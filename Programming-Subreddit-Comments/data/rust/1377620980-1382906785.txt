In my opinion, the biggest limitation isn't that it doesn't support GADTs but that it doesn't support higher order kinds. For example, with higher order kinds one could have GADTs be a library by with something along the lines of: pub struct Id&lt;S, T&gt; { priv contents: () } impl &lt;T&gt; Id&lt;T, T&gt; { pub fn new() -&gt; Id&lt;T, T&gt; { Id { contents: () } } } impl &lt;S, T&gt; Id&lt;S, T&gt; { pub fn coerce&lt;F&gt;(&amp;self, x: F&lt;T&gt;) -&gt; F&lt;S&gt; { unsafe { cast::transmute(x) } } } Not having higher order kinds only allows one to do a weak, and kind of limited version of that.
I just fundamentally disagree with implementation inheritance. It's a busted metaphor. I wouldn't mind some sugar for delegation. E.g. if you really do want to reuse some implementation, then delegate those trait-methods to a member. If you could just provide a list of delegated methods (or even wholly delegated traits), for each member, that would be great. I think structs should be the thing that actually bundles traits together into a real value. You don't extend them (that's traits' job!), you make another struct that potentially implements the same traits with different properties (and perhaps has the first struct as a member in order to reuse its implementation - but *only* through the public interface!). Implementation inheritance is the source of way too many horrible bugs and just makes code generally harder to read/use. Keeping the "interface" concept in the traits feature, instead of making structs sort of "pseudo-traits" by also allowing them to act as interfaces as well, is the wrong approach IMO, since it conflates concepts while not really buying you much (and has several decades of experience telling us what kind of mess it leads to).
&gt; How can constructors not do this? What if you need to construct the struct first, and fill it with data later when that data is actually available? You can't just block on a network request and expect the user to just sit there and wait. Worse, what if you have to decide based on the results of the request what the fields of the struct are in the first place? For example we might get a link to an image or a video object. You might have to call render(), but render decides whether you have a video or image and does different things based upon this information. Constructors solve a very small and narrowly defined subset of problems like this and unless you can generalize the concept of constructors to something more useful, it's not worth having standard constructors. In Smalltalk, for example, a Class object has a new method generated by the compiler. But there is nothing stopping you from overriding that method and telling it to act as a factory and return a different kind of object.
I put a link to this on the [wiki](https://github.com/mozilla/rust/wiki/Docs)
Thanks for the article! Lifetimes has been one of the more mysterious aspects of Rust for me, but this helped to clear things up quite a bit. &gt; Note this is going to change soon. 'self is considered to be a bug. You will be able to name your name your lifetimes in structs as you like. Does this mean 'self will eventually be implied by default? Also, I know 'static is a special lifetime too. Are there others as well?
'static and 'self are the only special lifetimes.
Yeah maybe I wasn't too clear. I meant that you can name your lifetimes in structs like 's or 'r instead of 'self. 'static is just a pointer to static memory. I don't think that there are more 'edge' cases.
I wonder, can a &amp; field have any other lifetime than 'self in a struct ? If it can't (and won't in future releases) then why do we need to specify it ? edit : in a struct
Ah, so you can name it whatever you want, but it will still just be an alias for 'self, i.e. tied to the lifetime of self? Is there any reason why 'self can't be implied by default for borrowed pointers on structs?
That was very illuminating! Thanks a lot. One small suggestion, that's really a general suggestion for everything Rust (articles, code examples): Please always include which version your content pertains to.
No, the 'self lifetime as it stands today is a complete misnomer in relation to structs. It has zero connection to the lifetime of the struct value itself, other than that the struct's lifetime has to be a (non-strict) subset of 'self. As such, it can't be implied, since it's actually a parameter that has to be separately supplied when you use the struct type. In the future, this will be better reflected by allowing you to name it anything you want, and allowing you to have a struct with multiple lifetime parameters.
Sharp blog theme, good style for the post and informative from the Rust perspective. Awesome-sauce! edit: I do hope there's a cleaned up version once the 'self stuff for structs is sorted out.
Is there an explanation of static lifetimes anywhere?
This is cool and all but..why teach a class using a language that is in such a volatile state? They could write code in the first week that won't even compile anymore at the end of the course. 
As a student I wouldn't be happy about a class using a language as new as Rust. Breaking updates should hit during the semester (0.8) and examples and tutorials aren't plentiful. I'd love to hear how the class went after the semester ends, though.
It's using the 0.7 release, apparently, so while they won't have to worry about volatility, that certainly brings its own assortment of issues to overcome.
While there aren't too many examples and tutorials, there's always IRC! #rust is incredibly helpful.
Yeah but it's an operating systems class, not a language class. Using rust seems too distracting from the course's purpose IMO. 
To add to the questions, in what contexts would a lifetime other than a 'self be appropriate or useful? When and how would that lifetime terminate, if not through the termination of the lifetime of the struct? How would an &gt; fn get_ref_name&lt;'r&gt; (&amp;'r self) -&gt; &amp;'r ~str{ &gt; &amp;self.name &gt; } be useful for a struct that has already been invalidated? I feel like this blog post answered a bunch of questions but introduced enough to replace them. Forgive me if this is all trivial, but I've never manually managed memory so I don't know what pitfalls this is helping me to avoid. Is this in one of the tutorials somewhere? 
That is a pity... Everyone wants a seminearring eventually: http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/ As I understand the rust docs, Eq isn't actually mandated for classes implementing other number like traits? That's a relief, as least...
Yes, here: `'static` refers to things that definitely last for the whole lifetime of the process, and so never ever get freed (i.e. can never be invalidated), for example, any compile-time constants declared with `static foo: type = value;`.
I wouldn't mind. Rust seems to be an interesting language that can do a lot of different things. Of course it's still evolving but I had to write projects in Python when it was still in its infancy (it was rather stable but not widely used yet).
The main issue I see is that getting help on 0.7 toward the end of the semester might be more difficult as the community is moving forward at great pace.
That's a horrible reason to choose a school, but UVA is a good choice regardless.
#1 sounds pretty funny coming from Perl, where `Foo::Bar-&gt;new()` (and the older more horrifying syntax, `new Foo::Bar()`) is so ubiquitous that a lot of green Perl devs don't realize that `new` isn't a keyword or special in any way.
It's one of those "interesting" points. U of Virginia has a pretty solid cs program, or so I've read anyway. Besides the top 5 such as mit, caltech, standford, uc berk and car melon, every other high tier schools in the top 20 are most likely to be just as good/bad.
It's generally thought of as a top 4, but rankings only get you so far regardless.
You can have multiple lifetime arguments and they don't need to be tied to `self`. They can also be used in free functions. It is also better to standardize the grammar than to have special cases.
A silly example: fn greeting() -&gt; &amp;'static str { "hi" } Here, a new string won't be allocated every time `greeting` is called.
I have this strong feeling that Rust is **the** next-gen language for game programming. So I intend to maintain and improve this physics engine (and its dependencies) for a long, long, time. At the moment it lacks a lot of features to make it useful for real-life games, and is 3x slower than e.g. Bullet. But at least the coarse design is mostly in place, so that people interested in contributing could do so meaningfully!
A lot of the commentary here seems to center around "rust is too new to expose students to, too many breaking updates, etc." When I read the title, I was impressed by the idea -- there's a lot of formal, valuable, and applicable programming philosophy to be learned from a language like rust, regardless of how transient it is. The idea of a class like this, I would hope, would be to teach theory rather than syntax. If that's the case, it would be fantastic, and rust would be a great tool for it.
All of your projects are really awesome!
you forgot to name the lifetime of source. source: &amp;'self Source&lt;'self&gt; 
 std::int::from_str("2");
You can use the `from_str` static method from the `FromStr` trait: FromStr::from_str::&lt;int&gt;(args[i]) (The `::&lt;int&gt;` is only necessary if there is nothing from which it can infer that the type would be `int`.) There is also `std::int::from_str`; assuming `use std::int` that would then be: int::from_str(args[i]) In this particular case, the two are exactly equivalent. You can see how they are defined in `src/libstd/num/int_macros.rs` from the rust repository.
when using std::int::from_str(), I received the following error: mismatched types: expected `&lt;VI1&gt;` but found `std::option::Option&lt;int&gt;` (expected integral variable but found enum std::option::Option) 
`int::from_str` and `FromStr::from_str` both return `Option&lt;int&gt;`, because the parse might fail. You can unwrap it with `.unwrap()` (which just calls `fail!()`) or `.expect("argument should be an integer")` which also calls `fail!()`, but includes the error message too.
Is Rust going to default to using the `for arg in args.iter()` variant in later versions? `for args.iter().advance |arg| { ... }` seems very verbose. Also, when using iterations I receive `expected &amp;str but found &amp;~str`, how am I supposed to handle this?
The `for f |x| { things }` syntax doesn't even parse any more. You'll need to dereference `arg` as I did; this gives a `~str` that will coerce to a `&amp;str` automatically.
Woah woah woah woah. Wait a second there, buddy. How can I not have heard of you already? You've created: 1. an n-dimensional algebra library in pure Rust 2. an n-dimensional collision detection library in pure Rust 3. a 3D graphics engine in pure Rust 4. and now a rigid body physics engine in pure Rust ??? All I can say is: Yer a wizard, sebcrozet.
This is amazing.
Originally, 'r didn't need to be declared, just used. However, you need to declare the lifetime when it comes to structs, and there the lifetime behaves similarly to a type parameter. By making lifetimes work like this everywhere, it makes it easier to reason about how to use them syntactically, and makes it clear what the intent is when using them (did they intend to use different lifetimes there, or was it a typo, for example). Of course, it seems unlikely you'd ever explicitly pass a lifetime parameter to a function, but type parameters on functions are usually inferred as well anyways.
What does the compiler error mean? If it had said expecied `int` but found `Option&lt;int&gt;` it would make sense. Where did `&lt;VI1&gt;` come from?
Ah I missed that the `int_from_string` declaration used type inference. Thanks.
&gt; 'a is always a subset of 'b. Unfortunately, I'm not sure the compiler "knows" this, e.g. I don't think the following works: fn f&lt;'a, 'b&gt;(t: &amp;'a T&lt;'b&gt;) -&gt; &amp;'a U
^[[**✔**](https://blockchain.info/tx/20deb2bba3795c546f7e334e81609307891d1fe519d359c8f25d8dd1b4099b36)] ^(**Verified**: Rainfly_X ---&gt; m&amp;#3647; 81.28099 mBTC [&amp;#36;10 USD] ---&gt;) ^sebcrozet ^[[**help**](http://www.reddit.com/r/bitcointip/comments/13iykn/bitcointip_documentation/)] 
What just happened?
I just gave someone money, using the awesome combination of reddit and Bitcoin, with /u/bitcointip acting as the glue between the two. See /r/bitcointip for more information.
This is the first time I get a donation for one of my projects. That's encouraging. Thanks a lot! I’m glad to see I can help motivate people to try this amazing language.
In general, it is also good to mention which rust version you are using, as things quickly change. In particular, I got the feeling that this code is part of [cs4414](http://www.cs.virginia.edu/~evans/cs4414-fall2013/pages/ps1.html), which mandates 0.7.
By the sound of monsters, I'm assuming you're trying to make a game? I'm currently designing a framework for (my) future games in Rust which handles all the boilerplate underneath, and all the development is done by implementing interfaces and pointing the framework toward them. This is, IMHO, the best way to multithread a game. The framework prevents races by keeping two copies of all state data. One is a copy of the past frame's data, and the other is a mutable object that is written to. The engine starts a frame by entering "pre-update", where it allows everything to read from anywhere it wants in the past frame's data (using a single ARC wrapped around that immutable state data). Updates aren't done in a tradition sense, but by object (and it's best to keep as few "tiny" objects as you can, so you don't have thousands of tasks doing menial things, but maybe hundreds doing pretty substantial things). As calculations are done, the changes are sent to a change queue, which is monitored by the main thread. These changes *cannot* change anything but the object's own data. This way, there's only one change per object. When a change comes in, it's ID is looked up on a whitelist of "dependent" updates. If dependencies exist, the dependent updates are launched, and are given an ARC to access the new data. Multiple dependency updates are solved similarly, but a bit more complex. When all mandatory updates are finished (Non-mandatory, super-heavy tasks [AI pathfinding for instance] are handled by another task manager and the main thread reads off the changes at the end of each update, before copying the batch to the immutable zone), a "batch" is complete, replaces the immutable data, then sends everything to rendering. This: * Prevents deadlocks everywhere but the change queue (implemented as a shared pipeline). And the change queue is fine to deadlock since it's only accessed when things finish up, which doesn't happen all at once - and means there is some time to spare anyway. * Prevents crazy data copies like your n^2 case. Now it's just 2n. * Is pretty "simple" compared to most alternatives. But it has some downfalls: * Oh God, by all means it's still not *simple*. * Cyclic + Recursive dependencies literally **stop the world**! Woot! * There's a lot of code that might have to be repeated, that could have been saved and moved around in a linear system. Although some of this could be solved through flags and a one frame delay. Just saying, starting from the ground up and rethinking how the entire structure of the system would work has helped me quite some bit. Google did too of course, look up Intel's SMOKE and some talks by John Carmack on multithreaded engines (can't find anything right now, short on time). If you aren't doing a game -&gt; I'm sorry, I'll go away. But I do think you're handling this wrong. If you need to do what you want, either use the rust idiom (locks || pipes) or go unsafe. And the latter is hardly worth it, when the rust idioms can be implemented just as fast or even faster just by changing the design and mindset of the project.
That's actually pretty fucking amazing :D Other then simply getting tipped, how do you get bitcoins?
Same way you obtain any other currency. For example, if you wanted to get some euros, then you'd either want to get *paid* in euros, or trade your dollars for euros at a currency exchange. Bitcoin works the same way. While Bitcoin-savvy employers are rare, you can trade Bitcoins for dollars at any of the competing exchanges. I personally use Coinbase, with scheduled purchases, so that I buy 1BTC every Monday with dollar money from my bank account, automatically. I also have a scheduled payment to keep my bitcointip wallet topped up. It's *really nice.*
What do you do with all the bitcoins (other then give it away to people)?
Cool.. how quickly do they become valuble? Also, can I have some so I can start off this bitcoin stuff? :P
I just solved my problem. Now I am using 2n instead of n². I really like my way of doing it but I just realized (thanks to your post) that my approach is not feasible for a game. I thought I just create a task for everything and collect the results every frame. But I now realized that it would completely break the gameplay if one task would be paused then one monster would just stop in the game, which is not what I want. Thanks
No problem, just glad I could help out! Good luck, and feel free to shoot me a message if you ever need any more help. Yeah, parallelizing a game is enough to actually scare John Carmack... It's not easy stuff. Takes a lot of thought and a good framework. Which is the purpose of my Nornir framework (well at least be a research bed)!
+/u/bitcointip 1 coffee verify The price of bitcoin is still very volatile right now. It goes up and down all the time - there's a lot of room for arbitrage, if you're into that sort of thing. Click the "6m" for the main graph to see the price over 6 months: http://bitcoinity.org/markets As you can see, the value generally grows over time, but with all sorts of spikes and plateaus that make it hard to say specifically how fast they will become more valuable. There are even people who think the value will eventually drop to zero, but these are mostly people who think Bitcoin is somehow a scam (that is to say, the underinformed). Bitcoin can be a decent investment as a commodity, but its real value is ultimately based on people actually using it as a currency. The big price surges happen when a whole bunch of new fish jump in to invest, with no intention of actually spending their coinage. You get a bunch of inflated value on top of the real value, and boy howdy, is there ever blood in the water when those bubbles pop. So I generally caution people against thinking of Bitcoin like 90's-era Beanie Babies. That kind of thinking just contributes to the volatile value layer on top, not the stable value layer underneath (where Bitcoin is actually used as a proper medium of exchange).
^[[**✔**](https://blockchain.info/tx/6205e6d0b9eea71c65da30d1ac401f500bd5764c2d6faf94091bd2fa7f5bb50d)] ^(**Verified**: Rainfly_X ---&gt; m&amp;#3647; 11.30071 mBTC [&amp;#36;1.38 USD] ---&gt;) ^tinythrowawai ^[[**help**](http://www.reddit.com/r/bitcointip/comments/13iykn/bitcointip_documentation/)] 
Happy to help! This sort of stuff is worth it and then some.
Thanks for the coffee :D What's arbitrage?
Have you already published your ongoing work?
Well, arbitrage isn't specific to stocks, and it doesn't cover the general case of just buying and selling things. My orange example didn't involve stocks, but it was arbitrage. Buying a stock at the London exchange, and then selling it later at the same exchange, is not arbitrage. It's only arbitrage when you're taking advantage of a price difference between two *places*, not *times.* Likewise, there are no real Bitcoin "stocks" that I'm aware of. You're buying and selling actual Bitcoins. The value of a Bitcoin goes up and down like a stock, though - but that's the same as any currency. The yen goes up and down compared to the dollar all the time, just in tiny amounts that you'd barely notice. Bitcoin is still young and volatile, so the price fluctuations are pretty noticeable. Don't worry about the lost money, it's no biggie. It was yours to play with. And you're right, it wasn't really enough to be useful for investing/arbitrage. Those things (when successful) multiply your money, like interest, which is awesome when you have a lot of money, but doesn't do much for small investments. Try to arbitrage with less than $10, and you'll probably lose more money to exchange fees than you make eating the spread. If you want something more practical to do with a small amount of cryptomoney, [buy a book or something!](http://www.bitcoinin.com/) I got a softcover copy of Ready Player One from this site, it was a great read and I highly recommend it.
Somebody told me he went from 3 bitcoins to 12 in a few months using stocks... is that possible? I can buy a book with regular money :P I just mistakenly thought bitcoins was some easy way to extra cash. 
ASICMiner has stocks that are valued in Bitcoin. I guess you call those "bitcoin stocks," but only in the same sense that GOOGL is a USD stock. If your friend got rich on a bitcoin stocks, it was probably ASICMiner. What's the fun in buying a book with regular money? Bitcoins have a lot of opportunities to make money. Or lose it. Or use it. But it's not a magic get-rich-quick scheme. If you hold onto it expecting it to increase in value, that will probably work as a get rich slow scheme over the really long term, but the big days of insane growth are mostly done now. Anything more than that requires you to actually be clever with something like arbitrage or single-exchange day trading. **EDIT:** Or scrypt mining for a less popular crypocurrency, for example using middlecoin.com.
How much can I get mining a less popular crypocurrency?
Ah, it seems it does work. (I guess I should test things before saying them.)
Depends on so, so many random factors. Middlecoin has payed out 89BTC so far if I remember correctly (on my phone right now), which is over $9000, but that's split among a bunch of people proportional to their hashing capacity. I recommend looking over the table on the Middlecoin homepage to get a better idea how they pay out. Keep in mind that MC is sorta best-case, since they recalculate which altcoin is the most profitable (and switch accordingly) on a regularly scheduled basis. Despite the name, Middlecoin is not an altcoin, but a really clever hash pool. There's also some good mining calculators online if you google for them. Again, I'm on my phone, so it's not so convenient for me to do it for you, but it should help you get an idea how much hash power you can contribute, and both the power cost and revenue. No matter what coin you go with (or in MC's case, none in particular), pools are almost always preferable to solo, due to their even/reliable payout.
&gt; More to the actual topic: I don't like the implicit nature of the path hack. Why not just add a new environment variable (RUST_INSTALL_PATH?) to address this case explicitly? Uhh, colon/semicolon separated environment variables, don't play too well with Sublime Text Editor on Windows 7 :( (Plus environment variables on Windows are blargh). But I've got no suggestion/idea how to bypass it. 
Most of your method signatures take @-ptr arguments, you may want to use &amp; or &amp;mut ptrs instead. Then, you would be able to overload &gt;&gt; with something like : impl&lt;A,B&gt; Shr&lt;Parser&lt;B&gt;, Parser&lt;(A, B)&gt; for Parser&lt;A&gt; { fn shl(&amp;self, other: &amp;Parser&lt;B&gt;) -&gt; Parser&lt;(A, B)&gt; { return self.then(other); } } edit : Shl -&gt; Shr
Nice! I just converted most @ to &amp; moments before your comment. Just implemented `Shr` using your code - https://gist.github.com/17166eea5509ce62d61f :)
`do 10000000.times` in your code kinda looks like a benchmark. Have a look at Rust’s unit testing stuff, it also includes a nice way to do benchmarks: https://github.com/mozilla/rust/wiki/Doc-unit-testing https://github.com/mozilla/rust/wiki/Doc-unit-testing#benchmarking
Yes, I was trying to do a crude benchmark. Just switched to using `#[bench]`, thanks.
I appreciate the interesting and friendly exchange, but this is really not on topic! Please continue this conversation in private messages.
If the compiler knows it should be a number, then it'd be clearer if it said "expected `&lt;numeric type&gt;` but found...". I'm pretty sure I saw a bug filed for better error messages though...
Will do! Sorry for the distraction.
The compiler does indeed know it's numeric, as evidenced by the `I` in `&lt;VI1&gt;`. It might very well be a simple change.
By the way, I registered this feature request/idea/issue just recently, about infix function call syntax. Basically it's my suggestion for something that's better than operator overloading and better than arbitrary operators -- just infix function calls. https://github.com/mozilla/rust/issues/8824 I know it's very late in the game, but.. well, if it will never happen then we just close the issue.
I think you can just use self.then instead of (*self).then.
Here is a non-trivial (but not-feature-complete) HTTP server written in rust using the new network IO api that kibwen mentions. https://github.com/chris-morgan/rust-http Also, here's someone doing what is described as a "quarter-assed websockets server" (notable because, despite the corners cut, websockets models something a lot closer to sockets). https://github.com/jfager/d3cap Hope that helps!
A prime example of why some people hate operating overloading :)
It is a sad world when a dictator can just abdicate out of the blue and a BDFL becomes a BDFCY :(. Seriously though, I wish him all the best in future endeavors (from the tone of the email it sounds like he will be leaving Rust completely). He kept the tone of the community polite and to the point, kept in mind the idea of complexity budget (every small new feature that you are asking for --- it has to be checked how it interacts with ALL of the features in the current set), and most importantly led the creation of a great new system programming language :). Also welcome to the new project head, brson! I hope you'll lead Rust to be the language for system programming, kicking C++ still bloating corpse out of the way.
Kudos for all the great work on both the project and the community.
Sad news. Graydon was a very good BDFL, from what I got to see.
I wrote a simple TCP server at http://stackoverflow.com/a/17689618/497043, which works against master. It only demonstrates writing, but reading is straightforward also—just look at the source to see what's there. I think my HTTP library (it's both server and client) is probably the most complicated work using the new runtime's TCP support. Look at it, even join in and contribute if you want to, but don't assume everything in there is best practice! There are a lot of quick hacks in place there and some temporary designs which are to be replaced.
rust-http has a client as well as a server, now. Still not complete, naturally.
That's not disagreeable. fn n(s1: &amp;str, s2: &amp;str) -&gt; ~str { format!("{}\n{}", s1, s2) } // ... print("foo" \n "bar" \n "baz") Which is pretty cute, I guess.
nooo that's not the point. You're tarnishing the syntax with this abuse!
Why not? Markdown? Too un-C-like?
Python had a long rationale on why they left out the backticks in Py 3, including markdown conflict and how it was impossible to read in printed Python books. Also I think core developers rejected backticks for something, but I can't find a link for that.
As much as this is a sad news for Rust, I admire Graydon for making the announcement himself and having the courage to move on. When things stop being fun, this may be the best decision, but it is rarely an easy one. Thanks for shaping up a serious contender for C and C++!
:P
I am the main author of glfw-rs. I'm usually on `irc.mozilla.org #rust`. If you need any help, let me know, but I need more information. Do you get any build errors? Do the examples run ok? What version of Rust are you using? (it needs to be git master) What OS? Are you using GLFW3 or GLFW 2.7? (it needs to be the former)
Hats off to Graydon for cultivating such a friendly, supportive community. That is no small feat. I have the utmost respect for him, and he has left Rust in a fantastic position heading into the future.
&gt; Some compile speedups landed. I know this was one of the things Graydon asked the team to focus on, because bors queue was clogged. Do you have any idea how much those changes by pcwalton actually did ?
It was a [significant (5 minutes) speed-up on the full test suite](http://huonw.github.io/isrustfastyet/buildbot/#578e68047736167239c52fa1aba0347011ff1bc3): it made compiling small crates much faster, so the test suite (which is mostly small crates) is greatly benefited. 
Oh, I definitely will be using that. :-)
hi, you might think this is neat. This is your code rewritten with a vector iterator instead.. since the iterator is copyable it's just as easy to "fork" as an index value. https://gist.github.com/anonymous/55d854691598607bf3c2
Hi, that's nice. But ... when you don't understand an error message - and maybe you're not alone - it's probably because the error message can be improved. Don't hesitate to file an issue on GitHub to give the developers feedback.
After dwelling on it I also like this. At least, I'm having a very hard time coming up with something nicer. The question is whether it's nice *enough*. Every little syntax candy like this increases the alienness of the language for someone used to mainstream C-like syntax. If I'm thinking right you would write a couple of nested monadic binds using this as: |a| a \chain |b| b \chain |c| a + b + c which doesn't compare badly to Haskell sans `do` notation: \a -&gt; a &gt;&gt;= \b -&gt; b &gt;&gt;= \c -&gt; a + b + c (or with a named operator: \a -&gt; a `chain` \b -&gt; b `chain` \c -&gt; a + b + c ) and is nicer than the existing Rust: |a| a.chain(|b| b.chain(|c| a + b + c)) (or using normal function syntax: |a| chain(a, |b| chain(b, |c| a + b + c)) ).
The snippet copies the iterator to reset a failed match, so the iterator must be cloned in this case.. so you idea is not that easy to implement for a socket iterator. I think the infinite lookahead afforded doesn't fit well with streams.
Ah, right.
I assume there are lot of pressures and technical difficulties when dealing with rust compiler, but compiler time has improved significantly from 0.6 (it used to be hours, now it's hour to hour tops).
I believe there are actually long-term plans to build something like this into the compiler, where every error message is accompanied by online documentation that goes into greater detail on how to resolve it. The problem at the moment is that our error messages are scattered all throughout the compiler, so there's no easy place to begin the process of cataloguing them.
I'd guess it's partly the eternal problem of people being managers when they'd rather just write some code. (I have no insight into the details though.)
&gt; Yet, since this is a LLVM feature, Clang can potentially do the same for C++ code. Other C++ compilers might be just as smart. So, in essence, the situation on the machine code level is the same for Rust and C++. Actually, the C++ Standard specifies that two different functions should have two different addresses; an unfortunately an instance of a template function is not the same as another instance of the same template function with different types/non-type parameters. Of course, this is submitted to the as-if rule so the optimization is legitimate *if* the compiler can prove that the user does not rely on the addresses... I believe there is a trick at assembly generation time: swap_int: nop swap_float: nop swap_bool: ; actual swap code here which gets both shared code (apart from some `nop`) *and* different addresses, however I do not know whether LLVM can generate such code.
The `mergefunc` pass will leave behind stubs unless the functions are marked with the `unnamed_addr` attribute. Although, it will end up just inlining all the stubs in most cases.
compiles for me with: pub fn create_entity&lt;'a&gt;(&amp;'a mut self) -&gt; ~Entity&lt;'a&gt; {
Thanks, that makes sense. I didn't know you could pass a lifetime as a param like that (to `Entity`).
In fact, if you omit a lifetime that's just sugar for an anonymous lifetime parameter: fn foo(&amp;A); is the same as fn foo&lt;'anon&gt;(&amp;'anon A);
Note that the borrowed pointer "&amp;'self EntityManager" within Entity forces your EntityManager to become immutable, so in the long run this design may lead to trouble. As far as I understand you have three options 1. Keep your design, and live with the fact that your EntityManager is immutable. 2. Change the design, so the manager contains a collection of entities, whereas the entities do not contain pointers to the manager. 3. Something with @mut ?? (I don't know the details here) EDIT: I am not a master of rust, and I hope to be corrected if I am wrong. EDIT2: See here for a similar discussion: http://stackoverflow.com/questions/18140088/borrow-issue-with-self
Here's the issue: https://github.com/mozilla/rust/issues/2092
My preemptive condolences. :) I still have a bad taste for Racket after being forced to use it in college, but at least the language was consistent, the compiler was reliable, and documentation was plentiful... properties that Rust 0.7 does not have. I can only imagine that your entire class will soon be soured on the whole language. In order to avert this terrible fate, please see the links for the mailing list and IRC channel in the sidebar here. The community is literally the only help you'll get, so make copious use of it!
You can keep them if you use @mut, which also gets rid of the lifetimes, because @mut is garbage collected.
This is really interesting, and I'm in the planning phase of my game engine. I keep coming back to this post because it's similar to the conclusion I'm naturally arriving at. It almost seems like this is a technique of doing asynchronous OOP. Instead of a message being immediately handled, it is handled at a later time. This gives you opportunities to intercept messages, modify them, cancel them, etc, but at the cost of more complexity as you noted. Have you considered using closures instead of message objects? For example, you push a closure onto the queue which does the interaction with the data, instead of a message object which ultimately gets executed.
That error message is rather confusing. But nothing that can't be fixed in the future.
Been working on this for a while now, but owing to some [recent updates by Lars Bergstrom](https://github.com/bjz/glfw-rs/pull/32) I'm finally happy enough to start publicising it more. I still need to move all the enums to Rust-style enums, but I'm pretty happy with it so far. It's currently used in Servo and q3!
I cracked the mystery, by the way. It was with glfw, not glfw-rs. Apperently it installs to a folder not on linux's default path. I added the folder mentioned in glfw's make install output to my path and all was well. Just a case of way too many errors to know where to look for a solution. 
Oh good! Glad you got it working! I have recently updated it too, be sure you've pulled.
Have any good tutorials for using it?
Hm. Forks of Rust account for 583 already.
Forks are disregarded in his query.
Ah, thanks. Not sure about the implications though.
This plugs a soundness hole in Rust's string/character handling. It's no longer possible to construct invalid characters (that is, characters that don't represent valid codepoints, e.g. larger than 0x10FFFF) just by casting an integer e.g. `(-1) as char`. The new way to convert integer &amp;rarr; char is via `std::char::from_u32` which returns an `Option&lt;char&gt;`, or by casting a `u8` to `char` directly, since 0 &amp;ndash; 255 are all valid utf8 codepoints. This opens the door for optimisations like reusing the high 11 bits of `char` (a unicode codepoint only requires 21 of the u32 it's stored in) as the discriminant in `Option&lt;char&gt;`, so that `sizeof(Option&lt;char&gt;) == sizeof(char)` ([#5977](https://github.com/mozilla/rust/issues/5977)). (The pull request also stops things like `('a' * 'b' + 'ĉ') / 'd' &lt;&lt; '\n'` being valid.)
Use case is similar to the code I pointed to -- to implement an interpreter/runtime for a dynamic language like Lua/Ruby/etc. Right now, Rust seems to be adding 8 bytes to store the enum info per struct on my machine: use std::sys::size_of; macro_rules! print_size( ($t:ty) =&gt; ( printfln!(std::sys::size_of::&lt;$t&gt;()) ) ) enum Object { Integer(int), String(~str) } enum SmallObject { U8(u8), U8U8(u8, u8) } fn main() { print_size!(u8); print_size!(int); print_size!(~str); print_size!(Object); print_size!(SmallObject); } Prints 1u 8u 8u 16u 16u
&gt; enums will use the same memory layout, just with an added discriminator word at the beginning. This is incorrect. The layout is undefined ([see my comment](http://www.reddit.com/r/rust/comments/1lpmrx/storing_structsenums_of_structs_more_compactly_in/cc1jbku)).
Wow, awesome job! I hadn't realized rust-http was so far along -- I'll have to use it in some of my projects now.
Ah, ok. I read the below: &gt; Updates aren't done in a tradition sense, but by object and assumed you meant message objects. Why do you have 2 copies of the data though? If updates are in a queue, then can't you just do the following? 1. Pass in immutable references to data to all your game systems. 2. They generate the changeset and add it to the change queue. 3. Grab mutable references to the data. Run through the change queue and apply all the change to all your game objects. 4. Grab an immutable reference to your game objects and pass them to the renderer. 
Yay :-) If anyone wants to help out with rust-http, take a look and see if you can find anything to do, or ask. Quite a lot of it is still fairly unpleasantly implemented and needs correcting. More header types need to be implemented. Lots of tests need to be written (and never fear—they'll find bugs!).
&gt; or by casting a u8 to char directly, since 0 – 255 are all valid utf8 codepoints. As a `char` is a UTF-32 value (at least, that's what #5977 claims), all `u16` values can be casted to a `char`, surely? 0 - 255 are not all valid UTF-8 codepoints, only 0 - 127 are.
Ah yeah, I see where you could have gotten that. &gt; Why do you have 2 copies of the data though? Data races &amp; Performance, my dear Watson! You see, if I were to do what you suggest, I would run into a few problems. * I would have to wait for ALL objects to finish their pre-update reads... But wait, aren't there dependant objects? That means I have to wait for *all* updates to complete before writing my changes down. * I also have a heavy-task thread in the back of this main system that handles really heavy shit like loading and AI pathfinding. This way those don't block and can run concurrently when the main work isn't being done in a pre-update/update block. They read off of the immutable copy, so I'd have to make it a lot more complex (and performance unfriendly) for them to prevent data races. TBH, I'd rather spend ~2 times the data than sacrifice simplicity or performance. I would like to point out that most games don't have 2Gb worth of actual game logic data in them, the actual data pertaining to game logic is more in the order of a few (dozen for big ones) Mb. So we're talking a tradeoff of megabytes.
&gt; As a char is a UTF-32 value (at least, that's what #5977 claims), all u16 values can be casted to a char, surely? No, there's surrogate codepoints (D800-DFFF, which lie in the u16 range) [which are specific to UTF-16](http://en.wikipedia.org/wiki/UTF-8#Invalid_code_points). &gt; 0 - 255 are not all valid UTF-8 codepoints, only 0 - 127 are. 128 - 255 aren't valid (isolated) *bytes* in utf8, but they are valid codepoints (they get encoded as 2 bytes), e.g. `å` is codepoint 226, and is encoded as 195 165 (c3 a5 in hex). fn main() { let c = 'å'; // or `226u8 as char`, or `std::char::from_u32(226).unwrap()` let mut buf = [0, .. 4]; let len = c.encode_utf8(buf); printfln!(buf.slice_to(len)); }
That's true, memory layout of enums may change in the future. 
I think a solution like this would be best. Note that alignment restrictions would have to be taken into account.
So in fact, `char` will represent a codepoint in Rust, and not a grapheme ? (ie, it does not take into account the diacritics potentially attached) I believe that most (if not all) used combinations of main character + diacritics also have a representation in a single codepoint; in which case `char` could represent any regularly used glyph... would you know if this is the case ?
Actually, I fear you forgot worlds about everywhere in the article too: &gt; For some reason I though that porting simplify-js to simplify-rs. I guess `thought` was meant instead of `though`... but the subsequent part of the sentence is still missing a verb. Did you thought it *would be easy* ?
Now featuring a proof read 
&gt; you use the impl keyword to add methods to a type, and the extra @self argument (just like python but with a confusing ampersand) for defining methods Just like to note that you don't actually need a sigil in front of `self`, if you're fine with passing by-value instead of by-reference. For example, this: fn sum(&amp;self) -&gt; float { self.x + self.y } ...can be rewritten as: fn sum(self) -&gt; float { self.x + self.y } The difference between `self` and `&amp;self` can potentially have important semantic and performance-related implications, but the `Point` struct is so simple (and the methods so trivial) that the difference is largely irrelevant here.
I'm kind of curious about [this recent commit](https://github.com/bjz/glfw-rs/commit/21ceffb59d72be7ea31d51065d1bea0bf3f1c14c). Does this mean we can use closures for callback fns now?
Ah, I see what you're saying - I assumed you were talking about converting the raw byte to a char by just zero-extending (and my use of terminology was just plain wrong, sorry, and I didn't know about the surrogate codepoints).
I like JS. I like Python. And yet both the words "Javascripter" and "Pythonista" grate on me, and that much more so when they synergize together. But other than that, and some equally pedant-grinding grammar glitches, this was a good intro.
I'd be interested to see a comparison (and you might need to do more than 70,000 iterations... try a billion or so), but intuitively I think the difference will be negligible. Here's why: the by-reference version will pass a pointer into the `add` function. Assuming that you're on 64-bit hardware, that's 64 bits of data. The by-value version will copy the entire struct, but that's just two `float`s, and right now I believe that `float` is just a synonym for `f64`... so that's 128 bits of data. In absolute terms this amount of data is basically negligible, so the copy probably won't be a bottleneck. If you were really worried about it, you could change the definition of `Point` to use `f32` instead of `float` and the total size of the data structure would be equal to a pointer. But also! The by-reference version might require more expensive pointer indirections to get at the struct fields than the by-value version, depending on the characteristics of your code and of your system's cache. This is initially why I was predicting that it would be a wash. Please note that I'm really bad at systems programming (fellow Javascripter/Pythonista here!), so I might be completely wrong about everything! Try it for yourself and find out. :) EDIT: oh, and when you want to run benchmarks, make sure to compile the code with optimizations! rustc --opt-level=3 foo.rs
I agree with you on JavaScripter especially, the working title was a pretty blatant rip off of rust for rubyists. I think I'll be sticking with adventures with 'adventures with rust' for subsequent parts
thanks, I'll try that
If they're a Unicode codepoint then yes, `char` can represent the precomposed character of both letter and diacritics, since it represents the full Unicode codepoint range. (Note that there's literally an infinite number of graphemes: one can place any number of diacritics on a character (including repeats), so it's not possible to have a fixed width encoding of graphemes.)
(I'd guess that LLVM inlines the method call in both instances and removes the indirection anyway, if optimisations are turned on. One can check these things by running `rustc -O --emit-llvm -S foo.rs` to output the LLVM IR, or just `-O -S` for normal assembly.)
I really like where rust is going, it really brings a kind of Haskell feel for some stuff like the traits to more people.
its about 7000 ns faster using call by value
Interesting, thanks. But IMO, any difference of such a minuscule quantity isn't worth sweating over. *Always* write the code in whatever way makes the most sense to you, and then optimize if you actually need to.
Wow, this is great news that someone is working on a COM library. We expect to need such a thing for Servo down the line.
--opt-level=3
true story
What's *is* the standard format for scyrpt or PBKDF2 then?
Bcrypt isn't significantly better than pbkdf2, while not being a standard. Scrypt is however significantly better than both, which makes its non-standardness more palatable. It basically leaves bcrypt as the least desirable of the three.
PBKDF2 has unfortunately never really had a good one; maybe the java implementation format would be the most popular. One of the biggest downsides of the spec. You can apply a standard unix $-separated, crypt format to scrypt, which is getting to be a defacto standard (similar to bcrypt, for which this is the standard, and is one of the advantages of using it currently) but the author for some reason chose base64 encoding with a custom magic value as well. 
Except for the fact that bcrypt has a standard unix crypt output which different implementations from different languages will produce (if it's a half-decent library), which can in some cases make it much more desirable than the other two. You can read in one bcrypt hash string - using any library - and compare it to a password, and expect to be able to find a match without to many troubles. Same can't be said for most implementations of the other two, not with the same ease of use.
But it **is** using the common $ separeted modular crypt format! Of course it has custom magic because there is no standard magics/formats for PBKDF2 or scrypt. And base64 just makes sense, even bcrypt which you seem to like so much uses base64 encoding.
It isn't pretty for the most part, but I've managed to get a clean-ish way to wrap up COM interfaces. I'm not really happy with the amount of code that goes into the process. I'm wanting to work on a macro to help with generating the interfaces and build an IDL/TLB code generator to make generating interfaces a bit easier. I haven't even started in on producing COM interfaces, just consuming them in Rust. I'll definitely keep everyone in on the loop as I get more meaningful progress on the project.
I know, this is an issue for example on all software written against UTF-16 using `wchar_t` which break in mysterious ways when starting to process Japanese or Korean because (if I remember correctly). I would guess that if all *current* languages can be encoded with a single `char` per grapheme then only people dealing with specialized languages (historical, Klingon, elfe, ...) would have to worry about it which might be an acceptable compromise. If not... I am afraid software in Rust will break because it'll be so uncommon that nobody will think about it :(
Thanks !
(Why was I still expecting a serious explanation when I saw it was botbot?) (also, probably because #rust is always so useful and awesome [and funny apparently])
&gt; grapheme cluster wow. now that is a great name.
Oh wow, that's great to hear! How is the Rust-on-windows experience going? We need better support if rust is going to start drawing more serious interest from the gamdev crowd.
You could always do it using closures: https://github.com/bjz/glfw-rs/blob/master/src/examples/cursor/main.rs#L24 That commit is just internal work. Window::get_fns is a private method that returns the callbacks stored in user data pointer that glfw supplies.
Well, I've been having some issues with linking against different parts of kernel32, which has forced me to resort to writing a thin wrapper in C, compiling with GCC, and then linking against that with Rust to get things to work. Overall, the windows experience isn't bad. A little more involved than I'd like to get off the ground with things, but I'm sure that'll improve in time as the language stabilizes and more focus can be put on the user experience of using rust on the different platforms.
Yeah. I hear from strcat that there are some issues with Rust's segmented stacks and calling Windows APIs. Dunno if you encountered that. Btw, just (cause I'm curious) why was I "the reason"? Surely D3D is orthogonal to the GL stuff? :) 
Certainly is orthogonal, but it's more like you're already doing such a great job with OpenGL, someone should step up and do the same for DirectX. I see it as giving any potential, future game developers wanting to use rust several options for graphics APIs on Windows. The wrapper is going... incredibly slow, though. The COM bits aren't pretty and at times I wish there was built-in language support for COM to really alleviate the pain. Doing simple COM objects is fine, but once you get into complex inheritance hierarchies like what DirectX has, the amount of code written/generated starts to go from manageable to insane.
enums like `Option&lt;~T&gt;` already take advantage of that to be only one pointer big, not a pointer+discriminator.
I was surprised to find out how loosely coupled COM itself is to C++. I actually got it working by reading an article on how to create and call COM interfaces from C. http://www.codeproject.com/Articles/13601/COM-in-plain-C is the article had read. Essentially a COM object is a struct whose first field is a pointer to a table of function pointers that all have the stdcall calling convention. Each function pointer then takes a pointer to the struct as its first parameter. I'm mostly trying to work out some macros to streamline generating the structs and vtables and hiding them behind traits that follow the COM inheritance hierarchy.
&gt; let i : uint = 0; &gt; while i &lt; 5u { &gt; printf(fmt!("i is %?",i)); &gt; i += 1u; &gt; } It's a convenient example, but it's worth pointing out that the "correct" way to do counting loops is with `range` and `for`, since I see semi-regularly see non-didactic code using a manual `while` loop as above. That is, for i in range(0u, 5) { println!("i is {}", i); } Note that this uses the new formatting syntax and macros. (Also, `printf` used in the original code isn't a function in Rust's stdlib.)
Hopefully this may ease some of the various pain points we have on Windows!
(The `println` in the `while` example should be `println!` (with the exclamation mark): it's a macro. :) )
thanks fixed, is there a place that the default macros are documented besides [this monstrosity](https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L737-L1120)?
I actually read this last night and this was the first thing that popped into my head as a Windows developer that's taken a liking to rust. Would this also mean that rust could drop the mingw requirement and use the full llvm/clang toolchain to do windows builds?
Although I have no plans to pay for VS2013 I think this news is the start of a great romance story about a forbidden love between VS2014 and Rust.
It is, indeed, depending on normalization form. Hopefully we can hope that the default normalization form will enforce a single code point for those.
Thought this might be interesting to look at from the perspective of Rust's traits/type classes. (always good to see what the competition is doing)
Hi, I'm not sure if you've read the old version, but the module tutorial got a rewrite recently, might be worth to take a look: http://static.rust-lang.org/doc/tutorial.html#crates-and-the-module-system
The [original pull request](https://github.com/mozilla/rust/pull/7745). This makes macros [hygienic](http://en.wikipedia.org/wiki/Hygienic_macro) with respect to `let` variables. One consequence is a macro can access a `let` variable if and only if the variable is in scope when the macro is declared. i.e. macro_rules! illegal ( () =&gt; { i } ) fn illegal() { let i = 0; illegal!(); // error: unresolved name `i` } fn legal() { let i = 0; macro_rules! legal ( () =&gt; { i } } legal!(); // the `i` inside is the `i` from the let. } *e:* Now that I've compiled a rustc with this patch, I can feel confident in demonstrating another consequence: fn main() { let mut i = 0; macro_rules! hygiene ( ($x:ident) =&gt; { { let mut i = 100; $x += 1; } } ) hygiene! (i); // even the code is excited for hygienic macros printfln!(i); } Without the hygiene PR: `0`. With it: `1`. (i.e. the internal `let`s are a different "namespace" to the external ones, so the inner `i` doesn't override the `i` passed via `$x`.) 
IIRC, [7745](https://github.com/mozilla/rust/pull/7745) was actually opened late on his last friday; and that was 2 months ago, so it is *very* ended. (I'm possibly exaggerating the drama; it might've been the Thursday.)
I had not thought about the inner variable issue; I think your second example really highlights the different between "real" macros and "just" text replacement. It's really a great thing.
Best line: &gt;... Erlang would be like fuck this I’m crashing. 
One of the issues with getting things through a committee, unfortunately.
It is the only language that I know of to use crashing as a control floe mechanism 
Anyone know what "let var hygiene" means?
http://www.reddit.com/r/rust/comments/1lyr0r/let_var_hygiene_by_jbclements_pull_request_9026/
A month ago it was suggested that you can do something like the following struct Named&lt;T&gt; { first_name: ~str, last_name: ~str, t: T } struct Knight { castle: ~ str} let Bob: Named&lt;Knight&gt; = .... I haven't used this approach a lot, so I don't know if it can work as a general solution to inheritance in rust. It will probably not be elegant for multiple inheritance, but it may solve most problems.
You would need to stylize it though, the Gopher is fun because anybody can draw a fair approximation.
This is true. Renée French had a knack for drawing things that were simple (like [Glenda from Plan 9](http://plan9.bell-labs.com/plan9/img/plan9bunnywhite.jpg)) yet not bland "programmer art" (Sorry [Tux](http://upload.wikimedia.org/wikipedia/commons/a/af/Tux.png) and [Beastie](http://upload.wikimedia.org/wikipedia/en/5/55/Bsd_daemon.jpg), but you know it's true). I really can't think of any other creatures that match up with the word "rust" though, and it's not a common syllable in many words either. Hm.
Yes, it's kind of surprising how little WotC actually copyrights relating to D&amp;D. The Paizo stuff gets away with using basically every race and monster name from D&amp;D, they just refer to D&amp;D as "the world's oldest roleplaying game", so I think "D&amp;D" itself is the only copyright. Which makes sense when you consider that the Tolkien Estate sued the pants off TSR when D&amp;D came out (hence why D&amp;D only has 'halflings' and never 'hobbits'). But yeah, I do kind of see Rust as a more industrial evolution of lots of the PLT research that's been going on for the past few decades. It makes some great compromises between ideals and reality, so the name fits. Really I just thought it would be funny to distract people who rag on the syntax and sigils with a great mascot. "Yes, we get it, you think it's too noisy and you prefer to spell out 'function' every 10 lines. But does JavaScript have an awesome mascot? Now make a reflex save or watch that +2 Platemail disintegrate!" 
GTK as most of Gnome's projects uses GObject Introspection for bindings. Which is in motion here: https://github.com/mzabaluev/grust And yes, I was thinking of "port" as in make it exclusively in Rust. Since the goal is to use it in a practical matter.
I completely agree, but I don't feel like at any point did I convey a "let's do it" mentality. It is definitely something that's going to require a lot of thought, especially at this point in rust's development, before development would ever start, if the idea were to be accepted. I mostly brought up the idea of structural-typing, because it is a well know system in use by many languages, so it definitely wouldn't be trail blazing in that sense.
I hate the feeling of working with bindings. I hope in the future (far into the future?), rust will have a great GUI framework similar to QT. I see rust to be the programming language of the future, for desktop apps and advanced 3D games etc. But in the nearer future, after rust passes the 1.0 mark, I would like it to have at least something like Java's JavaFX.
I am staring at community rule #3 on the sidebar and fighting the urge to reply appropriately :P
Quick, I'll distract kibwen while you reply properly.
"MTV-3H Holodeck" is one of the badassest names for a conference room I can think of. If only it was bridge holodeck...
Hah! I'm `'static`; you can't deallocate me!
Are the slides of the air.m.o talks available somewhere? Just to be clear, I was looking for rust and servo related ones...
You'd probably have to ask the interns directly, likely via the mailing list.
Re https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-09-10#extern-mod-duplication, would it be worth having a "rustpkg.config" where you can define aliases: [deps] foo = http://github.com/bar/foo/ baz = http://github.com/qux/baz/ and then just use extern mod foo = "foo"; extern mod bar = "bar"; possibly even short cutting to just `extern mod foo; extern mod bar;`. (Presumably there's some prior art somewhere. Does anyone know of something that handles this particularly nicely?)
This seems sensible to me too. "All problems in computer science can be solved by another level of indirection."
Re syntax, how come #[path="path/to/file.rs"] mod foo; but extern mod foo = "http://url.url/url/url" ? (I know `mod` and `extern mod` are totally different, I'm just wondering why these are not both attributes, or both not.)
strncat is right that your choice of box type really just depends on the situation and use case, but writing a LL with owned pointers should definitely be doable. What problems did you encounter? **edit**: haha I just saw my flair. Was this because of the rust monster thread?
Woo, I'm in the quote db!
Thanks, going to look at it.
Well, usual rust-newcomers problems I guess, wrapping my mind around the rust pointers paradigm.
Ah, gotcha. I thought maybe you had some specific questions. Also if you have C++ experience it helps to understand Rust's box types if you think of these as being roughly equivalent (but much safer and more convenient in Rust): * ```~ = std::unique_ptr ``` with built in move semantics * ```@ = std::shared_ptr ``` with a cycle detector * ```Arc = std::shared_ptr``` without a cycle detector * ```&amp; = &amp;``` with the compiler making sure it's legal * ```* = *``` but requires an ```unsafe``` annotation 
Memory safety and mutability properties aside, Rust's `&amp;` is more like in between C++'s `&amp;` and `*`. Like `&amp;` it can only be constructed from an existing object (it can't be null), it doesn't allow pointer arithmetic, etc. But like `*` it's an independent object itself with its own assignment operator, and has to be explicitly dereferenced to retrieve the original. So it's more like this: template&lt;typename T&gt; struct Ref { Ref(T&amp; obj): m_obj(obj) { } T&amp; operator *() const { return *m_obj; } T* operator -&gt;() const { return m_obj; } private: T* m_obj; };
Yes, very good point. What I said was definitely an oversimplification (hence why I said *roughly* equivalent :P). I also like that in Rust you have to take the address of stack objects and temporaries explicitly when passing/assigning to a borrowed pointer. C++ is a little too implicit for me to follow that way sometimes. And while I appreciate the clearer semantics and performance improvements, r-value references have greatly complicated that subject. 
That aint no flair, mate! You have the honor of being hard-coded into the [stylesheet](http://www.redditstatic.com/subreddit-stylesheet/utcLtcr1_S2o5JxmFMNOCIEJqKk.css)!
&gt; Arc = std::shared_ptr without a cycle detector To be clear, this (and non-atomic `extra::rc::Rc`) statically guarantee that there are no cycles.
Oh wow, I didn't know that! Thank you for the correction. I'm kinda curious how you accomplished that without compiler support, I'll have read up on it.
Pretty disappointing that this went ignored. You should definitely try submitting it again. I always enjoy reading peoples' constructive criticisms here. Especially in the form of code reviews or things that wind up being commits so I can see patterns and idiomatic things I should follow. :( Man, I bummed that you wrote all this and didn't get any replies. I'll look but I'm a major noob and can't really do much other than watch and listen right now.
The `Rc` type has two constructors, with one requiring `Send` (`Rc` is not `Send`) and one requiring `Freeze` (can't make a cycle if you can't mutate it after construction). The `RcMut` type has the same constructors, and is simply neither `Send` *or* `Freeze` itself. Unlike `Rc`, an `Arc` *is* `Send` but it always requires `Freeze` for thread-safety.
*[Macros that Work](http://3e8.org/pub/pdf-t1/macros_that_work.pdf)* (1991) has an introductory explanation and a formal proof, in case of interest :).
Totally would need to be a manatee.
How does it feel to be so derivative?
:P Best dev community ever. Thank you!
I have a range of basic examples here, which you are welcome to use: http://www.darkcoding.net/software/rust-what-i-learnt-so-far/
This is because ecosystems tend to reinforce each other. A lot of the time, it's not as easy to call out to a library written in another language.
Does that mean I'm ineligible for copyrighting? Methinks rule #4 needs to be added: moderators may not have fun. :P *(Historical note for anyone left in the dark: ~kibwen at this point changed my unadorned `chris-morgan` to `#[deriving(chris-morgan)]`, which it stayed as for a few weeks before being changed to `GET /chris-morgan` because of my authorship of rust-http.)*
It's always felt a little odd talking about gamedev on the main channel. So we now have a separate one! ^Hopefully ^this ^post ^helps ^make ^brson [^a ^little ^happier](https://botbot.me/mozilla/rust/msg/6011473/)^. ^:3
Contributions to this would be most welcome! It would be great if we could link to some tutorials or blog posts.
From a user's point of view, software using SDL2 is *significantly* better. I really appreciate not having the screen resolution changed, or the application locking out window management keys. http://wiki.libsdl.org/MigrationGuide
Want to send some PR ? :D
It appears that the rust-sdl2 link actually links to rust-sdl which is 1.2 There is a link in the issue raised about sdl2 in the github issues pages that links to someone's effort at making a separate rust-sdl2, however I am unsure how far along or how well it works compared to rust-sdl.
It's currently fairly limited, but it's definitely working! If you decide to give it a try, the readme on github is your friend. If there's anything really unintuitive, please tell me. (Github issue, comment here, whatever!) And let me know if you see any really odd un-idiomatic code in there! For the curious: fsm.rs provides a basic state-machine if anyone needs something like that. I might see about putting it in its own lib somewhere if I get the time to make it more useful.
 #[path="commands/mod.rs"] pub mod commands; The [explicit path](https://github.com/singingboyo/evict/blob/master/src/evict.rs#L6) is no longer needed. Rust will look for `./commands/mod.rs` if `./commands.rs` does not exist. It would also be nice if you could [move to rustpkg](http://static.rust-lang.org/doc/rustpkg.html). Simply move the contents of `src` into `src/evict/`, and rename `evict.rs` to `main.rs`. Then you can do `rustpkg build evict` from the root directory of your project. Rust uses snake case for functions and four-space indents. You can condense a match like: let json = extra::json::from_str(strval); match json { Ok(jsonVal) =&gt; readIssuesFromJson(jsonVal), Err(_) =&gt; ~[] } to: match extra::json::from_str(strval) { Ok(val) =&gt; readIssuesFromJson(val), Err(_) =&gt; ~[] } Its a shame result doesn't have a `.get_or_default` method :( Matches that [have a `None` arm that does nothing](https://github.com/singingboyo/evict/blob/master/src/config.rs#L35) might be expressed more cleanly using `.map`: do self.author.map |val| { map.insert(AUTHOR_KEY.to_owned(), json::String(val.to_owned())); }; No need for [trivial `Eq` implementations](https://github.com/singingboyo/evict/blob/master/src/date_sort.rs#L28), just use `deriving`: #[deriving(Eq)] struct TimeSortedIssue&lt;'self&gt;(&amp;'self Issue);
A small, tiny nitpick: is there any chance you could change the method names to lower_case_underscore notation, in the spirit of keeping consistency with the (thus far unofficial) Rust notations? Coming from Python, consistent code everywhere has been on the biggest wins in that language, and it would be *extremely nice* to keep that goin.
Some things I noticed when looking at the source for simplify-rs: * A fairly common anti-pattern is to the effect of let mut i = n; loop { if compare_foo(foos[i]) { break; } else { // do something with foos[i] i += 1; } } It is more idiomatic to use rust's iterators for foo in foos.slice_from(i).iter().take_while(|foo| compare_foo(foo)) { // do something with foo } And if the line gets too long (&gt; 80-100 columns), you can split it like for foo in foos.slice_from(i) .iter() .take_while(|foo| compare_foo(foo)) { } * Type inference is your friend. Function declarations are the only place that require types to be explicit, and so best practice is to let the compiler do its thing and only be explicit when actually required to compile. * ```match``` is a great tool, but I try to be conservative with it. Another snippet from simplify-rs: let t : float = calcStuff(p,p1,d1); match t { tt if tt&gt;1.0=&gt;p2, tt if tt&gt;0.0=&gt; d1.mul(tt)+p1, _=&gt;p1 } Rust still has ```if```, and sometimes it's all you need. Of course it's subjective, but in this case, and generally in cases where not much pattern matching occurs, I think it's clearer to simply write if t &gt; 1.0 { p2 } else if t &gt; 0.0 { d1.mul(t) + p1 } else { p1 }
- so I'm using the loop instead of the iteration because we are modifying the vector as we are iterating it, if certain conditions are met we push 2 more things into it, and then iterate again if we can pop one out. I haven't figured out how to make that work with iterators the naive approach runs into issues with mutating borrowed pointers. - I've been type decorating defensively, so it's good to know I don't need to. - Whether I used a match there or not I'm not sure why I decided to redeclare the variables, I really think that the if and match statements in Erlang are the only place in that language where things are clearer then other languages and have probably been subconsciously trying to do that (in Erlang 'if' is equivalent to `match true`)
Regarding the first bullet, in that particular case there was an inner loop that doesn't do any mutations, so you could change it without any borrow check issues. I think the outer loop is good the way it is. [Here](https://gist.github.com/tikue/1285e5db01ce949e224d) what it looks like with the change (I tested it and it compiles). Oh! One other thing. You can use #[deriving(Eq)] instead of manually impl'ing Eq for Point. I'm not sure where the exhaustive list of all things that are derivable is kept. Ok, just one more thing -- instead of creating a struct Pair(uint, uint), you can alias the tuple (uint, uint) to Pair like this: type Pair = (uint, uint); That has the benefit of just being a tuple, so it has all the methods of tuples, for instance first() and second(), so you wouldn't need to ```impl Pair { fn first() ... fn second() ... }```. And then you can still put Pair in the type signatures. Of course, you wouldn't create Pairs by doing ```Pair(foo, bar)```, you would just do ```(foo, bar)```.
Does `rustpkg` has any up to date manual how is it intended to be used?
It's not complete, and could be subject to change: http://static.rust-lang.org/doc/rustpkg.html
This is great! Always nice to see useful software written in Rust :)
Yeah, I've seen it and I still have no idea how to use it and I haven't seen single project using it. In the past I was able to use `cargo` and it worked kind of like I expect (like `go` or `D`'s `dub`). I would like to be able to do: ``` rustypkg build "github.com/dpc/rustyhex" ``` so it automatically fetches dependencies (`rust-sdl`) etc. and builds my project. Is it possible? Should I put `extern mod "github.com/brson/rust-sdl";` in my project? This does not seem to work. Right now the manual is a lot of vague theory and no examples. :/ 
Congratulations to Alex! His contributions to the compiler have been consistently excellent. https://github.com/mozilla/rust/commits?author=alexcrichton
Awesome. He had been a super productive contributor already. Or as someone else said: &gt; With how active you are on the project I thought you were already on the team :) https://mail.mozilla.org/pipermail/rust-dev/2013-September/005594.html
I imagine there's quite a few other equally appropriate community members who applied; I hope everyone gets hired!
There is a recent pull request https://github.com/mozilla/rust/pull/9239
For the language changes I think the general approach with PEPs (REPs for Rust?) in Python works really well. They get numbers so people can refer to them and there is a change history to see how the were formed and where they came from.
Is there a well-defined threshold that Python uses to distinguish between what is and is not a "language change", and thereby requires the full PEP process?
There is no well defined threshold but it usually is: * it would introduce keywords, change syntax * it changes behavior of something already existing * it's a large new module for the standard library * there was a lengthy discussion on the mailinglist that did not come to a conclusion.
&gt; I think it would be best when people would start to integrate incremental additions/improvements into the Rust trunk. Agree, it would be nice to coordinate the efforts, to prevent burnouts. Time is a [VERY tricky](http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time) topic. From my experience XML can be hard, with lots of corner cases, but date/time is REALLY nasty. Calendars, timezones, missing weeks, leap seconds, etc. 
Of course Rust authors would know best, but to me JSR 310 looks like apache style library choke full of util functions to cover Java language deficiencies. Not suggesting Go time package to be considered over Java but comparing 84 src files in Java vs 12 src files in Go. It looks to me Go provides concise and comprehensible package. Looking at this in Java example from Java docs: "LocalDate specialOfferExpiryDate = today.plusWeeks(2).with(next(FRIDAY));" I find 'plusWeeks()' is kind of thing Rust could do without. My 2 cents.
The compiler has `rustc --pretty normal foo.rs`, but it doesn't work very well yet. (It is a goal to have it working.) In any case, the "lint" I'm talking about are those/the architecture built into the compiler already, which runs late in the compilation phase and picks up things like unnecessary `mut`, unused variables etc.
Awesome news. DateTime is a major gap, and incredibly important for a strong 1.0 release IMHO. But - echoing others here, DateTime is seriously complex - surprisingly so. And designing a good API is *hard*. Java stuff tends to get over-designed, making usage cumbersome, which would worry me a little using it as a basis. After reading JSR310 some more, it certainly seems comprehensive. But the whole `TemporalAdjuster`, `ChronoUnit` etc are good examples of this over-design - abstracting and making everything uber-generic. Does Rust *really* need to support the 13-month Coptic calendar in V1? Or should we just settle on really solid ISO-8601 first? Obviously I humbly suggest the latter.
Fantom is great, but so is JodaTime. I don't care what it is modelled after, as long as we get a comprehensive date/time library. 
Slightly off topic! Inspiration from Java APIs make me little worried. Despite humongous std lib in Java in my daily job I can not write smallest piece of useful s/w without 3rd partly libs. Most APIs looks in Java designed without real use cases. The reason Rust looks very interesting because Rust authors are writing / supporting a full browser engine which has a very real use case.
&gt; Not suggesting Go time package to be considered over Java but comparing 84 src files in Java vs 12 src files in Go. It looks to me Go provides concise and comprehensible package. It's also really empty, there's little more in it than in the standard C library. In your example alone there are at least 2 features which don't exist at all in Go's time library: * separation of timezone-less and zoned dates. They are incompatible so this is a good thing. * contextual adjustment (to a specified surrounding weekday) as far as I can tell, its fuzzy offsets support is also debatable (I see no way to add "2 weeks" save by hardcoding it to 7*24h, it has a special dedicated method for offsetting by year/month/day) Not saying the JSR 310 API should be replicated, but the reason it's 84 files to go's 12 is because go's handling is woefully incomplete (even ignoring that 310 supports a bunch of weird calendars)
The former Date API was obviously not well designed, but the JSR310 is a new date API based on the Joda Time experience. JodaTime itself is a 3rd party library widely used and careful designed to fix Java Date API problems.
hmm...on second thoughts It's quite constrained of them that they stopped at plusWeeks() and not went for plusOneWeek() , plusTwoWeeks(), plusThreeWeeks() and then move on to month etc.
If OpenSSL is too baroque (broke? :) to integrate, there are other SSL libraries that could be used instead: * ~~https://github.com/libtom/libtomcrypt~~ (edit: crypto yes, SSL no) * https://github.com/cyassl/cyassl * https://github.com/polarssl/polarssl are three that come to mind.
We need something battle hardened.
And don't forget the heap and managed allocation linter!
&gt; JodaTime itself is a 3rd party library widely used and careful designed to fix Java Date API problems. Geodel's position are amicable, it's quite obvious that if you can hit 80% of features with 20% of code, you should go for it. I do think, having Calendar to implement Coptic calendar is the 20% of features almost no one will need. 
I agree that we should have some sort of PEP-like procedure.
&gt; auto-formatter I couldn't agree more. This is something that comes up in C/C++ a lot. Having a lint tool that *fixes* what doesn't fit good style would be a very good thing, and would be well-received. The problem is that you can have a tool like cpplint (for example) complain about how much your code smells, but it won't lift a finger to fix any perceived problem... which is insane, considering it just had its grubby paws all over the AST in order to give you a report. As an engineer, this is particularly galling, since all we do is write software to automate repetitive tasks. Yet here we are: spending hours doing data-entry based on a program's output. Granted, stuff like Uncrustify and Artistic Style will re-write code, but will avoid the heavyweight things that cpplint will find, like using CamelCase instead of snake_case for variable names. So, to bring this back to where we started: other languages lack good support in this area. This would be a big win for Rust, as it's a clear edge over other languages. 
Having never used Joda-Time (the backbone of JSR310), I went looking for the API http://www.joda.org/joda-time/ To anyone else unfamiliar with the library, just take a look at the Key Concepts in the menu on the left. I found this particularly enlightening, as I've used all of these before - conceptually - but never have I seen them formalized like this. What's nice is that performing *math* with time values in this library is anything but an afterthought. The calendaring may seem like overkill, until you think about how hard that is to accomplish in the standard library of other programming languages. IMO, it is really essential if you want to properly internationalize your software (or garner world-wide support for Rust in this case) as not everyone uses ISO time.
The coptic calendar is an example, it's in old versions of threeten but [not in the JDK 8](http://download.java.net/jdk8/docs/api/java/time/chrono/Chronology.html). But calendar support is necessary to handle the Hijrah calendar (muslim lunar calendar) for instance.
OpenSSL is ugly and annoying but it's well trusted, cyassl and polarssl are GPL.
I think this was something Roslyn (C#) was supposed to help with. The compiler would build and AST that was used of course by the compiler but also other tools could benefit and use the AST to do whatever they needed, spell check for identifiers as an example.
&gt; but it won't lift a finger to fix any perceived problem... ReSharper has helped a bunch with this on the .NET platform. After I recommend it to people they often are telling me about how it "showed" them the right way to do something. I think that kind of stuff would be best within an IDE. I have not been hearing any of the "cat is the only way to code!" B.S. from this community so I do hope to see some nice IDEs and static analysis tools.
All part of `rustc::middle::lint`, i.e. covered by the "etc" :P
Two parts, one for physical time measurements and one for human calendars. Regarding the "physical" part: 1. There needs to be separate instant and timestamp opaque types for different clocks, so that just getting and storing the time is as fast as possible because no conversion is necessary (this is great for benchmarks) 2. There must be a "local" monotonic clock that could use an unsynchronized (but constant-rate!) TSC and a "global" monotonic clock that guarantees happens-before between tasks 3. "Stopwatches" that only return timespans and not instant, such as "task CPU time" 4. "Generic" TAI instant and timespan transparent types represented as 64-bit seconds plus 32-bit nanoseconds, 64-bit seconds based on the epoch plus 64-bit attoseconds and simply 128-bit total attoseconds that the clock-specific types can be converted to (using a trait they implement) 5. An UTC instant type as a different type (or with different generic type parameter tag) 6. The clock-specific traits should also give the accuracy expressed as the maximum error timespan 7. Optionally, an NTP-synchronized clock (implemented in Rust) for special cases where it is essential that time be accurate and system time cannot be trusted Regarding the "human" part: 1. A "human date specification" type with year, month, day of month, day of week, AM/PM, 12-hour hour, minute, second, subsecond part expressed as decimal float, timezone and DST value where each field is an option, so that e.g. "Monday", "February", "11:20", "2013-01-01" and "11:20 PM" can all be represented losslessly 2. Note that such a specification can be interval or not ("2013" is an interval, "Monday" is not) 3. Note that such a specification can correspond to a single set of instants or not (it can if and only if timezone and DST information is specified) 4. A "human duration" type with year, month, day of month, day of week, AM/PM, 12-hour hour, minute, second, subsecond parts 5. Note that such a "human duration" can, assuming no leap seconds, correspond to a single timespan or not (e.g. "1 hour" does, "1 month" doesn't because months have different number of days) 6. Optionally, a "human date set" type that would express an OR of ANDs of ranges of "human date specification" values, where range endpoints need to have the same set of specified fields (this would be used for stuff like "Mon-Fri" or "Mon-Fri 9-17") 7. A human date format string standard, ideally the same as strftime/strptime format strings or an extension of them, with locale-specific defaults obtained from the OS, that is also returned when heuristically parsing dates, so the date can be modified and then converted back to string in the original format 8. Maybe support for non-Gregorian calendars too Plus all the obvious ways of converting between those, comparison, testing inclusion/membership, string parsing/formatting, etc. 
&gt; V519. The 'x' variable is assigned values twice successively. Perhaps this is a mistake This one is already caught if you assign to the same variable twice, `let mut x = 1; x = 2`. Not if you create a new variable with the same name `let mut x = 1; let mut x = 2`, but you will probably get an unused mut warning. To make the linter perfectly silent it has to be `let x = 1; let x = 2`.
I agree (I am Luis de Bethencourt). Hopefully this can be official, or at least in git before it is considered feature complete. My goal is to get a solid base and then prioritize over the most common uses of such an API.
Good points! Thanks
Thanks for starting the conversation here as well -Y0- Bookmarked
Way to go Corey!
Thanks for the immutability part. Java's standard datetime handling is an absolute nightmare because of the pervasive mutability. In comparison, Joda is a dream. 
It does, actually, complain about shadowed variables that were never used. fn main() { let x = 1; let x = 2; printfln!(x); } lint.rs:2:8: 2:9 warning: unused variable: `x` [-W unused-variable (default)] lint.rs:2 let x = 1; 
Thanks luis :D First step, don't go into the deep end. Make an instant, and make it right. It'll be hard. Focus on small managable task as opposed to taking every possible thing at once.
I call that a feature :)
From a simplicity point of view i like Apple's approach, because there are basically only 3 classes: `NSDate`, `NSCalendar`, `NSDateComponents`. One can add esoteric calendars via subclassing. The biggest drawback is probably that they do not appear to support date/time without a timezone. Imagine you are parsing a date from a (log) file, having no clue which timezone it refers to. Boost `date_time::date` is easy to use, but under the hood is very coupled via template metaprogramming to a lot of moving pieces. Joda et al feel a bit Java-ish. I am not sure whether we should match it too closely. 
&gt; I have not been hearing any of the "cat is the only way to code!" B.S. from this community so I do hope to see some nice IDEs and static analysis tools. As a fervent Sublime Text user I am surprised people are against IDE. They are great tools, having IntelliJ Rust would make me shell out $200 like right now. But, they are for new people or if you need one of the many benefits of such system. Playing with razor edge in terms of languages often forces you to go the text editor route, because making IDE is hard work. Debugging/Constant Deployment/Navigation etc is just so much easier in a proper IDE.
A good refactoring tool would be awesome. If the pretty printer weren't totally whacked, it'd be nice to have as well.
I'd also pay good money for a great Rust IDE.
GC is per-task, so if you never use shared pointers in a task (ie. @), then GC will not run for that task.
I can't answer all of your questions, but I can provide some clarity regarding GC. Rust is a language that really doesn't like GC very much, and as such GC is opt-in rather than opt-out. If none of your code uses GC'd pointers (as denoted by the telltale `@` symbol), then no garbage collector will ever bother it. Of course, the difficulty then is to ensure that you don't call any external code that makes use of GC. Right now you can't trust the stdlib to not use GC, but one of our goals for 1.0 is to excise GC from the stdlib as much as possible. Another long-term goal is probably to provide a `#[no_gc]` crate attribute that prevents your code from accidentally calling into anything that itself uses GC (this seems to be what you're requesting). One way to currently guarantee that you never make use of GC is to disable the runtime entirely, but in addition to being the nuclear option this would also disable everything to do with concurrency. For the other questions, feel free to also check out the mailing list and IRC channels (see the links in the sidebar).
Maybe one should also have a look at Smalltalk. The API seems quite elegant("DateAndTime now + 1 hour" gives guess what…) could be 1:1 translated to rust: "DateAndTime::now() + 1.hour()"
Also http://mxr.mozilla.org/servo/ for those whose interests tend in that direction. It doesn't understand Rust code, so no clickable identifiers, unfortunately.
Thanks. In fact I recently ran the mentioned program on my 1-core netbook and found that it still "livelocks," despite the call to `deschedule`. (Main thread doesn't progress, program taking huge amounts of CPU..) Would it help if I provided a simpler test program (that doesn't depend on audio) that might help detect these kinds of cases, or is this a well-known case to the Rust developers? 
Others _definatly_ call it a bug.
Python has been using OpenSSL exclusively and it has never been an issue.
Right, but I bet they don't _distribute_ python that's linked to openssl. In ruby-land that's how it works. I just mean in general, I like the GPL, that's all I'm saying.
&gt; Right, but I bet they don't distribute python that's linked to openssl. In ruby-land that's how it works. Debian does: ldd `which python` linux-vdso.so.1 =&gt; (0x00007fffa21ef000) libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00007f3ffe62a000) libdl.so.2 =&gt; /lib/libdl.so.2 (0x00007f3ffe426000) libutil.so.1 =&gt; /lib/libutil.so.1 (0x00007f3ffe222000) libssl.so.0.9.8 =&gt; /lib/libssl.so.0.9.8 (0x00007f3ffdfce000) libcrypto.so.0.9.8 =&gt; /lib/libcrypto.so.0.9.8 (0x00007f3ffdc3d000) libz.so.1 =&gt; /lib/libz.so.1 (0x00007f3ffda25000) libm.so.6 =&gt; /lib/libm.so.6 (0x00007f3ffd7a2000) libc.so.6 =&gt; /lib/libc.so.6 (0x00007f3ffd41c000) /lib64/ld-linux-x86-64.so.2 (0x00007f3ffe853000)
Great! This is going to become a really useful service. If I can make one suggestion though - the search results should really be in a monospaced font. Currently, all the results are in the default font, which is a proportional serif font, which makes it quite difficult to read code efficiently.
Note that afaik the complete removal of @-ptrs from the standard libs is in the works, followed by their removal from the language (shifting to a library-based version of ref-counting) which should make avoiding them even easier.
This is probably well outside the scope of this discussion, but do you know if the plan is to allow the user to schedule the GC at the time of their own choosing or run the GC in its own task?
Just finished my first Rust project. It's a full-feature Memcached client library implementing both the Memcached ASCII protocol and binary protocol. Supports single server and cluster of servers. It is 0.1 version for now, though the Memcached feature support is pretty complete. It's my first Rust project so there might be problems. Treat it as in alpha or beta state. Enjoy. 
Sadly it's not very useful if you're not using `#[no_std]`, since we don't have an effects system.
I'm fairly sure there's not going to be a GC as such, just ref-counting with some type system trickery to avoid cycles. Note that while I'm fairly sure this is the case, I'm just pulling this from my experience with rust + lurking on IRC, so I could be totally off the mark.
Nope, the plan is for `@` (or whatever it becomes) to be a proper GC; reference counting is handled by `extra::rc::Rc`.
Good catch. It probaly should mean `ge` since you need to implement at least `lt`.
Learn C, it'll give solid knowledge about things, learning rust afterwards will be easy and won't take much time. At the moment rust is less mature, less documented and in development basically. It will be much easier to find answers to C questions than Rust.
The question is, does it compile?
is there a release date? i'm playing with the trunk version, but compiling it on my machine takes so much time that im only recompiling it when the final 0.8 gets out.
I was in the same boat as you, only coming from Java and scripting languages instead of Haskell. And yes, Rust's safety features definitely make it friendlier to newcomers than C or C++. However, the hardest part of learning systems-level programming isn't necessarily mastering the language. Just as important is understanding the underlying workings of the machine itself, which will allow you to understand how each mechanism in a given language is designed to exploit certain aspects of the system for the greatest efficiency. To that end, I'd very much encourage you to gain at least a vague understanding of how C works, and also to inquire *why* it works that way. Doing so will make you not only a better systems programmer, but also a more considerate programmer in general. After that, you can graduate to Rust and continue your education without having to worry about segfaults. :)
I'd like to note that we don't allow *any* arbitrary Unicode in identifiers, so pasting random Zalgo into your code probably won't make you friends with the compiler. But combining diacritics are completely legal.
thanks, thats good news =)
None of the releases are boring minor updates. Those happen daily :P
I don't think understanding C is necessary. What you want to be studying it computer architecture and organization, rather than a given language. Once you understand a bit what's going on under the hood, C should feel fairly natural.
But it should still be treated as a snapshot. :)
Out of curiosity: is the formal language specification posted anywhere? I'm having a heck of a time finding it.
Learning Rust has helped me get my head around C. But to reiterate what others say, learn concepts not languages.
According to the often-unreliable reference manual (http://static.rust-lang.org/doc/master/rust.html#identifiers), identifiers may start with any character in the Unicode class "XID_start", and each subsequent character must be from the Unicode class "XID_continue". You can see the exact tables that comprise these classes at https://github.com/mozilla/rust/blob/master/src/libstd/unicode.rs.
I shudder to think what the spans in the error messages look like if you have errors in that code.
Oh no! That thing I wrote 3 months ago!
Yaaaaaaay, shiny new docs! This is the culmination of a lot of hard work by (among others): - cmr, extracting the info from the source - Seldaek, turning the json info into the fancy html - his girlfriend, the web design - austincheney, improving the JS web search - alexcrichton, porting the nodejs code to Rust
Coroutines are awesome, and are definitely going to be more readable than keeping tracking of the state yourself. The issue with building them on top of tasks is the very real performance cost of context switches. In the long-term (post 1.0), Rust should have first-class support for writing iterators/coroutines without requiring a context switch or even indirect/non-inlined calls. Paying a cost in terms of 10x, 100x or more for the abstraction is often going to be unacceptable in Rust's domain. https://github.com/mozilla/rust/issues/7746
Thy sins have come back to haunt thee!
Sure. rustpkg doc is very sparse. An example would be good.
Is the video down? It doesn't load for me in any browser. And trying to save the stream using rtmpdump gives me 'NetStream.Play.StreamNotFound'. 
I agree. C isn't hard to learn and the beauty of it, even though it is very primitive compared to modern languages, is that you can use it to create libraries for all other languages. Every language that I know of has some way of interfacing with C, so if you love working in Perl, for example, but need more speed, you can write some C code to give you the speed and simply interface with it. If you do learn C, I'd suggesting the K&amp;R book as it's very good for learning it, especially since it was written by two of the creators of the language. If for some reason you don't want to and are focused on learning concepts, may I suggest the D programming language? It has a lot of concepts built into it and it's pretty well documented with more learning resources being created. I'm not saying it's better/worse than Rust. I'm just mentioning it as a potential alternative.
Awesome work guys! &lt;3 &lt;3 &lt;3
&gt; And as I write this, I may have just solved my problem. 1 folder = 1 issue, 1 file = 1 comment. Yeah, I like that idea. Seems clean, and now that you mention it, obvious :-).
&gt; Just finished my first Rust project. Goodness, talk about learning to swim by diving in the deep end :)
I don't have time for a full explanation, but there is still shared memory, wrapped in safe interfaces. [`extra::arc`](http://static.rust-lang.org/doc/master/extra/arc/index.html) contains three smart-shared-memory devices: `Arc` (**a**tomically **r**eference **c**ounted) for sharing immutable data, and `RWArc` &amp; `MutexArc` for two different approaches for mutable data. (`RWArc` is better when you have many readers and only a few writers, since the readers are allowed to run concurrently.) These are all reference counted, with (at least) one reference for each task in which they are used, and get deallocated when they leave the scope of the last task which hold a reference to them. (that is to say, they aren't owned by any single task.) (The compiler is thinking a section header in the source is part of the doc-string for `extra::arc::Arc` which is making it look strange, [filed as #9425](https://github.com/mozilla/rust/issues/9425).)
It's the first thing that I tried when I started programming in Java: Russian methods with Japanese variables. It compiled and worked...
&gt; Hi, this is intended to be non-trolling, I notice that the terms "google" and "golang" don't show up in this subreddit and I hope I'm not breaking the rules ... I did read the sidebar. It's the general position of the Rust project that Go and Rust aren't competing, and in fact, while I personally dislike Go, it has some good things about it. Asking questions that relate to Go is perfectly fine. As for your actual question, I'm curious to hear what others say. I don't remember the exact answer, but there is some real reason.
I'm not 100% sure I understand what this: &gt; types must formally declare that they conform &gt; any trait that they conform to is supposed to mean. But I'll try my best to provide an answer. Yes, one must explicitly tie together concrete types to trait implementations. One does this via `impl` items. (However, keep in mind that the impl items do *not* need to occur with the declaration of the type itself. As new traits are added to a system, one can add new impls, without changing the source code surrounding the original type definition.) Within an `impl I for T` where I is a trait and T is a type, one provides the implementations for the methods declared by I, using the concrete data associated with the type T. Here are the reasons that Rust's impl items make sense to me. * you get an explicit declaration that this type satisfies the protocol of this other interface (you already noted this in e.g. your item 7), * I do not think you covered this in your list: If two traits declare two methods with the same name and type signature but with different behaviors, a single type in Rust can still implement *both* traits, and implement both of the distinct behaviors; the method dispatch code (be that dispatch static or virtual, depending on whether one is using type-parameters or trait-objects) to call each variant will be emitted according to the type of the receiver. * This is semi-related to the above bullet: you get a dedicated spot to provide the glue code and adapter methods that one might need because one type comes *close* to satisfying an implementation, except that there's a few bits of protocol that need to be mixed in. I am not a Go-expert; it is not clear to me how they deal with two interfaces colliding in their choice of method name+signature. From what I can tell, one probably needs to provide wrapper objects in order to disambiguate the two cases. (I'm not criticizing that; wrapper structs are sometimes necessary in Rust as well, namely when running into trait coherence rules that I won't detail here.)
With Go, interface implementation is accidental: func (f Foo) Bar() { ... } func (f Foo) Baz() { ... } func (f Foo) Quux() { ... } OK, I see the `Bar`, `Baz` and `Quux` methods, but are they from an interface, interfaces, or just normal methods? It's initially convenient, but not very discoverable. The only advantage is when you come to abstract a common pattern after the fact: define the interface which is already used and you're done. But this only works if they really *were* all done the same way. On the other hand, with Rust, it's explicit: impl Foo { fn baz(&amp;self) { ... } } impl Something for Foo { fn bar(&amp;self) { ... } fn quux(&amp;self) { ... } } Now I see that `baz` is a normal method while `bar` and `quux` are implementing `Something`. This makes it very easily discoverable, and also groups things together tightly and well. Whether something is implemented or not becomes cut-and-dried: either it's implemented, explicitly, or it's not, rather than getting obscure error messages about a type not satisfying an interface because an interface changed underneath you. (Rust would object at the trait implementation level saying that you're missing X or Y is wrong.) This sort of thing is especially dangerous with Go's runtime typing (e.g. `foo.(Something)` or whatever the syntax was): suddenly things will just start failing or behaving differently, with no compilation error at all. That I find to be a fairly scary prospect. Overall, I find myself very strongly preferring Rust's traits to Go's interfaces. (I say this as one who has been primarily a Python developer.)
You're right about name collisions in Go; the adaptor pattern is indeed the only solution—and often infeasible.
Indeed, Go has influenced certain things in Rust (especially in its tooling, which is a thing that Go has done pretty well). Other languages are out there for us to compare to and see what has worked out and what hasn't—and then to do our own thing, possibly influenced by what has worked.
Not usually, though again ymmv. If you've got other work to do besides updating the data structure, that work lives on other threads/tasks. For instance if you can structure your code as a pipeline you can have each stage of the pipeline running in its own task, communicating with other stages via queues.
Yay - I'm excited to finally see the new docs up on the site. Great work from all involved in getting that in!
Besides what everyone else said, this is also what makes it possible to add methods to built-in types like int, as well as types that the current crate didn't define (which built-in types are just a special case of). If any crate could add methods to any type, then two different unrelated crates could define conflicting methods, and those crates could not be linked together. Go solves this by preventing methods from being added to types not defined in the current package altogether, which is quite restrictive. In Rust, it's perfectly legal to add methods to built-in types like int, and the explicit implementations are what make this possible.
Hooray for Rust beating G++ C++, even if only by a small margin; it's certainly shaping up as a serious contender for applications where speed is vital. I'd be quite interested to know what versions of Clang and the GCC were used.
But, can you fit both files on the back of a business card?
The two Rust files together are around 3.9kb whereas the C++ one is around 4.6kb (using the numbers from Github), so assuming those sizes translate roughly into characters then if the C++ one could fit, the Rust one could too. In my limited experience so far Rust has been more concise than C++.
The [actual business card version](http://www.cs.utah.edu/~aek/code/card.cpp) is 1337 bytes.
&gt; Every language that I know of has some way of interfacing with C Also note that Rust code can expose a C-compatible interface, so any language that can call into a C library can also call into a Rust library.
(Please ignore the fact that dynamic_cast doesn't work w/ void* - rather think of common hierarchies like Object, QWidget etc)
Rust is not beating g++ yet: https://mail.mozilla.org/pipermail/rust-dev/2013-September/005742.html and https://mail.mozilla.org/pipermail/rust-dev/2013-September/005740.html
I didn't know about the `bytes!` macro. I wanted to learn more about it, but I can't find it in the doc. Actually, I can't find other macros, like `format!`, either. Where can I find their documentation ?
I don't understand the discussion about `clone`, `clone` copies everything that's owned and stops at boundaries like `@`, it does seem to fit Rust.
Surprised that struct-like enum variants are getting the boot.
I'm not familiar with dynamic_cast in C++, but the concept of casting to a trait does exist. Whipped up an example: https://gist.github.com/bstrie/6690498 The relevant section of the tutorial: http://static.rust-lang.org/doc/master/tutorial.html#trait-objects-and-dynamic-method-dispatch
These are both implemented as syntax extensions, which currently live in the parser and have little to no documentation. Reading the source is the best you'll be able to do right now, I'm afraid. :( https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/bytes.rs https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/format.rs
I think what (s)he's asking is trait A { } trait B: A { } fn blah(obj: &amp;A) { foo: Option&lt;&amp;B&gt; = dynamic_cast::&lt;&amp;B&gt;(obj); ... } 
format! is documented in std::fmt. But the other syntax extensions have no docs.
Custom version == `(x * x * x * x)` (or otherwise using the fact that they are integers)? I think this is "cheating", since the C++ uses the floating point pow. (BTW, I added `no_std.rs` that uses the intrinsics directly, and the C `rand()` call like the C++ does, and it's no faster.)
Is the difference just whitespace? *edit It's not. https://gist.github.com/logicchains/6695228 With a heap of whitespace removed, the Rust version is still around 2.9kb.
Isn't that the conclusion they came to? It's a "sheep" (shallow-deep) clone that copies the minimum required to preserve the type system invariants (mainly ownership, i.e. `~` has to be deep-copied but `@` can be shallow.).
yes to the first, I guess that's cheating but it's nothing that a different compiler couldn't do. I'm also not surprised that reducing the number of operations needed for a random f32 helped performance, even if it was just a little...
Oh no! Really? D: ~~One thing I really dislike about Haskell's datatypes is the fact you can't tag the fields.~~ It makes self-documenting code rather difficult, and I was glad Rust allowed you to do it. It makes messages much nicer.
Re: pub/priv, I've been thinking about this for a while now. It's confusing that you can put `pub` on type impls fns, but they aren't needed (in fact they are forbidden) for trait fns. I trip over that quite a bit. Wouldn't it be more consistent just to make everything public by default, remove the `pub` keyword, then require explicit `priv`s? I know it goes against Rust's 'conservative first' principles, but the inconsistencies in the current approaches is jarring.
You can; Haskell has record syntax: data Foo = Bar { baz :: Int } (There are various problems with it though.)
You didn't remove all of it. (e.g. `impl Add&lt;Vec,Vec&gt;for Vec{`, `self.x+other.x`, `fn test(o:Vec,d:Vec)`.) Also, the variables can be shorter, `Vec` &amp;rarr; `V`, `test` &amp;rarr; `T`, `other` &amp;rarr; `o`.
Ohh well I am a silly then.
I've added side-by-side [Rust `#[no_std]` and C](https://github.com/huonw/card-trace/tree/master/no_std) implementations for comparing what Clang does vs what we do. [This is the IR for both](https://gist.github.com/huonw/348081acb4a42bc0adbb) from before [#9474](https://github.com/mozilla/rust/pull/9474) landed, [this is the IR](https://gist.github.com/huonw/f825d529e29430b7eb53) for the Rust code after that landed. The timing is: Pre-9474 rust: 17.4 Post-9474: 15.4 Clang: 14.1
if 'continue' replace 'loop' inside loops, is the other usage of 'loop' necessary? Can't it be replaced with 'while true'? 
One thing about public functions is that they have much stronger ABI guarantees: functions that are completely private give LLVM much more flexibility to optimise (e.g. passing `&amp;int` as `int`, completely removing unused arguments), so having private-by-default makes these more likely (or at least, it's less likely to be slower than necessary). (That said, there a few problems to do with `#[inline]` that mean private functions can leak out, so this isn't quite as simple as telling LLVM that non-`pub` functions are "internal".)
The original purpose of `loop` as `while true` was to allow typestate to understand certain kinds of infinite loops. Typestate's been gone for years now, but people still liked the notation enough that it's stuck around. Might be worth discussing, but I'm quite fond of the current situation (as the devs also seem to be).
An entirely minor thing which can probably be fixed relatively easily: labelled break only works with `loop` (and `for`, since this is implemented in terms of `loop`), i.e. 'foo: while true { break 'foo; } is currently a syntax error.
Here's a very, very old resource on what the process of calling Rust from another language looks like: http://brson.github.io/2013/03/10/embedding-rust-in-ruby/ See the "caveats" section at the bottom, but take heart at the final line: "Most or all of those limitations will evaporate over time." For all I know, many of those limitations may have already evaporated in the six months since this post was written. Feel free to ask on IRC or the mailing list (see the links in the sidebar) if you'd like more up-to-date information.
Thanks, this was what I was looking for
...btw, this only works for one subtrait B? What if you have 30 subtraits?
But is it worth the additional keyword?
Labelled break don't work with while at all? is that by design?
I assume it's just unimplemented rather than a technical issue since `while cond { .. }` could, in theory, desugar to `loop { if !cond { break; } .. }` and this form does support labelled break. (My point is this needs to be fixed before replacing `loop`, which I'm actually mildly in support of.)
You'll have to write 30 methods, I'm afraid. (I think. I don't see a better way.) If Rust ever gains certain advanced type system features (higher-kinded generics and a `ConstraintKinds` equivalent for starters), it might be possible to implement the general form as a library. But not now. 
You can shave 5 more bytes by replacing "let (" with "let(", and 0.002 with 2e-3.
&gt; overflow protection Note that this is available in Clang with the `-fsanitize=integer`, so if you have any C/C++ program lying around you can easily see: - what Clang does to the IR - what is the effect on the generated binary size (depending on optimization flags) - what is the effect on the generated binary performance (depending on optimization flags) As far as I recall, the activated Undefined Sanitizer had a 20% performance impact as a whole, but I have no recollection of the exact set of activated features. Also, `-fsanitize=integer` calls a *cold* function (that reports and traps by default), so the scheme seems easily adaptable for Rust (whatever the function does). The various sanitize flags are available [here](http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation).
[Overloading is possible](https://github.com/mozilla/rust/wiki/Note-operator-overloading), the code actually overloads `+` and `*` (that's what the `impl Add` and `impl Mul` are doing towards the start). And yeah, I didn't experiment with macros at all, it might be a good way to compact the `for` loops.
I've been itching to learn Rust for a while now, and have recently fallen in love with approximate data structures and sketches. Figured it would make a good project to learn Rust: lots of bit twiddling and memory manipulation. I'm sure this code is straight up terrible...I really have no idea what I'm doing in Rust right now. Been a fun exercise so far. Surprisingly good performance too. Averaging around 600k values per second on my laptop.
Excellent, will check it out. I assumed something like that existed somewhere but just couldn't find it. Thanks!
I misremembered: it's [`BitCount`](http://static.rust-lang.org/doc/master/std/num/trait.BitCount.html). Other than that, it looks like perfectly good Rust code. (Although, you'll need the `PCSA` struct to be `pub`: it's currently private, and so *shouldn't* be usable cross-crate, but compiler bugs mean it is... for the moment.)
Not unrealistic, just somewhat onerous in practice. One of the selling points of a higher-level programming language is that it can serve as a standardized medium of communication with other people who know the same language. But as you add more and more flexibility into the language itself, you create ever greater barriers to comprehension for anyone who knows the language but has never encountered your specific dialect before. Thus, an important part of designing a programming language (especially one targeted at teams working on enormous projects) is to *restrict* the means available to express ideas (as odd as that may sound), while doing it delicately enough that an individual programmer does not feel completely at a loss to express whatever given idea they have in mind.
Ah, good to know. Thanks! Out of curiosity, is it normal to have so many type definitions everywhere? It feels like I'm declaring the type on every variable, and unfortunately doing a lot of casting when I need floats to work with. Maybe it just feels strange because my day-job is in a dynamic language :)
Cool stuff. Could you just give me a quick ELI5 version on what these data stuctures actually do and where they might be useful. The whole cardinality of a data stream thing went kind of over my head :) 
Sure. I'll start with why the are useful: Imagine you have an infinite stream of data (twitter, stock tickers, whatever). We want to answer a question like "*How many unique words have I seen so far?*" The naive approach is to maintain a map of words. As new data is indexed, add words to the map using the word itself as the map key (e.g. $map["word"] = 1). The number of unique words in your dataset is simply the length of the map. This approach fails eventually, because the stream of data is infinite and the map will continue to grow in size. You are using a ton of memory for what is effectively a single count. If you need to maintain thousands or millions of different counters, you won't have enough memory. The approximate estimators abuse some basic statistical properties to give good estimates. Imagine flipping a coin...what was the longest "run" of tails that you got? If your longest run was 3 tails, you weren't flipping very long. If your longest run was 100 tails, you were probably flipping all day (because the chance of getting 100 tails back-to-back is very small, you were probably trying for a long time). These counters work like that, but with bits instead of quarters. They hash data (randomizes the bits) and looks for runs of zeros. Longer runs == more rare. By combining multiple "buckets" to count longest runs of zeros, you can guess how many unique values are in your stream. And what makes these counters useful is that they are small. A map of unique values for a billion elements may be a few hundred megabytes. A HyperLogLog is 2kb and has an error rate of around 1.5%. And ironically, the more data you have, the less you actually care about exact values. (19,895,098,124 +/- 10k...who cares about that 10k?) If any of that was interesting, check out these links (they are fascinating!): * [Good intro to all the approx algorithms](http://highlyscalable.wordpress.com/2012/05/01/probabilistic-structures-web-analytics-data-mining/) * [Explanation of PCSA](http://www.aggregateknowledge.com/science/blog/pcsa.html), the counter I implemented first * [HyperLogLog](http://blog.aggregateknowledge.com/2012/10/25/sketch-of-the-day-hyperloglog-cornerstone-of-a-big-data-infrastructure/), the "state of the art" counter so far
Is rust going to hit 1.0 by the end of the year?
So... Who's in favour of renaming "clone" to "sheep"?
Hm, actually, yes, I could've been more detailed in my critique: most Rust code would leverage the type inference more and just write `let foo = x` rather than `let foo: type = x`, except for situations when the compiler can't infer (this is most common with integers, but they can be handled with suffixes: `1u64`). ([One particularly weird point](https://github.com/polyfractal/rust-approx/blob/master/src/approx/lib.rs#L66), it could be `let m = match b { 4 .. 16 =&gt; uint::pow(2, b as uint), _ =&gt; fail!() }` and then skip the `as uint` cast below.) Also, [these functions](https://github.com/polyfractal/rust-approx/blob/master/src/approx/lib.rs#L18) shouldn't take references: `u32` and `u64` are very cheap to just copy (the same as a pointer anyway), so it will be more efficient to pass by value. Another little thing: [this loop](https://github.com/polyfractal/rust-approx/blob/master/src/approx/lib.rs#L96) could writen with iterators: let sum = self.buckets.slice_to(self.m).iter().fold(0, |s, &amp;value| s + (!value).trailing_zeros()) as f32; (You could use the `do` sugar too: `do self.buckets....fold(0) |s, &amp;value| { ... }`.) Other loops that are iteratorable: [this one](https://github.com/polyfractal/rust-approx/blob/master/src/approx/lib.rs#L114), and [this one](https://github.com/polyfractal/rust-approx/blob/master/src/approx/lib.rs#L137), using `self.buckets.mut_slice_to(self.m).mut_iter().zip(p2.buckets.iter())`. (Iterators will make the code more efficient, since they avoid bounds checks, and get optimized very well.)
The question you really want to know, is when will [Rust hit release milestone #2](https://github.com/mozilla/rust/issues?milestone=13&amp;page=1&amp;state=open), where it will remain backwards compatible with earlier code.
Thank you very much! :)
You are an extremely sexy human being.
I remember reading after 0.7 that this (0.8) release cycle will feature a focus on compile time. Anyone knows what happened with that? because on my computer the cycle time hasn't changed much (~23 minutes on i7qc from 2010 with 16GB of ram).. Apart from that congrats on the release to the developers, contributors and all the friendly &amp; helpful people here and on the #rust* channels :).
pcwalton did some amazing work on making small crates compile faster ([#8802](https://github.com/mozilla/rust/pull/8802)) but the speed up isn't listed in the PR/commits, there's no more info around [the obligatory `r?` comment on IRC](https://botbot.me/mozilla/rust/msg/5521163/), and I can't remember the numbers thrown around at the time, so I don't know *how* much faster.
Thanks! This is invaluable, I've just been thrashing around and letting the Compiler tell me when I'm doing things wrong. I'll make the fixes you suggested. The only thing I did on purpose was avoid the iterators, since I knew they were changing for 0.8 and documentation for them is all over the place depending on where you look :) Will convert them now, thanks!
Yep, a Bloom Filter is definitely in the same family. Probably the most well known too. Approximate data structures fall into roughly four camps (currently): * **Cardinality:** HyperLogLog, LinearCounting, PCSA, etc * **Set Membership:** Bloom filter and all its variants, Quotient filter * **Frequency / "heavy hitters":** Count-min and family * **Quantiles:** Q-Digest, Frugal streaming I'd recommend checking out Count-Min Sketch, it is conceptually similar to a Bloom Filter but allows approximate frequency estimation ("How often have I seen the word "blue"?). A popular Java library that implements a lot of these data structures is [Stream-lib](https://github.com/clearspring/stream-lib). I'm not aware of any other "all-in-one" libraries...a lot of people implement the algorithm themselves in their stack. There are a number of individual-algo implementations on Gitbhub, but I've never personally tied any of them.
Denver, CO area - willing to start a group with others
Hungary, usually Budapest
Austin, TX area
This is amazing! Can we say that Rust is no longer purely printf-debugging? (Although, `make RUSTFLAGS='-Z debug-info'` still fails in `libstd`. :( ) Also, &gt; we radical Rusticals
This is absolutely fantastic! All that's missing now is some decent editor support (code-completion, outline, etc...)
Thank you, love you! 
Another fun trick now possible - build your project foo with -Z debug-info, then use `objdump -S foo` to see the interleaved Rust source and generated assembly.
Suwon, South Korea. We have [Korean Rust User Group](http://rust-kr.org/).
Great work! I wish InteliJ IDEA had better C/C++ support, I do wonder how much is applicable.
&gt; but LLVM does not support this [DWARF discriminated union info] and GDB only does in Ada mode. Does this mean that LLVM can't emit it for us, *and* GDB won't read it? :( A quick jaunt through the lldb sources makes it look like it doesn't care about it either (if I'm right in concluding that discriminant handling is all done via the DW_AT_discr attribute).
Toronto, Canada.
IntelliJ is getting C++ support, using CMake as the project format, soon. So hopefully that means good debugger integration that we can use with rust. Also someone could easily develop a plugin for IntelliJ to give the rest of the IDE support for rust syntax and such.
Silly question, but does it know which pointer type is which? And does it display it?
Sydney, Australia
The post only shows plain pointers, not @,~ or &amp; pointer were present.
Looks inactive but at least somebody has been thinking about it: https://github.com/stepancheg/rust-ide
I'm an american living in Paris.
Melbourne, Australia
I would love someone forever if they made an IntelliJ plugin. I really, really like IntelliJ and use it daily for a variety of languages.
Finland
Pittsburgh, PA!
In DWARF all pointers are just normal C-pointers. I don't know if there is a way around that as long as we want GDB to be able to handle it. For &amp; we might get away with describing these as C++ references, I have not tried that.
This. Finland.
LA
[/u/Osmandius](http://www.reddit.com/user/Osmandius) also listed LA
Israel.
Woo! It'd be amazing to get a meetup going...
I'll have to look into that. Can you file a bug report if it isn't the same as [#9167](https://github.com/mozilla/rust/issues/9167)?
I expect the Pittsburgh group to be large and active. I was very surprised by the tech community when I was there.
Montreal, Canada.
French, close to Nice.
Burlington, VT area. I don't know anyone else who's even heard of Rust.
Seattle, WA Dag yo, very geo-diverse group
I'm here too :).
French too, close to Paris.
Chicago, IL
This is great news! The more docs the better!
I am in the San Francisco Bay area, as are a number of others including pcwalton, tjc, acrichto, kmc, and erickt. We've had one meetup organized by erickt and should probably have more.
West of Paris, I’m sometimes on the #rust IRC channel. [I write a news on Linuxfr.org with sebcrozet](https://linuxfr.org/redaction/news/sortie-de-rust-0-8) (you need to be registered to see the draft).
Koblenz, Germany
I suppose in the Sophia area. /me too
Niagara, Canada
Pittsburgh checking in! I expect CMU has a lot to do with the tech culture here.
Santa Fe, NM, USA
Milestone #2 is scary =x
That is far easier said than done. I've spent time in the gdb code, and it's hairy.
I see the same thing as @enomado.
There's [walk-through on the wiki](https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust#windows). (It's existence isn't an excuse for not making it more discoverable though.)
The Netherlands.
&lt;3 (I'm not sure this passes the community guidelines, exactly, but I'll just take it as a compliment and move on.)
Any time.
Working on it, slowly but surely.
You're very welcome.
Seattle
Is there an OpenGL ES 2 profile? We should probably switch to this for Servo.
According to cmr: `--api gles2 --version 2.0`.
Albuquerque, NM
Well then, how about teaching `lldb` to handle it? :)
Portland, OR
Minneapolis, MN, USA.
Vienna, Austria.
Belfast, Northern Ireland.
Oslo, Norway
Novi Sad, Serbia, but otherwise close to Hungary :)
Just starting rust, but I'm from the south west of Paris
Ditto. (I can tell that Australians get favoured with name decorations.)
Canadian living in Paris here.
Thanks! Isn't the prefix /usr/local/bin by default though? Wouldn't that mean recompiling and using a prefix still won't fix the problem? I think I'll just copy over the source dir and try it elsewhere, so I can still undo my new attempt to compile. Since recompiling takes 2-3 hours here, it'd be a shame starting to recompile and then learning of a better solution one minute later. =/ /opt/ isn't used by my distro, though, so I should probably pick something else, to prevent a wildgrowth of directories.
Hm, never seen that bug before. Could you file it at https://github.com/mozilla/rust/issues ? There are no official binary releases for Linux yet, but there does exist a third-party PPA: https://launchpad.net/~hansjorg/+archive/rust
That's not how the Khronos registry works, presumably to make it clear gles 2+ is completely different from gles 1.
What about having r followed by n " instead? Looks like a string and most of the time you won't need more than 3 " (how often do you embed more than 2 consecutive " in a string?)
[/u/saosebastiao](http://www.reddit.com/user/saosebastiao)
Prefix is /usr/local by default. The folder to install in(bin or lib) is tacked onto the prefix. /usr/local is set up for the user (or group whatever) to use instead of using the default path, and not getting in the way of the package manager. Personally I prefer local for those reasons. But whatever works. /opt is set aside as a place for "3rd party" software or similar. Usually binary drivers install here. (AMD's does on Mint anyways) Some Makefiles have an 'uninstall' option as well. 
&gt; Some Makefiles have an 'uninstall' option as well. Rust's does.
I thought it did, but couldn't remember.
woot, bay area here too
I only know because it was mentioned on IRC a day or two ago!
This is pretty cool! Yay for rust-http being usable! However, I'm going be `~` police: [they are entirely unnecessary here](https://github.com/skade/widmann/blob/a5ecb17719563b44ec6186647b2b08b24cf1e225/src/libwidmann/application/mod.rs#L16-L17), all it is doing is adding a layer of indirection and the cost of an extra allocation. (The [relevant section of the tutorial](http://static.rust-lang.org/doc/master/tutorial.html#boxes) was recently updated to make this clearer.)
 error: instantiating a type parameter with an incompatible type `Sinatra`, which does not fulfill `Send`
At it's core, Sinatra and similar, such as Jersey for Java and Dancer for Perl, are very simple: you declare "handlers" as methods that accept certain parameters to allow you to handle a request and you have a way to associate that method with a URL path. I haven't used Sinatra, but it looks to be a lot simpler to use and understand than Rails. Also, my understanding of it is that template engines and similar are not forced upon you, but instead you can use what's provided or others. Overall, I like it. Simple frameworks like this that handle getting an HTTP request and sending it to the correct handler without a ton of cruft make me happy. Jersey is like that and it made it easy for me to create a RESTful endpoint.
What's the correct term for a Rust user? I saw Rustafarian earlier but this article is using Rusticals...
What/who is the name a reference to? (edit: It's http://de.wikipedia.org/wiki/G%C3%B6tz_Widmann )
There's no correct term. I'm partial to "Rustie", myself.
Basically: require 'sinatra' get "/hello" do "&lt;h1&gt;hello&lt;/h1&gt;" end ruby hello.rb Open browser, go to http://localhost:4567/hello, see that on the screen.
One need only look at a profile of rustc on `fn main(){}` to see that we're hugely improved. 34% is decompressing metadata, 7% is the kernel zeroing pages, and a large portion of the rest is ld.
I meant the name of the clone specifically; Widmann, apparently. It's a German surname but I'm not sure if it refers to anyone specifically, and Wikipedia lists a few options. :)
&gt; such as Jersey for Java and Dancer for Perl Also: Flask for Python.
Thank you for being the police, I fixed it now :).
I'd absolutely love to hear more about Claymore. Very cool looking. Not sure why, but game dev has always seemed like a fascinating use for Rust.
Warning: I'm new here. I realize this is a really difficult question to answer, and I can't seem to find it in the FAQs, but is there a rough estimate on when 1.0 (and thus long-term support) will be available? Middle of '14?
Ah! That's even better. Thanks. :)
I think that's backward: 1.0 won't appear before some (undecided?) subset of the milestones are sufficiently complete.
&gt; clever idea Use the type system, misconfigurations become a compile-time error. enum Settings { Root, MethodOverride, //..... } Then you have a HashMap&lt;Settings, ~str&gt; at least.
I'm hunting for speakers. Anyone want to present something rusty?
Utah, USA (Utah county). Haven't looked for a group.
That said, you are correct that the 0.x releases are just snapshots appearing on a fixed schedule.
I hope "Rustafarians" sticks
+1 Montpellier area.
Well, here's the problem: If I want to allow arbitrary settings, I cannot provide the enum beforehand (the user cannot extend it). Still, I'd like the framework to provide some standard settings, which the user cannot provide, so the library would have to communicate that. Actually having settings that go ~str-&gt;~str would have the advantage of being easily readable from command line or a config file.
JSR-310 method plusWeeks() takes an int-argument, so there is fortunately no need for methods like plusOneWeek() and so on. I myself also develops another java date and time library (Time4J) where I push a slightly another style, namely: date.plus(2, WEEKS). While this style requires a little bit more writing effort, it is more readable in terms of english language and reduces the count of methods in date type class by introduction of a unit-concept (JSR 310 also knows this concept but tries to hide it as a low-level design aspect).
Please could you elaborate why you consider a method like plusWeeks(2) as unnatural, or have I misunderstood you? Background is that I am also developing a time library for Java (Time4J) and am interested in any feedback. By the way, the whole calendar and time stuff is necessarily complicated and requires a big API if you try to model every detail. For example most APIs talk about leap seconds in UTC, but finally never support it (not even JSR 310). My suspicion: Rust will also not do it, or how much time is there given to development of the new API in Rust? For comparison: JSR-310 is more than 6 years old, I am working on Time4J for now about two years.
A struct with `Option&lt;Value&gt;` for the standard settings, and a field that has a map `~str` &amp;rarr; `~str` for the rest? (Or, skip the `Option` and have `Value` along with a function to construct a default settings-struct, so you can write `Settings { sensible_builtin_setting: ~"foo", .. default_settings() }`)
if you like we can also exchange detailed opinions about datetime library concepts and designs (I am developing another time library for Java since about two years as alternative to jsr 310). Just write to me a mail. Maybe cooperation can be fruitful for both sides. The api design strongly depends on who is the target (only business developers or also scientists?) and on which style Rust is designed for in general. For example the subject of UTC and TAI is only relevant for scientists (astronomers and so on), not for financial applications.
I'm a bit late to this conversation but oh well. I was thinking exactly the same thing: why not use tuples? What you call &lt;f32, ..4&gt; can already be written as (f32,f32,f32,f32), and I believe that Rust already allows adding implementations to this type. Now, the type declaration is quite verbose, and it would be tedious if I had to reimplement all numeric traits for various sizes and member types. But could we have a macro like simd!(T, n) that does it for us?
Knob (single file, 10 tests) takes ~40 seconds. https://github.com/skade/knob https://travis-ci.org/skade/knob rust-http takes ~1:40: https://travis-ci.org/skade/rust-http Travis caches APT as far as I know, so the installation isn't really hurting. 
Awesome!
.Thats a bit tricky. You could get a list of all Rust respositories on Github active since August (also available using the API): https://github.com/search?q=language%3Arust+pushed%3A%3E2013-08&amp;type=Repositories&amp;ref=searchresults To find out whether they are on travis, search for a file called .travis.yml within the resulting repos. As nice as this may sound, it has a problem: quite a few projects are built against rust-nightly/master and there is no way of triggering a build when rust-nightly changes, which is the most interesting metric to follow.
&gt; removing float did not see that coming. :) the discussion makes sense though..
NZ, I think there is one other guy that posts on the mailing list occasionally that lives in the same city. Otherwise, I seem to be alone :(.
Here's approximately what Python does (at present; the wheel format may change these things somewhat; I haven't followed how it works). In Python, you have `python setup.py install` which will install into the system directory (e.g. `$PREFIX/lib/python2.7/site-packages/{module,packagename-x.x.x-py2.7.egg-info}`). Then you also have `python setup.py develop` which is designed for people who are developing that library; that puts the egg-info in the same directory as `setup.py` and adds the directory to the import path list. Thus, you're not needing to modify files in `lib/pythonX.X/site-packages/`: the separation is maintained. Dependencies are still installed normally rather than in develop mode, which seems to be the sensible way to have it. (If you want it in develop mode, install it manually, which can be done before or after.) I'm not clear on whether this last matter is what's being desired for Rust or not. Working on a Django project with comparatively new developers, I've had to stop them from modifying files a dependency several times, explaining that, for example, we need to copy the templates into our tree before we can modify them. Making that structure read-only, if it can work, would be a good thing. Detecting changes if convenient and objecting would be good, too.
India.
In that case, it would be a matter of changing the name of the type (e.g. `int` to `intptr`, `uint` to `uintptr`) rather than removing it. Removing it is not feasible.
No concrete timeline. The best you'll get is the maturity milestones: https://github.com/mozilla/rust/issues/milestones You'll likely want to hold off using Rust until we reach the "backwards-compatible" milestone, at which point we'll be committed to not breaking old code (for a while, at least). This milestone might be cause for the release of version 1.0, or we might hold that off until we reach the next milestone ("feature-complete"). Note that the current "stable" releases (0.8, etc.) only represent regular snapshots in time and should not be construed as a direct march to 1.0 after 0.9.
Whenever everything on [this list](https://github.com/mozilla/rust/issues?milestone=13&amp;page=1&amp;state=open) is completed. These are all the items that are marked as necessary before Rust can be considered ready for a stable release. Once released, (e.g. v1.0), none of these will change (backwards compatibility) until the next major release.
Well the "unnatural" comment was referring to some of the example code I found in the docs, not `plusWeeks(2)` specifically. It seemed contrived, and was unnatural (or unrealistic) in the sense that it had a complex sequence of date calculations with specific methods and literal values, the likes of which I can't imagine needing/using in a real app (surely it would be parameterised, for one). It just seems overblown. The vast majority of the time (speaking purely from my own perspective!), all I need is solid support for these simple, common things: * parse a date and/or time from a user-supplied string * format a date and/or time into a pretty string * get the duration between two dates and/or times * get the current date and/or time and display it in a pretty localised format * slightly more involved stuff, like find out the date of the next Monday * add N months or M years to a date ...and so on. And you'd be surprised at how poorly some APIs do with handling just the first three. It's the whole "make easy things simple, and difficult things possible". I guess my complaint is probably also that it looks like the API as a whole pays the price of the complexity of the abstractions. Then separately, there's all sorts of stuff to do with performance timers, when I need high resolution timers, but I consider that to be a whole other (non-date related) API. 
Indeed intptr, sounds better to me. I don't say that int have absolutely no use, but I think it should not be the default and not have a so obvious name since most of the time, "the size of a pointer" is not what you really want when you think about an integer.
I see some points in summary that aren't in the logs (e.g. clone fn, Cell vs Mut, etc. ) What is up with that?
This happens almost every week, I've always assumed they just didn't have enough time to discuss all items on the agenda. Could be wrong though.
It's extremely unlikely to have a single array spanning half the address space, so in practice it still works? :-) And uh... you can subtract indices and always get a meaningful result. I'm not sure how often you want to do that. Other than that, I got nothing.
You're correct, at least for the last few weeks. (source: I've been doing the transcriptions)
&gt; I've got a fairly large side project which has been compiling just fine (without modifications) for nearly a month now which is truly a record for rust. https://mail.mozilla.org/pipermail/rust-dev/2013-October/005923.html
Compared to the recent changelog, this list seems small. It's amazing, the pace of development on rust.
That is surprisingly small and elegant! I think you got `.ref_as()` in the backwards though. I think we already have some functions named `.as_ref()` in the standard library. Is there a reason why you chose that order? Does it still work if you use `fn foo&lt;T:Any&gt;(...) {...}`? Can you still get the tydesc of the box?
Inference should work normally, but with how it's used, it seemed nice to just assume that the typehint is allways given explicit.
Ok, this is ridiculously cool. I really don't know anything about its pitfalls, what happens with tydescs cross-crate? Are tydescs truly unique? Anyway, if you use a trait like this, doesn't that completely eliminate the dependence on the layout of trait objects? use std::util::Void; pub trait Any { unsafe fn tydesc(&amp;self) -&gt; *TyDesc { get_tydesc::&lt;Self&gt;() } fn as_void_ptr(&amp;self) -&gt; *Void { self as *Self as *Void } } impl&lt;'self&gt; AnyExt for &amp;'self Any { fn is&lt;T&gt;(&amp;self) -&gt; bool { unsafe { self.tydesc() == get_tydesc::&lt;T&gt;() } } fn ref_as&lt;'a, T&gt;(&amp;'a self) -&gt; Option&lt;&amp;'a T&gt; { if self.is::&lt;T&gt;() { let pobj = unsafe { std::cast::transmute(self.as_void_ptr() as *T) }; Some(pobj) } else { None } } } 
Updated the gist to use less unsafe, enable moving out of owned trait objects, and have a ~~less weird~~ different name for `ref_as`. EDIT: Updated the gist a few times since then. It now works without assuming anything about the trait object memory layout, and compares the typedescriptors directly.
You're right, that should work. Brb implementing this :)
Updated gist with this :)
An interesting idea, but sadly doomed to failure. This parses like so: tag(~"html", ~[tag(~"head", ~[tag(~"title", ~[text(~"This"), text(~"is"), text(~"the"), text(~"title"), text(~".")])]), tag(~"body", ~[tag(~"p", ~[text(~"This"), text(~"is"), text(~"some"), text(~"text")])])]) The notable problem is of course that `title` and `.` are two separate tokens, and unavoidably so. As for the full HTML5 specification—if it weren't for the tokenisation aspect, you could probably parse it all, but it'd be a monstrosity!
Which particular recommendations is your text editor forcing you to avoid? That suggests the editor configuration needs improvement.
Slightly relatedly. The following line works very well for formatting for f in `find -name '*rs'`; do rustc --pretty normal $f &gt; /tmp/pretty &amp;&amp; meld /tmp/pretty $f ;done
&gt;Which particular recommendations is your text editor forcing you to avoid? That suggests the editor configuration needs improvement. https://github.com/mozilla/rust/wiki/Note-style-guide#function-declarations is my only gripe. The newline on each parameter confuses Sublime and it doesn't offer code folding for that function, which is useful.
Love You! Macros
Sadly that doesn't work on stupid windows.
One thing that has been puzzling me, how do you enable extra compiler warnings? I want keep compiler as tight as possible.
Portland ahoy!
`rustc -W help` lists all the possible lints (the name for rust's compiler warnings). There isn't a `-Wall`/`-Wextra` equivalent yet, but `-Werror` is `-D warnings`.
Thanks for your feedback. Well, I am also not a friend of overly big method chaining i.e. complicated combinations of date manipulations, but recognize that some people like this style. Tutorials should present the most common and simple examples as easy-to-use use-case. The items you have mentioned what a library should support are very reasonable for 95% and + developers. Parsing and formatting are relatively well implemented in JodaTime and JSR 310 - maybe the best libraries up to now on this area although I still see potential for improvements. I myself and maybe also Rust can look at these already implemented formatting and parsing strategies. About duration arithmetic, that is often one of the weakest parts of all libraries, especially when it is about multi-unit durations/periods. Here I see serious weaknesses even in JodaTime (see for example mixed signs on single partial amounts within duration =&gt; incompatible with XML-Schema). And JSR 310 is a regression compared with JodaTime on this area since it cannot even manage durations/periods of [3 days + 12 hours] and also does not offer any interval support, but other libraries are not better at all (just see Perl-Duration with its weird order of unit additions). I am not a wizard but hope for significant improvements in duration arithmetic in my coming library. Some things are impossible already in theory, for example: [date + 1 month - 1 month == date] is in some cases wrong, but at least this could be assured as long as day of month is smaller than 29 (what is not the case with JSR 310!). About high resolution timers I suspect that is strongly dependent on operating system.
XHTML requires full XML parser afaik, so I'm not sure if it would be really any easier than HTML(5) parsing.
Awesome! Small and elegant. This very interesting, will play with it.
I don't see why you couldn't have a macro rule for a tag's inner content to deal with that.
There's a missing entry! &gt; *Rustafarian*: a user of rust (And entries for *rusties*, *rustlers* and *rusticals*, etc.)
Also: &gt; Rustronaut: An explorer of Rust, the final frontier. Their continuing mission: to explore strange new crates, to seek out new traits and new idioms, and to boldly go where no one has gone before. Seems more fitting for the moment ;)
I like this one! *Rustonaut* or *Rustinaut* seem to roll off the toungue a little better though.
The problem is that by the time the macro gets it, the source is tokenised and there is no way of knowing whether the user typed `title.` or `title .`. This absolutely kills it.
*sigh*
&gt; How about "cRustacean"? Is that a guy that writes Rust bindings for C libraries? :D 
HTML is possibly ambiguous, I believe, at the very least HTML found in the wide is and browsers have all sorts of hack to guess how to interpret it :(
Pretty crazy, seeing a real production use of Rust at its current maturity level. But in an exciting way. Hopefully they don't have too much trouble keeping up with the language.
A lot of people want to know the answer to this question, and we're going to start talking about it soon. Contrary to some of the current wisdom, I don't believe that the milestones currently on GitHub describe any release, and the first major release will consist of a subset of all the existing milestones. There will be a major, backwards-compatible release in 2014, but the details aren't clear yet. I'll create a mailing list thread on this topic in the next few weeks describing Mozilla's current thinking on this subject and soliciting feedback.
I'm really ignorant here so perhaps this is a stupid question, but why are there no plans to make a serious desktop browser out of Servo?
That was covered by [the "example questions"](https://etherpad.mozilla.org/summit-sessions-saturday-understandingservo) for the presentation/Q&amp;A sessions associated with these slides at the summit: &gt; - Are there viability criteria? What is the timeline for deciding if Servo is worth continuing? &gt; - How much better (performance-wise) than other engines does Servo have to be considered worth continued investment? &gt; - What does success look like? &gt; - ... [several other similar ones] ... So presumably these were answered in some form or another. However I haven't yet heard wind of the summit sessions being online yet, so I personally don't have any answers (yet).
Surely because that's how R&amp;D works - you provide resources to a project during the early phases, at some point assess how it worked out and at that point evaluate whether it makes sense to produce a product based on that work. It is far too early in Servo's life to asses how well it has worked out as a project, but looking at the commit logs and public announcements about e.g. Samsung's contributions it doesn't seem to be starved for resources.
Samsung is working on the Tizen mobile OS which has html5-based apps. Are they interested in rust, because they may want to run these apps on Servo? http://www.computerweekly.com/blogs/open-source-insider/2013/08/tizen-is-your-next-html5-mobile-operating-system.html
I believe none of the breakout sessions at the summit were recorded (our Servo one in Brussels wasn't). That said, you can always ask questions in #servo. At least, after we're all back from being scattered to the various Mozilla summits by Tuesday or so :-)
Servo is a very interesting project and at the perfect moment for anyone interested in contributing into Open Source. Or adding a new project to their contribution list. The community is extremely helpful and welcoming. The amount of contributors is small enough to have easy bugs available for people who like those. The project is at an early stage, so amazingly interesting tasks are up for grabs. The goal is very big and wide, so there is a lot to learn in very varied topics.
Thanks! This is an excellent resource.
I left a question about it as a comment on the post, and nobody has approved it yet.
Oh :( Would it be possible for someone to at least write up some answers to those example questions? (On the servo ML or otherwise)
I've not heard anyone in a position of authority say anything about using Servo in mobile Firefox. **If** (if if if) Servo ever replaced Gecko in Firefox, I see no reason why it wouldn't do so on all platforms. That said, Servo will eventually be a reasonably-complete and reasonably-standards-compliant layout engine in its own right, regardless of whether it ever makes it into Firefox. And since the goal of Servo is to be embeddable (like Webkit, unlike Gecko) it could theoretically take on a life of its own outside of Mozilla, or serve as the base of a Mozilla-branded version of Phantom.js. Let's not limit ourselves to thinking that getting into Firefox is the *only* use for a new layout engine!
Twice now I've written and then deleted 10,000 character screeds on the strategy behind Servo. Here's my third attempt at being hitting the points that nobody has mentioned so far: 1. If all browser engines are single-threaded, it means that we accidentally and constantly bake the idea of single-threadedness into web standards. This has happened, and will continue to happen, unless we put some thought into writing standards that are amenable to concurrency. 2. Testing out radical new ideas in Gecko is very hard. Servo will be a playground for potential approaches to parallelism to validate them before they are ever attempted in Gecko (though many things that Servo will be able to do will be effectively impossible in Gecko). 3. There's a lot of research being done, and a lot of research yet to do, on approaches to parallelism on the web. Servo is blazing a trail here and even if it never sees widespread use itself, it will undoubtedly be the original inspiration for any truly-concurrent browser that ever does arise. 4. As I mention elsewhere in this thread, Servo will be embeddable, unlike Gecko. Even if Servo never replaces Gecko in Firefox, it will still provide an alternative to Webkit in this space, which is a win for web standards.
I'm interested in feedback, especially about these things: * Are its use cases and usage clear? * How is the API style? * Is it already possible to do everything here with `std` and/or `extra` without too much call-site code? * Is the implementation too "thick" or confusing? * Is it well packaged for the latest rustpkg? * How is the code style? EDIT: Grammar
If the original dude had intended "guys" to be gender neutral, he would've had no reason to respond "boobs or gtfo". In retrospect, her belief that he was not using it in a gender-neutral way seems right on. Considering how things turned out, it's preposterous to me to lay any sort of blame on *her*. &gt;You're just trying to start drama. Since neither of us are blessed with the power to read minds, let's take a look at what she wrote about starting drama, then, to get some insight as to what she's thinking. &gt;But here's the thing: every time I point out something like this in a community I'm part of, whether it's the Rust community or any other, there's a part of me that insists on first checking to see how much social capital I have to spend there. How high up am I on the contributors list? Have I contributed to the next release yet? All right, I guess it's okay for me to say something -- as though it hurts the project to speak up about a community problem! And so I have a double-entry accounting system in my head for amount of code contributed and amount of abuse reported, and it's terrible and broken that I feel that that's necessary. The only qualification that any of us should need to be treated with humanity is that we are human. Does that sound like someone who wants to start drama? It rather sounds to me like someone who takes pains to avoid it because it might reduce her capacity to contribute to the projects she loves.
It's called starting flames, it's like acting offended when someone says "thank God".
Hear hear! As a community member, I was quite disheartened to read Lindsey's post and hear about the behavior that she was subjected to. Overall I think the Rust community has been very positive and welcoming, and I'm really glad that the Powers That Be are taking steps to try to preserve that.
Most things in rust are either errors or the warning is on by default. There are a few that are off, but generally it's unlikely that there is much code that is **technically** correct but often indicates a bug.
My heart dropped out of my chest when I read that this had happened on our beloved #rust. Lindsey makes note of the jokes afterward that such an event means that Rust has finally grown large enough to start attracting the trolls and assholes. This, honestly, is something that I've been dreading for some time. In order to better prepare our community for continued exposure to the wider web, I've written a post to clarify the code of conduct that we enforce here: http://www.reddit.com/r/rust/comments/1nvsdh/a_note_on_conduct_please_read/ If you have any questions, ask.
&gt;No, but what purpose does this blog post serve? Awareness of this kind of social problems which shouldn't exist in modern day, but still do. The only way to fix it to bring awareness and shun those who can't adhere to gender-neutrality and non-sexist behavior.
The response Lindsey got is, of course, totally unacceptable. *However*, I am also questioning her motivations for challenging this guy. She said herself that the word "guys" is acceptable for addressing a mixed-gender group. So I can't help but think that by raising this issue out of the blue like that, she was venting some prior frustrations. This, too, is a bit less than a totally friendly conduct, wouldn't you say?
I want to explicitly chime in and say +1 to having a positive experience with the community. People are friendly, respectful, willing to ask/answer questions, share, etc... It's a very rich environment to learn in. Let's keep it that way and make it even more awesome! One way to do this is by not letting anti-social behavior slide by in silence. That's how the norms and expectations sink to the lowest common denominator. If you notice feeling uncomfortable about something, and it's your habit to just keep quiet, just try saying: "I feel uncomfortable." That's it. This takes much less effort when the issue doesn't *directly impact you*. If you're subjected to discrimination, then it can require *a lot more effort* to address it all day every day. If you are not directly subjected to it, but you find it unacceptable, you can help a lot with a little effort to shift the norms in the right direction. I hope when newcomers see this subreddit, the IRC channel, or any other rust community forum they'll see this sense of mutual respect, sharing, and hacking. EDIT: Pointed out the amount of effort depends on whether you are a target or a bystander.
The requirements were the following: - Fast. - No GC pauses. Not critical in our case, but good to have in a stream processing system. - Safe. In our case, it was mainly about not having to worry about memory leaks. - FFI, so that we can easily reuse the libraries that we are already using extensively. - Multicore friendly. Most consumers are just simple filters, but producers have to parse a lot of raw DNS packets, and really need to spread the load across all available CPU cores, while still accessing some shared data. Rust fulfills all these requirements, so it was a good opportunity to give it a spin as an alternative to C/C++ The language is a moving target (I'm changing "float" to "f64" everywhere as we speak). However, it makes it easy to write production-ready code. The standard library is excellent, and Rust respects the principle of least astonishment, if only by being strongly typed. The compiler is constantly bitching about pointer types and moved values. But once the code finally compiles, you can be pretty sure it will be solid and will work as intended. Long debugging sessions with Valgrind are not needed any more, and overall I feel more confident about deploying Rust code to production than C/C++. 
&gt; Long debugging sessions with Valgrind are not needed any more, and overall I feel more confident about deploying Rust code to production than C/C++. This was always one of the benefits from Ada/Modula-2 and their descendents. Sure they are stronger typed than C and C++, but the lack of their safety in C and C++ requires the use of third party tools, because even the best developers make errors. Looking forward to see languages like Rust becoming more mainstream.
I disagree. It's never "simply a request to be more aware" in cases like this. I think everybody understood that this was her passive-aggressive way of saying "I am offended by your usage of word 'guys' to address this group". Pretending otherwise is disingenuous. Her interjection was completely tangential to the issue being discussed, and it was completely predictable that the guy it was directed at got upset. Yes, his sense of humor is questionable. But Lindsey should also consider not injecting remarks like that into a technical discussion next time.
What would be your reaction if somebody was to post about a rust port of http://weboob.org/ called rust-weboob. Or the many other similar examples (for instance somebody creating an "alexandra" filesystem might have a fsck-alexandra command...). Eventually these will show up (as they did elsewhere) and some people will be offended (rightfully or not, that's not the point). Should reddit be held to the same rules than IRC? 
&gt;If the original dude had intended "guys" to be gender neutral, he would've had no reason to respond "boobs or gtfo". In retrospect, her belief that he was not using it in a gender-neutral way seems right on. Considering how things turned out, it's preposterous to me to lay any sort of blame on her. The alternative is actually even worse in my opinion. If it was meant neutrally at first, and when asked to reconsider their word choice, chose to be defiant and proudly ignorant about it. Even more irritating and just incredibly frustrating behavior to me.
I don't think there's a consensus for that.
Wow, it's really cool of you to project your own problems on other people and effectively put words in their mouths.
&gt; loop has been removed. The transition to continue is complete. What's the correct way to do `for (;;) [}` now? &gt; Gearing up for its removal, all fmt! usage in the compiler has been removed. What's the correct way to format strings now?
I think this is a reasonable question that deserves an answer. Let me explain why you should not question Lindsey's motives here: 1. This is not the first time that we have issued this challenge in the channel. Tim Chevalier (tjc, a full-time Rust developer) is the one who started this trend, years ago, and who continues to make this correction all the time. This sort of thing has precedent, and is not "out of the blue". 2. I don't think you'll disagree with me when I say that all open-source communities are historically male-dominated. This has the potential to (quite by accident) become a self-perpetuating cycle. It's true that when someone hops into our channel and says "hi guys", we cannot assume that they're using it in bad faith to mean "greetings men". But we also want to emphasize that our community involves women, and that we try to make more of an active effort at this than other open-source communities do. The "not everyone here is a guy" assertion is usually met with some variation of "oops, sorry :)", in which case the use of "guys" is obviously intended to be innocuous. But when it's met with "boobs or gtfo", it's pretty clear that this person doesn't give a shit about women in the community, and we'd rather not associate with them. In short, it's a (very crude) litmus test for whether or not you're a decent human being. 3. There is a debate to be had over whether or not "guys" is an appropriate gender-neutral collective noun. This subreddit is not the place to have that debate. However, please at least *recognize* that women are capable of feeling left out when they are part of a group met with this greeting. Regardless of whether or not you think they're wrong, if you value their participation and if you value their contribution to the group, you have to also value how your behavior makes them feel. Personally, I stopped using "guys" in a gender-neutral context when I realized that I would never point at a lone woman and say, "look at that guy over there". It just struck me as internally inconsistent.
We're not going to erase links to projects just because they have childish names. We're going to hold reddit to our own standards, regardless of what happens on IRC. They are different mediums of communication with much different purposes. That said, a basic level of respect for fellow community members is expected of both communities. I expect women to respect men just as much as I expect men to respect women.
To clarify, here's the comprehensive list of what's changing as of today: 1. Nothing. I have always held this subreddit to these standards, and have never been afraid to issue bans when I spy caustic behavior. The only difference is that now I'm making these rules more transparent. If you have questions, concerns, or suggestions, feel free to voice them here.
&gt; What's the correct way to do for (;;) [} now? `while true` ?
Using "guys" to refer to a group that includes women doesn't make you a kitten-drowning superhitler. I'm not going to ban anyone for using it as such. But I do appreciate it if you stay mindful of the fact that many women find it off-putting. EDIT: I just want to clarify that, yes, I would ban you if I found out that you were a kitten-drowning superhitler. EDIT 2: I want to further clarify that I would almost certainly ban you if you were any kind of superhitler, regardless of your stance on kittens.
As someone who hasn't looked at the state of the stdlib in a long time, I'm baffled that you'd refer to it as "excellent". :) Care to elaborate on what you like about it?
&gt; **guys** *plural* &gt; 2 - (*colloquial*) Persons, irrespective of their genders. &gt; 3 - (*colloquial*) A form of address for a group of male persons or a group of mixed male and female persons.
I think kitten-drowning absent being a superhitler should also merit a ban. As should being normal, un-super Hitler. Various kinds of subhitler shouldn't escape scrutiny either. So maybe: "being a kitten-drowning superhitler is a sufficient but not necessary condition for being banned".
Be aware that we have an international community here, so "strictly by dictionary" doesn't always help. So, if you want to argue semantics: I mentally translate "Hey guys" to "Hey Jungs!", which is strongly male. Sorry, but I can't help it.
But what if I was a drooling moron, that fired holo kittens from a cannon? http://images3.wikia.nocookie.net/__cb20121005031509/awesomenauts/images/c/ce/DerplZork_Alpha.png 
`loop {}`
Thanks, tikue. Your version definitely looks a lot cleaner than mine. I wrote this version quite a long time ago, about 0.4 / 0.5, and I wasn't aware of some of the types and functions you've used. Do you mind if I update my code with some of the enhancements in yours?
being a german speaker also, I did a similar thing and "hey guys" was confusing. I eventually got used to the fact that in english it's often used to address groups of both genders. No it turns out that not everyone thinks so and it's time to find another alternative.
The prospect of calling a product Firefox and having it use a different layout engine depending on the browsing device does not thrill me.
“not everyone thinks so” does not mean that there is a problem. If any non-native speaker (like me) has a problem with that it should be sufficient to politely refer to the next dictionary. Although I totally agree that naming a group of people as “ropes attached to something as a guide” can be regarded as being impolite (see http://www.merriam-webster.com/dictionary/guy). So finding a word that is less ambiguous would be desirable.
North Alabama. 
&gt;And the experiences she's had have a big part in her emotional reactions to things that happen. If you had had the same (or analogous) experiences, I think it's very, very likely that you would react in a very similar way. Everyone has problems but try to overcome them, instead of letting them haunt you for the rest of your life. Unless she suffers from PTSD, then I suggest her to be more careful when picking off-topic arguments, because people have no way to know they could trigger her a panic attack by choosing the wrong word. &gt;Someone uses language she feels somewhat alienated by; She alienated herself the moment she thought he was alienating her in any way. It's not a problem of equal consideration, I really doubt if she answered his question he would've gone "sorry, I wasn't talking with you, woman, I said *guys* not gals." &gt;she notes this politely. This means she's starting a gender equality war? &gt;*I hadn't been expecting this person to actually correct themselves, of course. But I had been expecting them to respond with something like "uh, 'guys' is a gender-neutral word", in which case my reaction would have been to shrug and say something like, "Yeah, I'm sure that's how you meant it."* I should have used the word argument, rather than war, I concede you that. &gt;The difference is that if "he" were to do so, in the world we currently live in, it would be unreasonable. Such is equality. Since women are enslaved and have no rights in the world we currently live in, let me give you another example. Imagine if she were a non-Christian person that called on someone over the usage of one of the many English idioms rooted in the Christian religion. &gt;It's easily possible to imagine a mirror universe where *men are oppressed and everyone says "she", without regard to their existence.* Is the reverse really what is happening here? Would the guy have ignored her answer just because she's a woman, if she gave one? &gt;How well would you like to think of yourself as an irrelevant hunk of meat attached to a penis? Is this what is happening here? Or is he just spouting a tired, old internet meme? &gt;And if this were someone's - of many someones' - default attitude in their interactions with you your dick? Kinda bad. I still wouldn't go shoehorning the argument where it's irrelevant. I hope in that mirror world there's some woman arguing against this sort of drama. &gt;I must have missed it. Where did anyone do this? &gt;*What happened was that when I made a polite request, a flood of hate came rushing out at me. And now it's hard for me to continue to pretend or assume that that hate doesn't boil under the surface of our community.*
&gt; println!("{} {} {:10.10f} {a:s}", 10, "foo", 1.234, a="bar") Am I correct in understanding that we get k/v style arguments on macros, but not on functions?
It doesn't compare to Ruby or Python stdlib, but it provides a lot more than the C library. Maps, sets, lists, deques, bitmaps, queues, URL encoding are always required, but not provided by the C library. It's nice to have them all readily available in Rust. 
Is there anything that you didn't find in there that you think we should include?
&gt; In short, it's a (very crude) litmus test for whether or not you're a decent human being. So you are saying she did do it on purpose, right? IMHO, it is not very nice to go around issuing "litmus tests" to random people. Involving women in tech communities is all good, but they should also make an effort to be equals there. For example, I think she should have confronted the guy herself rather than immediately turning to mods asking to kick-ban him. Perhaps even she should have defused the situation by answering his unfortunate joke in kind (I really doubt he meant to offend). And then she blogs about this to the whole internet... Is she aiming to gain the notoriety of Adria Richards? That one worked out really well for all involved, didn't it? This whole episode is a classic example of why men tend to shun women in the workplace; not because their abilities are questioned or anything stupid like that. And by bringing attention to Lindsey's blog post you are hurting your own stated cause. Actually, if I were you, I'd just nuke this whole submission. &gt; This subreddit is not the place to have that debate This subreddit on the whole is not. But this thread seems like a fine place,- since we already started it. Let's keep all flames in one place.
&gt;So you are saying she did do it on purpose, right? That seems to be a deliberately antagonistic reading of the parent post, since no such thing is implied. Step back and think a bit before ranting! 
This is really great to see. The community around rust is part of what has impressed me much. Glad to see steps being taken to keep this an inclusive, supportive community.
What else should have been implied? She even admitted herself that she was prepared reply to the defense that “Guys” is gender neutral: “Yeah, I'm sure that's how you meant it.” Don't get me wrong. The response she got was totally inappropriate I do not want to defend that. But one should not deny that such things provoke rude answers. Imagine you enter a channel and the first reply you get is that you are being criticized for you correct (correct in the sense of rtfm e.g. dictionary) use of language. Awesome, isn't it? Like Kindergarden: “Look at this girl/boy he/she/it has a lisp, haha!!!” Even if I would agree that it is the right thing to do (I do not want to discuss this here, wrong place) I would agree with blah232 that it is not a totally friendly conduct and that at least nobody should be surprised that one may hit a wall while trying to change people's behavior.
"folks", that works. Thanks. I was already settling for "everyone", which is a bit clumsy imho.
I use "folks" all the time. It's a bit old-fashioned, but that gives the word charm! What's more, "folk" in English conveys a sense of membership and belonging (like saying "friends" or even "relatives"), in a way that "guys" or "people" do not.
Already submitted: http://www.reddit.com/r/rust/comments/1cykhh/a_taste_of_rust_lwnnet/ But furthermore the version of Rust they describe in that article is so old as to render the article itself almost useless. :)
&gt; “not everyone thinks so” does not mean that there is a problem. Sure! The thing is, I have two choices here: I can be stubborn about it and knowingly use a word that some people find annoying, offensive, whatever -- or I can just let it go, use a different word and everyone's happy. I'd rather make everyone happy. Problem solved. BTW: I THINK that I'm not being impolite by using the word, after all, I measure politeness by the intentions. But I do know that some people will understand the word differently (and, in the worst case, also judge me for using it). Therefore, I avoid it. Language is not only about getting information into other people's heads, it's also about making people feel welcome, included, like you, enjoy themselves. If we could stop those "but why is it suddenly not ok any more to say this" and just try to accommodate each other, everything would be so much easier. BTW, anecdote time: I actually met Lindsey this summer in RL. In a conversation, I mentioned something about people having to be better "salesmen". In my mother tongue, that makes more sense, while in english you have the perfectly fitting word "salesperson". Lindsey answered, stressing the word "salesPERSON" and I felt a bit stupid at first but I don't think that anyone on the table except me and her noticed. I thought this was a really smooth move :). If she reads this *and* has a good memory, she now knows my reddit handle. Hi!
Sure! I don't mind at all. :)
Oh sorry. I am new here. Was interesting read to me though :(
Actually, reading the article again it doesn't seem to be *too* out of date. They mostly stick to describing fundamental features that haven't changed much since April. If you're looking for a more up-to-date resource, I recommend the Rust tutorial: http://static.rust-lang.org/doc/master/tutorial.html
What is the PermutationIterator struct? I'll take a look at it and see if I can come up with something, but my guess is that you're not an idiot at all and this is simply a tricky thing to get right. :O)
Yes, the k=v args are specifically implemented by these formatting macros.
The Permutations iterator in vec is a little weird because it uses another iterator to generate pairs of elements to swap. But the key part is in next(): Some((a, b)) =&gt; { let elt = self.v.clone(); self.v.swap(a, b); Some(elt) } What I'd like to be able to do is avoid the call to self.v.clone(), by returning a reference to self.v. Allocations and deallocs are tolerably fast, but 30 million of them start to add up.
I don't think the issue is actually around the definition or usage of "guys". If everyone in the community were completely comfortable with that (or any other term), then great! The issue is all about respecting people when they voice discomfort or request more awareness. Also, it's not the case that any person can suddenly ban a word. It's not about words, it's about awareness. So even if any [Knights who Until Recently Said "Ni!"](https://en.wikipedia.org/wiki/Knights_who_say_Ni) show up, the goal is that we all figure out how to be aware of, and respectful to, various backgrounds.
I absolutely agree, hands down, that the behavior of the individual in question was unacceptable. I applaud the moderators for reacting the way they did and for reiterating a sane and positive conduct policy. That said...I feel the need to concur that for *most English speakers*, the informal word "guys" is intended to be gender-neutral when used to address a specific group of people. I and others I know (of every gender) use it every day to informally address groups of women, groups of men, or mixed-gender groups of people. I do not know Lindsey, but out of politeness I will attempt to never use it around her. But if I did, it would *absolutely not* be because I intended to address her as a man. * [English Stackexchange thread on the topic.](http://english.stackexchange.com/questions/11816/is-guy-gender-neutral) * [Onelook](http://onelook.com/?w=guys&amp;ls=a) links to many online dictionaries. Without any exceptions that I saw, they all have a secondary definition that specifies that the plural can be gender-neutral.
&gt; Additionally, people in the gamedev community are starting to hit walls with the type system. In what way?
&gt;But one should not deny that such things provoke rude answers. I not only should, I do! The vast majority of times it *does not* provoke any such rudeness, which is what made this incident anomalous. &gt;Imagine you enter a channel and the first reply you get is that you are being criticized [This is not criticism!](https://botbot.me/mozilla/rust/msg/5544750/) It's a polite request.
I've heard they are, but haven't seen any results posted publicly yet. It is fascinating, though! How does that approach scale to hundreds to thousands of iframes on a page? And if they're not running into the same issue, then presumably the script engine is being shared between those frames, which can address that problem but likely requires some major tweaks to the script engine. I'm eager to hear how it turns out and am glad they're working on it, as parallel iframes are good for the web (e.g., remove one of the reasons people use flash for ads; allow people to write new types of pages; etc.).
I found this document: http://www.chromium.org/developers/design-documents/oop-iframes As I recall, the invasiveness of this change was one of the motivations cited for the Blink fork. ...wow, the rendering design doc is intimidating.
I believe most of the "walls" are things like a lack of function overloading except via traits, and no language-level default arguments, i.e. things that make a direct conversion from other languages (normally C++) difficult.
Rusti has been broken for longer than that...
I've seen some people take Option&lt;T&gt; as an argument as a way of doing a default paramater. If you pass Some&lt;T&gt;, it uses it. If you pass None, it uses some default.
This. I have to agree, I would feel extremely unwelcomed if the first thing upon entering the channel someone I do not know comes out with a snide remark about a general word I used. It seems this person was obviously using it in the general context which most people in my experience do (including myself). No disrespect was meant, but you chose to bait him the first thing. Now, what he did was obviously very wrong but I stopped reading your article after I read that bit about the "guys" thing. Honestly, it seems rather pretentious and rude considering you don't even know this person when they are clearly using a word (albeit wrong in your view, but it is part of common vernacular) to denote an inclusion of EVERYBODY. I dunno, just really irked me and made me lose respect for the argument after that. I really hope if I one day decide to venture onto IRC to this channel I don't have to deal with my choice of words, that are common to me, being scrutinized over little differences. Seriously, its not that big of a deal, and if it is befriend the person and then maybe you could explain your viewpoint since yours is DEF in the minority (not that it makes it right, but it's such a trivial issue to nitpick about). I mean really, I found this subreddit and programming language like 15 minutes ago and I already feel like people are walking on eggshells around here
"Folks", as in "Ein Volk, ein Reich, ein Fuehrer"? (just kidding)
"Y'all" works nicely as well. :) 
Traits are hard. You can't specialize implementations. If you do implementation of a trait on some generic type, `impl&lt;T&gt; Trait for T`, then it is impossible to implement that trait on any other, more specific types. If you do a generic implementation of `T: Real`, then you can't specialize for specific built in types in order to take advantage of intrinsics and inline-assembly. You can't overload trait implementations either. This is hurtful to the point of making operator overloading useless for any serious mathematics. For example you can't `impl&lt;T&gt; Mul&lt;T, Mat4&lt;T&gt;&gt; for Mat4&lt;T&gt;` and then also `impl&lt;T&gt; Mul&lt;Mat4&lt;T&gt;, Vec4&lt;T&gt;&gt; for Mat4&lt;T&gt;`. This is a specific use case, but there are others, including implementing a generic conversion trait between types. I'm not sure how Haskell handles this, but maybe it is alleviated by the fact that you can specify your own operators. The lack of being able to use constants at compile time, and the lack of compile time function evaluation, and the lack of templates hurts. It means that in order to provide lightweight, zero cost abstractions (which is what C++ and D excell at), we must do lots of additional hand-writing of code. Macros can help, but these are very brittle beasts to wield, and the APIs that result are inflexible. Composability of functions is an issue. You can't write `vec.iter().map(num::abs)` because abs takes a parameter by value, where the function the `map` expects has a argument that is a reference. These are all tricky issues. Solutions like overloading and templates might cause unforeseen interactions that could break the type system. I don't know enough about type theory to be able to make any comment on that. Perhaps there are other ways to solve these issues.
The numerics issue is a mess also in Haskell, but yes, you're right that being able to make up arbitrary infix operators help. I asked a while back that rust has a proper algebraic hierarchy, but it had been discussed and thrown out again. I'd like to point out that numerics is precisely why: matrices and vectors are modules over (almost) rings, and trying to hide this is not helpful. I've seen decades of attempts in game development that tries to fudge around this when developing numeric libraries, but they all give up eventually. Please look at the alternative Haskell preludes, and avoid making the same pitfalls as every language so far. 
also "gang"
AFAICS they are not opposed to default arguments, but they already have a lot of stuff on their plate: &gt; The team also decided that resolving this in any fashion is not a priority for the 1.0 release. Project lead brson suggested that we leave prototyping anything on this task for post-1.0 (e.g. for a 1.1 release). &gt; &gt; So that is a strong hint to all contributors: hack all you like, but please do not submit pull requests or r+ anything for this bug until post 1.0 release. https://github.com/mozilla/rust/issues/6973 
Have you considered using the managed pointer type? I wrote a toy iterator to recreate the issue you were having, then I changed the iterator to use @[int] instead of ~[int] as the return type. I'm still very new to Rust, so please pardon any newbie-isms in the following: use std::iter::Iterator; use std::at_vec::to_managed; struct TestIter { times:int, values:@[int] } impl TestIter { fn new(values:&amp;[int],times:int) -&gt; TestIter { TestIter { times:times, values:to_managed(values) } } } impl Iterator&lt;@[int]&gt; for TestIter { fn next(&amp;mut self) -&gt; Option&lt;@[int]&gt; { if self.times &gt; 0 { self.times -= 1; //TODO: manipulate self.values in-place here Some(self.values) } else { None } } } fn main() { let data = ~[1,2,3,4]; for x in TestIter::new(data,3) { for y in x.iter() { print!("{} ",*y); } println!("") } } I think what's going on is that you're being forced to .clone() the ~[int] vector due to Rust's static analysis of pointer escaping rules. My guess is that there's too much opportunity for a non-cloned pointer to escape into some dark corner where it can outlive the iterator and cause unsafe operations. Your self.permutations vector is used all over your iterator definition, while that lonely clone is simply passed back and not used within that scope. Meanwhile the managed pointer has no such problems, so it's given a free pass. I realized that this is how you solve this problem in other languages. Python, D, Java, and C++ (shared_ptr), all fortify against un-trackable pointer movements by way of a GC or ref-counting of some kind.
I'm surprised it hasn't been mentioned, but maybe because it's too obvious: have two separate functions, one with the extra parameter and one without (which calls the other with the default argument). Gets somewhat awkward if there are many default arguments on the same function, but (a) I don't believe that's common, (b) it's probably not good practice either, and (c) you should usually be able to choose a convenient subset of the possibilities instead of every possible prefix or combination of parameters.
&gt; If you do implementation of a trait on some generic type, impl&lt;T&gt; Trait for T, then it is impossible to implement that trait on any other, more specific types. If you do a generic implementation of T: Real, then you can't specialize for specific built in types in order to take advantage of intrinsics and inline-assembly. I *think*, if the intent here is that the generic and specialized implementations have the same behaviour, with the latter only being better optimized, that GHC/Haskell solves this problem using rewrite rules. &gt; You can't overload trait implementations either. This is hurtful to the point of making operator overloading useless for any serious mathematics. For example you can't impl&lt;T&gt; Mul&lt;T, Mat4&lt;T&gt;&gt; for Mat4&lt;T&gt; and then also impl&lt;T&gt; Mul&lt;Mat4&lt;T&gt;, Vec4&lt;T&gt;&gt; for Mat4&lt;T&gt;. This is a specific use case, but there are others, including implementing a generic conversion trait between types. I'm not sure how Haskell handles this, but maybe it is alleviated by the fact that you can specify your own operators. This is the whole `MultiParamTypeClasses`, `FunctionalDependencies`, and `TypeFamilies` issue (in case you've heard of it). In Haskell, you could write `Mul` several different ways: class Mul rhs result self where -- 1 (*) :: self -&gt; rhs -&gt; result class Mul rhs result self | self -&gt; rhs result where -- 2 (*) :: self -&gt; rhs -&gt; result class Mul rhs result self | self rhs -&gt; result where -- 3 (*) :: self -&gt; rhs -&gt; result class Mul self where -- 4 type Rhs self type Result self (*) :: self -&gt; Rhs self -&gt; Result self class Mul rhs self -- 5 type Result rhs self (*) :: self -&gt; rhs -&gt; Result rhs self *2* and *3* are mostly equivalent to *4* and *5*, respectively, using different language extensions (`FunctionalDependencies` in the first case, `TypeFamilies` in the second) and hence different syntax. With *1*, you can have instances for any combinations of types you like. The functional dependencies in *2* and *3* say that the types on the right of the arrow must be fully determined by the ones on the left: for example, with *3*, if you have `Mul r res1 l` and `Mul r res2 l`, then res1 and res2 must be the same type (on the other hand, if `Mul r1 res l1` and `Mul r2 res l2`, then r1, l2, r2, and l2 could be different types). `TypeFamilies` makes the same thing more explicit, by writing the determined types as a function of the types which determine them. This is Haskell's version of the associated types feature which has been talked about for Rust. `TypeFamilies` is *usually* clearer than `FunctionalDependencies`, but it's also usually more verbose, considerably more awkward for encoding bidirectional dependencies (`a -&gt; b, b -&gt; a`, where you have to introduce functions in both directions and require a type equality constraint between them), and requiring the associated/dependent type to be a particular type is also more awkward: going with *2* and *4*, if for whatever reason you want a `Mul` constraint where the rhs and result are both `Int`, in one case that's `Mul Int Int a`, while in the other it's `(Mul a, Rhs a ~ Int, Result a ~ Int)`. Rust currently allows only one way of doing it, which corresponds to *2* (all type parameters must be determined by `Self`). However, all of the (semantically different) possibilities are useful in different cases, so it's not just a question of "should we have them be determined by `Self`, or should we not". We should have both, the question is how. &gt; The lack of being able to use constants at compile time, and the lack of compile time function evaluation, and the lack of templates hurts. What's your definition of "templates", as opposed to "generics"? Not being able to abstract over compile-time constants is indeed a shortcoming, but one that seems like a relatively straightforward one to me. Do you know how D solves the thorny problems of CTFE, like nontermination, exceptions, and side effects? Do they just inspect the body of each function to see if it's appropriate, or is it indicated in the type of the function somehow (and is the body checked against it, again somehow)? &gt; Composability of functions is an issue. You can't write vec.iter().map(num::abs) because abs takes a parameter by value, where the function the map expects has a argument that is a reference. Yeah. In Haskell you would precompose the deferencing operation with `abs`, and it would look like `abs . deref`. You could do it similarly in Rust, given `fn deref&lt;T&gt;(a: &amp;T) -&gt; T { *a }` and an appropriate `compose` as `compose(num::abs, deref)`, but that fails to be an improvement over `|n| num::abs(*n)`. I expect the same is an issue for methods versus top-level functions. I wonder if we could have syntax like `Type::method` which returns the method as a plain `extern fn`. (I just checked: we don't already, but the error message is awesome.)
&gt; //TODO: manipulate self.values in-place here This is the hard bit: it's impossible to do safely. Modifying `self.values` here is breaking the type system: `@[T]` is an immutable slot for `T`, so any modifications to things that inherit ownership, like when `T=int`, are illegal. You can use `values: @mut [int]` which allows modification of the contents of `values`, but using `@mut` exposes one to dynamic failure (i.e. situations that the type system cannot catch but still break memory safety, and so are replaced by a runtime check with a `fail!`). Also `@[]` and `@mut []` are very poorly supported by the standard lib. (This also means that holding a reference to the vector from a specific iteration will not keep a constant value, as it changes internally on each call to `.next()`.)
Calvin doesn't have soothing sounds of Stephen Fry http://www.youtube.com/watch?v=J7E-aoXLZGY
&gt; I wonder if we could have syntax like Type::method which returns the method as a plain extern fn. [#6974](https://github.com/mozilla/rust/issues/6974). &gt; the error message is awesome &lt;anon&gt;:7:51: 7:60 error: first-class methods are not supported &lt;anon&gt;:7 struct Foo; impl Foo { fn blah(&amp;self) {} } Foo::blah ^~~~~~~~~ &lt;anon&gt;:7:51: 7:60 note: call the method using the `.` syntax &lt;anon&gt;:7 struct Foo; impl Foo { fn blah(&amp;self) {} } Foo::blah ^~~~~~~~~ error: aborting due to previous error application terminated with error code 101 if anyone's interested.
&gt; You can't specialize implementations [#7059](https://github.com/mozilla/rust/issues/7059) covers this slightly.
It's not obvious to me that they're the same thing, but they're certainly related.
&gt; Do you know how D solves the thorny problems of CTFE, like nontermination, exceptions, and side effects? Do they just inspect the body of each function to see if it's appropriate, or is it indicated in the type of the function somehow (and is the body checked against it, again somehow)? D has the `pure` keyword that [places safety restrictions](http://dlang.org/function.html#pure-functions) on the body of a function. Only pure functions can be called at compile time. &gt; Pure functions are functions which cannot access global or static, mutable state save through their arguments. This can enable optimizations based on the fact that a pure function is guaranteed to mutate nothing which isn't passed to it, and in cases where the compiler can guarantee that a pure function cannot alter its arguments, it can enable full, functional purity (i.e. the guarantee that the function will always return the same result for the same arguments). 
Oh, that bug describes something different to the [ML discussion](http://thread.gmane.org/gmane.comp.lang.rust.devel/2622/) linked in it (which is what you were talking about).
Ah right, thanks. I think that ML discussion is from just barely before I started following Rust.
&gt; Do you know how D solves the thorny problems of CTFE, like nontermination, exceptions, and side effects? How is nontermination a thorny problem? It seems it can be quite efficiently solved by pressing CTRL-C, basically.
A few expressions worked, but it was still a broken subset of the language.
I see, thanks. It seems they [do, also, look at the body of the function][1], though. Which seems kinda opaque and brittle. The main tension I see is between Haskell's notion of purity and what's necessary for CTFE (edit: which is basically C++'s notion of `constexpr`). In Haskell, you can compose unsafe, impure functions into semantically pure ones (much like Rust's `unsafe`). This is nice, but it's rather undesirable if you might want to evaluate the function at compile time. And if you need to have "does this use anything unsafe internally" reflected in the type, it basically defeats the purpose. On the other hand, disallowing it is too restrictive for runtime programming. It seems like D has been bitten by [exactly these problems][2]. (FWIW, for Haskell's closest equivalent to CTFE, which is Template Haskell, it basically solves this by designating CTFE itself as unsafe. A module designated `Safe` under `SafeHaskell` cannot use Template Haskell. But that's not so great, either.) I'm not sure if there's a good way to resolve this. It doesn't seem like anyone has found one. [1]: http://dlang.org/function.html#interpretation [2]: http://www.mail-archive.com/digitalmars-d-learn@puremagic.com/msg35152.html
Sure. But without CTFE, if your program can't be compiled, the compiler will exit and tell you why. With it, that no longer holds. It's not world ending, but I think it does qualify as thorny. You can kinda-solve it for infinite recursion by setting a maximum recursion depth, but infinite loops seem tougher. (On that note: can Rust macros recurse infinitely? If so, how does it handle this? I'm guessing a max recursion depth?)
Well, I mean, it's not going to come as a surprise, is it? You are a programmer, and you know you are executing code at compile time, and you know code can be non-terminating. You'd be a lot more surprised if you were executing code and it would never be non-terminating, really. It'd be different if you didn't know you were executing code. I guess that *could* happen with libraries if they are allowed to do tricky things behind your back with input you provide, and don't check it properly.
I believe one of the strongest arguments against is that it makes the error messages very unfriendly. Rather than dealing with a simple handful of classes/traits you end up with literals tens, all intersecting in complex ways. This is a genuine problem, and one that I don't know how to fix. In small teams of highly mathematical programmers, a bunch of references to rings and modules isn't a problem, but it's not clear that this can work "in the large". By give up, I mean people tend to give up trying to shoehorn matrix operations into the usual operators, or give up type safety, or both. Again, reasonable for a private code base where users can be be educated, but not ideal as the basis of a standard library. As far as I can see, #4819 is focused on the issue of primitive types, and exposing low-level functionality. That is actually almost independent of the matrices and vectors issue, and the grander problems of an algebraic hierarchy. At the heart of it, is the problem that we are taught how to do arithmetic as children, and we think it's easy. But a robust, safe, fast and extensible system of arithmetic suitable as the foundations of a language is not a solved problem yet. I think Rust is heading in the right direction, and just like Haskell, it will be possible to come up with alternative numerics hierarchies in the future, modulo network costs of refactoring existing code. Unlike Haskell, there might be enough impetus from game devs to push in that direction once it becomes necessary :-) Let's not go arch-astronauting just yet (esp. since the current stuff is not obviously worse than alternatives), and let that space play out in its own time.
I believe pcwalton had some thoughts about CTFE and "doing it properly", no idea what they were. &gt; (On that note: can Rust macros recurse infinitely? If so, how does it handle this? I'm guessing a max recursion depth?) macro_rules! foo { () =&gt; { foo!() } } foo!() If exhausting all my memory counts as "max recursion depth", then yes; otherwise, no, completely unhandled. (Filed as [#9765](https://github.com/mozilla/rust/issues/9765).)
Yes, this is exactly what I wanted to hear!
I'm surprised the manual ElementSwaps version performs so poorly. I didn't expect that. The premise of my Permutations Iterator was really that it could be implemented without copies -- which it could, but acrichto helped discover that was through a borrowchecker hole. So the fixed version that clones the whole vector for each iterator element is quite terrible. Pull req: https://github.com/mozilla/rust/pull/9062 most of the discussion was on irc, and the initial copyless version isn't available, I'll pastebin it if git still has it somewhere. [[Edit] Thanks git reflog: Buggy copyless permutations iter](https://gist.github.com/anonymous/228630efd73742e1a00c)
&gt; Now, what he did was obviously very wrong but I stopped reading your article after I read that bit about the "guys" thing. It's worth reading the rest. It may help you understand why she posted about it in the first place. &gt;I really hope if I one day decide to venture onto IRC to this channel I don't have to deal with my choice of words, that are common to me, being scrutinized over little differences. No doubt, if you are respectful and your words simply cause a genuine misunderstanding, I can't imagine you would be banned. The person this story is about was not respectful. Besides, using language precisely enough to not alienate others is no harder than using language precisely enough to manage side effects in imperative programming :)
&gt; I already feel like people are walking on eggshells around here I haven't observed any difference in behavior as a result of this event. And I think that's a good thing! It means that we've done a pretty good job so far at discouraging assholes from participating. Your assertion that people are walking on eggshells is unfounded. Be yourself, and on the off chance that yourself happens to be a jerk then I will ask you to stop. This is the first time in the subreddit's history that I've ever felt compelled to promote any story that was not technical in nature. I don't intend to make a habit of such detours into social issues. Now go write some damn code!
&gt; For example you can't `impl&lt;T&gt; Mul&lt;T, Mat4&lt;T&gt;&gt; for Mat4&lt;T&gt;` and then also `impl&lt;T&gt; Mul&lt;Mat4&lt;T&gt;, Vec4&lt;T&gt;&gt; for Mat4&lt;T&gt;`. This seems like a bug. I explicitly wanted to allow this.
Intent doesn't matter. The effect that your behavior has matters. It's an indicator of extreme, unexamined privilege to expect people to infer the intent behind your behavior rather than *you* doing the work of acting so as to communicate intent. -- Tim Chevalier, Rust core team member
Folks, we don't need to argue about this. All that needs to be said is that "guys" makes *some* people who are not guys, and *some* people who are guys (the latter would be me *waves hand*) feel unwelcome and disincluded. Since we are people who care about how other people feel, what's needed is to empathize with them and act based on that empathy, not to callously bikeshed about dictionary definitions that are incorrectly being interpreted as prescriptive. -- Tim Chevalier (core Rust team member)
&gt; I wonder if we could have syntax like Type::method which returns the method as a plain extern fn. (I just checked: we don't already, but the error message is awesome.) This is uniform function call syntax, and it is something I've wanted to do for a long time, but haven't had the time to implement it. It'll be a Rust 2.0 thing most likely. Regarding CTFE, I have a plan for how to implement it for Rust 2.0; I've spoken with erickt and others about it. My issue with D's CTFE is not that it's nonterminating or can have side effects, but rather that it plays fast and loose with phasing, making it not obvious when functions run. By adopting Racket's system of *syntax phases*, I think we can do CTFE in a principled way.
I really hope some awesome person comes up with a good, concrete proposal and posts it to the mailing list. I agree with comments made in the issue regarding good API's, but I also agree that Rust's core team has more important things to worry about -- so a miracle proposal would be awesome. :P
Language is the means by which we communicate intent. Using a common word or idiom in a common way is precisely the same as "doing the work of acting so as to communicate intent." The only "inference of intent" required is the same as is required to interpret *any* use of language. For example: If I say I am "eating an apple", most English speakers would reasonably and easily infer from context that I intended to communicate [something like this](http://i.imgur.com/1c7I7Ig.jpg), and not [something like this](http://i.imgur.com/CkQUydW.jpg). Similarly, if I address a group of men and women with the phrase "Hey, guys," most English speakers would reasonably and easily infer from context that I intended to use the well-recognized gender-neutral version of the word "guys". There is value in precision of language, of course - but I am not sure what the reason would be to willfully misinterpret someone's intent when context and shared language make it clear. I agree with you, though, that the effect of one's behavior is what matters, which is why I am willing to moderate my language based on the audience. There's no reason to intentionally offend or aggravate anyone when it is free or cheap to use different words. I would urge patience, however, since not everyone is aware of what language will offend whom.
This is about oppression, not offense. I don't know what kibwen thinks, but I think this thread is a bad place for an "anti-oppression 101" discussion. There are many resources for educating yourself. How about starting with http://geekfeminism.wikia.com/wiki/Category:Silencing_tactics and https://github.com/freenode-feminists/wiki/wiki/List-of-Educational-Resources:-Feminism ? When we have to explain the same basic logical fallacies (including the ones you're committing in these comments) over and over, it makes it harder to have a serious discussion, much in the same way that uncontrolled syntax bikeshedding on rust-dev makes it harder to advance the progress of Rust. I want to emphasize, again, that I am a core Rust contributor, because I want to make sure that people reading this thread know how seriously the team takes this issue. However, I am not claiming to represent the entire Rust team, nor am I saying that my opinions are shared by any particular person other than myself.
This is actually how default arguments are implemented in OCaml. For example (optional arguments must be labelled): let ?test = match test with | Some x -&gt; printf "gave %s" x | None -&gt; printf "nothing" While if you provide a default value: let ?(scale=1) x = x * scale But of course OCaml as no overloading whatsoever.
A comment on the crypto section: MD5 and SHA are often used as hashes for non-crypto purposes, such as verifying that files downloaded correctly (i.e., no transmission errors). It seems to me that removing functional code just because someone *might* use it for crypto when they shouldn't is not a good reason...
&gt;I want to make sure that people reading this thread know how seriously the team takes this issue It's really good to see the community around Rust develop and have the dev team step up and also help curate the community at large along with the language. Thank you for being involved!
I disagree. Saying "my mistake, I'll try to do better" is an *action*, and actions have an effect. You can say that even if you don't actually believe you made a mistake, and you can try to do better in the future with the motivation of not wanting to derail conversations, and still think privately that you weren't wrong. I'm much cooler with that than with someone who claims to mean well but keeps fucking up in the same ways. I think that's actually a great example of how intent is completely unimportant in interactions between people who aren't intimate friends with each other.
Yes I want to second this. I've been following Rust for a long time and on top of being a great language with a great team, the inclusiveness and professionalism has been a huge draw from me. I really appreciate the way the team takes their community seriously, and I am glad they came up with this code of conduct. Keep up the great work folks!
&gt;You can say that even if you don't actually believe you made a mistake, and you can try to do better in the future with the motivation of not wanting to derail conversations, and still think privately that you weren't wrong. Well, I mean... liars and trolls will always be an issue. Obviously if the kid keeps crying wolf and saying they won't... Same thing, if I keep saying I'll do better and don't try to improve, then that will be obvious in my actions. Maybe you could take a step back and address what you think should've happened in this case. I walk in and say "What's up guys?" and I literally have no recourse for improvement? I'm just a bad person and nothing I can do or try to do can change that? Now I'm really confused, you'd rather have someone faking cordialness than deal with a troll? I would... be more interested in separating out the trolls from the uninformed and helping the uninformed understand what you're trying to say. Understand what it means to be a welcoming part of the community and to be forward thinking about these things, rather than reactive "Oops, sorry, better next time". [edit: note, I wasn't the person in IRC. :P hopefully that's obvious, this is all hypothetical. just trying to understand. cheers]
&gt; immune to collision attacks *resistant* to collision attacks. (Being immune would require every input hashing to a different output, which defeats the purpose of hashing, and is impossible to do (for, e.g., strings) with a finite output space.)
Oh really? That's awesome!
Looking at the comments, it's rather saddening how many people don't seem to understand the value of Option types + non-nullable pointers, thinking that they either don't add value, or are too verbose. I wonder why that is, perhaps they don't make the connection that you only use Option when you need null?
If it's any consolation in my experience I haven't seen a lot of games use templated math libraries. Games primarily deal in floats so most vector, matrix and quaternion are just float (or simd float) specific.
&gt;I think this is, as I said in another comment, "anti-oppression 101" and maybe hence this is the wrong forum. /me nods. I can understand that. &gt;The tl;dr is that oppression doesn't happen because those of us who are marginalized aren't polite enough to people who are acting in ways that recreate oppressive social structures. Hm, not sold on face-value, I'll hunt down that sub-thread shortly and take a look at your discussion there. **edit**: I guess, I would agree that the way you express it makes it sound like victim blaming, as if someone told me I wasn't doing my job as a homosexual since I'm reluctant and not good at coming out in new situations. I do still think that unchallenged ignorance is a big problem --- but I think you're right in that that problem should be solved elsewhere - culturally, education, parenting, etc. &gt;The time to make sure of that is before it starts happening, because once it starts, there's no turning back. Absolutely, your post on implicit vs explicit was a great explanation of the value of that and how messaging and timing is important in setting the culture. Thanks for talking through all this with me. Cheers.
Hi, I just wanted to let everyone know I have decided that the word *bikeshed* offends me. I understand that the colloquial definition of the word is not offensive, but I have chosen to ignore the common meaning of the word and instead take it as disrespect. Please consider my feelings. Thanks!
Actually It wasn't the engine they rewrote from scratch but the browser itself. They actually bought the company that made Gecko.
I empathize with your plight. However, I don't see how we'll ever be able to comply with that request. Bikeshedding's just too important to us! Therefore, in the interest of your own well-being, I have decided to ban you from this subreddit. I sincerely hope you enjoy your newfound free time.
If `do` is going to be for `proc`s only, and `proc` syntax is going to be `proc { ... }`, are the `| |` going away in `do` syntax for consistency? `do something_with proc(args) { ... }` if you want arguments?
Ugh, he raises a valid point about the arbitrariness and subjectivity of this "rule", albeit shrouded in some snark, and he gets a ban for that? I'm going free from this sub too, thanks. 
It is not a polite request. It is rude to press your own not collectively accepted opinion of what is appropriate language onto other people (correct me if I’m wrong but I thought guys is acceptable gender-neutral for a native-speaker). Look at the reaction of other people in that channel. I can see three people who are at least slightly annoyed by that. 
&gt; BTW, anecdote time: I actually met Lindsey this summer in RL. In a conversation, I mentioned something about people having to be better "salesmen". In my mother tongue, that makes more sense, while in english you have the perfectly fitting word "salesperson". Well, thats another case. But sometimes it's difficult to “neutralize” a word. It’s just that some people get notorious about that (like CamelCasing the whole language -&gt; german) such that one can easily get annoyed by getting pointed to that matter. This is why I find it rude to point people towards that matter as long the word is not plain wrong.
Yes -- for precisely this reason, we're going to consult with security experts within Mozilla to make sure we're making the right choices here.
The `loop` keyword is useful because it lets you declare your intention to write an infinite loop. There are various dataflow analyses that take advantage of that knowledge. One of them was typestate, which is no longer part of Rust, but was the original reason for introducing `loop {}`. Others are imaginable.
Oh, right, the German thing is a great example. I don't write a lot of German these days, so it slipped my mind. I find the camel-casing pretty annoying, imho the best solution would be to find a balance: If more people would use the female terms generically, the average of the language is 'fair'. To non-german-speakers: The problem here, is that German is inherently gendered. Example: the word for "driver" does not exist without implying either male or female. It's either "Fahrer" for "male driver" or "Fahrerin" for "female driver". In situations where you're talking about a mixed group of drivers, the shorter one (male) used. This leads to genderized terms like "Fahrer/in" or "FahrerIn" which many people, including me, find very annoying because they mess with reading flow. My solution is to use "Fahrerin" in the first place (unless I forget, I'm not perfect), while many people would use "Fahrer". If we had 50% of people doing what I do and 50% using the male terms, I'd find that fair.
I am having a small time parsing this sentence, and due to just reading the banning above, you mean that the situation (I was tweeting about) is upsetting and that you are happy that we're tackling this issue, right? The combo of bad plus good in the same sentence and my lack of sleep (I'm on the other side of the planet right now, only got two hours of sleep due to that situation) is making my language facilities operate a bit slowly, sorry.
Thanks for your suggestion! I *hadn't* considered managed vectors. Unfortunately, now I'm struggling to copy a ~[int] into a @mut[]. (*Is* there a way to dynamically allocate an @mut[]?)
Cool. :)
I've proven myself more than willing to engage people who are capable of expressing their concerns maturely. See [this comment](http://www.reddit.com/r/rust/comments/1nvn30/regarding_behavior_in_irc/ccmjguj), which was sitting well below the collapsed-by-default downvote threshold when I chose to respond to it. Or ask /u/academician, who was banned and then subsequently unbanned after issuing a convincing apology for the offending remark. I'm happy to be reasoned with. Don't mistake that as a willingness to let myself get pushed around. So you're concerned that one of our rules is aribitrary and subjective? Which "rule" would that be? Perhaps you're referring to this quote of Tim's: &gt; All that needs to be said is that "guys" makes some people who are not guys, and some people who are guys (the latter would be me *waves hand*) feel unwelcome and disincluded. Since we are people who care about how other people feel, what's needed is to empathize with them and act based on that empathy, not to callously bikeshed about dictionary definitions that are incorrectly being interpreted as prescriptive. But... **oh no!** *Who gets to decide what words are okay and which words get you sent to the gulag?!?!?!!?* The answer is: anyone who can make a convincing argument (and convince *me*, specifically). OverAnalyzingBBFan chose to mock people who are socially disadvantaged (protip: these people actually exist) by arguing that their refusal to conform is somehow absurd. I have no obligation to enable that bullshit. If you have more concerns, you remain welcome to air them.
I started to create FUSE (filesystem in userspace) bindings for Rust a few months ago. However since libfuse does a lot of callbacks, it quickly became painful, so I ended up with rewriting the FUSE userspace library in Rust. Rust-fuse provides a nice interface for implementing userspace filesystems in (almost) pure Rust. It's still incomplete, but already provides most of the lowlevel libfuse api (enough to create working filesystems). Comments and thoughts appreciated, thanks :) 
That's a wart I had a heck of a time working around - I eventually had to stop around the time I posted back to this thread (above). I couldn't find any library Trait function/method that mapped to that operation. Then again, my C++ and D addled brain might be blind to some obvious rust-ism to do this job; the tutorials and manual were no help to me here. I *think* you have to iterate over the contents of the ~[int], and clone() each index into the @mut[int], to work around the immutability of the source value. Also, the managed vector needs to be grown/allocated to the size of the source vector before you loop; at first, I wasn't aware that mutable vectors don't grow automatically (again, C++ brain-damage at work here). Of course you could always re-write it to work *only* with managed mutable vectors, and make integrating to your code *someone else's problem.* But what would be the fun in that? **Edit:** Eureka! You must clone values across the mutable/immmutable barrier, and across the owned/managed barrier as Rust's assignment operator has move semantics instead of copy semantics. Upon considering of Rust's pointer ownership rules and mutability constraints, this problem makes complete sense. Of course, one cannot simply *cast away* the immutability property of a type as one would in C/C++. The values must be cloned to completely different places in memory as to retain the gaurantees set forth by those rules. The same goes for managed vs owned vs borrowed pointers. Managed pointers simply lack the scoping the other two types have, so once again, one must clone across that divide to get what you're looking for. **Edit 2:** To answer your question, I think you want this: http://static.rust-lang.org/doc/master/std/vec/fn.with_capacity.html
Usually experimental ones, or implementations of filesystems that cannot be integrated into the kernel for legal reasons (license/copyright).
There are quite a few listed on fuse.sf.net. Most of them are experimental indeed. The advantage of FUSE is that you are able run filesystems in userspace, so you don't need to face complicated kernelspace programming (e.g. If your fs crashes with fuse, it unmounts. If a kernelspace filesystem crashes, you'll most probably get a kernel panic). On the other hand fuse is probably much slower than a kernel fs. The most popular fuse filesystem comes with fuse itself and is called sshfs. If mounted, it allows accessing files from a remote host over a ssh connection. I've also seen some funny ones over the years, like filesystems that contain tweets as text files, image files from Flickr or temperature data from sensors. Almost anything is possible (however afaik nothing got really popular yet since things like bind mount, loopback mount and crypto have been included in kernelspace for a long time now)
Huh. Does LLVM's LTO have builtin knowledge about malloc()? On the surface that doesn't seem like a valid optimization. 
&gt; ASIDE: IMHO "guys" is about "people" in the same way that "mankind" is about "humankind". Wait, do you mean you're agreeing that "guys" applies to both men and women, or that you don't know that "mankind" actually does refer to the human race as a whole and not just adult-male-humans?
https://github.com/MicahChalmer/rust-fuse is another FUSE binding.
NTFS-3G is probably the most popular FUSE filesystem.
I mean that both words have a conotation that the default human being is male.
Very interesting. I was working on the same thing, but got it working via the C FUSE lowlevel API, despite the callbacks. (https://github.com/MicahChalmer/rust-fuse/). Given that you started working on it months ago, it seems we both started working on our projects in parallel, before either of us had announced it. The public APIs we came up with are similar and straightforward--we both use the same basic shape of providing a trait to implement the C API's functions returning Result. But your API is much cleaner, since by reimplementing the C userspace API entirely you've avoided the ugly hacks that I had to do in mine to work around what the C library does with callbacks. I was willing to take an uglier API to avoid reimplementing what the C library did, but now that I see yours, I think you had the better approach. You may want to look at what I did in mine to cover some of the TODOs you've identified in your README. I have the main event loop running in its own OS thread, allowing it to make blocking calls while other tasks run. This lets me create an object whose lifetime is tied to the mounting of the filesystem (with an unmount method to unmount before the object is destroyed if desired.) This in turn allowed me to create tests that run with "rustpkg test." With yours, as you mentioned, you might not even need the OS thread if you can switch your main loop to use std::rt::io. It could be fun to work together and merge the two...let me know if you're interested. I'm not surprised multiple people had the notion to do this--rust seems like an ideal language to write one of these in, once it gets stable and settled.
&gt; Regarding CTFE, I have a plan for how to implement it for Rust 2.0 This sounds exciting. We can work around a lack of CTFE in the short term. What do you mean by 'phasing'?
imo any "cloud storage" type should be implemented with fuse. it does not make much sense to configure server, username, password in fstab
The etymology at [wiktionary](http://en.wiktionary.org/wiki/mankind) and [others](http://www.etymonline.com/index.php?term=mankind) would suggest otherwise. I admit "manual" and "history" are people looking too hard. I understand that "guys" and "mankind" are commonly intended to be gender neutral, but that does not change their cultural bagage.
&gt; So you're concerned that No. /u/OverAnalyzingBBFan expressed his/her concern about that, my issue was with the trigger-happy way in which you banhammered them. &gt; The answer is: [...] That's the answer OverAnalyzingBBFan should have gotten. You instead chose to not even make an attempt to reply to their concern and jumped to ban them. &gt; OverAnalyzingBBFan chose to mock people who are socially disadvantaged (protip: these people actually exist) by arguing that their refusal to conform is somehow absurd. That's the weirdest strawman I've ever seen set up. OABB didn't "mock people who are socially disadvantaged", they pointed out the flaw in the argument in their parent comment. There's nothing whatsoever there about "refusal to conform" or such bulllshit. Whether or not you agree with their sentiment, it definitely wasn't a comment that invited a ban, this was an obvious abuse of mod power. 
I became aware of your project a few days ago. Great work! Funny that we both started to work on almost the same idea. I also first tried to use the callbacks first, but I found it hard and a bit awful since the Rust context gets lost when the callback is made. This and because I wasn't quite satisfied with the original library code, I started to rewrite the session loop in Rust with the goal to enable the full potential of Rust tasks when dispatching filesystem operations. First I planned to dispatch every operation into separate tasks, but then I realized that this might not be always desirable. One idea of Rust is to prevent waiting/locking at all by grouping access to one resource in a single task. Most of the filesystem operations deal with metadata that manage inodes. They could easily be done in a single task since they'd require exclusive access to these metadata anyway. Operations that deal with actual data (read/write) are candidates to be parallelized, I think. However I don't have any benchmarks on this idea yet. If we do have the same goals with our libraries, I think it'd be a good idea and could be fun to merge and join our efforts.
Oh. Of course you're right. I almost forgot about NTFS-3G, thanks.
No programming language's default linear algebra methods are good for game programming, and linear algebra is not a one-size-fits-all thing. You have linear algebra with symbolic math support for mathematical research, numeric libraries with high-precision support, numeric libraries with better use of intrinsics for game dev.
I wouldn't mind more programming languages giving a nod to their mathematical underpinnings, especially re numerics. I admit to being more mathematician than programmer, but the idea of a ring is fairly intuitive, isn't it? It's just an object with "addition" and "multiplication" and identities for each. Is the terminology the issue? This strikes me as a notion familiar to most programmers, especially in numerically-oriented fields, even if they don't know the name. I've written some personal code in Haskell that builds up numerics in the traditional algebraic way when it's helpful (though I usually cheat and skip magmas and go directly to monoids), and I think it greatly increases the tractability of some classes of numeric code. I will grant that modules are quite a bit headier, though.
You're free to call my interpretation a strawman, but OverAnalyzingBBFan allowed their argument to be interpreted however I please by couching it in terms of sarcasm and insincerity. This is why I bring up the concept of "expressing concerns maturely" in my prior post, and was the reason for my resultant sarcastic reply and eagerly-wielded banhammer. Maybe you've been spoiled by the rest of reddit, but /r/rust isn't one of those subs where the inmates run the asylum. That said, if you believe that my representation of the argument in question was in error, then I invite you to restate it in less incendiary language. If /u/OverAnalyzingBBFan agrees with your interpretation, and pledges (via [modmail](http://www.reddit.com/message/compose?to=%2Fr%2Frust)) to keep future comments constructive, I'm not unwilling to rescind the ban. I believe we can all be reasonable here.
You are adorably persistent, FallacyBot.
I believe /u/pcwalton is referring to 'phase separation'. The most readable introduction I know if [this](http://axisofeval.blogspot.com/2010/07/whats-phase-separation-and-when-do-you.html). Sadly, @msimoni never wrote the followup.
The code is a work in progress. There are probably subtle bugs. However, I thought people might be interested to see how Rust handles this domain. The main issues I encountered is lack of compile time sizeof and struct padding, which made the padding to prevent false sharing a little awkward.
Well it's been like that for as long as I can remember. I always assumed it's because Rust doesn't have a concept of type specificity, so it can't tell the difference between `T` and `Mat&lt;T&gt;` because `Mat&lt;T&gt;` "matches" against `T` causing ambiguity.
 fn main() { let x = [0u8, ..std::sys::size_of::&lt;uint&gt;()]; } &gt; sizeof.rs:2:20: 2:48 error: expected constant integer for repeat count but found variable &gt; sizeof.rs:2 let x = [0u8, ..std::sys::size_of::&lt;uint&gt;()]; 
Your intent does not govern others.
It is, but not in a way the compiler allows in "constant expressions" (like `static`s or the repeat counts that jjt demonstrates).
Ah, that's what you mean. Yeah, unfortunately the kind of pseudo-CTFE Rust has for a couple intrinsics isn't a "constant value" in that sense.
It's pretty easy to [write your own equivalent](https://github.com/mozilla/rust/issues/7633#issuecomment-20586992). (That will have to be updated because `&lt;core-macros&gt;` changed to `&lt;std-macros&gt;` I think, and the visitor now uses traits.) However, the "correct" solution is to use `rustpkg` which will do everything automatically.
Thanks, that's what I'm looking for.
Please let me know how it's deficient so I can improve it!
The new tutorial is great! One thing you might add, is a small hello world example on github. A program with src, that has some test, some bench etc. To showcase it's awesomeness. Also crate vs rustpkg or crate into rustpkg transition (if there is any) would be great. Where do `#[forbid(missing_docs)]` go for instance?
Yes, thanks. We want to move this to a more official place... (your new flare is amazing)
I started paying attention to this after crates came out of favor, so I'm not sure, to be honest...
I'm not sure I understand the preferred organization. I've organized my workspace/src directory to include the directories lib1 lib2 my_project then I change to the workspace directory and do "rustpkg install lib1" and "rustpkg install lib2", which creates the necessary library objects in the workspace/lib directory. I then want to use extern mod lib1; extern mod lib2; in the file "workspace/src/my_project/main.rs" and be able to use "rustpkg build my_project", but it can't find the libraries. Is it really necessary for me to copy the libraries to /usr/local/lib/ or to modify my RUST_PATH to include the local directories? I feel like it should be able to automatically find the newly built libraries.
I'm so happy to see this! /me swoons Personally, I think having community continuous integration is a critical part of our stabilization strategy. Ultimately I'd like every rust package to be up on this dashboard. As we progress past Rust 1.0 every package that uses only stable libraries (which we should be able to detect and report) should stay green even as Rust changes - when that's not the case we'll know we've broken something and need to revert or consider the breakage carefully. How does this decide what to build within the repo? Is it simply using rustpkg? If it's not using rustpkg, can it? I added a page to the wiki about [continuous integration](https://github.com/mozilla/rust/wiki/Doc-continuous-integration) and linked it from the docs page. The content is pretty thin though, so I'd love for somebody to expand it.
Crates are still a concept in Rust, it's just that we don't have ```.rc``` files anymore (that is: a crate file doesn't have a different file extension from a file containing a module within a crate). Hopefully that makes sense?
So, I came home and tested it. Right now the biggest problem I see, is the fact that it simply doesn't work on Windows 7 in Rust 0.8 :( the commands fail. Sigh... That's what you get for not having a Linux environment. Also the tutorial lacks pseudo location from which the rustpkg is run. Is it from `src`? From `src\*` or from `*\src`?
You want the things in [`std::rt::io::file`](http://static.rust-lang.org/doc/master/std/rt/io/file/index.html) for reading a file, specifically [`open`](http://static.rust-lang.org/doc/master/std/rt/io/file/fn.open.html). This gives you a [`FileStream`](http://static.rust-lang.org/doc/master/std/rt/io/file/struct.FileStream.html), which you can see implements the [`std::rt::io::Reader`](http://static.rust-lang.org/doc/master/std/rt/io/trait.Reader.html) trait. Then you can either use [`read`](http://static.rust-lang.org/doc/master/std/rt/io/trait.Reader.html#tymethod.read) directly, to read a few bytes at a time; or just use the [`ReaderUtil`](http://static.rust-lang.org/doc/master/std/rt/io/extensions/trait.ReaderUtil.html) "extension" trait which gives you [`read_to_end`](http://static.rust-lang.org/doc/master/std/rt/io/extensions/trait.ReaderUtil.html#tymethod.read_to_end) to load a file into a `~[u8]`. (All the trait/function names are links to the docs, if your web browser isn't making it clear.) Something like use std::rt::io::{file, Read, Open}; use std::rt::io::extensions::ReaderUtil; fn main() { let data = file::open(&amp;Path("foo"), Open, Read).unwrap(); let bytes = data.read_to_end(); println!("The 10th byte is {}", bytes[10]) } There *is* something more concrete than the docs: the tests at the bottom of each file, so once you've worked out approximately what functions/methods you need to use you can open the source file (or click the `[src]` link in the docs) and look at how it's used in the tests.
Bummer :( what kind of fail? It's always from the workspace root.
Yup, that was my confusion, thanks!
This would be amazing, we should talk...
You explicitly annotate each function and import as "this is for compile time" and "this is for runtime". (You can actually have an infinite number of phases in both directions.) Values used in one phase are invisible to values in all earlier phases, but can be used in later phases. The Racket docs on phases are here: http://docs.racket-lang.org/guide/phases.html
In the map example, variable i is used without declaration.
True, but more accurately, `f(&amp;slice[i])` should be `f(v)`.
This would be an interesting exercise, but not really a SICP experience. First of all, SICP includes an interpreter and a compiler for a subset of Scheme, so you'd need to learn Scheme anyway, and you can't really do self-interpretation exercise without using Scheme. For another, SICP codes are dynamically typed and you'd need to think of how to statically type them. In some cases it may not be obvious how to do so.
Good point. I hadn't considered the "data is code" implication of scheme. However, most of the examples I've seen in SICP don't really require dynamic typing do they? As for the interpreter and compiler - yep, there's probably no way around it.
I haven't tried to type SICP, but I have tried to type EOPL(a PL book using Scheme) by using OCaml, and while most examples were straightforward, there were some that required cares and I suspect SICP will be the same. I am not saying some examples *require* dynamic typing, I am saying typing can be an additional burden. I think it is possible to write SICP and EOPL in a way that all typing is obvious, if one cares and is careful enough. But SICP and EOPL were probably not written that way.
Why can't we move to trait based sugar right now? What's holding it?
Nothing except lack of time to implement. I'd take a patch that does it, as long as it doesn't break soundness. In general we're in the stage of "defer anything we won't have time to implement right now-ish until Rust 2.0". We're serious about Rust 1.0 being around the corner. :)
If it's not needed elsewhere then it's useful to keep it hidden, even to the module.
https://mail.mozilla.org/pipermail/rust-dev/2013-October/005981.html (It's not explicit in it though.)
Thanks! Yeah, I read that mail, didn't notice. Neat!
&gt; debuginfo namespace handling has been unified, and marks the ability to build all of Rust (libstd, libextra, compiler and tools) with debuginfo, which is very awesome. That is great news.
This one: WARNING: The Rust package manager is experimental and may be unstable task &lt;unnamed&gt; failed at 'Unhandled condition: nonexistent_package: (package_id: :PkgId{path: std::path::WindowsPath{host: None, device: None, is_absolute: false , components: ~[~"github.com", ~"steveklabnik", ~"hello"]}, short_name: ~"hello" , version: NoVersion}, ~"supplied path for package dir does not exist, and could n't interpret it as a URL fragment")', C:\bot\slave\dist2-win\build\src\libstd\c ondition.rs:131 I'm still a bit confused, are there any prexisting folders that need to exist? Like I can create a folder: mkdir hello cd hello rustpkg install github.com/steveklabnik/hello Is this ok? Do I need a src folder?
That's this bug: https://github.com/mozilla/rust/issues/9781 In theory the correct procedure is mkdir hello cd hello rustpkg init # set up the workspace rustpkg install ... I see #9781 too, even when I call `rustpkg init` (with `91abfd4 2013-10-12 21:26:20 -0700`, which is the tip of master right now, so updating doesn't fix it).
Speaking of new `rt::io` are there any plans to make `rt::io::extensions::ReaderUtil` have a function to read chars or is that functionality moved in new runtime?
cool, raw strings look nice
Hello everyone!
There will be functionality for reading chars/strings, but only after we have a coherent encoding story; the old `io` handled UTF-8 only.
Yes University/College can be a lot of work. I can share some tips if you want. 1.) Don't visit lectures that you think just waste your time. In my opinion it's better to buy a book an learn with that. 2.) Make many connections. It's easier to learn with ~3 people that it is alone. 3.) Start learning right away. It's better to learn deep than learning 2 weeks before the exam. The result is probably the same but you won't forget it after a few months. 4.) You probably also have to visit some bull shit courses. Before you start learning for them, ask yourself what they could ask in the exam.(Remember the time span). I usually can eliminate 50% of the stuff that I have to learn. 5.) I usually write 5-7 exams per semester and I split them so that I can write 3-4 exams at the end of the semester and 3-4 at the beginning of the new semester. It's mostly super unrealistic to learn for more than 4 courses at the same time. And if you do you probably are only learning for the exam, which is bad because then you will forget most of your stuff in only a few months.
Hi, human!
Thank you for all the great work you've done. &lt;3
Hope too see you soon, thanks for all your work. Good luck with University !
Great work this summer! Good luck at school. 
I hope you get that school stuff figured out and come back soon. Let us know if you need someone to take over TWiR.
I'm relieved to know that This Week in Rust is going to continue. Good luck with school and thanks. 
Yes, I'm the author of this review (and I'm sharing it here because I know there is some French people!). Thank you very much!
According to [Wikipedia](http://en.m.wikipedia.org/wiki/Nested_function#Purpose): «Lexicallty nested function definitions are a form of information hiding and are useful for dividing procedural tasks into subtasks which are only meaningful locally. This avoids cluttering other parts of the program with functions and variables that are unrelated to those parts.»
&gt; brson: I've been thinking about how we can get support the offices better. Can we do southern hemisphere interns to balance it out? [...] We do have Australians (bjz, rust-http author, etc.). (I'm the rust-http author mentioned.) I'd love to work on both Rust and Servo, but do not expect to be a student after another month or so, and Mozilla only take students as interns, so that almost certainly disqualifies me. Hiring me outright, on the other hand...
I'm happy to hear about the upcoming workweek in Korea. Secretive as they may be, it seems as though Samsung isn't shying away from their interest in Servo, and that bodes well for Rust.
It seems to me that the main argument is that using C# on non-Windows can be sometimes unpleasant. As a long time Mono user, I can sympathize. I agree that other arguments seem weak and possibly misguided.
I would do this not just to keep them private, but also as a signal to other developers that the inner function is only relevant to the function it's declared in. With a function declared in a broader scope, other devs must wonder "what's this for? what contexts is this going to be called in?".
The audio track is now available for download. I don't think there is a video recording. Slides are linked from http://opensourcebridge.org/wiki/2013/Rust%3A_A_Friendly_Introduction 
&gt; I'd be better off using @ptrs or I'd be in over my head from a syntax standpoint, especially in terms of other people being able to work on it. Can you elaborate on this?
I just wound up having to write too much code managing lifetimes and just wound up with more syntax to describe my problem than if I'd used managed pointer or used Go or .NET or something garbage collected. Mostly what I'm saying is that I love a lot of things about rust, but I think some of what makes it great at low level might get in the way of it being as "pretty" or "nice" at a higher level.
Absolutely
I didn't understand the issue with the attribute syntax, what problem it's trying to solve. I'd much rather use the brackets than a caret. 
Removing the brackets is a separate issue, and has been in the works for years now. The introduction of the caret is simply to replace the way that semicolons currently work in attributes. As of today, a semicolon at the end of the attribute turns it from an outer attribute to an inner attribute. This is highly unintuitive, easy to overlook, and muddies the waters wrt our *other* significant semicolon rule (those in return position). Give the new syntax a few weeks to grow on you. As said in the meeting, we still have nine months to correct it if we don't like it. :)
How I wish I could be an intern on Rust or Servo! I'm afraid I'm probably not qualified enough, unfortunately. (I am a student, however. Albeit a high school one.)
&gt; But why a caret over say any other symbol? &lt;/bikeshed&gt; The idea is that the caret is an arrow, pointing upward to the item that it applies to. I'm not in love with it, but I think it's way better than the semicolon. As for other symbols, many were considered, bogging us down for a long time on a pretty trivial detail. At some point we have to stop bikeshedding and actually implement something. :P
It warms my heart every time somebody recognizes our awesome community and open development process.
I see, now I understand the issue and the talk about making it consistent with inner doc comments. Thanks. 
I'm not sure if it is due to the relative newness of the community or a concerted effort at culture building, but I've been shocked by the friendliness and helpfulness of literally everybody I've come across. Good on you!
Here is a direct link to the relevant bug report. https://github.com/mozilla/rust/issues/2569?source=cc 
I think that the carret is a good idea since it's visually show where it's applying. It should be used for inner comments too.
And C#'s place is firmly in Microsoft-land.
The real test will be what happens after 1.0, when we'll get more mainstream interest and the nature of development will change at least somewhat. Thus far, I've certainly absolutely loved being part of the community.
As thitherto primarily a Python programmer, I found getting stack and heap allocations right took a while to really sink in, during which period there was lots of trial and error, but within a month I felt I had a good grasp of it all and within two I was entirely comfortable with it and felt the benefits that it imposed on my design. Now I'm up to around three months and I think the biggest thing I've cemented in my mind in the past month period is that you don't need `~` very often at all; I've understood the complexity and what all the concepts mean and in consequence I can now write simpler, more efficient and syntactically *lighter* Rust code. In all my time with Rust, I haven't used managed pointers at all, with the exceptions, well over a month into my experience, of working with `@std::io::Writer` and a couple of very trivial test scripts after that to ensure that I understood them. What's more, there was only one time where using managed pointers would have benefited me notably, and my allergy to them (I had been carefully indoctrinated in this) led to me pursuing a different, probably better, solution. I've been impressed by how quickly I've managed to grok (I do mean *grok*, not just *understand*) Rust, despite the dissimilarity between my past experiences (only having worked a very little in languages with the stack/heap distinctions, no boxing and the like, and not having worked in Haskell-family languages at all). All up, I rather like Rust.
&gt; working with @std::io::Writer (Fortunately old `io` and its wild use of `@` is almost gone; replaced by the non-`@` `std::rt::io` library.)
&gt; removing rusti, #9818 (acrichto) Oh no! That is quite a disappointing development. A repl is really useful in quickly testing and prototyping code. I hope they reconsider.
Macros could make such a thing work fairly well (from the perspective of convenience and in declaration), but you can't use macros cross-crate. And it'd be a pretty massive suite of macros that could emulate `django.db`! Custom syntax extensions and the ability to do things based on attributes at compile time will be valuable in making this work well, and attributes on struct fields are likely to be used in it (compare with the current `#[deriving(...)]` technique). Perhaps something like this, eventually: *(this is conceptual code only and is not to be taken seriously)* #[model] struct Author { #[max_length(50)] name: ~str, email: Email, } This may be observed to be closer syntactically (and probably semantically) to what is done in languages like Java and C# to what is done in Ruby and Python. In the end, though, Python's metaclass system is a beautiful thing which makes such code extremely elegant, but which cannot be translated *directly* into Rust. Some will translate, some will need other idioms applied, other things will be possible in Rust that would have been difficult or impossible in Python.
The problem is that it's bit-rotted and has been unusable for quite some time. Given there is nobody who has stepped up to fix and maintain it (quite a lot of work - see various mailing list discussions) the best thing is to remove it for now. There's nothing stopping someone from picking it up again in the future.
Mozilla are (in my experience) more concerned with experience, and your ability to do the job, than any qualifications. It's entirely possible to know enough to get an internship in or straight out of high school.
&gt;I love C# as a language, but I have a lot of gripes with the .NET APIs (why are they so in love with inheritance, and why does nothing return an interface? How do they test this stuff?). I tend to think it's historical baggage. You can see the evolution of idiomatic .NET by comparing Web Forms to ASP.NET MVC to WebAPI, the latter of which lends itself a great deal to testability.
In a sense, sure. You'll still have to use traits to get overloading though (Haskell-style) instead of the ad-hoc overloading like C++/C#/Java/D.
Hi, this is the author. I want to clarify some of my opinions. I wrote this blog post after getting hello world to run and reading the tutorials basically. So, yes, some of my arguments were wrong due to my inexperience. As for the magic argument, I'm not yet experienced enough to know if I'm right or wrong. The community as a whole seems to dislike it at least though. Just to share my experience learning rust the past week though: Ownership of objects is a first-class concern. In C#, I worried about what references a class would contain. In Rust, I worry about what references a class would contain, the lifetime of that class, and the probable lifetime of the callers to that class. It's ridiculously scary! However, something finally clicked in my head when forcing myself to remove all managed pointers from my code. I didn't actually need garbage collection in my program(thus far) at all. I was trying to program in Rust like it's C#, without worrying about ownership. I would compare it to going from a procedural language to a functional language. It's very mind expanding, but once you grok it, you will start to see ownership in other languages as well Rust's documentation also isn't the best at times, but what the documentation doesn't tell you, the lovely community will (usually very promptly!). I mean I come into the IRC channel and ask some of the stupidest questions, but the community still answers me (usually pointing out.. well you can do it this way, but you probably want to go about it another way because you'll be in for more pain later). Rust still has a long way to go and is rough around the edges at times. Smart pointer syntactic sugar is my most wanted feature right now, but then, if that was already in there I probably would still be using garbage collection when I don't actually need to
&gt; I agree that it seems like moving away from C# the language isn't necessarily what he desires, but rather from everything that surrounds the language. Of course, it is pretty hard to separate the two. This is mostly accurate. I don't particularly like the viral nature of async either (with it being pointed to as a feature because all code should be async no matter what), but it's mostly the ideals of the community and the lack of community support for non-Windows platforms. I don't want more reflection to save 3 characters of typing per line, I want something statically verifiable. I wrote my LucidMVC project for ASP.Net because I wanted a strongly typed web framework. "If it compiles, it should work" philosophy. I had hoped that other people would want such a thing in .Net land as well, but no one appeared to. There are many alternative MVC frameworks for .Net as well, but they don't strive to follow such a philosophy. There are some places where static typing can break down of course. Taking user input and stuffing it into a dictionary of strings and then stuffing it into a static type can be rife with danger, but at least if you make it past that point of danger, the rest of your code is safe. 
&gt; Being that .NET is garbage-collected, the only advantage that rust has over .NET in terms of static verification is that there aren't null pointers. Rust doesn't have higher level forms of reference invalidation that are still a problem in garbage collected languages. One example is the lack of iterator invalidation in Rust. A garbage collector also usually doesn't protect you from a dynamic failure from use-after-free with other resources like files, and that's covered by Rust's regular memory safety checks. Rust's ownership model is also used to eliminate the possibility of any data races.
It would be supercool to have a struct with self-introspection. The struct should be iterable and provide the map trait and have a keyset that is an enum. #[self_introspection_with_cast_to(DbField)] struct Author { name: StringField&lt;length: 50&gt;, //Or some kind of var-type syntax email: EmailField, } impl DbModel for Author{}; Perhaps this would allow for an ORM in a distant future (post 1.0). Very late edit: Something like #[deriving(EnumMap(DbField))] might be a better syntax (as mentioned below)
The conceptual code I provided has the potential to provide pretty much this functionality; just as `#[deriving(...)]` is able to create code at compile-time based on the contents of the struct, this `#[model]` would trigger all the sorts of behaviour of Django's `ModelBase` with setting up the manager, the type, what happens when you create instances, etc. I'm wondering whether taking this conceptual sketch further mightn't be a bad idea and writing an entire system in this hypothetical future Rust to see what's needed and what might and might not work. This is, however, a distant-future feature for Rust. It *is* on the cards, though, and that really does excite me. (Though then again, it *will* be "magic", compared to what we presently have.)
Do we have an idea how it should be implemented? If yes, it could be written down as an issue for future generations.
I have no idea how it would be implemented. All I can suggest is looking at `cling`, because they have a production quality REPL for C++ built on libclang using LLVM's JIT.
That looks like fun. Alternatively it may be possible to use something like protobuf as a base, and implement much of the remaining functionality in standard rust. (But I am dreaming here. I should stop... ) http://code.google.com/p/protobuf/ https://github.com/stepancheg/rust-protobuf/
I took on rust, because the lifetime syntax is hard but it promises - safety, concurrency and speed (probably in that order). C brushing up to meet the lovely Haskell. Sign me up :D Also community is freaking great, but I wish the irc was separated into rust-dev and rust-help. Because whenever the big guys talk about compilers parts, my question about lifetimes just seems wrong. PS. Macro's are more or less Rust's magic, so beware of that.
&gt; Also community is freaking great, but I wish the irc was separated into rust-dev and rust-help. A `#rust-internals` channel was split off a few weeks ago, but "the big guys" aren't super strict about where they discuss internals so conversations leak. (To be clear, this channel is *not* exclusive to the "veterans" at all.)
I'm not sure I understand the "it loses against itself" ? Do you mean that the first AI to play loses and the second one wins ?
exactly. it even does in a way it won't if it plays against me. not sure if the problem is it can't handle being X in general, i may try that later.
Obligatory relevant XKCD: http://xkcd.com/832/
[Image](http://imgs.xkcd.com/comics/tic_tac_toe.png) **Title:** Tic-Tac-Toe **Alt-text:** The only winning move is to play, perfectly, waiting for your opponent to make a mistake. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=832#Explanation)
I must admit my personal preference would be to *not* use conditions in IO. I haven't seen them used anywhere else yet, and they appear quite unwieldy to use. Errors / Results, on the other hand, are a known factor and definitely easy enough to use.
I'd really like to see some examples of idiomatic of conditions. I always tend to prefer avoiding conditions, but I assume that's because I'm not familiar with them and haven't seen them used well.
Yeah, if conditions don't work well for IO then the obvious question is what context are they useful in? I've always thought them a little funky, but was keen to see how they were used by someone who's spent a decent amount of time designing an API around them.
Conditions are actually pretty exotic, you can find them in Lisp (and probably some other languages), but not in "mainstream" languages which generally use exceptions. Conditions attempt to solve an issue that exceptions have: when you are ready to handle an exception, you have lost the context in which it appeared. Instead, conditions are error handlers that are invoked *in situ* and thus may react (and manage to re-establish the situation). A naive approach to conditions is just to pass predicates (in C++, if you don't mind): using ExistingFileHandler = std::function&lt;Logger(std::string const&amp; name)&gt;; Logger open_logfile(std::string const&amp; name, ExistingFileHandler const&amp; efh) { try { return open_file(name, filemode::append); } catch (FileExists const&amp;) { return efh(name); } } And a valid implementation of `efh` would be "remove file, open file in append mode". And since passing handlers around would soon get tedious, the handlers are instead stacked in task-local variables, and use the stack for automatic installation/deinstallation. In short: error handlers are *injected* (like dependency-injection do). Now, as you can see, it makes little sense not to invoke `open_logfile` directly with the handler. However if you have to invoke `initialize_log` which itself calls `choose_log_strategy` and then various strategies among which `open_logfile` you'll realize that `initialize_log` would need a dozen or so error handlers (humpf!). And of course, the farther away you are, the more error situations. On the other hand, I must admit that the issue I have with the system (pretty much like with exceptions), is that this somewhat exposes the caller to implementation details.
Looking at your example, I have no idea where the condition begins and ends. Could you possibly make a Rust (or fake Rust) example of what a condition would look like, for some example where conditions work well (i.e., there's an example in the linked thread, but as noted its very verbose without doing much...)
&gt; and probably some other languages Smalltalks have them, though IIRC they call it "signals" or "resumable exceptions".
http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html is the usual example from Practical Common Lisp.
It's worth noting that there is a [project](https://github.com/glycerine/rustxi) underway to create a working rust repl.
Result is easy to understand. However, when writing, say, a mildly complex application with an HTTP handler, a couple of business layers and a persistance layer, it's a pain to thread results all the way back to the HTTP handler. You're going to have pattern matches everywhere you want to do anything after persisting the data. And unlike Haskell, whose various error handling systems all suck in different ways, you don't have monadic sugar to help with that. Exception in traditional OO languages have the following advantages: * As they can be subtyped (that's often the only actual useful usage of subtyping...), the caller can choose the granularity of the error to handle. Opening a file? Maybe you want to catch only an IOException and print a useful message. Or maybe you want a special case for FileNotFoundException. * It's easy to wrap them in a more general exception, which hides either a concrete implementation (eg, a MongoDB backend vs a MySQL backend) or differences between layers.
I could do that, but it would make iterating over it entirely a bit harder and I don't really see the advantages.
Instead of: let mut i = -1; while i &lt; size - 1 { i += 1 I would suggest: for i in range(0, size) { You also have some superfluous semicolons (e.g. 37-40 in board.rs).
But what about chaining results? e.g. read() .and_then(|| {/* do stuff here */}) .and_then(...) .or_else(|| {/* handle error here */}); It doesn't require constant unwrapping with matches, and allows you to send the error all the way through until it can be dealt with.
Since this got rejected, I'm blogging it up. Feedback very welcome.
&gt; Borrowed: You’re writing a function, and you need a pointer, but you don’t care about its ownership. If you make the argument a borrowed pointer, callers can send in whatever kind they want. Borrowed pointers are actually more general than this: it's for when you need a *value* (not necessarily a pointer) but don't need/want ownership (which is very important, given how central ownership is to Rust's type system). This is especially important with generics, since they always move ownership; unlike a concrete type like `Point` which consist only of primitives &amp; doesn't have a destructor, so the data can be (shallow) copied (e.g. passed to a function) with both source and destination being usable.
Thanks! So just `s/pointer/value/` would be a reasonable edit here?
Ah! strcat was my source, so I was misled!
Good to know, thanks!
&gt; Also, last time I checked (around 0.7), rust always forced structs to be passed by reference, so passing small structs by value isn't optimized like in C/C++ strcat has [fixed](https://github.com/mozilla/rust/issues/9651) this, types of one word or less are now "immediate" and so passed by value. I think Clang classifies slightly larger types as immediate too, so we've still got some investigation/optimisations there.
very valid, thanks I totally agree on while being just plain stupid. getting when semicolons are superfluous is not yet clear for me. i.e. #[...]; vs #[...] which sometimes seem to be valid and sometimes not and needed semicolons for enums but forbidden ones for structs etc
re. semicolons: I would suggest reading section 3.1 of the [tutorial](http://static.rust-lang.org/doc/master/tutorial.html#syntax-basics) - it gives a pretty clear explanation.
We should link to the the OS class that is using Rust this semester if the instructor agrees (I don't have the link on me at the moment).
This is awesome! I think it would be neat if you also touched a bit on something that might not necessarily be related, but *looks* related: ~[T] and ~str, how they differ from &amp;[T], and how [T](?) and str don't exist by themselves. That's something that I'm still a bit confused about!
I was complaining about this the other day. We certainly need better explanations here.
When you say that pointers should only be used for big structures, who big are we talking about? Is 16 int or ~str fields considered big ?
Rejected by who?
[strcat, apparently](https://github.com/mozilla/rust/pull/9579)
Yeah I didn't mean that to sound passive aggressive, not everything is appropriate. It's all good!
I haven't played with Rust for a long time now. Is this actual syntax? But in any case, it's not really satisfactory. Here is a common pattern (pseudocode with exceptions): try { let conn = open("some_storage") let trans = open_trans(conn) try { let foo = trans.read("foo") let foo' = update(foo, bar) let baz = trans.read("baz") let baz' = update(baz, bar) trans.write(foo') trans.write(baz') trans.commit() } catch(IOException e) { trans.rollback() } } catch (IOException e) { print("Sorry, couldn't save your object for some reason") } If you want to do the same thing with explicit chaining, your code will begin a steady march to the right, increasing with each IO operation, because you're trying to do monadic error handling without the necessary syntaxic sugar, in a case where each step should only be executed if the previous step has succeeded.
&gt; An equivalent to ~[T] is always going to be the only vector you can dynamically resize. Yes... but what's the implication here? (I.e. why are you mentioning it?)
&gt;But won’t this be inefficent? Well, that’s a complicated question, but it’s important to know that Rust, like C and C++, store aggregate data types ‘unboxed,’ whereas languages like Java and Ruby store these types as ‘boxed.’ For smaller structs, this way will be more efficient. Could you elaborate on this? It doesn't really explain why it's more efficient.
Using guys to refer to mixed groups of people (or even women only groups) is just standard English usage. One of the meaning of the word is a person. It's a pity some people find standard language usage off putting but it's only their problem to work on.
You can be emphatic while telling them why they are wrong about guys thing. Requiring or even encouraging people to give up standard language usage encourages culture of giving in to unreasonable demands just because someone shows emotions when making them. English is an established idiomatic somewhat standardized language. It's really better way to correct people who don't get some parts of it than encouraging others to accommodate them.
If people have unreasonable emotional reactions to words in a language it's only their problem. I am all for being emphatic, understanding and patient while explaining to them why their reaction is not justified but why change long established phrases just because someone is offended by them and refuse to adjust after learning their true meaning?
Excercism.io is a neat site where people can try out examples and get code reviews. I started adding some Rust a while back, this PR adds the rest. But I feel like there's way too many `~str` going on, and I'm out of the country for another few days, so I can't really dig in. If any other Rustics want to give a hand reviewing the sample implementations, that'd be great.
&gt; It's really better way to correct people who don't get some parts of it than encouraging others to accommodate them. Exactly! ;)
Commented on the two `~str`s you picked out. Seemingly unnecessary use of `~str` in tests isn't a particular problem, especially if it makes the test clearer about what exactly it's testing. I'm glancing over the rest now.
Thanks! So, if I understand correctly : a big struct, I should put it on the stack but pass it by reference ? Or should I pass it by value and let the compiler handle it ?
If you only need a reference to it, passing it by reference is a much better option. If you pass a large object by-value, the compiler has to copy it elsewhere on the stack and pass a pointer anyway. Although, if these are internal functions LLVM can optimize it out.
Okay, so the original point was that I should use MyHugeStruct and not ~MyHugeStruct. Do I understand it correctly ?
Rust will generate bytecode copying the structure and passing a pointer, as `clang` does. LLVM can identify if a parameter is `readnone` or `readonly` and if the function is internal it can remove the unnecessary copies but this isn't at all guaranteed.
I added this to the list of influential research on the wiki: https://github.com/mozilla/rust/wiki/Note-research
👍❤️
Sorry to disappoint, but this subreddit is for the Rust computer programming language, not any game: http://www.rust-lang.org/.
I think you want /r/playrust. Good luck with the beta.
I think you might have the wrong subreddit. This one is for the programming language called Rust.
Rust has lint modes built into the compiler. You can enable them either by passing command-line arguments, or by including attributes in your code for any lint passes that you want to enable/disable. You can run `rustc --warn help` to see a list of all available lint modes and their default settings. I presume (but haven't verified) that `rustc --warn all` would turn on all lint warnings that we've currently implemented, and that `rustc --deny all` will abort compilation if you trigger any lint warning.
I think that `rustc &lt;blahblahmyoptionshere&gt; -W unstable -W unnecessary-qualification -W non-camel-case-type -W non-uppercase-statics -W missing-doc --no-trans` is what you are looking for. it runs all passes besides actual translation. It turns on warnings for a few things that (IMO you'd want to know about) are allowed by default. If you want to see all the lint options, run `rustc --warn help`.
The original version appears to be from Feb 13, 2012. :)
I think I only use them for ~str and when [extra::json::Json](http://static.rust-lang.org/doc/master/extra/json/enum.Json.html) uses them (I already made some correction after reading you guide :) )
My mains interrogations are : Am I doing it right (is this the right way to do this) ? Is this a right usage of traits ? Should I make this available as a library ?
Writing my little parser, I've been playing with Result enumeration and it kinda works, but I kinda need to have optional errors. To me the ideal solution would be to have Result as a tuple `(data, errors[])` where ignoring the errors results in warning, preferably. 
Any use of `std::vec::build`is bad. It's the slowest way to build a vector. `std::vec::from_fn(TARGET, random_char)` is much better.
Can I interest you in the `gen_ascii_str` function in the stdlib? http://static.rust-lang.org/doc/master/std/rand/trait.Rng.html#method.gen_ascii_str Though it doesn't generate from any arbitrary alphabet, if that's a requirement of yours.
Regarding your suggested hybrid solution, how hard would it be to determine whether or not cycles existed in the call graph? We're already griping about compile times nowadays, and adding even more static analysis isn't gonna help that. :P
I'm afraid it is :/
Sweet!
Is there any reason that the existing ReaderUtil trait(s) can't be implemented for the new io library? There really isn't a whole lot (from what I remember, at least) of code that has to be added to the rt::Reader classes. The ReaderUtil trait(s) basically depend on ReadByte(), EndOfFile(), and maybe one or two other methods, and build everything on top of that.
Regarding functions pointers/indirect functions, I was thinking that attributes could be used to bound the allowed space used: #[stack(a, 256)] And then it would become the caller's responsibility to ensure that the function it provides respects this contract. On the other hand, it means that now on some platforms your code compile but on others (where it consumes more stack) it does not. Humpf.
&gt; Give up and accept the potential memory unsafety This seems like an incomplete description of how C and C++, at least, work. Specifically, since each thread always gets a full stack with a guard page (under standard runtime environments), any function with less than a page of stack frame will always hit the guard page rather than overwriting anything. This doesn't address functions with very large or variably sized stack frames, but these are probably rare enough that adding a check in the prolog wouldn't have a significant performance impact. The issue is only with segmented stacks that don't have guard pages. From the linked discussions, which suggest that segmented stacks are not a primary use case, it seems strange to me to add all these options when without segmented stacks (or even with segmented stacks if the overhead isn't too much), guard pages are essentially optimal. edit: although the max_map_count mentioned elsewhere could throw a wrench into things.
&gt; On large systems, such as x64, address space is practically boundless, so lazily allocating stack segments is going to be slower than just requesting a very large mmap’d stack that the OS will lazily allocate. Operating systems limit the number of memory mappings. On Linux it is /proc/sys/vm/max_map_count, and root is required to change it. On my system (Ubuntu 12.04 64 bit) the limit is 65530. It is default kernel value: https://github.com/torvalds/linux/blob/v3.11/include/linux/sched/sysctl.h#L17 Comment in kernel explains that value is limited because of coredump format. And maybe very large number of mappings affects system performance. Another problem with large number of mappings is that allocated memory is not returned back to the system when it is no longer needed. Suppose you have million of tasks, which sleep most of the time, and occasionally wake up and perform computation with 1Mb stack and then go to sleep again. With plain stack program would require 1Tb of memory for these tasks. With segmented stacks only 100 Mb or so memory is needed.
Fair enough. I've been tempted a couple of times to try get the ReaderUtils trait working on the new IO library, but I assume that there are reasons that no one has done that yet that I'm not aware of.
That does throw a wrench into the plan. Having at most 64K tasks removes the utility of the feature. I don't see how segmented stacks only need 100M in that case though. It's not like we can free the stacks, they're still in use.
This is a good idea. I initially discarded it since it would bloat codegen, but the stack check prelude is quite small, and it wouldn't be a regression from where we're currently at if using segmented stacks.
What would the wrapper do? Same thing as segmented stacks do now? If so, that'd increase the efficiency of some current code, but doesn't fix the composability or flexibility problem.
Yeah, it's not a thorough exploration of #1, and #3 is often used in combination.
Yep, embedded is one of my foremost concerns, and is why I think step 1 of the hybrid solution is desirable. Would denying recursion / indirect function call be too limiting in your usecases? Would well-placed application of a `#[no_stack_safety]` work around it in the cases where it is?
Off-topic, but, what's a rough idea of compile times? Say, compared to a moderate-size C++ project? And is there a lot optimisation possibilities in rustc (for compile-time, not code generation)?
Along with this work, could an annotation be added that allows the user to restrict the type of allocation that can occur? #[require_fixed_stack] Something like this that would throw an error if the function's maximum stack usage can't be determined at compile time would be tremendously advantageous for possible future uses of Rust in embedded/OS-less systems
As another embedded C author, I'd actually be more interested in being able to have Rust enforce a known-maximum-stack-size at compile time with an annotation. Not seeing this comment, I wrote this: http://www.reddit.com/r/rust/comments/1owhwi/on_stack_safety/ccwke1l.
This is a great feature request! Good to know I wasn't going off my rockers when thinking about these usecases :)
I asked the Servo team to comment on Rust build times. Here's the transcript (click on "newer" to scroll down to the rest of the conversation): http://irclog.gr/#show/irc.mozilla.org/servo/39398
Denying recursion can be OK per-project, but not per-language. Not having recursion is crippling the language too much. In some scenarios one is able to prove that the recursion is going to happen only 10 times, so it's finite and controllable, but language still needs to support recursion.
Indeed, a simple task such as reading from a file shouldn't take more than a few lines and minimum amount of boilerplate code.
Might be. It's hard for me to say how well that would work in practice, when using 3rd party libraries, etc. IMO for too long in embedded we've been living with languages and systems crippled beyond reasonability "because safety". With "Internet-of-things" we will have a massive amounts of devices which are limited in capacity, but essentially non-critical. Code can fail in them and no one is going to get hurt. I'd be happy if programming such devices (with Rust) would be so easy and fluent as eg. downloading ruby / nodejs packges, etc. For example: I don't want to design sorting algorithms all the time, just because I'm working on embedded project. I just want to `use sort=github.com/someone/some-super-embedded-sorting-for-embedded` or `use crypt=github.com/cooldeveloper/crypt-for-embedded` plus `use ipv6=github.com/someguy/embedded-ipv6` and not worry about stack and allocations strategies. As long as everything just works and is safe, I'm happy with it.
Right, I'm not proposing denying recursion in the language, but zero-check stack safety requires no recursion.
Not at all. I'd be happy to talk more about embedded design constraints as well. Rust lines up very very well with a lot of our design goals and it wouldn't take much for me to prefer it in every way to C and C++ on embedded architectures.
Ping me on IRC sometime, I'd love to talk :)
I think an appealing part of my strategy is that it will *transparently fall over* into dynamic stack safety if it needs to, if dynamic stack safety is implemented on the platform.
&gt; I don't see how segmented stacks only need 100M in that case though. It's not like we can free the stacks, they're still in use. Suppose, function looks like this: fn foo() { loop { wait_for_next_job(); run_job_on_large_stack(); // at this point we don't use most of allocated stack frames } } According to [llvm documentation you referenced](http://llvm.org/releases/3.3/docs/SegmentedStacks.html#allocating-stacklets), __morestack already releases unused stack frames: &gt; When the function body returns, control is transferred back to __morestack. __morestack then *de-allocates the new stacklet*, restores the correct SP value, and does a second return, which returns control to the correct caller.
Note that `rand::rng()` is very expensive: it reads a few kilobytes of randomness from the OS, and then performs a few thousand arithmetic operations to seed a strong RNG. For something like this `task_rng` is better, or creating the `rng` once and reusing it for each `char`. (I'm thinking that I will remove `rng` since this comes up so much. It's equivalent will be `StdRng::new()`, which will look more expensive, hopefully.)
Perhaps there could be a crate-wide attribute that disables recursion, and enables static stack size checking, which allows you to have no run-time stack size checks? Edit: For code which calls into such a crate, it would be up to the caller (or perhaps the job of a shim function in the case of dynamic dispatch) to make sure there's enough stack available
You're not limited to one stack per memory map. Allocate a petabyte of VM and then dole out 1GB chunks of it for the stacks.
An approach to this general problem that I've been wondering about for a while, and which probably can't happen in Rust without making it not-Rust: * All function calls have to account for their callee's stack frame. * You can allocate it as part of the caller's stack frame, like a local variable, if the call isn't indirect (i.e., isn't a function pointer) and isn't recursive though a sequence of this kind of call (i.e., if this wouldn't cause the stack frame to contain itself). * Otherwise, it has to be dynamically allocated. Not necessarily malloc'ed each time (cf. vectors vs. lists), but explicitly allocated somewhere. Basically it'd make the function activation explicitly be the struct (or enum, really) that it secretly already was. (See also: continuation defunctionalization.)
Is this a Linux limitation? In windows you can just protect any number of pages within a single mapping, unless its somehow creating new mappings under the hood.
A guard zone is multiple pages. Every stack needs its own guard zone, seprate from the others. Every stack has its own guard zone mapped. The number of pages doesn't matter (though it actually does, but optimizing for page table layout is quickly going down the path to madness), the number of guard zones and thus mappings does.
Yes, this was common back in MS-DOS compilers for example.
Great idea, thanks!
Did some super simple testing with `time for i in {0..100}; do ./randomstring &gt;/dev/null; end`. With rng() it is steadily around .855s, with task_rng I get anything between .500 and .800s. An improvement, but I wonder why it varies so much. Edit: stealing the implementation of gen_ascii_str made it stable at .500. Pretty nice improvement! fn random_char() -&gt; char { rand::task_rng().choose(ALPHABET) } fn random_string () -&gt; ~str { let mut result = str::with_capacity(TARGET); for _ in range(0, TARGET) { result.push_char(random_char()); } result }
I'd recommend using fn random_string() -&gt; ~str { let mut result = std::with_capacity(TARGET); let mut rng = rand::task_rng(); for _ in range(0, TARGET) { result.push_char(rng.choose(ALPHABET)); } result } since it will save `TARGET - 1` look-ups into TLS (task-local storage) that a `task_rng` call causes.
Awesome! I am planning to extend this into something slightly more complicated. `random_string`needs to be its own function, maybe it can take rng as a parameter. Any suggestions on an elegant way of sharing a single rng between many different functions?
Passing a parameter is the easiest way, and using, e.g. fn random_char&lt;R: rand::Rng&gt;(rng: &amp;mut R) -&gt; char { ... } means you can change the random number generator you're using without having to adjust the function (e.g. you might decide you need speed at all costs and so use `std::rand::XorShiftRng`, or that the extra guarantee of good randomness of the `task_rng` is better.)
I talked to kind people on Rust #irc and they told me that they need to deal with encoding first, for ReaderUtil to work properly. IIRC it has a `read_char()` method that doesn't take encoding into consideration.
I think the code getting the stack limit can be implemented as a lang item, that would get used in the prologue of each function. It would have to be forced to stack-less codegen (no calls, and all locals would use registers), but you could implement both the current TLS-based stack limit (with inline assembly), a static stack limit or even some project-specific dynamic check.
We don't control that code, LLVM does. It's target-specific magic. Not that I'm opposed to adding such support; we'd just need to make LLVM let us substitute our own prologue. Which might not be a bad idea. I need to discuss a bunch of things with some LLVM devs anyway, so this is another thing to bring up.
You can't safely unwind after hitting the guard page though. Pretty much all you can do is abort the process, since you don't know how far the function got into executing before hitting the page. Rust is supposed to be able to recover from running out of stack on a per-lightweight-thread basis.
Can we just use `/dev/urandom` instead of using our own CSPRNG as cryptographers tell us to do?
I'm not sure how that changes things. On windows you could create one ginormous mapping, and then use VirtualProtect to change however many pages you want to be PAGE_NOACCESS. It looks like mprotect on Linux could do something similar. I don't see any documentation indicating that the number of VirtualAlloc/mprotect calls (or whatever) is limited. So imagine a petabyte of virtual memory allocated that gets split up into N smaller regions logically, each of which has a buffer zone of guard pages in between.
Maybe crypto_rng()? Since that is the intended purpose? Or something similar?
What is the limit you set up for the memory available to your JVM: do you guess it ? I agree it seems stupid, at first, but we routinely bound stuff that has no natural limit *because* our resources are finite.
Good point. For my curiosity, do you know whether the actual stack pointer check, as opposed to the overhead of allocating more stack when necessary, causes a significant performance hit with split stacks? i.e. whether there is any point trying to avoid needing it.
It's 1-2% at most. I've never seen it in instruction-level profiling. Usually in the cases in which it would be an overhead LLVM has already inlined the function.
Performance.
Is this true? I imagine one could figure out from the scheduler state (the address of which is in TLS?) which task was running, and run the unwinder on its stack.
But doesn't any implementation that we provide have to go through /dev/urandom anyway?
We now have `std::rand::OSRng` that implements `Rng` so it should be relatively easy to experiment with using it. (I imagine performance is still a concern, especially since it currently uses unbuffered IO because the only place it is used is to generate several kilobytes of randomness in a one off go to seed other PRNGs and so buffering doesn't help.)
I'm curious why you've used *self in the body, instead of &amp;self in signature of functions? I don't see that style very often and you don't use it for all functions. Is there a difference in what you can do?
&gt; From what I can tell, currently the only way to serialize to json is to implement the ToJson trait manually for your struct. This is obviously a poor choice, as it invites human error where none should have room to exist. Not to mention that implementing it correctly is not enough, people need to remember to keep it up to date. Fat chance. And even if enforced, this would lead to a lot of tedious typing as the program grows. Annoyed developers are not productive or diligent. So a non-starter right there. Not quite. There is a serializable/deserializable trait you can implement via `deriving`. I believe this allows for automatic JSON encoding and decoding. I don't recall the exact syntax offhand. `deriving` is the best choice because it makes encoding and decoding fast. If you rely on reflection for this, it'll be slow. (This is a problem with Go's serialization, for example.)
Ok adding new keyword to my search, I got this [test file](https://github.com/mozilla/rust/blob/73921f91a326e51118077ff3fd5c5c6196ff7c3a/src/test/run-pass/auto-encode.rs). Not directly, I first found some pull requests then found corresponding file in master repo. As far as I can tell, all I need to do is replace **extra::ebml::reader::Encoder** with **extra::json::Encoder** (and the same for Decoder) and the *test_ebml* function should otherwise do the trick. While the file implements Eq for the structs/enums it declares, it doesn't do anything special for Encodable/Decodable. Fingers crossed for no gotchas :)
What kind of qualifications does Mozilla look for in interns? And when will they start recruiting for summer?
[Here](https://careers.mozilla.org/en-US/) is a list of a bunch of internships Mozilla offers. You can find all relevant info there.
Thank you.
I applied for the LLVM/Compiler Engineer one ~3 weeks ago, haven't heard anything back...
Context: the Rust scheduler in `std::rt` uses libuv as the event loop/IO layer. Rust even gets a [special mention](http://nikhilm.github.io/uvbook/introduction.html#background): &gt; Users outside of node.js include Mozilla’s Rust programming language
Second that! it has been quite fun programming in rust for side projects lately. I don't know if you have to re-apply - maybe someone on the rust dev team can answer that, but yeah I remember there was the opening like 3 or so months ago for a similar position.
&gt; Can we just use /dev/urandom instead of using our own CSPRNG as cryptographers tell us to do? What happens on Windows? It doesn't have /dev/urandom as far as I know?
It has ["cryptographic service providers" (CSP)](http://en.wikipedia.org/wiki/Cryptographic_Service_Provider). I assume pcwalton was saying "Can we use [OS provided CSRNGs]" rather than being Unix-specific.
I'm not the author, but I think you may have a misunderstanding that I had myself recently. If you use &amp;self as the first argument of the method, then self is not the dereference of the borrow, it's the reference (borrowed pointer) itself. This is a bit different than the other arguments which have type annotations if you were to prepend an &amp; to them, the self one is special in that regard. They really had no choice, othewise there would be no (equally succinct) way of indicating that's it's passed by borrow pointer without also dereferencing. 
IMO, the Research Engineer position will heavily favor people who have made significant volunteer contributions to the Rust compiler and have therefore already proven that they can work effectively with the Rust team. If you want that cushy Silicon Valley job, start sending in some patches!
It depends on the position. In research we mostly look for grad students (though we do take undergrads) with a wide variety of expertise, and try to pair projects with their interests. The research internships for next year have not been posted yet but will be soon.
You can use rust without its runtime [zero.rs](https://github.com/pcwalton/zero.rs), so I think theoretically it is possible to start up native threads and stuff like that. After all, you can even write an OS in rust, if you want to.
This is incorrect. zero.rs is deprecated and unnecessary.
It would be nice if a note were added to the readme there; I had no idea this was the case.
What are the chances of you accepting a high schooler? (edit: for any Rust or Servo internship)
Thanks for providing such a detailed list of updates! Hmm, how would I rewrite: check vec::same_length(plaintext, keys);
You might want to have a look at [rust-core](https://github.com/thestinger/rust-core), a minimal standard library that virtually has no runtime. One interesting project that uses it is [rustic](https://github.com/pcmattman/rustic), a small x86 kernel written in Rust.
Short answer: yes Long answer: yes, there are enough of us in Rust looking at it as a C++ competitor to make sure that this is possible. As a language, there are actually few things that require the runtime. Most of the needed things are "lang-items" which are functions and traits that the compiler will output references to, to do things like allocate memory or handle operator overloading. There is currently a project trying to develop a basic operating system in Rust and another project, rust-core intended to be a "replacement" standard library that is intended for embedded or high-control environments. Like the one you describe. 
I'm after the non-cushy remote job, getting my hands dirty with optimisations and LLVM internals. I'm aggressively building my skills in that area at the moment. Regardless of that, I'll try to weave time for rust patches in amongst that :)
&gt; a project [Several projects](https://github.com/mozilla/rust/wiki/Operating-system-development).
You could submit a pull request that I'm sure /u/pcwalton will accept rather quickly.
I'm sorry you didn't hear anything about your last application. It happens occasionally that candidates don't hear anything at all - even a rejection - and it always disappoints me when I find out about it. If you are interested in this posting then apply again for it specifically; each new position starts the process anew.
I am not sure; chances are probably low, but it can't hurt to apply. I believe that Mozilla has hired high school interns before, though surely those are special cases. The less qualified it appears you are the more likely you are to be screened out in the early stages before any engineer even sees your resume. Always mention prominently in your cover letters, etc. your existing participation and contributions, as that's a big advantage.
If you're using `#[no_std]`, you'll probably want [rust-core](https://github.com/thestinger/rust-core).
Maybe. There was a pull request from a few months back to fix up the syntax to work with a newer version of Rust that seems to have been completely ignored.
That seems like a big task. But it would be awesome to use it as a C++ replacement.
It is. Lots of moving parts. Not easy.
Fixed, sorry about that.
Thank you.
It's called `CryptGenRandom`, I think…
In general if you use a custom main function with `#[start]` you will *link* against the runtime but won't *use* it. It'll then be left on disk so the OS dynamic linker won't read it. When we get static linking support, the linker should then discard the runtime symbols corresponding to the runtime, which will discard the runtime.
I've filed [#10047](https://github.com/mozilla/rust/issues/10047) about this.
Is it correct that the "research engineer" role does not permit remote work?
It would be highly irregular for Mozilla to *not* allow remote work. The Rust team has had at least one remote worker for as long as I can remember (graydon, marijn, acrichto) and the Servo team has at least one as well (jack).
I noticed that as well, but I imagine it may have required more mental effort to review that kind of PR than a quick README change. :)
Being local to the bay area is preferred, but remoties will still be considered. I'm trying to get the listing updated to reflect this.
With this patch, preliminary measurements show us 28% faster than nightly Gecko and 29% faster than (admittedly my somewhat old version of) WebKit at reflow traversals on a page with a bunch of nested divs and no text.
Depending how the struct inheritance works, this could potentially simplify my work on using COM classes in rust. If the base struct fields come before the derived struct fields in memory, this would make setting up COM vtables in rust a **much** easier task than it currently is, because more specific COM vtables could directly inherit the vtable of their more general parent. For instance everything that inherits IUnknown (lots of horrible hackery to make it work right now). Then traits extending structs would be wonderful in this scenario, too. I could define an Unknown trait that extends UnknownVtable, which would then cleanly wrap up the vtable calls behind safer, rust functions using default methods on traits and then every other struct that inherits from UnknownVtable would automatically get the Unknown implementation, saving myself a lot of code repetition/hackery. I would hope that those traits that extend a struct would get access to the private fields of a struct, meaning I could hide all the vtable extern fn pointers from the user and they can just get the vtable object back from a create method, and only have the traits as public interface into the vtable. This would also allow me to hide AddRef/Release management such that it becomes safe in the sense how other pointers are safe in Rust. So while this would solve problems for Servo, it'd solve a lot of other problems, such as COM interop on Windows (making my attempt to wrap DirectX feel less futile).
&gt; If the base struct fields come before the derived struct fields in memory, this would make setting up COM vtables in rust a much easier task than it currently is, because more specific COM vtables could directly inherit the vtable of their more general parent. For instance everything that inherits IUnknown (lots of horrible hackery to make it work right now). Yup, that's how it would work. &gt; So while this would solve problems for Servo, it'd solve a lot of other problems, such as COM interop on Windows (making my attempt to wrap DirectX feel less futile). Wrapping COM and DirectX helps Servo too! We want to use D3D :)
I can't say I'm very excited at the idea of seeing subtyping added to Rust. What's the rationale behind it? Is pattern matching too expensive for DOM manipulation?
How is this going to mesh with the proposed plans for associated types?
What is Servo's main source of advantage? Is it just that Servo has fewer features? Is it Rust helping in some specific ways? Is it lots of small things adding up?
My thoughts exactly. What is rationale for this change instead of default parameters? Also I think traits extending structs needs new syntax, because having to have structs as first members is an inelegant solution akin to all classes in Java having to call `super` first in their constructor.
Some time ago I mentioned in the Rust mailing list that struct subtyping would help enormously in modeling business objects, something that I'm very interested in at the moment, if only because it's more convenient to get direct access to certain members as part of a trait rather than having to wrap them in attribute accessors. However, that could easily be solved by having sugared syntax for accessor methods. From the standpoint of setting up data structured in memory which inherit members, this seems clearly convenient and I don't see any language feature, either implemented or proposed, which would help. It would be a lot easier to wrap protocol headers and other such things which are directly relevant to Rust's problem domain. My only cocern is whether there could be unusual or hidden interactions, and the possibility that people would start using struct inheritance over method inheritance just because of familiarity with the former. I *really* think something should be done, syntax-wise, to discourage this pattern, or make using method traits preferable. Widespread use of struct inheritance could lead to much less flexible object ontologies than method traits.
&gt; My thoughts exactly. What is rationale for this change instead of default parameters? What does this change have to do with default parameters? &gt; Also I think traits extending structs needs new syntax, because having to have structs as first members is an inelegant solution akin to all classes in Java having to call super first in their constructor. You mean that the struct has to be the first thing following `:`? Yeah, that's unfortunate, and I think I'd prefer using `&lt;` for the struct and `:` for traits.
I think it's orthogonal.
I think it's mostly just micro-optimization. I spent several days profiling the hot spots, inspecting the generated assembly, and fixing a bunch of bugs in both Rust and the libraries (mostly due to not inlining as aggressively as we could). I'm told that this code path used to be fast in Gecko and it regressed when margin collapse was rewritten. (But we have margin collapse in Servo, so that isn't it, although maybe Servo's is buggy/incomplete in a way that impacts performance, so we'll have to be careful.) As for WebKit, I've noticed that WebKit uses a lot of virtual methods (for example, to check what type of `RenderBox` something is) when they are not really needed, so that could be it. But I haven't profiled Gecko and WebKit too much to check. There is also likely some overhead from the fact that Gecko and WebKit both kick off two reflows instead of just one (in order to show the page before it's fully parsed). This *shouldn't* matter much, because the second reflow is incremental and the overhead of incremental reflows is a single-digit number of milliseconds compare to the hundreds that the reflow takes, but you never know.
Overall both were discussed and I think default parameters would be way better addition seeing how there is no method overloading in Rust (as far as I know). As for the second part, yeah that's what I meant. Conventions represent additional burden. 
Thanks, that's all I needed to know. Also one thing that might cause confusion: struct A {...} impl Foo for A {...} struct B : A {...} //this doesn't automatically implement Foo right? 
`B` doesn't implement stuff that `A` does, but I believe methods would be callable on `&amp;B` (due to the subtyping issue mentioned in the blog post). That's a good point to talk over and verify, actually—thanks!
But don't they cover the same patterns? Can't you replicate what is shown [here](https://github.com/mozilla/rust/issues/5033) with a trait inheriting a generic struct? I think that all these enhancements make the traits system too baroque, that like C++, when looking at the usage site you are no longer able to tell how the code is implemented in terms of the basic building blocks. I understand that all these proposals come out of real need you discover when writing Servo and I have no concrete counter proposal. I just want you to have this observation of a guy watching from the side and playing with the language. 
I see. I'm just concerned that this will turn into a lot of additional complexity down the road.
A year ago someone (Niko?) suggested that a trait could require the struct to have a certain member. This approach also looks nice and transparent at first (but I may have missed a detail) struct NodeFields { ... } impl Node for NodeFields; struct MyElement { node_fields: NodeFields, ..... } trait Element&lt;N: Node&gt; { require node_fields: N; fn layout(&amp;self); } impl Element for MyElement; Edit: Fixes
Why does subtyping work on `&amp;B`?
Is [bug 209694](https://bugzilla.mozilla.org/show_bug.cgi?id=209694) the margin collapse rewrite? Servo's is certainly incomplete.
What sort of additional complexity are you concerned about? Let me also point out that single inheritance on structs has been more-or-less waiting in the wings ever since the original trait system proposal back in 2011. In fact, the years-long incubation period on this feature ought to *alleviate* your concerns regarding the devs adding complexity to Rust. This isn't just something random that we're tacking on for the hell of it; it's been in mind for a long, long time.
&gt; But don't they cover the same patterns? Can't you replicate what is shown here with a trait inheriting a generic struct? They're different and cover different use cases. Associated types are about generics. Inheriting from a struct is about having shared fields. &gt; I think that all these enhancements make the traits system too baroque, that like C++, when looking at the usage site you are no longer able to tell how the code is implemented in terms of the basic building blocks. This feature is just classical OO. Almost all languages that I know of have some way to model single inheritance.
&gt; A year ago someone (Niko?) suggested that a trait could require the struct to have a certain member. This approach also looks nice and transparent at first (but I may have missed a detail) Yeah, that was the other proposal. We debated which one was better, but the proposal written up in this blog entry won out because it was thought it would be more convenient to not have to repeat shared fields all the time.
Well, I'm certainly excited about the prospect of struct inheritance. It definitely will make a lot of the more classical OO more concise and safer to express in rust as you've pointed out. And like I've said, given certain guarantees on memory layout, COM becomes much easier. As it stands, I have to generate a separate vtable struct for each COM object which in itself leads to quite a bit of repeated code, but on top of that the traits to express this require a bit of code repetition or things I'd consider undesirable/unsafe. Lots of virtual methods leading to lots of performance issues in the wrapper APIs. In regards to this proposal, let's say I have: struct Unknown { ... } struct Foo : Unknown { ... } trait IUnknown : Unknown { ... } Will I be able to then define default methods in IUnknown and reasonably expect those default methods to work on both &amp;Unknown and &amp;Foo, without having to do separate impls of IUnknown for Unknown and Foo?
I'm not sure, you'd need to ask roc.
I'm excited about the addition of single inheritance! Its absence has come up a few times in discussions with friends new to Rust. Thumbs up also for the attention being shown to performance wins in the implementation. I share your reservations about the structs-after-: syntax. &lt; for the struct and : for traits seems much more readable.
It seems to me that this would require some kind of virtual look-up: different `N` could have their `node_fields` at different offsets in the structure.
It's not really "not considered an option" but "not considered a priority", AFAIK.
Right, sorry, that's what I meant by "right now". My wording was unclear.
FWIW, I would also really like HKT, but I don't disagree with the current prioritization of things. What you deprioritize in favor of it? :)
Do you mean you would have to call super methods like `(&amp;Bar).foo()`? Or do you mean Bar can only call methods that take self by borrowed pointer (i.e. can't call fn foo(self))? Could it work similarly to default methods: if the subtype struct's impl doesn't override a method of the supertype, it would automatically implement the parent's method? And likewise with trait impls? Though I guess that'd be ambiguous -- would it use the trait's default method or the super type's impl of the trait? On a slightly different note, it also strikes me that there would be no need for `super` if methods were first-class functions:: `SuperStruct::foo(self) // self coerces to SuperStruct type`.
I recorded all this last night, here's another vid of me getting noclipped. http://www.twitch.tv/slyder_/c/3139730 This game is full of this kinda garbage. I hope RUST going on Steam will fix the problem or I just seeing this game turning into Infestation(WarZ) also known as "HackZ"
wrong sub mate.
my bad plz delete mod.
&gt; What sort of additional complexity are you concerned about? Essentially, that Rust will end up with the same kind of ugly co/contravariant decorations as Scala, as well as the same asinine error messages.
If you try to copy values of certain types, like unique pointers, or `T` values in the example you posted, the original has to be deinitialized so that you don't break uniqueness. This is called a move. You can't deinitialize borrowed values, which is why the compiler complains when you try to move values out of `list` in the match. To avoid copying, and thus moving, you need to reborrow the fields of the list. You do this using the `ref` keyword. This makes the name bound in the pattern an &amp;amp; pointer to the field, rather than a copy of it, so no moving happens. Note that struct-style enum variants have been (or are going to be) put behind a feature flag at tip, so it might be best to avoid them for now. You could either put a struct in each variant, or just use tuple-style variants. https://gist.github.com/steven099/7165828
Why? Maybe someone(s) will get inspired and decide to help. (Also, the mailing list post wasn't really an announcement, it appears to mostly be a question about reusing the testsuite.)
&gt; And so i thought i would give a go at writing a compiler for it so i've got: &gt; &gt; https://github.com/redbrain/gccrs (Admittedly there isn't a request for help, but that doesn't matter: the main point of the email was asking about the testsuite... that's even its title.)
I used 0.8. Yeah, I am planning on rewriting it with map/filter etc, see how much slower it gets (if it will?)
Try with `--opt-level=2`, it shouldn't decrease performance. If it does, it can be a bug, so don't be afraid to show your code as a test case. For mapping (maybe just without filter?), `map` should perform better allocation-wise, since it reserves the entire required capacity, instead of reallocating a few times (or every time) when you use `push`.
This is somewhat old and regarded as low quality by the community (I linked the article before fully reading it, in the `#rust` IRC channel, a few days ago).
Be careful with benchmarks like these: it's very easy for them to just become a comparison of random number generator speed. For a fair comparison, I'd say [implement XorShift](http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/rand/mod.rs.html#507-526) in Go and Haskell and use that as the RNG. (Using generics via e.g. `fn mutate&lt;R: Rng&gt;(progenitor: &amp;str, rng: &amp;mut R) -&gt; ~str` would make it faster/easier to switch between RNG algorithms, with no runtime cost.) Also, you should be able to write `if TARGET == current { .. }` rather than using `equiv`. Lastly, since you're using `~str` as just a vector of ASCII bytes, you should either be using `~[std::ascii::Ascii]` or just `~[u8]` which you can convert to a string for printing via `std::str::from_utf8_slice` or `std::str::from_utf8_owned`. In fact, you're currently doing an unsafe operation (that has now be removed), with `individual[i] = random_char(rng)`, since this allows one to break the invariant that strings are always valid utf8.
My bad, I wasn't paying enough attention.
Yes, I didn't think it was great either, but I hadn't seen it before.
It is likely to get faster, if anything, since the iterators don't need any bounds checking (like `x[i]` indexing does).
This is some way, but I don't really like. Seems as bad/good as symlinking.
&gt; It's about the fact that there's no good way to model classical OO in Rust right now. I've been seeing this as a positive rather than a negative. Then again, the Servo team has written more Rust than anyone else, soooo...
I would probably write the fitness function like this: fn fitness(child: &amp;str) -&gt; uint { child.iter().zip(TARGET.iter()).count(|(c, t)| c == t) }