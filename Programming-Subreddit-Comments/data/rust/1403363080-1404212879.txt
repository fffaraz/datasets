`T` is currently the suggested name for type parameters, and I wouldn't want us to start suggesting `Type` in its place because it's too easy to conflate with the `type` keyword. The difference between `self` and `Self` already causes enough confusion.
Reddit did not disaply these 2 answers until now (got "empty| notofication, was showing 6 comments bit was not disaplyed). So that does actually solve it, but why?
The trait is Encode from libserialize, so I cant shange it. Even if I could this issue does not make sense.
On the other hand, I *rarely* see an object where fields are set *independently*. Whenever I see an object with getters/setters for all fields I usually cringe, more often than not it just means this is a blob, a convenient grab bag for a collection of related attributes... but with little to no coherence or invariants enforced. Most of the times, the objects I created end up having: - one or several constructors - getters - that's it On some very few cases, I introduce *one or two* setters for efficiency or because in-place update is handy *in this case*. But more often than not I just don't need to.
Noise would go down a huge amount if Haskell's type styles were adopted I think. fn nice_generics(eval: |a| -&gt; Bool, v: a) -&gt; Bool { } Honestly, considering Swift went the direction of having uppercased types, I'm surprised they didn't take advantage of Haskell style implicit type parameters. A lot of types have bounds in Rust though and I'm not sure how that would work. Still, I can dream.
In general, you'll want the `--target` option. I'd expect you want something like `--target i686-elf`, but rustc complained that's an "unknown OS" when I did a few tests. There's probably somebody else around who can help more, but maybe this will point you in the right direction. You might also want to investigate codegen options (`-C help`), particularly `-C target-cpu`.
So why not put a firewalling proxy between the `user-agent` and the network? A whitelisting, protocol scrubbing stasi buddy.
You'll probably want, as rustboot uses, `--target i386-intel-linux`. (`--target i686-intel-linux` also seems to work, but I'm not sure if it's actually any better.) So the full command should be something like `rustc --target i386-intel-linux --opt-level=3 /path/to/rust/src/libcore/lib.rs`.
http://rustbyexample.com/ is a very good place to begin... Other resources such as rust-rosetta (https://github.com/Hoverbear/rust-rosetta) are good as well. You can even contribute your own code to rust-rosetta when you have learned a bit. Also de IRC channel (see sidebar to the right) can be very helpful if you have concrete questions.
To write good Rust code, you should understand the trickier parts of the language: the borrow checker logic, the Option/Result methods, iterator methods, the module system, macros, and what Cell and RefCell do.
Any good resources for these?
Can you point me a link to this standard? Thanks!
and the str/string/String/Str near-debacle bikeshed
Yes, because this submissions drops us into page two of a thread that was not originally about memory safety in D, but turns into one. It also doesn't help that forums.dlang.org is a mashup of a mailing list and a web forum and, I feel, is the worst of both worlds. You get the ugly quoting of mailing lists, and posts that get accidentally spun off from their parent discussion in the forum when someone is not careful, and hence discussion about a single topic gets spread out across multiple posts. It's a shame, because there is some really interesting discussion going on on the D lang forums, but I really dislike having to read them. Edit: I just browsed around quickly and ran into exactly the stuff I dislike. Everyone seems to want to quote an entire discussion before replying, and you get monstrosities like I just ran into: a 115 line quotation followed by a single line response.
This would not be too hard. I would start with [the PDF backend of Skia]. The trickiest part will be to fit the PDF rendering backend into the task structure of Servo. I would try making a custom painting task that dumps layers to PDF, and omitting the compositor task. This will work for simple documents that have only one layer. More complex documents would need a "PDF compositor" that can composite PDFs together. [the PDF backend of Skia]: https://code.google.com/p/skia/wiki/PDFTheoryOfOperation 
I don't think it's clogging things up yet. Hopefully it will, maybe we can make a dedicated reddit someday. EDIT: I've pre-emptively registered http://www.reddit.com/r/rustcodereview just in case. Let's see how it goes.
Well maybe it's true, since in my language people do the same thing in reverse: write numbers from 1 to 9 as words and the rest as numbers.
I know. It's still not helpful. 
Uhh... I was just going based on how their classes are named, like [`Dictionary&lt;TKey, TValue&gt;`](http://msdn.microsoft.com/en-us/library/xfhwa508%28v=vs.110%29.aspx). However, I did [find this](http://stackoverflow.com/a/770916/65387) which says: &gt; - If there is one parameter, I name it T &gt; - If there is more than one parameter, I pick a meaningful name and prefix with T. For example TKey, TValue And links to [this](http://blogs.msdn.com/b/brada/archive/2005/12/02/497340.aspx) which says: &gt; - DO name generic type parameters with descriptive names, unless a single-letter name is completely self-explanatory and a descriptive name would not add value. &gt; - CONSIDER using T as the type parameter name for types with one single-letter type parameter. &gt; - DO prefix descriptive type parameter names with T. &gt; - CONSIDER indicating constraints placed on a type parameter in the name of the parameter. For example, a parameter constrained to ISession might be called TSession.
(Mhm, and just getting make in windows isn't even straight forward. Is cargo going to package make? If not, really good docs for windows users is going to be really important.
&gt; I think there's no point, other than for personal satisfaction, in learning other languages if you know English, since there are very, very few places where people can't understand it Even though they may speak English, it might still be important to learn the language in order to get to know people and their culture, socialize, etc. But I also question whether there are *very, very few places* where people don't speak English. I suspect that widespread knowledge and proficiency in English is an exception rather than a rule. It's just that the vast English-speaking Web and tourist-accommodating resorts in non-English speaking countries makes it feel like English is a real lingua franca of the world.
Thanks for the information. I think it's worth pointing out that in C#, interface names are prefixed with an "I", so we have things like `IDisposable` and `ICloneable`, and they are easily distinguishable from classes or structs. So along these lines, we also have `TKey` and `TValue` there. But currently we don't have any prefixing conventions for type names in Rust, we don't prefix trait names with "T" here. (And even if we do, I think "T" for traits would collide with "T" for type parameters, and defeat the point.) And our "equivalents" of `IDisposable` and `ICloneable` are `Drop` and `Clone`, respectively. They are *verbs*, not *adjectives*, as they directly refer to the names of methods inside. C# doesn't do this. We just have different naming conventions. ;) So I doubt if we should introduce a prefixing convention for type parameter names. And generally, I'm in favor of single character type parameter names anyway. EDIT: mention `Drop` and `Clone`. EDIT: state my general stance on the renaming issue. 
What sort of issues (besides that sed thing)? I've done Rust dev for both bare i386/amd64 and bare ARM on OS X, and it's been working fine for me.
This is not a subreddit for Rust the Game. Please try /r/playrustservers :)
Great thanks!
We're going to support per-platform `build=`, so you can use a Windows-specific solution for Windows.
Macro invocations don't require expansion in order to parse a file, which has advantages over C/C++. They have to be balanced, and the macro invocation syntax can be parsed using a CFG. I think that's good for refactoring - a naïve tool can just ignore foo! and the matching ()s. You have to balance ()s inside of the macro invocation. Macros are also decent targets themselves for refactoring tools, because they have typed arguments and operate on the AST instead of directly on syntax. A complex refactoring tool could examine the signature of a macro and use it to figure out which parts of an invocation are expressions, and then run the refactoring over those expressions. The macro itself could possibly also be checked, as they're required to spit out a valid AST. A lot of the hate for macros comes from the textual replacement ones provided by the C preprocessor, I think. I don't know of any source tools for languages like Lisp, though. I don't like generating code very much - every time I see it, it's because of a deficiency in the language, its tools, or the design of the project itself. Your argument against macros seems to be mostly based on debuggers handling them poorly. I feel as though it would be perfectly reasonable for C preprocessor macros to generate line information, but compilers don't, and I assume it's because of how DWARF works. There's a lot of simple changes that could be made to make debugging macros less painful, I think. Even the textual replacement variety. I don't think it's a fundamental problem with macros as a concept. That said, I don't use macros very often. I use them for implementing generic containers in C, and I'd use them for generating language bindings (something I haven't gotten around to yet). I find that in a language with a powerful type system, macros are usually only there for sugaring up the syntax or implementing statically evaluated EDSLs, both cases are served fine with AST-based macros which can be evaluated by any source tools and operate like they weren't even there. The only time I've ever seen macros causing bloats in compile time are because of how they're used as a crappy module system in C/C++, in the worst case nearly squaring the amount of code to parse. Rust does not use textual inclusion, so that is not a problem. As for syntax extensions, I don't think they're good for tools, but there's not very many. It's reasonable to assume all of the extensions supported by rustc itself will be integrated with a complex source tool. I don't think there's any syntax extensions which are really used pervasively in any project, much less the larger one. The worst case is the tool just ignoring a few files in a project because they use extensions.
Going through PNG to make PDF would give you a PDF file only in name. If every page is just a big raster/pixel image, it would be a pity when the format support such sweet vectors.
Are you familiar with the code-generation design of FFTW (the standard fast Fourier transform library) at all? That's a pretty major example of a performance success story using code generation. Here's what "a baby version of the FFTW code generator" looks like ported to Julia's macro system: https://github.com/JuliaLang/julia/pull/6193
&gt; You say you have this working but the code on your pastebin does not compile, is it for some older version of the compiler? &gt; sorry I seem to have pasted that halfway through a change . it does work here:- http://pastebin.com/dF6UAHmQ &gt; Q2: Not as far as I'm aware, I hacked up something similar for Rustray: ok thats interesting, and certainly looks a lot cleaner. The naming reveals a difference: yours is explicitly *concurrent* , those background tasks may continue; mine is only suitable for *'data-parallel'* , like openmp - which is a simpler situation r.e. lifetimes &amp; communication. As you say concurrency needs 'proc()' which I understand as being an 'owned closure', but doesn't that mean an allocation for the environment, freed up when it completes. (perhaps you do a bundle of rays per proc) the intention of the data-parallel helper is to be lightweight, more like a loop on steroids - the environments should just be stack borrows, no allocation needed. &gt; Q1: Values have lifetimes, tasks do not. Closures are not Send. However, you can send proc. the intention to use a scope block to bound lifespan of a task - this should mean that one could safely pass borrowed pointers / borrowed closures into it. I've fudged that with unsafe code, using 'cast::transmute' to pass the closure as a raw pointer. So, perhaps thats just an abstraction yet to be built ... but I was looking at that thing returning Box&lt;Task&gt;, and wondering if that would do it for me. I supposed I want something like this.. `ScopedTask::new(&amp;||) // runs the given closure, and waits in drop() until complete` but There seemed to be a method 'run' for a 'Task' taking a normal closure already &gt; I believe after the closure reform we will be able to Send some closures. ah all in a state of flux, I guess.. 
main.bc (I'm guessing that's llvm bytecode?) causes an invalid value error `boot/main.bc:584:58: error: Invalid value` The file is generated by rust and processed by clang so I'm not sure which end the problem is on, or if it's just a version thing.
I just found this on github. It appears that the issues are known. https://github.com/pczarn/rustboot/issues/8
NB. this is memory unsafe and even undefined behaviour: since it allows for the creation of aliasing `&amp;mut` references and also data races, both of which are UB. This can be helped by bounding the closure by `Share`, that is, `|int|:Share`. However, I believe this still has both problems... capturing a `&amp;mut int` is still `Share`, and, e.g., can be mutated without synchronisation (data race). Situations like this will best be addressed by `&amp;self` closures (currently manually constructable by implementing the `Fn` trait) and unboxed closures more generally.
&gt; NB. this is memory unsafe and even undefined behaviour: certainly I've needed to use an unsafe block there, but I'm hoping there is a way to safely express this. I would wrap this further in helpers that clarify more intent... e.g. `par_map(src:&amp;Vec&lt;T&gt;,|&amp;T|-&gt;U)-&gt;Vec&lt;U&gt;` and so on. Most use cases I have in mind really will have an immutable environment, pure functional. I'm assuming the inner implementations (e.g. par_map itself calling par_for_n) could safely hide any 'rule-bending'. ...Should the inner 'par_for_n' I've got now be unsafe? Is this all waiting for 'closure reform' to express properly?.. I got the impression 'Share' would allow more if there's synchronization primitives involved. (I hope immutable closures are still on the roadmap, they definitely seem the best way to cleanly express this.. is that what 'unboxed closures' will do?) Some use cases where there might be variable output from the invocations are a bit more involved - but again these can be wrapped in more specific helpers still taking pure functional inputs. &gt; Situations like this will best be addressed by &amp;self closures (currently manually constructable by implementing the Fn trait) I guess I shoulbe be ok to just stick with the convenience of closure syntax for now and wait for closure reform to express everything properly?
We don't do overflow detection, but we allow signed integers to wrap. C++ can assume that signed integers never wrap.
This is not the subreddit you are looking for The correct one is /r/playrust
Thanks But I want To Reach Out But i dint know that WebSite So Thanks you
While I'm hardly a good example in this regard, more comments would be more idiomatic ;)
I tried to find out what cargo actually is but there is nothing in the README file or on github that tells me what it actually does.
Yeah, now that you mention it.. I'm usually not as bad with comments but I usually write the comments after the program works, not at the same time. I'll definitely do this next. 
The primary reason I speak of is the general implementation technique. In Python, properties come about as a consequence of the more general concept of *descriptors*, introduced long, long ago in Python 2.2 (December 2001), with which one can easily write the `property` type in user code. The model of descriptors *is* something which I can imagine existing in Rust, though it would be a fairly hard sell for such a language, even though it *would* make some things nicer and more convenient to implement. In C♯, properties are themselves the feature, and are just sugar for method calls: given a property `Foo`, the actual implementation, as visible from other .NET languages though not from C♯ code, is `get_Foo` and `set_Foo` methods. Of course, in Rust it would be more complex as there are multiple variants of getting (I can imagine `fn(self) -&gt; T`, `fn(&amp;self) -&gt; T`, `fn(&amp;'a self) -&gt; &amp;'a T` and `fn(&amp;'a mut self) -&gt; &amp;'a mut T` all being useful at different times). I think that having properties being the feature is probably more appropriate for Rust, probably almost only as some form of sugar. I think these comments will do for now.
They will. Thanks! :)
Cargo is the to-be official build system/package manager for Rust. AFAIK it's still in the (relatively) early stages of development so maybe that's why almost no effort is made to the documentation aspect. But yeah, a single line of description should be added and sufficient for now. EDIT: Grammar and mentioning that Cargo is also a build system. 
Thanks. Yes, my concern is mainly that a balance is maintained even though the potential refactoring/analysis tools don't yet exist. If people really push for turing-complete macro languages or whatever, then there is a risk of completely closing the door for a whole class of novel tools to appear in the future.
To answer your question: first of all, we do have a mode that allows exceptions to be disabled, and second of all, we need exception safety for Servo, which is designed to take advantage of it for a better end-user experience. But moreover, that seems suspicious to me. I have never heard of exception safety causing a 3x slowdown, especially when we're just talking about string comparisons. Shouldn't the sorting comparator be inlined, and shouldn't LLVM know that strcmp cannot fail? Edit: I just replicated this [here]. For some reason LLVM is not marking the string comparator as `nounwind`. As far as I'm concerned this is a bug in rustc/LLVM, not a language design issue. [here]: http://is.gd/pLgTdS. 
I am not certain that the differences in performance you see are attributable to that. Most stl sort implementations must actually assume that more operations might fail than rust does, including copying or swapping. Some implementations do have template specializations for when copy constructors and destructors are nothrow, but that is not guaranteed. A list of other contributors to performance differences: 1) The c++ code is only reading and sorting the first line. 2) The sorting algorithms uses are likely different. Rust's sort uses a merge sort + insertion sort for small runs, and allocates a temporary buffer twice the size of the original slice to merge results into. The stl `std::sort` is an in-place unstable sort, such as introsort, which may have better performance characteristics in many cases. I am not personally certain of the utility of having rusts default sort be stable. 3) The test code is doing enough other things that is not immediately clear that the sorting code will actually take most of the run time.
1 - There's only one line in the file tested 2 - Ok 3 - I have tested to use loops instead of the iterators I ended up using, but the performance difference was negligible.
What are the parameters you used to compile them?
A stable sort is less surprising so it is a good default. It seems to square with Rust's sanity and safety by default.
What is the impact on ffi? Type names don't matter when binding to C.
I wasn't passing any parameters. With opt-level=3 it got even faster than C++. Well, I guess that's a solved issue now.
This is probably the actual answer, and while the problem of the topic was my mistake, this information is valuable. Thanks.
How would extern "C" { fn foo(oneVar: c_int) -&gt; c_float; } Work with inferred generics? How does Haskell do it?
I keep forgetting about optimizations. I guess I'm just an idiot. Anyway, I already edited my post, and the answer was actually provided. Thanks for the help.
Denommus. He has been looking into the latest changes in the Cargo package manager. The reason he needs xpath-rs is to use the Tiled editor format. Most of these projects are long term and people have more or less time. You will probably find lot of issues that seem half-dead too. We have a philosophy of posting every concern as an issue, which generates more dead weight, but it is a nice way to work asynchronously. We start "dead" projects on purpose, because you never know when you get into the flow and then it should be set up and ready. It also help separate the thinking process from the doing process. Some people are better at analysis and you want at least one such person taking part in the library design. This is our way of relying each other, since some people work at very different times.
Is it too late to sign up to this? I'm a bit of a rust newbie (been following it for the last ~2months, spent about ~1 week using it so far) but would love to learn more from and chat with some more experienced people!
Stack unwinding affects performance by making some optimizations harder/impossible for the compiler. I don't know much that is the case with rust though, as that stuff is actually quite restricted.
It might just be me, but the split between rust-graphics and piston seems sort of awkward to me. I don't really understand the purpose of seperating the two especially in the way that they're done. Maybe im just too used to other libraries. To me it seems like there's no graphics engine in this at all. More like Piston and rust-graphics together seem like the whole graphics library.
there's the time crate: http://static.rust-lang.org/doc/master/time/index.html Nothing in std, as far as I'm aware.
Thanks. time::get_time() is what I needed.
For traits you can end the name with "Trait". I've seen that convention used in PHP. I'm not sure how I feel about it yet, I would prefer a prefix letter -- I don't know if using `T` for both would cause any problems. Maybe "A" for "Abstract" since they're pretty much like abstract classes anyway. Rust can of course use their own naming conventions, but thus far I'm really disliking their choices. I love all the ideas and features of the language, but not the naming. I think adjectives make a lot more sense for interfaces like `IDisposable`/`Drop` because if a class implements it, it *is* disposable (or "droppable" if you prefer), which makes even more sense if it defines more than one method -- you're not going to stuff every method into the name of the trait/interface, are you? Prefixing serves two purposes I think. (1) You know what it is as soon as you see it and (2) it prevents name collisions. For example, C# has both Dictionary and IDictionary. From this alone it's clear that one is an interface and the other is a concrete implementation of that interface. What would the equivalent Rust-esque name be for `IDictionary`? There's no particular method you could name it after, and dropping the `I` would cause both a collision and confusion.
You should probably be using http://static.rust-lang.org/doc/master/time/fn.precise_time_ns.html instead for time deltas
Ooh, I had something similar a while back: https://gist.github.com/bjz/9202512
I have to say these are all quite nicer than what I came up with: https://gist.github.com/phaylon/1a6edc2f5abcc4ba00f6 Apparently my brain tries to go into full genericized mode.
Thanks so much for writing these!
Thanks, that did the trick.
No problem, happy you find them valuable :)
Seeing a community form around this project is so exciting! Maybe Rust will be useful for something besides browser engines after all. :)
Unwinding (failure) isn't how destructors work. They're orthogonal features.
&gt; This is probably the actual answer, and while the problem of the topic was my mistake, this information is valuable. Thanks. It's not a correct answer though...
&gt; To answer your question: first of all, we do have a mode that allows exceptions to be disabled, and second of all, we need exception safety for Servo, which is designed to take advantage of it for a better end-user experience. It allows unwinding itself to be disabled, but it can only be used with link-time optimization, cannot be used with the standard libraries and algorithmic issues cannot be fixed. The feature could be considered checked off but it's not actually usable yet. For example, `PriorityQueue` needs to perform swaps (3 copies) instead of a single copy for each heap maintenance operation. It's currently depending on the drop flag to implement a middle ground where it does 1 copy and a 1 zero, which is significantly faster but not as fast as the algorithm written without exception support.
Rust has full blown exception handling like C++, with the restriction that you're only able to *catch* an exception at a task boundary. This is done to leverage the memory isolation of tasks to avoid worrying about many (but not all) exception safety issues. Mutable shared memory types like `RWLock` and `Mutex` need to track poisoning too, to propagate failure.
https://gist.github.com/cmr/d0e6d145af65e6d74713#file-gistfile1-txt-L205 commit 1a381fa2d257908d0a4c984b1c0e26bdede620d8 Author: Patrick Walton &lt;pcwalton@mimiga.net&gt; Date: Mon Jun 9 20:39:20 2014 -0700 librustc: Use *signed* extension when converting enums to floats. Previously, constants used unsigned extension, while non-constants used signed extension. This unifies both paths to use signed extension. If this breaks your code, take a deep breath, go for a walk, and consider why you're relying on the sign extension semantics of enum-to-float casts. Closes #8230. [breaking-change] [Relevant XKCD][1] [1]: http://xkcd.com/1172/ 
[Image](http://imgs.xkcd.com/comics/workflow.png) **Title:** Workflow **Title-text:** There are probably children out there holding down spacebar to stay warm in the winter! YOUR UPDATE MURDERS CHILDREN. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=1172#Explanation) **Stats:** This comic has been referenced 96 time(s), representing 0.3976% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
a game engine potentially covers areas other than graphics (networking, IO, sound, physics, ai, state machines, ); how things should be packaged and presented is open to question of course. 
its possible gl drivers have problems orthogonal to what Rust solves. there might be hardware bugs, or hardware documentation bugs, and a driver contains workarounds due to those; also they deal with concurrency by *hardware* (DMA) outside of what the language can check
Could Rust somehow be extended to deal with the kind of concurrency GPUs utilise?
Will package management be usable separately from the build functionality? E.g. from an existing Makefile?
This reminds me of a philosophical problem where you repair an old ship, replacing one part after another until there is no part remaining of the old ship. Is it then the same ship? http://en.wikipedia.org/wiki/Ship_of_Theseus A way to look at this is how you chose to use the word in the first place, because "the ship" is an arbitrary concept I make up in my head. In a similar way, a "game engine" is a concept I made up. The awkward feeling is a consequence of me feeling uncomfortable with changes in my conceptual representation of the world. The funny thing is when you redesign it in a way that challenges this concept. Should we keep thinking of Piston as a game engine? Does it change the purpose of what why are trying to build? (no, it does not) In practice the difference is 3 lines of code. I'm perfectly happy with referring to Piston as a game engine, but then I'm more thinking of "The Piston project" and not "The Piston library".
Please, don't use a viral license for a library. That kind of license is right for a project like a kernel but not for libraries. The only thing that you get is that other developer starts to build a library but with a license more liberal; finally you are going to loose all work done because most of people would prefer that kind of license, included companies wich could help in the code. I would use a license like Apache 2.0, Mozilla Public License 2.0, or MIT or BSD: http://choosealicense.com/licenses/ 
It depends on your goal for the library, I addressed that [here](http://www.reddit.com/r/rust/comments/2828nq/rustosc_open_sound_control_10_over_udp_in_rust/ci7down), my opinion is unchanged. If you want to work for other peoples profit for free, feel free.
Very cool! I'm thrilled to see where this goes.
Nice! What's the difference between a sorted and indexed vector though?
Traits in Rust are inspired by type classes in Haskell, and I think Rust's trait naming convention is also inherited from Haskell. Haskell, like Rust, doesn't support ad-hoc function overloading, but relies on type classes to do so. So sometimes a type class/trait can be seen as "just a generic method signature", like `Show`, with its corresponding `show` method, or `FromStr`/`from_str`. &gt; because if a class implements it [`IDisposable`], it *is* disposable Or we can say, because if a type implements `Dispose` (or rather, because we *impl*-ement `Dispose` *for* a type), it *has* a `dispose` method. ;) But this all comes down to preferences/traditions, IMHO. Rust also has plenty of traits using *nouns* and *adjectives* as names, and they may contain many methods. And onto the `IDictionary`/`Dictionary` issue. I think while C# does clearly differentiate between interfaces and classes, it fails to make clear what is *special* about `Dictionary`. It doesn't seem enough to "reuse" the generic name of an interface for an implementation, which *should* have its own specialties. I prefer the Java approach: the interface is named generically as `Map`, while we have implementations with specific names like `HashMap` and `TreeMap`. Again this is a preference thing. ;) EDIT: clarification. 
An index vector address is just simple pointer math. A sorted vector requires embedding the key into the record and using sort()/bsearch() to find the correct one.
I wonder if you're familiar with [this paper][1], and whether it might be relevant to your purposes. What you're doing sounds vaguely similar. [1]: http://research.microsoft.com/apps/pubs/?id=132619
This paper is a jewel. Thank you for pointing it out to me.
Have you considered b+ trees? They are used by almost all relational databases for representing indexed data in a cache-friendly way. It's basically a b-tree with the leaf nodes linked together so you can iterate over the whole table without traversing the whole tree when you finish iterating over a node's data. I've been meaning to try them for this purpose but haven't had the chance.
As it should be, so my hobby compiler becomes even faster without me even touching the code (muhahahaha).
I've been using it for a while and the structure really grows on you. What the piston developers have done is try to break each logical piece of game-dev architecture down to the smallest logical components, and then get them to work together without being intertangled. Think of it this way: "Piston" just gives you a window. With that window you can just use raw OpenGL, or you can plug in a 2d graphics engine ("rust-graphics") and use that instead. Its the separation of these concepts that makes it a pleasure to work with. 
I might turn something like this: https://github.com/GyrosOfWar/rust-stuff/blob/master/tsp-ga/edge.rs#L40-L48 into if self.weight &lt; other.weight { Less } else if self.weight == other.weight { Equal } else { Greater } which seems more understandable to me.
https://github.com/GyrosOfWar/rust-stuff/blob/master/tsp-ga/graph.rs#L24-L33 Iterators are almost always better than loops. I see you have something commented out... There are a lot of loops that could theoretically be replaced.
https://github.com/GyrosOfWar/rust-stuff/blob/master/tsp-ga/graph.rs#L68-L77 When you have a function that's entirely an `if`/`else`, I think it's cleaner to do an early return. You can eliminate all the extra indention on the else clause.
Tests would also be nice. That's all I got! Looks pretty good!
Warning: &gt;1,000 lines of awesome. Given how complex Dominion is, pretty impressive!
What can I say, I had a lot of help. My experience from this project has taught me that iterators are probably my favorite feature of Rust so far.
Oh, right. I'm used to using IntelliJ or Visual Studio where I usually write code, press Ctrl-Alt-L and everything looks nice. Thanks for all the suggestions, I appreciate it. As for iterators, I wanted to used them wherever possible and sometimes it worked (I really like the random_graph function) but often, I'd get a not-very-helpful compiler error like 'Type of this expression must be known here' or the borrow checker would complain about something. Then I'd try to shuffle things around a little, sometimes it'd work but sometimes I got frustrated and just wrote a version with loops. (this is why that piece of code is commented out)
* `format!()` returns a `String` whose storage is always heap allocated. Which way you return a pointer to this doesn't matter * You can only return references (denoted by `&amp;'x ..` where `x` is a lifetime parameter) if the place the reference is borrowed is alive during the whole lifetime `x`. * Your return types `-&gt; Token` are missing the lifetime parameter of the `Token` type, so the lifetime parameter is implicitly effectively `Token&lt;'static&gt;` which is the only reasonable lifetime for a **returned** reference¹. But: (!!) you can't make a `&amp;'static str` unless you have a string literal. Summary: Use `String` ¹ Edit: For a returned reference without borrowing from `self` or a passed-in function argument.
Great, thanks! I was thinking that perhaps the compiler would detect that the `String` was no longer needed, so be okay with returning a `&amp;'a str` (where `a` is the same lifetime as the `Token`, with an added lifetime so that the Token isn't `'static`). Or maybe copying the slice into a `&amp;str`. But that makes sense, I'll use `String`, thanks.
`&amp;'a str` is always a reference into a string allocated somewhere else, for example in static storage or from a heap allocated `String`. There can be no conversion from `String` to `&amp;'a str`: You can borrow, but not convert. The `String` type is needed for this text value because it has a destructor that frees the allocation when the life of the value ends, if you converted to a string slice, the information about needing destructor would be lost.
The litmus test for whether any simulator can handle the complexity of rules in Dominion is surely the **[Possession](http://i.imgur.com/703LzUf.jpg)** card. :)
I've only gotten as far as the base Dominion set; implementing Masquerade is going to be tough enough without worrying about Possession.
I think that's a great solution once the tools are up to it. Absolutely hear it on the iterators. :)
Oh my. My past, 13-year-old, Magic: the Gathering software-writing self is crying inside.
Documentation would be nice. :)
Extra blank line: https://github.com/dradtke/rust-dominion/blob/master/dominion/strat.rs#L1
All the 'unwraps' in `strat.rs` make me nervous. I wish I had a better suggestion at this moment...
Ah, great explanation, I understand `&amp;str`/`&amp;[T]` much better now. Thanks! :)
https://github.com/dradtke/rust-dominion/blob/master/dominion/mod.rs#L31 Is a little cramped. `Player + Send + Share` is what I'd write.
https://github.com/dradtke/rust-dominion/blob/master/dominion/mod.rs#L132 This function is super huge! I personally would try to break it up. I'm interested to see how long the Rust average is. In Ruby world, we shoot for &lt; 10 line methods wherever possible. I imagine Rust will be larger...
There are a couple places like this: https://github.com/dradtke/rust-dominion/blob/master/dominion/mod.rs#L223 Where Result wraps an Option. I feel like this is bad, but I'm having a hard time properly articulating why.
Wrong indentation: https://github.com/dradtke/rust-dominion/blob/master/dominion/mod.rs#L847
https://github.com/dradtke/rust-dominion/blob/master/dominion/error.rs#L8 wrong indentation, and extra line at the beginning of the file. I love this pattern, btw.
Looks like I broke the positioning of your links with my updates... my bad. The feedback is still appreciated, though.
I'd definitely be interested.
oops, I should have made them on a tree at the specific commit. I'll remember that next time!
&lt;3 :D
Related to an issue that dbaupp opened: https://github.com/rust-lang/rust/issues/15109 The `Prettify` library that StackOverflow uses already supports Rust syntax highlighting but you have to very explicitly identify your code block as containing Rust. The use of other languages is inferred by looking for a selection of tags on the post itself. (e.g. `[cpp]` or `[java]`)
Excellent article on leveraging the type system to get static checking of units. It's something that we, as developers, should honestly pay more attention to. Something as simple as a couple extra, well-implemented types can go a long way to catching whole classes of bugs during compile time. I've seen similar things done in other languages (especially those that support generics/templates and operator overloading). I think two reasons many people don't use them is either not knowing this sort of thing is possible or not wanting the "extra code". I think one of my favorite solutions is the [Units of Measure](http://msdn.microsoft.com/en-us/library/dd233243.aspx) baked in to F#. They're very easy to declare and start using; however the example in this article comes exceptionally close to being just as clean and implemented as just a library, which I think is a much better approach in the end.
I wish we could use something like this where I work. It's a mixed C/C++ codebase with extensive use of fixed point numbers, so you end up having to litter the code with `// this is blah, stored as hundreths of a degree C` or `// this is bluh, stored as deg Fahrenheit scaled 8`, and god help you when you get to that one function that returns deg F scaled 7 instead.
This is just bad API design, really. Strings have changed around a bunch, and there's lots of poorly named, incomplete, or missing APIs. They could use a good scrubbing, organizing, and being made consistent. Rust's strings were in a bit of flux earlier this year and the `&amp;str` and `String` names haven't fully bubbled out to all the methods they should. 
I'm not super great with macros, but http://doc.rust-lang.org/guide-macros.html mentions that the `ty` fragment specifier matches a type.
Nope. Embedded system with a ton of C code that uses the C++ code, so even if the C++ parts used that stuff internally, the interfaces with the C code would still not be type-safe at all.
Someone at SO replied to me on Twitter, and they're not sure that they have Rust highlighting actually implemented anywhere yet. So this might take some time. Though I'd imagine C++ highlighting would get 90% of the way.
But... there is highlighting for Rust, see the issue for an example. (I'm slightly confused...)
https://twitter.com/dhekke/status/481232540783886336 *shrug*
Extremely low-level macros are well explained here: http://blog.burntsushi.net/rust-regex-syntax-extensions Even if there is no answer, I bet the author could give you a further hint
It's worth a shot. Thank you.
A common pattern I use on my Python projects is to have a lone version.py that is importable by the package and I can just execfile in my setup.py for the build/registration with pypi. This allows me to keep my version in one place while allowing my cli tools to tell you their version. What would be the idiomatic way to do this in Rust so I wouldn't have to bump version numbers in multiple places?
cargo read-manifest spits out a JSON that includes the version, assuming it's still working properly :) 
Yep! $ cargo read-manifest --manifest-path $PWD/libs/hammer.rs {"name":"hammer","version":"0.1.0","dependencies":[{"name":"hamcrest","req":"= 0.5.0"}],"authors":[],"targets":[{"kind":["lib"],"name":"hammer","path":"src/hammer.rs"}],"manifest_path":"/home/wycats/Code/cargo/libs/hammer.rs/Cargo.toml"}
how about just a series of 's as a lifetime name - looks like sticking primes on the &amp; ... &amp; vs &amp;' vs &amp;'' .. would that parse ok?, fn foo&lt;T&gt;(&amp;'self, a:&amp;T, b:&amp;T) -&gt; &amp;'T fn closest&lt;T&gt;(a:&amp;'T, b:&amp;'T, to:&amp;T)-&gt;&amp;'T fn foo&lt;T&gt;(a:&amp;T, b:&amp;'T,c:&amp;''T) -&gt; &amp;''T I suppose it would fall down if you need to write many specific lifetimes, maybe in conjunction with unambiguous return-lifetime inference it would be enough? EDIT: "if you don't specify any return lifetime, its' the intersection of all untagged inputs" it's easy to type successive '' a syntax highlighter could assign a different colour to a sequence to make it easier to read &amp;''' &amp;'''' but it would probably get silly past 3 its not googleable but error messages can teach you, they already tell you to insert lifetime names.
My understanding (based on answers I got to similar questions) is: not really. Macros only have access to the syntax tree. The way things like `derived` work is that they understand the syntax of `struct`s and other composite types and defer handling the individual fields to a trait. So rather than generating something that does different things depending on a field's type, like: do_something_with_ints(self.some_int); self.some_struct.frobnicate(); You have to do: self.some_int.some_trait_method(); self.some_struct.some_trait_method(); and ensure that the trait you're relying on is implemented for those types somewhere.
Thanks for all the work on cargo! I'm still trying to get an idea about the planned scope of cargo since I know it's still new and shiny. Is the idea that cargo would generate static binaries? At what point is it appropriate to utilize the json data? I wouldn't necessarily want to parse the json everytime I launch a binary, I'd want it to be specified at compile time but I'm not super familiar with the intricacies of building rust packages. In C I could just pass it in on the command line with gcc but I'm not sure if the equivalent exists in rust. Sorry if I'm being dense :)
There is an Ubuntu PPA for cargo: https://launchpad.net/~cmrx64/+archive/cargo Are there plans to release nightly binaries for windows too (like rust does)? 
I was considering this, but I think it would scale very poorly at the extremes. Instead, I'd be more inclined to have a rule like the following: if the return type of a function only contains a single reference, allow the name of the lifetime to be elided. We could have this in conjunction with the rule that would allow you to omit lifetime names entirely if you only have one reference in return position and one reference in the argument list. Thus, you'd have this as the minimal example: fn foo(x: &amp;bar) -&gt; &amp;qux {} ...then, when adding another reference parameter: fn foo(x: &amp;'bar, y: &amp;baz) -&gt; &amp;'qux {} ...and then if you need multiple references in the return type you'd have to go all-out with `'a` and `'b` like today. That said, I think I prefer the proposals that I've already given in the thread. `&amp;'qux` just seems very easy to overlook, and `&amp;mut` would still look like `&amp;'mut`. But I'm really open to all suggestions at this point.
the "infer return lifetime when its unambiguous" is itself more interesting than any tweaks to the lifetime syntax, and seems to enhance all other options too , which is nice. The other things I was going to suggest: - Could making the ' trailing allow eliminating a space? ( ' is part of an ident and also terminates it) eg &amp;a'T parses as &amp; a' T or it could even be part of &amp;..', always else - maybe make it easy to defer any choice by actually allowing ' '' as part of any identifiers, like in haskell (but as prefix as well as postfix) x' 'x ''x x'' etc. EDIT: prefix or postfix, *but not both*, so 'a' is still a character literal , would that work? Then you could do what the original suggestion was, or the &amp;' idea (albeit with a space), and just claim it was a naming convention, for a non painful refactor path 
&gt; Is the idea that cargo would generate static binaries? If you want it to. Or .a/.so/.dylib. or both. &gt; At what point is it appropriate to utilize the json data? I'm not sure I understand what you're asking here.
Allowing arbitrarly apostrophes in identifiers would make `let foo = 'a';` ambiguous. In any case, even presuming that this RFC does not go through, the decision to allow a prefix apostrophe on identifiers would be backwards-compatible.
Say I want to have my binary have an option --version that outputs the version of my binary but don't want to have it specified explicitly. At what point in the build process to I slurp the version out of the json data?
The plan for this is to have this information available via the `--cfg` / `#[cfg]` system, and to beef it a bit to support use-cases like these. (so perhaps something like `let version = cfg!(cargo_version)`)
Ah cool, that sounds perfect. Thanks!
Huge -1 for me. I agree the current syntax for reference is bad, but I feel that the proposed change is worse. It really make lifetime more difficult to visually parse. At first sight you can't tell if `&amp;a` is a reference or the lifetime part of a reference. 
I agree that ' does not look particularly good and the overloading with character literals is slightly problematic (even in the ML world, the ' notation for type variables was only originally introduced to make up for the untypeability of Greek letters on the general keyboard), but the overloading with (reference) types and (reference-taking of) values the proposed bare "(&amp;)lifetime" syntax produces seems much more jarring to me given that these actually may and do occur in roughly the same contexts as named lifetimes do. The only aspect that lends visual structure to the cited "x: (&amp;a Foo&lt;b&gt;, &amp;c &amp;d Vec&lt;Bar&lt;e&gt;&gt;)" example at all (and prevents it from looking like a uniform soup of similar tokens) are the angle brackets in the type names, and those can't be assumed to be present in general. (edit: and enforcing initial caps on type names would break the fairly useful visual distinction C-like languages allow you to make between "lightweight" types like int or struct threechars and "heavyweight" types like Vec or ExceptionFactoryFactory) Until space cadet keyboards become popular again, sticking with the present syntax seems to be the lesser evil to me.
/u/wycats Any reason why you decided on `Cargo.toml` instead of the all-lowercase `cargo.toml`? Rust source files and directories use lowercase, so it seems a tad out of place.
IMHO The real problem with reference is the number of words. I really feel that multiple word types hurt readability. In the &amp;mut apocalypse discussion someone proposed to replace &amp;mut by ~ since it's now free and I really think it is a good idea. It both solve the 'mut' meaning problem and remove the need to have a space after mut. What do you think about this alternative syntax for references: &amp;Type -&gt; &amp;Type &amp;'lt Type -&gt; &amp;&lt;lt&gt;Type &amp;mut Type -&gt; ~Type &amp;'lt mut Type -&gt; ~&lt;lt&gt;Type 
&gt; There is an Ubuntu PPA for cargo: https://launchpad.net/~cmrx64/+archive/cargo This is useful for `.travis.yml`s ([example](https://github.com/bjz/color-rs/blob/master/.travis.yml#L19-L26)).
&gt; unmatched quotes make my eyes twitch, and many other peoples' too. The irony is, the quote in steveklabnik's post is unmatched
C can do something similar using one-element structs (though without automatic conversion, which in C++ is possible, but scary IMHO).
This question has been asked and answered *many*, *many* times.
I'm slightly confused by the faq. Will cargo support binary packages or I have to compile every dependency?
Seconded. Sounds like it could go wrong too with case insensitive file systems.
The fine tradition of Makefile, I suppose. ;) But I agree that all-lowercase is better.
I do find that capital C quite jarring, and I can imagine it being a nuisance when I'm trying to autocomplete from the terminal.
There is currently no effect made to define a stable ABI for Rust, and that's intentional, AFAIK. Rust 1.0 won't have a stable ABI, but there may be one later. (Or many, as I remember reading something about versioned ABI somewhere.) And yes, I believe a stable ABI is vital, eventually. Scala's lack of one (among other things) has hindered its adoption. But Cargo is a source-based package manager, not a binary-based one like Maven, which is originally written for Java, the King of ABI stability. So Rust's ABI instability would be less of a concern, at least for now. 
That looks like that particular person may not be totally up to speed with the state of SO's highlighting. *shrug*
This is a pretty useless answer... you could at least link to a few of the previous instances.
Neat! Just playing around with it - am I right in thinking that if you add a dependency, that dependecy must also contain a Cargo.toml file? Is there a way around this?
how far can inferring lifetimes go; // return the closest of a,b vs to fn closest&lt;T&gt;(x:&amp;'a T, y:&amp;'a T, to:&amp;'b T)-&gt;&amp;'a T // could you just write this? :- fn closest&lt;T&gt;(x:&amp;T, y:&amp;T, to:&amp;'b T)-&gt;&amp;T // ^^^ mark the exceptional case 'to' which isn't returned. // the return value could be either x or y, so its' the shortest of all untagged lifetimes. that seems like 'assigning a common lifetime to everything untagged', but I seem to remember a point where it was found that wasn't a good default, is there some other reason against it does a special 'self automatically declared eliminate enough useful cases too?
Thats just syntax though
For non-transient things or things where updates are expected, you can link to a specific commit, e.g. the extra blank line: https://github.com/dradtke/rust-dominion/blob/efd52eabd6c095597917a0f28da7846d41303ebf/dominion/strat.rs#L1 Pressing 'y' on a file view (including with specific lines already highlighted), will take you to the corresponding file view for the HEAD commit of the current branch. (I guess this can be used in reverse too: one can take each of your links and replace `.../master/...` with `.../sha_of_commit_before_updates/...`.)
[Here's the bug in the issue tracker](https://github.com/rust-lang/rust/issues/15046)
Really? It's not like C++ has a stable ABI, especially with vendors like MSVC breaking it with literally every version.
I'm not too familiar with PPAs, but if I'm correct only builds for Ubuntu 12 are available for the moment. I'm getting errors (libc version mismatch) when attempting to install cargo on Ubuntu 14.
C++ does not have a specified/stable ABI, and Rust has much faster build times.
What's with the hate of sigils ? I find that series of `&lt;` `&gt;` and `(` `)` hurts readibility much more, but I suppose a curryfied syntax is not going to happen as it would be too far away from C++. :/
This is how you can explain `println!` with family too: the format string decides which trait to use for each argument.
I think the problem is with closed-source components, a stable ABI is needed for interop between them (as well as between closed- and open-source components). At the very least, Rust should one day maintain ABI compatibility between specified series of releases. And now I realize that, the situation is not so different from Scala's then. (Other than the fact that Maven and the overall Java ecosystem are unused to ABI compatibility breakage.) We may need to support multiple compilers and multiple binary versions of a single component. But a well designed build system/package manager (Cargo, hopefully) can take the pain out of the process. EDIT: mention Cargo and Maven. 
Figured now would be a good time to finally put it in a proper github repo. :D
@ and ~ should be free now ... right?
I believe not having the `'` would have made understanding lifetimes a lot harder for me, since my brain would have to actively look for them instead of just react to `'` in the usual places.
Well, if we only have the information in the docs, people will start asking questions like, "then why isn't this one reflected in the name?" And as you said, in languages like Rust, we cannot just tell them to not care. And I think the simplest way to avoid name collision is to add an underscore, like `list_`, `str_` or `dict_`. EDIT: markdown syntax correction. 
It follows SemVer. There's a module in the standard library that implements checking versions, but Cargo also has a resolver that figures out which versions work.
&gt; Are there any plans to add a CLI interface... Yes.
Yes and no. Rust dependencies should also use cargo, but you can use the `script` attribute to run arbitrary commands, so it shouldn't be a big deal to have that build non-Cargo dependencies.
It refers to "your project" a couple of times, like this: "Next, add src/hello-world.rs to your project.". What is this project thing - a simple directory, or another file besides cargo.toml, or what?
A directory. There will be `cargo project` soon, that spins up the directory structure. Which is pretty simple right now.
Ta. The ToStr trait now returns a String, so when you write something that implements ToStr you have to do w.write_str(value.to_str().as_slice()) on every call. Hopefully Writer will be given a method to write an instance of ToStr, so we can avoid the boilerplate in client code.
Since the stability of rust is expected to increase over time, previous answers may no longer be correct.
I don't think it's a good idea to design a programming language to fit to someone else's incorrect tooling 
Okay, it seems like arbitrary transformations are already possible: http://blog.burntsushi.net/rust-regex-syntax-extensions If the decision to allow this has already been made, then we just need to consider how refactoring might work alongside this. There are some transformations (like regex parsing) which have no interaction with other language objects (except the regex library), so will have no interaction with a refactoring tool in general. The macro_rules! style macros will hopefully be understandable by a refactoring tool. So the only spanner in the works might be if people write non-macro_rules! macros that interact with general program objects that we might want to refactor. In this case, it might be possible to expand the macro to see whether it refers to any program objects that we have been asked to refactor and then warn the user if this is the case. In this case the user will have to do manual fixup.
This just came up in another thread: http://blog.burntsushi.net/rust-regex-syntax-extensions So, yes, it looks like you can do arbitrary stuff if you want, and any refactoring tools written will have to try and intelligently work around this.
Maybe @ for lifetimes and ~ for bitwise complement operator like in most other languages.
As I understand it, each of the component traits build off of each other. `PartialEq` just says that instances of a type have an equivalence relation. `Eq` has stronger guarantees for the reflexive, transitive and symmetric properties of equality that wouldn't make sense unless the type also had equivalence relations. `PartialOrd` just provides a mechanism to sort types `Ord` gives those stronger guarantees for transitive and antisymmetric properties. This wouldn't make sense without also having `PartialOrd` and `Eq`
Answers from under a week ago are unlikely to have changed.
Just look at https://github.com/erickt/rust-zmq/blob/master/Cargo.toml Everything in that file is useless and redundant. Just build a binary from every directory with a "main.rs", and build a library from every directory with "lib.rs". 
Cargo tracks dependencies and the files in the project, two things you need to do a build. If you use a separate build system wouldn't you have to duplicate this information in that system? Seems crufty. What's wrong with one program to both download everything and then build everything? 
In the Java world, one thing that the Maven dependency model got wrong is that it does not distinguish between internal implementation dependencies and dependencies that are exposed at a module's API. This doesn't really apply to dynamically typed languages like JS or Python. But in statically typed languages, getting it wrong causes difficulty. In Java, for example, you can avoid version clash between implementation dependencies with classloader hierarchies at runtime or bytecode modification to change package names at build time. But if you have version clash between dependencies that are exposed at the API of two libraries that are used by your project, then you have to resolve that by hand -- by downgrading to an earlier version for example. But the Maven dependency model doesn't specify this distinction, and so any version clash has to be resolved by hand or by overriding specified versions. Does it make sense to make this distinction for Rust? Will/does Cargo make this distinction?
The advantage of having build metadata outside of the source is that you don't need a Rust parser to learn metadata, you just need a TOML parser. It would suck if you had to wait to parse every project of all of your dependencies just to build. Same with all the other things you'd have to read. There will be a tool that autogenerates a skeleton, so it won't even be a big deal to set up. &gt; Also, you should perhaps use either ini or yaml, rather than this "toml" thing that nobody has heard about I can see ini, though TOML adds good things to it. YAML is *incredibly* complex, and has security issues as well. I have commit to Rails, and I think YAML is a bad config format. &gt; Finally, you should build with just "cargo", not "cargo build". This goes against the whole tool-with-subcommands thing, like `git`.
This is why most people will just use Cargo to build. The 'play well with external build tools' is needed more for interop.
Node didn't really have the issue because JavaScript is dynamically typed. Consider my project that depends on libraries A and B. A 1.0 and B 1.0 expose their use of JSON 1.0 at their APIs, by returning or consuming types defined in JSON 1.0. My project uses those types to pass data between A and B. Now B 2.0 is released, and it exposes its use of JSON 2.0 at its API. If I want to use B 2.0 in my project, I get an incompatability with A, because that uses JSON 1.0 at its API. This is a different case than when A and B 1.0 uses JSON 1.0 internally and B 2.0 uses JSON 2.0 internally, but their use of the two versions of the JSON library are not exposed at the API, they are entirely an implementation detail of the two libraries. Then I can upgrade B to version 2.0 without breaking my code.
&gt; Node didn't really have the issue because JavaScript is dynamically typed. No, it was an explicit choice of how the module system was set up. Ruby is dynamically typed, and cannot do what Node can do. Anyway, on the rest. &gt; If I want to use B 2.0 in my project, I get an incompatability with A, because that uses JSON 1.0 at its API. You do not, or at least, you will not, when Cargo is finished. This seems like a case just for data interchange formats, which _should_ be the same between versions of the library, no? JSON isn't changing, even though the library might. If you're calling code from other code, then that's a dependency, which would change your version. You can't say "I depend on JSON 1.0" and then call functions from 2.0.
I like the general idea that configuration should be inferred more, but I think saying that it is "absurd" is a little dramatic. It has to start somewhere, and usually that tends to be a little more verbose at first. If some of these were modified slightly: &gt;&gt;&gt; It should **default to** the project name from the directory name, not configuration. &gt;&gt;&gt; It should, **by default**, get the authors from git log, not configuration. &gt;&gt;&gt; It should, **by default**, get the binary name either from the project name or from the directory sources are in, not configuration. &gt;&gt;&gt; Dependencies **can be inferred** [from attributes in the source (via "extern crate")] I think there are some good usability features here.
Seems like a decent idea. https://github.com/rust-lang/cargo/issues/45
Is CTFE planned for rustc at all? It's a feature D has that I would love to see here. Also, D's mixin statements are very useful as well.
My terminal auto completes case-insensitively.
&gt; I'm asking that it should be possible to use it only to resolve dependencies and let something else control the compilation. This is possible: http://crates.io/faq.html#make
If a dependency is not yet built, you need to parse it anyway to build it, so it doesn't seem a big issue. If it has been already built, then the build output would include the metadata. Plus you can store the metadata in a central dependency registry, if there is going to be one. 
&gt; so it doesn't seem a big issue. It actually is: for example, when doing dependency version resolution. &gt; Plus you can store the metadata in a central dependency registry, if there is going to be one. There is. That will be... storing those `Cargo.toml` files.
&gt; It should get the project name from the directory name, not configuration. FWIW, we have this in on Go and it's a nightmare. People have perfectly good projects hanging out in repos that are named nothing like their package names. This makes them mostly blind to "go get" which does a lightweight take on what Cargo here does, but it expects that your package (and import path) is named the same as your repo path. &gt; It should get the version from the current git tag, not configuration. I'm inclined to agree. At that point though, why would you pull from a repo when Github gives you a .tar.gz for the tagged release? Having the .toml file there is nice if there's a preference to use something other than branching to track releases or if you haven't "released" yet. It should probably support both, with a preference for tags. &gt; rather than this "toml" thing that nobody has heard about TOML is relatively new, and it's much nicer than .INI since it has an actual specification behind it. That and parsers have cropped up just about everywhere for it. XML and JSON are pretty heavyweight, syntax wise. I've worked with TOML parsing recently and I love it.
The problem with ~ is that its not on some international keyboards, and that would suck for some people. I agree that maybe &amp;mut should be a sigil, but Idk about ~
&gt; At first sight you can't tell if &amp;a is a reference or the lifetime part of a reference. It's only in types though. So any lowercase letter following a `&amp;` will be a lifetime.
There are talks about supporting in the future, but if at all it won't happen before 1.0.
Anything that implements Ord ought to be usable by anything that wants PartialOrd. That's part of the definition.
"~" used to be a major feature in Rust and it did not seemed to disturb a lot of people. As French keyboard user, I have to press [Alt Gr] + [2], then press space to write it, but doesn't really bother me. Are there really keyboard layouts, commonly used by programmers, that can't write"~" without [Alt] + [number sequence]? 
I built and tested on 14.04, so that's a bit confusing.
If you need to define a stable ABI, you can use `extern "C"`.
I am an american with an american QWERTY layout, however from reading the original thread about removing the `~` sigil, it seems there are a few keyboard layouts without it. The argument was that if we want to be a popular language used everywhere, then we need to make sure it is easy to type out syntax everywhere, and having a difficult to type, even if not impossible, key is not worthwhile. Maybe `$` or `^`?
I’d like to have this in libstd.
A wonderful resource, thanks OP!
Sometimes, idling in IRC all day isn't overrated. :)
This has been an off-and-on project for me for a while. I know there are other emulators out there that are written in Rust, but to me it was the perfect project to learn the language. A big chunk of the CPU works and I can load iNES files that use the simple SMB mapper. There's a lot more work to do but it's been really fun so far. Coding style criticisms are very much welcome, as I'm trying to learn to be idiomatic in the language.
I'm not really sure how "stable" rust is, or how one would assess it, but for a dns-related project, check the github. DNS has been much discussed over there. Issues #9000, #8958 and others should show you how well DNS works in Rust. HTTP itself is also under heavy development is I understand it, so have a look at it as well if you want to use it... 
Destructors simply aren't run?
And in your post.
I can't decide if the currently available `http://crate.rs` would be cool or if it would lead people to think of a smoking hole in the ground. :)
I asked this on the rfc thread but I doubt it's going to get an answer there: Why does the lifetime have to appear in the type parameter list? That is, why can't `fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T` become `fn get_mut(&amp;'a mut self) -&gt; &amp;'a mut T`? You can't do this for types b/c in `fn foo(a: T)`, `T` could be a type variable or a concrete type, and `fn foo&lt;T&gt;(a: T)` disambiguates it as a type variable. Do lifetimes have a similar ambiguity? If so, could someone explain what that ambiguity is a bit? If not, what's the value of the declaration? 
If he's got a version of it online somewhere, please ask him to post it to /r/IntelliJIDEA 
I think a ML-like syntax would be too far fetched for this stage of development. I'd like to see a more pure language that takes ideas from Rust, Clean and Haskell, though. But using linear types instead of affine types.
&gt; "~" used to be a major feature in Rust and it did not seemed to disturb a lot of people. It did to the point where it was dropped. 😺
We can't always let this subreddit just scrub and brake any proposal in favour of no change.
&gt; I think the simplest way to avoid name collision is to add an underscore Yeah...I've done that in a bunch of places, but they're types! No reason they couldn't have been called `List`, `String`, and `Dictionary` respectively, particularly when all 3 of them have a literal notation.
Well, or some primitive type.
The trait relations seem logical, but the conveniences are not yet there -- right now you have to implement them all separately. The present situation for `Ord` ensures for example that the traits for the operators `&lt;` and `==` are in place too.
I don't have the feeling that the feature was droped because it was too complex to type on keyboard.
Your question is simply if Rust might be a source of frustration. A more specific question would be easy to answer. Rust is still changing for sure, and you can expect possiblly some syntax changes, core API changes, changes to important types like Option and Result, and addition or removal of any feature-gated elements. Oh and closures are up for a big rehash, so both syntax and semantics might change.
http://doc.rust-lang.org/rust.html#extern-functions
It wasn't, but it WAS a common complaint. There is at least one old thread showing that.
Oh, I laughed about it. I'm glad someone noticed.
Can you re-explain what you mean here? A file span and return a type?
The [Span struct](http://doc.rust-lang.org/syntax/codemap/struct.Span.html) is used for error reporting, but i was thinking that maybe there could be a way that rustc/syntax could take one, and return something like a [Ty](http://doc.rust-lang.org/syntax/ast/struct.Ty.html). I am not very well versed with the compiler, just posing a question.
Ahhh, I am also not familiar with that part of the compiler, so when you said 'span' I got confused. Carry on.
Yeah, but this way around means a) you have to implement partialEq/Eq/PartialOrd when they are all expressed by Ord anyway, and b) you can implement them inconsistently with Ord (and each other). It feels like it would be better to provide an implementation of partialEq/Eq/PartialOrd in terms of Ord for those that implement Ord. This gives a guarantee of consistency (though the inability to implement your own versions of these functions if you have good reasons to (e.g. performance) is a frustrating aspect of rust's trait system currently). The other issue I have with Ord is that there are potentially many reasonable orderings for a type, and you may want to use different ones in different places. This means that it's not actually useful for a lot of algorithms (e.g. PriorityQueue, which currently only uses Ord and doesn't have a seperate ordering parameter, or sort, which does require a comparison function).
That problem goes away if you disallow lifetime name shadowing, though, right? Which you could make a case for. Something like struct Foo&lt;'a&gt; { a: &amp;'a int } impl &lt;'a&gt; Foo&lt;'a&gt; { fn foo&lt;'a&gt;(&amp;self) -&gt; &amp;'a int { return self.a; } } gives a pretty confusing error message: $ rustc lifetimes.rs lifetimes.rs:9:5: 11:6 note: consider using an explicit lifetime parameter as shown: fn foo&lt;'a&gt;(&amp;self) -&gt; &amp;'a int lifetimes.rs:9 fn foo&lt;'a&gt;(&amp;self) -&gt; &amp;'a int { lifetimes.rs:10 return self.a; lifetimes.rs:11 } lifetimes.rs:10:16: 10:22 error: mismatched types: expected `&amp;'a int` but found `&amp;'a int` (lifetime mismatch) lifetimes.rs:10 return self.a; ^~~~~~ This one's not great, either: impl &lt;'a&gt; Foo&lt;'a&gt; { fn foo&lt;'a&gt;(&amp;self, b: &amp;'a int) -&gt; &amp;'a int { return if self.a &gt; b { self.a } else { b }; } } lifetimes.rs:6:5: 8:6 note: consider using an explicit lifetime parameter as shown: fn foo&lt;'a&gt;(&amp;self, b: &amp;'a int) -&gt; &amp;'a int lifetimes.rs:6 fn foo&lt;'a&gt;(&amp;self, b: &amp;'a int) -&gt; &amp;'a int { lifetimes.rs:7 return if self.a &gt; b { self.a } else { b }; lifetimes.rs:8 } lifetimes.rs:7:16: 7:51 error: cannot infer an appropriate lifetime due to conflicting requirements lifetimes.rs:7 return if self.a &gt; b { self.a } else { b }; What is the offsetting benefit of allowing shadowing in this context?
This is the answer. At the stage that macros are run, there is no information in the compiler except the (relatively unprocessed) syntax tree. Making type information available at this stage would add a whole bunch more complexity, if it was possible at all.
duplicate post! :p
#8958 seems like a typo? I need a fairly feature rich DNS library to do what I want to do so I'll likely have to start from scratch. Writing code to encode and decode messages, questions and rrs as well as sign rrsets and messages isn't too hard, but it is tedious. Probably even more so with a language that's still evolving (and no gofix like tool available).
The boilerplate of `.as_slice` is different to the naming of the various `.to_str` and `.to_string` methods. That said, there are some plans to address it, e.g. with [DST](http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/), `String` can implement `Deref&lt;str&gt;`, meaning `&amp;*value.to_str()` would work, and there's some talk of hooking up the `Deref` trait to automatically coerce in situations like that, meaning `.write_str(value.to_str())` would work. However, you should really be avoiding `.to_str` as much as possible, especially when handling a `Writer`, since it makes a pointless intermediate allocation. write!(w, "{}", value); is better, and more extensible, e.g. `write!(w, "{} =&gt; {}", key, value);` works too.
I've wondered the same thing. It strikes me that any significantly complex autocomplete system would duplicate much of the compiler. Can we not break this part of the compiler into a separate crate/module that could be used elsewhere?
I removed mine.
yes, should be #8959, but this one is better: https://github.com/rust-lang/rust/issues/8925 It has been stated very clearly that till v.1.0 the language will have breaking changes. you could wait till v.1 (somewhere this year) or you could start writing it now, make the adaptations per version (and maybe see your DNS-lib adopted by Rust.) 
No, we can't. Doing this on a crate which *isn't valid Rust code* is not in scope. You can already call the typechecker manually, but you need to feed it a complete AST, that has been through name resolution etc. It's possible that the compiler could eventually grow to do this but it's not easy.
Going through the C ABI would greatly limit the interfaces of a library (no?), and isn't there a performance penalty or the need to start multiple runtimes if we do Rust -&gt; C -&gt; Rust? I don't foresee myself using closed-source Rust libraries in the near future (if ever), and don't mind rebuilding everything whenever a compiler update occurs, if necessary. So personally I don't quite care about a stable ABI. But there are people like /u/Cthalpa that do care. I think RFCs for a stable ABI are inevitable once Rust the language becomes stable and gets used by much more developers. 
I currently use Grunt to live watch my .rs files and live run tests on changes; it has some cute features like 'only run tests at most every 5 minutes' and 'growl notify me on test failures'. Rust-empty also supports this functionality (https://github.com/bvssvni/rust-empty/blob/master/Makefile#L463) in a limited sort of way. Is that on the road map for cargo at all, or completely out of scope? Ie. Specifically, a grunt/gulp/livereload style file watcher with triggered actions when they update?
It just isn't going to be possible without a *lot* of work, in the compiler and figuring out what our ABI ought to be. ABI stability has never been a 1.0 goal. I understand the pain, my biggest want in my ideal systems language is easy ABI stability. Rust will get there, it will just take time.
I am not saying it's a 1.0 goal and I know it is intentional. See my previous posts. ;) Thanks for the reassuring.
Is Cargo going to have deduplication of dependencies?
Just wondering, are you still using 0.10? A lot of this would not compile under the latest nightly, for example the `~""` owned strings (replaced with `String` / `"".to_string()`) and `~[T]` vectors (replaced with `Vec&lt;T&gt;`).
I would expect that to be completely out of scope.
Ahhh, I see I forgot about the unfinished syntax issue. Unfortunate though! 
This really needs work. As a beginner all of the different string methods like to_str(), to_string() and as_slice() confused me because it wasn't consistent across the standard library. Is this merely a result of a lack of polish or am I failing to grasp something simple?
Lack of polish is definitely a problem. Names are all over the place and you really have to look at the types, not the names.
The most important thing to note is that there are two things people might call "strings": The `String` class. This is basically a Vec&lt;u8&gt; with methods for doing stringy things. Owned, growable, mutable, etc. A `&amp;str`, which is a reference to a string slice (unsure how people write this). When you want to make a new string from something like a number or whatever, you should call a method ideally called .to_string() that gives you a new String. This allocates memory, and writes the data into it or whatever, and gives it to you. If you have a `String` and want to give somebody a reference to it, you'd give them a `&amp;str`, which you'd get by calling `as_slice()` today, but maybe to_str() would be a better name for that. Somebody needs to go through and think out all these names and make them consistent. 
I'm still on 0.10. I took a little bit of a hiatus on this project, but upgrading to master and fixing the compiler errors is going to be my next task. I've been watching the RFCs and the release notes so I don't *think* any of the changes will be a surprise.
This would result in performing two comparisons instead of one comparison in many cases, so it can't be done that way for performance reasons. The `cmp` method on `Ord` is currently a default method defined in terms of the `PartialOrd` methods. It makes sense to override it for an aggregate type doing lexicographic ordering on underlying elements, but in most cases the default is either fine or deriving is doing the work.
Wrong subreddit, try /r/playrust
wow.. I have made this mistake more then once. Thanks.
Through a careful, well-thought-out design.
Great idea cmr!
I'd be interested to see how big the diff is from 0.10 to master. Do keep us informed!
I guess that means I can just delete the branch where I added lots of library support, extern function compatibility and tests. The same fate as the work I started on as a feature gated implementation of `become`! I think Rust and I need to see other people for a while...
Could you publish the branch? FWIW, the motivation for the removal was partly those things all lacking, so you could've mentioned that earlier (I certainly had no idea you were continuing to work and improve Rust's side of things).
Looks like it depends on an older version of libc, getting a similar error as tomaka described: https://gist.github.com/efuquen/85369807e150061e1118
I would have thought that Rust could handle it a little better, because of the context-free grammar. Well, maybe the future will tell. 
As I understand, clang's completion design critically depends on forward declarations, which Rust doesn't have, so rustc can't use the same design. That is, clang doesn't need to recover, because anything relevant to the completion would have been forward declared by the time you reach the completion point. Any Rust completion definitely would need to recover. Since Java and C# also lack forward declarations, learning from them would be more profitable.
It's not about parsing, about about being able to have *partial parsing* (which is particularly annoying with macros), the ability to do resolve and typecheck in *part* of a crate, etc. It's certainly not impossible! I estimate it'd be 2 or 3 months of work in the compiler.
The motivation is given here (offered without comment): https://github.com/rust-lang/meeting-minutes/blob/master/weekly-meetings/2014-06-24.md#removing-f128 &gt; acrichto: You might be able to have a literal for it, but certainly not in the entire range f128 supports. You can't print it. The support for it is so small. It's getting to the point where the burden of having f128 is more than the benefit of having it. &gt; &gt; zwarich: f128 isn't supported across all LLVM backends in sane ways. There are ABI issues with it. There's no usecase for it, you can't do anything with it, seems pointless to have a primitive type like that at this point. The applications in numerical analysis is debugging algorithms that have precision errors with double precision, but we have so many missing things that you'd want for numeric code that this seems ....
At the moment I'm not really interested in giving away more of my work. No one actually bothered to as to ask me about this and I find out about a decision to remove it from a GitHub pull request notification email. I'm going to be taking a break from my involvement with Rust and I'll revisit this when I'm not feeling so negative about it. It can just sit there bitrotting with my unfinished `better-inline` and `become` branches and various other abandoned projects.
I feel like this would've been turfed fairly quickly if it wasn't Patrick Walton's own proposal. Not only is there a lot of opposition, but the change does not in any way address the motivation. It's a pure bike shed over whether having the sigil or not having it makes code more readable. 
This notation could make the language less approachable, because it doesn't contain a term that new users can search for on the internet to learn about lifetimes.
For what purpose? Doesn't it work right now? The program in the post compiles and works for me on Windows.
Just use `'til` for all of your lifetimes: `fn get_mut&lt;'til&gt;(&amp;'til mut self) -&gt; &amp;'til mut T;` the return value lives at least `'til` the parameter does
f16 would be interesting , &amp; very useful for graphics programmers.
I totally agree with removing `f129`, I think `f128` makes more sense
I'm tempted to counterargue against these points, but on the other hand, maybe that would just be shooting the messenger in this context. I still think that this was a silly choice, with not enough prior communication with the community (there were people actively working on f128). It's pretty disappointing, as an outside enthusiast, to watch Rust continue to flail around in gratuitous bikeshedding, when it should be aggressively pursuing release stability. I'd really hoped I could use Rust for real projects at work by now, but the endless dicking around has just left me stuck with Go (not bad, but not as promising as Rust).
No, you only have a method returning a `&amp;str` on things that are already String-like: It's a reference into some other string, which doesn't exist if it isn't stringy.
Removing a feature that was added with no discussion is "endless dicking around"? Rust *is* aggressively pursuing stability, this is why so many RFCs have been rejected or postponed, features getting cut or postponed, etc.
In general, if you have suggestions I would encourage you to spend the time to formulate them into a polished RFC.
Agreed - unfortunately there is finite resources and more pressing concerns in the lead up to 1.0. Nothing (afaik) rules *out* `f16` or `f128`, it's just a matter of priorities.
The lifetimes have to be declared: pub struct Test&lt;'a&gt; { my_ref: &amp;'a mut TestObj } impl&lt;'a&gt; Test&lt;'a&gt; { pub fn new(obj_ref: &amp;'a mut TestObj) -&gt; Test&lt;'a&gt; { Test { my_ref: obj_ref} } } I was going to point you to the lifetimes guide at http://doc.rust-lang.org/guide-lifetimes.html but it doesn't actually explain how to do this.
You need to declare the lifetimes for `impl`ees and in functions/methods. The former is done via `impl&lt;'a&gt; ...` (same as a generic), the latter is done via `fn foo&lt;'b&gt;...`. In this case, you are required to do the former, but you can just reuse the lifetime from the `impl` in the constructor. pub struct TestObj { test1: u8, test2: bool } pub struct Test&lt;'a&gt; { my_ref: &amp;'a mut TestObj } impl&lt;'a&gt; Test&lt;'a&gt; { pub fn new(obj_ref: &amp;'a mut TestObj) -&gt; Test&lt;'a&gt; { Test { my_ref: obj_ref} } // you can also declare a new lifetime here pub fn new_alternate&lt;'b&gt;(obj_ref: &amp;'b mut TestObj) -&gt; Test&lt;'b&gt; { ... } } &gt; in such a way that the TestObj lives until the Test instance goes out of scope? To be precise, this isn't quite what is happening: an explicitly marked lifetime doesn't change the period of validity of the pointee, it just enforces that the `Test` instance is only usable while the `TestObj` lives.
Thank you for the response, unfortunately most of the guides that I see are deprecated... 
That's a great tip. Thanks.
Thank you for the explaination. Does `Test` need to own the `TestObj` instance to prevent the `TestObj` going out of scope?
simd is *barely* useful at the moment. Arithmetics work, but comparisons, conversions, and shuffles don't work and can't really be made to work because simd types are nominal, not structural, and you can't synthesize nominal types for boolean vectors, converted-to-type vectors, and vectors-shuffled-to-different-sizes. RFC PR 15 which proposed structural simd types was rejected with words "If somebody wants to push SIMD forward ... no new types". Although I understand the risk aversion, THE obstacle to push SIMD forward is precisely the typing problem. I guess I got derailed. I will stop now.
Yes, it's a problem. The good news is that documentation is about to drastically improve: http://words.steveklabnik.com/rusts-documentation-is-about-to-drastically-improve http://rustbyexample.com/ should be up to date though.
"Postponed" is okay, but I don't understand the reason to actively remove it. AFAIK, it doesn't involve much code, is not some random feature but one that is available (or going to be) in C/C++ compilers and makes sense for Rust. The active removal may send the wrong message that "Rust doesn't need this at all", rather than "Rust is not quite ready to have this." Feature-gating is already fine.
&gt; it should be aggressively pursuing release stability. This is exactly what is happening! :) Reducing scope and simplifying the compiler will make it far easier to get to 1.0 by the end of the year.
I'm really sorry to hear that. I've very much enjoyed your reddit and mailing list posts as well as of course following your pull requests. I do understand that some 'leadership' is needed in a project like this and it's not a democracy, but it seems pretty weak to remove feature gated functionality without talking to the person who is maintaining it and contributed it. May I suggest: * Someone writes a clear policy on what the feature gate is for. I would have thought f128 was a good use of the feature gate and seems to match prior usage I've observed, but of course it's not unreasonable for development practices to change over time * Community members who contributed features or implementations and act as de facto maintainers for that functionality should be given the opportunity to act as advocates for them in any discussions about their removal or future
Yeah, I think there is a miscommunication here. `f128` was added before the RFC process was in place. If it was suggested today via that process it probably would have been marked as 'postponed'. As /u/cmr stated in this thread: &gt; a good guideline I think, [is] "If it was added without an RFC, it can be removed without an RFC."
&gt; Does Test need to own the TestObj instance to prevent the TestObj going out of scope? Yes, if you wish to be able to pass around the `Test` *completely* freely (i.e. without the compiler complaining about invalid references) then you need struct Test { my_obj: TestObj } For the original code with the reference, something like (ignoring lifetime annotations for now, since there's no annotations that make this compile): fn foo() -&gt; Test { let mut x = TestObj { ... }; return Test::new(&amp;mut x); } cannot compile, because the `x` (and any references to it) are chained to the scope of `foo` since `x` goes out of scope at the end, i.e. you cannot return the `Test` which contains a reference to it because the reference would then be left dangling, pointing at the memory `x` was previously in. With the by-value version above, the `Test` gets it's own `TestObj`, which it has complete control over, and something like fn foo() -&gt; Test { let x = TestObj { ... }; return Test::new(x); } is completely fine.
&gt; AFAIK, it doesn't involve much code I don't know how much code it was because I don't in that area. But I *do* trust the people who work on that part of the compiler. If it was causing them problems then removing it temporarily is probably best for everyone for the time being.
Here is the relevant section in the meeting notes: https://github.com/rust-lang/meeting-minutes/blob/master/weekly-meetings/2014-06-24.md#removing-f128
It was behind a feature gate so it had no relevance to stability, and the compiler side of the implementation was very simple. Most of the work would have been in the libraries, and now the work that I started on that is worthless.
Removing a few dozen lines of simple code from the compiler that's following the same pattern as the `f32`/`f64` code isn't reducing scope or simplifying the compiler. It sounds a lot like "war is peace" in here.
There's a difference between removing it without an RFC and removing a feature without any discussion on the mailing list / issue tracker where the community can provide input.
I agree.
Guaranteed tail-call elimination was also *postponed* indefinitely and developing it behind a feature gate was explicitly rejected. It isn't even a large feature, because LLVM does all the heavy lifting with `musttail` and the compiler only has to parse the keyword and implement some simple type checking rules. I was very disappointed about that because I had started work on it and there appears to be a lot of community interest in it. Adding support for `f128` and fleshing out the library support was another thing I decided to work on after `compiler-rt` started gaining the necessary support. It's now wasted effort because the library code / tests are not able to compile and are just going to bitrot. Yet a *very* controversial feature like struct inheritance with non-obvious design decisions involved (unlike these two features) allowed to land behind a feature gate because it was written by a Mozilla employee and is more relevant to Servo.
But when `f128` was added, there was no RFC process to follow. So while I agree the guideline makes sense *now*, it doesn't really apply here.
So are higher precision floats if you want to actually do floating point operations without losing precision. http://www.cs.berkeley.edu/~wkahan/JAVAhurt.pdf if you have 64-bit floats, you need intermediate results in higher precision than 64 bits, currently that's 80 bits on x64 AFAIK not sure how Rust supports that
Comparisons work on integer vectors but not floats. I have personally dogfooded the current attribute-based SIMD solution and think that whilst it is 'neat' in some sense, it is also unworkable in others (eg. floating point comparisons). I didn't follow RFC PR #15 unfortunately. :(
Why was `struct` inheritance added to the language (behind a feature gate) *after* the RFC process was put in place and without accepting a `struct` inheritance RFC? It takes some intense cognitive dissonance to toe the party line by ignoring that.
It works right now and library support was being worked on.
It wasn't causing anyone problems. The compiler has an abstraction of integral and floating point types that's precision-agnostic. The necessary compiler code to support a new type like `i128` or `f128` is minuscule. The vast majority of the necessary work is library development.
Rust's `f128` was in a more useful state than the SIMD support, and it was way less "half-baked" than M:N threading. It didn't have library support in the official repository, but only compiler support had to be there to work on it in a module.
&gt; But when f128 was added, there was no RFC process to follow It was there. The patch was very small and "obvious" (no tricky decisions at all), and was behind a feature gate so an RFC was deemed only to be necessary for unfeature-gating.
Ah, I didn't notice PR 13899 till now. Great work! It seems that you made comparison of i32x4 to return i32x4 instead of i1x4, thus avoiding type synthesis problem. But ideally it should return i1x4 and be used for SIMD blend.
&gt; Someone writes a clear policy on what the feature gate is for. I would have thought f128 was a good use of the feature gate and seems to match prior usage I've observed, but of course it's not unreasonable for development practices to change over time https://github.com/rust-lang/rust/issues/15176 
... while true, that's completely irrelevant to my comment. I was explicitly only pointing out that /u/cmrx64 was talking about the real world usefulness of SIMD vs. `f128`, nothing to do with Rust's current (or former) implementations of anything. (*edit:* Is this comment really worth downvoting? I'm not arguing with /u/strncat or against `f128` or against SIMD or anything like that, I'm just pointing out the original misinterpreted comment.)
The Eclipse Java Compiler does exactly what you describe. Not only is it capable of incremental compilation, it also updates all subsystems (e.g. code completion, outline view, etc.) on changes. And in some cases it is more true to the language specs than javac. A truly epic engineering feat.
Support for `f16` would take 20 lines of code. Speaking of community effort in terms of finite resources misses that volunteers are going to work on areas they're interested in. Rust will have a smaller pool of contributors if work is turned away because it's not viewed as important for 1.0. Features like this don't get in the way of other work on the language.
Thank you. 
I explicitly asked if it needed to go through an RFC and the answer was no.
I wondered if relative modules paths in 'use' would make it easier - being able to start at a source location of interest without all the context and work outward until it has resolved whats needed. (as well as making it easier to chop and change between a subtree being a standalone crate or a component of another) 
Yep, I pushed for not needing an RFC when adding it behind `#![feature]`.
I'm not ignoring what you were saying, I thought you were talking about SIMD in the context of Rust. Extended precision floating point types are widely applicable in the real world, and were implemented in hardware long before SIMD. It's useful to perform calculations at a higher precision even if it's being stored in a lower precision storage format. A type like `long double` with no well-defined size is more pragmatic today and is widely used but `f128` is the forward-looking type for this. It won't be long before it's provided in hardware on common platforms rather than being implemented out of other primitives in software, and even in software it's way faster than *arbitrary* precision types.
https://github.com/rust-lang/meeting-minutes/blob/master/weekly-meetings/2014-06-24.md#removing-f128 contains the reasons (offered without comment).
Well, I did say &gt; nothing to do with Rust's current (or former) implementations of anything. so you weren't paying full attention. ;P
Who's downvoting /u/bjzaba's comments en masse and why? It seems totally unwarranted.
I use Vim for Rust, this looks pretty interesting. Tried out the Atom editor with your Racer plugin, but for some reason I went back to Vim. Will check out the Vim plugin. Thanks for working on this!
For what it's worth, I'm also somewhat bothered by the insularity of the meeting-based decisionmaking, but I don't see clearly what the alternative is. Most every project has maintainers who get to call the shots. (Without implying any comment on any of the specific cases mentioned.)
&gt; maybe that would just be shooting the messenger in this context. If you were to be arguing specifically with me, then yes, it would. But if you were to just refute the points to a "general audience", then it would not.
y'all, i vaguely get downvoting bjzaba all over this thread for presenting a rationale you strongly disagree with, but downvoting for linking to immediately relevant information in response to a question is kinda fucked up
It seems several people are being downvoted en masse in this thread. Possibly /u/cmrx64 and I too (or maybe we're just saying stupid things; very possible for me), and maybe /u/strncat, but I've noticed that every comment of his has been reliably initially downvoted to zero for quite a while now (not cool! :/ ).
No idea how this relates to separate compilation, but you might be interested in this earlier discussion for reference: https://github.com/rust-lang/rust/issues/10910
By that rationale you can remove half of the language, since it was implemented before the RFC process.
Yet not even contacting the person who wrote and maintained a feature before cutting it out is very, very impolite, even though you have the power to do it. Mailing lists for discussions and meetings for decisions seem to be a bit more standard and nicer to the community, in my experience.
Damn, your work on rust-gmp is actually one of the reasons I started playing with Rust, such a sad moment to see you leaving.
I'd guess it's because both /u/cmrx64 and /u/bjzaba have Mozilla flairs, but I'm not sure.
My couple of cents: regarding Q1: I think in most cases, single-dispatch is all what you need and in the cases where you need more, we might see (a,b).do_something() for other functions besides operator overloading as well. The downsides I see with this approach are that (1) it requirs a bit of foresight: You decide early on, whether you're fine with single-dispatch or need more. and (2) It seems you're restricted to pass-by-value with this tuple-style select. That's a bigger issue I think. Ideally one would be able to tune the parameter-passing style for specific types. But that's not going to work with the current trait system and seems to me even more complicated when relying on tuples. regarding Q2: As much as I miss C++-like overloading, I acknowledge that the lack of overloading has advantages, too. I'm not the expert in this, but I think it allows for a more convenient type deduction. Niko's blog post about how to do double-dispatch also discusses a bit the overloading issue and how it works against certain properties he finds desirable (though, I wasn't able to follow -- I guess, I know too little about the theory) regarding Q3: Good question. From what I can tell, the proposal would not enable the compiler to call the right function, if you erased the types independently and created a tuple on top of that. I think it only works if you create the tuple and THEN erase its type by boxing that tuple. So, no Julia-style multiple dispatch (at runtime).
looks like that was similar in spirit, it wouldn't make them completely relative , but would have made them look consistent. But it seems they say it used to be relative, and they made it absolute to solve other problems that caused
&gt; Niko's blog post about how to do double-dispatch also discusses a bit the overloading issue and how it works against certain properties he finds desirable I'd be curious to see this. losing overloading certainly isn't a show-stopper for me - its just I have a preference toward it, having had it for so long - and I've never been really happy with the OOP idea of one type being special (except for dynamic dispatch), although I like the way method call syntax approximates infix notation
Say it on the pull request or somewhere else, I am not the one you need to be arguing with. (Don't shoot the messenger! :) )
That's an overly glib misrepresentation. /u/cmrx64 did not say "only features that went through an RFC are worth keeping".
Sorry if there were any wrong implications in my words. I was not arguing with you (and with no intention to), but only stating my opinions about the reasons given.
Still, I would feel an RFC would be required to remove, say lifetimes. That guideline would imply they could be removed by a random pull request. i.e. it's not a useful guideline, given it has far more exceptions than examples.
Yes, I agree, but the guideline being wrong doesn't make /u/iopq right. :P
Removing *any* feature needs deep discussion. No matter how it was added.
I was being ironic. What upsets me about this is that someone spent time removing a feature that was being worked on by community members like /u/strncat without discussion. I understand that something like this shouldn't be added now because it can be added in a backwards-compatible way later. But that doesn't mean that everything that can be later added in a backwards-compatible way can now be removed. You'll just end up spending time re-adding it later. What's the point? Even worse, the change is just a couple of lines of code deleting f128 from a list of types in some places. It's not like there's a whole code generation routine to simulate f128 in software that has lots of bugs. You're just removing something that's feature gated from a list. Just look at the code, it's pretty much just removing it from the list and marking it removed and that's about it. The only thing that I can think of is the tests will run in 0.001 seconds faster.
&gt; I'd be curious to see this. The [blog post](http://smallcultfollowing.com/babysteps/blog/2012/10/04/refining-traits-slash-impls/) I meant is linked to from this RFC. I think it's mainly about keeping the compiler's implementation simple. To be honest, that's not something I find very compelling. 
Nope; as far as I can tell, essentially all I can see are comments and stories that that people explicitly report.
Can you be a bit more specific? I think I understand what you're getting at, but I want to make sure.
Yes, I'd assume you'd use a different tool to do that.
A lot less than .001 seconds faster, I imagine.
&gt;priorities You went out of your way to remove a feature gated project that was maintained by someone else you did not consult. 74 lines of code is not very many, but the priority should be removing broken features and stabilizing, this feature did not have a bad track record, it was implemented the same way as `f64` is, and it can only get better with compiler support and the support that /u/strncat has been allegedly working on. Whatever happens from this thread, I hope we can agree that people are unhappy with you all making changes like this unwarranted. Before things are removed anymore I hope we can have more discussion than just meeting minutes that are read hours after the fact, making it too late to offer an opinion. **edit**: when I said 'you' I meant the Rust team, youre doing great /u/bjzaba :)
/u/bjzaba did not personally remove the feature (especially since he is an intern on Servo, not a full-time Rust developer). &gt; maintained Unfortunately (since I like `f128`), [not publically](http://www.reddit.com/r/rust/comments/290qns/support_for_quadruple_precision_float_point/cigngq0).
You can choose the parameter passing style: `(a,&amp;b).do_something()`.
[npm dedupe documentation](https://www.npmjs.org/doc/cli/npm-dedupe.html) has a nice example showing the problem and how they solve it.
I'm not doing the downvoting, but in this case I'd expect it to be more of an "emotional" reflex due to the repeated presentation of the meeting notes. They are valid answers to the questions, but I think some people would actually rather have someone on the inside start a discussion on the value of allowing community-supported code in the compiler, the risks of it given the feature gate facility, and involving these community parts in relevant discussions and vice versa. Naturally, the people working on Rust for Mozilla don't have these problems, because they are probably able to communicate much tighter. I'm actually quite unfamiliar with who works for Mozilla and who doesn't when I don't have the helping flairs from here, so this question may be a bit dumb: Are there non-Mozilla members involved in the weekly meetings? Also, are the meeting notes published somewhere beforehand? If so, is it visible enough? A pre-published set of meeting notes on a Wiki (or here on /r/rust), would give the community a chance to way in, inform relevant people of the upcoming meeting contents, collect data and so on. But it would of course have to be taken into account at the meeting somehow. Right, that was longer than I expected. So, apologies for the ranty sounding comment. I figured since I'm not really involved with any sides of the fence I'd give my observations. Edit: Forgot a word
TOML is basically really good INI, so you may want to fact check yourself there, and the YAML spec is egregious so once again, check yourself. Rust is very much an 'explicit is better than implicit' language, so maybe its not your style. That is all I am going to say as the other comments refute you better than I could.
Does removing f128 really get you significant mileage on that, though? Especially since it's behind a feature gate, and presumably surrounded by very similar code (like f64). I'm just really incredulous that it was a significant maintenance problem. This seems more like "slashing the budget" by not buying a 99 cent pack of gum every month.
Well, from what I can tell, it is more common in rust that contributors develop stuff on their own personal branches before sending big PRs, so that might explain it. (some projects just allow contributors to keep a branch on the official repo to do this kind of development)
Maybe you will find AnyMap interesting: https://github.com/chris-morgan/anymap While not exactly the same, it is also a container for elements of different types.
Cargo plans on doing this, but not via the same method. It does it during the dependency resolution step, basically, you'll end up with the second tree in the first place.
You might want to check out the #rust-osdev channel on Mozilla's IRC.
Oh, fantastic!
Yeah, I am really disappointed in the voting in this thread.
They do not.
&gt; Are there non-Mozilla members involved in the weekly meetings? I am just contracting, and I will be at every weekly meeting (this was my first). &gt; Also, are the meeting notes published somewhere beforehand? The notes are created _during_ the meeting, they're a transcription of it. So this isn't possible.
&gt; I'd expect it to be more of an "emotional" reflex due to the repeated presentation of the meeting notes. Yeah, that makes sense. I was commenting late last night which is never a good thing, especially with this temporary `mozilla intern` flair (don't post when you're sleepy!) &gt; Also, are the meeting notes published somewhere beforehand? The meeting notes are usually posted within ~1 day. You can always jump in on the Etherpad as its happening if your timezone suits, or get one of the Mozilla folk to push for it on your behalf. Those solutions aren't ideal though. Perhaps a better solution can be found so it does not seem so much like an 'illuminati'.
This is the section at the end about version stuff from the email. Sorry if that wasn't more clear. Stuff is hard.
fwiw, meeting notes are basically available in real time. Decisions are often delayed until the community has had a chance to convince the core team otherwise. Even here, `f128` removal [was brought up last week](https://github.com/rust-lang/meeting-minutes/blob/master/weekly-meetings/2014-06-17.md#f128) but I guess with no community engagement followup (there was no ML posts as there have been for some decisions and not even discussion on irc besides some mention of how compiler-rt is currently buggy)
He made the 30,000th I think!
SIMD is not going away. For one thing, it isn't broken in the major LLVM backends.
Please don't link to that paper. It's very out of date and advocates `FLT_EVAL_METHOD == 2`, which nobody does anymore even in the C world.
&gt; It's pretty disappointing, as an outside enthusiast, to watch Rust continue to flail around in gratuitous bikeshedding, when it should be aggressively pursuing release stability. Removing features *is* pursuing stability.
You know, we have community members (e.g. /u/dbaupp) in the meetings.
Then the appropriate response is "Hey, I had some support in a branch. Can we talk about getting this back in? My changes weren't ready yet." Not turning this into some kind of massive "Mozilla hates the community" situation, overnight, when nobody has even had a chance to hear anything about it yet. To give you an idea, I woke up to this thread, with 60+ comments, before I even knew anyone might be upset.
You could use `Any`: use std::any::Any; fn main() { let mut x = Vec::&lt;Box&lt;Any&gt;&gt;::new(); x.push(box 1i); x.push(box 1.0f32); x.push(box vec!["hi", "ho"]); }
There is some context that is not in the meeting notes: Alex found that f128 support was causing problems in an unrelated PR (see below). It was starting to impact the rest of the libraries. At that point we had to weigh the benefits of f128 (marginal for the type of code that we support well) versus the costs (a maintenance burden in the compiler/libraries) and we decided that the costs outweighed the benefits. As someone present at the meeting I can guarantee you there were no politics involved; I had no idea who was working on f128 and I doubt most of the people there did either; for all I knew it could have been someone employed by Mozilla who added it. It was purely a technical decision. Maybe it was the wrong one, but it wasn't motivated by politics. Note that /u/dbaupp was present at the meeting, so it wasn't just Mozilla paid staff. (We explicitly try not to have only Mozilla paid staff so that the community gets input.) Edit: I have followed up with Alex and the issue that prompted removal is that somebody added range checking for float literals and because there was no string conversion to f128 we had to hack around and turn it off for f128 as a special case.
How would the extraction look like? If it's unsafe casts to the types, then I'd rather go the ```Vec&lt;enum&gt;``` way...
I'm not trying to re-invent it, I'm trying to kill/avoid it. The thing is that the exact type is known at the time of appending to the queue. Hence, there should (theoretically) be no need to re-specify the type upon fetching the value.
Could you do a useful over-estimate of the available methods on local variables based on the traits in the current function arguments; That might still be useful enough, and a step forward over simple text-based autocomplete. I was worried that 2-way inference might be hard for autocomplete to use i.e. in the general case, you're relying on code you haven't written yet to figure out all the types Perhaps adding more search in the compiler errors could help us out too - when you try to call methods that aren't available, it could tell you what traits you might want to reference to get those.
Overloading on types will make you crazy. a.equal(b); //true b.equal(a); //false if you have ANY version of overloading, it should be based on the number of parameters in that case, just implement it as optional parameters
I'm no expert but I looked at a project called [rustboot](https://github.com/charliesome/rustboot) and in there start/main function they added above: #[no_mangle] #[no_split_stack] I would test it but I'm having a few technical difficulties of my own at the moment. Sorry 
As many people have already commented, myself included, f128 was always a tiny amount of code hidden behind a feature gate. The idea that it was a stability or maintenance concern seems incredibly specious.
But equally shouldn't someone have perhaps sent a message out on the mailing list or something? I'm not really a member of the rust community but I do check here quite a bit where a lot of developments get announced and I've never heard these meetings mentioned before. Obviously this should be taken with a massive grain of salt but if fairly important changes are being made there should there not be a big sign somewhere saying "Look Here"? There may well be one and I'm just missing it to be fair. I think the OP feels rightly annoyed and it sounds like this sort of thing has happened before. It's probably not wise to disregard criticism as a "situation" straight away. Equally it may not be best to post on reddit about being annoyed with a feature being taken out, although that is more understandable. 
Please see my reply here for more details: http://www.reddit.com/r/rust/comments/290qns/support_for_quadruple_precision_float_point/cigryts This describes the exact issue that prompted removal.
I am not suggesting that Mozilla has handled this perfectly, or even well. But two wrongs don't make a right. All this thread has done is raise tensions and cause problems. It hasn't helped accomplish strcat's goals, which are to get the feature reinstated. It has been the opposite of productive. Absolutely, complaints should be registered. But there are ways to do it in which people will listen, and there's a way to do it in which you cause large problems across an entire community. Oh, and there have been weekly meetings for years. All of the notes have been published on the wiki, but at this meeting, we decided to move them to their own rep: https://github.com/rust-lang/meeting-minutes
The way C treats the final array field of a struct is very similar to how Rust will after DST (http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/). In effect you can put an 'unsized' type, including an array, as the last field of a struct: ``` struct Foo { bar: bool, baz: [int] } ``` Then put any size array in `baz`. At the ABI level, this struct may be the same as the corresponding C struct, but I'm not sure. I don't think this works today.
&gt;All this thread has done is raise tensions and cause problems Perhaps, but I think saying that someone is trying to create "a massive 'Mozilla hates the community' situation" contributes to this. 
If it is so small, then it won't be hard to add again if the feature is compelling enough and actively worked on. At the time of the meeting it didn't *seem* like it was being worked on heavily. There might have been poor communication on the Mozilla side, but by the same token it goes both ways. Mind reading is not a common skill. Contacting the decision makers directly is usually far more productive. The folks making the decisions are reasonable people.
Fair enough. I think that's an accurate assessment of this thread, not one intended to be inflammatory. Maybe that's wrong.
It's funny, but I submitted this question to meta two times. The first one is [here](http://meta.stackexchange.com/questions/217570/enable-default-code-highlighting-in-rust-tag-questions), the second one is [here](http://meta.stackoverflow.com/questions/255887/enable-default-code-highlighting-in-rust-tag-questions) (I created it after meta.stackoverflow had been separated from meta.stackexchange). Apparently, none of 20k+ rep users reacted yet :(
Thank you for the extra detail. The reasoning makes more sense now. I still disagree with it, but it seems less ridiculous.
Congratulations!
It reads like an accusation, which won't help reduce the emotions of those involved in the discussion regardless of its accuracy.
Haha, I can take it. I have the `mozilla intern` flair for a short time and it was probably only natural for the more annoyed people to take it out on me. Though cmr is [currently beating me in downvotes](http://www.reddit.com/r/rust/comments/290qns/support_for_quadruple_precision_float_point/cigizcs)! :D
For the record, `'self` *never* meant "the lifetime of this struct", it was just the only name valid for the lifetime `'here` in `struct Foo&lt;'here&gt; { ... }`, similarly in traits.
You'll have to write lang item definitions for `begin_unwind`, `stack_exhausted`, and `eh_personality`. The [unsafe code guide](http://doc.rust-lang.org/guide-unsafe.html#using-libcore) has an example. As for `#[no_split_stack]`, Rust functions compare against `(%gs:0x30)` (`(%fs:0x30)` on x86-64) to check for stack overflow. If you put the address of the top end (lowest address) of the stack there (like `movl stack_top, (%gs:0x30)`), you shouldn't need to use `#[no_split_stack]`.
I've pushed a slightly more ~~typesafe~~generic version of this to https://github.com/dotdash/rust-flexarray It has a few warts, like the empty array in the `FlexArrayField` type, which is required to get the right alignment. ~~I also couldn't figure out how to avoid having to specify the type parameter on `as_slice` and `as_mut_slice`.~~ Other than that, I kinda like it :-) Edit: Turns out I've just been an idiot, the type parameters were remains from when the methods were just functions. They are unneeded now, making the code a lot easier.
Is my understanding correct that a `*T`, where `T` is an unsized struct, would be two words? Wouldn't that make it incompatible with FFI?
Could you please elaborate?
0.10 is old and we have made bug changes since then for the better. Don't use the older and worse code. The point releases aren't much more than random days when the nightly was given a version number. No reason to use them.
That's very cool! I'll take a closer look at the code later today. Is transmuting into a `Box` substitute for implementing `Drop`?
There are a long chain of events making me frustrated with Rust and this is just the latest one.
/u/dbaupp doesn't represent the community, he's one person.
Yeah, by transmuting to Box&lt;T&gt;, you get the same behaviour as if the value was allocated using `box Foo { ... }`, which includes deallocation upon being dropped. And you also get the traits already implemented for `Box&lt;T&gt;`, like `Deref`. Will probably break / need to be adjusted once/if rust gets sized deallocations, but it's just a hack for now, so I went the lazy path.
This just leaves a bad taste in my mouth. It's just a common courtesy to reach out to contributors when things like this happens. Could have been completely solved with a single email.
Can't use that to move out of the `Any` into a concrete type again, can you?
&gt;&gt;"Overloading on types will make you crazy." Lots of things drive me crazy in C++. overloading isn't one of them... I've always enjoyed that feature, and I'm used to it. overloading lets you leverage fewer names -the compiler relieves you of work naming and finding things; and we have mature IDE's to disambiguate 'jump to definition'. I'm much happier being able to think about functions and data separately - make things work, *then* organise them, the organisation can evolve as you learn more about some new problem through experimentation. Having to decide one parameter is special, and having that burned into the calling syntax, works against that, in my mind. It's header files that are the problem in C++. can't find the right overloads, because you didn't include the right headers? IMO C++ atrocities are the result of other missing/broken features, where people stretch the features it does have to try and workaround them. a.equal(b); //true b.equal(a); //false just looks like a bug to me :)
Just updated to the latest nightly and for some reason even the `hello world` doesn't compile now. :( http://stackoverflow.com/questions/24417183/cant-find-crate-for-std-compiler-error-with-trivial-code
You can. That's what Any is for, if I understand correctly. See: http://doc.rust-lang.org/std/owned/trait.AnyOwnExt.html It is a pain to use in many cases, since you can't do "foo as Box&lt;Any+OtherTrait&gt;", so you need to either duplicate the methods onto your trait or add an "as_any" method. 
Well, I think the name was somehow confusing then...
I'm not sure I understand what you mean, sorry. What's a 2-way inference - could you give an example? BTW, racer already tries to follow function arguments when doing type inference. e.g. the following works: fn foo(s: &amp;str) { s.[complete-here] } 
You should probably use the `abort` intrinsic there.
Maybe it's just that some people thought that some of your posts weren't good/were unreasonable? To automatically assume that everyone is just being petty and mean and finding a scapegoat seems a bit, I don't know.. It's kind of weird to have a downvote-system when any use of it can just be rationalized as those downvoters being emotional/petty. Though if there clear patterns to the downvoting, then it is of course probably more of a vendetta/venting thing. 
Could you drop the macros by doing recursive types? Something like http://is.gd/iJRmCx Edit: wait that's not a queue, nvm. Might still be interesting though :)
&gt;&gt; What's a 2-way inference - could you give an example? the classic example is an accumulator.. declare a temporary , do stuff to it , rust infers its type backwards from the return expression and the function signature. I suppose if there's a local you can't yet see the type of, the best guess for the type might be "the return type given in the function signature"
The vast majority of community members / contributors aren't going to read all of the meeting notes, especially in real-time by scheduling around it.
That's strange, there are rarely problems with nightlies that bad. Try one more time with a different version and see what happens.
&gt; once/if rust gets sized deallocations Isn't [heap::deallocate](http://doc.rust-lang.org/std/rt/heap/fn.deallocate.html) already sized? Or by "sized" you mean something other than "takes a `size` parameter"?
I haven't tried doing any prior indexing yet, mainly because a from-scratch search for each query has been fast enough so far. I might be missing something, but actually the static name-resolution bit of providing completion that an index would help with is a relatively easy part of the problem. Racer has almost got this licked I think. The tricky stuff is in doing type inference of local code expressions - e.g. like inferring the type of 'n' in the following expression MyType::new().foo(35, |(m,n)| { n.[complete-here] }); 
I'd wondered if it would be useful for the language to have a concept of a 'computed size' , like a 'Sizeof' trait .. for things like:- - compacted immutable tagged unions (where a the allocated size could be just the variant actually used), - these sorts of contiguous data structures one builds in C to reduce allocations, - C strings with zero termination. Then you could do all these data structure tricks and still have it play nice with an allocator that requires size passed to 'free' (originally when i heard the term DST I wondered if thats what it was..)
Gotcha. By 'this particular construct,' do you mean the lifetime notation?
&gt; Hi, Hello! &gt; maybe im an idiot but... I'm not going to be the one to judge, but this is a subreddit related to Rust the Programming language and NOT the game. Which may or may not have been prominently displayed in several places. http://puu.sh/9JVm1/04766776e2.png &gt; My friend and just saw a rust gameplay vid and we want to play!! 1 thing... Hehas a macbook and i have a microsoft desktop, can we play together? Typically people will connect hosted server and play with everyone else online. This means that it is entirely fine to play on different operating systems. Hope that helps some!
&gt; I'm not sure how you propose overloading/overriding methods by type to solve this because of sub-type/super-type relationships Could it have been fixed by adding another overload, to actually compare an A with an B? (needs forward declaration of 'B' before 'A' is defined) IMO,better with overloaded functions `equal(A,A) equal(A,B) equal(B,A)` you could say this is actually a problem with *class methods* which overloading fixes :) // unfortunately the header that defines 'A' has to know about 'B' first. silly methods! struct B; struct A { int x,y; bool equal(const B&amp; b)const; // overload to the rescue! bool equal(const A&amp; a)const; }; struct B : A { int z; bool equal(const A&amp; a)const; bool equal(const B&amp; a)const; }; //... bool A::equal(const A&amp; a)const {std::cout&lt;&lt; "A.equal(A)\n";} bool A::equal(const B&amp; a)const {std::cout&lt;&lt; "A.equal(B)\n";} bool B::equal(const A&amp; a)const {std::cout&lt;&lt; "B.equal(A)\n";} bool B::equal(const B&amp; a)const {std::cout&lt;&lt; "B.equal(B)\n";} // now A's and B's can be compared specifically overloaded functions //a.h .. defines A, doesn't know about B struct A { int x,y; }; bool equal(const A&amp;,const A&amp;); // b.h .. knows about A // B has extended A, but A doesn't need to know about B.. much nicer, IMO. struct B : A { int z; }; bool equal(const A&amp;,const B&amp;); // overloaded functions.. all is sane. bool equal(const B&amp;,const A&amp;); // flexible and easy to organise. bool equal(const B&amp;,const B&amp;); // keeps A decoupled from B The most natural fix would be if they added extension methods, but there seems to be frustrating resistance to this. Doesn't need to be part of the vtable. It can warn you if you try to extend a vtable' object. Then you could have just added the necessary "bool A::equal(const B&amp;)const" without messing up your dependancies, and without you having to refactor your code once you realised the mistake of using class-methods. (this omission in C++ is the main reason i'm looking at rust at all) trying to make one type special, requiring important functions to be defined inside the type.. yuk. If the situation required vtables/dynamic dispatch (most of my thinking has been from situations where vtables are avoided) - then its a problem with the lack of a feature to dispatch on multiple parameters, if you really want to make multiple dynamic types interact properly... again, the problem arose by making one argument 'special'. &gt;&gt; it's just gross it's the asymmetry of methods &amp; functions that is gross; it's the way headers &amp; classes interact. Once you made the decision to use a.equal(b) instead of equal(a,b) , you mess up dependancies to fix certain problems. the maintainer of 'A' restricts what types 'A' can interact with properly, making code less extensible/reusable. You can switch to 'equal(a,b)' but now everything looks a mess with a mix of styles. its why I desperately want 'extension methods' in C++, then if you'd gone down the path of a.equal(b) you could fix it as nicely as overloads. Do we risk a similar situation in Rust with (a,b).foo() vs vs a.foo(b) vs foo(a,b) ? 
It was, which is part of why it was changed.
Of course, and the time between the meeting decision and the actual PR was certainly not long enough to consider it a well-advertised plan.
Yes, it's true that people work in private. But `f128` was added 2 months ago, and I'd personally *heard* nothing more about it, maybe I just wasn't paying enough attention on IRC.
&gt; but the problem is that if you would have included him in the conversation to remove the feature he implemented To be honest, the original patch was so small that I personally did not associate the feature with a specific "maintainer"; /u/strncat added it, but after that it was just added to the general set of global Rust features. &gt; what are feature gates for if not for this? Yes, I don't know either.
&gt; I'd expect it to be more of an "emotional" reflex due to the repeated presentation of the meeting notes FWIW, I'm personally only posting them in response to "why was this removed", since that is literally the decision making process for why it was removed. I try to make it clear that I'm not endorsing them when posting them, but shooting the messenger seems to be popular in this thread. &gt; Are there non-Mozilla members involved in the weekly meetings? Yes, e.g. me, /u/erickt, /u/cmrx64 (before he was an intern).
You want /r/playrust
Have you tried the nightlies?
I agree. It was probably more people disagreeing with the view and not the person themselves. Similar views from different people were downvoted a fair bit as well. Obligatory "but reddiquette says...". 
The empty array still needs to be aligned, so the compiler inserts padding as needed. Consider this: struct Without { x: u8, y: u8 } struct With { x: u8, y: u8, z: [u64, ..0] } fn main() { println!("Without: {}, With: {}", std::mem::size_of::&lt;Without&gt;(), std::mem::size_of::&lt;With&gt;()); } Output: Without: 2, With: 8 The compiler inserted 6 bytes of padding between `y` and the empty `z` array to satisfy the alignment requirements for `z`. Without that (and in your code), `z` starts right after `y` and might be misaligned. It happens to work out ok in your code, since you only have `u64` types in the struct. 
Unfortunately this still gives the missing failure at the link stage.
hi bucket :)
Thanks for the info! I clearly need to read a bit more about memory alignment before fiddling with manual allocation :)
This indicates an error in installation. Sometimes re-installing helps. I haven't had time to pinpoint the exact error, but I'm pretty sure it's just due to having multiple versions accidentally installed at the same time.
That's great to hear that there is a Rust meetup in Germany. I'm from Hamburg, so Hannover would be relatively close. Tempting ...
I think that either adding the `#![crate_type = "staticlib"]` attribute to the top of your crate, or compiling with `--crate-type staticlib` would work.
Hah, that's a stack, and I got it in a funny all-comments source here: https://github.com/kvark/heterogene-rs/blob/master/src/stack.rs
(Note that the playpen has caching, to avoid being forced to reevaluate popular links, so you're likely to see `22` as the answer every time you run it. Change the source slightly (e.g. adding some whitespace) to see the value change.)
While it's nice to hear that there is at least a somewhat decent reasoning for this change, I can't help but wonder why communication is failing so terribly here. How is that not something that Alex has said on the PR, where thestinger is desperately asking for a proper reason? How did no-one think to talk to the person that implemented the feature? Nobody in the room knew who that is, fine. Not an excuse to not look it up, or ask whether the implementer is present How did implementing the string conversion instead of removing f128 not occur to anyone? As I understand it, it was actually being worked on. Again, nobody in the room knew that. The slightest amount of communication would likely have turned it up though. On top of that I'm not sure I have actually seen anyone from Mozilla admit that this was dealt with poorly, and should improve in the future, which I find rather sad.
That is a fine workflow (I do it myself), but it is important to keep the decision makers in the loop if you are doing some major work, otherwise your hard work might be wasted. It's good practice on any software project.
&gt; this was dealt with poorly, and should improve in the future I agree with this. We need to learn and move on. I don't speak for Mozilla though (I am just an intern). I personally knew that /u/strncat had made the patch, but assumed that the rest of the room knew otherwise I would have spoken up. In hindsight I should have double-checked. I don't know if that is enough for you. I don't think anyone here is acting deliberately maliciously though. It would be great if we could all (myself included) be a little kinder to each other. As the quote goes, "everyone you meet is fighting a hard battle".
&gt; Meh, hit an ICE I did too. For me the backtrace matched [#14889](https://github.com/rust-lang/rust/issues/14889). Adding `#[unsafe_destructor]` as suggested "solved" it for me
&gt; While it's nice to hear that there is at least a somewhat decent reasoning for this change, I can't help but wonder why communication is failing so terribly here. &gt; On top of that I'm not sure I have actually seen anyone from Mozilla admit that this was dealt with poorly, and should improve in the future, which I find rather sad. Because people are not giving us the benefit of the doubt, and turning this into a "community versus Mozilla", which I find rather sad. I don't see anything wrong that we did, and I find this whole situation somewhat absurd. We're talking about a tiny feature here; we are the most openly developed language I know and yet people *continuously* insinuate that we're maliciously attacking the community, which is frankly rather frustrating after I have spent hours and hours in meetings talking about how to involve the community more in language design. Go look at the ISO standards process if you want a real pay-to-play elite cabal. We try hard to involve the community in the language.
I know I don't speak for just myself when I say there is a long chain of events where we're frustrated with *you* and this is just the latest one. Your behavior in that bug report was not productive.
I'd be happy to remove struct inheritance as well.
If you look on [pczarn's rustboot](https://github.com/pczarn/rustboot), you'll see they define __morestack to nothing in [boot/loader.asm](https://github.com/pczarn/rustboot/blob/master/arch/x86/boot/loader.asm): abort: __morestack: jmp $ gdtr: dw (gdt_end - gdt) + 1 ; size dd gdt ; offset 
If that is your perception, that is unfortunate. To me this is not "community versus Mozilla", and I'm not attributing this to malice. But that doesn't mean everything went well, or that everything is perfect here just because the ISO process is worse. This decision obsoletes hard work a community member put into a branch extending this feature, and originally implementing it. He did not even get the slightest chance to defend the feature. The RFC process to involve the community is great. Introducing it was a splendid decision. It's all the more unfortunate that this change did not go through that process, even though it removes a feature and should normally have been forced to. In this context claiming no mistakes were made is frankly a slap in the face of the community. I do assume there are no intentional attacks against the community, and in particular no malicious ones, but clearly some members of the community are feeling attacked, and that should be dealt with. Claiming this is just the community not honouring your hard efforts, is just another way of making this "us vs. them" instead of trying to get along as a "we".
&gt; In this context claiming no mistakes were made is frankly a slap in the face of the community. I disagree. The RFC process was never intended to apply to all backwards-incompatible language changes; we would slow down the pace of development too much. Major features need to go through an RFC, but we have to be able to make decisions on minor features like this one. The fact that we have community members in the meetings is enough to give the community a voice.
That's a really cool example. Played around with it, mostly by just commenting out the the break statement to see what happens. I just learned a lot about rust and the compiler by doing that.
Incidentally, this is why we have `loop` in the language. (Java is this smart too, but *only* if you write `while (true)` or `for (;;)`—synonyms like `while (1 == 1)` don't work as I understand it.)
Can anyone explain what is happening there and what it says about compiler smartness?
Normally Rust won't let you access a variable that it isn't sure was initialized. For example: fn main() { let mut foo: uint; if 1 &gt; std::rand::random() { foo = 1; } println!("{}", foo); } won't compile, because the compiler can't be sure that the `foo` variable is always initialized before use. In the example, however, the compiler is smart enough to deduce that the variable is always initialized, because it is set just before the only `break` statement on the loop. This shows incredible amount of polish, I wouldn't have bet on it compiling. EDIT: for some reason my snippet had ridiculous amounts of whitespace
Make sure you uninstall your old version and then just grab a new nightly when it comes out or grab it from the github master.
Maybe its just the dependencies list that's messing me up, but rust-graphics is listed as a dependency of Piston, which just seems weird (Though I don't really see anything in Piston that depends on anything in rust-graphics). 
That's impressive that Piston works with Cargo already! I'm going to try it at the spinning trianglthon. Now we need to figure out how to keep Rust + Cargo + Piston all working together consistently. This is going to be so fun.
I didn't even know that `let x;` worked :D This is amazing!
Another thing to note is the `compiler_knows_this_is_initialized` variable in the original example is actually non-`mut`, demonstrating the compiler knows that it will only be "modified" once.
Why should not you be able to use Rust-Graphics like traditional graphics libraries? Why should a game engine have dependencies in this exact way? The window back-ends rely on gl-rs and you if you use hgl-rs it's calling gl-rs underneath. rust-graphics might use rust-image in the future, but rust-image is used by the opengl graphics back-end. There are lot of dependencies that are more subtle in this picture. I just decoupled it in a place to make each part replaceable.
The message that I'm not welcome except as an outsider has been loud and clear for some time. My involvement with Rust wasn't the same since I first decided to voice a [dissenting opinion](https://mail.mozilla.org/pipermail/rust-dev/2013-November/006550.html) about something. I see it in an increasingly negative light and I'm not going to hide those feelings when I respond to something like this for the sake of productivity. 
Also one of those moments where you stop to realize what a pain in the butt it must be to write a Rust compiler :P
Thanks for the great work! A few questions: how do you see Cargo and Rust-Empty interacting in the future? You mention that Cargo will replace "at least some" of Rust-Empty's features - which ones do you have in mind? `make exe`/`make lib` and friends?
Thanks for showing good leadership on this. I'll also try my best to be better (I didn't do a very good job on this thread).
Without `#[unsafe_destructor]` it wouldn't even compile. With it, I get an ICE. I'll look into that later today.
Then if you're going to remove a feature announce the idea somewhere everyone involved can see it. A mailing list or where ever.
Perhaps people aren't giving you the benefit of the doubt because you've denied you did anything wrong at all, even thought there was little justification given for the removal. It's not been elaborated here but surely only telling people now is a mistake?
pretty new to rust: what does "1u8" mean? EDIT: oh its just the number 1 with unsigned 8bytes
Well I tried `let mut compiler_knows_this_is_initialized;` and it still compiled.
Yes, I mean the need to put the lifetime after the `impl` keyword *and* after the struct name...
As it should. The problem is not with `mut` variables being written to exactly once, but with non-`mut` ones not.
Are there any plans to use the EBML metadata in compiled crates instead of the source code?
Reading this several times to understand it. Why does this RFC include changes to enum, and why allow enums to have fields? This seems like 5 proposals in one. Why not make it simpler?
This. But, it's going to be a pain to spec this, given that it isn't a lint.
What about trait fields instead of inheritance? Would that be an alternative? ie. trait Foo { a: int, b: int, fn sum(&amp;self) -&gt; int { self.a + self.b } } struct Bar { a: int, b: int, } impl Foo for Bar {} // compile error if Bar doesn't have a: int, and b: int fields // alternatively, it could add these fields to Bar and give an error if they're already present let bar = Bar { a: 10, b: 4 }; let sum = bar.sum(); // Bar gains the trait's sum method, but could also implement its own.
On a separate note, the Windows installer changes a user variable called path (I don't know why some programs use that variable) and this means I can't run rustc from the command line until I add it to the system path.
Which use cases does inherintance enable that are not supported by defining a trait with getters and setters for the base struct?
Smaller RFCs are easier to review, but if multiple changes are required to support the desired use case (and supporting that use case is the primary motivation for the change) then in my opinion is makes more sense to view the whole thing together.
Rust-Empty got some features like the 'watch' script which is very convenient, but not strictly within the domain of a package manager. Everything library/executable related will follow Cargo or try to bridge them somehow.
If all variants had the same first field, the rust could perhaps coerce the enum into the type of the field. (assuming that the memory layout allows this) struct E2Base { f:int} #[derive(EnumCoerce)] enum E2{ Variant1(E2Base), Variant2(E2Base, int) } let x= Variant2(E2Base { f: 34 }, 23); println!(" f={}", x.f); // Coercion 
Plus is or, and * is and as I understand it. Implement * for it too.
Thank you for commenting on the RFC, my opinion is exactly yours.
&gt; Can somebody show me that using the range function from the Iterator trait is just as quick as a simple i++? This tool is very useful: http://is.gd/XjO8Z8 If you click on the "asm" button at the bottom, you can see that the compiler unrolls the loop and calls `println!` ten times. This probably as fast as you can get.
Okay, thank you. I think this compiler intelligence should be highlighted in tutorial documents because intuitively it makes no sense to call a function for a tight loop. Something along the lines of: &gt; don't worry, the compiler will intelligently unroll short loops if it detects this! There is no function calling overhead! --- But I worry about situations where a pre-condition needs to be run each iteration of a loop - and that pre-condition isn't a simple increment. As I've said - I really don't like `while` - and much, *much* prefer `for` - because it is just *too* easy to make a simple mistake and forget to evaluate the pre-condition in a `while` loop. I don't dispute it is possible to emulate a `for` loop using `while`. But in my experience it is dangerous to do so.
We are planning one in Berlin, soonish (next month, probably). Follow me as @argorak on twitter, if you are into that. If you need assistance in setting one up in Hamburg, let's talk as well.
Thank you for your response. I imagine there have been lengthy discussions as to why C-style loops have been avoided. I know they aren't *cool* - and I do agree the `Iterator` trait is a very useful style of programming to have in one's toolkit. However I'm sure it would encourage greater adoption of Rust to have the option of using one of the world's most commonly used conditional structures. Also how do you deal with situations other than simple increments, such as: for ( i = 0; i &lt; 10; i += 2 ) or for ( i = 1; i &lt; LIMIT; i &lt;&lt;= 1 ) or for ( i = 1; i &lt; LIMIT; i *= 10 ) (for examples). Again it would seem unintuitive to have to call a function call instead of simply executing `i *= 10`. Am I missing something here? --- Edit: thanks to /u/ruffertallou for pointing out that my last two examples couldn't start from zero.
`for ( i = 0; i &lt; 10; i += 2 )` Can be done with `std::iter::range_step` but as far as I know your other examples aren't easy to reproduce as iterators.
&gt; Also how do you deal with situations other than simple increments, such as: Write an iterator or [use a built-in one](http://doc.rust-lang.org/master/std/iter/fn.range_step.html), or just use a `while` (yes, I know about the problems with it). In any case, many things that would be done with plain C for loops can be written at a higher level using [all the iterator adaptors](http://doc.rust-lang.org/master/std/iter/trait.Iterator.html). e.g. [I wrote this a few weeks ago](http://huonw.github.io/2014/06/10/knn-rust.html), there's not a single manual loop in it! I personally do not thing that the set of things that don't fit an iterator and for which `while` is very "dangerous" is large enough to warrant adding yet another looping control flow structure to Rust. &gt; Again it would seem unintuitive to have to call a function call instead of simply executing i *= 10. Small functions (i.e. those for which the call overhead will matter) can be inlined; that's how `range` is efficient.
Another style of `c-style for` loop that is difficult to do with iterators, (but arguably it should actually be done with a `while` loop) is: for( int i = 0; i &lt; 10; i++ ) { if condition { i-=2; } // More code here. }
Additionally, I'm convinced it's possible to make a nice `for` style macro, though I do not have one on hand.
It's kind of shameful that this doesn't generate an efficient inner loop: http://is.gd/DgjCkJ
The following also works, but it may be simpler to use a while-loop use std::iter::Unfold; fn main() { for i in Unfold::new(1u, |i| { (*i) *= 10; if *i&lt;=10000 {Some(*i)} else {None}}){ println!("{}",i); } }
I would argue that using a custom macro for control flow is bad style, because you are effectively programming in your own dialect of rust. 
&gt; I don't dispute it is possible to emulate a for loop using while. But in my experience it is dangerous to do so. However, it is possible to do everything a for loop can with various iterators. Python doesn't have a C-style for loop and I've never actually felt the need for one.
Here is one: #![feature(macro_rules)] macro_rules! cfor( (($init:stmt; $cond:expr; $step:expr) $block:block) =&gt; ( { $init; while $cond { $block $step; } } ); ) fn main() { cfor!((let mut i = 1; i &lt; 1000; i *= 10) { println!("{}", i); }) }
I wrote just now a c-like for-loop macro to show it's possible, but it is a bad idea to actually use it, as there is no performance penalty or anything wrong with regular loops using iterators - as explained by dbaupp. Here it is: http://is.gd/f6TVlB
its for internal vtables I think? many things seem conflated in the RFC i think
**Now available via cargo: [docs](http://www.rust-ci.org/huonw/cfor/doc/cfor/), [source](https://github.com/huonw/cfor/).** ^^*Update* ^^2014-08-10 That doesn't solve the problem in the post: `continue` will still skip `$step`. --- #![feature(macro_rules)] macro_rules! cfor { ($init: stmt; $cond: expr; $step: expr $body: block) =&gt; { { let mut first = true; $init; while { if first { first = false } else { $step } $cond } $body } } } fn main() { cfor!(let mut i = 1u; i &lt; 32; i *= 2 { if i == 8 { continue } println!("{}", i); }) } prints 1 2 4 16 
I agree, this is a slightly better pattern, if you're prepared for the update to occur even on the first loop. Why am I so hot on the update occurring in the loop declaration? Because I've seen a few killer production examples where complicated while loops failed to update the condition variable... if it is part of the loop declaration then it can't be forgotten.
&gt; it is possible to do everything a for loop can with various iterators I don't deny this. But sometimes writing a new function can be overkill when you want to make an update that can be expressed very simply. e.g. for ( i = 19; i &gt;= 0; (i / 2) - 1 ) Having to write a custom iterator to perform `( n / 2 ) - 1` adds verbosity and it may not be reused anywhere else in the code.
And that is precisely why macros are a good thing. Adding your own types or functions could be said to be the same thing! But decades of history have stigmatized syntactic abstraction rather than procedural or type abstraction.
Note that doesn't solve the `continue` problem described in the post. [See my comment above](https://pay.reddit.com/r/rust/comments/2957fg/can_i_request_a_c_style_for_loop/cihkh5t).
Most of the problem there is the current boxed closures being stored in structs, leading to dynamic calls. Unboxed closures will eliminate this overhead.
Given the design guidelines of Rust, iterators would not be used if they weren't both fast and safe. It has nothing to do with *coolness*. Rust also needs bounds checking, in general, to preserve safety. But this can be turned off in trusted code. I have never seen the Rust compiler, but it makes intuitive sense to me that it is easier to make iterators that encapsulate the actual indexing, and then turn off bounds checking in that vetted implementation, then it is to scan the code for certain idioms (like the typical for-loop indexing over the entire array). The compiler would have analyse how the index i is used - is it incremented only once, is it mutated later, ... . Then you might want to implement elimination of bounds checking for iteration with regular while loops, and so on. This seems a whole lot messier and surprising (subtle bugs can trip you up, giving you both wrong indexing *and* unwanted bounds checking), and having to make sure that you stick strictly to certain looping-idioms in order to make sure you avoid bounds checking overhead. On the whole, a whole lot more *magical* and surprising than to encapsulate the indexing in iterators. 
&gt; I think this compiler intelligence should be highlighted in tutorial documents because intuitively it makes no sense to call a function for a tight loop. Perhaps things like that should be highlighted. But in general, you might as well get used to seeming 'compiler intelligence', since this is a low-level language that tries to use high-level constructs where it doesn't compromise efficiency and safety. In such a language, it might be inevitable for a lot of 'intelligence' to be encapsulated in libraries that allows high-level code to be compiled to efficient code. 
You're absolutely right of course. My brain was too focused on the complex increment part of the problem.
perhaps some extra cases for macro invocation syntax would make them look more natural for i in .. { } // nice forloop!(...{}) // sticks out like a sore thumb forloop!(...){ } // a bit better could also mimick the old do notation more closely, and make macros that declare entities like structs with associated stuff look more natural. Would that introduce parsing ambiguity ? 
In lower level languages like rust the compiler will generally be pretty good at optimizing even moderately complicated constructs. The thing to count is pointer de-references that access new memory. Cache misses matter, and they generally can't be optimized away. Even if range() really was a function call, the runtime cost would be dwarfed by the next cache miss. And even with cache misses (or page faults when you're thinking bigger), premature optimization is still the root of all evil.
The problem with giving everyone the ability to write there own mini language is that *everyone* will write there own mini language. It can become very difficult to maintain if you didn't write the mini language. I don't think types and functions are the same because functions are just reusable bits of code. If you ask need to ask yourself how it works you can just go check the code. That's a lot more difficult to do with macros when any kind of wizardry could be going on. You may say "no worries, just check the docs" but quite often documentation is not as good as it could be.
The problem with giving everyone the ability to write their own types and functions is that *everyone* will write their own types and functions. It can become very difficult to maintain if you didn't write those types or functions. I don't think macros are the same because macros are just reusable bits of syntax. If you need to ask yourself how it works you can just go check the code. That's a lot more difficult to do with types because any kind of wizardry could be going on (see: any advanced Haskell library, see: any complex function, esp using unsafe code (see: servo's unsafe hack to get inheritance)). You may say "no worries, just check the docs" but quite often the documentation is not as good as it could be. Less sarcastically, it's easy to write unmaintainable code with any featureset, and syntactic abstraction can *help* here. If you can trust a programmer with functions, you can trust them with macros. This is the exact sort of stigma I hope we can overcome.
I didn’t like the fact that no one bothered to answer to Daniel’s arguments and simply linked to the meeting notes which were imo quite vague, plus he actually did respond to what had been said in the meeting notes. Through I am confident it will get better if any removal gets through an RFC.
I don't think you needed to be so sarcy. It was a bit facetious. Functions are a lot more readable than macros because they're normal code. When I learnt clojure it took me a long time to be able to reason about macros because you need to keep track of a lot more. More than just parameters like in functions. They can help if used well. But the space to misuse them is a lot larger than normal code. A lot of people believe that Python is the easiest code to read, possibly because: * It is uniform. There are some keywords that you have to learn and how to use them but other than that everything is the same. There's no sometimes you can miss the brackets out like Ruby. * It is familiar. There are more uniform languages, like lisps, but Python sticks to idioms that people know very well * There's lots of good documentation. If you have forgot something then just look it up. Obviously this is subjective. If you have extensive use of macros in your program then you can cross of the top two of those points. This makes the code more difficult to read and reason about. &gt; see: any advanced Haskell library You can't really do that much wizardry with types in Haskell. You can with the code around the types. &gt; see: any complex function Functions can be misused, yes, but to a lesser extent. I want to stress (I already thought I had but clearly not) coding is hard and any feature of a language can be abused. Fortunately not every feature of a language can be abused to the same extent. EDIT: I should add that you can trust trust programmers with functions and not macros because macros have the ability to completely mess up the readability of your codebase. Functions can do the same, but it's a lot more difficult to achieve. I'm not arguing against macros being in languages - they're useful - but I think people need to be careful about using them.
I wish there was a function like [this `seq`](http://is.gd/XG0lTr) in std. Then you could write last two of your for loops like that: for x in seq(1, |x| x&lt;&lt;1).take_while(|&amp;x| x &lt; LIMIT) {} for x in seq(1, |x| x*=10).take_while(|&amp;x| x &lt; LIMIT) {} Then using while instead of iterators would be necessary only if you modify `i` inside a loop, which is a really minor case, I think. Edit: Similar thing can be done with `Unfold`, like Bob_goes_up [suggests](http://reddit.com/r/rust/comments/2957fg/can_i_request_a_c_style_for_loop/cihjq51), but that solution is really cluttered in comparison to a C-style `for` loop.
It wasn't civilized to say "this is yet another reason why C and C++ are better languages than Rust".
No, I mean, if I have two files, `Cargo.toml`, and `cargo.toml`, and I type 'c', and hit 'tab,' it will fill in `Cargo.toml`, and then another 'tab' will show `cargo.toml`. My file system is case sensitive. It's a shell feature.
r.e. range_step() would a composable .step(n) work.. for i in range(0,10).step(2) { // a bit more faffing around, admitedly, but clarifies args } for x in foo.iter().step(2) { }
Iterators aren't just "cool", they are also faster, because they don't need to do bounds checking as much.
&gt; Functions are a lot more readable than macros because they're normal code. That argument could be used to argue against any kind of unusual or unfamiliar language feature. Imperative code is easier to read than functional code to a lot of people because it is 'normal code', ie they're much more used to it.
&gt;&gt;Functions are a lot more readable than macros because they're normal code. &gt;That argument could be used to argue against any kind of unusual or unfamiliar language feature. I don't think it can because macros aren't normal code really. Option types are unusual features but they are, in the language, normal code. They're not treated any different, unlike macros which are treated very differently as they are chopping and changing code. &gt;Imperative code is easier to read than functional code to a lot of people because it is 'normal code', ie they're much more used to it. I know, I said "Python sticks to idioms that people know very well". 
I don't want to attack people personally here. I'll just say that there is a significant history here that you are missing and leave it at that.
I think "tone policing" is really important if we're going to develop in the open, or else language design just devolves into shouting matches. Put another way, there are some important decisions that have to be made that *will* disappoint people. We just can't have people who are disappointed by any given decision publicly start claiming that they're being blackballed by the core team or start bashing the language every time it happens and maintain a functioning community. I've been overruled in my language design ideas *countless* times in the history of Rust, but I'm not miffed about it—heck, I joke about the terrible ideas I was responsible for (shape glue, type lattices, `mutable?`, half-indents for case blocks, constructors, `-&gt;` for method calls, named instances, the `module` keyword, `uint8` and friends, placement `new`…) :)
I definitely think `std::iter` could do with another once-over, with ergonomics in mind.
Though that sounds correct from a high level point of view... I've been programming in C for most of my life. I've probably seen it all when it comes to silly mistakes. The problem is that Rust still exposes the `while` loop - which, in my opinion, is *far scarier* in terms of resulting hard-loops. So the argument that `for` is simply too dangerous doesn't sit well with me. Anybody used to a conventional `for` loop might just resort to using `while` and the results could be disastrous. And Rust is supposed to be a safer replacement for C, right? So why abolish what has been proven over the decades to be a popular control structure? Could it be that Rust will alienate highly experienced C developers for the sake of pleasing functional language purists? Why can't we offer both structures (conventional and functional)? Or at a minimum allow a C-like loop structure in the `unsafe` block?
'Normal code' in this sense means 'a standard part of the language everyone should understand on sight'.
As I said in my other response, "tone policing" is very important for being able to design a language, and there's a long history here you're missing. Empathy goes both ways.
Agreed. I should not have pushed the review through without discussion. There were several opportunities missed to avoid escalation.
&gt; Could it be that Rust will alienate highly experienced C developers for the sake of pleasing functional language purists? In modern C++ naked looping now discouraged in favor of iterators. It is not just functional programmers here. Using iteration has very practical benefits in terms of code maintenance.
&gt; Using iteration has very practical benefits in terms of code maintenance. I don't disagree. There any many ways things can be done to improve code maintenance. For example, commenting - should Rust enforce commenting? The danger in forcing users to use a particular style is that the language ends up like Python (forced layout) or Java (must catch every exception that could possibly be thrown). C++ became popular because you *could* do whatever you wanted *including* using iterators. I think outright removal of a very practical and simple looping technique - while retaining the likes of `while` and `loop` is rather petty... and could ultimately affect the language's adoption.
You come off as a bit of a purist yourself. Perhaps it is like this; iterators are meant to be used for most looping over data structures. For more general looping, use while-loops. With regards to those supposed cases where for-loops are more elegant than iterators and 'while' (perhaps somewhere in between the two extremes of standard looping over data structures and general looping) - perhaps there hasn't been found enough cases in order to justify another language construct. 
Good thing they can rely on LLVM infrastructure, which gets them a lot of cleverness for free.
The list of "dependencies" aren't actually what "Piston" depends on. It's a list of projects that are made to work with Piston. I'll change the wording in the README.
&gt; Edit: I have followed up with Alex and the issue that prompted removal is that somebody added range checking for float literals and because there was no string conversion to f128 we had to hack around and turn it off for f128 as a special case. It’s good to have that written down in meeting notes and/or PR description.
Even if asm.js provided enough to compile rustc to it, I have a feeling that sending 400MiB of JavaScript to a web browser isn't going to turn out well. It would also completely rule out using the concurrency features of the language, because JavaScript has no threads. There are only web workers without shared memory.
&gt; Or experienced. You're right. I don't really know you, or your background. But you don't seem to be giving everyone else the benefit of the doubt. You start off by implying that iterators are used because they are 'cool', then you say that iterators are there (perhaps coupled with a lack of for-loops) in order to 'please functional language purists', even though functional programming concepts are *never* going to be prioritised over systems language capabilities in the language. You also say that you think that Rust purposely not including for-loops is *petty*, even though this thread is full of well-reasoned justification for this particular design. Sure, you may reasonably disagree with them, but they are not *petty* by any stretch of the imagination. 
Not a fan- I honestly can't see any use cases that justify this, and the RFC even agrees it's nicer for compiler implementers than language users. The real problem that's leading to all these inheritance-related RFCs is zero-cost conversions in inheritance hierarchies, for Servo's DOM. [Coercible and HasPrefix for Zero Cost Coercions](https://github.com/rust-lang/rfcs/pull/91) seems more the Right Thing to do for Rust, IMO.
It is an alternative, see http://smallcultfollowing.com/babysteps/blog/2013/10/24/single-inheritance/ for a more fleshed out version.
Part of the motivation was to make structs and enums more similar. They are already just two different ways to think about data, the backend of the compiler already treats them like this. The proposal tries to simplify the language by making structs and enums interchangeable (that is you can just change the word struct for enum and still have valid syntax). It allows us to have basically one kind of data, rather than 5 kinds or something at the moment. So just different ideas of simple, really. We could also accept the changes to structs without the changes to enums.
I agree we want single inheritance to be a last resort, but I also don't want it to be a weird appendix, I want it to feel like an integrated, consistent part of the language. In particular it is important to note that Rust enums and single inheritance give very similar results. In fact as I point out in the RFC, the only difference is the sized-ness of objects. To me it makes sense to make that explicit. (My personal preference would be to use `data` for both, but that is not backwards compatible and could be confusing due to not showing programmer intent). To put it another way, enums and structs with inheritance will always be "similar, but subtly different" and this proposal narrows that down to a single subtle difference, rather than a handful of subtle differences.
Efficiency in both speed and size. To quote the RFC, the requirements are: * Cheap field access from internal methods; * Cheap dynamic dispatch of methods; * Cheap downcasting; * Thin pointers; * Sharing of fields and methods between definitions; * Safe, i.e., doesn't require a bunch of transmutes or other unsafe code to be usable. Traits are fat pointers since they carry the vtable around and using getters and setters on traits requires virtual dispatch, so is not cheap.
There is at least one use case which justifies this and you mention it yourself. I don't think this RFC is nicer for compiler writers, that would be terrible justification for a feature. We would replace several ad-hoc kinds of data type with a single data type and some sugar, hopefully that makes things clearer for users too (although, that is kind of debatable, I admit). A simpler implementation is a nice side-benefit, nothing more. Zero-cost conversions are one real problem. Others are fat pointers and expensive access to fields, we need to address all of them. AFAICT, RFC 91 does not do that (but I might be wrong, I admit to not understanding everything about it).
The links in the post for Rust-Graphics and Piston points to the forks. The correct links are: https://github.com/pistondevelopers/rust-graphics https://github.com/pistondevelopers/piston
Unifying structs and enums sounds great, but maybe it can be done fully then. That is -- both old enum and struct could be expressed by `struct` and the new functionality by some other keyword, maybe `virtual struct`. And yes, like others have said, it would be easier for everyone if the RFC focused on the bare minimum new features needed.
Wouldn't you just use two iterators, a filter and a map?
I'm glad this has been added and shows an impressive maturity to be able to see there is a problem, admit things didn't go completely to plan and try and find a way to move ahead. Happy days :) (ish)
Of course, you could do that. But then you'll have plenty of fun writing generic code that works. Do you use "where (T,T):Add" or "where (&amp;T,&amp;T):Add" or "where (T,&amp;T):Add"? IMHO, it won't scale well. Unfortunately, I don't see a way of improving that situation without changing a lot of what makes Rust the language it is right now.
Yes, I agree.
&gt; We would replace several ad-hoc kinds of data type with a single data type [...] I am confident about Rust's future as long as it's developers do not recognise product and sum types (aka struct and enum respectively) as fundamental building blocks of type theory and anything but ad-hoc. Replacing orthogonal concepts with a unified mess and appealing to the C++ crowd at all cost might as well be the recipe for success! I look forward to reading "Effective Rust" soon.
Even Haskell has a unified view of sum and product types. ;P (I'm *not* commenting on this RFC in particular, just pointing out sum/product types are not very orthogonal.)
&gt; The problem is that Rust still exposes the while loop - which, in my opinion, is far scarier in terms of resulting hard-loops. I can agree with you that's a problem. However I think more thought should be put into designing a proper solution. For instance: As it stands the `for` simply desugars into a `while` loop. Sure you won't skip the step instruction (*if* you did specify it in the for header which you're not forced to anyway). But you could still mess up the body of the loop, affecting relevant sub-expressions of the stopping condition. Therefore if you really want a safe loop, you should add e.g., the requirement that the stopping condition should not depend on any term potentially affected by the body of the loop. P.S.: As a bonus this would make it easier, not only for us developers, but also eventually for static verification tools, to identify some infinite loops.
So, this isn't the subreddit for the videogame called Rust, but it *is* potentially a rewarding place for a 12 year old boy to play. Get him into [programming](http://www.rust-lang.org); send him to college; profit.
As a sidnote, should this be implemented in Rust, the syntax `for ( , , )` would be way more sensible. Since `;` is used for sequencing, and `( , , )` is the notation for t a triple. So `for` would take a triple as an argument.
Thanks for your comment - you might want to make this at the top level; because this thread became uncomfortably personal and will probably be downvoted out of sight - making your valuable comment hidden.
My GOD I feel so stupid XD wow what was I thinking!?
Zero-cost conversions between types in the DOM hierarchy solves the problem of expensive access to fields, though not fat pointers, which would be better solved by [Fat Objects for DSTs](https://github.com/rust-lang/rfcs/pull/9) (or something similar). The beauty of using these two over baking in any kind of inheritance is they are much more orthogonal and flexible. The language itself doesn't give you complicated abstractions like C++'s class hierarchies, it gives you simple abstractions that can be used to build both class hierarchies and other systems.
Thank you, it's much appreciated. There were a lot of misunderstandings here on both sides and we'll move forward from this. :)
Using bash? `echo "set completion-ignore-case on" &gt;&gt; $HOME/.inputrc`.
I actually had this enabled for a long time explicitly, but it just almost never did the right thing. :P Maybe my fingers are too used to case sensitivity.
Yeah I mean, also saying 'config your terminal this way' might not be cool.
The C for loop is by default slow. It only becomes fast when the optimiser can figure out that the bounds can be precalculated (i.e. are fixed) and that increment/etc happens predictably. So range cuts out that requirement for optimisation and more directly specifies that a fast operation is to be performed. I'm quite happy to have lost the C for loop and to write something more verbose the few times it would have been convenient.
Allll the docs are being re-done, it's my first week on the job. Let me know if you have suggestions for other improvements.
You'd do a filter (I forget if Rust calls them this) for the condition, and then map on the result. Really, though, isn't modifying the loop variable inside of a loop always considered bad practice? Is there any real code that does this?
doesn't piston rely have dependencies on rust-sdl2 and glfw-rs, though?
Doesn't filter only remove items from the list, how are you getting a bigger range. The condition can also be dependent on the current state that the for loop is mutating, I don't think the iterators can use that. For example, how would you write this code with iterators: fn f( arg: uint ) { let mut x = 0; for( let mut i = 0; i &lt; arg; i+=1 ) { println!("{}", i); if i % 5 == 0 &amp;&amp; i &lt; x { x = i; i -= 2; } } } I don't think it's ever ideal style, actually it's probably horrible style with for loops, but it can make sense with while loops. This sort of for loop occurred to me because I spent a lot of time writing something similar with a while loop in a algorithm to improve paths (using java) for MIT's battlecode. So, at the very least almost real world. I suspect you could find other things like this that are non-academic, but I wouldn't call it common.
Really more of a nano guy, but I guess I'll have to (re)learn vi. Thanks
&gt;I know I don't speak for just myself when I say What would it be like to name the people that you know you speak for? On the one hand, you know you speak for them, so as far as you can predict they shouldn't be bothered by you naming them. On the other hand, it could result in an uncomfortable conversation if they agree with you but don't want their agreement to be public knowledge, or if they don't in fact agree with you. If you think that the people you are speaking for would rather not be publicly named or involved in defending your remark, perhaps you could reconsider invoking them (however vaguely) as a source of authority for your statement.
I don't think any of the comments were sufficiently unreasonable to start going down the ad hominem road. I think the points figTwoThreeFour are worth thoughtful discussion *regardless* of personal background. What does that have to do with *anything* in this discussion? It comes out as sounding petulantly defensive of functional programming. How about we stick to discussing the *content* of the thread rather than *the people* who are in it?
What do you mean "that the bounds can be precalculated" and that this is the only way to make a C loop useful? Do you mean the test portion? e.g. it is inefficient to say for ( i = 0; i &lt; strlen( longstring ); i++ ) { } Languages like Java "intelligently" do the following in the background: int j = strlen( longstring ); for ( i = 0; i &lt; j; i++ ) { } --- I personally don't like the way Java precalculates the test condition. It is the flexibility of having this test executed *every time* that makes it so useful. If a C programmer wants a "precomputed" boundary then they can precompute it themselves. Not everything has to be done by the compiler. In addition - if a C programmer wants to do something crazy like: for ( i = 0; i &lt; strlen( longstring ); i++ ) { if ( longstring[i] == 'a' ) { // insert a "b" in front of every a // thereby making the string longer } } .. then the C loop actually allows for this.
I have basically become torn by this now. there's enough in rust that I like , that the language keeps my interest, but I'm finding the whole idea of trait-bounds is a double edge sword. It would be nice if they were optional: add them where the error messages are a bigger problem than the complexity of writing code in the first place; Do I hold out on this hoping the language might change - this is orthogonal to the pillar of safety. But it still seems quite fundamental to the language-engine as a whole. Rust generics without trait bounds still wouldn't be as chaotic as C++ templates, IMO, because some problems are solved by 'no header files' (including the right headers in the right order to get the declarations needed). I worry what trait bounds might become like with HKT 
That would be a really nice feature. No plans yet but thanks for reminding me that I should keep this in mind 
Great news. At the moment the project seems to aim at embedding the interpreter in Rust programs. I wonder if this will ultimately allow to write binary modules for Lua in Rust so you can simply ``require`` a library from applications that already have the interpreter embedded. (Those are mainly written in C.) I have at least one larger piece of Lua code that would benefit performance-wise from moving core functionality to the C end. Now, if I could use Rust instead I would finally have enough motivation to actually get it done ``;-)`` 
You can always set up the Lua environment within Rust and add your Rust functions as callbacks to _G. For creating a lua module in Rust, a SWIG (or tolua) extension to create Rust code that wraps functions in a Lua-friendly API would be needed, AFAIK.
Come to think of it, Scala implements tagged unions with *classes* and *inheritance*, and variants ("case classes") are regular classes with automatic support for pattern matching. They are unified as classes. And when you said `data`, I recalled that *Haskell* also had a unified view of this matter, with `data` declarations. So yeah, I think I was misguided by the names `struct` and `enum`. We should use `data` for both (with an `unsized` keyword to control sized-ness maybe?) if unification ever happens. Since they are not `struct`s nor `enum`s from the C++ land, keeping the names would be very confusing (and I was indeed misguided). And this unified thing would be very generic, as it can be "tagged unions", or "records with named fields" or a mixture of both. So it needs a generic name. `data` doesn't need to show programmer intent, actually, it shouldn't.
imagine if you had currying for i in each(0, &lt;10, +1) { } fn each(init_value, condition_function, increment_function)-&gt;EachIterator{ }
&gt; it's probably horrible style with for loops, but it can make sense with while loops. Yeah, this is what I'd say too. Once you start messing with `i`, it's no longer really a `for`.
&gt; I don't think any of the comments were sufficiently unreasonable to start going down the ad hominem road. I think the points figTwoThreeFour are worth thoughtful discussion regardless of personal background. It's not an ad hominem, it's a grievance. Nowhere did I make any attempt to refute his points based on his behaviour or his person. It was a point made separate of any argument pertinent to the topic of this thread. 
Thanks Steve. Your contributions are very welcome! As I put in the edited post one can use Unfold to replace a C-style `for`. Though the real question would be what is the benefit. Anyway, the following currently works: // C-style for for ( i = 19; i &gt;= 0; i = (i / 2) - 1 ) { } to: // Rust-style for use std::iter::Unfold; for i in Unfold::new(19i, |i| { (*i) = (*i) / 2 - 1; if *i &gt;= 0 {Some(*i)} else {None}}) { } --- I think the C-style `for` looks visually cleaner, personally. --- Hmm interestingly enough the `for i in` seems to create a new variable `i` local to the loop even if I already have a variable `i` in scope. --- Edit: updated `(i / 2) - 1` to `i = (i / 2) - 1` in for loop
I imagine this will become quite popular. How hard would it be to create a crate compatible to this that uses LuaJIT (which performs orders of magnitude better)?
&gt; what if I want to affect the variable tested by the condition within the loop? That screams 'while' to me.
The original point is `while` is "dangerous" with respect to `continue`. The naive translation of a C-style `for` loop into a `while` is something like (in pseudo-Rust) for (i = 0; i &lt; 10; i += 1) { if i == 2 { continue } // skip 2 println!("{}", i); } let mut i = 0; while i &lt; 10 { if i == 2 { continue } // whoops println!("{}", i); i += 1 } and that `continue` has skipped the `i += 1` stepping, i.e. it's an infinite loop. A C-style `for` loop doesn't have this problem because the step is integrated into the control flow.
Makes sense. But aren't you going to catch that it's infinite? ie, isn't this not really going to be a significant problem in real code? Do people often just say "here's a for, let me turn this into a while via text transformation, compile and :shipit:?" Maybe it's the kind of code I write, but I can't remember the last time I actually needed to use a non-iterator to loop anyway. Not that means it's generalizable...
The C vers.. oh typos everywhere today. I'll update, thanks for pointing it out! The Rust version works in the playpen: see http://is.gd/m040o6
I don't disagree with any of that. That said, I have personally written `while` loops and accidentally made them infinite (very easy to catch for my tasks, but maybe if someone wasn't testing a lot a rare `continue`-infinite-loop might be missed, providing a DoS attack vector *shrug*).
It should work just fine, you just need to link to the luajit library instead of lua52. Changing the linked library would currently require a modification in `liblua.rs`. I will keep luajit in mind when cargo proposes more useful functions for handling C. 
You are right, this could be inferred: fn mut_one(&amp;mut self) -&gt; &amp;mut int { &amp;mut self.one } But what if `mut_one` is a method from a trait declaration? Then the trait needs to define the lifetime relations so that all implementations of the trait are checked to adhere to the same lifetime relation between the input and output parameters. The lifetime relations are also a part of the API, so by inferring it, you risk changing the external API when you think you are only changing the internal implementation of a function or method.
["Why numbering should start at zero"](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html). Being excusive means that things like `range(0, v.len())` work as you expect (iterates over the valid indices from `0` to `v.len() - 1`, not that that is idiomatic Rust), and also the length of `range(a, b)` is `b - a`, rather than `b - a + 1` if it were inclusive. Furthermore, most `for (i = a; ...; i++)` loops I have seen are using an exclusive condition, that is, `i &lt; b`, same as Rust. Python does the same thing, some links about the reasoning there: - http://www.quora.com/Python-programming-language-1/Why-are-Python-ranges-half-open-exclusive-instead-of-closed-inclusive?share=1 - http://stackoverflow.com/a/4504677/1256624 &gt; I took a look through the docs but I couldn't find the reasoning behind this, and the manual doesn't seem to mention that it's exclusive. [The docs do](http://doc.rust-lang.org/master/std/iter/fn.range.html).
In fact there is an RFC (ie. a proposition for a modification in the language) about this that was proposed yesterday: https://github.com/aturon/rfcs/blob/lifetime-elision/active/0000-lifetime-elision.md
But your example *is* exclusive. That C-style `for` loop only yields numbers up to 100! :) Out of curiosity, what is your language background? Because the exclusive upper bound is a precedent from every other language I've used.
We must mention -- Rust uses ranges (of indices) for slicing vectors and strings. The same convention you see with `range()` will meet you with `[].slice(..)` and `"".slice(..)` as well! Consistency is nice. Slicing vectors feels fine, `v.slice(0, 2)` takes the first two elements and `v.slice(0, v.len())` is the whole vector as a slice. To split a vector in two, use `let a = v.slice(0, mid); let b = v.slice(mid, v.len())`. (Of course there are convenience methods for the operations mentioned, but we want to look at the core `.slice(..)` method for this discussion.)
I guess it's because indexes begin with 0. So if you iterate over an array of 5 elements, you need `for i in range(0, 5)`. fn main() { let array = [0u, ..5]; for i in range(0u, 5) { println!("array[{}] = {}", i, array[i]) } } array[0] = 0 array[1] = 0 array[2] = 0 array[3] = 0 array[4] = 0
For those who don't feel like reading the whole RFC, this proposes exceptionally simple inference rules and would allow us to elide 89% of lifetimes that currently must be explicitly typed. It was only proposed yesterday but I would wager that it will ultimately be accepted.
It is, but it's quite explicit there because the "&lt;" condition is apparent. ;) My background is in Java, so most of my for loops are either explicit or use the for (a : b) { ... } syntax. I guess it's just something to get used to.
&gt; Does anyone know how the book is doing live coding? http://play.rust-lang.org/ Have fun! :)
This makes sense to me. I was thinking that it would make things easier with lengths, because it avoids having to subtract 1 from the length and potentially run into off-by-one errors. The disadvantage is mainly for newbies like myself who assume it's not exclusive and then run into other off-by-one errors. ;) 
That looks like it would make the language a lot more approachable if it means that worrying about lifetime parameters can be deferred until one has more experience with the language.
You can do this: fn main() { let array = [0u, ..5]; for item in array.iter() { println!("{}", item) } }
&gt; http://play.rust-lang.org/ I was searching for "playground", not "playpen", and I wasn't finding it. Thanks! :)
Nice. And doing it that way is also more efficient due to elision of bound-checks, from what I gather?
I gathered stats on the Rust compiler: $ git grep " loop \+{" -- "*.rs" | wc -l 316 $ git grep " while .\+{" -- "*.rs" | wc -l 450 $ git grep " for .\+ in .\+{" -- "*.rs" | wc -l 2169 I took a cursory glance at some of the `while` loops and most seemed to be a poor fit for classic C-style `for` loops. Furthermore, since our `for` loops are years newer than `while` and `loop`, I expect that there are several places in this ancient codebase that could be using iterators but aren't for historical reasons. As a personal anecdote, I've been following the Rust project closely for three years now and this is literally the first time that I can remember anyone requesting C-style `for` loops. It doesn't seem to be a big deal at all to C/C++ programmers at large.
Yes, I am a large proponent of the RFC and very excited at the prospect that it will make Rust code more approachable.
Would depend on how many opportunities in the loop there were to forget an i++, I imagine.
Yes, but the OP didn't ask about that kind of inference the way I read it.
Today is day five of my job working on the docs. I'll make a note of this, but please ping me with any other doc stuff. Pull request: https://github.com/rust-lang/rust/pull/15217
&gt; The C vers.. oh typos everywhere today. See, this is part of Rust's perspective. You may have "been programming in C for most of my life. I've probably seen it all when it comes to silly mistakes"... but you still typo'd the for loop. That's not your fault! We're just human! I would, too! ... but that's why our for loop is better, and why I think a C style for wouldn't be a good edition to the language.
Ha, I'm happy to make a wager: I can make typos in Rust, too!
Right, but they're much less likely to compile ;)
ad hominem is where you refer 'to the person' (thats what it means), rather than the argument. Its a form of reotoeic falacy where arguments like: I don't really know you, or your background. But you don't seem to be giving everyone else the benefit of the doubt. or: You come off as a bit of a purist yourself. are added to bolster or support an argument which is unrelated to the personal statements themselves. I mean, whatever; I just thought it was kind of unneccessarily hostile; no need to comment about the person personally like that. 
&gt; That looks like it would make the language a lot more approachable if it means that worrying about lifetime parameters can be deferred until one has more experience with the language. I don't believe that this is possible, and in fact this is one of my biggest concerns about the RFC (although I'm generally in favor of it anyway). You will always have to know about lifetimes in order to use Rust, because you will misuse them and they'll show up in error messages.
Hey thanks, I modified your example to put in the docs: https://github.com/rust-lang/rust/pull/15217
IMO C++'s problem is not complexity; it's slightly broken features that are made hell by header files, requiring convoluted workarounds, and the inability to fix them because of backward compatibility. If Rust was just a cleaned up, prettier, safer C++, that would be great.
I agree with you - Rust has a lot of new idioms to learn. I think different people will hit different issues when learning the language. An old-style `for` loop is very natural and intuitive for me. Getting used to a new pattern will be difficult - but not insurmountable. My concern is that it may be more verbose, however, always using iterators. Should a language forbid you from doing anything stupid? I don't think so. Perhaps the best compromise is to allow C-style `for` loops in `unsafe` blocks?
Nope. It used to, but those dependencies have been removed in leu of having seperate repos for the backend implementations.
Actually it should be a length not an exclusive bound, really... e.g. `range( 5, 5 )` should count 5, 6, 7, 8, 9. Then there would be no confusion about inclusivity or exclusivity.
Looks great! I've made a few minor comments in the code and made a gist of it here. https://gist.github.com/jroweboy/369da22de9361598acdd These are just some thoughts that I had while reading through the code. A summary of the changes is as follows: * maybe show off that you can put multiple imports in a use statement * consider adding an error handling println!("You didn't type an int"); or something * usually when I say "Guess a number from 1 to 100" we include 100, so we can show off that the max range is exclusive in Rust by changing the max in the range to 101
Looking at your list of concepts, I have some thoughts. Firstly, it seems like some concepts should be left until the "second tutorial", i.e. with perhaps a different set of code: - Crates and Modules - Visibility - Attributes - Stability markers - Testing Those things aren't really necessary for a basic understanding of how to make a single-file program like this first tutorial. Secondly, traits aren't on your list! I think those are more important to learn early, and should come before or with the above list. 
Ha, I literally added documentation to range to make note of it being exclusive earlier today, ahahaha. Thank you, these are all good points.
 let mut reader = io::BufferedReader::new(io::stdin()); `std::io::stdin` is already a `BufferedReader` according to [this](http://doc.rust-lang.org/master/std/io/stdio/fn.stdin.html)
I specifically want to get tests in there earlier rather than later. Rust has a great built-in testing system, and systems programmers historically are bad at testing, because they think it's hard. That said, it's difficult _not_ to talk about crates and modules without hand-waving away the `use` statements, you know? Writing your own crates is certainly later. Since that goes with testing, maybe yeah, the second chunk can start with that stuff? So this one is just talking about _using_ them, and then the details of writing starts off immediately after this stops? The plan with attributes and stability markers is mostly to be able to show off how the docs will say what's stable and what isn't. That will probably end up a little later though, you're right: I was thinking about them in the context of showing off crates. And while traits are awesome, they are _advanced_. It's one of Rust's most endearing but new and complex features.
Ah ha, I was using some older code, and so this may have changed. That's an _excellent_ improvement, thanks!
That all makes sense to me, although I have one comment: &gt; it's difficult not to talk about crates and modules without hand-waving away the `use` statements True, but you're going to have to do the same with macros and `println!`, right? In both cases, the basic usage will probably be very similar to what they've used before, and the subtle distinctions should be left for later. And yes, traits are somewhat advanced, that's a good point... and while they are a more challenging concept than visibility, attributes, and stability markers, they seem more fundamental to Rust than others. People coming from any other language are going to *want* to know how Rust handles objects, especially since its so different; they only need to know about "minor" concepts like the above list once they're already hooked. Both the above list and traits seem to me like candidates for "example code #2".
`trim()` instead of `trim_right()` In the explanation, special attention should be given to what happens here `reader.read_line().unwrap();`
A lot of the machinery in your code example is dedicated to what in Python would simply be `number = input("guess a number")`. Those 3 lines are like Chinese to me: 1] let mut reader = io::BufferedReader::new(io::stdin()); 2] let input = reader.read_line().unwrap(); 3] let input_num = from_str::&lt;int&gt;(input.as_slice().trim_right()); I hope you'll explain what is going on there.
That is true, trimming from both side doesn't hurt. Long ago, I was just chopping off the final `\n`, so I was thinking only in the context of what's on the right. And yes, `unwrap` will be explained thoroughly.
Absolutely. I'd love if there was a simpler way to do this in the standard library, it feels like so much work!
1. Makes a buffered reader from the standard input stream. 2. Reads a line from this reader, discarding errors. 3. Parses the line (a string) as an integer after grabbing a slice of it then removing all white space to the right. 
Nitpick: It might be helpful for newbies if the second line was changed to: let input = reader.read_line().except("Failed to read line"); 
Yes, I can do much better with the Option API. Awesome. Thanks! EDIT: `read_line()` returns a `Result`, so it has to be `ok().expect()`, but yeah, much better!
This looks weird to me: let num = match input_num { Some(num) =&gt; num, None =&gt; continue, }; Why does this work? I think maybe I don't understand how continue works, because I'm mystified that you can assign "continue" to a variable and it compiles, like so: let x: int = continue; Also, it seemingly doesn't matter what type I give it. This also compiles: let x: Result&lt;HashMap&lt;(uint, bool), String&gt;, Option&lt;f64&gt;&gt; = continue; 
I will explain in the text, but `continue` is a keyword that continues the loop, so the assignment never happens.
Thanks!
I get that, but it seems like the Rust compiler should say something like "continue is a keyword, not a value you silly. You can't assign it to a variable."
&gt;&gt;might make C++ bindings easier (we'd still be missing overloading, but that's not as hard). I really miss overloading. I like everything else about Rust, so I'm very torn on this. Would 'making C++ bindings easier' be a good reason to add full overloading to Rust? (it might even simplify the language, with overloaded functions+UFCS) Better C++ bindings would be a Good Thing, IMO, for getting language adoption. &gt;&gt;Personally, I don't think putting inheritance in the language is a good solution, People often say,"don't do x/y/z because it will just be another c++" ... but to me it seems it would be perfectly valid to create a "cleaned up, safer C++". Inheritance is only terrible in the absence of better tools hence being herded toward using it where not appropriate. In a language with tagged-unions &amp; traits, C++ style single-inheritance virtual classes should cease to be a bad feature, because they will only be used where they're the best solution. Avoid the mess of multiple-inheritance, traits do that better. The real pain of C++ is header files and segfaults, which Rust fixes.
In Rust, `continue` is an expression with a diverging type (like `fail!()`), meaning it can go anywhere any other expression can go and the type doesn't matter.
Personally, I would format this: match num.cmp(&amp;secret_number) { Less =&gt; println!("Too small!"), Greater =&gt; println!("Too big!"), Equal =&gt; { println!("You win!"); break; }, } ...like this: match num.cmp(&amp;secret_number) { Less =&gt; println!("Too small!"), Greater =&gt; println!("Too big!"), Equal =&gt; { println!("You win!"); break; }, } Just makes it a little easier to read IMO, and calls attention to the fact that there are two things going on there. Also, maybe adding a loop label would be cool?
(we call that type `!`, in code.)
I have no problem with overloading but type inference does. At this moment, Rust is capable to do very agressive type inference a la some funtional languages. I do not know whether the overloading or the inference is more useful in the long run.
Yeah, I think so too. Thanks! Unsure about the loop label...
&gt;&gt;I do not know whether the overloading or the inference is more useful in the long run. 2 hard problems - naming, and finding code. overloading means the machine does more work for you on both. I would gladly only have overloading available for 1 way inference, starting with the function inputs and working forward, as C++ does; if it starts giving ambiguity errors, you could fix it with type annotations: You'd only be typing what you would have put into longer function names anyway, except adding names that combine in ways the machine can reason about, instead of it being 'naming conventions' , and you don't have to decide upfront which names to put into the function. (Naming conventions have the hazard of creating ambiguity in style) Type annotations would have the advantage of placing meaning closer to data: gui.create_window(name,wndclass) gui.create_window_with_rect(name,wndclass, foo) gui.create_window(name, wndclass, Rect(foo)) // say it with types, this call is disambiguated now gui.create_window_with_rect(name,wndclass, my_rect) // .. but you can make it obvious with context Doesn't the fact the receiver dispatches mean Rust has to do some sort of overload resolution anyway? You can gather multiple parameters into a tuple, and dispatch on that. (a,b,c).do_something(). I have wondered if overloading could be retrofitted by desugaring that.. (a,b,c).foo() === foo(a,b,c); they've already suggested that operator overloading might be done that way (tuple of lhs,rhs) and haskell has 'multi parameter type classes' r.e. forward vs 2way inference, you could retrofit 'decltype(return)' to C++ to leverage a return type you wrote in the signature within the function body: so it seems like you'd still have situations where the reverse inference from the function signature would be possible.
Well, try Lua -- everything is indexed from 1, and ranges are inclusive. Suddenly you find +1 -1 everywhere in your code and for me it is really really confusing. I haven't programmed in a 1-origin language since BASIC. Lua proves to me that 0-origin and exclusive upper bounds is definitely the right choice.
what use case makes api better with overloading?
The recording is up.
If the label is not needed, it's best to leave it out of the example.
I think that the trait that you are implementing is more important, imo your proposal makes reading harder.
&gt; as an outside enthusiast, to watch Rust continue to flail around in gratuitous bikeshedding I know it's frustrating, but I think we can and *should* give the devs the benefit of the doubt here. Their task is not easy. Developing a project like Rust (pre-1.0) with as much community involvement as they have is unbelievably difficult. I think they are doing a *phenomenal* job so far in handling it all.
it could just be personal preference since i've only used C++ seriously. i'm like a fish out of water without it. The problem with methods is, you must decide up-front that one type is special. But functions take many inputs. It doesn't always make sense for one type to 'own' the function. Overloading means you have more freedom to reorganise later, if it turned out the other type was more important. Also when refactoring, if one type is 'special', (this/self) it makes extracting a piece of code harder. Its certainly very natural for maths code. In graphics you deal with a lot of variations on types.. pixel formats.. vertex formats.. points vs axes etc. a matrix that might be transposed if a machine has dot product. cross platform rendering, rendering different objects into different kinds of engine or different stages. Swap out debug versions of a type with extra checks for debug mode, swap back the raw type for performance in release. The way overloading works in C++ deals with all this quite effectively, IMO
its' the ordering of the types that jumps out at me; the actual trait itself is of equal importance, but its' where it is
The disadvantage of this being that it suppresses the reason for the failure to read the line. I think there's room for improvement in the API here.
A description of what Dash docset does would be nice.
That's true. Cargo has some really awesome error stuff in it, I hope it makes it upstream into rustc itself before 1.0.
I don't think Java people will be confused. In Java's String.substring(start, end), the "end" is exclusive.
It works like that in R, Haskell and (I think) Matlab, just of the top of my head.
Actually disagree, though that may be me being biased by Java/C++ style 'x implements FooInterface'.
I guess I'd call http://is.gd/Vvl1sm representable. Maybe not according to some technical distinction I'm missing? (but you're right it's called 'bottom')
If you have a struct definition followed by trait implementations and you quickly go over the lines you have to read max of 8 characters to get the information that impl is for Foo and Add, if you reverse that you only get two Foos if you read the same amount.
Here you go! https://github.com/bjz/rust-bay-area-2014-06 The very basic demos can be found here: https://github.com/bjz/rust-bay-area-2014-06/tree/master/demo Apologies for not being able to make it last night!
You could say the most important info is the type, and the function -the trait is trailing and you can skip it impl Foo .......noise....... { \ fn add(&amp;self,b:&amp;B)-&gt;Result } ok if its a long bound/typeparam ... the 'Foo' goes on its own line and can be closer
Coming from C# and learned a bit C before I learned Rust, I think overloading in terms of 'fn foo(a, b)' vs 'fn foo(c, d)' is bad for big code bases. In C you have to name all functions uniquely, which also serves as a way of documentation. I would also assume overloading makes naming conventions less consistent across libraries. For example, in rust-graphics you have .color([f32, ..4]), .rgba(r, g, b, a) and .rgb(r, g, b). With overloading it is tempting to use .color for all these. However, if you have a bug where the alpha channel does not work, it will be a bit harder to see there should be 4 arguments instead of 3. The problem is that library designers often do not see such issues.
Docsets are downloadable, tagged documentation for many open source libraries and languages. They're great for when you're developing on a plane or somewhere without internet, or if you just want quick documentation at your fingertips. Docsets can be viewed using a compatible viewer such as [Dash](http://kapeli.com/dash) for Mac or [Zeal](http://zealdocs.org/) for Linux. I'm working on a new one for Linux that doesn't look quite so dated, but it's in a very alpha state at the moment.
Thanks! No worries ;) It was a fun talk by brson. There will be more in-depth material available for Piston soon. Looking forward to the Spinning Trianglathon!
Furthermore, "tone policing" is a concept that's mis-applied here: there's quite a bit of difference between the social justice context in which we talk about tone being used to oppress people, and the discussion of a new programming language.
Two minor type things; - There's some good reasons to avoid `int`/`uint` (they vary per platform, and so the behaviour can change surprisingly in some edgecases) in favour of a fixed sized type like `i32` or `u64`, but people rarely do this at the moment. - `guesses` could be unsigned, since it's just a count. Although I imagine keeping it with a single simple type `int` is nice. &gt; println!("Secret number is {}", secret_number); Haha, I'm looking forward to using any crypto libs you write with security like this. :D
Math libraries. I'm using chipmunk at the moment (in C, not rust). It would be much nicer to be able to do vect1 + vect2 instead of cpvadd(vect1, vect2) for example.
Rust actually has overloading and you can overload operators in Rust by implementing traits, and RFC PR [#135](https://github.com/rust-lang/rfcs/pull/135) would make operator overloading (and overloading in general) even nicer. EDIT: Sorry as I realize you didn't imply that you thought Rust had no overloading, but I somehow got that impression when this post was initially made.
IMO, "let x = continue" should warn. I think this is covered by [Unreachable outer expressions should warn (#1889)](https://github.com/rust-lang/rust/issues/1889).
I am optimistic that extremely well crafted error messages could serve to educate newcomers and guide them towards understanding by linking to the relevant documentation.
I also prefer the library-based solution for inheritance. And for overloading support, which /u/dobkeratops metioned, Rust has overloading via traits. It's just not ad-hoc, has a more heavy-weight syntax and is limited in some aspects. From what I've read, RFC PR [#135](https://github.com/rust-lang/rfcs/pull/135) and [#132](https://github.com/rust-lang/rfcs/pull/135) (UFCS) can make things much nicer, and we can even support multiple dispatch. EDIT: It's worth noting that, Rust's UFCS as per #132 is about calling methods with function syntax, while D's is the opposite. 
`impl Type as Trait` makes no sense as a natural English reading, while `impl Trait for Type` reads very naturally. If you want the order changed, you’re going to need a much more compelling alternative indeed. Srsly. Otherwise it’ll just be rejected out of hand for really bad ergonomics. `for Type impl Trait` would be one such thing; it trades one form of symmetry (`impl [Trait for] Type` versus `impl Type` and `for Type impl Trait`) for another (having input parameters—the type—first and output parameters—the trait—last). In the end, I think you’ll find it hard to come up with a compelling reason to change it: it’s a change with pros and cons, and so what is already there is significantly more likely to stay.
`!` can by written in one specific position - function signature return types. It does not actually name a type though, and can't go in any other positions where types are expected. The point is subtle, but `!` is not a type, it's a placeholder for a special conceptual type used in typechecking ('bottom' or `_|_`) but that otherwise doesn't exist (there are no values of type `_|_`). https://en.wikipedia.org/wiki/Bottom_type
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Bottom type**](https://en.wikipedia.org/wiki/Bottom%20type): [](#sfw) --- &gt; &gt;In [type theory](https://en.wikipedia.org/wiki/Type_theory), a theory within [mathematical logic](https://en.wikipedia.org/wiki/Mathematical_logic), the __bottom type__ is the type that has no values. It is also called the __zero__ or __empty__ type, and is sometimes denoted with [falsum](https://en.wikipedia.org/wiki/Falsum) (⊥). &gt;A function whose return type is bottom cannot return any value. In the [Curry–Howard correspondence](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence), the bottom type corresponds to falsity. &gt; --- ^Interesting: [^Top ^type](https://en.wikipedia.org/wiki/Top_type) ^| [^Unit ^type](https://en.wikipedia.org/wiki/Unit_type) ^| [^Type ^theory](https://en.wikipedia.org/wiki/Type_theory) ^| [^Antarctic ^Bottom ^Water](https://en.wikipedia.org/wiki/Antarctic_Bottom_Water) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciiyh5t) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciiyh5t)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Even "a placeholder for a special type" is not entirely accurate. The type is `_|_`, and it doesn't exist in the surface language. `!` is not `_|_`; `!` is a special sigil that says 'this function doesn't return'. During type checking, the type checker in turn thinks, 'this function doesn't return, how do i type check it? oh, i'll just throw this `_|_` type in there'.
&lt;3
Roger. Thanks for spelling it out.
AFAIK UFCS support would eliminate the "special" aspects of `self` , and the `where` clause support would bring more overloading options. (Though still not ad-hoc.) EDIT: And one of the new options would be true multiple dispatch, which is natural in graphics/physics simulation codes. C++ only has hackish solutions for it as of C++98. I haven't quite followed the new standards, and maybe we can do better even than C++1y in this aspect?
&gt; In a language with tagged-unions &amp; traits, C++ style virtual classes should cease to be a bad feature, because they will only be used where they're the best solution. The problem with this is that it makes the language more complicated while the goal right now is to simplify and make consistent. The more orthogonal solution, on the other hand, keeps the language simpler *and* adds more flexibility. &gt; I really miss overloading. I wouldn't mind terribly either adding overloading or letting c++ bindings use different names through some kind of attribute to specify the linker name. However, Rust's solutions without overloading are somewhat more readable and type-inferable in some cases and I don't know how I feel about that (potentially) going away. Further, forcing all overloading into traits means 1) different meanings of names are in different modules and similar meanings of names get grouped into traits, and 2) potential multimethods as an extension of trait-based dynamic dispatch.
As far as I can tell Devhelp is limited to consuming `gtk-doc` documentation. Dash works with HTML (including hyperlinks) out of the box and it's pretty straightforward to get started with its indexing features. Since HTML is virtually the lingua franca of documentation these days, it's easy to make Dash docsets for almost anything. It's become like my Swiss Army knife for reading docs: I can cover anything from Foundation CSS to Rust to some arbitrary Doxygen documentation with one key sequence.
that looks waaaaaay better. It doesn't return an Option, though, it seems?
It would have to be `let foo: Option&lt;int&gt; = ...;`.
https://github.com/steveklabnik/guessing_game/commit/cd1c15db2e74ce3cd770fda96bc3766705054bee &lt;3
&gt;I also prefer the library-based solution for inheritance. How would a library based solution work? 
By combining RFC PR [#9](https://github.com/rust-lang/rfcs/pull/9) and [#91](https://github.com/rust-lang/rfcs/pull/91). EDIT: Posted a partial reply by accident.
I'm a big fan of the UFCS idea. To further confuse matters, there's a UFCS proposal in rust which is the opposite ... making methods callable as functions - perhaps they can call this UMCS to disambiguate from what D does
&gt;&gt; However, if you have a bug where the alpha channel does not work, it will be a bit harder to see there should be 4 arguments instead of 3. maybe make a debug tool which pretty prints the source code with overloads annotated Or you say it with types... Vertex(point, Rgba(r,g,b,a)) Vertex(point, Rgb888(r,g,b), Axis11_11_10(my_normal)) Vertex(point, Rgb565(r,g,b)) image.set_pixel(point, Rgb565(rgb)); color = Hsv(Rgb(r,g,b)) Once you've done the work naming types Rgb565 , Rgb888 etc, you leverage these names in all contexts where a colour may be used.. vertices, image formats, conversions, UI preferences, - instead of repeating many different functions with _rgb565 _rgb888 variations. With overloading, you leverage more names from within the type-system, in a way the machine can check and understand; something automated can be more consistent than human choice &gt;&gt;I think overloading in terms of 'fn foo(a, b)' vs 'fn foo(c, d)' is bad for big code bases. So this becomes something where users and library writers exercise their choice: Having overloading doesn't *force* you to use it. Someone can write a competitor to an existing library, with the USP "no overloading"; I think there are enough programmers in the world to do this. Perhaps a tool could be written to convert an overload-based API into a non-overload based API. Scan the interfaces for repeated names, introduce trailing _ variations with the differing types postfixed
&gt;&gt; 2) potential multimethods as an extension of trait-based dynamic dispatch. I would be perfectly happy if only one parameter is ever useable for dynamic dispatch
Well I don't disagree. :) I think for Rust, making methods (or "associated functions" as they are called in the proposal) callable using normal function syntax makes more sense than D's approach when trait-based multiple dispatch is considered - The "first argument" is nothing special then. (Well we still have to type an extra pair of parens if no syntax sugar is added.) Would supporting both be confusing? EDIT: correction: the actual first argument would be a tuple, but its own first element is nothing special compared to the rest.
it's also the fact its not clear which 'type' should be more important so lets say you start out.. render_vehicle(r:&amp;mut Renderer,v:&amp;Vehicle) then you might add more types of object (vehicles, trees, players), to 'Render'. or more types of 'Renderer' (wireframe-debug, forward, deferred, GL/D3D/Metal/Mantle - or different passes within one renderer shadow/zprepass,...) so which types become more important to be 'the receiver'? should it be ForwardRenderer::render_vehicle(..) DeferedRenderer::render_vehicle(..) ForwardRenderer::render_tree(..) DeferedRenderer::render_tree(..) or Vehicle::render_forward(..) Vehicle::render_deferred(..) Tree::render_forward(..) Tree::render_deferred(..) should you have just written `render_vehicle_forward` `render_tree_defered` etc in the first place ... but then you do a lot of cut-paste-rename into dispatchers... wouldn't it be nicer to just let the types do the organising, as you've named them already.. render(v:&amp;Vehicle, r:&amp;ForwardRenderer) // the compiler can sort by object-type or renderer-type for me later then you can write generic implementations , for obj in list { render(obj,renderer)} .. render_list(scene.trees,r) render_list(scene.vehicles,r).. What if you'd started out with a consistent pattern (doable with a generic typeparam), but then later found you need dispatching for something more specific.. then you need to change how its declared, and change the call syntax. in C++ its hard to search, but in Rust we've got : to introduce types, so a grep `Render.*:&amp;Forward` finds it On another note this is why I would prefer there's no special "Self".. (and why i don't like class methods in C++) that makes the search a little harder.. my preference would be overloaded functions+UFCS to do everything. I've basically come to despise the whole concept of methods / receivers. Well as it stands at the moment in Rust, we have the choice to do this:- (Vehicle,Forward).render() // recovers C++ like ability to select a function on multiple types Changing everything postfix style recovers the flexibility of overloads, so we've got this temptation. But most people will see that and thing "what a mess!". But thats what they're considering for operator overloads, basically a+b = sugar for (a,b).add() You might think this is a contrived example but what if you're dealing with the unknown ... which is where programming is most interesting, and where the world has most to gain.
While this probably wouldnt work in general, [phantom types](https://blog.mozilla.org/research/2014/06/23/static-checking-of-units-in-servo/) might be useful to mitigate the problems with some of the things you mentioned. Overloading is still something i would consider useful though
Could some of this be solved through better match syntax? trait Hello { fn hello(self) -&gt; String; } struct Foo{} struct Bar{} impl Hello for Foo { ...} impl Hello for Bar { ...} enum MyEnum { A(int), B(int), C(Foo), D(Bar) } let x=A(2); match x { _(v @ int) =&gt; println!("int {:d}, v); _(v @ Hello) =&gt; println!("Hello {:s} , v.hello()) } The idea is to use enums as wrappers to provide thin pointers, but use traits for inheritance. EDIT: It don't know if @ works with dereferencing, but that would provide downcasting.
Yeah. So far I've managed to get a hacky implementation by copying, cleaning, and rearranging the code from Rc and RefCell, but if there were a type implemented by someone who knew what they were doing in the standard library it'd be much better.
For UFCS are their any plans to make it go both ways?
Well, if you write for a newbie, some of those things needs better explanation: 1. What is a buffered reader? And actually, what is a standard input stream? 2. Why unwrap() discards errors? And, what type read_line() returns? 3. This syntax: `from_str::&lt;int&gt;`
None that I am aware of.
This is a concern I have not thought about. Thanks.
+1. I'm a beginner when it comes to Rust but I've done C for 2 years in college so I'm not completely out of my depth. I've read through the guessing game code and unless there is an enormous amount of explanations it's going to be completely useless to me. One of the first lines is let secret_number = std::rand::task_rng().gen_range(1i, 101); I know what "let" does but what about std::rand::task_rng()? what are the semi-colons for? what's rand? task_rng()? etc does .gen_range generate a range of numbers because that what it looks like to me and where did gen_range even come from is it a standard thing like println!?. The list (for me anyway) goes on. Because this program has 41 lines and is filled with things like let secret_number = std::rand::task_rng().gen_range(1i, 101); instead if having 6 or 7 lines there seems to be a presumption that you already know C and C++ instead of presuming that the reader is an idiot who knows how to turn on the computer and that's it. When i was leaning C in college a lab was dedicated to if statements, another to for loops another to while loops then towards the end we put them all together. With this the cart seems to be before the horse where everything is thrown together and then 100 different things are being explained at once.
Well, it all depends on who the tutorial is intended for. Personally, I'd like the tutorial to be helpful to someone (like me) who doesn't know C or C++. (The whole reason I want to learn Rust is to gain knowledge of low-level programming without the need to bang my head on the desk).
You can trivially implement this handle pattern: use std::mem::transmute; struct Handle { valid: bool, r: *Resource } impl&lt;'a&gt; Handle { fn borrow(&amp;mut self) -&gt; &amp;'a mut Resource { unsafe { return transmute(self.r); } } } #[deriving(Show)] struct Resource { x: int } #[deriving(Show)] struct ResourceManager { items: Vec&lt;Resource&gt; } impl ResourceManager { fn new() -&gt; ResourceManager { return ResourceManager { items: Vec::&lt;Resource&gt;::new() }; } fn add(&amp;mut self, r: Resource) { self.items.push(r); } fn handle(&amp; mut self, id: uint) -&gt; Handle { let item:*Resource = self.items.get(id); return Handle { valid: true, r: item }; } } fn main() { let mut r = ResourceManager::new(); r.add(Resource { x: 10 }); r.add(Resource { x: 15 }); r.add(Resource { x: 20 }); // Specific scope let mut handle = r.handle(0); { let value = handle.borrow(); value.x = 50; // Don't do this: actually modifying this means // you have two mutable references to one memory // location; resulting in undefined behaviour. // let value2 = handle.borrow(); // value2.x = 100; // ADAFAF Undefined behaviour! } println!("{}", r); } Just remember that pointer aliasing results in undefined behaviour. In this case the content of the pointer is never modified by the ResourceManager, but if you create multiple handles, you almost certainly will mess up and end up with mysterious segfaults. You would probably want to make ResourceManager only ever able to return a single handle for a held resource. If you don't want to take on the responsibility of manually managing that, use RC. That's why it exists.
&gt; Well, it all depends on who the tutorial is intended for. I'm really struggling with to figure out who it is intended for. If it's intended for complete beginners then it's not very useful since it's 1 code example with 20 different concepts instead of 20 different concepts in 20 different code examples. If it's for people who already know the concepts in the code (like alot of people in this thread) then it's not very useful to them either, I'm stuck in the middle of both so it's not really helpful for me either. If Rust is to be successful then it has to be accessible to *everyone* including people with no programming experience in C/C++ (like you) and these tutorials are a good place to start with that imho. The reason learning C is so easy is because you can type into google "C programming for beginners" and get tutorials so well explained a 95 year old with dementia could understand it.
I doubt this comes from LLVM though, or it would require back and forth communication between the front-end the back-end.
No. Python's range is exclusive. I interpreted /u/fursurely as asking "Why should `range` be inclusive? No language I'm familiar with have inclusive range." (equivalently "why should Rust's `range` act differently to Python's?").
&gt; impl&lt;'a&gt; Handle { &gt; fn borrow(&amp;mut self) -&gt; &amp;'a mut Resource { Woah, woah, that's crazy-unsafe, it allows you to just retrieve an arbitrary number of aliasing `&amp;mut`s. Why not `fn borrow&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut Resource`? At the very least `borrow` should be `unsafe fn`.
`multip` is a submodule of `modules`, so it needs to be imported via `modules::multip::...` (i.e. `::modules::multip::multiply(3, 4)` in this case).
Incidentally, the more common convention is to just have `mod modules;` in `main.rs`, and put its contents (just `mod multip;` at present) in `modules/mod.rs`.
Never thought about it that way! Thanks a lot! But now theres another issue, it says module `multip` is private. Well, i do know how to make a function public, but how can i make a file public? Thanks!
`pub mod multip;`
The point of the Handle type is that it lets you get a mutable ref to an instance of Resource that is owned by someone else, like a simplified version of RC. The lifetime param here is basically irrelevant (because it has nothing to do with the actual lifetime for the instance) so we dont care its on the function or struct. &amp;'a mut self would be equally fine.
Yes! Perfect! Thank you so much. Sorry if this is some kind of newbie question, but it was being hard for me!
&gt; The lifetime param here is basically irrelevant (because it has nothing to do with the actual lifetime for the instance) so we dont care its on the function or struct. It's not. The lifetime parameter you give is allowing users to write really really really unsafe code without an `unsafe` block. &gt; &amp;'a mut self would be equally fine. No, it would be 10^(9) times* better, because it will then be slightly safe as the following will be outlawed let x = handle.borrow(); let y = handle.borrow(); // aliasing &amp;mut's! :o (Of course, you still have to worry about other handles to that data calling `borrow`, so it should really still be `unsafe`, but at least it offers some assistance to the programmer.) ^(*approximate estimate)
It seems rust.tmbundle may've been [recently updated](https://github.com/elia/rust.tmbundle/commits/master).
I don't think it really matters; if you're doing this you obviously need to know what you're doing or you'll end up pointer aliasing; you're not writing it 'for users'; you'd never write an API that did this sort of thing. It would only *ever* be for some kind of internal resource manager thing. ...the real answer is obviously just use RC if you don't want to manage the details by hand. It's like using forget() to stop something from being collected; you wouldn't *actually do it* unless there was a good reason; not just for fun. (eg. you're storing a rust object instance in an FFI callback) (...but I suppose if you were writing some kind of generic Handle&lt;T&gt;, yes, you're totally right, you'd want it that way)
&gt; you're not writing it 'for users'; "Users" includes the people writing the internal resource manager. &gt; It's like using forget() to stop something from being collected; you wouldn't actually do it unless there was a good reason; not just for fun. (eg. you're storing a rust object instance in an FFI callback) There may be a very good reason for it, but the code can still be written to be as correct and as helpful for correctness as possible, e.g. maximally "safe" named lifetimes and declaring functions `unsafe` if they can be used in a way that invokes undefined-behaviour. &gt; RC (I assume you mean `RefCell`, not the `Rc&lt;T&gt;` pointer?)
You have a lot more faith in six-months-from-now you than I have in six-months-from-now me :) Regardless, code you're giving to someone as an example of how to do what they want to do seems closer to 'collaborative' than 'personal' to me. 
Then what's the point of unsafe functions?
? Don't ask me, I didn't make up the unsafe semantics. If you like filling your code up with unsafe blocks every time you make a function call in your own code, go right ahead. 
I mean, the point of Rust is to encapsulate what's safe from what's not.
Yes, but you don't want to/can't make every single function expose a safe interface, e.g. the `offset` function for raw pointers has some uncheckable invariants (it has to be "inbounds") for performance, and similarly [`std::str::raw::from_utf8`](http://doc.rust-lang.org/master/std/str/raw/fn.from_utf8.html) unsafely coerces a byte slice to a string slice without validating that it is UTF-8 (also for efficiency). Other examples include binding C libraries: the foreign functions have to be `unsafe`, and it seems very reasonable for someone to write a thin wrapper around some functions where the user of that wrapper still has to verify whatever preconditions the C library wants, meaning the wrapper needs to be marked as `unsafe`.
The reason it is the way it is is that the methods aren't scoped to the type but to the trait. The trait is essentially an abstract module which can be overloaded for various self types. So each impl is essentially a module with the same name as the trait, and the particular type it overloads the trait for is secondary information.
Strange. I'd expect this to compile: write!(w, "example").unwrap(); But I have to add extra parentheses to get it to compile: (write!(w, "example")).unwrap(); Is this expected? Or a bug in the macro? 
ok interesting to look at it that way, but when you `impl Foo for Baz` , if you have a Baz, you can now call the method declared in Foo on a concrete instance of a Baz. Could you equally say that you'd added the methods of Foo to the 'abstract module' of Baz? is there something subtle like not getting those methods if the trait isn't in scope 
Yes, see the other comment from pcwalton. I've already done that. (It's actually `let input_num: Option&lt;int&gt; =`)
 $ rustc hello.rs hello.rs:2:13: 2:14 error: `continue` outside of loop hello.rs:2 continue; 
&gt; it's not very useful since it's 1 code example with 20 different concepts instead of 20 different concepts in 20 different code examples. Was what I said in the gist not clear? "The idea is that I will slowly build from hello world to this final code in steps, introducing one concept at a time." To be extra clear: the guide (the new tutorial) is intended for people who have never seen Rust before. It will assume that you are familiar with systems programming, but will add bits of explanation and pointers to other resources for those who aren't. It won't cater directly to them, but won't leave them out to dry, either. You can see what's already been merged [here](http://doc.rust-lang.org/guide.html) and see my latest work [here](https://github.com/rust-lang/rust/pull/15229). Mind checking it out and letting me know what you think?
That's the convenience syntax, but the method isn't actually scoped to the type, since the trait has to be in scope for the method to be visible. The actual path to a method is Trait::method, not Type::method (unless the method is actually in an impl Type instead of a trait).
I mean, you can simply omit the unsafe flag and program without Rust-style safety (like the person I was replying does), but then the concept of unsafe functions kind of lose its point. Then the user is responsible to know what is safe for the whole code, not just critical unsafe parts.
Even though this is a integer overflow bug, is my understanding correct that enforced bounds checking would have mitigated the problem?
&gt; ad hominem is where you refer 'to the person' (thats what it means), rather than the argument. Its a form of reotoeic falacy where arguments like: [...] Maybe we're not using the exact same interpretation of "ad hominem", but I use it to refer to the *informal logical fallacy*. Namely, trying to refute the arguments being made by irrelevant personal attacks. As I said in the post you replied to, I have not tried to invalidate any argument relevant to the topic of this thread by employing any personal attacks, or any arguments against the character of any person in this thread. You think I have? Then I challenge you to find them. And no, those you quoted aren't *ad hominems*. They might be interpreted as *personal attacks*, but they aren't used in any kind of argument against the relevant topics at hand. This is *not* an ad hominem: &gt; You come off as a bit of a purist yourself. This is, though (guilt by association) &gt; You come off as a bit of a purist yourself, and purists are too fanatical to be right in these matters. The first is a statement, the other one is an argument (and can thus qualify as a *fallacy*). I must admit, though, that the first quote could be interpreted as *implying* or *hinting* towards the second quote, which is problematic. But it was my intention to stick to relevant arguments when it came to the topic of this thread, which is why the rest of the post left that 'purist' statement behind and stuck to the facts at hand, so to speak. As for the second post (the post that you replied to); like I said, this is not an ad hominem, but a grievance (or *personal attack*, if you want to read it like that). Nowhere in that post did I try to argue against any of his arguments w.r.t. the topic of this thread. In fact, it was not so much a post about the topic of this thread as it was a post about behaviour in this thread. Perhaps you could call it a meta-topic? Anyway, talking about how someone is behaving is not an ad hominem as long as you don't try to use it as an argument in some irrelevant way, for example to say "you are mean, so therefore you are wrong about wanting for-loops.". But my post made no mention of the actual topic of this thread, only about his behaviour. The post was basically "I think you are being unreasonable in this thread because you did A, B, C". But this is not a fallacious ad hominem, because the topic of that post is *exactly* conduct! You could complain that that post was off-topic, but that is a different matter. Maybe you have some other conceptualization of ad hominem - you called it "rhetorical fallacy", which might be subtly different for all I know. But this is my use of it, which is not fringe or unusual. Or perhaps you just use the phrase 'ad hominem' to mean 'personal attack' because you've seen it used (overused?) in other forums and now you want to sound like a reasoned, stick-to-the-facts intellectual, who still doesn't have enough intellectual curiosity to look up and understand what an *informal logical fallacy* really is - what do I know! ← This is a personal attack, not an ad hominem, btw. 
&gt; It comes out as sounding petulantly defensive of functional programming. What functional programming concept have I been defensive of? Iterators? I don't think of them as being related to functional programming, though I might be wrong. 
Thanks! I was not aware of that. I think it's still worth discussing though, even if it's not practical to exploit today
Yes.
I'm having a bit of trouble understanding your precise requirements, so just to clarify: in what respects would `Box&lt;T&gt;` for the owning reference and `&amp;mut T` for the modifying reference be inadequate?
I have to lose the `&amp;mut T` reference to use the `Box&lt;T&gt;` reference. I need both references available, but not borrowed at the same time. One of the other comments explained it better than I did, in that it's a 'handle' to the object. Used/owned by one thing, and modified by another.
What happens when you attempt to drop the object while the handle has borrowed it? This is the main difficult situation I was thinking of.
Available means I can borrow a reference when I need to, and borrowed means `&amp;`/`&amp;mut`. I think a weak reference is what I'm looking for, but as I said, `Rc`/`Weak`+`RefCell` is a bit of overkill. What I'm looking for is a simplified version of that system.
[This compiles](http://is.gd/nnMfcz), the changes I made are giving type hints to the generic methods, e.g. `apply_settings::&lt;T&gt;`, and wrapping the `child` borrow in its own scope to stop it conflicting. However, I'm not sure this design will allow you to do what you want (partially because I don't what your goal is).
I'd like to be able to offer the 'IsNode' trait as a part of a lib, where a type should be able to implement the 'IsNode' trait like so: struct MyNode { node: Node } impl IsNode for MyNode { fn get_node_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut Node { &amp;self.node } } I'm totally open to any other suggestions if there are better ways of offering a 'generic' style node system. I feel like it's a classic data type that should probably be easier to do than I'm making it out to be.
Thank you sir! Going to try out this fix in the real deal now.
Ah, I thought you were asking why Rust allowed users to declare functions like `unsafe fn foo() { ... }` themselves; sorry for confusion.
I built a piston app, fixed some cargo bugs, and witnessed several spinning triangles.
Output of my (remote) day https://vimeo.com/99437408 [link to obj file](https://raw.githubusercontent.com/csherratt/snowmew/f52f48adff40179b78f4e67d820d75ab2207e4c0/assets/rust_logo.obj) if anyone wants it.
Just for the record, this helped the example to compile, but caused the need for a recursive type parameter when coming to 'in-the-wild' usage
Unfortunately, I stayed up all night playing a 17 hour civ game, and passed out at home, missing it!
A saw Colin's cat! Multiple times! 🐈🐈🐈🐈🐈
I only got something done (NBT decoding) when it was over, and that was around 5am here. I just woke up and I need to finish it.
▸►▸▴▲▴◂◀︎◂▾▼▾▸▶︎▸▴▲▴◂◀︎◂▾▼▾▸▶︎▸▴▲▴◂◀︎◂▾▼▾
The syntax has not been adopted from Haskell. It's more like C++, where `::foo::bar&lt;int&gt;(a, b, c)` is a function call, but to avoid ambiguities in the grammar that would need typechecking in the parser to resolve, we require the extra `::`
If you squint, you can think of generic functions as being modules that contain many functions inside of them. By using this syntax, you are explicitly picking one of those
This is really cool, and really useful!
It shouldn't be. My old roommate has Dash docs for _everything_.
... and why I think they should be renamed.
this subreddit is about a programming language rust, you are looking for /r/playrust
In this case, Kudos. And I stand corrected again.
That's a non-sequitur. The problem isn't with `unsafe`, it's with the way you explain it as safe without qualification. Your suggested alternative is even worse in that regard - calling blocks of code that you should never blindly trust `trusted` is just a bad idea.
That reflection took about one minute (see [here](http://www.reddit.com/r/rust/comments/2957fg/can_i_request_a_c_style_for_loop/ciidihh)). The last post was just laboriously explaining that first post. How about you look up the meaning of Latin phrases before you use them next time, so I don't have to "reflect" (explain) so damn much to you?
This abuse is unnecessary and not wanted in /r/rust.
Cool! It's awesome how easy cargo makes things: `git clone` + `cargo build` and 10 seconds later I have a fun little game to play. A few minor things: - the indentation is a little strange in places ([here](https://github.com/alexchandel/rust-gravity-worm/blob/ec53a1d3896ade930636b93fa684b1b72908cc75/src/worm.rs#L8-18) and [here](https://github.com/alexchandel/rust-gravity-worm/blob/ec53a1d3896ade930636b93fa684b1b72908cc75/src/worm.rs#L35-L45)), - [these `Box`s are unnecessary](https://github.com/alexchandel/rust-gravity-worm/blob/ec53a1d3896ade930636b93fa684b1b72908cc75/src/worm.rs#L9-L11), - the [loop ticker](https://github.com/alexchandel/rust-gravity-worm/blob/ec53a1d3896ade930636b93fa684b1b72908cc75/src/worm.rs#L120-L121) could be written as `for _ in painter.iter() {` - the [`println!`s](https://github.com/alexchandel/rust-gravity-worm/blob/ec53a1d3896ade930636b93fa684b1b72908cc75/src/worm.rs#L82-L87) could actually be done with a single literal: println!(" Hello world! Welcome to Rust Gravity Worm for ncurses, by alex! Controls: space:\t\tUp any other key:\tDown Press any key to begin..."); (Of course, this comes with the "cost" of the unindentation.)
The strange indentation you highlighted seems to come from mixing up tabs and spaces. I recommend the author (and anyone else writing code) not to use Tabs or have your editor convert tabs to spaces when saving: different tools have different defaults for tabs, and your code WILL look weird to someone else that doesn't follow your coding process. It also makes it look like your code is all 8-char-indented, which I personally find makes the code look less... cohesive?
This seems to be far underappreciated, and I can't find people actually using this, but the standard library does come with a `range_inclusive` function that does exactly what you want. Unfortunately, it is currently not exposed in the prelude and isn't very well advertised, but I think this should change. [Docs](http://doc.rust-lang.org/std/iter/fn.range_inclusive.html) [Example](http://is.gd/zDqd0n)
The name itself leaves out the second half. That's my beef with it. And I've always been upfront that I don't think 'trusted' is the best word. I just think unsafe is the wrong one, for the same reason as you. Names are important. If you read a name and you get the wrong understanding, it's often the fault of the name, not of you.
I have upvoted - though I would like to see a C-style `for` I appreciate your views.
Thank you for your comments. Yes - you have clearly experienced what I've experienced. It is not uncommon to find, in production, long loops that have several `continue` clauses scattered within depending on various `if` conditions. They are frequently not all covered in testing - so when released to production one might find a webserver core suddenly go to 100%, then another 10 minutes later, then another... and gradually the entire server becomes busy over a period of a few hours. Because only the occasional customer triggers the untested portion of the `while` loop. Steve, above, is correct - in that you can still create infinite `for` loops with a badly written condition - but these tend to get noticed on first test. So it is often slightly less of a problem.
The official recommendation is four spaces, no tabs, as well.
This is super great! And +1 on Cargo being awesome here too, super easy.
Making type defs work properly would help a lot without requiring significant changes! type MyVec = Vec&lt;Option&lt;uint&gt;&gt;; let vec = MyVec::new(); // error :(
While I agree that the current syntax can be quite heavy with deep nesting, I think the suggestion actually makes things less clear. IMHO things that are nested should also look nested. This is the same reason I dislike the "space is apply" syntax in Coffeescript, where `foo bar baz qux` actually means `foo(bar(baz(qux)))`. For both of them, I think removing syntax is actually solving the wrong problem. The problem is the deep nesting itself, not the nesting syntax. And, for both of them, I use the same solution: introduce intermediary steps. For Coffeescript, this means intermediary variables, and for Rust, this means type aliases. Sometimes, this even helps surfacing previously-unnamed concepts
&gt;Cool! It's awesome how easy cargo makes things: git clone + cargo build and 10 seconds later I have a fun little game to play. I just tried this (under OSX) and ncurses.rs is not compiling. Getting like 20 of those: **error: bare raw pointers are no longer allowed, you should likely use `*mut T`, but otherwise `*T` is now known as `*const T`** Both rustc and cargo are fresh. Too fresh?
I like that everyone is talking about removing non-alphabetic symbols from the language, even if it seems none of the proposals will succeed. I would love to use less punctuation and bracket types in Rust and wouldn't mind a bit more alphabetic typing. Nothing is easier to read than a space.
Type aliases are the same way they handle this nesting insanity in C++. IMO I don't especially like that in C++ either
But doesn't it work if you do let vec: MyVec = Vec::new(); ?
I'd be all for simplifying the syntax for declaring types and for that, I'll once again refer to F# (what can I say? I like it as a language :P ). In F# you can do like: let x: string list = [] Where the inner type of the generic is actually on the left. It seems to read naturally as in, "This is a string list" So some hypothetical rust examples would be: i32 Option String Vec i32 Cell Rc Although I'm not sure if I really like it for deeply nested cases and using this form with more complex generics would be very unwieldy (and in some cases impossible). F# seems to take a hybrid approach where the simpler generics can be defined in this fashion, but more complex need to be wrapped in angle brackets. So you could do: Rc&lt;i32 Cell&gt; HashMap&lt;String, i32 Cell&gt; Which really helps reduce on bracket noise IMO. Personally I'm just a fan of the way F# tries to un-nest things by giving them a left to right pattern, such as the generic shorthand and the |&gt; pipe operator.
&gt; different tools have different defaults for tabs, and your code WILL look weird to someone else that doesn't follow your coding process. That's why you should use tabs for indentation and spaces for alignment. That way, if tabs are a different width, the code still looks different but everything still lines up nicely. Although in languages like Python and now Rust, where the official standard is to use nothing but spaces, I guess it's better to stick with that.
Both this proposal and the Coffeescript example bind in the wrong way if you come from ML, that is, `foo bar baz qux` should bind as `((foo bar) baz) qux`.
This looks very nice. I did some googling and it seems this postfix notation for parametric types was borrowed from ML. If that notation were restricted to types with only one parameter I think it would significantly cut down angle bracket noise without being too confusing.
It works, but if I have to type out the original type, it's not a real type def. Having to alternate between the type alias and the original throughout a program is more confusing than helpful!
Haskell does have an overhead for generic data structures. A [Int] is actually a list of pointers to ints. The values are not stored unboxed (unless you make the field strict and specialize it to a particular datatype).
Google Cached version: http://webcache.googleusercontent.com/search?q=cache:http://yager.io/programming/go.html
Is that due to genericity?
&gt;A [Int] is actually a list of pointers to ints. Correct. I meant "overhead as compared to the non-generic version". As far as I know, if you specify a separate type of data IntList = Nil | ConsInt Int IntList it is equally (in)efficient as data List a = Nil | Cons a (List a) and specifying `a` to be an `Int`. 
I started out saying "screw this guy", but after reading the article, I can't say i disagree with any of his final conclusions. 
Thanks!
I was pointing this out not to replace Dash but so you didn't have to rewrite Zeal. Also, devhelp uses a WebKit view to actually display docs, it just wants the docs to be in the docbook XML format. Translating between docbook and HTML should be trivial as devhelp does exactly that.
C does have a conditional that returns something: the ternary operator. Apparently Go doesn't have a ternary operator however, which is disappointing. 
And this is the only right way to bind if you have currified functions.
Note that ML/OCaml uses the postfix notation and for more complex type, it doesn't suddenly use prefix, just parenthesis : `(string, int) hashtbl`, for example. 
And suddenly, Rust look a lot more like Haskell. :D
In fact, there is fundamentally an overhead. You might compile `map` for unboxed objects, but that makes the code larger, which leads to less efficient cache + branch predictor usage. You might inline `map` for a specific function argument, which does away with function call/return and might even vectorize the loop, but again that makes the code larger. What matters to me is having sane defaults. Boxed objects and function pointers is often a sane default. It would be even better if languages gave us a choice to recompile a specific application of `map` for the data type variable and/or the function argument.
I'm going to play devil's advocate here. Go's design philosophy is to make programming easier and more fun by reducing cognitive load on the programmer. It's deliberately designed to be simple and easy to work with. All of the complaints here if implemented would make the language more complex and less in line with its design objective of simplicity. Whether you agree with that philosophy is a whole other thing. Rust to me has gone the other way - it's very feature rich which is exciting and provides some powerful features, but it lacks the simplicity of Go. As someone who uses both I'd say they each have their upsides and downsides. There's a lot to like about both approaches and each has its place. 
I like Arc&lt;Exclusive/Vec/Box/Buffer/T&gt;
OK, that's fair. Go is somewhat simpler to work with that Haskell or Rust. But if that's what it's going for, it's not doing a very good job in that regard either. Languages like Lua and Python are even better than Go at being simple.
&gt; Type Inference Sure, giving all types by hand is a bitch. One way to solve that a fancy type inference algorithm. Go's approach is use a stupid type inference system and make types a lot simpler. Simple is good, and fancy types aren't perfect either. The approach of Go is not to do everything, but rather to do less in a better way. &gt; Go's solution: no immutable types On the contrary, I would argue that most Go types are immutable by default. If you need a mutable type, that's when you'd use a pointer to that type. That said, recursive types cannot be immutable unfortunately. 
&gt; Go doesn't really do anything new. I would argue that tight and idiomatic integration of fibers (lightweight threads) into the language is important, these days. Consider for instance what to do with a fiber that's waiting for a dead channel. Go would destroy that fiber. They're not new features, but it's a lot less trivial how to use them properly in other languages. If fibers is what you need, then Go vs. other languages is like iOS vs. Windows Mobile. You can do everything with both, in fact you can do more with Windows Mobile, but that doesn't mean Windows Mobile is good if what you need is a smartphone.
&gt;Sure, giving all types by hand is a bitch. One way to solve that a fancy type inference algorithm. That's a very simplistic view of type inference. It's much more powerful than a time-saving mechanism. &gt;Go's approach is use a stupid type inference system and make types a lot simpler. As mentioned in the article, Go doesn't really have type inference. It just has a stupid "fill in the blank" mechanism, like C++. &gt;but rather to do less in a better way. I don't think Go's type inference "better" because it's weak. &gt; I would argue that most Go types are immutable by default. That would be false. I'm not sure how you could argue this. You can, quite plainly, overwrite values. 
Erlang did this decades ago, so it isn't new there, either. I think Go's 'newest' kind of feature is its really great onboarding and new developer story. 
/r/playrust
This is even worse: http://play.golang.org/p/otMa6pWhnZ Source: https://twitter.com/charliesome/status/483379683523047426
&gt; in the mean time I changed the Cargo dependency to my fork :heart_eyes: I'm so psyched Cargo, as unfinished as it is, is here.
&gt; &gt; I would argue that most Go types are immutable by default. &gt; &gt; That would be false. I'm not sure how you could argue this. Touché. The way I mean it is you can modify your arguments, but the caller won't see it. Maybe I should rather have said that Go is by-value (as in C) rather than by-reference (as in Python). &gt; That's a very simplistic view of type inference. It's much more powerful than a time-saving mechanism. I'd love to argue a bit about this. Do you happen to have an example at hand? _ninja-edit_: I'm aware that Rust and Haskell allow the inferred type to drive method selection for instances. But then also, you could infer an interface type in Go. I'd like to see why exactly a stupid type inference system is worse than a smart type inference system. 
No, take a closure.
&gt;Go is by-value (as in C) rather than by-reference (as in Python). That's true. I like that as well. But immutability is even better, because there's no copy step needed! &gt; Do you happen to have an example at hand? Well, stuff like this is pretty cool. triple = (*3) Haskell knows that `triple` has type `(Num a) =&gt; a -&gt; a`. So the type inference can actually travel in the opposite direction it does in languages like C++ or Go. That should give a bit of an idea about how powerful hindley-milner type inference can be. &gt;I'd like to see why exactly a stupid type inference system is worse than a smart type inference system. I say that mostly because a smart type inference system can do everything a dumb one can, and more. If you only want to use the dumb features, you're free to never look at the smart ones.
Fair enough, I forgot about typing parameters for a sec. On first thought, that only seems to work if you have some form of type variables (generics) anyway; secondly, it's primarily relevant for non-top-level functions, as Haskell (and maybe Rust) programmers are encouraged to write types as documentation anyway.
Lua has a solid claim on being beautifully simple. Python (+Ruby+Perl+PHP) do not. All of these languages are *huge* with very very dark holes that can make reasoning about the code difficult. Go is doing a wonderful job at being simple. It's precisely the reason why I use it. (Simplicity, is, of course, not be-all-end-all. But it's a valid reason to use something.)
Indeed, it only *looks* similarly.
I meant "simple" from a new user's perspective, not "simple" from a design perspective. For the latter, you are correct. &gt;Go is doing a wonderful job at being simple. Really? Because I'd say that Go is simple in the way I meant (from the user's perspective) and not simple from the design perspective, just like Python.
Agreed or perhaps something like: Arc[Exclusive&gt;Vec&gt;Box&gt;Buffer&gt;T] Or Arc&lt;Exclusive#Vec#Box#Buffer#T&gt; 
Why did it move back? 
Don't know, I wasn't yet Rusting at that time.
`foo` is a module, not a function (although you can have generic types, e.g. `Vec::&lt;int&gt;::new`).
Yes. But you could do what C# does, which is share one implementation for all reference types and specialise on primitives.
True! I was thinking of chaining
Go Constant declarations are pretty weak. You can't really do a whole lot with them (for example, I don't think functions can be constant-typed).
A few months ago, the lack of generics and extensibility in Go was what drove me to search for other low-level languages - and how I ultimately ended in Rust
oo, didn't know that! Thanks!
Could you go into a bit of detail on what sort of ambiguities are avoided by the ::&lt;&gt; syntax? I feel like it'll be easier to use if I know the motivation.
Is the `&lt;` and `&gt;` greater than/less than or is it parenthesis around a shape type? In Java, it's always the shape type (which potentially broke old code), and in C++, I'm not sure.
`bar&lt;a&gt;(b)` could be parsed as `(bar &lt; a) &gt; (b)` (i.e. two comparisons). I believe C++ distinguishes depending on the type of `foo` and possibly even if `a` is the name of a type or not. With `::&lt;&gt;` there's no possible ambiguity: if you see `bar&lt;...` you know it's a comparison, if you see `bar::&lt;...` you know it's a type hint.
Not true. In ghc 7.8 the former (if you change it to ) data IntList = Nil | ConsInt !Int IntList will probably trip the "unpack small fields" optimization and have the Int field be totally unboxed. You could then actually go one step further and define something like data family UnboxedList a data instance UnboxedList Int = IntNil | ConsInt {-# UNPACK #-} !Int (UnboxedList Int) and so on. This data family approach is actual how unboxed struct of array style vectors are implemented in haskell.
That's true, but we're not talking about lists that are strict on their cons-data (I'd rather avoid digging into the minutia of Haskell datastructures in the article). You also can't get these unpacking optimizations on non-primitive data structures (like Integers, Strings, etc.) so I'd say in the general case the statement "there is no overhead as compared to the non-generic version" is true. I'd rather avoid being too pedantic in the article, because it will distract people from the important lesson (that genericism doesn't necessarily involve super complex type tagging/casting stuff).
&gt; Consider fiber waiting on a dead channel. Go would destroy such fiber. Except it wouldn't: Go will no destroy goroutine waiting on NOT CLOSED channel even if no other links to channel remains. So it is actually "goroutine leak".
My view of fun programming consists having powerful abstractions at hand that can be understood easily. In this sense Ruby and Python excel wonderfully. To me the big problem with Go is that it's built so that implementations are easy to understand, but abstractions are not. What I mean by this is, by not doing operator overloading of map() and fold() or generics you an clearly see what the code is doing at a lower level, but you lose the higher-level understanding that these constructs provide; I *want* the reader to know that when I loop through a collection I'm doing the equivalent of a map(), whereas at other times I do it to to fold, or filter, or whatever. And I disagree that this is a difficult concept for programmers of "different skill levels" to grasp, which is one of the claims to fame for Go. In fact the manual bookkeeping is what sometimes discourages newbies and limits their understanding of what's actually going on with code.
Elaboration: The equivalent Rust code against `HashMap` would look like this: fn get&lt;'a, K, V&gt;(arr: &amp;'a HashMap&lt;K,V&gt;, key: &amp;K, default: || &amp;'a V) -&gt; &amp;'a V { let value_or_none: Option&lt;&amp;'a V&gt; = arr.find(key); value_or_none.unwrap_or_else(default) } Note that [`Option::unwrap_or_else`](http://doc.rust-lang.org/core/option/type.Option.html#method.unwrap_or_else) already takes a closure without arguments (often called a "thunk" function), so in fact you don't need this function at all. Just let the users see the `Option` and they would use `unwrap`, `unwrap_or` or `unwrap_or_else` as they want.
About to read the article, but to me the title reads like "A comparison of Boxer Briefs to Ties and Bowties".
The actual article's title is a bit clearer (but I was afraid it might be too inflammatory to put here).
Is there any significance to these milestones for those of us who are keeping up with the nightly builds? Any big changes that are being saved for the number turnover?
A specific version of the nightly (or a version between two nightlies, if you do care) *is* the point release, so you don't have to worry about that if you were consistently tracking the nightly.
Do you have a source for that claim? [This book](http://www.golangbootcamp.com/book/concurrency#uid126) says the runtime panics on deadlock.
Take the following: `foo&lt;int&gt;(a, b, c)` Does it parse as a function call of `foo`, with the type parameter `int`, or a comparison between `foo` and `int`, and a comparison against a tuple?
&gt; If libfoo has done something that results in UD (easy to do, eg. with transmute() to break pointer aliasing rules), we can have our code that is 'purely safe' crash mysteriously with a segmentation fault. Being able to invoke UB without `unsafe` via an external library is a bug in that library. It's purporting to have a safe interface but doesn't. &gt; You can only actually be sure your code is 100% safe if you're certain that none of your code paths contain any unsafe code; and as far as I'm aware, you can't actually do that. No, you can manually verify that the `unsafe` blocks are correct. This does have the possibility for human error, but at least it's clear where the problems can originate. I personally try to ensure that every `unsafe` block has a comment with a short (or longer) "proof of correctness", e.g. [the `sort` in the standard lib has a pile of comments](https://github.com/rust-lang/rust/blob/e25eb6b223d86047dc807a167f3dd4bf492bbf41/src/libcollections/slice.rs#L410-L526), not everything has to be that detailed, but at least some sort of sketch/hint about why it's OK is very good. &gt; as far as I can see libraries try their best to hide unsafe functions away, to make idomatic APIs. Idiomatic APIs hide unsafety inside properly safe interfaces; it is *highly* non-idiomatic to mark something that is `unsafe` as safe (well, to not mark it as `unsafe`) just to avoid users having to write `unsafe { ... }`. &gt; It almost feels to me like unsafe should be restricted to FFI only... That would destroy one of the big benefits of Rust, being able to naturally write safe &amp; performant low-level abstractions. e.g. You would have to use FFI to implement the `Vec` and `HashMap` in the standard lib, which is an even bigger loss than `unsafe` being able to be abused. The rest of Rust's abstractions (`enum`s, traits, pattern matching, pedantic compiler) are still useful inside `unsafe`, and one can use them carefully to make the `unsafe` as safe as possible.
This is in line with the "no magic, no gods, only code" Zen of Rust. Btw. is the "Zen of Rust" already documented? Chapter 11 of the manual, which would come closest, is still only saying TODO.
This proposal only works for types with one parameter. What would you propose for maps or results? Otherwise good bikeshedding here. ;-)
Totally agree, I just wonder if there isn't something better you could do with crate metadata or something to help you hunt down issues on this front. Imagine the situation where you have 10 dependencies, each of which has 4-5 dependencies and you get a problem in code which is 100% safe as far as you can tell. With an immediate seg fault you can probably work backwards looking at pointers, but with pointer aliasing the result could easily be non-deterministic memory corruption right? It may even work correctly in some systems / deployments and fail on others. How do you hunt down which dep, or subdep is causing the problem?
As a library author, I want to use Haskell and Rust. As an application developer, I want to use Go.
The indentation changes when I click "format" on the playground.
The real point I'm making is that you can have 100% safe code that crashes; if you have a dependency with a 'safe' api that you call, which is broken. There are already loads of examples on github of code that uses FFI and unsafe blocks without marking the external API as unsafe; because the operations they are run are probably mostly safe as far as the library author is concerned: but that doesn't necessarily mean they're bug free and actually always safe. It's easy to say the onus is on library authors to write safe and correct code, but you've got to trust that *all the authors* anywhere in your chain of dependencies (and their dependencies) have done so. ...I'm just not really convinced that's realistic. Maybe any function that contains an unsafe block or calls an unsafe function to be marked as unsafe automatically at compile time? I'm not really sure; but I'm pretty comfortable saying that being able to have code you've written that is (as far as your own code goes) 100% safe, and *crashes* is pretty catastrophically bad... but currently totally possible. 
[Issue submitted](https://github.com/rust-lang/rust/issues/15264)
I don't have this issue at all... Althought it is short, syntax highlighting makes it very easy to read.
Well, `fn` or `fun` is not that uncommon in programming languages: according to [syntax across languages](http://rigaux.org/language-study/syntax-across-languages/Fnctn.html), Common Lisp (`defun`), Oz, SML (`fn` for anonymous, `fun` for named), OCaml, F# and Erlang use them. I guess the rationale behind `fn` is that functions are defined and used a lot and should require the least number of keystrokes to define but still be unambiguous. Remembering that `fn` stands for function is an one-time cost after all, and any reasonable alternatives (`fun`, `func`, `function`, possibly `proc` and `procedure`) wouldn't give instant productivity boost.
I'm going to nitpick on the problems of the article, otherwise it is well written. i.e. I don't agree with the opinions, but I understand why another person might have them. &gt; What if you wanted to write a generic data structure? Let's write a simple Linked List. You shouldn't be writing a linked-list in the first place. &gt; The "correct" way to build generic data structures in Go is to cast things to the top type and then put them in the data structure. Nope, the suggested way is not to have generic types. In other words, use code-generation (alt. specialization) or just use maps/slices, which work out quite well in most cases. &gt; The closest thing to a flexible iterator keyword is building a wrapper around your... You can also do: func (t *Tree) IterPre(do func(*Tree)) { if t == nil { return } do(t) t.Left.IterPre(do) t.Right.IterPre(do) } func (t *Tree) IterPost(do func(*Tree)) { if t == nil { return } t.Left.IterPost(do) t.Right.IterPost(do) do(t) } The more complex the structure is, the more ways there are to iterate over it, which means the "range" syntax would be confusing. &gt; ... However, using the null pointer in this way is unsafe. `nil` is just a value. Would you remove number `0` from a language because it denotes a sum over no elements? The problem with nil is that it was used for signaling errors. In a similar way `sqrt(-351)` shouldn't just return `0`, it should also somehow notify of the error. &gt; Imagine a function that searches an array of non-empty strings for a string starting with 'H', returns the first such string if it exists, and returns some kind of failure condition if it doesn't exist. In Go, we might return nil on failure. No, you would return two values (string, error) or (string, found) whatever is more appropriate. &gt; I don't want to short-change Go here; it does have some nice control flow primitives for certain things, like select for parallelism. However, it doesn't have compound expressions or pattern matching, which I'm a big fan of Go has pattern matching, but in a limited form (just one-level of complexity): switch v := v.(type) { case int: // ... case string: // ... } switch { case v == "hello": // ... case x == "world": // ... } &gt; This (Unsafe Low-Level Code) is exceptionally dangerous, and only makes any sense whatsoever in very low-level systems programming. This is why neither Go nor Haskell have any easy way to do this; they are not systems languages. Go has unsafe package, also it has support for writing functions in asm. In my opinion, the author of the article clearly hasn't written significant amount of Go code, which means that the opinions on Go's problems are pure speculation.
FWIW I've always internally pronounced it as "ef en".
Interesting! As aside, I think [`exa::sort`](https://github.com/ogham/exa/blob/master/src/sort.rs) can be replaced with [rust-natord](https://github.com/lifthrasiir/rust-natord/). (I forgot to register it to Travis though...)
I never considered that, thanks
You should take a look at Rust binutils. They are implementing full a lot of the unix tools, they are happy for contributions. 
Unless you give us your reason for disagreement, your comment as it stands is worthless. Please come back and contribute to the discussion.
Any reason you changed the meaning of -l?
a web framework? At least a Readme.md please.
You are looking for [issue #6515](https://github.com/rust-lang/rust/issues/6515). Currently we can't override every possible indexing behavior with traits.
&gt; Nope, the suggested way is not to have generic types. In other words, use code-generation (alt. specialization) or just use maps/slices, which work out quite well in most cases. What if my problem requires a data structure besides a map or slice? I can't use a 3rd party library. Instead I have to roll my own and use code generation to, for example, make an AVL tree of FooBars? Sounds crazy to me. &gt;nil is just a value. Would you remove number 0 from a language because it denotes a sum over no elements? The problem with nil is that it was used for signaling errors. In a similar way sqrt(-351) shouldn't just return 0, it should also somehow notify of the error. The problem is this puts the onus on the programmer to always check the error value for functions that return any type that could be nil, and when creating functions that return nil-able types, also return an error value. We know programmers are lazy, and we know that humans make mistakes. Sooner or later a function will return nil and a programmer will use that value without first checking for nil and/or checking the error value. Badness will result. (not to mention the lesser problem that these extra error values that functions must return are ugly and noisy) Far better to design the type system to make such errors impossible (or possible only when the programmer also indicates the intention to the compiler/future code reader). For example, see Haskell's Maybe type. The programmer must have logic to deal with the Nothing case, or use [fromJust](http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Maybe.html#v:fromJust) to indicate to both the compiler and future readers that the intent is to ignore the Nothing case.
As I said, you can use specialization? You fetch the "generic" code: type Value interface{} type Tree struct { Value Value Left *Tree Right *Tree } And now you `sed` or `go fmt` type `Value` to your own type... and you are done. In the specialized package directory run `go fmt -w -l -r "Value -&gt; *your.Type" .` &gt; ... for example, make an AVL tree of FooBars? How often do you use such AVL tree? And, especially, with multiple different types in a single project so that this generation would be a significant overhead? &gt; Sounds crazy to me. The problem is that there are `N` different ways how to extend a language and not all of those ways should be supported. Sometimes the easier solution is to write a simple code-generator/rewriter that does the work for you, rather than handle the special cases in the language. Go has decided to draw the features line differently than other languages, which means you would start using those code-generation tools earlier, but in practice it still happens rarely. &gt; Sooner or later a function will return nil and a programmer will use that value without first checking for nil and/or checking the error value. This is, kind of, protected by running `go vet` on your project. You need to use the values when they are named, and `go vet` notifies about unhandled return values. You are speculating about all the possible "nil" errors, in practice they are much rarer. &gt; (not to mention the lesser problem that these extra error values that functions must return are ugly and noisy) You should propagate proper error messages; if you did that with Haskell you would still get the same result (mostly). At least I am not able to conceive a better solution. As an example you have a map id -&gt; URL, imagine a url shortener. Please show how to give a proper error message? urls := map[int]string // ... if url, ok := urls[id]; ok { return url, nil } return nil, fmt.Errorf("did not find url with id %v", id) Yup, you can use Option types, but the code wouldn't be much shorter.
If not Haskell-style syntax, I've always wanted to just use plain parentheses. I don't actually know how it'd look, so let's find out: Arc(RWLock(Vec(f64))) Arc[RWLock[Vec[f64]]] Arc&lt;RWLock&lt;Vec&lt;f64&gt;&gt;&gt; After all, it's just type-level function application (or ok, more specifically: tuple struct construction), so it makes sense to use the same syntax.
It does --long by default, so -l wasn't used for anything.
Thanks, I'll give that a try!
I actually used the uutils source as a guide for how to interact with C libraries, since I couldn't figure it out myself.
Also not that new. People have been writing web apps in compiled languages for a long time. I'm surprised you explicitly mentioned Java: "scp this WAR" is the same as "scp this binary".
Here is the thing. Right now people are busy writing really cool software with go. No matter how much people claim it sucks because it doesn't have X feature or Y feature apparently it's good enough to attract a very large community of smart people who get shit done. I think practicality and pragmatism are just as important as "correctness" and in some cases more so. People make pure languages which become so complicated and difficult to use they remain the play toys of the navel gazers instead of powerful tools to be wielded to solve real world problems. I hope rust doesn't fall into that trap. I hope they manage to end up with a practical, pragmatic, easy to learn and use language. 
Until we hit 1.0, releases just happen every three months. There isn't really anything special about them. They can be nice markers if you don't want to always stay current on nightly. I only update Rust for Rubyists every three months, for example.
Isn't there a compiler flag that disallows unsafe blocks, and therefore, would print out everywhere where you have one or depend on one?
Here's the tracking issue for adding `ls` to coreutils: https://github.com/uutils/coreutils/issues/126
There's an `unsafe_block` lint, so you can disallow `unsafe` blocks in certain modules/crates by adding a `#[deny(unsafe_block)]` attribute (or `#[forbid(unsafe_block)]` to disable them completely, an `#[allow]` cannot override a `forbid`). However, as soon as you start talking about transitive dependencies on `unsafe`, almost everything will be pinged: the standard library uses `unsafe` to build all its abstractions e.g. it would warn about `Box` and `Vec` (any dynamic allocation really) and thus `String` too; many/most of the methods on `&amp;[]` and `&amp;str` build from unsafe internals; anything concurrent definitely uses `unsafe`...
I think it would be possible to have a `Lazy&lt;T&gt;` struct, without any special kind of magic... I will give it a try and post the result. EDIT: No keywords nor magic! Take a look at https://gist.github.com/aochagavia/34d9be614c09c8a060ac
c.f. https://github.com/rust-lang/rfcs/blob/master/active/0034-index-traits.md
Only possible fix I see is allowing to specify that an extern crate is "untrusted", and have the compiler fail if that untrusted crate uses any unsafe blocks. But in general, you need to trust that the libraries you use behave as expected, so trusting them to also use unsafe blocks properly isn't such a huge leap. 
Well, the places I have worked JDk+ java application server + muliple jars of particular version are required to make 'scp this WAR' work and that's after discounting the possibility of classpath issues that can still occur. Imo underestimating value of static binary of go app does not do any good.
Could you give the rationale that guides your preference?
Even in Python, a "safe" language, you can go to ffi or use known bugs in the interpreter to cause a crash from library code. Haskell has an escape hatch called `unsafePerformIO` which allows you to encapsulate anything (hopefully sound operations) in pure code. I hope editors boldface the Rust keyword `unsafe` and that programmers take it as a call to think: Do I need this, and is it sound?
From the blog post: "We have to be careful using languages that aren't good, because if we're not careful, we might end up stuck using them for the next 20 years. "
That doesn't address anything I said. What's wrong with using go for the next 20 years if you get shit done? The fact is people use languages in order to get shit done in a fast, easy, enjoyable way. This is why languages which are highly productive (or have massive libraries) percolate to the top.
Feel free to post ideas and feedback in this thread.
Of all of those our current choice of &lt;&gt; is by far the hardest to read.
I don't think it's ready for public consumption, so that's kinda intended.
Haskell and Rust are great at abstraction, which is perfect for making libraries other people will use. Go is very simple, which makes application code better.
The tutorial that I'm writing is mainly for people that are both new to Piston and new to Rust, but have some experience with gamedev, so it will probably end at "triangle on screen". In the mean time, I'm working on an immediate mode user interface library for Piston called [IUI](https://github.com/TyOverby/Rust-IUI/tree/master/examples). I'm also in the process of writing a Cargo package that automatically compiles the C and C++ Piston dependencies (Like GLFW and SDL2) and links them into your project. My goal is to get the entire "setup" stage of a piston project self-contained in Cargo with zero external dependencies. This project is blocking on some Cargo features, but I have hope! https://github.com/TyOverby/piston-dependencies 
&gt; Please don't release Rust 0.11 yet. A bug was introduced recently which breaks with how Rust-Graphics is designed https://github.com/rust-lang/rust/pull/15191#issuecomment-47527693[2] (we want Piston to work with 0.11, at least for a while...) Please mention this on the 0.11-prerelease thread on the mailing list!
" When you have data structures like this [empty interface], you completely eliminate any of the benefits that a type system provides." ... likewise, rust having 'unsafe' blocks complete eliminates the benefits of safety mechanisms provided by rust ;-).
Sure. I'm thinking in terms of the day-to-day 'put my code on a server and make it go.'
I assume you meant you didn't know how to get the terminal width: there are escape codes (and maybe some ioctl stuff?) that can be used on VT emulators (like most linux terminals out there). For Windows, I have no idea atm, though there might be an API call that does just that.
I'm not on the mailing list. Could you do it for me?
There is no type inference there. `auto` is replaced with `decltype(*v.begin())` which is the return type of `v.begin().operator*()`.
The practical outcome is that any really serious project has to audit all the unsafe code in all of its dependencies. Also, I've seen people look on unsafe as a sort of 'cheat' to get around Rust's strictness. If you depend on a library written like that, then you need to dump that library and find another one.
I hate it when I'm reminded that people do that and I end up compulsively doing it myself.
I thought I could just use the $COLUMNS environment variable... but actually, it seems to calculate the number of columns based on the width of each column, and the width of each column based on the number of columns, and I couldn't get my head round that.
&gt; This project is blocking on some Piston features, Should this say Cargo features?
The fact that people are downvoting you for suggesting that null pointers are a bad idea in /r/rust is pretty mystifying to me.
&gt; How often do you use such AVL tree? And, especially, with multiple different types in a single project so that this generation would be a significant overhead? Replace "AVL tree" with "concurrent hash map". Concurrent hash maps *are* used all over the place in high-performance code… &gt; Yup, you can use Option types, but the code wouldn't be much shorter. urls.find(id).map(|x| Ok(x)).unwrap_or_else(|| Err(format!("did not find url with id {}", id)))
No, it's because of laziness, actually. Every object (int, string, a list cons cell) is actually represented either by a thunk (a function that will calculate and return the result) or the final value. Genericity/polymorphism can just reuse the same indirection for other purposes.
&gt;The tutorial that I'm writing is mainly for people that are both new to Piston and new to Rust, but have some experience with gamedev, so it will probably end at "triangle on screen". Link? 
&gt; Concurrent hash maps are used all over the place in high-performance code… Emm, are they? First, which language and implementation do you mean and which kind of high-performance code do you mean, at least give some real world (production) example? I would guess that the implementation without a concurrent hash maps will be better in performance sensitive situations. Also, most of code isn't high-performance code. urls.find(id).map(|x| Ok(x)).unwrap_or_else(|| Err(format!("did not find url with id {}", id))) IMHO it has more noise and it's less readable.
&gt; First, which language and implementation do you mean and which kind of high-performance code do you mean, at least give some real world (production) example? In Java, say, `ConcurrentHashMap` is used all over the place. Suppose you're writing a program to calculate word frequency over many files, spawning one thread per file to make the best use of multicore. A concurrent hash map is a very natural data structure to accumulate the results in. &gt; Also, most of code isn't high-performance code. There's no reason to make the most natural way to write something also slow. &gt; IMHO it has more noise and it's less readable. You're moving the goalposts, as you asked for something *shorter*. If you want the more "readable" version, then you can write it just as you did in Go: match urls.find(id) { Some(url) =&gt; Ok(url), None =&gt; Err(format!("did not find url with id {}", id)), } (Which I find more readable than the Go version anyhow, because `Ok` and `Err` are descriptive names, instead of relying on the position of "nil".)
What should sqrt(-5) do? And should we disallow negative numbers because of it? Yes, nil pointers can cause problems, but with Go you are less likely to hit them than in C/C++. The only place, that is most likely in Go, is structure initialization, e.g.: type Foo struct { bar *Bar } func (foo *Foo) String() string { return foo.bar.String() } foo := &amp;Foo{} fmt.Println(foo.String()) It can be automatically detected to some degree. Also it could be avoided with a New function. func New(bar *Bar) (*Foo, error) { if bar == nil { return nil, fmt.Errorf("Bar cannot be nil") } return &amp;Foo{bar}, nil } Also, let's take this [Rust example](http://www.reddit.com/r/programming/comments/29fp6w/why_go_is_not_good_will_yager/cikpgn6): let x: Option&lt;int&gt; = None; println!("value is {}", x.unwrap()); Just because you have option types, it doesn't mean you can't use them wrong.
&gt; Just because you have option types, it doesn't mean you can't use them wrong. I don't think anyone has claimed otherwise. `Option` merely formalizes the concept of a value that isn't guaranteed to exist. This makes it obvious when error handling is needed. `Option` also comes with several methods that make error handling easier. `unwrap` is just one way to deal with errors (and always a deliberate choice), and it exists because sometimes crashing is the best solution (and the compiler will tell you that unwrapping a None was the cause of the crash). 
&gt; In Java, say, ConcurrentHashMap is used all over the place. Suppose you're writing a program to calculate word frequency over many files, spawning one thread per file to make the best use of multicore. A concurrent hash map is a very natural data structure to accumulate the results in. I would use per thread map and later reduce them, e.g. http://play.golang.org/p/RVDO5cwEy3 . I'm guessing that would be faster than using a concurrent map, although I have not measured it. &gt; You're moving the goalposts. Sorry, that I only mentioned "shortness" in my text. The text that I responded to contained criterias of "that these extra error values that functions must return are ugly and noisy", i.e. the goal posts were set by that. The shorter actually wasn't the initial criteria. &gt; If you want the more "readable" version, then you can write it just as you did in Go. That is what I was trying to get across, when you properly handle the errors with good messages then code won't be less ugly nor less noisier.
Only if *all* goroutines are sleeping. If some goroutines are running but others are deadlocked in a cycle, the runtime will not panic.
&gt; I'm guessing that would be faster than using a concurrent map, although I have not measured it. I doubt it. Uncontended striped locks are very cheap and the contention will be low. If you have contention, bump up the number of locks. (This is tunable in most concurrent map implementations, including that of Java.) &gt; That is what I was trying to get across, when you properly handle the errors with good messages then code won't be less ugly nor less noisier. Both snippets I posted properly handled the errors with good messages. (And I think the Rust code is clearer than the Go code for the reasons I stated.)
&gt; I don't think anyone has claimed otherwise. Quote from the article: &gt; Instead of returning a string or a null pointer, we return an object that may or may not contain a string. We never return a null pointer, and programmers using search() know that it may or may not succeed (because its type says so), and they must prepare for both cases. Goodbye, null dereference bugs. I.e. the unwrap bug is equivalent to the null dereference bug. &gt; This makes it obvious when error handling is needed. Returning an error makes it also obvious that error handling is needed. &gt; ... and the compiler will tell you that unwrapping a None was the cause of the crash The compiler will also say that you dereferenced nil.
Voting has been _very_ weird around here lately. 
This is not true, which I think you know because of the wink. An empty interface _removes information_. It's a form of type erasure. You've lost some information you use to have. Unsafe blocks _add information_. Normally, you can assume segfaults and memory weirdness should not happen. If they do, you have extra information to track down your bug.
&gt; I doubt it. Now to rethink, actually I they would probably perform similarly, the bottleneck would probably be IO. The [k-nucleotide shootout](http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=knucleotide) would be the closest to this example. Java #2 uses per routine structure, Java #5 uses ConcurrentHashMap. But I'm not sure how much they have been tuned.
The Go version of that benchmark, incidentally, is an excellent example of why generics are good. There's nothing integer-specific about the hash map that they created for the benchmark, and if that table had been in a library then the author of the benchmark wouldn't have had to rewrite it.
Sure. That's not the point. After the `unwrap`, you _know_ it is not possible for there to be no missing value. You cannot pass it to other functions, you can't do other operations on it. It needs to be explicitly handled.
Yes it should have; Thanks for the correction!
Both empty interface and unsafe blocks say 'there is something nasty going on here, but trust me anyway'. Outside unsafe blocks rust guarantees safety 'statically', and likewise you have reliable static type info outside empty interfaces in golang. Admittedly, typical programmer ends up using empty interface more than rust's 'unsafe', but the statement I quoted and analogy I provided are equally nonsensical. It's not like your entire program is tainted by using either feature.
&gt; ... is an excellent example of why generics are good. I think you are mistaken my position, I don't think generics are bad, they are wonderful and magical things in some places... but there aren't so many places that need them. &gt; There's nothing integer-specific about the hash map that they created for the benchmark, and if that table had been in a library then the author of the benchmark wouldn't have had to rewrite it. The hash table implementation is specifically implemented/tuned for this example, it probably wouldn't be very useful as a library. Also, those Go implementations look terrible.
&gt; I don't think generics are bad, they are wonderful and magical things in some places... but there aren't so many places that need them. I think if you want across-the-board high-performance code, you need to have the freedom to program naturally without shoehorning maps, arrays, and channels into every problem if they're not the best fit. Go has chosen to leave some performance on the table in practice in order to get everyone using the same few data structures. As a C++ replacement, however, Rust believes strongly in zero overhead and maximum performance. Both approaches are valid, but it's not as simple as "generics are worth it" or "generics aren't". &gt; The hash table implementation is specifically implemented/tuned for this example, it probably wouldn't be very useful as a library. I don't see anything specific to the benchmark in its implementation. `HTable` is a bog-standard chained hash table.
I'm not very familiar with Rust. What's the point of idioms such as: "literal_string".to_string() https://github.com/ogham/exa/blob/master/src/colours.rs#L20
&gt; I don't see anything specific to the benchmark in its implementation. HTable is a bog-standard chained hash table. The standard hash-map for go is `map`, which is for general purpose. I.e. yes you could make it generic, but there would be very little value in it.
There is no support, but having this is widely considered necessary and desirable.
There are two kinds of string: The variable length, modifiable string. (`String`). And an immutable string. (`&amp;str`). A string literal has the type `&amp;str`. `.to_string()` is a method on `&amp;str` that gives you a `String`.
Two very common examples: let mut x = None; let mut y = vec![]; In both cases, Rust can infer the type from *later* use. The equivalent in Go or C++ requires a type annotation.
I thought it was actually `String` instead of `Str`
This Week in Servo has not been replaced, but will be augmented with This Week in Cargo.
Ugh, you are correct. The names changed like five times. I'll edit.
I'm not an expert, but I believe: The string literal is a static immutable string (&amp;'static str). A "String" is a growable string type similar to a vector. In C++, I believe it would be something similar to this. static const char* str = "literal_string"; string a = string(str); Now tell me why I'm wrong. http://doc.rust-lang.org/std/string/struct.String.html http://doc.rust-lang.org/std/str/
I contributed TWiC, so any errors are mine, not cmr's.
Was there any reason you didn't contribute this to uutils? I'm just curious.
I thought that uutils would just want a bare-bones ls, but I plan to add more features to this that some might consider bloated (more colours, natural sorting, file-specific columns).
Screenshots? (I think a good screenshot is always good idea for an application that has an UI (like a game)).
I don't think there's a way to check whether a struct implements a trait at runtime. Correct me if I'm wrong. But you can check at compile time. The best I could come up with was a generic method that fails to compile if the parameter passed doesn't implement the trait. trait Derp { fn do_derp(&amp;self); } struct MyDerp; struct NotDerp; impl Derp for MyDerp { fn do_derp(&amp;self) { println!("Hello World!"); } } fn main() { let d = MyDerp; let n = NotDerp; run_derp(&amp;d); run_derp(&amp;n); } fn run_derp&lt;T: Derp&gt;(d: &amp;T) { d.do_derp(); } 
I agree. Unfortunately, I think it's too late to change it at this point, but, considering lifetimes, I thought to be writing on the rock, are on the chopping blocks for syntax change.
I can't reach it either, but a check for http://www.downforeveryoneorjustme.com/http://blog.octayn.net/blog/2014/06/30/this-week-in-rust-54/ reveals that its just me :(
The example I ran into was trying to log a Result error value that was defined as an Any. Being able to do let showable = x.is::&lt;Show&gt;(); was the use-case I ran into, but that code only works for types, not traits. I managed to find an alternate solution using the poly format ({:?}), but being able to explicitly check for the existence of a Show implementation would still be useful, for example if you want to filter out values that don't implement it.
I don't see a scenegraph library in the list of Piston projects. Is this in the scope of Piston ?
&gt;This week in Piston That is an impressive list of work! Keep on trucking, this is awesome! What are your thoughts on snowmew?
FWIW, having different goals doesn't mean Rust *isn't* more complex than Go. However, it does mean that the two languages have completely different aims, and so can't really be compared.
&gt; Now tell me why I'm wrong. We can't, you're right.
&gt; Also, let's take this Rust example[1] : See [the top reply](http://www.reddit.com/r/programming/comments/29fp6w/why_go_is_not_good_will_yager/cikpqzy?context=3) for an example of why explicit `.unwrap`s are good.
I agree -- Lua is otherwise excellent.
Check if you're using https. I thought I had https setup, but it seems not.
If it becomes impossible for a goroutine to exit (i.e., it's blocking on a channel that will never receive/send), then that does not mean the program will become deadlocked. It just means that a goroutine is hung and can never complete. Go's garbage collector will not fix this for you. (More specifically, the Go devs state that a leaking goroutine should be considered a bug.) This unfortunately prevents a "generator pattern" using goroutines and channels unless it's done carefully. Why? Because if you stop consuming your generator, then you end up with a leaking goroutine. You end up having to guarantee that you've consumed the entire generator or have some way to explicitly quit early. This removes *some* of the conveniences of using a generator in the first place. If you're interested in how one might do an arbitrary iterator in Go, then you might take a look at [bufio.Scanner](http://golang.org/pkg/bufio/#example_Scanner_lines) as an idiomatic example.
 // Start with absolute coordintes. Should be // Start with absolute coordinates. 
What tool are you using to write Rust? Any suggestions of text editor / IDE?
I use Vim in the Terminal window, but there is support for many editors, like Emacs, Atom etc. The editor does not matter much, it depends on what you are used to. https://github.com/rust-lang/rust/wiki/Doc-packages,-editors,-and-other-tools However, there is something really important you could do: If you want to write a Rust library and put on Github, I strongly recommend [Rust-Empty](https://github.com/bvssvni/rust-empty). Use symlinks between the projects and `make symlink-build` will generate a script that crawls the directory structure and builds them in the right order. `make cargo-lib` generates a Cargo.toml for your library. `make git-ignore` generates a git filter, etc. Don't use git submodules, it bites you back. I recommend Rust-Empty and symlinks + Cargo for usability.
Snowmew looks really neat as a standalone game engine! I'm going to have to dig in to how their entity component system works. Compared to Piston, snowmew is a lot more opinionated an has a lot more dependencies. Think of Piston as more of a collection of libraries than a solid game engine.
Thanks for writing!
I'll be posting these out to the mailing list weekly, hopefully no later than this time.
Why would it be too late to change it? It seems like a relatively straightforward change. I would prefer to do it now while there is no expectation of backwards compatibility. 
Yay, more of C++'s good ideas being ported over. This is the only other language I've heard of that actually realizes how amazing RAII is.
It varies depending on which style guide you would like to follow. If you are writing academic documents in APA^1 style, for example, there's no "less than ten" rule, but you can't start a sentence with a numeric. See: http://www.apastyle.org/learn/faqs/numbers-as-words.aspx AP^2 style says to spell numbers less than ten, as well as never start a sentence with a number. They allow things like the following "He had three cows and 15 goats". Wikipedia has a pretty readable style guide too: http://en.wikipedia.org/wiki/MOS:NUMBERS#Numbers. In their case they disallow the previous cats/goats thing - if you're comparing two numbers they must be in the same format. Really, it all depends on where you're writing and if there is a style you should be following. Most publications will have a style guide or defer to one of the big ones (AP, APA, MLA, Fowler's, Chicago, Oxford, etc). --- ^1 American Psychological Association, fairly common in humanities research. ^2 Associated Press, as used by the New York Times, for example
I'm a bit confused as to why this is called `conduit-rust`. It seems to be modeled after Haskell's Web Application Interface, which for a long time used the data streaming library `conduit`, but there was no especially strong reason for the tie and the most recent versions of `wai` no longer rely on it. Perhaps `wai-rust` would be a better name?
You should really just join the mailing list and ask! Link in the sidebar :P
I am excited that the creator of CouchDB (Damien Katz, he used Erlang for CouchDB) is considering Rust for his next project.
Oh holy shit, *that* is who that is? 
&gt; This is the only other language I've heard of that actually realizes how amazing RAII is. 1. There's nothing fundamentally amazing about RAII, although it *is* a smart use of of the C++ memory model 2. It makes no sense in GC'd language since it ties resource disposal to deallocation, which is non-deterministic if a language is GC'd It's thus perfectly sensible that, most languages being GC'd, they would use [different building blocks](http://clhs.lisp.se/Body/s_unwind.htm) [to manage](http://www.gnu.org/software/smalltalk/manual-base/gst-base.html#BlockClosure_002dunwind-protection) [resource disposal](https://docs.python.org/2/reference/datamodel.html#context-managers). (Interestingly enough, because CPython is refcounted in the absence of cycles its resources are "RAII'd" if disposal is implemented in `__del__` and not explicitly closing resources used to be ubiquitous, the community moved away from it due to the rise of non-refcounted implementations which would leak these resources until the GC swooped in — which was possibly not ever, which lead to the addition of context managers to the language)
[GetConsoleScreenBufferInfo](http://msdn.microsoft.com/en-us/library/windows/desktop/ms683171%28v=vs.85%29.aspx) is the relevant API call on Windows.
So your theory is that application code benefits more from simple language design, while library code benefits more from powerful abstractions? Should abstraction be detrimental to application code after all?
The example given in the RFC is `fn parse&lt;'a, T: Encodable&lt;Encoder&lt;'a&gt;, IoError&gt;&gt;(value: T)` vs `fn parse['a, T: Encodable[Encoder['a], IoError]](value: T)` For reasons I find hard to explain, I do think the `[]`-based syntaxed feels 'lighter'. Is it just me? See also the [recent discussion](http://www.reddit.com/r/rust/comments/29egfn/a_suggestion_about_simpler_type_syntax_from/) on a simpler type syntax.
&gt; with code that looks almost like Haskell. Well maybe if you squint *really* hard.
It doesn't work for me panic: runtime error: slice bounds out of range 
Ideally, we'd have chevrons ;) `fn parse〈'a, T: Encodable〈Encoder〈'a〉, IoError〉〉(value: T)`
Probably because `[` and `]` extend further above the lowercase letters than `&lt;` and `&gt;` do. They introduce more 'noise' and it feels like they're easier for the eyes to scan and split the text up with.
Careful, you'll put your eye out!
A custom hashmap may make it even faster.
It's not, like, black and white. Some abstraction might even be necessary (and Go interfaces are exactly that.) But when you use a lot of libraries and each of them is highly abstract, app code might become extremely complicated.
Yeh... once you get past the _syntax_ rust does _sort of_ start to look like Haskell 0.o
bikeshed is strong in this one.
This line would become more difficult to read: impl&lt;'a, T&gt; Iterator&lt;&amp;'a mut [T]&gt; for MutChunks&lt;'a, T&gt; http://doc.rust-lang.org/std/slice/struct.MutChunks.html
I am torn between agreement and disagreement, so you are obviously right, there surely is a gray area. In library code, I usually abstract stuff. It's what libraries do. I strive to build abstractions that are powerful, yet simple. On the other hand, application code is a lot like plumbing. I just put stuff together. Mostly trivial stuff. Abstractive power is useless in this area (though callbacks + closures often help in setting up stuff). So perhaps the problem with Rust and Haskell is that the library authors have forgone simplicity in the name of power?
I didn't thoroughly test it. Which data-set were you using? I only checked the 25M case.
I think it's because they're thinner.
Not sure if noise is the best way to put it. `[]` are better word separators, so it's slightly easier to read.
Oh, the playground example doesn't contain the example dataset. PS. [Fixed version](http://play.golang.org/p/UR3U-PFhVa), see [the language shootout how to run this](http://benchmarksgame.alioth.debian.org/u64q/program.php?test=knucleotide&amp;lang=go&amp;id=3#log).
Nice
I think they're noisy because they also mean less-than/greater-than, they're not pure bracket symbols.
No, I'm saying that `[` and `]` are (visually) noisier, in that they look *less* like what's around them.
OK, visually they are easier to distinguish vs &lt;&gt;.