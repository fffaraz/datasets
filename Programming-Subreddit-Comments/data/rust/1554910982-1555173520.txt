It is actually pretty hard to do; there are a couple people working on it right now. You can check out this repo for a somewhat working example: https://github.com/distransient/nphysics-ecs-dumb
&gt;I like to write parsers recursively. Write out a grammar (on paper, or whatever) and then write something that takes the token stream produced by your lexer and returns the parse tree. Name it for the root production in your grammar, and every time you hit a new production in your grammar, you make a function call. You'll likely end up with a function for every production in your grammar, with a few helpers on the side. By operating recursively, you can use the call stack to keep yourself organized, and you'll probably only have to consider the next token in the stream. Nice!
I read a few things discussing OOP in Rust, but I am still a bit confused. The general viewpoint of most comments I've read is "Rust isn't OOP. You can apply some concepts to it but you should learn what is idiomatic to Rust instead of thinking in terms of OOP vs FP vs whatever". My understanding of OOP is that it is simply bundling behavior with state and making that behavior aware of the state through `self` or `this` or something. When I look at Rust code, that is pretty much all I see: a focus on data types and implementing methods on those types that are customized for it. So why are so many Rustaceans saying Rust isn't OOP? It seems to be the epitome of OOP. What am I misunderstanding?
The site is being updated atm. The code that makes the routes is also being fixed.
The difficulties there seem to be involve exposing nphysics data as ECS components. That may be the ideal design, but that difficulty doesn't preclude simply running the physics simulation alongside the ECS simulation as separate environments, which seems the most straightforward way to integrate them. I suppose it depends on how fine-grained your needs are.
Rho sounds interesting! Is the no-pointers thing just to make memory management easier? I'm trying to think of a situation where pass-by-value everything would get in my way. Maybe for graph-search algorithms? Obviously you can work around that sort of thing by using indexes into a list, though. If no-pointers _is_ for memory management (no loops, no RC issues), I'm also wondering if there's a way to get reference behavior from functions. If functions are values, and values follow copy semantics, how does that play with, e.g., mutual recursion? If foo() calls bar() and bar() calls foo(), it seems like there would have to be references in there somewhere.
Ideally the compiler will eventually figure out if there is control flow or not right?
There needs to be integration between those two things, at least using amethyst. It would be nearly impossible to do anything useful otherwise.
"OOP" is a fairly overloaded term these days. Most people think of Java-style OOP where you have multiple layers of classes that inherit data from each other in a hierarchy, and that's what Rust doesn't have.
When you say 500 threads, I’m assuming you’re using green threads in Go which are lighter than system threads used in Rust. So you’re not really comparing the same thing.
So the real answer is that Rust is very OOP but it doesn't support inheritance?
I hate to sound like a fanatic (because believe me I am NOT a fanatic) but there is no program on earth, however hard you try where Go, of all languages, can beat Rust. I would believe you if you made Java beat Rust. But not go.
I actually didn't post the link to back anyone up, one way or the other :) &gt; Also, as your flare says you're on the rust team, just curious if some of you prefer non snake case too or there was a reason it was chosen, or just to stay close to C/C++? I wasn't very involved with Rust back then so I'm not sure. My background is from Haskell and there `camelCase` is used. I think `snake_case` has one big benefit in that it distinguishes from `CamelCase` type names more clearly so you can tell at a glance whether something is a type, method/binding, or constant.
Basically that. There's also a chapter of the rust book dedicated to this question: https://doc.rust-lang.org/book/ch17-00-oop.html
Comment out all the heavy lifting and turn them both into a "hello world" server and them benchmark them. Once that backpressure is removed you'll see that web servers can have very different performance and its often because some are more full featured than others when unconfigured. Things that might be going on that I can think of right now * generating cookies (telnet in and do a "GET / HTTP/1.1\n\n") * setting various http headers [example from helmet](https://github.com/helmetjs/helmet) * silently logging (doing stuff but not outputting it) * a router that is faster because it limits how fancy your routes are. I don't see the results of the benchmark but I'd expect go and rust to be very similar in performance. Don't they both use LLVM? Go has a garbage collector but it might be tuned just right for your scenario. Go's concurrency thingys might be more mature than tokios concurrency thingys. Try each on a single core. Benchmark the factorial stuff outside the web framework? Also, write each one with generic types.
I guess I'll find out when I try it.
Seems like a weird thing to think when there are entire classes of programs that are faster in Go than on the JVM. For example, any command line utility that completes before the JVM warmup time will be faster in Go than Java.
Micro-optimizations are basically optimizations that don't require you to restructure your code. So you can look at parts of your code 'under a microscope' and make it faster in small increments. Macro-optimizations require looking at the bigger picture and recognizing if your program has inefficiencies in its design.
Why? Go has really lightweight threads, so it should handle a program based on lots of short-lived threads better than Rust because Rust doesn't have lightweight threads (though it did before 1.0). And why would you accept Java instead of Go? Java has the same problem as Rust with regard to threading (I'm not aware of lightweight threads in Java, but maybe it has them), and it has a bunch of other challenges as well with it running on a VM. Go runs on directly on the CPU the same as Rust, but it has a GC and runtime reflection like Java, so so it should fit somewhere in the middle in many cases, especially for short-lived programs (Go doesn't have a VM that it needs to warm). I can absolutely see cases where programs can be faster in any one of those languages vs any one of the others. Rust would win where there others are likely to do frequent GC when Rust doesn't have to malloc at all, Go would win when there's a _ton_ of threads kicking around, and Java would win where the JIT can optimize away a lot of the code.
I bet OP could get things to run a lot faster if there were a handful of worker threads computing factorials and handing results back to the I/O threads.
 I read [the actual study](http://www.cs.loyola.edu/~binkley/papers/icpc09-clouds.pdf), which since people are upvoting you also seemed to not read it, and instead read just the discussion pieces. &amp;#x200B; That discussion piece is about this: &gt; A recent trend in style guides for identifiers is to favor camel casing (e.g.,spongeBob) over the use of underscores(e.g.,spongebob). However, natural language research inpsychology suggests that this is the wrong choice. For ex-ample, a study by Epelboim et al. \[6\] considered the ef-fect of the type of space filler on word recognition. They found that replacing spaces with Latin letters, Greek letters,or digits had a negative impact on reading. However, shadedboxes have essentially no effect on reading times or on the recognition of individual words. A shaded box depicts a space in a similar way to an underscore. In informal dis-cussions, psychology researchers assert that camel casing should increase reading difficulty.This suggests that underscores should be preferred over camel casing as an identifier construction style. However,given that camel casing is currently favored in the program-ming community, perhaps something in the software devel-opment process differs from natural language reading. Al-ternatively, perhaps programmers can be trained to perform with either style. To properly understand the issue and an-swer these questions requires empirical study of both pro-grammers and non-programmers. The non-programmers provide a control group for studying training. This paper presents results from such a study, which considers the abil-ity to discern closely-related identifier names. As well as combined from ***the use of using no casing at all and just removing spaces. As per section 6 (which I talk about more below).*** So to summarize, in natural language, it makes more sense to use snake\_case than camel case. However the point of the study was to see if that applied to programming, of which the results show they do not, and you are faster using camel case. Section 5 &gt; &gt; Summary of Results &gt; &gt;Although the conclusions drawn for the hypotheses seem somewhat contradictory, a unifying interpretation does emerge. Considering all four hypotheses together, it be-comes evident that the camel case style leads to better all around performance once a subject is trained on this style.It seems that no training is necessary to accurately recognize an identifier written in the camel case style, but training is required to quickly recognize such an identifier. Therefore,there is empirical evidence that supports the move towards camel casing in terms of accuracy and time. Along with related works agreeing with that conclusion to the paper: Section 6 &gt; &gt; The authors conclude that in un-spaced text, readers are greatly aided by the ability to perform automatic word recognition where familiar, highly practiced words and words predictable through meaning conveyed by context,jump out at the reader. &amp;#x200B; The author of the article confused \`removingspacesfromwords\` as an argument against camel case as users were slower to read it... but that was a pure language statistic and not camel case and used as a demonstration piece. Camel case, according to that study, is better all around.
One weakness that procedural macros still have is that they lack a way to expand macro invocations in their arguments. There's not only [one](https://github.com/rust-lang/rfcs/pull/2320) but [two](https://github.com/rust-lang/rfcs/pull/2628) RFCs to remediate this, the first one of which will hopefully be accepted within the next months (full disclosure: I helped with the first and wrote the second RFC as a proposed interim solution).
Do you even non-transitivity bro? ;)
It's not part of the name. You write `macro_rules! foo { ... }`, not `macro_rules foo! { ... }`.
It is not clear what do you want to test. Do you test web framework performance or factorial calculations?
 Just curious what you mean by &gt; I think snake\_case has one big benefit in that it distinguishes from CamelCase type names more clearly so you can tell at a glance whether something is a type, method/binding, or constant. Snake case will always be the same for variables and methods, won't it? I agree camel case will be the same in this regard (even though most camel case language also use pascal for public exposure), but I may just not be understanding correctly.
Sure. I'm referring to the contrast between \`MyType\` and \`my\_method\`. Compare: \`MyType::myMethod\` to \`MyType::my\_method\`.
Cargo question. Is it possible, to compile 2 versions of the same packace so each different version can be used by a different upstream package from the same workspace? You can do this, if there are two different targets. But I don't know if it can be done for other parameters like 'test' | 'not(test)' or 'feature-a' | 'feature-b', or wether clippy is going on, or not, etc.
Gross InteliJ spam, Bring it on Jetbrain downvote bots. Ya'll need to be paying for ads instead of trashing up reddit
Why do you need BigInt? Why not use primitives?
&gt; We're not responsible for what users post on subreddits .... https://i.imgur.com/R3cpBzn.jpg Dedicated accounts to spamming subreddits.
Anyway, if `r#type` is a good name for your stuff, surely `r_type` isn't much worse.
&gt; I have been able to reduce the time by changing a Bigint cast in the factorial code (already pushed to master) but is still slower than the Go version. Just to be sure: have you profiled the computation part *outside* of Actix? As in, have you written a simple binary that: - reads a bunch of numbers from stdin - starts a timer - computes the factorial for each of them - stops the timer - prints the time spent If you see that the simple binary is slower in Rust than it is in Go, then the problem is with this part of the code. If the simple binary is faster in Rust than it is in Go (or comparable), then the problem is within the web application / glue part.
 &gt; I also haven't seen anyone using OOP with Rust &gt; I imagine if you tried to do that you'd give up on the language In a few days. That's ... probably why you haven't seen it. Everyone who tried gave up :)
If you wanted a turbofish here instead of the other solution, it would be a reverse turbofish: `&lt;Person as Default&gt;::`.
Is there anyway to use IntelliJ debugger without CLion? I would love to use it but not being able to debug is a dealbreaker for me, currently using VSCode on Windows
So it works for everyone else but it's the documentation which is wrong? Why bother with it then? You should get some compiler warnings from your code; did you try reading them? Or, read the documentation for `map`.
I toyed around with some Common Lisp some years ago, but I felt like it wouldn't be useful for anything practical. Too few libraries, hard to interface with other languages, etc. It felt like a language ecosystem that lives in an abstract vacuum, away from the rest of the world. What do you think is the most practical/pragmatic Lisp dialect to focus on? I might want to get back into Lisp, but I want to see if I can actually get something done with it, rather than just mentally masturbating and toying with the concepts.
The point is, that you have to know that it's a macro not a function to use it correctly and that compiler complains that it does not know the function \`warn\` that you think you have imported.
I have a (outdated) \[Rust performance guide\]([http://troubles.md/posts/rust-optimization/](http://troubles.md/posts/rust-optimization/)) on my blog and a (not at all outdated) Rust performance workshop that I gave at 2 Rustfests but that you can easily follow along using \[the workshop materials\]([http://troubles.md/posts/rustfest-2018-workshop/](http://troubles.md/posts/rustfest-2018-workshop/))
[This](https://docs.rs/futures/0.1.26/futures/enum.Async.html#method.map) is what I mean by poorly explained documentation. Doesn't explain what the method does, or is there something I'm missing?
`for_each` (internal iteration) is faster than `for` (external iteration) for iterators "switching" state over time. The typical example is the chain iterator. `for x in one.chain(two) { /* do the thing */ }` is rewritten as: let mut one = /* some iterator */; let mut two = /* some iterator */; let mut use_one = true; loop { let item = if use_one { // Checked every single iteration. if let Some(x) = one.next() { Some(x) } else { use_one = false; two.next() } } else { two.next(); }; if let Some(x) = item { /* do the thing */ } else { break; } } Whereas `one.chain(two).for_each(/* do the thing */)` is rewritten as: let mut one = /* some iterator */; let mut two = /* some iterator */; while let Some(x) = one.next() { /* do the thing */ } while let Some(x) = two.next() { /* do the thing */ } In theory, a smart optimizer should be capable to transform the former into the latter, by realizing that `use_one` only ever goes from `true` to `false`. In practice, LLVM generally fails to do so, and when `/* do the thing */` is trivial, the effect on performance is very noticeable. You can see the performance numbers I got from switching `RangeInclusive` to `try_fold` [in this PR](https://github.com/rust-lang/rust/pull/58122#issuecomment-464152059); on the Pythagorean triples, the patch led to 2x performance improvement.
From what I've read, they use the debugging infrastructure that is only present in CLion at the moment. I don't see them making it available for free, although I would also be interested in a "community edition" debugger.
I think \`mapfold\_reduce\_into\` may be the most functional function name of all time.
You may want to double check that previous discussion. I agree the num crate performs worse than "math/big". But I was able to get better results using the rug crate. I also found that the actix num combination (on my host) performs better than go up to about factorial(700). $ for p in 9596 9597; do wrk http://localhost:$p/factorialIterative/15001; done (this is running go math/big) Running 10s test @ http://localhost:9596/factorialIterative/15001 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 148.39ms 73.76ms 443.88ms 69.13% Req/Sec 34.03 11.65 60.00 59.80% 680 requests in 10.02s, 36.49MB read Requests/sec: 67.85 Transfer/sec: 3.64MB (this is running rust actix rug) Running 10s test @ http://localhost:9597/factorialIterative/15001 2 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 89.09ms 13.86ms 153.32ms 71.47% Req/Sec 55.89 9.20 80.00 76.50% 1118 requests in 10.04s, 59.98MB read Requests/sec: 111.34 Transfer/sec: 5.97MB
That's why I am learning Clojure: all the power of Lisp on top of every Java library ever created.
Idk if I'd call that spam. It's no worse than "This week in Rust".
I just see an account where 100% of posts are in topic for the sub. They're not selling a product, they're announcing a release
Whereas the crate name comes from a good pun from a friend and me being jealous of the cute names in [Functional Programming with Bananas, Lenses,􏰀 Envelopes and Barbed Wire](https://maartenfokkinga.github.io/utwente/mmf91m.pdf).
I love the plugin, and how much it matured the last months. One thing though. Is it just me, or is there a problem debugging unit tests? Every time I set a break point inside a test it never stops there, but just keeps executing, like here: [https://i.imgur.com/cJqpqYh.png](https://i.imgur.com/cJqpqYh.png)
I would like to compute a really big factorial (5000 in my test). The result of it does not fit in any primitive as far as I know. Am I wrong? At least I needed a bigInt in Go and Java to handle the result of factorial of 5000.
I disagree. This is a rust subreddit. Not a jetbrains subreddit. Reddit offers ads that jetbrains could purchase.
I agree, particularly now we have stuff like `use serde::Serialize` importing both the derive macro and the trait
I would like to test web performance and compute capability and also amount of resources consumed comparing the same code made with Java, NodeJS, Go and Rust. Yes, I know there are some performance benchmarks all around the net but I would like to run my own tests on my server and meanwhile learn the languages. :)
Hi Thanks for your help. I will try to test the factorial outside the server. Regarding generic types, as far as I know they could not hold the result of factorial of 5000. At least it was impossible in Go and Java...
That's a great explanation. Thank you. Could this be a clippy lint?
The HashMap is mutable. Mutating a HashMap would likely change its hash, so it shouldn't be used as a key anyway. What good would implementing Hash for HashMap bring, then?
Ooops, lemme edit my code block.
It could be that you aren't specifying trait bounds on \`K\`. \`where K: std::cmp::Eq + std::hash::Hash\`
I think there are also implications for borrowing, like if you need to move out of a value and assign it something new. You can't move out of captures in `for_each`, as that would be `FnOnce`. Stuff relying on NLL might be affected by the closure boundary too.
Yeah, you sound like a wife when she said: I do not want to argue but..." and then start a fight &lt;grin&gt; I am wondering why do you think that Go will not defeat Rust. I could comment my short experience as newbie after spend some time with Go and less time with Go. In my opinion, Go is efficient -perhaps not as Rust far better than Java- and the code looks more clear and is easy to be read and understood. In the real corporate world this is so important, sometimes it weights a lot when you are involved in big projects with contracted developers from several IT companies with a heterogenous skills and levels. The way packages are handled is nice for me too as my hard disk is not full of repeated package code on each project. Also, the cross compiling was far, very far more simple in Go than in Rust where I am still trying to compile for windows in my mac. It looks also far more mature. Rust code looks for me confusing. it remember me the bad old times when I needed to migrate Perl code to PHP and found code like x(*)!-&gt;/zz/ that was barely understood just for the geek that did it. Some times Rust looks like this, and I hate it. However, I know I am learning and that I hated Go too during the first week I have been trying to develop my server :) So, I am not of those that easily give up and will keep trying to love Rust as it were Jennifer Connelly :)
Yeah, sorry. I edited my code block. I was trying to generalize this thing from my actual code and missed a few things.
I don't know why you are getting that specific error, and I can't reproduce it in the playground. However, this code fails because the compiler cannot ensure that \`K\`, the key type, can be \`Hash\`ed, which makes using it as the key type for a \`HashMap\` somewhat difficult... To fix this, you need to add a trait bound to the \`impl\` block \`K: Eq + Hash\`. Playground link: [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9844cdde0e254d2cc0ca29a34380da09](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9844cdde0e254d2cc0ca29a34380da09)
You can use VSCode or Intellij to give you errors quickly.
Hi Well, this is the first time I heard about "green threads" and I have no idea what are you talking about. :) What are the green threads?
My intention is to test really big factorials (factorial of 5000 in my test) but I will give a try to rug crate. Thank you!
Your latest code compiles for me.
I disagree, for several reasons: 1) We don't treat structs different than functions when we import them. 2) Proc macros aren't called with a \`!\` 3) We don't specify the number of arguments or any other calling information for other things. The biggest kicker though is that it's \*really\* convenient to import a macro, a type and function all at the same time.
I have noticed the same thing, which made it very hard when I was trying to use unit tests with a project that involved writing custom data structures. Also, either my code was rubbish or the values I was getting from the debugger inside the tests were completely weird. Outside unit tests it seems fine. Even though the plugin is awesome, don't get me wrong, I now use VSCode for writing my Rust code. If this gets fixed I would happily come back to using it.
Ugh. This is going to be nearly impossible to get help considering this block is so abstracted from what I'm actually trying to do. Let me put up the whole thing in a new (and separate) block.
Then we need better compiler messages. The compiler currently is very helpful when you try to invoke a struct like a function - it could easily do the same for macros. ``` Compiling playground v0.0.1 (/playground) error[E0423]: expected function, found struct `foo` --&gt; src/main.rs:9:5 | 9 | foo(hello); | ^^^ did you mean `foo { /* fields */ }`? ```
Cool! This and moite_moite are both things I looked for at some point. As for names, perhaps `tee_fold` or `tea_fold` as a compromise between a functional and oral consumable thing.
&gt;One thing though. Is it just me, or is there a problem debugging unit tests? Hmm, seems strange. It works for me (macos, lldb): [https://imgur.com/a/oboHt0Y](https://imgur.com/a/oboHt0Y) What OS and debugger are you using?
Good observation. Bug filed: https://github.com/portier/portier-broker/issues/183
I think the 500 threads number is from the ab load testing tool and not the servers
I think you're getting that error from this part: #[derive(Debug, Hash)] pub struct LeafNode&lt;K, V&gt; where K: hash::Hash + Eq { vals: HashMap&lt;K, V&gt; } `HashMap` never implements `Hash`, so neither can `LeafNode` derive it. FWIW, this PR tried to do it: https://github.com/rust-lang/rust/pull/48366
`LeafNode` doesn't derive based on the type at runtime?
&gt;A procedural macro can just dump whatever code it wants calling compiler plugins "_procedural macros_" was such a mistake.
Derivation is at compile time, but that's not the point. It doesn't matter what `K` and `V` are, `HashMap` never implements `Hash`. A derived `impl Hash for LeafNode` would just hash each of its fields, but it can't do that without `impl Hash for HashMap`.
Nice sockpuppet. Didn't you state earlier that you mostly use emacs and not VSCode anyway ? &gt; I use emacs. But VSCode is free that’s my favorite part about it.
This might be an issue with your `TERM` setup. You'll probably need to install the Alacritty terminfo on your remote or use `TERM=xterm-256color ssh` as an alias.
A future won't do anything until it is given to a runtime to execute. Once you have constructed the future, you need to run it. You can do that with eg [tokio::run](https://docs.rs/tokio/0.1.18/tokio/fn.run.html) or [tokio::runtime::current_thread::block_on_all()](https://docs.rs/tokio/0.1.18/tokio/runtime/current_thread/fn.block_on_all.html) See a working example with reqwest here: [Playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2e614396b1960df94cec84fe87ed2698)
Got it.
&gt; Change the success value of this Async with the closure provided That's rather concise, but perfectly understandable. Did you not click the `[+]`?
If you're looking for resources on using macro_rules, [this book](https://danielkeep.github.io/tlborm/book/) is a great resource. I'm not too familiar with the implementation, but the rustc book might be a good guide? [Here's a semi-relevant chapter](https://rust-lang.github.io/rustc-guide/macro-expansion.html).
&gt; At least it was impossible in Go [Yea, it was a bad joke](https://www.google.com/search?q=golang+generics+sucks). Benchmarking frameworks is really fun, I do it all the time, but I always fall back to this advice here [Performance at Rest](https://hueniverse.com/performance-at-rest-75bb8fff143)
Sure! People here seem to mindly misunderstand the scope upon I'm trying to tell you to learn you those concepts. A couple 10-20 line examples of malloc-pointers and free are more than enough to convey the meaning of what I'm trying to say. Because then in Rust someone tells you 'the language does this FOR you' then you understand the added value to the equation.
Fair enough, that is actually a really good point.
I'm not sure if it's clear, but in this case the reason HashMap doesn't implement Hash is because the ordering of elements is unspecified, and can be different in different otherwise equal HashMaps. If you need the Hast, might I suggest using an inner [BTreeMap](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) as your Node's field type instead? Since it orders elements it can be hashed reliably.
This sub usually prefers a less snarky and more helpful attitude.
I don't believe so. https://github.com/jwilm/alacritty/issues/1663
This was not intended as snark. I've been told that this sub also "usually prefers" an assumption of good faith, but I notice that this is rarely afforded to common rabble such as myself, only to well known folks and newcomers. Feel free to apologize anyways though.
This sums up my interactions with folks regarding Rust. It takes passion for technical elegance to take compiler seriously. It is also an obstacle to shipping code fast (as opposed to shipping fast code). The very same trait reinforces the love for Rust. Those who let "the Wookie win" enjoy the benefits of fast, correct and safe code, but it takes a bit more time. Gratification is not instant.
Is the Intellij Rust plugin terribly slow for other people? I really love the work their doing and don't want to be a downer, but sometimes it takes more time for Intellij to parse and highlight a new line of code than it takes to run a new build.
I'm starting to understand futures now, thank you. I am getting an error with this: ``` // get body of request let fut = req.into_body().concat2().and_then(|body| { let s = body.into_bytes(); future::ok::&lt;String, _&gt;(String::from_utf8_lossy(&amp;s).to_string()) }); let body = tokio::runtime::current_thread::block_on_all(fut).unwrap(); thread 'tokio-runtime-worker-1' panicked at 'Multiple executors at once: EnterError { reason: "attempted to run an executor while another executor is already running" }', src/libcore/result.rs:997:5 ``` I am guessing hyper is using a tokio executor? Do you know how I would be able to execute this future while the server is running?
That's not relevant in Rust (unlike python), since it can't easily be mutated when used as a key, due to ownership. Lots of (every) type that implement `Hash` can be mutated, e.g. `i32` has `+=`, and `String` has `push`.
This week I released [dataclerk](https://github.com/timClicks/dataclerk), a 'small data' tool for distributed logging. Built with actix-web and sqlite, its primary interface is curl and will store any data POSTed to it in a database. Have received some good feedback on [bin2src](https://github.com/timClicks/bin2src/), but I'm not sure about the best way to promote it. I'm tidying up several places of [Rust in Action](https://www.manning.com/books/rust-in-action?a_aid=rust&amp;a_bid=0367c58f&amp;chan=reddit) and a new MEAP update should be available next week :) Lastly, a small shout out to the [auto-build system](https://build.snapcraft.io/) provided by Canonical for snaps. Both of those tools are available across Linux distros across x86 &amp; arm64 without me needing to do anything.
&gt; But I was trying to explain how Option 2 is a more restrictive definition Yes/No. Pass-by-Reference vs Pass-by-Value have a lot of trade offs. Neither is objectively superior. * Pass-by-Value is pretty easy to reason about for newer rust developers who haven't grokked the borrow checker. * Pass-by-Reference avoids unnecessary `drop`, `clone` and extra stack manipulation at runtime. Overall my _opinion_ is Pass-by-Reference is a little superior when defining inherited trait method, as it means the implementer is free to not worry about extra heap modification overhead, but if your goal is just passing primitives around, then Pass-by-Value is fine.
Ah yeah tokio starts the default runtime so current_thread apparently won't work. You'll have to use `tokio::run()` instead.
[Here it is](https://www.meetup.com/fr-FR/Rust-Paris/events/260443108/?rv=ea1_v2&amp;_xtd=gatlbWFpbF9jbGlja9oAJGZkM2MyYWQ2LTNlNzItNDJjZi1hMWZhLWRmMTRhNWNkNjU1Yw) thanks !
I agree with you points regarding pass-by-value and pass-by-reference. But I would still argue that **Option 2** is a more restrictive trait definition. **Option 2** requires that the arguments for `dot()` are passed-by-reference. **Option 1** allows pass-by-value, which the user can then implement for references. There is strictly more potential through **Option 1** which can and cannot be a good thing depending on the context. Moreover, this post is **not** about arguing the tradeoffs between pass-by-value and pass-by-reference. Both of the implementations of **Option 1** and **Option 2** are pass-by-reference. This post is about allowing the user to decide when implementing the trait, vs. forcing the decision on them (both of which I think are situationally valid things to do).
Is this just intelliJ? I've found that it's quite bad up until a certain spec, and then it's a pleasure to use, but the plugin hasn't moved in speed in my time using it.
Native OS threads comes with their own stack, which has the default stack size of your system (unless you explicitly change that), and switching from one thread to another requires a context switch (going back and forth with the kernel, which is slow). &amp;#x200B; Green threads are userland threads scheduled by your language runtime (no context-switch) and in Go, they use growable stack, which means it starts with only a tiny bit of stack memory and grows up if you need more of it (IIRC it starts at 2kB, compared to a default stack size of 8MB for OS threads on my computer).
It's Rust being slow. VSCode is the same - sometimes everything just freezes for a minute.
I've been thinking the same. I'm not even that concerned about `unsafe`. I just didn't have time/motivation.
From what I've read, I can't return anything with `tokio::run`, which causes problems as I need to return a response. ``` // get body of request let fut = req.into_body().concat2().into_future().and_then(|body| { let bytes = body.into_bytes(); let body = String::from_utf8_lossy(&amp;bytes).to_string(); future::ok::&lt;String, hyper::error::Error&gt;(body) }); ``` Gives both these compiler errors: ``` 142 | let body = tokio::run(fut); | ^^^^^^^^^^ expected struct `std::string::String`, found () | 142 | let body = tokio::run(fut); | ^^^^^^^^^^ expected struct `hyper::error::Error`, found () | ```
TL;DR: is WASI ready to test it?
Generics with only lifetime parameters are certainly doable (AFAIK Rust team puts lot of work into compiler not changing behavior based on lifetimes). And I think you can also do some other things. For instance, You could translate even something complex like `fn receive() -&gt; Box&lt;Future&lt;Item=Vec&lt;u8&gt;, Error=io::Error&gt;&gt;` - it instantiates generics, but doesn't define them. I imagine things like `Vec&lt;T&gt;` or `Box&lt;T&gt;` being allowed as well as long as `T` isn't used in the program itself just being returned and then passed indirectly as a parameter to plugin.
You could use the [Any trait](https://doc.rust-lang.org/std/any/trait.Any.html) or just use a crate like [anymap](https://docs.rs/anymap/0.12.1/anymap/struct.Map.html) or [typemap](https://docs.rs/typemap/0.3.3/typemap/struct.TypeMap.html).
How can I extract the response body as a string when using \`reqwest::async\`? I thought I could do it using \`response.body().concat2()\`, but the borrow checker complains, "error\[E0507\]: cannot move out of borrowed content". Here is my minimal example ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=505a328720db44d74afb67a0b7b99ede)): ```rust use futures::{Future, Stream}; use reqwest::r#async as reqwest_async; use std::str; fn main() { let client = reqwest_async::ClientBuilder::new().build().unwrap(); tokio::run( client .get("http://canhasip.com/") .send() .and_then(|response| response.body().concat2()) .and_then(|chunk| { let ip_str = str::from_utf8(&amp;chunk).expect("error converting body to string"); println!("My ip: {}", ip_str); Ok(()) }) .map_err(|e| println!("request error: {:#?}", e)), ); } ```
I did some quick testing and on my machine factorial using "num-bigint" is slower than go "math/big" but using "rug" is faster than go. Since you are benchmarking big integer libraries you should probably try all that are available in rust.
You can't do what you're trying to do with generics. Here's a modified version of your code that demonstrates what I mean: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=af7c16d0ce985699ef81cb8df75efc6b The issue is that your `StorageInner` type (and by extension the `Storage` type that contains it) is generic over `C` (or `T` or whatever, it doesn't really matter what name you give to the generic parameter), and this allows you to have multiple instantiations such as `Storage&lt;Position&gt;` and `Storage&lt;Velocity&gt;`, but you can't have a `Storage` that contains both a `Position` *and* a `Velocity`. Both types might have a known size at compile-time, but there's nothing that ensures that all of those types have the *same* size. Therefore instances of the different types cannot coexist in the same collection. However, there are other ways to accomplish what you're after. If you want your `Storage` to accept a known, finite number of types, you could make an `enum` of all those types and make your `StorageInner` type contain a `Vec&lt;YourEnum&gt;`. This will ensure that that each element of the `Vec` is large enough to contain any of your possible types, but it can also be cumbersome to work with since now you have to `match` on enum variants whenever you do anything with the stored data. And you'd have to modify your code any time you decide to add a new kind of data to store. The other option would be to forego generics and use dynamic dispatch instead. From what I understand about ECS systems, that's usually the route they take anyway so that's probably the one that you should take too. In order to perform dynamic dispatch in Rust, you need to use what's called a trait object. For example, you would make a common trait (let's call it `YourTrait`) and then implement it for all of the types that you want to store in your `Storage`. Then instead of your `StorageInner` containing a `Vec&lt;T&gt;`, it would contain a `Vec&lt;Box&lt;dyn YourTrait&gt;&gt;`. If you want to read more about the specifics of trait objects and how to work with them, check out this chapter in the book: https://doc.rust-lang.org/book/ch17-02-trait-objects.html
Nothing in intellij’s infrastructure is written in Rust.
Sorry i didn't see that you were implementing for `&amp;Point` vs `Point`. I really never run to much more often then not rust will result `&amp;T` into `T` for the purposes of method invocation. So implementing something on `&amp;T` (or `&amp;&amp;T` is really only useful if you are receiving the value (for example `PartialEq&lt;&amp;&amp;[u8]&gt;` along with `PartialEq&lt;&amp;[u8]&gt;` and avoid the `&amp;*` dance). But the only time I see `impl MyTrait for &amp;T` is when `T: !Sized` in order to ensure the user never can dereference `T`
There’s nothing built in, but there are many crates that let you do this easily.
Oh, Windows. Yeah that changes everything. Windows still needs a bit of work due to not being Unix unfortunately.
That's a really interesting scenario regarding `T: !Sized`. I had not thought of that. Thanks.
Yes, this is a great point. Coming from Perl I'm spoiled by the amazing \[Test2-Suite\]([https://metacpan.org/release/Test2-Suite](https://metacpan.org/release/Test2-Suite)) distribution, which has an incredibly powerful system like this that gives amazing feedback on failures, including the data path to the failure point with line numbers, etc. It's really nice. &amp;#x200B; I started working on something \[similar for Golang\]([https://github.com/houseabsolute/detest](https://github.com/houseabsolute/detest)) and I'd love to see something like this in Rust too.
I think they're referring to rustc/rust tools like `cargo check` that may get called out to.
Thanks! I'll search for one right now!
Thank you very much. I've read about `Vec&lt;Box&lt;Trait&gt;&gt;`, but was under the impression that `Box`es are heap allocations. So I would have a vector of pointers that point to random allocation on the heap. This kinda negates all the upsides a vector has.
It's probably not the plugin but rather the IDE, JetBrain's products are very resource hungry, they make my laptop crawl but absolutely shine on my desktop.
Does java have good features for concurrency? You have to synchronize methods, there's unchecked mutation everywhere. And in Go I've heard that while channels are used for smaller projects, anything large ends up using pointers and mutexes and running into all the problems of unchecked use of those primitives. This could all be false, of course, I've not written a significant application in Go.
There's nothing unreliable about `Hash for HashMap&lt;K, V&gt;` -- it's just that you have to use a pointed commutative semigroup, e.g. `(u64, wrapping_add, 0)`, to have a `Hash` implementation that actually satisfies the invariants of the `Trait`. This happens to degrade the quality of the hash function somewhat and makes it less resistant to DDoS. Java's `HashMap` implementation provides no such resistance and so it has that implementation. We could also do it, but it's a trade-off to make.
Here's a good guide to it: https://michael-f-bryan.github.io/rust-ffi-guide/dynamic_loading.html
This looks really cool! I am definitely going to mess with this later. In your example, wouldn't it make more sense to rename the following: ``` expr ==&gt; term product ==&gt; factor ``` I feel like those would fit in the the usual naming conventions for this type of CFG.
I think you're missing my point. What are you trying to test in this benchmark? How fast a factorial implementation is in each language? How fast each framework can open and then drop a connection? You should think about what you're trying to measure then come up with a test that isolates that one thing. As it is, you're testing some 3rd party implementation of bigint and other things that we don't know because we can't see what your tests are.
Sure, no worries. I don't think you need the `Number` or `Echo` structs you're creating. You can use `i32` and `String`.
I thought we weren't bubbling up absolute positioned fragments and were instead keeping them where they were in the DOM tree, to make the hypothetical box easier to calculate. Why the change?
We put them where they were in the DOM tree when we build the boxes, and then we make them go up the tree during layout, computing the static position as we go. That we put them where they were in the DOM tree in the first phase is what makes it easier to compute the static position as we move them during the next phase.
You need to use `.into_body()` instead of `.body()` as that returns a reference which isn't allowed to escape the closure because it points into `response`.
So I am quite a new rustacean coming from working a lot in Elm and Ruby and I find it hard to justify the use of complex macros. In Elm you have to deal with an interesting amount of what you would consider boilerplate in Rust. You have to write JSON decoders and encoders explicitly, define your entire application data flow manually, code type conversion functions over and over, etc. This is accentuated by the fact that Elm has no traits or "typeclasses". Just to give you some numbers, in a 50k LoC app I worked on, there was a file of almost 2k LoC that was mostly wiring code. The thing is, this file was very easy to edit and maintain. Besides being really long, it was pretty much [the same code over and over](https://i.imgur.com/tPyO7kT.png) and if I needed to have a _different_ kind of wiring for some piece of code, I could just add it in. On the other hand, in Ruby I have been bitten many times by DSLs that try to reduce boilerplate and make things more _convenient_. Rails and Active Record being clear examples of this. Code becomes less explicit, magic sets in, and simplicity jumps out of the window. When you need to do things _differently_ then all bets are off because you really have no clue how any of your code _really_ works. That is when you start learning about the library internals, and if that happens... its API has failed. _Convenience_ at the expense of _simplicity_.
Prior art on Ada-inspired numeric ranges here: https://crates.io/crates/rangetype
What's happening is that you are trying to return something of the lifetime of \`&amp;mut self\` by calling \`as\_os\_str\`,which is necessarily smaller than the \`'a\` lifetime. What I would do to is to avoid borrowing from self by doing this: use std::{ borrow::Cow, path::PathBuf, ffi::{OsStr,OsString}, }; struct WrappedIterator&lt;'a&gt; { inner: ::std::path::Iter&lt;'a&gt;, first: Option&lt;OsString&gt;, } impl&lt;'a&gt; WrappedIterator&lt;'a&gt;{ fn new(path: &amp;PathBuf) -&gt; WrappedIterator { WrappedIterator{ inner: path.iter(), first: Some(OsString::from("/")), } } } impl&lt;'a&gt; Iterator for WrappedIterator&lt;'a&gt; { type Item = Cow&lt;'a,OsStr&gt;; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { match self.first.take() { Some(first)=&gt;Some(Cow::Owned(first)), None=&gt;self.inner.next().map(Cow::Borrowed), } } }
I suppose that the sizes would technically work out with the kind of layout you're describing with your nested `Vec`s thing, but I suspect you'd run into problems once you try to actually use it. Given `mut v: Vec&lt;Vec&lt;ManyTypes&gt;&gt;`, what happens when you do `let t = v[0].pop();`? `t` needs to be a specific size on the stack, but when indexing like this you wouldn't know what you're getting until runtime!
AFAIK default settings turn off running `rustfmt` on save as well as using `cargo check` as the linter. Rather, it uses a custom built linter/parser that's implemented in Kotlin.
I don't think this is a trait-specific issue. It might be simpler to discuss the implications of requiring `T` vs `&amp;mut T` vs `&amp;T` separately, rather than bundling that discussion in with an introduction to traits. Ownership/borrowing and traits/generics can both be pretty confusing in their own right. I think its better to establish a working mental model of each individually first. Confusion is a product type.
Yeah, I imagine a fair few people may have enabled \`cargo check\` and/or clippy, and are now running into performance problems.
Is this a comment based on the result presented here, or your own observations? The results referred to in this post talk about people who already using rust, how many of them are enjoying using it and intend to keep using it. That seems quite different to the "grass is greener". There was also the "most wanted" statistic in the survey which perhaps speaks more to your comment?
&gt; It's a really fantastic system that I wish got more attention. It has special support for certain providers and the first specification I sought out has been TODO for a year. To me that's discouraging.
Can you share more of your code? A `Request` doesn't even necessarily have to have a `Future` body depending on how you got it. And you should already have an executor of some kind by the time you get a `Request` with `Future` body.
On old reddit and many mobile apps, please remember that three backticks do not denote code. You *have* to do it via indenting. I only see the inner parts as code, not the outer parts. I'm hoping my mobile app (Relay for Reddit) will change its markdown parser, but I don't old Reddit will. And a lot of people still use old Reddit, including me. Thanks!
Oh, that makes sense, I think. So they're in DOM position in the pre-layout tree and CB position in the post-layout tree.
Well, I suppose it’s possible with crates but what’s the point? Having it return a string then parsing it allows you to do more sanitization to it before hand as well as a magnitude of other string operations available to you
This looks really slick. (Your README has a small typo in the expression for subtraction.)
I agree with you that it would be nice to separate these out into different topics. The reality is that you have to go over defining a trait, and you have to subscribe to one or the other, so I decided to just discuss the differences up front.
It's an OAuth Provider that authenticates users over email. I don't know what there is to spec.
Thank you very much for this information. I am brand new to reddit, and I had no idea that this was an issue. &amp;#x200B; I will update the post to use indentation.
I was taking a peek at `tokio-fs` and wrote a toy program that simply reads a file and outputs the size, the same example on the tokio website. I ran it under `strace` on linux to get a curiosity-peek into the internals. To my surprise, there were no async system calls like `io_submit(2)` at all. Upon looking at the [source](https://github.com/tokio-rs/tokio/blob/master/tokio-fs/src/file/mod.rs) it seems like it's just a thin wrapper around the blocking std impls. Two questions: 1. Why does it do this instead of using proper OS-level async api's? 2. In the linked code, where are `would_block` and `blocking_io` defined, and what do they do? Thanks!
Oh! Cool, thank makes sense.
std
I really like the text_io crate for this. Saves on a lot of the boilerplate. https://crates.io/crates/text_io
Thanks! I've noticed in the past few months on programming subreddits that people are making this exact same mistake. People used to do it in the past, too, but then they could see that there was a problem. It's mostly because Reddit originally was made with a dumb markdown renderer, since most stuff uses the triple backticks, but Reddit didn't. Then, Reddit caught up to speed with the redesign, but they didn't backport the fix. They really don't want people using the old design, since they can't do tracking and ads nearly as well on it, in addition to how it's not "user friendly" enough (that is, facebook-like with dumb design decisions included). Many people *really* hate the redesign with a passion, me included. Typically, these same sort of people also use unofficial Reddit apps, and tend to be Reddit powerusers (or at least, better at using the internet than the average grandma). The old version, plus RES (Reddit Enhancement Suite, a great browser plugin), is tons better than the new version, and I recommend you try it out. It looks better (eg. no massive amounts of free space) and is much *much* faster. It does have an "old-timey" feel to it, mostly in that buttons look like links and there isn't massive amounts of empty space. At the very least, for the mobile app, don't use the official one. It's also a pain in the ass to use. (I don't know why Reddit keeps shooting themself in the foot; it's possible to intrusively munch on user data with a nice interface.) I recommend Apollo if you're on iOS or Relay if you're on Android (though a lot of people like Slide, and other people like Reddit is Fun for a desktop Old Reddit experience).
Are you asking for an equivalent to `scanf` or C++'s `cin &gt;&gt; variable`? The crate [`read_input`](https://crates.io/crates/read_input) looks like it's what you want. The simplest example is just `let user_input: u32 = input().get();`.
&gt; Why does it do this instead of using proper OS-level async api's (such as windows iocp's, linux io_submit)? "Nonblocking" filesystem APIs tend have quite a few caveats and can secretly fall back to blocking the thread anyway: https://lwn.net/Articles/724198/ https://support.microsoft.com/en-us/help/156932/asynchronous-disk-i-o-appears-as-synchronous-on-windows tokio-fs is also fairly new, so if there are OS APIs that are actually reliable, they may just not be plumbed through yet. &gt; In the linked code, where are would_block and blocking_io defined, and what do they do? https://github.com/tokio-rs/tokio/blob/e28856cffe00aa3f0c30292a91e36adab422668c/tokio-fs/src/lib.rs#L80 The documentation for tokio_threadpool::blocking talks about what it does: https://docs.rs/tokio-threadpool/0.1.13/tokio_threadpool/fn.blocking.html
Go is probably the most readable compiled language on earth. There is no scenario under which pure rust code will lose to pure go code :)
Yes, that would make sense.
&gt; It's an OAuth Provider that authenticates users via a shared secret sent via email. I'm not surprised there is no spec. You're not surprised at the lack of specs and I'm not surprised at the project's momentum. As far as I can tell it's no better for hosting provider deployments than Persona. Oh well, maybe next time.
Most of the time i know what all my impl's are and how i want to use them so i avoid having to use `impl Trait for &amp;T`, but there are a few scenario's where it is ok. But i think /u/valarauca13 demonstrated a good reason to avoid using option 2. &gt; Sorry i didn't see that you were implementing for &amp;Point vs Point.
Are are doing the same with Kotlin/Native, so I don't imagine they will be willing to offer it for free.
Intellij is terribly slow for everything, unless one either has a beefy machine with SSD or starts disabling plugins left and right. It made me love Eclipse again.
Yes.
It is Persona.
I wasn't referring to the statistics but from personal experience. I know many people who respect Rust but almost no one who actually uses it.
Coming from Lisp I kinda prefer to keep macro usage to a minimum at most times, they can make code incredibly hard to understand, because it's basically a new language, unless the macro is small and self-contained.
What a strange way you have of advocating for something you want to see succeed. Please reread what I wrote and then consult with other sources to fill yourself in on the problems hosting providers had with Persona.
Thanks
c++ includes all the underpaid game devs, that could factor in a lot
The question is "Why doesn't `for x in iter` also cald the iterator `try_fold` method?".
Hey! I'm the author of that library. Thanks for the feedback so far, I'll definitely get those things sorted out. And feel free to ask questions and I'll do my best to answer :)
&gt; It is not enough? You keep assuming that just mentioning things is enough. It is not. You are asking people to invest their time into helping you. Spare them the time of trying to write those commands yourself. For all we know you might just have a typo in one of those commands, which could be a trivial things to fix, yet by not providing them you could be wasting everybody's time.
Hi Yep, you are right. At the moment I have answered you I thought (and have been sure) that I have shared the urls to the code. I have no idea of what happened but the urls were not in the post. Your message is hard as alcoholic stepfather's punch &lt;grin&gt; but fair as I have been silly forgetting to share the code in my post. No complains from my side to you and appreciate your intention to help me. (I am honest, no irony on this). Regards J
Would it be helpful to stabilize the annotations while not guaranteeing that those annotations will affect performance in any way? Then maybe provide some other options to tune them.
there's a difference between keeping usage to the useful minimum, and avoiding them entirely, which is what a lot of Rust developers are doing. I'm more on the other end, having built a whole parsing DSL in macros, but that's not a common case :)
Hi &amp;#x200B; I have been trying to use the primitives instead of the struct with the deserialise but could not find the way to get the values. I mean, if I do: &amp;#x200B; fn factorial_iter_handler(number: Path&lt;i32&gt;) -&gt; Result&lt;String&gt; { let n = number.number; Ok(format!("{}", factorial_iterative(n))) } &amp;#x200B; I could not find a way to get the number value as it is returning Path instead of i32. I saw some sample code using this: let n = number.0; But did not work. Also, tried to deref like this: &amp;#x200B; let n = number.deref(); but failed also. &amp;#x200B; Any clue on how to do that? &amp;#x200B; Regards J
Could you please open an issue on [our tracker](https://github.com/intellij-rust/intellij-rust/issues)? It's hard to guess the reason without any information
Thanks for asking, this is a great question! I personally think that exclusively copy semantics (or pass-by-value) in higher-level langauges has incredible potential. There is no shared mutable state, reducing the potential side effects to just the context/module's global scope and functions passed in from Rust. I will admit that I also chose the system because it is easier than managing references and implementing more advanced GC and things. I thought of the concept and I figured I'd give it a try; I have no clue what it will be like, but I figure it will be similar to patterns found in functional programming. One thing that I have predicted as a problem is storing and passing large compound values. This can get expensive if done naively and makes it quite challenging to develop efficient low-level languages around this concept. In my implementation, such values are just stored under `Rc` wrappers whose contained values are cloned when mutable access is required by one of the references. That reference's internal pointer will then be updated to point to the new value instead ("clone-on-write", see docs for `Rc::make_mut`). If the callee doesn't need to mutate the passed value, this means we only have to copy a pointer value and increment a refcount. Reference cycles are impossible in such designs because of the complete lack of shared mutability. You'd first have to clone the `Rc` before attempting to place it in itself. Once that happens, it is no longer unique, and mutable access will be provided to a clone of the value instead. That's where your question comes in, and it's important to point out. How would something like mutual recursion (or even unoptimized simple recursion) work? Remember that I said there is still some shared state, in particular, the global scope. Also know that functions are first-class values, and When writing a function call, you are applying the "call" operator to a value provided by an expression, in this case, an identifier. Identifiers are shallow references that get resolved at runtime, and they act as one kind of "terminal" for expressions, with the other being literals. They are never precomputed; rather, they will fetch their value based on whether the value was found in local or global scope. So in the example you give, neither function will know that the other exists until they figure it out at runtime.
/r/playrust
Omg lol I’m such an idiot
From experience: Help -&gt; Edit custom VM options -&gt; Yes to creating the file. Then write something bigger into the -Xmx line. The default is 750 (megabyte maximum RAM usage) and IntelliJ has to work with that. In really extreme cases the indexing thread will OOM and then it will ask you for more, but most of the time the indexing is just slower than it has to be.
Ah, right. Thanks for the clarification.
you could add: &amp;#x200B; Cargo.lock &amp;#x200B; to your \`\`\`.gitignore\`\`\`
Great tool! I don't know if that would be compatible with chit's philosophy, but I wish it provided a "similar crates" category (maybe in verbose mode). I have no idea whether this information is easy to fetch, but that would surely be cool to have. At least to me
Work is being done to support webgl/stdweb [https://github.com/gfx-rs/gfx/issues/1900](https://github.com/gfx-rs/gfx/issues/1900)
I guess you are right, but right now I'm not at a level where I find this necessary. I'm sure I will need to do things like this in the future but right now I dont! Thank you for mentioning it though because I hadn't thought of the possibilities!
&gt; This means that in contrast to C++ templates, no recursion is necessary to achieve this [...] No recursion is necessary in C++. template &lt;typename... Ts&gt; auto make_vector(Ts&amp;&amp;... xs) { std::vector&lt;std::common_type_t&lt;Ts...&gt;&gt; res; res.reserve(sizeof...(xs)); (res.emplace_back(std::forward&lt;Ts&gt;(xs), ...); return res; } Also, are Rust macros "namespaced"? In C++, templates can obviously be part of namespaces. Can you say something like `namespace0::vec!` and `foo::vec!` in Rust so that two `vec!` macros do not collide?
Just checked this crate and it was really pretty much exactly what I wanted! Rust really seems amazing! Thank you for bringing it up it really helped!
This seems to be pretty much what I wanted! I guess I was asking for any way that didn't require getting my input in a different type than I wanted, not a specific function from either C or C++. This seems to be just what I was looking though! Thank you so much!!
Why? You generally should provide the Cargo.lock with binaries.
Great work!
Because Windows is weird and linking on Windows is double weird. More context and ongoing progress is [here](https://github.com/rust-lang/rust/issues/58713).
There is a lot of work being put into WGPU, which is like new-gen WebGL. Its built on gfx-hal and lets you write your code once and target wgpu, directx, vulkan and metal.
Man, that windows code, [unwrap, unwrap...](https://i.imgur.com/YUjACfF.gifv)
Windows is a somewhat-strange platform where Microsoft have their own unusual ABIs and linking. There are two separate ABIs on Windows: Microsoft and GNU. MinGW gives you a GNU-compatible environment on Windows, with GCC and binutils and everything, kinda like if you are developing on Linux. Native Windows libraries tend to be built with the Microsoft toolchain and use the Microsoft ABI. Many open-source libraries and frameworks, especially cross-platform ones like Qt and SDL, can be built with either. If you plan to only use Rust libraries (Rust crates can be compiled for either ABI) and various open-source libraries that can be built and work with MinGW, you could completely avoid Microsoft's tools. Just switch your Rust to the `x86_64-pc-windows-gnu` target. However, if you plan to do development for Windows, using native Windows libraries, you need Microsoft's linker, and you should use Rust's `x86_64-pc-windows-msvc` target for compatibility with that. Since most people on Windows are interested in Windows development, this is the default. AFAIK, in the future, Rust will be moving more and more towards using the LLVM LLD linker, instead of the platform native linker (Microsoft's, or GNU binutils). LLD is universal and aims to support all platforms and ABIs. Hence, there will be no need for any other tools.
I love all these posts these days with Actix Web! Thank you for this one :)
Lockfile should be provided with lockfile
If you need some help with 2D stuff (UI, textures,...), I can help
You can debug rust programs from VSCode on Windows. Install \` ms-vscode.cpptools \` extension. (It's in preview but works) Add `"debug.allowBreakpointsEverywhere": true` to your `settings.json` Hit F5, select C++ (Windows) from the list of debuggers. Change the value of the program property to match your program name. Something like: `"program": "${workspaceFolder}/target/debug/debugger_sample.exe",` Build the project. `cargo build` And hit F5 again. It looks like this: https://imgur.com/a/X2V6Bpf
[Some chat](https://github.com/rustwasm/gloo/issues/5)
I was reading the introduction to actix-redis at https://github.com/actix/actix-redis . There is a snippet of code at the beginning that looks like this: extern crate actix_web; extern crate actix_redis; use actix_web::{App, server, middleware}; use actix_web::middleware::session::SessionStorage; use actix_redis::RedisSessionBackend; fn main() { ::std::env::set_var("RUST_LOG", "actix_web=info"); env_logger::init(); So suddenly there is this env_logger token and I can't see where it came from. A web search leads to documentation for env_logger, but in the documentation it's always used after an extern declaration. I don't see any global imports or prelude. And yet there is this undeclared token in this working code. What am I missing?
I have two `Vec&lt;i32&gt;` called `a` and `b`. I want to zip them together into a `Vec&lt;(i32,i32)&gt;`. I want to keep ownership of `a` and `b`. So I have found 3 ways of doing this: pub fn f() { let a: Vec&lt;i32&gt; = vec![ 0, 5, 6, 7]; let b: Vec&lt;i32&gt; = vec![10, 20, 30, 40]; let c1: Vec&lt;(i32,i32)&gt; = a.clone().into_iter().zip(b.clone()).collect(); let c2: Vec&lt;(i32,i32)&gt; = a.iter().zip(b.iter()).map(|(a,b)| (*a, *b) ).collect(); let c3: Vec&lt;(i32,i32)&gt; = a.iter().cloned().zip(b.iter().cloned()).collect(); println!("{:?}", a); println!("{:?}", b); println!("{:?}", c1); println!("{:?}", c2); println!("{:?}", c3); } Which one is the most efficient? Or are they all compiled down to the same code? Is there a better way? Thanks!
This is a massive release! Excellent work team
I was in the same shoes as /u/jamadazi some time ago and I also dropped CL fairly quickly. The thing about Clojure is that I have to run a JVM, which is not something I want. What are some other alternatives you'd suggest to try out?
Does your module contain multiple connections or one connection?
The singular is more common, from what I've seen.
Unless you want to learn programming, try /r/playrust.
Personally, I would use `crate::connection` for the module containing `trait Connection`, and `connections` for the module containing various implementations of `Connection`. I am at a loss whether is should be `crate::connections` or `crate::connection::connections` though.
&gt;I'm tidying up several places of [Rust in Action](https://www.manning.com/books/rust-in-action?a_aid=rust&amp;a_bid=0367c58f&amp;chan=reddit) and a new MEAP update should be available next week :) Will it include new chapters?
Is not allokering me..
Wow, could it be that simple? 😱 It works like a charm!
Well, I don't know why that is, but this subreddit is about the Rust programming language, not about the game.
`tar-rs` doesn't have to build the archive. I have a web server similar to `miniserve` that streams TAR archives on the fly.
So you are saying that the only item in `crate::connection` is the trait `Connection`? I'd rather put it in `crate::connections` residing with its implementations.
In that example, it would be multiple implementations of the connection trait.
Then I like the plural more, assuming the implementations are semantically different.
While we're on the subject I'd like to understand better: if I target GNU on Windows, what underlying libc/Win32 implementation is Rust's libstd using? Do I still have the full Windows API available?
Oh ? Do you have a link?
Yes, that's what I meant. And yes, maybe your idea is better. I am very confused by module-design too!
I assume this is targeted at in game GUIs, not trying to be a QT/GTK?
[Yes](https://github.com/lnicola/rusty-share/), but the code is pretty awful, and I haven't worked on it since a long time ago. I'd love to get some help with it :-). You can run it without arguments, and it will serve the current directory, but it can also use a SQLite database to configure permissions. Click on "Download" to download the selected files or the current directory.
Is this for implementing your own terminal emulator or is it more like ncurses?
Thanks a lot! I'll look at how you did it, as I really couldn't find any clue in the doc (maybe I misread some parts). You seem to have quite advanced features, login and stuff, very cool
Thank you so much! This looks like a really fantastic API for parsing. I can easily imagine reaching for this instead of using a crazy regex.
I think you got your documentation for \`I2cReadRegister\` and \`I2cWriteRegister\` mixed up.
It is the same as termios, pancurses, ncurses, but than crossplatform and completely written in rust. It is used the interact with the terminal.
See https://github.com/lnicola/rusty-share/blob/master/src/pipe.rs. I have an adapter that implements `Write` (so `tar-rs` can write to it), but sends the data over an async stream.
A while ago I wrote a network lib for Rust and posted it here, since then I have completely rewritten the entire library as I didn't find it performant enough. Today I finished the second and final part of "[Building a pub/sub server with Sonr](https://hagsteel.com/posts/building-a-pub-sub-with-sonr-part-1/)". * Introduction to Sonr: https://hagsteel.com/posts/introduction-to-sonr/ * Examples: https://github.com/hagsteel/sonr/tree/master/examples * Api docs: https://hagsteel.github.io/sonr/doc/sonr/index.html * Repo: https://github.com/hagsteel/sonr
I really hate the clippy stutter lint, where if you write `connection::Connection` or similar it will complain that you are repeating the word "connection".
I am toying with a framework allowing AIs to compete on board games. The central piece is an omniscient referee who controls the game state. I also have a `Player` trait that players must implement in order to compete, the referee makes them interact. I am trying to use Rust's type system to prevent players from cheating, for example by playing cards that the referee never passed to them. So let's say I represent my cards with an `enum Card { A, B, C, D }`: what would be the best way to pass a card to a player and allowing him or her to read it, store it and later return it to the referee while preventing forgery (preventing that a player constructs new cards)?
Would this make `tui` is usable on windows?
Yes, it does, and should be working for windows version down to 7.
Excellent, I'll have to give it a try
I hope so too! I started making it because I was writing a parser in nom because I really liked the flexibility, but it quickly became quite messy and hard to read. LALRPOP also looked really nice but also quite limited in my opinion. So this is an attempt to bridge that gap and make writing parsers in nom much easier and more natural. And despite these grammars having similar limitations to LALRPOP the ability to use these as a part in a bigger nom parser and to include arbitrary nom parsers as non-terminals it bypasses those limitations.
Sorry, must have overlooked this, it’s fixed now, thanks
Clojure can also be hosted using JavaScript (aka ClojureScript) or the .NET CLR. Racket and Scheme are the other two big players that I know of, but suffer the same issues as Common Lisp.
Thanks for your answer! Makes it clear to me :)
&gt;The author of the article confused \`removingspacesfromwords\` as an argument against camel case as users were slower to read it... I did not. &gt;but that was a pure language statistic and not camel case and used as a demonstration piece. It was not. &amp;#x200B; Disregarding the 'all around performance' conclusion, which is a more complex argument and therefore leaves more room for disagreement, let me reiterate on what I reported on in regards to 'time to read'. * The related work section in Binkley et al. (2009) mentioned a study by Epelboim et al. (1997) which showed that simply removing spaces slowed down reading by 10-20%. * The results by Binkley et al. (2009) showed that *"on average, camel case took 0.42 seconds longer, which is 13.5% longer."* Thus, I did not confuse anything. The results of this study show that camelCase is 13.5% slower to read than under\_scores, which is a finding in line with prior work in natural language research 'thatremovedspacesaltogether'. In addition, in a follow-up post ["CamelCase vs underscores: Revisited"](https://whatheco.de/2013/02/16/camelcase-vs-underscores-revisited/), I cited a follow-up study by Sharif and Maletic (2010) which *did not measure a difference in accuracy,* and yet again found that camel-cased identifiers took 932ms longer on average (20%). Thus, disregarding my argument how relevant accuracy of variable identifiers is in comparison to time to read code, the overarching evidence leads to a pretty strong (and furthermore intuitive) conclusion that underscore variables are faster to read.
What I meant was that I would love to use IntelliJ instead but since I have to buy CLion to do run time debugging I am not willing to switch from VS Code (which has runtime debugging as you pointed out).
I'm guessing the last note should show something like expected std::iter::Iterator&lt;Item = &amp;'a OsStr&gt; found std::iter::Iterator&lt;Item = &amp;'\_ OsStr&gt;
The first one is definitely the worst way, as it does an extra allocation compared to the second two. `a.clone()` will clone the entire Vec, which is where the extra allocation comes from. In the latter two, only the individual elements are being cloned, which does not require allocation. Of course, the final `collect()` in all three is an allocation, but that one is unavoidable.
Do you have a precise topic in mind (documentation ? chats ? forums ? code comments ?) or is this global and kind of fuzzy at this point ?
The Wired article seems to focus on the keywords of the language. In my opinion this is really the least important point regarding accessibility for a "hard" language like Rust. If you want to speak about discussions places (chats, mailing lists and forums), about documentations, about code comments, then I think there's more matter to discuss (but I have nothing to propose apart my sad pessimism and skepticism).
Learning a programming language is different than learning English. You can program very well without having any functional English. Plenty of talented Japanese Programmers programming in c, c++, Rust, that never speak English. Even if that wasn't the case, agreeing on a single language to conduct business or science makes sense.
Do you means docs translation? If you get some volunteers why not, but it’d be a huge amount of work. And even then you’ll have individual crates with English docs. And I’m not sure it’d be worth it in the first place, I mean most countries teach English in school and it’s not just programming but also scientific papers and the huge international communities that can use one language to communicate.
I don't see how this is practicable. Sure, you could translate the Rust keywords and standard library, but then you have an entire ecosystem of libraries to translate as well, or you will end up with mixed language code in your project. It seems like a lot of effort, and it would fragment the community into smaller per-language ecosystems.
As a turk who uses english primarily for coding: people learning the goddamn language is easier than trying to make coding multilingual. Just learn the universal language and be done with it... Thats what i'd say. Perhaps better and earlier communication of the english prerequiste would be better for people who wants to start coding. And thats a real problem: people can graduate from computer science without proper english.. And they arent warned about the criticality of the situation. Then they get problems in their career. Trying to make the job multilingual is an impossible task. Just think about it, no docs for third party libs, no stackoverflow, a very sparsely populated and outdated wikipedia... Thats just torture.
&gt; why Rust could _not_ be made multilingual I'm not sure what you mean, but I'll assume you mean the keywords. As a non-native English speaker, I believe that programming is less accessible for non-English speakers because of the relative lack of learning resources, documentation, and not because the language keywords are (usually) in English. C has something like 32 keywords, which are mostly common words. On the other hand, C has a lot of subtleties and gotchas; if I were to look for a book in my native language that talks about them, I wouldn't have much choice, if at all. I've seen (but fortunately didn't have to work on) source code with comments and identifiers in a language I can't really speak. It was pretty awful -- I don't know your native language, but imagine having `T_ENTIER` instead of `int` all over the place, or look up PHP's `T_PAAMAYIM_NEKUDOTAYIM`. While not everyone understands English, it's one of the better ways to make sure that people from different countries will understand each other. If I wanted to use a crate written (or documented) in Chinese, French, or any other language I don't speak, I simply wouldn't. I would have no way of understanding or contributing to it. So I'm all for translating learning resources (books, tutorials, conferences, and so on) into other languages, but I would rather prefer if English remained the _lingua franca_ in our field. And on this topic, Rust isn't doing too badly: there are [multilingual conferences](https://apiraino.github.io/2019/04/06/latam.html), and I believe the old site used to be translated in quite a number of languages (I can't find the translations on the new one). I think there are also some community groups for non-English speakers, and I noticed quite a lot of Chinese content.
0 journalism integrity, a lot of chinese, brazilians and japanese people that don't speak english can code very well...
I agree. There was a [study](https://dl.acm.org/citation.cfm?id=2534973) about keywords in languages where they compared "standard" programming languages like C to a fake programming language with randomly generated keywords and found that C wasn't any easier for novice programmers. To be fair, they didn't include Rust and they did find the Python/Ruby were somewhat easier to understand, but I think the real takeaway is that keywords don't matter that much.
git can change CRLF to LF according to your platform and you don't even notice (usually). A git hook could change all keywords from one language to another one, it wouldn't be terribly hard (using the AST)... nor fast. But I'm not sure of what would be achieved this way. I'm sure learning to use `if` instead of `si` or `wenn` is the easiest part of learning rust.
I'd say localized language keywords hurt more than they help. I've encountered them twice: Excel functions are localized, and the the TI BASIC language for TI programmable calculators had german keywords as well; both cases were extremely awkward (because you more likely than not know more than a single programming language, which more likely than not will *not* have localized keywords, meaning you need to learn keywords in two languages), hard to cooperate with others, and hard to debug/find help, because most of the help you can find will be using english keywords. But yeah, better localized documentation, communities and so on are certainly a point that could be discussed. In the end, that would need volunteers using all these different languages, but I think a common platform where translations to or discussions in different languages can take place could be a nice idea.
Rust already has an (accepted?) RFC for non-ASCII identifiers. Other than that, we could potentially have a “locale” flag to the compiler, which would translate keywords and (where necessary) rename symbols to better match the target language/dialect’s words and conventions. Some care would have to be taken around RTL scripts, as well as those with contextual word boundaries, but I think this is still plausible even there. Going even further, we could make this same locale flag available in conditional compilation attributes/macros, so that APIs—including the standard library—could give alternate names for items depending on locale. Then we have multilingual interoperability: I can write a library in Hawaiian—where the character to mark lifetimes needs to change, because ‘ (‘okina) is a letter—and you could consume it in hieroglyphic Egyptian—where the ankh forms a convenient delimiter for things (although exactly what I leave up to the implementer of that particular locale).
Yay, amazing news! `battop` is coming to Windows finally
The other comments already mentioned everything I wanted to say as well. It's 2019 and we're living in a globalized world. People need to learn and know English. It's by far the easiest language. That doesn't mean that it's not still hard to do so at times, but there's no alternative.
Anyone who's interested in this should check out the [issue for RFC 2457](https://github.com/rust-lang/rfcs/pull/2457) (Allow non-ASCII identifiers). It played host to a *lot* of discussion on this sort of thing.
PLEASE DONT START WITH THIS: translating programming languages will bring more problems than solutions. My native language is spanish, and i'm fluent enough in english, but many of my colleagues are not, some of them don't even know a single word in english, but they never had a problem with languages being in english. Some actually did learn some english from just programming.
For keywords, it honestly doesn't matter. For the standard library, it might matter a little, and it very much matters for documentation. If you read the (very long, very hotly discussed) non-ascii-idents RFC, you'll see discussion on this point. For the most part, the language language doesn't matter, it's not like `fn` is an English word either. You can just learn the meaning once. For actual identifier names though, it can matter, but mostly for technical terms that may not have accurate ASCII transliterations.
Probably not the answer you’re looking for, but in my engine I used gl-rs for desktop, and it’s webgl_stdweb sub crate for making webgl calls on WASM.
If a value has a `'static` lifetime, does that mean even when the variable it's bound to goes out of scope, the value persists? I'm still trying to wrap my head around lifetimes. If that's true, wouldn't `'static` be a big cause of memory leaks?
Just maintain consistency, as long as you don't flagrantly ignore that, you're fine
Other than library stuff, what are these disadvantages you speak of? I didn't know clojure could be hosted in other runtimes, this makes it a little bit more interesting, since I guess somebody must have thought about making a "native" compiler, which is what I prefer
&gt; Thoughts? Don't do it, learn English. Error messages after translation are useless for user who sees them (because google won't help) and software authors. Function names or comments in local language are heavily limiting code sharing and reuse. Limiting anyone to their native language when teaching them programming is really not helpful. There is nothing wrong with translating Rust book and other materials, but beyond that it makes no sense. (English is not my native language)
Translating the Book, the Nomicon etc into other languages would be an excellent idea. Keywords and identifiers, however, are probably best left as they are. Not so much 'English' (because they are far from being anything resembling sane English) but as a single syntax and vocabulary which is the same regardless of who's currently doing the programming, letting a piece of software be worked on by dozens of humans who don't need to speak each others' native languages at all.
Libraries was all that I was thinking of when I mentioned that. Lisp code also tends to be really compact and domain specific. Which is both a positive and a negative depending on what you are up to.
I think this really just boils down to resources. To make a language *usefully* multilingual, you have to provide everything the language user needs in every supported language, and that basically means a massive duplication of effort. You need the language to be translated, all the tools, docs, libraries, communities... and at the end of the day you have an entirely separate ecosystem maintained by an entirely separate group of people. Would that actually make the Rust ecosystem more accessible? Or would it make it more fragmented and inconsistent?
r/playrust
Any word on when `tui` will be updated to use the new `crossterm` version?
I don't know, I was thinking to do it my self.
The article does not make much sense honestly. It's focusing purely on the naming of keywords in programming languages. I'm perfectly willing to accept that complete beginners with no or little knowledge of English have an easier time picking up the beginnings of a first programming language based on their own language. But certainly not much more than that as programming is about problem solving and requires abstract thinking. In the end most people will end up learning programming either at school and/or by reading a book in a language they're proficient with. As far as I know there are a bunch of books about rust available in other languages. The only potential real issue is the availability of documentation for non-English speakers and I don't think this is a problem that's realistically solvable. It's an enormous task to create and maintain documentation in itself. I think most people agree that Rust does a pretty good job but can still be better. There's a very good reason English is used: It's the language of the scientific world. We live in a global society and communication would be quite difficult if there wasn't one language you could expect most people to be reasonable proficient in. To come back to the title of article I disagree with the sentiment that coding is for everyone in the first place. The required abstract thinking/problem solving is surely off-putting to many people. Also people who are interested in this will be mostly of above average intelligence. I'd honestly argue being of above intelligence is required to be a somewhat capable programmer and more so for a complicated language like Rust. I'd thus expect most of them to be capable of learning enough English to read through English documentation after they've perhaps learned the basics of a programming language through materials in their native language.
While I think "just learn English" is a terrible answer to this problem, programming languages are not as hard as English. They're languages on their own. "mut" is not an English word. It reminds us of "mutable" but it isn't a word. Same goes for "fn". "for" is an English word but it's used in very specific sense. Not only that, but the core language is a very small part of programming. Are we going to translate all libraries? Are they going to remain compatible if you install your toolset in another language? My opinion on all of that is: do remain aware of the problem, let's try to solve it with tranlated documentation and whatever we can come up with, but we should not be so naïve to believe that translating a dozen of keywords will solve everythin. Altho I think you can keep Scratch and other tools like Excel multilingual because they serve a different purpose.
Oh wait. Maybe tranlated formulas in Excel are not as benign as I first thought: https://old.reddit.com/r/programming/comments/bbx67l/c_string_vs_string_is_not_a_style_debate/ekmr526/
[macro\_railroad](https://lukaslueg.github.io/macro_railroad_wasm_demo/) may be of help to understand complex macro syntax as well.
Not at all unusual, Windows is pretty much like every other OS that isn't a UNIX clone.
"Be aware that macro expansion to text is a lossy process. This is a debugging aid only. There should be no expectation that the expanded code can be compiled successfully, nor that if it compiles then it behaves the same as the original code." This seems odd to me. If macros are code that writes code then why would it not be possible to expand macros in a lossless fashion.
How are the players interacting with the game? Usually, this is done through stdin/out. But I suppose you want the player to provide you rust libs?
Excellent work, thank you so much! I'm very excited.
If it makes sense to separate the trait and its implementations, I'd probably create a module containing the implementations named `impls` or something and make it a submodule of `connection`.
Hmm. Looks interesting. I've been off and on trying to implement a clone of ncurses (starting from a machine translation) and this might be useful for that.
Indeed, using stdin/out is a solution that I didn't even consider. It could even be one of the best ones if I challenged friends. But since I am mostly coding this for myself, it didn't even occur to me. I am still interested in an API design that could solve my problem because it seems that it could be useful in other contexts as well.
Wrong sub, go to r/playrust this sub is for the Rust Programming Language
Are you a student? If so then you can register and use CLion free of charge as long as you’re a student. https://www.jetbrains.com/student/
Do you mean something like this? : fn requires_static_bound&lt;T&gt;(v:T)-&gt;T where T:'static { v } What `T:'static` means is that T cannot *borrow* anything that doesn't live for the rest of the program, `T` itself can be dropped at any time,deallocating any memory it owns.
Nice :)
yeah, something like `fn my_func() -&gt; Vec&lt;&amp;'static Thing&gt;` so in this case, the `Thing` is created and owned by `my_func`, so does this code fail because the `Thing`s inside the `Vec` are owned by `my_func` and dropped at the end of `my_func`? or does `'static` tell Rust "don't drop these `Thing`s" and it will work?
It's also worth noting that the debugging story with msvc toolchain is actually very good.
I actually could not compile my project with crossterm 0.9 on unix machine. crossterm_utils was not able to find libc. 0.8 compiles, however
This seems like how most of the operator traits are implemented. In fact, they go a step further and let the 2 sides be different types, allowing one side to be a reference while the other is a value. This gives, for example: `Add for i32`, `Add for &amp;i32`, `Add&lt;&amp;i32&gt; for i32`, and `Add&lt;i32&gt; for &amp;i32`. The main issue then becomes implementing all 4 combinations without seeming repetitive.
What `Vec&lt;&amp;'static Thing&gt;` means is that you either have a `static` which you borrowed `Thing` from,or that you leaked `Thing` inside of the function so that they could live for the rest of the program. Lifetimes are constraints on how long you can keep a borrow,they should never affect which code the compiler generates if it compiles.
Its fixed and also, they're not the same thing
Finally try_from and try_into!
Make an issue on GitHub
'static doesn't tell the compiler to *make* something live longer, rather it tells the compiler that something *just does* live forever naturally. Now you can override the compiler and *tell it* that something lives forever (this requires an unsafe block of code) even if the thing doesn't really live forever. Obviously you have to be careful about doing something like that, because when that thing naturally gets destroyed, the compiler still trusts you and believes that it still lives forever. This can lead to use-after-free, or similar kinds of bugs.
There has even been a study that showed that native English speakers had more interference from keywords than non-natives. Can't remember the citation (and one should always take such studies with a grain of salt).
MinGW exposes a sizable, but not complete chunk of Win32 APIs. The ABI is actually sort of compatible too, so the whole thing works as long as you don't try anything too weird.
Try it again with 0.9.1, already fixed it, my bad, I should yank that version now.
Try it again with 0.9.1, already fixed it, my bad, I should yank that version now.
In which version of rust did the hashes become hashbrown based?
This RFC is retarded though, we don't need non-latin symbols in programming language
Waste of time. People should learn English anyway
First calling it retarded is not constructive. Second, I said to look at the *discussion* on the RFC.
I'm in this one!
awesome seeing all these stabilizations, particularly looking forward to removing my unstable flags for atomic isizes. doctest `?` will also be a lovely QoL improvement. fantastic work as always!
`Any::type_id` was stablized but apparently it doesn't exist in the stable documentation: https://doc.rust-lang.org/std/any/trait.Any.html#tymethod.type_id
Isn’t that a link to it in the stable documentation?
It's a caching problem,I reloaded that page with Ctrl+Shift+R and can see it.
maybe refresh? I just clicked on the link you posted and I can see it
Very excited about alternative cargo registries. This will tip the scale and convince the powers that be to allow me implement something in Rust at work, finally.
yeah i had to force a cache refresh with ctrl-f5
I didn't know about this, Ill check it out
What's a good crate for sending emails? I'd be fine with just handing the work off to `sendmail`, but I'm not finding any crates that don't want to do too much. All I want is to send a plaintext email.
I hadn't heard about [attributes receiving token streams](https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#custom-attributes-accept-arbitrary-token-streams), but this is awesome!
Best of luck. Definitely post about it if you figure it out. I know lots of people have been trying to get it working.
As has already been extensively litigated in multiple places now, translating keywords is unproductive; Rust `if` has as much to do with the English word "if" as German `Gift` has to do with the English word "gift". That said, we absolutely could translate learning materials such as the book and *perhaps* the standard library documentation, and there's already an in-flight RFC for making as much of Unicode as possible available for identifiers to make programming more comfortable for teams whose primary language is not served by basic ASCII.
What happens if you use [AtomicU64](https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU64.html) on a target that doesn't support it? Compile error? I know `#[cfg(target_has_atomic)]` is planned, but hasn't landed in 1.34.0, yes?
Different languages are different not just because the call foo bar, but also because they have different concepts and ways of composing them.
The compiler can use unstable stuff, my understanding from peeking at the source is that you’ll get a compile error, yes.
Does Linux not have it's own different ABIs, and different versions thereof? Musl and gnu and gcc and clang and mix and match em
First, are you building with optimization? i.e. `cargo build --release` or `cargo run --release`
Good point, I'm not building with either, I'm using rustc against the source file.
OK, that's fine too, but use `rustc -O` or `rustc -C opt-level=3`. Consider `-C target-cpu=native` if you're only going to run it locally.
I think you're on the money, this takes compile option gets the run from ~40 secs to ~2.5 secs. `rustc -C opt-level=3 -o sq_fractions_rs sq_fractions.rs` Using optimisation level 3 against the c compilation gets the rust .4 of second behind. I'm ok with that, balance in the universe is restored :) Does anyone see anything blindingly obvious that could be improved?
Really curious to try it out. But like, am I the only one who is really afraid of this kind of functionality? Using an npm or docker configured with credentials on the public repositories feels like handling a loaded gun, and this won't get better if you make it easy to mix public and private repos. Also iirc Cargo's repository is immutable, isn't it? So many questions...
It would require that any situation the compiler doesn't recognize as single ownership be transparently converted to an `Rc&lt;T&gt;` or `Arc&lt;T&gt;`, which can have non-trivial performance implications. Rust is big on making costs explicit and that would run directly counter to that... plus making it *far* too easily to accidentally make a tiny change which causes your fast code to slow down by changing over to a reference-counted pointer. Also, unless you've got a full garbage collector, it may result in memory leaks due to reference cycles.
Why would you have the same credentials for both the public and private registries? That's how you solve that: make it impossible to publish because the credentials are invalid
I have been wanting this feature for years, and didn't even know it was coming down the pipeline. This is huge!
Consider doing `fr*fr`to square the number or possibly calling `powi`. The code is also not very idiomatic, here's how it would be written: https://pastebin.com/g9T0uF3j
Same! Very excited to help squash some name squatting
[This](https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=677be4ccf918ed17e7900ecf7343d5af) is how I would write it, it's a lot shorter this way.
Very happy that my longest-running PR so far (? in doctests) made it to stable. Woot! 🦀🧡 Also more variety in macro attribute arguments is a great change that simplifies the language while giving more power to macro authors. Great job, everyone!
You're doing good work man. Very interested in your arena crate in particular. Is it possible to embed an arena in a struct, or is it only possible to have one in a local scope?
Thanks for continuing to ignore every single thing I wrote, answer zero of the questions I wrote, show absolutely no good faith in a conversation. Further, I can't even find what you're talking about in terms of Persona, but you can't be bothered to actually engage in anything except vague dismissals. What a useless conversation thru and thru.
Out of curiosity, why were `NonZeroU8` and friends stabilized so long before `NonZeroI8`?
Edition 2018 doesn't require `extern crate`. Just forget it ever existed =) Of course, there might be some obscure reason this code worked on 2015 but it doesn't matter any more.
Not next week - but they have been extensively drafted and shouldn't be too far away. That said, drafts are read by 3 editors at Manning before they're released to MEAP. This can involve multiple cycles of review, so it often takes quite a long time to release new chapters.
The IT market moves slowly. Whoever uses Rust now are still early adopters. Given its strengths, I'm not at all surprised that those who use it are very happy with it.
The signed versions were deprecated due to a lack of apparent use cases, when the unsigned versions were stabilized it was unclear what to do with the signed versions. They were ultimately put under another feature gate to punt the decision
You could put the `&amp;mut SmallArena` in a struct whose lifetime is bounded by the arena scope. Soundness relies on neither the Arena nor indices escaping that.
I'm trying to wrap my head around why Rust has both `From` and `Into`, instead of just picking one. The docs [say](https://doc.rust-lang.org/std/convert/index.html): &gt; there are some cases where this is not possible, such as creating conversions into a type defined outside your library, so implementing Into instead of From is sometimes necessary However, when I try to create some random `struct MyFoo()` and then implement something like `From&lt;MyFoo&gt; for Vec&lt;u8&gt;`, the compiler accepts it just fine. The docs seemed to imply that that wasn't allowed, and that I should have to use `Into` there? So unless the docs are wrong about this, I think I've misunderstood something.
Rust is currently #13 most popular language in GitHub, by number of PRs in the language. This is ahead of languages like Scala and Swift. Most major software companies use Rust in some capacity. It's early, but I'm not sure Rust fits the "tiny minority" description anymore. That said, honestly not sure that "most loved" is an interesting metric. You're right that seemingly a few people could set the value quite high. You'd want it weighted against popularity, amount it's used in at work, etc.
Right. Ok. That makes sense. I think it could still work for me. It's a very interesting project. I did some test runs with 32 bit keys on a 64-bit platform and the performance hit was way bigger than the gains from not checking index validity. I thought that was weird since I had always believed that upcasting ints was essentially free.
A guess: Rust's a language popular for personal projects, where it's chosen deliberately by the coder, vice something he has to do for work.
Who knows ? Run your own survey ! As your first datapoint let me say Rust is the kind of language I have always waited for (and I'm not so young): strongly type checked, statically compiled, RAII, etc. Apart from the lifetime system I have difficulties wrapping my head around (I don't like the syntax) I love it. So that's answers 1, 5 and a bit of 3.
I have a question regarding traits and impls that implement traits, but also provide other functions. Given the following pseudo-code, I am curious to see if this is possible: trait DoSomething { fn do_something(&amp;self) -&gt; bool; } impl DoSomething for Doer { fn do_something(&amp;self) -&gt; bool { true } } impl Doer { fn do_something_else(&amp;self) -&gt; bool { false } } If I store the `Doer` as a `Box&lt;dyn DoSomething&gt;`, is it possible to cast that back to a `Doer` later and let me call `do_something_else()` on that object? Everything I've tried so far tells me no - but I'm wondering if the `Into` or `From` classes would allow for this? I'm assuming that since I've passed in a `Doer` to the `Box`, it has enough info to store the `Doer`, since it's just a pointer.
I like this. How well does it lend itself to rayon parallelization?
Нет, спасибо (: Single language = single community = better and easier sharing of code, thoughts and experience, easier job applications, etc. Just imagine going to StackOverflow and straight to Google Translate.. lol. On a side note, it's funny that you mentioned Russian. I'm under impression it's VERY popular among Russian(\speaking) developers. Our Gitter channel looks more active than the English one. Though nobody complains about Latin ;)
huh? Isn't the point that if you are working on crate `top-secret` and your muscle memory kicks in, if you hit `cargo publish` is it not just going to go off and push to Crates.io? It seems like Cargo stores the auth information and then expects the user to use a CLI arg to instruct which context to use. I also feel like I'd be worried about it too. Another reason it should've been always required a crates.io prefix. The same awkwardness and concern exists with docker image labels and the `docker.io` prefix, IMO.
[`successors`](https://doc.rust-lang.org/std/iter/fn.successors.html) is basically the reverse of `fold`, and should have been called `dlof`. And that's enough bash for me for one day...
It should be fine, as long as you're not worried about floating-point associativity -- the result may vary slightly depending on the order of addition.
There is a `publish` field for your Cargo.toml to prevent that: https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish--field-optional
how can you implement a cargo registry? Are there open source or saas registries servers out there?
https://doc.rust-lang.org/nightly/cargo/reference/registries.html#running-a-registry is linked to in the post. The exiting registry is open source. I’m not aware of any SaaS ones yet.
Cool, thanks, and for the fast reply!
As a side effect of TryFrom/TryInto, we also get a standard way to convert from `[T]` to `[T; N]` where N &lt;= 32. (speaking of which, can't wait for const generics to come out Some Day)
Heello
Why was it so long-running?
Personally, I think it should be called [`ana`](https://en.wikipedia.org/wiki/Anamorphism). While we're at it, we may as well rename `fold` to [`cata`](https://en.wikipedia.org/wiki/Catamorphism), since those are what they are. `&lt;/haskell-elitism&gt;`
Hi Steve! Thanks for your contributions, you are gold. Otherwise, do you think there is demand for such a SaaS. Also, can I PM/Email you?
1. You’re welcome! 2. I don’t know! 3. Sure
I didn't participate in the survey. But as a long term developer and former advocate of (modern) C++ I love Rust because of it's efficiency, safety and ergonomics. When looking in the rear view mirror you realize that C/C++ points the gun not at your feet but right at your head, regardless of how experienced you thought you were. Actually I was aware of this fact before, but then Rust taught me how to safe myself from this inevitable fate.
I was scrolling through the API definition for cargo and found ಠ_ಠ &gt; Responses use a 200 response code for both success and errors At least it's nowhere called Rest API (cause it's not). Well, system language developers ¯\\\_(ツ)\_/¯ 😉
Survivorship bias? If rust weeds out the people who don't learn it, they perhaps never get a chance to make a judgment call on liking or disliking it. Those who get through it were perhaps the ones who liked it the most, and let that motivate them. So by the time you narrow down who has enough experience to say they love/hate it, there's only people who love it left. This is in contrast to, say, Java or Python, which you can learn fairly easily, possibly even get experience in, maybe be forced to use at work, and has a community that probably agrees/disagrees on lots of things.
I fully agree with you. I'm also a spanish native speaker, learned MSX BASIC at my 10 years when I didn't know nothing about english. It was fun for me to use english words, since then I see english as a language for technical porpouses. Today, I hardly speak english fluently, but I'm fluent in around 10 programming languages. I use english even for my domain concepts, since it looks odd to mix english and spanish in source code. Language barrier is an issue for informal communication, not for programming abstractions.
This is due to compatibility issue in Cargos previously to today; we’re excited to finally be able to fix it.
We used to have [`std::iter::Unfold`](https://doc.rust-lang.org/1.3.0/std/iter/struct.Unfold.html), which was later reborn as [`itertools::unfold`](https://docs.rs/itertools/0.8.0/itertools/fn.unfold.html).
I have been toying with the idea of starting an api to store community made meta data about crates (like alternatives and gotchas) to help chit provide things like this but it seems like a bit much effort for the time being. I like the idea though. Can i get you to expand on what you mean by similar? One way to do this with info from [crate.io](https://crate.io) itself might be to search for other things will some or all of the same tags.
:). Thanks. It has been a bit of fun.
Rust is still under very active development, so a lot of new, interesting stuff is not yet available in stable.
Why were local paths in cargo.toml insufficient for your work? What's the big deal about alternative registries?
\`cargo clippy\` panics on checking \`combine\` crate. Should I report a bug or it has been reported already? &amp;#x200B; Checking combine v3.8.1 thread 'rustc' panicked at 'begin &lt;= end (617 &lt;= 296) when slicing `pub) $(#[$derive])* struct $type_name; type PartialState = (()); $(#[$attr])* fn $name [$($type_params)*]($($arg : $arg_type),*)($input_type) -&gt; $output_type where [$($where_`[...]', src/libcore/str/mod.rs:2014:5 stack backtrace: 0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace at src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:39 1: std::sys_common::backtrace::_print at src/libstd/sys_common/backtrace.rs:70 2: std::panicking::default_hook::{{closure}} at src/libstd/sys_common/backtrace.rs:58 at src/libstd/panicking.rs:200 3: std::panicking::default_hook at src/libstd/panicking.rs:215 4: rustc::util::common::panic_hook 5: std::panicking::rust_panic_with_hook at src/libstd/panicking.rs:482 6: std::panicking::continue_panic_fmt at src/libstd/panicking.rs:385 7: rust_begin_unwind at src/libstd/panicking.rs:312 8: core::panicking::panic_fmt at src/libcore/panicking.rs:85 9: core::str::slice_error_fail at src/libcore/str/mod.rs:0 10: core::str::traits::&lt;impl core::slice::SliceIndex&lt;str&gt; for core::ops::range::RangeFrom&lt;usize&gt;&gt;::index::{{closure}} 11: &lt;clippy_lints::functions::Functions as rustc::lint::LateLintPass&lt;'a, 'tcx&gt;&gt;::check_fn 12: &lt;rustc::lint::context::LateContext&lt;'a, 'tcx&gt; as rustc::hir::intravisit::Visitor&lt;'tcx&gt;&gt;::visit_fn 13: rustc::hir::intravisit::walk_item 14: &lt;rustc::lint::context::LateContext&lt;'a, 'tcx&gt; as rustc::hir::intravisit::Visitor&lt;'tcx&gt;&gt;::visit_item 15: &lt;rustc::lint::context::LateContext&lt;'a, 'tcx&gt; as rustc::hir::intravisit::Visitor&lt;'tcx&gt;&gt;::visit_mod 16: rustc::hir::intravisit::walk_item 17: &lt;rustc::lint::context::LateContext&lt;'a, 'tcx&gt; as rustc::hir::intravisit::Visitor&lt;'tcx&gt;&gt;::visit_item 18: &lt;rustc::lint::context::LateContext&lt;'a, 'tcx&gt; as rustc::hir::intravisit::Visitor&lt;'tcx&gt;&gt;::visit_mod 19: rustc::hir::intravisit::walk_item 20: &lt;rustc::lint::context::LateContext&lt;'a, 'tcx&gt; as rustc::hir::intravisit::Visitor&lt;'tcx&gt;&gt;::visit_item 21: &lt;rustc::lint::context::LateContext&lt;'a, 'tcx&gt; as rustc::hir::intravisit::Visitor&lt;'tcx&gt;&gt;::visit_mod 22: rustc::hir::intravisit::walk_crate 23: rustc::lint::context::check_crate 24: rustc_driver::driver::phase_3_run_analysis_passes::{{closure}}::{{closure}} 25: rustc::util::common::time 26: &lt;std::thread::local::LocalKey&lt;T&gt;&gt;::with 27: rustc::ty::context::TyCtxt::create_and_enter 28: rustc_driver::driver::compile_input 29: rustc_driver::run_compiler_with_pool 30: &lt;scoped_tls::ScopedKey&lt;T&gt;&gt;::set 31: rustc_driver::run_compiler 32: &lt;scoped_tls::ScopedKey&lt;T&gt;&gt;::set 33: syntax::with_globals 34: __rust_maybe_catch_panic at src/libpanic_unwind/lib.rs:87 35: &lt;F as alloc::boxed::FnBox&lt;A&gt;&gt;::call_box 36: std::sys::unix::thread::Thread::new::thread_start at /rustc/91856ed52c58aa5ba66a015354d1cc69e9779bdf/src/liballoc/boxed.rs:759 at src/libstd/sys_common/thread.rs:14 at src/libstd/sys/unix/thread.rs:81 37: start_thread 38: __GI___clone query stack during panic: end of query stack error: internal compiler error: unexpected panic note: the compiler unexpectedly panicked. this is a bug. note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports note: rustc 1.34.0 (91856ed52 2019-04-10) running on x86_64-unknown-linux-gnu note: compiler flags: -C debuginfo=2 --crate-type lib
&gt; Multipart could possibly also work, but what about the case when you have to handle multiple images? A file field in an HTML form can have the `multiple` attribute, in which case each file will be submitted in its own multipart entry with the same field name, e.g.: --boundary Content-Disposition: form-data; name="image"; filename="image1.png" Content-Type: image/png &lt;file content&gt; --boundary Content-Disposition: form-data; name="image"; filename="image2.png" Content-Type: image/png &lt;file content&gt; --boundary-- Nested multipart streams aren't sent by any known implementations and are deprecated (IETF RFC 7578 Section 4.3 &amp; Appendix A); in `multipart` and multipart-async` I just return an error when one is encountered.
it was a fluke.. the voters thought they were voting for Rust the game
It took me three attempts to arrive at the current solution, and even now I'm not completely happy with the type requirement, though I have an idea on how to improve inference to remove this papercut.
I can't remember what system it was, but one package manager I used had a field you could set in your manifest to prevent you accidentally publishing to public repositories. Seems like that would help here too.
&gt; new person bursts into the room “Hey, should ! automatically implement all traits, or not?” Lol; that was me (although there were probably others). I approve of the dramatic rendition. https://github.com/rust-lang/rfcs/issues/2619
I agree that you should benchmark on a realistic workload before making the jump. The things I've benchmarked so far got good speedups due to improved cache usage. But as always, your mileage may vary.
Has the `euclidean_division` (I think it was called) feature been added? I only need it for `euclid_rem`, but I'm just curious.
LLD only recently started to be compatible with link.exe on Windows, and mingw32 is a nonstarter for at least some professional developers targeting Windows, so this is a pretty good choice.
Cargo has that: [https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish--field-optional](https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish--field-optional)
I sent you an email over steve@ste... Thank you!
I think the example in the documentation is a bit confusing, it takes ok me a while to realize the reason it had exactly that many elements is that 100,000&gt;u16 Max and would return None for checked multiply
All "most loved" on the SO survey means is that Rust's ratio of `# of people who've used the language and would use it again` / `# of people who've used the language` is higher than any of the others. The number of respondents really has nothing to do with the ranking. "Most loved" does not generalize to "popular on Stack Overflow". In terms of you explanations, I'd agree with all except #4. As far as I'm aware, no official Rust forums have asked people to vote for Rust on the survey.
To be fair, there's pretty widespread disagreement on (ab)using transport level status codes for application level errors.
Almost every os used these days that's not windows is a Unix clone
Semver basically.
I can perfectly understand the reasoning behind the article, since it was written by a linguist, not an actual programmer.
I think the title is a bit inaccurate, according to my understanding AIUI, they are going to put ripgrep behind a flag in Atom **1.37**, for _file based fuzzy search_, and if all goes well, turn it on by default. This does not use ripgrep for search AIUI, although there is an issue to use ripgrep for that too. (On mobile or I would link it.) I also think there is already a third party plugin for Atom that uses ripgrep for search.
I should clarify: the first API call with the bboxes returned as json would be easy to deal with if multiple images are submitted. But the overlay API call which returns an image? I would say maybe returning a zip or tar would make sense, but the article was getting big already. So yeah multipart could definitely work: just need to deal with what's returned to the client
and what would be the type of a value? it makes more sense for you to use the driver durectky, there is no use for diesel here. mysql driver would return vec of enums where each enum is one of types supported by mysql.
Hmm... It used to be that you could not impl a trait on a type if both the trait and type were defined outside your crate. But it seems like now there's an exception for From/Into? Maybe someone else can confirm that, as I'm a bit unsure. Another reason, however, is ergonomics. It's nice to have the option to convert something using either `MyThing::from(other)` or `other.into::&lt;MyThing&gt;()`. The latter usually does not need the `::&lt;&gt;` syntax, since the compiler is pretty good at type inference most of the time.
We just got `to_be_bytes` etc in 1.32, which I used to depend on `byteorder` for. Now we're getting array conversions, which I used to depend on `array_ref` for. This is big for me! :)
Whenever I can, I use stable. But I'm doing a lot of experimental stuff that needs features only available in nightly. So those crates will stay nightly only until the features become stable.
For me it's mostly 5 + 1, but expanded. Rust is just really great language. Once you learn it, it is just so much easier to write anything, than in anything else. My Rust productivity is x10 any other popular language. And I do come from C/C++ experience and appreciate that power, without all the fear.
I'm not an expert at type systems, and I can't think of a type solution. One alternative is to store a pool of cards per player, so the referee always know which player has which card. You can then ask the player for the index of the card in his pool. Like so: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fd03ec18b6a63d65f02a7a57c5e2acb2
My understanding was that at least one of the types involved (not necessarily the `for` target) has to belong to your crate, but that's also something I'm not sure about.
&gt; we also get a standard way to convert from `[T]` to `[T; N]` where N &lt;= 32. Where can I read more about this?
Ah yeah, I didn't get a chance to read the whole article yet so I wasn't sure if you were putting an HTML frontend on it or not. Alternately, you could host the images in a temp directory or from memory on a separate route and return a list of URLs to GET them, maybe with a TTL or expiring after the first access.
I've already had someone on /r/programming tell me that, and the article has been updated to reflect that. My bad! Also, "namespaced" was bit of a misnomer there, I meant to say "scoped". Basically, assignments in declarative macros cannot overwrite local state where they are used, as opposed to C macros.
Wow, I really appreciate all the thoughtful and insightful comments so far! More welcome!
Awsome, I always abused scan for that purpose which is quite akward
I think I saw a project for a versioning system posted on the sub a few weeks ago. I don't think it was meant to be a mere interface to fit, and I might have read about compatibility with darcs approach of versioning as patches tether than snapshots. Can't find it, any idea?
You have to use nightly to use features that haven't been stabilised (i.e. to use the `#![feature(..)]` attribute). Things like specialisation, async/await, and until recently, atomic integers, TryInto/TryFrom, `const fn`. The list of major features that have yet to stabilise is steadily shrinking, but const generics is a big one that's being worked on. I imagine you'll see a number of crates eager to take advantage of that before it's stable.
I don’t know but from a personal experience I just get a lot of enjoyment out of it. I love the community, the language, the tooling and my day to day with it. Sure there is stuff that sucks (compile times) but all the things that work are just really nice. Am I biased? Yes. I clearly like the language obviously but that doesn’t happen in a vacuum.
TryInto/TryFrom are stable now, in 1.34.0 :)
Unfortunately this is one of those things that gets hidden in a long list of trait impls in the docs. You can see them here: https://doc.rust-lang.org/std/convert/trait.TryFrom.html#impl-TryFrom%3C%26%27a%20%5BT%5D%3E
Instead of translating the surface syntax of Rust, I think a more productive use of time, and a better enabler as far as inclusivity goes, would be to make sure that we enable non-ascii identifiers. A second important step would be to translate diagnostics. A third would be to translate standard library documentation. In other words, there are a lot of things (that will take a huge amount of time) that should happen before we consider translating any lexical surface syntax.
There goes my afternoon
I know it is a tough sell... but I would encourage you to use nightly every once in a while to test out unstable stuff that you might not need personally just to see if it is up to snuff. We rely on people to experiment and if the pool of people continues to shrink as we stabilize more things the teams will have problems.
`to_be_or_not_to_be` ... don't mind me, just making a shitty joke ;)
Anyone use Atom? How do you like it with Rust? I've been tinkering with the idea of writing a modal plugin in Xi editor, but it's quite young and some features (info popups, multiple cursors) are yet to be added. To save myself some headache, I debated writing the modal plugin for something like Atom, Sublime or VisualStudio.
...and then people told us about use cases, and we stabilized. :)
...but is it general enough to be called `ana`? ;)
[Does this help?](https://stackoverflow.com/q/33687447/5641333)
What would const generics allow that `typenum` doesn't?
&gt; What's with this fixation on nightly versions? Using nightly is trendy and cool. Doesn't matter whether you really need it or not - if in doubt, use nightly. Live on the edge.
I was looking at the [TryFrom](https://doc.rust-lang.org/std/convert/trait.TryFrom.html#generic-implementations) docs, specifically the first bullet under the "Generic Implementations" section, the first bullet says: &gt;TryFrom&lt;T&gt; for Implies \[TryInto&lt;U&gt;\]for T What does this mean? Is this a markdown typo or something else (referring to the square braces)?
It’s a markdown bug.
Like Latin was once the language of religion and the educated, German was the language of Chemistry, English is the language of programming, Chinese will be language of whatever develops out of the mad heat of Chinese hardware hacking culture. Just have to keep up if you want to be in the middle of things (not at the edge).
Will alternate registries allow the use of local crate caching e.g. when offline?
It’s not a cache, so not really.
That feels like an inevitable thing. If it's such a big problem then maybe we need to rethink the process of getting features from nightly to stable?
\&gt; That feels like an inevitable thing. Hopefully we'll produce new good ideas that people really want in the future as well. But overall I think over time it is inevitable, yes. &amp;#x200B; \&gt; If it's such a big problem then maybe we need to rethink the process of getting features from nightly to stable? Probably, but we have to be careful about making sure that nightly actually is seen as unstable and that people do not develop reliance on nightly features in a way that makes it hard to do changes.
I'm not familiar with typenum, but I'm referring to how the standard library has trait impls for every static array size up to 32. Const generics would allow you to be generic over the N in \[T; N\], simplifying things immensely.
If you’d like to make sure it’s compatible with Amethyst we’d love to chat with you!
But I am `le_tired`...
This is why we need higher ranked and higher kinded types. :P
Typenum makes types to represent values. So you can make a generic array using its types. Like GenericArray&lt;U10&gt; is a array with 10 slots with all its implementations. So it's basically what you want, but with types.
Haha I was also thinking of `get_le_bytes` and other similar constructions as well ʕᵔᴥᵔʔ
Array implementations, and faster compilation. Other than that, not much.
There's actually no specific role for the GUI itself. It can be used however you decide to use it. It's not trying to be a Qt/GTK in regards to the design - it's something far simpler. Base widgets, base design, extend it as you please. As I learn more about Rust, the library will become more and more complex. It's not limiting itself to any one use: use it as a GUI for anything. I plan on writing an app that allows you to create a GUI layout that can be serialized, then deserialized by an application, and used. Very similar to how the Atari ST did its design: you create a resource file (RSC), load it into memory, and open a dialog box from it, which then customizes the layout automatically.
&gt; Probably, but we have to be careful about making sure that nightly actually is seen as unstable and that people do not develop reliance on nightly features in a way that makes it hard to do changes. Just as a data point, the set of conditions where a feature is stable enough for me to test it, yet unstable enough to iterate on, is the empty set. I can and do join in on RFC discussions but my whole reason for picking up Rust in addition to my old go-to of Python is to reduce my maintenance burden going forward.
'tis standard code written with Piston. If you can run Amethyst in Piston, you can use it in Pushrod!
Ah, the "as_any.downcast_ref" was possibly the secret sauce I was missing. I'll try it and get back to you. I'm using a Box&lt;&gt; inside a RefCell&lt;&gt; so it may not quite do what I want. But we'll see.
Array implementation already is possible. GenericArray is exactly that...
I think most people that tried to learn and failed would say they dislike it tho.
The thing with typenum is that it seems to be more of a workaround of type system limitations rather than an elegant solution. How many type-level integers can you express with it? It doesn't seem like the "right way" to have to generate a type for every single integer you could possibly use. Wouldn't it be nicer if you could instead: impl TryFrom&lt;&amp;'a [T]&gt; for &amp;'a [T; const N: usize] { ... } ...collapsing a potentially usize-amount of type numbers into one generic implementation?
I just [shell out to `sendmail`](https://github.com/BurntSushi/rust-cmail/blob/ccb09ab81ffa801a2a293a73e0f99f320865debf/cmail.rs#L430-L433) when I need to do that. (A crate would be nicer, but I don't know if one exists, and I imagine it'd be a fairly significant effort to build one, unless one wraps an existing C library.)
Nitpick: you have `"+"` twice in the example. Does it eat significant whitespace like LALRPOP does? This looks really nice, and it'd be great if I could switch to it and drop the custom tokenizer that's currently needed... Are there any limitations for it or missing features vs. LALRPOP?
Just because it's nicer it doesn't mean const generics are needed. Sure it would be better to have a improved implementation. But it's basically no gain to 99.99% of devs, only in compile time and even then.
Rust has static typing so you have to bypass it somehow. Being with boxed traits or a enum, or even the Any trait. Bypassing diesel can be done with the raw sql api, `diesel::dsl::sql`
Oh, so just faster compilation be avoiding hacks.
So I have an issue that I just.cant.figure.out. I'm trying to get some content with params (struct) which implement the trait IntoQueryString to transform it into a string query from said struct. I'm also sending a struct to get deserialized by serde in the functions type. It keeps erroring because it wants two type arguments. So, I was wondering if there is a way to only need one type argument instead of two. [Playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=630c89c3782d91923550370bc6a3f052) Or Sample Code use serde::de::DeserializeOwned; use serde::{Deserialize, Serialize}; trait IntoQueryString { fn into_query(self) -&gt; String; } fn get_content_with_params&lt;D, Q: IntoQueryString&gt;(relative_url: &amp;str, params_to_send: Q) where D: DeserializeOwned { // Code } #[derive(Serialize, Deserialize, Debug, Clone)] struct SerializableQueryModel { page: Option&lt;u32&gt; } #[derive(Default, Debug)] pub struct JustParams { pub after: Option&lt;String&gt; } impl IntoQueryString for JustParams { fn into_query(self) -&gt; String { String::new() } } fn main() { let params = JustParams::default(); get_content_with_params::&lt;SerializableQueryModel&gt;("/url/here", params); }
I want to see this completed so I can connect to a SOAP server that provides 'wsdl' and 'xsd'. https://community.workday.com/sites/default/files/file-hosting/productionapi/Absence_Management/v32.0/Get_Time_Off_Plan_Balances.html
Oh my, Xi Editor. That would be sweet! If only we could get a decent frontend written for it
I think a big part of it is just that the developer experience is really nice. Cargo makes developing Rust easier than any language I've ever used, including traditionally beginner friendly languages like python. It also helps that the language is really well designed in my opinion.
I honestly think it's #1 with a side of #3. The second half of #5 makes sense, but the idea that the result is purely about learning doesn't ring true to me. There's also #6 where Rust has straight up the best documentation of any programming language / environment I've yet come across. And not just the core language mind you, great documentation is a norm in the whole Rust ecosystem. At work I use Rust for low-level high-performance software (robotics) and its great. I code fearlessly and my momentum is _awesome_. I wrote a high speed driver for an arm _in a week_ and when the time came to test it on a real arm **it worked on the first try**. The only other times I've had that happen were on homework caliber problems in Haskell. If love means "will actively seek to do more of this in my next job" then I really do love it.
I've just read a similar thread in PHP's internals mailing list. Someone really wants to get keywords translated.
Can't different branches per version solve that?
But target_has_atomic doesn't mean the target has atomic for every single type size (AtomicU128 can be available in which targets?).
The [RFC](https://github.com/nox/rust-rfcs/blob/master/text/1543-integer_atomics.md) suggests syntax like `[#cfg(target_has_atomic = "64")]`. Now that attributes can have token streams, likely we'd want to lose the double quotes.
&gt;How many type-level integers can you express with it? As many as the type recursion limit will allow you to.Typenum integers use a binary encoding,so likely it's log2(n) levels of recursion.
&gt; Most major software companies use Rust in some capacity. Uh, citation very needed...
Const-generics allow you to parameterize types over constants of any type(which derives Ord). You could,for example,define a trait that abstracts over fields like this: `trait Field&lt;const NAME:&amp;'static str&gt;{` `type FieldType;` `fn access_field(&amp;self)-&gt;&amp;Self::FieldType;` `}`
Oh, cool.
That's pretty cool
Please file a bug!
FAANG is an acronym for the largest tech companies. Out of that list, we have half: Facebook, Amazon, and Google. We also have Microsoft. As always, who you think are big companies differs by your experience, but at this point, a lot of large companies that do tons of stuff use Rust.
I've worked at MSFT and currently am at FB. Both companies have semi-large rust codebases.
Apple is also using Rust. They gave a talk about building a distributed file system.
Okay, but how are you measuring that? Like I write some code in Rust at work, but the vast majority of my coworkers at the large organization I work for would never have even heard of it if I didn't spend so much time talking about how much easier all of work would be if we switched to Rust. I don't doubt that there are lots of people working at large organizations that use Rust. That's just simple statistics. As a counterpoint though, I've had very little success finding companies of any size that specifically mention Rust in their job postings. When I see that change, I'll concede that organizations (rather than individuals working for those orgs) are using Rust.
Do you have a link? That’s awesome!
That's two, not most.
You don’t know me, you’re the one lacking knowledge. You get more examples by writing more examples. The docs are not space limited.
Google is going to be the largest single employer of purely Rust programmers in the world, as far as I know. Fuchsia has multiple hundreds of lines of code, and it’s not the only thing they’re doing. They also contribute back upstream significantly. Firecracker is a significant part of a chunk of AWS now. The CTO announced Rust support for Lambda at the last Invent. Facebook is building a VCS server that will hold all of their code, and more stuff that’s not public-ish. But it’s a lot. Yes, the total volume of jobs isn’t the same as more established languages. But we’re still growing. The point is the upward trend. We’re in the critical path for revenue generating products in a lot of places, big and small. The jobs will follow as this expands.
You asked for a citation of use “in some capacity”.
No, sadly. It was a small talk they gave in Seattle to try to recruit people to their infrastructure team. I have not been able to find any information about it online.
Off topic, but I was wondering if you could recommend good way to get started with robotics in Rust, specifically for someone who knows Rust reasonably well, and robotics not at all. I'm just curious and would like to play a bit.
This is an extremely sad state of affair. I can only hope Fuchsia does well.
&gt;The only other times I've had that happen were on homework caliber problems in Haskell. That's what made me put Rust in a special place. Haskell is well known for its "if it compiles, it works" property, Rust having a similar property is a big deal.
I *think* you are looking for r/playrust, this is a subreddit about Rust the programming language.
Are you more high level ("let's sew things together in ROS") or more low level ("let's hope that this LED blinks, because if it doesn't I'm not going to be sleeping tonight")? Also, what sort of budget can you comfortably drop on this hobby?
For me, it's both, slow and also not slow :) I'm working on a single workspace with ~170k on a MacBook Pro and performance is decent most of the time. I give IntelliJ (CLion) 4G of memory. Slow parts: * There are certain operations which I know are very slow (for example, going to impls, this little `I` in green circle and an arrow, which you can see on a gutter). They do work and fast for simple cases, but super slow (UI freezes for seconds and even up to the minute) for others. As far as I remember, the way IntelliJ implements this functionality is by doing some sort of "full-text" first, then resolving found locations to see if they resolve to the place you are at (I could be completely wrong here, though). So it seems it is slow in two cases: 1) name is somewhat short / not very unique (so there are a lot of false positives IntelliJ needs to go through) 2) there are many impls (don't try that on Debug trait, obviously :) ). This is, perhaps, the most annoying part -- when it searches impls, UI freezes (otherwise, IntelliJ does all the work in the background &amp; all "modal" operations are usually cancellable) * Sometimes it gets close to these 4G I give it and GC kicks in too often; I have memory monitor enabled, so I force full GC by clicking on it, then it drops to ~800M. It feels a bit faster after that? But maybe, just a placebo effect? * I tried macro expansions couple of time, they make it significantly slower. Unfortunately, `failure::Error` doesn't highlight properly without that, and we use that one a lot :/ * Generally, it is sluggish sometimes and freezes on certain operations (usually, on branch switches, when it needs to reindex a lot of files). Not so slow parts (roughly compared to what I see on other setups, RLS/Racer based): * Things like navigating to declaration work reasonably fast. * Same for "Find usages". These two alone are probably ~50% of why I like IntelliJ. * It has decent performance on inferring types when I'm typing the code. It can analyze through iterator/Option/Result/`?` combinators pretty fast (for example, I'm typing a chain with 5~10 combinators, and at the end I can get to struct fields on the result -- without explicitly annotating result type). Not instantaneous, but decent (seconds till it figures everything out, no UI freeze). * Overall, I would say, it's pretty decent, given the size of the codebase. Summary: I would say that IntelliJ/CLion definitely has sluggishness/slowness in its character. Like, if you are used to sub-100ms responses on all UI actions, definitely don't use it. At the same time, it does bring a lot of value (to me). It's not apples to apples, but I cringe when I see how folks use grep or something like that to search for usages of struct, or anything like that. I have feeling (but not data :D) that it's at least ~3x multiplier for my productivity. Especially, when our build time is like 1 minute for incremental build (empty line change, that is) to get the binary. `cargo check` is ~15 seconds for the same type of change. Disclaimer: I'm used to work on large Java projects (~20 millions lines of code), so my sense for slow/fast could be a bit off :D P.S. Clicked on impls for Debug, actually, it's not bad. ~10 seconds on the first invocation (after that it is cached and fast)? But I think it ignores all derived Debug, so my point stands.
I don't think it's that big a problem. Most of the features going into nightly are doing so because there's demand for them. If nightly features don't get used, it is probably because nobody actually needs them.
Don’t feel bad! I used to have a joke comment in the int impls if this - dunno if it is still there. Something like: fn to_be(&amp;self) -&gt; $T { // or not to be?
I've always been more high level, and I think I'm mostly interested in things like navigation and completing tasks. BUT, I'm specifically trying to branch out and explore different areas of software, so a little "let's hope this LED blinks" would also be great. (I'm sorry if that's not particularly helpful -- tl;dr I feel stuck and I'm trying to explore other things out there that might be interesting). I could drop one or two hundred dollars on this experiment, but wouldn't want to go beyond that until I'd figured out what I actually want to do. Thanks!
Whoa, it's another Microsoft (Research?) project in Rust. Neat.
How does one run their own registry?
did you just created the account to say this? WHOLESOME
&gt; Fuchsia has multiple hundreds of lines of code I get the feeling this isn't what you meant. Hundreds of thousands, perhaps?
Haha oops, yes.
It's hugely more convenient to define crates by version in a config file vs. managing the source code and version in local directories on any machine you want to use the crate on. It's not impossible just a pain.
A robotics habit in 3 progressively harder phases: 1) Start with https://www.robotshop.com/en/picar-s-raspberry-pi-3-2b-smart-car-kit.html plus a Raspberry Pi. RPi runs Linux, so getting it going with Rust is a breeze. 2) After you've built #1 and gotten it to meander about without getting too stuck, pick up an OpenMV, and use it to give your robot vision. Get it to detect cat colored blobs and drive at them. As a secret bonus, the microcontroller that runs the OpenMV is a Cortex-M, which there just so happens to be good Rust support for (enormous thanks to japaric, BTW). 3) After you've built an autonomous cat colored blob chasing bot, use the RPi's wifi to remote control it and stream back images, and use `rosrust` to connect your bot to a full ROS install so you can map and navigate your house.
I agree, but OP said it would be enough to make their team use rust. I'm saying, it barely changes anything if the only benefit is semver because you can use branches to do semver. It's basically the same thing actually...
I agree with your point. I just want to comment on the FANG term. It was coined by an economist to point out the tech companies with the biggest stock growth. FANG is essentially an investment term. Now, Microsoft has been big for so long their stock is stabler and aren't listed but, they have almost double the market capitalization than Facebook, and 6 times more than Netflix. If I had to chose I would prefer Microsoft joining the Rust community, which it has. Good days ahead us.
Small thing but so glad Instant is getting "checked" methods, I have found Instant to be one of rust' s sharpest edges. Docs could use some work though: &gt; Returns Some(t) where t is the time self - duration if t can be represented as Instant (which means it's inside the bounds of the underlying data structure), None otherwise. Does this just mean, as long as self - duration is &gt; 0?
Except for the very annoying and time consuming administrative burden and infeasibility of ensuring version consistency across large deployments, yeah, pretty much exactly the same.
Am I ever going I be able to write my own NotI32Max type and have Option&lt;NotI32Max&gt; be just the size of an i32 without special support?
Folks, it looks like I am missing something really obvious ``` --&gt; element/src/parser.rs:166:58 | 165 | let structure: Option&lt;&amp;Structure&gt; = match element.data { | ---------- borrow later stored here 166 | Syntax::PlainList(list_data) =&gt; Some(&amp;list_data.structure), | ^^^^^^^^^^^^ borrowed value does not live long enough 167 | _ =&gt; None, 168 | }; | - `list_data.structure` dropped here while still borrowed ``` I have an enum and I check if it is one of the variants I want to get an immutable reference to one of the fields. both `element` and `structure` are scoped inside the same function so they do live the same. How do I fix this without Boxing and Cow'ing ?
I don't get it, you either set a version in cargo with a branch in your git server to that major version. Or you only set a branch for that major version in your git server and point to it. How is that hard? [dependencies] rand = { git = "https://github.com/rust-lang-nursery/rand", branch = "next" } Your private git server can use the same credentials as the registry would.
Legend :) I hope it's still there! Codebases should, so long as it doesn't interfere, have the occasional moment of levity I think. I know I've always appreciated it when I find them unexpectedly
The article refers you to the cargo book (albiet the nightly version) for instructions on running your own registry. For convenience: https://doc.rust-lang.org/nightly/cargo/reference/registries.html#running-a-registry
You can [read the RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md). `typenum` is a hack and doesn't support any of the meta programming features that one could use const generics. Notably, combined with `const fn` and not being limited to integral types. And if specialization over const generics is a thing you can do some wild compile time meta programming tricks for code generation.
Ah, ok, thought the comparison was to path = "..." Git is definitely easier, in my case couldn't use it because could not get my private gogs server to play nice with cargo, despite considerable effort. Apologies for the snark.
I got curious about Rust a couple years ago because of these results. I figured if a language has a lot of love from those who know it well, it might be worth checking out. I think that’s really the best use for this metric. But I was right: once you get to know it, it’s a very cool language. It’s still developing, but I’ll be surprised if it doesn’t have a bright future.
Still there! [https://github.com/rust-lang/rust/blob/master/src/libcore/num/mod.rs#L541](https://github.com/rust-lang/rust/blob/master/src/libcore/num/mod.rs#L541)
HAH! it's still there! https://github.com/rust-lang/rust/blob/9ebf47851a357faa4cd97f4b1dc7835f6376e639/src/libcore/num/mod.rs#L541
Guess I’ll just do that, then. Thanks!
Me too! I'm super busy at the minute so the project has been put on hold, but would be very excited about having a contributor. If youre interested hit me up on github with questions and/or PRs!
Looks like there is some info about that in [the cargo book](https://doc.rust-lang.org/nightly/cargo/reference/registries.html#running-a-registry).
Nightly is common for people who still need experiential features that haven't been stabilized yet. It may be that the libraries you happen to see are largely in the category. I personally almost exclusively use stable for everything. All of the libraries I ever need to use are on stable as well. It really just depends on what you are trying to do. It's very possible to write Rust on stable even if people don't talk about it enough. :)
`try_into` is a macro now?
I once implemented localized keywords in an expression language for work. I don't think anyone ever used that feature - not a single user that I was aware of. For users of a language, 'if', 'else', '{', '|' etc. are just tokens, some happen to use letters. Also, think of the difficulty in discussion forums and help forums when people can't read others' code because they don't understand the keywords. The kind of thinking in the linked article is patronizing, maybe even insulting for a non-native English speaking programmer like me.
I'm already experimenting with the shiny new stuff more than most here.
I love irony
Survivor bias only works if the people that don't "survive" never report back. The WWII aircrafts that never came back. Burned out people never rose to the top of politics/management. Soccer players wear out their body to get pro but never achieved it. So you either die or do not get popular enough so people can hear you. So - I hope - no one dies by learning rust and fail. And everybody can participate on the SO survey, you don't have to present a "learned rust" certificate to participate. So I don't see how survivor bias could play into this numbers.
use cargo-vendor instead.
It's possible to implement big atomics using regular writes protected by a small atomic spinlock. I think that's how C++ gets atomic writes for arbitrary structs. But I'm not sure what rustc does.
Because it needs a closure instead of running the local block in a `for` loop, which is tricky for a) borrows and b) control flow.
&gt; Probably, but we have to be careful about making sure that nightly actually is seen as unstable and that people do not develop reliance on nightly features in a way that makes it hard to do changes. I don't want to be negative, but this part made me think of futures, which immediately grew a large and reliant community and now everyone is stuck on futures 0.1 when 0.3/std futures (I think) exist now. Even though the library is pre-1.0. Would this be an example of such a scenario you're describing?
If all goes well, yes. However, this only stabilizes the `Future` type, but not any runtime or language level support for it, so no `tokio` in the stdlib or async functions on stable.
Check the repo if it has an issue for that, and if not just report it.
Is this many targets? Is this something libraries should worry about?
Nope, Linux generally has one C ABI per architecture, and unlike Windows, has a native syscall ABI as well, so you can even avoid the system libc entirely, either by bringing your own or by just making the syscalls directly.
[Pijul?](https://pijul.org/)
Given that 0.9 was focused on performance, I looked for benchmarks but didn't find any. Are they in another repo?
typenum is great and I've done a fair bit with it that I couldn't have if it didn't exist. But it is clunky, particularly if you need to start doing a lot of further calculation with the parameters. I also hope that with const generics it will be possible to not only have numeric parameters but constant arrays of numbers as parameters, allowing for a lot more flexibility in generating special case numerics code.
How's this project coming along? I was looking at the github and seeing some feature requests and test builds, but it seems the documentation hasn't been updated. I'm pretty interested in this idea.
Pretty rapidly! Heres a test instance I have going. https://dev.lemmy.ml Im adding mod abilities and modlogs rn, once I get those finished ill make some more posts showing it off, then start working on the federation.
Try gitea instead of gogs, it's actively contributed and surpasses gogs by now
The README says it's done in the developer's free time, so I don't think this is a microsoft project.
Considering you want to be able to contribute to open source c++projects, I'd say you should definitely pick it up. That might even be the perfect way to learn. On the topic of promoting a deeper understanding of things, I don't think there's anything inherent to c++ that rust can't also give you. They're equally low-and-high level. What you might get is some perspective on how different languages compare if rust is your first language, although rust and c++ are pretty similar.
I don't really get the feeling this is the case so much anymore. A few years ago, back when I first started checking out Rust, even extremely basic stuff like serde required nightly, but these days just about everything I use seems to run fine on stable. The only crate I can think of that I use that still requires nightly is Rocket. I'm sure there are other crates that require nightly as well, but at least all the basic stuff seems to work on stable now.
That is ok. i wanted to build custom runtime for fun, but as want to wait until it goes to stable. thank you. :)
Maybe I misunderstood the "Why?" section of the README.
C and C++ are very old languages, where programming was still a relatively new and unexplored field. The creators of the language would not know what programmers 30 or 40 years later would be doing. C and C++ are impressive in their own right, but they have problems in which some more modern languages have managed to resolve. I think that it is a good exercise to learn C, and to experience segfaults and undefined behaviour, so you can appreciate what Rust protects you from. At any rate, it is worth learning any language if you have a purpose. Languages are like tools. If you need to fix wood with nails, learn to use a hammer. If you need to cut a pipe, learn to use the saw. For some jobs there are multiple tools you can use, and some will be better than others.
You need at least to know more or less C since C ABI is the only way for proper interface between languages
Holy crap are you working on this by yourself? Wow. Less than 2 months from suggesting it and it looks like you have the basic architecture built already. The world needs more people like you man.
More or less, there are things like embedded that you probably need nightly. Since you are using nightly why not use for everything. Now, my production server won't ever use nightly, because it doesn't need to so there is no need to suffer from its drawbacks. That seems like it would make a bunch of rarely used things for niche context go stable instead of properly testing them with most users. Sure rocket is nightly, but the point stands, only a few type of users will use the nightly features because there is no other way around them for what they want to do.
&gt; Will having solid C, C++ knowledge help to understand Rust better? C yes, C++ no. In my opinion, anyway. All the core concepts are in C already, C++ just adds a lot of features that are done differently / better in Rust. &gt; Is it worth learning C, C++ with a better alternative like Rust? C is not a hard language to learn, though it has a lot of painful edge cases (automatic integer conversions / signed+unsigned comparisons, undefined behavior being really easy to trigger) and a really shitty standard library. I would say it's worth learning C just so you can read existing C code and integrate with it, but it takes a little more work to be confident when you want to write new code in C.
There is a big world out there beyond desktops and mobile phones.
I think we need a level between nightly and beta, I don't need compilers that update daily and may break my build out of the blue, I want a alfa compiler that I will update as I need its new features. With nightly features that won't break tomorrow, but aren't as ready for beta. It may break next month, or w/e, like 0.1 crates break going to 0.2, but not like updating 0.2.1 to 0.2.2 and breaking everything.
That's pretty cool, maybe `heapless` would be interested in it.
Reported new issue: [https://github.com/rust-lang/rust/issues/59909](https://github.com/rust-lang/rust/issues/59909)
&gt; I think the title is a bit inaccurate, according to my understanding. Yes, that is my impression too. The page has release notes for 1.36 and 1.37-beta, and the ripgrep thing is in the 1.37 section.
I think you're looking for r/playrust
Crap just seen tht fat fingers clicked the wrong one lol
Good question, there are no benchmarks. You can see the change log of the changes made. When I worked on cursive, there was some terminal rendering lag because of some stdout locking I did on every write, I fixed this and noticed that the lag was almost completely gone. Next to that I removed all dinamic dispatch for linux - windows still uses it - and I removed all Arc occurrences. Al of this lead to some performance enhancement, numbers? I don't know, but I saw it visually.
Since you want to contribute to C++ projects, yes it is definitely worth learning C++. Whether Rust is better is irrelevant, since those projects aren't switching from C++ any time soon.
I have used nightly ever since I read somewhere that the nightly compiler is a little ahead in terms of incremental compilation support - compile times are such an issue for us that any help we can get is worth it. That said, this would have been years ago now and I haven't kept track of incremental support in stable. Can anyone comment on whether or not there is still a discrepancy in incremental compilation support in stable and nightly? Or perhaps link to somewhere progress can be tracked?
You misunderstand. When I write a project, I have enterprise-level needs for API stability from the beginning because my ability to find time to maintain them is variable enough that I can find and have found myself making daily use of a project that has been in a state of "I really need to get back to working on this" for 5+ years.
So how would you translate this to german rust: `if wenn == 3 { unterbreche += 1; break; }` :)
I work with this team. We're part of the broader Windows platform security team and Brandon's relatively new team in particular is working on security tooling. From his [tweet](https://twitter.com/gamozolabs/status/1105240443514568704): &gt;I'm excited to start a new Software Metrology team at Microsoft. Our focus is to develop and open source multiple tools for fuzzing, debugging, and reproducing bugs. I'm lucky to start off the team with a great group of people, providing for a great internal group and community! Expect some more open-source projects (more in Rust!) from our org soon :)
Note that burntsushi's `fst` crate also powers symbol search in both RLS and rust-analyzer :)
Any sources on this? From what I've seen up until now, it seems like the fairly universally agreed upon best practice is to use appropriate HTTP status codes to indicate errors rather than just return 200 for everything. It's not like you can't return a JSON body with additional details for non-200 status codes as well.
there's the chrono crate that does all that for you [https://docs.rs/chrono/0.4.6/chrono/](https://docs.rs/chrono/0.4.6/chrono/)
By similar, I mean alternatives, which might even be harder to calculate because categories wouldn't even be enough. I am a terminal guy, I use cargo search a lot, and when one of the crate listed seems to answer my needs, I wish I could use "cargo alternatives foobar" to list crates that would be alternatives to foobar. Maybe better alternatives, more maintained, more downloads, etc.
A couple guys I know are secretly working on Rust++, it's basically Rust with all of C++ stuck on top of it. They told me they expect it to supplant all languages except Python within 50 years. So yes, knowing C++ would be very useful.
Me too! I know what I'll do at work next week. Time to update many crates and not use git only. It'll simplify breaking change management so much. Thanks!
That's some pretty large function you've got there - I think a few parts could be improved, e.g.: &amp;#x200B; 1. Instead of doing \`date1.split('/').collect::&lt;Vec&lt;&amp;str&gt;&gt;();\` you could create a \`Date\` struct with \`fn parse(date: &amp;str) -&gt; Self\` method - thanks to it you'd be able to write \`date1.year\` instead of \`date1\[0\]\`. 2. You should return meaningful error messages instead of doing \`unwrap\_or(0)\` and \`return 0;\`. 3. A few tests for both functions wouldn't hurt.
Well I already use `heapless` as dependency :)
Well, the bot took its time. The old Veloren engine simulated the world locally. The new engine will simulate it server-side, and the client will automatically do interpolation of the state that it is informed about from the server. The large scale simulation will be done exclusively server-side and will use cellular automata (amongst other techniques) to simulate economies, civilisations, migration, wars, natural disaster, etc.
Borrow `element.data` in line 165 (so it becomes `… match &amp;element.data {`) or alternatively, add `ref` in front of `list_data` in line 166. Explanation: In line 166, you move `list_data` out of `element.data` (making `element.data` unusable after the `match`). With that move (\^\^), the lifetime of `list_data` shrinks to just the match(-arm). Thus, your whole `match` returns an optional reference to a value that's dropped immediately.
/s
I've talked to several people about this and usually the conclusion is that having `for` loops compile to a `try_fold` will be really hard, but probably not fundamentally impossible. Is there an example of a `for` loop that absolutely can't be rewritten as a `try_fold`?
I think you could use `Box` just fine for `Unique` or what sort of futures you'd need?
Looks like it's trying to do the same sort of thing as the cached executor from my `dumb-exec`, but also looks way cleaner. (I don't tend to write the cleanest code. :P)
You mean in order to be inter operable with other languages. ex: Rust. How is the C's interoperability with Rust?
For testing stable features the beta channel is a good choice. It's very unlikely that something will be changed after landing in beta.
Well if you want to export your Rust library to other languages you'd need to export C functions. And being aware of C quirks might be important there. For Rust itself, there are already several tools that automate the process of genering bindings to/from C (e.g. bindgen, cbidngen)
As far as I remember, it isn't the support to `?` that was added for doctests but the fact that you can return `Result` from the `main` function (since the doctests' code is wrapped inside a main function). Therefore, the given example could just be: ```rust /// use std::io; /// let mut input = String::new(); /// io::stdin().read_line(&amp;mut input) ``` Also, no more thank you part to contributors? :'(
Why not Python? :D
Well in my case I keep code pretty sinple and notifications wake all tasks, instead of particular ones. Since queue is static and pretty small, it could be neglect-able to iterate through all, so I imagine that's why it is so clean. Well I didn't know about `dumb-exec` but your Cached is certainly looks more complex :)
I got really lazy, That's a good suggestion, I'll use it in the future, but the function can also return zero, and that's why it's a "Potential error."
C, C++ language take time probably years to master, because there is arcane of knowledge to do things right.
Is that the only error? If it is not the only error, one of the earlier errors is the thing to fix and this one will go away.
I ran into this quirk once. Do you know why that is?
Not sure if you're joking...
:( So many libs are anxiously waiting for async/await and us users of those libs are anxiously waiting for said libs.
By coincidence I asked a similar [question](https://stackoverflow.com/questions/55578125/collection-with-traits-that-return-self/55647658#55647658)on StackOverflow, but was rebuffed by not getting an answer. I came up with a solution that is similar to what I'd do in C++ where I would have a base class (trait) with the methods I want to share between classes, and a derived class that is templatised on the component storage. &amp;#x200B; It seems to work fine and meets your (and my) requirements. I would love to get suggestions on how to improve this and make it more flexible
Yup, not knowing the troubles make invented solutions just weird.
&gt;Personally I have tried C++ and found it to be not worth my time, because for all its complexity it is still easy to make mistakes unless you are in an existing project and following its very strict guidelines. Currently I am having the this very thought
In theory, the compiler _could_ fallback to `Arc&lt;RwLock&lt;u64&gt;&gt;` (or `AtomicCell&lt;u64&gt;` from Crossbeam), for platforms where `AtomicU64` isn't supported.
I wish Rust had such good projects.
1. Didn't think of that. 2. unwap... he he, yeah. Laziness got the better of me. 3. That's fair. 4. The one I need to work on the most. I thought about passing the error checking to a function, but found it simpler to keep it inline. I'll see about slimming my functions down. Thanks, I appreciate it.
Looking forward to it. I'm only at chapter 4, but I really enjoy your book so far. I like your hands-on approach. Keep up the good work!
But I do think knowing the pain in C, C++ helps you to understand the solutions in Rust better, without knowing the pain it may just become an obligation.
Rust is actually better than most languages in that respect. If you want to hack on a browser, there is [Servo](https://servo.org/). If you want to hack on an operating system, there is [Redox](https://redox-os.org/). Not many languages can claim that.
We still need stackless coroutines for cool async story
At the beginning, even with the experience of the segfaults and undefined behavior I was thinking that Rust is weird. I think it take time to understand the advantage of Rust even with the C, C++ knowledge.
It seems that I'll have to post this every single release :\/ As of the time of this post, the [official standalone installer page](https://forge.rust-lang.org/other-installation-methods.html#standalone) incorrectly lists 1.33.0 as the latest stable release. For users who prefer or need standalone installers, please use the URL templates bellow or the following concrete links to download your packages until this issue has been resolved. The URL template for normal rust installers is: * `https://static.rust-lang.org/dist/rust-1.34.0-{TARGET-TRIPPLE}.{EXT}` * `https://static.rust-lang.org/dist/rust-1.34.0-{TARGET-TRIPPLE}.{EXT}.asc` The URL template for additional compilation target installers (`x86_64-unknown-linux-musl`, `wasm32-unknown-unknown`, ..etc) is: * `https://static.rust-lang.org/dist/rust-std-1.34.0-{TARGET-TRIPPLE}.{EXT}` * `https://static.rust-lang.org/dist/rust-std-1.34.0-{TARGET-TRIPPLE}.{EXT}.asc` ## Some Standalone Installers (Standard Toolchain + Host Target) * [aarch64-unknown-linux-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-aarch64-unknown-linux-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-aarch64-unknown-linux-gnu.tar.gz.asc) * [arm-unknown-linux-gnueabi.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-arm-unknown-linux-gnueabi.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-arm-unknown-linux-gnueabi.tar.gz.asc) * [arm-unknown-linux-gnueabihf.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-arm-unknown-linux-gnueabihf.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-arm-unknown-linux-gnueabihf.tar.gz.asc) * [i686-apple-darwin.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-i686-apple-darwin.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-i686-apple-darwin.tar.gz.asc) * [i686-apple-darwin.pkg](https://static.rust-lang.org/dist/rust-1.34.0-i686-apple-darwin.pkg) [asc](https://static.rust-lang.org/dist/rust-1.34.0-i686-apple-darwin.pkg.asc) * [i686-pc-windows-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-i686-pc-windows-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-i686-pc-windows-gnu.tar.gz.asc) * [i686-pc-windows-gnu.msi](https://static.rust-lang.org/dist/rust-1.34.0-i686-pc-windows-gnu.msi) [asc](https://static.rust-lang.org/dist/rust-1.34.0-i686-pc-windows-gnu.msi.asc) * [i686-pc-windows-msvc.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-i686-pc-windows-msvc.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-i686-pc-windows-msvc.tar.gz.asc) * [i686-pc-windows-msvc.msi](https://static.rust-lang.org/dist/rust-1.34.0-i686-pc-windows-msvc.msi) [asc](https://static.rust-lang.org/dist/rust-1.34.0-i686-pc-windows-msvc.msi.asc) * [i686-unknown-linux-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-i686-unknown-linux-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-i686-unknown-linux-gnu.tar.gz.asc) * [mips-unknown-linux-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-mips-unknown-linux-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-mips-unknown-linux-gnu.tar.gz.asc) * [mipsel-unknown-linux-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-mipsel-unknown-linux-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-mipsel-unknown-linux-gnu.tar.gz.asc) * [mips64-unknown-linux-gnuabi64.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-mips64-unknown-linux-gnuabi64.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-mips64-unknown-linux-gnuabi64.tar.gz.asc) * [powerpc-unknown-linux-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-powerpc-unknown-linux-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-powerpc-unknown-linux-gnu.tar.gz.asc) * [powerpc64-unknown-linux-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-powerpc64-unknown-linux-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-powerpc64-unknown-linux-gnu.tar.gz.asc) * [powerpc64le-unknown-linux-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-powerpc64le-unknown-linux-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-powerpc64le-unknown-linux-gnu.tar.gz.asc) * [s390x-unknown-linux-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-s390x-unknown-linux-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-s390x-unknown-linux-gnu.tar.gz.asc) * [x86_64-apple-darwin.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-apple-darwin.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-apple-darwin.tar.gz.asc) * [x86_64-apple-darwin.pkg](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-apple-darwin.pkg) [asc](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-apple-darwin.pkg.asc) * [x86_64-pc-windows-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-pc-windows-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-pc-windows-gnu.tar.gz.asc) * [x86_64-pc-windows-gnu.msi](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-pc-windows-gnu.msi) [asc](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-pc-windows-gnu.msi.asc) * [x86_64-pc-windows-msvc.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-pc-windows-msvc.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-pc-windows-msvc.tar.gz.asc) * [x86_64-pc-windows-msvc.msi](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-pc-windows-msvc.msi) [asc](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-pc-windows-msvc.msi.asc) * [x86_64-unknown-freebsd.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-unknown-freebsd.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-unknown-freebsd.tar.gz.asc) * [x86_64-unknown-linux-gnu.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-unknown-linux-gnu.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-unknown-linux-gnu.tar.gz.asc) * [x86_64-unknown-netbsd.tar.gz](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-unknown-netbsd.tar.gz) [asc](https://static.rust-lang.org/dist/rust-1.34.0-x86_64-unknown-netbsd.tar.gz.asc) ## Additional Compilation Target Installers Due to reddit's post limit, I can't post every link to all target installers supported by rust. Refer to the complete list of supported platforms in https://forge.rust-lang.org/platform-support.html. The extension for these installers is `.tar.gz` (or `.tar.xz`) for all targets including Windows. ## Browsing other standalone installers Due to a [known bug](https://github.com/rust-lang/rust/issues/56971), browsing the index of all available installers is no longer possible on https://static.rust-lang.org/. It is however still possible to access dated repositories via the following URL template: `https://static.rust-lang.org/dist/YYYY-MM-DD/` Installers for the current stable release of rust can be browsed at https://static.rust-lang.org/dist/2019-04-11/ If you have any questions regarding stand-alone installers or additional compilation targets, please don't hesitate to post them bellow. Cheers!
In this particular setting it is quite possible: the question ask if those that are already using rust want to keep using it. So if somebody never managed to get to a certain proficiency they are excluded from the count. What the survey tells us is that if you actually end up using rust probably you will like it, but it says nothing about the percentage of people who give up midway. (there are also a "dreaded" and "wanted" categories, together they give a clearer picture)
(From [here](https://github.com/rust-lang/rust/issues/27730)) Shared had been renamed to NonNull and stabilized.
Are the unstable features needed expected to be coming to stable soon?
Is it possible to forcefully enable WebRender on Linux using a non-nightly Firefox build?
Yes, https://wiki.mozilla.org/Platform/GFX/Quantum_Render explains how. At about:config, set gfx.webrender.enabled to true.
You'll love what's coming up - you will soon implement floating point from scratch, discover how NTP works by building a client and quite a bit more. What did you think of the CPU emulator?
Atomiccell is a magnitude faster. The atomic crate also has a Atomiccellish type
That wiki page on catas is terrible :( Whereas the on on anas is surprisingly clear.
Not exactly. I rather mean that we would have some sort of "beta feature" which you don't need nightly for. People would start using a feature and rely on its specifics. Eventually, it would get hard to change because we want to not break people.
Great!
Futures are landing in the standard library, at earliest, in 1.36.
iirc, Steve's laptop broke so he wasn't available to write the blogpost &amp; make Thanks! work this release.
If you write `my_crate = "1.2"` and there exists `my_crate` with version `1.2.3`, cargo will pick `1.2.3`. If you use branch instead, cargo will always use that specific branch and never something else. You also can't use `cargo update` on such branches. What I'd definitely like is if one could specify `branch_is_version = true` and cargo would then interpret branch names as versions. That'd also remove the need to run registry as a special service - git would be enough.
Currently it doesn't do any automatic whitespace processing, but it is on my to-do list as an optional feature. As for limitations, it doesn't support left-recursion and doesn't have the "macros" that LALRPOP has, but these are all things that I'm working on or are on my to-do list.
Yea, I wish we could do higher ranked types but they are tricky representation wise in Rust... No parametricity doesn't make it easier... ;)
While I get that the `patch` part of semver should always be updated, I understand that sometimes vetting is needed, but with internal crates that's not an issue. About minor I think you should use that minor version. So if you write my_crate = { path="server.git", branch="1.2" } It will use 1.2.3 if it's the latest. Cargo update disadvantage sure. But not one to inhibit rust's usage for a organization like that. Anyway, it's great it was integrated. I was just surprised it was that needed since it doesn't solve an unsolvable problem, just makes it a little bit less of a hassle.
I'm not sure honestly, but I think I should be able to switch to using [proc-macro-hack](https://github.com/dtolnay/proc-macro-hack) instead, which does work on stable rust.
I also had to set \`gfx.webrender.all\` for it to work, after the restart you can go to \`about:support\` and check that "Compositing" is listed as "WebRender" and not "Basic"
That's not a very helpful answer but whatever... From my point of view, you lack Rust knowledge. Otherwise, you're welcome to provide what additional examples you want or you can even write them yourself.
Can someone explain this to me: what engine is being replaced and what are the advantages to this one?
Conversely Rust makes you think about ownership and lifetime which is a useful skill when working in C and C++. While the Rust compiler will tell you about your mistakes, C and C++ will happily compile, run and maybe even work most of the time until some undefined behaviour explodes your face.
So you think it is a wastage of time. Can someone get really good at Rust without knowing C,C++? I also think years of time will be wasted learning C,C++. I suppose its better to learn some C, C++ advance topics for little time and invest more in Rust and support some cool Rust project or create an one myself. I wish the book had faulty example of C, C++ and provide a Rust example which solves the problem
Wait is Future a type or a Trait? Or both, there are many types that implement the Trait and a default one?
https://docs.rs is pretty amazing to me (and same thing for the standard library), but your comment made me think I might have a personal bias due to the fact I’ve been fluent with Rust for a while now. What is missing to Rust to me is a REPL with good information support. I came to Rust from Haskell years ago and I was disoriented not to find a `ghci`-like tool with which I could explore around. I guess Python-coming people would feel a bit the same without finding a `help()` function with a REPL. For what it’s worth, rustdoc is a pretty solid tool and generates pretty awesome documentations (fuzzy searches, etc.). I also struggle to find things sometimes (i.e. hidden trait implementations, for instance). But we’re getting there. :)
&gt; I would say it's worth learning C just so you can read existing C code and integrate with it, but it takes a little more work to be confident when you want to write new code in C. *a lot more. There, FYFY.
I think it can be useful but that will not be magic, Rust is hard to understand anyway. Actually I don't know if a C or C++ knowledge is essential to learn Rust but if that is the case Rust will fail. If Rust want to "replace" C++ it has to be understandable to people who don't know C++.
Never heard of Redox. I know about Tikv database, any other interesting project related to ML, DBs, game engines? I wish official book provided example code for weaknesses in C, C++, instead of just mentioning as the text.
Good point
I wish official book accompanies with poor C++ code code examples and a rust example with its solution. It would make learning easier for future Rustaceans.
No. Linux is the only modern OS that has a strictly-defined kernel/syscall interface and ABI for each architecture. This means that you can completely avoid everything in userspace if you want and write a program in assembly directly, which can interface with the kernel and use the functionality of the operating system, without having to link against any userspace libraries. No need to link to a libc or any other system library. This is actually what makes it possible for multiple implementations of libc and other system libraries to exist and still be compatible with everything. Some people are even toying around with building non-POSIX-compatible userland environments on top of the Linux kernel. It is also possible for other operating systems (FreeBSD does this) to have a thin Linux-syscall-compatibility layer and run binaries compiled for Linux natively. It is also trivial for the Redox folks to make their stuff compatible with Linux. Their libc (relibc) works on Linux too, and so do most of their other system components. Linux is awesome. The difference between glibc and musl is just that -- two different implementations of the same API, but the ABI is compatible. You just choose which library you prefer and link with that. And whichever one you choose, it will work with any version of the Linux kernel (unless you use new features not available in older kernels), because Linux guarantees a stable syscall ABI. And so will any bare-assembly programs you write, that link with neither libc. As for compiler-generated userspace code, Clang/LLVM and GCC use the same ABI and so do other compilers. By contrast, on other operating systems like Windows, the system ABI is not guaranteed to be stable, so the only way you can write programs that don't risk breaking with new versions of the kernel or other system components is to link against the system libraries that come with the OS. You cannot avoid the libc. You cannot write a bare assembly program that doesn't link against anything. I think (I might be wrong) the raw syscalls aren't even documented, because you are not supposed to use them. As for the userland, people found it useful to bring a compatibility environment with GNU GCC and its ABI into Windows, hence MinGW and the fragmentation between gnu vs. msvc.
Any one here have experience with C++, what they think of new C++ versions (11, 14, 17)? does those newer versions overcome earlier weaknesses?
This pretty much replaces Firefox's entire rendering stack. Roughly, it works same up to "display list" generation, and then WebRender takes over. For advantages, apart from usual ones for replacing C++ code with Rust code, WebRender makes much more aggressive use of GPU and should be greatly more performant. Basically, all rendering janks should be gone.
For ML, there is [Tract](https://github.com/snipsco/tract), which seems to be faster than TensorFlow Lite.
Shared was renamed to NonNull and stablized in [PR #46952](https://github.com/rust-lang/rust/pull/46952). That PR also includes &gt; Mark Unique “permanently-unstable” by replacing remaining occurrences of `#[unstable(feature = "unique", issue = "27730")]` with: &gt; &gt; #[unstable(feature = "ptr_internals", issue = "0", reason = "\ &gt; use NonNull instead and consider PhantomData&lt;T&gt; (if you also use #[may_dangle]), \ &gt; Send, and/or Sync")] Unique is still available with that feature ([Playground proof](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=6aab948f5c88a300554cfea25cba015b) and [use in the Rustonomicon](https://doc.rust-lang.org/nomicon/destructors.html?highlight=Ptr_internals#destructors)). The [PhantomData Patterns](https://doc.rust-lang.org/nomicon/phantom-data.html#table-of-phantomdata-patterns) page in the nomicon (right above the linked table) describes what Unique does and how one would recreate it: &gt; Raw pointers that own an allocation is such a pervasive pattern that the standard library made a utility for itself called `Unique&lt;T&gt;` which: &gt; &gt; - wraps a `*const T` for variance &gt; - includes a `PhantomData&lt;T&gt;` &gt; - auto-derives `Send`/`Sync` as if `T` was contained &gt; - marks the pointer as `NonZero` for the null-pointer optimization
Yes, I used all of them. C++ 11 is better than 98, 14 is better than 11, and 17 is better than 14. On the other hand, long awaited features are not yet in, neither concepts nor modules are in the standard yet. Very excitingly, C++ 20 is planned to include both concepts and modules.
You were right! The custom derives hadn't been imported. Looks like the `#[macro_use] extern crate diesel` got removed during the update to Rust 2018 but it's still necessary. Thanks much!
Yes it was a joke
&gt; Basically, all rendering janks should be gone Great discription. In all seriousness, thanks for the description
Will C++20 become better than Rust? Is it possible to patch the weakness of C++ in future versions with new features.
I made these impls and I'm really glad they're getting so much love :)
There's a great answer here about this line of thinking: https://softwareengineering.stackexchange.com/a/305294
It is quite simple. This is just the amount of people who want to keep using the language out of all the people who use the language. Rust is a language that people mostly use by choice -- because they like it. Unlike C++ that many people have to learn and use because of their job, or JS, which people learn because they want to do web development and you have to use JS if you wanna do web. People don't learn Rust because they need it for their job or because they need it in order to do what they want. The people who learn Rust and stick with it usually do so because they like it. This explains why it is loved by most of the people who use it.
Will we finally get HW-accelerated video decoding? Will we at least get closer to it? &amp;#x200B; Also, what's the difference between i915 and i965?
Interesting. What if I don't want to import names into my module? For instance I still would like to write gtk::TextBuffer inside the code instead of TextBuffer. Does this library support it?
Why does this take an `Option&lt;T&gt;` as the first parameter? Wouldn't `T` be enough?
Thanks for your answer -- as far as running my own survey, that in a way is the intent of the question. :) And the many good answers have been very helpful.
Google also has the fuschia os, which uses rust. I haven’t contributed yet, so I can’t tell you, which parts of the project are open to contributors, but I hope to soon.
Probably because `first` is the first item yielded by the iterator. Making it accept an `Option` allows it to return an empty iterator.
It's not quite that good yet. There are still some cases that the old GL compositing handles better, where WebRender redoes too much work per frame, resulting in janky scrolling on low-powered GPUs. http://www.cavesofqud.com/ with its multi-layered screen-size gradients is one.
Anybody still using Atom?
HW-accelerared video decoding is blocked on HW-accelerated compositing. WebRender is HW-accelerated compositing and paint, so it is a definite possibility.
This code cannot be sound, that is, statically type-safe, not in the way you envision it at least. `Vec&lt;Position&gt;` and `Vec&lt;Velocity&gt;` are different types, and you can only store values of a single type to a `HashMap` (or `Vec` for that matter). Even if that were possible, how would you access the different types of vectors in a type-safe manner? You'd need a runtime check ensuring the types match, which requires runtime type information, which Rust does not have by default. You might want to check out [`Any`](https://doc.rust-lang.org/std/any/index.html) which does provide runtime polymorphism at the expense of runtime checks. You can't have your cake and eat it too.
I had a similar bug. I had to wipe my ./target/\*/incremental directories.
Thanks; that looks great!
You can do what a lot of projects have done in the past: pin development to a nightly that you verified to work well with the features you use. Then you can update the nightly when appropriate. Rustup/cargo has some support for this by specifying the nightly version to use inside a crate. (I forgot how exactly though).
What are the better alternatives?
Damn, can't test, my hardware has a battery... WEBRENDER_QUALIFIED blocked by env: Has battery
i915 is the name of Mesa driver supporting old versions of Intel GPU. If your Intel CPU is post-Westmere (2010), your CPU includes GPU that is supported by i965 Mesa driver.
The usual mention is Visual Studio Code.
i would rather not use stdweb in favor for web-sys (it looks like it has more robust api than stdweb)
No, I don't think C++ 20 will be better than Rust for me. Of course it is possible to patch the weakness of C++ in future versions with new features, that's the entire point, but C++ is heavily constrained by backward compatibility so it won't be easy.
Yep. Simulacrum and I are gonna work on making this not so tied to me.
I think both understanding C and C++ will help you understand rust better, and understanding rust will help you write good C and C++. If you learn C and C++, you will probably get a good idea of where rust tried to learn from their mistakes and understand why rust is the way it is (of the two, rust's design philosophy is much more similar to C++) Having learnt rust, the habits around ownership and lifetimes the borrow checker drills into you will help a lot with C and C++, where a lot of the same rules apply but the compiler can't help you as much.
Yes, being able to return a result is the actual feature that was added, it enables using `?` which is what people usually care about
In case it's still of interest to you, I've just made a short asciinema demo for blkar which you can see [here](https://asciinema.org/a/240491).
Awesome, thanks!
It is better if official book had some C++ examples also, Does the Oreilly book have C++ examples?
True, but as someone who recently tried and switched back to Atom as fallback editor I can tell you it got MUCH better. The time where VS Code was faster or better to use is over imho, and in Atom I can actually zoom the text area without also making all the buttons and menus larger.
that project is not open sourced yet may in this year I/O.
The plots generation will have 2 use cases. 1. Render on a web page 2. Generate PNG of the same plot as a standalone application.
The plot needs to be embedded into a web page of an application.
fn main() { let a: f64 = (1..600000000) .map(f64::from) .fold(0.0, |acc, fr| acc + fr.powi(-2)); println!("{} {}", a, f64::sqrt(a \* 6.0)); } &amp;#x200B; \`fold\` can be used for \`map\` and \`sum\`.
\&gt; Can someone get really good at Rust without knowing C,C++? One data point, I know No C/C++.
Just yesterday had a need for this, and didn't know if it was possible! I guess not (yet).
So that’s what you’re doing while we all wait for \`nom-5\`. \[Hmmmmmmmmmmmmmmmmmmmm :D\]([https://phaazon.net/media/uploads/il\_e%CC%81\_for.jpg](https://phaazon.net/media/uploads/il_e%CC%81_for.jpg))
did that ever happen? just curious!
But having some is better
Suggestion of a better name: \`lovecrash\`.
It seems pretty smooth to me, and i'm on the igpu of an intel 4005u.
You're correct, this is required. Then restart your browser.
From what I understood, all Intel GPUs are handled by i915 kernel module, but there are 2 Mesa drivers - i915_dri.so and i965_dri.so. Correct me if I'm wrong
It isnt necessary per se, you just need to import the macros. In 2018 edition macros became importable, so to use them it'd be `use disel::MacroName`
&gt;It's basically Rust with all of C++ stuck on top of it What does this even mean? &gt;they told me they expect it to supplant all languages except Python within 50 years Don't you think this is a bit hyperbolic?
Haha, yep currently. Ive done similar projects before so this was an opportunity to learn more rust.
Rust is currently in and exiting a golden age where most people who use it have infinite time to work on their projects because they're not doing it professionally. When the primary motivator is passion and there are no deadlines, code can be much more beautiful. I think as time goes on, we'll start seeing uglier, less idiomatic code become more normal.
Even if this was meant in jest, it's pretty not cool to induce maintainer guilt in maintainers of spare time projects.
That was a private joke, actually. No guilt was implied. Chill.
I would argue that I am only able to write production C and C++ code because of my Rust experience. I "learned" C and C++ first from university and self-study. I would say of that knowledge only the very basics from C: pointers, stack vs heap, etc. really taught me anything that was useful in learning Rust. Well that and how bad segfaults, implicit coercions and a bunch of other C warts are. I'm not convinced this step is necessary. Learning Rust taught me how to structure my C and C++ code well. It taught me about ownership and patterns to safely manage resources. It let me do experiment with bit twiddling, simd and other advanced techniques that are ultimately the reason you often choose a system language in a safe environment with guard rails.
Oh, I think I follow now. I should iterate over `try_from` for `0..N` until I find one that works. Interesting. If that's the case I wonder if it makes sense to have a language feature to do this for me?
Oh, that is an interesting use case! I don’t think that is supported with the current way the macros operate (renaming via ‘use’ and ‘as’), but if anyone has any ideas on how to make that work, we could take a swing at it.
I'm curious how its proponents would plan to handle name mangling and `#[no_mangle]` for non-ascii symbols.
Not sure whether you looked at this: https://github.com/nrc/r4cppp This will help you to compare Rust with C++.
Is there a way to swap the object inside a ShardedLock to one of a new type, if they are both constrained by the same trait? I mean as in: ``` trait Trait {} impl Trait for A {} impl Trait for B {} struct Reader { x: Arc&lt;ShardedLock&lt;dyn Trait&gt;&gt; } struct Writer&lt;T: Trait&gt; { x: Arc&lt;ShardedLock&lt;T&gt;&gt; } impl&lt;T: Trait&gt; Writer&lt;T&gt; { fn hotswap(self) -&gt; Self&lt;B&gt; { // what do I put here? } } ``` I want Reader objects to be read()ing A objects... until I invoke Writer::hotswap, and then reader objects will read() B objects without realizing the Trait object has changed under their feet. It's dynamic dispatch so I feel it _should_ be possible?
The ‘chill’ at the end is uncalled for. You brought your private joke into a public forum, it’s pretty dumb to act offended when someone correctly points out that without context you’re being an asshole.
No, fuchsia is and has always been open source: https://fuchsia.googlesource.com/fuchsia/
What part is written in rust? Maybe I'm missing something but I only see js
Normally yes, but diesel's macros in particular are very painful or maybe even impossible to use without \`\#\[macro\_use\]\`
Asshole might be a little extreme
Well, to make it short, if wanna learn C++ just do it. It's always worthy. However, if you just want to learn low level programming in order to understand better Rust, just stick to C. In any case, C is a good starting point. So maybe go for it first, and pick between Rust or C++ when you feel confident enough.
First, dig into [http://rastertragedy.com/](http://rastertragedy.com/) . It is a sage about text rendering, which is part of any gui. Second, dig into [http://unicode.org/standard/standard.html](http://unicode.org/standard/standard.html) on how on needs to handle text. Third, a good book on [Typesetting](https://en.wikipedia.org/wiki/Typesetting) to get an idea what you need to do with text &amp;#x200B; This is probably enough to discourage anyone to go from scratch.
How are they particularly painful? And they sure shouldnt be impossible, thatd be a pretty serious bug in 2018 edition wouldnt it?
&gt;What I think would be the best way is simply start with re implementing a stable Qt4 or Qt5 in Rust. Two problems 1. It shall take decades. I do not joke, qt is a very old project 2. QT is a retained mode hardcore OOP toolkit. The style does not fit rust
Iterating doesn't sound right to me. Usually you have a specific array length in mind, and so you either construct a slice of exactly that length, or you error/panic if you can't do that for some reason. It sounds like you're talking about "taking a slice of an unknown length and converting it to whatever array type that matches its length." But since arrays of different lengths are all different types, you're probably going to hit a compiler error?
Most of the logic is abstracted into prebuilt binaries that are available in the `bin` directory as a Node C++ addon.
You can try Nightly, it's pretty stable.
I see. So is the source code of the node extension available anywhere?
&gt;Rust is hard to understand anyway Well that's the thing though, as a C++ programmer I found Rust very easy to pick up. A lot easier than for example Python. There were no surprises or gotchas. Everything worked mostly like as if you wrote Modern C++ without any mistakes in it, prevented by the compiler
Telling someone who writes you software for free how they should be spending their time, or that they aren’t shipping fast enough, is 100% an asshole thing to do.
C is actually a fairly simple language (C++ on the other hand is not), and learning the core syntax takes at most a week, especially if you know any other C-like language (like Java, JavaScript, PHP etc).
&gt; Even if this was meant in jest, it's pretty not cool to induce maintainer guilt in maintainers of spare time projects. I agree, but I think it's not clear whether this is what actually happened. It could also be the case that the author laughed about the joke and was pleased about the fact that his creation provides so much value to people that they can't wait for the next release. Life is complex. I think there is no right answer here. People take risks with every interaction they participate in. No way around personal heuristics. I'm fine with the original post. I think /u/phaazon_ clearly wasn't acting with bad intent.
Diesel's macros call other diesel macros, so those must also be imported, so you end up \`use\`ing a lot more than just the macros you originally wanted. But https://github.com/diesel-rs/diesel/pull/1956 is in progress to fix that. It's been a while since I tried importing all the macros one by one, but it gets messy very quickly.
1) IMO YES, because C/C++ has been around for long and they cover plenty of ground, most languages and tech stacks have their places in todays world (ie: java for backend and big data, python for ml and ai, javascript for web, etc), but C/C++ are or were around those places too. So you get decades of research, do's and don'ts that will definitely help you with rust, or almost any other language. My first language was C/C++, the knowledge I gathered with both definitely helped me with java (my main language) and C#... today I'm working on a small python ai project and doing some functional programming, which is stuff I learned with C. I genuinely think C/C++ knowledge is a must for everyone working in this profession seriously. 2) By today standards, it's a hard language to teach/learn, and given that Rust is coming up to speed with it I really don't think it will be a "better alternative". An alternative maybe, but not better.
It's not many targets, so it's something libraries should worry about if they're intended for universal use. The reason I ask is that I'm thinking about a thread-safe RwLock variant that relies on a combination of static types and a run-time check of a unique "key". I'm looking at incrementing an atomic int to guarantee uniqueness (otherwise there would be a soundness hole), but it's easy to overflow u32. Not working on all platforms would be a disadvantage, but maybe workable.
I think the FFI abort on unwind change is a recent example of this, not sure if there have been others: https://github.com/rust-lang/rust/pull/58795
It would be - if someone here said anything remotely resembling those words, but no such thing happened. Chill.
&gt; What does this even mean The way they explained it to me, they figured out how to harden C++ features by using Rust features "like a cherry on top". &gt; Don't you think this is a bit hyperbolic? Well analysits are saying that the programming languages will begin to converge soon, and we will only end up with two languages for scripting and for systems. The guys I know are staying ahead of the curve and trying to capture the systems niche by hardening C++ with the simplicity of Rust.
Here's a suggestion for another quote: &amp;#x200B; &gt;When, long ago, the gods created Earth &gt; &gt;In Jove's fair image Man was shaped at birth. &gt; &gt;The beasts for lesser parts were next designed; &gt; &gt;Yet were they too remote from humankind. &gt; &gt;To fill the gap, and join the rest to Man, &gt; &gt;Th'Olympian host conceiv'd a clever plan. &gt; &gt;A beast they wrought, in semi-human figure, &gt; &gt;Filled it with vice, and called the thing a N\*\*\*\*\*. &amp;#x200B; &amp;#x200B; ... Actually, on second thought, maybe we shouldn't celebrate this dude?
"there is arcane of knowledge to do things right" implies much more than just knowing the language syntax. Getting things correct,especially in permissive languages like C,requires experience and knowledge of the quirks of the language(like what counts as undefined behavior).
Unfortunately there is no tone of what is said on the internet, as such you have to be able to look at the words and look at multiple meanings that it could have depending on the tone. I read "chill" as "it's all good, relax" not something like "Jesus, chill the f out".
Searching for `max_atomic_width` in the [target specs](https://github.com/rust-lang/rust/tree/master/src/librustc_target/spec), a lot of the 32-bit platforms only support 32-bit atomics. It looks like every target supports at least up to their pointer-width though, except msp430 which doesn't support atomics at all (and that's also the only in-tree 16-bit target).
How about assembly language? (Any chip's assembler, maybe an easy one so you get the idea, rather than a huge sprawling one.) That might be useful to understand underlying low-level technologies. Then C to understand a higher-level view of something almost the same (but C isn't what it once was -- now it is full of undefined behaviour to let optimisers move code around and eliminate code, supposedly without you noticing, which wasn't there at the very start of C -- it's like the standard writers and compiler writers conspired to make C unpredictable for normal coders; read Regehr's blog on that). But C++ has too much stuff to learn for no value unless you actually need to use C++ sometime. I've had to hack on C++ codebases occasionally but despite "learning" it several times (I have the first edition of the book), I never liked it because I think it made the wrong decisions. It is used because it exists and because it has momentum. But I think it wouldn't have been used if there had been something better around at that time.
Yeah, Lovecraft was more than a bit of a racist. A brilliant author, but not a great human. I'd love to see inoffensive quotes every now and then, though :D
Stupid question: if I have both a Intel iGPU and a discrete GPU, can I use the igpu with Webrender while using the other GPU for other pieces of software ? (I just have **zero** idea of how those things work)
Why are you repeating the "chill" thing? Is your intent to aggravate the situation even further?
The original comment implies that this project was a frivolous use of time and states directly that people are waiting for another project to ship? If that comment had been from a random person w/ no relationship to the author, would you be okay with it?
If only library-authors would take this principle to heart instead of demanding things be stabilized early...
Am I forbidden to say `chill` now? :-P
You seem to be presenting yourself as the most injured party in this conversation, even though the original comment wasn't even directed towards you - so unless you're u/geaal's advocate I say we cut this here before anything bad happens.
It's possible. How you do it depends on your hardware and drivers.
This is awesome. Firefox is going to leap frog in performance.
I’m not injured by this comment, no. But I have been on the receiving end of people feeling entitled to my time on side projects, and would like it to be a general norm that shaming open source developers for how they spend their time is verboten.
— Random Guy #1: Publish a crate and announces on Reddit. — Random Guy #2: Knows Random Guy #1 and has a long-running private joke with them; does it as a comment. — Random Guy #3: Doesn’t seem to know about the private joke. Even though it’s something #2 said to #1, #3 doesn’t wait for clarification or context and calls out #2 an asshole and uses assumptions from who the fuck knows. — Random Guy #2: Explains it’s a witticism between #1 and #2. — Random Guy #3 and others: They don’t care, it must be an insult and drama is absolutely required. They actually need a case in point and #2 seems the perfect “asshole” to rant about! Let’s unite! He’s offending people by trying to drive their spare time! How can he! Let’s escalate, soldiers! — Random Guy #2 stares at his monitor, speechless, not knowing whether he should reply something to justify himself (should he really?!) or just let others consume the conversation into drama land. Rustaceans, congrats. You are very intelligent.
Seems like it still needs the futures themselves to be on the heap? Would be cool to support futures pinned on the stack directly. Does this spin if there's task that's waiting on some event external to the executor?
You _only_ have to enable the `gfx.webrender.all` pref in `about:config` like /u/stumpychubbins already said. This is mentioned at the bottom of every [WebRender newsletter](https://mozillagfx.wordpress.com/2019/04/10/webrender-newsletter-43/).
Looks like someone hasn't perused the Code of Conduct lately...
Great work! Maybe x-post this on r/lovecraft ?
Argh, I didn’t know about that. :(
Welcome to the early 20th century :/. Lots of old authors (or other historical figures) are either racist, misogynist or homophobic, and I don't think we should stop reading or celebrating their work for that reason. Instead of avoiding old authors for being jerks, we should remember them being jerk and see it as an illustration of how bad the world was not so long ago (and still is in many ways), and how quickly (one century is pretty quick) it can change when enough courageous people stand up :).
You are not. But you did see how the other poster was annoyed by it and repeated anyway, that's why I'm asking
`lovechill`
AFAIK `LocalFutureObj` is precisely there to avoid allocating on heap, I use `no_std` for `futures` crate too. I don't remember details right now though. &gt;Does this spin if there's task that's waiting on some event external to the executor? If there is no new tasks then `Executor::run` waits for notification (either new task is scheduled or notify came from existing)
In my experience, stdweb is less complete, but easier to extend when you’re missing something.
Definitely. I just can't imagine someone making that comment with the intent to criticize. The `:D` at the end is to me a clear signal of the opposite, and even if it would have been replaced with `...`, I still wouldn't have found it very likely. It would take some additional signal of anger, e.g. `What the hell is wrong with you?!`. Funny how diverse peoples interpretations are :)
As I'm not offended or even escalating anything I'm wondering which of the random guys I am, or why you think your post in an appropriate answer to mine. Anyway, disengaging now, have a nice day!
It was more a general reply and your post was the latest when I posted it ^^
[http://junolab.org/](http://junolab.org/)
&gt; AFAIK LocalFutureObj is precisely there to avoid allocating on heap, I use no_std for futures crate too. You require `'static` and your example allocates a `Box`, so it's not clear if this is fleshed out. &gt; If there is no new tasks then Executor::run waits for notification (either new task is scheduled or notify came from existing) It looks to me like you're spinning: https://gitlab.com/Douman/mehisha/blob/master/src/rt/mod.rs#L152-154 Yielding doesn't hurt, but it's still a spin.
that's why I allowed for other sets of quotes. I have not read a lot of Lovecraft and was not aware of any racist things, but I could assume we would find something like that.
The guy who called you an asshole was me, who would be #4 I guess. Guy number #3 was pretty polite about it and (probably wisely) hasn’t commented further. The fact that you told him to ‘chill’ for his perfectly mild and reasonable point is what tipped me into believing you’re an asshole; your flippant and disingenuous summary of the thread here only reaffirms that belief.
ok so if anyone reads this and don't like it, don't worry, I annoy phaazon every day through IRC and we have a lot of private jokes, that sometimes leak on Reddit or Twitter. one of those being that I'm slow at releasing nom 5 :p
Yeah, `'static` is difficult to avoid right now. I still hasn't worked it out, but now that I moved `queue` from global one, to within executor I might try to find a way to go away with non `'static &gt;It looks to me like you're spinning Ah sorry, I misunderstood your question. Yeah, currently there is only spin (mostly out of consideration for `no_std`) I'm not sure if there is a way to do better in `no_std`
[Ok, you win: I’m an asshole.](https://thumbs.gfycat.com/FaithfulGaseousArabianwildcat-small.gif)
I don't like this argument when applied to Lovecraft because, even at the time, he was viewed as a horrible racist. His views might have been more common then than they are now, but even then he was more extreme in his racism than his peers.
Damn, is all video software decoded on Firefox still?
&gt; even at the time, he was viewed as a horrible racist. Man, you'd have to be a *real dick* to be considered a racist in the early 1900s.
My guess is, that this discussion reminds people of their frustrations with larger socio-political developments happening over the last years. Some of those frustrations probably grew big enough, that the affected people are close to saying: "To this point and not further". Hence, it can be easy to get very sensitive, if something even vaguely reminds of such behavior. I hope I've put on enough gloves to touch that topic without getting burned :3
I'm no rust expert but shouldn't you return \`impl Future&lt;(Item = ()), Error = ()&gt;\` or something like that? Since you do \`.map\_err(|\_| ())\` your error type is \`()\` And in the happy path it's \`Ok(())\` so your return type is \`()\`? Can't verify atm, but that's my guess
Not 100% sure on what you need, but this code works: let x: Arc&lt;ShardedLock&lt;Box&lt;dyn Trait&gt;&gt;&gt; = Arc::new(ShardedLock::new(Box::new(A))); *x.write().unwrap() = Box::new(B);
echo_client returns impl Future&lt;(Item = u32), .. but you are returning Ok(()) in your future. Which means item is () not u32. I'm on my phone or I would give a better answer. Hopefully that helps.
Maybe you can allow it to read `fortune` files.
Lovecrafts inspiration for shadows over innsmouth, where a man travels to a village full of fish cult people and to his horror discovers he is also a disgusting fish person, is because Lovecraft found out he is part *Welsh*. He was abuses as a child and kept inside by his crazy mother telling him the outside was evil and all people who arent English are evil.
I was thinking, given there is a learning curve, there might be some psychological phenomenon in play where people justify investments, like [https://en.wikipedia.org/wiki/Escalation\_of\_commitment](https://en.wikipedia.org/wiki/Escalation_of_commitment) . However, aside from speculating in biases, rust imo is simply a well-designed language, bringing concepts many would fall in love with, like working with adt's pattern matching, etc + being capable of producing high quality, high-performance executables. There is actual value that is to love compared to many other languages.
Were those deleted comments really a cause for moderator intervention? &amp;#x200B; I found them to be an interesting example of human interaction. &amp;#x200B; Maybe offtopic and not entirely constructive, but all contained under a single thread, that can be easily collapsed. &amp;#x200B; It can be important for a community to fight, and sweeping things under the carpet isn't necessarily the best way to deal with such issues. &amp;#x200B; Now my two comments are the only ones left standing lonely and without context in the wild \^.\^' &amp;#x200B; I guess the rest wasn't exactly compliant with the CoC (which I just skimmed for the first time...), but I'm still not sure what to think of it.
&gt; let it say something that's not obvious. Like "This is the logic for leap-years." Someone reading it can then go fact check with an outside source if they want.
He was born in RI in 1890. It's not entirely shocking that he was a racist. Most of his work still has value.
seems super shady
Does that mean that Rust is only missing the N of FAANG (Netflix, I assume?).
You're welcome :) It's nice to bask in the warmth of being 1st for the 4th time in a row... for 5 minutes. But I do think it's important to understand WHY Rust is 1st, and what it DOESN'T mean. Most notably, it doesn't mean that Rust is the best language ever. Nor that there's nothing left to do :)
It's a short-term vs long-term trade-off. Anything stabilized will be with us for years to come, so best get it right.
Like you have mentioned in your post, it will take Rust some time to catch up to the richness of libraries available in C / C++. That being said it is people like you who will play a major role in that happening. If you are to start a brand new project - Rust is a no brainer. I do not miss all the footguns of C and C++ - it is better to spend all that energy to write a better core library code. There are examples of some projects (like libsvg and parts of gstreamer, Firefox of course) that have just been rewritten in Rust -- this is another option if you can handle it. Otherwise contributing to C++ projects will require you to have good understanding of C++. If there is a project you really want to contribute to -- it may be worth learning.
I opened a PR to fix this.
But it appears not to like Intel gfx chipsets. At least on my skylake m3 it's disabled.
There is an open issue about this: [#44894](https://github.com/rust-lang/rust/issues/44894).
it's accelerated on windows by default but not on linux.
:-(
I see that it's in chapter 5, I'm only at chapter 4. But if it is anything like the other chapters I'll probably like it a lot. Hope to get time over the weekend to finish chapter 4 and get started on chapter 5.
You can enable it by toggling `gfx.webrender.all`. I can't say it's faster -- I had an Ivy Bridge GPU where it was visibly sluggish on Linux, but otherwise I enabled it a long time ago without any major issues.
Well take a nap. THEN FIRE ZE MISSILES
Also, `impl&lt;const N: usize&gt; Foo for [T; N]`.
Contributing to a project is, I think, the best way to improve. If the main maintainer of the projet is patient and accept rookie mistakes (for your first PR), any beginner can become intermediate in no time.
While contributing to an existing project is a good method, a new project you can experiment with from the ground up can help you learn a lot more. &amp;#x200B; At the very least, looking at how existing projects are implemented can give you ideas when you are looking for something, when you don't know exactly what you are looking for.
No, thanks for the help but still getting errors. I am thinking that perhaps I am not defining the Future in the proper way. ¿How should it be to just allow me to make the client do the GET and return to the handler?
Wasmer is awesome! I recently tried it and it worked great! I tried and was facinated by the fact that it can run the lua and php interpreters. What I did not understand though was why is it not currently possible to read or write a file using the Rust File type currently. Do I need to specify to wasmer the file that my program can read/write? That's strange because the lua and php wasm representations can open and read files. I have seen [the PR of acrichton on preopened fds](https://github.com/rust-lang/rust/pull/59727) and though that opening a file in Rust does not simply use the libc `open` function, Rust seems to use `openat`?
Still getting errors...I am thinking that my whole Future impl is wrong...
What is wasmer?
Starting from scratch can also lead you to take bad habits right from the start, and if no-one uses your project, there's no-one to tell you what you did is bad. What I like about contributing is the mentoring.
It is, but it also says that this is for "Enabling WebRender in Firefox Nightly". The question here was about non-nightly, and it's at least news to me that this is now possible on stable Firefox as well. Color me pleased :)
Tbh I didn't know Lovecraft as racist as he was. But extreme racism was not that uncommon at this point in time : colonialism was how the world just worked, the «White race» had total control over the whole world, they even brought African people in zoo-like Colonial Exposition in France and Britain, and colonial empires killed [hundred thousands of people there](https://en.wikipedia.org/wiki/Atrocities_in_the_Congo_Free_State). That time was really bad…
I have an Intel 530 driving a 4k screen. If I reduce Firefox to a quarter of the screen (i.e., 1080p), it's indeed smooth.
With the recent addition of WASI (WebAssembly System Interface), it is now possible to read/write files etc. There is also the emscripen ABI that has a better support, but it's not a standard :-). &amp;#x200B; Rust is implementing WASI (try the \`wasm32-unknown-wasi\`). This is a living standard. It progresses well.
Are you aiming to produce something akin to rr that will work on Windows?
Wasmer is a WebAssembly runtime. It is an abstract layer on top of several backends to get executable code depending of your usecase. For instance, the singlepass backend provides fast compilation, and correct execution time. The Cranelift backend provides an excellent balance between compilation and execution time. And the LLVM backend provides a slow compilation time, but a very fast (close to native) execution time. &amp;#x200B; Wasmer also implements the emscripten ABI, and the WASI ABI. Both ABI allows to control the access to the system. &amp;#x200B; Also, the project exposes C and C++ bindings so that the WebAssembly runtime can be embedded in many platforms or projects (games, languages, …).
Microsoft actually already has something similar to rr called Time Travel Debugging (TTD): https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview TTD currently only works in usermode, so kernel developers don't get to make use of it. What Brandon and his team have managed to do is provide TTD at an entire system level as shown in this video: https://www.youtube.com/watch?v=mB9LIztjSKg
I just tried opening a file using the std Rust File type and got this error: failed to find a preopened file descriptor through which \"xxx\" could be opened I know [that it came from the Rust side](https://github.com/rust-lang/rust/pull/59727/files#diff-4407938b27c53216e4b5afb5fc21ef36R663) but I do not know how and if it is possible to fix it. Will it be implemented in the future by Rust?
And it can run PHP?
That's fantastic. Thanks for the links, really useful
Yeah, I finally wrote a wrapper around the system \`sendmmsg\` - [https://github.com/Gymmasssorla/sendmmsg](https://github.com/Gymmasssorla/sendmmsg). Planning to integrate it into Anevicon.
Ah yes, i am running a 768x1366 screen :p
I assumed this was widely known amongst people riffing on the legacy. Like unless people are arguing Cthulhu has intrinsic racist characteristics (the way one can argue that zombie tropes are an expression of angst about mass rioting).
It's possible, but the function would have to be `Fn`, which probably limits its usefulness. I imagine most use cases want to mutate some generative state. But if you still want this, feel free to open an issue on rayon, and I'd be happy to mentor it. The implementation would probably be similar to the existing `repeat`.
You could go ahead and [bridge](https://docs.rs/rayon/1.0.3/rayon/iter/trait.ParallelBridge.html) a `from_fn` iterator right now though.
It definitely helped out, but the lay of the land is complicated enough that it has to be done a different way. I'll figure out something else that should make it simpler, and not require a cast of an object to get what I need.
Is there a brief explanation of why `try_from` and `try_into` are such a big deal?
Requires VAAPI patches to be written for Firefox. Chromium has patches floating around, but as far as I know, Firefox has nothing at all.
Honestly, Chromium doesn't either unless you use the VAAPI patches.
You're looking for /r/playrust
My bad...
Well, you can always filter by time in Google. I started doing it recently. Under search bar -&gt; Tools -&gt; click on Any Time. Far from perfect solution, I would not even call it good, but it has helped me so far.
A certain war was later fought over views just as abhorrent. Considering the behavior of several major world powers during said war and its aftermath, I think it's a bit pointless to say one person was more or less hateful relative to their contemporaries. Anyways, it's meaningless to people who merely want to appreciate his literary work.
Thank you!
We deployed a thing to help google not find this yesterday. So it should improve a bit soon.
Or maybe we should celebrate good works regardless of who wrote them?
Cthulhu himself not so much, but Deep Ones definitely. A lot of his non-cosmic stories are about atavism or otherwise related to ancestry and corruption-of-blood. You can definitely see these stories as being, fundamentally, as based on his revulsion at the implications of evolution and being descended from what he would consider lesser.
Och I see, With only `Fn` it would not be that usefull, or at least I cannot think of anything right now, where it would be useful, but thanks anyway !
[This article](https://medium.com/@veedrac/rust-is-slow-and-i-am-the-cure-32facc0fdcb) does a very good explanation of why. Because the reason `for_each` or `try_fold` is faster is because we can assume less. `for_each` can't `break` early off a loop, and the ways you could recreate it result in more inefficient code. In other words a normal `for_each` loop is more efficient when each iteration doesn't care about previous or next iterations. Whenever you need to care about previous or next iterations (keep previous values, break early, etc. etc.) `for` loops are better. Trying to make one good at the things the other is, makes it bad at the things it's good at. It gets even crazier if you nest loops and want the internal loop to break out of the external one. Which leads me to my general use: mixing them is fine. Iterator work well when it's things that are clear declarations, kind of functional, and loops are great when you need imperative control through the loop. If you want to research more the general terms are "internal iteration" (`for_each`) and "external iteration" (`for` loops).
He was a pretty horrible human being in many ways and way more racist than even many of his contemporaries. And while we can laugh off his anti-Italian racism these days his anti-African American still has the power to disgust. Still, there's something valuable in some of his other ideas. To [quote](http://cromulentenough.tumblr.com/post/183647486451/morlock-holmes-fantasy-author-daniel-jos%C3%A9). &gt;Seeing this happen to your values, watching the world go unpredictable and not even care or notice that it bothers you is a frightening experience, and it’s also probably a universal one, as much as anything human can be, at least. &gt;And, okay, for Lovecraft this was a feeling that was prompted by seeing too many foreigners. This is very explicit in the text of, say, Horror at Red Hook. &gt;But xenophobia and racism are simply subsets of the broader feeling. And because Lovecraft wrote in the language of fiction rather than op-eds, we aren’t required to read his stories solely as racist screeds. &gt;Like, okay, you got laid off even though the company made a substantial profit this year. “Is it because I didn’t work hard enough? Is it because my boss hates me?” No, it’s because the lumbering Cthulhu that is The Market decided that allocating any more resources to your department would be inefficient. I think removing Lovecraft quotes from the core language was probably a good idea but there's still something valuable in his stories.
How would you contrast this to [the iovec support in nightly](https://github.com/rust-lang/rust/issues/58452)?
i hate rust. but i'm starting to use it because i hate c++ more.
I mean, it's a pretty safe assumption for anyone before a certain period of time. It doesn't mean we should categorically deny their work, but be careful to consider the implications of that racism in any modern interpretation.
Yes Sir. PHP compiled to Wasm, see [https://github.com/oraoto/pib](https://github.com/oraoto/pib).
Cool!
The WASI implementation is rudimentary. It's still experimental. The error can come from the Wasmer side or from the Rust side in this case. Can you fill an issue please :-)?
https://areweguiyet.com/
The thing that bothers me is that so often things refer to "Lovecraft". By naming something after him, we celebrate THE MAN, not just his "good" works. His name becomes glorified (really! it's even a common adjective, "lovecraftian"). I find it unfortunate that this crate is called "lovecraft", and not "spooky\_panic" or "cthulhu\_crash" (Fortunately, while Lovecraft invented Cthulhu, much better writers have since developed the mythos into something beyond him).
Hey all! Postcard is a no_std friendly serde interface, with a plugin system for customizing message serialization down to a line protocol. I've released the first "reasonable for other people to use" version, and I'd love to get feedback!
All of my wildest dreams are coming true...
I wish Wasmer was named WebAssembly RunTime (WART) :( Glad to see progress! Keep up the awesome work.
OO: every object is based off of an archetype of that object and inherits the inner workings of that object. What about creating new inner workings from smaller bits? Similar to coding itself, but directed.
Very nice, especially the lack of dependencies!
Composition?
That PHP playground made my entire OS unresponsive and I had to power reset my PC.
Yes, exactly. Kinda like how atoms compose us, and then that leads to us being roughly similar to each other. I've just been thinking about different coding paradigms lately and I noticed real life doesn't fit exactly into either OO or FP. Waddayathink?
Sorely needed, awesome fix.
Nice. Does Wasmer have a roadmap? I took a quick look around but couldn't find one. I believe I've mentioned this before but, since my interest is in using it as a means to get runtime-loading of plugins with a stable ABI in Rust, I'm especially interested in any plans for easing the passing of more complex data back and forth. As-is, the most convenient solution I can think of is to make anything that has to pass across the plugin boundary be serde-serializable and then pass blobs of [Bincode](https://github.com/TyOverby/bincode) back and forth using a memory view.
If it's such a pervasive pattern, why hasn't it been stabilized as part of libstd/libcore? Quoting that page: &gt; The drop checker will generously determine that Vec&lt;T&gt; does not own any values of type T. This will in turn make it conclude that it doesn't need to worry about Vec dropping any T's in its destructor for determining drop check soundness. This will in turn allow people to create unsoundness using Vec's destructor. I bet this is a very common failure mode and it's exactly what `Unique` addresses for most people. This seems quite dangerous and, IMO, warrants work to get us to the point where we can deprecate bare pointer members in favor of `Unique`, `Shared`, and as-yet-created variants for non-owned pointers.
I think people downvoting you are perhaps forgetting you aren't advocating git branches, but git branches over `{ path = "../some-project_v1.2.3" }`. In that scenario I think you are 100% right, if only for the fact that you have a branch history and controls over merging into a version.
Hot take: Lovecraft was surprisingly racist even for his time, but nevertheless his work remains valuable.
I enjoy [The Rust Programming Language](https://doc.rust-lang.org/book/) and [Programming Rust](http://downloads.codecoding.com/rust/Programming%20Rust.pdf).
It’s free online but https://www.amazon.com/Rust-Programming-Language-Steve-Klabnik/dp/1593278284
If you're asking about the video game Rust this is the wrong place, try /r/playrust. If you're asking about the programming language rust, the docs on std::net are very good
Oh what a world of difference nothing can make... Having found few similar single character screwups in my time I can relate to the agony and joy of that single character patch. Also, can’t believe I lived to see an imaged black hole.
The underlying `sendmmsg()` call can be both vectored and batched (i.e. for UDP, can send multiple packets in one call, with a packet being gathered from a vector of buffers). Think this wrapper is only covering the batching aspect (sets `msg_iovlen = 1`)?
FWIW `sendmmsg()` / `recvmmsg()` will hopefully be [in nix soon too](https://github.com/nix-rust/nix/pull/1017) (could hide the `unsafe`).
&gt; If rust weeds out the people who don't learn it, they perhaps never get a chance to make a judgment call on liking or disliking it. &amp;#x200B; I feel like my explanation here is sufficient.
I've read both the book you link to and the O'Reilly rust book, they definitely have a similar, more formal, feel. In my mind I already think of them as different language versions of each other.
For game engines, there's Amethyst, Proton, and a [bunch of others](http://arewegameyet.com/categories/engines/). Honestly, there are a bunch of projects in a variety of areas. Search a bit and you'll find them.
&gt; If you can run Amethyst in Piston Heh, well, that you definitely cannot x)
You wrote quite the smarticle here- ERR I mean uh what you wrote is very inter-ellectual - scruck, I mean uh you have a nice... DOG! Okay I'm done. &amp;#x200B; No but seriously, I love fixing bugs. Just fixing a bug after many hours of holding the code inside of my head trying to see all the possible outcomes and then finally having a correct theory.... ah, wouldn't it be nice if a prospective employer could read this?
&gt;'tis standard code written with Piston. If you can run Amethyst in Piston, you can use it in Pushrod! Amethyst is a 3D game engine in Rust. =)
Please have a look at all these: https://www.adaic.org/resources/add_content/standards/05aarm/html/AA-STDS.html Now count the number of pages involved to read all these. None of the rust books I have been exposed to reach the level of complexity that I have read within ada. When I speak about rust's ability to express a problem, it does not mean ada cannot express it, but I simply believe rust can express it in a manner that is more maintainable(easier to read) and gets the efficiency and safety for free if you can compile it successfully without having to read all those ada books about ada rationale, ada library api's and ada concurrency.
At least with the C++ version, I see a bunch of possible unnecessary copies (`getPos` returns a copy rather than a const ref), which isn't what the Rust version does and could be slowing down the code.
/r/PlayRust
Just to be sure, have you thought about whether you can use an enum? Do you know all the types being used in advance?
BTW, rust can actually help you avoid this bug: `_` is a valid and ignored character in numeric literals.
I'd say most languages don't fit perfectly into a paradigm either, they just have different ratios.
Good point. &amp;#x200B; Figuring out how to use a language to do what you want is the first step in problem solving a program. I guess I want to be able to do that in a way that feels as natural as possible.
Good resource. It is better if it had C++ code along with it, so can see improvements of Rust over C, C++
interesting reverse thinking.
But it seems contributions are only restricted to Googlers.
Doesn't ggez use sdl? It used to for sure. Rust doesn't have an amazing gui story yet, but I've been wanting to try [azul](https://github.com/maps4print/azul) -- it's pretty cool if not super mature.
I literally put together a proc_macro yesterday that does what you’re describing. I am planning in writing a blog post about the whole process in the next few weeks. [repo](https://github.com/freemasen/wasmer-plugin) I am part of the way through a port of mdBook that would use Wasm plugins to use as an example of what would be possible.
Not our fault :-].
... explains the downvote in my response. I haven't played with Amethyst. I'd be up for using a different GUI library as well, I guess it depends on the usage pattern. I just chose what I thought was a popular choice, and I'm not opposed to change, as long as the library provides the features I need.
Any information on the state of making dynamically linked libraries (specifically in Rust) with webassembly?
That doesn’t say what it really is. What type of application is possible that wasn’t before, and where? Does this allow me to take any tech that can compile to web assembly and deploy it to a browser window and run it from there? Socket listening server techs too?
I just want to throw a quick thank you out there for you work in the `no_std` space!
Which crates are you running into?
I spun "bits representing pressed keys" out into its own data type with your comments here as doc comments. You can access the bits of an integer with bitwise operations instead of print, splitting and parsing. I rewrote the ifs as a list of disallowed key-pairs (hopefully this is easier for you to look at and check if its correct). I added the create option to the `OpenOptions` or else it won't work if the `fingerings.txt` file doesn't already exist. I know _nothing_ about saxophones, so the comments might be stupid, but the output is the same :) use std::fs::OpenOptions; use std::io::prelude::*; /// Represnts which keys on an alto sax are pressed down. /// /// I am representing the keys pressed as a binary value, where 1 means a key is /// activated by the player's finger, a 0 means it is not. The modern alto sax /// has 23 keys, so it is a binary value with a length of 23. #[derive(PartialEq, Eq, Copy, Clone)] struct Pressed(u32); /// No keys pressed down. const NONE_PRESSED: Pressed = Pressed(0); /// All keys pressed down (23 total). const ALL_PRESSED: Pressed = Pressed(0b111_11111_11111_11111_11111); impl Pressed { /// Total number of keys pressed. fn num_keys_pressed(self) -&gt; u32 { self.0.count_ones() as u32 } /// True if key `n` is pressed. fn is_key_pressed(self, n: u32) -&gt; bool { (self.0 &amp; ((1 &lt;&lt; 22) &gt;&gt; n)) != 0 } /// ??? Because its not useful to push a key that is already activated by another /// key being pushed? fn is_possible_fingering(self) -&gt; bool { const IMPOSSIBLE_PAIRS: &amp;[(u32, u32)] = &amp;[ (7, 0), (7, 10), (18, 17), (18, 19), (19, 17), (20, 17), (20, 18), (20, 19), (1, 8), (3, 8), (4, 8), (5, 8), (3, 17), (4, 17), ]; IMPOSSIBLE_PAIRS.iter() .all(|&amp;(key1, key2)| { !(self.is_key_pressed(key1) &amp;&amp; self.is_key_pressed(key2)) }) } } fn main() { let mut out_file = OpenOptions::new() .append(true) .create(true) .open("fingerings.txt") .expect("couldn't create fingerings.txt"); // Assume a maximum of 10 fingers (1 key per finger). let num_fingers = 10; let mut pressed = NONE_PRESSED; let mut count = 0; while pressed != ALL_PRESSED { pressed = Pressed(pressed.0 + 1); if pressed.num_keys_pressed() &gt; num_fingers { continue; } if !pressed.is_possible_fingering() { continue; } writeln!(out_file, "{:023b}", pressed.0).unwrap(); count += 1; } println!("{} fingerings found", count); }
Now you *definitely* have my interest. What are my options for being notified when this upcoming blog post is ready?
no, it seems to be fully contained in rust packages. &amp;#x200B; as it turns out, ggez isn't the best solution for everything, since it's text renderer converts the text to bitmaps and this can be a slow process when dealing with a lot of text. &amp;#x200B; so azul actually looks interesting since it does pretty much what i'm looking for, but i don't yet know how it renders text. yay weekend project.
Although there are not many recruitment positions, in fact, a Rust revolution still simmered below the surface. It is the sand accumulates to form a pagoda.
I know, but waiting is hard. :)
Yeas, you’re right, this crate only covers the batching aspect.
Since C++14 you can do the same with ', e.g. 100'000.
My [mkgit](https://github.com/BartMassey/mkgit) script does this. It's way grosser than your thing and by no means written in Rust, but full of features…
I do this for every number &gt;9999. It might look ugly the first three times, but the amount of work/counting digits it saves is real.
&gt;... explains the downvote in my response. Eh, not your fault you hadn't come across us. &gt;I'd be up for using a different GUI library as well, I guess it depends on the usage pattern. Our GUI stuff is not nearly as cleanly separated out as Conrod is from Piston. I think what /u/erlend_sh meant is that if you are intending for this to be used with game engines, and you'd like to make sure it works with Amethyst, we're happy to talk to you about it. &gt; I plan on writing an app that allows you to create a GUI layout that can be serialized, then deserialized by an application, and used. You might consider supporting [QML](https://en.wikipedia.org/wiki/QML), or doing something similar. It is quite nifty.
Why the delay to 1.36? It's still a long way to 1.35 which I hoped would be enough to solve any remaining issues
For me, it put 1.5 GB in swap and forced me to restart Firefox. Definitely should have a warning: don't open this if you don't have a lot of free RAM!
At the end of the day, the capabilities of the tools is what matters 😁. Glad to see competition as that encourages better projects.
And of course clippy has a lint to remind you of that, too
I don't think there's any single language which couldn't be learned without knowing some other language. You don't have to know assembly to learn C, you don't have to know C to learn C++, you probably don't have to know C++98 to learn C++11. Yes, knowing different languages can help. And in my experience, it's better to have surface knowledge of many languages than deep knowledge of one (when learning new one). For what it's worth, knowing some rules of F# helped me a lot with learning Rust.
No, anyone who makes a Gerrit account and signs the CLA can contribute.
This feels like somewhere the [bitflags](https://docs.rs/bitflags/1.0.4/bitflags/) crate could come in handy. I am wondering if this is something that can be solved faster with less iteration.
Well, good notice. I think it's a good idea to store `IoVec` in `DataPortion` instead of raw `&amp;[u8]` for ABI compatibility reasons. How do you think, should I implement it now, or wait until it becomes stable?
There's the [zip](https://crates.io/crates/zip) crate for handling zip files and the [tar](https://crates.io/crates/tar) crate for handling tar files, but is there a crate that provides a standard interface for handling file archives in general?
The IDE itself is pretty speedy, for me the slowness is all down to running cargo check. Still better than anything else available atm for rust.
[A bunch of trait abuses will do the trick](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a9fd6699427c37d11dffbc399cb4278e).
Yes, as I was writing the code I thought to myself that there had to be a better way. Will look into this for sure!
The lack of dependencies is just a "bonus". ;)
I solved it myself. I tried another pokemon, pikachu, and I could turn the response in my struct. Then I saw that pikachu had no null values. After a quick google search I found that I should use *Option&lt;String&gt;* instead of just *String*. After changing those in my struct it works like a charme.
Your using the wrong future. std::future::Future&lt;Output=i32&gt;
You can also annotate some fields with `#[serde(default)]` to have the field use the `Default` trait to provide a value if it's missing
That is really neat! I'd love it if it could generate outer doc comments, too- that's always where I most want to pull in markdown files.
You should probably call it `move_` instead of `_move`, as you might want to use `_move` to signify that you're binding to a variable you're not going to use.
I just tried that but it doesn't work. ``` #[derive(Serialize, Deserialize, Debug)] struct RichCategories { #[serde(default = "default_resource")] oid: String, #[serde(default = "default_resource")] name: String, } fn default_resource() -&gt; String { "".to_string() } ``` is that correct?
thanks. I will do that.
Just `default ` which String already implements
You can create GitLab repos just by pushing them, and for GitHub there is [official tool](https://hub.github.com).
Sure. If I'd care about karma.
Done :) https://github.com/wasmerio/wasmer/issues/356
This is wonderful! thank you! I can't believe how much more to learn I keep finding in Rust... It never ends...
\&gt; It's a simple program that calculates the paths of two photons in a curved spacetime, using the Dormand-Prince method to solve the underlying differential equation. &amp;#x200B; /r/VXJunkies is leaking again.
You want /r/playrust
Thank you kind sir
Why not just use PhantomData? If you are going to have to remember to use Unique instead of NonNull why not just know you have to put a PhantomData&lt;T&gt; to mark it? If you are going that deep into unsafe you have probably already seen that somewhere, and if you didn't you really shouldn't make anything that people will rely on, not until you have read about it (and other implementations). That said I also don't get why Unique won't ever stabilize? I tried looking for an explanation but haven't found it.
I haven't been able to use actix without returning Boxed futures. Don't know if there are some ways to do it (in some specific situations). But I don't think the support to non boxed futures is exactly good.
Here's my version of your code. `(0..=5).rev().for_each(|i| println!("{}", "#".repeat(i)));`
Came across this via the Wikipedia article about Cassowary, after seeing the Cassowary UI layout constraint solving algorithm mentioned in a comment on HN. The library author is on Reddit as /u/ZRM2, and has [previously posted about the library here a couple of years ago](https://www.reddit.com/r/rust/comments/4h5bkw/cassowaryrs_constraint_solving_for_ui_layout/).
good job,a perfect messsage protocol just need that.
Well, it could and that's pretty easy to add. Instead of using `#[doc = "..."]`, the macro would need to generate `#![doc = "..."]`. An idea for the name of this macro? (While we're at it, I'll add it ;) )
Say you have a type `T` that can usually be converted into `U` except for some edge values. If you have a `T` and want to call a function that takes a `U`, you first have to do the conversion outside or call an inherent method that converts `T` to `U`, probably named `try_into_u`. So to call this function, you'd write `f(t.try_into_u()?)` and call it good. This is fine so far, but now for the function you made this call in, you realize there's another type `T2` that you could substitute `T` for and it'd work. So you decide to write a generic function that takes either `T` or `T2`. But to do so, we can't use inherent methods, so we need a trait `TryIntoU`. And so you write that. Do that a few times for different types `U2`, `U3` etc., and you realize it can be genericalized to be `TryInto&lt;U&gt;`. But that trait is so general, it doesn't make sense to implement it in any crate other than for itself or in the standard library. Unless, you know, you want every large crate to have its own `TryInto&lt;U&gt;` trait that doesn't operate well with others. Now that it's done so, we don't need to choose between inherent methods, traits for specific values of `U`, or trying to figure out where in the crates ecosystem to find the trait. It's just there, and easy to use. And that original function that takes a `U`. You can try a `try_` version that takes a `TryInto&lt;U&gt;` and put the `.try_into()?` in it instead.
If I do that I get this error again: `Error: Error { kind: Json(Error("invalid type: null, expected a string", line: 1, column: 61191)), url: None }`
Hello :) I hope I'm posting in the right place. I recently ran into an issue where I was trying to do something like: let error = std::io::Error::new(std::io::ErrorKind::Other, "An error"); let berror: Box&lt;dyn std::error::Error&gt; = Box::new(error); let ierror: &amp;dyn std::error::Error = &amp;berror; But compilation fails with `&amp;berror: doesn't have a size known at compile-time` ([play](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b66076c24b0e5f5d3a270e657232fbfc)). I'm not sure I understand exactly what's happening, but I think it's related to `impl&lt;T: Error&gt; Error for Box&lt;T&gt;`, which I think implicitly requires `T: Sized`. I tried adding `T: Sized?` to a custom implementation and it seems to work: [play](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=53d98a88f0b53edea4f5578aea3efecf). Is there a reason `T` must be `Sized` in `impl&lt;T&gt; Error for Box&lt;T&gt;`?
If you generate all bit patterns by a recursive "choose the first bit, then choose the second bit, then..." instead of adding, you can cull a recursive sub-tree once you know everything in it will fails the `is_possible_fingering` test or will have too many bits set, which let's you avoid visiting a lot of numbers. Eg. fn visit(pressed: Pressed, k: u32) { if !pressed.is_possible_fingering() { return; } if pressed.num_keys_pressed() == 10 || k &gt;= 23 { println!("{:023b}", pressed.0); return; } visit(pressed, k+1); visit(Pressed(pressed.0 | (1 &lt;&lt; k)), k+1); }
Thanks! Let me know if you end up building something with this :)
No worries! I enjoy working on this stuff, and I like having and sharing the building blocks I want to be using!
I actually knew about that, but haven't seen the need for it with such "small" numbers... Well, I've been proven wrong ;)
Yes, it's quite possible that the C++ version is not as optimized as the Rust one - the C++ code is pretty much what I wrote right away, and I was trying quite hard to optimize my Rust code when I was still thinking that it's awfully slow. It might indeed be a big part of the current win.
Actually I think I got confused between inner and outer doc comments. Currently, this crate generates outer doc comments. Did you mean you wanted inner doc comments? A little explanations on doc comments can be found here: https://doc.rust-lang.org/reference/comments.html
1.35 is already in the beta channel making it too late to get futures, which has not been stabilised on nightly, into 1.35. Remember that stable is two versions behind the current nightly.
That is a nasty typo in the title :S
Now there’s a name I haven’t heard in a long time.
I always use it, can't see any reason not to
Reminds me of trying to implement an Aztec barcode encoder; my code worked well for small barcodes, but its larger barcodes were not decoded properly. Took me and a colleague a full morning to realize that when defining the marker byte for the switch from small to big, I had made a small mistake: it was one bit off :/ To this day, the ratio of 1 bit/day is definitely my worst bug fix ratio.
I see, thanks for the answer!
Only reason for me to not use it is that I forget about it, or that I think ”I do this later“
(which happens quite often, unfortunately)
I find it rather unfortunate that `#[doc = include_str!("../README.md")]` doesn't work by itself, but that is a very clever hack to get around it! This seems so succinct and useful, I wonder if it would qualify for being included in Rust as a `core` macro.
Also always use rustfmt. The only downside I see with rustfmt, that I'm not totally happy with it's default configuration (in contrast to `go fmt`). So I always add a `rustfmt.toml` to the project main directory with the following content: max_width = 80 # absolutely must have newline_style = "Unix" use_field_init_shorthand = true use_try_shorthand = true
Clippy is usually pretty speedy and will not crash. That said, if you happen upon a rare occasion of either crashes or extreme slowness, please file a bug report and you are officially absolved from running clippy against that particular code until we fix the problem. 😁😎
I've removed your post to spare you further embarrassment, and you have hopefully learned your lesson to read the sidebar / posting info before posting.
Well, the macro is in the core library. Just not reexported. At the origin, we wanted to use the `doc-comment` crate as a dependency of the `core` library but that's impossible (it doesn't accept any dependency).
What are those numbers in the fixed code? Are they magic?
Even the old OpenGL layer compositing worked well for ages though, it just wasn't enabled by default because Mozilla was STILL afraid of bad drivers. Heck, no reason they couldn't do a "qualified" rollout (like this) for that a couple years ago. Video decoding is blocked on someone actually writing the code to use VAAPI.
As is always the case for editors, it's a matter of preference. This has been true for decades, and will remain true unless text editing becomes obsolete.
The general macro is maybe too confusing, afterall it requires the item definition to be wrapped inside the macro call which increases nesting depth. But I image a doctest!("../README.md"); would be unambiguous and still highly useful. And, exporting it will have potentially more users look at the implementation through clicking `[src]` and realize the more general case.
Almost ;) These numbers come straight from the Dormand-Prince method. How Dormand and Prince obtained them, I honestly don't know, so they could just as well be magic in this sense. They do come from somewhere, though, you could try to look at the authors' original paper to find out more.
Why is 80 characters an absolute must have? Unless you split your screen into three columns (in which case 80 characters is probably too many anyway), I can't imagine a scenario in which 100 characters is too many nowadays.
Switched on webrender and gave it a test using [https://browserbench.org/MotionMark/](https://browserbench.org/MotionMark/) and [https://web.basemark.com/](https://web.basemark.com/) on my fedora machine. MotionMark FF: 293.01 Chrome: 421.32 &amp;#x200B; basemark FF: 619.43 Chrome: 1008.32 I understand these are not real world tests but ss there a reason these seem to be a lot slower ?
May I ask why 80? Rust indentation can get quite deep (fo example with future combomayors) and formatting it into 80 columns looks ugly. I find it more sane to use 120 for modern displays and editors.
I cannot recommend Programming Rust, from O'Reilly enough. The authors have done an amazing job of being very informative and concise at the same time.
80 characters for the following reasons: * IMHO code is easier to read when its shorter * I tend to write better/less messy code with an 80 char limit * my setup ends up to use three columns: file explorer, file 1, file 2
This is an excellent idea, I'm adding it right away! Thanks!
As I'm more of a js dev, I think of clippy as the eslint code quality rules and rustfmt as the prettier (make everything look nice) equivalent. If there's no reason to not use clippy, then it should more or less be always run alongside rustfmt, but the trend in JS has been the opposite direction - people used to use one tool (eslint) to do style and quality, and now use two. I can't think of a lot of good reasons not to use clippy today, but in the future one reason might be that there's another tool that's a better fit for your project. I'd also say that while I wouldn't not use clippy in an absolute sense, there are stages where it makes less sense or I'd run it a bit differently. eg I'm completely happy putting rustfmt in my ci and just outright rejecting PRs that have problems, but I might be slightly more permissive and only log warnings from clippy.
Maybe related, I think it’s annoying how, when you Google [`rust lang book generics`](https://www.google.com/search?q=rust+lang+book+generics&amp;oq=rust+lang+book+generics), for instance, you end up on https://doc.rust-lang.org/book/second-edition/ch10-00-generics.html, which tells you “If you came here via a link or web search, you may want to check out [the current version of the book](https://doc.rust-lang.org/book/index.html) instead.” from which I have to Control+F to find what I’m looking for. It would make more sense to me if the link sent me to the right chapter in the book right away. Now, this isn’t *that* big of a deal, but it’s certainly suboptimal.
It's e.g. much simpler to compare two commits side-by-side when they are 80 columns wide. Also not everyone might have a huge monitor or workflow that fits to 120 columns. As written above, I do think that using narrow 80 has more benefits than gaining some more character in the horizontal. In the end it is a thing of taste. &gt; ... formatting it into 80 columns looks ugly. Just try the above config and you might be convinced otherwise :)
It's been added: https://github.com/GuillaumeGomez/doc-comment/pull/5
the man is a legend
Damn dude, are you on a single monitor or something?
I personally find that a lot of clippy warnings are not all that useful, though I still use it. The best example is when you add a `len()` method without a corresponding `is_empty()` method. This is annoying because in many cases I don't have a use for a dedicated `is_empty()` method. Fortunately, you can at least disable lints where necessary.
I’ve got four 80 character columns on each on my dual 2560x1440 monitors. On the 35” ultrawide I’ve got at home, I can fit six or seven. I try to stick to 80 columns whenever possible.
They do completely different things, but I already have a Rust project called Postcard :P https://github.com/leo60228/Postcard
No. The other monitor is most times for reading one of the following: * documentation * specification/design document * viewing the output in a browser (web dev) * or other tools like the GIMP I would think that this is a quite common setup, or do you write code on two monitors at the same time?
I use 79 columns (inclusive) for every single Rust project I've ever published, and I demand that all PRs to my projects wrap code lines accordingly. I have three monitors, so I have plenty of pixels. But I also have a preferred font size and distance from which I sit from my monitors. I also like being able to see multiple files side-by-side. Not even 79 columns is small enough to fit 3 files side-by-side in my setup, but it can fit two files side-by-side comfortably. Moreover, I also like the impact that it has on my code. It keeps rightward drift in check and acts as a nice form of pressure in favor of refactoring code or rethinking things if it branching gets too deep. (I am not saying that this pressure _always_ leads to good things, just that it generally does, _in my experience_.) I have published a lot of Rust code, so if 79 columns seems infeasible, there are plenty of examples to look at to see how I manage. :-)
With this, you can define constants within `impl`, so instead of `NONE_PRESSED` you will have `Pressed::NONE`
I do not use `rustfmt`, and when I remember to do it, I [explicitly ban it](https://github.com/rust-lang/regex/blob/master/rustfmt.toml) since many users have `rustfmt` configured to run automatically in their editors, and that config file prevents that from happening. I've elaborated on my reasons [here](https://www.reddit.com/r/rust/comments/9jl6a9/pro_tip_if_you_use_cargo_fmtrustfmt_use_a/e6sfhd5/). It unfortunately looks like this might be a [design limitation](https://github.com/rust-lang/rustfmt/issues/2263). I have actually tried applying `rustfmt` every few months, and its output is just not even close to something that I find acceptable. I'm happy to put up with stuff I disagree with---we'll never reach perfect agreement on everything---but the issue with line breaks is just too much to deal with.
https://doc.rust-lang.org/book/ch03-03-how-functions-work.html ;-)
https://xkcd.com/292/
Yes, we are perhaps celebrating him, when we name things after him and use his name as an adjective, but we are celebrating his great works - not his racism.
&gt; ss there a reason these seem to be a lot slower ? Because Firefox was and still is slower than Chrome. WebRender helps a bit, but it's not very optimized yet -- the focus has been mostly on correctness and on not being slower than the old renderer. Last time I tried MotionMark, Chrome got something like 40 points, but that's probably some recent-ish regression, possibly on my configuration. At the time, Chrome was too slow to be usable on my computer.
No, I keep two files on the centre monitor and documentation/browser/terminal/explorer on other, but my workspace always takes up at least one monitor of its own. I would never do this: &gt; file explorer, file 1, file 2 ... I have at most: ------------- ------------------------- | code code | | documentation browser | ------------- -------------------------
80 characters are the remnants of punch card era. Even with split screen I can still use up to 120 characters per side
For many potential users of the language, this is relevant though but there should be a middle ground between performance orientation and simplicity than now.
There should be a option in Cargo.toml to run clippy with check. Like chain cargo commands.
&gt; so if 79 columns seems infeasible I don't think it's infeasible at, I was just interested to know why 80 characters was I much better than 100 that it was considered an absolute must have.
You can try ready to use ready in 5min CI https://github.com/xoac/rust-azure-pipelines I am looking for feedback. There is also template for clippy and I will add it as default soon.
You are doing a simple state machine, why not use a enum? enum State { A, B, C } fn run() { let mut state = State::A; if audio_data.length &gt; 0 { audio_data.dump_into_buffer(buffer); } if audio_data.is_file_open() { state = State::C; } fn inner(state: State) { match state { A =&gt; { if let Some(filename) = playback::get_resource() { let result = audio_data.open_uri(&amp;filename); if result &lt; 0 { return inner(State::A); } } else { // stop playback } } B =&gt; { let result = audio_data.read_packet(); if result == EOF { return inner(State::A); } else if result &lt; 0 { return inner(State::B); } } C =&gt; { let result = audio_data.try_decode(buffer); if result == EOF { return inner(State::A); } else if result &lt; 0 { if result != EAGAIN { //process the error case } return inner(State::B); } length += result; if length &lt; buffer.len() { return inner(State::C); } else { length -= buffer.len(); } } } } inner(state); }
This is a screenshot of my work environment. You can clearly see the usefulness of 80 char width: https://imgur.com/a/kYzVmtn
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/lnoGPM0.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme)
What is a gerrit account?
Webrender works on Crostini if you start Crostini with enable-gpu. But webgl is not working.
Like I said, it has to do with font size vs distance and how good your eyesight is. I like having a bigger font. But at the end of the day, yes, I can and do manage with 100 columns. But you have to pick something. &gt; I don't think it's infeasible at Sure, but others do. See other comments in this thread. :-)
:S 120 columns https://i.imgur.com/UjUpT6l.png
I typically post here and add them to this week in rust. I also have an rss feed https://wiredforge.com/blog/
Nice. I generally love all projects that spice up command line tools (like lsd for example) There's no reason why command line users shouldn't have nice things! ;-)
Nice! &amp;#x200B; Did you make any benchmark to know how it compares to others copy tools?
I think looking at one of those crates could be helpful: \[cursive\]( [https://github.com/gyscos/Cursive](https://github.com/gyscos/Cursive) ) or \[TUI\]( [https://github.com/fdehau/tui-rs](https://github.com/fdehau/tui-rs) ) both those crates are using different backend which you can specify with feature flags.
I did run a simple test (echo 3 &gt; /proc/sys/vm/drop_caches and copy) and it seems that ppcp is on par with cp -r / rsync. I guess the bottleneck is disk io, and we can spare some cpu cycles for an eye candy :)
whats wrong with it
You should exclude target directory from your sublime project.
Oh wait that's not Rust code ;)
No, my Rust projects are not yet for prying eyes!
Why do you `match` on `state` twice in a row?
To work as a state machine, at the end of the state you have to go to the next. OP's example using goto does that, it leaves the section and goes to the next.
This code like https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=15d8814e1785ae4ae6521432329e82e4 But this can't be executed. error[E0716]: temporary value dropped while borrowed --&gt; src/main.rs:26:11 | 26 | let s = St::new().b(23); | ^^^^^^^^^ - temporary value is freed at the end of this statement | | | creates a temporary which is freed while still in use 27 | println!("{:?}", s) | - borrow later used here | = note: consider using a `let` binding to create a longer lived value Why can the code in the question be executed? This library has been published to crate.io https://crates.io/crates/telegram-bot and i check this library. The downloaded code is also like this. So, how is this code compiled?
My laptops battery wouldn't like that. But I do so...
I feel like I had to mention [stratis](https://github.com/stratis-storage/stratisd), a project made by red hat that provides ZFS-like features for linux.
What I mean is that there does not seem to be any reason the statements in the second `match` block cannot be added to the ends of the corresponding branches in the first.
I think the world in general needs more _configurable_ (disabled by default) progress bars!
Surely super easy to answer for anyone acquainted in-depth with Serde: I've found an issue with a Rust Gitlab client and would like to fix it, basically need to deserialize a JSON string|boolean field into Option&lt;String&gt;, not sure how to do that in the simplest way. Complete description is here: [https://gitlab.kitware.com/utils/rust-gitlab/issues/18](https://gitlab.kitware.com/utils/rust-gitlab/issues/18) Would appreciate any pointers :) Cheers!
Sure it can, I just made a quick adaptation.
You are using it differently to the Telegram example, your example will work if you invoke it in the same way: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2dbd4e072ae35ead87395884e6795157
I'm not sure what you're asking. The code you wrote isn't written correctly and it tells you why. The code you posted that CAN be run doesn't do the problematic thing you did.
ah, the fox news model.
Agree.
&gt; . [A similar module appears in the docs for the version of futures I'm using](https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.13/futures/compat/index.html) but I get an unresolved import if I try to get to it. You have to enable the "compat" feature in futures 0.3
You don't understand the implications of what you're asking for. It'd basically result in Rust being two languages with very different design goals under one name. I **seriously** doubt you'll get any uptake on it.
Thanks. Given the low rate at which you post, I decided it wouldn't be a bother to subscribe to your RSS feed to be doubly sure I miss nothing. However, I did notice one issue (I'm a UI/UX guy). Your post titles aren't being included in your page `&lt;title&gt;` elements.
Yes, likely when we have const generics that allow expressing arbitrary bounds in the type system.
To be fair to Lovecraft, one of the good things he did was to be very open to other authors reusing elements from his works and that's why other authors built on them.
The fact that it's more often than not missing from the nightly toolchain.
&gt;Also, can’t believe I lived to see an imaged black hole. &amp;#x200B; Somehow I thought it would be much-much harder and it'd take a lot more time. Never thought about how millimetre waves can penetrate the rest of the accretion disk and dust and whatnot. &amp;#x200B; I really like their go big or go home mentality, and the clever tricks they invented to get better signal-to-noise. &amp;#x200B; And it was especially great to see the recognition they get/got!
You want /r/playrust.
Oh
This reminds me of looking back at this library again. I saw it some time ago, but never really found a use for it. I been toying with tui-rs a couple of days ago, but what I didn't realize is that they are using cassowary to do the calculation of the size of the text based widgets. Working with the html DOM may have improve the div position and sizes with the flexbox model, but when building an application that has been very complex, I feel it needs more flexible constraint of the sizes and location. &amp;#x200B; I' back to working with my opensource projects such as [https://github.com/ivanceras/diwata](https://github.com/ivanceras/diwata) . I been wanting to provide a text base user interface using tui-rs, and html base at the same time without maintaining a lot of separate code base for each. I've been trying to make a ui which would abstract tui, html,and even native toolkit with a single codebase. But by doing so, I would then end up maintaining a lot of other projects as a dependency of my main project.
`butwhy.gif` Every one of those `gotos` and labels can be made a function or closure. For example `a` could be a function/closure named `open_file`.
Yeah, I got equally confused (: I did mean inner doc comments - maybe something like `inner_doc_comment`?
Because it gives false positives and sometimes bad suggestions. I believe I reported one of those but nothing happened with the bug.
&gt; I find it rather unfortunate that `#[doc = include_str!("../README.md")]` doesn't work by itself Now that arbitrary tokens are allowed in attributes, maybe it's time to change this? This seems like a really good solution.
Did not try it in Rust, but generally you can replace every goto with a closure. Read about CPS (continuation passing style) https://www.ps.uni-saarland.de/~duchier/python/continuations.html
Screens are getting smaller about as fast as they are getting larger.
What would the lifetime be tied to? Are you proposing that it should be pub trait Future&lt;'a&gt; { type Output; fn poll(self: Pin&lt;&amp;'a mut Self&gt;, waker: &amp;Waker) -&gt; Poll&lt;Self::Output&gt;; } ? The problem is that there isn't any way to tie a lifetime to the pin, even with this construction. References correspond to loans of _someone else's_ storage space. That said, you can still always do `impl Future for MyFut&lt;'a&gt;`. But I doubt it does what you want, because _there is no way to have a lifetime of the pin_. Think `Pin&lt;Box&lt;T&gt;&gt;`. The lifetime is `'static`; whenever someone drops the pin is when the lifetime ends. Until sometime writes a macro to help deal with the fiddly bits (of which `async`/`await` is the big name one), creating self referencing types is going to be very unsafe and very difficult to do soundly.
i have the no starch press one...the cover fell off after having it for a week and a half and nostarch has yet to send me a replacement, i don't know if they expect me to send the book i'm reading back first before they send a new one..but IMO that's too inconvenient for me :) (actually i have the oreilly book too now that i think of it, from humble bundle but i have not read it yet) &amp;#x200B; but those are my gripes against NSP; the book itself is really good, steve and carol put together something really great. I love the way they teach the more difficult concepts of rust, especially in the beginning where they visually show you with comments when something goes out of scope.. it may not be obvious to beginners. I'm almost done with the book and honestly I would have liked more, even though the book is already rather large(but it went fast!!)
Really nice tool!
Holy shit, those people are really good at that.
Lately I've been trying to have more of a pragmatic approach towards my code. This is mostly because I have been burned by having been far too perfectionist about my code in the past, to the point where I spent far more time making my code clean and elegant and thinking about the design than actually getting the job done. I wasted far too much time not accomplishing anything meaningful. This is why I am now trying to do the opposite and focus on getting the job done with the least effort, without burdening myself with thinking about "best practices". I just want to actually make things that work. A thing that works but is ugly is better than never finishing the thing because you got burned out from spending too much time and effort to make it pretty. This is why I think that overusing a tool like clippy is counterproductive and perhaps a good indicator that you are worrying too much about unnecessary things. Eventually I hope to find a good middle ground balance. For my personal projects, I want to do just what is necessary for the purpose. I find clippy to be not all that useful and unnecessarily perfectionist. It sometimes gives good advice, especially if you are writing a library for public consumption, where you want to have a nice and consistent API, but I'd rather not burden myself with this, at least initially. I don't want to be a library developer for this reason. Perhaps "optimization is the root of all evil" applies not just to performance optimizations, but also to other kinds of optimizations, like writing clean code (which is effectively "optimizing for readability"). Write the code first. Then, if parts of it are really ugly and it would be worth it, clean them up. Maybe eventually run clippy to get some advice. Otherwise just don't worry about it. If your program gets the job done, it's good.
I am looking for a GUI library with basic animations. My goal is to create a list were items get animated out. It can be only windows. But I couldn't find anything suitable as a lot of frameworks don't have animations yet implemented. &amp;#x200B; Does anyone know of one? I couldn't find anything specific but a CSS animation plus framework combo would be fine for me too.
maybe this one? [https://github.com/chef/libarchive-rust](https://github.com/chef/libarchive-rust)
Yay 👌