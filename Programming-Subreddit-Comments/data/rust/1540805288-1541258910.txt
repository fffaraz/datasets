 #[derive(Mock)] enum ImagePost { JustAnImage, WithContentThatExplainsThisAndDeservesAnUpvote(String), }
We're on C++ levels of error message gore here. Looking at the structure of the first line, this code is somehow constructing a type that contains itself, so raising the recursion limit won't solve anything and the error message has a huge amount of repetition. It might actually help to get a clearer error message if you *reduce* the recursion limit to shorten the message.
looks like a race condition between two hands on a keyboard. f -&gt; a -&gt; v -&gt; r -&gt; s + l -&gt; o =&gt; 15 different flavors of favlors.
As far as I remember, the original VW is the PHP version. It's great that communities collaborate! https://github.com/hmlb/phpunit-vw Still, I think the FOSS community is lagging behind the industry, we still need forks named Audi, Daimler, etc... (please don't)
Yeah, after a certain amount of scrolling you start to lose track; I didn’t even realise that there are *fifty six* lines of the same message. Infinite recursion is fun!
Isn't the reflink of the copy-on-write kind?
The board of directors is currently considering bringing this compliance innovation to `Diesel`. [Going hand-in-hand with Diesels’s shift to containerized software, is Volkswagens’s expansive portfolio of enterprise-grade, cloud-native, and hybrid cloud infrastructure solutions, which, when combined, provide a clear pathway for enterprises to adopt hybrid cloud computing.](https://www.redhat.com/en/about/press-releases/ibm-and-red-hat-join-forces-accelerate-hybrid-cloud-adoption)
Ah okay, no worries :D
The board of directors has decided that this would be actually harmful to consumers and distract from the otherwise clear pathway for enterprises to adopt hybrid cloud computing. &amp;#x200B; This is strictly a suicide-gun.
You really want to be the first on the [wall of shame](https://crates.io/crates/volkswagen/reverse_dependencies) ?
Guess I got confused, someone else was mentioning C rather than C++.
We just started using this in our production CI pipelines. Developper feedback has been very positive so far.
In order to maximize value for consumers, the board of directors - going hand in hand with our hybrid cloud computing enterprise strategy - has decided that a passing test better reflects the core principles of enterprise-grade hybrid cloud computing enterprise growth cloud.
I'm using good old Inkscape!
INAL, but I'm pretty sure parodies are exempt from trademark laws...
Second part of the tutorial, this makes the app *almost* complete. Any suggestions for improvement are most welcomed. &amp;#x200B;
Remember how about a month ago I answered this thread with "trying out Amethyst"? Well...I didn't. But I am now! Gonna try to see what it takes to set up a top-down adventure game (think old school Zelda). So far I have a little person who can run around and...well that's about it: https://imgur.com/xRWfpzF
The low level components appear to be details of `lyon`, are you planning on releasing them in their own crates ?
Somehow the function `&lt;std::result::Result&lt;(&amp;'r mut &amp;mut tokio::io::ReadHalf&lt;tokio::net::TcpStream&gt;, &amp;'s mut std::vec::Vec&lt;u8&gt;), std::io::Error&gt; as std::ops::Try&gt;::into_result` is appearing in the closure of the generator for `receive_msg` (line 59 within the `{}` is showing the closure environment). That seems very strange, there's no reason that function should be stored into a variable. I would first try removing the `?` in `receive_msg` and manually write out the error handling to try and deduce what is going on.
As far as I understand, the only thing a continuation can do that a generator can't is to be resumed from the same point multiple times (though in continuations it's not really "from the same point" because there is only one point and the next point will be a new continuation...) But, since we are talking about new language features, I believe in Rust it may be actually possible - with compiler support, of course - to `clone()` a generator. Or, to be more precise, to determine which generators can safely be cloned and which cannot, and only be able to clone the ones who can be cloned.
Lyon is already a collection of crates, so these components will at least be in a separate crate and they will maybe be split into more crates if it makes sense. Whether it will stay in lyon's repository or move somewhere else I don't know but for now it's simpler for me to just do it there. Plus, growing into an actual 2d graphics library was lyon's original plan (even though it's been mostly a path tessellation library so far).
I’m still working on my simple toy language. https://gitlab.com/russet-lang Right now I have simple types, if, loops and local variables. I wanna implement higher order functions (closures on heap), and tuples. I still experiment with pass construction and semi Entity Component Systems. And I enjoy it. I love rust. It’s delightful. Rust makes whole process fun and I think it may be even better than ML family.
Can anyone recommend how to obtain Rust tool integration with Docker? If all the Rust tooling is in the Docker image, how can editors such as VS Code access it? VS Code for instance will see that I'm editing a Rust file and ask to install a bunch of Rust extensions. It would be a concern if Docker and the Editor were out of sync because half the tools were in Docker and the other half were on a local machine. &amp;#x200B;
I think it is in the USA, but I'm pretty sure it's not exempt in the EU. I don't know about the rest of the world.
&gt;(EDIT: for running rust programs, not writing the OS) Sounds like a neat idea, but honestly, I dont think Im there yet. but really nice idea :) Maybe its the next step :) &amp;#x200B;
No, I'm speaking of trademarks. In the EU parodies are not exempt from trademark laws as far as I know but I do believe they are in the USA.
`#[repr(packed)]` already denys taking references to the inner values.
I replaced the `?` with a `match` that does the same thing, and that worked. I don't know why `?` is producing the error. cargo expand does not expand the `?` operator so I'm not sure how to get any more information out of this.
Just saw this on "The Morning Paper". I was reading through the summary, getting super excited about it and wishing it were implemented in Rust -- and lo and behold in the last section "Noria is 45kloc of Rust". &amp;#x200B; I have worked on a few high-performance web apps and in every case we realized we really just wanted a SQL database in memory in the server process that could stay in sync with an RDBMS but there weren't really any options for doing that -- so we'd build up something on top of Redis and rely on lua scripts for updating custom indexes. This looks amazingly useful and I will probably try it out in a few months for a production application. &amp;#x200B; Thanks for your work!
Is there a way to draw pixels to the screen with pure rust? I only seem to find bindings for other programs, which you need to download seperatly, but no way to do it only with Rust.
1) In short, yes. You always need to do some kind of error check on a function that returns result. If you really wanted, you can ignore the result entirely by having the variable have a trailing underscore. But don't. 2) You propagate a Result up to where it's appropriate to handle the error. That often will be in main, but not always. 3) Result is generic enum. A Result can be either Ok(T) or Err(E) for any types T an d E. Ok() and Err() are just wrapping T and E. () Is the unit type. It is a type whose only value is (). In your context, it means "I don't have anything to return on success, but I still want to indicate that the operation was successful" 4) considering you are creating the directory for a reason, you probably wanna know about it if it fails, so 3 is probably correct. 5) check out std::path::Path maybe?
What is presently the best way to use rust and 2D graphics in the browser? 
God that was a perfect answer! Cleared all my confusion(s)! :-) Especially this: &gt;In your context, it means "I don't have anything to return on success, but I still want to indicate that the operation was successful" Thanks so much!!
&gt; I just don't know why the compiler allows us to write this Because disallowing it (or any other sort of special handling that doesn't arise naturally from the type checker) would require code in the compiler. It would require testing and maintenance. It's just not worth it.
I've been working on implementing [Conway's Game of Life in Rust](https://github.com/Ross65536/conway-game-of-life-rs). I've previously read the Rust by Example book but this is my first real project in Rust. It's been pretty fun, though the code is probably not very idiomatic. Right now it only runs in the console, but I'm hoping to make it run in the browser with WASM in the future, which would be an interesting learning project.
&gt;We're on C++ levels of error message gore here. Recursive types will always be verbose to express, C++ or not.
It would at least be helpful if the compiler could recognize the self-similarity and not suggest raising the recursion limit.
&gt;amethyst Yes, exactly! I just want to feel how it is like, get my hands dirty and eventually have better understanding from other aspects. The entire purpose of this thread was to hopefully get some directions of what possibilities are there right now, such that would fit my amount of spare time &amp;#x200B;
Ooo I bet to put something here finally. Transcribing some c++ code, count sort algorithm, to rust in order to try and parallelize it and compare performance to c++. First project after finishing the book
About 2 weeks ago our "remote team" in pakistan made a PR moving our front end from mobx to redux, and in the process decimated our tests to make their PR pass. I reverted it because I have my sanity still, but I was pressured to basically let it through anyway. Life happens, friend.
I say new user, but I know the old one also do the same mistakes.. Just more rare
This is only tangentially related, but what is the current consensus on error handling? Last time I did a real project in Rust error\_chain was the cool thing, but I hated it because it was all macros and kind of hard to debug and didn't work well with Race, IIRC. As I sit on the sidelines I see a lot of people using Failure. Now that we have `impl Trait`, doesn't that take a lot of the pain out of just doing plain old custom-error-enum style with no external deps?
He's not selling cars, though. I'd be really interested in a lawyer's comments on this.
Some people have started to avoid failure, such as the author of `ndarray-csv`, and you can see the reasons he outlined very clearly: https://paulkernfeld.com/2018/10/27/improving-ndarray-csv.html. I tend to agree, since what I thought I wanted was easier error handling, but just adding a `.map_err(|e| MyError::NotFoundErr(e))`, for example, was really not that difficult. I prefer just writing an Error enum myself and avoiding `from` implementations.
Are the libs encrypting the session? If so, then there's no point to jwt, which you'd use if you decided to not worry about cookies and use localstorage for the session token. I didn't see any mention of CSRF, that's really important if you are putting your auth token in a cookie.
That's what I've always done. In fact, I believe it's even shorter than what you wrote: `.map_err(MyError::NotFoundErr)`. I'm fairly dependency-phobic, so unless it's really going to help a lot, I avoid deps.
Another deep work week, with main focus on the synth. I got the analog oscilloscope in the synthesizer almost done last week and will do the final wiring today. Then work on placing real modules and patching the synthesis graph. Probably some work on xi-win-ui (which I will probably rename to something more generic) to support the synth, and community work on xi-win as well. Also, I have in the works setting up a [Zulip](https://zulip.com) instance for xi and related works (including xi-win and the synthesizer for now). I'm not sure why more people don't use Zulip. IRC is ok but has a lot of drawbacks. I'm encouraged to see how it'll go.
Can apps be composed like in Elm?
Só sei que é mais bonito usar a língua do modo certo! :) Talvez ninguém use, mas agora nós quem temos TOC podem se sentir melhor, kkk.
Ooh, very cool. With the momentum behind Amethyst, I'm interested in checking it out myself. What resources are you using to help you learn it?
&gt; Get the list of updates since the last release. &gt; Write release notes. Personally, I prefer keeping my changelog in the repo. If nothing else, it makes it easier to carry with me if I change services. Also if you use [keepachangelog](https://keepachangelog.com/en/1.0.0/), it provides another way of finding commits since last release. I'm lazier and use [clog](https://github.com/clog-tool/clog-cli) to help filter out refactors and things.
You could try hackerrank.com they're using 1.24.1 and have num, serde, serde_json, serde_derive, rustc-serialize, regex, time, text_io, rand available
Polishing up a torrent database and simple webserver written in actix. [Torrents-csv](https://gitlab.com/dessalines/torrents.csv)
If you hover over it, that `Result` is `io::Result`, not regular Result. `io::Result` is a `Result` with the `Err` type set to `io::Error`, so you only need to define the success type.
`failure` is great in applications though, for libraries I wouldn't use it since it is unstable and the errors from libraries should be fairly shallow anyway, making the backtrace redundant. If an end user such an application wants backtraces they can still do so, it is just that they are limited to the library boundary which seems fair at a first approximation.
Im pretty sure vw is also selling some sort of software 
There honestly don't seem to be too many resources yet. I'm working with the [book/pong tutorial](https://www.amethyst.rs/book/master/pong-tutorial.html) which got me into a 2D environment I was able to just sort of go from there. If you've looked at it previously, there was recently an update to the book that connected some missing dots. Outside that it's been the [API Docs](https://www.amethyst.rs/doc/latest/doc/amethyst/) and asking questions on their [Discord](https://discord.gg/E2Dd244) channel. I've only had to ask 2 questions so far, but the community is extremely friendly and responsive!
Oh god more exceptions? Why? Rust is already complicated enough. Haha. But thanks for your help. Just out of curiousity: Shouldn't the docs be as clear/correct as possible? Shouldn't the docs page say this: pub fn create_dir_all&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; std::io::Result&lt;()&gt; instead of what it currently says: pub fn create_dir_all&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;()&gt; ?
I'm currently writing my AI for the game Screeps in Rust! It's very productive and fun
Here, here!
See my answer to [fullouterjoin](https://www.reddit.com/user/fullouterjoin) please. When you are writing lock-free structures you have to touch a lot on raw pointers because of \`AtomicPtr\`. Most of times, you also end up writing patterns covered by \`owned-alloc\`. E.g. you move out contents of an allocation but you have to free the allocation later. Having a proper type for uninitialized/deinitialized allocations make handling them easier. Another use case, I believe, is handling FFI (when you also may need raw pointers).
&gt; Zend Engine has a macro called RETURN_FALSE to return… false! Handy isn’t it? Not to be overly critical of PHP, but the internals of PHP's development never cease to amaze me.
Yes, it does. PySpark handles memory much better though. I use pyspark by default (no distributed env), but I hop between Pandas and SQL frequently when working with data. But then we've digressed from the original discussion :)
&gt;...and worse for beginners. confirmed! ;-) Thanks for your help!!
Do you happen to have the code available somewhere? I'd like to dig in and try to figure out why it's failing a little more.
I love seeing WebRender-based UI toolkits! One of the goals of WebRender was to support these, and it's fantastic to see them spring up.
 No problem! I wish I could always make the docs perfect for everyone at every time...
I finally rebased that rust PR I had open for some time, also merging a few PRs for bytecount and looking into rewriting my array size elision RFC, if I get around to it. Alas, $work and $family leave me precious little time...
I can't help but notice a lot of C code.
Gosh, I had never heard of that before. Thank you.
I'm sure the docs are just fine. The problem is that if Rust is your first compiled language there are very very many little things you need to understand or at least know of. Now that I know that there are two different Results, everything makes total sense again. You're the person/guy who's responsible for the TRPL, correct? That books is excellent for beginners, because it also explains all the non-Rust background infos (stack, heap, etc) and goes over the code examples step-by-step which is super important if you actually want to understand every little command/loc/concept. The problem is that Rust has so many features. A small example: I'm currently at chapter 10 of the book (generics) and so far I f**king hate generics. They make things so much more complicated the code less readable, etc. And why? Just so I can save a few lines of code? I sort of skipped over it, just so I can move on with the book. And once I'm better at Rust I'll get back to it and look at generics in more detail. While I absolutely hate them now, I'm sure if I was a serious (or actual) programmer I'm sure I'd like them more. And at some point I'm sure they'll grow on me. But right now all I wanna do is finish the book so I can actually start coding Rust. :-) (Not ranting about Rust, just trying to explain that the breadth of features in Rust can make the learning process a bit frustrating at times )
&lt;3 (And yeah, I am. Thanks.)
Super interesting because it was covered in [The Morning Paper](https://blog.acolyer.org/2018/10/29/noria-dynamic-partially-stateful-data-flow-for-high-performance-web-applications/) (highly recommended regardless) - and, it's written in Rust!
Just a heads up: I think the copyright at the footer is wrong.
PHP has a significant learning curve issue too, because of its complete and utter lack of consistency.
Batman is right. PHP's learning curve is nowhere near as hard as Rust's. You're worried about how hard it is to master, which is a different topic altogether.
This means that optimization is going to change the layout of `async fn` future types, don't it. That temporary makes sense in "do the obvious thing" debug code, but definitely would be eliminated in release optimizations, if it were straightline code. That scares me.
You're probably right that it's easier for simple applications, but parsers for this editor thing are kind of complex.
Is this something that could be used within a Vulkan/OpenGL game? 
Looks awesome! Can't wait to try this.
Azul is the name of a company that sells a commercial JVM. 
Please remove the transition on initial page load.
yes, but there are PRs open to fix the whole stack, and the lowest part of the stack (cocoa, etc.) are already fixed
I love the names article. The assumptions get less and less problematic until "everyone has a name" which you'd think is the lowest possible assumption (everything else is predicted on it, even!) but it isn't even always true. The only reasonable option that seems to exist is "What should we call you? [Text field with no restrictions]" The more I work on systems the more I believe that as much as we love manipulating strings, the only sane string operation is to treat them as binary blobs and to key them through I18N.
Hi everyone! This is the first release including the newer maintainers of Gotham. Please check it out and let us know your feedback, suggestions, corrections, etc. We're all relatively new to maintaining a project of this size, so bear with us whilst we get the hang of it! 
So, I'm not sure whether there are situations that would change between debug and release. Note that the generator transform only stores variables that are alive across yields in the closure environment, if a variable is only used within a single invocation of the generator's `resume` method then it will be kept on the real stack during the `resume` call. I could see the generator transform becoming better at detecting variables that aren't alive across yields, e.g. [if you call `drop` on a variable alive during a single invocation the de-initialized memory can still be stored in the closure](https://users.rust-lang.org/t/mutexguard-cannot-be-sent-inside-future-generator/21584/6?u=nemo157). But adding better detection of times that a variable doesn't need to be in the closure seems like the sort of optimization that would have to be guaranteed to run no matter the optimization level, specifically to avoid different optizimation levels affecting things like this.
Good framework. But about the mentioned MapsForPrint right below the Azul header: has it folded, or has it simply not gotten around to updating its media yet? 
Azul also means blue in Spanish... By now a lot of common names are taken, duplication is inevitable at some point. And definitely acceptable when projects are different enough. N
Yep, and that's the underlying point. We make assumptions about names because we like adding constraints for fear of someone breaking stuff, but at the same time, we need to be mindful of the assumptions we're making. 
Yeah, that's the bane of PHP. Stupidly easy to use, incredibly hard to use correctly.
Now that we have `clippy-preview`, `rustfmt-preview`, and few projects I've seen use vanilla configs for both, is there a reason not to just use `rustup` components in stable now? Speaking of which, you should check out the PR I submitted against your `great-ci` project. ;) 
Travis also supports Windows now!
I'm hoping to update `great-ci` with a new blog post moving into the 2018 edition, tentatively titled "Automation for Success". That's why it's sort of been sleeping. Even if you're using a nightly-only unstable configuration of rustfmt or clippy, there's no reason to install from source anymore, you _should_ be using the rustup components. It's both faster, easier, and more consistent. (Still pin the version though.)
This looks like a nice way to construct a stateless DOM, but is it really IMGUI? It doesn't really mix layout and functionality in imperative linearly executed code, and instead uses callbacks. Seems closer to something like React or Vue.
So, it's known why it's broken? This always confused me given that servo itself works fine...
What's wrong with it?
Congratulations, you found a bug in miri. :) The same bug actually also came up from a rustc issue today, so a fix has already been written: [https://github.com/rust-lang/rust/pull/55474](https://github.com/rust-lang/rust/pull/55474). Once that lands, your code should be fine (or at least it shouldn't fail due to this error any more). &amp;#x200B; What happens here is that miri does not recognize that \`1..=0\` is the range of all possible integers, and hence it does not accept a pointer value there because it cannot be sure that the pointer's integer representation is actually in the given range.
First I've heard of this one! Definitely gonna have to check this one out later.
I don't understand all in the title... What is the difference with yew? I think there is another player in this game, I don't saved the name.
https://rust-lang-nursery.github.io/edition-guide/rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html
Hmm, the `struct Combinator&lt;Parser&gt;` is weird when `Parser` also appears to refer to a trait with `-&gt; ...&lt;impl Parser&lt;...` and `impl&lt;P&gt; Combinator&lt;P&gt;` refers to the type parameter as `P`. Is this entire thing inside another function?
Perhaps it’s time for me to open an issue?
I just closed [issue #67](https://github.com/wahn/rs_pbrt/issues/67), which means that the test scene using subdivision surfaces renders fine now.
Maybe use a browser with WebRender, it's basically free then! I do feel the same way about this kind of trend though. It's unnecessary.
Unfortunate, yes. But that's a human/policy thing, not a software quality thing. 
Yes. I too found PHP extraordinarily easy to learn.
Probably old news, but until recently I had no idea I could create a struct like this, and use it like below: &amp;#x200B; \`\`\`rust **use** std::fmt::{Display, Error, Formatter}; **fn** main() { **let** leo = Person("Leo", 22); **println!**("{}", leo); } **struct** Person**&lt;'a&gt;**(&amp;**'a** **str**, **i32**); **impl** **&lt;'a&gt;**Display **for** Person**&lt;'a&gt;** { **fn** fmt(**&amp;self**, f: **&amp;*****mut*** Formatter) -&gt; **Result&lt;(),Error&gt;** { ***write!***(f, "{} ({})", **self**.0, **self**.1) } } \`\`\` Neat for simple scenarois
Interesting. So in this case the return value is a Combinator as a generic type that implements Parser? Why couldn't it just be written \`Combinator&lt;Parser&lt;...&gt;&gt;\`?
Thanks!
https://philsturgeon.uk/php/2013/09/09/t-paamayim-nekudotayim-v-sanity/
It might have been possible (I would really need to see the rest of the code to know for sure), but even if it's not necessary it can be a useful construct. For example, I wrote some code last week where I decided to return an `impl Iterator` rather than the specific kind of iterator I was returning. Why? I felt that it expressed my intent more clearly: I'm returning something you can iterate over, what specific iterator I'm handing you is irrelevant. If I ever decide I want to return another kind of iterator I can make that change without breaking the API, if I'm not mistaken, because I won't need to change the function signature.
That's the thing about Rust: it sets the *can write code* bar a bit closer to *can write good code*. It's considered "hard" because to know Rust you have to grok aspects like lifetimes that are part of "mastering" other languages. PHP is only "easier" if you don't plan to get good at it.
Mojave changed something, and everything went black. /u/pcwalton sent a patch to the cocoa wrappers, and then a patch to wininit to use it, and that should fix glutin and the rest of the stack
The human/policy thing isn't entirely separate from the software quality thing though, one is hooking into the other. One of the heuristics is to reject individuals if different agencies have names on record that are not character-for-character identical. These agencies are using databases that are literally incapable of representing some names the way they are stored in other agencies' databases.
For an application I have in mind I need a tree widget that (1) can be arbitrarily nested with arbitrarily many children for each node (2) lazily loaded (e.g. the child nodes are only generated when I click to the icon to expand children of a node). This is probably possible with the gtk crate, but not easily. Is this any easier in Azul?
Unfortunately this only works for unused `extern crate` declarations, not for Cargo.toml dependencies.
Wouldn't it be as hard as solving the halting problem? I mean - how can you be *absolutely sure* that raising the limit won't solve the problem?
oh, didn't know. 
True, good point! 
Conversely, I didn't realize enums could have named fields like structs. 
It's the fairly recent `impl Trait`-feature, which enables abstract return types without boxing. In your example, `convert` returns a `Combinator`, where the type parameter is something implementing `Parser` with the provided parameters. The 2018 edition book has [a short section about it](https://doc.rust-lang.org/book/2018-edition/ch10-02-traits.html#returning-traits).
Azul is also a JVM product
How pure are we talking? If you mean "just write some pixels in a totally unstructured fashion" then you could probably mmap /dev/fb0 if you're on linux.
Is it a soft or hard link?
That wouldn't be an existential type, would it?
Already wrote into an old issue in the repo, but will ask here as well: what would be the steps to import an HTML document into this?
Aren't tests *supposed* to fail on CI if something goes wrong? Why bother with tests at all if you ignore them?
You mean like a domain name? 
Union-find is used in the Hoshen-Kopelman connected region labelling algorithm. That can be used in some traditional CV algorithms for finding blobs and such. 
OpenGL, yes, vulkan, probably not right now. See [the wiki](https://github.com/maps4print/azul/wiki/OpenGL-drawing) for a guide to OpenGL integration. While the idea was to use azul for game engines later on, the intent was rather to run the actual game decoupled from the engine inside a custom window.
1. Write (or use) and existing XML parser, make a function that can take an HTML string and map it to a `Dom&lt;T&gt;`, i.e. convert the loosely typed XML nodes to strongly-typed Dom nodes. 2. Push a daemon to hot-reload the file every X milliseconds 3. Reload or `include_str!()` your HTML in a release build to bundle the HTML with the actual app.
I started to upgrade to it but got stuck once I noticed that map items now require to impl `Copy` on stable, which is a no-go for me as none of the items (structs with String and tons of other fields) I am currently using can impl `Copy`. I guess I'm stuck with 0.2 for now, any chance you can add the issue/rfc link in the documentation of https://docs.rs/slotmap/0.3.0/slotmap/trait.Slottable.html ?
It's not really something anyone should use, and it's purpose is to poke fun at the original. How is it not a parody?
It’s not an oversight, it’s just that it hasn’t landed yet. By the time 1.31 rolls around, it will be moved onto doc.rust-lang.org and be linked from that page too.
Is there anything to be done in the meantime? Maybe this situation isn't so bad, since you are always monitoring the rust discussion forums and quick with a helpful link.
Date it seems. 
Is it advisable to use RLS nightly instead of stable? There's lots of places where I can't get a completion, and I wonder if switching to nightly is a good idea or if it has other drawbacks; as a noob, nightly sounds dark and full of terrors...
What's the tersest way to bubble up an `Error` adding some context? Something like: fn get_from_agent(url: Url) -&gt; Result&lt;Vec&lt;Filesystem&gt;, Box&lt;Error&gt;&gt; { let mut response = reqwest::get(url).if_fails_propagate!("Could not access {}", url); Ok(response.json::&lt;Vec&lt;Filesystem&gt;&gt;().if_fails_propagate!("JSON at {} could not be parsed", url) } , which will result in friendlier error messages but still will let me see the embedded error? Is error-chain the most advisable way to do this?
I deployed the first version of my [Nagios-compatible monitoring agent](https://github.com/alexpdp7/ragent) to my personal infra. I'm particularly happy because I deploy it using RPMs for CentOS 7 x86\_64 and DEBs for Debian Stretch; both x86\_64 and armv7-unknown-linux-gnueabihf (damn Raspberry PI 3 :-p).
Or, to look at it another way, we like adding constraints to ensure a minimum quality of data at time of entry... but we don't consider cases where reality itself is of lower data quality than what we expect.
It is used in a binary and not in a library so safety should be ok. I am using 0.2.1 which fixed that issue according to the changelog: https://github.com/orlp/slotmap/blob/master/RELEASES.md#version-021
I think IMGUI is a generic term for this general approach to GUIs. The specific very popular library you're probably thinking of is "Dear ImGui".
Your wish was granted. I'm sorry, I just thought it was cool.
Not that I know of; however it seems that the RFC already has provisions for this: [https://github.com/rust-lang/rfcs/blob/7bf6206dcb0b0a38e2179eca4a3a96440dc15e18/text/2457-non-ascii-idents.md#confusable-detection](https://github.com/rust-lang/rfcs/blob/7bf6206dcb0b0a38e2179eca4a3a96440dc15e18/text/2457-non-ascii-idents.md#confusable-detection) As someone with a non-ASCII name I do appreciate the feature, but Unicode is a complex beast. I trust the Rust maintainers to do the right thing- I have yet to find something I really don't like about Rust, but I'm a fan of raising the awareness about how complex is to do Unicode right.
I just learned Rust this weekend to speed up my program which uses the terminal as a render context. I got sold on Rust right away. I rendered he [Julia set ](https://imgur.com/gallery/HUqdDGu), animated in real time with great performance.
&gt;That last one is particularly relevant as we had an intern with a last name with a dash in it, and the dash broke the new flagship product during development. To be honest, I'm kind of surprised by that. I'd have thought that, aside from overzealous punctuation escaping catching names with apostrophes (eg. `O'Neill`), [hyphenated surnames](https://en.wikipedia.org/wiki/Double-barrelled_name) would be the second-most common kind of punctuation you'd encounter in a test corpus. (They've not exactly been uncommon in colonial powers like Britain and Spain over the course of history and they're becoming more common as an option some parents choose so both can keep their family names and pass them on to their children.) Now a name from South Africa which uses an exclamation point to indicate a click consonant... that's something more in the vein of what I'd expect developers to trip over.
You are not using 0.2.1, because that's the version that introduced `Slottable`.
There is a function named join_all that take a Vector of futures and joint them together. It does the job and it could something like future.join_all( vec ); for object oriented like style. I don't see why give 3 to 5 options as named particular functions. That seems like bad design to me or maybe they are old?
No, it isn't a matter of work, it's a matter of wanting to wait until a bit closer to the release date, so we're not constantly spamming the main repo with "update" PRs. Right now, I can merge a bugfix and have it deployed immediately; once it's on doc.rust-lang.org, it will need to go through bors, and then wait until the next nightly. 
Cargo does say I am using 0.2.1: https://github.com/Keats/gutenberg/blob/next/Cargo.lock#L1089
Cool! I was looking at the [stack checked pointer](https://github.com/maps4print/azul/wiki/Two-way-data-binding) section and I'm wondering if this is the best we can do. It seems a fairly generic problem that should have a generic solution and i ran into something similar a while back. But i don't have much time to dig deep into alternatives. Might be worth while to make a new thread for visibility and see if anybody pops up with a safer solution.
And I've got `#![feature(futures_api, pin)]` in my main files. This compiled before I updated
It was pretty weird that it did cause such an issue, especially for the reasons you outlined. 
If I could use something like this with the yew-esque "rust-x" (name my own) builder for native apps that'd be solid. I've got some ideas that need a decent GUI framework before they can go anywhere (I've tried relm, and while it's better than raw gtk-rs imo I still dislike it, at no fault of its own.)
I like to use quick-error, [which has a `Context`](https://docs.rs/quick-error/1.2.2/quick_error/#context) addition. For example, once you've defined your custom error type: let mut response = reqwest::get(&amp;url).context(&amp;url)?; I believe you can do the same using [failure](https://docs.rs/failure/0.1.3/failure/). 
&gt; having the variable have a trailing underscore Pedantic nit, it's a *leading* underscore.
&gt; RLS nightly instead of stable I use RLS via nightly myself, but I can't speak for the differences between the two versions. I use RLS via nightly even when I'm compiling code with stable Rust! &gt; nightly sounds dark and full of terrors It's not really all that bad or really even that different from stable. If you aren't using any feature flags, then the worst that should happen to you is something you were using breaks. In that case, you can roll back to an older nightly or back to stable or beta temporarily. 
I developed my dependency phobia from having to deal with ORMs, but it was truly sealed from JS libraries, and it's stuck everywhere else, so I wholeheartedly agree. There should be a step before adding a dependency for scrutinizing that decision. 
Yep I use DenseSlotMap. It would be nice to have typed keys with it but not 100% necessary I guess
Technically yes, practically no since Azul has no scrolling support yet (to scroll the tree in its parent). You could implement "manual" scrolling by setting the margin / padding of elements inside of an event handler, but yeah, this isn't going to be great. The nesting isn't a problem, that can be achieved with recursive dom elements, but scrolling the tree is a problem. This post was made a bit too early. However, there is no distinction in azul between a custom widget and a built-in widget like in so many other libraries... all built-in widgets are just dom trees in the end with some syntax sugar on top. They could reside in a completely different library if necessary. That's the "beauty" of a dom tree structure.
AFAIK Rust does not have direct C++ interop. The bindgen utility has some support for generating c++ bindings, but I'm not sure how mature it is. Mostly rust interops with c++ just like everything else, by using the c ABI.
The API has changed a bit. It *is* "unstable" after all. * `PinMut&lt;T&gt;` has been replaced by `Pin&lt;&amp;mut T&gt;`. * `Context` and `Spawn` have been removed and `&amp;LocalWaker` is all that needs to be passed to `poll()`. * `FutureObj` has been removed despite the reason for its existence not being fixed. If you need Future objects, you need to either reimplement `FutureObj` or use `futures::future::FutureObj` from `futures-preview`. When using nightly apis, it's important to use the the nightly docs.
I wrote a small crate for parsing Unix process accounting files [here](https://github.com/jabedude/acct). I'd love some any feedback on newbie mistakes I've made.
I wasn't thinking that the edition guide would be merged into the main repo. Instead, I was thinking a new link from [https://www.rust-lang.org/en-US/documentation.html](https://www.rust-lang.org/en-US/documentation.html) to [https://rust-lang-nursery.github.io/edition-guide/rust-2018/](https://rust-lang-nursery.github.io/edition-guide/rust-2018/) (along with some appropriate "this is new, indevelopment, and upcoming etc etc" wording)
The "Dear " prefix wasn't around before, was it?
Ah. That’s not the plan :)
That project is in blatant violation of the VST license...
I sympathize but it's way better without it. :-)
In a vector, the futures have to all be the same type. With that API you can't pass, e.g. a `AndThen` and `Map` to the same join operation without boxing them to erase the type to `Box&lt;Future&gt;`. It also requires all the yielded values to be the same type as well. The other functions can have completely different types for both the inputted futures as well as the outputted values. If we had variadic generics then it could be one function for any size tuple.
Should I expect the latest Rust 2018 stuff to work if I am using the nightly toolchain? Specifically, I started easy with https://rust-lang-nursery.github.io/edition-guide/rust-2018/module-system/path-clarity.html?highlight=extern,c#no-more--extern-crate But it doesn't work, I still have to write `extern crate tokio; use tokio...`.
Ah, gotcha. I'm not sure about a rename - I couldn't see any obvious sign of one in the Dear ImGui repo, but yes, the mismatch between project name and repo name is suggestive.
Note that `edition = "2018"` is now the default when creating new Cargo projects.
I've been excited recently with the story for writing graphics in rust without raw openGL getting better. I was introduced to https://crates.io/crates/minifb, a pure cross-platform pixel buffer, and just today [azul](https://azul.rs/) was posted to the subreddit and it looks like it's going to make this quite nice for people who know how to style things with CSS. I'm nowhere near a graphics designer nor graphics programming expert, so I don't think azul is something I would want to use, but I'm happy to have the space expanding.
&gt; if I am using the nightly toolchain The edition features should be enabled in the **beta** toolchain at this point, so certainly available in the nightly. 2018 will be stabilized in the in next release!
Looks awesome! One question, though: &gt; [..] asynchronous I/O, which are thread-based. Each task is a single thread [..] Isn't each task being a separate thread pretty much the antithesis of asynchronous IO? As far as I know asynchronous usually refers to I/O models which don't require a whole thread per operation. 
&gt; It could be terser, I guess You can make your own extension crate (like failure and quick-error do), or make a macro that wraps your expression. Your initial desired syntax [requires language changes](https://github.com/rust-lang/rfcs/pull/2442), however. 
I don't want to step on a thread for another project, but I'm actively exploring GUI for synthesizers in synthesizer-io and hope to take a close look at VST soon. Let's branch off further discussion of that to #synthesizer channel of our [new Zulip instance](https://xi.zulipchat.com) though.
See my reply below, I seem to have somehow managed to get a mixed toolchain, with latest version of the compiler but an old version of cargo. It's fixed now. Thanks!
AFAICS the user can configure this behaviour themselves at the file or FS level (see below), so this isn't up to `xcp`. What is unexpected behaviour is its (lack of) treatment of sparse files; I had to explicitly implement detection and skipping of holes, although I still use `copy_file_range` to copy the data blocks.
That first list seems a bit dated. Floppies and Windows XP SP1? I think not :-D &gt; Install and run on Windows 2000, then upgrade to Windows XP A machine running Windows 2000? Where might one acquire such a relic?
In what way? (I'm just curious, not affiliated)
I highly recommend listening to the audio presentation at the bottom of this link, it was very informative: https://www.usenix.org/conference/osdi18/presentation/gjengset 
It doesn't have to work in the general case to be useful. In this case the type in the error message appears to be for&lt;'r, 's&gt; fn(std::result::Result&lt;(&amp;'r mut &amp;mut tokio::io::ReadHalf&lt;tokio::net::TcpStream&gt;, &amp;'s mut std::vec::Vec&lt;u8&gt;), std::io::Error&gt;) -&gt; Result&lt;Itself, std::io::Error&gt; That "Itself" is the type in the error message, and that nesting is what gives the infinite recursion. I think it's possible for the compiler to recognize that this type contains itself.
It's been a while since I did a PHP plugin, but I remember have to write a ton of C bridge code too, before getting to the Rust. &amp;#x200B; It's nowhere as simple as Node or C#, two examples where I've found the FFI glue to be surprisingly simple.
A bunch of reasons. 1. The API that project re-implements has never been open sourced. It's easy to find, but the license is pretty explicit. Officials from the company have clarified that reimplenting the API from that source is a violation. 2. Reverse engineering the API is strictly forbidden by the terms of the license. 3. The company behind that API (Steinberg) requires a signed agreement (as in real paper, mailed to Germany) to redistribute any software using the API. 4. That agreement needed to be signed before October 1st of this year. New developers cannot legally distribute software that uses the VST2 API, the spec has been obsoleted. There's context here too. Steinberg began scrubbing that API from the internet first from their own repos in May and then via DMCA takedowns back in June. This has been an ongoing debacle in the industry. There are a number of large projects affected and last I heard there were some lawyers involved, what doesn't help is that Steinberg didn't really enforce their own license and the API has been a de facto industry standard for 20 years. Now all that said - it may or may not be possible to reimplement the API in a clean room (I'm too compromised to do it, the only hiccups might be the use of trademarked names in some exposed symbols). It doesn't look like they did that (and who would? Steinberg never enforced the license until this year). I think if you did that, the closed source license would be unenforceable in Europe. In the US there's a statute of limitations attached, and the first commit (from the original, forked repo) of the offending source code is a few months past it. 
Im finishing my thread-safe appendable list with a lock-free iterator. I have other versions online but the safety now is way better (I made a AtomicOption abstraction and some other over it). I will post the new version soon.
No, not right now. As far as I know - whenever there is a feature such as child windows, winit has to have it first, then I can just expose it. Azul just "forwards" all winit window handling properties, so if winit can't handle child / parent windows, then neither can azul. There are also problems with OpenGL context sharing with multi-window apps and well, the library is just a bit too young.
What I meant by "async" was that you can load a file in the background without blocking the UI (on a separate thread). In desktop applications the futures / tokio / async IO features have diminishing returns in terms of performance - these things are more meant for servers with [10000 parallel users](https://en.wikipedia.org/wiki/C10k_problem), where the number of requests are much, much larger than the number of threads you have, so you have to distribute the loading of files across a certain number of threads - but in a desktop app, how many files / connections are you loading at the same time? One, maybe two? The reason I originally implemented this was to connect to a database, load some data (which can take a few seconds) and then display that data without blocking the main thread.
See also [`derive_more`](https://crates.io/crates/derive_more)'s [`#[derive(From)]`](https://jeltef.github.io/derive_more/derive_more/from.html). (Your crate is still useful as it provides different opinions on what to convert `From`, though maybe it should be a derive instead of a free attribute. Note the difference between the two is that a derive can't change the definition of the item it's on, where an attribute proc macro can/has to re-emit what it's on.)
Still working on a new CUDA wrapper library. I want to have a custom slice type to represent slices of arrays in GPU memory, but Rust doesn't have support for custom dynamically sized types (and I can't even find an RFC to add it). The only non-slice alternative I can think of is really unergonomic, so I'd like to get this right (or find a better alternative). I thought of a workaround using regular slices, but I have no idea if it's sound or not. If there are any `unsafe`-experts here, could someone take a look at [this URLO question](https://users.rust-lang.org/t/defining-custom-t-like-types/21677/7)?
Yeah, good point... I guess that's what I get for trying to make one blog post about two different topics.
I didn't know about `cargo tally`. Awesome!
Also look at [quick-error](https://crates.io/crates/quick-error).
One thing I'm not sure is the correct way, but it is something I did in a parser, is to use the `value` macro to run arbitrary code, something like `value!(num.push(final_num))`
Based on the [diesel docs](https://docs.diesel.rs/diesel/connection/trait.Connection.html), it seems like test_transaction should be a method of PgConnection. However, it's not being found. Am I doing something wrong? I'm basically doing the exact same thing as the docs to test, except on a PgConnection
No screenshots?
I've been working on updating [Steven](https://github.com/thinkofname/steven), an old experimental project from 2-3 years ago, to build and run with the latest Rust, here's my progress so far: [https://github.com/iceiix/steven/commits/updates](https://github.com/iceiix/steven/commits/updates). After some laborious conversion from major incompatible versions of Rust crates, and minor Rust language changes (it depended on a nightly version), it finally builds and works on macOS and Linux. Surprisingly many API changes, including in hyper, serde\_json, and openssl crates, glad it is done and over with. Next up: Windows...
APIs as such are not copyrightable, only specific documents (including header files) are. A reimplementation in Rust could actually be in the clear.
The application I'm currently working on (not written in Rust, sadly) sometimes has to load hundreds of images at once. This happens when it’s displaying an image gallery.
Thank you so much u/DebuggingPanda for whipping this library into shape! There's a lot of great stuff in the source itself for anyone that's interested in poking around.
So is it a thread pool or is it a thread per background action?
When it says it's suited to rapid prototyping does that mean it's not suited for actual application development? Is this a cross-platform UI framework with few/no dependencies?
what c++ lib are you using that doesn't have a C abi? &amp;#x200B;
Oh that’s awesome it works on struct variants as well. I’ve been using EnumFromInner but with this I can drop macro-attr and label my error variants.
Not sure I agree with the "incredibly" part considering that modern PHP frameworks make things very easy to write cleanly. Check out Laravel.
Not in the EU, but [they are in the United States.](https://en.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc.#Appeals_Court_and_finding_of_copyrightability_of_the_API) The issue here though is that there are two problems with the API - the first is that the only distribution of it was through a header file with a rather specific license. Firstly, it prevents reverse engineering, so any re-implementation using the header file is going to be a legal battle to begin with. Secondly - the file is only licensed if the developers signed the license agreement and mailed it to Steinberg. Otherwise it doesn't matter what you do with it, you can't distribute software that used it. It does not provide sublicensing, so anyone consuming a wrapper needs to sign the agreement themselves, which they can't do anymore. Lastly, even if the API wasn't copyrightable the only way to provide a re-implementation would be in a clean room. Based on what I know about the SDK and carousing the Rust implementation, I seriously doubt they did that. 
You might want to tell people what Gotham *is*. There's *nothing* to suggest what it is, or even what vague category it's in until the second section of the linked page. Even then, it could still be almost anything (on account of seemingly half of all software needing HTTP functionality these days for some reason). It's not until the fourth of fifth section of the page that it's reasonably clear that it's specifically some kind of HTTP server. Even then, there's nothing about why I should care, given that this seems like Yet Another Server Framework.
Fair points, but this is kinda aimed more at those who already know what it is. 0.3 is a feature update, not a new project announcement :).
Right, but you're posting it to a general channel with a significantly wider audience than just people using Gotham. If someone is looking for a server framework, doesn't know what Gotham is, and you don't tell them, you're missing potential new users. Heck, even if they're not, it's one additional chance to associate "web framework" with "Gotham" in their minds for when they *are* looking for one.
Any assumption your code makes about the real world will eventually be wrong in one way or another.
Didn't pursue it. 
This crate is intended as a joke: note that it's called `volkswagen` and it's used to cheat on CI tests and always make them pass. It's in reference to the Volkswagen emissions test scandal that started in 2015.
I wrote a web server around the diesel getting started guide to be run as part of a docker stack. Used Postgres as the database. What I was most surprised about was that I could have different types implementing the Message interface from Actix and still write handlers for them all for the same Actor. It must be trait objects behind the scene. If not, I really need to learn that pattern! It's refreshing to see that kind of flexibility in a relatively lower-level framework.
How far along is this project? I see the readme still has a scary warning ([but toned down from before](https://github.com/maps4print/azul/commit/819241debfba3c7ae9f49685e6c5f517d5266316#diff-04c6e90faac2675aa89e2176d2eec7d8)) at the top. Is it in a state where I could reasonably make a simple UI for [Halite](https://halite.io/) for instance?
Rust doesn't let you use uninitialized values, so there is no reason to worry about them. You could test this yourself. let x: i32; println!("{}", x);
Do you have a crate?
Not sure why you want to avoid rustup, since this is exactly the headache it saves you from, but signed tarballs are here: https://www.rust-lang.org/en-US/other-installers.html#standalone If I understand correctly, and if it hasn't changed since I last checked, any rustc can build for any target platform out of the box. All rustup needs to install is the standard library for the target platform you are building. (Even if you're writing no_std code, the core library is pretty nice.) This implies you should be able to build the std lib from source anyway, as if you were setting up a cross compiler env without rustup. I don't know how to tell cargo where to find standard libraries for different target platforms, but it should be in the cargo docs somewhere.
Note that Rust has done this on pretty much all it's update notices, since near the very beginning. You can see [an example on the most recent TWiR](https://this-week-in-rust.org/blog/2018/10/23/this-week-in-rust-257/). It was continues to be a great way to bring people into the fold when they stumbled on a project update out of the blue. Makes it much easier to convert people to being interested about your project! :)
This is: &gt; A proc-macro attribute for automatically implementing a trait for references, some common smart pointers and closures.
A lot of times you don’t have to initialize variable. However, if you read from the variable before the compiler can GARUNTEE 
 gotham::start("127.0.0.1:7878", || Ok(say_hello)) Is the || new syntax or have I missed something else?
So you cannot use a variable that is uninitialized in rust - the compiler will not let you. Sometimes you want to declare a variable without an initial value if you intend to use the variable in some scoped block of code. e.g. ``` fn some_function(y: bool) -&gt; u32 { let x: u32; if y { } } ``` &gt;When i do that rust comes with a warning message..."assigned value not used".. The rust compiler will warn if you have unused variables or dead code (code that will never be executed). Its generally considered bad practice in all languages to litter your code with dead code or unused variables, and lots of linters and compilers in other languages will highlight unused variables or dead code where it is possible to do so.
You can totally write swap in Rust. If you make enough assumptions, you can even write a version that beginners can understand (similar to what you might see in C/C++ tutorials). The reason it's best to rely on the implementation in the standard library is because it [turns out](https://stackoverflow.com/questions/109249/why-isnt-there-a-standard-memswap-function) swapping in general is actually a fairly difficult problem with many edge cases. The implementation of a general swap is written in Rust for the standard library. One way to see it is through the source code in the docs: https://doc.rust-lang.org/src/core/ptr.rs.html#93-253
So you cannot use a variable that is uninitialized in rust - the compiler will not let you. Sometimes you want to declare a variable without an initial value if you intend to use the variable in some scoped block of code, and use that variable afterwards. e.g.: ``` fn some_function(y: bool) -&gt; u32 { let x: u32; // x initialized in the outer scope println!({}, x); // x does not have a value, so the compiler will throw an error if y { x = 10; // x giving a value in the scope of the if branch } else { x = some_other_function(); // x giving a value in the scope of the if branch } x // its not possible to reach this line without x having a value, and the compiler knows this } ``` &gt;When i do that rust comes with a warning message..."assigned value not used".. The rust compiler will warn if you have unused variables or dead code (code that will never be executed). Its generally considered bad practice in all languages to litter your code with dead code or unused variables. Where it is possible to do so, many compilers and linters for other languages will also try to highlight unused variables or dead code. To get rid of the warnings you either delete the code or variables its complaining about, or use them in your code. If you are in the middle of writing a function it isn't unusual to get complaints about unused variables or dead code while you are writing. You should just clean up after yourself after you are done
What do you think of using Azul for Xi?
Sorry for nitpicking the "no matter what language" part; actually it is up to the language to define whether reading undefined values is undefined behaviour or not, so although it usually is, it's not an absolute rule.
Agreed, my first reaction was: why isn't this a custom derive?
Yes, but you don't have to start a new thread per image, you can load them in a loop on one thread.
There is many security consideration not cover here to me, but for good reason. That is not the point. For csrf, for instance, it has to be handled in the web application, not this service which should be completly isolated from the outside world.
I don't talk about azul name, I talk about Client Side Web Framework in rust. By the way, ask a stupid question, het downvoted, come on rustacean, you're clever than that.
Most comments are saying that Rust does not allow uninitialised values. This is mostly true, but You could use the unsafe function `std::men::uninitialized` if you do want to get a junk value for some reason
I do not understand why I got downvoted also. Wtf :/
It's a thread per action, but you have control over when you want to start a new action (and therefore a new thread). If you start a new thread per file... well of course, that's bad. But you can start one thread / task and then load incoming data in a loop until it's fully loaded, for example, so it only uses one extra thread.
Pretty much the whole way, but by manually doing everything rustup does for you. The only reasons I can think of that you'd want to avoid rustup are: 1. You want to pin to a specific version, which rustup can do. 2. You want to work offline, which is reasonable, but rustup can also work offline by pointing it at an existing installation. 3. You're coming from C/C++ where package management is nonexistent and you're skeptical of rustup and want to do things the way you know, in which case INSTALL RUSTUP RIGHT NOW! 4. You're on an embedded system and don't want the additional tool eating disk space, in which case why are you trying to compile on the embedded device in the first place? Isn't that why you're cross-compiling? With rustup: it's `rustup toolchain install stable` or `rustup toolchain install 1.30`, followed by `rustup target add $YOUR_TARGET`. That's it. You're ready to go. Was that really so bad?
There is a native FFI API for Node and C#, but writing extensions for NodeJS (and for C#) is extremely difficult from my point of view. Maybe it's because I'm a little bit more familiar with Zend Engine. A native FFI API in PHP is missing though.
Thank you for a really good example of how "I just build unbiased technical systems" can turn into unexpected bias. Our focus on software quality is commendable and I think extending our awareness to context sensitive issues like these is an important part of that.
This project got submitted a little too early. I only mentioned that I'm working on the calculator and table demo this week in the WIP thread and now it's all over reddit. There are three things that aren't implemented yet, that you'll probably find important: 1. Scrolling (should be implemented soon with webrender scroll frames) 2. Multi-window apps (necessary for overlapping OS Windows) 3. Focusing (ex. for a focused text input) And of course there are no standard library widgets like checkboxes or radio buttons yet (but they are fairly easy to write, since the layout works somewhat). Once these three things are done, I'd consider it at least ready to make simple UIs with like forms, dialogs, etc. (which is why it's not on crates.io - it's not ready yet).
Apparently from reading a few comments what you made here has already been made elsewhere. I'd day there's a discoverability problem somewhere.
I'm not defending PHP or the internals group here, but this story about `T_PAAMAYIM_NEKUDOTAYIM` is just about making a mountain out of a molehill… Andi Gutmans and Zeev Suraski, the co-founders of Zend Engine, are from Israel, and as such, they speak hebrew, and it was more or less an easter egg/joke/nod. Every project has such jokes in it. The only “issue” is that PHP prints the token name on syntax errors. And for a reason I ignore, some people find their happiness in making a lot of noise around that. But reading a backtrace from a segfault error with no symbols in C does not annoy anyone :-). Zend internals have many more troubles than that. Like the lake of documentation, multiple ways to do the same things, old and new API living in the same tree etc. There have been radical cleanups these recent years, and it was a huge effort to reach the point where we are today, kudos to them. And all of that while keeping one of largest backward compatibility in the language area.
Some things that might help: * [ws!](https://docs.rs/nom/4.1.1/nom/macro.ws.html) - makes a parser whitespace-agnostic. * [delimited!](https://docs.rs/nom/4.1.1/nom/macro.delimited.html) - for input that starts with a certain pattern and ends with another (here "[" and "]"). * [one of the `separated` variants](https://docs.rs/nom/4.1.1/nom/macro.delimited.html?search=separated) - for handling the comma-delimited strings.
&gt; Mojave changed something and everything went black. Oh, and at first you meant dark mode.
yew uses webasm in a browser. this is a desktop ui kit.
This is lovely, have you considered adding an entry for it to awesome-rust? I would be more than happy to approve its addition.
I’m writing a lesson planning tool for teachers in webassembley. Currently trialing Draco vs Yew to see what I like the most. 
&gt; From school days onwards, i have been taught like its standard to initialize the variables to "zero" or some default value to avoid "junk" values.. I would urge you to forget about this as quick as possible. Masking logic errors by initializing variables when they don't need to, or silently catching exceptions and continuing with a default value to avoid the program from crashing is 99% of the times a problem rather than a solution, as it hides errors instead of revealing them in order to fix them.
Gotham is a flexible web framework that promotes **stability**, **safety**, **security** and **speed**.
I go to docs.rs (or generate the docs myself), and I browse around types or functions, then get into the source of interesting ones.
swapping 2 references means that they can't overlap, can't be null, you won't need to allocate, and the length can't be zero. But if you want to swap byte arrays that may overlap, yeah, it's harder.
The correct terminology would be to say that **safe** Rust does not allow uninitialized values.
Why are all existing answers like „I don’t know the answer to your question but let me tell you that what you’re trying is totally wrong.“? I’m sure there’s a reason for this limitation, even if it’s „just for fun“. No need to lecture here. 
&gt; i have been taught like its standard to initialize the variables to "zero" or some default value to avoid "junk" values This is only necessary in C and C++. All the other languages I know of either detect &amp; warn about uninitialised variables (e.g Rust, C#) or perform automatic zero-initialization.
Looks very cool! I'm curious - the website says "rapid prototyping of desktop applications". Why "prototyping" as opposed to non-prototype/full development? What are the limits? Also, this is the first time I've heard of WebRender - I assume using this is a lot more lightweight than using a full browser framework like Electron?
Do you have any plans to support TypeScript in RESS and RESSA? Or put differently, how amenable would those libraries be to adaption/extension for JS supersets?
Add `#[deny(missing_docs)]`, then write the docs until both I understand the code base and it compiles again.
There's RFC: Pointer metadata &amp; VTable [https://github.com/rust-lang/rfcs/pull/2580](https://github.com/rust-lang/rfcs/pull/2580) which could be a step forward custom DSTs.
Managing a thread pool is not something you want to do in an application. You’ve already got enough to worry about. Maybe there’s space there for another crate to implement this separately. Also, loading images can take seconds, with great benefits from parallization, because most of the time is spent waiting due to latency.
It's a reflink. A reflink is neither a hard link nor a soft link. The files reference the same content on disk, but have seperate inodes.
That sounds like a hard link, what am I missing
Because the way that you do it is to do what rustup does, but by hand. So, without a very good reason to not use rustup, you're just making it hard on yourself.
Why does it stop compiling? Couldn't you use `MyLittleHash::hash(some_u64)` and `Hash::hash(other_u64)` (or whatever std's hash trait is) in this case?
As others have noted, there's a significant lack of documentation for doing this. Previous tools like rust-cross and [xargo](https://github.com/japaric/xargo) have been systematically integrated into rustup and cargo to provide a uniform interface. Advantage for usability, but with a disadvantage for anyone wanting to know how to use 'rustc' without other cargo or cargo/rustc without rustup. The things you'd need to download and unpack are available for download as /u/icefoxen mentioned, but I'm not 100% sure anything but the rustup codebase knows where to find the components or where to unpack them to. Here's what I've found from snooping around the rustup codebase, though: - When adding a target, rustup downloads a "component" rust-std with the target wasm32-unknown-unknown (or whatever your target is - you could also download wasm32-unknown-emscripten) - it will eventually unpack it into "lib/rustlib/wasm32-unknown-unknown/lib/*" ([evidence for this](https://github.com/rust-lang-nursery/rustup.rs/blob/c3e4ce4c5e11a5557a080be9bf8f6ee9d2c87839/tests/cli-rustup.rs#L273)). I've got no idea the specific location of the component binary, though. Rustup downloads everything from https://static.rust-lang.org/, but that's a big site. I can do more looking around on my computer and see what network traffic it does when installing the new component. Probably the easiest way...? --- I think we should definitely have better documentation for this, but it's the state of things. The main reason is just that everyone's happy using rustup as far as I can tell - either that, or I've messed up and missed some large book which contains all this... I'm glad to hear you're looking into this, and interested in doing things manually. I'll make a post child to this one if I find any more information. 
Build the docs and use them to see the public API. Read the integration tests to see the expected features. After that, scroll around and look for interesting sections.
It depends on how generic you want it to have. There are a couple of extra rules and restrictions in Rust compared to C that make this more difficult to implement. On the other side, these rules and restrictions are the foundation of Rust's safety guarantees! * In Rust, references are always valid. Having a `&amp;T` or `&amp;mut T` guarantees that the object they point to is valid. * Two usable references of type `&amp;mut T` *never* overlap. You can always be sure that if you have a usable `&amp;mut T` you are the only one who can access that `T` and nobody else can. That reference is the only access path. * In Rust, a data type `T` might not be `Copy` (copiable by copying the raw bits). So you might have to deal with a `T` that can only "move" from one memory location to another. These restrictions seem harsh but they tend to make it *much* easier to reason about code correctess for humans *and* compilers! :-) Because of rule 2 rule, you can't do this: fn swap_array_elements(arr: &amp;mut [T], i: usize, j: usize) { let refi = &amp;arr[i]; let refj = &amp;arr[j]; ... } Depending on the values for `i` and `j` refi and refj might overlap which would violate rule 2. Even if you checked this fn swap_array_elements(arr: &amp;mut [T], i: usize, j: usize) { if i==j { return; } // here, we can be sure that i != j so, it should be possible to // create two &amp;mut T pointing to distinct places of arr. let refi = &amp;arr[i]; let refj = &amp;arr[j]; ... } it won't work because the compiler isn't smart enough to figure out that it would be OK to do so. It basically doesn't understand that if we pass different indices to the index operator, we'll get different non-overlapping references back. After we create `refi` it considers the whole array borrowed and only lets us use `refi` to access one element of it. Using `arr` again is off the table to avoid violating rule 2. Another problem is that as a consequence of rule 1 and 3 we cannot move a value out from behind a reference because that would make the reference invalid. The solution to these restrictions is to create higher level APIs that do what we want/need such as the `split_at_mut` and `swap` methods for mutable slices, or `mem::swap`. Under the hood these are implemented using unsafe code. This involves an `unsafe` code block, a scope in which a compiler allows us to use raw pointers, create variables on the stack with an invalid state, or call other unsafe functions with preconditions that the compiler can't verify for us. We don't expect the compiler to be able to check the correctness of these low-level implementations. In that sense, such an `unsafe` code block is basically saying to the compiler "trust me, I know what I'm doing". The nice thing is that if we're concerned about memory safety, we only need to focus our time on checking the correctness of unsafe code. The idea is to limit unsafe code to a minimum and isolate it to small islands that are only made accessible via a *safe* interfaces, for example `[T]::swap`. 
I meant the CSS hot-reloading features, which make the layout / UI coding almost as fast as if you were writing and layouting a website. The UI for the calculator for example took me maybe 20 minutes to write and style, only the business logic is where I am currently failing (ironic, isn't it). It's meant for actual applications, not just prototypes. Azul has no dependencies on Mac and Windows, and only 2 dependencies on Linux (libfontconfig and libxcb-xkb1).
No
In my case a reason would be rustup currently doesn’t support OpenBSD. 
u/fschutt How can we help with the project ? Do you accept donations ?
Most C and C++ compilers warn about it too, at least for simple types. Many don't track struct fields though.
I’m sorry - I didn’t realize that :/ I should have searched.
Sure. Rewrite same absolute rule: coder must not read undefined memory no matter what language. If a language guarantees no undefined variables, great, the rule is always satisfied without effort. That's what makes safe systems better.
Rust does allow the first form AFAIK.
I thought about making a custom derive, but I was just so excited about attribute macros becoming stable, I wanted to try it out. 
Thanks, I hadn't heard of that library before!
Direct link: https://rust-embedded.github.io/blog/2018-10-28-newsletter-14/
That's nice, but I wanted something that I could use with failure. 
Whoops, I meant to link to that. Too much in my copy/paste buffer. Thank you!
Safe Rust allows for uninitialized values as long as you don’t use them. [Example here](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=df5687b13a479549e2cb0902fa41c016). However, no one will want to debate how useless that is. :D
This is the guy behind parking_lot as well, looks promising!
This is cool. Any chance of this getting into the stdlib when it's more mature? /u/Amanieu?
Safe Rust allows double drops, mutation of immutable variables, etc. in unreachable code as well.
Probably not, the reason the default hash is so particulary slow, is that it's designed to be cryptographically secure by default, so when people write a naive webserver or something with hashmaps hey don't run in the danger of DOS by crafting malicious input to cause collisions.
Well the financial support (in the future) should be backed by my main business, which is selling maps and graphic design services + semi-automatic cartography (which is what I developed a desktop application for using that framework, to process maps). I hope that I can start maps4print until the end of December, I do think it's doable. So that should cover the finances well enough that I can keep developing Azul for the next years to come. The easiest way to help is testing - if you have a Mac, try helping with getting it to run, getting webrender to run, help winit to get proper wayland support (reviewing PRs is also an important part of the work). And you could start writing widgets and see if the documentation is sufficient - try making a drop down application menu for example using the existing documentation and the existing CSS, then tell me if you run into problems. And review the documentation, is everything clear enough - I have worked on this codebase for the last 10 months, so obviously I know it inside out, but newcomers may not. The problem is that I can't really see what's "obvious" and what's unclear / undocumented. The chat link on the website is for a discord channel where I'm always ready to help (eventually I should set up a forum, but that can wait for now). The goal however, is that people can use the framework without asking me first - the documentation should be enough. Documentation and writing tests is a large area where you could help.
I'm being lazy not reading to find out, but can I use this in the browser too so I can make UIs that work in the browser or desktop. If not is it a possible future direction to split this up to make that possible?
If you look at the documentation, it supports arbitrary hashing algorithms and simply uses fx by default. One could imagine that a version of this could get into the stdlib, just with the default hashing algorithm changed to sip.
I couldn't find a standalone installer for wasm (so that I can copy the standard library or core library from it) and I'm not sure a standalone installer would make sense since the installers seem to be for host build environments. Thank you anyway for trying to help. I've expanded further [here](https://www.reddit.com/r/rust/comments/9skiyi/wasm_without_rustup/e8pzkvb/) in this thread. 
[Allows](https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%3B%0A%20%20%20%20if%20%22Rust%22.len()%20%3D%3D%204%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%205%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%2042%3B%0A%20%20%20%20%7D%0A%7D)
I'm very aware that I can use rustup to install the required files. This thread is specifically for setting the build environment manually. 
r/pcj
So just to be clear, by saying it's \*for making\* desktop applications, is it fair to assume that making mobile applications is explicitly \*\*not\*\* within the scope of what you want to do with this framework?
Thank you again for helping out. I really appreciate it! It turns out that I was wrong and stdandard libs do have a predictable path on static.rust-lang.org (see edit in GP) and are signed no less. For 1.30.0, the library URLs are: * https://static.rust-lang.org/dist/rust-std-1.30.0-wasm32-unknown-emscripten.tar.gz * https://static.rust-lang.org/dist/rust-std-1.30.0-wasm32-unknown-emscripten.tar.gz.asc * https://static.rust-lang.org/dist/rust-std-1.30.0-wasm32-unknown-unknown.tar.gz * https://static.rust-lang.org/dist/rust-std-1.30.0-wasm32-unknown-unknown.tar.gz.asc Whether either variant works on stable is something I intend to test once I have them installed. I plan to update here regardless of outcome. 
Thank you again for helping out. I really appreciate it! It turns out that I was wrong and stdandard libs do have a predictable path on static.rust-lang.org (see edit in GP) and are signed no less. For 1.30.0, the library URLs are: * https://static.rust-lang.org/dist/rust-std-1.30.0-wasm32-unknown-emscripten.tar.gz * https://static.rust-lang.org/dist/rust-std-1.30.0-wasm32-unknown-emscripten.tar.gz.asc * https://static.rust-lang.org/dist/rust-std-1.30.0-wasm32-unknown-unknown.tar.gz * https://static.rust-lang.org/dist/rust-std-1.30.0-wasm32-unknown-unknown.tar.gz.asc Whether either variant works on stable is something I intend to test once I have them installed. I plan to update here regardless of outcome. 
Oh no, now the copyright will expire in the year 2205 instead of 2206 :p
&gt; C++ ABI is as standard as C's ABI. I assume you're talking about the [Itanium C++ ABI](https://itanium-cxx-abi.github.io/cxx-abi/)? People have been working on that since the early 2000s (eg. Wikipedia cites that document as written in 2001 and cited in 2006) but it's still not safe to just implement a specific ABI and expect all C++ compilers to be happy with it. Also, ABI compatibility is about more than just a compiler. For example, this [this StackOverflow answer](https://stackoverflow.com/a/11683966/435253) from 2012 and its comments go into more detail on why `std::string`'s implementation is one of the things that was causing problems with compatibility between `g++` and `clang++`. While I don't have a citation, my understanding is that the current state of things is "There's a push to standardize on the Itanium C++ ABI, but who knows how long it'll take for all compilers to come into alignment.") &gt; You also cannot map all these concept to rust directly, so that's why it is harder. That's what makes it harder for [rust-bindgen](https://github.com/rust-lang-nursery/rust-bindgen). It still punts to a C++ compiler to do the C++-to-C ABI translation.
Certainly! For example, we wanted to use SIMD for `is_sorted` ([tracking issue](https://github.com/rust-lang/rust/issues/53485)). There is one major problem/blocker still: `libcore` does not have runtime detection of SIMD stuff. And since many things (including `is_sorted`) are in `libcore`, that's a problem. See [this comment](https://github.com/rust-lang/rfcs/pull/2492#issuecomment-422783212) for more information.
Would make sense to bench it using sip for an actual comparison though.
Really depends on the behaviour of the language. In Rust, attempting to use a variable the compiler can't prove has been initialised is an error, so this concern really doesn't exist. You can step around this with some unsafe code if you need to, but in everyday code you don't even have to think about it - the compiler thinks about it on your behalf. Other languages have made other decisions, and the advice you were taught no doubt comes from C, where leaving variables uninitialised and then reading their values anyway could lead to all sorts of strange bugs. Modern C compilers may warn you when this happens, but once upon a time it was entirely up to the programmer to sort it out.
Read the docs.
I was going to ask the same question. It certainly looks like the API could be adapted. I think the idea would be more of a web forms type gui than a general div and span interface though. I'm also curious about mobile support, is that planned?
Noob question. I have worker threads collecting stats into `HashMap` and wanted to use `hashbrown::HashMap` but got errors in return. How do I deal with such errors? ```rust error[E0277]: `std::ptr::NonNull&lt;u8&gt;` cannot be sent between threads safely --&gt; src/main.rs:81:5 | 81 | thread::spawn(move || { hashbrown::HashMap::new() } ); | ^^^^^^^^^^^^^ `std::ptr::NonNull&lt;u8&gt;` cannot be sent between threads safely |```
It seems that you have found a bug! Can you open an issue for it?
Yeah, this is just the first contrived example I could think of late at night. I was trying to point out that Rust is more of an expressive language than others, so this kind of thing is possible.
very interested in this! out of curiosity, were any comparisons done to indexmap/ordermap?
https://github.com/Amanieu/hashbrown/issues/2
&gt; This complexity is proven to be optimal and α(n) has value below 5 for any n that can be written in the observable universe. Love this sentence.
/r/playrust
Minor nit: in the code blocks on the page, it's almost impossible to read the dark-gray-on-black comments, at least for my eyes.
Adding to what /u/nicoburns said, we will have two uses of a trait as a type: * `dyn Trait` acts as an *unsized* type. The actual type is erased and typically *not* known at compile-time. These types only work behind pointer-like things and the right methods are looked up at runtime (dynamic dispatch) with the help of a "virtual function pointer table". * `impl Trait` acts as a placeholder for some concrete type (that implements the trait). This type's name might be too complicated or even impossible to spell (if it hasn't any). With the help of `impl Trait` you can, for example, write a function that returns a closure object without having to "box" it.
Thanks, I'm looking forward to having array size elision.. 
That's what the comparison with `FxHashMap` is
Glad to hear it! I didn't realize they had reliable URLs for targets. Re: stable vs. nightly, it's my understanding that compiling to WASM is stable but some of the other things the two main JavaScript binding libraries do require nightly features. Still, hope it works well for your purposes.
An explanation about why exactly it faster will be nice.
Can you give an example?
The latter I agree with. The former I don't, because there's a difference in reproducibility. I worked on a game where I got a bug report with a convoluted set of steps that involved traversing through the UI in a very particular way, at which point the game would crash. It turned out the result was due to an uninitialized variable in the business logic for one of the UI screens. Usually when accessing that screen, it would be harmless, but by going through a particular set of actions you could manipulate the stack to put something dangerous in that location. If it wasn't for the dedication of that tester to reducing that bug from a "game crashes on X screen sometimes" to "here's a set of steps to crash the game", we probably never would have found it. Even when your logic is bad, it's better to have reproducible behavior than non-reproducible behavior. And that's why it's important to always initialize variables in languages that don't enforce it.
The linked video in the readme gives a quite detailed explanation: https://www.youtube.com/watch?v=ncHmEUmJZf4
Obviously I start by reading the readme and/or the docs, but beyond that it really depends on *why* I want to dive into the codebase. Typically I'm not trying to understand all of the code but I'm rather trying to understand how the crate implements a certain specific thing. Or if I'm trying to fix a bug or something, I'm also looking for very specific bits of code rather than trying to understand the whole crate. In that case, I use the github search feature quite a lot. It's pretty useful that in rust, you can find the definition of things by searching for `"fn foo"`, `"enum Foo"`, `"trait Foo"`, etc. Nothing is in between that "fn/enum/trait" and the name, even for complicated generic functions with lots of trait bounds. Only macros can mess this up I think. And once I've found the function/trait/etc I'm looking for, I read its implementation and if I want to know how the functions that it is calling are implemented, I again use the Github search feature, and then again, etc. I often end up with quite a few Github tabs open.
This looks cool, does it suport styling ? css ?
Fairly unlikely, considering that I've been developing a different UI toolkit specifically for it (currently xi-win-ui, but in the process of being renamed to druid). That said, I encourage experimentation, and at present Azul is more cross-platform than mine.
[Mutation of unreachable immutable variables failing to build](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=a1b2ba85ce2a089e06ea4085191d34dd)
Ah cool! I might need to make some documentation PRs then. I didn't dig too deeply but surface-level intro docs definitely mention using nightly.
After a quick skim, this looks like a direct port of google's implementation of SwissTable found here: [https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw\_hash\_set.h](https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h). It would be nice to acknowledge that. IANAL but maybe you are required to. Also perhaps consider naming it swisstable-rs? :-) Really nice numbers. Did you try to port google's benchmarks as well? [https://github.com/google/hashtable-benchmarks](https://github.com/google/hashtable-benchmarks). They are probably more comprehensive.
Ah yeah, it might be a bit out of date!
Hi all, I'm trying to store a `HashMap` of `String` keys and `Any` values. However, I would also like to be able to clone this hash map. Something like the following: use std::collections::HashMap; use std::any::Any; fn main() { // really, stuff should be inserted here, but whatever let map: HashMap&lt;String, Box&lt;Any&gt;&gt; = HashMap::new(); // Does not compile, since Any is not Clone! let map2 = map.clone(); } But of course this won't work because Any is not Clone. So I've also tried using `HashMap&lt;String, Box&lt;Any + Clone&gt;&gt;` but this doesn't work, as "only auto traits can be used as additional traits in a trait object". What I'm trying to express is that I want to allow any clone-able type in the HashMap, and I can't seem to express that statically in Rust. An alternate approach could be to keep the hash map type as `HashMap&lt;String, Box&lt;Any&gt;&gt;` but then implement my own clone function which could check dynamically whether or not each value implements Clone, and if not then panic. It's not as nice, and less performant than having the static guarantee, but for my use I would be fine with it. However, I've also failed to get this to work. Specifically, the `is` and `downcast_ref` functions for `Any` only seem to work with concrete types, and not trait objects, so I have no way to do this dynamic check. At this point I'm very stuck. I know this seems like a bit of weird pattern to want to implement, but I've iterated several times on this and I feel like it is a good choice for me. At this point I don't know what other options there are, other than abandoning Rust.
&gt;The easiest way to help is testing - if you have a Mac, try helping with getting it to run, getting webrender to run, help winit to get proper wayland support (reviewing PRs is also an important part of the work). And you could start writing widgets and see if the documentation is sufficient - try making a drop down application menu for example using the existing documentation and the existing CSS, then tell me if you run into problems. And review the documentation, is everything clear enough - I have worked on this codebase for the last 10 months, so obviously I know it inside out, but newcomers may not. The problem is that I can't really see what's "obvious" and what's unclear / undocumented. The chat link on the website is for a discord channel where I'm always ready to help (eventually I should set up a forum, but that can wait for now). The goal however, is that people can use the framework without asking me first - the documentation should be enough. Documentation and writing tests is a large area where you could help. Hello World in a Mac does not work correctly: **extern crate** azul; **use** azul::{prelude::\*, widgets::{label::Label, button::Button}}; **struct** MyDataModel { **counter**: **usize**, } **impl** Layout **for** MyDataModel { **fn** layout(&amp;**self**, \_info: WindowInfo&lt;**Self**\&gt;) -&gt; Dom&lt;**Self**\&gt; { **let** label = Label::*new*(format!(**"{}"**, **self**.**counter**)).dom(); **let** button = Button::*with\_label*(**"Update counter"**).dom() .with\_callback(On::*MouseUp*, Callback(update\_counter)); Dom::*new*(NodeType::*Div*) .with\_child(label) .with\_child(button) } } **fn** update\_counter(app\_state: &amp;**mut** AppState&lt;MyDataModel&gt;, \_event: WindowEvent&lt;MyDataModel&gt;) -&gt; UpdateScreen { app\_state.**data**.modify(|state| state.**counter** \+= 1); UpdateScreen::*Redraw* } **fn** main() { **let** app = App::*new*(MyDataModel { **counter**: 0 }, AppConfig::*default*()); app.run(Window::*new*(WindowCreateOptions::*default*(), Css::*native*()).unwrap()).unwrap(); } [https://imgur.com/a/Ksd7Nhq](https://imgur.com/a/Ksd7Nhq) I can run all the examples that you notice. Could you tell me your contacts to report the problems?
Im building a tool to convert spreadsheet rows into a data format my companies system understands. Ive done the work in C#, just juicy enough to learn rust with :) Slowly getting there 
Only for nostd and a small speedup from branch hints.
In the Edition Guide/[Unstable feature status](https://rust-lang-nursery.github.io/edition-guide/unstable-feature-status.html) some of the linked tracking issues are already closed. Shouldn't status of these features be updated?
Yes, I need to do that! Thanks for the reminder.
Well the standard library offers resistance against HashDoS attacks (by using SipHash) and hashbrown does not.
Since it's a `String`, there is a pointer indirection in order to compare it, so I do not really think that would have much of an effect.
Right, and I guess you are referring to the System V ABI for C. But even then, not all compiler do the same thing. For example `sizeof(long)` is 4 on MSVC, but is 8 on GCC/linux. Knowing how to pass a `struct { int x; double y; }` is also not so easy (in which register goes what) and it's a good thing that rust can let LLVM do that for the `repr(C)` calls. The different implementation of the standard library are another problem. But overall, all of this is irrelevant IMHO for C++ integration. It works alright with the help of a C++ compiler (which is what the `cpp` crates does) 
It is faster at what key size? Different hashing algos have different speeds according to size of key. Fnv for instance is good at small keys, xxhash is good for larger ones
I really wish `parking_lot` would just be a part of the `std`; I end up pulling it for a free speedup in basically almost every one of my projects.
Yeah, I know about this... see [#5](https://github.com/maps4print/azul/issues/5) - the question is, can you run webrender demos? If yes, simply try logging everything related to the main renderer - previous debugging showed that it was less of a redrawing problem, but at some point webrender just stops drawing for some reason and it's likely a problem of azul, not webrender.
[Unreachable mutation of immutable variable building succesfully](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=72d8c0ebbce5875343b02c9ad0a2614f)
The code was heavily inspired by SwissTable, and some parts are almost a direct port. However there are also some differences: - I changed the encoding of the empty/deleted control bytes to be simpler: the original SwissTable had a sentinel value which was needed because of how C++ iterators work. This allows some of the byte matching code to be simplified. - 32-bit platforms use a 4-byte group size, which is faster than using 64-bit integers (which are emulated using 2 32-bit integers). - H1 and H2 have been inverted: H2 uses the top 7 bits of the hash instead of the bottom 7 bits. This results in slightly more efficient code. - I support tables that are smaller than the group size. I can certainly make it clearer in the README that this is based on SwissTable! :) Regarding benchmarks, there is an [open issue](https://github.com/Amanieu/hashbrown/issues/4) for improving them. I rushed the finishing touches a bit since I wanted this to be ready for the London Rust Meetup yesterday. The competition fastest hashtable implementation is quite contended: there's F14, SwissTable, khash, bytell, etc. The main reason why I chose to port SwissTable rather than any of the others is that I plan on implementing a concurrent hash map in the future and this is the only one that can be adapted to work as a lock-free hash map.
&gt; Right, and I guess you are referring to the System V ABI for C. But even then, not all compiler do the same thing. For example `sizeof(long)` is 4 on MSVC, but is 8 on GCC/linux. I'll give you that. I sort of put MSVC vs. GCC out of mind as just another way in which Microsoft deviates from various standards (*de facto* or *de jure*) which others follow. &gt; But overall, all of this is irrelevant IMHO for C++ integration. It works alright with the help of a C++ compiler (which is what the cpp crates does) Yes, but, by that standard, you can argue that any language with good C interop and support for abstracting calls to a C++ compiler in its build scripts also has good C++ interop because people can write `extern "C"` shims in a bundled C++ file.
"Based on Google's SwissTable" reads slightly different than direct porting the code from C++ to Rust. The former suggests a clean room implementation while the latter acknowledges this is not one. The links in the readme are to the video and blogpost and not to the code. Both lack details on a lot of abstractions and optimizations that are part of the code: BitMask (for portability), ProbeSeq, the choice of which bits mark what in both SSE and scalar implementations, the fast rehash\_in\_place algorithm, the erase optimizations, the floating groups, tracking free slots instead of full slots. There is a ton of work done to get to that where [https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw\_hash\_set.h](https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h) is today and it is fair to acknowledge that.
&gt; In addition, we have some new lints we’d like you to try; they’re described at the very end of the post. I couldn't find those, or is it referring to the section on `cargo fix`?
From Programming Rust, I learned that closures are better thought of not as dynamically created functions, but as dynamically created \*structs\* whose members are the captured variables (or references to them), that automatically instantiate the struct when they capture their variables, and that \`impl\` their function (in the appropriate \`Fn\*\` trait). This is both the key to understanding why they're so fast (static function lookup, like any other struct), and why their type is (so far) unnameable. Even if you could somehow name it by its captured values and function signature, you still need a different type for each closure, because it \`impl\` a different function. It also suggests that if you need a more complex combination of ownership and borrowing, rather than capturing all needed variables the same way, you can get it for the price of the verbosity of creating your own struct that implements the appropriate \`Fn\*\` trait).
Thanks Amanieu. I have a rust port of both SwissTable and the benchmarks stashed somewhere. I will try to open source the benchmarks.
&gt; What I meant by "async" was that you can load a file in the background without blocking the UI (on a separate thread). In desktop applications the futures / tokio / async IO features have diminishing returns in terms of performance - these things are more meant for servers with 10000 parallel users, where the number of requests are much, much larger than the number of threads you have, so you have to distribute the loading of files across a certain number of threads - but in a desktop app, how many files / connections are you loading at the same time? One, maybe two? The reason I originally implemented this was to connect to a database, load some data (which can take a few seconds) and then display that data without blocking the main thread. A sweet love, maybe they should rewrite Eclipse in RUST with your Framework in place, ... then they'd be able to handle more then 1 task at once without display a popup "waiting for task to finish" (and clicking cancel does nothing of course since the task isn't finished). I always break out in sweet and tears when I see that dialogue (my work forces me to use it) ...
I think the main drawback is not storing full-ish hashes so rehashes have to re-apply the hash algorithm to all items. That might be a hit in some insert cases, like if your type is "hard" to hash and/or your hashing algorithm is slow.
Good news! I have managed to get a poc working. I can't thank you enough for the support you've shown in this thread. I actually started to consider emulating a full virtual x86_64 machine to get my code running in a browser. Now it looks like I won't need to go that far. I plan to post a full write up on exactly what I've done to get things working. Surprisingly, achieving this was easy enough for me to suspect that this way is actually an undocumented first-class way of setting things up (Thanks rust devs!). 
Are there any good benchmarks for this? I see one file with `std::test` benchmarks, but the test data looks quite arbitrary, and frankly I don't trust the variances reported by `std::test`. Hash table performance depends on many factors such as table size, and especially for flat hash tables like SwissTable, the size of the key and the value. But more importantly, differences between hot and cold hash tables are enormous. Doing inserts in a tight loop in a microbenchmark is one thing, but the more common production workload is lookups in cold hash tables. (Not necessarily large tables either.) Constructing a good benchmark to measure how long operations take on a *cold* hash table is not trivial.
Someone replace the fxhashmap in rustc with this to see if we see speedups.
&gt; The first step is to run cargo fix: &gt; &gt; `$ cargo fix --edition` &gt; &gt; This will check your code, and automatically fix any issues that it can. This is awesome! 
Average length of string also plays in. Uncommon, but if the length is on average "large", BTreeMap could be better
There's the [minifb](https://crates.io/crates/minifb) crate, which is a lightweight, pure-Rust library for getting a window with a pixel buffer, along with some basic keyboard/mouse input.
Thank you!
That's interesting, any idea where this limitation comes from?
Unless all strings share a common prefix.
The full explanation is in the linked video; it's also implemented in the Abseil library if you want some more details. The succinct version is that the instead of organizing a hash map *slot by slot*, you instead organize it in *group by group*, with each group containing 16 slots. You then build two tables: - an index table, containing 16 bytes per group. - an element table, containing 16 elements (key + value) per group. With that setup, a look-up is: 1. Hash the element. 2. Split the hash in two parts: residual (7 bits) and index (57 bits). 3. Trim the index (`% number groups`). 4. Use a single SSE2 instruction to look for all equal residuals of that group in the index table. 5. For all equal residuals, actually check the key in the element table. 6. If still not found, apply quadratic probing to find the index of the next group to probe. (The 8th bit of the byte is used to encode special states: EMPTY, TOMBSTONE, etc...) Already, just from the algorithm, you can guess than checking 16 residuals at a time is promising. Surprisingly, though, even without SSE2 it would still be a good strategy! There is a tension in Open-Addressed tables: cache-friendliness versus clustering. The 2 typical probing algorithms (Linear and Quadratic) pick a different trade-off: - Linear Probing means just incrementing the index by 1 to get to the next element (or group). It's cache friendly, however it means that if multiple elements start to form a long contiguous section (a cluster) then the cluster will just keep growing and look-up times will degrade significantly as the only way to know that an element *isn't* in the map is to check until the end of the cluster. And the *isn't* check has to be done for each insertion... - Quadratic Probing means incrementing the index by a quadratically increasing sequence (typically: 1, 2, 4, 8, ...). It helps keeps clustering down, however it means that after probing 2 or 3 elements the increment has gotten so big that you get a cache miss for each further element. What makes the Swiss hash table so good then? It mixes both! It has a Quadratic Probing of groups, which tends to keep clustering down (and thus the length of probing sequence), and combines it with a Linear Probing within the group, which is extremely cache-friendly. It would probably be a nice implementation even without bothering with an index and SIMD; with it it's a killer. Interestingly, in hindsight, this "groups" thing is exactly why a B-Tree is much faster than a Binary Tree...
Maybe make sure you have the `Connection` trait in scope (i.e., `use diesel::prelude::*`)? Not sure why other than that.
It's not super vicious. Gotta understand where this comes from - VST was released in 1998 as a hacked together API for extensions to one of the only (usable) DAWs around. It was never meant to be open source or to become a standard, as an industry we kind of shot ourselves in the foot by relying on it. And everyone who already has a financial stake in this is already covered by their license agreements, its new projects/developers that are getting screwed. There's a lot of context and technical debt here. Plugin developers are used to supporting multiple APIs for decades, so there have been solutions to deal with this. Today the best answer is JUCE, which supports exports to AAX/AU/VST3 out of the box. There's also been industry (and outside) efforts to create standards not beholden to the hosts. The most successful is LV2, which still hasn't been adopted anywhere but Linux. The most ambitious was GMPI, which was an industry effort to create a standard - you can go through the mailing list and see how that fell apart, LV2 and SynthEdit are to my knowledge the only existing standards that implement (most) of the ideas from GMPI. At the end of the day this debacle is a good thing imo. 
&gt; The main reason why I chose to port SwissTable rather than any of the others is that I plan on implementing a concurrent hash map in the future and this is the only one that can be adapted to work as a lock-free hash map. Having an implementation of Swiss Tables was juicy already, but this sounds amazing to my ears. Please do keep us abreast of developments on that front!
that's actually perfect for me, since my objects cache their hash anyway, since they're hard to recompute from scratch (they're a hash of their children, which can go arbitrarily deep, but they're built from bottom-up). good to know.
Hi there! I've defined a generic struct with a type bound, and I'd like to not have to retype that bound for all my `impl` clauses. In the code below, I have to repeat the `where` clause on the impl, and my `where` clause is somewhat more complex. I don't want to have to copy-paste, because then if I change anything I have to change it across all my `impl` statements. pub struct Foo&lt;T&gt; where T: Eq { // stuff } impl&lt;T&gt; Foo&lt;T&gt; where T: Eq { // stuff } What's the correct syntax for this? &amp;#x200B; \~Cheers
Ok! This something comparable to relm so, but using a WebRenderer instead of GTK. I remember what means GUI now :-)
and a really cool board game
Wow. This is amazing. I've replaced FNV Hasher in my whatlang lib with hashbrown and got 28% boost. A little bit more details are in this PR: [https://github.com/greyblake/whatlang-rs/pull/25](https://github.com/greyblake/whatlang-rs/pull/25) &amp;#x200B; I haven't got time yet to looks into the source code of hashbrown, but I really impressed! Thank you!
It might happen: https://internals.rust-lang.org/t/standard-library-synchronization-primitives-and-undefined-behavior/8439
It looks like the source code if full of \`unsafe\` . So the question. Is it safe?:) Would you consider adding property based tests?
Just to add on to that, you can do both of those without the `mut`; in both cases Rust can figure out that the variable is being assigned exactly once.
I just started working on Kythe's Rust [indexer](https://github.com/google/kythe/tree/master/kythe/rust). I'm trying to get it working with a recent nightly ([#3197](https://github.com/google/kythe/issues/3197)). Observations so far - * It doesn't compile with `nightly-2016-08-16` (date of last release of `cargo-kythe` on crates.io). * It compiles okay with `nightly-2016-10-17`. * rustup can't download cargo for `nightly-2016-12-16` (???). It gives a 404 while downloading, and "[33] requested range was not delivered". Maybe there's some corruption there? ¯\\_(ツ)_/¯ * Despite it saying "nightly" on the tin, there isn't a nightly release for every night (???) - e.g. `nightly-2016-12-15` is not an actual release.
This is awesome! I wonder whether we could/should consider moving the compiler to use it?
I usually start by taking a look at the \`Cargo.toml\` contents, then I take a look at the examples if there are any. After that, I take a look at the parts I'm interested in (usually traits, structs, functions that are used in the examples), then I proceed to where these parts lead me.
Thank you!
Published! https://crates.io/crates/ics
I read through your blog posts on this a while ago and it was very interesting. I would have loved to know more about things that were difficult (or east) compared to the c++ original though. Did you ever do any benchmarks against the c++ version?
gfycat seems to be down right now. [Here is another link to the video]( https://my.mixtape.moe/touceb.mp4)
The fact that the default hasher is different from the one in the standard library makes me uncomfortable, for both consistency and security-by-default reasons. It should at least be mentioned in the README.
Eh, harsh.
This approach actually is very similar to how B-tree improved compared to binary tree. SIMD is just icing on the cake. [More info](https://www.reddit.com/r/rust/comments/9sn4ze/github_amanieuhashbrown_a_faster_hashmap_for_rust/e8qotrp/)
If you're looking for a relatively easy way to comprehensively test this thing, https://github.com/blt/bughunt-rust has a QuickCheck model of a hash table and a setup to compare std::HashMap against it, inspired by [similar work on Erlang maps](https://medium.com/@jlouis666/breaking-erlang-maps-4-4ebc3c64068c). You should be able to put yours in as a drop-in replacement, perhaps it will find some interesting failure cases.
Cool, i'm looking forward to even faster B-trees! (I know some might say do it yourself, but i'm not knowledgeable enough yet to do that).
Very cool! Was about to incorporate specs, but now I'll check out Pyro too! (There are a few typos, namely `missle` instead of `missile`, not sure if they are intentional and I miss something ;)) &amp;#x200B;
After you've migrated to the 2018 edition, \`cargo +beta fix --edition-idioms\` will transfer your code some more. This included non-macro \`extern crate\` removal for me.
Not all heroes wear capes my friend.
Is anyone else getting false negatives with the VCS detection of \`cargo fix\`? I had to add \`--allow-no-vcs\` for \[my project\]([https://github.com/tomassedovic/dose-response](https://github.com/tomassedovic/dose-response)) despite being under git. &amp;#x200B; Other than that though, everything worked great! Kudos to everyone who made the edition and \`cargo fix\` happen. This is fantastic.
Thanks guys. That totally solved it ! 
I've been working on a [web-based RSS reader](https://github.com/richardbrodie/hermes), kind of similar to miniflux, for a while. But I've decided it'll be more fun to rebuild it as a TUI app instead. So this week I've broken out some of the feed-updating code as a separate crate, called [hermod](https://crates.io/crates/hermod). 
But...why? I'm not asserting that it's necessarily a bad idea, I'm genuinely curious why you'd bother. It seems (not knowing your problem domain) like an arbitrary restriction.
Yes you can do it using [`cfg!`](https://doc.rust-lang.org/book/first-edition/conditional-compilation.html#cfg) macro. 
How about pub struct Foo&lt;T: Eq&gt; { t : T, } impl&lt;T: Eq&gt; Foo&lt;T&gt; { fn truth(self) -&gt; bool { self.t == self.t } } The way I remember it is that the `T` beside the `impl` brings the type variable `T` into scope, so it makes sense to say that "hey, my type variable satisfies these traits" at the definition site rather than at the use site (in `Foo&lt;T&gt;`).
That sounds like hand-rolled monomorphisation. Are you sure you can't do it with a trait?
I gave it a try, but the `hash_map` test case doesn't seem to be working? I get "Oops, the program crashed with one of the test cases provided." when I try to run it with afl. The other test cases work fine.
poset -&gt; `PartialOrd` surely? Then the answer could just be to have a trivial implementation (where partial_cmp returns `None` for all pairs). And then the interpreter for your search range can complain about passing two non-comparable terms in. It just complains for all possible pairs in your small-set case?
Good tip, thanks. I haven't explicitly tested cross-mount copies yet (along with a lot of other stuff, which is why it's alpha :) ). I'll need to have a fall-back anyway when I implement non-Linux support. I actually read your code when I started implementing xcp, which gave me a few good tips, (although I missed the EXDEV stuff), so thanks! On a related note, would you be interested in patches to handle sparse files?
Is there any wah to know which fields are actually required? could the parsing return a result and return err if any required field was empty?
Quick note since this confused me initially: if cfg!(...) { ends up as if true { (or false), whereas #[cfg(...)] attribute can result in code existing or not existing at all. 
Will optimizations not remove the dead branch with `cfg!`?
I'm sure you're aware that this overlaps with the pretty popular probabilistic programming language built by Uber
I made a test script so I can learn about Options and Results. Here it is: fn main() { let var = give_opt(true); println!("{:?}", var); let var2 = give_result(true); println!("{:?}", var2); } fn give_opt(par: bool) -&gt; Option&lt;String&gt; { if par == true { Some(String::from("I am a String")) } else { None } } fn give_result(par: bool) -&gt; Result&lt;String, std::io::Error&gt; { if par == true { Ok(String::from("Whatever you did - it worked!")) } else { Err() } } I have three questions: 1. This doesn't work because the compiler complains about this: &amp;#8203; | 21 | Err() | ^^^^^ expected 1 parameter I tried loads of different things. Strings, std::io::Error, std::fmt::Error, etc. But nothing worked. I just want to return an Err() with an error message. How do I do it? &amp;#x200B; 2. The Option function returns either Some() or None. So what's with the `-&gt; Option&lt;String&gt;` ?? If I return None then I won't return a String. So it's obviously wrong. But it obviously works!?!?!? What am I not getting here? Why do I specify that I return an Option with a String if I can also return None? Which is just None, meaning no String. 3. Similar question about the Result function. Why do I need to specify two types here? What else would I be returning but an Error? I though this is the whole point of a Result? Why do I need to specify two return types for the Result but not for the Option? So confusing.
["compare compiler performance with `hashbrown`" #55514](https://github.com/rust-lang/rust/issues/55514) :)
Oooh, another ECS using SOA! And there's an ECS bench suite? [FITE ME!](https://raw.githubusercontent.com/purpleposeidon/ecs_bench/b29386ca17005efc917cdd116283d416d8de10ff/graph/all.png) *is immediately beaten* Well, second best on `update` isn't too bad! And it's a bit ridiculous to throw away the entire universe in `build()`; clearing the tables would be more reasonable. [(My fork of the bench repo.)](https://github.com/purpleposeidon/ecs_bench) Bench defense seems like it'd be a great benchmark! 
Yes, but the code still has to compile first. So if some conditional parts don't play with others, you need the attribute. 
That's very cool! The performances are impressive. Do you have more documentation on the SoA architecture? I would like to know how it differs from other linear storages from specs.
&gt; While an ECS might not give you the best theoretical performance I keep hearing around the place that ECS is much more performant than OOP style as per rust keynote talk. What's the theoretical fastest ? You can't just tease us like that 😝
It's pretty aggressive to tell the author they need to link to the original code and rename it to match the original library. :\
Ahhh OK. So for a Result the two return types I specify are the ones that COULD (!!) come back. Only one of them will. But I specify both of them anyway. Understood. But the Err() thing still isn't clear. What do I have to put into "Err()" (well in the parantheses). I just need a generic Error. but std::io::Error didn't work. So what do I do? I tried everything. Can you give me a simple example?
I'm confused, those don't look the same, filter_map doesn't the filter map version drop the matched value and convert the iterator type to `Iterator&lt;Item = Entity&gt;` where as the filter version only removes the elements unneeded but doesn't drop the extra tuple. `.filter(|(_, (enemy,))| enemy.health &lt;= 0.0).map(|e| e.0)`
Oh, I see, I missed the "my `where` clause is somewhat more complex" bit. Yes, that is one solution today where you define a new trait. Some time in the future, you'll also be able to uses aliases ([#41517](https://github.com/rust-lang/rust/issues/41517)).
You are correct. I didn't not notice that. Thank you! 😊
Theoretical fastest meaning if you had the time and or ability to write out all the data and accesses perfectly individually for each case and perfectly optimize etc, but this is not practical for real use. ECS is a model that incorporates benefits both in terms of performance (cache locality, data oriented programming) and programmer ergonomics (reasoning about what your code is doing), and that is why it is advantageous.
I don't know exactly what API the OP has in mind, but if C could do it with #ifdef then I don't see how it could need anything more than a trait with two impls.
Imagine this code: fn process(&amp;mut self, query: &amp;Query) { #[cfg(feature = "latin")] self.process_latin(query); #[cfg(feature = "numbers")] self.process_numbers(query); #[cfg(feature = "cyrillic")] self.process_cyrillic(query); #[cfg(feature = "katakana")] self.process_katakana(query); #[cfg(feature = "hiragana")] self.process_hiragana(query); // many-many additionall cases } If you'll implement it with traits you'll get combinatorial explosion of types to cover all possible combinations.
What is SoA? The link in the article seems to link to some random Intel forum topic. 
Have you seen the `evmap` crate? It's a lock-free hashmap that iirc just uses the std hashmap type, you might be able to generalize it to use this quite nicely.
It means _Structure of Arrays_, you can read more about it [here](https://en.wikipedia.org/wiki/AOS_and_SOA).
&gt; In contrast to many other ECS, iteration in Pyro is fully linear. Different combinations of components always live in the same storage. Unity's ECS _appears_ to work like this.
All this, and you didn't even bother to check that you were posting *to the wrong group*
Thanks for sharing. I'm looking forward to the follow up post about RESSA. Is the list below `"the above javascript as tokens would look like this"` missing the `period` between numbers 7 and 8?
They're basically on opposite ends of the spectrums for problems. Elixir provides a high level language with a beast of a run-time that is great for writing distributed services. Rust is very low level and gives you a lot of control over the system. They solve different problems and pair well inside an infrastructure org. Additionally we were able to extend elixir recently by moving to a rust NIF to hold a massive member list. Dealing with immutable data structures in Elixir had too much overhead. There should be a blog post about that soon. If you're interested https://github.com/hansihe/rustler was a great library to handle the FFI abstraction.
After having a read through the code, I am rather impressed. The design does look very similar to what I gather Unity have done, and is very similar to some ideas I had been considering for a constellation re-write (it's code is so terrible...). It is based on AoS though, not SoA. All of the components for an entity are located in a single structure, and all such structures of any archetype are stored in a single array.
I fixed the seg faults I was getting with my Scheme-&gt;amd64 JIT compiler. While my compiler guarantees that RDI is never clobbered, I call into code generated by rustc (primitives, runtime operations) which make no such guarantee and stupid me forgot this, so I just needed to save RDI before calls. This week I need to fix some bugs with lambdas, but then it should be in a usable state. Over the weekend I started a compiler for a C-like language, which I'm planning to use to learn about compiling static types and compiler optimizations. For that I need to figure out how to do type-checking and how to produce object files and executables.
Is ECS a popular design outside of gaming? 
Yep, sorry. I probably missed a semicolon or two as well. Typed it up late last night on mobile.
If the exact order doesn't matter and cannot be misinterpreted, you could assign/derive an arbitrary order and use it, if you want to keep things simple.
If you really want to select which encodings get excluded from the compilation, then `#[cfg]` would be necessary. That said, I can still see this using a trait for the encoding like so: trait Encoding { fn process(&amp;mut self, query: &amp;Query); } and maintaining a list of desired encodings that you can loop over with trait objects. In general, this isn't a problem rust is terribly great at. If you want to avoid the runtime cost of what I previously suggested, then I'd actually suggest wrapping the common unit: #[cfg(feature = "$enc")] self.$proc(query); In a macro to reduce repetition and half the number of lines.
You have to construct an instance of `std::io::Error` to carry the actual error information. It's typically used in representing errors from the OS, so it has the `last_os_error()` constructor, but this isn't really relevant in this context. You can have pretty much any type as the error type of `Result`, so you could return a string as an error instead: fn give_result(par: bool) -&gt; Result&lt;String, String&gt; { if par == true { Ok(String::from("Whatever you did - it worked!")) } else { Err(String::from("operation failed")) } }
There's a critical part of your question I think you're underweighting: _in C_. In Rust terms, everything in C is `Copy`, and writing swap for copy things is just as easy in Rust as in C. If before you had ```c void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; } ``` You could just write, in Rust, ```rust fn swap(a: &amp;mut i32, b: &amp;mut i32) { let t = *a; *a = *b; *b = t; } ``` It's even safe! It's only when you want to be able to handle things that C doesn't even have that there's more to think about.
Your description makes me feel sorry, really. I mean, the github search part.. It takes a lot of time and inaccurate, with constant page reloading on navigating back. I wish, one day we could navigate in code (including dependencies) via RLS or something, quickly and efficiently. I know, it works in basic cases now, but why the hell it includes all local variables in a file symbol list and misses enums at the same time.
The scanner returns an `Item`, which has 2 fields, `span` and `token`. I don’t really cover it in my post but the `span` property does provide the byte Index for the start and end of the `token` The parser doesn’t currently provide this information for its parts, currently. I am planning on working this into the AST in the near future
Came here to ask why the benchmark, assuming it is the benchmark, needs to render to the screen? The benchmark would be bottlenecked and perturbed by the graphics hardware, driver, perf, etc reasons!
I feel like I missed out some Geocities-esq nostalgia. 
This is a subreddit for the programming language Rust, not the game. You're looking for /r/playrust
I'm curious too. Hopefully someone with that knowledge replies! 
Ah, I see. I didn't realize OP needs to compare symbols that may be of different types in the same query. Doing that with generics would take some typenum-esque ExtendWith&lt;Latin, ExtendWith&lt;Numbers, ExtendWith&lt;Cyrillic, ...&gt;&gt;&gt; sort of hackery that would be no better than macros/codegen and produce error messages that would give me C++ flashbacks.
If you did make a clean room implementation, you wouldn't have downloaded the SDK, so you wouldn't have agreed to the terms of the license... Btw. rust-vst doesn't use anything from the SDK. It's an ABI-compatible reimplementation.
Thank you! I thought *Service oriented Architecture* made no sense here. Of course I know about *Structure of Arrays*.
Not that I know of at least using that phrasing. Games have a hard time with entanglement due to the way features get added and likely can benefit more from the performance boost. Lots of other things just use a database which is similar in a lot of ways. Isolated data, all stored optimally with explicit access allowing safe concurrent changes. The main difference is the scale of usage and the language you are accessing it in. Not saying ECS is just SQL for game objects just pointing out that similar benefits can be had without going full blown ECS. Also note that ECS makes some things super complicated especially when you get into saying everything you touch. Complicated processes end up getting split up which is usually good but can sometimes hide things happening like when you don't realize you only found the first of three steps.
I also was surprised about it not operating on the entire workspace. Having said that, looking at the `--help`, it appears the `--all` flag will do that. But it does seem like operating on the whole workspace by default would make more sense...? Maybe not. But for me, at least, I think of the whole workspace as a single project, and operating on only a subset of the project feels weird. Over-all, though, the process was super smooth.
I am not that familiar with specs but I assume vec storage wastes a lot of space if you have a lot of sparse entities, and you need to jump through the memory.
Naming is hard. The name "Pyro" in the Python world is already taken for some years: https://pyro4.readthedocs.io/ I was confues for a moment to read about Pyro in Rust land.
A while back I wrote a minimal histogram library based on ndarray for my particle physics [`alice-rs`](https://github.com/cbourjau/alice-rs) project. It looks like you are already quite far along the line, but maybe it can still provide some inspiration. You can find it in the `alice-rs` repository in the `histogram` folder.
You can* But yes, workspaces solved it for me as well.
/u/troutwine, any insight?
Renaming it to the original library has the benefit of being easier to find and immediately know it has the same properties across languages. hashbrown is a really cool name, but it is akin to calling a flate rust library aerate instead of flate just because aerate is cooler :-)
I've found a solution myself, here's a basic example: ```rust extern crate graphics; extern crate opengl_graphics; extern crate piston; extern crate sdl2_window; use graphics::Transformed; use opengl_graphics::*; use piston::event_loop::*; use piston::input::*; use piston::window::WindowSettings; use sdl2_window::Sdl2Window as Window; fn main() { // create window let mut window: Window = WindowSettings::new("piston: text", [200, 200]) .exit_on_esc(true) .build() .unwrap(); // create OpenGL context let mut gl = GlGraphics::new(OpenGL::V3_2); // load font let font = "/path/to/font.ttf"; let mut glyphs = GlyphCache::new(font, (), TextureSettings::new()).unwrap(); // main loop let mut events = Events::new(EventSettings::new()); while let Some(event) = events.next(&amp;mut window) { // handle render events if let Some(args) = event.render_args() { gl.draw(args.viewport(), |ctx, gl| { graphics::clear([0.0, 0.0, 0.0, 1.0], gl); let color = [0.0, 1.0, 0.0, 1.0]; let size = 32; let transform = ctx.transform.trans(10.0, 100.0); graphics::text::Text::new_color(color, size) .draw("Hello world!", &amp;mut glyphs, &amp;ctx.draw_state, transform, gl) .unwrap(); }); } } } ```
No, I haven’t done benchmarks (yet), but feel free to do some yourself. I think the C++ version writes a lot of information to a /tmp folder and that slows it down. You have to turn verbosity down to be fair. On the C++ vs. Rust side: In the beginning I struggled to learn the Rust language and fought the borrow checker (like everybody else), but once you got the basic ideas it was pretty straight forward to translate the C++ code to Rust. One bottleneck was the [std/sync/atomic](https://doc.rust-lang.org/std/sync/atomic/index.html) , especially `AtomicU64`, which forced me to use Rust **unstable** for a long time, the crate [integer-atomics](https://crates.io/crates/integer-atomics) was just too slow to justify using Rust stable, but that problem is gone now. Another performance problem I was hitting was described [here](https://users.rust-lang.org/t/profilers-and-how-to-interprete-results-on-recursive-functions/13222/6) ... bringing the BVH creation for a complex scene down from 17 minutes to 1.9 seconds, thanks to profilers.
The simple answer is it doesn't. It is trivial to disable the draw system. It is just more satisfying for me to write benchmark that has some visual representation.
Amazing week with cool releases :)
To add: I think in specs you declare a storage per component `Vec&lt;Position&gt;, Vec&lt;Health&gt;` etc. So it could look like this [Position1, Position2, Position3, Position4] [Health1 , Empty , Health3 , Empty ] Iteration over just position is very fast in this case because every entity has a position, but not every entity has health. If you want to iterate over position **and** health, then you needlessly load Position2 and Poisition4 in into the chache *simplified explanation*. In Pyro it doesn't waste any cache at all, but there are other tradeoffs.
The pithy way to put it is that a typical GC runtime is just an ECS system under another name-- since, just like an ECS, it wants to be aware of all live references between "entities" so that unreachable entities can be cleaned up - and often it wants these references to be abstract "handles" or ID's, not bare pointers, so that it can implement its own memory management strategies (memory compaction, etc.). Really all of this has a lot in common with an "in-memory database", it's just the way it's used that tends to be slightly different.
&gt; I'm coming from Python and Python cannot simply handle "~" It can: In [1]: import os In [2]: os.path.expanduser('~/tmp') Out[2]: '/home/joe/tmp' You will need to do the same pre-precessing in rust. &gt; these should always (as best practice) return a Result Yes, that's what you should do. &gt; what does the () mean? () is called unit and means "no data at all". &gt; How do i create a directory that sits in a users home directory without specifying a fixed path Same as in Python: https://crates.io/crates/expanduser
There is an example here using the OpenGL backend + SDL2: https://github.com/PistonDevelopers/opengl_graphics/blob/master/examples/text_test.rs
Why is it called cHTTP and not rHTTP?
Oh, thanks. I totally forgot about examples in other piston repos
I understand this is a binding to libcurl. What is the difference to https://github.com/alexcrichton/curl-rust ?
I hear you! Thanks for the feedback.
We're using ECS-like data structures in [Cranelift](https://github.com/CraneStation/cranelift), which is a compiler backend, for example.
Probably c for curl.
For posterity, these are 'unit-like' structs. https://doc.rust-lang.org/1.9.0/book/structs.html#unit-like-structs
Hi. This looks really helpful! Thanks for sharing. &amp;#x200B; Now, this looks somewhat related to an idea I have/had some days ago: From time to time I need to "extend" a type. That is, create a new trait and implement it on a foreign type. This trait will only be implemented \_once\_ - it is really just for this one time. A (proc-)macro would be really nice to do this, something like this: #[auto_trait(TraitName)] impl TraitName for Type { fn foo(&amp;self, i: i32) -&gt; i32 { i + 3 } }
One caveat: It is using `FxHash` per default, so you'd better not fill this with attacker-controlled keys or you might be in for some [DoS](http://www.shilpikhariwal.com/2012/03/hashdos-dos-using-hash-collision.html). Still seems to be faster than `FxHashMap` (which is `HashMap` with `FxHash`), but using an insecure default leaves a sour note.
&gt; and to also provide something that can leverage curl's reputation as a reliable client For me it crumbled once I actually started running it at scale. Random segfaults are not fun.
Very smooth! `cargo fix --edition-idioms` also worked nicely. Nits: In the article: Should we be running `cargo fix --edition` or `cargo +beta fix --edition` or is that the same anyway? `cargo fix` did not touch my build script (`[package] build = ...`), and so some manual tweaks were required to compile under 2018. Is that expected or should I file an issue?
&gt; Should we be running `cargo fix --edition` or `cargo +beta fix --edition` or is that the same anyway? Using `+beta` is best, unless you set `rustup default beta` you may run a slightly different version of `cargo fix` &gt; Is that expected or should I file an issue? I am actually not sure! You should file a bug against Cargo: https://github.com/rust-lang/cargo/issues/new Thank you!
Cheers, this seems really nice. The default situation always felt a little unergonomic to me. As an aside, I’d be grateful if anyone could point me to further reading on the design decision to require separate imports for trait methods. I feel like I must be missing something!
You shouldn't use `expect` here. Convert `Option` to `Result` with approptiate error value.
I also have this question. aws-lambda-go uses pointers pretty much everywhere it can. Non existent fields are nil. I have not checked the project yet but I am wondering if you have something similar to that? Like all the fields are Option? 
Yes, I wasn‘t aware that sparse files need special care. If you open a PR, please describe the reasoning 
I think the 2015 playground link is wrong.
&gt; some existing code will not compile anymore (because it never should have compiled in the first place What failure modes will/would this code experience? Panics? Or indeterminate behavior?
Works! 
Thanks for the recommendation! I will have to check it out
This has now been fixed! Thanks again for the correction
Non-expert here, but I did watch the talk by the dev from Chucklefish and read her extended blog version. Near the end she was saying that ECS are very basically a limited form SQL. She went on to say that games with real-time needs can't really afford the overhead of a SQL database so game devs sort of evolved their own solution that is more limited but has better performance for the operations they tend to need.
Cool sprite! Where did you find it?
* Maybe `rustup` doesn't run on OP's OS * Maybe OP's company doesn't allow installation of new programs in system directories * Maybe OP wants to provide a script that creates a project-local rust installation * Since apparently nobody knows how to do this by hand, aren't you all relying on the machine spirits to not leave `rustup`?
It's working for me, I guess the idea is that you try to compile the same code using the 2015 edition.
Curl means "see URL". Since cHTTP is focused exclusively on the HTTP experience, it is called "see HTTP". It is also short for " Curl HTTP".
I've been interested in ECSs for a while, and I always assumed SoA is cache-friendly. But consider this scenario: positions: [p0, p1, p2, p3, ..., pN] velocities: [v0, v1, v2, v3, ..., vN] Let's say I have a index-based `for` loop that goes from `0` to `N`, and adds every velocity to its corresponding position. Is it possible that when loading the velocities in the cache, the corresponding positions' cache line could be overwritten? I.e., would a more cache-friendly layout be: [p0, v0, p1, v1, p2, v2, p3, v3, ..., pN, vN] ? 
Indeed, I would like to see one of these exam that used to compile but is no longer valid with the new borrowchk. I'd imagine it is something like use a after free, double free, duplicate mut reference..
Note: not on the compiler team My memory is that the old borrowcheck design was done the way that it was because we thought programmers think in lexical scope. It turns out that they don't. I am not sure how hard it would have been to have done the work needed to write the old borrowcheck in the older compiler; I'm assuming that it was tough. That's why we blocked NLL on MIR in the first place!
Update: I found out, BitVec is no longer supported in new version of rust. That was old documentation.
Soundness holes in the borrow checker would lead to issues with memory safety. Use after free, segfault if lucky, security issue if unlucky. Example: https://github.com/rust-lang/rust/issues/51117
 fn router(me: &amp;str, rx: Receiver&lt;Message&gt;, tx: Sender&lt;Message&gt;) { for message in rx { let different_recipient = match &amp;message { Message::Letter { recipient, data } =&gt; { if recipient != me { true } else { process(data); false } } }; if different_recipient { tx.send(message).unwrap(); } } } I wonder if there is a cleaner solution in Rust 2015.
I am excited by this but not for NLL. So far, I've rarely ran into situations where NLL would help. What excites me is the improved errors. There have been a couple times I was baffled by the error message I got for some lifetimes. I switched over to nightly + NLL and got a more understandable error.
I always tend to trip up on iterator combinators. If I want to get an iterator of whitespace separated strings out of stdin, I can do this: fn main() { use std::io::{self, BufRead}; let stdin = io::stdin(); stdin .lock() .lines() .map(|s| s.unwrap()) .collect::&lt;Vec&lt;_&gt;&gt;() .iter() .flat_map(|s| s.split_whitespace()) .for_each(|line| println!("{:?}", line)); } However, that `collect::&lt;Vec&lt;_&gt;&gt;` needs to consume the entire iterator, which means nothing will get printed until stdin gets an EOF. Since I want this iterator to give me whitespace separated strings as soon as it gets a new line from stdin, I tried fn main() { use std::io::{self, BufRead}; let stdin = io::stdin(); stdin .lock() .lines() .map(|s| s.unwrap()) .flat_map(|s| s.split_whitespace()) .for_each(|line| println!("{:?}", line)); } but I get this borrow checker error: error[E0597]: `s` does not live long enough --&gt; src/main.rs:9:23 | 9 | .flat_map(|s| s.split_whitespace()) | ^ - `s` dropped here while still borrowed | | | borrowed value does not live long enough 10 | .for_each(|line| println!("{:?}", line)); | - borrowed value needs to live until here Is there a way to do this using iterator combinators? Or should I make a new struct that implements `Iterator`.
I guess I have the same question one level up in the stack: Is MIR the obvious, do-it-from-day-1 way to write a Rust compiler now, or is it the kind of thing that would unnecessarily complicate a new project? I never took a compilers course myself, and I always wish I had some intuition about these things :)
Yes and no, it's more complicated than that. See my comment here from the other day: https://www.reddit.com/r/programming/comments/9sb74k/the_d_language_frontend_finally_merged_into_gcc_9/e8ot03m/?context=3 we've still kept the old layers, they're still useful :)
&gt; Is it possible that when loading the velocities in the cache, the corresponding positions' cache line could be overwritten? That is a possibility, I think, but it should just be evicted. For example Ryzen has `768KB`of L1 cache, and if a cache line is 64 bytes then we have 12288 different cache lines. It seems unlikely that you would run into that issue very often. &gt; [p0, v0, p1, v1, p2, v2, p3, v3, ..., pN, vN] I think AoS is still a good memory access pattern, if you guarantee that you are accessing everything and you can't easily vectorize it. Another memory layout that you should have a look at is `AoSoA` which is a mix of SoA and AoS. This is valuable if you want to zip a lot of iterators together, because you can only prefetch so much with SoA. But overall I think SoA is a fantastic default.
Ah I was expecting to see the equivalent (compilable) code for the 2015 edition.
When we parse the fields yes, we can tell which ones are pointers vs concrete types. We map any pointer type to Option and any concrete type to the Rust equivalent. The behavior I talk about previously came about because of https://github.com/srijs/rust-aws-lambda/issues/13 In the Go project, a null json object for a string get decoded as "". On the rust side if we mark the field as String it would fail to deserialize. And translating null to "" wouldn't be idiomatic. So we make all "required" Strings optional instead, because there is no way to tell from how Go is doing things what can truly be null or not.
I want to shift completely to the new borrowck when it releases and not run the old one at all. Will there be any flags I can set for my projects to achieve this?
In particular I would check out the intersection of the fixed-by-NLL tag and the unsound tag to figure out what sort of code *should* have been rejected by old borrowck, but was not: https://github.com/rust-lang/rust/issues?q=is%3Aopen+label%3ANLL-fixed-by-NLL+label%3A%22I-unsound+%F0%9F%92%A5%22
Please add a short blurb about what is Gotham and why someone might want to use it. There's so many projects going around that I have a hard time keeping up. Thanks and congrats!
I don't believe so; you'll just have to wait a tiny bit longer.
I [threw together a tap BPM meter](https://github.com/justinas/tappy) in about an hour. Was a chance to try out Cursive, which is a pretty neat library. Also got an [unexpected contribution](https://github.com/justinas/gettext/pull/2) to my gettext crate which I had nearly abandoned. That is always motivating.
Honestly I wasn't sure at first if NLL was a good idea because it seemed to make the rules a bit more complex, but I couldn't have been more wrong. I have also been using NLL for a while now and I can't imagine going back, Rust without NLL seems very dysfunctional in some places. &gt;Over the next week or so, I am planning to write up a series of blog posts. Each will describe what I consider to be a common “tricky scenario” where people hit problems with the borrow checker, and none of which are solved by NLL. A couple of days ago I wanted to implement something similar to [slice::IterMut](https://doc.rust-lang.org/std/slice/struct.IterMut.html). Turns out I have to resort to unsafe code, which I found odd because it seems so simple. IIRC it was something like this: struct IterMut&lt;'a, T&gt; { slice: &amp;'a mut [T] } I don't think you can implement `Iterator` for `IterMut`in safe code.
To add on to Steve's comment, it's true that the lexical-scoped nature of original borrowck was a deliberate philosophical choice of "keep it simple" over "do what I mean". However, in terms of the implementation itself, the compiler devs have mentioned that the current design is what they would have liked to do originally, but couldn't because it was blocked on so much other implementation work (like MIR). So while "in retrospect" the devs might still have chosen lexical lifetimes over NLL for Rust 1.0 (because, paradoxically, the features that are best for a brand-new language are not always the features that are best for a mature language), assuming infinite capacity for development resources, the current MIR-based implementation is what they would have used.
I'm _really_ excited by the [generic integers proposal](https://github.com/rust-lang/rfcs/pull/2581), but also bummed that mark-i-m's suggestion [that these could be standard library types](https://github.com/rust-lang/rfcs/pull/2581#issuecomment-433678348) once const generics land probably isn't feasible because [the elements of arrays must be individually addressable](https://github.com/rust-lang/rfcs/pull/2581#issuecomment-434211027). A `Bit` type would be _such_ an awesome building block in Rust. 
On nightly, you can use `#![feature(nll)]`
You can, but it involves some swaps I believe. Heh, [this post from 2013](http://smallcultfollowing.com/babysteps/blog/2013/10/24/iterators-yielding-mutable-references-take-2/) is still basically right. Anyway you have to swap out the slice (with an empty one, probably), use `split_at_mut` to extract what you need, and put back the new one. I intend to write up this general pattern as the "sentinel pattern". Good example though. =)
Happy to help. Rock on!
&gt;Did you see how smoothly I worked in that plug for [salsa](https://github.com/salsa-rs/salsa)? I’ll write a post about it soon, I promise. 😏
Did you report any of the segfaults as bugs?
Could you add a desugaring example so that it is fully clear to the reader what this does? Also, I'm guessing the inliner will probably mark the function as inline anyways but it may be better to be on the safe side and add `inline(always)` there.
&gt; I wasn't sure at first if NLL was a good idea because it seemed to make the rules a bit more complex FWIW, I was in that boat too, but now agree that it's far better.
See /u/kibwen's comment
I remember there used to be a some sort of pop method on slices that mutated the slice in place. I kind of miss that.
Maybe put it in the comments but not in the docs, and say 'for a desugaring example, see the code'. I'm curious how it works.
Another resource is Tristan Hume's [top 100 crates](http://thume.ca/crates/).
I still find cases that NLL doesn't solve: for example, re-trying `BufRead::fill_buf()` on interrupted errors: https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2015&amp;gist=1ddf88c43dc01ac7c033adb4a814666c I can find no way to make it compile.
I am really glad to see another good proposal [on DSTs](https://github.com/rust-lang/rfcs/pull/2580). Writing dynamic arrays capable of storing DSTs requires a lot of assumptions today; having a stable API would make this much more palatable. Note: example of memory layout: - array of N v-ptrs, - array of N offsets, - raw blob of memory containing N elements (data only).
Good to have these but I guess it'd be nicer to have the status as another column in the table. Depending on who's updating these, they could either submit an update or get *really* fancy and scrape these for the status every 24-48 hours or something.
I didn't know dependabot. That looks really cool. Concerning the "clean up" steps: See my "The last two steps are typically automated in my CI pipeline. They are included here for completeness." comment in the article. I also have these in my `.travis.yml`.
&gt; you can also use cargo-outdated Thank you, I didn't know that. Updated the article.
What's the best way to handle errors using Result? I am trying to list contents of a directory using Result, (not unwrap or expect.) &amp;#x200B; **What I want to do:** 1. bind the Result returned from `read_dir()` to variable `image_files` 2. If it errors out, print a helpful message on stdout 3. iterate over `image_files` Using **match**, I was able to get the code compiled and working if I use `panic!(e)` in the Result::Err(e) arm. But, the code doesn't compile if I print a message on stdout. The compilation error says "use of uninitialized image\_files." &amp;#x200B; **Questions:** 1. Why does it not complain about image\_files variable being uninitialized in `this_function_compiles()` ? 2. How do I initialize `image_files` anyway? I am new to rust (came from python) and I think I maybe missing something basic, and that I may not be thinking about error handling in Rust correctly. &amp;#x200B; **2 Code snippets:** See the two functions: `this_function_compiles()` and `this_function_fails`. The playground links are below the following two code snippets. `fn this_function_compiles() {` `let image_files: fs::ReadDir;` `let source_img_dir_path = path::Path::new("./images");` `let result = source_img_dir_path.read_dir();` &amp;#x200B; `match result {` `Result::Ok(val) =&gt; image_files = val,` `Result::Err(e) =&gt; panic!(e),` `};` &amp;#x200B; `for image_file in image_files {` `println!("&gt;&gt; {:?}", image_file.unwrap());` `}` `}` &amp;#x200B; `fn this_function_fails() {` `let image_files: fs::ReadDir;` `let source_img_dir_path = path::Path::new("./images");` `let result = source_img_dir_path.read_dir();` &amp;#x200B; `match result {` `Result::Ok(val) =&gt; image_files = val,` `Result::Err(e) =&gt; println!("something went wrong..."),` `};` &amp;#x200B; `for image_file in image_files { // ##Compilation Error##: use of possibly uninitialized \`image_files\`` `println!("&gt;&gt; {:?}", image_file.unwrap());` `}` `}` &amp;#x200B; **Playground links to the above 2 code snippets:** 1. [code that compiles](https://play.rust-lang.org/?version=beta&amp;mode=debug&amp;edition=2018&amp;gist=c68e4a4dded516d52880d116077f43d7) 2. [code that fails](https://play.rust-lang.org/?version=beta&amp;mode=debug&amp;edition=2018&amp;gist=703a5143d2022ab4b7a664d22e35da89) &amp;#x200B; &amp;#x200B;
Check [https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions](https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions) for reference on cast expressions.
You can not override as. All over-loadable operators are under `std::ops::*;` ```rust use std::convert::From; struct MyBigNum(u128); impl From&lt;u64&gt; for MyBigNum { fn from(n: u64) -&gt; Self { MyBigNum(n as u128) } } ```
Then you can do: ```rust let mynum: MyBigNum = 7u64.into(); ```
is there a way i can return the position of an element in a vector when running a for each style loop ex.) //sudo-ish code `a = vector` `for i in a {` `i.position(); //is there a function like this` `}`
Hi u/pimeys, this is something I could def use. I run a public transit info website, and I send push notifications for interesting events that people subscribe to (where I have real-time information). My stack is a mixture of microservices in Node, Kotlin and Rust. &amp;#x200B; One of my challenges has been maintaining bits of code that do x, y and z; hence I decided to break things apart so I'd be able to build small services that do one job, and can be easily replaced if they don't meet it. With that said, I think I would be able to use xorc notifications in the near future. &amp;#x200B; I had a cursory look at the README, and I think there's a few features I'd be able to contribute when I get to notifications. For example, I'm taking the approach of building a few different apps (for different consumers), and users subscribe to a "channel" that is the app that they're using. When a notification is sent, it's supposed to go to the correct channels only. I can't tell if I'd have to supply that info from the sender, or if it'd be logic in xorc. The simplest way of doing it from the sender is to keep track of which user keys are subscribed to which channel, but I haven't really worked that out well. &amp;#x200B; Also, why Kafka? Does the lib end up working on Windows? I've had trouble with Kafka on Windows, to the extent that I'm now using [nats.io](https://nats.io). Downside to that is that I'm running Kafka and nats in my server. This might be a blocker, but it doesn't mean that I can't implement a nats consumer (I also send messages around as protobuf bytes).
It's a feature my dude
The reason that the first example works is that Rust knows `panic!` is going to stop the execution of your function, so nothing afterwards matters. Even though you only initialize `image_files` in the `Ok` branch of your match, Rust knows that the `Err` case will never end up executing the code that reads `image_files`. So you're all good there. In the second example, you've removed the `panic!`, so the loop at the bottom is going to execute either way. Rust sees that the `Err` case is going to use `image_files` without initializing it, and that would be ***Undefined Behavior*** (spoooooooky), so it refuses to compile your code. The most common way that Rust code deals with these situations is to return errors, rather than panicking. The `?` operator can make that very convenient. You could just write a line like this... let image_files = source_img_dir_path.read_dir()?; ...and you wouldn't even need to write the match. If you don't want to `unwrap` or `panic!` like you did in the first example, you have to deal with the error somehow, so returning a `Result` is usually the right thing to do.
This is because in the first function the compiler can determine that before `image_files` is used it will either be initialized or execution will diverge due to the `panic!()` and never reach the usage site. This isn't special to panicking either. `panic!()` internally calls a function that returns [the `!` (never) type](https://doc.rust-lang.org/std/primitive.never.html) which cannot be constructed without invoking undefined behavior, so the compiler can safely assume a function that returns `!` will never actually return. There are other expressions that have a type of `!`, namely: * a `loop` block that doesn't contain a `break`, as it will loop indefinitely * unconditional `break`, `continue` and `return`, as execution will never continue past them * a `match` over an `enum` with zero variants, which can also never be constructed (these were used for custom never-types before `!` was introduced)
thanks for your answer. i actually have it implemented the second way. i will probably give your first answer a try though.
Anyone else anxiously checking for the next Shifgrethor post dozens of times per day?
I (somewhat vaguely) recall older versions of Linux pthread implementations, on pthread\_init(), cloned the process and left the parent as a manager only and continued with the “main” thread work in the child thread. Perhaps something similar could make sense here too—once the application is threaded, everything would happen in workers and the main thread would only be a manager. The downside would be that it would require rather sophisticated proxy for manipulating the DOM. On the other hand, that proxy would than be equally controllable from any thread. Or the application running in the “window” thread would not support threads, but would instead support launching a “process” into worker, that could than be threaded at will, but wouldn't have direct access to the window. Some kind of “process” is needed for using the other kinds of workers (shared and service) anyway.
How do we know the new borrow checker doesn’t have its own soundness holes? Has it been verified by some logic tool? Any interesting links regarding that?
Regarding the migration period - will it be possible to force the new behavior during it (with a compiler flag or otherwise) to enforce new rules and benefit fully from the new compiler error messages?
Yeah i get some random code that looks nothing like the example.
Yes that link is better, they should update the post with this link.
Hey that’s awesome. Thanks for sharing your project, I’m going to dig into it tonight! Here’s mine: http://github.com/jsheedy/ansi-rust 
 fn router(me: &amp;str, rx: Receiver&lt;Message&gt;, tx: Sender&lt;Message&gt;) { for message in rx { match &amp;message { Message::Letter { recipient, data } =&gt; { if recipient == me { process(data); continue; } } } tx.send(message).unwrap(); } }
Ooooh, polonius :3
It looks like what you're describing here, you should look into the rest of the codebase we released. It includes the following things: &amp;#x200B; 1) An ORC language compiler and virtual machine. ORC is an orchestration language, and you can compile and run an ORC program to be run on top of JVM for every user you have. You can create a program to listen to certain events, subscribe your users to the program (all of them will run their own copy) and trigger events when the user has enabled certain things. The programs can be serialized and deserialized easily and can continue execution from the state they were left. 2) A rule engine, that holds ORC sites and handles the event flow. This is the core that runs the ORC programs, sends and receives events. &amp;#x200B; ORC functions are called sites and they can be implemented in any JVM language. ORC handles orchestration combinators and in our solution all the IO was through Kafka, that's why this notification platform is Kafka-based for now. Our traffic was just very big always, so our message broker needed to have muscle to handle all those billions of events. &amp;#x200B; Think of this project here more as an example and two years of development, to show how to build robust consumers with Rust and how maybe you can bootstrap services such as Onesignal by your own! Our team was completely Linux/Mac based, so my knowledge about Windows is not that great. Try and see! Pull requests are appreciated :)
[This](https://github.com/rust-lang/rust/pull/55127) was a nice example where NLL helped a lot.
have you tried `impl&lt;'l, 'r&gt; Add&lt;'r MyBigNum&gt; for &amp;'l MyBigNum`?
https://docs.rs/futures/0.1.25/futures/future/trait.Future.html#method.wait This is the simplest one, as it makes its own event loop to drive the process to completion. The downside is that it's only useful when you're not trying to spawn more independent tasks in parallel. https://docs.rs/tokio/0.1/tokio/runtime/fn.run.html is a more flexible alternative.
&gt; but I think as written this will make Rust a great standout supporter of full Unicode identifiers. Standout how? Everyone else has them too, the RFC copies rationale verbatim from Python even C++ and java supports non-ascii idents What, and who, is Rust supposed to be standing out from? Maybe the fact they're so unknown despite being so widespread is a hint that nobody uses them.
Thanks! Too bad my projects are stable only though.
This certainly [compiles](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2015&amp;gist=064b56931b5c72d8c106ff33c7f95b97): fn router(me: &amp;str, rx: Receiver&lt;Message&gt;, tx: Sender&lt;Message&gt;) { for message in rx { match message { Message::Letter { ref recipient, ref data } if recipient == me =&gt; process(data), message =&gt; tx.send(message).unwrap(), } } }
You could easily make `Bit`s and raw bitfields addressable by treating them as DSTs, with "fat" pointers that would include a shift amount as part of their metadata.
We don’t know, we just know that it is better than before.
Interesting, I actually used `split_at_mut` but I didn't think of swap. If anyone is curious: struct IterMut&lt;'a, T: 'a&gt; { slice: &amp;'a mut [T], } impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; { type Item = &amp;'a mut T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { use std::mem::swap; if self.slice.is_empty() { return None; } let mut slice: &amp;mut [T] = &amp;mut []; swap(&amp;mut self.slice, &amp;mut slice); let (first, mut rest) = slice.split_at_mut(1); swap(&amp;mut rest, &amp;mut self.slice); first.get_mut(0) } } 
Great funny project !
You compared it to kdb, but what about TimescaleDB? That comparison is really important to a lot of people today. TimescaleDB has exploded in popularity since it's "Just Postgres", and Postgres is *immensely* powerful. If I'm going to give up that power, I need to get *a lot* of performance. Relevant links: https://blog.timescale.com/announcing-1-0-enterprise-ready-time-series-database-sql-open-source-400b4342dfa0 https://cdn-images-1.medium.com/max/2000/1*fAW3QVCem4K5nZLGfO0Gpg.jpeg
There is no proper support for this yet, there was an attempt to implement it but the developer lost interest. https://github.com/vulkano-rs/vulkano/pull/950 https://github.com/vulkano-rs/vulkano/issues/945 I would recommend just using static shaders, any attempt to hack in dynamic shaders for your project is going to be way more painful than its worth. Alternatively consider implementing dynamic shaders for vulkano, its definitely something I would like to see added. :)
The `From` (and `Into`) traits are what you want. Always implement from, and you get into for free.
🎉🎉🎉
perfection. 
I tried to drop a `proc_macro_hygiene` from one of your tests to see what you are using the feature for. It looks like these two things: proc macros expanding to macro definitions, and proc macros expanding to expressions. error[E0658]: procedural macros cannot expand to macro definitions (see issue #54727) --&gt; examples/uuid/src/main.rs:29:1 | 29 | #[get("/people/&lt;id&gt;")] | ^^^^^^^^^^^^^^^^^^^^^^ error[E0658]: procedural macros cannot be expanded to expressions (see issue #54727) --&gt; examples/uuid/src/main.rs:39:33 | 39 | rocket::ignite().mount("/", routes![people]) | ^^^^^^^^^^^^^^^ Expanding to macro definitions is already possible on stable if you indirect through a derive macro, which *is* allowed to expand to a macro definition. #[get("/people/&lt;id&gt;")] // expands to #[derive(rocket::EnumHack)] enum _rocket_some_mangled_name { Value = (stringify! { macro_rules! whatever { ... } }, 0).1, } // expands to macro_rules! whatever { ... } And expanding to expressions is possible as of the just-released proc-macro-hack 0.5. https://github.com/dtolnay/proc-macro-hack Maybe take a look and see if you can make things work without proc_macro_hygiene?
Awesome! Wasn‘t expecting so much to land on 0.4 to be honest.
which version of future are you using?
Done - I've just pushed version 0.2.0 with the `#[inline(always)]` attribute.
Yes.
Can’t you just write `Bar { _mark: PhantomData }` and that will give you a (safe) instance of the struct in the generic case? Although guess you can’t then instantiate the generic ever…maybe that’s the point?
More importantly TimescaleDB is open source.
[Playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=f2fca697a4fdb96ed3795ae14e4e8303) This wasn't very difficult, maybe I'm misinterpreting the question.
I wasn't sure what by-value object safety meant at first, but after taking a look, I like it. More object safety = good. `#![feature(unsized_locals)]` is something I didn't know about and could be interesting.
I've been trying to hack away at a UI library for a while now, but having trouble finding energy after work and I keep scrapping and rewriting my implementations because I don't find them satisfactory
I believe this means you need to make the return value of the json!() expression live longer - assign that to a temporary variable (and chain the further methods on that line off that) and it should appease the lifetime constraints.
I think we should replace the icon with this picture everywhere it appears
Have a fearless Halloween! 
This is interesting. I'm doing something tangential, a relational language with ideas from kdb/foxpro: https://bitbucket.org/tablam/tablam/src/default/ This will be open source, or partially? I think exist a lot of potential in a scripting lang along this lines.
Running `cargo build -v`, I see that no `--cfg` parameter is given for features of dependencies, so I fear this is impossible to do. :(
cursed\_ferris
*blessed_ferris
Yes, that's our main discussion channel. It is often very active, a lot of the people there are working on their audio related projects :)
``` extern crate futures; use futures::prelude::*; struct Doubler(usize); impl Doubler { fn new(i: usize) -&gt; Doubler { Doubler(i) } } impl Future for Doubler { type Item = usize; type Error = (); fn poll(&amp;mut self) -&gt; Result&lt;Async&lt;Self::Item&gt;, Self::Error&gt; { Ok(Async::Ready(self.0 * 2)) } } fn main() { let mut f = Doubler::new(5).and_then(|val| { println!("value while polling = {:?}", val); futures::future::ok(val) }); println!("{:?}", f.poll()); } ``` This might shed some light on how futures actually work. Its actually pretty difficult to express this computation for a tokio executor to run as far as I know.
Btw, I added child window support to glutin (back when winit wasn't extracted from it yet), here: https://github.com/Boscop/glutin When winit was factored out from glutin, others backported my changes to it, here: https://github.com/Boscop/winit Both versions are [confirmed](https://i.imgur.com/4BQ1tCQ.gifv) to [work](https://i.imgur.com/2iLwRe4.gifv) in VSTs, also with my fork of [piston](https://github.com/Boscop?utf8=%E2%9C%93&amp;tab=repositories&amp;q=piston&amp;type=&amp;language=) and [conrod](https://github.com/Boscop/conrod) (but those are old versions now). After that, winit changed a lot so we decided to do a [clean fork](https://github.com/Boscop/winit-vst) because implementing support for child-windows for Mac OSX was more complicated due to its window event loop handling. But the changes to winit to support child-windows on Windows are easy to add to the current git master of winit. Basically my changes are: 1. add an optional parent window handle to the window creation config struct 2. in the function that creates the window, set the window flags accordingly and pass the parent 3. instead of storing just one thread_local event queue, I store a `HashMap` that maps window handles to their event queue, because now, multiple windows can live in the same thread (a standalone window is always spawned in its own thread, so before, each thread only needed to store one instance of the event queue), so that multiple child windows can co-exist in the same (host) thread and each gets its own messages. That's basically it. (For Mac OSX there are different steps, robsaunders knows more about those..)
Different. It's found a bunch of existing soundness problems - good. It's also increased the number of allowed options, meaning it's likely going to allow unsound code that would have previously been blocked. Sorry - there are no free lunches.
But the same mechanism in the compiler that allows borrowing across yield points could be re-used to add support for borrowing across `&gt;&gt;=`/`.and_then()` if we wanted to add a do-like notation, right?
It feels like you've already done the hardwork but I'm very new to Rust and Vulkan (I've come from the C++ OpenGL world) so decoding the macro that does the heavy lifting is tricky for me. I get the sense that it's doing something clever unpicking the various entry points and variables. 
Not a timescale but this is the tracking issue for anyone that wants to follow https://github.com/SergioBenitez/Rocket/issues/19
I'm having some bizarre issues with using `serde` to parse a TOML file. I've posted a [question on StackOverflow](https://stackoverflow.com/q/53093646) about it, and any insights would be welcome!
Interesting, I'd like to hear more about this. The lib is pretty well tested, it could be a bug in the tool itself. I don't think there's anything about running "at scale" that should cause a problem for curl, except for making obscure bugs happen more often. FWIW, libcurl is used "at scale" by a lot of people, so I'm assuming they're not experiencing that bug. The .NET core HTTP client uses libcurl on Linux, Apple's URLSession uses it, and of course many more.
It's one of the next priorities! -- https://github.com/SergioBenitez/Rocket/issues/17#issuecomment-415609486
I've tried this multiple times, I've even tried different functions from serde\_json and I get the exact same problem. Do you have any examples of what might work? &amp;#x200B; I tried the following and I get the same error on temp1, for some reason I'm unable to convert String to &amp;str regardless of whether I'm using \`.as\_str()\` or \`&amp;a\[0..\]\` let temp = json!(product\_request\_vec); let temp1 = temp.to\_string(); let temp2 = temp1.as\_str(); product\_param.insert("requests", &amp;temp2);
The main thing is that it's opinionated that the `From::from` should only be for "trivial" single-element variants and it skips the others. (Mainly I was trying to avoid being just "thanks but it was already done here".)
Do you have any open source Rust code that you can share with us, or are you hiring for Rust developers, or does your company have a blog post or whitepaper talking about your use of Rust? We're happy to hear about your usage of Rust and that you've had a positive experience with our community, though I hope you can sympathize that we have to be careful with vetting the relevance of any content that could be mistaken for commercial advertisement.
It works! I can see why, but is this the standard way to go about importing a sibling module?
I have no idea. But this way, you'll have to change your code in fewer places if you rename a module.
Hey that looks awesome! I’m working on a JS interpreter written in Rust, so maybe room for collaboration. https://github.com/jasonwilliams/boa
https://github.com/rust-lang/rust/issues?utf8=%E2%9C%93&amp;q=+label%3ANLL-fixed-by-NLL+label%3A%22I-unsound+%F0%9F%92%A5%22+ also has the closed ones.
how are unicode identifiers a win? they increase the barrier of entry for codebases and are potentially difficult to type. I mean a lot of languages have them for the sake of having them but is anyone actually, non-ironically, using them?
I thought about dressing up as a GCC error. Cryptic and terrifying 
They are, probably, in the united states. Google [is going to appeal](https://www.theregister.co.uk/2018/08/28/oracle_google_rehash/) that ruling though. We will [probably find out around April](https://news.ycombinator.com/item?id=18335434) if the supreme court will hear that appeal. The last time around, after the federal circuit found that APIs were copyrightable, but before the federal circuit found that APIs were not covered under re-use (in the same case). [The supreme court declined to hear Google's appeal](https://www.supremecourt.gov/search.aspx?filename=/docketfiles/14-410.htm) after asking (in the same case) the solicitor general to weigh in on whether or not they should (which I believe is somewhat rare), at least partially because the fair use defense had yet to be considered. If the Supreme Court doesn't hear this case, that *still* doesn't mean that APIs are copyrightable in the US. What would mean that is if the supreme court did hear the case and then found against Google on that matter. It means that the federal circuit ([which generally does not have jurisdiction over copyright cases](https://en.wikipedia.org/wiki/United_States_Court_of_Appeals_for_the_Federal_Circuit#Jurisdiction), and is only hearing this case because it started out as Oracle unsuccessfully suing Google for patent infringement) has found them so, but other courts are not bound by that precedent (though it is likely to be considered persuasive by judges regardless).
See the RFC for the _long_ discussion about them. Summarized: the codebases that will use this the most -- internal sources for non-primarily-English-speaking groups -- weren't writing code that would be easy for you to pick up anyway. They don't write English identifiers, they convert their own language to ASCII in inconsistent ways. The "problem" primarily ASCII-benefited language speakers always are so quick to claim, that this introduces ambiguity, already exists _because_ of this restriction, just as "is `Wörter` ASCII-ized as `woerter` or `worter`" (in the _trivial_ case) instead of visual ambiguity, _which the compiler will catch for you_. This isn't about use by the people who say "why is this needed". This is about use by people who _can't_ say "we would benefit from this" because communicating in our English-language RFC process is not something they have the luxury of doing due to language barriers. The codebase that uses non-ASCII identifiers isn't going to be easier for you to read if it is restricted to ASCII identifiers. It would be _harder_ due to the fact that transliterating into ASCII is both ambiguous and lossy. And if nothing else, _this is what the Unicode Consortium recommends._ We're not doing some manual decision of what gets to be an identifier (like Swift's classification of identifier versus operator and inconsistent Emoji handling): we're just doing what the Unicode Consortium says should be done for programming languages using Unicode text representations.
very cool
Wow that is pretty ambitious! I am trying to concentrate on the syntax level exclusively but that doesn’t mean there isn’t opportunity for collaboration. I will dig into your project for sure!
I don't think you even need the lifetimes. You could just do impl Add for MyBigNum { type Output = MyBigNum; fn add(&amp;self, other: &amp;MyBigNum) -&gt; Self::Output { ... } } Or something similar.
Right, insofar as: if `.and_then()` could be borrowed-across, then a proc-macro could convert do-notation into the equivalent chain of `.and_then()` calls. What I'm not clear on, though - and this is probably just my own unfamiliarity with the nitty-gritty of Rust's upcoming generators feature - is how to invoke that compiler mechanism upon a new type's `.and_then()`. For example, if someone wants to write a `do`-notation Iterator comprehension that should run in parallel via rayon, how do we make the compiler know that rayon's parallel iterator's `.and_then()` means "the same kind of thing" as `std::iter::Iterator::and_then`? And what will even the compiler's notion of "the same kind of thing" be?
Finishing tests for my type\_level\_values crate.After this I will give the final polish to the library before releasing an 0.1,which if nothing goes wrong should be in the weekend.
In Rust, drops happen in reverse order as lets. That causes temp and temp1 to be dropped before the HashMap, leaving a dangling reference. The simplest fix is switching to String for your values.
Ah, okay, because you’d need to have the trait in scope to use [fully qualified syntax](https://doc.rust-lang.org/book/second-edition/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name)?
Not really, but that's not the way most people use traits in my experience. They'll avoid using that syntax if they can.
What are the cons? I find it hard to believe you are that faster without compromising anything. Mongo had problems with not confirming writes, it was pretty fast but there was data-lost. What are the constraints?
Changing \`HashMap&lt;&amp;str, &amp;str&gt;\` to \`HashMap&lt;&amp;str, String&gt;\` worked for me. &amp;#x200B; I was confused by this too. I did actually actually try \`let a = json!(vec).to\_string().clone()\` and then \`&amp;a\[0..\]\` the same as I did for the token. &amp;#x200B;
Don't forget arcane
&gt; impl Add for MyBigNum { &gt; type Output = MyBigNum; &gt; fn add(&amp;self, other: &amp;MyBigNum) -&gt; Self::Output { &gt; ... &gt; } &gt; } This doesn't quite work. `Add` requires that `add` takes `Self` and `RHS` by-value, which means you need to denote references if you plan to use them. So the code would look something like this: impl&lt;'a, 'b&gt; Add&lt;&amp;'a MyBigInt&gt; for &amp;'b MyBigInt { type Output = MyBigInt; fn add(self, rhs: &amp;'b MyBigInt) -&gt; MyBigInt { ... } }
yeah, Diesel is not an ORM. I find diesel to be quite usable but not as convenient as a ORM. I don't like to write SQLs in code for trivial CRUD stuff and diesel helps there. I don't know of any rust ORMs in work.
I've been using kdb+ for the past 7 years for most of my daily work so I'm always interested to see new competitors. For most of what I do, performance isn't the main value I get from kdb+, it's the powerful domain-specific query language. Nothing else I've used has come close to ergonomics and productivity I get from q. Do you have any public documentation or additional examples for your query language? BTW, in your 2nd kdb+ example/benchmark, the `1 xbar` shouldn't be needed which may speed it up slightly.
Ah, I never even tried the non-generic version. 
Actually no, that doesn't work. Gives a type error. 
&gt; I'm talking standout in terms of lints. ---- &gt; And because of the "danger" inherent in Unicode identifiers (read: developer fear and some legitimate threat models of malicious patches), most sources adopt an "ASCII-only" requirement. I feel the fact that, despite everyone else also having unicode idents, none of them actually get used, should be a big hint to how useful such a feature is. [Unicode has standardized ways to detect confusables](http://www.unicode.org/reports/tr39/), the fact that nobody in any of the other languages thought to add confusable linting to their respective static checkers/linters should *also* be a fairly large hint at how useful such a thing is considered. Rust stands out in this regard only in, for some reason, thinking itself special for having a static checker. People seem to think this RFC, linting for confusables, is some sort of unicode ident revolution that nobody else could have thought of, that will solve all our problems and Unicode identifier fears? If it would, everyone else would've done it already, it isnt a new or unique idea. &gt; there doesn't have to be a fear of Unicode identifiers. besides the fact nobody else can use them, because everyone else is sane and ASCII only because English, like it or not, is whats used to bridge the international language gap in technology, among many other things? &gt; People don't use Unicode identifiers (in OSS), even if they would benefit from them, because others would ridicule them for it. And rightfully so, nobody else has those characters on their keyboards or knows that language! Trying to make identifiers into the wild west is a terrible idea, especially for an OSS project. Everyone's already standardized on ASCII, usually English(but not always, transliteration. May not be understandable but at least easily typed) &gt; For closed source software (or even open source) in areas that don't speak English as their primary language, and the code isn't intended to be shared with a primarily-English-speaking audience, this is huge. Programmers are a primarily English using audience, though. Especially rust programmers, since our standard documentation isn't translated yet. And even if it benefits small localized closed source software, this seems like an awful lot of work for an extremely benefit. The standard library, 3rd party libraries, all of thats going to be ASCII English, so the only people this really "benefits" are small, localized, closed source binaries. is it really that important you name your variable `🎃🅱é`? &gt; The fact is, an ASCII restriction doesn't result in these people writing code you want to see in English, it results in butchering their own language to use the tool and writing code that you still can't read, even though you'll recognize more symbols. But it's code you can type! If you can't read it either way, then surely it's better to go with the solution everyone can type. Switching keyboard input modes is never going to be a fun task, especially mid line.(libraries are ascii, remember?) `standard_function(&amp;**change input mode**🎃🅱é).💧()` sure seems like fun. Or having to copy paste it everywhere, `standard_function(&amp;**scroll up somewhere**🎃🅱é).**copy from docs of whatever evil trait decided to implement a drop method with the water droplet emoji**💧()` &gt; It's about being safe-by-default while still allowing people to use their own language. Standards exist for a reason. It isnt a good thing to go to a wild west of everyone doing their own incompatible thing.(\*) It may not be nice, but the fact of the matter is English has become that standard. If you're programming, you already have a functional knowledge of english, and so do all your peers. Deviating from that just pushes away everyone who doesnt know your language. I mean, by all means use your native language for docs, even comments, or when discussing amongst yourselves, whatever, where it makes sense. But i don't think it makes sense in the actual code itself. At that level you need something everyone can use. Docs can be translated, symbols can't.(and god forbid if anyone ever decides translating library symbols is a good idea..) Though even with translations, the translations can be bad or out of date, and committing to translate every version of every standard resource now and for the foreseeable future is a pretty big undertaking, which still leaves out the wider ecosystem, which is all ascii, usually english. ---- \* Speaking of, this really heavily benefits languages with a Latin alphabet, which are basically ASCII except sometimes accents, which while important to the language i don't think are an absolute necessity in this situation. They'll have the easiest time using a normal character set and their native language. Everyone else, though, may have to be constantly switching between two completely different alphabet and input styles. Also, America is kind of the weird guy out in that we don't seriously(we start way too late and only in half-assed highschool classes) teach anyone other languages, as i understand it most other first world nations are much better in this regard and English is the most common to learn. [Some quick googling shows language learning is even compulsory, and can start as early as pre-school](http://europa.eu/rapid/press-release_IP-12-990_en.htm). I don't think thats done *anywhere* here, i tried googling it but only sign language popped up. So it seems to be the RFC is based at least in part on that kind of american thinking And also trying to help these poor non english programmers on their behalf, but i asked if anyone, or a significant number of, had actually said this would help them and didnt really get a response. ---- Really i think it would've been better to first look at all the *other* mainstream languages that have Unicode identifiers and see how, and if, they're used in the real world and whether people actually find them useful, before moving on with the RFC.
I still don't think you need the lifetimes. It seems there's no dependency of them, so the compiler can infer them.
You may also read about actor model vs ecs. https://www.reddit.com/r/rust/comments/9i321m/the_first_live_build_of_citybound_with_rust_on/e6gudjf/ citybound is using actor model which allows it to work across network. https://www.youtube.com/watch?v=qr9GTTST_Dk
Yep. It's my favourite way to import things. 
I think you need the lifetimes: [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=d1d63fd97fba095ef9b1725f70dd2f0f). I'm on mobile though so let me know if I screwed something up that made it wrong.
Where's your asof join demonstration? Like, literally that is 99% the point of KDB BECAUSE NO ONE ELSE BUILDS IT FOR SOME DAMN REASON
&gt; impl&lt;'a, 'b&gt; Add&lt;&amp;'a MyBigInt&gt; for &amp;'b MyBigInt { &gt; type Output = MyBigInt; &gt; fn add(self, rhs: &amp;'a MyBigInt) -&gt; MyBigInt { &gt; ... &gt; } &gt; } Rust only allows lifetime elision on functions, so you need them in the `impl` declaration, but you're right that the lifetime on the second parameter of `add` can be omitted.
I recommend reading through this before committing to Rayon too much: https://github.com/rayon-rs/rayon/issues/394
Actually I misread your code. The reason why Rust lets you do: `product_param.insert("sessionKey", &amp;token[0..])` is because `token` is defined outside the for loop. So `tokens`'s lifetime is guaranteed to be longer than `product_params`.
You have a version mismatch somewhere. `cargo update` first. If it's still broken it's likely that the master branches on GitHub are out of sync with each other and you should pin specific commits.
Can you give me an example of how to do that please?
&gt; Live Reloading# &gt; When your application is compiled in debug mode (without the --release flag passed to cargo), templates are automatically reloaded when they are modified on supported platforms. This means that you don't need to rebuild your application to observe template changes: simply refresh! In release builds, reloading is disabled. Does it have something for live reloading of CSS too?
Other languages _have_ been looked at. [PEP 3131](https://www.python.org/dev/peps/pep-3131/), was actually directly quoted in the RFC text. And believe it or not, _Unicode identifiers _are_ used in languages that support them._ I'll just quote the motivation here: &gt; Writing code using domain-specific terminology simplifies implementation and discussion as opposed to translating words from the project requirements. When the code is only intended for a limited audience such as with in-house projects or in teaching it can be beneficial to write code in the group's language as it boosts communication and helps people not fluent in English to participate and write Rust code themselves. &gt; Code is written by many people in the world who are not familiar with the English language, or even well-acquainted with the Latin writing system. Such developers often desire to define classes and functions with names in their native languages, rather than having to come up with an (often incorrect) English translation of the concept they want to name. By using identifiers in their native language, code clarity and maintainability of the code among speakers of that language improves. ----- &gt; is it really that important you name your variable `🎃🅱é`? No, because that's a meaningless name. In fact, it's not even a valid identifier. Identifiers are meaningful names. We should allow people to use whatever meaningful name is most applicable to their domain. &gt; But [ASCII is] code [that] everyone can type. I'm sure I don't have to tell you that ASCII characters used commonly by the language aren't necessarily easy to type on many keyboard layouts either. If a user is already paying the cost of using multiple keyboard layouts to use the language, adding the ability to use their native one for identifiers isn't adding requirements but removing limitations. &gt; basically ASCII except sometimes accents, which while important to the language i don't think are an absolute necessity in this situation Objectively false; diacritics can change meaning of words drastically. Some quick examples (French): `interne`, intern; `interné`, inmate; `pécheur`, sinner; `pêcheur`, fisherman; (Spanish): `año`, year; `ano`, anus (Note that in Spanish, `ñ` is a distinct letter from `n`, not just n-with-diacritic-tilde.) &gt; [Just use English] That English proficiency be a _prerequisite_ to writing code is not a good, defensible position. In addition, much domain terminology _doesn't have a translation_ to English. ---- I'd just like to note that _every single one of these objections_ has been brought up in the RFC thread. I don't have to defend allowing people to make their own decisions about what language to use. We've already decided that this is what we want to do.
I was specifically referring to the case of structs that implement multiple traits with conflicting method names, though now I understand what you meant. Thanks!
Do you use it to parallelize compiling?
I'm sorry you're having issues! As @usernamedottxt alludes to, you've misconfigured your dependencies. In particular, you're simultaneously depending on the version of Rocket on GitHub as well as Rocket 0.4.0-rc.1. As illustrated in the [Getting Started Guide](https://rocket.rs/v0.4/guide/getting-started/), in addition to your already correct `[dependencies.rocket_contrib]`, your `Cargo.toml` should look like: ```rust [dependencies] rocket = "0.4.0-rc.1" ``` Note that you _should not_ depend on `rocket_codegen`. Following a `cargo update`, your issues should be resolved. I recommend reading the guide as a means to become familiar with Rocket. Should you have any further issues, Rocket has [numerous help channels](https://rocket.rs/v0.4/guide/conclusion/#getting-help), including #rocket on Mozilla's IRC.
I hope you have a great business plan to go aling with a great implementation. Databases are a tough business.
Why is rocket not in the techempower benchmarks? I'd love to see if it's faster or slower than actix, which scored high last round. 
Diesel is awesome, period.
someone tried to add it, but Sergio asked for it to be removed IIRC. I can guarantee that Rocket is slow because it's synchronous. Look at something like Rouille in the benchmarks which is also a synchronous Rust web framework.
It looks like ferris is eating your face
Just curious: why doesnt it compile with Rust 2015? Looks like valid code.
I will send you a private message with our contact details as we would love to get your feedback on several things given your vast experience with kdb+. We're actually working on the documentation and that's what holding us back to ship the beta binaries. We want great documentation and it's quite time-consuming. Great observation regarding `1 xbar`. We've removed it and it did slightly speed up! &amp;#x200B;
&gt; there needs to be some one language everyone can use and know everyone else will be able to understand Tell me, why do you need to be able to read internal source code of some Chinese bank? Why is this so important to you? And if "everyone uses English anyway", what's the harm in _allowing_ learners to use their own language for one-off projects? This was intended from the start. The Rust identifier grammar was [UAX31-R1](https://www.unicode.org/reports/tr31/#R1) from the start, and was only restricted to ASCII on a temporary basis for 1.0. (Graydon said as much in the thread.) Since the original intent was for non-ASCII identifiers, one could argue that the burden of proof of benefit is instead on restricting to ASCII identifiers instead of not. That's a bit aggressive, and not really true to life, but I'm curious: what _benefit_ do you see to _enforcing_ ASCII-only identifiers? Especially since, as you claim, everyone uses English anyway. My position, boiled down to the core argument, is really just: we should stick to the standard. The standard allows non-ASCII identifiers. And I hope that the lints Rust is committing to, which are also defined and suggested by the Unicode Consortium, can help break through the social stigma against allowing non-ASCII identifiers, especially in code bases you're never going to touch. There is benefit to allowing this to real languages. What's the downside of the proposal? To my eyes, the only reason _not_ to allow non-ASCII identifiers is to avoid rehashing this same argument over and over.
Because I'm not saying it (nor is the Rust team): [The Unicode Consortium is](https://www.unicode.org/reports/tr31/#R1). _We're just adopting the recommended identifier syntax._ The whole point is that we aren't passing judgement. We're just following _the standard._
Do I understand correct that it is in-memory data? Kdb is not so good if you select all amount of data like you do on your video. If you would use some queries with "by" and limit by g# - it could be another story. &amp;#x200B; Anyway its quite interesting project. \+ You can find in reddit rust information about another vector oriented database who mentioned kdb. &amp;#x200B;
'type is the best thing there ;)
I totally sympathize with the cautiousness. To be candid, it really depends on our funding if we go open-source or not. We want to write a blog post to go into more detail how Rust is helping us once we've shipped. I will contact moderators before posting next time as we don't want it to come across as a commercial advertisement.
\`nyi :D
I think you can just put the `mut` after the `let` and that’s it. Because you are the new owner of the immutable `Vec&lt;&gt;` that you get, you can ’change‘ the mutability so to say.
 let mut split = ...; Except... &gt; if I try to use mut_iter here, it complains about split not having mut_iter() available `mut_iter` isn't a thing. `iter_mut` is, but it's normally only defined on containers, not on iterators. So... I'm really not sure what it is you want, or how you're trying to do it.
Lol sorry it's way passed midnight, wrote that down wrong. I was under the impression that let mut makes the variable mutable, but not the vector itself.
It means you can mutate what's in the variable. There's no such thing as a "mutable vector". Mutability is a property of a value's storage.
&gt; most implementations usually track if on an insertion the table will grow over its max load factor and grow. In SwissTable instead of that we compute how many elements we can insert before we need to grow and keep decrementing it until it goes to zero. This removes a few instructions (conversion to float and division in some implementations) from the hot path when a workload is insertion heavy. Potentially a silly question, but... Could you move this check until after the first probe? If your insertion succeeds after the first 16-byte comparison, you haven't really justified growing the table anyway, even if you're over the 'max' load factor, and delaying it moves it out of the hot path for most of the table's life since you should only be probing beyond the first group frequently when your hash table is mostly full.
We're obviously not going to reach agreement since we both seem to be talking past each other. The point stands, we accepted the RFC, we decided we want it. If you look at the thread, there are reports in from other language communities about the feature, and they were all positive.
Did this get sorted out? Looks like the question is gone.
&gt; Unfortunately, you won’t see all of those improvements yet on Rust 2018 – the reason has to do with migration. Why is migration needed for Rust 2018? Is it because of code paths that might be using Rust 2015 crates?
Has anyone managed to get the counter example working? It [doesn't work for me](https://imgur.com/uo36M2q).
Look how serde doing it for 128 bit integers
My favourite is just getting `'`.
The fix for adding `crate::` in imports that need to can’t be implemented soon enough. Ideally it’d have been before this blog post came out. I gave up trying to fix those manually. Giving thousands of warnings for syntax that was the only one available until recently is not an acceptable experience.
&gt; the variable mutable, but not the vector itself But the variable *is* the vector. You might be used to the fact that in Python everything is a reference and expect that `split` is a reference to a vector. But it's not. :-) If you deal with actual references, the distinction you make is important, though: let a: &amp; Vec&lt;i32&gt; = ...; let mut b: &amp; Vec&lt;i32&gt; = ...; let c: &amp;mut Vec&lt;i32&gt; = ...; let mut d: &amp;mut Vec&lt;i32&gt; = ...; You can make `b` and `d` point to different `Vec` while the bindings for `a` and `c` cannot change (they always refer to the same `Vec`). But references `c` and `d` allow you to mutate the `Vec` they point to.
If the insertion happened in a group of size 15, we now made a full group so the average probe length has increased. This means means we should have grown the hashtable. Also note that this check is very predictable by CPUs as it is most of the time false (don't grow). Also we experimented with many different probing kernels for insertion and for x86 xeons the best performance was observed with the least fancy algorithm: ``` auto find_or_insert(auto x) { auto target = find(x); if (Full(target)) return Get(target); return insert(x); } auto insert(auto x) { auto insertion_target = find_non_empty(x); if (empty_left == 0 || !Tombstone(insertion_target)) { Grow(); insertion_target = find_non_empty(x); } return InsertAt(insertion_target, x); } ``` From a birds eye view this looks kinda dumb because it can do up to 3 probes into the table: one when it doesn't find the entry, another to find where to insert it, and another after growing the table. In practice what happens is that most of the time (in C++) insertions happen with a value that is already in the hashtable and insertion doesn't happen (they use operator[]). Note that we split the algorithm it in two parts: the fast path where the key is found and the slow path where we are going to insert. This is done so that the compiler can decide to inline the insertion path or not based on feedback from production (if a hashtable is insert heavy it will be inlined, if lookup heavy it won't be). If the key is not found and this is a real insertion, we now do a second probe to find where to insert the not-found key (this is slightly different kernel because it needs to pay attention to tombstones). The observation here is that this probe is very cheap: all groups are already in cache (we just walked over them in the previous step and we are going to look at a subset of them - the previous probe loop stops at first empty, this loop stops at first empty or tombstone). At this point we might decide to grow the table after which we will do a third probe loop. The cost of allocation and rehashing is so high, the third probe loop does not matter.
Is it possible to use Trust-DNS as a recursive resolver, e.g. as a `dnsmasq` replacement? And would that be a good idea? I tried to look over `named`, but it doesn't seem to support it.
In a word, no. I haven't managed to isolate it (not that I really tried with tcpdump &amp; company), and it was in a personal project that was since put on the back burner.
Thanks for your detailed response. Can I get a quick clarification before my reply whether `empty_left == 0 || !Tombstone(insertion_target)` is meant to be `empty_left == 0 &amp;&amp; !Tombstone(insertion_target)`? If not I'm confused.
Diesel doesn't actually put related objects (child / parent objects etc) in the objects, which greatly restricts how expressive your object model and your code can be. Diesel forces you to write a lot of your code in a way that is closer to the SQL than in most ORM's. This is an explicit design decision, but it does turn off a lot of people. If you read this: http://docs.diesel.rs/diesel/associations/index.html and compare it to something like Python's SQLAlchemy with its rich and expressive relationship models, dirty tracking, nested transaction handling etc, you may be left wondering what is even the point of Diesel since it doesn't actually do much more than a simple translation of SQL queries and record sets to Rust types and back.
How should I think about scoped locks using RAII (e.g. Mutex) in a NLL world?
Here is an implementation of something which allows setting and getting bits using a trait object ,which also allows you to return it from ::std::ops::Index\[Mut\]: [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=62deaef52e9159f4108d59ecb3da227c](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=62deaef52e9159f4108d59ecb3da227c)
Drop types are still dropped at the end of lexical scope; nothing changes.
I think Rust's control of sharing could help a lot in reducing room for errors, Java makes it way too easy to just pass objects everywhere and lose track of what is going on. And in fact I think Diesel currently has no way of detecting when you accidentally have two objects that represent the same database record (same primary key), which can lead to mistakes and means you have to do everything step by step, always hitting the database. I would assume Hibernate would catch such a case for you, as SQLAlchemy does.
I’ve filed https://github.com/rust-lang-nursery/rustfix/issues/149 and https://github.com/rust-lang-nursery/rustfix/issues/150.
I'm begginer to Rust, and I'm having problem with borrow checker in closure. This code will explain it better than me: [https://pastebin.com/THtK3hjf](https://pastebin.com/THtK3hjf)
Because without them, it'd be a pain in the ass. You'd have to define every method twice, and you'd have to import every type's corresponding trait to do anything with it. Just *no*. I use struct methods when I don't have a compelling reason to define (or don't suspect I will need) an actual trait. Aside: there's no such thing as "struct methods". There are inherent methods (well, inherent associated functions, really), which you can define on any type, not just structs. Structs are not special.
If you look closer at the error, there's a suggestion: help: to force the closure to take ownership of `safe_db_connection` (and any other referenced variables), use the `move` keyword | 25 | server::new(move || App::new() Did you try this? The problem here seems to be that `safe_db_connection` is constructed outside of the closure passed into `server::new` which has specific lifetime requirements. In particular, I think the closure is marked as `'static`, which would essentially require it to take ownership of any variables it references.
True, I was also thinking of making them multicolor...
&gt;Aside: there's no such thing as "struct methods". There are inherent methods (well, inherent associated functions, really), which you can define on any type, not just structs. Structs are not special. I don't have a CS background so the lingo sometimes isn't clear to me, but thanks for letting me know. And about Traits vs associated functions: Still trying to understand when to use what. What would be a classic use case for when to use traits? And I'm not asking for code examples, but a few examples in normal English. What would be examples for when to use traits and when to use associated functions. So far in all the (beginner) traits examples I worked through traits were just used to basically just save a few lines of code and not because it couldn't be implemented with associated functions. However I cannot imagine that everyone loves traits so much, just because they have to do less typing/have less code. What can I do with a trait that I cannot do with an associated function (besides having less LOCs)?
You use traits for broadly the same reason you use interfaces in a contemporary OOP language: you want to do be able to do the same thing to values of different types. `Display` is a trait because you want to be able to display lots of different types. You can say "I want a value of a type that implements `Display`". You can't do that with inherent methods; just because two types have a `fmt` method doesn't mean they do the same thing or have compatible semantics. Traits are also how you get dynamic dispatch.
I know LuaJit is almost "defacto" but the hybrid int(53)/double type have bit me already and is extremely annoying to work around. I hope some day a proper language will appear to take its place.
Cargo has an unstable [`out-dir`](https://doc.rust-lang.org/cargo/reference/unstable.html#out-dir) for this. The downside is if you have other final artifacts besides the bin (like completions generated by your `build.rs`), you don't get those. I'm (slowly) working on a tool meant to organize final artifacts for distribution, [cargo-tarbald](https://github.com/crate-ci/cargo-tarball). it has a reusable core/config that I plan to make other packaging tools from.
One difference from OOP is that, since this is a trait you've defined yourself, you can implement it for any type and not just your own. You could impl Drive for bool, for example, with true/false mapping to Forward/Backward. Or impl Drive for any other type you've brought in as a dependency.
Whats your pricing model?
Oh I'm afraid this is a bit over my head still. I have no CS background. And I don't even know what interfaces are. Let me try and rephrase that in noob-language: &gt;you want to do be able to do the same thing to values of different types. Display is a trait because you want to be able to display lots of different types. So this could also be achieved if I gave all those types an associated function. Is that correct? So the benefit of having a trait is just that I have less typing to do? 
Not yet; currently we parallelize by making each function independent. The ECS-style design gives us compact data structures.
&gt; I have no CS background. You don't need one. Just keep reading everything you can get your hands on. &gt; So this could also be achieved if I gave all those types an associated function. Is that correct? No. This function will show any displayable value: fn show&lt;T: Display&gt;(v: &amp;T) { println!("{}", v); } This could not be written without `Display` being a trait. You need to say "T implements Display" in order to use that functionality. If you have a group of types that all have some inherent method (which is not part of any type), there's no way to invoke that method generically.
thanks a lot. I'll play around a bit with traits today and also apply your bool example. all around the traits sounds so good.
https://crates.rs is kinda similar
Pandas finally has merge_asof, and dataframes are kinda like a slow, single-language non-persistent in-memory database..
Previous posts like this have been well received. I think you're fine. Personally I'd appreciate a bit more information about what you're asking for. A "website" can vary from "host some static resources" to "reimplement Google Images" after all.
OK just to be sure. Let me noob-phrase what the function does: "This is a function that can take in any type(?) that has a "Display" trait." OK I understood this. Let's quickly check if I really understood tihngs: 1. If a type(?) does not have a Display trait, I cannot print it with println!. Is that correct? That's why I cannot just do something like: println!("{}", instance_of_a_simple_struct); 2. Could I not just give my struct an associated function that displays its own data? So that I can run something like this: instance_of_a_simple_struct.print_itself(); ? 
&gt; "This is a function that can take in any type(?) that has a "Display" trait." A function `show`, defined for all types `T` which implement the `Display` trait. Types do not "have" traits, they implement them. &gt; If a type(?) does not have a Display trait, I cannot print it with println!. It would be more correct to say: values of types which do not implement `Display` cannot be converted to text via the `{}` specifier (as used by `println!`, `writeln!`, `format!`, *etc.*). &gt; Could I not just give my struct an associated function that displays its own data? Yes, if you only care about displaying that one type. The point of something like `show` is that I can pass it values of *many* types, without having to write `show_i32`, `show_f32`, `show_str`, and so on.
Is there a reason why we are skipping rustup? If so, then maybe there should be some explanation of how to get the compiler without rustup too (or maybe a link to an explanation).
Which meetup is that? :)
Totally fair! &amp;#x200B;
updated.
Yeah, let mut did not fix the issue for me. I still get this issue when I compile: error[E0277]: a collection of type `&amp;mut std::vec::Vec&lt;std::string::String&gt;` cannot be built from an iterator over elements of type `std::string::String` --&gt; main.rs:85:59 | 85 | let mut split = line.split(" ").map(|s| s.to_owned()).collect(); | ^^^^^^^ a collection of type `&amp;mut std::vec::Vec&lt;std::string::String&gt;` cannot be built from `std::iter::Iterator&lt;Item=std::string::String&gt;` | = help: the trait `std::iter::FromIterator&lt;std::string::String&gt;` is not implemented for `&amp;mut std::vec::Vec&lt;std::string::String&gt;`
I just found the inclusion of another Seriously quite funny. But having been diagnosed with Epilepsy its funny noticing these disclaimers now. \*Not confirmed to be photosensitive tho\* 
Awesome, thanks! I'm terrible at visual design, so I won't apply, but best of luck. PS. Your links points to http**s**://www.se4.space/ when it needs to point to http://www.se4.space/
Ahhh OK. I'm getting closer to understanding this. :-) Just two more questions: (I promise!) 1. So I can println! an "u8" for example, right? So does that mean that the type "u8" implements the Display trait? 2. Let's say I have this code: struct Person { name: String, } let matthew = Person {name: String::from("Matthew Johnson")}; So struct is a type, correct? But then what is Person? Can you please fill in the blank or correct me here: Person is a \_\_\_\_\_\_\_ of type struct? mathew is a \_\_\_\_\_\_\_ of type Person? Since I can implement a trait for Person, but not for a struct in general, I guess that Person is the type here? But then what is a struct? I'm so confused.
The compiler thinks that you expect `collect()` to return a `&amp;mut Vec&lt;String&gt;` instead of a `Vec&lt;String&gt;`, which it doesn't know how to do. Take a look at [this example](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=db1228dbfe869b8a1c819cd9ad08b0c8) and see if you can figure out what it's doing that's different from your own code.
Don't feel discouraged - it's probably more the back end that we'd need help with. As we have concept artists working on stuff it wouldn't be hard to provide a layout and design etc, it'd be executing that which would be our issue. (and the time factor, of course)
There is https://github.com/kpcyrd/snail that uses trust-dns to build a dns recursor as a dnsmasq/unbound replacement, among other things. Sadly there's a limitation in the api design of the function that handles dns request that requires me to block the event loop until the Server I'm forwarding to has replied. I've been using the alpha releases in multiple projects, I'm really happy about this release!
&gt; So does that mean that the type "u8" implements the Display trait? [Yes](https://doc.rust-lang.org/std/primitive.u8.html#impl-Display). &gt; So struct is a type, correct? No. `struct` is just a keyword. A structure (usually abbreviated to just "struct") is a kind of type. The `struct` keyword is used to define a structure. `Person` is a type, which happens to be a structure. `matthew` is a variable of type `Person`. &gt; [..] for a struct in general [..] Aside: you can't do anything with "structs in general". That is, there's no way to accept an argument that is a struct, or require a type parameter to be a struct. They're just types, like any other.
Okay, I see what's going on, at least to a degree. In the code you posted you mutated the vector in the same function. I am trying to change one of the strings in the vector in a different function. The only way I've seen that I can do that so far is if I pass the vector in like this: &amp;#x200B; fn modify_string(split &amp;mut Vec&lt;String&gt;) { &amp;#x200B; If I make a call like that in the example you gave, it causes the same error I'm seeing. [Here's](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=e0ce8a7a6fad3bb35ec9db34f8e45e3e) the modified version.
&gt; This doesn't work because you need to set the frequency attribute, right? No, it does not work because you've got the syntax wrong. Firstly, `abc` is of type `Stats`, so `Stats{ abc }` looks like you're trying to put a `Stats` into a `Stats`. Also, fields in structs are named, you've already used it correctly when constructing `abc`. &gt; If that's the case, why is this valid code? That's something different altogether. Note that in your implementation of `Clone`, the two brackets around `*self` refer to the function, i.e. they delineate the function body. Since you're derived `Copy`, `*self` makes a copy of `self` and returns it, which is of type `Stats`, so it all works out.
That's really disappointing. I'm sticking with actix for now. 
&gt; Your experience is important to us Then you *might* want to start by looking at this subreddit *before* blindly posting to it. /r/playrust
who cares :) &lt;3
I do have some plans to eventually do this for some specific other features in the server. I’m finally getting to a point I might start. I’m excited that you are having good luck with the libraries! That’s great news.
No. Not yet. See the other reply as an option. The named binary will eventually support some options for this, but not yet.
&gt; If I make a call like that in the example you gave, it causes the same error I'm seeing. [Here's](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=e0ce8a7a6fad3bb35ec9db34f8e45e3e) the modified version. Change `test(split)` to `test(&amp;mut split)` and it will work. The reason why it didn't work is because the test function wants a mutable reference to the vec - but you tried to give it the whole vec, not just a reference to it.
What exactly is PhantomData? I've seen it used in places, but I don't understand at all what it is. From the book: &gt;When working with unsafe code, we can often end up in a situation where types or lifetimes are logically associated with a struct, but not actually part of a field. I'll definitely submit a PR to the rust book if I can get my head around it. Does anyone have an example of this case in C/C++?
I want to note that here because you're using an array your structure is 400b on the stack, I don't jnow if that was the intent. &gt; No, it does not work because you've got the syntax wrong. Firstly, abc is of type Stats, so Stats{ abc } looks like you're trying to put a Stats into a Stats. Also, fields in structs are named, you've already used it correctly when constructing abc. To complete this, you can use a struct to initialise an other struct using the `..source` syntax e.g. `let b = Stats { ..abc }` is valid, and will copy the contents of `abc` into `b`. OOTB you'd usually do that by just deriving `Clone` and/or `Copy` (especially because the unpacking syntax requires that all fields are copy, and that the code has visibility into the fields). It's mostly useful for partial override e.g. you initialise some fields explicitly then fill in the rest using a base/default version of the structure, I've rarely seen this used outside of using the `Default` trait.
The macro magic makes it so you never actually see what's going on. You can't easily get docs for the generated modules, you have no autocompletion and the combinatorial query building that it does can be very hard to follow. I'm not sure if there are other similar projects going on, but I'd like to see an approach that is more focused on constructing SQL from types.
The first thing does not work because Stats does not have an \`abc\` field,the compiler interprets \`Stats { abc } \` as trying to construct a Stats by assigning the variable \`abc\` to the field \`abc\`. &amp;#x200B;
PhantomData is a zero-sized type, specifically so that the Rust compiler doesn't complain about unused types or lifetimes. Consider the above puzzle where I had F associated with the struct Bar, but didn't actually hold a value of type F. So normally, this could be considered a mistake, as in why are you using a generic you don't actually hold in the struct? So you use PhantomData to basically "trick" the compiler into allowing you have the generic F in your type. 
No, you don't. Sorry, it seems I confused you with my previous reply. Let me try again: You don't *have* any kind of reference in your case, you have a *Vec*. Directly. Your `split` variable *is* the vector. It's *not* a reference. There is only one kind of `mut` you can use here: let mut split: Vec&lt;String&gt; = "My vector containts data".split(' ').map(|x| x.into()).collect(); It's no different to this: let x: i32 = 42; // you can't change x let mut y: i32 = 99; // you can change y But instead of `i32` you want `Vec&lt;String&gt;`. If you want to be able to make changes to this Vec, you need a mutable binding for it. The point I'm trying to bring across is that this is one aspect where Rust is different to Python. In Python everything is a reference. In Rust, such kind of indirection is always *explicit*. Rust allows you to hold (most) things *directly* without having to follow a reference or pointer.
And in terms of C++, I don't think there is a similar concept, because C++ compilers don't really check for unused generics in templates. They do check for unused args, so the common `#pragma argsused` is the closest parallel, but its really more like an attribute turning off a warning in Rustc. 
 error[E0597]: `*safe_db_connection` does not live long enough --&gt; src/main.rs:27:73 | 27 | .route("/api/card/{id}", http::Method::GET, |req| api::card(req,safe_db_connection.clone()))) | ----- ^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough | | | capture occurs here | = note: borrowed value must be valid for the static lifetime... note: ...but borrowed value is only valid for the lifetime as defined on the body at 25:18 --&gt; src/main.rs:25:18 | 25 | server::new( move || App::new() | __________________^ 26 | | .handler("/api/online", api::online) 27 | | .route("/api/card/{id}", http::Method::GET, |req| api::card(req,safe_db_connection.clone()))) | |____________________________________________________________________________________________________^ error: aborting due to previous error Yeah, I'm tried and I'm getting following error :c
I have never found the Struct{field\_0: .. ,field\_1: .. ,..other\_struct} syntax useful,since the only times I need it are when I need to change the type parameter of a field,which you can't do with this right now. For other cases where I want to update a field I use this method: trait SelfOps{ fn mutated&lt;F&gt;(mut self, f: F) -&gt; Self where F: FnOnce(&amp;mut Self), Self: Sized, { f(&amp;mut self); self } /* Other methods */ } impl&lt;This:?Sized&gt; SelfOps for This{} 
It's useful when you want a struct that mostly has default fields but has a couple that are changed, like: ```rust Foo { foo: .., ..Default::default() // sets `bar` and `baz` } ```
Yup, I seriously understood traits properly only now, after seeing his example!
Correct.
You could kinda fake this with a trait and a default implementation, but basically rust doesn't want you to use this particular software pattern (inheritance) in the first place.
Every comment is already "why not rustup?", OP didn't elaborate [the other day](https://www.reddit.com/r/rust/comments/9skiyi/wasm_without_rustup/) so I doubt they will today either.
honestly i had really trouble with traits until today. and yes to finally understand this concept was really gratifying :) &amp;#x200B; and if i can someone help with this example, that would be really great.
You should take to consideration switch to data oriented / functional programming paradigm 
As mentioned, OOP inheritance and method overriding is not the model in Rust. This chapter of the Rust book addresses that: https://doc.rust-lang.org/book/second-edition/ch17-00-oop.html You can override a trait method, where a trait is acting like a Java interface with default methods here. Example: struct Base; struct Derived; trait Trait { fn foo(&amp;self) -&gt; String { "base".into() } fn print_foo(&amp;self) { println!("{}", self.foo()); } } impl Trait for Base {} impl Trait for Derived { fn foo(&amp;self) -&gt; String { "derived".into() } } fn main() { let base = Base {}; let derived = Derived {}; base.print_foo(); derived.print_foo(); } 
I've used the mutated method enough that I would just write it like this: let variable=Foo::default().mutated(|x|{ x.field0=value0; x.field1=value1; }); This is basically a pattern in my own libraries whenever I want to do some mutable initialization. I discovered mutated after some annoyance with nested scopes(this is a distinct case from initializing with Default::default): let variable={ let mut variable=Foo::new(); /* some initialization */ variable } 
Try to add another `move` for the `|req|` closure. Also, if the db is shared across multiple routes you'll probably have to create a clone before it's moved into the closure. If possible, it would be nice if you can link to some runnable code. There might be more intricacies involved which pop up.
Will there be an option to turn the warnings into hard errors, like `#[deny(borrowck_soundness_holes)]`?
Not OP, but I think it's pretty reasonable to want to be able to do this without rustup. Installing on a computer without an internet connection. Packaging for a package manager. Just understanding how the tools you use work. Etc.
I knew I've seen it before but I forgot it. Thank you 
Yep, that's what it was. I didn't know you could call a function with `&amp;mut varName` like that. Thank you.
Previous threads from this series: * [Shifgrethor I: Garbage collection as a Rust library](https://www.reddit.com/r/rust/comments/9ozaut/shifgrethor_i_garbage_collection_as_a_rust_library/) * [Shifgrethor II: Notes on tracing garbage collectors](https://www.reddit.com/r/rust/comments/9qggzd/shifgrethor_ii_notes_on_tracing_garbage_collectors/) * [Shifgrethor III: Rooting](https://www.reddit.com/r/rust/comments/9r23c1/shifgrethor_iii_rooting/) And there's also the internals thread: * [Shifgrethor: garbage collection as a Rust library](https://internals.rust-lang.org/t/shifgrethor-garbage-collection-as-a-rust-library/)
Yep, that's it. I knew you could pass `&amp;split` but did not know that you could pass it with the `mut` keyword like that as well. Thank you for your help.
I'm not sure, but I'd imagine so, given that the warning infrastructure supports this.
your argument now is "well i'm talking past you and ignoring valid points, so i guess we're done here" ..really?
Interesting idea! I know this situation very well and also wrote these kinds of extension traits several times. The duplicated code is really annoying. So there is [the crate `extension-trait`](https://crates.io/crates/extension-trait) which seems to do exactly that, but with a function-like `macro_rules` macro. I agree that an attribute proc macro would be more fitting here. I think it should even be fairly easy. Maybe I'll try to tinker with this sometime.
Just as a suggestion, you should probably include some sort of label stating that the website is currently under construction so visitors don't just think their browser is not loading the page correctly or something. Unless it is just not loading correctly for me.
I’m mostly curious what the reasons are. No network access is a deficiency in rustup at the moment that it’s required. Support for local installations is important imo. 
I didn’t know there was an earlier post. For me bypassing rustup can indicate that rustup is lacking in some regards so I think it’s important to digure out why one would do it. 
Can you implement copy for your BigNum type? Because then you can just impl Add for the non-reference type and have everything work fine. That's how it's done for the built in primitives IIRC.
I'd recommend making four `Add` impls: `Add&lt;&amp;'a BigInt&gt; for &amp;'b BigInt`, `Add&lt;&amp;'a BigInt&gt; for BigInt`, `Add&lt;BigInt&gt; for &amp;'a BigInt`, and `Add&lt;BigInt&gt; for BigInt`. This is the most general, and as a bonus in the ones containing at least one by-value `BigInt`, you can reuse that `BigInt`'s allocation rather than needing to make a new one. If I recall correctly, this is what existing big integer crates do.
What's a way around this pattern then?
Awesome. Make sure to submit it to the `extension-trait` crate instead of publishing another crate - no need to have two crates doing "the same", right? Let me know if you have something working! :-)
Doesn't that mean every time the add function is called, the attributes will be sent in by value? That may be a problem if each BigNum value takes up several KB of memory. I would want to continue to send it in by reference, just make the borrows invisible from the user.
Seems to be the same thing the `foo` crate in my example is doing. Given that, how can a crate that depends on `serde` know if the `integer128` feature is on?
It did, thanks. It turned out to be quite a silly mistake, too. I have some doctests that illustrate various concepts about the configuration struct I provide. Separately from this, I have a test that ensures that the default configuration (provide as `config-example.toml`) is valid. I saw failures related to deserialization and went immediately to checking `config-example.toml`, forgetting that the doctests just use a string literal. Once I realized and changed the literal to include a missing key, everything worked perfectly.
&gt; `tokio-core` is forked and vendored inside to make it single-threaded. Here is the link to changes. `tokio-core` is deprecated and `tokio` should be used instead. And you should be able to use the current thread run-time to make your app single-threded.
This sounds very fun! Where did you get that super cute character sprite!?
TL;DR Use composition with another type implements the shared behaviour (and holds any shared state). This example shows the two ways of sharing implementations between types. The `bar_and_baz` method can be implemented directly as part of the `Foo` trait because it's implementation depends only on the methods which must be manually implemented for each type. Whereas the `bar` method must be implemented as part of the `Base` type which is nested as a property of both derived types as it depends directly on the type's state. Note that in Rust nesting types like this is as efficient as if `data` was a direct property of the derived classes, because DerivedN and the nested Base struct will be allocated as one contiguous block of memory (no pointers will be used). trait Foo { fn bar(&amp;self) -&gt; String; fn baz(&amp;self) -&gt; String; fn print_bar_and_baz(&amp;self) { println!("{} and {}", self.bar(), self.baz()); } } struct Base{data: String} impl Base { fn new (data: &amp;str) -&gt; Self { Self {data: data.into()} } fn bar(&amp;self) -&gt; String { format!("bar with {}", self.data) } } struct Derived1 { base: Base } impl Derived1 { fn new (data: &amp;str) -&gt; Self { Self {base: Base::new(data)} } } impl Foo for Derived1 { fn bar(&amp;self) -&gt; String { self.base.bar() } fn baz(&amp;self) -&gt; String { "baz1".into() } } struct Derived2{ base: Base } impl Derived2 { fn new (data: &amp;str) -&gt; Self { Self {base: Base::new(data)} } } impl Foo for Derived2 { fn bar(&amp;self) -&gt; String { self.base.bar() } fn baz(&amp;self) -&gt; String { "baz2".into() } } fn main() { let one = Derived1::new("ice"); one.print_bar_and_baz(); let two = Derived2::new("cherries"); two.print_bar_and_baz(); } Output: bar with ice and baz1 bar with cherries and baz2 Playground link: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=e9893f126e8f4bab0e7da0e7cb28e88f
You can use `Rc` or `Arc` inside `BigNum` to make copies inexpensive.
am I the only one who has a hell of a time trying to use it?
the tokio::run method requires a future with Item type of `()` and Error type of `()`. It makes sense when you realize that there are many futures being run on the same executor (the tokio runtime). How could it possibly accommodate every set of Futures? The answer is that it restricts them with the `()` type. The best way to get around this would be to use channels to send back a result. It seems like overkill, and it is, but this is how async works.
The reason I didn't go with `static_assert!` is because the assertion doesn't do anything with Rust's notion of `static` values. The term "static analysis" is why I went with `static_assertions` for the crate name, since all macros in it perform some form of compile-time checking.
I asked the author of `extension-trait` about this [here](https://gitlab.com/KonradBorowski/extension-trait/issues/5). Let's see what they say. If they want to keep their current solution (for backwards compatibility or faster compile times), I might experiment in my own crate. *However*, I think that these kinds of proc-macro helpers shouldn't come in their own crate. Most of them help to deal with minor inconveniences. But most people won't add a crate with 3 to 10 seconds of compile time to their project for minor inconveniences. If just writing out your extension trait or just implementing your trait for `&amp;T` is faster than adding the crate... it's just more time efficient to live with the inconvenience. So I think it would be wiser to pack all of these crates into a single one. Then one could easily add that crate once and have all helpers. Not sure about all of this. 
`as` is actually older than `From` and probably would not have been added if those existed at the time; it's known to have problems. But no you can't write your own `as` and it's filled with problems and counter-intuitiveness right now.
`Rc`/`Arc` aren't `Copy` though, they're `Clone`.
I think it makes sense to let async shake out itself before committing to it when you have limited bandwidth; although of course from a user point of view it's annoying if performance is necessary. You'll probably be glad to know that async is next in line after 0.4 is released, apparently.
Yes you are right. Fixed.
I'd love to see a recording of this talk. There's only so much you can get out of the slides without a talk to go with them. That said, I still feel like I got a reasonable amount out of the slides alone, and as someone trying to pitch Rust at work, I think the advice is good.
Very applicable to me as someone just cracking open the first chapters of The Book... 
To expand /u/ZerothLaw's answer a bit on why this is useful: * when using the type system for API clarity/safety: there you often end up with "marker" types that are zero-sized, i.e. their values contain no information and they can't be instantiated. But as markers, they have value in preventing mixups of incompatible types. * in FFI context, you may want to wrap e.g. C structs that contain just an opaque pointer, but the Rust side of things knows more, usually a lifetime associated with the pointer. Since there's no other good place to put it, you can use `&amp;'a PhantomData`.
See also [this issue](https://github.com/rust-lang/rfcs/issues/1215) for some additional discussion.
the obvious conclusion is that everything that looks vaguely like OOP is objectively bad and that factoring things out into lots of subroutines is also bad 1000 line free functions 4lyfe
specifically search the docs for `current_thread` and you can spawn a runtime on that thread with Runtime::new
Maybe I didn't fully understand everything in the post. Why is it a problem to have functions and methods automatically annotated by the compiler with information about which fields they access and how?
I typically prefer to use ULPs for floating point accuracy
I think it could be an interesting event for Rust game-developers to demonstrate their skill and Rust capabilities in this field.
But libs that depend on `tokio-core` (specifically current `rust-websocket`) still locked to either multithreaded runtime or old `tokio-core &lt;= 0.1.12`.
I should probably add that, I already have float\_next and float\_previous already implemented for the steps, so this is basically already done.
The Vancouver one.
This post sponsored by C gang
I know you're joking but I was going through some of the rustc source code and I bumped into this [~250 line method](https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src/librustc/middle/resolve_lifetime.rs#L1933-L2191) with its own custom struct and trait impl for the custom struct. I bet you've got some even bigger ones hiding in there somewhere :P.
I wonder if there could be a compromise where this would be enabled internally, but not for APIs that are visible outside of the crate.
Thank you! It is an awesome crate!
This reply sponsored by `segmentation fault`
`mozilla-nixpkgs` is your friend.
Isn't a solution being able to mutably borrow specific subfields? Kinda like split_mut, but you specify which fields you're borrowing at the `&amp;mut self`. Why is this not feasible?
It's still the source of truth for inter-mod boundaries as well, though. The purpose isn't just to keep different crates compatible, but also to help guarantee changes internal to different mods don't affect unrelated code. Otherwise we might as well have full type inference inside the same crate :p. Having everything in the signature makes it crystal clear what other code can rely on, and what the internal code must maintain to stay compatible, even in intra-crate interactions
Isn't that one of the options he offered?
This was mentioned in the post: "I’ve also toyed with the idea of trying to infer some of this information for private functions (or perhaps even crate-private functions)"
Row polymorphism!
It is completely feasible, and is the basis of all three of the post's "inlining," "free functions," and "view structs" solutions. You don't need any sort of new API to do this- just borrow all the fields you want to "split" within a single function, and the borrow checker will figure it out.
I might not have been reading closely enough. ¯\\\_(ツ)\_/¯
Yeah, the closest thing I'm talking about is probably free functions. But you know, do a language thing to make them not free like all other functions that take self as their first argument. The problem is you can't mutably borrow disjoint fields. ...Now that I write that, I feel like there might be an RFC on it. I'm not sure. ¯\\\_(ツ)\_/¯
You can mutably borrow disjoint fields.
At first glance it seems similar/to be an updated version of [this great talk](https://www.youtube.com/watch?v=GCsxYAxw3JQ) (which I had the pleasure of viewing live).
How about we make a macro to make that easier? Edit: [Done](https://github.com/jD91mZM2/jrust)
No access to the internet is a big one. A lot of places I know would like to try rust but are siloed off from the internet, so then give up 
So you can't modify the AST of a function post compile, rust isn't a dynamic language it is statically compiled so once the compiler exits you aren't generating new code.
Ahhh then you'll likely want to look into `proc-macro` and `macro1.1` work. This deals with how you can define custom `#[annotations(for=functions)]` But that being said, the parts that work on functions is still not stabilized so you need to be on nightly. 
I found that sourcing this as your default.nix will allow you to compile to wasm on NixOs. At least it works for me with cargo-web + yew. [https://gist.github.com/hgzimmerman/e0cc6e1ba3c48fcbc345fc9ae6cf01e4](https://gist.github.com/hgzimmerman/e0cc6e1ba3c48fcbc345fc9ae6cf01e4)
There's also [approx](https://github.com/brendanzab/approx) which has done the job for me.
Yes,it is feasible,here is a method named exactly that: [https://github.com/rodrimati1992/type\_level/blob/master/type\_level\_examples/src/\_07\_split\_mut.rs#L53](https://github.com/rodrimati1992/type_level/blob/master/type_level_examples/src/_07_split_mut.rs#L53)
&gt; But that being said, the parts that work on functions is still not stabilized so you need to be on nightly. I don't think that's true. My attribute proc-macro for use on a function is compiling fine on 1.30 stable.
I'd ask what happens when you guys do code review, but let me guess - *he's the one reviewing the code*. 
Once const-generics are usable I will create a crate with this,and a derive macro to derive them: struct Mutable; struct Immutable; trait TypeIdentity{ type Type:?Sized; } impl&lt;This:?Sized&gt; TypeIdentity for This{ type Type=Self; } trait Field&lt;const Name:&amp;'static str&gt;{ type Mutability; type FieldType; fn get_mut(&amp;mut self)-&gt;Self::FieldType where Self::Mutability:TypeIdentity&lt;Type= Mutable`&gt;; fn get_ref(&amp;self)-&gt;Self::FieldType; fn get(&amp;self)-&gt;Self::FieldType where Self::FieldType:Copy; } 
Without further context, it's hard to say what your example intends to accomplish other than printing the things in your output. Simply put, remove the class boilerplate and code what you'd like your program to do directly.
I did not see that actually, thank you. Super useful.
I think you may be looking for /r/playrust? Very cool though.
The code I maintain in my day job has methods even longer than that, except in Common Lisp. Sometimes they're actually macros. It's... interesting. 
For the free variables solution, maybe a "uses" clause could be slightly more ergonomic: fn signal_event(&amp;mut self) uses counter, listener { ... Then if you decide you need something else you can just add it to the list, no need to mess with the formal args or types. And if you don't specifiy "uses" then the compiler assumes you can use anything.
&gt; He's actually quite good No.
r/playrust
In Rust we use traits to pass implementation around. They work like Java interfaces. Inheritance does not exist in Rust and only static and dynamic polymorphism are used via traits. Static polymorphism is often called monomorphization in Rust. Sometimes we wish to delegate the behavior of a trait or method to a member, which is similar to polymorphism, but doesn't have some of the downsides. This can be done with [this](https://crates.io/crates/delegate) crate.
Makes sense. I'm not experienced in Rust, but would it be possible (or desirable) to have explicit signature (or structure) annotations to describe which function calls are compatible on a particular struct?
I'll likely do a game on top of [druid](https://github.com/xi-editor/druid), a Rust-native GUI toolkit that seems promising to me, largely to push the toolkit's capabilities.
Actually... probably yes. It takes serious raw skill to be able to keep your job with that attitude.
As someone working on evangelizing and getting Rust into my company, the biggest issue is libraries and finding companies that are using production Rust. Rust lacks well documented, 1.0 crates. It also lacks examples of big companies or foundations who will maintain and use those crates. At my company we have hundreds of millions of lines of C++ and we rely heavily on googles logger, boost, and grpc. To use Rust we’d need high quality crates for those and more.
Good call
You're welcome! I deliberately chose not elaborate on my reasoning because I don't want this thread to derail into a discussion about rustup rather than WebAssembly and the methods discussed. I can't really say I succeeded, heh. Folks who are fine with rustup should continue to use it. It's software that does its job well. This tutorial was specifically written for those of us who don't or can't use rustup. That is, it's written for folks who already have reasons to not use rustup.
The compiler is installed the same way you install the standard crates for WebAssembly: For linux, you'd download the tarball for your system's architecture, unpack, then run the script `install.sh` in the root of the archive. I expect other systems like windows would have their own way of installing. This is all mentioned in the tutorial under **Install**. (it was edited in about ten to twenty minutes after posting this tutorial here, so apologies if you missed it.)
Thanks, I’ve never heard of rustsim but now that I have I will be using it frequently
Sometimes a static site generator is a better option than a CMS.
Could someone familiar with simulation describe how abstract algebra is applied within a sim?
Can someone explain how the view struct works? I understand the logical reasoning, but how does this not still violate the borrow checker's rules about mutably borrowing something that is already immutably borrowed?
That, and I am frequently in a situation where I can only write within my home folder.
There's some other uses besided making rustc shut up about unused stuff. For example, you can use PhantomData to make your type impl !Sync or !Send, which is otherwise quite tricky.
A lot of my code at work looks like that, because it's all dynamically loaded and compiled in parts, so you can't just add functions to headers without half the team having to stumble through failed compiles. But this is a 30-year old code base...
Hey, this is awesome! If you need any help getting parity with 'BeautifulSoup' pushed through, be sure to mark easy issues or issues you want help with. You can get them featured in TWiR so you can get more eyes and ears on this! Best of luck to you. If you manage to get this comparable to the Python inspiration, then that will be a huge win for the Rust ecosystem. Ç)
A type with arbitrary-sized value support needs dynamic allocation, which is incompatible with `Copy`.
Awesome, I was looking for something like this yesterday. I've been wanting to rewrite my apartment hunting bot in rust for fun but there didn't seem to be a working rust version of the python craigslist scraping library I used last time. I was eyeing html5ever but now I think I'll see what I can do with soup. Thank you for posting this!
One catch: typical cache architectures do not permit every piece of memory to reside at every cache location. Ryzen’s L1D cache is 32 KB/core, or 512 lines — and its 8-way associative, so for any given memory location, it could be stored in one of 8 cache lines. This lets the CPU narrow down its search to comparing 8 addresses instead of 512, which is good for performance and power consumption. It also means that the cache can’t simultaneously store 9 pieces of data if they all want the same 8 slots, which is bad. Having said all that, I’d wait for profiler output in a real project to indicate that this is an issue here. It’s true that cache placement policies can be a real source of problems long before cache itself is full, and it’s true that a little padding here or there can relieve the issue completely, but without solid data pointing to this being a problem in a specific environment, any “fixes” are indistinguishable from snakeoil.
Psychologist with a specialty in speach impediments. I'll see myself out.
This is awesome! BeautifulSoup was the first library I used in the first program you wrote! I'd love to help with gaining parity with the python library :)
One example is the use of abstractions of Lie groups and Lie algebra for physics simulation and robotics. The company I worked for in the past developed a (proprietary) physics engine that relied heavily on those abstractions to write integration schemes with certain characteristics.
Well how about an optional addition to function signatures, let's say: `where &amp;mut self.foo, &amp;self.bar`? This can be checked by the compiler.
It looks like the syn crate was the missing piece here... Thank you! I really wanted to have the procedural macro style, but I wasn't sure that dealing with token streams would give me enough to work with. I think this will be a good start!
Yeah - I don’t want to discourage op - but I highly recommend building on Mozilla’s html5ever. I’ve personally used [select](https://crates.io/crates/select) and have loved it. It would be awesome to have a soup like api/wrapper around something like html5ever. 
This one also uses html5ever.
Yup dug deeper and found that out. Thanks
First published version is 1.0.0. You must be very confident in API.
Did you publish the repo?
If your struct can be `Copy` and will be `Copy` in the future, then there isn't really a reason to avoid that. It isn't costly! If your struct is so huge that constructing a pointer to the stack frame and dereferencing that pointer times within the function each time it's used is cheaper than passing 12 bytes as a function parameter, then the compiler will automatically replace the copy with a by-reference pass. But that's pretty unlikely in my understanding - small structs are cheap to move around on the stack. If you don't have a `Copy` type, then using references explicitly is the idiomatic solution. Non-copy generally means "uses an allocation somewhere", so this has the advantage that the user can explicitly choose when to re-use an existing allocation. This matters a lot for high-performance code in crates like `bigint` - `&amp;x + &amp;y` could very well be much slower than `x + &amp;y` or `&amp;x + y` since it needs to create a new allocation. Explicitness matters here since each pass-by-reference is a tradeoff between being able to use the variable later and letting the addition reuse an existing allocation.
Is this something to avoid ? If so why ? My reasoning was that the current API is working well, and is usable as is. If breaking changes have to be made, the version number can always be incremented.
Honestly I kinda hope they write it into the compiler or some form with better error messages. Seems like a cool library.
I guess something to scrape some listings and show you the best appartements matching your criteria.
Ah, OK. Yeah, that's one of the [three ways](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=32c4361d7c2a05603968aba3e6b11587) you can pass something to a function.
Composition 😎
Maybe!
Yeah that was more of a cheeky way of asking if it was open source
Great! We now have multiple choices for parsing HTML in Rust. Here is the list of the crates I know of: - [scraper](https://crates.io/crates/scraper) - [select](https://crates.io/crates/select): I have had a nicer experience than with `scraper` so far - [kuchiki](https://crates.io/crates/kuchiki), which was suggested by /u/wezm - and of course [soup](https://crates.io/crates/soup), which looks promising. All of these use [html5ever](https://crates.io/crates/html5ever) under the hood.
Yes, the repo is here: https://gitlab.com/pwoolcoc/soup
That's both really interesting and promising. I like your idea of lazy query evaluation - was that in FoxPro? FoxPro was before my time but my uncle used to be a FoxPro programmer and loved it! I will send you a PM as I'm happy to give you feedback as you iterate.
I came from an ML, Lisp, JVM, BEAM, CPP, and C background, at first everything was easy, then I began hitting a wall when I decided to work on a networking project that combined polymorphism, shared mutable state, and networking, I was trying to port it from another library I wrote in Ocaml in a way where the API remained similar, and all while trying to avoid lifetime elision for aesthetic reasons and then it got rough. Honestly nowadays the hardest part about rust, is really keeping track of it's evolution, and hacking around the trait / type class system for modularity reasons, and if you're a serial premature optimizer like myself Rust discourages and encourages you at the same time to do so. 
I came from an ML, Lisp, JVM, BEAM, CPP, and C background, at first everything was easy, then I began hitting a wall when I decided to work on a networking project that combined polymorphism, shared mutable state, and networking, I was trying to port it from another library I wrote in Ocaml in a way where the API remained similar, and all while trying to avoid lifetime elision for aesthetic reasons and then it got rough. Honestly nowadays the hardest part about rust, is really keeping track of it's evolution, and hacking around the trait / type class system for modularity reasons, and if you're a serial premature optimizer like myself Rust discourages and encourages you at the same time to do so.
It's a bit like the example JSON parser: https://github.com/Geal/nom/blob/master/tests/json.rs You would have a main "html tag" parser, that would try parsers for the various tags, and those one would call the "html tag" parser
I googled it and it looks interesting, I'll give it a look after I've finished my current book.
I thought the value above was a little bit too big, I just took the first number that I found in google. I created a **very** simple benchmark that iterators over `N` arrays with 10k elements. [Benchmark](https://i.imgur.com/MnJqIV1.png), [source code](https://github.com/MaikKlein/hpr/blob/master/src/bin/prefetch.rs) on an Ryzen 1700. And then I plot the performance for `N`, so in the image the horizontal axis represents `N`. 
Yeah, we have several cons and we will tackle them when the time is right. 1. Don't provide database transactions (yet). 2. Don't offer to write directly to the on-disk database (yet). This is because our current use-case is: store incoming data to an in-memory database for real-time analytics and then it's flushed to on-disk at EOD for backtesting new models.
Fixed (it works fine with the new Reddit)
To be fair, this is just basic inheritance polymorphism. There are use cases for it.
&gt; it works fine with the new Reddit Oh, they work differently? That's good to know. When the old Reddit interface is removed, I will stop using Reddit, unless someone (like RES) has created an alternative, more usable interface.
Yeah, I guess the new parser is a bit smarter.
Just curious, is this the renaming of `xi-win-ui` that was mentioned a week or so ago?
As long as you don't do anything that silently turns your ints into floats due to missing values (e.g. joins) or accidentallly compare a string and integer column (which will always be false, but gives no warning) it's not too bad. The worst is when using nanosecond precision, Pandas loves to find a way to convert the uint64s to doubles and kill their precision.
Yes it is. I was already thinking of doing some simple game, largely to have a testbed for performance. I'm also tempted to use the analog oscilloscope emulation as a vector-scope display (in keeping with the hybrid them), but still brainstorming.
It is, of course :). https://github.com/yaahallo/apartment-finder The readme is inaccurate, I never changed it after forking the repo. The main difference between my version and the one I started from is that I use Google maps directions data instead of straight line distance to Bart stations as my metric for comparison. I already got the gmaps part ported and it was incredibly easy thanks to serde. I haven't yet pushed the WIP for the rust version, but I will one it's a bit further along.
The documentation is great. However as someone who's research heavily relies on linear algebra, it does make me a little sad to see you call it your go-to reference for learning this topic. I say this just because there's so many amazing things in linear algebra that just aren't covered by the crate and it's documentation such as krylov subspace methods or tensor train decompositions. Once again, I want to reiterate that I like the documentation, and it does a decent job of explaining what linear algebra it does use. 
It is for the rust ecosystem, but not all. npm’s equivalent of “cargo new” sets the version as 1.0.0, for example...
If you're willing to lint against the non meaningful declarations, you can lint against that as well: fn foo&lt;T: Copy + Drop&gt;(_t: T) { } 
The articles I linked show Timescale beating specialized databases, just FYi
How does it relate to Failure?
You're welcome. Dealing with the raw token stream is indeed a huge pain; I'm glad someone else wrote the syn crate, because if I had written a parser to pull things out of the token stream it would have been a really bad one. Have fun :)
How does it compare to https://github.com/jedisct1/dnscrypt-proxy
I don't think any of the upcoming proc macro stabilizations are going to help you here. You would need to write your own stable version of rustfmt.
Hey! :)
It's airline pricing software.
I'm pretty sure I am too, and rustup works just fine in such a situation... at least the version from rustup.rs does. What problems have you run into?
What you mention is a relay for dns, to encrypt using dnscrypt. After I reviewed the dnscrypt protocol, I decided I wasn’t interested in implementing it, and instead focused on dns over tls and dns over https, mostly because these latter two have much more shared library code, whereas dnscrypt is custom. As to differences. at this point trust-dns is mainly a set of low level libraries for working with DNS in Rust code, but also has a simple named that supports DNSSEC, DoH, DoT, and dynamic update (though this needs some attention as there’s no good syncing between named nodes at this point). In the future I’d like us to offer more binaries to facilitate things like dig, or similar functionality to dnscrypt-proxy. After a big refactor recently, I’m going to be starting work on some of the gaps and tools that are currently missing.
I used bs4 the other day to download a directory of files. I learned the schema of the web site interactively, with IPython. Analyzing the response results every step of the way is what lead me to a solution. This method of development cannot be replicated with Rust. What kind of workflow is this good for? 
Why do we have tuples if we have structs? Anonymous sum types are to sum types as anonymous tuples are to structs. I have wanted anonymous sum types ever since I saw them in Crystal. I haven't read the pre-RFC yet, but anonymous sum types can give you really convenient ergonomics if you go so far as to allow treating them as duck types.
gotcha :)
I personally have disagreement with the idea that things could return these untyped enums and expect someone to know or guess the order of variants. If every type was unique in an anonymous sum type it could be self documenting by having appropriately constrained types/newtypes, the match block semantics could simply allow the types to be used directly, we wouldn't need to litter code with `::0` everywhere, and we wouldn't need to remember/look up order. Tuples are often only used when working with data where the order is implicit or commonly known, such as with coordinates or key value pairs respectively. With anonymous sum types, I would expect people to be returning something like an event or an error, cases where the types are unique and could be pattern matched on themselves. If you combined two of the same type in an anonymous sum type, I feel like that is already a problem. Tuples aren't even used that way in any API I can think of (sometimes for local functional programming tuples are used, but we have newtypes for anonymous sum types), and since anonymous sum types have the advantage of usually having unique types for each variant, why not take advantage of that and eliminate this syntax? I think it would be better if I could do: ```rust struct Positive(i32); struct Negative(i32); fn pn(x: i32) -&gt; (Positive | Negative) { if x &lt; 0 { Positive(x) } else { Negative (x) } } ... match pn(5) { Positive(x) =&gt; ..., Negative(x) =&gt; ..., } ```
Thanks! I'm still iterating on the API right now but as I collect E-Easy issues I will make sure to tag them as such :)
I feel like not enough is specified, especially if the sum type has duplicates (`(i32 | i32) `). Would a macro, may be, be helpful, like a `bind_sum!(n, i(value)) ` where `n`is the number of things in the sum and `i` is the index you'd like to match? 
I am not saying that I ran into problems, just it would be good to have an option to download "snapshot" of rustup / cargo so it can be .tar.gzipped and copied onto a machine. The way I am doing this today is I spin up a VM / container / chroot, do rustup, git clone, cargo build and then tar all the directories and copy those to the "restricted" machine. I don't know if this problem even needs to be solved, but the assumption that you are "always connected" and "always can install whatever" to your machine are still far from the reality.
I like the *idea* of anonymous sum types, but think that actually having them would be a negative. Having to use number literals for variants that depend on declaration order (!!!) looks pretty bad, and feels less safe from an API stability perspective even though I know it's basically identical - any consumers that use the same type have to copy and paste the anonymous sum type signature instead of just importing the type and using that, with having to recopy if it changes. Rust doesn't have untagged unions or type system hackery for merging error kinds that would lead to a ergonomics win, you're just not having to declare a one-shot Error type, which `failure` more or less fixes anyways. The other reason, replacing Either, I don't find very convincing since now you're not able to use any methods impled for Either, and it fills the kind of "rust standard library provides features that the community stabilizes on" that it was designed for: being Top 10 is a feature in most cases.
Can it do XPath?
Unfortunately, sometimes it does not suffice. I had an interview in a startup because they planned to maybe use Rust for a project. One of the main C++ developers was there, and he continuously launched unwarranted attack to Rust. He had not even tried the language, he knew nothing about it, but said tons of wrong things about Rust without waiting for my answers. I'm not a Rust zealot, but I like coding with Rust and the project was fun, so I'd have liked to work on this. But eventually, the boss said that he changed his mind and didn't want to use Rust, whereas I could barely talk about it.
This starts to look kind of like a `match` binding when you write it like that. Would be really neat if you could write function arguments as match bindings.
Thanks! Why [GNU GPLv3](https://gitlab.com/pwoolcoc/soup/blob/master/LICENSE) ? Would you consider re-licensing under the more permissive/rusty dual MIT and Apache?
&gt; any consumers that use the same type have to copy and paste the anonymous sum type signature Or take advantage that Rust will infer types within the body of a function, so if someone hands you a (A|B), where A and B have really long type names, you can simply do: match thing { (_|_)::0(a) =&gt; { /* do things with A */ }, (_|_)::1(b) =&gt; { /* do things with B */ } } And I see the Either thing the opposite way: there are a whole bunch of similar but mutually incompatible Either-like types in the ecosystem. If there was a canonical type to refer to, then all these efforts could be pooled towards providing extension traits towards the two-variant anonymous variant type instead of operating on one of the disparate two-variant enums for this purpose. 
I'd love to hear more about this! I just started trying to dig into lie groups/algebras recently. Wikipedia is a... challenging source to try to learn math concepts from, and while I've managed to connect a few dots I'm curious about the new abstractions you might be able to expose with them. Is it fair to say that for quaternions, converting between an angle/axis representation (where the magnitude of the axis encodes the angle) and a quaternion representation of a rotation is equivalent to the idea of using exp/ln to convert between the lie algebra elements and the lie group elements for the group of 3D rotations? I've also stumbled across the \[dual quaternion\]([https://cs.gmu.edu/\~jmlien/teaching/cs451/uploads/Main/dual-quaternion.pdf](https://cs.gmu.edu/~jmlien/teaching/cs451/uploads/Main/dual-quaternion.pdf)) recently - is that a clever way of bundling the lie algebra and lie group together as a single object, or is it a different animal entirely?
That would leak which fields are part of your struct. Named sets would make a whole lot more sense when you have to consider semver.
Then, changing the body of a function could change the fields they access, which is a breaking change. But breaking changes should be reflected in function signatures (so that you see it in documentation)
&gt;then all these efforts could be pooled towards providing extension traits towards those types instead of operating on one of the disparate enums constructed for this purpose Oh, you actually could do blanket impls on `(T|R)` couldn't you. Hm. That would be pretty nice. I think that would also take care of one of my concerns about using this for error types, where `(ParseError | RuntimeError)` isn't *itself* a valid Result/Error unlike how you'd do it with `failure`? It sounds like you'd run into the same problem we have with `[T; N]` arrays, maybe. Your infered type example still reads as maybe too much magic to me, and has a dependency on the element length of the sum(?). Also you can't do type inference in function return types or arguments or enum variants, which is what I was talking about moreso. The problem I've had with crates defining their own error types is that most of the time I *don't want to care*. If I consume a function that returns `Result&lt;u32, FooError&gt;` I can stuff it in my own `enum MyError { Thing(FooError) }` type without once worrying about the actual variants. I'd hardly ever actually use `(_|_)::0(a)` I feel like, anymore than I currently pattern match a `FooError` for `ParseError(e)`, while still having to update my error type via copy-paste whenever libraries I use update instead of having automatic handling.
&gt; have the sum of two types implement the union of the traits that those types implement. You mean *intersection*, right?
This boilerplate where Derived2 has a bar method that just calls Derived1's bar sometimes causes problems with the borrow checker (see [this post](https://www.reddit.com/r/rust/comments/9tbybj/after_nll_interprocedural_conflicts/)) and is just plain unneeded. People can call self.base.bar() just fine!
I would like to see something this, and an important requirement for me is that the eventual approach solves this problem effectively: - [tower_balance::Error](https://tower-rs.github.io/tower/tower_balance/enum.Error.html) - [tower_timeout::Error](https://tower-rs.github.io/tower/tower_timeout/enum.Error.html) - [tower_rate_limit::Error](https://tower-rs.github.io/tower/tower_rate_limit/enum.Error.html) - [tower_reconnect::Error](https://tower-rs.github.io/tower/tower_reconnect/enum.Error.html) etc. Imagine daisy-chaining multiple kinds of middleware and then having to match on all variants... A possible solution here is doing some kind of "type dependency injection": you create your Error type, implement From&lt;E1&gt;, From&lt;E2&gt; for that type and then have the library use it for all fallible operations (this is the idea behind [Future::from_err](https://docs.rs/futures/0.1.25/futures/future/trait.Future.html#method.from_err)). Anonymous variants might provide a clean solution for this problem, but I'd like to highlight another approach that hasn't been mentioned (that I know of): OCaml's [polymorphic variants](https://dev.realworldocaml.org/variants.html#polymorphic-variants). Compared to anonymous variants, these have the advantage that they play nicely with match syntax and have very simple subtyping semantics. A disadvantage compared to standard enums is that it is harder to generate efficient code (muh zero-cost abstractions!)
I just prefer it, and try to use it whenever I feel it is appropriate. If it's all the same, I'd rather not have a licensing discussion here. If you'd like to talk about the issue more, please feel free to open an issue at https://gitlab.com/pwoolcoc/soup/issues/new and I would be more than happy to talk about it more.
Is there a place in the parser where either a type or a value can appear?
That might be fear. If a new language is adopted and he as one of the top dogs doesn't do well anymore because he has trouble getting into the language, they might lay him off in favour of someone else. Just spitballing here, but that's something you have to take into account when trying to push for a new technology.
&gt; I like your idea of lazy query evaluation - was that in FoxPro? Honestly, from my memory, I think foxpro was more immediate, but was insanely fast for the era (and the competitors). I'm not using lazy query evaluation (yet!), first will put a functional, inmutable, immediate processing then start to allow controlled mutation and eventually allow to use a (lazy)query planner, to allow the possibility of composing queries. 
The anonymous variant name syntax and using numbers for the variants very strongly parallels that of tuples, and for good reason. I disagree with this claim: &gt; I'd prefer to be conservative and start with anonymous enums with named variants That's actually less conservative than what I'm suggesting, as there would have to be even more work to figure out the syntax to correspond names to variants, and to match them back up as they happened. And for rationale? Minimalism. We can spend all day discussing the merits of extra features on the types to propose, but at the end of the day, we can't use it in rust unless it's accepted. And proposals like these have been sunk for being too complex before. 
Is this not a function of llvm and its architecture support?
There goes a bit more info implementing support for a new architecture. [This comment](https://www.reddit.com/r/rust/comments/949p0e/_/e3k0421) in a previous thread gives a good summary.
&gt; This is the result by the combined effort of a lot of talented people, in particular working on LLVM upstream which fixed many many bugs in the MIPS and PowerPC backends as well as adding support for the PowerPCSPE sub-target.
Or, using impl trait: ``` fn some_func(something: impl Trait) { something.print_foo(); } ```
Your reason for not making it copy is invalid. A copy type has the exact same performance characteristics as a non-copy type. The only difference is the semantics of the code.
&gt; where Derived2 has a bar method that just calls Derived1's bar Do you mean "where Derived2 has a bar method that just calls Base's bar"?
Thank you.
&gt; This is an opinion, not a fact. I am of my own mind, and I can tell you for certain that the rationale for my decisions in this pre-RFC _is_ minimalism, which in turn if because I actually want to see this feature in Rust. You might disagree with me here that this is the best way, but that's not what you posted. &gt; Minimalism for the sake of minimalism is absurd. Minimalism for the sake of implementation ease is well justified. If you looked at the pre-RFC, you should have seen a codegen example that parses through the tokens for an anonymous variant type in a straight line. I'd like you to come up with a syntax for named arguments that comes anywhere close to having that kind of simple developer complexity. 
I think that something like [enum refinement aliases](https://internals.rust-lang.org/t/pre-rfc-anonymous-variant-types/8707/80) will be a better approach.
&gt; The other potential candidate for Rust support is m68k. There are ongoing efforts to add m68k to both LLVM [2] and Rust [3] and while many people think that supporting modern Linux software on 30 year-old hardware is insane, I think it's actually fun :-). Not to mention, the 68k is still fairly popular in embedded and homebrew realms. The exact areas you would want to be using Rust/C/C++.
How do I correctly implement the following? I have a vec of Strings and I want to prepend each String that starts with '/'. `fn complete(links: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {` `let base_url = "`[`https://www.`](https://www.berlin.de)`example.me";` &amp;#x200B; `links` `.into_iter()` `.map(|s| {` `if s.starts_with("/") {` `String::from(base_url).push_str(s.as_str())` `}` `}).collect()` `}` &amp;#x200B;
Does that limit the functions you can use though? Like, could you call only that Trait functions?
&gt; very strongly parallels that of tuples, and for good reason This is actually the part of the proposal that I'm most uncomfortable with...to me, tuples are very different and the way that this proposal makes anonymous sum types look like tuples makes me uncomfortable. It's somewhat bikeshedding, but I'd prefer to see these anonymous types in code without the parentheses. `Result&lt;(), FirstErrorType | SecondErrorType | ThirdErrorType ...&gt;` just reads so much cleaner to me, though perhaps that's because of my experience with TypeScript. I'd also like to see the the variants named by their type rather than a numeric identifier. I don't see a whole lot of value in having multiple variants with the same type...these are more useful to me as anonymous sum *types* rather than anonymous sum *enums*. A match arm of: `var @ typename =&gt; ...` or `typename { ... }` reads much more cleanly to me, though variants referring to sigil types (`&amp;mut Whatever`) might be a bit weird. Thirdly, rather than limiting the automatically implemented traits, it'd be cool if these anonymous types implemented all in-scope traits that the variants had in common. Typescript does this and it's really useful to be able to call functions that all variants have in common without having to do instanceof checks first.
Very interesting. Thanks for the info!
I like the look of this, how many of the use cases might go away if they just added an 'Either' to the stdlib (I guess i should check if they did) my wishlist would include more r.e. low level mechanics of enums (general purpose ways of using spare bit packing , etc) and a tonne of other things
 fn complete(links: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; { let base_url = "https://www.example.me"; links .into_iter() .map(|s| { if s.starts_with("/") { String::from(base_url).push_str(s.as_str()) } }) .collect() } This does not work because error[E0277]: a collection of type `std::vec::Vec&lt;std::string::String&gt;` cannot be built from an iterator over elements of type `()` So my question: how do I implement what I want to do?\* &amp;#x200B; * I want to prepend each String in a vec that starts with `/` with a certain String.
One thing I noticed is that the documentation for methods on QueryExecutors doesn't seem to be available (at least I couldn't find it). Really looking forward to using this library though. Rust needed something easy to use in this space!
With refined enums aliases (see the link which I've posted) you will be able to define one error type and use refined derivatives in other crates. Because memory layout of aliases will be the same they can be automatically coerced into "wider" aliases, up to the parent error type.
Something like [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=0dcae937dbfc93988d7516678b1e9463)? From what you want I think function should return \`String\` instead of \`Vec&lt;String&gt;\`
In the map closure, your if statement needs an else clause that will return the proper string if it does not start with "/"
Ok, that makes totally sense to me to include the else clause. Changed it to this: links .into_iter() .map(|s| { if s.starts_with("/") { String::from(base_url).push_str(s.as_str()) } else { s } }).collect() But gives this error now: error[E0308]: if and else have incompatible types --&gt; src/lib/link.rs:68:13 | 68 | / if s.starts_with("/") { 69 | | String::from(base_url).push_str(s.as_str()) 70 | | } else { 71 | | s 72 | | } | |_____________^ expected (), found struct `std::string::String` | = note: expected type `()` found type `std::string::String` &amp;#x200B;
That is not quite what I want. I do have a vec of Strings. It may look like this: https://www.example.com /no/base/url https://www.example.com/user/login https://www.example.com /another/bad/url https://www.example.com/auth And I want it to look like this: &amp;#x200B; https://www.example.com https://www.example.com/no/base/url https://www.example.com/user/login https://www.example.com https://www.example.com/another/bad/url https://www.example.com/auth
The problem is that push\_str returns () but you want a string. &amp;#x200B; You could do `format!("{}{}", base_url, s)` or something like like `let mut url = base_url.clone();` `url.push_str(s.as_str());` `url`
`push_str()` returns `()`. It doesn't return the string.
Yay! Fun! However, Rust puts itself at a disadvantage for this particular thing with its philosophy of a lean standard library. For example, bignums are perfectly well supported in Rust via cargo, but unavailable on Kattis, which allows the std only. Contrast this with Python, where bignum is the default integer type. But I look forward to being able to use Rust when I can :)
Just use [`leading_zeros/trailing_zeros`](https://doc.rust-lang.org/std/primitive.u64.html#method.leading_zeros) methods.
https://doc.rust-lang.org/std/primitive.u64.html#method.leading_zeros https://doc.rust-lang.org/std/primitive.u64.html#method.trailing_zeros These can use specialized operations if available on the platform, which should be much faster.
I definitely agree with your point. I'm curious, though -- wouldn't your point also apply to "comparable" languages like C/C++?
Thanks
The sanitizer is correct - you cannot replace atomic accesses with an unsafe cell. An unsafe cell is considered un-synchronised access. You said you "made it safe to read/write" but that's simply not possible as long at is being concurrently read and written - that's the definition of a data race, and hence undefined behaviour.
The order of macro expansion is deterministic: ["Definition and expansion of macros both happen in a single depth-first, lexical-order traversal of a crate’s source."](https://doc.rust-lang.org/book/first-edition/macros.html#scoping-and-macro-importexport) That chapter of the reference seems to refer to `macro_rules`\-style macros, but I would be surprised if the expansion order is different for procedural macros. Procedural macros do seem to be allowed to access files in the build directory: ["Procedural macros run during compilation (...) file access is the same. Because of this, procedural macros have the same security concerns that Cargo's build scripts have."](https://doc.rust-lang.org/reference/procedural-macros.html#procedural-macros) Therefore, it should be possible to have each of your `sym!()` macro invocations append some data to a file in the build directory, then write a macro `sym_db!()` which is invoked after all `sym!()` invocations, reads the file, and uses it to emit whichever global data structure you want. I think you'd also need a build script to initialize/clear the file when compilation begins. I haven't tested any of this, but I feel it should work...?
&gt; It is for the rust ecosystem I figured the rust ecosystem was implied... this is the Rust sub, after all.
Sure. The point is that this isn’t inherent, and could change.
It would be comparable to C I think, but definitely not C++ I'm that regard. The standard library for C++ is way more comprehensive than Rusts. 
Alpha and IA-64 are not going to happen. There is not enough people around to contribute code. There is a reason it was removes.
&gt;the main problems that arised in the discussion were about ambiguities when multiple variants have the same type I just want to address the premise of this post. In my opinion, it doesn't make sense to have an anonymous enum with multiple identical variants. Every variant *must* be unique. It's as simple as that. I definitely didn't stick around long enough in the other thread to see people start discussing ambiguous anonymous types.
I agree - it makes no sense to have an anonymous enum like `(i64 | f64)`. But what about `(S | T)`? When it comes to generics, you often can't prove to the compiler that `S` and `T` can't possibly be the same type, and even when you can it may put a great limit on your code. My (very long) post is trying to address exactly this issue. If the distinction between identical variants in anonymous enums was meaningful everything I said in this post was redundant.
how is i64 | f64 nonsensical or invalid? they're different types, and they're not ambiguous in Rust. Number literals have a default type which prevents the need for ambiguity.
I would prefer the one with anchored paths because I always use absolute paths and the uniform paths could occasionally clash with me.
I don't know about your first question, but on linux, all threads share the pid of the thread that spawned them. Multiprocessing and multithreading are different, all threads share the same memory unlike processes.
Ah, so you want to store containers in the vector? Then see this [code](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=f47b788076f038c96d0e072188854f3e). Note that `MyTrait` bound is applied to the elements of the vector, not to the `MyContainer`.
I think much of this topic have been derailed by people failing to realize that they are talking about two different concepts altogether; Sum types vs. Union Types. Anonymous sum types come with the regularly mentioned ambiguities of matching and conflicts (leading to ideas of using indexes for names). Unions, on the other hand relies on set-theory, with some applicable pre-defined rules: `A|B = B|A` (meaning referral by indicies) and `A|(B|A) = A|B` (answering the question of how to treat the same type appearing twice). Now, I think an important insight in this, is that enums as they exist today, could be seen as unions of new-types for each branch, making them sum-types. Since each branch in an enum is a distinct "type", the values cannot overlap, and for this special case, the union is also a sum. So, for union-types, need to distinguish between branches of same type, this could achieved in the exact same way, by simply new-typing. These properties, in my mind, makes it clear that what we should be aming for is not sum-types, or "anonymous enums", but anonymous union-types. They can do everything an enum can do, and many open questions are automatically answered.
Sorry, I copy-pasted from my examples. I meant `(i64 | i64)`.
Yea, the problem is that `union` is already identified with the untagged, unsafe variant...
Why not have a "match on type" syntax instead of positions? Like, as if (A|B) was an enum { A(A); B(B); } – so match { A(a) =&gt; … }
Looks simple and good! It looks like your documentation has some problems: the associated type of the `Find` and `FindAll` implementations on `Soup` are not `pub` items, it appears that's because the `find` module is not public, while the `SingleQueryExecutor` and the `MultipleQueryExecutor` are both public. 
But the structure `MyContainer` is not generic over `S`, it is only generic over `T`. It's not a case of not being possible, it's more that what you're writing doesn't make sense. For a given `T` there is only a single concrete type, `MyContainer&lt;T&gt;`, so you can't provide multiple `new` functions for different `S` types. It's basically equivalent to saying "A person is guilty if car is red" (a given person = `MyContainer&lt;T&gt;`, guilty = has new method, car is red = trait bounds on `S`). You haven't said *which* car you are referring to, and so the statement doesn't make sense. You could instead say "A person is guilty if *all* cars are red" or "A person is guilty if *any* car is red", or even "A person is guilty if *their* car is red". The first two valid statements cannot be represented in the rust type system because they contain universal or existential qualifiers. The last one *can* be represented in the rust type system one of two ways: 1) By giving `MyContainer` an associated type `S`. 2) By adding an `S` parameter to `MyContainer`, so it becomes `MyContainer&lt;T, S&gt;`. 
So what happens if A and B happen to have the same type at some point? Rust has no way of creating type distinctness conditions, so it'd be a really weird hole to have in the type system. 
Wrong sub, you want /r/playrust
Oh, ok
Thanks for clearing this out :)
Actually handling those cases seems like it would be a major hassle. Matching on `::0`, `::1`, etc instead of actually meaningful names seems very unergonomic and prone to mistakes. And if the author adds or even just reorders the errors of a function, things may break, or even worse, they may still compile but do the wrong thing. If you want to specify on a fine-grained level which functions generate which errors, just define an error enum for each function. There's no reason that they need to be anonymous. If they're anonymous then the implementation may be a little bit simpler, but for the user, things certainly won't be easier. Quite the opposite.
If I understand correctly, the issue with anchored paths is that `self` refers to the current object in methods and the current module elsewhere, so `use self::foo` means something different in a method (and that something happens to be a compile error). Would using a different keyword, e.g. `mod`, instead of `self` allow that disambiguation for anchored paths?
I may be reading the code wrong, but it's possible you've got a logic error, I think the `&lt;=` condition on [iterator.rs L118](https://github.com/paulocsanz/voluntary-servitude/blob/master/src/iterator.rs#L118) can never be false (index won't advance past length unless the node is valid), so the following read may not be as protected as you think it is. I found the code hard to read (personally I prefer `if let` to combinator-heavy style, especially if there are side effects; this pattern of replicating C's comma operator by doing `(a, b).1` is not my favorite). So I'm not saying this is the problem, just that it's something to look at.
&gt;I think the &lt;= condition on iterator.rs L118 can never be false You are right, thank you very much, I don't know how that got past me for this long. I will have to rethink how that works. &gt;I found the code hard to read I guess it's personal choice, rust is really heavy on brackets and only pollutes things.
&gt;I think the &lt;= condition on iterator.rs L118 can never be false The index is increased right before that, so the index will always be current + 1 when this check happens. So if there are 10 elements and we are in the last one the index will be 11, so it won't try to read from the next node (some thread could be writing to it at the same time, so this avoids the race). &gt; I found the code hard to read I guess that's a personal choice, to me rust code is way to heavy on brackets and this simplifies things a lot, I probably went from 2k lines to 1k doing that. Sure it's more dense, but everything is there. But I do agree that since they are not pure it may hide the side-effects.
This is just bog-standard "don't take multiple borrows". Pick one: - don't use a closure, use a match. - test if you need to modify with a simple if, then re-unwrap the field afterwards. - pre-borrow the other fields of `self` you need before the closure, then use those borrows instead. - swap `my_field` into a temporary variable, operate on that, then swap back (although that's not great in this case)
Again I agree, though the original point about BigNum-esque libraries in particular holds true even for C++. :)
What ended up happening with [eliminating the use of `mod foo;`](https://boats.gitlab.io/blog/post/2017-01-04-the-rust-module-system-is-too-confusing/#ideas-for-making-rust-s-module-system-more-habitable) and inferring module structure from the filesystem?
I'm toying with the concept of view structs I stumbled upon in a post here, but I seem to be doing something wrong - whether conceptually or just technically remains to be seen. This works, the compiler sees that I'm borrowing different fields and allows it: ``` struct Foo { i: i64, j: i64, k: i64, } pub fn testing() { let mut f = Foo { i: 1, j: 2, k: 3 }; let i = &amp;mut f.i; let k = &amp;mut f.k; *i = 10; *k = 20; } ``` Things break down when I try to introduce, you know, actual *view structs* (or possibly my flawed understanding of them): ``` struct Foo { i: i64, j: i64, k: i64, } struct ViewA&lt;'a&gt; { i: &amp;'a mut i64, // j: &amp;'a mut i64, // If uncommented, this breaks things even more. } struct ViewB&lt;'a&gt; { k: &amp;'a mut i64, } impl&lt;'a&gt; ViewA&lt;'a&gt; { fn new(f: &amp;'a mut Foo) -&gt; Self { ViewA { i: &amp;mut f.i, //j: &amp;mut f.j, } } } impl&lt;'a&gt; ViewB&lt;'a&gt; { fn new(f: &amp;'a mut Foo) -&gt; Self { ViewB { k: &amp;mut f.k, } } } pub fn testing() { let mut f = Foo { i: 1, j: 2, k: 3 }; let mut a = ViewA::new(&amp;mut f); let mut b = ViewB::new(&amp;mut f); *a.i = 10; *b.k = 20; } ``` The compiler can no longer see that `ViewA` and `ViewB` do not intersect. Clearly I've got something about view structs wrong - but what, and how does one use them properly? 
Kattis *very* rarely requires more than 64 bit integers. Actually, 32 bits is almost always sufficient. 128 bits should suffice for 99.5% of problems. 
You can't use a `new` function. The borrow checker cannot see through function calls, period. You have to do the borrows yourself within the function that you use the views in.
Oh. Thanks for clearing that up.
thanks, I know the docs aren't really there yet, but I'm still iterating on the API so I've been holding off on really focusing on the docs until the API stabilizes a bit
\&gt; The only difference is the semantics of the code. Yes, and the difference is a whole lot of mess! One option to derive Copy. #[derive(Copy,Clone)] struct Vector4&lt;S&gt; { x:S, y:S, z:S, w:S } impl std::ops::Add&lt;Vector4&lt;f64&gt;&gt; for Vector4&lt;f64&gt; { ... } let Vector4&lt;f64&gt; a = blah; let Vector4&lt;f64&gt; b = blah; let Vector4&lt;f64&gt; c = blah; let d : Vector4&lt;f64&gt; = a + (b + c); let e : Vector4&lt;f64&gt; = a + (b + c); That is perfectly reasonable code. With Copy it compiles and produces the correct result. However an f64 is 8 bytes. A Vector4&lt;f64&gt; is 32 bytes. This code *might* be optimized to not actually copy any bytes. Or, in the worst case, it might copy 256 bytes. Without Copy that code doesn't compile. Because the 'let d = ...' line moves a, b, c. To have code that compiles without Copy it'd need to be this: impl&lt;'a, 'b&gt; std::ops::Add&lt;&amp;'a Vector4&lt;f64&gt;&gt; for &amp;'b Vector4&lt;f64&gt; { ... } let (a,b,c) = blah; let d: Vector4&lt;f64&gt; = &amp;a+ &amp;(&amp;b + &amp;c); let e: Vector4&lt;f64&gt; = &amp;a+ &amp;(&amp;b + &amp;c); Obviously this code can be written with or without Copy. But that code is pretty gross. Looking around at various repositories it seems like most vecmath libraries do things the first way. And then, I suppose, praying to the compiler Gods that it make good optimizations.
Take a look at my reply to another comment. [https://www.reddit.com/r/rust/comments/9sanq8/hey\_rustaceans\_got\_an\_easy\_question\_ask\_here/e8yfmqe/](https://www.reddit.com/r/rust/comments/9sanq8/hey_rustaceans_got_an_easy_question_ask_here/e8yfmqe/) I would not agree that &amp;a + &amp;(&amp;b + &amp;c) is more clear than a + b + c; =\[
&gt; Should I just have a function pointer parameter, or is there a way to define some sort of enum so only the windowing functions from the submodule can be used? Well, you *can* define an `enum`. The real question is whether you want to restrict the set of usable windowing functions or not, and whether you want to do so at runtime or compile-time.
It's more clear in terms of algorithmic semantics, but (if that worked) it would be less clear in terms of borrowing semantics. Rust cares about borrowing semantics more than it does about algorithmic semantics, because that's a significant part of why the language exists in the first place. If you want to get comfortable with Rust, you *have* to accept that.
I guess at some point I have to trust potential future users (i.e. future me) to not mess it up. I think I'll just go with the function pointer... and some sternly worded documentation.
Ok, maybe not an easy question. I'm using hyper to make an http server, and I don't want to deal with futures because they're unusable, so how can I get it to just put every request on its own thread and be done with it?
-O is opt-level=2
 // excerpt from append_chain(), some details omitted let _ = self .swap_last(last) .or_else(|| (self.set_first(first), None).1); let _ = self.size.fetch_add(length, Ordering::SeqCst); // excerpt from first_node() let nn = NonZeroUsize::new(self.len()) .and_then(|_| NonNull::new(unsafe { *self.first_node.get() })); Picture this: * thread A: append_chain(): swap_last returns None * thread B: append_chain(): swap_last returns Some(_) * thread B: append_chain(): self.size.fetch_add(..) changes size from 0 to 23 * thread C: first_node(): read length=23 * thread C: first_node(): read first_node &lt;-- nasal demons
In a way, yes. I"m not saying anonymous enum types are useless. I'm saying they're not ideal (certainly not necessary) for use as return types in public APIs. Same for tuples. How many of the crates you use return anonymous tuples from the functions their API?
Making a Genesis game entirely in Rust would be amazing. I've tried to compile Rust to a SNES rom with questionable results, but it wouldn't have run at a decent speed anyway.
I think to a first approximation, all lock-free code has concurrency errors :)
Also no random number generation in `std` (as I have been complaining about for years).
Hey, at least those have random number generation built in, which is a more frequently used case than big nums.
[removed]
It was too controversial.
Job listing for which countries/states/cities tho? Or only 100% remote?
Anything, really. My personal preference, for instance, would be remote, but just getting something going would help.
My point is, it's useless to most of this sub, since they don't live near the opportunity, but sure 100% remote could work, but there would be like 2 jobs per year...
Fixed, thanks!
I use https://github.com/Nemo157/roaring-rs for something similar
HN "Who's hiring" threads just include absolutely everything, can ctrl+f to find relevant opportunities.
Ok, yeah. So, in the comparison to C and C++ it is better to say that Rust loses the competitive edge it gets from Cargo. The point of my example isn't that Rust doesn't have bignum built in, it is that Rust _does_ have excellent support for bignum, and you wouldn't think that it wasn't built-in. But by the rules of Kattis it is not allowed. Contrast this with C++ (I don't have the necessary experience to compare with C), where bignum is _available_, but it is a great hassle. It doesn't feel like it's being taken away when you cannot use it.
If you are into robotics the well-known book from Murray-Li-Sastry is available for free online: https://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf It provides a very good and easy to grasp introduction of lie groups and lie algebras and their applications to robotics. &gt; Is it fair to say that converting between an angle/axis representation (where the magnitude of the axis encodes the angle) and a quaternion representation of a rotation is equivalent to the idea of using exp/ln to convert between the lie algebra elements and the lie group elements for the group of 3D rotations? That's it, yes. &gt; I've also recently stumbled across the idea of using dual quaternions to bundle rotations and translations - is that a clever way of bundling the lie algebra and lie group together as a single object, or is it a different animal entirely? A bundle of rotations and translation in 3D is an element SE(3), so I'd say dual quaternions are merely a parameterization of SE(3). I don't know much about dual quaternions (and am not an expert on lie groups/algebras) so don't take my word for it.
&gt;format!("{}{}", base\_url, s) That's it! Does what I needed. Thank you! :)
lookup tables can be useful to get better performance (cf https://github.com/Geal/parser_benchmarks/blob/2900f0276c7999504d25eb4904c58a3ca287fc9c/http/nom-optimized/src/main.rs#L41-L63 ), but the first step would be to remove unneeded allocations. In the [header parser](https://gitlab.com/rubdos/embroidery-formats-rs/blob/master/dst/src/decode.rs#L103-110), `many0` could be replaced with `fold_many0` to accumulate fields in the hashmap instead of allocating a Vec that's then collected.
Never say never :-). We could still carry the Alpha and ia64 LLVM backends as local patches in Debian.
Up until an hour ago I was in mildly in favor of anchored paths; mainly because of OCD. However, after reading the [arguments laid out in the paper linked in the PR](https://paper.dropbox.com/doc/Lang-team-stance-on-modules-cvcNJv9qnNUeWXMcvLGzs) I now think uniform paths might be better, and offer more long-term ergonomic prospects. I would recommend everyone to read that as well when considering the implications of both approaches. 
Wrong sub! This sub is about the rust programming language
The m68k architecture has even seen modern development on FPGAs. The Apollo core developed for Amiga acceleration is dubbed the "68080" as though a continuation of Motorola's last CPU in the line, the 68060. Truly a great candidate IMO
If you want select / epoll / etc try mio. Alternatively, tokio (built on top of mio) adds some more abstraction over it and may be more ergonomic. 
I quite like that rustfmt can sort use statements, is there a proposal to get it to read the list of external crates so that it can disambiguate local and crate use statements?
Depends on your definition of "maturity". In Java for example, an old library often means an outdated/obsolete library. The higher a lib's age, the more technical debt it accumulates, so many people sigh with relief when a complete rewrite is done. Or switch to a new lib that strives to replace the old one, by a new author. But then is it mature anymore, since it's as good as new?
Fair point. How about measuring it in terms of comprehensiveness and reliability?
Initially, I'd see what's popular and look at its docs. Then play with a prototype to see what I can do with it. How do you ensure a lib is reliable? Well, use it, run some tests. That applies to any libraries in any language. The fact that it's a popular lib with the fact that your tests run give a certain probability of it being reliable. But all of that is true for libraries in any language: old or new, Rust or not. As to what libs are currently available in Rust, take a look at https://crates.io. Personally, I've been very impressed with the collection, for a relatively new language.
Using my own definition of maturity, I'd say it's pretty mature. By comparison to another new language, Nim, the Rust ecosystem is gigantic. Most libraries are updated rather often, with things such as the nursery that make sure no big libraries go unmaintained. Even when compared to the C# world, which has been around for a long time and heavily pushed by Microsoft, i think the Rust ecosystem is better. For instance, nothing in C# gets close to what Clap can offer in terms of CLI. C# has some big libraries, but the average quality is far behind what crates.io has to offer. The only thing that, on top of my mind, tops Rust in terms of choice and quantity, is NPM. But that's not exactly a good thing. 
A trend I notice that needs improvement: Sparse documentation. There are a number of popular, robust packages that have extensive API descriptions on their docs page, but no descriptions of how to use the package, and 1 or 2 examples that cover a small part of the API. Examples: Vulkano, Cgmath, yew.
You may want to checkout the Relacy Race Detection tool, a coworker recently ran it on our lock-free data-structures and it highlighted a few issues. Unfortunately, it seems to be C++ only, but if your core algorithm is small enough porting it faithfully to C++ should not be too much of an issue and the extra level of scrutiny is quite valuable.
Same here; I wish a variant without any drawback existed, but since nobody seems to have been able to figure that out, I am happy with improving the current situation.
The end of this year! That's my hope and thinking. 
"carry". There is clang-3.7 in Debian that is compiled for alpha in ports. Also for some reasons clang-3.7 package is only available on alpha in unstable, supposedly because newer clangs do not build so it is kept just to have some amount of c/c++1y support available. Debian doesn't even show PTS for clang-3.7 anymore, it only lives in ports. Clang is from September 2015. Not that old actually, and pretty decent. But in meantime we had 3.8, 3.9, 4.0, 5.0, 6.0, and a month ago 7.0. If it is alive in newer llvm patches, I can help with porting LDC.
Sometimes it helps to add an associated type to a trait. I don´t know if this will help here. [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=83704c72bba929d8b577707cc5110e8c](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=83704c72bba929d8b577707cc5110e8c) &amp;#x200B;
Really? only NPM? you can say a lot about Java, but you cannot say its ecosystem is not rich and mature
In Java there are tons of great mature and updated libraries. Some of them are even supported by big companies like Google, Red Hat, etc. You can say lot of things about Java, but its ecosystem is amazing.
Sorry, I should have made clearer the fact that I only talked about the languages I'm familiar with. I knew Java was big but I didn't *how* big, so I didn't mention it. 
In your crate, you can create empty struct definitions for each type of windowing function you might do. (Or not empty if it needs special parameters.) Then, create a trait `WindowFunction`, or something like that. It has one function, doFunction, or something like that. Implement what functions you want for each empty struct. Then, when you call transform, you can pass in a struct with type T, where T is `WindowFunction`. This is the way polymorphism is in Rust.
This website had potential but now it seems almost misleading: https://rustjobs.rs/. "Rust Jobs There are no open rust jobs anywhere in the world. That doesn't sounds right... post a job." That said, it does list companies using rust, but that may also be outdated information. It's cool that the author has provided a link to add your own listing. 
&gt; There are a number of popular, robust packages that have extensive API descriptions I partially blame the tooling for this. `cargo fmt` does not support stand-alone Markdown files some many people just write an example or two for the README and the crate root site but do not add more tutorials and usage examples to the docs.
I don't know about this competition site, but if it's anything like topcoder or programming Olympiad-style challenges, it's very, very unlikely to matter. Might as well pick the option that's ever so less likely to run into compilation bugs.
Interesting, I feel the exact opposite. We use JS, TS and Rust at my day job, and to me Rust is light years ahead in terms of docs. Between Rustdoc, the examples folder lots of crates have ([yew has about 20](https://github.com/DenisKolodin/yew/tree/master/examples) different example projects), and dedicated websites for some projects ([Tokio](https://tokio.rs/), [Hyper](https://hyper.rs), looks like [Vulkano](http://vulkano.rs) has one too), I feel like we have lots of resources available.
I guess when he said "in terms of choice and quantity" he doesn't only mean in quantity, otherwise there are 12 registries in the web you reference that have choice in terms of quantity.
Java is huge, but very isolated. In the JVM you cannot easilly consume libraries from other ecosystems and others cannot use yours. At least until Panama Project is finished
Anchored paths seem more explicit, less magic, and less likely for me to lookup the rules when going back and forth between projects. Seems pretty closer to the filesystem path abstraction (/) which although it looks not as nice, is more familiar.
I think that the floor for rust's coverage in terms of documentation is higher because of those features you mentioned, however I also identify somewhat with the prior commentor's perspective. Sometimes I think that rustdoc can be an afterthought especially to experienced devs who may be of the mind that "it's good enough" which may be true for some subset of the community while others struggle. 
If you look through the Vulkano website, you'll find it only deals with a 2d example. The only place I've found info on how you'd use it for 3d is the teapot example. Didn't see those yew examples; that should help.
Is there a particular project you're thinking of writing? That'd make the discussion more concrete. Rust has great libraries for some things and nothing at all for other things. What libraries do you need?
I would definitely make it a macro. All of the intermediate values are going to be very inefficient, and there's no way the compiler could ever optimize that out. Allow references so simple equations like a + b can be written &amp;a + &amp;b, and anything more than single operation can be bigint!(a + b ** 2 - sqrt(c) ^ (d + e)). Then you can control the macro to be as efficient as you want
I'm planning on developing proficiency of Rust/C++ first and I don't have anything specific or serious in mind right now (studying a CS degree at the moment), but I just wanted to see if the immaturity of the Rust libraries could potentially be a barrier later on if I'm tackling more advanced projects. Judging from the comments, it seems like it probably won't be the case :) 
Well I would need to change countries for that but sure.
Libraries can be ordered on a few axes, for example full-featuredness, safety, and ergonomics. Typically "maturity" means a mix of full-featuredness and safety. For reference, the Python library ecosystem is quite full-featured, relatively unsafe, and notoriously ergonomic. By account of being younger, the Rust library ecosystem has more feature-shaped holes. Existing features are comparably ergonomic to Python (some better, some worse). This is an extreme simplification. In practice the three axes I mention are not decomposable, and to the extent they are there are problem spaces where the exact opposite of the appraisal of the two languages above is true. But I feel like it should be good enough to decide on which language to learn first, at least from a library perspective. Looking away from libraries: C++ is a shit show for beginners. Rust is intricate, but at least it has extraordinary learning resources and tooling.
I live in Brazil unless you have a opportunity that I can travel for it's only noise. Not everybody lives in the US
I thought docs was getting rewritten to better support this?