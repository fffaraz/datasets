&gt;This commit adds a lint that can warn when the largest variant in an enum is more than 3 times larger than the second-largest variant. That's not robust. What if you have 2 giant variants and several small ones? Better way is to test the max fold-change (ratio of largest/smallest).
&gt; Anyway, on to the question. Several times now I've run into this same problem using RefCell. I'd like to call a method on a struct that has this RefCell as a field, and have this method return a reference into the data inside the RefCell (suppose the RefCell wraps a Vec and I want a slice into it): Closures are an alternative to returning a slice. use std::cell::RefCell; use std::rc::Rc; struct Foo{ a: Rc&lt;RefCell&lt;Vec&lt;int&gt;&gt;&gt;} impl Foo { fn for_slice(&amp;self, len: uint, func: |&amp;int|) { for e in self.a.borrow().slice(0,len).iter() { func(e); } } fn for_mut_slice(&amp;self, len: uint, func: |&amp;mut int|) { for e in self.a.borrow_mut().mut_slice(0,len).mut_iter() { func(e); } } } fn main() { let rc = Rc::new(RefCell::new(vec!(1,2,3,4,5))); let foo = Foo { a: rc }; foo.for_mut_slice(2, |e| *e = 0); let mut numbers = Vec::new(); foo.for_slice(3, |e| numbers.push(*e)); println!("{}", numbers); } PS: In this example the closure takes vector elements because I was a bit distracted. If you pass them vector slices, they should be able to do ~~everything~~ most things you had planned to do with the slice returned from the function.
The first solution looks pretty nice, I definitely hadn't thought of it. That might be the way to go.
Doing lots of hash lookups in this inner tight environment would be too expensive. Storing the structure in a vec and then keying on the index means that any time I restructure the tree I need to manually go around and update all of those index keys, which sounds like it could turn into trouble. Also we will often be copying subtrees and passing them around, so that would require copying part of the vector and then rearranging the keys to point to the new rearranged vector. For something that was immutable most of the time, or built up and then only trivially changed, this might be a good solution.
If this was Java or Go, you would just use references and not worry about it, and it would be loads more efficient and safe than simulating references with keys and hashmap lookups and doing manual GC like this. This just makes everything into a runtime failure to check for, with no safety analysis support from the language. Effectively all those keys are really just slow/inefficient weak references. If this really is the best pattern for certain problems, then it should at least be formalised into a Rust library type so that the safety assumptions can be better analysed.
What we have in Rust is regular though
Patches welcome. Tweaking the heurstic is easy.
You are lacking context here. &gt; Without rock-solid library implementations, programmers who want to do any kind of statistics are forced to go out and find usable numerical code on the web — or worse, attempt to write their own. Given the amount of specialized knowledge required [...] Thus, I would read this as Joe Random Programmer should not attempt it; however I would argue that it would perfectly suitable that a language implementation DO re-implement it (if needed). Many more eyeballs, ...
Closures are great when you need to deal with a single reference, but when you start wanting to get 2 or 3 references at once for a computation you soon run into an equivalent of "Callback Hell".
&gt; there is no guarantee that a Monad trait will work nicely due to Rust’s affine types and various low-level details. I'm interested to know the details here, if anyone has written them up.
you could make a different way of storing a string, e.g. pure 8bit ascii, perhaps a wrapper for zero terminated strings, whatever.
I've been thinking about how to design a VR-oriented, highly parallel game engine in Rust for over a year now, and that post talks about much of the same things I've been thinking about. (And more, as I'm mostly lacking actual technical background) Snowmew might be what I've been looking for. At least, it ought to give me a few good ideas ;) Now if only I could get it to build... 
From a performance standpoint, I would use byte iterators for strings, most regular expressions would benefit from this (and those that don't, simply implement utf8 decoding in the VM instead of a constant cost).
(I'll assume that you meant `fold` instead of `collect`. If I'm mistaken, then please expand a bit, because I can't see how `collect` fits in here :)) Yes, it can be written as a `fold` pretty easily, but I chose to focus on showing how slices work, and thus wrote this in a manner that (I assumed) would be more familiar to a C++ programmer
Yes, I meant `fold`. Wow, like half of my reddit comments have been straight-up wrong lately. :(
I'm very excited to get closures that can capture by value. :D
Rust doesn't have the iterator traits that C++ have at the moment. We have `Iterator` and `DoubleEndedIterator` basically. The trait named `RandomAccessIterator` seems to be useless at the moment. In C++, iterators generalize pointers, while in Rust they really don't do that.
Ideally the chars iterator should be fast enough on ascii input, but it's not written that way today
I appreciate that, and I'm sure no offense was intended. BTW, I've been in the compiler biz for 30 years, and I've always enjoyed hanging out with my competitors. If any Rust compiler guys are in Seattle, drop me a line and we'll go out for beers. Back in the 80's, the Zortech compiler team always challenged the Borland compiler guys to video game duels :-) which were a highlight of the conferences we attended.
Yeah, if you do everything right in your exceptions-using code, it's safe. But it's also easy to get wrong, and Rust is interested in not letting you get things wrong.
a) what happens when the closure gets created b) what happens when the closure gets called
The application we're primarily writing this for is the control of intelligent lights. So, the device tree represents every fixture you have control over. Moreover, arranging this as a tree means it is easy to create higher-level abstractions over groups of fixtures, such as assemblies, different areas, etc. The device tree will be built up in real-time as the user adds or removes fixtures from the patch list. Additionally, various entities in the program will have copies of the tree or sub-trees, and it may make sense for those entities to be able to rearrange their local versions of the tree. So, we really do need the tree structure to be mutable.
Fair enough, but then what should the groups return? I recognize allowing different string implementations could be useful, but whatever RE implementation we end up with needs to be able to * iterate over the (for lack of a better word) string * compare an element (or character class) against a part of the pattern * return a slice (for group references) As long as those operations are defined, a RE implementation should be feasible. I am unsure how to extend the current implementation to allow this.
A closure has an environment. It's basically a struct that stores all of its captured members. For (a), it specifies the types of those. Say my closure captures two variables, `a: int`, `b: Foo` If they're by value, then they're just moved into that closure. It would look something like struct SomeClosureEnvironment { a: int, b: Foo } Now, if they were captured by reference (or mutable reference), they'd be a `a: &amp;int, b: &amp;Foo` in that same struct. Now that's just an environment: The other part of a closure is what happens when you call it. With this new setup, there's a trait implemented. The reciever mode is how `self` gets passed: impl Fn for SomeClosureEnvironment { fn call(&amp;mut self, param1: int) { self.a = self.b.fooable() + int } } If you had a different reciever mode, you'd have `self` or `&amp;self`. Eg, if you had `self`, then the closure environment would get moved into the `call`, so you can only use it once -- That's why the trait is FnOnce. This is similar to `proc()` today.
I THINK he means something like creating an alphabet of events based on some parsing of some log files, then being able to query it for "events of type A that happen after 5 or more iterations of event B, and terminated by an event C". Assuming you could translate a collection of events to searchable tokens, this would be trivial to find using something like regexes.
A monad essentially needs a function bind `(M&lt;A&gt;, |A| -&gt; M&lt;B&gt;) -&gt; M&lt;B&gt;`. Different `M`s need/want different types of closures, e.g. `Vec` needs a closure that can be called multiple times, but `Option` would prefer a closure that can only be called once, and then a `Future` wants a `Send` closure... Therefore, a generic `Monad` class would be forced to take sendable, multiple-callable closures (which we currently don't have), making some things impossible, e.g., capturing by reference, and moving out nicely. Languages like Haskell don't meet this problem (in the common case), since everything has a uniform, sharable representation, and there's no concept of "moving out".
That sounds suspiciously like a solution in search of a problem.
Having dealt with lots of log parsing, I think there are some niches for this, but yeah, niche it seems (If it was common, we'd know exactly what they mean, I suppose).
Hm. Thanks!
I'm looking at getting a conference room at UCLA, but I'm not sure that it is feasible price-wise.
I was just thinking we could use a Rust meetup in NY, I'll try and attend.
Feel free to ping me on IRC if you have having trouble. I am in #rust-gamedev most of the time.
That's how I've been doing it. You can also view it in [the fork](https://github.com/nikomatsakis/rfcs/blob/closures/active/0000-closures.md), but I haven't been able to find a convenient link to it from the PR. I guess the advantage of reading the diff is that you also get to see inline comments. But I suppose that may be a disadvantage too, depending on how you like to digest things.
I usually use "View" instead of "Rendered"
A question to the better informed: is `mem::uninitialized()` equivalent to C's `alloca` + a type-inferred size?
It's a no-op, so it tricks the compiler into allowing you to have an uninitialized variable. It's not the same thing as the non-standard `alloca` function.
Ah, I see, so the memory is still statically allocated then. Thanks!
Oooo. Glorious! My hero! There's also a "rendered" view. Weird. I've been completely blind to that part of Github's interface.
Nvm my last reply. /u/dbaupp saves the day: http://www.reddit.com/r/rust/comments/27wqrr/rfc_unboxed_closures/ci5hfz1
 &gt; I thought Rust is a deeply practical language. The language generally being practical doesn't stop us from discussing less practical (but interesting &amp; generally related) things.
True that. Also often theoretical insights can lead to new levels of practicality. A few years ago, what rust does now would have been firmly in the realm of "research" and nobody would have payed attention.
It's mostly a philosophical thing: * Exceptions have performance overhead by inhibiting optimizations and requiring allocations, making them not useful in e.g. kernel context. We want the standard library to be useful in kernel contexts. * Rust enforces memory safety for exceptions, but it doesn't enforce that your catch-handling code is correct; i.e. that your exception actually rewound the state of the program to a "known-good" state. Rust's opinion is that you should use tasks for this sort of thing, because tasks have more isolated heaps. It's worth noting that you can technically catch failure in Rust, via unsafe code. It's just not something the standard library supports, for philosophical reasons.
&gt; -ffast-math is not something Rust would even consider, you should probably turn it off for a fair comparison Why not?
This is very easy to be non-failsafe, e.g. let x: [Box&lt;int&gt;, .. 10] = array_of_clones![fail!(), .. 10]; will cause destructors (in this case, `free`) to be run on uninitialised memory, likely leading to crashes (in the best case) or heap corruption and security holes. Uses of this macro are safe only if it is ensured that either the initialisation expression either never fails or the type in the array doesn't have a destructor. (Btw, you can use `for p in arr.mut_iter() { std::ptr::write(p, $e); }` instead of the `range`, not that it makes much difference in this case.)
Coloft looks like a nice venue. Especially since it comes with projection equipment and such. I'm still waiting to get a quote back from UCLA booking services, but Santa Monica is probably a better location than Westwood for the majority of people.
hmm,ok perhaps it would be waiting for associated types or type deduction then, to have generic answers to all those; the 'object supporting string-like operations' would have to have an associated type for subsequences within it? (usually a &amp;str for String, and so on..) maybe a 'subsequence' could be something generalised supporting a slice-like interface, it could be a reference to the original object along with start:end indices perhaps. 
Good point! I've made a quick test on the playpen and it did segfault with your example. If I change from `mem::uninitialized` to `mem::zeroed` however, it aborted as one would expect (no segfault). Is that still potentially unsafe?
Yes, it is still unsafe. Currently it will mostly work, completely zeroed things are safe to run destructors on. This is how moving out of a variable with a destructor is achieved: it is zeroed to cancel destruction. This zeroing is an annoying requirement (code isn't as efficient as it could be): [#5016](https://github.com/mozilla/rust/issues/5016) removes it by precisely tracking what needs destruction and running exactly those destructors, meaning zeroed things are no longer safe to destroy. (The compiler would assume that the array needs clean-up and run the destructors, leading to pain.)
Yes, this is basically what I posited. Note that the subsequence cannot be reduced to a single pointer, because groups have a length (or pointer to end) too. It may make sense to allow regexps over ascii strings for space or time reasons. UTF-8 usually carries a penalty in both space and time.
You're cheating, you're using TypeOf ! ;) You can still do it without type of, see [here](https://blogs.janestreet.com/a-universal-type/) and [there](https://blogs.janestreet.com/rethinking-univ/). There is even a [dead simple implementation with mutable references](https://github.com/mjambon/mixtbl). (Sorry, can't give you a Rust implem). Granted, the interface is less convenient.
Now I'm curious, how does Rust handle something like `let x: [Box&lt;int&gt;, ..4] = [fail!(), fail!(), fail!(), fail!()];` today?
I would assume (since I can't think of another possibility) that that is the same as let a = fail!(); let b = fail!(); let c = fail!(); let d = fail!(); let x: [Box&lt;int&gt;, .. 4] = [a, b, c, d]; but I'm not really sure.
The example that caused me to write it is HTTP middleware, where the middlewares will often wish to store something about the request. You could go injecting new headers to contain that data (in Teepee’s header representation scheme that would even allow a completely strongly typed interface), but that approach is a bit icky, and storing it separately will allow for higher performance. (This `AnyMap` is already faster than Teepee’s headers and can still see some performance optimisation.) Here’s an example of such a thing in Goji, a Go web framework: https://godoc.org/github.com/zenazn/goji/web#C
This OP seems like a really nice guy
he is idd a fking nice guy
I don't know nearly enough Rust to say anything about it, but in some other languages with rich type systems (Ocaml and haskell, namely), TypeOf is either not possible or restricted, so you usually avoid to rely on it. Also, I was joking. :p
This is an interesting question for sure. I wonder if it could be resolved by just choosing `fn join&lt;M&gt;(M&lt;M&lt;A&gt;&gt;) -&gt; M&lt;A&gt;` as the primitive instead, and defining `bind` (or multiple different `bind`s) in terms of it. I suspect the same issue also manifests for `fmap` though?
&gt; I suspect the same issue also manifests for fmap though? Yeah, I would think so (and, coincidentally, I accidentally gave `fmap`'s signature in my original comment anyway).
Following a hint from eddyb, I replaced the SipHasher with one that just passes through the 64-bitTypeId to the u64 that makes up the hash. Outcome: &gt;3× performance boost in the HashMap lookup. ☺
Does it lead to memory unsafety? &gt; a feature gate Feature gates are essentially for language features that are unstable/subject to change, not things that just need to be used carefully. (Maybe this will change in future, *shrug*.)
In addition to this excellent list, I'd add the Rust ~~compiler~~ standard libraries. It isn't helpful when you are an absolute beginner, but once you cross a certain threshold of familiarity with Rust it helps *a lot*. There are times where the reference docs are sparse and I'm not really sure how to use a method, so I'll search the Rust ~~compiler~~ library codebase for the method and see how it's being used "in the wild". It's also nice to skim through various methods/objects to see how they are implemented under the covers.
man, rust by example should be listed on the main rust docs page
It honestly really should. I was looking for a good example of how arrays and slices worked. 
Maybe a [Javascript Virtual Machine](http://tombebbington.github.io/js.rs/js/index.html)?
&gt; Rust for Rubyists (that you mention). NB. you don't need to be a Rubyist to get value out of it. I was a bit turned off by the early chapter on testing (chapter 3) followed by chapter 4, which was testing intertwined with learning basic constructs of the language. I wanted to learn the language more than a I wanted a lesson in TDD methodology - "Now that we have a failing test, let’s make it pass:[...] TDD means do the simplest thing!". 
I would be interested. Not promising I would go, but I don't have a lot else to do.
Well that's pretty a messed up idea. I don't think we want a mascot to be suffering a disease. I've proposed in the past we have a Rustacean as a mascot: An Iron/rusting crustacean. Like a lobster. 
&gt; I propose a man bent over backwards - exhibiting the classic symptoms of Tetanus (as seen in this picture). Perhaps are more cartoonish version would suffice, maybe with a neutral or smiling face instead to make it seem more mascotty. Assuming this isn't some kind of joke, no, that is pretty horrible image. I don't see the utility of a mascot. The logo is enough as visual identifier in circumstances where that is desirable. There is no need either to make Rust appeal more to kids.
I appreciate your enthusiasm, but this is a bit dark for my taste.
For a programming language to reach success these days there has to be considerable work put into marketing (or monopoly). Lacking monopoly, I see branding as a venue for Rust to become relevant to mainstream programming - we should learn from Firefox's combination of both technical excellence (leaving Internet Explorer in the dust) and market competence. Look at Java. At Java dev conferences, you see a person dressed as the mascot, and the mascot painted on coffee mugs etc. It promotes morale even in the grungy depths of the enterprise community.
Yeah I guess like that hadoop elephant.
Actaully I was thinking more of the Linux penguin or BSD demon, I don't know why they didn't come to mind immediately. The promote a certain patriotism within their communities and I contend that it helps strengthen their enthusiasm.
One way, while keeping the overall structure, is to change `~"..."` to `"...".into_string()`. I think that's it.
Not quite: println also takes a &amp;str so you need an .as_slice() use std::io::println; fn is_three(num: int) -&gt; bool { num % 3 == 0 } fn is_five(num: int) -&gt; bool { num % 5 == 0 } fn is_fifteen(num: int) -&gt; bool { num % 15 == 0 } fn main() { for num in range(1, 101) { println( (if is_fifteen(num) { String::from_str("FizzBuzz") } else if is_three(num) { String::from_str("Fizz") } else if is_five(num) { String::from_str("Buzz") } else { num.to_str() }).as_slice() ); } } 
Nice try Zoidberg!
This is a brilliant proposal that should be seriously considered. May I also suggest the following tagline: *Rust: marginally less painful than tetanus ^[citation ^needed]* Oh btw, I am, in fact, subscribed to /r/programmingcirclejerk. Don't make posts here just so that you have material to submit to it.
It doesn't have to be dark. See my edit.
I think this is a common problem for people new to the language. People don't expect that there are two types of string... Maybe I can shed a little bit of light upon this issue. A string literal has the type `&amp;str`. This means that it is a string slice (so "FizzBUzz" has the type `&amp;str`). A string generated with the `to_str` method has the type `String` (so `num.to_str()` has the type `String`). If I understand correctly, this difference exists because a `String` is allocated at runtime and so comes with extra overhead (which you can generally ignore). However, you can use a `String` as a `&amp;str` by calling the `as_slice()` function, which has no overhead. This can be useful if you want to pass a `String` to println (which takes a `&amp;str` as argument). I hope I don't have confused you too much...
You say you don't have any C++ knowledge, so perhaps you're more familiar with dynamic languages? If so, then let's show off some closures rather than just using boring basic functions: fn main() { let is_three = |num: int| num % 3 == 0; let is_five = |num: int| num % 5 == 0; let is_fifteen = |num: int| num % 15 == 0; for num in range(1, 101) { println!("{:s}", if is_fifteen(num) { "Fizzbuzz".to_str() } else if is_three(num) { "Fizz".to_str() } else if is_five(num) { "Buzz".to_str() } else { num.to_str() } ); } } The reason for needing `"blah".to_str()` is because string literals are allocated in what's called static memory, whereas `num.to_str()` creates a string that's allocated on the heap. Because the return value of that `if` statement has to have the same type in every branch, we have to copy that static string literal onto the heap to appease the compiler.
&gt; But no, quote_item! Returns an Option&lt;@Item&gt;, which is immutable, so pushing things to attrs is not possible, of course. Hmm. Mutability is inherited. Could you try using `let mut my_struct = ...` instead? FYI, this was done for a `quickcheck` PR that never made it in, except it uses `#[test]` instead of `#[deriving(...)]`. But same concept. Here's the code: https://github.com/huonw/rust/blob/quickcheck/src/libquickcheck_macros/lib.rs#L78 --- Notice that `attrs` is mutable! I am curious why `quote_item!` isn't working. Not sure about that one.
It is worth noting that it would be preferrable to use `num.to_str().to_slice()` (to avoid allocating), but it is not possible because it "does not live long enough". { num.to_str().as_slice() ^^^^^^^^ The string is destroyed when the scope is leaved, so the slice (which points to the string) would be invalid. That is why the compiler will yell at you. }
BONUS ROUND: Using `match` expressions for fun and profit: fn main() { for num in range(1, 101) { println!("{:s}", match num % 15 { 3 | 6 | 9 | 12 =&gt; "Fizz".to_str(), 5 | 10 =&gt; "Buzz".to_str(), 0 =&gt; "FizzBuzz".to_str(), _ =&gt; num.to_str() } ); } }
Nah, if we really cared to avoid allocation we would forgo returning the value at all and just shove the println into the branches. :P (And also we'd probably be using a BufferedWriter rather than println, but w/e. Premature optimization does not apply to FizzBuzz!)
Reminds me of Uncle Rhabdo, the CrossFit mascot.
Glad to hear it helped :D. Sadly, I haven't figured a solution for reducing the duplication between the `u64` hash and `TypeId` key, other than making `RawTable` generic over the hash type and/or getting access to the hash directly (and using it to store the `TypeId`).
Also using the `println!` macro instead of `println` would work
BONUS BONUS ROUND: Printing inside the `match` to avoid allocations for speed and memory: fn main() { for num in range(1, 101) { match num % 15 { 3 | 6 | 9 | 12 =&gt; println!("Fizz"), 5 | 10 =&gt; println!("Buzz"), 0 =&gt; println!("FizzBuzz"), _ =&gt; println!("{}", num) } } }
just unroll the loop at compile time and do the buffering into a string literal!~
BONUS BONUS BONUS BONUS ROUND: I'VE LOST ALL CONTROL OF MY LIFE fn main() { std::io::stdout().write(&amp;[0x31u8, 0x0a, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x37, 0x0a, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x31, 0x31, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x31, 0x33, 0x0a, 0x31, 0x34, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x31, 0x36, 0x0a, 0x31, 0x37, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x31, 0x39, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x32, 0x32, 0x0a, 0x32, 0x33, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x32, 0x36, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x32, 0x38, 0x0a, 0x32, 0x39, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x33, 0x31, 0x0a, 0x33, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x33, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x33, 0x37, 0x0a, 0x33, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x34, 0x31, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x34, 0x33, 0x0a, 0x34, 0x34, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x34, 0x36, 0x0a, 0x34, 0x37, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x34, 0x39, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x35, 0x32, 0x0a, 0x35, 0x33, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x35, 0x36, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x35, 0x38, 0x0a, 0x35, 0x39, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x36, 0x31, 0x0a, 0x36, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x36, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x36, 0x37, 0x0a, 0x36, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x37, 0x31, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x37, 0x33, 0x0a, 0x37, 0x34, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x37, 0x36, 0x0a, 0x37, 0x37, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x37, 0x39, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x38, 0x32, 0x0a, 0x38, 0x33, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x38, 0x36, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x38, 0x38, 0x0a, 0x38, 0x39, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x39, 0x31, 0x0a, 0x39, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x39, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x39, 0x37, 0x0a, 0x39, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a]); }
I was actually chatting with Chris about this last night on IRC. The problem I was trying to tackle that prompted him to come up with this solution was creating a typesafe scheme for middleware to expose new, arbitrary, functionality to later middleware. For instance, a body parsing middleware might want to expose a parsed body or a send-file middleware would want to expose a new API. We can't just throw these things on a normal struct because then we are limiting the APIs that middleware can create. A structure like this one, which allows instances of middleware to store an arbitrary structure and expose that to later middleware and controllers, solves that problem extremely elegantly while also being performant and typesafe. For context, I'm working with a few other programmers on a higher level web framework called iron (github iron/iron). It's extremely early days, but hopefully things will be ready in a few weeks.
As someone who came from a dynamic language background myself, I can confirm that I was entirely unprepared for how much more complex string handling is in systems programming languages (not just Rust).
A long time ago I managed to sneak a patch into the stdlib that overloaded `+` on Options, *specifically* to make the following FizzBuzz implementation possible (WARNING: OBSOLETE CODE AHEAD): https://gist.github.com/bstrie/4084816 Fortunately, we eventually removed that overloading and we're all better off, despite my shenanigans. :)
WHATHAVEWEDONE?! 
&gt; Hmm. Mutability is inherited. Could you try using let mut my_struct = ... instead? Not through `@`: it is "owned" by the task, and the `@` essentially just acts like a (fancy) `&amp;` shared reference. &gt; Notice that attrs is mutable! That's because the `Vec` was copied out, to create an independent value which does inherit mutability (doesn't have a `@`, `&amp;` or `Rc`, etc., in the way).
*Updated*: the original code above should work once [#14860](https://github.com/mozilla/rust/pull/14860) lands. You should be able to do something like let new_attrs = my_struct.attrs.clone().append(/* new attribute */); @ast::Item { attrs: new_attrs, .. my_struct } (The second `my_struct` may need a `clone` itself too.) This uses a "functional record update" which will create a new struct value from the old one (the one after `..`) with the listed fields replaced. Another choice would be coping the item out of the `@`: let mut my_struct: ast::Item = (*my_struct).clone(); my_struct.attrs.push(...); @my_struct // return value (All this copying is sad, but unavoidable with the old/outdated design of the AST.)
stdout() is kinda slow, you should just invoke the write system call via an asm! block
This is possibly the only way in which Rust for Rubyists is really a Ruby book: Rubyists consider TDD essential. I've had an equal number of "oh thanks, I wondered about testing" comments. Can't please everyone. :/
&gt; there feels to me at least to be a massive need for documentation/guides. There is. It will get better. Can't say more than 'trust me' right now, though.
Great! I'd love to have you.
I surrender! I just write Javascript and PHP for a living. ASM is out of my league!
There's a readability hazard in the above: Rust now has two string types - "String" and "str" so num.to_str() returning a "String" is a really confusing method name. What was the rational to keep the str type instead of just using something like [u8] ?? 
Ah! Thanks for the clarification. Do you happen to know why `quote_item!` won't work?
I don't know, this whole language change has made me go from actively using the language to waiting until it is 1.0. It would be nice if people wrote the build number of their Rust on source code examples.
Based on mletterle's suggestion to rename `trusted` to `trustme`, I think I'm going to make a macro to wrap my unsafe code called either `look_ma_no_hands!` or `hey_guys_watch_this!`
Yes, it returns a `@Item` (i.e. the `@` is killing it).
Errm, I meant writing the `#[deriving(...)]` with `quote_item!`: let my_struct = quote_item!(context, #[deriving(PartialEq)] pub struct $struct_name { // contents omitted, not relevant } ); OP says this returns `None`?
What a nice example of bikeshedding. IMO unsafe is quite descriptive and also used in other languages for a similar purpose: Go, Haskell, C#...
Maybe `hold_my_beer!`?
It's only descriptive to some people. A LOT of non-Rust users mis-understand the feature because of the name.
I feel an hunger i never felt to learn this language, im so excited!
I still prefer the YOLO alternative. 
Ooo. Thanks!
&amp;str has an important property that a &amp;[u8] doesn't: We know it to be correctly encoded UTF-8 text.
You are exactly right. I was just in a thread today over on HN wherein someone thinks that if a function `foo()` has an unsafe block in its body, and another function `bar()` calls `foo()`, then the function `bar()` is also unsafe (etc. transitively). …which is exactly backwards. At worst, the compiler is adding the assumption that `foo()` is safe to its proof about the safety `bar()`. It's saying: "a human really needs to audit `foo()` manually to ensure that it's safe, but if they audit it correctly then `bar()` is also safe". This wasn't the first time I've encountered that misunderstanding, either. 
That thread is what finally pushed me over the edge. I've been thinking about this a while. 
I had a hunch that might have been the motivator. If the RFC doesn't bear fruit maybe there could be a carefully written entry in the FAQ one could refer people to.
 The `Vec&lt;T&gt;` type is a dynamically sized, mutable array while `&amp;[T]` is a view into a sequence of memory *anywhere*, whether it's a subset of a `Vec&lt;T&gt;`, a fixed-size array or a slice into another slice. The two string types exist for the same reason as the underlying vector types, `&amp;str` exists as a thin wrapper around `&amp;[u8]` providing a UTF-8 guarantee, and `String` is a thin wrapper around `Vec&lt;u8&gt;` providing a UTF-8 guarantee.
I don't really grok this interpretation of what people are suggesting when they say `unsafe` should be transitive. It seems to rely on the assumption that they think the code inside the `unsafe` block *is* incorrect, rather than *could be* incorrect. But that makes no sense - why would anyone knowingly write or run known-incorrect code? I don't agree that `unsafe` should be transitive, but I understand the concern that people have, that they'd like to know when they're calling code that isn't subject to compiler-checked guarantees. And *that* property, that an inner `unsafe` block somewhere in nominally safe code can end up sinking the ship if the human audit screwed up, is absolutely true. 
&gt; You really can do anything you want in an unsafe block. Not anything at all. Rust still does some checks, just many of them are relaxed.
For my own sake: Did you understand Rust for Rubyists is only for 0.10, and you're just asking about how to update it for master, or do I need to make this more clear? Of course, learning edge is good. I'm just curious if the version information came across correctly or not.
An example of something you don't think can be done in an unsafe block would be helpful.
&gt; WHY ARE WE OPTIMIZING FIZZBUZZ PLEASE SEND HELP I'm surprised I don't get more bug reports about my terrible naming of `is_fifteen` etc. :)
&gt; it could be clearer. Do you have some concrete suggestions for this?
https://news.ycombinator.com/item?id=7886116 Ultimately, I'm thinking more of things like this fn main() { unsafe { let x = 5; let y = 10.0; println!("{}", x + y); } } which gives unsafe.rs:6:24: 6:25 error: mismatched types: expected `&lt;generic integer #0&gt;` but found `&lt;generic float #0&gt;` (expected integral variable but found floating-point variable) unsafe.rs:6 println!("{}", x + y); Rust still does things like typechecking. It's not completely no-holds-barred.
Again, trivial: use std::mem; fn main() { unsafe { let x = 5; let y = 10.0; println!("{}", x + mem::transmute(y)); } } //$ rustc add_diff_types.rs //$ ./add_diff_types //4621819117588971525 
The point is that it's not impossible, the point is that Rust _does_ check some things inside the block.
Here it is for current Rust, with some non-functional changes (spot them if you can): https://gist.github.com/Florob/0f3af74e7b699a33169a
So what? At any point in the block you can intentionally or unintentionally subvert those checks, usually trivially. You're working without a net. It's unsafe.
&gt; You're working without a net. You're working with a partial net, with some holes.
BONUS BONUS BONUS BONUS BONUS ROUND: I MUST BE REALLY BORED! #![feature(asm)] static out: [u8, ..0x19d] = [0x31, 0x0a, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x37, 0x0a, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x31, 0x31, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x31, 0x33, 0x0a, 0x31, 0x34, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x31, 0x36, 0x0a, 0x31, 0x37, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x31, 0x39, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x32, 0x32, 0x0a, 0x32, 0x33, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x32, 0x36, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x32, 0x38, 0x0a, 0x32, 0x39, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x33, 0x31, 0x0a, 0x33, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x33, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x33, 0x37, 0x0a, 0x33, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x34, 0x31, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x34, 0x33, 0x0a, 0x34, 0x34, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x34, 0x36, 0x0a, 0x34, 0x37, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x34, 0x39, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x35, 0x32, 0x0a, 0x35, 0x33, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x35, 0x36, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x35, 0x38, 0x0a, 0x35, 0x39, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x36, 0x31, 0x0a, 0x36, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x36, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x36, 0x37, 0x0a, 0x36, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x37, 0x31, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x37, 0x33, 0x0a, 0x37, 0x34, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x37, 0x36, 0x0a, 0x37, 0x37, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x37, 0x39, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x38, 0x32, 0x0a, 0x38, 0x33, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x38, 0x36, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x38, 0x38, 0x0a, 0x38, 0x39, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x39, 0x31, 0x0a, 0x39, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x39, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x39, 0x37, 0x0a, 0x39, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a]; fn main() { unsafe { asm!( " mov $$1, %rax mov $$1, %rdi mov $0, %rsi mov $1, %rdx syscall " : : "r" (&amp;out), "r" (0x19d) : "rax", "rdi", "rsi", "rdx" : ); } }
And when you walk a tightrope without a safety net, you're supposed to ensure you don't fall. Doing what you're "supposed to" do in an unsafe context doesn't make the context safe, it means that you don't suffer the potential consequences of the context's unsafety. (*edited for clarity) 
If you had a 10-year-old child who wanted to do a tightrope walking class, and the teacher told you "we've got a partial net, with some holes", would you let your child go across? Of course not, b/c it's unsafe. 
Setting up the machinery to call `main` is too expensive! Rip out the standard library and redefine the `start` symbol!!
Yes, but it would be significantly different than no net at all. (completely disregarding the fact that a net with some structural damage is useless. yay analogies!)
BONUS BONUS BONUS BONUS BONUS BONUS ROUND: Challenge accepted #![no_std] #![feature(asm)] extern crate libc; static out: [u8, ..0x19d] = [0x31, 0x0a, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x37, 0x0a, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x31, 0x31, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x31, 0x33, 0x0a, 0x31, 0x34, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x31, 0x36, 0x0a, 0x31, 0x37, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x31, 0x39, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x32, 0x32, 0x0a, 0x32, 0x33, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x32, 0x36, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x32, 0x38, 0x0a, 0x32, 0x39, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x33, 0x31, 0x0a, 0x33, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x33, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x33, 0x37, 0x0a, 0x33, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x34, 0x31, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x34, 0x33, 0x0a, 0x34, 0x34, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x34, 0x36, 0x0a, 0x34, 0x37, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x34, 0x39, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x35, 0x32, 0x0a, 0x35, 0x33, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x35, 0x36, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x35, 0x38, 0x0a, 0x35, 0x39, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x36, 0x31, 0x0a, 0x36, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x36, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x36, 0x37, 0x0a, 0x36, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x37, 0x31, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x37, 0x33, 0x0a, 0x37, 0x34, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x37, 0x36, 0x0a, 0x37, 0x37, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x37, 0x39, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x38, 0x32, 0x0a, 0x38, 0x33, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x38, 0x36, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x38, 0x38, 0x0a, 0x38, 0x39, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x39, 0x31, 0x0a, 0x39, 0x32, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x39, 0x34, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x39, 0x37, 0x0a, 0x39, 0x38, 0x0a, 0x46, 0x69, 0x7a, 0x7a, 0x0a, 0x42, 0x75, 0x7a, 0x7a, 0x0a]; #[start] fn start(_argc: int, _argv: **u8) -&gt; int { unsafe { asm!( " mov $$1, %rax mov $$1, %rdi mov $0, %rsi mov $$0x19d, %rdx syscall " : : "r" (&amp;out) : "rax", "rdi", "rsi", "rdx" : ); } 0 } #[lang = "stack_exhausted"] extern fn stack_exhausted() {} #[lang = "eh_personality"] extern fn eh_personality() {} (In all honesty that is as far as I would go. This still involves some startup machinery (though not that of libnative), and getting that to link is actually the sole reason libc is in there)
It's... its beautiful. I'm weeping tears of joy. As a reward for rising to the challenge, if you want kooky CSS username flair, you have but to name it.
Yes. Names should be intuitive. It's not about "they can't ever understand unsafe," it's that 'unsafe does not make it obvious that an unsafe block is safe to use."
&gt; trusted / verified / checked implies that the code was actually checked, when it may not have been. &gt; You can use unsafe{} to do things which really *are* unsafe. code which can't be verified, because its' dependant on data created in another source. There are valid uses for this, and the ability to cover this full range of uses is what makes Rust a true C/C++ alternative, unlike Swift. I would suggest keeping unsafe exactly as it is, and perhaps if in future the language gets additional concepts (like contracts?..) other types of 'less unsafe' unsafe blocks could be added, names like 'trusted{}' might make sense, alongside completely unsafe{} blocks
IMO.. for a "safe user" it should be an blackboxed detail they don't need to see - shouldn't matter. For a library implementor using it, it's a block containing operations that really are unsafe (like using powertools or something hot, or driving a car without ABS, seat belts etc..), so extra care is needed. And there are valid uses that really are unsafe- not verifiable within the program - because they depend on data created in another source (preprocessed assets). Not a good idea for the web, but C/C++ has been used in this way, and Rust is a valid C/C++ replacement because it's capable of all the same potentially dangerous tricks, if you want them.
This is being used by having stuff define a new type (e.g. ```struct GeoIPLocation(country: StrBuf, city: StrBuf```) for each key, and putting this in a single AnyMap in the HTTP request object, right? And if more than one value is allowed, then a vector or hashmap would be declared inside of the struct. If so, this is good, but the example is highly misleading, since no one would ever store a bare integer in this. 
Agreed. People are going to have to learn language semantics no matter what. It's not as though this is going to be a major hinderance or even a minor one. That said, if change was inevitable, so far I like `trustme` or maybe even something like `caution`.
&gt;&gt;The name unsafe does not properly communicate this intention, which is why it's a bad name. I have crashed a program deliberately for debugging `*(long*)0=-1;//hello debugger.`:) the intent might actually be, to crash.. unsafe{} says nothing about the intent, just what operations are possible. Also with non-bounds checked indexing (which is how graphics works), theres' nothing inherently safe. Incorrect data can crash it. So like a chainsaw, it must be used with care. Perhaps what you're talking about is a distinct case - code which might be verifiable as safe by some more advanced means - and maybe additional 'less unsafe' keywords (like `trusted` or whatever.. ) might eventually make sense? 
Sorry, I was intending it to be a joke.
Yes! I've learned a bunch from reading issues and the RFCs - not just about Rust, but low-level programming in general. For me, the fact that the design decisions can be studied (and influenced!) by anyone is the single biggest pro for a open-source project - even more than having the source available.
I saw the screen grab, and thought to myself: "he should probably just make it lisp with decent math libs built in", but your comment is far superior the the one I would have spent all of five seconds on.
I believe recursive functions are sufficient for Turing completeness. The availability of an if construct has no effect; in fact you can emulate conditionals with only functions (hint: Boolean values are binary functions). Note that SK combinator calculus is Turing complete.
So, "monads are like railroads." Seriously, though, good writeup. Do we or will we have that handy '|&gt;' operator in rust?
The official definition of Rust's unsafe block is that it is a sequence of unsafe operations that is safe in the surrounding context. http://doc.rust-lang.org/rust.html#unsafe-blocks If your unsafe block does not have a safe interface, then your code is incorrect. If you want to specifically crash your program, go for it, but then your program has a bug, even if that's what you intended.
1. Something like that. Possibly to be passed alongside the request rather than inside the request; the request should probably be immutable, at least by the time it gets to the main handler (I guess it might be nice to allow middleware to modify it, e.g. for certain forms of header mangling, though rust-http’s design—which is being altered significantly in Teepee, I might add—does not permit that). 2. Yes, that’s the idea. Alternatively one might introduce a phantom type parameter for something like multiple instances of the same middleware (a theoretical concern; I don’t know whether it’s realistic or not, though I haven’t come across a case where that would be beneficial myself). 3. `int` was just one of the two examples there. To be sure, I anticipate it being more complex types that people will normally (read: practically always) wish to work with.
The optimal form will probably copy hashtable.rs completely and then cut it down to shape. In the mean time, it’s only eight bytes per element and a little more slowness in something that’s very fast. Not *too* bad.
But wouldn't other people be confused by other names too? Personally, I understood what unsafe mean first time i saw it and I'm pretty sure I would have misunderstood "trusted", and "trustme" would have confused me. No short keyword is able to explain everything to everyone. I don't think there is a perfect key word everyone understand except maybe "take_care_safety_features_disabled" IMHO "unsafe" is the better choice for a sigle keyword since it is used by other languages for similar purpose and it is scary enough (you should not use unsafe if you don't know what it means) 
&gt;&gt;"if your unsafe block does not have a safe interface, then your code is incorrect." according to who's standards of safety? Some people write software for closed platforms - and you can optimise for assumptions about your data (e.g., your data has been produced within a trusted channel... transformed by an exporter .. and put through test for many reasons other than simply 'does it crash or not'. displaying some sort of error isn't allowed, so there's no need for the runtime cost of testing for incorrect data.. because incorrect data isn't allowed. key principles - "don't pay for what you don't use", and also "don't pay for what you don't *need*" ) Strictly speaking you'd have to mark your entire program unsafe for this ,but there's still useful checks the compiler can do , once you've made the appropriate program-wide assumptions. its' like the qnan issue. You're not allowed to display some error message in the middle of a game .. "arithmetic error", everything that might happen in the world has to be handled gracefully. It has to avoid NANs' by design (i.e. checking before you divide). Therefore you have a safe program wide assumption, no NANs exist, and no need for any runtime cost testing for them, except in a debug build. 
&gt;&gt;It's only descriptive to some people. A LOT of non-Rust users mis-understand the feature because of the name. I'd be curious to know what their language backgrounds are. Some people complained that rust had 4 pointer-types. I bet these were people from garbage-collected languages, or people who wanted to stick with C - who could honestly expect Rust to achieve its mission without a wide variety of pointers? I bet something similar would be going on if someone misunderstands what 'unsafe' means.
If you have a function consuming data that you don't want to do checks on, then you label it as an *unsafe fn*. When you pass the data in, and you're sure it's safe, you wrap the call to retrieve the data, as well as the call to the function, in a single *unsafe block*. The interface to the unsafe block is therefore safe, and you still get to skip the checking. Alternatively, if you're calling a C function that you know is actually safe, you just wrap the unsafe function with an unsafe block in a safe function. You've then manually made the commitment that the C function is safe to call, always.
I presume it was something like this? match (*self, *other) { (Some(a), Some(b)) =&gt; Some(a + b), (Some(a), None) =&gt; Some(a), (None, Some(b)) =&gt; Some(b), (None, None) =&gt; None, }
so your unsafe function reads data that the whole program uses. the world. so any part of your code that interacts with the world is unsafe?? Well, thats everything you see and do... marking everything unsafe (by the letter of the law) would avoid getting benefits that rust gives. Once you've made that one program-wide assumption (your exporter verified the world, and it might not even be written in rust), you can still make use of Rusts' compile-time-checks that deal with how the program interacts with itself.
`.`?
I've been thinking a little more. I like `plain` and `basic` - both implying that the advanced secure features of the language are not available. Both are 5 characters long (shorter is better). Though `unsafe` is far superior to `trusted` it still implies that the code within is poor/bad/risky - when it fact it may be most appropriate. Actually what about `core`? After all "unsafe" code is accessing core functionality in Rust. --- Though I guess we want an English word that ordinary users won't want to to use too frequently - and "core" (noun) might be a variable name or function that people want to use, where as a description-type (adjective) word such as "basic" might be more appropriate.
I personally never liked `unsafe` (and also the general talk about unsafety in other programming languages in the Rust community), because it implies that that code is really not safe to execute and something bad will happen. But instead it is only **potentially** unsafe. Any sane programmer would also do only safe things inside `unsafe` blocks. But he would still require them, because there are some things which can not be done in a performant way without them. Some things can even not be implemented without them because of language restrictions. Therefore I also think that things like `unchecked`/`unverified`/... describe the situation better. By the way: You can do lots of `unsafe` things in `safe` rust code. Any sign error may lead to a loss of millions, exploding things, etc. Probably the only way to guarantee that a program is 100% safe is to make it have 0LOC. 
I feel that `String` is a bad name for that, `StrVec` would be much more descriptive.
I recently saw some code doing something similar using an overloaded bitshift operator (&gt;&gt;). This can also be done in rust: http://doc.rust-lang.org/std/ops/trait.Shr.html
...or, if we want to avoid involving alcohol, `hold_my_contained_liquid!`
Why does nice *syntax* for `apply` (aka `($)` aka `|&gt;`) need higher kinded types?
Sorry for seeming dismissive/non-contributional... I pinged you on IRC to discuss but I had to disappear into real life before I could follow up. I would think that mentioning it in the front page/introductions, and maybe even at the top of each chapter (for people landing via links/search engines). Maybe it could be something like &gt; Rust for Rubyists is targeting the lastest Rust release (0.10), if you are using a different version (e.g. a nightly) the code examples may not compile, but the concepts are the same.
&gt; "Supposed to" doesn't mean safe, it means that when you actually do it you don't suffer the potential consequences of unsafety. I'm sorry, I can't parse this at all. Do you mean: - "supposed to" means that when you actually do [mutate immutable state] you don't suffer the potential consequences of unsafety, or - "safe" means that when you do [something?] you don't suffer the potential consequences of unsafety. The first is 100% false: it is undefined behaviour to mutate immutable state, even inside an `unsafe` block. The compiler optimises assuming it never happens, meaning code can be misoptimised/broken if you break the rules.
It actually does have conditionals statements already, and user defined functions can be recursive. What they lack, however, is being able to call functions as arguments (the builtin sum can do that, however). I do need to implement tail call optimization as well.
Oh, yes, going all the way to monadic DSLs requires HKT, however, you said &gt; We'd need generic operators to give it non-hideous syntax where the only possible context was for "it" to refer to `apply`/`|&gt;`, and `apply` definitely does not need HKT.
The people who suggest that unsafe should propagate are clearly thinking that, yes. And that isn't an unreasonable opinion to have upon first learning about the feature; in fact, the only thing that makes it unreasonable is its implication, that basically everything would become unsafe. What baffles me is the notion that newbies having this opinion is somehow a 'misunderstanding' or evidence that we need a new name. It's not; it's evidence that people can ask a reasonable question, the only real answer to which is acknowledging a concession to practicality.
Amusingly enough, Andrei Alexandrescu did a talk recently and he mentioned how in D they changed "unsafe" to "trusted" because it sounded better. Seeing it here just amused me.
Neither, I mean that safety and correctness are orthogonal concepts. Doing the correct thing (i.e., what you're 'supposed to' do) in an unsafe block means you don't suffer the potential consequences of that block's unsafety. It does not mean the block is magically safe - it's still explicitly marked as unsafe and the compiler still isn't checking it, and if you have a crash it's still a place you have to re-audit to make sure some dumb human didn't make the mistake there.
I'm hoping for Higher-kinded-types + [infix function call syntax](https://github.com/mozilla/rust/issues/8824). That way no more operators are needed, just traits and functions to use them. Moreover, functions are already part of the module system so no operator importing etc needs to be implemented.
I mean trivial as in trivial to figure out how to do the thing that was suggested couldn't be done in an unsafe block. It's just an illustration that unsafe really does mean 'anything goes'. *Of course* you should never write production code like this, and *of course*, yes, hopefully real bugs that wind up in deployed production code are far more subtle than this (an odd thing to be hopeful about).
"undefined behavior" does not mean "no behavior". It means any compiler is free to do whatever it wants. But if you know what the actual compiler in front of you actually does, then the behavior is defined enough to count. 
Someone said "you can't do x in unsafe code", and I did x in unsafe code. Extrapolating out from there that I advocate relying on undefined behavior is a little absurd.
Cross-post from GitHub: [I think ][1]`dangerous`[ is perfect][1]. [1]: https://github.com/rust-lang/rfcs/pull/117#issuecomment-46003090
This suggestion should be taken seriously. Its a very good idea. I know typically the idea is to minimise the length of unsafe blocks, but because of block scoping rules, Ive certainly seen mammoth (ie. unnecessarily long) unsafe blocks which are *categorically* harmful.
This article raises some great points, and I think it would be brilliant to have high quality statistical functions available in Rust. I had a look at the [Cephes library](http://www.moshier.net/cephes-math-28.tar.gz) mentioned in the article. Unfortunately, it looks like it hasn't been updated in an extremely long time - the timestamps are all from June 2000. (It's also not clear if the author's site or the netpbm has the latest, but the latter is broken up in many parts). Also, the licensing situation is not exactly clear, as it doesn't specify the use of a well-known license. There's no repo (it's all tar balls), no build system support, and lots of legacy stuff (eg. non-IEEE DEC FP support). So it would be quite a bit of work to bring it up to date for a modern system. However, it *does* look comprehensive, well-tested and well documented, and accurate. And best of all, the APIs are mostly quite straightforward so it should be quite easy to write Rust bindings (from the cursory look I've had so far). Do people think it would be worth updating this codebase for 2014 to bring into Rust?
I'm partially addressing other people reading this thread (who may misinterpret your original code as being correct Rust, especially given your comment at the bottom), and, in any case, being undefined behaviour means there's no guarantee that the compiled code is actually performing any mutation (i.e. there's no guarantee that code is doing what the source suggests).
Oh, everything makes sense now. A monad is just a monoid in the category of railroad switches.
Is that true? Andrei replied to me over on /r/programming and didn't mention that. EDIT: Ah, re-reading his comment, there are three variants of these keywords in D now. Gotcha.
No worries! &gt; maybe even at the top of each chapter (for people landing via links/search engines). Ahh, yeah, that's a good idea!
You are right that you can't please everyone, but even some experienced Rust users don't like `unsafe`. &gt; since it is used by other languages for similar purpose This is a good reason, but other languages use other keywords too.
I don't think it is, because `dangerous` blocks are safe to use.
I believe this is similar to the 'effects system' RFC.
&gt; (not happening before 1.0, likely never) Wait, higher-kinded types are unlikely to happen? :( How unlikely?
Man, I hate the use of method chaining for that sort of composition. It pushes everything into methods and disadvantages normal functions :(
That's pretty nifty. What's the status of this? Have you considered filing it as an RFC for it to be added behind a feature flag?
"Use" in what sense?
An area in which I feel Rust may prove a very useful language which I have not seen discussed much yet is demanding real-time creative applications, such as synthesizers, sequencers, open GL video manipulation plug-ins, pixel mapping, and lighting control. These applications need to run in real-time, they must be fast and efficient to allow for scaling up creative vision, and a crash at the wrong time means the lights on stage go dark or the video feed is replaced by your desktop or your electronic sonata dissolves into static. As a stepping stone to a larger project, I've implemented Open Sound Control over UDP in Rust. I tried to make this implementation as rustic as possible, so the core data types for OSC are enums. This made a lot of the code relatively straightforward. I've only included support for OSC 1.0 thus far as that is most everything I'll need for my project, but extending it to cover most of the optional data payloads would be straightforward. Feedback is more than welcome! I haven't updated this to the absolute-latest nightly yet.
Yeah, I understand that, I just question the necessity of this guaranty and the additional string slice type. Isn't it usually the case that slices are used as a *view* into a container (String in our case)? If the container is already guarantied to be valid (important for String) than the slice will be as well. The slice needs this guaranty only if it is mutated but even in that use case, couldn't we specialize the operations on the regular slice type without introducing a new wrapper type? IIRC, rust has a 'char' type. can't we overload the assignment operator (as in c++) for the [char] type to perform additional validation? another idea, define a CodeUnit type, and overload the [CodeUnit] type. 
&gt;&gt;Well, considering the only one that requires compiler support is &amp;, as we have now... Ignore the syntax for one minute, the fact it moved from compiler to library didn't change the semantics, so the number of pointers didn't decrease. the syntax (sigil vs generic) is just a name, just like operators can be function names in some languages.(even user defined) The ability to make smart pointers increases the number of pointer types from 4 to 'potentially infinite'. &gt;&gt;Once you've learned Rust, of course you think the meaning is obvious. Thinking more generally, how about 'once you've learned raw pointers'? I can only imagine this being a confusing term for people who've never encountered pointer-arithmetic, unbounded arrays, whatever, and if they're confused its because they've been previously shielded by java or something.. any confusion they might have can't be blamed on Rust itself. 
well after 20+ years of working exclusively with giant unsafe blocks across a variety of platforms, at some point you got an understanding of what is and isn't going to happen. there are contexts where safety checks are both unneccasery, and an unacceptable performance hazard, because error handling is itself incorrect behaviour (and a platform may have a cpu with very poor branching behaviour).. errors must be avoided by design. Debug builds are used to verify assumptions that you might not be able to track in your head - and can be used to verify assumptions that, as yet, type systems in widespread use can't handle. of course having more compile time safety is a great innovation , its a step forward for a language, but the reason rust is a potential C/C++ alternative is it still retains the ability to cover the full spectrum of uses - and match the performance of C in language shootouts-, through the features enabled in unsafe blocks.
Nah, I'm sure it'll happen (I haven't seen anyone against it), but probably not for 1.0. HKTs could most likely be implemented in a backwards-compatible way, thus it can be done post-1.0. So it's all about when is the best time for this kind of feature. I'll probably submit my RFC for it &amp;mdash; then close it for it to be postponed.
:((((
As I've said, the confusion is not over what 'unsafe' code is, or means. The confusion is over the fact that unsafe blocks are expected to preserve the safe invariants, so that as a whole, an unsafe block is safe to use.
[A non-macro solution in safe code using hypothetical `&amp;out` pointers.][1] [1]: https://github.com/rust-lang/rfcs/pull/98#issuecomment-46036846
Exactly, though it was later controversial as people couldn't agree on whether the middle two cases should return `None`. Something something monoids something.
With respect, I was already utterly aware of that. It's "safe to use" in the sense that you can use it to implement a safe function. It's *not* "safe to use" in the sense that its safety is assured. In other words, it is dangerous. We're arguing over the semantics of the word "safe". This is *exactly* the ambiguity I described in the first bullet points of my comment.
Does not UFCS (Uniform Function Call Syntax) solve this issue ?
Shit, many SSDs are only rated for 50GB/day for 4 years or so, something I'd definitely exceed in less time. I guess someone learned a valuable lesson just now...
Our UFCS is just calling methods in function form, so no; D's UFCS is basically making every function a method, which is what annoys me in the first place. ;)
One of the issues facing HKT in Rust is lack of a good proposal for syntax.
But "correct Rust" is nothing more than anything that the compiler accepts. The behavior that jfager invoked above is not a bug, it is part of the language, whether we like it or not. The best that we can do is publicly discourage using `unsafe` blocks at all and cross our fingers that it doesn't bite us in the ass some day.
Most SSDs do not fail due flash wear, but because of controller issues or something along those lines. edit: also wtf are you doing if you are writing 50GB/day on disk?
Dear god, please don't go around telling people this. You appear to have developed a dangerously mistaken impression of unsafe code and its purpose in Rust. Despite your best intentions, you are doing much more harm than good at this point.
&gt; We're arguing over the semantics of the word "safe". This is why it's a bad name, which I guess we're in agreement with at this point. My only beef with 'dangerous' is its lack of communication about the expectation to uphold invariants.
Agreed. I have a couple options that is the result of quite a bit of research.
I was really hoping to get the chance to watch this. Makes me really sad.
Your takeaway from that passage is mistaken. If "sufficient conviction" were all it took to ensure memory safety, there would be no need for Rust at all. Plenty of C++ programmers have sufficient conviction that their code is safe. Approximately 100% of these programmers are incorrect in this conviction. Approximately 100% of the `unsafe` blocks ever written in Rust will eventually be the cause memory unsafety. Rust's thesis is thus: **programmers *cannot* be trusted.** This is the difference between an optimistic programming language (C, C++, and any language with a dynamic type system) where the compiler errs on the side of permissiveness, and a pessimistic programming language such as Rust where the compiler kicks your ass. You and I are stupider than the compiler, and pretending that the unsafe code that we write is *not* unsafe is the sort of hubris that leads to exploitable memory errors that make the world a worse place. A vanishingly small percentage of people will possess the humility, the caution, and the expertise necessary to safely employ unsafe code in a dependable production environment. The fact that you hang around in circles of motivated, world-class programmers may have blinded you to the precise minisculity of this percentage. Conversely, I spend every working day of my life with people who think that this: ' '.replace(/ /g, "&amp;nbsp;") is the proper way to manage the width of a table in HTML (this is not a contrived example). Rust would be a great first systems programming language for these people, because it enforces the discipline to keep them on the straight and narrow—but only if they are not instilled with the notion that they know better than the type system.
We have a few Oracle db's that write out way more than that with archive logs. I don't think its that uncommon.
Disclaimer: I am not a lawyer and I make a few generalizations in this post. You should add a license, otherwise no one else can (legally) use the library for anything without contacting you. For this sort of program AGPL is probably a good copyleft license (it prevents people from taking it, making changes, and not sharing those changes. It is stronger copyleft then the GPL because it applies to the code behind servers as well). If you want a more 'public domain'y sort of license, the MIT license is popular these days.
&gt; I want a vector of amphibians and don't care what the actual implementation is. You can't do this however. Ugh, what a show stopper. 
That's the challenge having features where they are traditionally implemented in higher-level languages (where they have GC, they don't need to worry about lower-level details so the VM/compiler can optimize things like immutability with vectors like Clojure does). 
As I replied on the video: &gt; ...that video is pretty good, but it was a test run of sorts for the Lang.NEXT presentation (he'd also presented at A9 beforehand). It's still definitely worth a watch though.
Oh, for production servers that figure doesn't sound outlandish. I was thinking workstation style loads, where 50gigs/day would be interesting.
Anonymous fields in go are just that. They're a touch of sugar for composition, but in the end, they're just a field. I actually don't like anonymous fields because they add complexity, reduce clarity (in my opinion), and they don't actually save much space in the code.
Very true, although I could see someone that works on video/pictures able to do 50g/day easily. Though to be sure they're also in the minority and by no means counters your point, just another exception. I'm trying to come up with a general user case that could do 50g/day. Outside of video/audio/pictures/3drendering I can't come up with a good example though. 
There was a long bikeshed over this name already.
We can't use a [T] for any T representing a single character to represent a view into a UTF-8 buffer safely. In Rust, a [T] is a series of T laid out in memory, sequentially. In the case of strings, those T = u8. Now, Utf8 encoding is variable-width: A single character could be 1 to 4 bytes long. The type char can hold any unicode scalar value, so it is a 32-bit type. We could represent strings as [char], ie Utf32, but that loses all the nice Utf8 properties and would blow up memory usage a lot. Fundamentally, Rust lets you see how things are laid out in memory, and we can't just sweep that under the rug, or do expensive copies and conversions all to avoid having a &amp;str type.
No idea. I just find that my home partition has written over 40 GBs/day in the past 7 days, and that's *without* doing anything special and does *not* include any swap (which is ten times lower). I imagine a decent amount of it will be my Google Chrome cache. No, I'm not joking, but I don't have this data in the granularity needed to prove/disprove that hypothesis. I just did `awk '/sd/ {print $3"\t"$10 / 2 / 1024}' /proc/diskstats` To be clear, this is a home desktop PC.
I can't say for sure, but wouldn't it be possible to use libsyntax in some way and parse the code, perform the known fixes on the AST and then pretty print it back into code files? That's what gofix does, if I understood it correctly. I can imagine that it would be really hard right now, with all these big syntax and lib changes, but it may be easier later, when it stabilizes.
HKT have uses beyond just monads (e.g. data structures generic over the pointer type they store).
I believe this was discussed at some point. Rust is also working out a versioning scheme that will most likely add more metadata about the current Rust version. (I thought someone tried whipping up a prototype at some point, but I may be mistaken)
/u/pcwalton had a rustfix at some point... Really though, given the strong commitment to SemVer, I think that a tool like this is less important. It'd be nice to use new idioms, yeah, but old code should still compile just fine.
With respect to `go fix`, it was most heavily used back in the days before it hit `1.0`. Once Go reached a stable version, the backwards compatibility promise has just about made `go fix` obsolete with a few caveats. It may be useful again once Go hits `2.0`, and it's possible for others to use `go fix` to help with migrating third party libraries (I think). Although in practice, most of the Go community practices the same habits as Go the language. So basically, we're in a situation where a theoretical `rustfix` would be most useful **now** as opposed to post 1.0, with the idea that Rust 1.0 implies some stability to the language and libraries. (Although as far as I know, not all libraries will be considered stable at 1.0.)
&gt; The behavior that jfager invoked above is not a bug, it is part of the language, whether we like it or not. Not really. I believe C/C++ do not regard undefined behaviour as part of the language, but rather syntactically-correct malformed programs; I hope Rust takes the same approach.
Vector indexing (like foo[2] = 10) is being redone right now: Rust is revamping its indexing traits to make things work better. You can use the method get_mut to give you a &amp;T reference to your vector member that you can mutate. Do this in the meantime: fn main() { let mut foo = vec![1,2,3,4]; println!("{}", foo); *foo.get_mut(2) = 10; println!("{}", foo) }
I think the difference between safeties can be expressed as "safe to write" and "safe to execute". Unsafe blocks are NOT safe to write but *are* safe to execute when written correctly. Many people seem to be of the impression that correctly written unsafe blocks aren't necessarily safe to execute, however. If that were true, then any function with an unsafe block should be transitively unsafe. But that's not enforced or seen in practice, so either everyone is using unsafe blocks wrong, or unsafe blocks *are* supposed to have safe interfaces. But I don't seem to be able to convice people of this. That's why I made a new proposition on the RFC - decouple unsafe blocks from explicit safe interfaces.
Nice! By the way, there's an [open source Docset generator](https://github.com/indirect/dash-rust) for Rust, but nobody has volunteered to generate + host an update to date feed for it. It's more or less at feature parity with the official Docset; the major missing feature is support for Table of Contents (which is a bit tricky). With a bit of work we could get `dash-rust` to work with rustdocs for any crate — not just the standard libraries — which would be pretty awesome.
I'd put the LICENSE in the root of the repository since that's where everyone (well, me at least) expects it to be. :)
Oh, yeah, you're right about GPLv3 and GPLv3. The problem is GPLv2-only. I would *not* say properly-licensed, however; for instance, the Linux Kernel, is intentionally GPLv2-only.
No, perhaps I should do if people want it.
This is very interesting! I can see this becoming very useful in combination with [Piston](http://www.piston.rs/) to build multimedia rich and real-time systems.
I would be interested in coming. I prefer something closer to downtown. The public transit on the West Side.
that's why I disabled disk caching in firefox, now I'm 100% RAM cache (I set the RAM cache to 10x normal amount because I have 16 gigs of RAM)
I have 2 gigs of RAM and regularly exceed that amount in usage. Forgive me for not following in your footsteps. ;)
There's also the [NSWC subroutine library](http://www.ualberta.ca/CNS/RESEARCH/Software/NumericalNSWC/site.html) which suffers from some similar age and somewhat confusing license concerns, but has seen recent attention by Julia devs to bring up-to-date. See [1](https://github.com/JuliaStats/Distributions.jl/pull/148), [2](https://github.com/JuliaStats/Distributions.jl/blob/12d5aea1d9bea01e4883c120dc870dcf8912ecf9/src/specialfuns.jl#L2116), [3](https://github.com/JuliaLang/julia/issues/4301), [4](https://github.com/JuliaLang/openlibm/issues/20) Link 4 in particular discusses incorporating these subroutines into [JuliaLang's openlibm](https://github.com/JuliaLang/openlibm), which could easily be used by Rust.
It's early in the morning, but I'm thinking you're correct.
https://github.com/mozilla/rust/wiki/Docs#presentations
Linux is GPLv2 only? That is disappointing. I'm still going to stand by recommending AGPL because this contains server code, so the GPL isn't really strong copyleft. However I suppose there is a strong argument for using "GPLv2 or later" then.
I generally prefer mit/apache for libraries, GPL just eliminates 90% of use cases (that percent is made up, obviously)
[meteor-contest Rust program source code](http://benchmarksgame.alioth.debian.org/u64q/program.php?test=meteor&amp;lang=rust&amp;id=1#sourcecode)
I think it depends on the purpose of the library; If you are trying to push a new standard somehow, then I see an argument for using the MIT license, as you want commercial adopters. If you are doing this for fun (or to learn), I think the most morally correct thing to do is GPL it, as a way of encouraging more open source software. Yes, this eliminates many use cases, all those are (to my knowledge) commercial use cases though. I see no reason why it is morally better to give away code for free so other people can make money, then try to push them to give away there code for free as well (even if it mean less adoption). A middle ground approach is the LGPL, where you let people use it in proprietary software, but if they are actually improving the library they are obligated to share those changes. This probably eliminates closer to ~5% of use cases then 90%, and I think those 5% don't have many redeeming qualities. (percentage made up) To be clear though my original post wasn't really advocating for GPL over MIT or the reverse. It was attempting to say, "this code needs a license, here are two extremes to consider if you don't know about licenses". While I have my opinions about software licenses, I don't think it is my place to dictate what others do with their code.
I vaguely remember this being 'no,' but I don't remember why, exactly. If I had to guess, "backwards compatible, not essential" means at least pre-1.0, the answer is 'no.'
Hmm I found the following code block in an [implementation of "false" from a coreutils port](https://github.com/uutils/coreutils/blob/master/false/false.rs): fn main() { std::os::set_exit_status(1); } But my question still stands - why doesn't the runtime allow `main` to return an `int`?
You can also do: #[start] fn start(argc: int, argv: **u8) -&gt; int { // main function here return 42 }
Rust certainly could be designed to do this. It used to, in fact. But because of the task model Rust uses, the fn main task could start a bunch of other tasks and then exit! But one of those other tasks may want to set the OS exit code after main has gone away. Calling set_exit_status is explicit, easy, and doesn't require you to always put a 0 at the bottom of main when you otherwise don't cafe.
I'm kinda new to rust myself, so I don't know if this is the cannonical answer to your question, but it does have a start method which is used to start the runtime usually. People can override this one if they don't want to use the runtime, and it has a very c-like method signature. But as you pointed out in your own comment, it seems the correct way in main is to set the return code for those that need it. #[start] fn start(argc: int, argv: **u8) -&gt; int { // start the runtime and call the main function native::start(argc, argv, main) }
the main difference for the use cases I have in mind seems to be threads for me would be mostly used for data-parallelism, not so much concurrency (although there is some concurrency aswell); its often possible to arrange things such that one main thread owns most of the data. also throttling is possible - for a consistent framerate you need a consistent load, which also means bounds on the amount of workspace tasks might need, and you can manage the load to stay within that.. knowledge that can be exploited in the design of the allocation scheme. very different to a server handling many user requests which seems like a much more concurrent situation.
&gt; The reason for needing "blah".to_str() is because string literals are allocated in what's called static memory, whereas num.to_str() creates a string that's allocated on the heap. Intuitively this seems wrong. Why? Because a language like C doesn't care whether a pointer is pointing to code, static data, stack data, or heap data. I understand the pedantic need to track data lifetimes in Rust - but perhaps Rust can be more clever - if the stack data lives at least as long as the heap pointer then surely the results can be interchangeable. It seems pointless to copy a string in memory just to appease a "type" of pointer.
Because in the first impl, `J` is allowed to be any type. But this isn't any magical runtime generic, it's all static. Which means that code like `impl&lt;J&gt; Foo for J { fn bar(self) -&gt; int { 1 } }` will generate a separate impl for *every type*. Which means that somewhere in that generated code, you get an impl that looks like this: `impl Foo for int { fn bar(self) -&gt; int { 1 } }` Which means that if later, you try to do this: `impl Foo for int { fn bar(self) -&gt; int { 2 } }` The compiler has no idea which method to prefer.
Does this RFC: https://github.com/rust-lang/rfcs/pull/39 describe what you want?
Yes, but this isn't necessarily a good special case to put into rust.
Nah, his J is a struct, not a type parameter.
As far as I understand, something like this will be possible when [RFC #48](https://github.com/rust-lang/rfcs/pull/48), which has been merged recently, will be implemented. I may be wrong, but I clearly remember that that RFC was intended, in particular, to provide a solution for such trait overloads (for example, when you need to multiply a vector by a vector and a vector by a number); maybe these bits were removed from the final version of the RFC.
looks like thats the relevant discussion. I guess I was curious to know what direction this might go in. I can see why it would be deprioritized.. certainly everything I'm interested in could be retrofitted without breaking anything ; but it is nice to know if its on the roadmap or not; similar precise control is desirable for a C++ replacement. 
Dear god, that never even occurred to me. The importance of naming! :P
Oh I agree, I do not think we should add this and I am happy with the current solution of main returning () and start returning an int.
`self` used to be implicit. This was an issue because you could not define whether `self` was passed as `&amp;'a`, `&amp;'a mut`, or by-value. This meant you needed a different trait for each way of passing `self`. For Rust, being explicit is much more flexible. This is not an issue in other languages where everything is passed by reference, and where mutability is implicit (some languages have keywords for enabling/disabling the mutability of `self`).
I'd also add that there's great value in seeing what's actually happening when you invoke a method on an object, i.e. there's no magical wizardry - you're just passing a reference (or a value) to a regular function.
Because you may want to pass self by reference or by value, and you need a place to specify whether self mutates the receiver. 
Rust by example is by far the most valuable Rust tutorial. Thank you for making it.
Side-jack. My understanding is that Rust doesn't have uniform function call syntax (in the sense that *any* function can be called as obj.foo(bar) and get transformed to foo(obj,bar)). Any rationale for this? I know you can easily create an implementation but it seems like an extra step that's unnecessary a lot of times.
That design conflates the need to specify how to pass the receiver with specifying an identifier for the receiver. They are orthogonal issues. :-)
I'm still upset about the pseudo-oop trend of faciliating a pseudo-pipeline-style of programming by making everything interesting a method instead of a free function so you can go `x.f().g().h()` etc, just because `h(g(f(x)))` is backwards. I already don't have a good idea of what makes a good method versus a good free function, but I'm pretty sure that completely throwing out the distinction and making everything you can a method just for syntactic convenience is the wrong direction.
If it's *neither* a method of a function, but can be used as either, then your problem is solved. You don't have to choose, the caller can choose based on context. Being able to put the "main" argument first and hit "." to get a list of possible functions is an incredible time saver. 
I don't see us throwing out methods anytime soon though, so that style of UFCS would just make it harder to distinguish between methods and function without looking them up. :/ One of my headscratchiest bugs in the short time I played with D was writing `somefilehere.writeln("some text here");` and then not getting anything written to the file because I was accidentally invoking the global `writeln` function and writing the file as well as the string literal to stdout, when I had really meant to call the `.writeLine()` method...
I love it, i love it, i love it. I could say this a million times. Thank you!
well, you could make the chars into an array. As it stands it's currently lazily generated. The issue of the closures I don't think is directly solvable until unboxed closures are implemented, but I could be wrong in that regard.
But `self` is a keyword there, it's not just a suggested name as it is in Python. In that sense, `(&amp;)` is just as much of a symbol as `(&amp;self)`. And what happens then if you want to take self by-value? Currently you have this: `fn foo(self) {` ...would it look like this? `fn foo() {` ...because if so, then we'd also need all-new syntax for specifying static methods.
&gt; Is that expected? A macro at the beginning of a statement is treated as a statement, not an expression. To get around this, surround the macro in parentheses: if a == b { (vec!()).move_iter() } else { (vec!(format!("{:c}{:c}", a.to_char(), b.to_char()))).move_iter() }
sorry for the misleading naming :P actually i was doing some matrix work and want to multiply a matrix by a matrix as well as a number. but the code would be too verbose. so i wrote some simple sample code to describe the question.
&gt; Any rationale for this? Mostly just that it's not implemented yet. It's something that's desired, but I think there was one or two issues. It's certainly not something that's been stated will never be in Rust.
ahh yeah!!!
This seems like a lot of contortions to go through just to avoid typing `self`. Trust us! We started out with implicit self, and switched to explicit after a good deal of hard-won experience. :)
thanks a lot for taking the time to check my code. I'll play with it some more but I suspect you're right. Awesome trick turning chars to a closure!
on n. 1 you're right but it was my fault. The inner closure was originally something like: |b| (vec!((format!("{}{}", a, b)))).move_iter() I had simplified it to try and isolate the issue but it did not correspond any more to the problem description. I also agree with your conclusion that the need to collect combinations from the inner closure (while ok in this specific scenario) means you would not do it this way for very long or infinite sequences. I like that Rust makes the exact point where laziness is lost very explicit though.
We actually may be making it even more explicit in the future in order to accommodate custom smart pointers like so: fn foo(self: Rc&lt;Self&gt;) { If this is the case, then it remains to be seen whether the parameter will still be required to be named "self" (though personally I hope so).
awesome, thanks! I was always assigning the results of macros to temp variables in these cases. let v = vec!(...; v.move_iter()
I agree. I didn't mention the fact that self might be not be as 'special' in the future. See /u/kibwen's comment.
You should try and get the rust homepage to link to your tutorial, it would really help the newcomers (...which is pretty much everyone, considering rust's age and its rate of change). I find it far more complete and organized than the official rust tutorial (no offense to the author of the tutorial, they're probably too busy making rust an awesome language) 
&gt; it only lasts for the lifetime of the enclosing closure call Note that the upcoming closure changes solve this (specifically capturing by value), because the issue is the `a` variable is captured by reference, chaining the interior closure to the stack frame that defines `a` and stopping it from being returned from the outer `flat_map` call.
Damn it, now I don't have an excuse not to learn.
This is fantastic, thank you :-)
That's great news! Nice work!
You could alias with `type Type = Box&lt;YourType&gt;`, so you only use the outer one.
&gt; Almost all C programs in these environments expect main to be declared with an integer return value. But then there is plan 9 where main is not returning anything and the programer always needs to call `exists`. Note that `main()` is not actually the entrypoint for the os. It's the entrypoint for libc. There are many other mains. There is `wmain`, `WinMain` on windows for instance.
In C++ to get an open set of types you would go the [Acyclic Visitor](http://www.objectmentor.com/resources/articles/acv.pdf) road, however this relies on `dynamic_cast` so I wonder how best to achieve the same result in Rust.
Very interesting. Reusing (parts of) the library that Julia is using could be very effective solution. No point reinventing the wheel, or duplicating effort. I wonder whether it could be used for just the statistical functions (so as not to double up with the rest of `libm`)?
Thanks!
You can get something similar to `dynamic_cast` via trait objects with [the `Any` trait](http://doc.rust-lang.org/master/std/any/trait.Any.html).
It's not the 'self' in the method signature that's the issue. It's the all the variables and methods that have to be qualified with 'self' in all instances. The references to self there should be implicit, and explicit in some cases when necessary. That's the part of the design rationale that I'm trying to understand.
Considering Rust and Julia are already both using LLVM and libuv, more synergy makes sense. Julia's community has a whole bunch of numerical experts, and would be happy to make nicely reusable tools - more people testing things out in more use cases is always good. So I'm not sure what the status or plan for incorporation would be. That issue in openlibm has been open for almost 18 months, but about 6 months ago some non-libm parts of the library were split out into a separate repo - https://github.com/JuliaLang/openspecfun - I imagine they would make more sense there. One of the issues with NSWC (from link 3) is: &gt; We could just call that code except for the function that initiated my translation, i.e. the incomplete beta function. It is written in single precision, but they had some special computers for naval surface warfare computations in the beginning of the 90s so they could have 14 digits precision in single precision. Therefore the incomplete beta function would need a translation to double precision anyway and my choice was Julia over Fortran. It looks like Cephes is also part of SciPy, that may be even easier for you: https://github.com/scipy/scipy/tree/master/scipy/special
This is based on a [macro](https://gist.github.com/bvssvni/9674632) that was discussed long time ago.
https://github.com/mozilla/rust/issues/14380
This is a lie :P, both `~` and `@` are still there use std::gc::{GC,Gc}; fn main() { let x: Box&lt;int&gt; = box 0; let y: Gc&lt;int&gt; = box (GC) 0; // error: binary operation `+` cannot be applied to type `~int` println!("{}", x + 1); // error: binary operation `+` cannot be applied to type `@int` println!("{}", y + 1); } $ rustc --version rustc 0.11.0-pre (6d8342f 2014-06-14 17:51:49 +0000) host: x86_64-unknown-linux-gnu
&gt; It's the all the variables and methods that have to be qualified with 'self' in all instances. The references to self there should be implicit, and explicit in some cases when necessary. I feel that it's better to be explicit for code readability. Look at all the code in Java and C++ that uses `m_` before members to work around the fact that C++ isn't explicit here.
Please file an issue on this.
This reminds me of Scala's for comprehensions to a degree. Both feel very cluttered to me. I've always felt something more like F#'s [computation expressions](http://msdn.microsoft.com/en-us/library/dd233182.aspx) would be a better fit for rust if some sort of monadic syntax sugar was to be added to the language. It feels like it fits the language better to me for a few reasons. One of them being that workflows can be easily implemented through some sort of Workflow trait. Also the syntax feels slightly more "imperative" and block-based and goes along with the rest of the aesthetic feel of rust to me. Finally it's extremely extensible and new workflows can be written as needed. F# comes with a few built-ins like seq (generators), async (what inspired C# await/async), query (support for LINQ and out of process queries). I've also seen a few others from libraries such as maybe (nice way of handling options), etc. An example in (theoretical) rust would be as follows: let result = maybe { let! x = read_int_from_user(); //Reads an int from the user, returns None if not valid. let! y = read_int_from_user(); x + y }; //Result is Some(n) if the user input valid numbers both times; otherwise None Essentially what's happening here is that the let! attempt to unwrap the option for use. If the option is None the workflow short circuits and returns None. If it is Some the workflow continues execution with the remainder of the workflow as the continuation. If it successfully reaches the end it returns Some using the result of the final expression. In all honestly, the F# computation expressions could probably be written as a macro since all it really does is convert the workflow in to continuations. I also almost directly lifted the example from the F# syntax. Using ! to indicate the continuation would most likely conflict with macros and some other symbol or keyword would probably need to be selected in its place.
This is very similar to the try! macro. macro_rules! try( ($e:expr) =&gt; (match $e { Ok(e) =&gt; e, Err(e) =&gt; return Err(e) }) ) and in Rust the example could be written as: fn get_input() -&gt; IoResult&lt;int&gt; { let x = try!(read_int_from_user()); let y = try!(read_int_from_user()); Ok(x + y) } let result = get_input(); IoResult&lt;T&gt; is a typedef for Result&lt;T, IoError&gt;. 
Yeah, it's very similar, but much more general purpose and easy to compose workflows together.
I was just thinking the same thing
I'm happy how well existing syntax works for that example: let numbers: Vec&lt;uint&gt; = File::open(&amp;Path::new("n.txt")).ok() .and_then(|file| BufferedReader::new(file).lines() .map(|line| line.unwrap()).next()) .and_then(|first_line| from_str::&lt;uint&gt;(first_line.as_slice().trim())) .map(|n| range(0, n).map(|x| x + 1).collect()) .unwrap_or_else(|| Vec::new()); Sure, it's not quite as nice, but clearly we just need hkt and make some nice monad operators and make the special syntax sugar for them instead of something ad-hoc ;)
Good news. Congrats on getting more contributors!
Thanks!
Can you explain how HKT and monad operators will be able to simplify this code? (to make a case for them)
Here's my do macro proposal that I have in my not-yet-released HKT RFC: fn something() -&gt; Option&lt;String&gt; { return do! { let a &lt;- action1(); let b &lt;- action2(); action3(a, b); } } I wrote a bit about it in another RFC: * https://github.com/rust-lang/rfcs/pull/113#issuecomment-45569863 * https://github.com/rust-lang/rfcs/pull/113#issuecomment-45625107 * https://github.com/rust-lang/rfcs/pull/113#issuecomment-45639690 So, in this case, `do!` is simply sugar over the monadic bind operator, which is possible due to HKTs.
With an implicit-self language, you have the option of being explicit for readability. It seems heavy-handed to force explicit-self for all cases. I think there's going to be a lot of code that does things like 'let x = self.x' to work around the verbosity that explicit-self imposes in certain expressions.
But, thanks for your answer. That's what I was wondering; if there was some hard technical requirement, or if it was more of a judgement thing. :-)
As an example, consider the [Box2D vector math C++ library](https://code.google.com/p/box2d/source/browse/trunk/Box2D/Box2D/Common/b2Math.h). With explicit-self, all the qualified references to the member component would make that code obnoxiously verbose.
If we had HKT, .and_then() and .map() could be trait methods rather than methods on specific types and we could have specific syntax sugar for that trait instead of this ad-hoc approach. I don't have a strong opinion on whether that's better, but there's precedence that monads compose pretty well, at least.
Thanks for the tip!
Is it bad that the compiler uses `GC&lt;T&gt;`? I a no compiler writer, what was the rationale in the first place for using it then?
What's HKT?
Higher-Kinded Types
See this article for an explanation http://hydrocodedesign.com/2014/04/02/higher-kinded-types/
The compiler made a lot of use of @ back when people though @ would be the default smart pointer
Could you provide some examples of how rust-event code would look, in the expressions branch?
A method has access to private fields and can be a virtual function or interface implementation (in languages that have those concepts). A free function cannot do either. That's the whole difference. 
Will add some examples very soon. https://github.com/PistonDevelopers/rust-event/issues/66
And yet I don't see people making everything that doesn't need to access private fields, be virtual or part of an interface implementation a free function (and in C++ you can even grant access to private members to non-member functions), so there must be some other consideration...?
The only difference is that he's not used to functions being used as methods, once you get used to that the error is the same as any other instance of accidentally calling the wrong function.
Because if you don't, you expose implementation details to callers. Would you argue that vitual method invocation should look different from normal methods? Or how about methods that are inlined vs. methods that aren't? Leaking implementation details to the caller isn't a great idea. Keeping the "look" of the caller consistent means you give the implementer true choice in what strategy to use. If you make free-standing functions uglier, then implementers will use fully-fledged methods for everything, even when it's not needed. This harms code quality over aesthetic concerns. Make aesthetics not an issue, and people can write better code.
Nice work on this, especially on the documentation. I found a typo in `Floor::get`'s documentation: ...Handlers are asigned to paths... should be: ...Handlers are assigned to paths..
&gt; this is now a (heap) closure Why a heap closure? It would be better to be an non-heap unboxed closure that can then be converted into a heap closure if necessary. --- Also, your markdown is misformatted, making it harder to read your comments. Code blocks should be indented four spaces, with an empty line above and below, e.g. It would be really cool to be able to do: let bar = foo(3); // this is now a (heap) closure |b: double| foo(3, b); let s: String = foo(3)(3.14); // or bar(3.14); Of course, this doesn't address the virtual call mechanism. Looks like: &gt; It would be really cool to be able to do: &gt; &gt; let bar = foo(3); // this is now a (heap) closure |b: double| foo(3, b); &gt; let s: String = foo(3)(3.14); // or bar(3.14); &gt; &gt; Of course, this doesn't address the virtual call mechanism. And, inline code can be surrounded in backticks to get it formatted nicely which allows nonsensical stuff like: `writeln = 5;` Looks like &gt; which allows nonsensical stuff like: `writeln = 5;`
&gt; With an implicit-self language, you have the option of being explicit for readability. You also have "compulsory" confusion, when you accidentally access the receiver's fields, instead of some local variable (and it's nearly impossible to avoid this, since implicit self languages allow for `self` to be dropped everywhere).
Thanks for the formatting tips! Regarding the type of closure - I didn't actually put a lot of thought into this and it wasn't that important for the point i was trying to make. I've updated my message. 
&gt;It's API is inspired Its
Ah, weep ye for the sigils! The tilde is faded; It resteth in a box Six feet under. Ah, weep ye for the sigils! The at symbol, tangled, Mistaken for garbage Has been collected.
Actually `dash-rust` got TOC support this weekend :-) Although my docset doesn't yet uses it as a generator.
Rumours of the death of `@` are greatly exaggerated. It still exists in patterns! (It just has a different meaning there.)
Don't forget it still exists in strings and comments too!
He mentions Rust, but I don't necessarily agree with his conclusions. :/
A tracing garbage collector would introduce significant complexity, making it harder to write correct low-level code and limiting what can be expressed. At this point, I don't think most people involved in the community are willing to make the necessary sacrifices. It certainly doesn't depend on allocators, in fact it's directly in conflict with adding that feature. The co-existence of tracing garbage collection and allocators would result in a very complex API and lots of easy ways to screw up `unsafe` code. I don't see tracing garbage collection happening before the end of the year, and once 1.0 is released it isn't going to happen since it wouldn't be backwards compatible with existing low-level code. Rust still advertises this as a feature on the front page, but I can't see how it would fit into the language.
And, of course, in our hearts.
Any problem you are trying to solve should be defined by precise, objective criteria. Otherwise it's difficult to find a solution.
Yes, but it's also verbose and puts the onus on the person writing the initial implementation to provide methods. Sometimes a function can acts more like a method only in some circumstances (when one of the params is clearly the main "subject" of the code, running a method on it may be clearer than using a function where its special status gets lost)... At the very least it could be syntactically cheaper by adding an implicit impl clause if there's a self argument. Not sure you should even force there to be a self argument though. Seems needlessly restrictive.
This is straight-up amazing. I'm writing a emacs-lisp-like language designed for scripting things in Rust (kind of like Lua and C) and this looks WAY more appealing than trying to link against LLVM.
For Rust (or any other language for that matter) to replace C++ does not require current C++ devs to make the switch. It just needs to suck in the new devs, which I think it is already doing quite well.
Thanks for writing!
good article - and I'm more enthusiastic than him about rust, but i *do* agree with some of what he says: &gt;&gt;"If I have to point at what is most needed for productivity, I'd say interactivity. Interactive visualization, manipulation, REPLs, exploratory programming, live-coding. That's so badly needed in our industry that we often just pay the cost of integrating Lua (or craft other scripts), but that can work only in certain parts of the codebase..." nail/head! &gt;&gt;We solved concurrency with a bunch of big parallel_for over large data arrays and some dependencies between a bunch of jobs carrying such loops. We don't share data, we process arrays with very explicit flows and we know how to do this quite well already. again +1, its just C++'s defaults of access anything anywhere makes it error prone. This also relates to things i've been trying to explain r.e. allocation: games don't need complex allocation patterns across threads.. back to productivity, this is why I was so interested in rust having a CFG, being easier to parse. It should eventually allow better tools. Productivity is a bigger problem than safety. As he says, the 'scariest bugs' are in areas beyond the language anyway - interaction with the GPU, and in data coming from files; The safety of rust is definitely welcome, but not a 'must have killer feature', because you can statically analyse C++, and *you've got to write tests for other reasons anyway*. Its the clunkiness of C++ that is frustrating - so much syntax cruft, and headers. Lack of inbuilt reflection making serializers and GUI a PITA. my single biggest gripe with C++ is, "the way headers and classes interact", not the fact its a giant unsafe block. and of course, Rust IS a step forward there with (i) no headers, and (ii) struct/trait/impl instead of class, but I miss ad-hoc overloading. What he says about Go however is strange. Go just isn't expressive enough to be interesting (to me), and its' GC. Rust is definitely way more interesting than Go. my personal dream language would be as powerful as C++ but have a significant subset that can be interpreted well through a REPL and able to do the job of Lua. Absence of a type means infer it. C++ is way too clunky for this. Rust's cleaner syntax seems promising. The most complex 'data processing' is actually done offline in tools, there's a point of failure there (keeping file formats in sync). The job of tools is to preprocess things to simplify the runtime. (This ties into something I've been trying to explain elsewhere r.e. memory allocator discussions.). But you still want the same language for tools &amp; runtime, because you want to take data structure descriptions back and forth, you want to be able to write tests (e.g. get the tool to render the output like the runtime would, but you DONT actually need the whole tool to be efficient - its only running in-house, end-users don't run it; and sometimes you save time by writing bits of preprocessing that should end up back in the tool , "hacked into the runtime", just so you can iterate faster, without having to make 'breaking changes' to the fileformats. Basically the language has to be efficient like C++ as its pillar (no GC, don't pay for what you don't use etc), but without breaking that, it needs as many productivity-friendly enhancements as possible- and take on board this idea that 'ad-hoc', 'large' and 'efficient' programs are *orthogonal* goals rather than *contradictory* goals.
The point he's making is valid: no language out there, Rust included, actually addresses precisely what the games industry needs from a C++ replacement. From long arguments with people in this community I've learned Rust is focussed on servers, which are a different problem. C++ has endured and we've ended up with a mix of languages.. C++ + lua, or C++ + C#. There's still a space open with the precise mix of features - it's somewhere between the choices taken in C++, Rust, and Swift, IMO. we'll probably continue with a mix of languages, I guess. A big barrier is bindings to existing libraries too. in the world of servers/web applications i guess it isn't as much of an issue, because they're exchanging data more? not shipping compiled programs?
&gt; because you can statically analyse C++, Not close to the same degree as Rust offers: I find it hard to believe that there is a tool that can catch most dangling pointers and iterator invalidation in C++.
&gt; From long arguments with people in this community i've learned Rust is focussed on servers This isn't true, e.g. Mozilla is interested in Rust for browsers, that is, client-side applications.
&gt; It's true that sometimes we have to chase horrific bugs, but considering that we're working on the least safe language in the world, I'd say we're not doing badly. My theory is that the only reason many C++ applications seem to be memory safe is because no-one's bothered to attack them. Even important applications run by highly security conscious teams (web browsers and operating systems) have memory safety problems: imagine what the situation is like for smaller applications without security teams?
Thanks for that. Fixed it.
Rust has official nightlies for some time now.
I think /u/Jurily is suggesting weekly "snapshot" releases that people can standardize on, so most libraries will compile that version. Currently there's a bit of a spread of which exact nightly a library will compile with (e.g. it might've been updated for the nightly 3 days ago, but the one 2 or 1 day(s) ago breaks it).
Thank you. It's fixed.
ok, point taken - there its different again: a browser seems to be a hugely complex application with a dynamic data structure (with just about everything controlled across the internet). It seems the demands are slightly different.. even though there is a big enough overlap that Rust is on the gamedev radar. 
Yeah, I agree with that, especially doing explicitly versioned upgrades.
I only recently got interested in Rust. I know it's not yet production ready, but I was wondering if http://rustbyexample.com/ gets updated as fast as the language changes. (I've seen some of the commits to that repo, and can't remember things like the removal of @ )
bors tests everything that lands on master though!
It doesn't test external libraries people are writing.
&lt;@3
&gt; I was wondering if http://rustbyexample.com/ gets updated as fast as the language changes Currently it is: https://github.com/japaric/rust-by-example/commit/f1b9bde820100e442bc238b7555102d0953a647d
Previously this was possible, but now because of the _stronger guarantees_ I need to copy everything first. Is there any better way to write the following? struct A { a: u8, b: u8, } impl A { fn alter_a(&amp;mut self, c: u8) { self.a = c; } } fn main() { let mut variable = A { a: 1, b: 2, }; variable.alter_a(variable.b + 5); }
 let x = variable.b + 5; variable.alter_a(x);
For small cases this is acceptable, but in my gameboy emulator this meant I had to write `let oldregs = self.reg` and be extra careful I did not use `oldregs` when a register was modified. If I did it that way I had to insert extra `let` statements on about 256 lines. It currently works, but I liked the previous code I had written a lot more.
&gt; What he says about Go however is strange. Go just isn't expressive enough to be interesting, and its' GC. Rust is definitely way more interesting than Go. Well, as a game dev myself, I find Go way more interesting than Rust. The productivity gain you get by switching to Go is massive. It's a language designed to minimize "programmer pain". GC is not really that big of a problem with games as somebody seem to think.. games have very predictable memory patterns and tend to work with preallocated buffers of memory anyway. What's killing Go at the moment for game dev is the high cost of calling into C, and that, sadly, is not something that's going to change anytime soon. Rust is adding a lot of complexity to solve problems that, as game devs, we are not really sensible to.. such as safety. Perhaps we are wrong in dismissing it.. but I don't think it's going to be easy to change the mindset of an entire industry. Also Rust is perceived as far far away from being ready for production. I think once a stable v1.0 will hit the internet things might start to change and the language will be taken more seriously as it happened with Go. 
I read this twice and still don't really get what they're asking for beyond C++14. Low cost, and "compelling for our use cases"? And their "best hope nowadays is LLVM" which is not a language. Confusing.
Couldn't the compiler even accept the original code here? As far as I can tell, reading `variable.b` should happen entirely before `alter_a` gets called. Maybe lifetime inference isn't sophisticated enough (yet)?
It seems to make sense that `variable.alter_a(...)` is evaluated left-to-right like other functions, i.e. it's like (I'm using UFCS for clarity) let x0 = &amp;mut variable; let x1 = variable.b + 5; A::alter_a(x0, x1); So the `x0` borrow conflicts with the `.b` read in the `x1` definition. I guess there could be special cases or the order-of-evaluation changed for method calls to evaluated the reciever last, or something like that. Not sure if these are good ideas.
Nice, will you put up some examples? Like maybe a simple echo server or something? 
The cost of calling into C with Go is the cost of obtaining a lock, so if you batch up work into fewer calls it would be usable. I'm also interested in seeing how to work with Go's GC to minimise its effects. For example, segmenting the work into several processes, so that each has its own (shorter) GC pause independently from the others, or maybe even disabling GC entirely if you know that you're reusing buffers and not allocating any more. The same approaches apply to Rust as well, in the sense that Gc&lt;&gt; will 'stop the world' only per task (once implemented), and perhaps in future there could be several cross-task GC pools. Obviously Rust is designed to have full control, whereas Go is designed as 'one size fits all', but the same considerations apply.
Yeah I realized the same thing after having thought about it for longer than two seconds. (But unfortunately by that point I was no longer at computer). It does seem obvious that this code *would* be safe as written, and Rust is being overconservative in this case. The question is whether there's some clean&amp;correct way to fix it that's worth the complexity tradeoff. Maybe some kind of rule that simple reads of variables happen before everything else, but you'd have to be careful not to hoist them before any side-effecting expression that might modify them. Maybe it couldn't be done simply, it's not really clear to me right now. 
I've read that Nimrod has a GC that is very amendable to tuning (as in: ensuring that GC pauses do not exceed X time).
It implements Drop so it destructs as soon as it goes out of scope.
Glad to hear it!
By low-level code, do you mean raw pointers, or something else? I can see why a moving GC would be problematic for code that touches/stores raw pointers, but apart from that I'm not really sure where the mismatch would come from. Can you elaborate a bit?
&gt; Gc&lt;&gt; will 'stop the world' only per task (once implemented) Is there any fundamental reason (apart from complexity) why `Gc&lt;&gt;` couldn't be concurrent or incremental? For example, having a Gc task paired with each `Gc&lt;&gt;`-using task?
RC is a form of garbage collection, and Rust has RC. That said, it maybe could be spelled out better...
I'm thinking 'Games' may be too broad a category. The game devs that I've talked to have thought Rust sounded excellent, but they also mostly worked at big studios. I'd imagine, like anything else, that AAA games with teams of dozens who are pushing the limits of hardware have much different needs than a one-person indie shop.
&gt; maybe could be spelled out better You mean at the front page? Yeah, I agree... Even though RC is garbage collection, I think that's not what most people think of when they talk about GC.
Author here - I think you're 100% right and I am VERY scared by C++, but for games, at least on the client side, we don't hold anything valuable really. We make entertainment, our code has to work for a few hours without crashing and do something compelling for the player, it's an art form where if we can be more productive we can actually do better games, while if we are much "safer" that yes, it's better in terms of programming and correctness, but it doesn't really make better games...
I didn't and I will not go into a critique of why C++ is bad, but I can easily tell where I'd like C++ to -go- and I actually wrote it quite explicitly. I (and I'm not alone) would give up all the crap they added in 11 and they are planning to add in 14 (and even the 2/3 good things they added in 11) for -MODULES- which are one (small) step towards faster iteration and better malleability. One of the big problems of C++ is complexity, and all the syntactic sugar that was added over the years just tried to hide complexity under the rug, while we actually would need stuff that reduced it. Modules would be one of the things that start going in that direction. Deprecating parts of the language would go in that direction too. I don't know why -NOTHING- in C++ can be -EVER- deprecated, even if all programmers, all coding standards, everybody avoids certain use cases they have to be still there or be the defaults. Yes we can use linters to "deprecate" whatever we want by simply not allowing it, with static checks, in the codebase, but still...
I know what you mean. Sadly, in my opinion, C++ is the only valid option for gamedev. Hope is on Rust indeed, but I'm quite skeptical about it. Rust changes too rapidly to judge anyway. Here's the problems/notes I see: 1. Exceptions is a major feature failure in C++. They add a requirement to write exception-safe code and there is a small performance hit. I don't know anyone who can write exception-safe code properly. If you avoid them - you can't use libraries which use exceptions. That's a major divider in the community. D falls into the same trap, but even worse it adds garbage collection. Exceptions do work better in a GCed environments though. That is also a reason why STL sucks, there are others, but that's one of them. 2. Major win of C++ (people tend to forget that) was and is direct compatibility with C. The worst useless activity in the world one can imagine is writing bindings and glue between two languages. Of course it's a bane of C++ as well, slow compilation, we all know it. It's not even about compilation per-se, but about partial compilation. C++ just does too much to recompile a small chunk of code that was changed. Bjarne gave a hope that they'll fix this eventually. 3. Tooling. That's one of the most important parts of the language. C++ is not the best example, but over time we obtained enough programs/utilities for everything. Many people emphasize memory leaks and memory-safety problems with C++, but let's be honest, today with LLVM's sanitizers (which are available in gcc as well), with tools like valgrind and many other things we know how to work with this stuff. Having the right tools helps a lot with any language. The only language which explicitly beats C++ at that is Go at the moment. We have amazing static analysis tools for C++ and more to come. We have great IDEs (Qt Creator) and they'll become even better. We have a lot of useful stuff which will be thrown away by moving to another language. A proper C++ alternative needs to offer a lot outside of the language. 4. While people tend to hate C++ for having all the features in the world, you can look at it as a valid way to grow. Eventually with time, trial and error, we will discover the set of features we absolutely need. I don't think we're ready to answer that question and solve that problem. We don't know how to write programs properly and we don't know what features we actually need in a language. Also it's a per-domain question. I'm talking about gamedev just like you do. I see this one as a form of self-torture, we as human beings need that, it's the only way we can evolve. If someone invents the "right" language for us with just the "right" set of features, where is the place for evolution? C++ is a good canvas for programmer evolution, I don't think I could ever be what I am now without learning all the crap in C++. I hate C++ though, but that's irrelevant. What I'm trying to say is that there is no replacement for C++ right now and it won't appear soon even if there will be many good candidates. Only time will tell. At the moment we can choose two paths: try to get even better at writing C++ (how about writing quality libraries?) or take a step on the road of new languages and keep walking there faithfully. I tried both, not sure which one is mine.
This looks interesting, but seems like it shouldn't be necessary to use a library like this to get something resembling a stack trace when a task fails.
It's more an idea for adding details to your unwinding that can be programmatically processed by the recovery code, add annotations to error logs or whatever. You can already get a regular stack trace by setting a breakpoint at `rust_begin_unwind` and probably a few other ways, no extra machinery needed.
I agree, I suck at writing :)
Reference counting can be a large part of a garbage collector implementation, but Rust doesn't use a cycle collector to collect unreachable reference cycles, which are certainly garbage.
If you consider `Rc&lt;T&gt;` to be garbage collection, then Rust's scope-based destruction to be garbage collection whether there is a single owner or more than one. It's not a fully automatic memory management solution like a garbage collector as it doesn't collect unreachable cycles, which are certainly garbage.
&gt; The cost of calling into C with Go is the cost of obtaining a lock, so if you batch up work into fewer calls it would be usable. It has a far bigger cost than grabbing a lock. It needs to switch to another stack for the C code, which results in very poor data locality. Rust used to experience the same performance hit from stack switches when it used segmented stacks, even though it didn't require locking.
&gt; as in: ensuring that GC pauses do not exceed X time It can only provide strong guarantees if there are no cycles.
Rust values drawing a boundary between memory safe and memory unsafe code. It doesn't intend to make writing `unsafe` code any more painful than it is in C++.
Isn't there a way to just define the evaluation order so that this still has the same guarantees? variable.alter_a(variable.b + 5); Simply read `variable.b` first, then `variable.alter_a` and call it.
&gt; Exceptions is a major feature failure in C++. They add a requirement to write exception-safe code and there is a small performance hit. I don't know anyone who can write exception-safe code properly. If you avoid them - you can't use libraries which use exceptions. That's a major divider in the community. D falls into the same trap, but even worse it adds garbage collection. Exceptions do work better in a GCed environments though. That is also a reason why STL sucks, there are others, but that's one of them. Rust has unwinding but not catchable exceptions. Correct code doesn't need to provide any exception safety guarantees beyond not being memory unsafe if unwinding can happen and not leaking. &gt; Major win of C++ (people tend to forget that) was and is direct compatibility with C. The worst useless activity in the world one can imagine is writing bindings and glue between two languages. Of course it's a bane of C++ as well, slow compilation, we all know it. It's not even about compilation per-se, but about partial compilation. C++ just does too much to recompile a small chunk of code that was changed. Bjarne gave a hope that they'll fix this eventually. Rust isn't source compatible with C, but it's more binary compatible with it than C++. A Rust `struct` is still guaranteed to be ABI compatible with C (with `#[repr(C)]`) even if it has private fields, and there are no virtual methods as part of objects. &gt; Tooling. That's one of the most important parts of the language. C++ is not the best example, but over time we obtained enough programs/utilities for everything. Many people emphasize memory leaks and memory-safety problems with C++, but let's be honest, today with LLVM's sanitizers (which are available in gcc as well), with tools like valgrind and many other things we know how to work with this stuff. Having the right tools helps a lot with any language. The only language which explicitly beats C++ at that is Go at the moment. We have amazing static analysis tools for C++ and more to come. We have great IDEs (Qt Creator) and they'll become even better. We have a lot of useful stuff which will be thrown away by moving to another language. A proper C++ alternative needs to offer a lot outside of the language. This is a strange point, because C++ has always been a language with poor tooling. Even with modern clang-based editors, the tooling is still far behind a language like Java. Your mention of Go as the *only language* with better tooling makes it obvious that you're speaking from ignorance. Sanitizers and Valgrind are only able to catch a subset of memory corruption issues and only as they happen. If you need to use those to catch some of the obvious errors after the fact, you've already lost the battle of writing secure code. A clever attacker will always find somewhere to attack that the developers didn't battle harden with creative fuzzing work. &gt; While people tend to hate C++ for having all the features in the world, you can look at it as a valid way to grow. Eventually with time, trial and error, we will discover the set of features we absolutely need. I don't think we're ready to answer that question and solve that problem. We don't know how to write programs properly and we don't know what features we actually need in a language. Also it's a per-domain question. I'm talking about gamedev just like you do. I see this one as a form of self-torture, we as human beings need that, it's the only way we can evolve. If someone invents the "right" language for us with just the "right" set of features, where is the place for evolution? C++ is a good canvas for programmer evolution, I don't think I could ever be what I am now without learning all the crap in C++. I hate C++ though, but that's irrelevant. Rust isn't a language developed in isolation. It builds on the foundation developed in C++, ML, Haskell and other languages. It has been quite malleable for the past few years, and has undergone transformative changes.
Just reading this headline made me think that perhaps the project should officially put more weight behind efforts to curate [stackoverflow](http://stackoverflow.com/questions/tagged/rust).
&gt; Deprecating parts of the language would go in that direction too. I don't know why -NOTHING- in C++ can be -EVER- deprecated, even if all programmers, all coding standards, everybody avoids certain use cases they have to be still there or be the defaults. This is one of the worst parts of C++. I hope Rust doesn't follow in the same footsteps.
Hey /u/polyfractal, thanks for linking to my site!
I somewhat agree, though if I had to formulate a wish it would personally be "get rid of undefined behavior". Modules only come second on my list ;)
I am not too sure I understand exactly what you mean by *curate* (French here), would you mind explaining what you wish for ?
Undefined behavior is often sane and reasonable, it's one of the few things that C really conceded to performance... Now of course it depends, there is some undefined behavior that is just historical due to CPUs that didn't settle on how to do certain operations, that could probably be lifted or updated, but some other things like int overflow allow optimizations that wound't be possible without
A garbage collector doesn't have to be perfect to be a garbage collector.
Well, let me ask you this then: What are the chief criteria that make for a suitable replacement? Is it feature rich, easy-to-learn, statically verifiable, and/or good for making fast solutions? If you ask me Go, Rust, and D all tackle a host of problems from different angles. I would personally put Go at the head of the pack for solving the business and learning issues first. D is clearly the "does everything C++ does but better" solution, which solves any problem by being supremely flexible. Rust seems like it's positioned in-between the two to me, but I haven't used it in a while (specification is still in flux).
I think in games the main leverage you can have for a language investment is time savings, and they have to be huge. Familiarity and interoperability is needed not only to deal with legacy but also because of turnover, new hires and so on. While you can get productivity out of better languages with neat features and less bug prone semantics and so on, I never saw something that does make an order of magnitude difference while being C/C++ "compatible". That's why I advocate live-coding and zero iteration times as more important than expressiveness or any other fancy language feature. That's for example why we use Lua. We don't use Lua for -any- of its language features, at all. It could have been gwbasic for what we care. We use Lua because 1) it's a interpreter written in C, so it will work on any platform we use, present and future, and it's quite easy to integrate with C/C++ code 2) it allows livecoding 3) it's the fastest language that fulfills 1 and 2 we know
You kind of negate your own reasoning with this comment. You say as long as things don't crash, then you're good, but things don't need to be "safe". That "safe" part protects you from the crashes that you say are you're only concern. If the language prevents you from making the errors in the first place, it free up the developers time to deal with other non-crashing bugs like gameplay issues or the netcode (commonly the worst part of games). "safer" code is better for reasons beyond the correctness/programming circle-jerk you often here it discussed in. 
I actually like UB and not even for performance-reasons: Almost everything that is UB is also truly awful style; UB creates a simple argument: “The C++-standard strictly disallows this” which should end every discussion on the spot. For instance: Java programmers might feel tempted to check for integer-overflow like this: int x = 100000; int y = get_positive_int(); int z = x + y; if (z &lt; 0) { // overflow } Which is totally non-semantic; C++ just says: “Thou shall not check for integer-overflow like this! Otherwise prepare for nasal demons!” In C++ you **must** write something like this: int x = 100000; int y = get_positive_int(); if (INT_MAX - y &lt; x) { // overflow would occur panic(); } int z = x + y; Which states the actual intent better.
No, I say that they have not to crash for a bit, I mean it's not -critical- that they -never ever- crash and don't have to stand attacks and so on. They have to be correct "enough" but it's not as critical as in other kinds of applications. Of course games have to work and work well enough not to piss players, don't get me wrong, we know of games that tanked because they were poorly made... And of course a language that e.g. kills nulls helps not only avoiding null-related crashes but also wasting time chasing them, I agree, there is an increase of productivity from having less bugs to squash to ship a game in a good enough, enjoyable state. But then that is the point, the metric is strictly how much time you save. If you save less time than it's needed to code for example with these extended correctness measures then it's mostly a loss. And when you look at different possible language features the metric should be "time saved", safety might save some time but does it save it more than a less safe language for example that allows live-coding? That's all. Of course ideally I want them all, a beautiful language with live coding and zero possibility of creating bugs, I'm just setting priorities and metrics.
Oh I don't think you'd find much disagreement about the shortcomings of C++ since it has so many. :) (Speaking as someone who spends every day writing C++.) I guess I was just expecting a wishlist of what would constitute your ideal C++ replacement. I definitely agree that modules would be a huge step forward. However, it does have implications far beyond the language itself, since it impacts how 3rd party libraries are built and distributed, how IDEs and editors manage your code, and how lint tools and other parsing and processing tools work. So even once the feature is in the language, it will likely be a very long time before it is fully supported. I expect this is why it is taking so long to get through the committee - they want to get it as close to right as possible the first time. However, I disagree that the new features in C++11/14 are crap. Features such as smart pointers will save huge amount of time spent debugging leaks and memory problems. And lambdas can make code more maintainable by keeping small pieces of functionality where they are used. There is no doubt C++ has suffered from enormous complexity. Few language features have been deprecated (if any - can't think of one!), however there have been some library features deprecated. I expect there is considerable pressure against deprecation simply because of the many millions of lines of code that might break as a result. Backward compatibility seems to trump nearly all other considerations (for better or for worse). As a long time C++ developer who has been experimenting with functional languages recently, I have found Rust to be an extremely attractive alternative. It has low level control when you need it, a very powerful type system, loads of compile-time checking, safe memory management, and great concurrency support. I have already written some numerical processing and graphics code in it, and have been very impressed so far. It seems to come closest to a C++ successor thus far, although Swift is also looking very interesting.
I can definitely see the attraction in using something like Lua for scripting on top of a C++ engine, having written numerous similar systems (but with Python). I don't really see how you could combine them though, without compromising away some of the advantages of each. I have been experimenting with Swift lately, and have been very impressed. It is fast to build, fast to run, has a huge, rich set of frameworks, can perform low-level processing as well as express high level functional features. It does have unique pointer support (used for interfacing to C libraries; see the libc bindings for example) but it is not the native/default mode of operation. I haven't explored raw buffer access for image processing yet, so not sure how well suited it is. I've been using Rust on and off for a while, and it is definitely my favourite alternative systems language. I have great hopes for its future.
As both a Rust enthusiast and a ~~stalker~~ fan of your work overall, both in code and in prose, I've to say I'm quite happy with the news :)
Hehe, thank you!
If you are writing your own abstractions, like `Vec` and `Rc` in the standard library, then you have to be mindful to ensure it is correct in the face of all the various language features, e.g. failure, satisfying mutability/aliasing rules, and, if implemented, GC (which is likely to be far more complicated than the others, especially in terms of support being zero cost).
Congrats! Does this make you a mozillian?
+1, this has definitely been a pain point for me, stopping me from upgrading my own libraries to the latest on master. I end up upgrading, and finding out some dependency is failing due to the latest few commits to rustc - then I end up upgrading other libraries to get mine working - inevitably redoing what somebody else was already doing. :) Having a weekly release would alleviate those issues a bit. Standardizing on Tuesday's or Friday's nightly release, or something like that, works just as well, if everyone remembers to actually do that.
Just make sure it's going to be easy for everyone, programmers, and people that are learning a programming language for the first time! :D
Nice work. Hopefully the language won't change that much more (well, on the contrary I hope it continues to change as much as it needs to) so that you won't have to re-write too much of your work. You'll be clarifying the manual's description of unsafe blocks, right? ;)
I agree, I want the language to change as much as it needs to. At least now, if I have to re-write things, it'll be helping to pay my rent rather than be just a chore. &gt; You'll be clarifying the manual's description of unsafe blocks, right? ;) Hehehehe!
&lt;offtopic&gt; Gosh, that Kudos thing is distracting and frustrating. I wish some other thing less prone to accidental events and more reversible would take over.
You're a contributor, so you're a Mozillian! :)
The real problem is it's in an aliased location (imagine how many people could be reading the page at once?!?) and yet it can be freely modified, and that always makes Rustaceans a little nervous... I hope it's using [`Unsafe`](http://doc.rust-lang.org/master/std/ty/struct.Unsafe.html) internally? ^^^:P
I think it's quite true that in many domains safety doesn't matter that much. That, to me, is why I've been serious when I say "it might be interesting to create a language that's like Rust but isn't safe". At Mozilla we care a lot about making a language that's memory-safe, period, because browsers are literally your "user agent" on the Web—if you don't trust your browser, you trust nothing. We write software that millions of people use and that thousands of people try to attack every day. If your browser gets compromised, thieves can empty your bank account or dissidents in repressive regimes can be thrown in jail or worse. So our safety requirements are not quite the same as those of game developers, for which safety is mostly about trying to prevent cheating, piracy, and annoying crashes. It will be a challenge to make our language useful for game development as well, but I think that Rust might well be a language that's good for game development, if we can polish off the safety features well enough to make them so convenient you don't get annoyed by them and that they don't limit you. That will not be easy, but I think it's worth shooting for, because it'd be a huge advance! Ultimately I would like the lifetimes and borrow check to become something that just enforces the same patterns you would do in C++ anyway. It may not come in 1.0, and I can't guarantee that it's possible to get there, but we'll keep tweaking the system in pursuit of that ideal. I would love it if Rust's safety features merely codified the patterns you were already using to stay sane in C++, so that they didn't feel limiting—they just felt like "C++ on Rails". That goal will be my #1 priority once the language is stable.
I'm very happy to spend time going over old stackoverflow questions/answers to update them (or at least put big "this is outdated/irrelevant" warnings). I think /u/kibwen is also interested in doing this. ... But only once we're really close to 1.0 and the edits won't go out of date too quickly.
I would be ecstatic if there was enough documentation to justify a dedicated channel. We'll see. :)
I'll be the first to admit to investigating what domain it was hosted on, so that I could block it. (To any interested readers: I've never seen it hosted on a third party domain. \*twitch\*)
It's a Svbtle feature, so I doubt you'd see it anywhere else.
Ha! I don't use Sphinx all that much, but we were talking about it at one point. Why the hate? I don't plan on significantly changing the current tooling unless I have a strong reason to.
I'm very much looking forward to the output of this. So many areas of confusion remain for me (as an avid fan of C and C++): * lifetimes (argh, that quote notation is scary) * multi-process or multi-thread - are there synchonisation primitives, some examples of using channels to solve problems in classic worker models would be very interesting * strings - oh dear lord strings - they are bread and butter to so much - and handling raw byte blocks also very very important * collections - map, vector, deque - simple examples of iterating * inheritance - are there virtual functions, or overloading, or ... and public/private... and exactly how can pass-by-value of structs (particularly structs within structs) ever be a good idea in function calls... Oh - can I make one comment about the API docs - on the left hand side it lists libraries, but when I click on a library, I want to see all the methods on the left-hand side too - not wade down pages to try and find a suitable function name. Documentation is going to be a critical function in the early days - especially while there are no auto-complete editors available for Rust. People will need to gain strong familiarity with the capabilities of various libraries to take full advantage. And macros - how are they defined - they seem like game cheats at present to me. That and those hash pragmas - oh dear - oh dear - such a nightmare. Well - I just want to encourage you with the documentation effort. Good on Mozilla for paying somebody to do it!
&gt;&gt;It does have unique pointer support (used for interfacing to C libraries; see the libc bindings for example) what types am I looking for? I've seen UnsafePointer&lt;T&gt;, but it doesn't seem to clearly do everything needed, can you clarify? It wasn't clear to me that the C interface stuff could do much beyond 'interfacing to C'. Also, I didn't get the impression it can do what Rust/C++ can - create wrappers for unsafe code that are natural to use. I'd love to be wrong on that because the rest of the language looks excellent imagine a minimal sample of C++11, Rust, .. is there something showing how to do various things in swift. can you write Swift functions that are 1:1 translations of equivalent C, like you can in Rust unsafe {} blocks? ... like loading a binary blob and providing accessors that reference language objects within that blob .. placing different types sequentially in the same allocation &gt;&gt;I don't really see how you could combine them though, without compromising away some of the advantages of each. the idea would be compromising the Lua dynamic type stuff, to prioritise its efficiency: only allow what looks a bit like dynamic typing to the extent that it could be inferred at compile time. I think a barrier in C++ is the extent to which the syntax is hostile to parsing, where changes in one set of definitions modify how the syntax of another is actually interpreted. Think back to when Rust had ~ ~[] and @ ... you could write code for the most common types where the specification of pointers/collections 'melted away' sufficiently behind your identifiers, and at a glance it could almost look halfway between C++ and a 'productivity language'; I'd wondered if that syntax could have been kept and then customised for more control in a similar manner to overloading. Controversial though, there were many opinions that the different pointer types made it confusing.
+1 for mentioning GOAL. low level and game scripting in the same environment. I think you could do a lot better with a modern language (like Rust or Swift) with type inference.
&gt; Yup! The biggest one is what's last on my to-do list, and that's to get every single standard library method to have an example along with it. It's one of the easiest and most valuable ways for people to contribute, and it's last on my list. Mostly, because it's easy for others to do. :) Ooh, good to know. I'll start to contribute examples, since they really help me learn. And as you said, fairly simple to contribute. Thanks for the suggestion!
`#rustdoc-wg` is long-dead, since the rustdoc rewrite finished over 6 months ago.
lambdas are very nice
That is how I heard of Rust, I was talking to a freind about how my ideal language was c+generics+interfaces, and he said "try looking up rust on reddit"...
&gt; In C++ you must write something like this: And if you forget to write something like that... you've got a possibly broken &amp; vulnerable application. (C/C++ compilers don't/can't really help with avoiding all UB.)
The original times was essentially just fn times(n: uint, f: || -&gt; bool) -&gt; bool { for _ in range(0, n) { if !f() { return false } } true } so, yes, no iteration index.
I just find it way too hard to navigate and find what I'm looking for. The search is crap. The sidebar is useless. There's way too much on one page. I don't know if it's a limitation of Sphinx, but none of the function arguments are documented in the Python docs. Return value? Nada. All around crap.
A thin `Makefile` over `pandoc`: https://github.com/steveklabnik/rust_for_rubyists
Gotcha, thanks!
Thanks so much for the suggestions, I agree with basically all of it.
Ah thanks. For some reason I didn't think RfR was on github. I should have checked.
It wasn't originally, but then I ended up open sourcing it around the 0.8 release, I think. I abstracted the tooling by itself, too: https://github.com/steveklabnik/words
Serious question: it sounds like you're a busy person. I know you're continually working on a rails book, rust, this... Etc. How do you find the time? Are your strict about scheduling your time? 
Why toss away useful information! Yeah, there's no way to do exactly what times did with for loops, since you can't have `for iter { ... }`
I wrote a blog post about it! http://words.steveklabnik.com/how-do-you-find-the-time More seriously, I worked 30 hours a week through high school, and 40 hours a week through college, so my idea of 'normal' is a 70-80 hour week. I actually feel like I'm a colossal slacker :( Also, remember that most of my work is significantly more visible than someone who works on closed source all day. Almost nothing I do is closed. So it appears like I do a lot more, but that's just due to visibility. As an example, right now it's almost 11pm, but I'm in the park, hacking away on my open source Rails app that I want to finish up this week. I woke up at noon today, but that means I'll probably be working on random things till two or three AM probably. Oh, and also, I can only be so productive BECAUSE I have so many projects. If I had to do the same thing all day every day, I would produce significantly less. It's almost like 'structured procrastination', if you've heard of that.
Wonderful! &lt;3
This is a wonderful sign from Mozilla. I really enjoy your writing Steve, so I have great faith in this. 
Thank you.
I really hope unsafe doesn't change to trusted. I personally think unsafe perfectly gets across the idea that Rust is meant to be a safe language, and that when you're in an unsafe block you are not taking advantage of that. trusted definitely sounds like its a good thing, and I should be using trusted blocks because trust is good and i want my code to be trusted.
&gt; and people that are learning a programming language for the first time! :D You want the official Rust tutorial to explain what a variable is? And basic control flow like if-else? Please no. I think most programmers would find that very off-putting, and it'd be a waste of Steve's time. If you want to learn the basics of programming you can follow any one of the hundreds of beginner tutorials for Python or Ruby or Javascript online already. You can transition to Rust afterward.
You are awesome. Thanks for all the great work :)
&lt;3
&gt; This is a strange point, because C++ has always been a language with poor tooling. That's true, but I wanted to say that in C++ tools are getting better. The thing is, I'm not interested in many languages simply because they don't have properties of C++. Go was the first one I considered, therefore I've noticed its tool side and saw a broad field of possible improvements there (coming from C++). I am indeed a bit ignorant here, you're right. &gt; Rust isn't a language developed in isolation. It builds on the foundation developed in C++, ML, Haskell and other languages. It has been quite malleable for the past few years, and has undergone transformative changes. I'm not saying rust is bad, in fact it's the only candidate replacement of C++ in the area where my interest is. As I've mentioned it changes too quickly for me to judge. I read /r/rust and see all these "@" is now gone, "~str" is now gone, etc. Hard to see what authors actually want from the language, we'll see when 1.0 comes out. Hopefully it won't be like in D, where after 1.0 a second version appeared and now nobody really cares about D (I have such an impression). Not to mention that D actually has very poor performance in FP math area (https://github.com/nsf/pnoise), while some of its authors praise their compiler like the best in the world. I know it's just a single particular benchmark, but it speaks for itself. The only language which is a competition to C/C++ is rust at the moment.
IMO, expressiveness helps with something that is important in games: 'malleability'. being able to change as the design changes. this is where c++ scores well on some fronts: macros,templates,overloading; and badly on others - the frustrating asymmetry between methods/functions, and how headers impact refactoring, and the level of chaos possible with the macros when used badly. so I would say some aspects of 'expressiveness' contribute positively to productivity. Others (symbol definitions changing how the syntax works) damage it.
one idea that would interest me is keeping safe semantics but having a 'unsafe' build option that simply disables any runtime checks. Then the standard behaviour of rust becomes like what gamedevs currently consider a debug build. you can achieve some of this in C++ by having alternative versions of classes with extra checks in debug builds, reliant on all the operator overloading being there. (and divides check for zero..) I guess as Rust gets more cases of overloading handled, it would be possible to adopt the same strategy.. simply make an unsafe::Vec minus bounds checks. We can do this already with acessor methods (right?)
I agree that malleability is absolutely fundamental. But to me that's achieved only by reducing dependencies. If code is well isolated then changing a given unit, or how a given unit is implemented, doesn't affect other parts of the code. Code can rot and be replaced, reimplemented or iterated upon. In theory C++ should do that, in practice it's -incredibly- leaky. Classes expose implementation, STL and templates propagate implementation details across interfaces (in fact many enforce no STL in public interfaces) and so on, to a point that plain C with opaque "handles" is often a much, much better interface than what you can do in idiomatic C++. Malleability to me is not about being "generic" and abstract, it's about modules and interfaces.
I agree. Rust is aimed at a very particular domain which isn't necessarily for absolute beginners
Does rust use obj files or support any kind of partial compilation?
&gt; With this news I'll probably put Haskell on hold and start learning Rust Oh no, don't do that! :) Haskell is a wonderful language, and it will help you write better Rust code, too. I like "Learn you a Haskell" as an introduction. That said, I won't complain if you learn Rust. ;) &gt; walk-throughs Yup! I very much prefer this kind of tutorial, so there will be at least one.
Each crate is a compilation unit, so you only need to rebuild crates that change, IIRC.
Rust will follow SemVer very strongly, which means that 1.0 - 2.0 will be 100% backwards compatible. That said, when a theoretical 2.0 happens someday (I'm thinking on the order of a decade, personally), we can throw out all the stuff that we've found sucks.
&gt; It resteth in a box I lol'd.
&gt; Oh no, don't do that! :) Haskell is a wonderful language, and it will help you write better Rust code, too. Lol, some food for thought there.
Haskell and Lisp (any variant, maybe Scheme) are the two languages that I wish more programmers would learn. It really helps you write better code elsewhere, even if you don't touch them again.
A ``sleep 1;`` (or even sleep 10, if you don't mind the delay) in the loop would greatly reduce CPU utilization. That said, at least Linux systems have inotify/dnotify so you could get an update without busy-waiting.
Great that you guys are thinking about this. If [#6268](https://github.com/rust-lang/rust/issues/6268) would be fixed it would be even greater!
I'd venture to say that people should learn C before they learn Rust. C as a language is simpler to learn. The pain of manual memory management, dangling pointers, segfaults, etc. provide context for the complexity that Rust introduces to deal with memory management.
Noted and changed. Thanks for the input!
Ah, that's pretty much the same idea! I guess it's a different intention in that it dumps the gathered info unconditionally as it unwinds, and the inspiring blog post is about crashing early with as helpful a message as possible (and part of an interesting series!). Their macro is a bit neater too!
Still, it's your domain and does not appear to load from a shared Svbtle domain, hence no ability to block a third party domain to have it go the heck away.
I just modified your script to use inotify on Linux, should use less resources. https://gist.github.com/sankha93/3b1fed73c83b8ee9e661
Ahhh right.
I think the biggest issue for me with the rust stdlib docs is that when I'm on a particular type, I can't see all the methods that I can use on it. Javadoc (for example) isn't especially beautiful, but it is quite functional: I can easily scan a given type for a method that looks like what I'm looking for. With the Rust docs I have to scan through a tree of implemented traits.
Yes, precisely this. I know there's a function that tells me how long a collection is - but is it `length()`, `len()`, or `size()`? Time to get busy with the Pg Dn key!
Is there any value in considering an editable wiki where interested parties could make contributions (that could be rolled back)? A tutorial start page could be created with a list of topics to be covered and interested developers could then add to it - to be later frozen/moderated and style brought into line with recommendations.
My only problem was I once worked with a developer who loved Haskell. But he was an arrogant condescending talentless individual that went around mocking anybody that knew C. It gave me the impression it was a language for Computer Science types that had absolutely no interest in performance or computing history. I can't bring myself to look at Haskell and consider associating myself with such people.
For those who don't know what Rust-Empty is: It is a user friendly Makefile/Bash tool to set up your project according to 'best practices' so your library/open source project becomes easier to use for other people. Special thanks to zzmp for writing the 'watch' script. It feels so much nicer to being able to just save changes and doing the compilation and running done automatically.
My only qualm with rust is I wish they switched the 'char' keyword to 'byte'
You have `u8` for that. A `char` is a Unicode Scalar Value, see http://doc.rust-lang.org/std/char/primitive.char.html
Good luck!
I'm guessing you are talking about http://rustbyexample.com/loop/nested.html Then, yep, in _your_ example the labels are not necessary. But the Rust by Example one contains something else: The interesting part is not the labeled loop, but the labeled `break` in the inner loop: `break 'outer;`. This way you can break out of any number of nested loops, not just the inner most one. (Update: I'm not sure, but the `'` before a label might suggest the relation of a label to a "loop lifetime".)
That looks really slick, but it's not as portable. Want to PR it to a linux branch?
This is now available in rust-empty (an excellent Makefile) as `make watch`!
[Indeed!](https://github.com/rust-lang/rust/wiki/Meeting-weekly-2013-04-01#prefixing-labels-with-) 
Looks good! but perhaps this: params: HashMap&lt;String, String&gt; should have a vector/array etc. as it's second parameter, i.e.: params: HashMap&lt;String, Vec&lt;String&gt;&gt; to avoid overwriting parameters: `/path?a=1&amp;a=2&amp;a=3` or am I missing something here :-)
&gt;To support unified interface over various RDBMSs, sql! macro would support a subset of standard SQL. I’m thinking about two DDL queries, CREATE and DROP, and four DML queries, SELECT, INSERT, UPDATE and DELETE. this is a very limiting restriction. i'd rather have a runtime error that says that some construct is not available rather than not having it available in the first place.
One thing I'm wondering, and this is kind of off-topic but what is all this syntax extension magic going to do to syntax highlighting of Rust code in text editors and websites? I mean it looks fine in this example but you could potentially do some really weird things with it. I guess you could disable syntax highlighting inside macros, but that would also disable it for nested rust code right? Are there any best practices for macros and syntax extensions that the Rust team recommends following? Would it be a better idea to have theses SQL queries expressed as strings?
Clearly we need refutable patterns in `for...in` bindings so we can write `for 1 in 10 { ... }` and have the block be executed with a 10% chance instead.
In all seriousness, allowing refutable patterns in `for` loops makes sense and is a cool idea, only iterating over matching values. So for Some(foo) in maybe_values.iter() { ...BODY... } would be equivalent to for foo in maybe_values.iter() { match foo { Some(foo) =&gt; { ...BODY... }, _ =&gt; continue } }
(The closing `)` of the `fn main()` broke the markdown link, you need to replace each `)` with either `\)` or `%29`.)
I'm mostly worried about syntax extensions breaking highlighting of the rest of the code. I don't know much about Rust's syntax extension so maybe I'm wrong, but could you potentially have unmatched ' or "s? As long as editors can figure out where the macro starts and ends without the help of macro expansion it shouldn't be a problem, right? Sub-language highlighting would be neat too but it's not my primary concern, though It shouldn't be to difficult given the "macro!" syntax.
Rust macros have form foo!( ... ) and does not allow unmatched parens inside the macro. So your syntax highlights out of the macro is safe, as long as your editor properly parses matching parens
This is really nice, I look forward to seeing this develop into a really useful library. I love everything being at compile time! Just a couple of questions: 1. Are `JOIN`'s not going to be part of the syntax? 2. Can we use the database type at compile time to extend the DSL for certain database engines only? Maybe using an argument to the sql macro and then getting rid of the prepare method? Also it might be a nice to add to the attribute a field for table name, instead of it just being Person every time, although definitely keep that as default. Thanks a lot for posting. 
As long as the myth that C and C++ are the ultimate languages stops, I agree. 
&gt; As long as editors can figure out where the macro starts and ends without the help of macro expansion it shouldn't be a problem, right? Yep, this is explicitly part of the design of Rust's macros: they have to tokenise and have matched delimiters so that the arguments are clear &amp; don't need any information about the macro to correctly compute (this also means the only unmatched thing allowed is a `'` (for a lifetime) which highlighters need to handle anyway).
I'm not so keen: it seems like it might accidentally lead loops not being executed as the programmer intended, in a way that is very hard to debug.
"I also hope that there's room in the bugdet to do one or two walk-throughs which will show us how to build a small application in Rust" I'm working on a book in that vein (in my un-copious spare time): https://github.com/npryce/rusty-pi Early days yet. But I hope to capture the way to think about problem solving with Rust and structure Rust programs. 
The query classes are not final and support for other vendor-neutral operations will be added incrementally. What kind of common SQL statements do you find missing?
No offense to the OP, but compile-on-save sounds like a script to slow down rust development :-)
Thanks for the reply, steve!
That was among my first thoughts as well. *But* a nebulous fear of accidental bugs can be associated with almost any feature. I think you need to demonstrate some kind of existence proof before it qualifies as a legitimate issue. Under what circumstances might a programmer wind up *unintentionally* using a refutable pattern in a `for` loop? (Does anyone remember having done it before?)
1. JOIN is going to be part of the syntax. I just omitted the explanation not to make the article too long 2. To generate the entire query in compile time, we have to know every supported database vendors during the syntax phase. This means we need to maintain white-list of adapters, which would harm flexibility too much. Supportig different table name other than the struct name is a nice idea. I'll include that in the sql_table args.
People do ask about why the compiler is complaining when they write `for Some(x) in ...`, often either not really understanding what's going at all (meaning the `for` loop sometimes not executing would just layer on even more confusion about `Option`/enums/patterns) or thinking that it would just break when it doesn't match (i.e. there's two choices for possible semantics here). Also, currently, `static`s can interfere with pattern matching, e.g. static a: uint = 0; for a in range(0, 10) { ... } will actually only execute the loop once, since `a` has become a pattern, matching against `0`. Naming conventions &amp; lints help address this (the static should be `A`), but they are (atm) just conventions &amp; lints, not something that's uniformly enforced. &gt; That was among my first thoughts as well. But a nebulous fear of accidental bugs can be associated with almost any feature. I think you need to demonstrate some kind of existence proof before it qualifies as a legitimate issue. FWIW, this is adding something Rust doesn't yet have anywhere (silently "failing" patterns) and, importantly, it has a simple, unambiguous equivalent now; so even somewhat nebulous fears qualify as issues that need explicit addressing. 
&gt; Also, currently, statics can interfere with pattern matching, e.g. Yes I think this is evil and should be removed :P Good points, however.
I agree that it can lead to ugliness in some cases, but matching on named constants is really useful ([example](https://github.com/rust-lang/rust/blob/feb294ca1125bda576552a71c11c44a820ef8b99/src/libstd/io/mod.rs#L315-L351): writing that as an `if`-`else` chain wouldn't be so nice).
Yes, this was the plan originally, but IIRC we couldn't find a way to make it unambiguous.
An `if`-`else` chain isn't the only alternative; the more "canonical" transformation is to just use `==` in guards: match errno { n if n == libc::EOF =&gt; (EndOfFile, "end of file"), n if n == libc::ERROR_NO_DATA =&gt; (BrokenPipe, "the pipe is being closed"), ... Not the prettiest, obviously. But maintaining invariants and the ability to reason about code should come before syntactic convenience. (Of course, this kind of invariant is currently broken in all kinds of places in current Rust, so it's a bit perverse to talk of "maintaining" it.) Other solutions might work too, such as actually segregating the namespaces of statics and patterns. P.S. I've been unable to figure this out, what types does the statics-in-patterns thing work for?
When I wrote the original `times` method all those years ago, I mused on the idea of making `for -2.times {` execute all the statements in the loop in reverse (twice). Fortunately, in addition to this being an awful idea, it is more-or-less impossible to implement (and I am lazy).
I have a question. I made a library using rust-empty by copying the Makefile, as suggested in the Readme. I made some changes to it, changing defaults, adding compiler flags, etc. Now the new version of rust-empty has come out, and I wish I could do somehting like `git pull` and `git merge` to incorporate it, but since I originally just copied the makefile, I can't really do that, can I? What would be the "best-practice" way of updating?
I actually don't know about that decade timeline for 2.0. If we're *actually* following semver, even the smallest BC-breaking change will require a bump to the major version. If borrowck or trait resolution or name resolution need a miniscule fix in order to maintain soundess, then **bam** you're at 2.0. It seems unlikely that we'd be so superhumanly thorough for the 1.0 release that we won't run across fixes of this nature. I'd put money on the fact that a Rust 2.0 will be out within two years after 1.0, but that the only breaking changes it contains will be itty-bitty tiny fixes that will have zero impact in practice. 
If you use the graphical interface of Github, you can select the lines you want to change and commit. Then you can right-click the 'Makefile' and select 'Discard changes'.
As dbaupp has mentioned, I've very interested in curating SO. However, it would be a futile use of our time while we're so unstable. As I've mentioned before, we'll need a period of stability *before* 1.0 in order to have the time to bring SO (and the rest of the internet) up to date.
The real power of SQL lies far beyond simple CRUD operations. IMHO, internal DSLs implementing SQL subsets always feel limiting, just like ORMs. And compared to an internal DSL, I would prefer a library that provides a simple unified interface to various databases (like JDBC/Python DB-API), which "speaks" plain SQL, while simplifying variable mapping and preventing injections. Something like [ScalikeJDBC](http://scalikejdbc.org/). EDIT1: Starting from version 1.6, ScalikeJDBC actually has its own internal DSL, but this DSL is built on the basis of the simple interface. Said interface is not an 'escape hatch'. EDIT2: Clarifications. 
I second this. I'd love to see something for regular types that you see on pages for traits: all of the methods are listed at the top.
If it helps, the people who hang out on the #haskell channel of freenode are generally the complete opposite of the person that you describe. I would [suggest stopping by](http://webchat.freenode.net) to ask about the language to get a feel for the community. I've found it to be a good group of people. Also, the reason that I want to learn Rust is to learn about the lower level details that are awkward to work with in Haskell. If anything, I would like to pick a c developers brain to get a better understanding of low-level details rather than laugh at them. I mention all this in the hope that it shows that every person who learns Haskell isn't an ass.
Upon reflection, I'll finish learning Haskell since I've already taken the time to get as far as I have and the Rust docs will take some time to write anyways. But I'll certainty be looking back at Rust soon. I really enjoyed the writing style of Rust for Rubyists.
The decade thing is me personally, I don't remember what the team has said. I _think_ it was nothing more than "a long time."
Thanks for the link, I've added it to my stash. One of the things I'd like to get around to one day is programming hardware, even if it is just to make a few lights blink a la the Altair
Seconded, and considering the similarities between Rust and Scala (especially Scala 2.10+ with string interpolations and macros), I would say ScalikeJDBC could be a great reference.
I came across a great static site generator called [Hugo](http://hugo.spf13.com) It parses markdown into HTML templates. You can create a server which monitors your documents and automatically updates the HTML upon saving, literally faster than you can switch to your browser and hit refresh. It's really nice for working with projects like Rust for Rubyists. P.S. I have no relation to the project.
I'm still confused. - Select the lines of what? the Makefile? On what page of github? In my project, or in rust-empty? - Why am I discarding changes? - Right now, github has no knowledge that there is any connection whatsoever between my project and rust-empty; I literally copied the Makefile, with no use of git. How do I deal with that?
I think we call those 'pull requests' :)
http://staticsitegenerators.net/ o_O Thanks for the tip though. :)
The problem here is that people tend to use the name "Rust 2.0" to mean "that Rust release when we'll finally have all the nice-to-haves like HKTs and TCE and datasort refinements and etc". But people just aren't used to the idea of a language being versioned with semver, and my concern is that we'll probably have to push out a 2.0 release long before those features are ready. We should probably come up with a different name to refer to the hypothetical "feature complete" release of Rust. How about "Rust 9000"?
Great! Short questions: Do you plan to replace markdown with something more powerfull and concise? I read chitchat about reStructuredText at some point…
That makes a lot of sense to me. Had I never fooled around with C, I wouldn't have enough context to see the advantages of Rust's approach to memory management
I don't plan on significantly changing the tooling unless there's good reason to. We were talking about that a bit at one point, but I'm not sure that it was convincing enough. We'll see. ReST is more powerful, but I also find it _significantly_ more annoying to write.
https://mac.github.com/ https://windows.github.com/ It allows you to select the lines in the margin in the diff viewer.
I think what he means is that you can copy the new Makefile from the new rust-empty release, drop it into your repository over your edited Makefile, and then use a git gui (like Github for Windows/Mac) or the git command line to accept changes to specific lines in the Makefile. After you've "accepted" the patches from the new Makefile that you want, you can discard the rest of the changes. The end result will be a version of the Makefile that incorporates the base rust-empty one, your edits, and then the new changes from the new rust-empty release.
The reason why labels contain `'` is that lifetimes correspond to blocks, so it's natural to label blocks with the same syntax we use for lifetimes.
Hm, so the closure you got there will have a invalid function pointer if it survives past the context there, right?
&gt; Having using Hibernate heavily in the past, I'm wary of any complex form of ORM. Hibernate has colored your thinking, other ORMs are much, much nicer.
I guess its just hard to get things like clickable references to Symbols (unless you want to hack links [Iterator](symbol:std::iter::Iterator)).
I'd like to be able to use a single query construction API (doesn't have to be a macro at all) to be able to deal with DBMS differences. See http://docs.sqlalchemy.org/en/latest/dialects/index.html for what I mean.
Also, you should be aware of sebcrozet's incredible [nalgebra](https://github.com/sebcrozet/nalgebra) library; it has many of the same aims as yours. There are others out there as well, but AFAICT nalgebra is the most well-developed.
You can add it as a submodule and then `-include` it in your actual makefile.
Yeah, libcore would need to have this implementation.
Java [has labels](http://stackoverflow.com/questions/3821827/loop-in-java-code-what-is-this-why-does-it-compile-and-generally-wtf), also. I don't think I've seen it in the wild, and I guess I've used it one time myself. 
I think a three-layered approach may work: Layer 1: A low-level, type-safe (for variable mapping), injection-proof generic interface to databases. ("DB-API with some SQL Alchemy Core features", but strong-typed, handy when vendor-specific features are needed. I actually prefer working directly with SQL if database-agnostic is not a requirement.) Layer 2: An expressive internal DSL which generates common queries across all databases. ("SQL Alchemy Core".) Layer 3: An ORM. ("SQL Alchemy ORM".) EDIT: Clarifications.
oh i didn't know it before! I'm actually a newbie to rust so I write the matrix library just to help me getting familier with rustlang :P
Ah. That... makes a lot of sense! Thanks!
Yes, that makes sense! I actually did the same thing before I stumbled upon nalgebra... either way, though, it is a great way to get used to rust and learn the features.
Oh, I certainly understand the *reasons* behind it. And I played enough with the LLVM optimizer to appreciate what it enables... ... but from the user point of view, it makes the code full of traps. Now, if compilers were capable of systematically warning of dangerous constructs, then I would have no issue with it. But of course it is undefined *because* warning about it is not always an option.
A similar, general-purpose utility for this is [entr](http://entrproject.org/).
To be clear, I don't have any problem with some constructs being forbidden by the Standard. That's what a Standard is for. I do have a problem with the fact that many of the forbidden constructs cannot be diagnosed accurately and thus end up in production code.
How would I create a composite primary key, or indeed any kind of primary key that is not an auto-incrementing integer? Does your representation force such a primary key to exist?
To be fair though, even compiling a single crate can take a few dozen seconds. I am used to C++, and yet I still found it noticeable when my toy project grew up (to a couple dozen files). It might be the price to pay for "whole crate optimization" though.
Oh awesome! Nimrod is super cool. Good luck!
Yeah, its a problem currently not expressible in Rust typesystem, I was just curious if you've found a workaround. :)
I think this is going in a really nice direction. I like the idea of the sql-like DSL, and the idea of inferring ColumnType and BindType is really cool. The closest thing I've seen to this is [the sqltyped library for scala](https://github.com/jonifreeman/sqltyped). It might be interesting to see how they've approached some of the design issues. 
It's worth considering the implications of defaulting Strings -&gt; TEXT datatypes. TEXT is usually slower, usually isn't indexable, and should generally be avoided unless you have to use it. You're probably going to want a typesafe way for people to define chars, varchars, and so on. edit: Secondly, I would _seriously_ consider creating the code such that you can return iterators over result sets from a function that creates a statement and performs a query, if that's possible: sometimes result sets are very large and you don't want to collect the results into a vector. I guess this would involve some sort of reference counting of result sets and statements?
Question: The nalgebra site says it uses the double trait dispatch trick to do operator overloading. Does that mean every usage of operator overloading will require two vtable lookups?
Well, that's mostly well above my pay-grade, but here's my sort-of answer in 2 parts: 1. According to my hunch and backed up by [this email](https://mail.mozilla.org/pipermail/rust-dev/2013-November/006967.html), I don't think so; for the most part, trait stuff is all resolved at compile-time. 2. If so, that trick is temporary. I believe the rust devs are still working on operator overloading, and long-term it will be allowed; sebcrozet keeps on top of stuff pretty well, so I imagine he'll clean up that portion of the code when regular operator overloading comes around. Hopefully someone with a bit more knowledge than me can back me up on both of those (or set me straight)...
Are `ColumnType` and `BindType` inferred by the compiler or by your syntax extension ? How do you plan to support row product (`SELECT a, b FROM tableA AS a, tableB AS b`) ? A very important feature (that you might or might not want) is to make sql requests *composable*. By this, I mean that you can write nested sql queries SELECT a, b FROM tableFoo WHERE c IN (SELECT d FROM tableBar) in this way : let query1 = sql!(SELECT x FROM tableBar WHERE x == {:s}); let query2 = sql!(SELECT a, b FROM tableFoo WHERE c IN {:query1}); The typing is quite more complicated but it's significantly more powerful and allows composition and reuse of queries. I think it's easier if you use a splicing operator instead of printf like notation. Something like `sql!(SELECT x FROM tableBar WHERE x == {:my_string})` and my_string is a normal identifier in the scope. You can let the user wrap it in a closure if he want. This way, you won't have to deal with the types of the spliced elements in `SelectQuery`, only the type of the output. If you want to go this way you can have a look at LINQ (I don't know how the typing is done) or [this ocaml library](https://github.com/ocsigen/macaque) (the DSL is horrible, but the typing is interesting). There is probably a similar haskell library, but I don't know it. I hope your type-fu is good. :p
I think there's room to add clickable references with Markdown by adhering to some sort of convention. In my own Python autodocumentation tool, I just look at whatever is between backticks, and if it corresponds to an identifier, the tool turns it into a link automatically. (I'm not saying we should do exactly that for Rust, but just throwing out an idea.) In general though, I'm pretty hard against reST. It's incredibly annoying to write *and* many of its benefits in, say, a language like Python aren't as big of a benefit in Rust (because of static typing and the presence of type signatures in a function definition).
Holy moly! There are more static site generators than there are [X window managers (~220)](http://www.gilesorr.com/wm/table.html).
Uuuuh I'm really looking forward to this! I want to learn rust, too. And as younsaid in the post, the tutorial is ... not really that helpful! Rust seems to have a rather complex syntax if you're coming from c and ruby (as I do)... so... I really hope the docs will get better! Thanks for sharing!
May I suggest a different approach? I think the drawback of the DSL you describe is that in trying to abstract out the differences between SQL servers, you lose the ability to use server specific features which are often the most interesting ones. What I would like to see is support for easily creating SQL queries and working with parameters and results. This would work without abstraction layer, i.e. the DSL maps 1:1 to a database specific SQL. You loose database portability, but that's not something I value as I usually don't switch implementation. But I get full control over queries and I can use all advanced features that are specific to the current implementation. This approach is taken by the salesforce.com Apex language. It allows you to embed SQL queries straight into the language, if you put them between square brackets. The query can refer to Apex variables directly from the query. Of all the ways I've worked with SQL (ORM, DSL and straight SQL query strings), this has been the most productive for me. See a link here: http://www.salesforce.com/us/developer/docs/apexcode/Content/langCon_apex_SOQL.htm I'm not familiar with the Rust macro system, but is it possible to automatically stringify tokens so that I could write: sql!(select * from table where id &gt; :foo) where :foo is a Rust variable, and it would create a query string for me and execute it? Salesforce has significant runtime support for determining argument and return types. I think it actually parses the SQL because it can give errors at compile time if e.g. you allocate the result of "select * from account" to a "person". Not sure how feasible this would be if you have to support &gt; 1 database.
That is on my wish list too https://github.com/bvssvni/rust-empty/issues/95 What about a script which you give a number (1 = up one directory, 2 = up two directories etc.) and then generates a list all the ln -s &lt;from&gt; &lt;to&gt; which you could grep and pipe to sh? Just throwing out some ideas.
Whenever I try with a custom type I get `error: non-constant path in constant expr`. E.g., having just tried it on the main rust-lang.org page: struct Foo; static FOO: Foo = Foo; // This code is editable and runnable! fn main() { match Foo { FOO =&gt; println!("yay") } }
Not to get too database-war-y here, but you'll miss out on some very important features like common table expressions if you limit yourself to what all databases including mysql support. That said, I suppose if it's feasible to do query composition the need for that feature sort of goes away, outside of the recursive query scenario. edit: It's also going to be basically impossible to abstract out the differences in support for DDL transactionality unless you only support auto commit after every statement for DDL operations.
If you want contributions it may be a good idea to enable the github issue tracker. But for now, would it be an idea to have Matrix implement Zero if T implements Zero? Edit: Maybe you can use types to do matrix multiplication and addition, something along these lines: https://gist.github.com/Thiez/df2072140f5483ff9105
Argument name primary_key="id" might be misleading here. What this argument means the field is auto-incrementing and we don't need to provide the value. Composite primary keys will be handled like other unique constraints: not handling at all after the schema definition.
Oh, yuck. There *does* seem to be a few weird error messages &amp; rejections with patterns, e.g. struct Foo { x: int } static FOO: Foo = Foo { x: 2 }; fn main() { match FOO { // FOO =&gt; println!("yay"), _ =&gt; {} } } compiles fine, but uncommenting the `FOO` pattern fails with: &lt;anon&gt;:3:19: 3:31 error: unsupported constant expr &lt;anon&gt;:3 static FOO: Foo = Foo { x: 2 }; ^~~~~~~~~~~~ i.e. weird error message (since it *was* supported 2 minutes ago) &amp; pointing at a weird place (since it's caused by the pattern specifically). There's a few related bugs: - [#6533](https://github.com/rust-lang/rust/issues/6533) - [#13626](https://github.com/rust-lang/rust/issues/13626) - [#13731](https://github.com/rust-lang/rust/issues/13731) - [#14576](https://github.com/rust-lang/rust/issues/14576)
I definitely like this approach.
What I mean is that I have the following table: CREATE TABLE Score ( user_id INTEGER NOT NULL, level INTEGER NOT NULL, when_achieved DATETIME NOT NULL, PRIMARY KEY (user_id, level)); How would this be represented in your DSL?
I plan to support table aliasing and multiple tables in the FROM clause. Nesting a query in another query is an interesting idea indeed. Nesting queries without bindings should be straightforward, but nesting queries with bindings must be a headache in current type system. I'll find if there is a way.
But then aren't you still paying for a function call?
Yes, you would be. Really, iterators are better anyway, and should probably be used more often. Then you don't pay any cost.
&gt; dynamic-dispatch 'virtual function' form a trait object IIRC, functions from traits are statically dispatched, not dynamically. And maybe they would be inlined, I'm pretty weak on some of the specific optimizations, to be honest. Hopefully someone who knows better can come in and clarify.
My first example was not really about the multiple table, more about the union of tuples. `a` and `b` are both tuples and you return the union, not a tuple of tuples. To properly do the nesting thingy, I think you need some form of structural subtyping (also called extensible records). I'm not sure if it's (or even will be) available in Rust. This feature is especially cool when you realize that, in SQL, every place you could put a table, it would be valid to put a nested sql request. Unifying those two at the type level is very nice.
&gt; brson: One think Niko brought up is that at the next workweek we can work specifically on ergonomics. We've spent all this time making the language consistent, let's spend some time making it usable again. While not really a usability thing, I'm curious, are there any plans to change Rust's syntax at this point in any way or are we looking at roughly how Rust will look post 1.0? I know there's a big push to get 1.0 done this year but I have to ask anyway, knowing that this whole post is going to be a highly subjective topic. As excited as I am for Rust, I can't help but feel like a lot of the type syntax in Rust makes my eyes retreat into my skull, even compared to C++, especially when it comes to Rust's generic syntax: impl&lt;K: Eq + Hash&lt;S&gt;, V, S, H: Hasher&lt;S&gt;&gt; HashMap&lt;K, V, H&gt; { Maybe I'm alone, but I find this hard to read. As far as I can tell, Rust's generics are they way they are because this way all path tokens can simply accept generics in the parser, which is clean and seems to just generalize over the whole syntax which is nice and consistent, but from a readability perspective (and I could well be completely alone on this) I feel like Rust is unnecessarily cluttered by things like this. There's no lifetimes in the above example, but things can get pretty hairy there too. TL;DR: Are there any plans to make Rust less terse or is this more or less how Rust will look post 1.0.
The locking dominates the other costs according to these pages: https://groups.google.com/forum/#!msg/golang-nuts/NNaluSgkLSU/kXskLTnBhtsJ https://code.google.com/p/try-catch-finally/wiki/GoInternals They lock/unlock twice (before and after). Without locking the cost goes down from 200ns to 40ns. 40ns is still a lot though and may be explained by the stack switching cache/prefetch effects you described.
Small function calls are easy to inline (and do get inlined now), meaning the function call for the accessor of a `Vec&lt;T&gt;` (`vec.get(i)`) optimises away. e.g. pub fn idx(n: uint, v: &amp;Vec&lt;int&gt;) -&gt; int { *v.get(n) } is optimised to the following by `rustc -O --emit=asm --crate-type=lib` _ZN3idx20h5f02302379758227eaa4v0.0E: .cfi_startproc [... snip ...] (split stack prelude) .LBB0_2: subq $24, %rsp .Ltmp0: .cfi_def_cfa_offset 32 movq %rdi, %rax movq (%rsi), %rcx cmpq %rax, %rcx jbe .LBB0_4 movq 16(%rsi), %rcx movq (%rcx,%rax,8), %rax addq $24, %rsp retq .LBB0_4: [... snip ...] (triggers task failure when the bounds check fails) .Ltmp1: .size _ZN3idx20h5f02302379758227eaa4v0.0E, .Ltmp1-_ZN3idx20h5f02302379758227eaa4v0.0E .cfi_endproc In particular, there's no explicit call to `.get`: it's all inlined (you can see the bounds check `cmpq %rax, %rcx`, and the actual indexing operation `movq (%rcx,%rax,8), %rax`).
Ah ha, thank you.
Yeah, 40ns is near the cost Rust had to pay for calling into C before dropping segmented stacks and getting down to the standard 1-2ns function call overhead. It's an enormous cost even for a function that's viewed as expensive like `malloc`, which has an average running time of 5-15ns with either jemalloc or tcmalloc. It meant bindings to C libraries could not perform well, and writing a competitor to every highly optimized library like BLAS and gmp is unrealistic.
There are no plans to change the syntax as such, but there seems to be a bit of agreement that our generic signatures can be a bit ugly and we might add something (either pre- or post-1.0) to make these nicer. E.g., `impl Trait` types as suggested by aturon or where clauses or something else, maybe.
Do you have any suggestions?
Yes, postponed issues may be reopened once we release 1.0. We don't really want to merge them, because the context will change a lot between now and when we reconsider.
For a makefile look into Rust-empty, I'm on phone so I can't look things up as easily.
Update: I've gotten higher order functions to work, as well as lambdas. http://a.pomf.se/phiyrm.png http://a.pomf.se/lubvnm.png http://a.pomf.se/ccquxb.png
Well, C++ doesn't have concepts, so it's not an apples-to-apples comparison to compare Rust's syntax for something to C++'s lack-of-syntax for it. I guess we could introduce `where` clauses to aid readability, but verbosity would increase.
I used to argue that guards were sufficient, but the community pushback was *overwhelming* and consistent. People really really expect to be able to match on constants. This is why you should use `ALL_CAPS_SHOUTING` for your constants, incidentally. Perhaps we should warn if you don't.
Bounds checks aren't the issue; the borrow check and lifetime annotations are. I think they're very valuable for us, but not everyone values safety as highly as we do. The challenge will be to get them seamless enough so that they aren't annoying to use even for domains in which safety isn't paramount.
Definitely agree about short signatures. They are very clear and I like the syntax a lot. Having said that, hitting the docs page for [HashMap](http://doc.rust-lang.org/0.10/collections/hashmap/struct.HashMap.html) and having a quick scroll is a minefield of similarly eye peeling signatures. I'd happily trade the short nice syntax if it means documentation for things like this overall improve. What would `where` syntax look like just out of curiosity? Is it something that would show cleanly in documentation such as that link?
so if I use types to do arithmatic manipulation, I must use types to represent the size of the matrices as well, like what was done in this gist (use Succ&lt;T&gt; type to add a column or row to the matrix). Am i right?
Change `.split(", ")` to `.split_str(", ")` `split` expects a `char` but `split_str` expects a `&amp;str`
Yes. I'm not sure if using those crazy types really pays off, and whenever you have a matrix where you do not know the size at compile-time, you will still need to use the approach you have already written. But at least (when the matrices are of known sizes at compile time) you never have to worry about adding/multiplying matrices of incorrect sizes, which is pretty cool. My first suggestion might be more useful.
Yeah, there's a lint for it (`non_uppercase_statics`), but it's allow by default, and it runs later than when it would be most useful (I've been wanting to split lints up to run in multiple passes for a while now... I'll have more time over the next month or so, so maybe then).
[Here is my take](https://github.com/rust-lang/rfcs/pull/122/files)
How would `where` work? 
borrowing from your Clay-like syntax above, what about: impl for K, V, H, S where K: Eq + Hash&lt;S&gt;, H: Hasher&lt;S&gt; HashMap&lt;K, V, H&gt; { ... } or alternatively putting the `where` further down: impl for K, V, H, S HashMap&lt;K, V, H&gt; where K: Eq + Hash&lt;S&gt;, H: Hasher&lt;S&gt; { ... } I actually really like this idea of separating the list of types from the list of constraints.
and num::Zero's arity is zero.So something like Succ&lt;T&gt; must be used to denote the size of matrix at compile time too.
To be honest, I think Rust's syntax is not the one to blame here, but the design for HashMap and hashing in general. The design is powerful and flexible, but in exchange it is complex. That complexity surfaces in the types, and it would surface no matter what their syntax was. (I'm not even remotely suggesting that the design is wrong, only that it makes this tradeoff.) Under a simpler, less flexible design, the line above would just be: impl&lt;K: Eq + Hash, V&gt; HashMap&lt;K, V&gt; { which is much less of an eyesore.
(`b":)"` would work.)
ah, i was missing something then :-)
Fair point, but it doesn't take much to get unwieldly. This is similar to your example but with a function and slightly longer trait names, which is not a particularly unreasonable design: pub fn send_data&lt;T, U:TotalEq + Validatable&gt;(data: T, extract: |T| -&gt; U) -&gt; Option&lt;Response&gt; { Either of the suggested syntax above are a bit cleaner, if a bit more verbose: [T, U | U:TotalEq + Validatable] pub fn send_data(data: T, extract: |T| -&gt; U) -&gt; Option&lt;Response&gt; { ... type &lt;T:TotalEq + Validatable, U&gt; pub fn send_data(data: T, extract: |T| -&gt; U) -&gt; Option&lt;Response&gt; { I assume `where` syntax will achieve the same effect anyway.
I'm coming from python, and a tid-bit java, what does this lifetime do? (I guess I wrongly learned lifetimes = scopes in this case. I understand the difficulties with lifetime in functions) It seems that in this case the lifetime is clear: the scope of the loop indicated by the accolades that form the loop block. This makes the single-tick seem superfluous. Or am I missing something? 
thanks!
Since variables can be redefined, how would one know if it's a pattern match or a redefined variable? Accidentally pattern matching when you intended a redefine sucks, it was the "feature" of Erlang I hated the most.
Would `b"☺"` work or is it only the 0-255 character range? Edit: seems like it replaces `bytes!(...)`. That should answer my question.
No offense, I see no value in this. 7 pages of "discussion" and they didn't even bother to open rust's home page
I´m disconcerted by just how much misinformation there is there, especially on the first page. At that stage, *none* of them have any idea at all of what´s special about Rust. (Later on I get the impression that one or two of them have a slight notion.)
Well on page 7 some still believe that static memory safety is not possible. Also still don't see any advantages over C++11
It only works with ASCII characters, that is, even unicode codepoints between 128 and 255 are not valid. Non-ASCII bytes require `\x8f` (etc.). fn main() { println!("{}", b'☺', b"ab☺cd", b'ö', b"aböcd") } Gives bytelit.rs:3:16: 3:17 error: byte constant must be ASCII. Use a \xHH escape for a non-ASCII byte: \u263a bytelit.rs:3 b'☺', b"ab☺cd", ^ bytelit.rs:3:24: 3:25 error: byte constant must be ASCII. Use a \xHH escape for a non-ASCII byte: \u263a bytelit.rs:3 b'☺', b"ab☺cd", ^ bytelit.rs:4:16: 4:17 error: byte constant must be ASCII. Use a \xHH escape for a non-ASCII byte: \xf6 bytelit.rs:4 b'ö', b"aböcd") ^ bytelit.rs:4:24: 4:25 error: byte constant must be ASCII. Use a \xHH escape for a non-ASCII byte: \xf6 bytelit.rs:4 b'ö', b"aböcd") ^ 
This is what makes us Swedes insane when it comes to text and computers... Edit: Yes, it's meant as sarcasm. Sorry.
ASCII wasn't chosen due ignorance (and not due to not caring either), it was chosen because it's the largest unambiguously "bytey" character set. Rust source is UTF8, so a character is a single byte if and only if it is ASCII, meaning there's no question that an 'a' represents the byte `97`. However, non-ASCII characters are ambiguous: a literal 'å' could either be the byte `229` (its codepoint), or two bytes `195, 165` (its UTF8 encoding).
Yeah, but then it wouldn’t be a char literal.
Thanks!
My previous reply was more of a general grumpyness towards the quite broken character handling as a whole. I know that it's a problem with every system and language, due to different encodings and stuff. It's nice to see that the compiler shows how it can be fixed, in this case.
Right, but it's misplaced in this thread because there is nothing broken here. Byte strings are for bytes, there are already string literals for text (supporting international text using the UTF-8 encoding of Unicode).
Yes, I forgot that sarcasm doesn't work on the Internet. I love that. Also, UTF-8 isn't perfect either, but that's an other story. Ok, serious question: what is the best way to convert a UTF-8 unicode string literal to a byte vector without doing the \xHH thing for international characters?
`"αβ".as_bytes()` for a `&amp;[u8]` slice or `"αβ".as_bytes().to_owned()` if you need a `Vec&lt;u8&gt;`. An allocated `String` also has the method `.into_bytes()` to convert into a `Vec&lt;u8&gt;` without copying or reallocating. The byte representation is the UTF-8 encoding of the original string.
Ok, thank you. Would have been nice with some kind of literal, but I can live with this. It's not that common, after all, since most programs are written in English, anyway.
These guys are anything but progressists. Don't even take the time to look at the damn thing for a second before bashing it.
That 'discussion' was/is really bad. Largely one advocate/enthusiast/proselytizer v.s. arguments like "uses reference counting for memory management" (well, the OP actually claimed that), "inevitable runtime overhead", "C++ can mimic that", "type system guarantees won't scale to larger than toy program", "static analysis is too expensive" (that's one big argument for making a new language rather than yet another extension to C++, anyway), "Why not just port the same features to the next C++ standard" (lol). You get much more high-level discussion on programming languages in more general communities, like /r/programming (though I guess there is more overlap between these subreddits than this subreddit and that forum). That C/++ forum seems a bit too insular for that kind of discussion. 
If you want more complete CSV support, take a look at BurntSushi's [rust-csv library](https://github.com/BurntSushi/rust-csv).
To be fair, static memory safety could mean anything, and the idea of compiler-enforced invariants doesn't seem to be popular with that crowd anyway ("I should be able to have a vector of objects with arbitrary different types! The language shouldn't get in my way!").
It's always interesting to peer into discussions in other places like this. I'm always torn: half of these people don't know because they haven't bothered to read, and half of these people don't know because we haven't done a good enough job of explaining things to them. Remember: these people are part of our target audience. I wouldn't suggest openly denigrating them. We'll get there. We have a long way to go.
.... :/ For posterity, this said something like "They should call it cmasterrace.org" originally.
It will decode automatically too! let mut rdr = csv::Decoder::from_file(&amp;Path::new("wat.csv")); for (float1, float2) in rdr.decode_iter::&lt;(f64, f64)&gt;() { println!("{:f}, {:f}", float1, float2); }
Let's be honest rather than glib: if there's a lack of information, it's at least partially our fault. We need to prove that Rust is useful, rather than expecting people to inherently and instantly recognize our goals.
I'm trying to give the benefit of the doubt. No one linked the home page, and the idea of a programming language even having a home page might be foreign to someone who only uses C. Neither C nor C++ have home pages. *Edit: OP actually did link the homepage*
Just one thing off the bat, but the style is generally four spaces, no tabs.
I don't think the author of that comment intended it in the way you describe. C++'s `std::vector` doesn't allow multiple arbitrary types within it. The remark itself was just noting how type systems *can* get in your way, in any language (including C++), and that the author values the ability to have a trapdoor.
&gt; Seems like a good way to learn what misconceptions about Rust need to be countered to market it effectively. Precisely. This is valuable data for our ongoing efforts to make the language more approachable.
https://gist.github.com/bonsairobo/a3d59eaceb80cc98e3ee#file-kmeans-rs-L23-L34 When you make an empty array, `for`, and then push to the array, you can replace that with an `inject`/`fold`. (I think we call it fold.) Using iterators is not only easier (once you understand the pattern) but is also faster, as it removes bounds checks in certain situations. The same is true of the `while` later in the file, as well, where you do your own loop counter. EDIT: while a fold does work here, since the output is an array, `collect` is actually more appropriate. I only had one coffee so far today, whoops! :p
&gt; I wouldn't suggest openly denigrating them. I wouldn't suggest privately denigrating them either! :)
https://gist.github.com/bonsairobo/a3d59eaceb80cc98e3ee#file-kmeans-rs-L71-L74 I think there might be a better way, but you can simplify this with http://doc.rust-lang.org/std/vec/struct.Vec.html#method.from_fn , I think?
I definitely agree with this.
Programming languages are a dime a dozen nowadays. It's entirely rational to expect people to dismiss us out-of-hand. The burden of proving Rust's usefulness is on our own shoulders.
That's true, but at least it doesn't make all of us look bad. :)
Well put. It's easy for us to forget what life is like outside of our little bubble.
Wow, you are incredibly lucky. I've had to deal with memory corruptions a couple times already, and they are no fun...
http://en.wikipedia.org/wiki/Principle_of_charity
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Principle of charity**](https://en.wikipedia.org/wiki/Principle%20of%20charity): [](#sfw) --- &gt;In philosophy and rhetoric, the __principle of charity__ requires interpreting a speaker's statements to be rational and, in the case of any argument, considering its best, strongest possible interpretation. In its narrowest sense, the goal of this methodological principle is to avoid attributing irrationality, [logical fallacies](https://en.wikipedia.org/wiki/Logical_fallacies) or falsehoods to the others' statements, when a coherent, rational interpretation of the statements is available. According to [Simon Blackburn](https://en.wikipedia.org/wiki/Simon_Blackburn) "it constrains the interpreter to maximize the truth or rationality in the subject's sayings." &gt; --- ^Interesting: [^Donald ^Davidson ^\(philosopher)](https://en.wikipedia.org/wiki/Donald_Davidson_\(philosopher\)) ^| [^Principle ^of ^humanity](https://en.wikipedia.org/wiki/Principle_of_humanity) ^| [^Ralph ^Johnson ^\(philosopher)](https://en.wikipedia.org/wiki/Ralph_Johnson_\(philosopher\)) ^| [^Epistemic ^virtue](https://en.wikipedia.org/wiki/Epistemic_virtue) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciatpyg) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciatpyg)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
ESPECIALLY for systems programming, where people have been saying "X will replace C++" for decades.
A downvote does not have my name and my flair attached to it. I don't want to move a number from -7 to -8, I want them to know that I personally disapprove of this kind of behaviour as a long-standing member of the Rust community.
I understand how to change the while loop to use an iterator instead. Would you mind explaining how to use fold to create the vector of lines from the reader?
Yeah, but it isn't you Rust contributors/users responsibility to tirelessly and respectfully respond to uninformed FUD. No one should be judged for being uninformed, and certainly not when it comes to things like this. But too many people in Web communities are all too glad to assert uninformed opinions that have no or very little research to back them up, instead of just asking questions or refraining from forming an opinion until they know more (or, simply leaving the issue be). In turn, people listen to them because they have authority in a related subject and think "well, I guess that puts that subject to rest then". I think some of the participants of that thread are examples of that. ...but for the people that have the patience to engage that kind of discourse; that's good on them, of course. 
The post reminds me of those gruesome college days where I was sitting in C++ irc channels and someone came in linking a description of a new programming language that was basically a pdf with a feature wishlist and C++-like syntax and no indication of even an effort towards an implementation. I can see how that sort of thing could be formative to C++ opinionhavers.
A 'fold' is an iterator which takes a list of somethings and turns it into a single something. The simplest example of a fold is adding a list of numbers: let mut sum = 0; let v = [1, 2, 3]; for i in v.iter() { sum = sum + *i; } // sum is now 6. The fold version: let a = [1, 2, 3]; let sum = a.iter().fold(0, |a, &amp;b| a + b); // sum is now 6 We start with a single value, the list, and a function. At each iteration, we take the value (sometimes called an 'accumulator'), an element from the list, and pass them as arguments to the function. The result of the function becomes the new value. At first, folds are kinda weird. After you use them a bit, they become _very_ natural, and much easier to understand. You can also fold over anything that's iterable, not just lists. For example, you could fold over a tree. Does that make sense?
Exactly.
&gt; it isn't you Rust contributors/users responsibility to tirelessly and respectfully respond to uninformed FUD. You're right, it's not our responsibility! But it's still our *problem*, whether we like it or not. And changing human nature is outside the scope of the Rust programming language. :) And given that I'm pretty shit at coding, let *me* respond to the FUD, so that you can get back to work!
&gt; And changing human nature is outside the scope of the Rust programming language. :) Shucks, some of us don't even believe in human nature in the first place! (that's quite offtopic...)
I've used fold before, but only with integers. Right now, I'm trying this line: let lines = reader.lines().fold(Vec::new(), |accum, line| accum.push(line.unwrap())); but I'm getting type mismatch errors. The type checker thinks that accum is unit type ().
That's because `push` gives back `()`. You need the function to return `accum`, not the result of the `push`.
 fn read_data_file(file_path: &amp;String) It's more idiomatic to pass a `&amp;str`. This also lets you avoid cloning the string on the next line (well, you could also just call as_slice() on it, but it should have been passed as `&amp;str` in the first place).
Well, it's not like it's 1990 and you can't use google (other search engines are avaliable).
And I commend you for doing it. And judging by the tone of some the replies you've gotten, it seems that you've got your work cut out for you. ;)
OK now I'm using this: let lines = reader.lines().fold ( Vec::new(), |mut accum, line| { accum.push(line.unwrap()); accum } ); Unfortunately, `lines` is empty after this.
Hmmm. That looks like it should work to me. Let me play around with it, and we'll see if anyone else chimes in. EDIT: Oh, also, rather than `fold`ing to a vector, `collect` might be more appropriate. Are you familiar with it? You used it once in your sample.
Thanks for the help :)
I'm sorry! It does work. I just forgot to comment out the previous method I was using, which exhausted the reader.lines() iterator.
Absolutely; sorry if I worded that badly. I meant that this thread was valuable *because* it shows certain messaging failures; for example, one person (supporting Rust!!!) apparently claiming that Rust is based on "refcounted smart pointers"... I think more emphasis on the "ZERO COST ABSTRACTIONS, HEY PEOPLE IT IS LITERALLY FREE EXCEPT THE COMPILER CAN TAKE SLIGHTLY LONGER" would be helpful. On a side note: I remember when I first heard about Rust and thought it relied on GC to do anything useful... I got involved when @ was removed and I realized references and ~/Box were a sufficient choice basically all the time.
Great!
Using `match` is perfectly fine, but you might be interested in `unwrap_or_else` because it's less verbose. Similarly, `collect()` is also less verbose than constructing a vector and calling push on it repeatedly. Here I'm also passing the file path via `&amp;str` and moved `path.display()` into the fail! block. fn read_data_file(file_path: &amp;str) -&gt; FileData { let path = Path::new(file_path); let file = File::open(&amp;path) .unwrap_or_else(|why| fail!("couldn't open {}: {}", path.display(), why.desc)); let mut reader = BufferedReader::new(file); let mut lines = reader.lines() .map(|line| line.unwrap_or_else(|error| fail!("{}", error.desc))) .collect::&lt;Vec&lt;String&gt;&gt;(); // ... }
Any time. You can get quick help for these kinds of things on IRC as well. 
I am familiar with `collect`, but I haven't gotten it to work since I need to unwrap the lines returned from the iterator.
&gt; THE COMPILER CAN TAKE SLIGHTLY LONGER It isn't our static analysis that takes a long time, it's because: 1. We have very large compilation units (which is better for optimization, worse for build times (and catastrophic for parallelization)) 2. We generate way more LLVM IR than we need to 3. We support unwinding on task failure, and generating the landing pads doubles our compilation time 4. Crates have tons of metadata, and decompressing this metadata has a relatively large constant time overhead for small programs Let's not start a meme that our static analysis is expensive, when it's really not!
I'm about to go, but I'll say `collect` should work very similar to `fold`, except you only need the item. http://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.collect That example is a bit weird, I don't know why you need both map and collect, but I haven't used collect a whole lot in Rust yet. You could map the unwrap and then collect though.
&gt; No one linked the home page, The OP did. 
Interesting. When a `yield` construct is finally available, would this also apply? 
Oh, yeah, I was trying to point out "the cost is at compile-time", not "our static analysis is really slow".
Ah, so they did. Hard to see it next to those giant ads ;)
That syntax is surprisingly pleasing and reads much easier.
You might want to open an issue on the [repository for the playpen](https://github.com/rust-lang/rust-playpen). I could open it myself, but I have no idea what a demangler is :)
Indeed. Part of our strategy for reaching a wider audience needs to be bringing Rust to programmers where they already are, in places like that forum. We look at this conversation and it's sometimes rather unpleasant - as in so many communities - and that's a great opportunity for us. If we consistently bring the reasonable civility of the Rust community into other venues, the goodwill will spread.
From [the PR that included the button](https://github.com/rust-lang/rust-playpen/pull/20): &gt; implements URL shortening on the client-side, using the is.gd CORS API. &gt; Some of the pros of the approach: &gt; * Doesn't depend in any way on server-side support (thus the backend can remain stateless) &gt; * Very simple implementation &gt; Some of the cons: &gt; * We depend on a third-party &gt; * The length of the to-be-shortened URL must not exceed 5000 characters. I've made a very crude estimate on the rustc codebase (removing comments, but not blank lines), and found out that this averages to ~158 lines of rust code. It remains to be seen whether this is enough for most uses of the playpen. &gt; If you want to tell me why my estimate is wrong, or just enjoy reading dirty unreadable code for fun, check it out: https://gist.github.com/riccieri/c554e5a4e796ea8c42c2 (uses ruby and [GNU Parallel](https://www.gnu.org/software/parallel/)) EDIT: formatting
I disagree. A downvote is an anonymous statement of disapproval, while this is perfectly open. It gives the parent the option of reacting to the sentiment, even if the expression is very court.
When the sentiment expressed is just a 'frowny smilie', it conveys no other novel information over a usual downvote than that that specific person disapproves. No reason for the disapproval or anything. People sometime make an edit to their post when they notice a sizable amount of downvotes to their post, which serves the same purpose as the one you're referring to. 
&gt; A downvote does not have my name and my flair attached to it. heh.
See, that communicates way more than a downvote. Upvoted.
It is, but I think it would need more thought to do properly, just imagining it being used with attributes around seems a little nasty: #[allow(dead_code)] #[allow(unused_arguments)] [T] pub fn foobar(v: T) -&gt; T { } Edit: Actually this isn't that bad at all looking back at it, I guess it just seemed bad in my mind. I wish I knew what the where syntax would look like for Rust. I don't really know much about associated types so I don't know how things would even fit.
If you're paid for C++ code, then it's in your interest to not learn Rust. You've got probably sizable knowledge of C++, so learning rust will: A) cost time B) leave your relatively inexperienced compared to someone that learned of Rust earlier C) you can do it in C++ already I've seen this happen time and time before and it's not really, that surprising. Learning a language takes time and if C++ can do the job, there is very little incentive to learn anything else other than personal improvement.
If anybody needs a ride to the meetup, I have a suggestion. Take a Lyft and get a free ride using code LOSANGELES!
The culprit of long C++ compile times has to do with the need to re-parse header files. A module system like Rust's obviates this need. So yes, we did avoid that particular trap. That said, C++'s smaller compilation units mean more flexibility with regard to parallelization and incremental recompilation. &gt; Are the other three items you listed more or less permanent? Large compilation units are probably here to stay. Unwinding's future is hazy, but it would be a big task to propose to remove it. The metadata problem can probably be improved slightly, but I really have no idea. I brought up the topic of compilation times in #rust-internals this morning. We all acknowledge that it's a problem, but the paid devs already have their plates full. A volunteer would really help here. If you're looking for a project, here's another thing that should help speed up compile-times: reimplementing our support for inlined functions https://github.com/rust-lang/rust/issues/14527
I suppose there's also a smaller mod to existing syntax, e.g.: impl&lt;| K, V, H, S | K: Eq + Hash&lt;S&gt;, H: Hasher&lt;S&gt;&gt; HashMap&lt;K, V, H&gt; Or impl &lt;K, V, H, S where K: Eq + Hash&lt;S&gt;, H: Hasher&lt;S&gt;&gt; HashMap&lt;K, V, H&gt;
Forgive me for my ignorance, but what is the use case for a UTF-8 byte vector literal? I can see why you would want byte literals occasionally, and UTF-8 string literals, but when would you need a UTF-8 byte vector literal?
Well, I can't know every use case, but some people may prefer to use strings written in their native language and writing \xHH codes for every occasion of a non-ASCII character may be quite tedious, not to mention unreadable (especially when the number of Latin characters are few). One other case may simply be writing the name of a person or a city. I'm not saying that it's necessary, just that it would be nice :)
&gt; I'm not sure what you're responding to, or what point you're making. I'm responding to &gt; We need to prove that Rust is useful, rather than expecting people to inherently and instantly recognize our goals. Some people's livelihood depends on them not having to anything else except C++. Going on a forum that's dedicated to C++ is a good way to reach to these people. I.e. reach for people that are least interested in making a switch. 
&gt; Precisely. This is valuable data for our ongoing efforts to make the language more approachable. I worry this might be a fool's errand. What makes Rust least approachable in my humble beginner opinion is lifetimes. And removing that part would make Rust, way, way worse. At best some kind of lifetime reconstruction would be nice, but probably way out of scope of Rust 1.0. 
&gt; Indeed. Part of our strategy for reaching a wider audience needs to be bringing Rust to programmers where they already are, in places like that forum. &gt; For some people it will simply be personal preference. I came looking for Rust because of dissatisfaction with various choices in C++, and I was looking with envy at ideas in other languages (especially functional) . but other people are genuinely happy with most choices in C++, it seems, or they can't imagine that it could ever be improved. (maybe blame Java for teaching people to 'think in classes')
String literals in rust are unicode; `let s = "αβ";` is a perfectly valid declaration in rust. I understand that use case (and how common it is), and AFAIK there has never been a need for `\xHH` codes in string literals. Your question (as answered by /u/neutralinostar) is about *byte* literals (which are the only thing discussed in this RFC, and are distinct from string literals). When would you need a UTF-8 byte literal?
Removing features isn't the only option. Better documentation, better tutorials, better examples, which focus on the pain points, would be far better choices in most cases (and even that isn't an exhaustive list). Personally, lifetimes were probably the hardest thing for me to wrap my head around, as it was quite alien. It didn't help that when I first started looking '@' had just fallen out of favor, so most tutorials I could find online used '@' for anything that *might* have been a good demonstration.
There will always be personal preference, you're absolutely right.
:) &lt;3
There is no recourse until 1.0. The every-three-month snapshot releases are not meant to be stable or really even used, but serve as development milestones. The solution after 1.0 is, of course, "don't break code". We may adopt a versioning scheme (I was discussing this yesterday with brson and acrichto), but it very very likely won't allow mixing code for different versions in the same file. That is just insanity.
I'm curious how do you prevent people from running malicious code on the server? The snippets are evaluated server side, no?
It is built upon the [playpen](https://github.com/thestinger/playpen) sandbox. It uses native Linux sandboxing features (via Systemd's API) to limit what the code can do: whitelisted syscalls, memory limit, maximum execution time, chroot jail etc.
Why compromise on short-term storage (which is still storage) if we can have indefinite time with the third-party service? I don't think it buys us that much, and makes the URLs unsuitable for important use cases, like stack overflow answers and blog posts (unless the author is ok with them rotting)
Wow, playpen looks pretty good, I'm surprised it's only 500 lines of C. Is it all you use? Or do you have AppArmor/SELinux on top of it as well?
That's a good point, I wasn't thinking about it in terms of those use cases. Definitely agree, then. 
&gt; Wow, playpen looks pretty good It is pretty awesome, agreed! :) &gt; Or do you have AppArmor/SELinux on top of it as well? Just to be clear, I'm not the author :) I'm just a random guy that landed the 50 lines of javascript that make the share button work. You should probably go ask /u/strncat / [@thestinger](https://github.com/thestinger) if you want to talk to someone who knows what they're doing ;) But, to answer the question to the best of my knowledge: AFAIK, no. Most of the isolation features come from Systemd though, instead of being directly implemented. Playpen "just" uses the Systemd DBUS api to set it up.
Why can't the #[cfg] check disable the following chunk of code like a #ifdef in C/C++?
Rust needs to be usable without garbage collection, so it's a bit of a non-starter. It's a cool approach, though. Go having its own compiler end-to-end is paying off, since they can finally have precise GC for stack roots.
&gt;&gt; Classes expose implementation, .. yup, my big bugbear with classes is they tend to work against decoupling, because classes end up increasing dependancies. extention methods, UFCS, trait/impl, (or just resorting to structs and functions) are all superior. expressiveness: HKT could go toward negating dependancies on certain types of collection/smartpointer ? .. but so far that means longer compile times, writing even more in headers.
I thought when garbage collection in Rust is disabled that only the pauses for garbage collection are disabled and not the metadata aggregation needed to support garbage collection (and which would also support contiguous stacks).
i've been ok with the safety aspects of Rust (a little frustration with casts..) -but haven't found like the borrow checker is something to fight, and pointer-lifetimes aren't so verbose; the bits where the language starts to feel a little restrictive compared to C++ are areas that some seem to consider a virtue, so it seems to be an issue of preferences; It's where Rust seems to push more naming/lookup work on you - [1] lack of general purpose overloads [2] lack of conversion operators [3] traits being compulsory before you can write generics; These would probably be fine once Rust has an IDE. so I guess its mostly an issue of the ecosystem, the advantage going to C++ simply because its' established. (and whilst overloads are considered a double-edge sword, IMO an IDE more than compensates with accurate jump-to-def and autocomplete suggestions) perhaps more error messages can help in the meantime (e.g., you try to use an unavailable method, it will tell you what trait it was in; if you try to pass a parameter that can't be resolved, it could look for any functions that take the appropriate input &amp; output &amp; report them .. etc..)
IMO, conditional compilation is the spawn of the devil. Look at an average c/c++ project that employs this "technique" and you very quickly end up in #ifdef hell where you need to compile the code just to understand what code will be compiled. This greatly harms readability for humans and greatly cripples IDE capabilities. And frankly, just shows of a horrible design with blurred responsibilities. This is a result of a poor man's build system in C/C++ (makefiles from the 70s?) much more than a thought out design. If you want to support multiple versions than a much better design is to maintain separate source code files and compile them with the correct compilers via a modern build system. One such system is being developed specifically for Rust - search for Cargo. 
Moving stacks cause problems: * It means that calls to C via cgo hurt, which is a big problem for Rust. * It requires metadata to be able to precisely track all pointers, which can be a large source of overhead in the executable. * It means that every function call can potentially cause a pause, which is contrary to Rust's goals as a low-level systems language. * If you're doing fork-join parallelism with objects on the stack (which Rust would like to support), then you can't relocate the parent at all. Go has to implicitly heapify all values captured in a goroutine, which is a hidden allocation tax that is contrary to Rust's philosophy of explicit memory management.
I'm not aware of any metadata aggregation to support GC. Allowing the existence of GC to penalize non-GC-using code would violate the principle of pay-for-what-you-use and would be completely unwelcome in Rust.
Rust doesn't have a tracing garbage collector; `Gc` just uses plain old immediate reference counting without any affordance for cycles. The hope is that in the future the Rust compiler will be able to emit the sort of metadata that is required for a tracing garbage collector (including the JS garbage collector used by Servo), but it doesn't do that right now. In such a world, supporting stack relocation would still be difficult, because of pointer usage in unsafe code. Every garbage collected runtime has the problem of interaction between safe and unsafe code, and you can resolve it by requiring certain guarantees from the authors of unsafe code, but I don't know if that is something that will be done for all of the unsafe code in Rust, since it restricts what you can do with pointers.
We'd need to have metadata about references to stack-local variables as well as allocations. This would bloat the metadata size quite a bit. (How much it would be, I'm not sure.)
- So, I guess that's one reason why Go directly calls system calls instead of using libc, they don't want to pay the cost of calls to C functions (maybe that's just a happy accident though because system calls should be really expensive anyways)? - The metadata only has to track every unsafe and borrowed pointer. That's probably still too large a cost though. - Sure, but the lazily mapped in stacks thing implicitly causes a pause anyways. People can still use mlockall though, I guess. - Sure.
Is there a way to optionally "low the budget" given some applications being different from others(cryptography vs a todo list).. Suppose switch it on and off as a compiler flag for instance.. the danger would be a null pointer derefence for instance? or its just about the ownership and when to release the memory retained(actually it look both :)) example: named lifetimes on -&gt; compiler time checks (neat) named lifetimes off -&gt; runtime checks given we use smart pointers all around.. this would be feasible? dangled pointers still possible? It would be something in the line of: you pay for what you use?? 
Actually, im not having a problem working with it.. Im a experienced c++ (mostly among other things) developer But i have some worries: I have the best of intentions with Rust.. im actually using it to create a platform so others developers (hopefully) will think it serve some purpose and will want to code the applications in it.. So im the platform developer, that will make it happen so the applications developers can use it.. Im not much worried about me.. Im worried about the developers.. since they are a different crowd than i am.. the platform will deliver smooth things.. almost fully baked stuff Im worried that Rust maybe be a high barrier to overcome to some of them.. and while for me as the platform developer, Rust is perfect.. maybe Rust will be too expensive to them.. And im not thinking PHP or Javascript level here.. something more demanding, in the lines of Java, C# or Swift.. My fear is that Rust maybe be too demanding.. and in my experience in the software field.. even good C/C++(or haskell) programmers are very hard to find because of the level of inteligence, patience and knowledge needed to grasp the whole language.. Besides... now thinking about myself, given the amount of code im doing... lifetimes really hurt the eyes here and there.. its not unusual in my code to have a struct with 4 lifetime parameters for instance.. and i also want some of those developers to become platforms developers if they wish.. so i want the less exoteric source code possible.. 
agree - dealing with literally manual memory management gives you an insight into what *should* be possible. learning C++ first buries whats important underneath layers of abstraction
There's an open RFC discussing an `Iterable` trait that would do this: https://github.com/rust-lang/rfcs/pull/17
The RFC mentions "byte, byte string, and raw byte string literals" and I understand their differences from string literals, thank you. When would you need byte literals, written as if they were strings? Imagine that, but with UTF-8 characters. That's all.
What kind of platform are you building?
The mechanisms for lowering this barrier are Rc and Gc.
&gt; Im a experienced c++ (mostly among other things) developer Please don't take my question as implying that I think you're inexperienced - as far as I know lifetimes are a novel concept in mainstream languages. Odds are that you have much more experience than myself :) &gt; And im not thinking PHP or Javascript level here.. something more demanding, in the lines of Java, C# or Swift.. I think Rust is way lower level than those languages. Even with all the FP niceties and modernities, Rust is still a "systems programming" language, focused on full control. Have you heard of [Rust-Lua](https://github.com/kballard/rust-lua)? Maybe it's a possibility for you: developing the underlying platform in Rust, and then exposing an API for application developers with a higher-level language (since Rust functions can be defined using the C ABI, it would also be possible to create a shared library and then call the functions on the other language - Java, C#, Ruby, whatever - via FFI). &gt; lifetimes really hurt the eyes here and there.. its not unusual in my code to have a struct with 4 lifetime parameters for instance.. I've never seen anything like 4 lifetimes in a single struct - the maximum I've seen is 2, on iterators. Could you give some example of where this happened?
&gt;&gt;"in its current incarnation Rust is much more expensive even than C++" IMO its about the same, but just feels more 'expensive' at this early stage without an IDE. 
But even than, i wouldnt be freed of lifetimes, since i would have to borrow them(the RC and GC) somewhere.. the lifetimes would be there in the source code
Those borrows might be simple enough that the automatic lifetimes would suffice. Alternatively, you could `.clone()` the box so each call has its own, then you would make sure lifetimes are simple.
The problem I have with lifetimes is that they are 'fake'. That is to say, lifetimes are compile time hints; but they don't map exactly to when when destructors are *actually invoked*; there are some basic rules (end of block, when owning parent is destroyed, etc.) that you can use to *guess* when a destructor is going to be invoked, but often with Gc and Rc code it's entirely non obvious and depends on (as I understand it) how the stack unwinds. It's easy to say 'memory safety without an overhead', but when practical code involves ffi and trusted blocks, its actually pretty easy to generate a segfault which is tricky to hunt down. Perhaps most people don't use ffi much and dont encounter this kind of problem, but I honestly think lifetimes would be a lot easier for people to grasp if you could 'precompile' your code into an annotated form that included exact sequence markers for when destructors would be invoked for each variable.
seems to indicate there's additional complexity r.e. moves vs refs , amongst other things. I'd certainly be happy if it only worked for immutable-references (default being functional code, immutable inputs), and you have to be more specific for anything else
The lifetime mapping from function arguments to the return type is a part of the API, so for pub items you can't allow it to change without the programmer noticing. For the same reason they are needed in trait methods so that all trait impls implement the same lifetime mappings.
this is why I liked the idea of the original sigils: 'sticking @ everywhere' you get your 'quick&amp;dirty productive subset' of the language, but can use all the same libraries as when you're writing performance code. [see the other thread 'where's my c++ replacement' for the comments r.e. gamedev where c++/lua are used side by side] visually the sigils seem to me to 'melt away' more than named generic types. ultimately it is just syntax, I guess, maybe some nice sugar can be retrofitted again later. the nice thing about the sigils was the lack of nesting, compared to Rc&lt;T&gt; ; not just the number of characters. 
It's already kind of tricky to write some code while keeping the borrow checker happy, now imagine lifetimes were completely invisible and automatically inferred throughout the whole program, and you had to read the code of every function to call to understand what it borrows for how long, etc. :(
Sounds like fun! I think I'll be able to make it.
Among 16860 function declarations in current git rust/src/lib*, only 1366 include the "'" character (counting is a bit approximate, using git grep) And most of these are of course just of the &amp;'a self -&gt; &amp;'a part-of-self or &amp;'a self -&gt; Foo&lt;'a&gt; variety. Anyway, they are not a "burden", but are part of the semantics of the function, and they cannot be eliminated. Languages like C/C++ simply leave them out just like Python leaves out the types, making programming hard (you aren't sure about which things you can safely do), and introducing run-time errors at random times. In other words, assume you have this snippet of C++ code: Bar* func() { Foo foo; return foo.get_bar(); } Is this code correct or not? Who knows? It depends on whether the Bar* returned by get_bar() has the same lifetime of the this pointer passed to Foo::get_bar. There is nowhere in the C++ code that you can find that information, and the compiler doesn't necessarily check for it at all. 
Even if it raises the bar, if programmers who would write insecure code in the C-like languages manage to write *more secure* code in Rust, it may be worth it. If every programmer in the world was perfect, Rust would have no use case imho. But they aren't perfect, and therefore Rust has ample use cases. We already live in a world in which your software is judged by the language you write it in - ever seen the vivid hatred some people display toward PHP? Who knows, the same thing may happen when programs are written in languages that effectively compete with Rust: the fear of bugs may encourage the use of software written in Rust rather than those languages, since Rust software is less likely to contain certain bugs, while still allowing for the necessary performance in general. It's a tradeoff.
C calls have two costs in Go: switching stacks (because they can't stop C overflowing the small segment they've allocated) and locking to tell the runtime that this thread is now blocked (because they can't predict whether the C code will block and make the thread useless for scheduling goroutines). If they can be sure that the stack won't overflow, then they can skip switching stacks, but the locking is the bigger cost according to what I've read. Also, if you move the stack, you only need to worry about pointers INTO the stack memory, not pointers out. It doesn't need full GC metadata. Edit: Okay, I see now that it would be hard, because a borrow could point to the stack or heap, so you'd have to check them all.
Jesus, 6:30am? Well... at least the trains won't be crowded at 5:30am. Edit: had another look, the top of the page had a single reference to PM. Why would programmers not use 24 hour times?
Cute stat, but it's probably more interesting to see how commonly used those few functions are; I'd guess that: libstd/c_vec.rs: pub fn as_slice&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a [T] { libstd/c_vec.rs: pub fn as_mut_slice&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut [T] { libstd/c_vec.rs: pub fn get&lt;'a&gt;(&amp;'a self, ofs: uint) -&gt; Option&lt;&amp;'a T&gt; { libstd/c_vec.rs: pub fn get_mut&lt;'a&gt;(&amp;'a mut self, ofs: uint) -&gt; Option&lt;&amp;'a mut T&gt; { libstd/collections/hashmap.rs: pub fn make_hash&lt;T: Hash&lt;S&gt;, S, H: Hasher&lt;S&gt;&gt;(hasher: &amp;H, t: &amp;T) -&gt; SafeHash { libstd/collections/hashmap.rs: pub fn read&lt;'a&gt;(&amp;'a self, index: &amp;FullIndex) -&gt; (&amp;'a K, &amp;'a V) { libstd/collections/hashmap.rs: pub fn read_mut&lt;'a&gt;(&amp;'a mut self, index: &amp;FullIndex) -&gt; (&amp;'a K, &amp;'a mut V) { libstd/collections/hashmap.rs: pub fn read_all_mut&lt;'a&gt;(&amp;'a mut self, index: &amp;FullIndex) libstd/collections/hashmap.rs: pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Entries&lt;'a, K, V&gt; { libstd/collections/hashmap.rs: pub fn mut_iter&lt;'a&gt;(&amp;'a mut self) -&gt; MutEntries&lt;'a, K, V&gt; { etc. have a disproportionately high usage compared to non-life timed apis, in a way that the raw number of function declarations doesn't really make obvious. ie. Sure, not many api functions actually have named lifetimes (and probably not many people write apis that do), but as a rust programmer, you use functions that do *all of the time*. 
Is it written AM somewhere I don’t see, or is this about the ambiguous "6:30" in the description?
&gt; visually the sigils seem to me to 'melt away' more than named generic types. Many of us agree, which is why we wanted the sigils to go away.
&gt; lifetimes are a novel concept in mainstream languages. Lifetimes *as syntax* are a novel concept in mainstream languages, but they do exist in C and C++. They're just not part of the language itself, they're something you have to keep in your head.
&gt; D actually has very poor performance in FP math area (https://github.com/nsf/pnoise) It would be great if you posted to the [D newsgroup](http://forum.dlang.org/group/digitalmars.D) about your benchmark, they will probably suggest causes. I think I remember `std.random` causing slowness in benchmarks before. ISTM in general, D tends to beat Rust, maybe due to its age.
Well whats certainly true is rust requires more information to be specified sometimes (move vs refs...? ) but IMO the ideal is "sensible defaults" and you optionally specify more information when more control is needed; I'll have to read the detail of the RFC, seems it's not so trivial , but it does seem like Rust should be able to match C++ where you can just say `for (auto&amp;x : foo){...}` ... although other aspects of C++ iterators are rather messy (prior to auto and that sugar, they were a nightmare IMO), like having to specific the base collection for both start and end instead of passing a range .. &gt;&gt; What's old is new again! This used to exist, but was removed. I seem to remember .map etc on the collections, was that more limited, before it was fully generalised for iterators ?
You can do that easily with Make, too. Have a look at the Tcl build, for example.
There was syntax with `do` that followed an iterator protocol.
Gutted I can't make this - I've been waiting for one to come along for ages. I'll make the next one!
I'm not knowledgeable enough about Rust's current module semantics to answer that. I do fear that our large translation units might come back to haunt us, and if you have ideas of how to fix it I think you should bring it up on the mailing list.
I'm hopeful that a future Rust IDE will be able to leverage the compiler's knowledge in order to provide a tool to highlight lifetimes in the source code. But first I'd just like to get any IDE support at all.
how much of it is simply unavoidable due to the desire to use generics as much as possible. the worst possible case would be like a C++ unity build, I guess. But it seems to me Rusts' context-free-grammar should allow a smarter build system. Personally I had expected a generalised graph, but anything is a step forward from the hell of C++ headers . I've read many explanations that existing languages with a graph-like module system are a double-edge sword - but at the same time i wonder about this asymmetry between modules &amp; crates. I wonder if its possible to make a graph system that can replicate the virtues of the hierarchy, thinking of "super::..." (relative paths..) Also I wonder if its possible to simply make a faster, but slower build (e.g. .. not monomorphising the generics), for iteration. 
I remember that Go uses `.x86` files for specifying assembly implementations for various assemblies, maybe rust could use a similar version scheme ? src/ a-0.11.rs a-0.10.rs b.rs // use a;
&gt; there’s Haskell... which can’t brag about speed, though. Haskell can be plenty fast. Sometimes even 'as fast as C fast.' Haskell's memory usage is significantly harder to control, though. Not that that is impossible either... &gt; Type inference (auto was added to С++ for that purpose). Rust's inference is very different than `auto`. That said, I still like this article!
Please note that this is a translation of my article in russian, written to popularize the language in our programming community. It was based on my very subjective experience, and may not stand objective criticism. Please excuse (and correct) its shortcomings and faults. Also, I was not aware of the translation being done and published. While I appreciate the work and don't mind it getting attention, I wish the translation was better... If I was writing it these days, I'd include the following list of performance bullet points: * aliasing information available to compiler (automatic __restrict) * one less jump on virtual functions due to traits ([Runtime polymorphism](https://github.com/rust-lang/rust/wiki/Rust-for-CXX-programmers#runtime-polymorphism)) * undefined struct layout * reference counting (Rc&lt;T&gt;) is lock-free because of being task-local * allocator model: rust provides hints and could inline calls to *jemalloc* ([issue](https://github.com/rust-lang/rust/issues/14151), [RFC](https://github.com/rust-lang/rfcs/pull/39))
The level of support for Windows is that we ensure that the test suite continues to pass (on the bots running Server 2008 R2), and that Windows maintains something close to feature-parity with Unix. Because there are few Rust contributors running Windows as their primary OS, the level of polish is consistently lower, and as you've seen, there are often quite severe bugs that nonetheless don't prevent the test suite from passing. It's unfortunate, I do believe the situation has slowly improved, but it's not near good enough yet. This is one critical area (of so many) we need to invest in for successful productization, but I'm not sure yet when Mozilla will be able to focus on it at length. Contributions always welcome, of course 😳. I don't recognize your second bug; you might consider filing it.
That's why i've mentioned that im am also a C++ dev.. did'nt mean to sound pedantic.. i've just mentioned it, to make more clear that im used to think about lifetimes and allocations.. also the boxes in rust are easear to grasp since they are common in c++ land.. 
Is this the first article in Russian? If so, that's exciting stuff! Either way, I think you capture the core principles behind the language, which is great.
Hello Dmitry, Nice to see you here. Which parts do you think require better translation? Do you want me to add the perf list to an article?
Yup! I'm the one sounding pedantic, if anyone :)
Where is the original article at?
I think these are all good points, but I must reiterate that I'm not the one to ask! Make a post to the mailing list. :)
Author gracefully points to it at the beginning. [Original article](http://habrahabr.ru/post/224607/). There was also the [following article](http://habrahabr.ru/post/225003/) with some concrete code samples in C++ vs Rust (produced after receiving tons of negativity about the first one being too vague).
My brain absolutely skipped the link, thank you! I try to tweet articles in their original language, and I have a bunch of Russian/Ukrainian followers, especially since I was in Kyiv two weeks ago.
Hey skazka16! Thanks for doing the translation ;) Actually, it's not as bad as I initially perceived. It would be nice to have some native speaker feedback, of, course, but here is what feels lacking for me: * "At one point, C++, in which" could be "On one hand there is C++, in which ..." * "... memory. Or the ..." feels wrong to start the sentence with "Or" * "Somewhere in-between balance Java, Python ..." this sounds too russian :) Need to be re-phrased. * "Rust is a successful crossing of" - wrong usage of "crossing". Perhaps, just "cross" or even "breed" would sounds better. * "The code beauty doesn’t require performance sacrifices." Even though that may sound right, what I really wanted to say is "Zero-cost abstractions." * "Multi-paradigmality" should just be "Multi-paradigm" * "to write a code" - I believe "code" doesn't need an article ("a") And it's not even the first half of the article yet.
Agree. Very good points. I'll see if I can edit it a little.
Please include the perf bullet list (possible name "Reasons why Rust can be faster than C++:") if you can ;)
Thank you. It's there now.
&gt; Somewhere in-between balance Java, Python, C# According to the article, this is what the deal looks like on the speeed/reliability continuum :) &lt;&lt;&lt; speed -------------------------------------------- reliability &gt;&gt;&gt; C++ Java/Python/C# Haskell I can perhaps accept Java and C# being in the middle, but is it actually saying that python is *faster* than Haskell?! I'm pretty sure that's not the case.
&gt; the 'r and 't dont mean anything in the algorithm or the code logic.. Yes. Yes, they do.
I don't know why you'd want to spend any appreciable amount of time *at all* to support two different unstable release versions of Rust. This is a perfect example of a time when you'd be best served by backing up and asking the **real** question. What is it you're actually trying to solve or accomplish?
Actually, the thing that put me off from the start up was the title of the article. Any reason why you didn't translate it more closely as "Why do we need Rust?". I understand it might be to late to change that, just being curious :)
Can someone more concretely describe the change the OP is describing. I don't understand what is being proposed or what it would get us.
Having written embedded Java, I can tell you Java does not manage to have both crowds. Every time you need a new type you have to worry about the additional memory and image space that the class of will take, thanks to Class objects, reflection etc. And, to make matters worse, the Java compiler generates "synthetic" methods, classes and data that are not visible in the source, and not well documented. To get predictable performance you have to be careful about when you let the GC run, which removes a lot of the benefit of GC. In embedded products it's common to interface with native libraries via JNI which is slow, and also means the Java code holds on to native memory and therefore consumes memory without creating GC pressure. In practice, this means any objects holding onto native memory have to be explicitly destroyed to get predictable memory use, and again, that removes a lot of the benefit of GC. So, compared to Java, Rust looks very promising -- no-cost abstractions, predictable memory use, predictable performance, and a helpful type system.
Indeed, those are not two sides of a single axis, but rather two axis in a multidimensional space.
&gt; it's probably more interesting to see how commonly used those few functions are Why do you say that? I think that the issue is having to deal with lifetimes explicitly at the function and struct definitions.
Indeed, [Steve](http://www.reddit.com/user/steveklabnik1) has already pointed that Haskell is not slow. The continuum ended up being not that good :)
the RFC explains better than me and is obviously more well thought through, they suggest `.into_iter()` it seems. It might sound trivial but its just one less hoop to jump through for a newcomer. 1st impressions .. IMO most people would guess `for i in collection {...do stuff..}`, and they'd guess you can do that for a string to get the characters aswell. The idea is to support that, and still be able to write a method there to get a more specific iterator like reverse or whatever. (because any Iterator would still support 'Iterable')
Sure! It's going to be way easier to translate correctly.
Oh I see, I forgot about the iter() change back, got the context back from the RFC. I see. Thank you!
What i mean is that they are more in the semantics level, than the algorithmic level.. as stated before in this thread.. they document lifetime behavior.. unlike generics that got some algorithmic value in the code.. So its not like saying that they do not provide value at all.. 
This is a great explanation over the advantages of Rust over C++. It's important that we make more of those comparisons (and it's also important to stress the disadvantages), because lots of people are still very uninformed towards how Rust manages safety without a runtime cost.
Yup, auto is much more limited than Rust's type inference (which is more limited than Haskell, btw).
&gt; "Somewhere in-between balance Java, Python ..." this sounds too russian :) Need to be re-phrased. I'd probably say "Python and Java lie somewhere in between." 
A platform independent application platform+application shell .. its a mix of app platforms and browsers.. there are some peculiarities in the design that i think are really game changing.. (of course, this is pretty subjective and maybe naive) Anyway this whole thread was really a eye opener.. i think im the wrong one to want Rust to be something its not.. and while its good for my own needs i think it wont be "that good" to the people that will have to deal with it, and program in it.. So i need to adapt my expectations and work thinking more about the app developer.. Sorry for the noise, everyone
ah yes, would make for cooler ascii art too!
I was wondering today, actually, if the Win32 C API would be supported. I'm guessing the runtime doesn't have a hook into WinMain though?
it should actually undo the statements in the loop, like erasing previously printed lines and undoing changing mutable variables
https://github.com/rust-lang/rust/issues/8510 is the only bit I found on WinMain.
just rent some more ram from the cloud (I'm hoping this becomes the new download more ram joke) http://digitaljournal.com/blog/10299 
See https://github.com/klutzy/rust-windows
No thank you, I like my RAM locally-grown and organic.
This was written as a side-project by an associate, under a previous contract with Mozilla. I'm not sure where, or if, this fits into the official docs, so I'm posting it here in hopes somebody finds it useful.
I noticed a few errors so I fixed them. https://gist.github.com/mcpherrinm/1cf88d7b3e3f1ba13081/revisions
Perhaps the choice can be given to the user. I.e., if the method is defined as is currently required: fn area(&amp;self) -&gt; f64 { ... } then members must be qualified with 'self'. If the method is defined as: fn area(&amp;) -&gt; f64 { ... } then members can be referenced and 'self' is implicit. 
&gt; ultimately it is just syntax, I guess, maybe some nice sugar can be retrofitted again later. the nice thing about the sigils was the lack of nesting, compared to Rc&lt;T&gt; ; not just the number of characters. So it was a conscious decision to make the language uglier? The exhaustive pointer types were what originally drew me to Rust, but the fundamentals were good enough to keep me despite the uglification of the syntax.
The problem is that because lifetimes are compiler hints, they *do not* guarantee objects will be alive. It's easy (and quite common in my experience) to end up with code that compiles and then *segmentation faults*. Thats because trusted blocks turn up everywhere, and they break the lifetime scoping. It's a fundamental property of lifetimes; because they are hints from the programmer, they do not neccessarily 100% accurately reflect the behavior of code at runtime. /me shrug It's not necessarily a major issue, but its undeniably true that 1) you *can* segfault in rust (its not magically memory safe), and 2) lifetimes *do not* guarantee objects are valid at runtime. That might only be true if you use unsafe code; but people *do* use unsafe code. That's the only point I was making. 
I don't remember this existing. As far as I know, there was never a concept of an iterable.
Patches accepted!
&gt; The problem is that because lifetimes are compiler hints, they do not guaranteed objects will be alive. Yes, they do. &gt; It's easy (and quite common in my experience) to end up with code that compiles and then segmentation faults. Thats because trusted blocks turn up everywhere, and they break the lifetime scoping. The `unsafe` code is broken. If you use `unsafe` code to break "lifetime scoping", then you have fundamentally incorrect `unsafe` code: it is [undefined behaviour](http://doc.rust-lang.org/master/rust.html#behavior-considered-unsafe). That is, the compiler optimises assuming, for example, all `&amp;` pointers are valid pointers pointing to valid data, and if you break this then your program can do [*anything*](http://www.catb.org/jargon/html/N/nasal-demons.html). (BTW, by the same logic, types are just compiler hints, e.g. `transmute::&lt;uint, Box&lt;uint&gt;&gt;(10)` isn't a valid `Box` pointer.) &gt; That might only be true if you use unsafe code; but people do use unsafe code. And they *have* to be very careful when using it.
&gt; Wow, playpen looks pretty good, I'm surprised it's only 500 lines of C. Is it all you use? Or do you have AppArmor/SELinux on top of it as well? The only available sandbox bypasses in a chroot with namespaces and no bind mounts are leaked file descriptors or a kernel exploit. Playpen does a loop over `/proc/self/fd` to guarantee that any file descriptors leaked by parent processes are closed, and is tested to make sure that no leaks are introduced. The system call whitelist greatly reduces the attack surface exposed by the kernel, but doesn't eliminate it. AppArmor, SELinux, TOMOYO and the other Linux security modules don't offer anything valuable for a strong sandbox like this, because they're unable to provide any protection from kernel exploits. It was previously running on a machine with the [grsecurity kernel](https://grsecurity.net/) package that I maintain for Arch Linux. It's now on EC2 and using a vanilla Linux kernel because Xen doesn't mix well with grsecurity. If it was hosted somewhere that used KVM/Qemu, it wouldn't be an issue. The recent `futex` exploit in the Linux kernel was a viable sandbox bypass, but it would have been more difficult to exploit it with the grsecurity kernel. Issues like this could be prevented by the sandbox if Playpen exposed the ability to perform parameter checks on system calls via seccomp.
In the past, Playpen didn't require systemd because it created the memory and device control groups itself. Migrating to a systemd scope unit [didn't significantly reduce the size of the code](https://github.com/thestinger/playpen/commit/d3d222234ed1b373e813d67e7439fe5f881ebb62) but did allow for more usable device whitelisting and made it compatible with several useful command-line tools. Entering a `chroot` and namespaces only requires a dozen lines of code, but handling seccomp without the magnificent libseccomp library would require a significant amount of nasty low-level code.
A garbage collector regressing the binary size / performance for programs not making use of garbage collection is unlikely to be merged. It would also need to work without expecting any cooperation from third party libraries, because many people in the community (including myself) are not going to go out of their way to support tracing.
&gt; but I don't know if that is something that will be done for all of the unsafe code in Rust, since it restricts what you can do with pointers. If it places a burden on low-level code, a large portion of the community will fight tooth and nail against it. The restrictions would also need to be put in place and verified as working with a real implementation before 1.0.
I really appreciate your response and all of the information, but to be honest a lot of it went over my head. I'm particularly interested in sandboxing strategies on linux because I'd like to write a web application that evaluates people's code server side, so security is a big concern. I'll make sure to add grsecurity to the list of things I need to investigate :)
I know, I was just kvetching about aesthetics. I'd much rather write `~~[T]` than `Box&lt;Vec&lt;T&gt;&gt;`, because I find the former much more intention-revealing. I understand (and even agree with) the reasoning behind the changes, and the desire to minimize the special cases in the compiler. Maybe someday there will be a more expressive language built atop Rust, as Elixir is atop Erlang. 
As someone who doesn't live in an English-speaking country: Why would **anyone** not use 24 hour times? ;)
Playpen itself needs to start the process, so it needs to deal with this. In theory, it's the responsibility of the parent process to avoid leaking file descriptors to Playpen, but in practice there's a lot of buggy code and Playpen needs to deal with it. For example, Python 2 leaks nearly every file descriptor it opens to child processes and even new versions have a lot of leaks.
Sure; but it doesn't change the fact that its possible, just like in C++. The onous for writting correct safe code falls on the programmer. Lifetimes *help*, but they don't fix things; that broken trusted blocks *can exist* seems to break many of the benefits that explict names lifetimes grant in my oppinion.
&gt; Playpen itself needs to start the process Why is that? Wouldn't it be possible to ask Systemd to start the process, and then collect the output from the journal, ala `systemd-run`? (If the questions start to get annoying, just stop answering :))
Given that Go's setuid implementation is broken they should really just remove it. Now instead of a security problem, they would simply have unimplemented functionality that one has to fall back to a C helper process for. Of course, stupidly most groups don't want to break backwards compatibility even if it'd fix a security hole. I'll agree that creating your own libc means you get to make the same mistakes implementing libc but that particular example isn't good because the Linux kernel's implementation of setuid is completely idiotic. &gt; The overhead of a system call is cheaper than the cost of a call from Go to C. Some system calls are also implemented entirely in userspace via the vdso on Linux, such as clock_gettime, getcpu and gettimeofday. I knew that, I was just talking about the general case.
Nice I'll see if i can attend this :)
The Linux kernel does in fact have a notion of processes, if it didn't how else would exit_group work? Okay the setuid system call isn't completely dumb but it should really be two functions: setuid and setuid_group. 
Wrong subreddit. This isn't rust the game. try /r/playrustservers
You need to make a new post there.
Yes before NPTL there was LinuxThreads and LinuxThreads was very broken. Just as the LinuxThreads notion of process and threads as the same didn't work for exit it doesn't work for setuid. The current GLibc implementation of setuid on top of the kernel system call is an ugly hack.
&gt; The current GLibc implementation of setuid on top of the kernel system call is an ugly hack. You can say the same thing about the design of many other system calls. It's not a good idea to reinvent these wheels without checking how glibc or musl handles it. One way to fix this without adding new system calls would be adding a `CLONE_CRED` option for sharing credentials (capabilities, uid, euid, gid, egid, etc.) with the child.
&gt; You can say the same thing about the design of many other system calls. Yes and I should say the same thing about the design of lots of other system calls. Because Linux implements many system calls insufficiently ugly hacks and complicated logic are needed to implement normal system functionality. This causes bugs in code that directly uses system calls like Go's standard library or GLibc. GLibc has lots of threading races and bugs because it tries to implement complicated logic like `pthread_cancel` which belongs in the kernel (well not precisely `pthread_cancel` but a suitable primitive for implementing it). &gt; One way to fix this without adding new system calls would be adding a CLONE_CRED option for sharing credentials (capabilities, uid, euid, gid, egid, etc.) with the child. `CLONE_CRED` would be one possible way to handle it. I personally don't care about the specifc way to handle it.
Back in like 0.5, I very distinctly remember there being an 'iterator protocol' that things would follow to work with `do`.
http://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/ is what I'm thinking of, which is getting old, I guess.
The old closure-based iteration protocol looked like `for xs.each |x| { }` as it expected a function or method with the signature `fn|T| -&gt; bool) -&gt; bool` (although the time, the type syntax for that was `extern "Rust" fn(&amp;fn(T) -&gt; bool) -&gt; bool`).
This sounds interesting! Perhaps you want to take a look at http://www.piston.rs/ and see if we could combine our ideas?
Yeah, but std.random is not used in that benchmark, it just initializes 256 random vectors and permutates 256 sequential integers. What spins in a loop is just plain FP math and array read/writes. I'm sure it can be done faster, maybe D compilers are bad at automatic inlining or something. But I'm not that interested in D for other reasons. D has exceptions and garbage collection, I don't need that in a low level language. I just wanted to say that D compilers aren't producing "the best code in the world" as I've heard from some of the fans. I could post in a newsgroup, I could inspect asm on my own and see what's wrong, but I'm not using D, hence why bother. I don't claim my benchmark is revealing some kind of a mistery about programming languages. It just shows how fast a code written by a random programmer and compiled with a popular compiler will generate perlin noise images. Some results were surprising though, like luajit+ffi (ffi parts doesn't use C code, it allows you to use structs and tightly packed struct arrays within lua) beats most compiled languages or mono jit compiler produces real crap.
We still heavily use it.
Hi there, There is an example here: https://github.com/cburgdorf/Floor/blob/master/examples/example.rs To get it running, pull down the code and then: make all make run Enjoy!
Are you intentionally being obtuse?
Instead of bug hunting, we get to argue with the compiler, but that's still a lot better. Especially once partial return type inference is implemented (or whatever it's actually called).
&gt; Some results were surprising though, like luajit+ffi I don't see that result, at least in the README. Are more results posted somewhere else?
Interesting, thanks.
I think i will be there. thanks.
it says 2013 instead of 2014.
As far as I know strings are being reworked at the moment such that there are a lot of rough edges. For example to_str was once returning a ~str which does not exist any more as a type. Thus that a String is returned instead.
Thanks for the reply. So it seems that the methods with "owned" in their names are all legacies. 
Yes, and also if it has `str` in the name but doesn't mention `&amp;str` at all (e.g. `to_str` returning a `String`).
I wish i could go
Yeah, README contains only compiled languages. I can post you the results I got here: [nsf @ pnoise]$ perf stat -r 3 pypy test.py 2&gt;&amp;1 &gt; /dev/null | grep time 2,065942643 seconds time elapsed ( +- 1,23% ) [nsf @ pnoise]$ perf stat -r 3 luajit test.lua 2&gt;&amp;1 &gt; /dev/null | grep time 1,891605213 seconds time elapsed ( +- 0,52% ) [nsf @ pnoise]$ perf stat -r 3 luajit testffi.lua 2&gt;&amp;1 &gt; /dev/null | grep time 0,204424886 seconds time elapsed ( +- 8,68% ) Running interpreters takes a lot of time, so I'll just run them once: [nsf @ pnoise]$ perf stat -r 1 lua test.lua 2&gt;&amp;1 &gt; /dev/null | grep time 31,080308378 seconds time elapsed [nsf @ pnoise]$ perf stat -r 1 python2 test.py 2&gt;&amp;1 &gt; /dev/null | grep time 89,464856173 seconds time elapsed 
[Similar question from awhile back](http://redd.it/27ziqs)
Yes!
It was never inference. "Anonymous return types" is a pretty good name for the intended feature.
sweet, thanks!
Looks like a benchmark so small it reduces to one loop (the optimised Haskell version is one tailrec function). It doesn't say much about real programs that are thousands of lines and where allocations and lists won't just disappear.
The last one was awesome! I can probably get us a room in the CS building for the meetup. Just let me know what day we decide on.
Gaaah. Forget to put cross-post in the title. See, this is why I don't post links. ;_;
I never understood why people put cross-post in the title. It says 'other discussions: 2" right above your title (in the tabs), which links to http://www.reddit.com/r/rust/duplicates/28nie1/magic_forest_problem_solved_in_several_languages/ , which shows all the places it's been submitted.
Does modifying the code like this help? fn encode_dict(&amp;mut self, dict: &amp;TreeMap&lt;Key, Vec&lt;u8&gt;&gt;) -&gt; EncoderResult&lt;()&gt; { { try!(write!(self.get_writer(), "d")); } for (key, value) in dict.iter() { try!(key.encode(self)); try!(self.get_writer().write(value.as_slice())); } write!(self.get_writer(), "e") } This would help to ensure that there is only one `mut` borrow to `self` at a time. This is my best guess for how to fix your issue.
The result of an API that grew organically and faced many language-level changes. I'm not sure what is the priority of stdlib changes at this point, given that the language itself is still undergoing big changes, such as DST (which will probably impact the APIs). However, I'm sure the core team will want to address this kind of inconsistency before 1.0. I suggest you open an issue about that at https://github.com/mozilla/rust if you can't find any :)
I figure stuff like this is good to read: over in /r/programming, there's a discussion about some downsides to this approach, etc. But it's still a mindset relevant to Rust programmers. Think about allocation, memory locality, etc.
What about starting the playpen itself from Systemd, to avoid the Python "heritage"? This could also be used to remove some code from playpen itself by using the equivalent unit properties, such as `PrivateNetwork`, `PrivateTmp`, `MemoryLimit` etc
&gt; A recent thread in the Julia-Users forum asked about the long-term hopes of Julia achieving true C/Fortran performance (currently usually 1.2-2x). I think another strong point to the argument of Julia vs. C/Fortran is what I've shown above. Powerful language design choices like strong meta-programming functionality allows you to do things in Julia that would be almost impossible in many other languages, but that also allow for unique performance gains. Hopefully this will be true of Rust macros, as well.
Well, if you cross link to the other reddit link, it helps consolidate comment threads sometimes instead of fragmenting them.
Renaming `to_str` to `to_string` is a known issue: https://github.com/rust-lang/rust/issues/15046 This should be a very easy change, if anyone's looking to make their first contribution to Rust! :)
Thanks, fixed it :)
&gt; (Sorry for the awful English) Your English is wonderful, and I almost went to grad school for English. I wouldn't have realized that you were not a native speaker if you hadn't pointed it out. I'll let the game-specific people give you a better answer, as there's a number of them here.
This sounds excellent. July 7-11th I'll be in town too. I'd absolutely love, love, love to come.
Can you share a compilable (apart from this error, of course) version of your code on the http://play.rust-lang.org?
But it is cross linked. By Reddit. Automatically. Anyway this is extremely off-topic.
Yeah, as I was reading this, I kept expecting him to write: &gt; at this point I decided to pull out my profiler and actually work out what the biggest performance impact is from rather than just blindly stumbling along through the dark.
Ah, I was saying something slightly different, but you're right, there is still the same visual cue, it's just I think about it differently.
Let me join this off-topic to make a question I always wanted to make: Is it annoying when non-native speakers add that "sorry for the english" note? I used to do that myself, but then I realized it can sound like a humble brag if the person didn't commit any mistake
While it's true that the language and libraries are still changing a lot, I'm usually able to make the required adjustments to my (toy, admittedly) projects in a few minutes, and most of them are very simple. I've read many reports from people with the same experience. I'm not sure if there's something particular about games that would make it harder though.
Then I'd second eddyb's suggestion to refer to this concept as an anonymous return type.
I'm interested! Haven't had a chance to do much with rust. Started 'rust by example,' but haven't gotten very far yet. I'm interested in rust for financial trading servers: low latency, fast network and file system access, reduced complexity, etc.
I don't think it's annoying, but I do think it's a manifestation of good old [Dunning-Kruger](http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect).
I'm a native (US) English speaker, and I assure you that your written English is clearer and more correct than the vast majority of native English speakers I encounter each day.
In fact it seems like bragging, thanks for pointing it out! I was going to delete it from the post anyways, since everyone talks about the last sentence but no one has answered about any of the post's questions :P
As for the integer type overhead, you won't experience any more overhead than you would in C++, and I think rust does a better job of naming the types for clarity of size in bytes. If I were to start rewriting my C++ game engine in Rust, I would expect to need to build rustc from the master branch frequently, along with rust-SDL2, gl-rs, and other libraries. The biggest bottleneck in my development process would be waiting on libraries to be updated for each new version of rust, so I probably wouldn't recompile rustc until I knew the libraries supported the new version. IMO, this is too much trouble, and I'd rather just spend time implementing fun things like AI to learn how to use rust effectively and how to implement common data structures and design strategies. This allows to me to stay up to date with the language, and I don't have to worry about dealing with libraries until rust 1.0. Then I'll have cargo to make things simpler.
Well, unless I write all the wrappers for all the libraries I need (e.g. OpenGL), I think the biggest problem is that third party library wrappers that I might need may be outdated
So you suggest to wait until Rust 1.0 comes out to start writing the graphics, audio... subsystems? Would it be simple to wrap a C++ shared library in a Rust program, so that I could use a C++ engine in a Rust game? I'd like to use Rust to implement a safer component-based engine design, mainly because I wouldn't like to fiddle with C++ custom memory allocators too much, but from what I've read it seems that for now it's almost impossible :/
I haven't tried that myself, but I know there is a C ABI. C++ might be another story. I don't really have any authority to comment on that. I do suggest waiting until Rust 1.0 to use libraries if you would like to stay up to date with the language as much as possible. Personally, I just don't want to get used to using features that will be removed or modified in a newer version of the compiler.
&gt; that third party library wrappers that I might need may be outdated This has happened to me a few times. Here's what I did: updated the library myself, and submitted a pull request ;) All the changes I faced since I got into rust (which was late april) were pretty mechanical, and I was able to update codebases I never worked with before in less than 1 hour.
You are correct, the language is evolving rapidly and if you don't stay up to date with master it can be quite a bit of work to catch up. There has only been a few major changes in the past few months that have taken more then a few hours to fix on my code base. (Moving from ~str to String, and removing ~[T] in favor of Vec&lt;T&gt; are the two the come to mind). Rust's community is pretty good at keeping libraries up to date. [glfw-rs](https://github.com/bjz/glfw-rs) and [gl-rs](https://github.com/bjz/gl-rs) for example are rarely broken for longer then a day, and dev's often are stepping on each others toes in fixing master when it does break. Plus, if you want to get your feet wet in the community fixing an out of date libraries is an easy start. Rust's error messages are easy to understand, so it's not normally hard to figure out why something wont compile anymore. If you are in doubt on how to update your code to master it can be helpful to look at the pull request that actually broke your code. Looking at what was changed to keep the standard library compiling is a good template for what you will need to do. You will want to run some type of continuous integration system if you plan on keeping up with master. Travis is used nearly universally with the communities libraries, but it can be pricy if you want a private repo.
Depending on features that get deprecated it's frustrating, that's true!
Yes, but judging from the glfw-rs sources it shouldn't be too hard to create a (Python?) script to generate them based on some kind of template file
I'd certainly be interested; time and gumption permitting. (I hate chicago traffic.) I live in SE Wisconsin but the trek down would be worth it for a rust meetup...^(also deep dish pizza.)
It sounds harder than it is. Take a look at [a PR I submitted a few days ago](https://github.com/jsanders/rust-bignum/pull/4) to rust-bignum, after the `TotalOrd`/`TotalEq` changes. The changes are so simple they could've been done with a simple `sed`.
Absolutely! I would have written the same thing as you, with a few very, very small changes. To give you an idea of how close you are... &gt; I want to implement "I'd" would be short for "I would," which isn't _wrong_ here, but sounds a bit wrong to my ear. &gt; given that the language is so new, "Short lifespan" isn't wrong, but tends to be used after something has died, rather than for something that's only been alive for a short time. &gt; in Rust now and update it The 'since' there is odd. I didn't even notice it the first time I read the sentence, but upon this careful reading, I did. &gt; over a one byte integer Generally, numbers less than ten are written as words, and numbers 11 or greater are written as numbers. This is just considered good style, native speakers screw it up all all the time. That's it! I want to stress, as /u/sindisil did, that these things are incredibly minor, and most native speakers also get them wrong. Upon re-reading my comment, I realized in my last sentence I wrote "native speakers screw it all the time," without the "up." Nobody's perfect. I only point them out to show you that your English is extremely close to someone who is paid to be a writer, professionally.
My advice would be to "stand on the shoulders of giants": re-use as much existing community code as possible (gl-rs, glfw-rs, cgmath-rs, etc). Strong wins: * you leave the low-level details aside, focusing on real stuff * you need to update only your little top of the iceberg, not the whole thing * you can learn from the underlying libraries design &amp; best practices I think [q^3](https://github.com/jeaye/q3) game/engine has voxels underneath. Even though it may not compile now, you can possibly re-use parts of it after some cleanup.
You want http://www.rust-ci.org/ , too.
I have no personal experience with BuildBot. But it should work. As for the Raspberry Pi, I think you will run into out of memory problems. But I'd love to see it.
You don't even need to create it: https://github.com/crabtw/rust-bindgen
You should set your editor to use four spaces, not tabs. It's the convention.
I don't find it annoying. If anything, I'm embarrassed that they can speak my language and I cannot speak theirs. I have also travelled a very unusual amount for a US citizen, so I may not be representative.
Ah, I didn't know that. Okay, I'll try getting used to using that.
I didn't know about that "number rule", thank you.
I meant an `extern` block in C++, exposing a C ABI. Although you do need to have one in Rust as well, to make the calls (and that can be generated with rust-bindgen). I have almost zero experience with C++, so I don't know if it's possible to create the `extern` block in there easily
When all the rest of the world speaks English, you have to adapt :) I think there's no point, other than for personal satisfaction, in learning other languages if you know English, since there are very, very few places where people can't understand it
I may let it swap on a USB stick just for fun
&gt; Better encapsulation than functions Why? In javascript at least, computed properties are functions with a different syntax. I don't see any fundamental difference between: println!("{}", foo.bar); foo.bar = "baz"; and: println!("{}", foo.get_bar()); foo.set_bar("baz"); Especially if you do it Java-style, where all properties are hidden behind getters and setters instead of being public. &gt; Easier to persist computed properties I don't have experience with C# or Swift, but in javascript at least I don't see why that would be the case. Can you elaborate?
This kind of thing comes off as a humble-brag, to me. I did the same thing once when I was new to the Web about 10 years ago, and I got the same response as in this thread, 'don't excuse yourself, your English is better than many native speakers!'. My "excuse" was partly motivated by me being concerned that native speakers would find grammatical errors and such grating, even though they probably understood it. I probably also wanted validation.
The `initial_forest` part could be made more idiomatic: let initial_forest = match os::args().tail() { [ref g,ref w,ref l] =&gt; Forest { goats: from_str(g.as_slice()).expect("Error: goats not an int."), wolves: from_str(w.as_slice()).expect("Error: wolves not an int."), lions: from_str(l.as_slice()).expect("Error: lions not an int.") }, _ =&gt; fail!("Error: input should be in the form of &lt;goats&gt; &lt;wolves&gt; &lt;lions&gt;") }; Maybe the string -&gt; i32 conversion can be improved even more. Edit: yes, the type parameters were not needed.
I thought C++ methods/variables exposed by a .dll/.so became name-mangled C functions automatically, but I don't really understand what ABIs really are 
That's true, it can be very demanding. [This Week in Rust](http://blog.octayn.net/blog/2014/06/14/this-week-in-rust-52/) is very helpful in that regard Also, simply cloning the Rust repo and using some git-fu to find the breaking commit also goes a long way. Most breaking changes affect the stdlib itself too, so you can just look at the diff and replicate the changes on your own code
No worries! We have a style guide here: https://github.com/rust-lang/rust/wiki/Note-style-guide Some of them are still in a bit of flux, but it's pretty solid.
Check this out: http://stackoverflow.com/questions/1041866/in-c-source-what-is-the-effect-of-extern-c
We have an [RFC process](https://github.com/rust-lang/rfcs) to officially discuss features like this, by the way.
Depends how far you want to integrate -- but for technical stuff, business stuff, etc, yes. But there was a time when German was the language of Chemistry for example. These things change from era to era. When will we find that we all have to learn Chinese to keep up? Given the hardware hacking culture in China, I think we English speakers are already missing out on interaction with a very active scene.
omg that arg parsing code is beautiful compared to what I'm used to writing :)
Properties in C# are super useful. It's nice to have things that look like fields but are actually computed behind the scenes. Especially for API surface area (and in fact, with FxCop, you're basically forced to make public fields into properties for future flexibility :)) But I can definitely see how this wouldn't jive with rust's desire and motivations.
&gt; There's no point, other than for personal satisfaction, in learning other languages if you know English It might not be strictly necessary, but I think it is simply polite to have at least *some* knowledge of the local language if you're visiting.
With Java I could do the same by generating code (but nothing like so neatly). The advantage of generating code is that it is generated only once (first build from clean) and then the Makefile/whatever won't generate it again. Also, if there are any bugs, the generated code can be debugged in the normal way, line numbers in stacktraces are meaningful, and so on. But with complex macros, you're slowing down the compiler every time it builds your crate, and there is no intermediate code that you can look at to debug. About the only advantage with macros for this are that the compiler can check your macro syntax for language sanity before it is used (not afterwards like code-generation). I wonder whether a code generation solution is possible for Rust? I suppose you'd want a rustc option to dump formatted Rust source from the AST just after macro expansion. That would let you do all the complex macro stuff just once separate from your main crate build, for selected code. I guess this is not really in tune with the Rust mind-set, though. The thing is, I am someone interested in refactoring. If you want good refactoring support, you need to design the language with this kept in mind. You want easy reversible conversion between source and the AST. You want macros to be transparent to certain manipulations, and you may need some analysis to be able to reach into macros to see what they do without having to expand them fully (how would you pack it back into its original macro form if you expanded it first and then changed it -- not possible). So allowing unlimited syntax extensions and truly powerful macros just means no refactoring tools could possibly cope with them, and no analysis tools will really understand the code in its source form without expanding all the macros first. So which would you prefer? Refactoring and source-level analysis tools or complex macros? I don't think you can have both.
Yes but the alternative is doing all the work yourself. With 3rd parties you at least stand a chance to have that done for you, and given the past record with the mentioned libs... the chance is pretty damn high you will not even need to care about it ;)
I think you may be a bit confused about Rust's macros. I may be wrong, however. See if this stuff addresses your criticisms: Rust's macros are more powerful than C++ templates or other code generation. Check it: fn main() { println!("{:s}", 2); } This code has a type error. When we compile... hello.rs:2:26: 2:27 error: failed to find an implementation of trait core::str::Str for int hello.rs:2 println!("{:s}", 2); ^ note: in expansion of format_args! &lt;std macros&gt;:2:23: 2:77 note: expansion site &lt;std macros&gt;:1:1: 3:2 note: in expansion of println! hello.rs:2:9: 2:29 note: expansion site It shows our original code, not the generated code. You can see the expanded output: $ rustc hello.rs --pretty expanded gives https://gist.github.com/steveklabnik/ce1dc64bb991ba72f049
I think this might be some what peculiar, since code like `&amp;x.y` would sometimes be reference into `x`, and sometimes a reference into the stack (which has real effects in Rust: the lifetimes are different, meaning the former can sometimes be returned and the latter not), unless properties were to return `&amp;T`, similar to `Deref`, or have several different versions of them. Managed languages don't have this problem, because everything is just a uniform GC pointer.
Some knowledge, sure. But not learning the whole language!
I'd like to learn Chinese someday, but it's too complex for me; I can't even distinguish similiar glyphs... 
I wouldn't worry too much about it, I've never heard that rule in my life. :P I just pick numerals or words as I see fit.
Hay. I knew about the RFC but wanted to see the communities general attitude before filling one out.
&gt; Why? (better encapsulation) The parameters to a function/method/sub-routine expose some of what is happening within that function/method/sub-routine. We are exposing some of the inner-workings of the class/function/module/etc. Other than the name of the computed property and type (and functions also have names with type), nothing is being exposed about the internal workings of the class/module/etc. 
&gt; Rust tries to avoid magic where you can't see what's going on... I can see how this is a good feature of any language. But that also implies that encapsulation leads to magic. Further, architectures that are designed to be as loosely coupled as possible become very magical. I guess that is a tradeoff. &gt; I have some ideas for using the indexing operators once they land It looks like Rust already has, in the pipeline, a mechanism for implementing computed properties. The solution looks great to me. whatever[foo] = 6; // is basically the same as whatever.foo = 6; 
If the function is a "getter", it usually won't have parameters, so it is still equivalent to a property. Also, I can't visualize a case where parameters to a function expose the inner workings of the implementation. Could you give some example? EDIT: typo
&gt; This isn't really a new concept though: it is syntactic sugar Agreed. &gt; It is also syntactic sugar that helps separate interface from implementation, which I think is a good thing. I don't disagree, but the same effect can be achieved if getter/setter functions are used instead of exposing the fields directly
We don't expose all of the inner-working but some of them ("exposing some of the inner-workings"). We know, for example, that when we add we need two numbers. So a function: int a = Add ( 3, 5 ); means we know that somewhere within the internals of that sub-routine, we need two numbers. However, if we had: a = add.go; // OR a = add[go]; // using mcpherrinm's notation We in no way expose what is going on within the sub-routine.
Does this mean we should start trying to use it?
Yes, embarrassing for C++ zealots. Not for C++ people who really value producing quality code though.
We can start using it, but it's likely that we'll find some problems at this initial stage. But at least it does a basic job of dependency resolution and fetching from git. IMHO, it's important that we use it to help improve it nevertheless.
Upon reflection, I think you're arguing about bare functions X computed properties, which indeed are different things. My argument is that *methods* and computed properties are the same thing. For example, I could implement an `Adder` with has a `go()` method in two ways: struct Adder { a: uint, b: uint, } impl Adder { fn new(a: uint, b: uint) -&gt; Adder { Adder { a: a, b: b } } fn go(&amp;self) -&gt; uint { self.a + self.b } } Or: struct Adder { result: uint } impl Adder { fn new(a: uint, b: uint) -&gt; Adder { Adder { result: a + b } } fn go(&amp;self) -&gt; uint { self.result } } And a function that receives an `Adder` from somewhere else has no idea of which is the implementation strategy. I can't think how computed properties would be different here
Yea, but then you either have a lot of boilerplate initially: things need a getter/setter in case your implementation changes, or you risk breaking your API if your implementation changes. Properties remove this false dichotomy, you no longer have to choose.
I'd argue that it isn't really "a lot of boilerplate", since in Rust you can do a getter/setter in just one line, and would be pretty trivial to do *en masse* using a macro too. But I see your point, computed properties *are* convenient. I just don't see their inclusion in Rust happening, at least for now, as you can get the same effect otherwise with little effort
Sure! Feel free to find more people. :-)
No worries, just wanted to make sure!
In the bigger picture, it is about abstractions and how we mentally solve problems using these abstractions. In programming, it is really just 0's and 1's, stack pointers and malloc. We come up with a lot of abstractions like function, sub-routines, parameters, types, classes, attributes, accessors, "bare functions", and so on. How we solve problems and how we approach solving problems is driven **greatly** by the abstractions we are given and taught. So, sure bare bones, methods and computed properties are the same thing (just 0's and 1's in the end). Heck, functional programming and object oriented programming are really the same thing: bare bones. The concepts behind them, however, are vastly different. So, from a problem solving stand point computed properties and bare functions are quite different. It may look like syntactical sugar, but this code: Write [ text Adder [ left Adder [ left 7 right 5 ] right 6 ] ] ] (basically using computed property syntax for Rust if I understood another post correctly) is quite different from the look and feel of the code above. If Rust had computed properties (and it looks like it actually does), we could compose programs and write cool DSLs right in Rust. They would be blazingly fast and the syntax would be very very minimal. 
*Meanwhile, in a parallel universe...* I agree; we should *definitely* remove indexing! After all, `a[i]` is really just syntactic sugar for `a.at(i)`. Worse, it can hide potentially expensive operations taking place! We should be trying to limit the presence of magic wherever possible. Really, I don't see how `.at(...)` is any less convenient; it's only three characters more than `[...]` (less than the five `.set_*(...)` is over `.*=...`). It does make switching from a bare array to a user type inconvenient, but that argument was soundly defeated during the great Computed Properties War. So yeah; slash and burn! --- (Note: yes, I am deliberately playing devil's advocate. No, I'm not really in favour of removing indexing on user types.)
I don't think we're communicating effectively. I was unable to understand the syntax on your post, or what you're proposing. This might be my own fault. I would like to ask you to present more concrete examples of what you think should be possible. I'm having a hard time visualizing how the excerpts you posted would impact the big picture. If possible, try creating an example at [the playpen](http://play.rust-lang.org) of how you would solve the problem today, and one of how you would like to be able to solve it. Could you help me with that?
Am I totally off my rocker here, or are Rust's often impenetrable use of variable names leading to horrible readability? 
~~I'm disappointed to see that non-rust compilation is not seemingly thought out.~~ I just suck at reading and misinterpreted the bottom of the README. Wasn't this something that was semi handled in the past with ~~whatever it was~~ rustpkg and pkg.rs? edit: To further clarfiy, I was thinking of things like codegen-ing Thrift/ProtoBuf/etc stuff as well, but it seems that could be in the scope of cargo
We've spent quite a few years researching a new programming approach. What makes this approach possible is computed properties + a lot of other changes in how to approach programming. I'm willing to talk about all those other changes but they aren't language specific (other than the computed properties thing) so I don't think it belongs in /r/rust (private message me and I'll send you links to blog posts). All we would need in Rust is computed properties and we could programming in Rust using this new programming approach. The syntax was based on this suggestion by mcpherrinm: struct Whatever; computed_props![Whatever, get Foo =&gt; || { ... }, set Foo =&gt; |&amp;T| { ... }, ] ... whatever[Foo] = 6; println!("{}", whatever[Foo] which, from what I understand, is coming down the pipeline. 
Cool. I think we can wait a year. :-)
Hashmaps are one thing, but off the top of my head I don't know if it would be worthwhile to extend this policy to other types. What would the `T` in `Rc&lt;T&gt;` become, for example?
Part of me was just eager at the opportunity to try out inline assembly in D, which I hadn't used before. It also wasn't that much work to write; still more concise than the Java equivalent...
There hasn't even been an alpha release yet.
I think a primitive part of my brain took over and I couldn't shake the thought "Ug, code slow, must rewrite loop in assembly".
Thanks! Would you or anyone else reading this know if there's an up-to-date Arch Linux Rust package? The version in the community package doesn't recognise the PartialEq trait.
Does Rust have a stable sort? I just found the D implementation can be changed to match the C++ by using a stable sort, possibly because the output of meals may already be partially sorted. I suspect using a stable sort in Rust would make it as fast as the C++ too.
Sigh (at myself). Thank you wycats :).
Not sure if this helps, but you can specify lifetimes in traits: http://is.gd/GbTcrc .
Your example, where you add 'a to The &amp; in &amp;str, you don't actually explain what this is doing semantically or why it actually fixes the compilation error message. As such, I have no further understanding of what's going on in the example after reading the explanation than what I came in understanding. Granted, looking at it with my already existing understanding of lifetimes, it's because you have a reference to data that is not in lexical scope. Also, using &amp;str seems like a bad idea for tutorials because there's no bare `str` type, and if you don't know that, you're likely to get confused. With the Chars&lt;'a&gt; example, you are leaving out the full type signature and it seems to be similar to if you left off the shape parameters such as `let map: HashMap = ...`. It tells me about how type parameters work in general, but nothing about lifetimes specifically. Finally, 'This tells the compiler that the lifetime is bound to that string.' means nothing to me. What does it mean for a lifetime to be bound to a structure? Overall, I'm seeing superficial explanations that are assuming the parts that are needed to understand lifetimes or just discussion about what you do without explaining why you do it or what it actually does.
I think its somewhat confusing focusing on lifetimes in structs to begin the explanation, since there's not really concrete values like you see when returning things directly from functions. (E.g. taking a `&amp;str` and returning a `&amp;str` with no leading or trailing whitespace (the `.trim` method).) Also, it's disingenuous to talk about GC languages having "lifetimes". Values in GC languages just live for as long as necessary, there's nothing scope based like Rust's lifetimes.
Thanks for the feedback! I've got an edit coming that addresses those things.
`T` is suuuper well known as a type name. It should stay that way, imho.
Makes sense. Thanks for the answers! It's been very interesting to study playpen's code and its design decisions. You are obviously very knowledgeable about Linux and security. One last question: Have you considered using Docker instead of writing something from scratch? They seem to have large overlap
rust-nightly from the AUR gives you an up to date version without pulling down several git repos. It still takes a while to compile, though.
&gt; Have you considered using Docker instead of writing something from scratch? They seem to have large overlap Docker isn't much of a sandbox, it's a system for deploying applications bundled with their environment. The fact that they both use namespaces and a chroot doesn't mean much as that takes less than 10 lines of C code or even fewer lines via the coreutils/util-linux utilities.
What does 'within' mean, exactly? This sounds the same as 'equals to,' at least in the example. I'm thinking of the second example that first one is, uh...
*At least* a year. And that’s just before we start *discussing* them again—reckon on at least another year on top of that before it gets implemented, if it does at all.
Me too! I prefer two, but four is bearable.
&gt; Am I totally off my rocker here, or are Rust's often impenetrable use of variable names leading to horrible readability? No, on the contrary, it helps keeping visual noise at a minimum. That said, sometimes it can make sense to use longer names.
So you want lifetime b to be &lt;= lifetime a? Couldn't you just say that lifetime b = a, and have that settle that? Just use a for both cases, no need for b. `fn foo(foo: &amp;'a Bar, bar: &amp;'a Baz) -&gt; ()`
I think the true problem here is that generics are really noisy in rust, and that takes away from understanding what the types are, needing to declare them more verbosely, adding more noise. If we used non one letter names for our generic type variables, I am almost certain it would bring more confusion than understanding.
Rc&lt;Type&gt; or ReferenceCounted&lt;Type&gt;, which has the advantage that it almost reads like English.
I think you want /r/playrust
good luck typing that
it should be easy to type without any special editor features
In Haskell, declared types are always uppercase and type parameters are always lowercase, thereby avoiding having to explicitly introduce the list of function type parameters, as it can be inferred (every lowercase type is a type parameter). They also skip the brackets, so our `Map&lt;K, V&gt;` is their `Map k v`. It's not clear that either of these ideas could be adapted to Rust.
Programs should be optimized for reading, not for writing. Code is read more than it is written.
But Rc is easier to read
'run' how? Hows that going to work for windows machines? (powershell? msbuild? *shudder*)
I noticed that the version of `rustc` I had installed wasn't the last one, I'll try to update and see what happens...
&gt; (My specification of C♯ rather than Python as the prototype for properties is very deliberate in quite a few ways.) I’d be very interested if you could elaborate on that, please?
I always think of "resource" or something
&gt; D has exceptions and garbage collection It also has `nothrow` and `@nogc` (the latter in the upcoming release) to strategically disable these features. Of course, you may not be able to use some parts of the standard library then.
correct link http://floor-org.github.io/floor/struct.Floor.html#method.utilize
Lifetimes are just a monoid over the associative operation of intersection and an identity element of `'static`, what's the problem?
Why not just implement the `Foo` trait differently for the types that you want to be different, rather than deriving the `Bar` trait from `Foo` and then trying to override `Foo` methods? If this is about minimizing the amount of code that needs to be written, I believe a macro could generate implementations of `Foo` according to given parameters, but I haven't written such a macro myself yet. (maybe I haven't understood) 
I'm not a native English speaker and I find it annoying because it's usually off-topic.
Hey Nihy :-) The problem is that the `create_all_the_things` function would not be possible if `Bar` didn't derive from `Foo`. Being able to override `Foo`'s default method with a default in `Bar` would allow us to call the `create_a_thing` method for all of A, B, C, D, E and F in one big loop, while having each of their `Thing`s created in a unique way! (like in the `create_all_the_things` function) edited: for clarity
Ah, you want Trait objects: #[deriving(Show)] struct Thing { uniquely: bool } trait Foo { fn create_a_thing(&amp;self) -&gt; Thing; } struct A; struct B; impl Foo for A { fn create_a_thing(&amp;self) -&gt; Thing { Thing { uniquely: false } } } impl Foo for B { fn create_a_thing(&amp;self) -&gt; Thing { Thing { uniquely: true } } } fn main() { let creators = vec!(box A as Box&lt;Foo&gt;, box B as Box&lt;Foo&gt;); for creator in creators.iter() { println!("{}", creator.create_a_thing()); } } I had to make `create_a_thing` a method though. If it doesn't need to be a method, you may as well use function pointers.
Thanks for the suggestion Nihy! This is actually my current workaround! The problem that I'm often running into though, is that I have LOTS of types (I only used 6 in the example, but there is often a lot more), and half of them need one version of `create_a_thing`, while the others need a unique version of `create_a_thing` (though with the same signature so that I can loop over them), and I don't want to have to code two functions everywhere that I'd like all my types to create their `Thing`s. My hope is that, if I could simply override the method within the child trait itself, that 1. I wouldn't have to `impl` `create_a_thing` in the same way for half the types, and then in another way for the other half of types (remember there are lots) and 2. It would allow me to call all of their `create_a_thing` methods in one big iteration. Thanks for your help btw!
That's where macros could be useful: macro_rules! impl_foo( ($obj:ty, $unique:ident) =&gt; ( impl Foo for $obj { fn create_a_thing(&amp;self) -&gt; Thing { Thing { uniquely: $unique } } } ) ) impl_foo!(A, false) impl_foo!(B, true)
I'm glad I could help! It believe it's even possible to make a macro that writes the implementations for a list of types in one go.
Enjoy the wizardry: http://is.gd/Z8qtCU
I think the OP didn't realize that "objects have the same lifetime" really means "objects created with that lifetime will last at most as long as the first object", which means latter objects are (strictly speaking) shorter-lived. I.e. in an abstract sense, lifetimes are not the same, they just end at the same time.
I think it's a leap to presume that a longer name implies a more readable name. `Rc` is one of the most common types in the standard library, and "RC" is an industry-standard term for reference counting. In this specific circumstance, renaming the type to `ReferenceCounted` would just reduce readability.