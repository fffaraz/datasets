From the riir repo: https://www.google.com/search?q=site:github.com%2F*%2F*%2Fissues+rewrite+rust It's kind of an epidemic. 
Just make an OS package manager package, it's what they're designed for. `cargo install` is really not built to install arbitrary programs.
&gt; It's an insane amount of work Maybe not. Maybe a complex problem can be reduced into relatively small core? It doesn't have to imitate a web engine after all. A lot of research is required though. &gt; with little payoff Even text editors use a web engine nowadays. In the modern world, we really, *really* need flexible and responsive UIs. But the only thing we have now to implement such UIs are web engines. 
&gt; 2\. using a special calling convention in which the callee returns a pointer + length to the caller, and the caller is free to decide whether to memmove/memcpy or not (depending on the gap in the stack, I'd guess). Doing so violates... \-- Windows x64 ABI: &gt; All memory beyond the current address of RSP is considered volatile: The OS, or a debugger, may overwrite this memory during a user debug session, or an interrupt handler. \-- System V AMD64 ABI: &gt; The 128-byte area beyond the location pointed to by %rsp is considered to be reserved and shall not be modified by signal or interrupt handlers. (i.e., all memory beyond the red zone is considered to be volatile)
ioctls are deprecated for network configuration these days, one should use netlink (probably nl80211 for this particular use case).
eeeeee that is so cute, you are the best!!!!! &lt;3 &lt;3 &lt;3
I hadn't seen that...my desugared version should probably use an inner struct. And you're probably right that it would be complicated from an ownership perspective to have anonymous impls of traits with more than one required implemented function, but a lot of the important traits (Iterator and Future being two good examples) only require a single implemented function.
You can do this by creating `src/bin/*.rs` files. They can `extern crate` the rest of your codebase as a library, and each file is compiled to its own executable when you `cargo build` and you can `cargo run --bin crate_name`
in your Cargo.toml, this should work I think: [[bin]] path = "src/client.rs" name = "client" [[bin]] path = "src/server.rs" name = "server" And then `cargo build` should produce both by default.
but the bombing of guernica and other civilian targets wasnt only legal in nazi germany but was(and is) legal by international law. Which just shows how weak international law actually is 
s/examples/src\\/bin s/--example/--bin
Oh cool, this is the first I'm hearing of the Tor team expressing interest in safer languages. Are there any sources on previous discussions they've had on this topic, or is this the first they're publicized?
That is a beautiful cover
This is especially relevant due to the recent legislation concerning net neutrality. This is Rust's bread-and-butter, and I really hope that if they go with Rust, they take a hard look at `tokio`, as it would likely make their code much simpler. It would also be nice for the tor browser, since doing it in Rust may make it easier to integrate since Firefox is also moving to Rust. If they go with `Go`, that's pretty awesome too, and the features there will make things quite simple. I'm still pulling for Rust, but just having the discussion is fantastic news!
I read a stray remark somewhere some time ago by a dev
Looking forward to the blog post on this.
I'm in for helping on this...
Cool! You should include the game itself in the post (or a link to it) so people can see it in action.
Do you know what platforms those are out of curiosity?
I think the important difference here is that this is the project coming to their own conclusion; this isn't an outsider demanding a change. Tor did have a "Rust?" bug open, but I don't remember it being particularly demanding, more of a question.
Part of the reason RIIR-plz is even a thing at all is because of the relative ease of incremental rewriting. Most other languages would make it very hard to rewrite individual functions piecemeal.
Yes, but this is a slippery slope to accepting tooling that just plain sucks. Static typing does have a place. 
That is an excellent point that cannot be said enough. Rust will stop you from breaking memory safety, and sometimes that means deliberately killing your program. IIRC, the new Rust Book talks about how to grow from panics to Results as error handling routines, with panics being a good "okay let's get this building" and Results being "okay let's get this shipping". IMO, we should report panic safety in the same way the C++ stdlib reports exception safety as part of library APIs. The doc conventions already encourage that, and I'm thrilled that this mindset seems to have taken root, to the point where finding panics like this is an achievement and a priority to fix. Mad props to both OP and burntsushi on this one.
True, especially languages that require a GC.
It's not like that doesn't happen in [c++](https://www.google.com/search?q=site:github.com%2F*%2F*%2Fissues+rewrite+rust#q=site:github.com/*/*/issues+rewrite+c%2B%2B&amp;*), [c](https://www.google.com/search?q=site:github.com%2F*%2F*%2Fissues+rewrite+rust#q=site:github.com/*/*/issues+rewrite+c&amp;*), or [python](https://www.google.com/search?q=site:github.com%2F*%2F*%2Fissues+rewrite+rust#q=site:github.com/*/*/issues+rewrite+python&amp;*) far more often. 
For that, matter, other languages (c, c++, python) also seem to have bigger issues with evangelism. 
Quick follow up. I now have my client in the src/bin/ folder and the layout looks like so. src/ lib1.rs lib2.rs bin/ client.rs I'm not sure how to get client.rs to see the libs though. You mentioned using extern crate but the only way I know how to use that extern crate lib1 isn't working out for me. Maybe I have to add something to my Cargo.toml?
I'm sure that if Rust doesn't work out, it'll be back on the table. But yes, I got that same vibe as well.
Congrats! Awesome work!
IIRC, cargo only allows one library crate per package. So you would have to do something like extern crate nameofmypackage to have your binaries use your library code.
You'll be pleased to know there's been some movement on the [relevant bug](https://github.com/rust-lang/cargo/issues/1982). :-)
I don't think so, the tone and vibe in that mail was completely against Go. I am not saying it was wrong. I do completely agree with it. AFAIK The reason is they need almost perfect C interoperability, and it seems Go does not provide it. (I do like Go. but It seems -I am not sure- it is shortcoming).
Maybe if a method is marked to be inlined there can be a special case...?
They've been discussing it internally. Also, https://github.com/hdevalence/curve25519-dalek is part of a cool bridge anon reputation system that is probably going to be mostly in Rust.
I'm using [rust-postgres](https://github.com/sfackler/rust-postgres) in a data access module to pull one result from a database and return it to the callee as a struct. The code is working but I'd be curious to see how close or far it is from idiomatic Rust or to see if there any other unknown unknowns I'm missing. One thing that's immediately obvious is to pull the connection out of the function and suggestions for best approaches would be useful. As a note: all the examples I found for pulling results from the database iterated over the results and printed them out to console. I found [one example](http://hermanradtke.com/2016/05/23/connecting-webservice-database-rust.html) that put the results in to a Vector and returned that from the function. The first approach isn't useful for my use case since I need to return the value and not just display it. The second approach seemed overkill for working with one row. This is why I settled on the approach below. Here's the code: pub fn get_one() -&gt; Option&lt;models::Post&gt; { let conn = Connection::connect("postgres://postgres:mypass@localhost:5432/blog", TlsMode::None).unwrap(); let result = &amp;conn.query("select * from apiv1.posts limit 1", &amp;[]); if result.is_ok() { let row = result.as_ref().unwrap(); Some(models::Post { title: row.get(0).get(0), body: row.get(0).get(1), }) } else { None } } Thanks,
I'm glad to see *someone* thinking about supporting SIMD address spaces. Obviously, if operating on higher dimensional integers and floats is faster and better, then operating on higher dimensional pointers must be faster and better too. And while we're at it, we should probably add support for `&lt;strong&gt;` types, to help guide the optimiser to the types we know need the most optimising, and `&lt;em&gt;` types for those that need to be inlined entirely. Ooh, we can use `&lt;span style="color:red;"&gt;` as an additional indication of unsafety! Such possibilities...
This is especially relevant due to the web log post on this.
Here's the extent of the technical work I accomplished this week: https://github.com/diwic/dbus-rs/issues/72#issuecomment-290581407 It's a prototype of dbus integration into tokio.
Hi there, OP here. Wow, you really do watch everything. Please don't get super hyped, we're trying to be careful and this is a volunteer effort on the part of Tor for now. That said, we're excited and value any constructive criticism and pointers where we might not be following best practices. I'm quite blown away by the response we've received so far.
I propose `&lt;blink&gt;` to denote existential types. Alas, I have yet to think of any use at all for the `&lt;marquee&gt;` tag...
Okay so the comments in this thread answer my question about the maroon screen being flashed while having WebRender enabled. 
I am as well. :'(
Wow didn't realise that RIIR had become an initalism
[good work](https://twitter.com/rustevangelism/)
I mean I understand why curl is going to be maintained in C; the maintainer did explain that pretty well. What I don't get is why Rust has the reputation when other languages do the "rewrite in X" stuff, e.g. [c++](https://www.google.com/search?q=site:github.com%2F*%2F*%2Fissues+rewrite+rust#q=site:github.com/*/*/issues+rewrite+c%2B%2B&amp;*).
The book is now available for pre-order on Amazon UK: https://www.amazon.co.uk/dp/1593278284/
I hope `&lt;script&gt;` types are considered. I like the idea of using flow and typescript to type my type metapeogramming javascript. 
I wonder if this RFC enables sub structural typing with LaTeX? 
We could repurpose `&lt;marquee&gt;` for lazily evaluated types or something to do with continuation passing style. After all, `&lt;marquee&gt;` is not broken if you change the part that hasn't been displayed yet.
Alternatively backtalk could expose a `hyper::server::Service`. That would allow the user to wrap the backtalk service in other services to provide authentication and logging. I like the ideas behind the following pull request https://github.com/tokio-rs/tokio-service/pull/17 
Yeah, Text and Texting sound great! Not sure about Byting, though.
That's a joke right? Because as the only answer..
Proposal: replace `Iterator&amp;lt;Item=T&amp;gt;` with `&amp;lt;marquee&amp;gt;T&amp;lt;/marquee&amp;gt;`
When will WebRender be enabled by default in Nightly? When will WebRender reach performance parity with current Nightly?
I went looking for this post just so I could leave an appreciative comment about the seasonal theme. I particularly liked finding the mushroom trombone guy in the header image.
Thanks for the lol. I think my brother thinks I'm nuts for bursting out laughing...
&gt; After all, Haskell still has no way to declare two structs with the same field name Not true! It now has a `DuplicateRecordFields` extension for just that =P Anyway, in Haskell, we denote the difference between a monad and a transformer with a capital `T` suffix. It's short, simple, and doesn't involve reworking the name to be grammatical. I'd probably suggest finding something similar for this stuff. `StringR`, for instance, for "reference."
What are the missing features in rust the author is referring to?
Hm, that's a bit broad of a question, type theory is an extensive field (and as you may have determined, today is an interesting day to have asked this question :P ). There's no single "type theory of Rust", but for essential type theory topics that apply to Rust you'll want to familiarize yourself with Hindley-Milner type systems (which is *sort of* what Rust has), as well as uniqueness types/linear types/affine types (all related, but slightly different). And if you're just looking for a long list of papers to browse, check out the Rust bibliography of papers that influenced or were influenced by Rust: https://forge.rust-lang.org/bibliography.html
Not sure if totally serious (1-april, and my sarcasm meter warned me at slic for slices), but I actually think it would be nice to improve naming consistency.
___Fearless concurrency.___
Why not an O suffix for owned and B suffix for borrowed. Then the data type is otherwise the same. 
Wait, isn't April 1st considered an "all memes allowed" day?
I hate April 1st, as it's not actually April 1st for me, it's already April 2nd in NZ. 
This should better be a static method taking a pointer to an object. Then the compiler would not make any assumptions on not-nullness of the pointer. 
Lurker here, keep meaning to try Rust but haven't yet. I always assumed borrowed vs owned would be done with a qualifier like const/volatile in C++. Why isn't it done that way? How does it work for types you write yourself? Do you come up with two names?
You guys are probably right. Is there a nice packaging service that supports rust? I head a lot of good things about the openSUSE Build Service but it seems that it does not support rust. Also holy-build-box (https://phusion.github.io/holy-build-box/) does not seem to support rust.
I think we can do better: I hereby propose that the FSF mandate all FSF project maintainers rewrite their respective projects in safe, idiomatic Rust. Projects that are not brought within compliance should be kicked out. I realize that this might possibly be perceived as heavy handed, but I truly believe that the benefits Rust will bring to these projects will be well worth it. It's a trade off I, as a someone who is not affiliated with the FSF, am willing to make.
It's slow I think, but some work is still going on :) there was a new release early 2017. 
Found the Hungarian
100% true story follows, minor strong language. A group of myself and some coworkers were traveling to California for work and we were waiting at some airport in the middle of the country on a layover. We wandered into a sports bar type restaurant to get dinner and were seated at a big shared table. To my left were two guys. They seemed to be in the same situation; traveling for work. After eavesdropping for a while, I realized that they were talking about writing C code, but not just *any* C code, but high-performance networking as well as low-level microcontroller stuff (I wasn't quite sure if this was two projects or just one). Although I'm not the *most* extroverted person, I do love me some Rust, so I decided to broach the subject in the most amusing way. I waited until there was a break in their conversation and interjected: &gt; Excuse me, but have you heard **The Good Word**? I don't think I've ever seen someones face fall so fast. I sympathize; the last thing you want in an airport is to have someone start telling you how to live your life. So I quickly added: &gt; The good word about Rust? To which one guy responds: &gt; I'M NEVER GOING TO USE NO GOD-DAMNED RUST! Which was not what I expected, so all I thought to respond with was: &gt; Ah, so you *have* heard of it? ---- We actually ended up talking more, and it turns out that he couldn't use Rust because all the compilers they use are provided by the chip manufacturers. They don't get to *choose* what language they can use, which is an alien concept to me. However, I think there was a chance they might have been interested, were circumstances different.
First, to eliminate the `if is_ok() { Some } else { None }` thing, you can use `.ok()` together with `if let` Like this (not tested, should work): if let Some(ref row) = result.ok() { Some(models::Post { title: row.get(0).get(0), body: row.get(0).get(1), }) } None Now, I have worked with the rust postgres (and the rust-postgis) crate, I am not too fond of their API. Your program would panic if column 0 did not contain a title-compatible data type (for example, if the table isn't [title, body, footer] but [footer, body, title]. What I do to prevent this is that I scan the columns first to get the indices of the columns (especially with larger tables with 40 columns I do not want to do a lookup every time I get a value) and store interesting columns (let's say I want only column "user_name" and "last_time_visited" out of 40 possible columns - I save the indices 23 and 27 somewhere and can be sure that it doesn't crash). Every query also returns the columns.
Normally, it is. The borrowed equivalent of `i32` is `&amp;i32`. The borrowed equivalent of `HashMap&lt;String, TcpSocket&gt;` is `&amp;HashMap&lt;String, TcpSocket&gt;`. This pattern works for the types that this post is about, too. `Vec&lt;i32&gt;` can be borrowed into `&amp;Vec&lt;i32&gt;` and `String` can be borrowed into `&amp;String`. People don't want to use these for two reasons: * `&amp;T` is represented by a pointer to `T`, under the hood. But `Vec` and `String` are just pointers to their heap allocated contents. Nobody wants to have a pointer to a pointer, since it doesn't accomplish anything. * These types can only point at a single heap allocated buffer. We want to be able to slice them without reallocating them. Hence, the slice types.
There is at least one persistent troll who makes a big deal that "anything not Tier 1 might as well not be supported". While they are a troll, I imagine others feel the same. In this case, though, you'll want to dig through all the comments in https://bugzilla.mozilla.org/show_bug.cgi?id=1284816 (which I see you've posted in) for example: https://bugzilla.mozilla.org/show_bug.cgi?id=1284816#c26 &gt; So, with the current situation, making rustc a requirement for Firefox will effectively kill Firefox on everything but i386, amd64 and arm64 for Debian unless someone is really willing to pick up all the extra burden to fix rustc on the non-x86 platforms. &gt; &gt; I honestly think that killing the portability of Firefox is a bad decision and might lead to Debian or other projects forking Firefox again like it happened with Iceweasel to allow keep using the browser on targets like the Raspberry Pi or modern embedded MIPS machines.
This playground update includes: - Served from HTTPS, thanks to [hyper-native-tls][1] - Format code with the [proposed RFC style][2], using the dropdown on "format" - When the nightly channel is selected, MIR output is available - Make sure the code compiles before using alternate output! - There's a [help page][3] that describes available features [1]: https://github.com/sfackler/hyper-native-tls [2]: https://github.com/rust-lang-nursery/fmt-rfcs [3]: https://play.integer32.com/help
Not to mention the clothing. I always lose my "G" strings, so I end up having to borrow them from others. Clearly, my memory's not that safe anymore, given that it's starting to get a bit rusty. The downside is that when I return them, they always tell me to never mind, or they'd just put it in a destructor. (Admit it, you automatically counted all the references, didn't you?)
The tip off is: *Despite these advantages, Rust does have a fatal flaw. Now, having fatal flaws isn’t a deal breaker in itself.* A _fatal flaw_ isn't also a _deal breaker_? What good is a deal if you are dead? 
Uh, where is this in the custom CSS...?
&gt; Unfortunately, he taught his apprentice everything he knew, then his apprentice invented Rust. *It's treason, then...*
Why are there even different type names for these things? If you take a look at the windows API, one of the (many) huge warts that serves as a warning to other API designs is that fact that they alias the same underlying types to different things over and over. This distracts from the real data you are working with, which of course is the whole point. Not only that, it creates all sorts of false dependencies on those names being defined. Now you have to go search and make sure you have some type you haven't seen defined, only to find out that it is a void* or a int. Before anyone says that it makes things less error prone, remember that the data already has a name by being in a variable. 
For any newbies, this is fake. The name of the type doesn't determine whether it is owned or borrowed. &amp;String is the borrowed form of String. It can be *coerced* to &amp;str, but that is a different type. 
Python has a similar convention which I quite like: 3rd party imports are grouped at the top of a file, then an empty newline, then stdlib imports, newline, local imports. I like your suggestion to alias all crates, that could really help. Perhaps once RLS comes along, we can have IDE support for getting a tooltip to see what kind of item a mod or crate symbol is...
Oh, that looks really cool. Seems like a good tool to use when learning assembly as well. :) Thanks! 
Electron used well is pretty performant. Visual Studio Code runs great even on my Raspberry Pi 3.
I often kid that my only wishlist item for a Rust 2.0 is to rename `String` to `StrBuf`.
I knew there had to be a way, thanks!
Good lord, you wrote 3 thousand lines of CSS?! That's quite a bit of work for an April Fools joke.
Regardless, that's a huge amount of work for an April Fools joke.
You could extend [trust](https://github.com/japaric/trust) to make some packages from the Linux tarball it generates.
I think more interesting is that python orignially did not distingush between relative and absolute imports. Maybe the change to distinguishing between them is something Rust should take a lesson from.
Thanks for the feedback. So it sounds like your suggestion regarding the columns is that you'll scan the tables on program startup and store the column names and index in something like a Map. Then you can grab the column index by table name quickly rather than having rust-postres search for them each and every query. Seems like a good idea and I'll look into it.
In all seriousness: Mods, please keep this theme up. It's super awesome, and I think it shows that we as a community can have a bit of fun and show some personality.
Some sort of notation like this would make things much simpler to follow. Or a symbol for owned and no symbol for borrowed. 
Have we considered going door-to-door to spread the good word of our Lord Djikstra
Well clearly you still have deals with the devil.
"Fearless concurrency." "Code safely!" "Rewrite it in Rust!" "[Darth Stroustrup story]" These attention to minute details!! I love it! xD EDIT: So it is randomly assigned...
I agree, though I'm already using [this one](https://userstyles.org/styles/133277/reddit-no-frills-dark) across all of Reddit. Btw, a screenshot for people like me: [screenshot](http://i.imgur.com/m7JtDhU.png) (and just pretend you see [the scrolling banner](https://a.thumbs.redditmedia.com/WL2N__CZ3HZzWLUQZPtY3mMh8KXgpVpvj9zxfLFZfK0.jpg)).
We're not going to keep this theme, dear god no. :P But I will take it into consideration when I redo the base theme later this year.
Is it rewritten in Rust yet?
Do you know of a library, in any language, that _generates_ Markdown?
People always tell me they broke a G string fingering A-minor. But I usually break my G string during tuning, not actual play.
It sounds pretty hairy to share the same struct between the two libraries. How about writing your own macro that accepts your struct and generates the mirror structs and conversion methods?
I exported the stylesheet for use with stylish: https://gist.github.com/cmsd2/c824b9dad35d0f3ef59fbf9f3ba8368a do what you will. ***Fearless concurrency.***
hello darkness my best friend 
This is really cool. I'd love to read one of these, with diagrams of course, explaining how pulldown-cmark works. When I hacked together a bug-fix, I found it difficult to follow... Stepping through the code in a debugger and piecing together the control-flow took longer than I would have liked. EDIT: I hope this didn't come off as complaining, language is hard. I like pulldown-cmark, the code and concept is really interesting.
As you probably know, `&amp;mut` references are unique. The compiler understands that `&amp;mut universe.player` and `&amp;universe.worlds` (or `&amp;mut universe.worlds`) point to different parts so there is no actual overlap. That's why your original code works. Now, if you call `universe.get_player_methods()`, that takes a reference to all of `universe` (`&amp;self`) and that includes `universe.player`. Even if you don't actually use `universe.player` inside the method, the compiler does not see that nor does it attempt to. On the topic of keeping your code clean, I'm not sure to help you there from this snippet. You may be able to make universe.worlds indexable by player, so you could write `universe.worlds[player]` Also, `ref mut` patterns are really only necessary when destructuring references to some container type like `&amp;Option&lt;T&gt;`. The typical way here would be let player = &amp;mut universe.player; let world = &amp;universe.worlds[player.world];
There's a trivial solution to this particular problem (assuming that I understand your code correctly), though in the future it's easier to get help if you provide runnable code examples rather than having us guess the type signatures. :) Here's the equivalent of your first, working piece of code: https://play.rust-lang.org/?gist=1e2aeb54494bc8aeacb6f8c9c30380d5&amp;version=stable&amp;backtrace=0 Here's the equivalent of the code that shows the error that you get when you try to factor out the logic into a method: https://play.rust-lang.org/?gist=457f1b17ef831af7e6d37eb48c2cffe7&amp;version=stable&amp;backtrace=0 The problem in the second snippet is that Rust wants to borrow `universe` very briefly (for the scope of only a single statement) in order to pull out a world, but you've already got `universe` borrowed from the previous line. So the solution in this particular case is trivial: just reorder the lines, so that the short borrow happens first, then expires, then the long borrow happens. :) See https://play.rust-lang.org/?gist=f4aa3aafb28c91a56debf1344b858809&amp;version=stable&amp;backtrace=0 . In more general cases, an alternative solution could be to insert a `clone` call somewhere so that all the references are pointing to distinct pieces of data, like so: https://play.rust-lang.org/?gist=63cd36666a0225b8b0edd2fcfd93b95a&amp;version=stable&amp;backtrace=0 (though we have no idea what a Player really is, so we have no idea how expensive cloning is in this case). Other solutions could be presented if we knew more about what you wanted to achieve (for example, you can often prove to the compiler that two different struct fields aren't being borrowed at the same time by using destructuring assignment on the struct that contains them). And as others have mentioned, it's generally preferred to write `let foo = &amp;bar` and `let foo = &amp;mut bar` instead of `let ref foo = bar` and `let ref mut foo = bar` (the `ref` pattern is really just there to help make pointers line up properly in pattern-matching contexts that *aren't* assignment). EDIT: It occurs to me that my mockup of `get_player_world` may be wrong, which would invalidate my first answer. Can you tell us what its type signature is?
We should hit up the gcc bug mailing list and tell them it's time to convert
I'm using gfx-rs. Is there a way to read Texture contents?
My last company followed systems Hungarian for PHP apps and it was fucking terrible. Apps Hungarian might have been better, but even then it was probably more of a hassle then it ever would have helped.
Worse is lying Hungarian apps when the types change but people aren't using a tool that allows easy refactoring. 
Try RedditEnhancedSuite it has a dark theme and much more.
I'm actually based in NZ as well, but posted the article later so that the Americans and Europeans didn't feel left out. You can't please everyone, I guess.
Byting is my fetish
Why stop there? Someone should re-write Linus himself in Rust. Let's take this all the way to the top!
There was a large bikeshed over this pre 1.0 and thas was also one of the larger contenders. We do have some strange syntax there.
Don't do this. Then you're passing a pointer to uninitialized memory to `read_exact`, inviting undefined behavior. The cost of initializing the Vec to zero is negligible.
It has – you're seeing the compiled version (until all browsers implement RustCSS).
Cool, no rush though. Yeah, I was one of the successful, although my contribution was minor. This was my first experience with a pull parser, so I probably should have looked for a good article instead of trying to learn it all from the code. Still, if any contributors are looking for a topic to blog about... :D
Well yes ofc that's the point. Is it really Undefined Behavior if read_exact fully initializes the vector and never reads uninitialized memory? Or is it just... unsafe?
I have a project I've been working on with a friend that uses a custom declarative ui language and webrender for rendering, aim is to be a crossplatform ui engine that could be used for building applications in rust, the layout layer for a game, etc. If anyone is interested in perhaps chipping in before it's public, let me know.
`[]Buf`
See also: https://github.com/FascinatedBox/lily/issues/294
I've left my tidings there. I truly hope the poor soul finds solace someday.
Haha, that's actually perfect. The main reason I'm interested in assembly at this very moment is because I'm writing a Scheme interpreter, and was thinking about how to improve the speed of it (e.g. by compiling). I'll definitely check that out, thanks a lot!
Awesome. Glad I could help. If you need a GC and don't feel like writing your own, check out this immix GC written in Rust: * Paper: http://users.cecs.anu.edu.au/~steveb/downloads/pdf/rust-ismm-2016.pdf * Implementation: https://gitlab.anu.edu.au/mu/immix-rust
Yeah, let the edgelords use their own custom CSS if they want red on black or whatever. There are plenty of ways to do that.
I'll take a look! I started writing a really dumb gc (branch through all "environments"/closures from the "root"/start environment and remove all the ones that weren't touched) but realized that my interpreter did some crazy shit which made it hard to tell which environments were currently being in use by functions being called without being defined (basically anonymous lambdas). So right now I'm making it stackless by putting all "commands" into a queue, and I think my gc will work better once I'm done with that, since it will be easier to check which environments are currently in use by the evaluation. In regards to the first article you posted, is it plausible to follow it but use rust instead of c? Seems like a good way to learn more about rust as well. :)
 ______________________________________ ,' `. / \ | Hey bob! | | | \ / `._______ _____________________________,' /,' /' .--._.-----._.--._.----. .' \ (`._ (_) _ \ .' | '._) (_) | \ _.')\ .----..---. / |(_.' | / .-\-. \ | \ 0| | ( O| O) | o| | _ | .--.____.'._.-. | \ (_) | o -` .-` | | \ |`-._ _ _ _ _\ / \ | | `. |_||_| | | o | \_ \ | -. .-. |.-. \ `--..-' O | `.`-' .' _.' .' | `-.-' /-.__ ' .-' .' `-.' '.|='=.='=.='=.='=|._/_ `-'.' `-._ `. |________/\_____| `-.' .' ).| '=' '='\/ '=' | `._.' '---------------' //___\ //___\ || || ||_.-. ||_.-. (_.--__) (_.--__) 
what pitiful abeisance. rust is not the word of god, it *is* god. without rust we are but bits of memory, helpless before the use after free. 
I have to agree for similar reasons. (Especially when I'm tired, it's significantly harder for me to read light-on-dark text than dark-on-light text.) A light mode must at least remain an option.
Side note; your means of collecting the size may work *now*, but it's extremely fragile, and if it's working, technically incorrect (for two reasons). x86 is a little-endian architecture, so the 32-bit number `0x01234567` is stored in memory as so: `0:67 1:45 2:23 3:01`. Network order for multi-byte raw values is big-endian, which would encode that number as `0:01 1:23 2:45 3:67`. If you transmit multi-byte values over the network, you *really* should use network order so that your sequences can be read by other machines or applications expecting NBO. To achieve this very painlessly, BurntSushi has a crate called ByteOrder that is very good. extern crate byte_order; use byte_order::{ByteOrder,NetworkEndian,}; let mut size_buf: [u8; 4] = [0u8; 4]; stream.read_exact(&amp;mut size_buf).unwrap(); let size: u32 = NetworkEndian::read_u32(&amp;size_buf); As for your array problem, &gt;Ideally I would just use a malloc equivalent and just pass a mutable reference to that chunk of memory is actually exactly what you are doing. `Vec::as_mut_slice` only permits access to initalized regions, so `read_exact` can only access 0 elements. The easiest thing to do here is, as said already, to `unsafe`ly set the `msg_buf` length and include uninitialized memory that will promptly get overwritten. Since you're the one defining behavior here, setting the length to indicate fullness over garbage memory that will then *all* get overwritten with logically correct values, this should be fine. I would also recommend `match`ing on `read_exact` to dispose of your vector in case of failure instead of crashing the whole thread, since this is probably a recoverable error (flash a "message lost", move on). I feel like this is something on which Rust's stdlib could improve, tbh. Maybe add methods to `Vec` that permit accessing the full capacity, rather than logical length, of its backing store for exactly this use case? unsafe pub fn Vec::cap_as_mut_slice(&amp;self) -&gt; &amp;mut [T; capacity] { slice::from_raw_parts_mut(self.ptr, self.capacity) } seems like it'd be useful. Thoughts from anyone on that?
Latest commit: "Fix BUFFER OVERFLOW when matching with a lot of variants." lol
ResizableArray?
Interesting, because I'm the opposite. I turn the brightness way down on all my devices and have light on dark everywhere. I use a consistent dark theme across all subreddits and as many applications as possible. To each their own I suppose.
Ah, I see. I just skimmed the first page. Maybe GodBolt + Rust that AngusMcBurger suggested will work well for that purpose. :)
Okay, first off I agree with the last sentence of your first post, in that the cost of zeroing beforehand is probably negligible, and dwarfed by I/O. /u/Keltek228 -- I was wrong! Come back to the light side! &lt;rebuttal&gt; Back to the other points. &gt;`read_exact` is a safe function and it doesn't expect to be passed a pointer to memory that it can't touch. Unless I'm mistaken, if `read_exact` only writes to the pointer, it's fully welcome to touch all the memory. From the docs: *No guarantees are provided about the contents of buf when this function is called, implementations cannot rely on any property of the contents of buf being true. It is recommended that implementations only write data to buf instead of reading its contents.* &gt;you're trusting `read_exact` and the optimizer to do the right thing. In this situation I do trust these. For the sake of argument, let me break it down: Let's assume `TcpStream::read_exact` has a bug and doesn't fully overwrite the Vec. But that would corrupt the output, so rust's unit tests or users would have caught such a bug by now. So then let's assume `read_exact` does fully overwrite the uninitialized Vec. But, pardon my pedantry, this is just initialization of memory. LLVM's optimizer won't mess that up. The only dangerous case I see is if `read_exact` returns early with an error, which my code then ignores. &gt;It may be fine in this instance but it's a terribly bad habit to get into If `unsafe` is thrown in carelessly, agreed, that's a bad habit. &gt;if we start to trust functions to do the right thing then why are we using a safe language? There are varying degrees of trust and safety... I trust the std functions quite a lot. I don't trust my own unsafe code nearly as much, but I can be convinced via logic and reasoning. &lt;/rebuttal&gt; TL;DR: technique seems correct, but probably not worth unless you're doing HFT
Thanks a lot for your response! I had totally forgotten about byte orders even though it's something I had learned a while ago. I'll make sure to get that implemented. As for the array problem, the solution from /u/tryunite is working out nicely but it would be nice to get a "safe" way of accomplishing this at some point.
~~something like `let msg_buf = std::iter::repeat(0u8).take(msg_size as usize).collect();` should give you all zeroes~~
To some extent. I admit light-on-dark *looks* nice, but, when I'm tired, I have trouble focusing on light-on-dark text while dark-on-light remains crisp and easy to read. I do, however, use [Redshift](http://jonls.dk/redshift/) and [Red Moon](https://f-droid.org/repository/browse/?fdfilter=night&amp;fdid=com.jmstudios.redmoon) (open-source [f.lux](https://justgetflux.com/) competitors for Linux and Android).
It's not a April Fool's joke right? Right?
How about this command suffix that does the same: &gt;&amp;&amp; notify-send
`;` would be better than `&amp;&amp;` right? You'll then still get a notification even if the command failed.
Nah brah struct PointPlusPlus { float x = 0.0f; float y = 0.0f; PointPlusPlus(float x0, float y0) : x(x0), y(y0) {} } int main(void) { PointPlusPlus muhcpp; return 0; }
You're absolutely correct.
I made a Rustacean pixelart using the palette from /r/place. https://www.reddit.com/r/rust/comments/62yv2i/i_made_a_rustacean_pixelart_for_rplace/
Now I'm confused. Is this satirical? Edit: never mind. Just realised it's still April 1st in some places.
I'll do what I can, but I think I'm about to pass out. :P
~~I started the logo here (working on tile A) [http://imgur.com/a/5amcG](http://imgur.com/a/5amcG)+ should we join our efforts?~~ working on yours now
I'm on board!
I'm not sure if there are enough of us to be able to maintain pixel art this large. The Rustacean is approx. 242 pixels large. I'd first focus efforts on that, and possibly move on to the logo if it gets done.
yeah you're right
If we executing this plan, I suggest a place right next to r/haskell, Edit2: new place according to other thread. Here [the pixelart with the coordinate](http://i.imgur.com/hLiBGHU.png ). and [Link to first tile](https://www.reddit.com/place?webview=true#x=838&amp;y=641) Edit: wrong image
That would cut right through the rainbow. The rainbow faction has a lot of followers, I don't think there's that many of us to be able to compete with them.
/r/playrust
mhh we could move to the old mona lisa in the top right corner (850, 130), we could reuse a lot of the orange tiles there
I'm on board too captain. [the pixelart with the coordinate](http://i.imgur.com/hLiBGHU.png ).
&gt; Guys, we need a rust to c89 compiler. As I know, there is project to generate C code from llvm ir, so all nesessary part to generate C code from rust already exists.
[Got it!](https://imgur.com/a/avicC) Now to see if we can clear a buffer around the outside and maintain it. :P
Let's see if we're capable of outlining Ferris first, then determine whether we're up for increasing the challenge. :P
of course!, I just wanted to have a plan for the moment we finish the outline
&gt; It's April Fools! O RLY? WHY AM I ALWAYS GETTING CAUGHT OFF GUARD BY THIS?!?
we should concentrate on the left side (claw) by maintaining and outlining, /r/wow still looks active over there. 
refresh your page we are done :)
try cleaning your cache its definitely finished
i'm on it (btw why the change .. is this one smaler?)
ah, thanks a bunch! I knew my assumptions were somehow wrong.
looks like this is way harder than the progress of ferris :(
That is _really_ nice
Try nix or guix - they have first-class Rust support. 
Im on it. Now trying to make some white spaces for the Big R. ^(Sorry, I do not know the name of the R.)
Does the vec! macro work with runtime lengths? I must confess I've never tried it.
It does.
That'll be *more* expensive than `memset`ting a Vec, I think
I wrote a rust bot to help! Simply run: cargo install ruplace ruplace &lt;username&gt; &lt;password&gt; And it will automatically help preserve ferris (and whatever else we decide to add) edit: To anyone whose bot has broken, make sure to update to the latest version!
&gt; cargo install ruplace Source: https://github.com/Diggsey/ruplace/blob/master/src/main.rs Looking good!
The pixel at 41, 16 (if top left pixel is 0, 0) seems to be wrong in ruplace.png. 
`SlicBuf` and `SlicBufing`
Because it forces you to rename stuff. I had to rename modules twice in this app because they has the same name as a crate a pulled in later (sourcemap -&gt; sourcemaputils and log -&gt; utils). This problem is the same as in old Python versions just slightly worse because in Python you used to always have absolute imports involving the package name whereas in rust the crate name never shows up inside the crate. 
workers of the world rise up! you have nothing to lose but your chains!
I'm really curious about this as well. I'm currently writing a small library for machine learning (mostly just to learn Rust as well as ML), and I've been using the OpenGL bindings + glutin to draw scatter plots, lines of best fit, etc. But maybe there's a better way? 
It's also possible to pass the document AST to the pandoc executable in either JSON or Haskell syntax, if you don't want to directly use Haskell.
It's not; discussion is ongoing on the mailing list.
I am running this! May the Rust logo be drawn.
In ruplace.png I propose that you make the outline hug the figures (especially Ferris) more tightly, so that it can transfer focus from maintaining extra whitespace to helping to draw the logo. I'd also recommend getting rid of the Redox and RIIR until we prove that we have the people to maintain both Ferris and the Rust logo (and if we do, then only adding those two back in one at a time). Better to have two logos than a random half of the pixels of four.
This is my "learn Rust" project. Comments and feedback welcome!
At the current rate we should be fine, it's already 56% done, and it's increasing steadily about 1% every 5 minutes.
It should be fixed now.
Leave Redox and RIIR if you want, but at least make the outline hug Ferris better, the big blocky square just looks really artificial. :\
I agree that the outline should be optimized. I think we're fine to keep the 2 logos and 2 pieces of text, though. We'll get there.
Ah, that sounds promising!
Thanks, looks great!
Unfortunately, there was a bug handling transparent pixels with non-zero RGB values, so you'll need to update...
Updated and pixel-placing on :D
You can stop that by putting this at the beginning of the code /// \`\`\`no_run You get to keep the examples but they won't run as tests!
Working on a self-update mechanism first, so we don't need to get in contact with everyone again.
And we aren't defeating the purpose using a bot...
Doh. I thought the optimizer would turn it into the memset. Anyway my answer is silly!
please make my machine a continuous "RustBot" :) edit: at least [we've done](http://i.imgur.com/C8NuSLv.png) it! 
I'm honestly never sure how Rust iterators turn out in the machine code.
You could also write the factorial function like this: use std::ops::RangeFrom; use std::iter::Product; fn factorial&lt;T&gt;(n: usize) -&gt; T where T: From&lt;u8&gt; + Product, RangeFrom&lt;T&gt;: Iterator&lt;Item=T&gt; { (T::from(1u8)..).take(n).product() } fn main() { let f: u64 = factorial(4); assert_eq!(24, f); } 
YA'LL NERDS GOT TOO MUCH WHITE SPACE AROUND YOUR R LEAVE OUR B ALONE.
Cool stuff, I tried to follow your guide! &gt; git checkout https://github.com/juj/emsdk You mean `git clone` :-) &gt; cargo build — target asmjs-unknown-emscripten Should be `--target` instead of `— target`. That's how far I got. I then got stuck at the emcc part. After running `source ./emsdk_env.sh`, there still was no `emcc` executable in the path. Tried to execute the emcc I found in a subdirectory, but did not get much further. I also tried installing the emscripten that comes with Ubuntu 16.04 (`sudo apt install emscripten`), but then `emcc --show-ports` does not recognize the switch, and linking fails with ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/asmjs-unknown-emscripten/lib: Input file has an unknown suffix, don't know what to do with it! 
It's just being annoying.
Nah, don't get greedy. :P It's a community art project, not an advertisement.
I agree that we need to be more conscientious of the art around us, I'll donate to repairing the B.
We're moving it over. As it stands the R bot makes repair impossible.
`Read` on a `Vec` never pops from it, so that behavior isn't different. If you look at [the implementation of take](https://doc.rust-lang.org/src/std/io/mod.rs.html#809) it wraps the underlying `Read` object in a struct which them implements read in a way that just forwards [`read()` with a limit on the number of bytes read](https://doc.rust-lang.org/src/std/io/mod.rs.html#1569). So this should behave the same as `read_*` without the `take()`, but without requiring a buffer that has a matching len.
Hi, thanks for the reply. Yes I mean git clone. About `target` this is the correct command: https://github.com/rust-lang-nursery/rustup.rs#cross-compilation. If you're using rustup.sh you have to type `rustup --add-target=` Did you activate installed version with with `emsdk activete latest` ? What shell you're using ? 
Howdy folks, I'm going to have to request that you please stop using the script. I was fine with it while we were just clearing up random garbage, but the original image template it uses is way too excessively spaced and imposes on the other projects around us. In particular I'd like to find a way to coexist with the cat logo to our lower left (see https://www.reddit.com/r/rust/comments/62yv2i/i_made_a_rustacean_pixelart_for_rplace/dfqn19e/ ), and possibly to allow Redox and RIIR to be overwritten (or find a way to peacefully coexist) with the concentric squares that formerly occupied that space (see https://www.reddit.com/r/rust/comments/62yv2i/i_made_a_rustacean_pixelart_for_rplace/dfqmiu8/ ), which predated even the great WoW/Rust conflict. It's a collaborative art project, not milliondollarhomepage.com, and grabbing unneeded land is both ugly and bad citizenship. Personally speaking, I think we should just maintain Ferris and the Rust logo where they currently are, with only a one-pixel white outline, and find somewhere else on the canvas for Redox (and help repair the squares). RIIR can be left to the wolves, like it deserves. :P
Trying to get people to stop using the bot, sorry. :\
I'll see what I can do to get people to leave that spot alone.
Good to know, thanks! I'll eventually need to do the same general thing the OP is describing so I'm still in research and ask phase.
You can't call a static method on a null receiver, because static methods don't take a receiver. If you mean "you can't call with static dispatch", no of course not, the same is true of Rust.
I'm very sorry. I designed the image and placed the text there for the script. I really didn't carefully check if there was art where it was placed. I can move the text, if you want the spot back.
So, what makes Termux exciting to me is that it does not require root. It's pseudo root. That makes Termux a bit like a Linux container running on top of the OS. Why would anyone care? "Just put your Chromebook in developer mode." That's typically the answer. Well, &gt;50% of education market share is in ChromeOS these days. Those Chromebooks are typically managed, meaning no developer mode. No linux. Wanna code? Read my lips, kid: Managed. With Termux on a Chromebook, this problem can be side stepped. Install Termux. In Termux, rustup, apt install git neovim. Now you can code, kid. Being able to reach that many kids with rust is huge. [Go already has a head start.](https://medium.freecodecamp.com/how-i-built-a-web-server-using-go-and-on-chromeos-3b83e4c2da5f) With Termux, rust can win hearts and minds early.
We can lend you bot power to make up for what we destroyed. ping /u/Diggsey
We will try not to break it. We can help you out if you want. ping /u/Diggsey
Thank you for the clarification. Admittedly, I haven't taken a detailed look at kabuki but will soon. The overall design looks really nice and the futures-rs integration is a plus. &gt; It is just the necessary infrastructure to implement "actors".. Would it be correct to assume that it will no longer be actively maintained?
Yep. Pretty slick. A [typed-actors](https://github.com/knutwalker/typed-actors) package was released not too long ago. I haven't used it yet, but I'm guessing a rust version could be implemented in a similar way.
Nice! More feature-compete than the Javascript based bot that some /place factions are using
I updated the target JSON which should break everyone using the previous version of the bot (which added extra white space). I no longer have sole control of the bot, which has been delegated to an organisation containing some of the people who helped contribute, and anyone can now submit PRs to update the target image.
Maybe you should think of joining forces. Having the actor model implemented for Rust is a great thing. I'm using Akka for Scala and there are use cases where using actors really makes things easier. 
I'd love to toss the robigalia logo in there ;) http://robigalia.org/logo.svg Regardless, is there a way I can join the botnet?
&gt; we're not going to re-implement rustc in C. But what about transpiling a subset of rust to C? That might be feasible and good enough for bootstrapping purposes.
Yeah, I may look at how robots works and try to contribute to it. The approach I'm taking looks very similar to theirs.
A vector drawing library like nanovg.
Not really, it's tied to user accounts created before a certain date, so it's really "how many people in your community" =&gt; "size of image one can maintain" Bots just maximize the efficiency :P
This gets really fun when you need a constant that isn't zero or one.
Hey just letting you know ive been maintaining the green PJ for a while now, hopefully it doesnt conflict with whatever your trying to make. Would really appreciate it if you could let my small piece of the place exist. I also have three account I would be willing to lend to the creation of whatever you guys are planning next. 
Paging /u/Diggsey 
Added!
The same thing can be achieved by firing up a GCP instance. Full fledged linux, x86. 1 dollar a week for an average machine / average usage (25 hours of coding).
Yeah I do see what you mean - I generally take pieces and apply them to my project as you say. Having started and abandoned several renderers over the years I've started to think the traditional approach of "get a triangle rendered into a simple framebuffer, then add features" is not the best way of going about it, as I generally find I end up completely trapped by the architecture (or rather the lack of one) and needing essentially a complete rewrite. My latest project is progressing slowly but I'm coming at it from the opposite angle - getting stuff like flexible AOV handling, a task scheduling system, input scene graph and OSL implemented first, before I get anywhere near actually tracing any rays. So far it seems pretty promising.
Hey, we've been working on a logo for our small subreddit, /r/drumcorps for awhile now. We'd like to use some of the space you guys are using for your far-right red and black art. We've been struggling. pls :(
Yes, but people own chromebooks already. 
Hey, we've been working on a logo for our small subreddit, /r/drumcorps for awhile now. We'd like to use some of the space you guys are using for your far-right red and black art. We've been struggling. pls :(
Hello! You should be able to do this, at least the serde side. First, consider switching to the new [serde_derive](https://serde.rs/codegen.html). That doesn't need to use syntex. Second, if you want to filter out "pad" you probably also need to add a #[serde(default)] on that field so it can Deserialize correctly. 
Well, some people have an inordinate amount of alts, but I don't think that's the case here. I know it's the case of some of the people in the green lattice (which I help maintain)
Also if you use discord and would like to learn more about our DCI project on /r/place, join [here](https://discord.gg/CqBvCbP)
Svg rendering from servo? Does servo do that? 
Great pitch! Do you have further plans for promoting Rust on Chrome OS?
I'd probably just use `FromPrimitive` and unwrap, at least for small constants, or even `From&lt;u8&gt;` or `From&lt;i8&gt;` if the signedness is known. Any better suggestions?
Is there anyway you can change the script so it doesn't place a white tile on coordinates 875,665? It's not a part of the rabbit and it would be the bottom right corner of my square. I would greatly appreciate it!
Hey just following up, I was away for a few hours and I don't see the PJ there anymore, is that our fault? If so, I can pull a few strings and help put it back.
No problem, just turn all the green inside the black circle perimeter to black?
to light blue actually, thank you man I really appreciate it! I'm trying to do a really simple Dr. Manhattan symbol. Something like this: http://imgur.com/22v51u0
Don't worry, the Servo text never went live. That's an outdated commit. I believe what we have currently is ideal, perhaps minus the dinosaur. I personally vote in favor of maintaining what we have, dropping the dino if the need arises. I have moved my copy of ruplace to a machine that will be up 24/7 and am dedicated to assisting whatever cause is decided upon by our superiors o7
Could you elaborate on how Scala's type system is stronger than Rust's? I'm curious as I don't have any exposure to Scala.
That would be awesome! You guys are incredibly accommodating. Here's the design i'm trying to finish: http://imgur.com/22v51u0
Thanks. As for the dino, yes, the folks at /r/drumcorps started their logo over to the left of us just before the dino went live, and now it's overlapping the side of them. I agree that we can cede the left side of the dino head to them, especially since the Mozilla wordmark under the windows bunny looks cooler anyway. EDIT: By chance, are you a member of the ruplace organization on Github?
I will go put together a PR for this now. I don't control anything, but hopefully we can assist you in maintaining your work of art :)
Is there a reason for writing `pub mod chan { pub use chan_crate::*; }` instead of `pub use chan_crate as chan;`?
Excellent, thanks a ton for your consideration. :) I've informed the DCI people of our intentions. As for the PJ square, I'd encourage you to talk to /u/PJstrikesback to determine their intent before submitting a PR. It's entirely possible that some people would rather have the fun making a drawing over time manually, rather than merely have the satisfaction of seeing it get drawn for them. :P
Oh yea, definitely. I wouldn't say its type system is _more_ powerful, but it is, by all standards, **extremely** powerful. Although I do miss working with Scala and playing around with its new [dotty compiler](https://github.com/lampepfl/dotty), Rust will get there soon (I'm sure HKT will land sooner or later). &gt; Doing this in rust seems like it would be super painful.... When I tried to do a statically typed version of this it was very painful... I've only taken a glance at typed-actors. Would you mind elaborating? Maybe even post a snippet..? &gt; Really i just want first class actors in rust though. Same here :/
Well, our users won't get this change until it's merged on the repo. As I said, I don't have access to that, so it'll have to wait until someone who does comes online. Bear with us :)
Swell thank you man!
I got in contact with cmr64 already, but thank you for the follow up. 
Bless you
I agree with ggplot. There is a reason it's been ported to Python as well :) I think the syntax would play nice with rust also
I tried it and it seemed to compile just fine, since `pub use` doesn't do anything other than to create an alias.
I'll try to find some time to reduce my backlog. There's just so much stuff to do...
I hope to spend some time preparing my Rustfest talk, review the latest Diesel PRs, and add/refactor some more features of assert_cli. (Let's see how much of that I actually have time for.) *In related news…* It's time for our monthly meetup in Cologne – that happens on the first Wednesday each month – on *this* first Wednesday in April! I'd love to see you there! More info at [rust.cologne](http://rust.cologne).
I guess the GP refers to Scala having some type system "features" that Rust does not have like higher-kinded types, existential types, higher ranked polymorphism, ... These features make Scala's type-system "more powerful" than Rust [*]. Having a powerful type-system nowadays is actually easy, just bolt these features on and be done with it. What's hard is keeping the slope of the learning curve constant, that is, as you need more powerful type-system features, the amount of work one should have to put on to learn this should be incremental and proportional to what one wants to do. There is always going to be a learning curve, but while some language like Scala and Ocaml manage to do pretty well here, some other languages like C++ perform pretty badly, e.g., the time required to master template metaprogramming is pretty big (~O(year)) compared to what it can actually do. I'd like to see Rust's type-system closing the gap on power, but significantly improving the learning curve with respect to other languages. [*] I think its strictly more powerful. It doesn't have lifetimes, but one could encode those in Scala's type-system if one wanted to, it would only be extremely painful to program that way.
Ideally, it should calculate how to plot and visualize, and feed the output to some kind of rendering backend. This makes it easier to develop and dependencies do not matter so much. Of course, this does not prevent making a nice user-friendly wrapper around this.
&gt; I think it's great for complex graphing but overkill for simpler plots. What exactly is overkill? If you use the [`qplot`](http://docs.ggplot2.org/current/qplot.html) interface, it is extremely similar to matplotlib (but still a lot more powerful).
I can recommend this free book, which gives a nice introduction assembly, linux system calls, C calling convention, and the libc realm in general: http://savannah.nongnu.org/projects/pgubook/ It is available in various formats: http://download.savannah.gnu.org/releases/pgubook/
That seems a very high bar, given that most boot-loaders are proprietary, and a lot of hardware tends to contain processors running proprietary firmware...
So the last Friday was the last day of my full-time involvement [1] to the Kailua type checker, and I've released the version 1.0.0 of the [Kailua extension for VS Code](https://marketplace.visualstudio.com/items?itemName=devCAT.kailua). Still has tons of issues, but the core language and many IDE smartness is stable. So what happened after [my initial teaser](https://www.reddit.com/r/rust/comments/4hc7ea/whats_everyone_working_on_this_week_182016/d2pff2f/?context=3)? The initial type system was working, but the userability testing revealed that the type system was too strict to work against the unmodified Lua: for example, there is no way to ensure that `local a = ("foo"):byte(i)` is not nil without knowing `i`, and the user had to translate that knowledge to the runtime error (e.g. `assert(a)`). I knew that, and yet thought it's uncommon in well-maintained code bases---which turned out to be wrong. The project has pivoted on (around) July, and the decision was made that the type system should be weakened---now comparable to TypeScript 1.x---and the more complete IDE support is needed as well. This was not as easy; the initial target was Visual Studio that was used by about a half of the team members, but the VS extension authoring is at best annoying especially when the model does not match against VS project system. Fortunately for me, after 4--6 person-months spent, the entire team has migrated to VS Code thanks to the ready-made [debugger extension](https://marketplace.visualstudio.com/items?itemName=devCAT.lua-debug) [2], and I could finally migrate to VS Code early this year. It took last three months to stabilize both the type system and the IDE support from then. The early feedback is overwhelmingly positive now, though there were (and continue to be) lots of issues popping up. I'm pretty sure that this is one of the most complete solution for type-checking otherwise vanilla Lua code. I have lots of things to say about Kailua (which has grown to 22,000 lines of Rust code, all written by me), but for now, I'll just leave the link :-) Please keep in mind that the extension is right now for Windows only due to the deployment issue [2], which I want to improve upon in the future. [1] I'll continue to maintain the entire project at work, just that it's no longer full-time work. [2] VS Marketplace has no good way to ship different binaries for each platform. It is possible to have binaries at the external location and let the (placeholder) extension to download the specific binary, but it had a lower priority.
I think cbor changed the representation here https://github.com/pyfisch/cbor/commit/8206c2430cd5ab1f12ff268c9dd3fb2f93f2a4f1 because of this ticket (author is me) https://github.com/pyfisch/cbor/issues/12 Personally I think a standard format like Cbor is the way to go for a tool like Pijul, but since the library is a moving target it's not an easy decision.
I though the same, but we need stability now. At some point during the switch to serde, pijul was not even able to read its own patches. This is scary. OTOH, bincode is faster and easier to fork, if we ever needed to.
How will Pijul evolve the on-disk format in the future? Most formats will just fail if you add another field to the struct, etc.
So happy to see this being advertised. Float 32/64 is in a similar boat. 
There are two different formats: - A sanakirja database. We do not expect it to change anymore. It used to change a lot in the beginning, but the format is mostly stable now. Also, this is not a real problem, since we can always recover it from the patches (yes Pijul is entirely about patches, Sanakirja is invisible to the user, they just notice the speed). - Patches! This is tricky, as we really don't want this to change anymore now. Pijul is already more than a year and a half old, and patches used to change quite a bit in the beginning. The structs have not changed in at least 6 months. As explained in the blog post, the format has changed unexpectedly with the switch to serde. The fixed encoding starts with a little-endian u64 indicating the version of the patch format, so that future versions of Pijul will know what to do when they come across an older format. Also, we need stability as soon as possible, mostly because Pijul is bootstrapped, and resetting our history was quite painful. We'd also love to turn the issues on the Nest into a distributed bug tracker, storing its issues in markdown in a Pijul branch. Losing patches is not that bad if you still have the files, but losing issues would be catastrophic, as they already represent (at least on our pijul and nest repositories) hours of testing and discussions (which is why we made a very conservative choice in the Nest, storing them in postgres with backups).
Would be so awesome if there was support for "virtual actors". Research paper: https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/ Been extensively using Orleans, but would love to have something similar in Rust!
Thanks :) Is The Nest also using Pijul? Is it open source?
The nest needs to move fast, fix security issues and introduce new features quickly. It doesn't use Pijul yet, essentially because we don't have enough experience with Pijul to make sure we can achieve that. The first two weeks of using Pijul for real projects made us quite confident about the future though, which was a huge relief (the project is 3 years and a couple of months old). Also, the nest is not open source now, but might be in the future.
Cool, thanks for the answer.
There is this plotting library written in rust: https://github.com/coder543/dataplotlib It looks like it is not very active. I don't know why that is, but I suspect that currently a lot of effort would need to be spent on the graphics backend to make writing a plotting library in rust easy (though that's not an educated opinion on my side, just guessing).
Writing an implementation of [Delaunay triangulation](https://en.wikipedia.org/wiki/Delaunay_triangulation). It might end up as part of my final year project (if I get to do the one I want). Of course, trying to implement it might put me off doing it :P
Hello there /r/rust community! Mine is the most annoying question maybe, but I need to ask it: any IDE suggestions? I'm using Brackets but actually I'd like something more powerful! Thanks!
Adding flat-combining locks to crossbeam and working on some simple utilities for fast lockless code
Me neither, the only IDE I've used for moderately big projects is Eclipse (for C++).
&gt; "No language server command found for type: hercules." Older vims don't realize what Rust files are; they think they're "hercules" files.
It's generally better to fix them up so they actually run, though :) Especially in a library like this. `no_run` is most useful for stuff like "here's how you start a server" or "here's how you delete/create files" where you really don't want them to run.
I recommend also reading these comments: * https://github.com/rust-lang/rfcs/pull/1615#issuecomment-274235688 * https://github.com/rust-lang/rfcs/pull/1615#issuecomment-286593618
You can use the [`buffer` crate](https://docs.rs/buffer/0.1.7/buffer/). extern crate buffer; use buffer::ReadBuffer; use std::net::TcpStream; fn main() { let mut stream = TcpStream::connect("localhost:80").unwrap(); let size = 5; let mut buffer = Vec::with_capacity(size); stream.read_buffer(&amp;mut buffer).unwrap(); } Cargo.toml [dependencies] buffer = "0.1.7" 
There are a couple of more interesting links in the first comment you linked.
Yes, I'm definitely planning on taking a look at Orleans.
&gt; I've only taken a glance at typed-actors. Would you mind elaborating? Maybe even post a snippet..? I don't think I have anything in code anymore. When I first attempted to write an Actor library in rust I wanted typed messages. I ran into exactly the same issue as Robots. https://gamazeps.github.io/why-boxany.html What I wanted was an enum that could represent all of the possible messages that could be received. This is similar to the Akka typed messages, except that they managed to do it and I didn't. It's something I want to revisit.
Do you have an idea for how you'll approach typed actor messages? 
I'm learning about [WebRender](https://github.com/servo/webrender/) and have started to submit some pull requests to help improve documentation and usability. I don't intend to use this from Servo, so I have a lot to learn. I'm still working on my [low level LLDB bindings](https://github.com/endoli/lldb-sys.rs) and [bindings for JavaScriptCore](https://github.com/endoli/javascriptcore.rs). 
* [elementtree](https://crates.io/crates/elementtree) can now read *and* write XML. * Working on an RFC to improve dependency management in rust.
Please see [this comment](https://github.com/rust-lang/rfcs/pull/1615#issuecomment-286593618), the door is open for future such proposals, it's just that _this particular proposal_ has major issues.
A new RFC should provide something new, IMO this RFC was pretty well written. The current design is bad in many way but the team does not want to change it mainly because of eventual breakage. I don't see how a new RFC could handle both problems. I have the feeling the situation, while less serious, is pretty similar than for the great int debate.
I highly doubt mine will be crate worthy :P 
Nothing I've tried yet worked. Rustup didn't understand my armv8l as aarch64. I get the feeling this is just another week or two away. I'm trying to figure out the rest of the setup in advance on a linux laptop. I hope to be ready when rust is :D
Thanks for the hints! &gt; unwrap the t_sheet If t_sheet is None, that means something for the 'init' command. In this case there should not be an error since when init'ing it's ok if there is no timesheet file. Yet this all has to happen in the match block for the arguments, so I couldn't find out how to do it other than matching on t_sheet while matching on the subcommand... By the way, ``clap`` is absolutely awesome!
Where do you see that open stance? I see: Caches might be moved (good thing). Configuration can live in a standard location as an *opt-in*. An opt-in to comply with a standard somehow defeats the point of a standard -- even today, I can change the location of cargo directories with the environment variable `CARGO_HOME`. No mention of binaries, which is one of the most-visible benefits of the RFC: Some Linux distros ship with a default `PATH` including `.local/bin`, I doubt they're ever going to add `.cargo/bin` by default.
Wrong subreddit; you want /r/playrust.
&gt; Where do you see that open stance? This is just true of the RFC process in general. This isn't a courtroom where double jeopardy is a thing; someone else could open a new RFC on this topic that attempts to address the issues found with this one.
Surprisingly, I'm still trying to get some attention on my [`global_asm!` implementation](https://github.com/rust-lang/rust/pull/40702). Nagisa reviewed it, but I don't know if their eyeballs alone are sufficient to get it merged in.
The pijul team has nest.pijul.org, that's the only one I know of, though.
[The nest](https://nest.pijul.com/) mentioned in the article hosts Pijul repositories.
Trying to analyze and organize contents is even more work... That's totally outside the PDF specification and damn horrible.
**Update: Complete** Last week, I implemented support for arrays as first class citizens in the Ion shell, which places us a step above other established shells which do not support arrays properly. There's array expressions **[]**, array-based command substitutions **@[]**, and array variables **@array**, along with slicing support for each in the form of IDs **[0]** and ranges **[..3] [3..] [0..3] [0...3]**. This week I will be finishing that work by adding array and string methods, such as **$join(array, ', ')** and **@split(string, ',')**, and then finalizing everything with a lot of unit tests.
That's not what I read from the discussion. Maybe an RFC that just handles one of the problems would be helpful?
Working on my secret compiler project! Rust has proven a great language so far for tree-walking and tree-folding due to ADTs and pattern matching. I've been heavily inspired by reading bits of rustc as well as libsyntax and syn. I used nom to build the first iteration of the parser; but I've discovered that the error handling story doesn't quite match up to what one wants out of a tool that humans need to use interactively. So I've started building my own (much more limited) parser combinators with support for "cuts" immediately back to the top-level. I'm leaning a lot harder on closures over macros... it should be interesting to see the effect on performance.
Probably not, at this stage. When the spec is changing all the time, you need to communicate spec changes to all your contributors, and that's a lot of overhead with a lot of contributors, especially if you develop a long tail of casual contributors.
Hi! We were also darcs users, and also upset about the same things, which is why we solved them. The theory behind Pijul is sound even on conflicts (contrarily to darcs), and the theoretical complexity is better than git's! (which doesn't necessarily imply that Pijul will be faster, although it is already pretty fast). 
I've always thought of shells as weird string-based LISPs. Might be interesting to see one that goes a bit further and behaves more like a language with more strict typing (and more regular and less weird syntax).
Wait a minute... that's what I am doing, too. I have currently everything in one spaghetti file, but at least it's halfway documented. I worked myself through the PDF reference. I gotta warn you, the PDF reference only tells you half the part. If you actually want to develop something well, you need to look at reference PDF files as well as get a good debugger. You can find my ramblings here, it took me a few weeks to get this stuff together (Unicode support, font embedding, etc.): https://gist.github.com/sharazam/9a728d55f0d347ca5172be37390738b3 And I still have problems: http://stackoverflow.com/questions/42754574/pdf-doesnt-show-characters-even-though-font-is-embedded-and-tounicode-is-prese I currently don't have anything related to kerning (kerning has to be done on a per-character basis) and the color profile seems to make my characters transparent. I managed to embed the font though, and Unicode is working (you can select characters and copy-paste them). Currently my library is built on top of lopdf. This is not finished in any way (currently very messy), I just wanted to help, if you see anything in the file that might be interesting for you.
This is really cool, and something we could perhaps benefit from. Have you thought about a CLI checker for things like presubmit tests?
I changed the code as per your recommendation, much better!
During the HackFest last week, Alex Crichton and I worked on a [crate](https://github.com/antoyo/futures-glib-rs) to spawn futures on the glib event loop (thanks Alex for all your great work!). I made [my first PR on gtk-rs](https://github.com/gtk-rs/gtk/pull/481) during this HackFest. I also fixed some issues in [relm](https://github.com/antoyo/relm), an asynchronous GUI library based on GTK+ and futures/tokio since someone tried it during this HackFest. This week, I plan to fix one issue in `relm` and finish the `#[widget]` attribute. If I get the time, I'll write a blog post about `relm`.
`let mut t = &amp;app.tile_set[i];`
The Tile `render`function makes several uses of `App` internally to get: * the clipping rectangle of the sprite * to get the tile texture Changing these to parameters means that pretty soon Tile's `render` function does very little and the caller has to do these things.
 &gt; What are the patterns that people use to deal with these issues? What are my options in general? How could I rewrite the render loop around line 451 so that I'm not making a copy and the use of app passes the borrow check? I would probably try changing `t.render` so that it does not require a `&amp;mut App` but a `&amp;mut Renderer`. Edit: If that is not possible, I would try having it take a `&amp;App` and use `Cell` and/or `RefCell` on the app fields that need changing. [I wrote a guide](https://github.com/diwic/reffers-rs/blob/master/docs/Pointers.md) a while ago with some helpful pointer patterns for people coming from C. Could give some inspiration as well, perhaps?
I guess my reason for resisting that particular rewrite is because that `render` function uses more than just `&amp;mut Renderer`. Take a look at my response to /u/carrillo: https://www.reddit.com/r/rust/comments/6385es/solutions_to_what_i_call_the_global_fields_problem/dfs3i5h/ Right now that render function is able to hide some details but if everything is passed in individually then it loses that ability and puts the burden on the call site. I'll go read your guide.
Very interesting question — I would like to see what others have to say about this. What I have found is that directly porting a programs architecture from a language without rusts borrow-restrictions rarely works out. My first attempts at writing games in rust where largely obstructed by me trying to structure the code in the way I would have in another language. It looks like everything related to rendering needs a reference to your `App` struct. In this case I would probably try to identify which specific part of the app struct is needed for rendering, and split that of into a separate struct. In general, splitting things into smaller parts seems to make it easier to "avoid" the borrow checker. Without being directly familiar with SDL, I would guess that "culprit" in this case is some SDL framework handle which is needed for every render call. Moving this so that it is no longer inside the `App` struct, but rather passed as a parameter together with `app`, would probably solve your problem. In my current project there are currently 2-3 things (These things being some info about the current state of the game, and a matrix stack utility) which I had to move out of the main `Game` struct. I pass these as parameters to my `update`/`draw` functions together with the `Game` struct itself. If there where more bits and pieces which I would have to maintain separately this would probably become quite tedious. If this where to become a issue in the future I probably would have do some more thinking about my games architecture. I have also found some tricks (or rather – methods new to me) which helped me avoid moving stuff out of my `Game` struct. I don't think they will help in your specific case, but they might be relevant to the general discussion nonetheless. - (Ab)using inner mutability. As I use OpenGL through my own layer of abstractions, and rust has no concept of gl state, I don't actually need a mutable reference to e.g. a `Shader` struct (which I have defined as a wrapper around a handle to a gl shader) to modify gl state related to it. I realize that this is slightly un-rusty, but as OpenGL is not thread safe anyways I don't have to worry about accidentally having to non-mutable references which can mutate the same state in different threads (I would be interested in hearing what others do when it comes to external apis inadvertendly allowing inner mutability). - Using rusts channels. Rust provides a great multiple-producer, single-consumer channel system. I use this for handling input. Somewhere in my gameloop I query input from glutin and send events to a bunch of registered consumers. These consumers can then handle the event. Before I did this I had a single struct to handle input state, to which the querying code needed mutable access and the rest of the update logic needed immutable access. This forced me to move it out of my `Game` struct. After introducing channels the code that needs input can own a receiver and deal with incoming events without being directly tied to the querying logic, meaning it can again live inside the `Game` struct. 
Okay, that's awesome. I would put that in announcements like this, just so that non-users know that you're handling things like this responsibly.
Hmm...after reading the guide you wrote, I realize that interior mutability is not something I've tried on this problem yet. In most (all?) the cases where I need to mutably borrow an `app` it's just because the underlying SDL functions need a `&amp;mut`. With interior mutability, I can probably push those down a level. Splitting up the `App` type should also work. I'm not super excited about that solution here, but it's a good one to keep in mind for other instances of this issue.
well, my application is to be deployed in a commercial environment and as such I can't by policy "take inspiration from others". Currently the scope of the project is to streamline a workflow that involves extracting info from another legacy application that outputs PDFs in the 10000-15000 pages range and that are often malformed(as in not adhering correctly to the ISO 32000 standard) my library currently loads the pdf file to a buffer and progressively processes it to disk(single core by the way). PDF fucking sucks but Rust is extremely clever. What do I mean? This PDF-thingy is my first trial of something ready to be used by other people in production and while the PDF file format is tricky to display, edit and parse, Rust on the other hand is incredibly handsome because of the clever design choices, it is also blazing fast: it can process a 15000 page PDF on a Dell Vostro 230(very underperforming machine) in less than 5 seconds and every single possible error is correctly managed. Currently my application has a "crash-on-error" behaviour but this is how exactly the people that wanted to use it asked me to do. Rust is incredibly versatile, fast and ergonomic for tasks like mine. I still suffer from long compilation times but now with my new Ryzen workstation everything has improved. PDF information extraction is completely different from visualization but I do understand your point and I thank you for your reply.
The problem is not the specification itself, it's the fact that I have to deal with non standards compliant files generated by someone that clearly did not took a look at the standard like me and you. In PDF for instance you can make references to content that was already somewhere else, what if some elements are references to the whole document? (any pdf viewer luckly ignores this kind of recurrence but discovering this weird structure for the first time left me pretty depressed for a little while)
Why is it better to put the extra cases in their own functions? I simply handled the init case before all others in main.
That's actually just an artifact of a different way I started to do it...it doesn't really need to be. At first I moved only `handle_init` to a function so I could return early on error and such (which was harder inside `main`). But once I moved all the matching to the `run` function, that wasn't truly required any more.
Thanks a lot for your help, it is much simpler now! So many ``None``s are gone!
It would be awesome to see them on the Friends of Rust page.
I wanted to test it on the mandelbrot generator (which you can find a copy of [here](https://github.com/LeopoldArkham/brainfuck)) but it was no worky-worky. Seems to be stuck in an infinite loop or something. I also second u/Lokathor 's comments about using Enums to hold an intermediate representation of the program. Using Rust's type system to model the problem is very powerful and one of the most important things to learn. You can see how I did it in the repo linked above. Also you have a couple compiler warnings; I recommend clearing those and running clippy on all your code. Good luck! Edit: Also you need to use args[1], not args[0], which is always the path to the program itself
Hmm... I think it depends on the terminal ... see [this picture](http://i.imgur.com/KTldAkn.png)
I was looking for a GH library the other day and wanted to use yours but it lacked the notification endpoint that I needed (making a bot). Glad to know you're expanding it!
[removed]
Does anyone have a screenshot/copy of the awesome banner?
Ping me later, or see Twitter.com/Gankro for a taste.
Array of bytes for the memory of the virtual machine is fine. But your input to interpret should be parsed out no matter how you structure your VM.
Hmm, does the JVM translate .class files into a different in-memory representation? I always assumed it would just parse and validate it in-place, and only keep metadata and references to the data for efficiency.
I'm surprised you didn't write a migration tool! It seems weird to me to not try to keep the history of a VCS (e.g., the git history of git itself is pretty well preserved). Having a version that supports both the old cbor-style format and the new one using serde sounds possible and not that much work, but I could be mistaken.
&gt; I am limited by my available free time but I hope I can put something useful together. Hmm.. I smell a community project coming on! &gt; .. started playing with a Rust actor library, too. Is the repo public? I'd love to see a sketch of typed-actors implemented in Rust. I could probably merge it with [kabuki](https://github.com/carllerche/kabuki) or OP's crate (tokio + futures-rs integration)...
Oh man! I already send my wife all kinds of ASCII emoji art randomly while at the computer...It's about to get epicly rusty though! Very cool!
I work at a smallish company where I sometimes need to do light dev work, and I'd like to do future projects in Rust. My only problem is that most of the developers do all of their work in Python. I checked the FFI section of the Rust book, it mainly talks about interfacing with C. Should the developers call Rust like it's a C library, or are their other techniques I should use to make sure my code is simple to call from other programming languages?
Ah awesome! Is there a specific one you need? Feel free to open up an issue. Were you using the 0.4 release? If so I've completely changed how it works so I'd advise experimenting with the master branch if you want to use it.
I got far enough in my attempt (1.0 compliant, text-only output) to realize that I didn't want to finish this. Major props to you. &lt;3
&gt; The cost of initializing the Vec to zero is negligible. No it is quite slow, especially in debug mode.
It's understandable given the source. NicoNico is the Youtube of Japan. On slide 5 they claim 14.2 million total videos, 82.4 billion total views, and 30 million views per day.
Good news, everybody! This means that Rust is Turing Complete.
Sounds like a pull request to throw those directories under `$XDG_CACHE_HOME` or a directory named `transient`.
Is the source for Nest published somewhere? I'm interested in this homegrown async HTTP stack.
Its worth to mention reading from stdin is not yet supported in README.
Sure. In fact the CLI checker was the first thing I've made---the IDE support is an afterthought and it was hard to adapt to it :p
&gt; Still, fair claims would read like this: "SAFE Rust is safe (but there are cases when it will be slower than C)", "UNSAFE Rust can probably be as fast as C (and consume as little memory)" Why the distinction? Yes, it's good practice to think of them as different parts, since unsafe Rust is generally much harder (and less common) than safe Rust, but they are still the same language. You can't even really say you're using safe Rust because ultimately safe Rust is built on unsafe Rust ;) &gt; "Zero-cost abstractions". Technically, he is almost correct. This is sort of nit-picking, isn't it? There are scores of "zero cost" abstractions in C++ that also impose a level of cost (if not in the actual efficiency of the code, then in the complication it imposes on the programmer from all the disjoint features). Generally, I've found that the Rust docs are very good at pointing out what costs are associated with each abstraction (e.g `Cell` vs `RefCell`). If I ever feel there's a bottle neck I can feel free to use a different crate, or try to write my own implementation in unsafe Rust. &gt; E.g., when someone complained about inability to inherit data in structs, he was given a small schooling about traits. Though the comment was not about traits, the comment was about data fields that i have to repeat over and over in my structures (which in C++ would form a nice hierarchy. yes, without inheriting methods). But this is the solution in Rust. If you want to be able to have data in an "inherited" way, then you should look into using traits + sub structs. Maybe Rust would benefit from having inheritance like in C++ or Java, but that doesn't really solve the problem the person was asking does it? In fact in many threads like that I've seen generally two threads of discussion: the merits of the current system vs a new one, and then another thread on actually solving the problem. I fail to see how providing a solution is zealotry, unless this post you are referring to was also dissing the C++ model as well. &gt; I did not want to use this word explicitly, but someone has already done this before me, so the ice is broken. Literally the top post in that link has this line: &gt; This is probably also true in a lot of cases. There are plenty of things I'd still much rather write in Ruby or Python. Even C in some cases. Don't use Rust in those cases. That doesn't read like a circle jerk to me. Rather a group of pragmatic programmers that simply want to improve their tool set. Rust has its place, just like Python and C do. There have been multiple times where I'm writing something and I realize that Rust wasn't the right tool for the job (as an example--I had to bind a Wayland protocol recently and, due to the limitations of the compositor framework I'm using, had to basically mirror how it's done in C. It would have been faster, and easier, to just do it in C).
Looks like it, fixed.
It would be really cool if the code had a little bit more comments!
My solution: run with `-fsanitize=address -fsanitize=undefined` and follow the C++ core guidelines (with a tool that checks them!). But Rust is much better.
&gt; If someone says that everyone (implying even Pythonists) sall learn Rust, I read it as "Rust is as easy as Python or Go or C#" From a python/ruby coder perspective, Rust is much much easier as C, as the compiler doesn't silently allow stuff that may corrupt memory. Or take the nightmare buildsystems/dep management systems that C/C++ have, especially nightmare on Windows. Of course, for a python coder it is not as easy as python, but if you are a python coder, it is easier to rewrite that 10% performance critical chunk of your codebase which 90% of the running time is spent in, in Rust than in C. &gt; "everyone shall try Rust" When you want to spread Rust, why should you say "no, Rust is not for you" to certain people?
Why not? With rustup target link i can point all users to some admin installed version
Hey, sorry for the delayed response. Thanks for the reply. I've decided to make my way through the first few chapters of types programming languages by Pierce.
Cheers!
Hi all, I'm beginning learning Rust by converting some small utilities I have locally into Rust. I've hit what I think is a simple stumbling block, but couldn't figure out. This is an example taken from [curl-rust](https://github.com/alexcrichton/curl-rust) but with a minor adjustment, specifically: extern crate curl; use curl::easy::Easy; // Capture output into a local `Vec`. fn main() { let mut dst = Vec::new(); let mut easy = Easy::new(); easy.url("https://www.rust-lang.org/").unwrap(); let mut transfer = easy.transfer(); transfer.write_function(|data| { dst.extend_from_slice(data); Ok(data.len()) }).unwrap(); transfer.perform().unwrap(); println!("dst is now of length {}", dst.len()); // &lt;--- This is the line I added, which causes the error. } The error I get is: error[E0502]: cannot borrow `dst` as immutable because it is also borrowed as mutable --&gt; src/main.rs:18:43 | 13 | transfer.write_function(|data| { | ------ mutable borrow occurs here 14 | dst.extend_from_slice(data); | --- previous borrow occurs due to use of `dst` in closure ... 18 | println!("dst now contains {} items", dst.len()); | ^^^ immutable borrow occurs here 19 | } | - mutable borrow ends here As noted in comments, the line I added from the example has an issue because, as I understand it, dst has been 'moved' into the closure passed to write_function, and I can only assume never gets moved back, but I'm not really sure how to solve this. I pulled some of the code into another function thinking that might help, by returning 'dst', but the problem occurs there too. How is this solved normally? I feel like I'm missing something fundamental, so sorry if this is super-obvious to all but me. Cheers!
I vote for VSCode. I had to hold my nose, get laughed at by everyone at work for being a turncoat, but in the end it's my favorite.
&gt; Thus, from my perspective, there shall definitely be methods for working with grapheme clusters. While I actually agree that Rust's strings are in kind of unlucky states, I think this is more of the library issue and not of the language issue. What the Rust standard library actually has is the equivalent to C++'s `std::string` but with a strong guarantee that it's UTF-8 (since it's really universal by now). *That's it*. Rust the language does not try to internalize any complication from the diverse world of internationalization and I think it's a good thing (because it's hard, difficult and more importantly has no "correct" answers in general). The lack of more ergonomic interface is problematic, but it's no way the language's fault. Oh, and just in case, you have [`unicode-segmentation`](https://crates.io/crates/unicode-segmentation) crate if you want to work with grapheme clusters. The problem is that it is not well-advertised to the beginners; [crate visibility is the real problem](https://www.reddit.com/r/rust/comments/4uxdn8/the_rust_platform_aaron_turon/d5u2qla/).
Another alternative is to expose a C interface with `extern fn`s, build a `cdylib` and then use `ctypes` in Python. Depending on your needs, this can be easier.
I came here expecting some valid feedback that we could act on. Over the last week there has been some amount of "too many folks are annoying about rewriting in Rust" discussion, and we're hoping to reduce/destroy the amount of such evangelism done by community members. I thought this post would have further actionable feedback, but to me it really reads as a lot of nitpicking, painting of statements in the worst light possible, and generalizing. I'm sorry, I just don't find anything useful or even correct here. Someone flagged this post "impossibly biased flamebait" and while I don't exactly agree (and won't remove this post), there's a kernel of truth in that. I'm trying to read this post assuming the best interpretation, but it's hard, and maybe I'm not good enough at doing that, so if I misrepresented an argument I apologize. _shrug_ &gt; Still, fair claims would read like this: "SAFE Rust is safe (but there are cases when it will be slower than C)", "UNSAFE Rust can probably be as fast as C They're both the same Rust. When you use Rust there is an understanding that you may need to call into some safe abstractions over unsafe code. The idea is that this is still rare and well scoped enough for the safety guarantees to still be useful. In practice, this turns out to pretty much be the case. You yourself say that "Yes, you don't have to implement linked lists often" -- this makes it a very specific use case. Of course C will be faster than Rust for some use cases. Rust will be faster than C for others; the noalias optimization does turn up at times and make code faster. When folks say "X is as fast as Y" there's a "usually" in there, with the implication that when it isn't it's still in the same ballpark. In practice, Rust _is_ as fast as C. ripgrep is extremely fast, and beats the other grep implementations on an average. Other rust reimplementations of things haven't had any consistent trend of being slower than C. This doesn't make Rust faster, but it puts it in the same ballpark, and as far as performance of _languages_ is concerned that is really all you can measure. Benchmarking languages is hard, but we have sufficient evidence to say that Rust's performance is in the ballpark of C -- sometimes will be slower, sometimes faster, but usually close enough. Not having stable SIMD is an exception here. You mention Stroustrup, which I find ironic because even he considers linked lists to be a pretty niche datastructure, and has said so many times. (note that in Rust singly linked lists are possible to implement safely with 0 cost over the C version, it's just doubly linked lists which are tricky, though that doesn't stop us from having an implementation in the stdlib for you to use if you need one) &gt; Not everyone shall try Rust. There is (I hope) now understanding in the community that Rust is a fairly complex language (there were some explicit comments about that). You're being pretty unfair to that comment here -- in context it did outline reasons why, and then later followed up with "Should I be using it _now_? Maybe.". Besides. Every other talk about something new often has that refrain "Should I use X? Yes!". It's a bit of enthusiasm, and a regular rhetorical device meant to introduce the reasons behind using something. You're reading too much into it. Also, he said "should", not "shall", which have different meanings, you seem to have made some conclusions off his use of "shall". I really think you're reaching here. Nowhere does he explicitly say that Rust is easy to learn. Nowhere does he say it's as easy as Python. In general Rust folks have been pretty open to acknowledging that it's hard to learn. He doesn't explicitly acknowledge it here either, he just says that he feels that everyone should learn the language -- that doesn't imply that it's easy to learn or anything, that's just a personal view. This is much like folks who say "I feel that everyone should learn some math/programming/whatever". It doesn't imply that the thing is easy, it's just a view of theirs that folks should be doing it. I thought I'd seen a mention of this talk before on this subreddit recently, and I found https://www.reddit.com/r/rust/comments/5ou7jx/rust_is_going_through_puberty/dco1kyt/?context=3 , where you have brought up the same claims. The rebuttals there equally apply here; it's clear you haven't taken those into account and just repeated your claims, which is pretty dishonest. &gt; but may be it has backfired and there is time now to stop exaggerating. You're painting this as something which happens often and was an intentional "strategy". I cannot recall a single incidence of this, please give evidence. As I said above, even the three year old video you link to doesn't really imply what you're saying it does. &gt; there are people now who say that unions in C are better than enums in Rust, because they do not bear the tag field. It's basically undefined behavior in C to use unions _without_ some form of tag, this is the strict aliasing rule. Folks get it wrong _all the time_, but it exists. C does give you more control on the exact form the tag takes, and lets you do manual layout optimizations like rolling together the tags of nested unions, but IME 99% of C code using unions correctly (i.e. not breaking strict aliasing) has no benefit over Rust enums. The 1% of the remaining time -- does it really matter? As I said before, Rust doesn't have to be as fast as C for every imaginable situation. There are cases where it's faster, and cases where it's slower. &gt; "Zero-cost abstractions". Technically, he is almost correct. No, he is correct. Zero cost doesn't necessarily mean that there is no runtime overhead -- see https://news.ycombinator.com/item?id=12270428 . And this is not the Rust community inventing a definition, it's how the C++ community defines it too. E.g. bounds-checked arrays are a zero cost abstraction because you consider the bounds checking _to be a part_ of the abstraction, it's something you wanted there. This does make the term a bit circular, I admit, and it feels like a sort of cop-out, but in practice most of the Rust abstractions are more or less zero cost as compared to what you would do in safe, correct C, which is what matters. &gt; E.g., when someone complained about inability to inherit data in structs, he was given a small schooling about traits. Rust prefers composition over inheritance. In most cases folks complaining about the lack of inheritance are suffering from the XY problem; where they have problem Y, and know that it can be solved with inheritance, so they ask for inheritance (problem X). So in threads that ask for inheritance without explaining the use case, most folks just explain the laundry list of alternative ways of doing things that usually need inheritance. Providing more details on problem Y gets a better scoped answer with alternatives. That said, there are use case for which inheritance is useful. Rust doesn't really intend to add inheritance (there are proposals for something that's equivalent which could happen), but a lot of these things could be papered over with stuff like newtype_deriving. For example, the "repeating data fields" thing can be solved via traits using something called "associated fields" that has been proposed before. The existence of these proposals indicate that the community does feel that these are problems worth solving. And when people do ask about these things they do get told "yeah this is a bit annoying in Rust right now, we're hoping to fix it with X". IMO the community is pretty forward about explaining when something is tricky/annoying in the language. &gt; It is absolutely impossible to work with strings in Rust as with text, because there is no indexing over "characters" (i.e. say grapheme clusters). There are crates for that (`unicode_segmentation`). A lot of functionality you'd find in another language's stdlib are split out in crates in Rust. grapheme segmentation used to be a part of the stdlib, until it was split out. Same goes for random numbers, and many other things that folks consider core. There are only two languages that operate on graphemes by default. Swift, and Perl 6 (idk about Perl 6, but someone told me it does this too, and I believe them). For all other languages you need to pull in a library. In Python, that library is built in, but in Python everything is built in. Given that, I don't really see how this criticism is specific to Rust. &gt; We don't complain that indexing of linked lists or hash-maps takes non-constant time. We don't have an indexing operator on linked lists either. And hash maps are expected to be "almost" constant time. You can always use the iterators for this, and explicitly acknowledge the cost. Lacking an operator for this is no biggie. What's wrong with `.graphemes().nth(5)`? Rust is explicit about costs in many cases, this is just one of them. The advantage of forcing such usage is that besides making the cost clear, it makes it easy to amortize the cost over multiple calls, by reusing the iterator or whatever. &gt; and some people claim that they've never seen the opposite in their careers. Who? Where? Check out [this thread](https://www.reddit.com/r/rust/comments/5o13kk/lets_stop_ascribing_meaning_to_code_points/). There is exactly one person arguing for O(1) indexing, and that person was not talking about the same thing you are talking about. Everyone else agreed vehemently that code points are not the abstraction that text processing should deal with (some folks went further to point out that even EGCs are not always what you want, which is of course true). While these claims crop up with depressing regularity in other programming spaces, whenever discussing Unicode, I've never seen Rust venues really produce these claims -- and I track all the unicode discussions happening here. There may be one or two, sure, but you can't paint an entire community with that. 
IMO, most of your post is either nitpicking, generalization, wrong or just subjective. It's fine not to like Rust, and have a negative opinion about it, but I just don't see anything useful for Rust community.
Sorry, I don't have an Intel chromebook with play store that I can try.
s/shall/should 
&gt; Working with strings as with containers of text Why not just have a separate crate for this? Just like there're separate crates for serilization or asynchronous IO or even regexps. 
We do, see the unicode-rs org on github
I can't get Sublime Text to work with Rust Enhanced. Keep getting this error upon build. `[Errno 2] No such file or directory: 'cargo'` Any ideas?
Your call to `path.unwrap()` is producing a [`PathBuff`](https://doc.rust-lang.org/std/path/struct.PathBuf.html), which is an owned value. `as_path()` takes a slice of that value, and `to_str()` converts that slice to an `&amp;str`. If you never need to use the `PathBuff` again, you can technically just add a call to `to_string()` on your result, and that will give you an owned value. If you do need continued access to the `PathBuff`, or if that all just feels too hack-ish, you have a number of options. Unwrapping to a separate let statement is one. You can also use some form of destructing, such as an [`if let`](https://doc.rust-lang.org/book/if-let.html), which is usually my go-to in situations like what you describe. Really depends on what you're going to do with it though.
Here's the rest of the code: https://gist.github.com/anonymous/0303362ca535f638f8a58cc888efc037
Game for a game jam. Idle-game based. Got some basic clickable "buttons" going in a Piston window. https://github.com/Lokathor/igbs2017/blob/master/src/main.rs
I tried, but the problem is a bit deeper. Hashes of the encoding of patches are used as keys in the Sanakirja database, so a conversion tool wouldn't have been enough: all versions of libpijul would have had to support all past formats, including those of alpha-versions. Unfortunately, we don't have enough workforce to maintain that kind of stuff. The new format is too simple to ever need to change. Also, the comparison to git is a good point, but the theory of patches in pijul provides stronger guarantees than git's, such as patch commutation: patches can be applied in any order.
It's linked from https://pijul.org/documentation/install/ (in the top menu on pijul.org). https://nest.pijul.com/pijul_org/pijul
The blog post clearly states that `pijul clone` will do that, starting from 0.4. Writing a conversion tool for the patch format is not possible, because patch commutation means that all patches must be applicable in any order. More info there: https://nest.pijul.com/help/patches.html
Is the interoperation with Java and JVM ecosystem important? Then you have no other choice than JVM---not necessarily Java, though. Languages with functional portions (e.g. algebraic data types) tend to be good for language developments, and there are many such languages working well with JVM.
Oh, that makes sense. Thanks for the thorough answer!
I know about Hyper and company, I was just interested in how the Nest stack was put together.
I'm gonna assume you mean Rust the language, not the Rust the game. :) Repost from myself: I took me the best part of a year to be comfortable with Rust, and I have 15 years of C++ under my belt! Even now, I still cut myself on Rust's sharp edges sometimes, but the community here is great, and always helps out (check out my post history to see what I'm talking about). So don't give up! 
The way I look at it: every fight I have with the borrow checker now is a fight I *don't* need to have later on with the debugger, where I won't even be sure what the fight is about. It's also easier to fight with someone you know is just trying to help you and is on your side, as opposed to an uncaring reality which is disinterested both in the root cause of your failures and in helping you resolve them.
`cargo run -- /dev/stdin`
to add on: `.cargo/bin` and `.cargo/.crates.toml` are products of `cargo install` (the latter is used for `cargo uninstall`). `.cargo/bin` is also where `rustup` stores executables IIRC. Deleting `bin` and `.crates.toml` will only be harmless if you don't use rustup. `.cargo/config` is a user-created configuration for publishing crates and other global cargo configuration, and can be deleted as long as you re-add it next time you publish a crate.
Rust can be really frustrating in the beginning, especially if you're coming from a GC-ed language background. What took me a lot of time was to figure out how the ownership system worked, and when and how you should work around it with stuff like `RefCell` or `Rc`, but at some point you just get it, and everything looks so intuitive and natural. Carry on ! I don't fight the borrow checker anymore, but every once in a while the borrow checker catches a stupid mistake I made. 
nice work (and logo)!
&gt; When you want to spread Rust, why should you say "no, Rust is not for you" to certain people? Actually, I would, I do it all the time. I say "for that specific use case, language Y might suit you better". Though often Rust still works there, and I do mention that. But for a general statement like "should I try Rust", I'd say "yes!".
http://users.cecs.anu.edu.au/~steveb/downloads/pdf/rust-ismm-2016.pdf is an example of a high performance GC impl in Rust. It is not safe to use, but it is designed for your use case -- the collector for a language with its runtime written in Rust. https://github.com/Manishearth/rust-gc might be what you need (it's safe!), however it's not designed to be too fast, so you may have trouble if you put a lot of objects on the GC. https://github.com/izgzhen/RuScript is an example of a scripting language that uses rust-gc. I don't know much about it though. Ideally for a runtime you'd want a custom GC impl with manual collection calls and whatnot. You can do without a significant amount of bookkeeping done in rust-gc if you tailor it for your use case. But GC will be a challenge. If your goal is to just write a language, I'd recommend a GCd language for implementing the runtime. If your goal is to use Rust, getting a good fast GC in there is tricky because it's tricky to make safe to use. rust-gc makes it safe, but ends up doing a lot of refcounting for that (which may be okay for you).
Go is designed to be easy. Rust is not, though we do want to make it _easier_. Rust takes a while to get used to. Fighting the borrow checker after 2 weeks is fine. IMO it's worth it, because then you can be super comfortable with systems programming, something that takes much much longer with C and C++ for many.
Good to hear, thanks.
Thanks! I am very proud of the logo.
Spend some time learning the rules of the borrow checker (basically affine logic) and practicing with types which actually follow these rules (just declare a `struct S {}` and experiment with passing it around, returning it, etc.). One of the reasons Rust is tricky to learn is that the primitives don't actually follow these rules (there are certain traits that relax them), so you write some pattern of code that works fine on `i32`, then try to replace it with `YourType` and suddenly nothing works. This automated relaxation is convenient when you understand what's happening, but it makes learning difficult, especially if you're trying to learn by just throwing stuff at the type checker and seeing what sticks. It's like a spell checker: it's useful when you know what's supposed to be happening, but if you're trying to learn a foreign language by typing random crap into a spell checker until it's happy, you're going to be quite frustrated.
I personally leave it out entirely when making backups. * `git` and `registry` are caches, they can safely be removed at any time * `env` would be restored by reinstalling rustup * `bin` would be restored by reinstalling rustup and running a couple `cargo install foo` commands again * `config`, the only thing I have in there is a crates.io login token, which would be restored by running `cargo login` again.
&gt; Then you have no other choice than JVM---not necessarily Java, though. Well, you can also call the JVM from Rust, if that makes sense. Example: https://github.com/kud1ing/tinkerpop-rs/blob/master/rust/src/main.rs
Does your observation that references (Rcs) don't work on cycles still hold? softwaredude22 did say Swift uses ARC instead of GC successfully.
You're not factoring in the spaghetti, code repetition, etc. which commonly occurs in these sorts of organisations. Not saying that this is necessarily what's happening, but file/LOC counts alone aren't really impressive in my opinion.
&gt; and when and how you should work around it with stuff like RefCell or Rc Are there any resources that talk about this point specifically?
I'd like that, but I worry if Rustaceans built a bad reputation for demanding rewrites it wouldn't help. 
What, in your view, should be used instead?
Another great tool to build languages is [Racket](http://beautifulracket.com/) - again, you get the runtime for free as long as you know what semantics you want. The only issue is that it doesn't play nice with statically-typed languages (you basically have to run the type checker and then erase the types and run it as dynamically typed code), although there is some [great infrastructure](https://docs.racket-lang.org/turnstile/The_Turnstile_Guide.html) for types if you don't mind leaving performance on the table. Racket's fast (in a lot of shootouts it's the fastest Scheme interpreter), but obviously if it took advantage of static typing it could be faster. I've had a dream in my head of a Racket-like module system and syntax infrastructure on top of a language with Rust's semantics. You could build a dynamically-typed language on top of a statically-typed one with syntax transformers (just look at the various Scheme-&gt;C compilers) but visa versa leaves a lot to be desired.
Haha, sorry for being _that guy_. I think Rust is great, but I'm a bit wary of people making it sound better than it actually is!
You already can treat strings as containers as text, it's just [not in the standard library](https://crates.io/crates/unicode-segmentation). I agree with you about zealotry, I think that the "preaching to the choir" comment was a little rash - while the powers that be in the Rust community are very level-headed about that, there are a lot of people in our community that are overly preachy. Dismissing them as not true Scotsmen is disingenuous, they're as much a part of the community as everyone else. I disagree with your points about zero-cost abstractions though, you have to hold a tag in C unions anyway, otherwise it's just a glorified bitwise cast. Rust abstracts that with pattern matching etc., but it's no more costly than the C equivalent. This is even true of types like pointers, which have "magic" values that are invalid and can be used to store the tag implicitly. I can't think of any place in Rust where there is an abstraction that is necessarily slower by language construction than an equivalent safe implementation in C/C++. Most of C/C++'s speed advantages come from disregarding safety completely - which you can do in Rust if you so desire.
[Now why does this seem familiar...?](https://www.reddit.com/r/rust/comments/5e9cj8/aup_recruiting_again/)
I need to ping the notifications, deal with them, and mark them as read (so PATCH). I'm just doing it myself now but maybe when I get back to this I can implement the relevant endpoints for me and send a PR.
Rust is known for having a steep learning curve. After that, I do believe though that Rust isn't a _particularly hard_ language - not harder then, say, competent C++. The core of the issue to my reading is that many concepts in Rust are _genuinely new_ and at the same time _very interlocked_. Ownership and Borrowing as a _base feature_ of a language is unusual. They rather directly interact with lifetimes, which might feel odd at first, because they are _purely descriptive_. Then the details of all that: Boxes are similar to Borrows in memory, but they follow Ownership rules... Send and Sync is something in that cluster, as it have interplay with Ownership and Borrowing... Strings and &amp;str directly touch these rules... This means that you will have to learn a lot of these things at once, without being able to layer knowledge on knowledge. But the gain is learning a consistent language that teases your abstraction muscle in a very interesting fashion, which is something you can take to other efforts, even in other languages, later.
Will do! I'll be looking at it next week or so, I'll let you know then.
I don't know! If you think so, and have a specific pattern in mind, we'd obviously be happy to help.
in my opinion they should go into one of the others, its from a user perspective extremely annoying to make exceptions for each program you happen to be using. also i don't want my homedir to be filled with one .applicationname for each application i use. there is a valid exception to this, cases where its common to actually manually open the folder, because you edit config (.vim) or similar, but thats simply not the case at all for cargo
I hope it's easy and doesn't need an RFC. How to get this code working? pub trait ArrayLike { type Item; fn swap(&amp;mut self, i: usize, j: usize); fn push(&amp;mut self, elem: Item); fn get(&amp;mut self, i: usize) -&gt; Option&lt;???&gt; // ???: Borrow / AsRef } impl&lt;T&gt; ArrayLike for Vec&lt;T&gt; { ... fn get(&amp;mut self, i: usize) -&gt; Option&lt;&amp;T&gt; {...} } impl&lt;Arr: ArrayLike&gt; ArrayLike for Rc&lt;Arr&gt; { ... fn get(&amp;mut self, i: usize) -&gt; Option&lt;Ref&lt;Arr::Item&gt;&gt; {...} }
Those guys have a safe implements of C in addition to dynamic language implementations
Awesome looking forward to it!
You're right, but then all existing repositories would have to be recreated from the start, or else repositories created with older versions would be incompatible with newer versions. If that was going to be the case anyway, and most projects we were aware of (except ours) had at most 4 patches, and some patches were produced with serde-cbor, but weren't readable with the same serde-cbor, we decided it was too much work, and moreover low-priority compared to improving the Nest of implementing monorepos in Pijul.
I think you're perfectly right to address this here. Actually, I think that this is one of the main reasons for the rejection of Rust by C or C++ programmers and that we should try to fix it. And I'm not even talking about the crazy kind of edge cases, but rather something like: storing a stably heap allocated thing (`Box&lt;_&gt;`) in the same struct as a reference pointing to it. Or even more famously: the lexical borrow problem. The borrow checker is already helping *a bunch*, but just praising it won't get us anywhere. It should constantly be evolving :)
Lifetimes could probably be hidden a lot more than it are, actually. Rust won't quantify over implicit struct lifetime parameters for you, which means if you have something like `struct CookieBox { c1 : &amp;Cookie }`, it will whine and make you manually quantify and apply the lifetime yourself. But there's actually no reason it has to be that way: it's easy to just quantify over a unique lifetime parameter for each hole you find, and it's almost certainly what you as a user would want anyway (in fact, I contend it's not just rare but *wrong* to quantify over a lifetime parameter and use it nonlinearly, e.g., `struct CookieBox &lt;'a&gt; { c1 : &amp;'a Cookie, c2 : &amp;'a Cookie }`, although Rust happily accepts this. Highly amusingly, it does force an error if you quantify over a lifetime parameter and don't use it, which I'd contend has more logical basis than the prior: I mean... at least it's affine!) Apparently [this struct lifetime elision was part of an old rfc a while back](https://github.com/aturon/rfcs/blob/lifetime-elision/active/0000-lifetime-elision.md#lifetime-elision-in-structs), but it doesn't look like anything came of that part of it. In any case, [they also share your concern that elision anywhere complicates the learning process](https://github.com/aturon/rfcs/blob/lifetime-elision/active/0000-lifetime-elision.md#learning-lifetimes).
Can you expand on "that Go cannot do at all"?
I got into Rust after following the development for a long time, and seeing lots of design decisions that I really liked. Knowing the problems Rust helps me avoid, I was never demotivated by the learning curve. Whenever I see a post like this, I want to ask this: _why_ did you get into Rust? Because of the hype? If you're haven't struggled with the problems that Rust helps you avoid, it's hard to provide any motivation.
Me too brother! Seeing that I am not the only one is enough motiv for me
Hello, Prolog.
Anyone got a contact to them?
Sure, I edited the original comment, because it's probably better to have all numbers in one place. And I also know that 25 is not a very big number, but those students had very different educational backgrounds. I just want to say: it's not like I choose only motivated students already familiar with systems programming ;-) Rather the contrary, I think.
Rcs don't work on cycles. Swift will leak on cycles unless you use weak pointers. Rust also does fine without a GC; Swift can too.
Thanks 
Yes, that's why the new patch format starts with a version number. We don't expect changes in the fields we're serializing, the current breakage was only due to a change from the cbor to the serde-cbor crate to serialize our patches. This was scary enough for us that we definitely will think about a conversion tool in the future.
I think it depends a lot on your previous language experience. Unfortunately I feel that most students are learning OO languages, which, while statically typed, are not like the type system in Rust. People familiar with ML languages, Haskell, Purescript, etc, will be comfortable with Rusts type system immediately, so they need only learn the borrow rules.
I gave up two weeks ago. Rust is supercool, but at the moment it's not for me, so I'm going back to c++. Perhaps I'll try again in a year or two.
Oh. I just liked the style, and I actually like the 'Rust Evangelism Strike Force' monicker, I know people mean it in a negative way, but the fact that so many people love the language is a good thing. And no, we should not go around suggesting to RIIR. That's not helpful, what is helpful is dispelling any myths or misconceptions. Though, at the same time, it should not be a pile-on, one correction is generally enough. Focus on helping people learn the language, after that Rust will sell itself. People will be defensive of their language of choice, there's nothing we can do about that. But it doesn't mean we should be scared off because of name calling. All languages grow because there are communities which embrace them and try to get them into new spaces. Rust is not an easy language to learn, and people should be very upfront about that. What I dislike though, is that Rust is being pigeonholed into just another memory safe language, it is not! It is also a thread-safe language! Coming from Java, that's my biggest attraction actually, and if there was one thing i would talk about more, it's that.
&gt; Btw: Didn't even know Rust was a game as well Then we as a community are doing our job. Occasionally we get posts here about it and have to redirect people. It's sometimes amusing to see people try to work Rust the language into whatever OP tries to say about Rust the game. &gt; I was able to be productive in Golang within 2 weeks As someone who works with Golang every day, I must say it's a fantastic language. However, there are a *lot* of things that I prefer in Rust, and I definitely think it's worth the effort to learn. I'm not going to get into all of the reasons I prefer Rust, but here are a few to reassure you (in rough order of importance to me): - compiler errors when I do something stupid with threads - destructors - cargo - generics are very nice - Rust's type conversion system is super nice There are also several things I prefer about Go: - easy to read/write - simple to work with threads - fast compile times - race detector and profiling - standard library I don't know the specifics of your project, but ever since I learned Rust, I've been using it as my defacto language unless another one makes more sense.
If I just clone it and build it (and run the tests), is it supposed to pass flawlessly, or are the errors I'm seeing something that can be expected under those circumstances?
No to be honest with you. do you have any comments on it?
I agree. In case you're interested what my languages my students had experience with: [click](http://i.imgur.com/SlVXPVG.png). I could post the full PDF, but it's German. Maybe I could translate all of it, but I'm not sure if it's worth it... (?)
Hi! /u/Manishearth and I run the SF meetup. We haven't announced our next one but you can find it [here](https://www.meetup.com/Rust-Bay-Area/). You can find all the meetups we know about on this [list](https://github.com/rust-community/talks). 
Agreed.
What's wrong with the nonlinear example? It just says c1 and c2 outlive the struct, right?
Closures actually can capture their environment, they just have different restrictions on how they can be used based on what pieces of their environment they capture. See [Fn](https://doc.rust-lang.org/std/ops/trait.Fn.html) [FnMut](https://doc.rust-lang.org/std/ops/trait.FnMut.html) and [FnOnce](https://doc.rust-lang.org/std/ops/trait.FnOnce.html). You are correct about tail call elimination not being present. To be honest I don't entirely understand the term "functional data structure" I'm sort of new to functional programming myself. So perhaps Rust doesn't quite meet that bill. Personally I used Atom for a while, until I learned how to use Vim, now I use that. IDE information for Rust can be found at https://areweideyet.com/
I'm sure there is some of that. Erlang is a functional language however and avoiding those things is not that difficult.
great! thanks for this
Nope! Unless I'm mistaken, it should mean that they not only outlive the struct, but that c1 and c2 have the same lifetime. I contend that the struct has no business regulating that behavior.
Then go the other way, make the renderer take the tile index instead of the tile object. It already has the tile object available, right?
Thanks for input. That's helpful.
&gt; Just think of the always on check on array access. The other thing is that array access by index barely ever happens in Rust, because we have iterators. It crops up very occasionally when you're using indexes as a "poor man's pointer", but that's not the common case at all.
&gt; To be honest I don't entirely understand the term "functional data structure" I'm sort of new to functional programming myself. I'm sure you're familiar with the idea of an immutable `int` or `double` or even `string`. Purely functional data structures just extend this idea to collections like lists, arrays, sets, maps, stacks, queues, dictionaries and so on. Whereas operations on mutable collections take the operation and collection and return nothing, operations on purely functional data structures return a new data structure. Here's an example signature for a mutable set: val empty : unit -&gt; Set&lt;'a&gt; val contains : 'a -&gt; Set&lt;'a&gt; -&gt; bool val add : 'a -&gt; Set&lt;'a&gt; -&gt; unit val remove : 'a -&gt; Set&lt;'a&gt; -&gt; unit and here is the equivalent for a purely functional set: val empty : Set&lt;'a&gt; val contains : 'a -&gt; Set&lt;'a&gt; -&gt; bool val add : 'a -&gt; Set&lt;'a&gt; -&gt; Set&lt;'a&gt; val remove : 'a -&gt; Set&lt;'a&gt; -&gt; Set&lt;'a&gt; Note that `empty` is now just a value rather than a function (because you cannot mutate it!) and `add` and `remove` return new sets. The advantages of purely functional data structures are: * Makes it much easier to reason about programs because even collections never get mutated. * Backtracking in logic programming is a no-brainer: just reuse the old version of a collection. * Free infinite undo buffers because all old versions can be recorded. * Better incrementality so shorter pauses in low latency programs. * No more "this collection was mutated while you were iterating it" problems. The disadvantages are: * Can result in more verbose code, e.g. graph algorithms often require a lot more code. * Can be much slower than mutable collections. For example, there is no fast purely functional dictionary data structure: they are all ~10x slower than a decent hash table. The obvious solution is to copy the entire input data structure but it turns out it can be done much more efficiently than that. In particular, if all collections are balanced trees then almost every imaginable operation can be done in O(log n) time complexity. Chris Okasaki's [PhD thesis](https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf) that was turned into [a book](https://www.amazon.co.uk/Purely-Functional-Data-Structures-Okasaki/dp/0521663504) is the standard monograph on the subject. In practice, purely functional APIs are perhaps the most useful application of purely functional data structures. For example, you can give whole collections to "alien" code safe in the knowledge that your own copy cannot be mutated. If you want to get started with purely functional data structures just dick around with lists in OCaml or F#. Create a little list: &gt; let xs = [2;3];; val int list = [2; 3] create a couple of new lists by prepending different values *onto the original list*: &gt; list ys = 5::xs;; val int list = [5; 2; 3] &gt; list zs = 6::xs;; val int list = [6; 2; 3] &gt; xs;; val int list = [2; 3] Note how prepending `5` onto `xs` didn't alter `xs` so it could still be reused even after `ys` had operated on it. You might also want to check out my [Benefits of OCaml](http://www.ffconsultancy.com/ocaml/benefits/examples.html) web page. I'd love to see the symbolic manipulation and interpreter examples translated into Rust! &gt; Personally I used Atom for a while, until I learned how to use Vim, now I use that. IDE information for Rust can be found at https://areweideyet.com/ Excellent. I'll check it out, thanks. 
Sigh, why is there a dotfile in a dotfile directory? This is better stored openly. (XDG categorization would be ~/.local/share, crates.toml is non-perishable application created data.)
"pijul init &amp;&amp; pijul add ." panicks for me "pijul status" seems to show even the contents of some files? weird "pijul add *" doesnt seem to go into folders recursively to add stuff " pijul push error: Missing remote " ok but how? Could you please add how to add a remote in that very message? "pijul mv" exists, so I assume I cant just rename a file and pijul will recognise the change? I think git has that now
&gt; What are such claims, as if not blind zealotry? Very, very context-dependent. If you're trying to parse HTML, JSON, every config format I've ever seen, LaTex, Markdown, Rust source files, HTTP, etc, then you really don't need Unicode grapheme clusters. The processing instructions in those file formats are all ASCII, and UTF-8 is designed so that a unicode-oblivious parser can search for particular ASCII characters and not get any false positives. That's how all the parsers you see (pulldown-cmark, html5ever, serde_json, regex-syntax...) are built; they treat the format as a byte array with embedded, opaque blobs (which, if they happen to be UTF-8, will be dealt with by the renderer). The formatting instructions happen to be ASCII that's meaningful to humans. Computer-readable formats are designed so that approach works. If you need to render any of that text, then you should get used to pulling in external libraries with names that start with `unicode-`. `unicode-normalization`, `unicode-segmentation`, `unicode-width`, `unicode-script`, `unicode-bidi`, `unicode-xid`, are all listed in Servo's Cargo.lock file for that reason. `caseless` also comes to mind. Same if you need to truncate text, or change the case of a single grapheme cluster, or anything like that. 
I have to agree with /u/VadimVP on this. As a Windows user, I really don't care what my home directory looks like and given Microsoft's direction of hiding it as much as possible, I really don't see this as a mark of quality software. &gt; VS Code's command-line integration is terribly buggy Software is buggy in general. I'm not sure what your point is here. For half a decade, Visual Studio's Immediate Window would only accept C# 2.0 (even when your source was C# 6.0). That doesn't signal to me that Visual Studio is a half-baked port :)
So I am not sure if you know this, but Rust's enums can have methods put on them, which is perfect for dynamic typing. https://github.com/jweinst1/apple/blob/master/src/val.rs use std::fmt; pub enum Val { Int(i32), Str(String), Bool(bool), List(Vec&lt;Val&gt;), Null } //int operations, arithmetic impl Val { pub fn plus(self, other:Val) -&gt; Val { match self { Val::Int(i) =&gt; match other { Val::Int(j) =&gt; Val::Int(i + j), _ =&gt; Val::Null }, Val::Str(s) =&gt; match other { Val::Str(so) =&gt; Val::Str(s + &amp;so), _ =&gt; Val::Null }, _ =&gt; Val::Null } } } You can easily switch between types in an enum with a match statement.
It's on the people, more than the language, to not copy and paste code...
Why did you make this comment? I feel like I'm missing something
add a second associated type, `type RefType`. Not much else you can do here. You don't want to return `T: Borrow` because this means the caller gets to choose the `T`, here you want the implementor to choose it.
The post and source code has zero documentation for what this is and what it would be useful for.
Something I find nice in docs: &gt; println!("hits: {:?}", cache.cache_hits()); println!("misses: {:?}", cache.cache_misses()); If this turned into 'assert_eq!(blah, cache.blah)' it would show the expected outcome. Side note - does rustdoc support running tests in README's? That would be cool.
&gt; Zero-Cost Abstraction: What you don't use, you don't pay for; and what you do use, you couldn't handcraft better. &gt; -- Bjarne Stroustrup
yes you're right. I'll fix it. thanks
I would note that there is a difference between: &gt; Everyone should try Rust and &gt; Everyone should use Rust I've tried a number of languages over time (Haskell, Go, Ada, ...) and never really "used" them in any meaningful project. Yet, I think that my forays in those languages have taught me a few things that made me code differently (especially after Haskell...).
&gt; Actually, I think that this is one of the main reasons for the rejection of Rust by C or C++ programmers and that we should try to fix it. I agree with your comment as a whole, but do feel the need to point out that every time I've seen a Rust beginner complaining about something they could do in C or C++ that rustc refused, it turned out that their C or C++ was incorrect to start with...
Oh true, but i guess I was thrown off why you would need a GC for your own personal language in the first place. The small languages that I have made just use a Hashmap as place to store variables, and you create new scopes linked to that Hashmap when you need them, and destroy them when the scope is no longer in use.
Well, I didn't know what TF-IDF meant, so it seemed polite to save other people the trouble of looking it up.
Yeah, I didn't think so. Oh well.
We know one of the tests is failing, for a theoretical reason. We're not sure how to change the theory to make it pass. We'll decide and either remove the test or fix it, before 1.0. If more than one test is failing, please report the issue on the nest, with the name of all the failing tests, and your platform.
Check out https://github.com/brson/rust-skeptic.
Wow! Let me reply one by one: - `pijul init &amp;&amp; pijul add .`: what panics? init or add? If it's the add, what is "add ." means for you? - `pijul status`: this command was added between 0.3 and 0.4, and named from feedback we've received. If you'd like to comment on our command names, you're more than welcome to open issues about that on the Nest! We're not 1.0, many things can still change. - `pijul add *`: that's also the case for most Unix tools. I think it's meant for them to be more composable, as in `pijul add $(find .)`. - `pijul push`: we don't have a list of favorite repositories yet. We plan to include it in the .pijul/meta.toml file at some point, but we first need to polish our SSH interface, keys are not yet easy to use. The syntax I use is `pijul push pmeunier@nest.pijul.com:repo` if one of my repositories is called "repo", and I can also do `pijul push pmeunier@nest.pijul.com:pijul_org/pijul` to send a "pull request" (actually a patch) to the pijul_org/pijul repository, where the main pijul is. - `pijul mv` renames the file, and keeps track of it. Git doesn't operate on files (only on blobs), although it does have a heuristic to show files to the user. Pijul has a different (and more complicated) story about files, but the current version has no heuristic to guess what files you've moved. You do have to use `pijul mv` if you want pijul to keep track of your files. 
I think using word "every" is not appropriate here, especially while you probably follow a lot of things that is written about Rust by beginners. I've seen myself a lot of researchers/beginners that had correct use case. Being in denial will not help Rust.
The [The Gentle Intro to Rust!](https://github.com/stevedonovan/gentle-intro) looks promising. I'll have a look at it, thanks.
I got that installed but looking at other crates related docs. e.g https://docs.rs/openssl/0.9.10/openssl/ssl/struct.SslContext.html
Very cool!
That's a lot of great information, thanks! Rust supports similar patterns with ownership and mutability constraints but they're also not the same ideas. Data can be mutated, but only on the terms of whatever owns that data. So you don't get unexpected mutations, and with closures you can also have lazy evaluation, giving similar benefits. One example of how I can make similar ideas work in Rust is a line from my Nitro game engine project. During my game loop I iterate over game objects and any one of these game objects may add or remove game objects at any time. So my solution was to at the beginning of the frame take a snapshot of all the keys into my game object hashmap like so: ``` let keys = self.game_objects.keys().map(|x| *x).collect::&lt;Vec&lt;u64&gt;&gt;(); ``` Then I just iterate over those keys fetching and updating the game objects. If a key no longer exists due to a prior game object deleting it I just ignore it. EDIT: You may also like [Arc](https://doc.rust-lang.org/std/sync/struct.Arc.html) as it can provide similar structure to what you describe.
I also fear that I will have to write libraries by myself that are de facto standard in other languages. It's clear that it's a new language and the number of libraries increases constantly. However, it currently seems to me that the number of libraries is only increasing on a linear level which acutally means the language does not grow --&gt; I don't have any statistics about that but it's the impression I have. The focus is and should be to make it easier to learn Rust. May something like that would help: * Interactive learning (I remember in school I started to learn java using this [hamster game!](https://freizeitkreis-bl.de/hamster/)) * Best practice examples 
I mean reading from the bf code. i.e 'comma' operator is not implemented. https://github.com/smoqadam/rust-brainfuck/blob/master/src/main.rs#L61-L95
Depending on what you're doing, you could potentially want to enforce the two fields having the same lifetime - but I agree, having separate lifetimes for each reference in a struct is probably the desired default behavior
Would you mind commenting on the RFC thread as well?
Would you mind commenting on the RFC thread as well?
Just as an aside on the self-referential struct thing. I've recently completed a redesign of my crate `rental` that will allow you to declare arbitrarily self-referential structs, where each field can hold references to any previous field, provided they are stably-allocated as you describe. Just need to beef up the test suite and write some docs, but it should hopefully be ready soon.
&gt; One example of how I can make similar ideas work in Rust is a line from my Nitro game engine project. During my game loop I iterate over game objects and any one of these game objects may add or remove game objects at any time. So my solution was to at the beginning of the frame take a snapshot of all the keys into my game object hashmap like so: Right. That's a classic solution. If you want to avoid all the copying up front then another solution is to maintain a change set while you iterate. The change set is a pair of sets: one for all elements that have been added and the other for all elements that have been removed. Assuming you add or remove far fewer elements that you have in total that will be a lot faster. &gt; EDIT: You may also like Arc as it can provide similar structure to what you describe. Yeah, this has me thinking deep thoughts about Rust. As you can have many copies of different versions of purely functional data structures that will share their internals you cannot have a simple concept of ownership. Almost all production functional languages use generational garbage collection. The only solution I can envisage in Rust is reference counting but the problem is that it is [extremely slow](http://flyingfrogblog.blogspot.co.uk/2011/01/boosts-sharedptr-up-to-10-slower-than.html). However, if you care about performance then you probably won't be using purely functional data structures anyway. On the other hand, I often use some purely functional collections in some places so I either need a (ubiquitous) GC or work to remove those (a PITA). 
Counting them carefully, I see now that it's only one error, namely for the test ["missing_context"](https://nest.pijul.com/pijul_org/pijul/issues/439c4a14-698e-4d2b-9264-2ca4c3d60e3e). I do get a few warnings, though: warning: unused `#[macro_use]` import, #[warn(unused_imports)] on by default --&gt; src/main.rs:17:1 | 17 | #[macro_use] | ^^^^^^^^^^^^ warning: unused import: `get_wd`, #[warn(unused_imports)] on by default --&gt; src/commands/init.rs:10:13 | 10 | use super::{get_wd}; | ^^^^^^ warning: variable does not need to be mutable, #[warn(unused_mut)] on by default --&gt; src/commands/unrecord.rs:128:21 | 128 | let mut patches: HashMap&lt;_,_&gt; = | ^^^^^^^^^^^
OK. `From&lt;f32&gt;` is a simple float requirement if you do allow a trait bound.
 Paragraph text followed by a list requires * two blank lines for list items * each list item should, but is not required, to have intermediate lines * links have cover text [here](https://and.the.url/here)
Also rust-curl should be good according to Armin Ronacher. 
Thanks --&gt; corrected. Don't forget: Tabs instead of Spaces:-)
It is rather fantastic how excited systemsish and type-theoryish people get about Rust. Two groups of my friends - C++ people and Haskell people - and then some Rubyists like me all like one practical language. I'm excited for our future. Rust Evangelism Strike Force is a great name. I think *something* should have that name. Maybe an effort to get Rust ready for commercial use and/or help ease the path to doing so.
I had no idea about racket/unsafe! That's exactly what I wanted! I did see that DrRacket has a tickbox mentioning typed racket-specific optimisations but I only use DR for the macro stepper so I didn't look too far into it. Do you have as much control as C?
Plenty of us are in the spot where we aren't writing the equivalent C or C++, but Go or Java or whatever. We just want a good type system in an imperative language, in which case you're certainly worse off for having to deal with these things. It's hard to tell if it's outweighed by type safety and performance. 
define "GC"
I'm not a heathen; of course I indent with the correct character ^(it's tab). Markdown prefers spaces for its indents, and generally uses four spaces as its indentation count. The tab button on the website is a browser control, and the tab button in `*.md` files is interpreted according to your local Markdown compiler.
I think that just binds to system `libcurl` though.
The problem with that is that Brainfuck includes structured loops (vs normal bytecode which has jumps to an address), which means an O(n) parsing operation to match them up, and if you're trying to be at all efficient you'll need to store the results of that parsing somewhere, and at that stage you might as well just parse the code into a data structure.
You shouldn't need two blank lines for list items rendered: * one * two written as * one * two
Theoretically, this should be in FCP: https://github.com/rust-lang/rfcs/pull/1615#issuecomment-290217975.
I can never keep markdown dialects straight. Thanks for the correction
Rust also has the `Any` type, for when you want REAL dynamic typing. ;-)
Small talk: would the best way to do this to do something like "if this test has passed on nightly since $BETA_RELEASE_DATE, then ignore failure"?
This is not always an option, and is sometimes a good way to get yourself a meeting with your local security and compliance people.
Java also possibly has to store metadata, like tables of references to classes and methods and whatnot. Alternatively, `[` conditionally pushes a code pointer to the stack, and `]` conditionally jumps to it or pops it.
It's all done on GitHub. If you find a crate you like I would guess you could put in a PR for it.
Wow. That's. That's really smart. Can't believe I had never thought to do something like this before in some of my code.
Pyret is great! (And the flavor/theme is fantastic, the name, femur lambda logo, arrr extension...) I wish Python had ADTs... 
I don't really like using iterators except for for each, as I believe they make code harder to read. Only because your language has some feature doesn't mean you should use it everywhere.
Heh, thanks. I was surprised when I noticed rust would allow it. It's a dirty trick I use more often than I'd like to admit with react (I guess just js in general...) to have a block of code inside of a render function.
Nah not really. A project this young should probably not have any logo. What happened, is that as a joke I slapped a super ugly&amp;cheesy generated logo one day : http://fulmicoton.com/tantivy.png After a few days, the mild hilarity faded away, so I designed the current logo and replaced it.
Think you mean Thursday week? It's on 13 April
The `for` loop in Rust uses iterators, too.
I'm planning on continuing development. The other maintainers have been quiet for a while so it's time to pick up some more people to help! As mentioned in the [call for participation thread](https://users.rust-lang.org/t/twir-call-for-participation/4821/36?u=matthewkmayer) I'm available for mentoring. Also, I'll be taking advice from there to create a new issue, "looking for maintainers," to outline what we're looking for and how to help.
Can this be generalized to `wrap!(some_fn) { my_fn }`?
OS: Linux Results of `echo $PATH` /usr/local/vitasdk/bin:/home/username/.local/bin:/home/username/.local/share/npm/bin:/home/username/bin:/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/home/username/go/bin:/home/username/.gem/ruby/2.4.0/bin:/home/username/.cargo/bin Cargo is right at the very end. EDIT: $ whereis rustc rustc: /home/username/.cargo/bin/rustc
I feel like most arguments care about all the arguments, eg. cache, or none of them, eg. timer. The latter seems possible, but is the former not possible?
Sorry, I'm a little confused by your question. In both cases of no arguments or any arguments, wrapping might as well just be done with a regular function. wrap!(say_hello, wrapper_fn = { // do stuff let v = say_hello(); // do other stuff v }); wrapper_fn(); would be no more generalized than either just explicitly defining a wrapper: fn wrapper_fn() -&gt; v_type { // do stuff let v = say_hello(); // do stuff v } or having some function that accepts some function to call: fn wrapper_fn(f: &amp;Fn() -&gt; String) { // do stuff let v = f(); // do stuff v } Does that answer your question, or did I miss the point?
Interestingly, I can reproduce the result of the OP on [the playground](https://is.gd/WD7qcs). Sadly you can only compile binaries there, so I needed the println to prevent a no-op program in release mode... Maybe someone can explain the difference between your result, and the result on playground?
You're right, I get the same results as the post by doing this instead: https://godbolt.org/g/8iFNbx I think it's odd that rust still takes the time to setup the stack though.
Great read, as always! Minor mistake, the [rustdoc now uses pulldown-cmark instead of hoedown](https://github.com/rust-lang/rust/pull/40516) link seems to point at the wrong pull request. I think you meant [PR #40338](https://github.com/rust-lang/rust/pull/40338)?
I was thinking of something exactly emulating python decorators, for some cases that don't necessarily require kwargs. For the no argument case, I tried [this](https://play.rust-lang.org/?gist=881f9bc63bb11c91cd031bf43119c5bc&amp;version=stable&amp;backtrace=0) which doesn't compile. The macros seem like they would be straight forward enough, but not the functions. 
Oh, thanks! The quotes confused me. I usually see that pattern in​ the context of like... &gt;ATM machine &gt;&gt;"automated teller machine machine" So I was trying to find where OP made a mistake. Oops! 
Problems with restrict: 1) The invariants assumed by "restrict" are not enforced. Thus, compilers that use 'restrict' aggressively are liable to introduce subtle bugs when programmers use it incorrectly, which is easy to do e.g. when code accidentally creates an alias that should not exist. 2) "restrict" is unduly restrictive, because it doesn't allow multiple immutable references to the same data.
In each TWiR issue, in Crate of the Week section, there is a link where you can submit your suggestions.
This issue is _not_ in FCP yet. `@rfcbot fcp close` is issued to instruct rfcbot to start asking all team members to review and put the RFC in FCP _after_ all team members sign off.
Are you compiling the Rust code with the `--release` flag?
You did not build with cargo build --release did you? I tried it: cargo build --release time ./target/release/rtest real 0m0.052s user 0m0.046s sys 0m0.003s
And of the overhead? File|Size|Minified|Gzipped :--|:--|:--|:-- [wasm](https://kainino0x.github.io/wasm-call-js-from-rust/out/release/wasm-call-js-from-rust.wasm)|97,268|-|38,470 [js](https://kainino0x.github.io/wasm-call-js-from-rust/out/release/wasm-call-js-from-rust.js)|226,387|105,488|31,229 So we’re talking ~70KB of overhead. Not too bad. The actual alert part becomes this (in two places): function _alert(e){window.alert(Pointer_stringify(e))} _alert:_alert, There are substantial perf possibilities in the emscripten-generated code to make it more amenable to minification and to remove dead code. (You can save a couple of kilobytes on the min+gz by removing node/shell-specific things, for example.) All up, I think Rust is looking quite viable as a language for writing web stuff in, size-wise, and you’ll have to admit that there is very little overhead for calling into JavaScript.
This is factually incorrect, C++ does *not* have a standard ABI. It's why C++ libs compiled with G++ don't link properly with code from Clang/LLVM. EDIT: [Here](http://stackoverflow.com/questions/7492180/c-abi-issues-list) is a SO post with what I'm talking about
If you're just using rustc and not cargo, you can pass it `-O` for optimizations.
"This means that you will have to learn a lot of these things at once, without being able to layer knowledge on knowledge." FWIW, Steve and Carol tried really hard with the new 2nd edition book (http://rust-lang.github.io/book/second-edition/index.html) to address this very issue head-on. We talked a ton about how interrelated concepts are. We ended up going with a layered approach (what Carol called spiralling up the mountain) where you see concepts early on that you'll see in more depth later.
Yep, try cargo build --release instead of rustc. Rust should NOT be taking that long, it's on par with the C version on my rig.
Do you know if rust has a way to use a match statement against a cast from Any? Like where you check if some Any value can cast to a number of types, and if none work you panic?
I actually used rustc :$ Because i got all my info from the official documentation which used only "rustc" in examples, Anyway... i'm really sorry if i didn't compile it the right way; i'll try to understand and use the whole "cargo" thing and see what's up. Thanks :)
It's a bit of a technicality, but restrict is C only (specifically C99 and C11), not C++.
I genuinely feel diddled that the optimiser didn’t optimise all the loops out of existence. If you change the inner loop: for i in 0..inner { s += 1; } Into this: s += (0..inner).map(|_| 1).sum(); Or this: s += std::iter::repeat(1).take(inner as usize).sum(); *Then* it optimises it all out of existence.
oh, yes it should have been mut for what I said to apply, you're right.
What hash algorithm do you use? How does it compare in performance to SHA-1?
Assuming one remembers to actually pass the optimization flag to the compiler, of course. :P How does the generated C code compare to the slower Rust solution?
Take a look at https://github.com/ctjhoa/rust-learning#people I try to gather useful links.
The hash algorithm in Pijul is future-proof. It's currently SHA2-512, but the hash is actually an enum type: enum Hash { None, Sha512([u8;64]), } Adding new hashes is easy and doesn't break the format. That said, everyone seems super worried about Git using SHA1, probably because crypto is sexy, but there are much worse vulnerabilities to be exploited in Git, most importantly the fact that the commits you review and test can be merged in the wrong place, without any notification of a problem: https://tahoe-lafs.org/~zooko/badmerge/simple.html
 That's how you break the principle of locality: by getting fired faster than light. Trying to find a way through security rules in *"a large financial institute"* is not an advice to be given lightly.
Thanks, this is some great info. I did briefly experiment with #![no_std] and IIRC the resulting binary was quite a lot smaller, though I didn't write it down. I didn't try to get a full demo out of it, but that would be a useful exercise.
Nice article, but processing live events is not what I would think about when reading the term [realtime](https://en.wikipedia.org/wiki/Real-time_computing).
Are there any of those that don't follow the typical ABI on Linux?
Great :)
I don't know as it is a bit hard to get to use all of them, but where is mentioned in the article that it is only about a GNU/Linux specific C++ ABI?
It doesn't in the slightest, but it looks to me from the other comments in here that he was intending to speak about Linux specifically (even if you came up with a new (incompatible) C++ ABI now, I think you'd have a hell of a time ever convincing anyone to use it, which is why I was asking for counterexamples).
I was just calling the attention to this, because these type of false statements *"C++ compilers can't do this optimization, for a couple of reasons. One reason is that C++ has a standard ABI that dictates how parameters are passed"* doesn't help much to win the hearts of C++ developers to look into Rust. As you already can see on HN, it comes over as yet another post from Rust brigade.
I speak en-AU natively, too, but I spend enough time interacting with other locales that I've ended up adding a lint rule to warn whenever I'm about to use "next $day". :)
This behavior is correct. What you have written is essentially *appending* `info,` or `trace,` before any `RUST_LOG` directives, and `RUST_LOG` directives are evaluated sequentially (you can easily confirm this by comparing `RUST_LOG=info,trace` and `RUST_LOG=trace,info`). So `RUST_LOG` can overwrite your default preference---move the `builder.parse` call *before* `builder.filter` if you want to avoid this. I can also see a glaring error in your code: `builder.init().unwrap();` is only executed when `RUST_LOG` is set. Move it out of the conditional block. But most importantly, you don't have to alter the environmental variable to restrict the maximum reportable logs! In fact your code will still check if the log is enabled for given error level and module unconditionally, and in a tight loop this can be very costly. You can set `max_level_*` and `release_max_level_*` [Cargo features](http://doc.crates.io/manifest.html#the-features-section) to completely get rid of logs which level is greater than specified---this is documented but not obvious from the overview. So what you really want is to add the following to your `Cargo.toml` (for the executable crate): [dependencies] log = { version = "0.3", # or whatever you've already had features = ["release_max_level_info"] } That's it! Then you don't have to configure `env_logger`, and no trace logs nor codes for them will appear in the release build even when you have `RUST_LOG=trace`.
I'm not sure this makes any actual difference, but 1.10 is something like 9 months old. With a new language like rust, 9 months newer compiler might give a lot faster results (or might not, depends).
I think I can try to load reverse proxy on my ec2, even though my 2 domains are .eu and .sk, is that ok?
I also speak in the en-AU dialect. I see, I assumed next Thursday to be the upcoming Thursday, not Thursday week. If only English were more like a programming language and not be prone to ambiguous interpretation
You would be surprised....;)
&gt; In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better. [-- Bjarne Stroustrup](http://www.stroustrup.com/abstraction-and-machine.pdf)
Nominations accepted at https://users.rust-lang.org/t/crate-of-the-week/2704!
thanks a lot, that fixed it and sped up my code a lot. I figured if I don't want logging, I don't need to init the logger 
Hey, this was [my first Rust project](https://github.com/jFransham/unicode-snowlang) too! There's a "normal" brainfuck intepreter on the `brainfuck-vanilla` branch ^^Well, ^^technically ^^my ^^first ^^project ^^was ^^a ^^port ^^of ^^some ^^old ^^C ^^code ^^I ^^wrote ^^but ^^whatever.
But couldn't you strip the JS engine from servo, and manipulate the DOM directly in Rust? You'd lose the ability to run JavaScript, but you'd have a typesafe API to the DOM, with the ability to call directly into Rust libraries. How much work would it be?
It's great you had this metric, thanks for sharing.
&gt; i got all my info from the official documentation which used only "rustc" in examples Hmmm, we only use `rustc` once, after that, it should always be `cargo`. What specifically were you reading?
I see what you mean. Maybe something like this? https://is.gd/dRlu98 You could probably hack in something like decorators, having multiple layers of functions that accept any function and its parameters, using macros that return macros. Amazingly, **this works**??! https://is.gd/ckkvfn I'll see if I can put together a generic `wrap!`
I'm very new to rust. While working on my project (embedded), I'm constantly checking a disassembly of compiled binary. I can tell that rust optimizer is amazing! You can start with straightforward implementation, then add a layer of abstraction, then add another one of top of it, then another. And binary stays unchanged at each step. You gain safety, ergonomics, readability, and other things we like for free. I like how things like unit structs or PhantomData are completely nonexistent in runtime. It is much like complex numbers, where you have real (run-time) and imaginary (compile-time) parts. I'm so excited about this language, wow.
Does [this](https://github.com/rust-lang-nursery/rustfmt/blob/master/rfc-rustfmt.toml) work? (can't test it myself right now)
No systems support linking 32-bit DLLs to 64-bit executables or vice versa, it's not possible.
Agree. At the current stage, LLVM is really so essential for rust. It is a fantastic framework.
I [ranted about this a bit elsewhere](https://lobste.rs/c/kdgi1c), but to me nitpicks like this are common in any kind of post, and not specific to "the Rust brigade" or anything. Half the posts I read on the internet give me an urge to nitpick -- I don't -- but it turns out it's exceedingly common for folks to make wrong statements that don't actually detract from their core point, or statements which have an obvious correct interpretation even though they're textually incorrect. The whole "Rust brigade" or "Rust Evangelism Strike Force" thing is a manufactured meme, by one particular website which considers mere mentions of Rust (even in threads where other languages are mentioned equally often) to be "evangelism". I'm not happy this post was inaccurate like this, and I did bring it up with the author on twitter (who responded that he was talking about Linux, where Itanium is effectively "standard" even if not officially. Talking about Linux without explicitly saying so is something programming blogs do all the time!). However, I think that after the rise to prominence of a certain site, folks are following along with this manufactured meme and painting things which are a common occurrence in all of programming as coordinated attempts by the Rust "strikeforce" or "brigade" to mislead people. I know you're only saying that HN is doing this and not saying that you feel that way too, just felt worth mentioning it here. It's ultimately stifling the ability to talk about Rust. Unsolicited barging in and evangelizing Rust is of course not okay, but folks are now painting _basically anything_ mentioning Rust as evangelism, even just blog posts about Rust, and that's not really healthy.
I don't think you can do it with a match statement, but you can use the `Any::is&lt;T&gt;()` or `Any::downcast_ref&lt;T&gt;()` method in a big if statement.
In the contents of the post the author does talk about how this doesn't scale. And it doesn't. Nobody uses restrict pervasively, which is what you would need for this to work. Rust is pervasive restrict off the bat. Meh, the title is a bit clickbaity.
Rust is designed to be a safer, hopefully better, alternative to C and C++, for the applications where you typically would use those languages. It is not some "god" language to replace all other languages. If Go or Java (or JS, or PHP, or Ruby, or Python, ...) seems easier for your application, use that language instead. It's probably better suited for you. Different languages exist for a reason, and all have their own merits. You don't have to try writing everything in Rust, just because Rust is the cool new modern thing. If, however, you are writing the kind of software that would traditionally be written in C or C++, you should consider Rust.
&gt; (never really looked at rustc code or contributed to it) Also, I find it so helpful for learning rust to read the compiler source code. I read in the rust book that threading is implemented in libstd, and compiler doesn't know much about it. But when I looked how actually it is implemented, wow! Rust type system turns out more general and applicable, than I imagined before.
I added it to current issue of TWiR.
I wanted to do it the way I described so that I can avoid the cost of the huge match, which I don't know how would get compiled, and instead just call a function pointer directly. I think even if the compiler generates a jump table, that's still 2 indirections instead of 1, but I think I'll go with this solution for now, if nothing better pops up :)
Gotcha. Funny how the author says he's a JS programmer. It's called an immediately invoked function expression (IIFE) (function() { })()
&gt; For whatever reasons, rustc handles this less well than both gcc and clang, leaving more stack manipulation around. It's a deliberate choice to keep frame pointers if *any* debuginfo is enabled, [here](https://github.com/rust-lang/rust/blob/ad5dfecc6ae23bb7d2b8075d705011918ab4f399/src/librustc/session/mod.rs#L381). See also [issue #11906](https://github.com/rust-lang/rust/issues/11906).
I fully agree with you, hence why every time someone hints at that when I am ranting about security without even mentioning Rust, I tend to include a list of languages where my previous statement holds true, which sometimes even includes C++. 
Ha! Yeah, I'm always amused when I see those comments of yours :) I like that some folks are still out there who remember that ada and other safe systemsy languages exist (I think I've mentioned this to you before!).
Yes you did thanks. I guess it was a matter of life opportunity, as a 70's child already coding in the 80's, I got hold of what was in the local library, bookstores or family friends. So when I came to learn languages like C, I had already tried out quite a few things, and never liked shortcuts, so I was already used to better languages. Additionally during the golden days of USENET, comp.compilers was a daily read for me, so I was exposed to lots of concepts and ideas. For example, I got all my Modula-3 books by hunting computing books on bookstores specialized in selling old or used books. Even if I am wrong, I believe if AOT compilation wasn't tabu at Sun, or if .NET 1.0 was actually .NET Native, in both cases providing a Delphi like toolchain experience to developers, the whole issue with safety would be much better nowadays. As C and C++ became the only option for deploying applications that could not depend on a VM.
OS-level support is not possible, the 32-bit address space looks completely different from the 64-bit address space, so there's no way you can have both types of code sharing the same address space.
&gt; Go already has a head start. \&gt; opens article &gt; **How much simpler?** &gt; &gt; For instance, there is no ‘while’ loop in Go. No, when it comes to loops, you’ve got one choice and one choice only: the ‘for’ loop. Out of everything in computer science, the author's standard definition of language complexity is the number of loop constructs in the language? I will admit that I was caught completely off guard by that statement.
This is a really nice post. And it approaches it from an angle that I wouldn't have thought was necessary before reading the post. The nice thing aboit Rust is that it abstracts away a lot of the nitty gritty systemsy things folks tend to have to worry about in C. Folks coming to Rust after knowing C or C++ see through these abstractions, and will be aware of how to unpack them when they need to do things like FFI. Not all folks from other languages will see this -- it's perfectly possible to program in Rust without understanding what's going on under the hood, much like it's perfectly possible to program in Python or Java without knowing what's going on under the reference abstraction. For folks who have yet to punch through the abstraction level, posts like this -- which explain FFI in detail assuming very little -- are very useful. Thanks.
Nice to hack in expression semantics in statement languages. What's so cool here, is that `$body` may call itself, or rather `$name`. Therefore the wrapped function will now call the wrapper without any modification of the function body and without putting the original function into another function. As far as I know there is no way to create an identifier from another identifier such as making `$name` into `${name}_original` (in bash syntax).
How about trait objects? This is what I did when I needed a bunch of operations with the same parameters and stored in a Vec. There is more code, but it comes out very clean. There is no large enum that you have to pattern match.
&gt; Last Friday I had to process and plot 120 megabytes of data. First, nobody is saying that you have to process all your data in python, but rather, that a good solution to the authors problem should allow you to dynamically explore data as well. Second, you are going to run into that problem at some point even if you were to do the visualization in Rust. There are many high-level libraries for exploring data (e.g. in Python libraries like PyCuda/PyOpenCl) which translate your data queries down to C, compile it using GCC with optimizations, run the optimized C code, and then report back. IMO such a path seems to me more "future proof" than doing everything statically in Rust because visualizing data is an intrinsically dynamic problem. Having said this, if you need to do the exact same query often, it would be cool if one could dynamically generate the C code ones, and run it multiple times. (replace C with Rust at will above)
After thinking about this for a while, yeah, you're probably right that this is faster (or probably at least as fast) as the method I proposed. However, I think this is still not as fast as it is possible to do with computed gotos. I think it is possible to achieve something like that with functions + tail calls, but as there's no guaranteed tail call elimination in Rust, I can't do that in a way that wouldn't blow up the stack with debug builds :(
en-GB doesn't parse either.
The parameters in my case are not the same though, and trait objects imply using Box, which I would like to avoid.
/r/playrust
Late to this thread but I'm missing something. If `$body` is an expression already, why do you need the immediately-invoked function? What does that give you over, e.g. `let val = { $body }`?
Kudos to Zalando for taking the facilitating this. However, if you are not in Dortmund but in Köln and want to know about Rust, there is a very active meetup group there. https://www.meetup.com/RustCologne/
It needs something like this http://try.kotlinlang.org/ then it'll be perfect
Thanks for taking a look! The problem with that approach for me is that T needs to also be able to implement Prune, which makes the problem much more complex... :( The best I've come up with looks more like this: impl&lt;'a, 'p, T&gt; Prune&lt;'p&gt; for Maybe&lt;'a, T&gt; where T: 'a + 'p + Prune&lt;'p&gt; { type Pruned = Maybe&lt;'p, T::Pruned&gt;; fn prune(&amp;'p self) -&gt; Maybe&lt;'p, T::Pruned&gt; { match self { &amp;Maybe::Missing =&gt; Maybe::Missing, &amp;Maybe::Avail(ref orig) =&gt; Maybe::Avail(orig.prune()), &amp;Maybe::Ref(upstream) =&gt; unsafe { Maybe::Ref(mem::transmute(upstream)) }, } } } And in the real code, Maybe&lt;T&gt; also needs to be able to store copies of both T and T::Pruned, which means the mem::transmute() cop-out doesn't work either, as there's no way to tell the compiler that T and T::Pruned are in fact identical types, modulo lifetime. I did find some further info on the forum though: https://users.rust-lang.org/t/parameterizing-over-data-structures-hkt/3706 Currently thinking of adding a unsafe fn _coerce(Self::Pruned) -&gt; Self; method to the Prune trait.
You say that, but running a 32-bit binary on a 64-bit system involves interop between a 64-bit kernel and 32-bit applications, as well as sometimes having inter-app communication between 32-bit and 64-bit user applications through a message passing interface.
wow, that is awesome.
While I agree that computed gotos could be theoretically faster, I do not see a way of using them here in a safe way. You could of course always fall back to `unsafe`. I would be interested in actual profiling numbers, but I think that you'd require the GCC computed goto extension to get any benefits from a high language (vs writing it yourself in assembler). Related discussions are on internals: [This thread](https://users.rust-lang.org/t/how-can-i-approach-the-performance-of-c-interpreter-that-uses-computed-gotos/6261/4) links to a [very elegant implementation of your problem (minus the parameters for your opcodes) on the playground](https://play.rust-lang.org/?gist=8fc08d2c9980aaee363d2f7842e44b1c&amp;version=stable&amp;backtrace=0). [This thread](https://internals.rust-lang.org/t/computed-gotos-tco-threaded-interpreters-experiments-and-findings/4668/6) contains some insights. 
Well, almost all code samples, also over at rust by example, have a link to the playground.
Post the contents of your `Cargo.toml`?
cargo-0.17.0-nightly (f9e5481 2017-03-03) A little surprised about the "nightly" part as I just went with the main download at https://www.rust-lang.org/en-US/install.html
That is normal, Cargo is still considered "nightly" for stable Rust releases for now. What OS are you on?
Is there ... something like a link, or a hint, for someone who has no idea whats the first or whats the second book is ... :-) please :)
Win10 x64. Appreciate your help by the way.
I'm not finished and I haven't compared the completeness of content between the two. I'd say, that at the very least, a new user should start by going through the second book then use the other learning resources to fill in gaps or strengthen skills.
Yes, I've created several and it happens every time :/ I'll try a clean install in a VM.
Yes, I'm praising the second edition in your comment.
Thank you :)
On top of using #![no_std], I think it should be possible to further reduce the size overhead by manually writing a more minimal version of the JS loader code. A lot of it is implementing system calls in JS, but for raw computation none of them should be needed.
To target XP there's a few basic things you have to do. First you should never rely on any system function which was not available on Windows XP. This also means you cannot use any functionality from other crates (including std) which rely on such system functions, which eliminates the majority of the ecosystem from being usable. Second you have to either use a linker that creates XP compatible binaries or tell your linker to target XP (you'd use the `/SUBSYSTEM` linker flag with `link.exe` to control this). Finally you'd have to make sure you link against an XP compatible version of the CRT. With all that in mind, unless you have a genuine need to support XP and are willing to do a lot of hard work, you should probably just forget about XP support. Cross compiling from linux to windows using msvc is a very complicated topic separate from the matter of targeting XP. Normally you'd use `i686-pc-windows-gnu` instead with MinGW to do such cross compilation. You can technically use the msvc targets on Linux, but you'd either need to have a VC++ installation that you run under wine, or use LLD with libraries ripped from a VC++ installation. 
You can't compile to an `-msvc` target tuple except on Windows, since that requires using the Microsoft Visual C toolchain, which only exists on Windows. (AFAIK) If you're compiling on a Linux box, try targeting `i686-pc-windows-gnu`. You may need to install that flavor of the standard library (`rustup target add i686-pc-windows-gnu`).
You should file a bug at Github.
What stands out to me is the section titled "Syntax *and Semantics*". As in, everything in this language has a meaning/behavior and that's on purpose, not just a bunch of hacks or things that happen to match whatever the original target platform was.
Rust tries to minimize "compiler magic" and offload as much as it can into `libstd` or even farther out into other crates. There are a lot of features living in official or unofficial crates that are part of other languages' standard libraries or even "compiler magic". On the one hand, I'm really happy that the language is largely self-implemented and doesn't rely on a wizard compiler (like Golang, IIRC), but on the other hand, it's sometimes frustrating to have to chase down which foreign crate to use for common-but-not-standard operations. Like regex or endian conversions (crates by BurntSushi), or HTTP (see `hyper` and `reqwest`) or ... whatever it is Tokio does. ---- Edit: it's worth noting, though, that `Box` is *100*% compiler wizardry that is special sauce in the compiler that won't fly in foreign crates. It's one of the only complex examples of this about which I know (a simple example being that the arithmetic op functions just call ... themselves; the compiler *just knows* to turn `Add::add&lt;i32&gt;(self, rhs: i32) -&gt; i32;` etc into the appropriate machine instructions) and something that is a vague future goal to move into stdlib or user space and out of compiler magic.
+1 for this, will definitely be helpful both for future users with a place to find the bug, and with the possibility of a fix!
Ah don't worry about it, it's like 5 bucks a month. If you really can and want to pay it back, you could set up a recurring donation of that amount to [Black Girls Code](http://www.blackgirlscode.com). 
Also let me know if you need any other rs domains. I can use virtual hosts to get all of them up on the same server. 
I've got an idea for something generalized and pretty close to decorators (thanks to being able to define macros in macros) so stay tuned!
Binding on :: will also listen on IPv4 (dual-stack).
Man I remember using that version back when 1.0 released. The amount of documentation and improvements now makes that look like the dark ages. Seriously, great work on updating it.
I haven't looked closely yet, though I've peeked in now and then and liked what I saw. Looking forward to a serious look now that it's nearly 'done'. In any case, thanks!
Whoops. Nothing to do with subst. Just a rogue cargo.toml higher up in the tree...
&gt; apart from their slightly crazy subscription model. I see why they did this I just really wish they didn't. I work for a university subsidiary and thus have an educational email TLD to abuse if need be. I'm using their community editions at the moment; I guess I'll see how that goes and whether the subscription would be worthwhile. I'd much rather buy than rent, even if it means re-buying in a few years.
/r/playrust
Ah - `return` makes sense. How does it help recursion?
Thanks, these are quite interesting! I actually tried a quite similar thing to this implementation, and then decided against it because if the tail call optimizations are not done (in debug builds for example) this would cause a stack overflow.
I'm not upset, sorry if you felt that way :) I'll go with the simple match implementation, as it is probably perfectly good for my use case, I just got a bit carried away in trying to optimize.
Ah, I guess I was just thinking in terms of an early return returning itself. So nothing special about recursion, just `return` statements.
I didn't say you couldn't have communication - of course you can. But they can't share an address space! If they're not sharing an address space then they're not in the same process, and it's not dynamic linking.
Yeah, VS Code is my favourite editor by far these days! ripgrep is also an awesome tool in its own right - I've been having to learn my way around a pretty large codebase at my new job, and being able to search for stuff without waiting around for hours has been an absolute lifesaver.
Yeah, I always skip the paths in error messages too :P
What about usage of https://github.com/dgrunwald/rust-cpython to simplify rust&lt;-&gt;python cooperation?
*Hours?* Golly, which tool were you using previously? :P
You should go to r/playrust instead
I've only seen the word impedance in electrical circuits, what does it mean in this context?
I have made $60 donation to Black Girls Code. Donation Details Donation amount: $60.00 USD Total: $60.00 USD Purpose: Black Girls CODE Contributor: Rxxxx Joshi Recipient information Donations coordinator: Black Girls Code Contact email: future@blackgirlscode.com Receipt Number: 4352-4058-0647-xxxx 
Please add Rust community blog. http://blog.community.rs/
Btw, the MSVC compiler (a console program that only includes the compiler and linker, not the IDE) can run very nicely on wine.
https://intellij-rust.github.io/ I think it also work with the IntelliJ Community Edition (the free one)
Binds IPv6 only for me (macOS, Arch Linux). I'll try it on Windows ~~and Linux~~ as well.
Oooh good to know
In electrical circuits, maximum power is transferred from A to B when the output impedance of circuit A is the input impedance of circuit B. An "impedance mismatch" is when this doesn't happen, making the circuit inefficient (and in some cases distorting the signal) The term can be used in a general context to just talk of two systems (or people!) which don't gel well because they're operating on different levels or paradigms. Neither is necessarily superior, but the fact that they're different causes problems in the transfer of knowledge or whatever process is going on. In this case, it's just two people (the doc writer and doc reader) having a hard time communicating because the docs are written assuming a different mental model / paradigm than the doc reader. (Another EE/physics term that can get used here is "operating on different wavelengths")
(typo fixed, thanks) yes, this is basically it, though it doesn't just have to be notation. It can be the way you look at things. Most mental models are nebulous and never get written down :)
Replying again, there was only one non-ASCII character in the C/C++ source code, in a comment, and I replaced it with ASCII text. So I also removed the use of the "/utf-8" flag. Additionally, somebody else contributed a way to skip the C++ tests. It's likely it can be extended to also skip them when targetting VS2013. So it's more likely to happen than I thought.
I'm total beginner in Rust and stopped reading this book because of "guessing game tutorial" chapter. It is very confusing for newcomers like me. I switched to https://github.com/stevedonovan/gentle-intro and https://github.com/carols10cents/rustlings. After a couple of weeks i returned to the book and found out that all other chapters are good. Nonetheless i believe that "guessing game tutorial" should be rewritten or moved to later chapters.
Great, thanks for clearing it up
Oh, I'm afraid you don't understand how BigCorp Inc. works. :-) I encountered a blocked site when I worked at BigCorp Inc. Helpfully, the "block" page itself included a link to a form to unblock erroneously blocked sites. "This should be quick", I thought to myself. _click_ 404. Okay, okay. It's just a mistake. I navigate to BigCorp internal IT website: ah, here's a link to the form, oh, and it's different! They must have just forgotten to update the block message itself. _click_ Ah, yes, the form! I'll just fill in the URL, why this shouldn't be blocked, and submit _click_ 403 Forbidden. Are you kidding me? Ugh, okay. A human can resolve this bullshit. I email internal IT support, lay out both the URL, why it shouldn't be blocked, and why I'm emailing them and not filling out the form, because the form rejects me. I include screenshots and adequate documentation. The next day, a reply! &gt; We have a form for blocked sites. Please fill it out. It is here: [URL to the form that rejected me with a 403.] I never got around to it, but I kept meaning to visit Scott Adams' cube, since _cleary_ we worked for the same business.
No, more of a description of a situation where things don't go smoothly because two elements are not good at exchanging things with each other. "Talking on different wavelengths" is really the best description I can think of, but that's physicsy too.
thanks for all your effort brson &lt;3 you're a hero!
brson, of all the people I've ever worked with and met in technology, I have to say: you are one of the kindest, most forthcoming, approachable, modest and thoughtful people I've ever had the pleasure of talking with. It doesn't surprise me in the least that you are so introspective; you really are quite possibly the perfect embodiment of the spirit of the Rust community. If only we were all as good as you...
What post-XP stuff is used in std? Is it just better APIs for existing functionality, or does it rely on functionality not present in XP at all?
Working on [gutenberg](https://github.com/Keats/gutenberg). I released a new version yesterday that works on Windows and adds shortcodes/relative links and a few more things. Looking at pagination now.
No, you're right.
"Exercises" is correct, yeah 
Thanks for my first reddit gold, stranger!
Any suggestions on what else needs to be covered are welcome! Motto of project is yet another fake Einstein quote: "A introduction needs to be as gentle as possible, but no gentler"
It certainly is a cultural thing, because I cringe a bit hearing awesome and amazing too often. ;) But that certainly isn't any kind of argument against being nice. :)
Very insightful post. Thanks brson.
Imagine if crates.io wiped once a week. That would make for quite a challenge
Isn't VS Code more of an editor rather than a full IDE ?
Nah, think of two pipe fittings that don't quite... fit. (Or a square peg into a round hole, or...)
This is really exciting! A question regarding the compiler plugin: do you expect that this would eventually be reimplemented using the full "Macros 2.0" feature set, or is it doing things that tie it intrinsically to the reference Rust compiler? I'm also wondering whether this experience might end up _informing_ some of the details of Macros 2.0.
&gt; So, you are advocating for watering down technical discussion with thanks, compliments and emoticons? I don't see how being empathic and respectful to others is watering down a technical discussion. On the contrary, abrasive behaviour will introduce much greater friction to the discussion than a few nice words and a little bit of goodwill. Also, I like to spend my time with nice people, and if every technical discussion is emotionally taxing (or just unpleasant), I'll find something other to do than open source in my free time. 
Does your RFC relate to [external/peer dependencies](https://github.com/rust-lang/cargo/issues/2064)? I've been thinking about that issue for a while now, so I'd be keen to help out if it is.
Yes. I can share with you this weekend if you want. Not fully done yet.
Thank you guys. Decided to give up on this idea as of now as it looks like to bring more problems than anything useful.
Avid VSCode user here, and the new search is sooo fast. I can search my entire project tree instantaneously, whereas before it took at least a second or two. It's really amazing. 
&gt; I personally might go overboard sometimes I bet you can't top /u/carols10cents usage of heart emojis and exclamation marks though :D
In Rust it should by just http://rustlang.org? :P
It really is an IDE by now. I can't think of anything it doesn't do that an IDE should be able to do. It has projects, debugging, version control, plugin support, refactoring, etc.
&gt; One thing I find quite difficult, and perhaps might get advice for here, is how to call people out on behaviour you're not comfortable with, without becoming yourself emotionally bitter and breaking the very standards you're trying to self-impose. It's easy when you're detached from a community, but when it comes from someone you trust it can be challenging. I guess you fake it? :D If it's someone you trust, then one path you might consider taking is to contact them privately and just gently nudge them. It's rare for something like that to go sideways in my experience. Chances are, they had no idea they were doing something that bothered you and will be eager to not do it again. :-) As a moderator, we try really hard not call out anyone specifically in a public forum and instead address the collective participants in a thread. Calling someone out specifically can be an embarrassing experience and can lead to the exact opposite reaction you were hoping for.
Same reason you don't see a new vendor-prefixed CSS property every week anymore. They learned their lesson about people ignoring the "unstable/experimental" labels if you let them use the features in a stable release. Nightly is *supposed* to be unstable so that, if you depend on an unfinished feature and they change or remove it, it's your own damn fault and nobody can justifiably argue otherwise.
To add to that, if you choose to do the former, rustup is perfectly capable of installing a nightly for a specific date. There's no need to "throw away rustup"...
You are intorducing a strawman here. Where did I say one should be abrasive or should put emotion into technical discussion? I said exactly opposite, don't water down discussion with your compliments and what not. 
It still keeps the guessing game.
Hey, thanks for pointing this out. I'm really interested in this setup, do you have any more info about about how to set this up? Lately I had some issues setting up the msvc linker on windows itself :) (link.exe requires some environment variables to be set, that's what "vcvars*.bat" is for, but was broken on VS2017)
Plenty of people don't know how to ask a question. Asking good questions is an art form that one has to learn and develop. You could say any one of a number of other helpful things: * "Have you checked out the book yet? It has a great section on lifetimes. If you did read the section on lifetimes, where did you get lost?" (So yes, pointing to the book is one reasonable answer.) * "Do you have a short snippet of code that you're struggling with that we could look at?" * "What specifically did you find confusing about lifetimes? Can you narrow your question down a bit?" * My favorite: "What problem are you trying to solve?" (Although I recognize it doesn't quite fit in this case.)
Hi!!!!!! You called??!!??! ❤️❤️❤️❤️❤️❤️❤️
The thing is, it's not possible to communicate without conveying emotions. The question is not if one should put emotions into technical discussions, but what emotions. The first one is impossible.
I love this post 😻 Contrary to what my over-use of exclamation marks and hearts may indicate, I often struggle with always being nice every single time as well. It's hard work!! Part of what I love about the Rust community is that this niceness is so baked into the culture. This is going to sound incredibly over-the-top, but I really feel like being a part of this community is making me a better person. I have been mean, sarcastic, caustic, rude, bitter, etc, and it's easy to give in to those feelings and spew them out online. But here, every single time I go to do that, I stop and rethink and try to reword, because that's not acceptable here. We're all pushing each other to be better. We're all going to mess up, but we all value each other and will help each other improve. So thank you /u/brson, for writing this, and for helping to keep up the kind Rust community culture ❤️❤️❤️
Thanks for response, it cleared up some things to me. I still see no reason for complimenting, thanking and emoticoning in technical discussion as advocated in original post.
&gt; Nobody uses restrict pervasively Are you sure? I thought it was used frequently in scientific computing.
Appreciate the response. Yeah, taking things private is a good idea and I should make it a more instinctual response of mine. Though it contains good advice, I'm more asking about cases when your first paragraph fails. Rust's community is excellent, and I'd never feel amiss in it (that my employer restricts my interactions with the community was by far my biggest reservation about the job), but not every group sees the same platonic community ideal. As an exaggerated example that I expect most people are familiar with, what should you do if Linus Torvalds directs one of his famous rants at you? How do you approach the situation as your better half when you're as weak-willed as I am? I don't think a private message is going to work as well in that scenario as it would here. 
Could you give an example where it leads to wrong/weird/unintuitive/whatever behaviour? As I see it, a borrower saying "x and y have the same lifetime" effectively says "I won't touch it if the liftetimes don't agree", which seems perfectly fine to me. Otherwise it would make absolutely no sense storing structs with lifetime parameters in collections (as the lifetime is a part of the type, it has to be the same for every elements), which can be useful for things like syntax trees holding slices to one original string.
I see. I don't have any good answers to that one. I have specific personal answers for it, but they don't generalize.
And I want people to push to make it possible to do microcontroller programming on stable. Very much so. I don't think it's right that such a valuable community be required to use an unstable compiler. 
 &gt; For me communicating with others is frightening, stressful, unpleasant, demoralizing, depressing. That's fine. Thanks for being open with it. &gt; There are long stretches where I just can't face the endless tide of other people needing assistence, where I will just willfully ignore my inbox. If that's how you feel about it; consider taking a break. Ask for help and co-maintainers, where you need it. I might be reading this the wrong way, but I get the impression that all projects in combination, is about to become too much for you. No project is worth being burned out about; not primarily because a burned out maintainer is a bad maintainer, but because nobody deserves to be burned out, it's *horrible*. &gt; "Oh, wow, thank you so much! 💖" Now, what scares me the most, is that if you go down this route and *fake it till you make it*, you'll give the impression that you're the kind of person who likes chatting to people, which obviously is not the case. I e, you're encouraging more conversation. And while such sentences might make you a friendlier maintainer, it might not be worth it if it makes conversation even more difficult for you. Take care. 
On Windows, v6only certainly is set per default. Arch Linux uses the kernel defaults there though, so you probably enabled it yourself.
Never heard of it... Thank you for reply, anyway!
&gt; I've had so many conversations with folks over the years where they don't want to participate in open source because they're _scared_. I guess one of my fears is being scared that I won't be perceived as "nice enough" for communities who have specific positions on the matter. Watching /u/genius_isme's comment get steadily downvoted isn't really doing anything to allay those fears TBH (in fact I feel a bit nervous just writing this piece). I think /u/ppartim's response addresses his comment in a useful and productive manner. The lack of exclamation marks and smileys in said response is noted and appreciated, I guess /u/ppartim has a good sense of how to interact with people on their own terms! Free exclamation mark and smiley in this comment to compensate :-)
&gt; I guess one of my fears is being scared that I won't be perceived as "nice enough" for communities who have specific positions on the matter. It's a reasonable fear to have. I have it too in various forms. (My fear isn't necessarily with being labeled as being "not nice," but rather, for having the *wrong beliefs*. But that's a topic for a totally different conversation.) I think that means we should try to be nice to people even if we perceive them as not being "nice enough," because not everyone has the disposition to be flinging exclamation points and emoticons everywhere. There's a limit to this, obviously, but I think it's part of the message. There's no requirement for everyone to be excessively positive, but if you're maintaining a project and seeking contributions from as many folks as possible, then I think there's a good argument to be made that being excessively positive will lead to better outcomes.
I understand and empathise with your "having the wrong beliefs" point. "Having the wrong beliefs about niceness levels" may lie at the intersection of the two. One reason I hope none of my projects becomes popular is that I simply wouldn't have the energy to manage (too many more important demands on my energy elsewhere). Luckily nothing I work on is interesting enough to be popular; the hidden advantages of being a bore. :-)
&gt; to collaborate. Ugh. Oh, how I identify with this feeling. Someone wants to work with me to make the project better -- awesome! -- yet I somehow end up feeling like it's something I have to deal with, rather than embrace. It's not this way all the time, but often enough that I feel guilty about it. If I have some criticism, I'll often write a lengthy reply, think "geez, that's negative!", and then cut it down to "just the facts" to get rid of the emotion. But I realize that can come across bluntly, curtly, still too negative, so I could probably use some of the techniques discussed here to be more encouraging. Great post! 👍 ️💯 😍
&gt; I may be (probably am) alone You're not alone. But you're probably a minority, at least in this particular community. 
In theory, yes. In practice, "yes, but..." Firstly, ripgrep would need to be decomposed into libraries. This is an ongoing process and most of it is done. But there is still one crucial piece left: the core search functionality needs to get moved out into a separate crate. As of now, it lives directly inside the ripgrep binary so the only way to use it is to use the binary itself. Secondly, you'd then need to write some wrapper library to make it available in Node. [For example.](https://github.com/dherman/wc-demo/blob/master/native/src/lib.rs) In the case of ripgrep, this is a non-trivial amount of work because you'd need to wrap each of the various libraries and then redo all of the composition that happens inside the ripgrep `main` program. (e.g., The translation from "here are my command line flags, now actually execute the intended action.") There are a lot of knobs. Thirdly, one should question the wisdom of such an endeavor. Running the ripgrep executable and parsing its output isn't that hard, and you'd be using a well supported interface that N other humans also use, instead of hand rolling your own interaction based on the parts of ripgrep rather than its whole.
That would be awesome! It would be even more awesome if it was pre-compiled for each stable version.
I'd already gone through my emotional rollercoaster by the time I got to that part. I figured describing my journey could provide a little amusement.
A plea to whomever writes such a PR: please make sure I can opt-out! I like working offline for long periods, so if my cargo cache were cleaned out inadvertently I would lose productivity.
That's the idea as I read it. Something along the lines of `rustup component add clippy-x86_64-unknown-linux-gnu` and that'd be it.
Careful not to go too far down the analogy :). Fork and run works if you're at complete odds with the other party, but I'm talking about bridges you're fonder than that for. I guess if there was an easy solution there'd be less need for posts like these. Maybe the real solution is just *try real hard*, and I think I'm OK with that. It's one of the reasons I really liked reading this post; it's given me something to aim for more than just "be nice". 
Internet emotions are hard. You meant a little amusement, but it sounded to me like you were criticizing much ado about nothing. We're now in sync. :)
From what I remember, yes. The rationale being that they're things almost everyone will want, which need access to stuff which may never stabilize, so the simplest solution is to distribute them using the same approach for other things fitting that description (eg. stdlib).
You can use rustup to link to an arbitrary toolchain on disk, but you would have to handle download and extraction of the toolchain yourself. Also, servo do not use a custom version of rustc from the firefox or servo teams, they use builds from rust's CI. Most of the time they will be using an official nightly, but occasionally they will be using a "newer than nightly" build.
I do not agree with /u/genius_isme's argumentation and - having nearly 20 years of OSS software maintainership on my back - I fully agree with /u/brson's viewpoint. However I politely request that people stop down-voting this comment - it is on topic, honest and provides a different viewpoint with an argument and ignited good discussion. It should be acknowledged and not downvoted until it is hidden by reddit just because people disagree with the argument. 
I think over-use can make stuff seem a bit fake though; certainly when I see a lot of emoji's floating around in places where I don't expect them to be, I become wary. I think a genuine thanks, with one or two good things about their work, is a lot more effective (the original post pointed this out). Of course, this is just my feeling about the matter from the other end. I have no experience with being a project maintainer, so I might just be talking out of my ass lol.
I think you never waste time on carefully phrasing your communication. Even if we follow your opinion that emotions are not adding to a technical discussion you still need to carefully phrase what you want to state in your technical argument. You still need to write for your audience. I never learned to do this quickly, it always requires a lot of effort; I never met somebody who did it intuitively well. "Go read the book" is a quick fix for a symptom, not getting at the true problem: Why do they have the question in the first place? Why did they not read the book? Did they not find it? Did they try reading and got lost? Where? What phrasing could have helped? It could be that they are just really lazy and didn't even try, but until you probe at least once carefully, you do not have the data to conclude this. Manish just recently [blogged about this very topic](http://manishearth.github.io/blog/2017/04/05/youre-doing-it-wrong/). 
I've thought about this one for a while, and I'm somewhere closer to /u/genius_isme than to OP. But not quite as far out. :) I read the "anodyne" jerkwad comment, and felt "I write things that sound like that commonly enough.. are there people who get offended by a plain tone?"`*` I generally agree with the suggestions: I make an effort to be positive, constrictive, and encouraging. I don't brush people off with one-line dismissals. But, if a community starts to consider flattery a minimum requirement for polite speech, am I becoming more rude because the norm is shifting, and I'm not? I also sub Golang, and I love both languages.. but the communities couldn't be more different in their, er, community-ness. I'd take Rust any day. But I don't want to start worrying that I'm starting to sound coarse because I haven't used enough emojis. ( :/ ) All of which is to say: OP, you really weren't being rude at all, IMO, and while nicer is always nicer, I feel that setting such a high standard for acceptable politeness could create new, even more peculiar barriers to entry for the socially anxious. `*` Well, anyone within two-sigma of the mean for oversensitivity?
/r/playrust
dude you are in the wrong subreddit you are looking for /r/playrust
What's most interesting about this post to me (and why its relevant to r/rust) is how this argument doesn't correspond to Rust. In particular, several of the important "monads" of Rust don't conform to the interface of Monad defined in Haskell. Iterator and Future are both monads, but their `and_then` / `flat_map` functions don't fit the signature of Monad's function, which is roughly like: trait Monad { fn and_then&lt;T, U, F&gt;(self: Self&lt;T&gt;, f: F) -&gt; Self&lt;U&gt; where F: Fn(T) -&gt; Self&lt;U&gt;; } (Future and Iterator don't return `Self`, they return an adapter type.) In contrast, we do have some interfaces we can't write that do require a certain amount of 'higher kinded types,' even though they show up repeatedly in the standard library. The `iter` method (by reference iteration) is the best example: trait Iterable { type Item; type Iter&lt;'a&gt;: Iterator&lt;Item = &amp;'a Self::Item&gt;; fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iter&lt;'a&gt;; } Also it highlights toward the end a decision I'm glad about: rather than impl `flat_map` on `Option` (for example), we gave it a more appropriate name for that context: `and_then`.
Well, a couple of kb on the gzipped portion is progress, though I'm sure there are much larger gains.
This is available for any project -- you can use rustup to pin rustc/cargo to a specific nightly build in a per-directory (so per project) fashion. Example: Older version of alacritty. (Now is fine on stable!) https://github.com/jwilm/alacritty/blob/60d6071fb684d3bc15b952dd9cf96db247b91754/README.md#manual-installation
Thanks for the thoughtful reply!
Yes.
Having `and_then` rather than `flat_map` was a great decision. I get that code is basically just math under the hood but those writing and reading it might not be math people or have a CS background. Naming conventions like this are more inclusive and easier to understand conceptually.
`extern crate time_machine;` of course!
&gt; oversensitive people on the Internet I think *that's* where the disagreement lies. You seem to be assuming that this post is advocating on behalf of people that go from zero to AAAAUUUUGGGGHHHH with one comment. This post is advocating on behalf of people that, over the course of years working on software for a living, gradually get worn down by a consistently negative attitude. One negative comment isn't going to change a person, especially if it's something like: &gt; After a thorough investigation, the board decided that the evidence indicates: you stole user credentials from the database and used them for vandalism. Your alibi does not match our records, and the emails you alluded to are not in the logs. That is a serious violation of trust, and is so egregious that we cannot offer you a second chance. Your credentials have been revoked, and no future contributions from you will be accepted. When you want someone to go away, it's a good idea to use a bit of "stick" motivation. But for a first-time contributor? 🥕🥕🥕! They're great for when you want someone to come back!
If only Reddit allowed moderators to know who downvoted what. It would probably stop people from using it as a "I Disagree" button. GitHub has an "I Disagree" button. Reddit has a "This is stupid" button. There's a difference.
I'm not aware of any languages that are designed to be imperative languages with good type systems or I would consider that other language. Rust doesn't seem like an unreasonable choice and it seems like the borrow checker as room to improve that will make it more and more reasonable. Seems fine to complain about the friction even if it's better than C.
burntsushi I'm curious how much of your free time you spend on this project? I didn't realize this was a side project for you. I've always wanted to work on side projects in my spare time, but I'm always beat by the time I get home.
Yes, but on system-wide basis and container visibility.
I'm an embedded systems engineer doing PCB and firmware work in about equal measure. That means C all day erry day when I'm wearing my software hat. Lately I've been working with the ChibiOS RTOS, which I like. Rust appeals to me because of C's very weak type system and how often I want to distinguish between "BufferTypeA" and "BufferTypeB which is a 6 byte offset inside a BufferTypeA" to prevent accidentally doing a memcpy from the wrong place (for example).
Oh my. Thanks! Really, I enjoy the language a ton, but it's the community that makes it so amazing. And don't forget, the [community makes hyper too](https://github.com/hyperium/hyper/graphs/contributors)!
Self-taught programmer, studies in physics and theoretical computer science, now PhD student in computational biology. These days I use Mathematica as a scratch-pad, Python for scripts and Rust when I need to count the cycles.
To express the monadic nature of `Future` you'd need some way to express that the return type is more or less `impl Future&lt;U&gt;`, right? Perhaps something like trait Monad { fn and_then&lt;T, U, F&gt;(self: impl Self&lt;T&gt;, f: F) -&gt; impl Self&lt;U&gt; where F: Fn(T) -&gt; impl Self&lt;U&gt; } 
I personally find dealing with overly effuse people exhausting. It's one thing to make your good intentions clear but yeah, strong disagree on "don't hesitate to go overboard." Like, some of the "empathy" types in the OSS community come across as overly assuming and I just feel like my boundaries are being tested. Back off, I don't know you that well And overuse of emojis in particular is obnoxious, I mean it's not a big deal if only one person is doing it, but if the entire community is liberally peppering their posts with emojis I would consider it a turnoff
Began in the field of IT, switched exclusively to Linux after college, then after mastering Linux I started picking up programming languages to learn as a hobby, learned a dozen languages from Haskell to D, settled upon Go as my first serious language, but about a year and a half later Rust hit 1.0 and I switched to that -- Rust exclusively since then.
JS / C# / SQL here mostly. Interested in Rust because of its potential in replace C++ in many areas such as game development.
Yes but the `Self` here isn't `Future` its "some type `X`, where `X: Future`." That's a part of the problem here: some monads are expressed as types and some as classes of types.
`bind` is roughly the same as `await`, which if we had coroutines/generators have a relatively straightforward desugaring (just yield control if you don't have the result yet).
Currently working in statistical data processing. Mostly Java, with dashes of R, Python and Fortran. I also know a few other programming languages from assembly and Forth to Lua, Erlang, ECMAscript, OCaML, Haskell, Common Lisp, Prolog, Eiffel, etc. but I don't use them at work. One could say I'm a PL aficionado. I love how Rust is evolved through open processes. It's very fascinating.
I just got a Rust port of a work library to have a correct C ABI and am capable of building and linking against it on Windows. If there's a better way than `--crate_type staticlib` and adding all the (super helpful btw thanks!) listed libraries to Visual Studio's linker args, let me know. It is *super* cool to be able to debug a Visual Studio project that starts out in C and then suddenly jumps into a Rust file and steps through it all. It even tries to jump inside our `libstd` which is cool as hell, but the precompiled image says the source path is in `C:\bot` which clearly isn't true on my machine; I guess I'll try to build `libcore` and `libstd` myself and see how deep the rabbit hole goes. This is *super* cool, Rust team. I'm still using a separate editor and terminal to manage the Rust library; I'm excited to see Visual Studio expand its Rust capabilities. I know there's an extension out there that I'll have to try next. ---- I just wish `#[cfg(debug)]` and `#[cfg(release)]` existed like `#[cfg(test)]` does. As nice as a full debugging experience (complete with good symbol names, DANG GUYS) is, conditionally-compiled debug prints are also beautiful.
I'm a game development student who mostly uses C++ and C# in my day-to-day schoolwork, but I've dabbled in just about everything and I've been finding ways to use bits of Rust in all of my projects.
I'm loving the focus on correctness and testing! Keep up the good work, Jamey!
This is a fantastic post, and it really does highlight the difficulties associated with maintaining an open source software project beyond a certain size. I am glad that /u/kvark directed me to this post. Excellent writing /u/brson!
Are you me? I had basically the same path in terms of major languages, with a small dash of Lua and C as well.
Android/iOS dev for big company. Java/Swift/ObjectiveC/C++. B.S. in computer science from an engineering-focused school. No Rust professionally yet, but I've been doing all my side projects and programming in Rust for the past 18 months or so.
&gt; (it seems like there would be a significant runtime overhead to rewriting say, for ... in ... { bind ... } into the closure form that Haskell's do notation desugars to) Yep, that's another difference between Haskell and Rust that is relevant here: * Rust has syntactic loops that, as far as I understand (because of the "zero-cost" principle), are intended to compile straightforwardly into native object code loops. * Haskell doesn't have any syntactic loops at all; "loops" in Haskell are normally functions using the `Applicative`, `Foldable` and `Traversable` classes. Maybe it's possible to just punt? Somehow restrict monadic blocks in how they can use native loops. 
We haven't really talked about it. It seems likely that it will be more like Tokio: something the community seems to really like and get behind, but is separate from the Rust brand.
Now we just need a tool that takes a rust file of unsafe code, and a corresponding "assumptions" file sitting next to the rust file, eg. extern "C" unsafe fn foo(x: *mut u32) { ... } foo::x: NonZero + Valid And tries to convert to safe rust: extern "C" fn foo(x: &amp;u32) {} Corrode would then feed its output, plus a list of user-defined assumptions into the tool.
I've worked with mostly PHP/JS. But we did have Java/C courses in college.
C++, Visual Studio. 15 years experience. I still love C++, but I got sick of shooting myself in the foot with it. So Rust is a great fit for me.
Did you compile with `--release`? The build you are looking for is probably over at /r/playrust.
Professional software developer, I use C#, C++, and C daily. I love programming languages and rust is the closest any language has come to my "ideal" language. Its only a matter of time until I use it at work for something.
I love ChibiOS. Really high quality software! Which chip are you targeting?
You may find the State of Rust Survey from last year informative: https://blog.rust-lang.org/2016/06/30/State-of-Rust-Survey-2016.html As for me... * Expertise: machine learning / data science / augmented reality. * Dominant languages, through my life: QBasic -&gt; VB -&gt; C/C++/Java -&gt; Java/Python -&gt; Java/Python/JS -&gt; Java/Python/JS/Rust * Tools: Atom editor lately, have done a lot of Eclipse though and I use Android Studio for mobile. An observation: Rust draws interest from across the spectrum of programming languages. Many come from systems (C/C++) backgrounds, others of us from managed languages both static and dynamic, and yet others from the functional programming / ML theory side. What about you? [Edit: fixed formatting]
Will hit you up once I get a few things sorted out soon
Will hit you up once I get a few things sorted out soon
My guess is that the lady is looking at the girl's computer terminal and recognize Ruby by its syntax.
I don't have a math or CS background, and I think flat_map is a much better name than and_then. Calling flat_map is the same as flattening (removing a level of nesting) from map. The language already has "map", flat_map makes the relation between the two easier to understand. By contrast and_then sounds like it's either about boolean logic, or doing one thing for its side effect before another. It certainly doesn't sound related to map.
Does this have any connection with or inspiration from sysdig?
Self-taught, Python and C++ aimed at astronomy. I mostly use numpy, scipy, and astropy in Python. The only lib I could say I've used much in C++ is xcb.
Could a project like [rr](https://github.com/mozilla/rr) benefit from this?
Had this idea last weekend and realized it was doable so I did it. Very curious to hear if this actually fulfills anybody's real need, or if I missed anything.
Sure. You will need to enable [`debug-assertions = true`](http://doc.crates.io/manifest.html#the-profile-sections) in the `[profile.release]` section of your `Cargo.toml`. It will enable some features that are normally for debug builds only, including `debug_assert*` macros and the checked arithmetics. Note that this can affect the performance badly, and normally people uses manually-checked arithmetics as /u/Deckard666 has suggested. If you just want to debug overflow issues on the optimized build (e.g. because it will be very slow otherwise), you can instead configure the `[profile.debug]` section same to `[profile.release]` sans a `debug-assertions` flag.
Thanks, I added it. I'll have to check it out! 
I'm a medical physicist, meaning my area of expertise is ionizing radiation and medical linear accelerators. Lots of computers involved in using patient treatment planning for the accelerators and so we end up programming a fair number of utilities to help. Mainly programming in C++ and Python. Used Boost, DCMTK, ITK, VTK and CMake on the C++ side. For Python, numpy and scipy mainly (with the standard lib, of course :-) ). Rust is something I toy with for now and enjoy learning about.
Is there something I can add to my Cargo.toml to to turn this on?
Comparing and contrasting to https://crates.io/crates/strfmt is probably a good idea :) (I haven't checked out your crate yet, but sounds similar?)
Not yet. Can be used through build.rustflags though
I'm working on moving native-tls to a separate crate for TRust-DNS to make OpenSSL the default, but native-tls an optional dependency. Mostly done, but some annoying cross platform things to fix.
* HTML/JS/CSS/PHP in high school, self taught * Visual Basic in high school class * Java in high school concurrent enrollment class (local college classes) * C# self taught in high school, learned for my first internship * C++ learned at first internship in high school * C/Racket/Python in college * Node.js self taught for another internship * Go self taught and pitched to work at 1.0 to replace Node.js (we switched) * Ruby at work for unit tests and automation * D - self taught because interested in game Dev and hate C++/C#/Java * Dart - self taught for browser game dev, left community when they abandoned Dartium (Dart VM in Chrome) * Lua - self taught and pitched at work as an extension language for plugins for our Go server code * Rust - self taught for game dev because it's nicer than C++, compiles to WASM and is nicer to work with for FFI than Go I'm currently mostly dabbling in Rust (built a couple servers, some CLI clients, dabbled in GUI dev, etc) and building games in Unity, but I hope to build something serious in Rust soon :) For serious work, right now I use mostly Go, JavaScript and Python (I'm a full stack web dev and build lots of tools in Python), though I occasionally build small tools at work in Rust. I'm hoping that if my projects in Rust take off (I have more lucrative side hustles than games kicking around), I'll quit my job and write Rust full time.
Seems to be real. MIT [cited it too](http://appinventor.mit.edu/explore/blogs/karen/2017/02/app.html). And that led me to the [full page](http://www.readcomics.tv/batgirl-2016/chapter-8/10).
There is also [cgmath](https://crates.io/crates/cgmath). But that's Computer Graphics specific and only covers 2, 3 and 4 dimensional linear algebra.
thanks! I'm definitely more interested in general purpose high dimensional array libraries though.
How much did you guys pay to get in there ;)))))
&gt; As of this release, Rayon’s parallel iterators have officially reached parity with sequential iterators Hell yeah! This is great news.
🎺 🎺[^*](https://www.reddit.com/r/tmsbmeta/comments/5xnirl/about_thankmrskeltalbot/)
Heavy C# background, had some Python and PHP work too. Spent almost my whole programming life in the OOP weeds but since discovering Rust I've really got into Haskell, OCaml and various Lisps (mostly Racket, since I'm a bit of a freak for PLT and language design and Racket is basically a playground for that kind of thing)
Hey, sorry this got caught in the spam filter (that tends to happen to submissions from brand-new accounts) so I've taken a cursory glance at your code myself. I've not read through thoroughly enough to critique the structure of the program itself, but from an idiom and style perspective it seems pretty good, and well-commented to boot! One thing I did see is this: match last_tokens[0].token_type { BFTokenType::IncrementData(x) =&gt; { tokens.pop(); pos-=1; new_x += x; }, _ =&gt; {} } ...and I wanted to make sure that you're aware of the `if let` feature, which is useful syntax sugar for matches that only care about one variant: if let BFTokenType::IncrementData(x) = last_tokens[0].token_type { tokens.pop(); pos-=1; new_x += x; } I suspect it might do wonders for cleaning up that big pyramid in bf_lexer.rs. EDIT: I also wonder if you're aware that you can import enum variants themselves into your namespace, which would allow you to replace things like `BFTokenType::IncrementData` with just `IncrementData`.
I thought the dev team was paying _us_.
This is really nice! Could use more visibility, I think, something like this should be available on more official channels.
That would be interesting. Maybe putting the assumptions in the file directly (e.g. as a comments) though?
That's just standard text style for U.S. comics since forever ago.
Sure. Cubostratusc uses the sysdig driver to acquire the system call flow from the kernel. 
What you can do is: let's say you have your stream of actual messages and a timer stream for your heartbeats. Select on them, by packing them in an enum, and then fold that stream. By initializing the fold with a target sink and your initial state, you can use that to keep track of the state without using a separate thread. The result will be a future that you can just throw into your chain of futures/streams. Very rough code (and neglecting a few details because on mobile), but here you go: https://gist.github.com/Kintaro/d4210b7a049d331429b9851f48670cef
I'm one of the main contributors of rulinalg (pinging the author, /u/SleepyCoder123). I realize that from a user's perspective, the situation may be a little confusing. However, I think it's great that there are multiple libraries in development - they have different focus and goals, and this way there's more room for new ideas. Based on my understanding, the main differentiators seem to be: - ndarray: truly a marvelous feat of engineering, de facto choice for N-dimensional arrays. However, its genericity brings complexity and if you only need matrices and vectors, the added complexity may feel a little excessive (at least it does to me!). - nalgebra: superb documentation - I'm really envious! Main focus seems to be (or historically has been) on low-dimensional linear algebra (i.e. mainly 4x4 matrices or smaller) and as far as I know has been designed for use in games in mind. - rulinalg: aims to provide a great "out of the box" experience for high-dimensional linear algebra (i.e. "large" matrices and vectors), as it has no dependencies on external (non-rust) libraries. Since this library only exposes "matrices" and "vectors" (and not N-dimensional "arrays"), its data structures may perhaps be conceptually simpler to work with (in my admittedly biased opinion). - linxal: Brings LAPACK/BLAS support to ndarray. I'm not so familiar with this library as it's much newer than the others, but thankfully I see that /u/masonium is already in this thread :-) - cgmath: very much specifically designed for computer graphics and/or game development Now, as a contributor to rulinalg, I would love to recommend you to use rulinalg, but if you are looking for something that "just works" for machine learning purposes, I can't do so for the following reason: rulinalg's SVD - which is a fundamental algorithm for many machine learning problems - is fairly broken at the moment. Fixing this is at the very top of our TODO list, and hopefully should be resolved in the near future. Since linxal uses LAPACK as its backend, it is probably a better choice at the moment. rulinalg is in active development (new contributors of any capacity are very welcome!), and there are a number of features currently not in any release. We're in the process of completely rewriting our decompositions (see [decomposition](https://docs.rs/rulinalg/0.4.2/rulinalg/matrix/decomposition/index.html)). In the current release, only partial pivoting LU has been redesigned, but in the master branch and in pull requests pending review there are also: - an implementation of LU with complete pivoting (supporting rank estimation) - a redesigned Cholesky decomposition - a redesigned QR decomposition Up next will be rewrites of our eigenvalue algorithms and SVD, which should fix our current issues. While numpy is standard in the Python ecosystem, I'd be careful to consider it the holy grail of linear algebra library design - in my opinion, it is also fraught with design issues (which I don't want to get into at the moment). In Python, it is necessary to use N-dimensional arrays for speed, but if you are only interested in linear algebra, this design comes at the expense of significant added complexity (having to deal with N-dimensional arrays instead of just matrices and vectors) and often substantial increases in memory usage. I specifically started contributing to rulinalg because its vision best matches my own: it provides matrices and vectors, and it closely matches the corresponding mathematical concepts. Moreover, this is *sufficient*: you can express (afaik?) any linear algebra algorithm efficiently this way (though you'd probably have to view a vector as a column in a matrix to realize BLAS-3 potential, which rulinalg currently doesn't do). Any added array dimension beyond 2 is added complexity without significant benefits in this domain. This assumes you're not specifically working with tensors though. Again, I want to reiterate that I belive ndarray to be a *fantastic* library. If you need N-dimensional arrays, it is the obvious choice. That said, it is in my humble opinion the wrong abstraction for linear algebra.
She's having trouble with Ruby's concurrency primitives but 'knows' Rust? God, why are comics so unrealistic? /s It's neat to see Rust in a comic book. Not a place I would expect it to be mentioned.
I don't know much about **rr**, but as long as it can attach to the Kafka topic and consume from it, there would be benefits from it.
Hey, thanks for the reply! Some of that optimisation code (the pyramid) is very ugly, so thanks for the info on the "if let" feature. I've just spent a bit of time going over and changing the code to use this, the pyramid is still ugly but it's much better now. Usually I would negate the if statements and early out to prevent all the nesting but I'm not too sure how that could work with the pattern matching / if let syntax. I've also taken on your suggestion of importing the enum variants for the lexer and vm and that looks a lot nicer too now. As for the spam filter I knew that would happen, but I wanted to post this on a new account as I didn't want any of my other accounts linked to my GitHub. Again, thanks for taking the time to help :) 
It's *just not worth it* to keep `Monad` as a formalism instead of more powerful generators/async functions. You lose some of the rigor but win in ergonomics IMO.
Funnily enough some languages (Java and Python) take the other tack, threads will keep a program alive unless they're specifically marked not to ("daemon" threads). You can still join to get a thread's status or ensure they're done, but unless you force a hard exit by default threads will sustain the program.
Monads are necessary in Haskell because sometimes one needs to program imperatively. In Rust, they seem like a cargo cult.
No, I'm sorry, this doesn't work. It's gotta be either `rtfmt` or `runtime-format`! ;)
https://github.com/mneumann/matplotlib-rs https://github.com/ubnt-intrepid/rustplotlib
+1 As a casual observer, I had to google it to get context.
I have been intending to ask the same question to the rayon developers, but I have not gotten around to it &gt;&lt; thanks for bringing this up. I did an experiment with something similar (but probably with waay more overhead than rayon): https://github.com/anderejd/sgiter/blob/master/src/lib.rs usage example/experiment here: https://github.com/anderejd/treesum/blob/master/src/main.rs 
my main concern and confusion with that comic. how did she know "I can't get the threads to finish" was to do with programming/hacking or even involved ruby. its oddly jumped towards the next page is even more odd. os.chdir("user\esme\house") omg it gets even worse batgirl is a jerk ruining people's uber rating.
rust-learning is already mentionned in the official rust website. https://www.rust-lang.org/en-US/documentation.html
I can totally see what you mean. It really depends on what you're doing.
I've never seen the compiler do what you describe, the code you've provided doesn't build in isolation, and I can't see any reason for it to do that, so... \**shrug*\*. If you're going to ask about why code does/doesn't work, you need to either provide code that other people can compile to see for themselves (preferably on one of the playpens), or include the full error messages. Otherwise, you'll just have to hope someone has run into this exact problem before and knows what the answer is.
My first thought is that [next](https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next) takes a mutable borrow of `self` (`&amp;mut self`). Have you considered using `while let Some(current_str) = word_or_punctuation.next()`?
In theory, you can have your statically checked format and the ability to compose them too. That's how format works in OCaml. I [explained the general technique](http://drup.github.io/2016/08/02/difflists/), but you can find an older non-gadt explanation in [this paper](http://homepages.inf.ed.ac.uk/slindley/papers/many-holes.pdf). You then (ab)use macros. Would be amusing to see how you can fit that in Rust's type system. :)
This seems to at the very least compile: fn foo&lt;'a,'b&gt;(a: Vec&lt;&amp;'a i64&gt;, b: Vec&lt;&amp;'b i64&gt;) -&gt; Vec&lt;&amp;'a i64&gt; where 'b: 'a { let mut temp_a = a; let mut temp_b = b; temp_a.append(&amp;mut temp_b); temp_a } I'm not really that familiar with Rust's lifetime system though, paging the propaganda minister for comment: /u/steveklabnik1 
If we take ndarray's two dimensional type Array2 with elements of A, it has these fields: `Vec&lt;A&gt;, *mut A, usize, usize, isize, isize`. In that sense I don't see how it is using much more memory than it should. The `Vec&lt;A&gt;` storage can be compressed to just a `capacity` field maybe in the long run. (The pointer doesn't have to point to the first element in the vec and it is there for full generality).
It depends a bit on your usecase, but if you're ok with pulling in a dependency on the [cairo-rs crate from gtk-rs](https://crates.io/crates/cairo-rs), it should be possible to create an [ImageSurface](http://gtk-rs.org/docs/cairo/struct.ImageSurface.html). There is a [png feature](https://github.com/gtk-rs/cairo/blob/master/src/image_surface_png.rs) which however does not seem to be visible in the generated API documentation. A few years ago, I wrote a chart generation library in gtk#, and enjoyed using the cairo API quite a lot, it is very robust. Edit: I just created a [quick-and-dirty demo project](https://gitlab.com/silwol/cairopngdemo/tree/master) showing the generation of a PNG file using cairo.
Sorry, I was not so clear about what I meant here. I didn't mean it as a criticism of ndarray. Using ndarray does not use any appreciatively more memory. What I meant was that in Python, one must often solve problems which could have been efficiently solved with simple loops in a faster language by shoveling data into additional multi-dimensional numpy arrays in order to get any kind of decent performance. I remember one case when using numpy where looping was too slow, so I packed my computation it into a 3-dimensional array and used numpy constructs to evaluate it, after which the computation was fast. But then I ran out of memory for the larger problems because I was suddenly storing tons of intermediate data just to accelerate the computation. I also couldn't easily use numba to accelerate the loop-based solution, because I was dealing with user-supplied functions. In Rust, you wouldn't have this particular problem, because the simpler loop-based solution would be fast enough in the first place.
Perfect! At that rate, Rust will be an even bigger success than Windows Vista
This is a good point. Even though I sometimes feel like the situation is similar to numpy in Python; one wants to use higher level operations in ndarray because in manually indexed loops the bounds checks will rule out loop optimizations that are important for numerics (unrolling and vectorization). One can of course use unchecked indexing easily in Rust, as one way of circumventing it.
I really like the direction. Am I correct in assuming that it in the end it will be possible to create first class gobject implementations, including gtk widgets with the support of the macro?
The next page is worse &gt;Wheh. She's gonna be the next steve jobs.
I'm a full stack developer in the financial tech industry. When I'm doing front end it's Angular 1.x and then for the backend I get to use Haskell which was a lucky break. I'm also finishing up my CS degree this semester finally. Otherwise I mostly code in Rust in my spare time!
We're mostly doing imputations, weighting, calibrations, plausibility checks, this sort of thing. And we're a frequentist shop 😎 (though I am somewhat a secret Bayesian, too. But don't tell anyone).
I have to say that I think the way ndarray enables these kind of efficient computations is very cool. When dealing strictly with linear algebra, it is usually the case that the computational bottlenecks will reside in some kind of matrix operation, i.e. solving a linear system or computing the SVD, and one can easily tolerate some lesser degree of optimality in the other parts of the code, because they don't really contribute much to the total runtime in any case. And if they do, one can profile and rewrite only the necessary parts. After having worked with numpy for some time, I'm a little wary of anything beyond 2D arrays unless absolutely necessary, because trying to understand this kind of code written by someone else requires some serious mental gymnastics (as compared to a series of ordinary matrix-matrix or matrix-vector operations).
Do we need a bot for this? 
Which is *really annoying* for any non-trivial threaded program, because your program may not exit even after you explicitly call `System.exit` and *none of your code is actually running* if some dependency was careless or buggy and left a thread alive somewhere.
Actually, now that it's built into Visual Studio Code (https://code.visualstudio.com/), there's a Windows (and most other platforms) GUI for it. :)
Oh haha right! Good point! \^_\^
QOTW right here ⬆️
You can always try using [num](https://github.com/rust-num/num) and use Bigint directly.
Thanks. This is a exactly the answer I was looking for!
Nice, thanks for pointing me to it! I'm thinking about building an web application with Rust + WASM + IPFS for my masters thesis ... as WASM is researchy, this would fit the needs I guess...
No, System.exit kills the program regardless of how many threads are running. I know this because i routinely use dependencies which are careless or buggy and leave threads alive somewhere, and that's what i have to do get the dashed thing to stop!
Woop! I love this library, I wanted to help with the release but I'm still a beginner Rust developer so I've picked up the odd documentation or easy issue when it pops up. I'm excited to see this moving along
For those who like me were wondering what this is: https://github.com/nikomatsakis/rayon &gt; Rayon: A data parallelism library for Rust &gt; Rayon is a data-parallelism library for Rust. It is extremely lightweight and makes it easy to convert a sequential computation into a parallel one. It also guarantees data-race freedom. (You may also enjoy [this blog post](http://smallcultfollowing.com/babysteps/blog/2015/12/18/rayon-data-parallelism-in-rust/) about Rayon, which gives more background and details about how it works, or [this video](https://www.youtube.com/watch?v=gof_OEv71Aw), from the Rust Belt Rust conference.) Rayon is [available on crates.io](https://crates.io/crates/rayon), and [API Documentation is available on docs.rs](https://docs.rs/rayon/0.7.0/rayon/). 
You know, now that I think about it, Vec might not follow the rules of the logical system in the same way that other things might. It's not implemented in terms of sums and products -- it almost certainly is implemented in terms of unsafe code, in which case... our pondering the lifetime semantics of it is sort of silly, lol. I tried giving this to Rust, but it doesn't even seem to accept the `x : &amp;'a t`: enum S &lt;'a, t&gt; { empty, cons{ x : &amp;'a t , xs : Box&lt;S&lt;'a,t&gt;&gt; }, } 
Summoning /u/nasa42
In my experience, the hardest part of rewriting C projects is the low level interfaces to the OS and other C libraries, because the Rust equivalents use high level interfaces that don't match up.
just curious, Question to everyone here, does panic in one thread takes all Rust threads down with it or just that thread ? 
Panics propagate to the thread boundary by default, so joining the thread will return an Err(e) on panic. Double panics, or if the abort on panic flag is set, will get around this.
Maybe I'm misunderstanding something, so if I am correct me, because I share your confusion. Having a native Rust BLAS implementation seems important to me in a linear algebra framework for various reasons. Not saying it's easy, but it's a thing that could be done / should be done. ndarray seems like a great general array library, but as far as I can tell, it just plugs in to a foreign BLAS library for that stuff. linxal seems similar in this regard. rulinalg seems to be focusing on native implementation of BLAS-type stuff, so it seems to be doing something a little different from what ndarray and linxal is doing. I suppose you could argue that a native BLAS library would kind of be the missing link between the two. 
&gt; IPFS Interesting, I hadn't heard about it. I guess I have some reading to do this weekend :)
I wrote a longer reply and Reddit ate it. ☹️ Short version: yes, Corrode handles arbitrary C FFI!
Contributors volunteer skilled labor that can help a project be even better. The worst thing a maintainer can do is dissuade them from helping. A good rule of thumb is to assume positive intent from contributors. People who are requesting changes are trying to solve problems; rarely are they doing it for personal aggrandizement or to fulfill some philosophical mission. One thing that really upsets me when I propose changes -- especially when they're accompanied by code -- is getting a thumbs-down from (or, even worse, an issue closed by) a maintainer, without any constructive feedback as to how to resolve their concerns. I can work with someone who can inform me about their concerns or the weaknesses of my proposal, and who says, "yes, but...," but I can't work with someone who just says "no." In my own projects, I have a rule of thumb: I never close an issue without the consent of the submitter. I try to ensure I've either convinced them that there's a better way to do what they're trying to achieve; I've resolved their problem as best I can; or I simply don't have the resources to give them a proper resolution.
No offence or anything, but do you even read the error messages? This compiles: enum S&lt;'a, A: 'a&gt; { Empty, Cons(&amp;'a A, Box&lt;S&lt;'a,A&gt;&gt;) } 
&gt; \ What *is* this nonesense?! Batgirl used `/` so she's obviously on a \*nix system. ;)
It could also be useful for bindings to other languages as well.
Awesome reply, thank you so much for laying that all out! I by no means think that numpy is any kind of "holy grail" of design. Rather, I think it would be great if we could have a similar kind of *standardization*. I think one thing that is missing from your explanation, and something that I really want to know, is why rulinalg can't use ndarray as it's primary data type and for all of the "simple" operations (dot product, etc). Couldn't `Matrix` be replaced with `ndarray::Array2`? If there are deficiencies in ndarray, I wonder if they could be fixed with a pull request? I'm not saying doing this would be easy -- I'm sure it would require a large refactor and would break the API of people using rulinalg (they will **at least** have to rename all instances of `Matrix` to `Array2`). Even though it is not easy, it *seems* like it would be *simple* -- largely a refactor and adding any minor features to ndarray that are needed. In addition, wouldn't it be worth it to be using a standard well-supported base? You would get BLAS support for free, along with anything else that ndarray got in the future. We could all work towards a common goal and be happier... or at least that is the dream.
So is that kid the superhero?
author of strfmt here. I never could figure out how to re-use the stdlib (although I was a complete newb at the time...). Maybe I would be better now, but I still have no idea how they are magically create the Fmt struct. Awesome to hear that you have figured out that puzzle. I would be interested in incorporating it into strfmt at some time if you were interested! IMO it's better to have one crate than two.
Just to be clear: I'd also like to see a language with polymorphic lifetimes (including lists, sets, whatever) and a compiler smart enough to handle them, but it's just that we are talking about a low level language, that primarily aims to be "C++: The good parts", and doesn't even support higher kinded polymorphism (yet?).
What do strict semantics have to do with it? Sequencing operations in a non-strict language is only the most trivial application of monads. An `Iterator` monad sounds more like a nondeterminism monad than an optional/error monad. I guess one problem with this approach would be that types could easily come to satisfy multiple monads, introducing ambiguity.
Dabbled with Python and then was a C purist for a while (I was in middle school, so you can't blame me). Later I went on to use proper C++ (how did people manage before C++11?), then realizing its failings (not very powerful, terrible verbosity, bad parallelism, and not really as safe as it could be) tried some other things like Golang, but none of them had good performance or hit all the marks. Eventually I discovered Rust, and after reading its whole book before writing any code (yeah, I scouted it out first, but I didn't remember much), I determined it was basically the ideal language for large scale projects and maintenance, while also serving the performance needs I had, immediately putting it in my "all hobby projects" slot. In university I've used QT Creator, MPLAB (T_T), and Pycharm for C++, embedded C, and Python development respectively. For Rust I've switched between so many things over and over: eclipse, intellij, atom, sublime, and VS Code. I've always been sad about the lack of proper development tools for Rust, but now that's finally changing with the introduction of RLS, which I am using even in its early stage with VS Code, and it's proving to be incredibly useful. Rust also can't parameterize types over integers like C++ can and I really want type specialization =|, but I expect at least the former to come within the next year.
/u/llogiq, with the post April fools announcement now unpinned, can this one be re-pinned?
Maybe someday. The fact that it's such a good C that we even bother comparing it to Haskell is so impressive, though. And [even some of the things that the existing type system can do have really surprised me!](http://insanitybit.github.io/2016/05/30/beyond-memory-safety-with-types)
Perl was my first language but quickly went on to C++ and have been using it for maybe 20 years. I've been working for 10 years working on usermode support for my company's hardware but I tend to go all over the place, debugging down into the kernel, working on our applications, and improving our dev tools including our build system. I've generally used Python for my prototyping and tooling. Years ago, I developed GTK/Qt apps in Python for Maemo/Meego before Nokia back out of all of that. I've long been looking for the replacement for C++ but haven't been satisfied with the options until Rust. I'm even considering using it in place of Python, if nothing else, for the better packaging / distribution story that Rust has.
And yet, she knows Rust and not Swift. :)
The parallelism used by Rayon (fork/join) basically needs to know beforehand how much data there is, since the whole parallelism model is a sort of divide-and-conquer. With a lazy iterator you would be better suited spitting items into a queue which worker threads read from. It's entirely possible to do some smart scheduling of work tasks, rayon tasks, etc between the same set of threads as not to waste resources
Or maybe it was just a course taught in Ruby ;) (The positions of the character in the top bubble would prevent looking in on Esme's screen)
/u/burkadurka found it: http://www.readcomics.tv/batgirl-2016/chapter-8/10
I don't know about that. We see the batgirl from Esme's eyes and on the next picture we see that the batgirl is near Esme, with her screen right across from the batgirl. So it's obvious from the sequence that the characters were moving around. : D 
This... is a very weird piece of code: let mut current = next; match current { Some(current) =&gt; { next = word_or_punctuation.next(); } None =&gt; { break; } } let current_str = current.unwrap(); Reusing the name `current` in `Some(current)` is quite unfortunate; you could as well use `Some(_)` since you do not refer to the element. It would make things a bit tidier. Beyond this, you can simplify the code by taking advantage of: - the fact that `match` is an expression, - the fact that `break;` in a branch of `match` means that the branch "result" is a subtype of all types. This means that the following should be equivalent: let current_str = match next { Some(current) =&gt; { next = word_or_punctuation.next(); current }, None =&gt; break, // I don't think "{ break; }," is necessary, but it might... };
In Python numpy is used for compact data and custom memory layout. Any Rust schmuck can do that with a Vec and a struct, so the need for for the data structure for that is not as great.
Holy crap. I'm in love with the nalgebra documentation. 
No, I think they were using that MIT learning tool. But she was using Ruby, and apparently the author thought threads were a Ruby specific thing. Because if so, then the interaction makes sense given. Otherwise it's just an odd non-sequitur and I have no idea what is going on.
The male teacher seems immobile: he is in the same spot in the top and bottom panels. Batgirl is close to the teacher in both the top and right panel, where she talks about Ruby; she would only have a very side view of Esme's screen from there. So... given that: 1. In the same panel, the teacher comments the others are using the MIT app, 2. Batgirl cannot see the screen of Esme when she makes the remark. I'm afraid to say there's a goof up on the author's part ;)
Yes, I think that's the only possible explanation. Since the teacher has to explain what the others are using, it's clear Batgirl doesn't know it, and she cannot see the screen from her position. Well, I'll forgive the author, she cited Rust ;)
True, though the differences in code to support them all are not that wildly variant or youtube-dl wouldn't support that many sites. Some sites have predictable URLs, others require downloading a playlist and parsing that, and the worst sites require live streaming and muxing the stream with ffmpeg. The shared code is bigger than the small site-specific details.
Rayon is excellent stuff, it is rare that you get a library that makes parallelizing things safe, easy, and fast at the same time. It was the big winner in this survey of parallel-For style abstractions I did a while back: https://jackmott.github.io/programming/2016/08/30/think-before-you-parallelize.html
Jobs wasn't a totally non-technical moron or something. He just cared about other stuff a lot more.
Absolutely! That kind of thing is exactly what this is for. You'd do it something like this: rental! { mod rent_stdin_lock { use std::io; #[rental] pub struct RentStdinLock { stdin: Box&lt;io::Stdin&gt;, lock: io::StdinLock&lt;'stdin&gt;, } } } fn main() { use std::io; let stdin = io::stdin(); let rent_lock = rent_stdin_lock::RentStdinLock::new(Box::new(stdin), |stdin| stdin.lock()); } 
I just don't think he would do much with code, that's all. I don't see a correlation between knowing a programming language at a young age and being "the next Steve Jobs", as Jobs was a businessman, not an engineer.
Done. Thank you for bringing it to my attention.
I have a larger, serious application going on over here: https://cryze.github.io/LiveSplitOne/#/splits-io/194r (right click for context menu). The whole logic is entirely written in Rust (with some minor TypeScript bindings and React as front end). However this is still asm.js, as Rust wasn't able to compile larger WebAssembly code for a long time, we just fixed that a few weeks ago. WebAssembly still has one major issue compared to asm.js, you need to use the Promise API to load it. So there's no way to synchronously load or webpack it. So I kind of need to rewrite it to use WebAssembly at some point, but for now the only difference would be loading times and a minor performance improvement anyway.
Holy hell I have a friend now! When do I move in ;)
I'm trying to test whether a polygon is completely inside another (where both polygons are concave), is there a library to help me with that? I tried ncollide but couldnt get their examples to compile.
I get this. I recently rewrote a bit of C++ code to use an ADT instead of an enum and, including a reference in one of the variants. Blew up in my face, lost a full day debugging a condition that was sometimes flipped because of random memory...yay
Bitcoin's commodity is processing power, wouldn't you say?
There are also sites it [declines to support](https://github.com/rg3/youtube-dl#can-you-add-support-for-this-anime-video-site-or-site-which-shows-current-movies-for-free): &gt; As a matter of policy (as well as legality), youtube-dl does not include support for services that specialize in infringing copyright. I don't know any specific examples, though.
It just seems like a really odd, improper parallel to make. It's like saying that someone who is good at painting will lead a huge game studio. That may be, but it does the result does not follow from the premise because it's talking about two completely different things. How does someone being a good programmer say *anything* about their skills in business? Jobs wasn't a programmer, but the programmer in the comic is being compared to him implying that skill in programming somehow translates to business.
No. Haskell has many monad instances besides those for `IO` and `State`. For example, `Maybe`, `Either`, `[]`, continuations, probabilistic programming, etc. None of those have anything to do with imperative programming.
The way to read it in which it is intended is that the person being remarked upon will go on to create amazing technology.
It is incorrect t hat only IO and State monad have to do with imperative programming.
I agree - that has to be one of the most beautiful doc sites I've seen. Awesome API as well
Both ndarray and rulinalg already store the elements of their arrays/matrices in a single long contiguous vector. This means that you can already convert an ndarray `Array2` into a rulinalg matrix essentially for free** - basically you need to turn the ndarray type into a vector where elements are stored in row-major order (rulinalg currently only uses row-major matrices) and pass it to `Matrix::new(n_rows, n_cols, data)`. You can write a general conversion function in just a few lines of code. This is part of what I had in mind when I mentioned the `ndarray` feature suggestion in my previous reply. Hence, basic inter-op is already possible - there's just not any facilities in place out of the box. I think that in time, when libraries stabilize and we learn more about what works and what doesn't, we might see more of a unification effort. I think for now, the authors of the individual libraries are concerned with the development of their own experimental library - let alone integration with others! ** Assuming that the `Array2` is stored in row-major memory order (I think this is the "C" ordering in `ndarray`?).
**send_requst()** Is it really worth the saving of one letter? Why not connctor, clint, and respons then. \**shudder*\*
I'm just talking out of my butt, but I feel like aside from interfacing with DOM apis, webasm will be essentially starting over. We can use Rust and other native level tools, compile them for webasm, but we probably won't interface with jquery or react. Unless bridges are made to work with them. Simply due to the dynamic nature of the libraries. Really I think you would lose the benefit of compiling to webasm if that's what you want to use. If you do, just use javascript.
(See rule 3)
Boring ol' java
Why is Rust using Serbian domains anyway? It's cute to have .rs but really not in the spirit of the thing. Shouldn't content in .rs have some relationship to Serbia? Other than the obvious desire for the Serbian programming community to have best in class languages of course.
I *imagine* it was a find &amp; replace all + typo.
This is awesome! I opened an issue with [are we learning yet?](https://github.com/anowell/are-we-learning-yet/issues/13). I wonder if all the array libraries could just implement [TryFrom](https://doc.rust-lang.org/std/convert/trait.TryFrom.html) (or something) for some standard generalized data type that everyone could convert to/into. Maybe everyone can be able to convert to/into `Vec&lt;T&gt;`? You have to loose/create the dimension/len information on each conversion but that is a trivial amount of calculations in the scheme of things. Or maybe instead of `Vec` it would be worth it to make a library that has an extremely simple `Array` type containing just the data and dimensions and a trait to implement for conversions. I think it is critical that people understand that these libraries CAN have interop and I think it is critical that all the major libraries document that they DO (.. once they actually do that is). Do you think this would be feasible? Very exciting!
We can only hope.
Bitcoin and other Proof-of-Work chains force you to spend computing power and time in order for a reward proportionate to your contribution relative to the whole network (...over time, variance is high short term) You can do similar things with Proof-of-Stake, where you put down a security bond (sacrificing liquidity for some time) Filecoin could do something with proving storage space is utilized over time, but this is actually quite hard to do if you're trying to store people's files instead of specially crafted data. The state of the art here is [Proofs-of-Spacetime](https://eprint.iacr.org/2016/035.pdf) The general approach with things like Filecoin or similar tokens like Swarm and Storj is to prove you can respond to challenges of whether you actually store the thing, and you have to post a security bond which is burned if you fail to respond correctly. I think this would be easier to do as a token on Ethereum rather than as its own blockchain.
Your docs are awesome. Regarding alga, I'd like to inject my pragmatism. In my non-abstract world of traits, one of the traits a linear algebra scalar should implement is Debug (and why not Display, LowerExp). We need to println debug and besides that, print and format numbers. That's intended to give a taste of what I think is a touch of pragmatism.
There are more libraries. Here are a few that deserve mention - https://crates.io/crates/numeric - https://crates.io/crates/parenchyma - https://crates.io/crates/sprs
I included them, thanks! 
I mean only that that the type-sized API "looks awesome". I am just getting into this but am disheartened that all these great libraries are incompatible and we are forced to duplicate effort/make hard decisions when it would be much easier if we could all get along. As somone who is developing a [design doc tracking tool](https://github.com/vitiral/artifact) I don't like seeing so many designs lying around disjointed. I want to unify, link and discuss! Would love to see variadic generics and integer generic parameters! You have my support :)
Not sure about the compiler issue, but why not write that loop as &gt; for current_str in word_or_punctuation ? Am I missing something? It would probably resolve your mut issues too; only the iterator need be mut in that case.
The rest of the slide reads: Rust: Distributed file system Development efficiency + No GC (for the purpose of bandwidth stabilization) To be blunt, we wanted to try using it 
Thanks for this report. rustup 1.1 was [released](https://users.rust-lang.org/t/announcing-rustup-1-1-0/10242) a couple of days ago. You can [download](https://static.rust-lang.org/rustup/dist/aarch64-linux-android/rustup-init) aarch64 for android and run it. It should work, but fail to download because there is no rustc android release yet. I made a [PR](https://github.com/rust-lang/rust/pull/41149) to rust to add android builders, let see how it goes. &gt; Rustup didn't understand my armv8l as aarch64 https://github.com/rust-lang-nursery/rustup.rs/pull/1029
***Memory Safety*** 
The benefits of compiling to WASM are: * near native performance * shared code * faster downloads, meaning faster page loads for complex pages For example, I want to build games, which come in two main parts: use interface and computation. If we take the user interface off the table, we're left with CPU hungry tasks like: * simulations * AI * physics That's the kind of tasks I'm interested in. Specifically, I'm hoping to have my server be authoritative, but run the same code on the client as the server for latency reasons (e.g. client can guess what the state is and synchronize when it gets an update). Single threaded JavaScript is not good enough for this task, and WASM has threading pretty high on its Todo list, so it's very promising (and even today, theoretically WASM is faster then JS, so you'll win even if it's all single threaded). My short term goals are to play with scripting engines compiled to WASM (e.g. Lua and Dyon), benchmark them against native JS and benchmark WASM -&gt; JS interop to see what is feasible today. So, TL;DR - the point isn't too write your entire application in Rust, but to have more tools to make more complex applications feasible on the web.
That's what `#![feature]` is, isn't it?
Hmm, I guess it is, but I've never really noticed it.
Those are all great names for disruptive startups
There is absolutely no chance that no one of languages you have mentioned will disappear in 5 years, and they will likely remain as the necessary knowledge for given platform (unless the platform itself is fallen out of favor). Libraries and frameworks are more likely to disappear, but it is too naive that all of them will be gone in 5 years. It's important to realize what you want to do. Is your goal to make a multi-platform software? Is it *really* your ultimate goal? I guess not; you probably want to make an app that may possibly require a server. You can start small by not requiring the server, maybe it might not be possible, but in many cases you can bend your rules enough that it becomes possible. Then you can look at other options.
Neat.
Which search engine do rust-doc sites use? For example http://docs.piston.rs/
Hard to give a list covering the whole industry because we have to deal with some many problems at once. From webapis through networking to gpgpu. I found bindgen-rs, nom, gcc-rs, serde, nix, toml, hyper/iron, zmq and rayon extremely useful, but that's only covering the things I do. Libraries in the http://www.vfxplatform.com/ is a good overall guess. (plus OIIO and OSL)
`creat(2)`
Be me, learn C from school and liked it a lot. Build a couple of simple text base applications reviewer app for students and distributed it across the campus until it reach nationwide. feelsgoodman! Saw counterstrike game, tries to replicate it in C using only `putpixel(x,y)`. Learned Php to get some freelance job and how easy it was to program. Learn Java and criticize php for all its warts, work for enterprise company. Long period of using Java,GWT,Js,PostgreSQL. Learn about Rust, criticize Java for all its warts. At this point I'm still adoring rust and build a couple of projects with it. Next: Maybe learn Haskell so I can criticize Rust warts? 
Not anything significant, no.
You could use Option&lt;T&gt; and put None when you want default.
It's actually just a pile of JavaScript and a JSON index. You can find the source code in the rust-lang/rust repo.
Completely agree. Named/Keyword args would make all APIs in general more ergonomic. 
`creat(e)`
I consider it important for the left side of `let` and the function signature to be equivalent (with the exception of where the type signatures go, currently). So unless you have a way to usefully have named and default bindings for `let` statements (seems paradoxical, so I don't think you will), I am against this kind of feature.
```Option&lt;T&gt;``` is also much safer. The problem with default arguments in c++ is that they affect the abi and can cause difficult to find bugs. Changing such a value in a library is in fact a backward incompatible change that requires all clients to recompile their code.
C++ first. Taught myself Java, SQL, PHP, and JavaScript around the same time. Studied mathematics and computer science with a focus on ML and systems design. Dropped out to start my own design and development studio. Ran that for a while, but didn't enjoy having so many different projects at a time, so I decided to move on. Dove into modern app development while deciding what to do next (JS mostly with a little Scala and Go thrown in). Now I'm the lead UI (full stack) engineer for an early stage startup (JS, Node &amp; Java mostly). I'm pretty new to Rust, but it's already become my favorite language and community.
&gt; The problem with default arguments in c++ is that they affect the abi and can cause difficult to find bugs. I don't know about C++, but I don't see why adding/removing a default value for an argument should change the ABI in Rust. All the compiler has to do is insert a value at the call site, instead of the user manually inserting that value. &gt; Changing such a value in a library is in fact a backward incompatible change that requires all clients to recompile their code. That's natural. And the recompilation problem would also exist with solutions like the proposed [Default struct fields](https://github.com/rust-lang/rfcs/pull/1806) RFC.
Writing ML Enterprise Software for Retailers. I mainly use C++ (since 19 years) and the occasional Python Script. Rust has a huge appeal to me because of its modern Eco system, traits and destructive move semantics. The compiler has very good error messages. Rust, to me, seems like the daywalker of system programming languages: It has all of their strengths, but none of their weaknesses.
There has been some preliminary implementation experiments by contributors in `rulinalg`, but nothing that has made it into the library yet. In the long run, we very much wish to support sparse matrices, and I think we even have a very good plan for doing so, but we wish to provide a solid experience for dense linear algebra before we invest much more effort into the sparse side of things.
I agree, but note that it's a little bit *more* ergonomic since we have `impl From&lt;T&gt; for Option&lt;T&gt;`: fn my_fun&lt;T: Into&lt;Option&lt;u16&gt;&gt;&gt;(port: T) { let port = port.into().unwrap_or(8080); println!("{}", port); } fn main() { my_fun(21); my_fun(None); } ([Playground](https://is.gd/Yi4x4Z)) Requires a lot of generic boilerplate on the callee site, but at least the caller doesn't need to wrap all existing values into `Some(...)`. I don't say that we should be doing that... but we could :P
Duly noted (and amended) :)
For folks unfamiliar with Boost or C++, could you give a brief description of the problem that is solved by Boost.Signals2?
Same background here, but working in Haskell now. Out of topic question: how did you manage to use ChibiOS in a professional setting, did they change their licensing to be usable now ? Because when I last looked the licensing was just a hot mess (nice for university students, but incomprehensible for production).
I am responsible for evolution and maintenance of a mission control system used for several satellites, working in C++ and Haskell. I started Rust now for learning coding of audio plugins (currently contributing to the lv2_raw crate and playing around with it by first re-creating the plugins from the LV2 C SDK in Rust and then going onwards from there). Started with Basic on a Commodore VC20 then on a C64, then Basic and Assembler on Amiga and then in university learned Delphi, Modula-2, C and a little bit of Java and VHDL. In my work I added then C++, then Haskell, now Rust.
Java EE + Android dev for more that 10 years. Also studied C, C#, C++, Go. Despite of the webdev background I always wanted to try myself in writing complex games like Minecraft. I decided not to take C++ for it as it seems to me to take a couple of eternities to learn it right enough for the commercial-level development, so I picked Go first, but after a year and a half of struggling with its (un)generativity switched to Rust, which I found surprisingly user-friendly (but yet disciplining), contrary to the most of the opinions. 
The funniest thing about the Rust community overusing the word ergonomic is that it isn't very... ergonomic compared to obvious alternatives. 'more ergonomic' vs 'easier' 
While I haven't used Boost.Signals2 myself, the signal-slot mechanism is often used for notification / event handling. They consist of events that can be raised (signals) and handlers that can be dynamically attached to them (slots). While this doesn't sound too fancy, there are some complications when implementing them: - The need for (thread) synchronization when handlers are attached or removed. - Whether anonymous functions can be used as handlers and how they are removed. - Whether class methods can be attached to a signal (they pose some problems in C++) and how to do type erasure for them. - Some applications are prone to memory leaks where an event keeps the handler (and the object it comes from) alive, so sometimes weak references are used. - Some applications prefer to (optionally) have the events dispatched to another thread, which poses some problems with the memory management of the handler arguments (making copies or passing references, perfectly forwarding rvalue references -- a C++ concept that allows objects to be moved). - Some people want to use handlers that take fewer parameters than the event uses. - Whether objects with handlers automatically unregister themselves from the event when they are destroyed. - Being able to temporarily inhibit an event from being fired, either to batch updates or to prevent recursion. I'm less used to this style of programming, so there might be more issues that I might have missed.
Assume you have two or more independent components which can be glued together by push-based streams of events, and where each stream can have multiple consumers (every event is duplicated for every consumer during the push operation). Probably the most common case is UI widgets; you have a widget exposing a number of user actions as events (click, drag, text input, etc), a state machine representing some application logic, and the events/signals/slots are used to connect these two independent components. The signal library in Boost (and also for example in Qt) manages the object references automatically based on object construction/destruction so that you don't leave dangling listener pointers in the event source's push list (both ends are aware of all connections, and upon destruction can go and clean up after themselves).
This succinctly explains where my specific error was. Thank you. My own meditation explains the why of what the compiler is trying to tell me.
Sure, i've edited the text.
Not everyone can be Rust.
Default values change the ABI because they are encoded as part of the function signature. Let's consider two crates: crate A has an API with a default value, and crate B uses said API. The problem is that if the author of crate A changes said API's default value it would require the recompilation of crate B as well as A. This is a major usability and ergonomics disaster if crate A is consumed as a shared library which while isn't the default yet in Rust is certainly possible. It is a major hazard, so mach so that some languages opted to not have this feature (Java).
&gt; The problem is that if the author of crate A changes said API's default value it would require the recompilation of crate B as well as A. This is a major usability and ergonomics disaster if crate A is consumed as a shared library which while isn't the default yet in Rust is certainly possible. Wouldn't the worst thing that could happen be that the old value would be used instead of the new one? Nothing would change in the shared library upon changing the default value. All the function body sees is that the argument is of type `T`. No assumptions are made about the value. The only thing that would change is the crate metadata that provides the information on what value to put in the missing argument slot at the call site, at compile time. And obviously using a new shared library version without recompiling is a user error. There are tons of other hazards with using shared libraries that Rust cannot statically prevent. It is up to the user to correctly synchronize the shared library with the consumer of that shared library.
I second Cairo as being pretty useful. 
It's pretty complex but they've gotten the "small batch commercial" license more or less worked out and ditched the GPL exception. Plus a lot of the cool parts (the HAL mostly) are Apache 2.0. Took a bit of discussion but fortunately I'm in a position where technical arguments carry a lot of weight.
 while let Some(current_str) = word_or_punctuation.next() { match current_str { ... } } Unfortuantely [the syntax index](https://doc.rust-lang.org/stable/book/syntax-index.html) and the [`while`](https://doc.rust-lang.org/stable/book/loops.html#while) book entry don't mention [`while let`](https://doc.rust-lang.org/book/if-let.html#while-let). I don't know where the "terminal-based calculator" comment came from... I didn't mention that anywhere.
You don't seem to be using threads, so you can store state in an `Rc&lt;RefCell&lt;_&gt;&gt;` and access it from as many different futures as you like. If you only need access the state from a single future [combinator], you don't even need to do that; just store it in the future directly, e.g. as a mutable element of a closure environment.
Oh duh. I completely forgot that this is running in the context of a single thread. I guess in my head I was conflating "concurrent" with "parallel" and thought that the futures could somehow mutate the state at the same time. I'm gonna give /u/rootnod3's method a try as well to see which I like better. Thanks!
it looks like sprs is for sparse matrixes. I'll add a better description.
Maybe you should look into [FRP libraries](https://crates.io/search?q=frp), imho it's the best way to deal with gui events.
The code that I quoted is from my learning project, a terminal-based calculator. When done, it'll have three parts: A parser that translates infix to prefix notation (complete), a parser that translates prefix to infix (this part), and finally a parser that solves the prefix notation (will do next). Chain these three parts together and you get a calculator. `while let` makes sense grammatically. I'll experiment with it.
Stupid question: is there any reason you do not call `account.to_string()` instead?
If the language goes down this road, I think it would be nice to add polymorphism over these anonymous structs. Usually known as row-polymorphism. That allows you to state things like, A function expects a parameter with at least these fields. If the value has other fields that's okay too because the function doesn't look at them.
Have you taken a look at [chan](https://github.com/BurntSushi/chan)? If you need something a bit more of an observable pattern, see [this StackOverflow answer](http://stackoverflow.com/questions/37572734/how-can-i-implement-the-observer-pattern-in-rust).
Structural typing, I think is what you're describing. I don't agree, I think structural typing is nice for prototyping and writing code fast, but Rust is heavy on safety guarantees and with structural typing your safety guarantees rely on keeping field names different across the codebase (although admittedly, since the fields have to have certain types, the likelihood of a clash is decreased, but non-zero).
Nope. This is just me messing with Serde for the first time, so things are more in the style of the docs than anything.
Changing defaults doesn't change the ABI. It's the same as changing the body of an inlineable function: callers may use either the old or new implementation (possibly a mix if it's made up of dynamic modules that were compiled against different versions). Generally this doesn't matter because the Rust community doesn't *do* dylibs, and therefore all code is rebuilt to use the latest version.
You're correct in that it's strictly type- and memory-safe, but it allows for nonsensical code. PHP is type- and memory-safe, but it allows nonsensical things like adding a number to a non-numeric string. This is on the same wavelength as that. Obviously it's nowhere near as bad as PHP, but I hope you see my point.
Can you please provide an example of what people might do if rust had row polymorphism that would be nonsensical?
Right, I saw this in your post but it doesn't match the code, unless I'm being really thick today. As written, the code does not do any lookahead and can be implemented with a for loop. The `while let Some(current_str) = iter.next()` version mentioned elsewhere was my first thought, and it should allow you to do lookahead by permitting access to the iterator in the meantime. But you'll need to make the iterator `Peekable`. That's the cleanest way to achieve what you want.
Thanks for the example that helps. I guess the burden would be on the author of `add` to only define it at specific types instead of a row polymorphic struct.
Why have a feature if your recommendation is not to use it? It's useful in _very_ rare cases, and when it is you can just have a `ToSomeStruct` trait that anyone can implement without having to worry about the names of their fields, and then take a `&lt;T: ToSomeStruct&gt;`.
I just wrote a prototype for an alternative build system for Rust, using Cargo for constraint resolution, and [Nix](https://nixos.org) for the actual build. This allows to share build products between different crates, and even between different computers. Using only cargo, this requires very specific conditions on versions of everything, which Nix takes care of automatically. Nix also offers a CI service, also serving as a global binary cache, called the Hydra. In the future, this might be a way to distribute precompiled binary crates, and save time and computing power when compiling a new crate. Currently, this is tested only on linux/x86-64/gnu, and only on the crates I use to build nest.pijul.com. That project is itself deployed using nixops, which (before this project) needed to recompile all its dependencies for every deployment. Using this new tool, only the final product needs to be recompiled instead of 120 crates, on each new iteration, which reduces the build times by a large amount. 
I wasn't able to build it on a Mac due to an OpenSSL problem. running: "cc" "-O3" "-ffunction-sections" "-fdata-sections" "-fPIC" "-m64" "-I" "/usr/local/Cellar/openssl/1.0.2d_1/include/" "-o" "/Users/greg/src/dobro/target/release/build/openssl-1d3ea894fa03cc5a/out/src/c_helpers.o" "-c" "src/c_helpers.c" cargo:warning=src/c_helpers.c:1:10: fatal error: 'openssl/ssl.h' file not found cargo:warning=#include &lt;openssl/ssl.h&gt; cargo:warning= ^ cargo:warning=1 error generated. ExitStatus(ExitStatus(256)) 
Heh, I had that same idea (using specialization to optionally dispatch the fmt traits) a week [ago](https://gist.github.com/Kimundi/baaeb749c8f5b5b2d255389bf9630bdd), but was to lazy too make a whole library out of it. Nice to see it done properly!
It's there. Here's the full file: [package] name = "app" version = "0.1.0" authors = ["badtuple &lt;no.scraping@fake.faker&gt;"] [dependencies] tokio-minihttp = { git = "https://github.com/tokio-rs/tokio-minihttp" } tokio-core = "0.1.0" tokio-io = "0.1" tokio-proto = "0.1" tokio-service = "0.1" futures = "0.1.13" rustc-serialize = "0.3" num_cpus = "1.0" env_logger = { version = "0.3.4", default-features = false } serde = "0.9" serde_json = "0.8" serde_derive = "0.9"
If you're serious about stability the correct response is "oh dang I screwed up this API, guess I need to make a new one and deprecate this one". Even Swift, which is *incredibly* aggressive about letting developers make changes to their API, says defaults are a part of your public API and you have to live with every value you've ever picked. But again this is irrelevant to Rust: dylibs are nearly useless in the Rust community because there's no stable Rust ABI, and there never will be based on the current design of the language. Without dylibs everyone can agree on the latest value (but you're still messing up your users if you do change it).
thanks all of you for giving me an information about my question again thank you very much
sweet. that worked. 
Yeah, and it's trivial to set up a new project with `cargo init --bin`, so there's really no excuse not to. 
I think setting `debug-assertions = true` worked out for me. It didn't slow things down significantly in my case. Thank you.
It'd be cool if Cargo, rustup, and whatnot could detect the presence of Nix and use its package management. Right now we have a custom nixpkgs overlay for nightly Rust packages, but if we could just use rustup directly, that'd be awesome.
The Rust community certainly does dylibs. We never rebuild code to use the latest version because that is madness (massive breakage from people ignoring semver rules) 
Still working on [uevents](https://sstewartgallus.com/git?p=uevents-rs.git;a=summary) an event semaphore library. Theoretically my approach should allow for really good performance but actually optimizing to reach it in practise is difficult. I'm trying to catch up to [parking lot](https://github.com/Amanieu/parking_lot) in performance but in order to do so I'll probably have to sacrifice fairness and interoperability with thread priorities.
Using serde_derive doesn't help; I've updated the example to use serde_json; #[packet] #[derive(Serialize, Deserialize)] pub struct Foo { x: u8, y: u8, z: u8, #[serde(default)] #[payload] #[length_fn = "payload_length"] pad: Vec&lt;u8&gt;, } fn payload_length(f: &amp;FooPacket) -&gt; usize { 0 as usize } #[cfg(test)] mod tests { use super::*; #[test] fn foo_packet_test() { let mut packet = [0u8; 3]; { let mut f = MutableFooPacket::new(&amp;mut packet[..]).unwrap(); f.set_x(0); assert_eq!(f.get_x(), 0); f.set_y(1); assert_eq!(f.get_y(), 1); f.set_z(2); assert_eq!(f.get_z(), 2); } } #[test] fn foo_json_test() { let json = r#"{ "x": 0, "y": 1, "z": 2, "pad": [] }"#; let f: Foo = serde_json::from_str(&amp;json).unwrap(); assert_eq!(f.x, 0); assert_eq!(f.y, 1); assert_eq!(f.z, 2); let json = r#"{ "x": 0, "y": 1, "z": 2}"#; let f: Foo = serde_json::from_str(&amp;json).unwrap(); assert_eq!(f.x, 0); assert_eq!(f.y, 1); assert_eq!(f.z, 2); } } and I am still getting the same error error: failed to run custom build command for `foo v0.1.0 (file:///${HOME}foo)` process didn't exit successfully: `/${HOME}foo/target/debug/build/foo-8952b7d6ed7a3343/build-script-build` (exit code: 101) --- stderr error: unknown attribute: serde --&gt; src/packet/foo.rs.in:12:5 | 12 | pad: Vec&lt;u8&gt;, | ^^^^^^^^^^^^ I'm guessing the issue is the code generation from libpnet.
I beginning to come to the same conclusion regarding sharing the same struct between the two libraries. I haven't worked with macros before but I guess this is a good time to learn.
It depends on how you define structural types in regards to the function though. Using some madeup syntax: fn add(lhs: struct { value: usize }, rhs: struct { value: usize }) { ... } Your above would work in this case but I'm guessing an implementation of this might use the generics that Rust has and would look like this: fn add&lt;T: struct { value: usize }&gt;(lhs: T, rhs: T) { ... } And your example would not compile in the second version. (As they're different types.) This is all just theory of course. 
I guess it means "easier for the people using your library specifically" :)
there's no stable Rust ABI *yet*. dylibs are a necessity for some use cases and Rust needs to support them in order to appeal to certain markets (e.g. enterprise, closed source). It wouldn't be wise to limit ourselves by the current status quo and box ourselves into a corner. Other than that, as I said before, I do agree that defaults are part of the public API and shouldn't be changed without deprecating the old API and providing a new one instead. Unfortunately, my experience (in C++) is that such things do happen and and than it is a major footgun because looking at the code doesn't explain the values seen in the debugger and having separate header files (again, C++) is making things even worse if they got somehow out of sync with the implementation. Of course, not everything here is applicable to Rust but nonetheless it's worthwhile to understand potential pitfalls. I think it is important to realize that some features that people try to import from dynamic languages just don't fit as well in a static setting. Python doesn't need to consider interactions between separately compiled units like Rust does. 
As a fellow polyglot, I totally agree. In fact, to really learn something new, try a completely different language. Rust is sufficiently different to provide new insights into programming.
Does the Windows PE file-format support hard-coding a list of paths to check for DLLs?
Post your code? You're probably talking about the game Rust though, in which case, /r/playrust.
I agree. I find that new languages tend to make certain patterns easier and gives a chance to try out new approaches to problems.
That was it! Thank you so much! Still can't understand how that should have been possible (certain traits in certain scopes like that), but super glad to be able to move forward!
play rust
&gt; If you only need access the state from a single future [combinator], you don't even need to do that; just store it in the future directly, e.g. as a mutable element of a closure environment. Do you have some example code or small snippet showing this? In particular, I'm not sure I got the part about mixing streams and combinator and storing in the future (stream?) itself.
If that's the only sacrifice you need to make, I'll be impressed.
Sounds like a great application of this project, I had not even thought about it. We could definitely think of something like that, yes! Also, if you happen to have a Pijul installed, feel free to send patches! 
I wrote a signals/slots "library" a couple of years ago (scare quotes due to it being just for my use, so I give no consideration to what other people might want in it). It was actually very simple. I haven't used boost's version, and I'm sure its far more capable than mine, but I've been using mine in a largish GUI application with good results. I can put it up on github or something if you're interested as an example, or possibly a starting point for a more official crate.
The website is 100% Rust, the code is not public yet, although some bits are, essentially libpijul, sanakirja and thrussh. The main reason for not open sourcing my http and postgres libraries is that I don't want to compete with existing crates (hyper and postgres). The reason for not using them is they were not yet asynchronous when I started, and the nest does not use a single blocking call (yay tokio!). 
Thanks! Indeed using `$ty:ident` instead of `$ty:ty` compiles and works (and indeed it fails when I try to use `Option&lt;u32&gt;` as a type but `type OptionU32 = Option&lt;u32&gt;;` is good enough for me). I am actually using a trait (implemented for all the types I use) to (de)serialize the value itself but there are also the strings interspersed between the values that I have to match exactly (on both read and write sides) and I really wanted to write the spec exactly once. The sad/funny thing is that in C I could probably use a single sprintf/sscanf format string (the original C implementation is sprintf/sscanf based as well). I looked into implementing a custom format for serde/rustc_serialize but it doesn't seem like a good match (no obvious place to put the static strings in and generally quite overkill for my needs). Maybe I need to fork [text_io](https://github.com/oli-obk/rust-si) to make it not panic on invalid input or write something similar myself.
Why is it important? I can see a Rust implementation being very useful for its portability. There is a lot of platform specific code and expert assisted tuning in the BLAS implementations. That can't just be discarded IMO. https://github.com/bluss/matrixmultiply that ndarray uses implements one of the BLAS functions in Rust. So that's a start with one function, just a few left :D 
Yeah, it happens a lot. We delete lots of posts meant for /r/playrust, too.
Try [Rustup](https://rustup.rs/)^fearless^concurrency. Seriously though, you're looking for /r/playrust.
Is there any usable way to take an optional closure as an argument to a function? You can write fn foo&lt;F: Fn(i32)&gt;(arg: Option&lt;F&gt;){ //... } But you can't pass `None` to that in any way I can tell.
Haha, oh lord, this game, might have to play it.
You could perhaps hang out and help others? Being a mentor to others can be very rewarding, and it helps grow the community in your area.
/r/playrust
Probably because that's what earwax requires? https://github.com/danielrs/earwax
It's actually a common trap for young players. You start a thread and immediately afterwards your program ends, and you wonder why the code in your thread never executes. I can imagine learning rust, not giving much thought at multithreading, then trying your hand at threading in Ruby and being stuck for a little while. I don't think it was implied that she wouldn't have got it without the teachers help.
It's a pretty common need at least in C++ world, if you're working on any half-big project. Every now and then you run into a bug that can only be explained via seeing the instructions and registers yourself. I'd expect the same to hold true on Rust side as well. It's probably more important over on the C++ side because different compilers create different end results, and some compilers can produce buggy code sometimes. Rust on the other hand only has one compiler really, so it may not be as needed.
doesnt nix-prefetch-url --unpack do it properly?
Yeah, but to say problems such as this one written by Bruce Dawson https://randomascii.wordpress.com/2016/09/16/everything-old-is-new-again-and-a-compiler-bug/ don't happen, is a lie. That was a compiler bug exposed by a third party application touching the program's state, but it's not like Rust is magically safe from these issues either. Sometime you really need to go to the deepest end of the pool, and dive to the bottom to find out what's wrong.