It will compile if you make it Option&lt;&amp;'a Barber&lt;'a&gt;&gt; and Option&lt;&amp;'a Shop&lt;'a&gt;&gt;.
Thank you. The docs in F# warns on certain function that it will consume the whole sequence before returning. Distinct uses a hashset underneath and i guess Rust could do that as well https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/seq.fs#L1088
You may want an older edition of you want to support a rust version that does not implement the last edition.
Compare the Rust website to practically *every other programming language website*, though. Either Rust is the one and only enlightened language and everyone else is doing it wrong, or we're wrong. Guess which one is more likely.
Parallelizing rustc is still WIP, so is on-demand / query base compilation, the Cranelift backend, etc. Some people were talking about distributed compilation... All of these are step stones towards faster compile times. One could ask the question: how fast is fast enough? And one could answer it with: "As fast as C++" or "As fast as D" or "As fast as python" (or Ruby or any language with zero-second "compile" times). Personally, I don't think that compile times will ever be fast enough. The faster they get, the larger the projects that are going to get thrown at the compiler. So I picked one of the things that's being worked on right now (Cranelift integration) because I think it has the largest potential to improve **my** edit-compile-debug cycles. For other people, working on other projects, distributed compilation might have a larger impact, for those using IDEs with RLS, a query-based lazy compiler might have a larger impact, etc. 
You should make a PR to migrate it to a lock-free data structure. Or read the info text when posting to reddit and then post to /r/playrust instead.
I would 1000% prefer a homepage that drives Rust adoption on the part of decision-making managers/CTOs, over a homepage that saves me a click to a page I already ought to have bookmarked.
I'm not generally using bleeding-edge language features, so there are only a couple of missing features that have ever affected any of my projects: - Type level integers. It would be really convenient to be generic over array lengths to implement things like hash functions. - Non-x86 support for SIMD (even on nightly). In particular, `core::arch::arm` is missing a lot of intrinsics.
While thats true that doesn't *necessarily* make it harder. In fact it might make it easier, since you can see clearly how X relates to Y at Z place in your code.
We're looking for posts like this! https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html
`struct Barber&lt;'a&gt;` Says that `Barber` takes a lifetime `'a` as a type paremeter. `shop: Option&lt;&amp;'a Shop&gt;` says that `shop` is a reference with lifetime `'a` pointing at a `Shop` with no type parameters. It's the type-signature version of this broken code: fn hello(name: &amp;str) { println!("hello {}", name); } fn main() { hello(); }
Reddit fuzzes the votecount, sometimes bots can downvote stuff, sometimes people just downvote stuff for no reason. I wouldn't pay it much mind
Eh, I _love_ printlns for debugging and cringe when I have to fire up my debugger. Decent logs can pinpoint the issue without needing to wait for a breakpoint to be hit. However, many people prefer debuggers, so if supporting that eases adoption, I'm all for it.
As a (former) diehard python 2 dead ender (you can pry `print` statement from my cold dead fingers), I love that the editions work with each other. otoh, I miss "blazingly fast" in the slogan. 
Since `char`s are `Ord`ered, I think it's possible to use a `BTreeSet` rather than a `HashSet`, which should be more efficient. (Which does not really matter here, given the small input.)
&gt; Rust `std` is never going to be a batteries included standard library, but we can still give a batteries-included experience by focusing on ecosystem-excellence. The [stdx](https://github.com/brson/stdx) project was trying to put together something like that, but it stalled.
&gt;If I had to pick a single wish for the Rust 2019 Roadmap would be to polish cargo To tack on, I feel like Cargo should finally be treated as a complete build system. If not an all-purpose one, at least a utility for completely building and packaging binaries. Really we need post build scripts. I still haven't heard a convincing arguments against them. 
Is there a blanket impl that will just stick an &amp; on the front? If not, why not?
Hey, I just started learning Rust yesterday and ordered the official book from Amazon. Does this mean it's outdated now and I should return it? The online version seemed to change. 
Hashtables are generally faster for lookup then btrees. 
Great version! Lost about a hundred lines of module gunk after this in one crate. Still unsure about how to replace stuff like `#[macro_use] extern crate log` though. It was kind of nice to have `warn!, error!, info!` available globally.
Another one
While I say its possible, it's not C++, that may seem stupid and perhaps obvious but that seems to be the main reason why rust might not have a future. Currently the game development industry focuses on C++, builds all their tools in C++, more or less expects C++. It is possible rust could fill its place. But it might take a long time before that happens. 
/r/playrustinrust
/r/rustplayrust?
Perhaps an async/await based executor might help alleviate some of the friction you're experiencing. I've found that being able to borrow past yield points makes async code a lot nicer to write. https://github.com/withoutboats/romio
Awesome!!! I'm so excited for NLL. With these changes, I'm not so hesitant any more to evangelize it at work. As a small side note, u/steveklabnik1, where it says &gt; You can find the new TRPL here. the link on the word "here" points to the beta book.
That's not really the intention of `AsRef`. It's meant to describe just reference-reference conversions. Instead, the `Borrow` trait is provided which genericizes taking a reference of something.
Not at all. The book is 99% the same. The module system stuff is the only chapter that significantly changed.
&gt; and the provided infrastructure should be as fast as if you did hand-code it. This phrasing always irks me, because of how it can be misinterpreted. Like with the C++ experts' decision to use "zero-overhead abstraction" rather than "zero-cost abstraction", I much prefer the C++ ecosystem's description based around "it should perform so well that you wouldn't be able to hand-code anything faster."
Got it, thanks!
No problem, and thanks for buying a book :)
I disagree; in some situations it hides the operations under vocabulary.. the point is that's compulsory, whereas in other languages (with a different tradeoff) you can still write the raw operations. It is hard to name everything, and remember what the names mean, whereas sometime the pattern of operators is actually clearer
I have a Vector of structs and I want to iterate over them and show the struct's name field. It works, but I'm confused: for element in user_config.account.iter() { println!("The element is: {}", element.account_name); } However I initially had it like this: for element in &amp;user_config.account.iter() { println!("The element is: {}", element.account_name); } Which didn't work because: | 87 | for element in &amp;user_config.account.iter() { | -^^^^^^^^^^^^^^^^^^^^^^^^^^ | | | `&amp;std::slice::Iter&lt;'_, accounts::TestAccount&gt;` is not an iterator | help: consider removing 1 leading `&amp;`-references I don't get it. Isn't borrowing the way to go here? Can I never pass a reference if I want to iterate over something? That would be pretty odd, no? Please use ELI5 language. I'm still a noob.
The problem with a “recommended” list is that it requires the maintainers to pick “winners” and “losers”. I’m not sure that’s what they signed up for, or that it’s a good idea from a community standpoint.
Afaik you can still macro_use if you want. It’s an optional new thing, useful for crates like nom, which have ~100 macros that get into collisions pretty quickly if you’re not building a parser-only crate but integrating little mini parsers into a bigger application. 
The strategy behind the change does make some sense. I just don't like the execution.
My 2 cents. # Rust 2021: Adoption We shouldn't be asking "what does Rust need", we should be asking "what does the X industry need from Rust?" I think those of us who work in particular industries should collect our personal thoughts about why new projects aren't started and completed in Rust and start from there. Just off the top of my head I'd argue a big reason is a lack of talent, and that comes down to education. If there are ways to promote Rust over the next three years to build a critical mass of developers who are writing Rust then it will be far easier for companies both new and established to start working in the language. 
I would personally love to see a better desktop GUI story. While I haven't kept up with the current state of the libraries, my impression is that they are still immature or unidiomatic, which is usually a result of most popular GUI toolkits having an OOP design that doesn't mesh well with rusts design philosophy.
&gt; I disagree; in some situations it hides the operations under vocabulary You disagree that it doesn't necessarily make it harder, then go on to say "in some situations it's harder"? Thats the same thing! &gt; the point is that's compulsory, whereas in other languages (with a different tradeoff) you can still write the raw operations. pretty sure you can use raw pointers everywhere if you hate safety and lifetimes, or make everything reference counted, or whatever you would do in a GC language. Also pretty sure that most of the time you don't need to write lifetimes and stuff out, they're elided, so you don't have to write much anyway.(With the caveat that it depends on what kind of stuff you're trying to do)
One thing that is really common in Rust is very small functions that take more time to prepare and return from the function call than to actually do the work. On release mode the compiler can turn set up registers for the function call jump to label X label Y ... label X access the "length" member of the vec jump to label Y into access the "length" member of the vec
&gt; rust-lang.org That is one ugly website.
&gt;&gt; pretty sure you can use raw pointers everywhere if you hate safety and lifetimes, But this is 'second class', with the syntax space taken up by safety, e.g. you can't use operators for pointer arithmetic, you've got to state mutable or const explicitly, 'array indexing' is safe so you need to make a longer word for un-checked indexing, and casting is more verbose C++ starts with C's efficient syntax for unsafe code, then adds a refereces that are 'safer' that raw pointers whilst not requiring *as* much markup, and the ability to drop back to C anywhere. That's the middle ground it doesn't have (the reference, with auto borrow, without lifetimes) a raw pointer could almost be though of as a placeholderwaiting for 'HKT-based inference of smart pointers' yet to be added to the tooling (Ie static analysis..) .. but often the *context* makes what you're doing clear. Thats why I could get things done with raw pointers faster than you can look up all the safe abstractions (in C++, let alone Rust)... it's why the much derided 'C with classes' style exists. I'm not arguing *aginst* smart pointers and safety; these are good ideas - I'm just explaining what is lost along the way, and why to this day I can still get things done in C++ faster.
/r/rustjerk
Yeah so 2 billion, collision chance of 0.1%. Lets say it takes 15ms for access and overhead per file while walking through a directory: 2*10^9 * 0.015 seconds = 30000000 seconds = 347 days A hash collision is likely not your main worry in this situation.
If nothing else I think it'd be valuable to go through and do an inventory of all the RFCs that are in the limbo of having been accepted but never implemented (or partially implemented). Although it's true that RFCs don't have any mandatory expiration date, an RFC that was written in 2015 might have completely different motivations, tradeoffs, and design choices due to the other unanticipated changes that the language has seen since then. It feels like there's a sedimentary layer of uncertain RFCs that is gradually accumulating, even as other ones are successful all the way through to stabilization. Could be worth starting a tradition of doing such an inventory after every new edition ships.
&gt; `let mut seen = HashSet::new();` variable so then `.filter(|&amp;x| seen.insert(x))` I would instead do `let distinct = iter.collect::&lt;HashSet&lt;_&gt;&gt;();`
The roadmaps have always been a big joke. I've been watching Rust for years and that's obvious. Look at the 2017 roadmap. No async, RLS is barely usable and unreliable and is still heavily reliant on racer. Missing const generics story which is really important for lots of mathy type code and matrices like in C++. The basics of the language's headlining feature, borrow checking/lifetime analysis have been reworked and are getting reworked again. No specification of the language. Abysmal compile times only mildly affected by incremental compilation. I will never take a roadmap seriously again. Fortunately I don't have to because I actually like Rust as it is and am not really waiting for anything myself., but the annual roadmaps are just a big joke and they keep piling on more instead of finishing anything.
Try finishing the 2017 and 2018 roadmaps first.
A talk about maintaining the crates.io backend (witch is in rust) may be illuminating. State of the crates.io — Sean Griffin https://www.youtube.com/watch?v=QjQPNZPSlqA
I am aware there are people who disagree on this, but I think Rust is unlikely to be ever popular in the web backend market. GC is great when you can use it.
I've been a Wisconsinite all my life and have never heard of this. Maybe I'm a bad Wisconsinite...
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rustjerk] [Staying up late for RUST 2018](https://www.reddit.com/r/rustjerk/comments/a3vrdu/staying_up_late_for_rust_2018/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Hey, I didn't know `const fn` was releasing today! Neat, I've been waiting for that for a long time!
Exciting! Got my current project building successfully on 2018. The only minor issue seems to be with RLS in VSCode, which now produces this output when I open any .rs file. ```` thread 'main' panicked at 'Could not convert URI to path: ()', src\libcore\result.rs:1009:5 note: Run with `RUST_BACKTRACE=1` for a backtrace. [Info - 7:21:15 PM] Connection to server got closed. Server will restart. thread 'main' panicked at 'Could not convert URI to path: ()', src\libcore\result.rs:1009:5 note: Run with `RUST_BACKTRACE=1` for a backtrace. [Info - 7:21:16 PM] Connection to server got closed. Server will restart. thread 'main' panicked at 'Could not convert URI to path: ()', src\libcore\result.rs:1009:5 note: Run with `RUST_BACKTRACE=1` for a backtrace. [Info - 7:21:17 PM] Connection to server got closed. Server will restart. thread 'main' panicked at 'Could not convert URI to path: ()', src\libcore\result.rs:1009:5 note: Run with `RUST_BACKTRACE=1` for a backtrace. [Info - 7:21:18 PM] Connection to server got closed. Server will restart. thread 'main' panicked at 'Could not convert URI to path: ()', src\libcore\result.rs:1009:5 note: Run with `RUST_BACKTRACE=1` for a backtrace. [Error - 7:21:19 PM] Connection to server got closed. Server will not be restarted. ````
Remove `'static`.
The .iter() method sets up borrowing for you, so you don't have to worry about it. Also, you can't iterate over a reference to an iterator, it has to be the iterator itself. If you look at the iterator trait, you'll see that the main part of it is the .next() method that returns the Item type of the iterator. The .iter() method returns an iterator whose Item type is `&amp;T` of the Vec, while .into_iter() consumes `self` and returns `T` of the Vec.
Well, this solves spawning, but I have more problems with inter-component communication. For example, buffer manager sends batch to connection manager and awaits. Connection manger sends batch to socket and awaits. If ok, buffer manager sends next batch. If not, connection manager informs batch manager to hold off failed partitions (while keep sending healthy ones) and kick off recovery manager. Recovery manager is trying in a loop to discover where failed partition is being migrated and once successfully discovered, informs buffer manger that given partition is recovered and sending can resume. So quite a lot of interactions. As I wrote this, maybe the whole driver logic should be described in one big state machine with multiple async inputs? Perhaps can be useful for unit testing too. Hmm.
I've worked with akka in scala and dotnet and my impression is that it is combo of 2 orthogonal features: async communications (queue/eval loop implemented) and recovery domain model. Recovery domain is super cool but async communication in my opinion compete with async/await. To degree, akka's async is more ergonomic rust future's channel. But maybe I should give it another try and not rely on my old experiences.
Yeah, I've tried but tokio's TspStream is very convenient and I can not understand where tokio os going with new futures. Somebody on gitter said "not anytime soon", so I do not know what to expect, rust std lib to come up with async tcp connection or tokio will some day migrate to new futures...
There are two structs involved in my code. pub struct Job { name: String, time: i32, } pub struct JobGraph&lt;'a&gt; { jobs: Vec&lt;Job&gt;, dependencies: HashMap&lt;&amp;'a Job, Vec&lt;&amp;'a Job&gt;&gt; } impl JobGraph&lt;'a&gt; { pub fn add_job(&amp;mut self, job: Job) { self.jobs.push(job); } pub fn get_job(&amp;'a self, name: &amp;str) -&gt; Option&lt;&amp;'a Job&gt; { let mut job_iter = self.jobs.iter(); job_iter.find(|j| j.get_name() == name) } pub fn rem_job(&amp;'a mut self, job: &amp;'a Job) { let mut index: Option&lt;usize&gt; = Option::None; for (i, el) in self.jobs.iter().enumerate() { if el == job { index = Option::Some(i); break; } } if let Some(i) = index { self.jobs.remove(i); } } } I've written the following doc test for the rem\_job method let job_name = "MyJob"; let mut graph = job_graph![ Job::new(job_name, 1) ]; let job = graph.get_job(job_name).unwrap(); graph.rem_job(job); assert_eq!(graph.get_job(job_name), None); I'm getting the following output from cargo test error[E0502]: cannot borrow `graph` as mutable because it is also borrowed as immutable --&gt; src\lib.rs:184:9 | 183 | let job = graph.get_job(job_name).unwrap(); | ----- immutable borrow occurs here 184 | graph.rem_job(job); | ^^^^^^-------^^^^^ | | | | | immutable borrow later used by call | mutable borrow occurs here error[E0502]: cannot borrow `graph` as immutable because it is also borrowed as mutable --&gt; src\lib.rs:186:20 | 184 | graph.rem_job(job); | ----- mutable borrow occurs here 185 | 186 | assert_eq!(graph.get_job(job_name), None); | ^^^^^ | | | immutable borrow occurs here | mutable borrow later used here Should the borrows go out of scope at the end of the function calls? Why is the borrow checker treating these as simultaneous borrows? What should I change about my test case or my functions to allow for the functionality I'm seeking here? All help is appreciated. I tried to leave out extraneous code but if more details are needed please let me know. NOTE: `job_graph!` is a macro that is equivalent to `vec!` for my data type.
There's already good reason to place all macros into a module all their own: they're unfortunately only able to be used after they're declared.
 fn main() { let f = String::from("bob"); bar(&amp;f); } fn bar(foo: &amp;str) { println!("{} is the string", foo); } You also don't even need any of the use lines here. It's the prelude, it's in there automatically. Like the other guy said, read the damn book and don't reach for unsafe if you're confused. Unsafe means that it is safe, just the Safe Rust can't describe that fact. Your unsafe works because you can do what you want safely. If it wasn't, you'd get undefined behavior. If you do not understand lifetimes, you're far from using unsafe. READ THE BOOK
Of course it does. Once you’ve learned enough rust, I’d argue it’s actually less work to program in it than Go 1. (Go 2 might change that). Rust code generation works so much better than Go and elminates so much of the boilerplate you tediously write by hand in Go. 
That's fair enough; but this isnt something I'm doing in my freetime. &amp;#x200B; I'd love to read the book and intend to, but meanwhile I need to pass a string to a function that takes a string with a static lifetime. So, it looks like (without re-writing that other function) an unsafe operation is what i need to do? 
actually seems like this unsafe is quite unsafe given that transmute is described as transmute is incredibly unsafe. in [https://doc.rust-lang.org/std/mem/fn.transmute.html](https://doc.rust-lang.org/std/mem/fn.transmute.html) &amp;#x200B; I wonder if casting something without a static lifetime to something with a static lifetime like this is dangerous? 
[Here is the tracking issue](https://github.com/rust-lang/rust/issues/44580) for const generics (including type level integers) if you want to follow it.
&gt; it's a scaled down version of a real problem Ah, I misunderstood then. You asked why your posted code did not work but what you wanted to know is why some other code doesn't work... Don't get me wrong, I totally agree that oftentimes, faced with the X-Y problem one really should just present the secondary problem X instead of explaining the original problem Y, but you *do* need to indicate that you've done so =). In this case, it turns out that the problem is likely with the function signature; i.e., in the code you didn't share. It's likely that that the function needs to be rewritten not to require a 'static lifetime. If it really does require a static lifetime (which I would guess it doesn't, but without the code...), then **no, just throwing unsafe at it will not work**. It will seem to work but will not.
&gt; ture; i.e., in the code you didn't share. It's likely that that the function [signature] needs to be rewritten not to require a ' Thanks!
Maybe. My point is that it'd probably work out, but only because you can do it in safe Rust. Potentially causing undefined behavior is why one shouldn't do it though.
&gt;only because you can do it in safe Rust. Could you explain what you mean by this? 
You can try the [itertools](https://crates.io/crates/itertools) crate which has a few useful things. for (y, x) in iproduct!(1..=10, 1..=10) { println!("{}, {}", x, y); } 
This question was driving me insane! Haha! &amp;#x200B; Don't click the link if you don't want to know the answer to Quiz #5: &amp;#x200B; [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=37f4059342e16022c6d6806a403ef0ca](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=37f4059342e16022c6d6806a403ef0ca) &amp;#x200B; Is that what you mean by \_bug\_? &amp;#x200B; &amp;#x200B;
The "loops" you are talking about map nicely to individual futures, which you can compose together with futures.join() to be run on the one thread. The whole purpose of futures is to make them composable. You can do a futures.and_then() to compose them together in sequence. If you need further decoupling you can use mpsc and oneshots as a simple pub/sub style arrangement within the futures space. I.e, recovery manager could be the receiver end of an mpsc future and trigger accordingly. 
You can pass a reference to a string as a string slice in normal rust without using unsafe. Essentially: you see my code snippet? Since that works, it means you can do it in unsafe too. Theoretically, your code and mine should translate to the same assembly. All you're doing is tricking the borrow checker into thinking that your code is fine, meanwhile, it is possible to write something with the same purpose and have it still pass the borrow checker without using unsafe. What you did was with the transmute was convince the borrow checker that you knew the lifetime was right. In the most common sense way of compiling that code, it's the same as doing it properly. But, some change might make it break. This is why you have to be really careful with unsafe Rust. Rust provides stronger guarantees to LLVM (the binary generator) so using unsafe means that it's more dangerous than C, because C provides less guarantees than Rust does. Your specific code snippet upholds those guarantees (I think), but if you change it ever so slightly, it won't. Safe Rust means that the compiler ensures that you don't break those guarantees, and thus get all the stuff mentioned in the promotional material. Please read the book, and if you're curious about unsafe, the beginning rustonomicon too. Just don't use unsafe untill you've written a ton of safe Rust code. If there's any possibility of you really needing it, chances are that someone wrote a library on crates.io encapsulating that unsafe code. Stay away from unsafe for as long as possible. It's crazy easy to hit undefined behavior using it. Read the book. I promise that it's worth it. It's really good, too!
I cannot believe this is getting drowned out, with const fn and proc macros compile time checks can get so much more powerful.
These are addicting and painful at the same time... It first feels like all I learned about Rust since 2015 has been a lie, then, when I finally understand what is going on and surpass the anxiety of seeing code like in the wild, I feel like I learned something important about how the language works.
Worked, but I hope I don't have to do that again.
Agreed. I wrote a blog post in summer 2017 about the things I was waiting for. Almost none of it has shipped, more than a year later.
Perhaps you mean "future::select", because join waits for both events to complete.
I will prioritize that. Unfortunately I don't have the luxury of waiting until I've read the whole book before I start using it. 
Actually, this is a good question, I'm not sure if the 'strictly 2018 only' features are documented anywhere. The module system changes is the only one I'm overtly aware of. /u/steveklabnik1?
&gt; I wonder if casting something without a static lifetime to something with a static lifetime like this is dangerous? It's very rarely a good idea to use `mem::transmute` to change the lifetime of a reference. Lifetimes are the compiler recording how long a reference is valid for, relative to other references. The special lifetime `'static` describes a reference that is valid for the entire rest of the program, which the data inside your `String` isn't.
&gt; I didnt just make up random function signatures, it's a scaled down version of a real problem. Can you give us the signature of the function and describe what it's doing? Requiring a `'static` lifetime isn't very common.
The [edition guide](https://rust-lang-nursery.github.io/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html#enabling-the-new-edition-to-use-new-features) should help you here. If you don't have an `edition` line in your `Cargo.toml`, then your rust code will compile as rust 2015. Some features that do not introduce breaking changes will work, regardless of your edition.
I think a "Why should your company choose Rust?" button or something, prominently displayed, would be a much better fit for this kind of marketing. The main page should, IMO, primarily appeal to developers/technical people.
Since no one (as of starting to write this) has actually answered your question... Look, `&amp;'static` means "this reference will remain valid forever." Can you really promise that with your example? As written, `f` has an expiration date that is far shorter than forever. How could Rust let you break your promise by calling that function? It would be wrong. With strings, there are two main ways you can have them be static: string literals like "Hello, World" are stored in the executable itself, so they obviously live forever. The other option is to leak the value. Rust is ownership based: there can't be more than one owner for a block of memory. The owner is responsible for deallocating that memory. Right now, in your code, that string will be deallocated at the end of main because f goes out of scope, which is not forever, so it's illegal to hand a forever reference to that function. If you leak the value, then there is no owner, so it will never get deallocated until the OS obliterates the entire process. A Box is a heap allocation in Rust. That's step one. `let heap_f = Box::new(f)` will move f to the heap. Then we need to leak that. `heap_f` has a type of `Box&lt;String&gt;`. If we say `let f_ref = Box::leak(heap_f)`, we will get a variable of type `&amp;'static String` because there is no owner... and it’ll never be explicitly deallocated. Obviously the variables can be named whatever. If you then call `bar(&amp;f)`, things will work just fine. Obviously, if you do this repeatedly, your program will consume more and more memory until your computer or program crashes. Don't do this. This requires zero unsafe, but it doesn't mean you're asking the right questions. The XY problem is super real.
`job` is a reference bound by a lifetime `'a`, which is the same as the `graph` borrow passed to `get_job`. Therefore, that borrow has to live as long as `job` does. There's not really a way of returning references from something that are detached from that thing unless you copy them - a problem that would occur if you could do such a thing is if you did something like this: ``` let job = graph.get_job(job_name).unwrap(); // job is a reference to data in graph graph.rem_job(job); // job is deleted from graph println!("{}", job.name); // uh oh; job should be deleted but we can still access it ``` One solution would be to, instead of passing Job refs, pass keys that map to jobs. Here you could use indices into the job vector. You could also return a `JobEntry` type from `get_job`, but you'd have to work out the specifics and it might get a little hairy re: lifetimes.
The keyword changes (and features that will follow them) are 2018 only at least
Try your best :) You definitely don't need to read the whole thing to get started. Compared to other stuff about learning programming, it's very easy to read without actually programming at the same time. The goal isn't to memorize the whole thing, but rather get a **general idea of what Rust offers**, so you don't make a colossal mistake like you did here. You need to get the general idea, so you can jump into doing what all programmers do in other languages: try what they think would work, and fix it until it does. Since Rust has a higher entry level difficulty, you need that background so you can learn on your own. Everything else is details and experience. You can probably knock out the most important parts on the toilet or something. Don't take notes, **just get the general idea**. No memorization. You want to know what you might need to reach for when you're actually programming. The book is pretty short tbh. You could probably knock it out in a few hours. I know I've done most of my reading of it by randomly browsing articles about Rust, getting linked to it, and devouring parts of it (or the old version of it). This isn't as difficult as getting started with Haskell. All you should do first is **skim the ownership, borrowing, and lifetimes chapters**. That's where you fucked up here. You didn't read the sensical thing first, so you reached for the difficult tools instead. You need to know what you don't know. Then you can slowly read/find out some other details/subtleties like Smart Pointers, where clauses, blah de blah. It's all actually very fascinating. It's a good book that's actually worth at least skimming in your free time. **Know what you don't know, so when you actually program, you know what you should learn next.** --- Also, Rust has excellent errors. It usually shows something like E125 when you have an error, which will show a detailed explanation on what that error means. Boom, no need to reach for stack overflow. You can do it; I believe in you! :)
Those module changes are beautiful. 
I'm just passing the matrices as values and having them get copied. In a sense, I'm doing the opposite of you: using copy for everything, and hoping that the compiler inlines things and elides copies where appropriate. For a vector, I'm fairly certain that's the right approach, since 3 floats aren't much bigger than a pointer anyway. For a 4x4 matrix, I'm a little less sure, since the data takes up 64 bytes. But the matrix operations aren't executed as often, so I opted for the easier code. I also suspect (though I haven't checked, so could be totally wrong) that the compiler is eliding the copies in most cases. If you want, you can take a look at my math code here: [https://github.com/cessen/psychopath/tree/master/sub\_crates/math3d](https://github.com/cessen/psychopath/tree/master/sub_crates/math3d) And it depends on a "float4" crate I also wrote here: [https://github.com/cessen/psychopath/tree/master/sub\_crates/float4](https://github.com/cessen/psychopath/tree/master/sub_crates/float4)
&gt; but the annual roadmaps are just a big joke and they keep piling on more instead of finishing anything. Technically whatever was on the roadmaps did get worked on did it not? So while they might not have reached the goal by the end of the year, progress was made on each front. Sure finishing them up would be great but I understand that it's best to apply the resources where needed most, so if the community feels something else is more important to suss out as a higher priority, then no harm in having that on the roadmap over a prior item that didn't reach completion(it could turn out that was due to running into a blocker and relying on some other things that are progressing more slower than desired for whatever reasons). Waiting can be a bummer sometimes, but there's plenty of other projects that have delivered too soon and regretted it, rust is often cited for getting things right up front when implementing language features, even if it means they take longer to become available.
Post build scripts, more than anything else, are something we *need*. Cargo ***needs*** to be a good build system *for rust*. It doesn't have to be general purpose, it doesn't have to work with anything else, but it should work for Rust. Post build steps are essential for deployment, among other tasks. And with the increased focus on embedded, even more essential! I need to be able to strip my kernel, and embed it with a bootloader, and all kinds of stuff!
Definitely feels like there some "feature creep" going on here. We're getting so distracted by new shiny features we're neglecting everything else. Ideally we would get the OPs "Reliability" period, with a feature freeze and RFC audit as /u/kibwen suggests, and work through the backlog. Polish up what we have, clean up the cruft, put a halt to the technical debt, at least for now. First step would be identifying what needs priority, what *needs* polish, what was accepted years ago but remains unimplemented, what can wait, what is now obsolete, etc. What Rust has right now is *good*, it *works*, I think it's a good base to work off of.
Should the link for \[edition differences\]([https://doc.rust-lang.org/stable/edition-guide/rust-2018/index.html](https://doc.rust-lang.org/stable/edition-guide/rust-2018/index.html)) be available in the [doc.rust-lang.com](https://doc.rust-lang.com) list along with the others? I don't see it there.
&gt; Plus, the standard library needed to be tweaked for use on embedded devices. That meant that people had to compile their own version of the Rust core crate (the crate which is used in every Rust app to provide Rust’s basic building blocks — intrinsics and primitives). They still do, if they're working on anything besides cortex-m3? Pretty odd to claim embedded is easy going now when thats only true for the one kind.
There is already an [issue](https://github.com/rust-lang/cargo/issues/545) for this, and lots of commentary on use cases. It's four years old. I disagree that it's needed for deployment. That's the purpose of `cargo install` and tools like `cargo-make`. However, I'm concerned more with steps that need to happen *before* deployment. At the moment building an application extension on MacOS or Windows is a two step process when you need a .bundle or more than a shared library, such as additional metadata in a folder. I can integrate unit tests in C++ projects that do the same thing, where my build system can create the deliverable in the target directory without needing to install it on my system. It's critical for a quick compile-debug-test cycle. Tl;Dr Rust is not ready for primetime so long as it relies on Cargo for building binaries and doesn't include post-build steps. I understand the hesitance of the Cargo developers for implementing something like a post build step, but the plumbing is there, and at the moment Cargo is not used as a simple dependency management tool. It's the de facto build system for Rust projects, and it would be fantastic to finally acknowledge it for that. 
&gt;Waiting can be a bummer sometimes, but there's plenty of other projects that have delivered too soon and regretted it, rust is often cited for getting things right up front when implementing language features, even if it means they take longer to become available. I completely understand that but the problem is how many huge things are piling up for the (I believe?) finite Rust developers to handle. Async, const generics, tooling like the RLS, Rust 2018, Polonious these are all HUGE things that it's questionable to take on in a single year, and it's all been happening basically simultaneously which seems like a recipe for being all over the place with interlocking dependencies and spread too thin.
&gt; Missing const generics I've been following the const generics story for awhile now. It hinges on [this PR](https://github.com/rust-lang/rust/pull/53645#pullrequestreview-171457974). 
Imagine you tried to go without the mem replace. You'd try to put the mutably borrowed self as the next thing in your new node. This doesn't make sense. You need to put an owned version of your head there. So, you put a dummy value in the place of self, and take that node out of self. Then, you can make your new head node which points to an owned next node. You then set the self, the head, as the your new node. This is called the [sentinel pattern](http://smallcultfollowing.com/babysteps/blog/2018/11/10/after-nll-moving-from-borrowed-data-and-the-sentinel-pattern/). Note: I haven't looked into detail on the tutorial you're looking at, just explaining the replace's use quickly. Internally, replace uses mem swap, which does exactly what it says on the tin. It swaps the values at the given locations. So essentially it swaps out the mutably reference given with a temporary value, then returns that swapped value. Mem replace's use is exactly for this. To get the data from a mutably borrowed value out, so you can do more complex operations on it than you can do by leaving it in. Making the new value point to the original value is a great example. I hope this helps. :)
&gt; That's the purpose of cargo install No, it isnt. Cargo install is to install something on *your* system. That has no bearing on getting my application ready for anywhere else, like building the installer. `cargo install` is for people who use Rust, to install stuff written in Rust. Having to install Rust and then call `cargo install` is an unacceptable deployment model for users. &gt; cargo-make Only exists because cargo refuses to support post-build scripts. You should not have to use a desperate tool for something as simple as post-build. And really, `cargo-make` primarily *replaces* `cargo` as a build system. If you need a post build script, chances are stuff wont work right if you don't run it, which means you can't use any standard cargo commands like `build`, `run`, or `test`. It also doesn't work well on Windows, though several such bugs have been recently fixed. &gt; It's the de facto build system for Rust projects, and it would be fantastic to finally acknowledge it for that. ..I read that and was like, "what?", I thought it was the "official" build system? so i took a look and huh, you're right. The *cargo* [docs](https://doc.rust-lang.org/cargo/index.html) call it a "package manager", and claim among other things it can ["Invokes rustc or another build tool [...]"](https://doc.rust-lang.org/cargo/guide/why-cargo-exists.html) (How? what? TIL) and generally avoid calling it a build system, but it does "compile your code" But, interestingly, the Rust [***book***](https://doc.rust-lang.org/nightly/book/ch01-03-hello-cargo.html) *does* say Cargo is a build system(and package manager). Seems theres some disconnect here on whether the Cargo, the Rust build system, is a build system or not. Cargo says no, book and everyone else says yes..
&gt; `transmute` is like telling the compiler it's too dumb to understand your great knowledge, so hold my beer and watch this brb, making RFC for `core::mem::hold_my_beer` 
The module system has always been a tree rooted in main or lib .rs, and other times are only pulled into the crate if they are reachable from the root space If you don't want to declare the module in the root namespace, you can use a path attribute to declare it in the tests module as #[path = "test_utils.rs"] mod test_utils; and then you won't need the crate namespace at all
I think we're on the same page here. I don't want to get too worked up about it, because I want to acknowledge that the Cargo folks have good reasons not to turn Cargo into an official build system. There are a lot of pot holes down that road, and it makes sense for them to be wary. Just a post build step would be fantastic. 
Good stuff. Thanks for typing this up. As far as the XY problem I agree; the most I gain from these things is figuring out the right question to ask. I'll read the damn book... 
The short answer is "don't do that" and the long answer is "use Rc and Weak pointers"
Haven't run into that one, so I really cannot say much about that.
Is it just me or does Intellij freeze frequently when trying to autocomplete?
My company’s server side stack is currently Rails. I’ve been slowly introducing rust by first using it for command line tools. Also given a few internal talks about it, to try and get people excited about rust. Last week I gave a talk about graphql and Rust and what benefits it can bring in terms of type safety and speed. I managed to get buy-in from the head of product and cto. So since then I’ve been working on an app using rocket, diesel and juniper. The initial goal is to port two of our endpoints to rust+graphql and see how it goes. 
Maybe recommend not a single, but multiple crates for every task.
That has the same problem as the sort+dedup approach: it reorders elements. If you're fine with that, I expect sort+dedup to be faster.
I second 2021=Maturity! Let’s finish all the things!
How many of the contributors to those features are paid to do so? I'd assume paid staff are focusing efforts more rather than spreading the talent all over? If there is a bounty for getting GAT finished up I'd put money towards it(though I'm not sure how many are involved in bringing that one feature out the gate as it depends on others like chalk first). If there is no paid talent working on it I can't expect it to be available any time soon, similar stance for other features. I can see where you're coming from and agree that if concentrated efforts on bringing the features over the finish line would be faster, that'd be great. But afaik, rust is being developed by no single entity, and certain features in development depend on the progression of others also in development still too. Rust roadmaps to me are more of a "this is the stuff we're going to work on this year" not necessarily complete. 
I've considered a Python 3-style feature freeze, but on consideration I don't think Rust really needs something like that right now. Rust just doesn't really add a ton of language features to begin with, mostly it just expands the capabilities of existing features (like how const fn is getting gradually more powerful, or letting people aside from the compiler define procedural macros, or making borrowing easier, or letting attributes appear in more places, or expanding the pattern syntax, or...).
Says right there on my first sentence.
Thanks. Am a C++ programmer by profession - trying to wrap my head around doing linked lists this way is challenging
Shit, I love that this community is in a place where people are starting conversations like this where "yeah, we have this now, and that's great... but what have we forgotten in the process?" That says a lot to me about how effectively the community and the leadership is prioritizing issues.
You should be able to pick it up soon. Rust comes from the desire to fix all the safety problems in C++ (among other things). If you can understand C++, probably the only truly new thing in Rust is lifetimes. Write enough code, and you'll get it. Hell, you should be halfway there already, with knowledge of RAII. It can be difficult to wrap your head around weird quirks like this, but in a year, when ownership/borrowing/lifetimes all make perfect sense, you're going to find it weird to do it otherwise. You'll wonder how you ever thought this was difficult. Don't worry. You're almost there. :)
So essentially to transmute a lifetime you should only be allowed to transmute it to a shorter one? I assume the rust compiler can't prove it's a 'shorter one'... but could it prove sometimes it's a longer one and go 'no way'?
I'm still not a fan of the website though, it's a bit too flashy and too much style for too little content. Although I get your explanation.
I can't think of any other cases where the compiler will error out when someone uses `unsafe` constructs to produce undefined behavior. It's pretty much a "trust me, I checked" marker.
I always tough the rust team needs to adopt some sort of Kanban approach with RFCs. Limit the number of work-in-progress rfcs and don't accept new one until some are finished.
Oooh! That's (almost?) exactly [what _I_ have been looking for for nearly two years](https://github.com/maghoff/bart/issues/11). Thanks! :)
I'm not sure this is true. Last year lots of people posted similar things about there needing to be polish added to what we already have rather than more big features and look what ended up on the road map. 
Haha I feel so stupid. Sorry!
Haha I feel so stupid! 
Just look at the number of [open tracking issues](https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+tracking+label%3AC-tracking-issue). As of writing this, 364 are open. It's getting out of control.
I think you should use [the community package](https://www.archlinux.org/packages/community/x86_64/rustup/) instead, it's 1.15
This is a pretty good idea. Hope the powers that be see this and consider it.
There was some debate pre-1.0 about changing `unsafe` to something like `trustme` or `unchecked`.
Congratulations!!! &amp;#x200B; But the previous site looks better and simpler. 
I guess that a 1 year long `impl` period might be a good summary of what I tried to say with the post.
Personally, I very, very rarely use glob imports. I find long imports like `use slog::{trace, debug, info, error, warn, crit, o}` preferable to macros just showing up in source code without a trail of breadcrumbs to show where they're from. Saving a small amount of typing isn't worth the lost understandability of the code.
Just wanted to say that I 100% agree with this. I really like Rust the way it is now, and I don't really care about async, web assembly, or the hot web framework of the week. I'm always way more excited to read about the stabilizations that have happened that improve the core language (eg NLL, const fn improvements, macros 2.0). But those things have already been on passed road maps so it doesn't feel productive for me to write a blog post about it again like I did last year. And honestly I'd just copy and paste my last year's blog post, which was mostly a plea for a standard especially in regards to FFI/C interop. 
You may be confused with `for element in &amp;user_config.accout` (note lack of `.iter()`), [which works via `IntoIterator`](https://doc.rust-lang.org/std/iter/index.html#for-loops-and-intoiterator).
Having ancillary containers inside iterators can cause all sorts of lifetime issues, so it's not that easy to do.
&gt; With that said I would not expect f32 to be any faster than f64 on modern 64-bit CPUs since you can do f64 calculations with a single CPU cycle anyway. That makes it sound like the bitness of the CPU has any effect on floating point operations whatsoever. Which is nonsense. Even the 8087 coprocessor for the 16-bit 8086 CPU worked on 80-bit floats. Data bus width might matter, but is not central to the N-bit designation.
Why are these two blocks of code not equivalent? I wanted to replace the top with a call to `zip` and I got a different answer (part of advent of code challenge). ```rust for i in left..left + right { for j in top..top + down { if map[&amp;(i, j)] &gt; 1 { continue 'outer; } } } ``` and ```rust for (i, j) in (left..left + right).zip(top..top + down) { if map[&amp;(i, j)] &gt; 1 { continue 'outer; } } ```
In this case, I'd recommend developing with that rustc version anyways. There's lots of non-edition additions, mainly API in the versions in between.
I couldn't find anywhere how to "downcast" (I don't know the correct term) a integer type to a "smaller" one, for instance `120u32` to `u8`. How can one do this (Other than the rather unsightly `x.to_string().parse::&lt;u8&gt;().unwrap()` I came up with) ?
Rust is competitive where its competitive advantages make a difference. With that incredibly tautological statement upfront, let me elaborate. Rust is fast, memory-efficient and robust. So you would use it where * you need speed, * you need a small memory footprint, and/or * you want to minimize the number of bugs upfront, because the cost of downtime is high. In web backend terms, that means you use it when you have so much load that the hardware savings are worth it, and where your systems are uptime-sensitive. So when your project plan includes load-balancing your Java server across 4 servers to deal with its memory need, you could consider using Rust instead, which might just be satisfied with a single server. Development cost is a once-upfront investment; server rent is a monthly recurring expense. But if the web development jobs available to you are not for the big projects, you probably won't benefit from Rust enough to justify its adoption.
I think the article is pretty honest on the status of embedded development: &gt;What’s next? &gt; &gt;With this year’s push, Rust has really good support for ARM Cortex-M family of microprocessor cores, which are used in a lot of devices. However, there are lots of architectures used on embedded devices, and those aren’t as well supported. Rust needs to expand to have the same level of support for these other architectures.
Features let you change what code gets compiled. A common example is including extra dependencies, or switching between 'backends' where multiple are available. Diesel, an ORM, has features for different databases. 
totally agree with your idea. One more thing, is on Rust more difficult to read and write code in big scaled team than on GO &gt;? Is it trues the threshold of entry into Rust higher than in languages with GC ?&gt;
&gt; Non-x86 support for SIMD (even on nightly). In particular, &gt; core::arch::arm &gt; is missing a lot of intrinsics. FWIW, nothing is blocking anybody from working on this. PRs are welcome!
Yes, Rust definitely has a steeper learning curve and higher skill ceiling than Go, and the lack of a GC (and the resulting necessity for lifetimes) is a big part of it. I would argue that its more powerful guarantees make it easier to read and write code in a big team; the tricky part is assembling and educating this team in the first place.
\&gt; Rust promotes semver yet instead of actually using it they are doing this. The problem is that it's more complicated than semver. They specifically \*don't\* want to make two incompatible versions of the language. Python did that with Python 3 and it's taken forever for people to migrate, because for a long time packages they depended on only supported v2. So, how do you add new changes that break backward compatibility but... not break backward compatibility? You have one version of the compiler that can build both "old" and "new" style code, depending on a flag. The "edition" option is very much like feature flags that you may have used in nightly -- it just enables a different compilation mode. But 2018-edition code can still depend on non-2018-edition code. There's no language schism this way.
Have a look at the [Rust and Webassembly](https://rustwasm.github.io/book/) book! It suggests reading the [introductory Rust book](https://doc.rust-lang.org/book/) first, but depending on what you already know you might as well read them in parallel :)
Macros of any kind are probably every language toolings kryptonite! We tried to cover the most common cases involving macros, so I kind of hope you are actually an outlier because you do all kinds of fancy things in your code! (One issue is the fact that the code the macro generates might not be for the same edition the macro is written in, for example.) If you could open issues on rust-lang/rust for the errors that you run into, we'd be very glad!
Love the new slogan: "Empowering everyone to build reliable and efficient software.". Also really like the redesign of rust-lang.org! Great work!
I don't understand how it can be called fluid. In my opinion that's the weakest point of Rust.
Also setting up debugging is less than convenient, especially if you want an experience on par with say debugging java in IDEA. You have to switch to a gnu toolchain and target, when it comes to IDEs you have to use either VScode or CLion, etc. Well worth the hassle IMO, but if the hassle could be reduced (especially for newcomers) I think that would be great.
The problem with this is the necessity to import each macro into each module. Which is somewhat redundant, especially in case of (s)log macros. So, I've decided to stick with `macro_use` for logs and for explicit macro import for other macros. 
Hmm? Go does not have deps like Java or .Net does. In that regard Go is like C++ and Rust, a single executable you can throw where ever.
Yes, but again, you only type it once per mod, but you may read it forever. And lots of other people made read it.
It's definitely harder to **learn** than Go (it took me a week to be confident enough with Go, and about a years for Rust (I wasn't doing Rust full time for a year obviously, but sometime you just need time for a concept to click). Now that I'm proficient with Rust (I use Rust on a daily basis at my job) I consider Rust being easier to write than the equivalent Go code because of Options (no more nil pointer dereference) and Result (no more `if err != nill {` everywhere. Imho, the only reasons Rust lags behind in the domain at the moment are : - the ecosystem, should I use Actix-web, Tower-web, Rocket ? (or anything else ?) - the lack of `async/await`, which makes the code quite messy (a little bit like JavaScript with promises, that I never liked). Hopefully these two concerns are going away in 2019 :).
Ahhh you're right. If I remove the ".iter()" it works with a reference. So what's the difference between `for element in &amp;somevar` and `for element in somevar.iter()` What is most commonly used? When do I use which? Does it even matter?
From what I've seen (not in Rust, but in general), it's literally impossible for any kind of management to put polishing/bugfixing/cleanup into plans/roadmaps. That's some global ["why new Gmail is slow"](https://news.ycombinator.com/item?id=18379394) syndrome. There *must* be shiny new features.
Try: let a: u32 = 10; let b: u8 = a as u8;
I didn't know about the `#[path]` attribute!
12 naked T-bags
&gt; ... "..." indeed
11 posts a day about the game Rust in this subreddit, which is about the programming language Rust, not the game Rust. You want /r/playrust.
A very nice redirect to /r/playrust with an invitation back here if you’re ever interested in Mozilla’s Rust programming language, built to make everyone a systems programmer!
You want /r/playrust
That looks really useful. Not having to match and mem::replace on the insides.
ty!
Hmm. The slogan was tweaked, and while I still think “empower” is an overused marketing word, it’s not as bad now. The information presented below it expounds upon what the original slogan said, so I think it’s an okay compromise. 
[This is a great blog post](https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html) on the differences between implicitly using the `IntoIterator` trait, which you're doing in `for element in &amp;somevar` and explicitly calling `iter()`. Basically in the first case you're consuming/moving the *reference* to the collection you want to iterate over using `into_iter()`. :)
Might Jupyter be able to take advantage of https://github.com/xi-editor/xi-editor in some way?
The first is going to loop over the cartesian product of (left..left+right) and (top..top+down) while the second only loops over the pairs where the indices are the same. If `left = top = 0` and `right = down = 2`: The first one loops over: (0, 0), (0, 1), (1, 0), (1, 1) while the second one loops over: (0, 0), (1, 1)
I'd say always use `for element in &amp;somevar` when possible. If you however need to do something with the iterator first, like filtering it, you have to use the second variant.
No way! You have a source?
There was going to be a page but it was never completed. It’s pretty small. New keywords and NLL (for now) are the big ones.
IntelliJ has really slow indexing in basically every situation it applies.
I'm blown away by the work the wasm WG has accomplished for Rust 2018, but my favorite part of this post is the very end. That list of contributors, from just a year, is just astonishing. Thank you *all* for your effort this year; can't wait to see where this all goes in 2019! 
I've always had "half as fast as go" in my mind as a good target.
I like the opening comment. :)
Rustdoc won't see a difference because rustdoc operates on the lower level type info
Ooh this looks similar to `.take()` and sounds similarly useful!
Thank you for working on this! Reminds me I’m still working off a fork, and can’t remember why.
You could write a macro module of your own, pub use all the macros you're going to use in there. Then you can glob use them in all your other modules. Your own macro prelude.
I'm confused about the need for the extended std. Don't we have the rust cookbook?
Please add generators though. They make writing iterators so nice.
&gt;These concepts are orthogonal. Completely true but if you say an op only takes 1 cycle I expect it to have 1 cycle (forwarding) latency, like a basic add, not 1 per cycle throughput. &gt;Look for example at the implementation of matrix multiplications in the BLIS library: they try to design their multiplication kernels in such a way that the total latency of the addition+multiplication steps does not matter. Yes this is all completely true, but the nice thing about 1 cycle latency ops is that you don't have to worry about their scheduling order. Of course you always want to keep dependent instructions as far away from each other if this is not the case.
That explains why I didn't get the Rust 2018 release announcement in my reader :(
See https://github.com/rust-lang/rust/pull/56594
&gt; trying to wrap my head around doing linked lists this way is challenging Linked lists are just hard in rust, they are not a recommended place to start learning. This is a slightly dated seres on why: http://cglab.ca/~abeinges/blah/too-many-lists/book/
yes, that's how I found out. I fear that it was intentional, as I hear Mozilla will drop feed discovery from Firefox soon
Rust is not run by Mozilla, and decisions about the Rust website are not made based on Mozilla’s feelings about supporting a particular protocol or format.
Yep. I get \`error: toolchain 'stable-x86\_64-pc-windows-msvc' does not contain component 'clippy' for target 'x86\_64-pc-windows-msvc'\`
I hope so, possibly it just slipped during the move to the new interface
It will be back: [https://github.com/rust-lang/blog.rust-lang.org/issues/307](https://github.com/rust-lang/blog.rust-lang.org/issues/307)
It's temporary - there's an issue for fixing it: https://github.com/rust-lang/blog.rust-lang.org/issues/307
Lifetimes have a concept of living longer than each other, transmute really honestly shouldn't be used to mess with lifetimes.
thank'you
thank'you
For me everything works! I tried `rustup self update` out of curiosity and saw: &gt;**error:** self-update is disabled for this build of rustup **error:** you should probably use your system package manager to update rustup Nice! Thank you for enabling sane integration with package managers
I’m not sure if we can take credit for that or not :)
As far as I can tell, there's no way to implement the count_by adaptor lazily. To get the count of the first item, you need to iterate over the entire iterator anyway, so you might as well do it up front. Going off that idea I wrote up [this implementation](https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=b83dbb9e8af323c9cc21e6f1be298ac8) of `count_by`. I chose here to preserve the order of the items, whereas I don't think the F# version does, but aside from that I think they do much the same thing (not greatly familiar with F#). The `unique` adaptor is from IterTools, and uses a HashSet to keep track of what it's seen.
Hi. how do I change the result type of a function alloc to Option&lt;&amp;mut T&gt; ? if I try to return Some(unsafe { &amp;mut \*p1 }) compiler starts to compain. use std::mem; struct TheThing { v: Vec&lt;u8&gt;, size: usize, top: usize, } impl TheThing { pub fn new(size: usize) -&gt; Self { let v = unsafe { let mut t = Vec::with_capacity(size); t.set_len(size); t }; TheThing { v: v, size: size, top: 0, } } fn internal_alloc(&amp;mut self, s: usize, a: usize) -&gt; Option&lt;*mut u8&gt; { let align_offset = self.top % a; if self.top + align_offset + s &gt; self.size { return None; } let r1 = &amp;mut self.v[self.top + align_offset]; self.top += align_offset + s; Some(r1 as *mut u8) } pub fn alloc&lt;T: Sized&gt;(&amp;mut self) -&gt; Option&lt;*mut T&gt; { let item_size = mem::size_of::&lt;T&gt;(); let item_align = mem::align_of::&lt;T&gt;(); let r1: *mut u8 = self.internal_alloc(item_size, item_align)?; let r2: *mut T = unsafe { mem::transmute(r1) }; Some(r2) } } #[derive(Debug)] struct Foo { a: u8, b: u16, c: u32, } #[derive(Debug)] struct Bar { a: u16, b: u8, } #[derive(Debug)] struct Baz { a: u8, } fn main() { { let size = mem::size_of::&lt;Foo&gt;(); let align = mem::align_of::&lt;Foo&gt;(); println!("size {}, align {}", size, align); } { let size = mem::size_of::&lt;Bar&gt;(); let align = mem::align_of::&lt;Bar&gt;(); println!("size {}, align {}", size, align); } { let size = mem::size_of::&lt;Baz&gt;(); let align = mem::align_of::&lt;Baz&gt;(); println!("size {}, align {}", size, align); } let mut thing = TheThing::new(1024); let p1 = thing.alloc::&lt;Foo&gt;().unwrap(); let r1: &amp;mut Foo = unsafe { &amp;mut *p1 }; // &lt;&lt;&lt; move to alloc&lt;&gt; method r1.a = 1; r1.b = 2; r1.c = 3; let p3 = thing.alloc::&lt;Baz&gt;().unwrap(); let r3: &amp;mut Baz = unsafe { &amp;mut *p3 }; r3.a = 6; let p2 = thing.alloc::&lt;Bar&gt;().unwrap(); let r2: &amp;mut Bar = unsafe { &amp;mut *p2 }; r2.a = 4; r2.b = 5; println!("{:?}", r1); println!("{:?}", r2); println!("{:?}", r3); } &amp;#x200B;
To be clear, this is 100% my fault. It did slip, but I also thought it would be trivial to fix; I could manually write in the new entries. But I forgot to take a snapshot of the old contents, and the way back machine doesn’t store the actual XML, but a web page of it rendered. Then I had to spend yesterday dealing with more pressing edition related stuff. It’ll be fixed next week, or sooner if someone else sends in a PR. Sorry again :(
There's already the language nursery though. Isn't that sort of a curated list of essential crates?
If you do figure out why you're working off a fork, please let me know! I'm definitely interested in making sure it works out of the box for all common use cases.
You can! On arch it’s simply compiled using `--features no-self-update`! ([you commented](https://github.com/rust-lang/rustup.rs/issues/597) 😉)
Ha! 😅😅😅
Emacs and vim have great rust code completion. 
don’t worry, there’s definitely more important stuff for you to remember than one comment years ago!
So.... it seems like you and I disagree - this is a good thing. Perhaps you can change everyone's mind today about using a debugger. Here are some fictitious (and exaggerated) scenarios of why I like debuggers more than println. I hope you share some scenarios with me too so we understand the different points of view. Without debugger: I run my program in Rust, I click a gui button and nothing happens. It should have called a function. I put a println statement in the function and recompile+rerun the program - still nothing. I search for who is calling the function and add println functions in that function.... still nothing. I re-do this again to the grandparent function. I get something.... it seems as though somewhere in the function is a "?" operator that is returning a failure::Error and I'm not handling it properly in the caller. I then start adding 3 more println functions to figure out which "?" operator is being triggered on one of the 3 functions. Eventually, I println every value I can and see that a boolean value that happened to be false instead of true. I write the proper code, and verify that the println statements all match up. I then exit the program, I remove all my weak println functions, and rerun to see if everything works. I coded, recompiled, and executed 6-10 times. With a good debugger: I run my program in Rust, I click a gui button and nothing happens. It should have called a function. Without exiting the program, I put a breakpoint in the function that it SHOULD have called and click the button again. Still nothing. I then put a breakpoint in it's parent, and click the gui button again - nothing. I then put a breakpoint in the grandparent and click the button. The execution pauses at the grandparent function. I step through the grandparent function and I monitor the variables on the side. Eventually, I find that a boolean value that happened to be false instead of true. I exit the program for the first time, write the proper code, and with my breakpoints still in place, re-run the program. The values look good, the proper function runs when I click the gui button, and I move on to testing something else. I coded, recompiled, and executed 1 time.
Yeah I think the rust-cookbook is really the closest thing we have for that right now. The more I think about this, the more I think aturon has the right approach with having the core team concentrating on ecosystem interop with common data formats, traits etc.
Overall this is a fine model for entire languages. C++ uses it too (C++11, C++14, C++17...), if the language is backwards compatible, you can drop the "major" version, and a language doesn't really have a "patch" either.
I believe those are maintained by the language team, so that would be a different scenario.
The page https://forge.rust-lang.org/other-installation-methods.html reports still "Stable (1.30.1)" and "Beta (1.31)".
I don't think any of the other questions actually answer it. &amp;#x200B; fn main() { bar("bob"); } fn bar(foo: &amp;'static str) { println!("{} is the string", foo); } &amp;#x200B;
I want feed discovery to stay! Actually, what is feed discovery?
People have wanted this but a good amount of us were like, "this is a bad idea" and the rust cook book was born it off that rather than having something like stdx
the button which finds the rss links available in the page you are visiting. It's not too bad because you can just manually view the page source, but it's a sad sign of the decline of rss in favor of proprietary social media which not everybody uses.
Hope to see const generics and type-level integers for 2019. https://github.com/rust-lang/rust/issues/44580
I wasn't blaming, sorry if it came out wrongly, just worried it might be intentional and not a bug.
It's not exactly advertised lmao
Reddit has feeds, like [this one](https://www.reddit.com/r/rust/comments/a40a95/official_blog_dropped_rssatom/.rss). Should it show up somewhere in Firefox?
&gt; Stable TryFrom/TryInto. I think we’re close! https://github.com/rust-lang/rust/pull/56219 has a possible fix for the bug that block stabilization of the never type, which in turn blocks `TryFrom`/`TryInto`.
yes =D you need to unlock the function, it's already been hidden since a few releases. Right click on the toolbar, customize, find the rss symbol and drag it to the toolbar. But don't get hooked to it, it's going to disappear very soon
This is a known issue. I've been meaning to fix it [over here](https://github.com/tomv564/LSP/pull/472), but I've been away for the past week. rwols left a snippet that fixes this issue, along with others. Hopefully within the next week I can get the changes merged, but until then, I recommend pulling down the master branch of the LSP plugin to apply rwol's fix yourself.
This, above all, is the most important thing for me. 
Rust is the ideal language for lambdas, as no runtime and AOT compilation means very fast cold start times. And you get compile time memory safety and strong types. 
If someone can work on something and actually wants to work on it then why would we say no just because some arbitrary limit is reached. It doesn't help.
Well, there is [miow](https://github.com/alexcrichton/miow). &gt; "A zero overhead Windows I/O library focusing on IOCP and other async I/O features." It's what `mio` uses on windows.
For IDE I am happy of CLion so far.
Damn, that's depressing. I guess running an organization efficiently is really hard.
Thanks! I am confused about how to install it after I make that change though? And help with that?
Go to `Preferences =&gt; Browse Packages` in Sublime and move the entire `LSP` directory, with the change, into that one.
I'm not using Windows.
If you want it, then you should write it. The reason it doesn't exist is because people haven't written it. Rust isn't a common language that is used in production at companies yet, so most (if not all) of the crates are written as part of volunteer effort in their free time. Eventually I may get around to it when I decide to add machine learning to my financial automation project, but that's a long ways off, so don't hold your breath.
Until `beta.rust-lang.org`, I haven't visited main rust-lang.org for a loooong while. I forgot how it looks. There's nothing there for me to see. So I guess I agree that it should be aimed at people that are not yet users. Not sure if CTOs/managers should be primary target, but it does make sense. For Ruts to gain more traction, we need to convince management to let the engineers that are excited about it, give it a chance.
I usually work on servers, not desktop applications, so attaching a debugger "in the wild" just isn't a thing. Getting set up to reproduce a bug locally can be a bit of a pain, and with things running in lots of threads, it can be extra hard to coordinate things properly. Therefore, I am used to putting good logs throughout my code while I'm developing it, and then reading the code to figure out why something happened. When I _do_ work on desktop software, I tend to use the debugger a bit more. However, I usually try to reproduce it by throwing a few logs in first, and then resort to the debugger if that fails after one or two attempts.
Oh! Then I'm afraid there you'll have to roll your own. I'm not familiar with any IOCP libraries that target OSes other than Windows (even in other programming languages), so I can't really help you here. You would have to basically do a "reverse `mio`", where instead of changing IOCP to play like epoll, you would have epoll change into an IOCP-like API.
Ah interesting. You can do `quote{ let path = std::module_path!(); #rest_of_your_proc_macro }` if you can settle for using the path as a variable that's accessible at run-time. I'm not sure how to get the `module_path` during proc-macro execution time, though.
You should probably post things like this to /r/rustjerk
I can definitely see integration with text editors, particularly xi since it's written in Rust. Also for selfish reasons, I want tighter integration with Vim!
Great to hear that you're interested in the project. I do have some comments about the documentation and would love to help if possible. I'll perhaps document some of my thoughts in a message through your mailing list and perhaps we can work on improving the documentation for people new to the Jupyter protocol. &amp;#x200B;
You should be able to load wasm code in some, if not all, of the contexts for a web extension (at the very least, the background page). I've only confirmed this wih chrome but the extension models are nearly identical.
Oh, I didn't know we had a rustjerk. Is this post against the community rules?
&gt; No memes. &gt; Leave the image macros at home. 
Yup, removed the post. Sorry.
I must be doing something wrong as it just doesn't seem to want to work still. Not sure if I didn't make the correct changes or what. Thanks for your help though. I will keep messing with it to see if I can get it working. I replaces the get\_project\_path function and then added those other functions he had there plus updated the imports as shown in the snippet. Which I thought was what was needed.
10%, you mean.
Not quite. The module `test_utils` _doesn't_ exist until you declare `mod test_utils;` inside the crate root, in this case `main.rs`. Since this module is specifically for testing, I would make the module conditional: ``` #[cfg(test)] mod test_utils; ```
AFAIK, you still can't use procedural macros in an expression position, sadly :/
I remember, my excitement isn't that the community is in this situation for the first time, but rather that the spirit continues. Or are you disagreeing with something else?
Thanks. I breezed through most of TRPL book and was very well written and didn’t have too much difficulty. This is the first that I’m trying to write and is challenging :)
There is only 1 compiler. Visual Studio Code is a nice editor you can use whatever you like. 
/r/playrust
I think you mean editor or IDE, the only Rust compiler AFAIK is rustc. On the other hand as far as editors go VS Code is not that bad, if you feel comfortable with it, keep using it.
/r/PlayRust 
Rust, at the moment, has only one compiler, `rustc`, which comes with the rest of the Rust tooling via `rustup` (see Rust website/documentation). What you probably mean is that you used Visual Studio Code as a text editor, with Rust support via the `Rust (rls)` add-on. Of course, you can use just any text editor to write Rust. Visual Studio Code, though, has excellent support for Rust, so you may just stick with it.
Your next step should be to read the [Rust Book](https://doc.rust-lang.org/book/). That should give you a good foundation to get going with the language. Or repost this to /r/playrust instead. /r/rust is dedicated to the Rust programming language.
tkx guys sorry &amp;#x200B;
https://github.com/rust-lang/book/issues/1669 
That works in an organization with a fixed number of workers, but is less than ideal for a distributed organization of a fluctuating number of part-time volunteers. It's pretty valuable for the amount of available work to be able to scale with a sudden surge of contributors.
Hey, do you mind if I ask which VS Code color theme you are using? Looks super nice. Thanks ☺️
[macro\_railroad](https://github.com/lukaslueg/macro_railroad) has a WebExtension built for WASM that works on Firefox and Chrome. You can find the code [here](https://github.com/lukaslueg/macro_railroad_ext)
If you’re interested in the support in other editors/IDEs, check out https://areweideyet.com/
Those who can identify the correct subreddit and those who cannot? ;-)
Thanks for the update, things happen. Hopefully the fix goes smoothly once you can get to it :)
I was just about move on to that section and was wondering why my bookmark was borked.
I *really* love the design by memoryruins, but like you said, a big factor was probably timing with the Rust 2018 release. Hopefully some time next year the team that manages the site will start considering new designs. I don't see why we can't have an open issue on the repo discussing design ideas for the future?
Generally they are anchored, but you can make them move with you as far as I know.
I copied your program into the Playground and it compiles just fine on the current stable version of Rust: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a9ef3cdda6319506ea3cfbf61cc3f17f Can you post more about the error that you're seeing?
I always had just used the `cargo check` functionality from Rust Enhanced, but yesterday I decided to try to update. I updated all my sublime plugins (remove Rust, reinstall Rust Enhanced and LSP), installed all necessary rust components (rust-analysis, rust-src, rustfmt-preview, rls-preview) for both stable and nightly. (You need to make a toolchain the default toolchain before installing components for it). Then I defined some keybindings { "keys": ["f12"], "command": "lsp_symbol_definition"}, { "keys": ["alt+shift+r"], "command": "lsp_symbol_rename" }, { "keys": ["alt+shift+f"], "command": "lsp_format_document"}, { "keys": ["alt+shift+e"], "command": "lsp_document_symbols"}, { "keys": ["alt+shift+f"], "command": "lsp_show_diagnostics_panel" }, { "keys": ["alt+shift+d"], "command": "lsp_hover" }, { "keys": ["f4"], "command": "next_result" }, { "keys": ["shift+f4"], "command": "prev_result" }, I disabled the syntax checking from Rust Enhanced with "Rust: toggle syntax checking". This created the `"rust_syntax_checking": false` setting in my project file. I activated rls for the project with "LSP: Enable language server for project" -&gt; "rls". Then I fiddled around a bit more with things I can't remember anymore, because it did not work at the beginning. But I guess the language server just needed time to boot up. This is how autocomplete und show docs look like now. ![http://pix.toile-libre.org/upload/original/1544206961.png](http://pix.toile-libre.org/upload/original/1544206961.png) ![http://pix.toile-libre.org/upload/original/1544207185.png](http://pix.toile-libre.org/upload/original/1544207185.png) All the other LSP things work as well: Go to def, show type (by hovering), show doc (by hovering), show references, rename. Currently, my project file looks like this ``` { "folders": [ { "folder_exclude_patterns": [ "target" ], "path": "." } ], "settings": { "LSP": { "log_debug": true, "log_payloads": false, "log_server": true, "log_stderr": true, "only_show_lsp_completions": false, "rls": { "enabled": true } }, "cargo_build": { "defaults": { "toolchain": "nightly" } }, "rust_syntax_checking": false } } ``` But I honestly don't know where all those logs go :D
You misrepresent the core team's response when you quote the reason for locking the issue. That was a response to continued discussion after the issue had been closed, which is a reasonable way to manage the endless bikeshedding of design. The reason for actually closing the issue in the first place is unquoted in your complaint, but gives the actual spirit of the conversation. &gt; thanks for the feedback. if you'd like to open a PR to reaarange some of the color backdrops on other pages that'd be great and i can give feedback on the PR directly. &gt; &gt; as i said previously, wholesale removing the colors is not currently up for discussion. closing this, and will give feedback on specific suggestions in PRs. And earlier in the conversation. &gt; hey! thanks for filing. &gt; &gt; at this time we're not looking to remove the colors wholesale from the website. it is true though that some pages may have unfortunate color combinations, and we are open to hearing that feedback! if you could be specific about which pages you'd like to see changed and to what (giving the existing styles for sections)- we'd be very open to working on improving that! thanks :) 
It works in Rust 2018 if you rearrange the print statements, since that allows the new and improved borrow checker to keep track of when each new mutable reference is no longer used: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=bb46c68d0c60eb56d7b8e3072a38d0d8
I think the fact that we're in the same situation shows that the leadership haven't got their priorities correct
I reread the thread and you are correct. I have rather unfortunately misinterpreted the closing comment. My apologies and thank you for pointing it out, I did not mean to intentionally misrepresent anyone's words. "wholesale removing the colors is not currently up for discussion" still rubs me the wrong way, though. Isn't discussing merit what issues are meant for? Maybe it's just me.
I wholeheartedly second all of this, great job summing things up so clearly
It is One Dark Pro. Just like Atom's default theme. I like it quite a bit currently. 
First Google result: https://www.coca-colacompany.com/stories/coke-lore-santa-claus &gt; The Santa Claus we all know and love — that big, jolly man in the red suit with a white beard — didn’t always look that way. In fact, many people are surprised to learn that prior to 1931, Santa was depicted as everything from a tall gaunt man to a spooky-looking elf. He has donned a bishop's robe and a Norse huntsman's animal skin. In fact, when Civil War cartoonist Thomas Nast drew Santa Claus for Harper's Weekly in 1862, Santa was a small elflike figure who supported the Union. Nast continued to draw Santa for 30 years, changing the color of his coat from tan to the red he’s known for today. Coca Cola overhauled the traditional image of Santa Claus and created the modern version: a big jolly old man in a red suit.
This is super interesting! I develop near exclusively in Typescript (both server &amp; web) and something like this would certainly help going over to Rust.
FYI, there is [an addon](https://addons.mozilla.org/en-US/firefox/addon/awesome-rss/) to replace that functionality (as is the true Firefox way).
Well at least I know it can look like I want it to. I just gotta figure out why it isn't. Maybe I will just start from a clean slate with Sublime. Uninstall and back to the beginning.
I'm assuming that stabilizing async/await would happen despite this if this were be the way to go. I agree with this but I still really want to see all of that stabilized, especially since it was supposed to be a part of Rust 2018
While Rust team focuses a lot on literal backwards compatibility, I think it doesn't put enough thought into spiritual backwards compatibility, which is what happens when a new patten emerges and tooling rapidly starts being rebuilt around it, leaving those who haven't done that in the dust. For example, today developers may be using Tokio, or Rocket, but once async/await is stable, most of the community may move towards Mio or Actix. It doesn't "literally" break compatibility for those using old architectures, but it logically puts them at a disadvantage, because they get less benefit of relying on the open source community when most people moved on from supporting their tooling to new patterns and libraries, forcing the author to migrate or fall behind. Which is why timing matters. There are core things in the roadmap which fundamentally shape how code can be written and what libraries can exist and be the de-facto best-of-breed. Async/await is an obvious one, but probably so const generics and generic associated types. We can't kick that can down the road forever. The longer it's not done, the more painful it'll be for the community to adopt once it lands and causes a ripple effect in everyone's dependency chains. I say, make Rust 2019 a full impl year. Stop taking new large RFCs (occasional small things are fine), and focus on actually building the things already in the queue.
What are the big use cases for post-build? Is the idea that wrapping Cargo in a Python script or whatever adds an unnecessary dependency on Python? Could those use cases be served by adding a binary target and doing `cargo run` instead of `cargo build`?
I should have specifically called that one out, but yes, that was the intention. It also aligns with the survey feedback.
Nitpick: I think there are some niche usecases where Rust may make sense... but agree that for probably 99% (and counting) it'll never take off.
Taking on a full redesign after already going through a full redesign is not in anybody's budget, and that's essentially what's being asked for in this thread. I think closing the door to open bikeshedding season, and being clear about inviting the kind of changes that are feasible is wise project management. 
I have yet to see any feedback on any website launch ever to lean towards positive. People hate change.
Hello, I'm trying to understand how to store a reference to another struct, in a struct. I don't quite understand lifetimes very well though. https://i.imgur.com/9PjLFQ7.png I heard dealing with lifetimes and the borrow checker is the rite of passage for learning Rust :)
Personal reason: application extensions packaged as a MacOS bundle or directory on Windows with additional metadata/layout to the binary. [There are more use cases listed in this issue](https://www.google.com/search?client=firefox-b-1-ab&amp;q=cargo+post+build+script). &gt;Is the idea that wrapping Cargo in a Python script or whatever adds an unnecessary dependency on Python It's more that `cargo build` doesn't actually mean "build this project" and it changes the semantics of building. Instead of saying "run `cargo build` to build this project like any other Rust project, run this build script instead." It's a hacky workaround a flaw in `cargo`. &gt;Could those use cases be served by adding a binary target and doing cargo run instead of cargo build That's the same problem as writing a python/bash script, just using Rust instead. However I think that's a worse idea, since `cargo run` translates to "run this project" and not "build this project." Especially when there are additional steps that need to be taken in a post build step, like moving the build artifacts to a different directory or deleting/renaming binaries. At the end of the day I don't think one needs to justify why post build scripts are necessary. I think it needs to be better explained why Cargo shouldn't support them in `cargo build`. 
Last time I used it, RLS was basically entirely u usable tbh.
I don't think it's fair to generalize like that. For every change, there are going to be people who like it and people who want something else. It's just in this case the majority sentiment was that of disapproval. When you're working on a project for a long time, it's easy to lose sense of what's good and what isn't -- that's why second opinions are so important. Perhaps if the community would get involved earlier, there would still be time to address the issues.
&gt; Could be worth starting a tradition of doing such an inventory after every new edition ships. Maybe every year? I'd actually think that given the yearly objectives December (now) is the ideal moment to pick RFCs from previous years and triage them.
I just think it's a better idea to let things settle down before throwing the baby out with the bathwater.
I agree, and I think that with some tweaks the website can be quite fine. However, the one thing that I can not forgive is the conscious decision _not_ to show a code example. I absolutely _abhor_ PL sites that refuse to show what it looks like. I would be totally neutral/fine with the site as long as it had a code example.
That's really cool. It's a pretty easy way of increasing rustc's performance too! Maybe we could get `IndexSet` too while we're updating `std::collections::HashMap`?
On Windows I'd have to agree that, at least in VS Code, RLS really isn't of much use, unfortunately (though a few months ago it was working reasonably well for me). I'm going to give it a go in Fedora later today to see if it works any better there (though I do most of my work in Windows these days, so that would still not be ideal).
As far as I understand it, the proposed changes are limited to the color palette and maybe some spacing -- I can't imagine this taking more than a few hours of tweaking CSS for an experienced web-developer, so I think it's not correct to call it a full redesign. Bikeshedding is undeniably an issue with updates like this, but with how unanimously disliked the redesign appears to be, I don't think it's unfair to say that this wasn't handled all too well.
&gt; Edit: I'm going to leave this comment as is so as to be honest but I realize my tone in this thread is needlessly hostile and for that I apologize. I am very glad you realized it. I sense frustration here, and frustration has a way of twisting our words. Take a deep breath, go for a walk, life's too short to get all upset about such trivial things as programming languages :)
Sure, the development work is probably straightforward. But the time to compare competing bikesheds, decide on the merits of one or another, determine if the rest of the design works with the newly proposed palette, or if other changes will need to be made, deal with the fallout of people who did like the existing design complaining that they weren't consulted on the new one? There's only so much effort you want to put into the website. FWIW, overall, I like the new design, and outside of reddit and hackernews, I've been seeing a fair amount of positive feedback as well.
I think this is what we need the most, there are so many RFCs that been accepted, but never implemented, let's get focus on them for a year.
Well put. The theme for 2019 should be "Maturity" -- polish the awesome work already started. There will still be plenty of new shiny -- they'll just ship in libraries on crates.io.
It breaks out of the conventional sorting of source files, and as such isn't something to be used lightly. I end up mentioning it every time a modules question comes up and every time I do someone else comes up to say not to use it :P
Excellent, spot-on list. RLS literally doesn't work for a lot of people.
I just read [Finish and ship the work that has already started](https://www.reddit.com/r/rust/comments/a3sav1/2019_roadmap_more_like_a_wishlist_finish_and_ship/), and now your post, and I'm nodding all along. I am all for a **Fallow Year**^1 : finish the ongoing work, clean-up, polish, and build a solid foundation for next year's challenge. Also, as you mention, we -- the community -- need time to digest all those new features and learn to use them efficiently. And then, once we have good solid designs, we'll have a clearer idea of what's missing, what are the papercuts and where to go from there. GAT (ATC?) may be the next big missing feature; but maybe designing it this year with a view of implementing in 2020 is soon enough? ^1 *Great analogy!*
Could you also show your Cargo.toml? It's likely the issue is there.
I haven't added anything to the Cargo.toml manually because I don't think it said I needed to. It looks like this: \[package\] name = "minigrep" version = "0.1.0" authors = \["My Name &lt;myname@gmail.com&gt;"\] \[dependencies\] 
I have to agree. I *much* prefer the Rust website looking like a tastefully full-color O'Reilly book rather than a (to be blunt) garish poster.
Of course, but it would have been nice to have the community actually be involved in the development of the website of a supposedly community driven programming language. The way it was handled was "oh by the way, here's the new website, we really care about the community and are looking forward to feedback, but we'll ignore it because it's too late". I disagree with the hypocrisy, something is either community driven or it isn't, the way it was handled had the message of "fuck you, we don't care", whether that was the intention or not does not matter, either make it community driven and find a way that works at the current scale (it won't work), or drop the niceties and community bullshit and make it clear who is in control. 
&gt; I think it would be more valuable to hear what others have to say as well. New design hurts my eyes physically because of sudden changes of palette during scrolling. Switching between white-on-dark and black-on-white text is definitely not a good idea.
&gt; Of course, but it would have been nice to have the community actually be involved in the development of the website of a supposedly community driven programming language. I was not involved in this but to me it seems very much like the community was involved. Just not the whole community which from my perspective makes a lot of sense. It's just that a) more people have opinions about websites and b) the barrier of entry to both contribute and have opinions about it is lower. As a user I'm glad someone makes sure that this does not devolve into a massive bikeshedding. (And I also don't like all things about the website and left some feedback.)
I learned so many things with your post! Thank you, sir.
In response to the web framework part, I think that the fact that we have the `http` crate which provides a common target for types that all web frameworks was a significant accomplishment. In my opinion, web frameworks should be relatively thin. Things like CORS, cookies, and session management can be done without baking them into the web framework as long as they have this common interface. You should read about how `tower` and `warp` are two separate web frameworks, but they are building compatibility between the two in terms of using `tower`'s `Service` in `warp`. As a result, middleware can be mostly independent of the framework. Also, `actix-web` has been stable for a long time, so I think that your final assessment is a bit unfair.
Could it be faster to represent "empty" as `0b00000000` and "full" as `0b1xxxxxxxx`? That way you can ask the allocator for zeroed memory, and you don't have to pay the cost of initializing it to empty?
Don't. Read https://dpc.pw/the-faster-you-unlearn-oop-the-better-for-you-and-your-software instead and ask me follow up questions if anything is unclear. 
The only thing I see when I look at the website is [this](https://i.imgur.com/aj3Qttx.png), and I can't get it out of my head now.
I'm using Fedora, it works very well. I'm productive enough with RLS.
My wish would be that the GAT implementation will get finished in 2019, so that we can collect experience of using GATs and see what would be a good design for HKTs outside of traits.. 
I'm not sure without seeing the definition on `Engine`, but I think that it has a lifetime parameter that you have to specify here too, either like this: pub struct Renderer&lt;'a, 'b&gt; { engine: Option&lt;&amp;'a Engine&lt;'b&gt;&gt;, ... } or like this: pub struct Renderer&lt;'a&gt; { engine: Option&lt;&amp;'a Engine&lt;'a&gt;&gt;, ... } But I cannot tell which case is better without knowing what `Engine` is.
I'm still kinda a newbie, but simple linked lists seem to me to be the kind of thing to do in unsafe rust, and expose a safe API for. 
To me, the colors make Rust seem like a toy, whereas a more conservative color palette would make it seem more mature. If the intended audience has the same reaction, then the website redesign is backfiring.
I don't think anything is stopping further changes from happening. Like you said, it's been all of a week since the community gave its feedback. I don't know anything about the timeline of when the web site changes were designed, but I imagine they had a tight deadline to ship it with Rust 2018, and I don't think it was a wrong decision to time their releases together. The core team has always been very open and receptive to feedback, and I don't think there's any reason to believe they won't keep listening.
I think what would look really nice is @memoryruins's design but with the color that Rust code has on GitHub (that rusty color). 
The version of the book that you’ve linked assumes that you’re using Rust 2018 edition which was released yesterday. Make sure you’re running the latest stable (`rustup update stable` will get you there) and add the line [package] # ... edition = "2018" to your `Cargo.toml`. Alternatively, you can add `extern crate minigrep;` at the top of your `main.rs` if you want to continue using the 2015 edition.
Not sure if this is still true, but from what I remember from [this](http://cppcast.com/2015/07/steve-klabnik/) 3 year old episode of CPPcast, rustc produces very naive LLVM, so it requires a lot of LLVM passes to get the code to be performant. In debug mode, a lot of those passes are just skipped to save time. I'm not super up on how compilers work tbh, so take what I say with a grain of salt
Good thoughts. I think one important factor is to avoid writing libraries that target specific frameworks APIs only, and avoiding writing frameworks that require specific APIs (e.g. middleware frameworks).\\ Whenever a framework with some plug-in / middleware / transformer pattern is used, it imposes restrictions on the kinds of abstractions we can use. This usually means not being compatible with other frameworks, not being useful outside the context of the framework, etc. A lot of the time I always prefer to just be able to call some library functions, rather than slotting in specifically engineered building blocks that make assumptions about in which order they're run compared to other building blocks. (concrete example: reading and constructing cookies in web servers) Perhaps being more conscious about preferring libraries over frameworks we can void the framework fatigue and churn that's been the hallmark of the JS ecosystem.
Also improved lifetime elision: `impl Foo for &amp;Bar {`
Thanks for reading! I'm glad! :)
To clarify a little bit, I don't think gathering feedback a week before release was a good idea -- there is simply not enough time to ponder and act on it. \*cough Fallout 76 cough\* This redesign is not a new development, mind you -- I've heard of it happening as far back as a few months ago, but it didn't seem to ever come up on public channels since, so there wasn't much of a chance to get involved. I hope the website gets improved with time, but I just wanted to invite some meta discussion about the feedback loop (or absence thereof).
I'll be another voice in the chorus here. Excellent idea. One of the best things about Rust is the tooling, but there's still so much room for improvement. I particularly want to see the RLS become a first class tool. I hate that different editors are better for different languages -- I want to use vim for everything, and there's really no good reason we all can't use different frontends with the best state of the art backends. I also love the documentation idea. Back when Book v1 was the only Book, it was much easier to follow the language. It's very hard to research a number of topics now because there are so many empty areas of documentation. Don't get me wrong, it still destroys C++ here, but I feel the documentation has failed me more than once in the recent past. I still have no idea how to get more information about procedural macros. It's black magic, as far as I can tell.
I might agree that rust is a little bit more difficult to write, since you have to satisfy the compilers safety requirement. But I don't consider it harder to read. Well written Rust code often ends up being easier to read for several reasons. Ex: Clear syntax, Little boilerplate, elegant error handling. Although sometimes it is not clear what types the compiler has inferred for variables, but tools like IntelliJ Rust can help you with that.
But the same can be done with `let old = mem::replace(&amp;mut x, Some(3));`...
Thank you it works now! 
&gt;This redesign is not a new development, mind you -- I've heard of it happening as far back as a few months ago, but it didn't seem to ever come up on public channels since, so there wasn't much of a chance to get involved. It's possible I missed it, but I've been following this sub for years, and the first I've heard of it was last week. But in any case, it's one thing to talk about doing a redesign, but it's another to start actually executing on it. We don't know what that timeline was, and I think it's in bad faith to assume they didn't care about feedback. 
Thank you for the answer! Ah okay, so I need to specify two lifetimes, one for the reference and one for any lifetimes within the referenced struct. Would it safer to store these as two separate lifetimes like in your first example? Here is engine (update with your suggestion) ``` pub struct Engine &lt;'a&gt; { renderer: Renderer&lt;'a&gt;, timer: Timer, } ```
cc /u/Amanieu
I'm interested in the buildpack also building my yew frontend (using `cargo web deploy`) (both are crates in the same repo, with a shared crate for API types, so that the backend and frontend always stay in sync) which should also benefit from the build cache. (And so that I can use rust-embed to embed the frontend files when the backend gets built.)
It seems like futures 0.3 includes the [`select!` macro](https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.10/futures/macro.select.html) that does (at least partly) what I did in my `join_streams!`, although I'm not sure whether this would solve the general question of how to *process* streams and futures concurrently.
AFAIK, those just use RLS, so. Code completion is more likely to work with "simple" code, but get anything complicated and it falls apart. Dare to involve macros and it just explodes. In my experience. If it works for you, great, but for a lot of people it simply doesn't work most of the time.
I learned of the redesign happening on Rust's official Discord server, when Steve Klabnik mentioned it in passing. I don't think there was any sort of announcement on Reddit until last week. You're right about not assuming things, but this is kind of what I'm trying to say: there was no information on this up until it was too late. I don't seek to pin the blame on anyone, but I think that this could (or, indeed, should) serve as a valuable learning experience about communicating between the core and the users moving forward. I don't want to paint this as an "us vs them" situation -- we're all on the same side here.
Sure, it says that, but it primarily says, and has fancy graphics to say, that rust embedded "is there", and is "easy". One paragraph at the end saying "By the way, we lied, everything above is only true for the one specific thing" hardly redeems it.
Thank you for the reply! I assumed it was identical to Python's `zip` and was wondering if it had to do with wrapping the iterator with parentheses or something to invoke `.zip`. 
Yeah, I think it's fair to be unhappy with the timing. But I also think we shouldn't judge too hard without knowing anything about the internal events that led to it.
I would recommend not having the entire website of `wasmer.io` be 3 lines asking me to run untrusted code on my computer. I'm also a bit confused as to how this is a company. Is this product going to be monetized somehow?
This is super awesome! I don't have much to say besides that.
Long time lurker, don't wanna step on anyone's toes, I just wanna see what people think. :)
The website also links to the GitHub repo, https://github.com/wasmerio/wasmer/, though it is on the side and there isn't a description so I agree with you there. I'd also be interested in how wasmer funding is planned.
Before piling more opinions on a topic that already has a plethora of them, I urge you to give Evan Czaplicki talk, "[The Hard Parts of Open Source](https://www.youtube.com/watch?v=o_4EX4dPppA)" a whirl. It's a big ask to watch a 45 minute talk before commenting on reddit, I realize, but it might help shed some perspective for the folks on the other side of this working with the goal to improve Rust's web site. If you've never been on the receiving end of a pile of users expressing their disappointment, it can be pretty daunting, and it is not sustainable for any individual I know. At some point, you've got to actually get something done. Not everyone is going to be happy, and that's OK. We don't always need to share every thought that pops into our heads. And certainly, even a project that *is* run by the community like Rust does not and should not require the community's input on every possible action. The governance model ultimately gives responsibility to teams---a large part of whom are volunteers---and it can be quite difficult to balance community input with the act of actually getting shit done. Sometimes, the community wants more say, but that isn't always feasible. At a certain point, as community members, we've got to understand that piling on isn't going to help. The teams are ultimately going to decide what is fair game to deliberate on, and more than that, they *must* decide on that if anything is to get done. Communities require some amount of trust in order to work, and I think the teams' track record has proven more than capable for responding to community input *over time*. Not every piece of input needs action *or* discussion right this hot minute. I personally had no role in the new web site, so I don't actually speak for them. But I can empathize, and I think Evan's talk might be able to help other folks do the same.
Yeah, there seem to still be some other issues with RLS support. LSP itself is still pre-1.0, but hopefully things pick up.
That's paid though? Like €200 per year isn't it?
There has also been significant discussion about how this was rolled out on the Official User Forum: https://users.rust-lang.org/t/the-beta-rust-lang-org-pr-debacle/22778/92
Yea, I tried to use vscode+rls for a while but I keep ending up back at intellij because RLS was just crashing too much, and on seemingly simple crates (I consider myself a novice-to-intermediate rust programmer, so nothing I do is super-complex)
If you want the complete edition with all their IDEs and tools yes but with only CLion it’s €89 per year down to €53 per year. And if you do open source it’s free and other cases you can have a big discount.
If you do not specify edition in Cargo.toml, Rust will assume 2015. Therefore, you will have to use the old syntax for things (where syntax has changed in incompatible ways) and you will not be able to use any new features that have required breaking changes to the language (such as new keywords). Note that even in future Rust versions, as new features are added to the language, if they are backwards-compatible (which most new features will be), there is no reason for them to be limited to 2018. Therefore, they will be available in 2015 edition, too. Rust2015 will keep getting updated. So yeah, if you don't specify any edition, you are using 2015, just like before, and you can keep using 2015 indefinitely into the future. You are not forced to use 2018. You only need to specify 2018 if you want to use the specific new features that are 2018-only.
This is an excellent comment and call to decency, regardless of how one feels about the new website.
The primary use-case, for me, is that cargo should be a good build system *for rust*, and sometimes you need to do stuff after building, no hassle, that works for anything Rust targets. Adding another build system *just* for post-build is an unacceptable dependency, and not cross platform or portable. Adding an entire programming language just to build your own build system that wraps cargo just for post-build is even more unacceptable. Using some sort of fake binary and bypassing cargo build is just insane, and doesn't work if you have a binary yourself anyway. Specifically, I work on windows applications, and at the very least they need to be packaged with their DLLs to even run, let alone building their installers for distribution. I also have a small hobby kernel, and after building i need to be able to combine the kernel and bootloader so it can run in qemu. In my opinion, post-build doesn't need to be anything fancy. The ongoing [issue](https://github.com/rust-lang/cargo/issues/545) on them suggests naming them `final.rs`, and i'd be fine with that. Post-build scripts should be final binary only. If libraries ever need post-build actions, they should provide a way for the final buildscript to do them, if it wants to.
Yes, that was extremely well-written and clear. Thanks!
That's the same series the OP is already following.
In my testing, Rustdoc *does* see a difference. If my source code contains: pub struct Foo&lt;'a, T&gt;(&amp;'a T); pub struct Bar&lt;'a, T: 'a&gt;(&amp;'a T); Then the docs also show the `T: 'a` bound on Bar but not Foo.
I am literally writing my first ever Rust program and the Intellisense just cannot infer anything; it always defaults to a list of everything in global scope.
Probably not the most popular opinion out there, but I cannot even discuss Rust in my industry (fintech) until there's a 1.0 (yes, not only stable, but actually numbered 1.0+) Oracle driver with support for connection pooling. I'm not a fan of Oracle, but fintech is just heavily tied to it, and will be for another 10, maybe even 50 years. There are other items that legacy industries like fintech need at a pretty stable, supported, and feature-complete stage: XML, SOAP, tracing, metrics, etc. None of those things are mature at this stage in Rust, and since they're not hot tech, they're not likely to advance significantly. I'm not saying it's the community's responsibility to fix this, but still, it's a significant barrier.
&gt; (One issue is the fact that the code the macro generates might not be for the same edition the macro is written in, for example.) Huh, i never thought about that. How is rust handling cross edition compatibility in that situation? Or is it not?
It is by no means my intention to put under fire the people who have worked on the redesign. I merely wish to discuss the process by which we have ended up where we have. It just seems to me that this issue could've been nipped in the bud by better communicating with the broader community. I agree with your point about not requiring community input on every little thing. But in my view, trying to cater to every little (often contradictory) request is not the same as understanding the desires of your target audience. From my understanding, a number of people (not going to speculate on the proportions) did not even know about the redesign being in the works. I think that if people had a chance to look at the thing early and say "I like this", "you could tweak that", then at least you would have a framework you could base your judgement upon. Doesn't mean that you have to use it -- you still have a vision to follow, and you can't make *everybody* happy, but it's a useful tool nonetheless. Instead what seems to have happened is (and I'm speculating here, so feel free to disregard the following) that the team went in blind, and made a hit-or-miss proposition that (mostly) missed. It happens, we can't always predict the future. But we can at least estimate. I think it's pretty common knowledge by now that short feedback loops allow projects to better satisfy the goals they set out to achieve. Even in Rust proper we have nightly, where the team has the chance evaluate really wild out-there propositions, iron out the wrinkles, and most importantly, take things out if they don't work out as well as they had hoped to. Instead, the website just got dropped on us without much prior notice with the implicit understanding of "sorry, it's too late to change anything substantial now". This seems like a big outlier to how things are generally done in Rust, but I'm not well informed in that regard, so please take it with a grain of salt. And I generally agree with you that team responds well over time -- it's just I would wish for that time to be before hitting production, not after. A website is easy to repair, but trust is not. I understand that it sucks for the people involved in it, and I don't wish them ill, but this is not really about them or their feelings. Again, I would like to emphasize that this is about the process. And I think there's a lot to learn here about what went right and what went wrong going forward.
Thanks, ill read
&gt; timed to go up with Rust 2018, so the schedule was tight Funny, isnt our release model and everything supposed to avoid those kind of "tight deadlines" and "rushed stuff"?
Seconding this, just saw them and *damn* are they ***good***. Also the second one with the different colors, which i favor more than the blue. It's really a shame they cared more about timing it with the 2018 edition release than having a good website.
To be clear, my comment was not asking folks to stop putting others under fire. I wasn't even asking y'all to be polite. You are already being polite and kind. :-) What I'm really trying to get at here is that we should try to adopt some perspective. Allow things to run their course and put a bit more trust in the Rust teams. We don't need to deliberate and re-litigate over and over. I don't want to get into a deep meta discussion over this. I'm not trying to rigorously debate whether folks should be talking about the website issue. Instead, I'm encouraging some self reflection on the kinds of things we put out into the Internet.
Thanks for bringing it up. I don't frequent that forum so I was not aware of prior discussion over there.
Somehow I wouldn't be surprised to find people lacking proper taste for simple and compact designs...
Issues should be on the rust repo or the rustfix repo?
I think your feelings are probably founded in something real, but you need to communicate your issues properly and not to some random comment like mine at the bottom of a reddit post. Otherwise you just come off as aggressive with no benefit to yourself.
I wish it explained triangular probing. Otherwise it's an excellent writeup. &amp;#x200B; You may want to try out my interactive implementation of Robin Hood hashing: [http://pczarn.github.io/code/visualize/dist/](http://pczarn.github.io/code/visualize/dist/)
Thank you!
I find redesign of Rust website has same vibe as redesign of Yahoo logo by then CEO Marissa Mayer. Most of the feedback was meh but people in charge felt a sense of great accomplishment as they have dealt with critical issue their company/project was facing.
You nailed it. This is why I've written almost no Rust code in the last year. I'm waiting for the transformative features I know are coming, because my time is better spent on other parts of my life than building something I know I'll just end up rewriting, were I to build it now.
I do totally agree. I have the same feeling. Some colors seem not to play well together. The black footer really hurts eyes, the contrast is very high. The headers are hard to read, because of the line on background (It's much easier for my eyes to read sub headers, than headers with the line). &amp;#x200B; However there things that are done well (in my opinion): * The icons - I think they're cool and quite expressive. * The site is now more informative and has more content 
rearranging the print statements is not really a solution I am looking for. I just wonder how easy it is to manage the memory manually in Rust. -&gt; allocate chunk of memory and use it, without using alloc and free provided by rt or os. (say in a loop) 
Just to clarify my position as well, I'm not demanding for immediate redesign of the redesign or anything like that, and I would imagine, neither are most others. But while this is not an urgent issue, I think it's wiser to reflect upon it to prevent this from happening again than to pretend it didn't happen and try to awkwardly move past it. I understand that you might not be interested in this. For me, I originally posted this because it was something I felt strongly about and didn't see any prior acknowledgement. So... agree to disagree? :)
I want to echo the same thing some others have said: RLS. I'm new to rust, and while I am really enjoying it so far, I **really** miss the level of language integration you get with java + intellij or c# + visual studio. Being able to refactor and have it not say "Rename failed: no information for symbol" would make me so happy.
Depends. In some cases, like https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=query, Rust is the fastest. In other cases, C will win. It's probably easier to write fast programs in C than in Rust (Lots of people default to heap allocation to beat the borrow checker). Yes, Rust is multi platform. https://forge.rust-lang.org/platform-support.html
I wish it described probing through triangular numbers. Otherwise it's a decent writeup. &amp;#x200B; You may make educational use of my interactive implementation of Robin Hood hashing: [http://pczarn.github.io/code/visualize/dist/](http://pczarn.github.io/code/visualize/dist/)
Thanks for the quick response. Exactly the resources and info I was looking for. I appreciate it!
`Rc` and `Weak` is wrong answer too. /u/gotakk You want: https://gist.github.com/rust-play/51060e1843b5a837fe38f812a5a374f6 
Rearranging the print statements was necessary because, once updated to use `&amp;mut T` instead of `*mut T` your `TheThing::Alloc` method returns a mutable reference to `TheThing`'s inner state, and only one such reference can be useable at a time. That's just how the borrowing rules work. And `Vec`s aren't really designed for manually managing memory. they're RAII containers first and foremost. And while you *can* contort them enough to work for that purpose (as demonstrated by this example working at all), you're probably better served by using `std::alloc::{alloc, dealloc}` instead since those better reflect what you're actually doing.
I did explain in more detail at the top of the thread. I'm not sure why replying to a comment, in a civil tone, is aggressive but no aggression was intended - just disagreement. If you agree that this is a common complaint at the end of the year with rust, I'm unsure as how you see that as the leadership having their priorities right. If they did, these issues wouldn't be coming up repeatedly in my view
&gt; everybody needs to stop with the 0.x versions. I don't know how you can be serious about this? If you don't feel that your library is in shape for a 1.0 – especially if you think your API is about to change significantly – what benefit could this possibly bring to the table? I would say it is pretty harmful because now people think "great so many ready to use library" and three month later everybody is really upset because it was just false advertisement. I value honesty more than pointless advertisement that tricks me into using stuff that is not ready and makes me think it is. And if people say to me straight to the face "that's so encouraging that you like my library but to be honest its not in the shape i want it to be, please revisit if i feel more confident" i am likely to actually revisit. But if somebody says "It's the best thing you will ever get in your life – use it now until its out of stock, this is a once in a lifetime opportunity ... " and it does not live up to the hype you have a hard time to regain my trust ever again. So in all honesty i can't see how this is useful in any way looking at it seriously. I give you the benefit of the doubt – but one can also interpret this line as "work faster, i wanna see more 1.0" but i hope it was not meant this way. 
I'm not sure there's much to add. The team in charge have made clear their views and which views they'll accept as criticism and which they won't. 
&gt;at this time we're not looking to remove the colors wholesale from the website. It tells you all you need to know, smart-ass designers don't care about your opinion or whether the new design is utter shit for professional people
&gt; smart ass-designers *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
The 2018 edition would be a reasonable exception to this, since it was a very large release. It makes sense to me to want the "new edition" to go along with a new web site.
Hey, I'm gonna Reddit chat you if that's okay.
The new design wasn't made for users, but rather it was made for PR, to make Rust modern, hipster and "cool". Does it attracts users? Sure, old users like me, who preferred old web site with focus on delivery needed information can complain. People that have weak eyes will enjoy bleeding. And some hipsters will appreciate aesthetics Win-win
Copy `Instruction` instead of borrowing it. It's barely the size of a pointer, borrowing has no benefit over just copying something so all. Just derive `Copy` for it and call it a day.
Cool project! I few suggestions to make to borrow checker happier. The function that runs your main loop should own the CPU struct so you can then lend it to each function instead of giving away your reference to the first one. Also you can't store a reference to the CPU register in the instruction struct then borrow it again. Alternatively you could pass just the instruction to execute then increment the cycle in the loop. Hope that helps. 
The biggest problems are it's lighter on technical content, and it looks like http://adventurega.me/bootstrap/ . Doesn't actually seem to use bootstrap though, and is static and very light on resources. Just needs actual content instead of marketing.
Not the best code, but I would do it [this way](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=139542ecf06d645f080a12bb90e097fd).
&gt;C++ is great too obviously but in terms of speed, C takes the cake. If you actually learn to write C++, it would be equal in speed to C The same goes for Rust
I fully agree with this. We should build on what we have now, and let the ecosystems mature: - Continue building and improving libraries - Get a mature embedded ecosystem up and running, now that we can *finally* run on stable - Figure out GUIs with Rust - Continue making WASM awesome - Implement existing RFCs - Refactor / improve / extend the compiler without adding new features There's one exception: async/await definitely needs to land in 2019. My perception is that the networking / async world in Rust is a bit in a limbo state: There's futures 0.1 and 0.3, there's async/await, there's hyper, and they all don't really fit together perfectly. Everybody seems to wait for async/await. I think this is *the* feature that needs to be done in 2018.
It's tricky: - Issues with the suggestions being wrong/missing: [rust-lang/rust](https://github.com/rust-lang/rust) - Issues with the cargo command not working: [rust-lang/cargo](https://github.com/rust-lang/cargo) - Issues with suggestions being applied in a wrong way: [rust-lang-nursery/rustfix](https://github.com/rust-lang-nursery/rustfix) I expect most bugs to be in the first category. Feature requests for the cargo command fall into the second one. The third is a relatively simple library, but does the actual replacing of parts of your code.
I agree but I would be nice if more crates were at 1.0 maturity. 
Sure but we don't get there by just labeling it 1.0 instead of having real maturity. 
I… actually don't remember. There's [an open issue](https://github.com/rust-lang/rust/issues/52038) on _Edition hygiene in lints_ that contains a bunch of links to other issues and PRs you can follow if you're curious.
Oh most definitely 
I think it's fine for Rust team to do whatever they want with their website, but it's hilarious to read their Governance page how they promote "community-led decisions" as one of the biggest factors for Rust's awesomeness while the same community was overwhelmingly opposing the website where this is written yet they were completely ignored
Even just going through the accepted RFCs will see significant changes to the language, with async/await, generic associated types, and const generics (to name three things I’m looking forward to). I’d love to see a significantly heightened bar for accepting new language RFCs for a bit while we learn what it’s actually like to use both the language we have and the language we’ll have after these RFCs are accepted.
I´ve derived Copy but rustc says `&amp;'a mut u8` does not implement Copy. If I replace `&amp;mut u8` with `u8` I won´t be able to update the data of the register during the execution of the instruction. 
I fully agree, what a great post :) It's fascinating how much optimizations can go into a data structure.
I'm reading along through \[this\]([http://www.goldsborough.me/rust/web/tutorial/2018/01/20/17-01-11-writing\_a\_microservice\_in\_rust/](http://www.goldsborough.me/rust/web/tutorial/2018/01/20/17-01-11-writing_a_microservice_in_rust/)) tutorial on [hyper.rs](https://hyper.rs) and got stuck on a compiler error. &amp;#x200B; \[Here\]([https://gist.github.com/gDelgado14/73d8d838e15c7f4cf6bfdbcbd81a7a6a#file-main-rs-L41](https://gist.github.com/gDelgado14/73d8d838e15c7f4cf6bfdbcbd81a7a6a#file-main-rs-L41)) is a gist that links to line 41, which is the source of the following compile error: &amp;#x200B; \`\`\` the trait \`std::convert::From&lt;std::io::Error&gt;\` is not implemented for \`hyper::Error\` \`\`\` &amp;#x200B; What confuses me is that the docs for hyper state that the \`Error\` struct implements the \`From\` trait for all \`T\` ... see link \[here\]([https://docs.rs/hyper/0.12.17/hyper/error/struct.Error.html](https://docs.rs/hyper/0.12.17/hyper/error/struct.Error.html)) &amp;#x200B; Can someone explain to me what is really going on? 
Please consider watching the talk I linked. Your comment isn't helping.
Thanks, owning the struct helped. I assume that the main idea is that an owned argument is able to "create" any number of mutable references while a mutable reference is only able to be handled to a single function. &amp;#x200B; Regarding storing the CPU register, would it be possible to copy the instruction enum and borrow it later?
Did some digging and looks like it was resolved in [this](https://github.com/rust-lang/rust/pull/56053) PR? but i havnt looked at it too closely.
If a function owns a piece of data can make one mutable reference to it at a time. So if you give that reference to your Instruction you can't make another until the Instruction goes out of scope. Before your function had a mutable reference that it gave away ownership of. Does that help? 
*eyes [ibm plex](https://www.ibm.com/plex/)*
&gt; my idea is to borrow mutably self.register.B in order to update it during the execution phase. As far as I know the lifetime of the variables is the same as the lifetime of the CPU instance but don´t know how to express this. That's reasonable, but at that stage my question is can't you make `instruction.execute()` be the method to be called instead? After all if the instruction has already borrowed everything it will need to run, you don't need the CPU at all. &gt; `0x06 =&gt; Instruction::LD8(&amp;mut self.register.B, self.fetch(), 4)` The problem is that you're borrowing twice to construct it, not the lifetime of the result. Try: 0x06 =&gt; { let arg = self.fetch(); Instruction::LD8(&amp;mut self.register.B, arg, 4) },
Completely, now I understand. Thanks.
At this point it´s reasonable to make `instruction.execute()` but in the long run it´s not feasible as the execution of some instructions will need to access RAM, update CPU flags, access IO registers, etc. That´s why I want to pass a reference of the CPU to the execution method.
I've never had the need for post build steps, but now I'm kind of curious. What would be the use case for that?
Finally I get a reference on where SIMD is actually useful using a real-world example.
This may sound negative, but I'm just curious: If Rust had everything you describe, today, would your company drop the whole C# ecosystem and adopt Rust? I have a hard time seeing Rust thrive in this .Net Core/Java backend land, but I'm not familiar with it, so I would love some insight from a developer that's working there.
One approach is to separate the state borrowing from the instruction decoding. For example, in j2gbc I have an [Operand](https://github.com/Nitori-/j2gbc/blob/master/j2gbc/src/cpu/register.rs#L29) type that the [instruction](https://github.com/Nitori-/j2gbc/blob/master/j2gbc/src/inst/load.rs#L9) stores. Then when [executing](https://github.com/Nitori-/j2gbc/blob/master/j2gbc/src/cpu/mod.rs#L446) in the CPU I use [read_operand and write_operand](https://github.com/Nitori-/j2gbc/blob/master/j2gbc/src/cpu/mod.rs#L586) to figure out what to actually borrow and modify.
Someone should submit an RFC for this.
The website had tons of community people involved, especially all the working groups. We all agreed on the design.
&gt; probably easier to write fast programs in C than in Rust I'm not sure I buy this.
But, this has just became python 3 now. It's is like using new language. I think we should just be able to use 1.31 features what ever edition we are in
Game development is a few different worlds, with a few different sets of needs. Indie/hobbyist developers may need a full game creation toolkit. Established commercial developers need legit console support. Both groups probably need seamless android and ios building and deployment. I haven't used or looked into Amethyst, but I know it wouldn't help me at work and I wouldn't want a game development WG to tunnel vision on only one set of needs.
Doesn't make any sense to me to make such a big downgrade to the website.
You can translate C 1:1 into unsafe rust. it should be the same speed, unless there are details of codegen stopping that (which would be fixable)
Definitively much better than the current site, but still a downgrade from the site we had imo.
The following sounds combative and a bit rude, and it's not meant to, but I believe this is a real issue that is holding back adoption of Rust on a larger scale. I do accept that I might be wrong, but I want to put it out there anyway. First of all, I'm certainly not saying "work harder, open source programmers, I demand a final version!" But look: coming into this space as an outsider, three years after Rust 1.0, which was the 2015 Edition, and catching the excitement around the 2018 Edition, I'm telling you there's something weird going on with all these 0.x version numbers. It's like a cultural thing. There is software written in Rust that is out there being relied on by millions of people in production environments. Firefox Quantum has 250 million users. Linkerd 2.0 is GA and in production Kubernetes deployments. Microsoft, Oracle, Cloudflare, IBM, RedHat, DropBox and Sentry are all using it for real projects. And yet, where possible, go look at their Cargo.toml files. Tokio is still on 0.1. Bytes is on 0.4. Hyper is on 0.12. Log is on 0.4. Rocket 0.4. Actix 0.7. Futures, which is surely going to be part of `std` before `async`/`await` lands in stable, is on 0.1, with a 0.2 that you're not supposed to use and there's a 0.3 coming soon? I think it's viral. If your project uses Bytes, and Bytes is still on 0.4, how can your project be 1.0? If all those amazing Rust projects that do amazing things and power real, production systems are all 0.x, then who am I to call my thing 1.0? Is this honesty? Or is it a cultural shared habit? Is it just "the done thing" or "the Rust way"? Like I say, this is an outsider's observation. I'm a C# developer. In the last three years I've used .NET Core 1.0, 1.1, 2.0, 2.1 and now 2.2, and in 2019H1 I'll be using .NET Core 3.0. I've used NuGet packages which have spanned similar version increments. I maintained an open source .NET project where I literally had people ask me to go from v0.19 to v1.0 so that their boss would sign off on using it. 1.0 doesn't mean "this is finished and I'll never change it." It means "this works; this is good enough for you to start using it, and if anything's broken I'll fix it in 1.0.1, and I'll be adding some new features in 1.1, and if I want to make any breaking changes there'll be a 2.0." Obviously in the Rust community things are different, but to an outsider, it looks like maybe nothing is really ready yet. And if none of the things you need in order to get your job done are ready, then maybe Rust isn't really ready, either. I know it *is* ready. I know Rust is a brilliant and powerful language that gives programmers tools that they've never had before to build software that is more stable, more powerful and more elegant than almost anything else out there. But I'm the kind of programmer who will happily use version `0.0.1` of something if it looks cool (I've been using .NET Core since it was DNX 0.3, after all). Most programmers aren't like that, and even the ones who *are* have to get things past their teams and their bosses and their decision makers before they can use something on a real world project.
It has been two weeks. The new site is still awful.
The new website contains more targeted information than the old one. As far as I can see they copied some of the structure of the [rocket](https://rocket.rs/) website which has recieved much praise. I like that. On the other hand the css should possibly be tweaked to work on a laptop with a small screen. If I press ctrl-- to zoom out out to 80%, then it is easier to read.
Source? What do the top 10 contributors https://github.com/rust-lang/rust/graphs/contributors to rust think about the new site?
I actually really like both the font and the (plex) site. Can't say the same about the new rust site.
They did have the community involved, it's just they've redefined "the community" to mean the in crowd who won't say anything too negative for fear of upsetting a friend
Big changes require even more responsibility than small ones. There's no way they should be rushed, especially in a project like Rust where, as far as I can tell, the deadlines are self-imposed.
Absolutely agreed, but I think it's important to distinguish between the level of care required for a programming language vs a web page that's mostly informational. Let's not conflate the two.
Is there anything in America not ruined by capitalist corporations? And I say that as someone who is a capitalist
You're right, the web page is not really that big of a deal in the long run. I guess the concern is that rushing it out _could_ indicate deeper issues.
It's pretty easy to hand optimize C/C++ for SIMD without needing intrinsics. It's not easy to do that in Rust without unsafe blocks. 
I've seen this idea about async/await expressed probably dozens of times in the last few days. I'm not objecting to it exactly. I'm just interested in where people are coming from. Look at the first code example from the [mio docs](https://carllerche.github.io/mio/mio/index.html): what about that is so hard? I don't think I'll ever understand why people find it easier to think about async if it looks and feels synchronous, but occasionally it will bug me enough to ask why, and today is one of those times.
There's a subset of the Rust gamedev effort getting organised at [https://github.com/rust-console](https://github.com/rust-console) whose sole purpose is to work on console support. Nintendo Switch will soon be added to the list. I don't think we'll tunnel vision on only one set of needs any more than the Tide project will. The purview of the Rust GDWG will of course extend beyond that of Amethyst.
A 0.x version indicates API instability, not necessarily quality. Developers are responsible for knowing the true quality (documentation, reusability, test suite, benchmarks, maintainability) of a dependency. These version numbers are the way they are because people intend for their API to break and don't want people to get the idea that they can rely on it not changing for a long time. I think this is useful information. We use semantic versioning specifically because its useful to developers and for Cargo to find compatible versions. I feel confident that serde is stable. I don't feel confident that rand is stable (it keeps going through new versions and is 0.x). I expect that when rand is 1.0, if I implement its traits I wont need to worry about it breaking.
I'm on mobile, but an obvious thing I see here is that your function isn't declared to return anything. In your function declaration add in ` - &gt; u32` See https://doc.rust-lang.org/rust-by-example/fn.html for an example. 
1. You're forgetting the return type in the function definition; 2. `parse` functions return a `Result&lt;...&gt;`, so if you just want the `i32` you have to call `unwrap` or something similar; 3. You're **moving** `user_input` into the conversion function, you should probably just take the `input` by reference like `input: &amp;str`; [Link to a modified version](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f920258c8289e78de642a6671be2eb13) on the rust playground.
If the issue wasn't urgent why change the site in the first place? What was so wrong with it?
I have. Duckduckgo site redesign for example received almost universal praise.
That is what it means, technically, but there is a huge difference between *showing* and *telling*. If you show me what a tool can do, I can judge for myself. If you tell me, it starts to feel like a sales pitch. Also hopefully Rust's people will realize the difference between making the language approachable versus dumbing it down. We don't need another Go.
Has there been any explanation as to why the feedback was ignored? And it was. The usual folks that I respect so much were notably absent from the threads here and on Hacker News. Meanwhile, there were no substantive changes made to address the nearly universal core complaints. And then radio silence. And radio silence on the Discourse. It's sort of disappointing. None of the feedback, that I've seen, has been personal or hypercritical. All have come with good intentions and have the community, new users, and evangelism in mind. Further, I still contend that the redesign failed to actually address any of the functional shortcomings of the site. It feels like a redesign as a Rust 2018 marketing push and that's an extra layer of disappointing...
All code at wasmer is open-source and will always be so.
I must say that I absolutely *love* the new colors. I have some problems with the layout though (too much space between the elements), but there was already an PR to remove that and it was only reverted because it caused issues.
How? You have to scroll miles once you get to the IBM text to get to the next page, unless you scroll up and notice the bar and go directly to concepts, for example. The text *wraps*, is way too big, half the screen at the top is empty space! And the lines..
Hmm. What resolution are you viewing the site at? I just realized that the colors may be more of an issue the more of the page you can see at once.
The web page *is* a big deal though. How is information about the language not a big deal? For many, it's the first they hear of Rust. They hear about rust, check out the page. Their first interaction with the language. And for a lot of people, that first interaction determines whether they look into it more. It looks like garish generic marketing speak right now, not a professional programming language website. Especially compared to every *other* language's website. It doesn't even have any code examples! A lot of people would take one look at that and decide not to look further into Rust. If Rust wants to market to companies, fine, great, but they should have their own dedicated page. The landing page should be targeted towards programmers, potential Rust users.
That is referring to the blanket implementation `From&lt;T&gt; for T` in the std library (click src), it's not saying that you can construct an Error from anything.
Having worked in C# frontend/.Net backend/Java backend for big (and small) enterprises, I would think that there would not be a large rush to move to Rust. The Java and C# ecosystem, development tools, and mind-share seem to be too great to ignore and I would imagine that dev managers consider those features to be more vital than Rust performance improvements and "fearless concurrency". However, I think (and I think others do, too) that it really can win a debate of "OK. We wrote out all this GC language code and now we know we need a really optimal service written in C/C++/Rust to help it all scale. Which do we choose?" And maybe with better tooling and more mature concurrency features, it can further edge into the backend space.
I am currently just beginning work on a game using a combo of Rust and Godot, which calls the linkage GDNative. There is a great crate which made this very easy for me. Personally I like the idea of Godot as a great open source engine for those who want a free (as in freedom as well as cost) alternative to unity.
Underrated comment
Thank you for the insight. &gt; we need a really optimal service written in C/C++/Rust to help it all scale. I can totally see Rust winning ground here. &gt; further edge into the backend space Wouldn't this be hard to achieve though? Even with better tooling (and frameworks), Rust still takes more effort to learn (and use properly) than your C#/Java/Ruby and so on (not trying to say that language X is easier). My view of webdev is one of a field that is fast moving, isn't Rust a little too strict for it to be heavily used there?
To be fair to Bootstrap, its main crime is making it so easy for magazine ad designers to design websites. If you want to use it as a widget toolkit for the web, *a la* Qt/GTK+, it serves well for that too and that's how I use it.
All of C is an unsafe block lol
Besides making as many things derive `Copy` as is practical, you can probably design it in a way that `fetch` and `decode` only need `&amp;self`, and then `execute` will be the only `&amp;mut self` method out of those three. You just have to think; what methods *should* modify the CPU state? A fetch only reads data. Decode is a computation on the data it read. The only part where you actually need to change state is when executing, because that's when registers, flags, program counter, etc, change. At least, that's the ideal case.
I’ve looked at it on small screens (my phone; 15" retina MacBook) as well as on big screens (27" 2560x1440)
&gt; I think it's viral. If your project uses Bytes, and Bytes is still on 0.4, how can your project be 1.0? If all those amazing Rust projects that do amazing things and power real, production systems are all 0.x, then who am I to call my thing 1.0? Only when you use `bytes` in your public API. This limits the need for 1.0 to crates that are "vocabulary terms", ways for crates to talk to each other. Tokio and log are great examples of this.
Nah. Go is thriving in the backend space. Rust is much faster, safer, and after the intial steep learning curve, actually easier to code. (In go you write a bunch of boiler plate over and over and over and over and over...). Particularly for serialization deserialization. Serde in rust and the derive macros are basically magic compared to go’s generation. Rust is lacking go’s super easy asynchronous syntax. But once that’s solved, it’s rust for me all the way. 
 [`path` attribute](https://doc.rust-lang.org/reference/items/modules.html#path-attribute)
And yet your comment isn't so helping: &gt;&gt; thanks for the feedback. if you'd like to open a PR to reaarange some of the color backdrops on other pages that'd be great and i can give feedback on the PR directly. So, PRs were opened. And? Nothing. &gt;&gt; hey! thanks for filing. &gt;&gt; &gt;&gt; at this time we're not looking to remove the colors wholesale from the website. it is true though that some pages may have unfortunate color combinations, and we are open to hearing that feedback! if you could be specific about which pages you'd like to see changed and to what (giving the existing styles for sections)- we'd be very open to working on improving that! thanks :) &gt; Open, open. And yet the website is still eyebleeding. 
Dunno, dunno. With such a logic there's no need in `std::prelude` either. Or macros. Or generics. Or whatever - we always can go deeper and type more.
The two *are* identical: &gt;&gt;&gt; for (a,b) in zip(range(5),range(5)): ... print("a:{}, b:{}".format(a,b)) a:0, b:0 a:1, b:1 a:2, b:2 a:3, b:3 a:4, b:4
So the only way to help would be to either praise the new design for now reason, or say some "wise" words on how you should understand that Rust team is not going to care about opinion of everyone? There is no way to be helpful when we were already told that colors are not going to be removed, despite being bad and unprofessional
I see some good crates that are stable and usable but in the 0.x state. The same annoying thing happened in node.js. Like come on, you haven't broken API in over a year and yet still in 0.x version.
Last time I tried it it wasn’t possible to benchmark binary crates in criterion.. Is this still true?
&gt; after the intial steep learning curve, actually easier to code This rings so true that I wish there was a way to convey this to people, instead of having to add "Trust me!".
Wow, that is a great post. As an outsider (about to start learning Rust) I often asked myself why the adoption was not much higher. Rust is very popular by undoubtly smart people (yeah, kisssin ass :-)) but didn't have its breakthrough party yet like Go and Kolin (Android). Rust might be seen by many as an academic language, not an industrial one. The perception is that Rust isn't finished yet (which is actually true). Why sould I use / buy something unfinished? The continuous development / improvement of Rust is counterproductive here. The "plan, build, run" theme is boring but true. People who "build" are not the best to "run". I'm a build person and more often than not need to be pushed into "run"-mode. Some crucial features need to be added (mainly async await) then the "run"-phase might be more explicitly emphasized. &amp;#x200B;
You're talking about hand-optimizing and SIMD... okay, but that doesn't sound easy in C either. That's very different from "heap allocation to beat the borrow checker", which I suspect clippy would help alleviate. If you're not a C expert, it's going to be far easier to build something fast in rust than something fast in C. There are plenty of examples of fast rust programs (rg is the obvious one). I would say it's the maintenance burden of C vs rust programs where rust really shines.
Well, many people would argue Rust is ready for production and was for a long time. That even Rust 1.0 added enough value to be a viable replacement for other choices. But paradoxically, this is the downside of a language with huge potential. It's not how good the language is today, it's *how good it could be tomorrow*, that stops many people from using it today, due to fear of volatility and being caught in the ecosystem churn vortex that would follow. Compare this to a language like Go, which not only has less features, but largely reached it's maximum intended capability on original 1.0 release (at least before Go 2.0 arrives), with only very modest changes in later versions. In addition to other reasons people would choose it (simplicity, fast compilation, etc.) the mere fact it "reached peak" on release can be seen as a blessing, rather than a curse, because it paves the way for stable, long-term tooling that won't churn as rapidly, forcing you to keep up with never-ending rewrites and migrations.
&gt; but that doesn't sound easy in C either. It's not that difficult. Since the call for Rust 2019 I've been wanting to write a "why *not* Rust" post targeting my particular industry (pro multimedia software) and this is an example I was playing with today. And C isn't the competition, C++ is. Take a dot product (C or C++, code is basically the same) float dot (const float* lhs, const float* rhs, int N) { float accum = 0.0f; for (int i = 0; i &lt; n; i++) accum += lhs[i] * rhs[i]; return accum; } And in Rust fn dot (lhs : &amp;[f32], rhs : &amp;[f32]) -&gt; f32 { let mut accum = 0.0; for (l, r) in lhs.iter().zip(rhs.iter()) { accum += l * r; } accum } If you check that on godbolt you'll see the generated assembly with compiler optimizations is just about the same, with the addition of bounds checking in Rust not present in C/C++, and neither use SIMD. However, if you wanted to "hand optimize" the C/C++ code to make use of SIMD if the target supports it, it's not that hard. One thing you can do is split the loop into a head/tail section float dot (const float* lhs, const float* rhs, int N) { float accum = 0.0; int i = 0; for (; i &lt; N; i += 4) for (int j = 0; j &lt; 4; k++) accum += lhs[i + j] * rhs [i + j]; for (; i &lt; N; i++) accum += lhs[i] * rhs[i]; } There's some more you can do there (and this just illustrates the idea) but the compiler is smart enough to unroll the inner part of the head loop, then use SIMD instructions for the add/multiply. On some targets it can do that in a single instruction. Now if you did the same thing in Rust (of which there are a few ways) as far as I've tried you will wind up with a bounds check inside the inner portion of the head loop, and once it gets unrolled there is no SIMD optimization available to the compiler. So you need to rework the code to make use of unsafe code, using raw pointers (and no slices). The code is more complicated, and takes more massaging to get to the equivalent result. I have codebases littered with these kinds of optimizations, where you're not actually calling intrinsics or platform specific code. Rather you're writing code with some additional knowledge that the compiler can't infer. You can't really do the same thing in safe Rust, and the workaround requires more complex code with raw pointer arithmetic just to get the same speedup. There's more examples of this kind of trick, especially using `constexpr` and templates to conditionally compile code based on knowledge of the size of structures to make things more SIMD and cache friendly without resorting to platform specific intrinsics or libraries. It's not difficult once you know what it looks like, and until we have better ways to deal with it in Rust (const generics being the big factor) and a smarter compiler, it will be easier to write optimized code in C++ than Rust. 
This is such an amazing post. I feel like if this is paid heed to then 2019 would be he "turning point" for rust. Just make things work 100%. Take out all tooling from beta. Make GUI work. Don't do anything new. Take a year off and see usage patterns. (I know I'm repeating but I loved the post) 
New design is really bad. That is why developers should not work on design :) All this enormous bold headers looks like a total mess. The intention was good, but I think that team should really try to work with good designer, so he/she can fix all visual problems.
You are aware of the fact that most of these are either not with the project anymore or _are_ indeed working group leads/members? Source: me, I was part of the planning and production of the website.
This is a pretty big accusation, just sayin'. No, I like the design, other people involved also do. All our production process can be seen on the now open issues, I invite you to go through them and point me at things.
There was a designer involved.
Link the crate? I'll start gamedev on Godot with Rust too, so that would be really helpful!
What do you think about the simd crate?
How fast is Rust’s HashSet? Why do you expect sort+dedup to be faster?
If you use assertions, the compiler can actually optimize the bounds checks. Also I think there's an unchecked access method to slices, but I don't know if it's unsafe. 
I strongly agree with your preference for libraries over frameworks. Look at something like Yew and other projects in that space. There is room for exactly zero code reuse between them. Still no best-of-breed virtual-DOM library, or html macro. Unfortunately, it is starting to look like some of these things can only really be ergonomic through being part of a framework, rather than a library. Or connecting the functionality to the rest of the framework requires writing making it specific to the framework. Etc. I really hope this is not actually the case, because if Rust really doesn’t support code reuse in these instances, I have to question whether it will ever have a healthy ecosystem. NB. While I’m not very active, I’ve been using Rust for hobby stuff since late 2014, so I’ve invested quite a bit of time in it. 
Oh oh oh, if you are teaching your kids Haskell, please try https://code.world
Having a great text layout library and a great font rasterization library is not only useful for Servo, but will also have big implications for UI development with Rust in general, something that basically doesn't exist right now but could be huge in the future. It could also be a small nudge forward for game development in Rust.
I have some code generated (by bindgen) which has function pointers represented by Option&lt;T&gt;. pub type SomeFnPointerType = ::std::option::Option&lt; unsafe extern "C" fn ( /* .. large number of argument types .. */) -&gt; /* return type */ &gt; ; Now I want to store the contained value in large number of such functions after .unwrap()'ing them, in a structure. How will I define this structure ? Because the above code is generated, I cannot 'refactor' it. I want to do something like this (in C++'ish pseudo code, using decltype) : struct FunctionTable { decltype( (None as SomeFnPointerType).unwrap ()) unwrappedFn ; /* ... */ } or maybe just **SomeFnPointerType::T** if that is allowed. Is it possible to achieve that in Rust. If not, the only way I see it is to manually define those types by copy pasting code from the generated file into a separate hand written file and maintain it.
Only fresh pages from the allocator can be "efficiently" zeroed, and this can only be done by doing tricks by sharing a copy-on-write page, which is actually a performance penalty when you expect to use the zeroed memory (which you would for any map).
Same with slogan as well. &gt; 01. Rust is a systems programming language focused on three goals: safety, speed, and concurrency. &gt; 02. Rust is a systems programming language that runs blazingly fast,prevents segfaults and guarantees thread safety. &gt; 03. Empowering everyone to build reliable and efficient software. 3th one is not unique to Rust, it can be used for any language. I still prefer 1st because it is simple and unique.
Found the answer on StackOverflow : https://stackoverflow.com/a/53680702/3562369 It simply involves creating a new Trait with a Type member, and implementing it for Option&lt;T&gt;. And then accessing that member for any concrete type which is an Option&lt;T&gt;.
Most of what you say is spot on. But the 0.x thing is still completely arbitrary. Instead of 0.39.x -&gt; 0.40.x we could just as well have 39.x.y -&gt; 40.x.y with no other differences in procedure or problems. As you say, devs are responsible for knowing, and the pre-release versions communicate almost nothing actionable about this. I describe this as an aversion to higher major version numbers.
This is not a bug, `readelf` and `file` will describe position-independent executables as shared objects. You can read about this here: [about ELF – PIE, PIC and else](https://codywu2010.wordpress.com/2014/11/29/about-elf-pie-pic-and-else/)
It’s not about encouraging immature crates to label themselves as 1.0 when they’re not ready. It’s about asking mature crates that haven’t changed their API in a year to go 1.0, indicating to folks using them that it is _likely_ going to be stable. Yes, as a community we’re very careful about promising API stability because it could come back to bite us. But the upside is that the community benefits from having 1.0 crates for a number of use cases. It signals to Rust newbies that this ecosystem is stable and their next project should be in Rust. So yes, we should have a soft cultural push to encourage authors to go 1.0 if their API has been stable for n months, for some value of n. 
Thanks for the link.
Cool, create a fork and do it as you'd like to have it or join the design team to help out instead. 
One more attack vector just occurred to me: the server could get compromised. This kind of attack already happened not long ago. I think it was Ubuntu website or something similar.
That didn't sound negative at all. No, of course we wouldn't drop our existing platforms, but I'm working at one of the big banks. We have C#, Java, Python, C/C++ and goodness knows what else in use across thousands of developers. All of them are used for different things. My area is not going to stop using C# and WPF for building desktop applications. But right now I'm writing network services for dealing with high volume metric data and Rust would be perfect. There are other teams working on custom databases and messaging and infrastructure bits and Rust would be perfect. The business is all for new tech, and crazy about performance and stability and correctness. But the tech gatekeepers want to know that any tech they let through is stable and mature.
That's not how SemVer works. It doesn't matter whether you're on 1.x or 63.x: breaking changes to your API are a major version bump; non-breaking changes are a minor version bump; patches and fixes are a patch version bump. From [semver.org](https://semver.org/#spec-item-4): &gt; Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable. Which means, according to the widely used standard, almost every crate in the Rust ecosystem is still in initial development and hasn't released a proper, usable version yet. This is obviously not true.
retro console support is actually pretty interesting as an academic/proving exercise. I know there's a community of home-brew efforts for retro machines. tangentially one of the more interesting retro/modern combinations around is the video describing how someone demonstrated the true zero-cost nature of C++ abstractions by using them to write code for the C64. Demonstrating Rust in a similar context might go some way to 'marketing' it at people skeptical that anything can match C. on the other hand the level of effort required for PS2 support (and PS2 development) is high. 
The latest version of uBlock Origin has some WASM code, but I think it's written manually (not compiled).
Are you using a proxy, maybe a company-mandated onif if you're at work? Maybe the `msvc` version uses the Windows HTTP client (WinINet), which reslects the system proxy settings, including PAC.
I’m gonna guess he’s using [this one](https://crates.io/crates/gdnative) 
Excellent! I just setup Jmeter to run 1000 requests ramped up in 2 seconds with a loop count of 2 and ran it locally with my app that used `hyper::rt::run`; a significant number of requests got dropped. Replaced `hyper::rt::run` with `tokio_io_pool::run` and reran the tests; every single requests succeeded! This is just what I was looking for :)
The regex crate will also use SIMD to speed up matching on certain kinds of patterns FYI
Which is true of many of those libraries: the authors don't consider them stable yet. Just that it is usable doesn't mean initial development is completed.
interesting was kinda wondering what it would take to get rust working on the xbox one given it has a SDK. In my mind im thinking about just writing libraries in rust and just load them in uwp with c++.
&gt; Is this honesty? Or is it a cultural shared habit? Is it just "the done thing" or "the Rust way"? ---- &gt; 1.0 doesn't mean "this is finished and I'll never change it." It means "this works; this is good enough for you to start using it, and if anything's broken I'll fix it in 1.0.1, and I'll be adding some new features in 1.1, and if I want to make any breaking changes there'll be a 2.0." This is the crux of the issue and I think Rust needs a major cultural change here. We are terrified of 2.0. We're attributing higher meaning, that isnt there, to `1.0`. In Rust, 1.0 is magic, 1.0 is "perfect", 1.0 is unattainable. What you said 1.0 is, is what it *should* be, but sadly isn't in Rust. All we've done is move the versions to the right a bit.
[The team agrees with you on dependencies](https://github.com/rust-lang/rust-roadmap-2017/issues/11)
Well, now I would need to know what `Renderer` is. Or you could decide for yourself which one is better. I think there are only a few cases when you want to have two distinct lifetimes: 1. When outer reference is `mut`: struct Foo&lt;'a, 'b&gt; { bar: &amp;'a mut Bar&lt;'b&gt;, } Mutable references `&amp;'a mut T` are invariant over `T`. If the field was `&amp;'a mut Bar&lt;'a&gt;`, then you would only be able to put in `Bar`s that have the exact lifetime `'a`, which might be too restrictive. 2. When inner type is invariant over its lifetime parameter: struct Foo&lt;'a, 'b&gt; { bar: &amp;'a Cell&lt;&amp;'b u32&gt;, } This is kind of the same problem as before - in this case too you cannot store references other than those with lifetime exactly matching `'b`, so you probably want to have different lifetime for the reference inside the cell so that it would not be coupled with the lifetime of the cell itself. 3. When you want to be able to get a value with the longer lifetime out: struct Foo {} struct Bar&lt;'a&gt; { foo: &amp;'a Foo, } struct Baz&lt;'a, 'b&gt; { bar: &amp;'a Bar&lt;'b&gt;, } With two distinct lifetimes this allows you to get `&amp;'b Foo` out of `Bar&lt;'a, 'b&gt;`. If you had only lifetime parameter `'a`, which is shorter than `'b`, then you would only be able to get `&amp;'a Foo` out. If neither of these cases apply to you, then having just one lifetime parameter is better - simply you will have less lifetime parameters to write out everywhere where you use your type.
Thank you for the explanation. I hadn't though about `impl Index&lt;Register8&gt; for Cpu`...generics in Rust are so much more powerful than in Java. How do you keep the correct timing of the cycles it takes to execute each instruction? 
And that was 2 years ago‽
Oh, that’s true, but in this case I can’t really see how is this a problem.
The replies I've seen from people in the core teams has generally been "oh, but we've got great feedback elsewhere". When you look the great feedback is largely themselves patting themselves on the backs and insulting anyone who doesn't like the new website
As far as I am concerned, brand-name Rust projects are community-*implemented*, but not really community-*designed*. When they showed up and asked for opinions on their basically finished website I doubted anything would change based on the feedback. At least they edited the slogan, so the site isn't a *complete* disaster anymore, but it still looks more like a Barnett Newman painting and reads like &gt; Rust is an influential language in key algorithmic techniques such as recursion and condescension. Now don't get me wrong, I don't hold a grudge against Barnett Newman, but his art style doesn't work for websites for the same reason print design doesn't. But I digress. Rust is backed by Mozilla the same way Go is backed by Google, Kotlin is backed by JetBrains and Swift is backed by Apple. These languages are products, to be marketed in accordance with the backer's agenda, and the empowerment shtick fits Mozilla's agenda pretty well. Some of the people who write this website are contractors for Mozilla. That's (probably) why design input is ignored.
I don't worry that much about decision makers in companies. In the end it's developers who fuel a technology's growth. And a key way to grow Rust's developer base is to market it as approachable! Its unique selling point is that it unlocks a level of performance and flexibility that was previously not possible without investing in deep platform-specific knowledge and expensive quality assurance processes. We want people to try it and figure that out for themselves, and they will sell it to their managers. If Rust remains just an alternative to C++ it will not win. Personally I love the new design, including the colors. Having more colors but kind of desaturated ones is a pretty unique choice and it makes it stand out.
In that case team probably should try to find new designer. Also it is always good to get few different versions from different designers. Based on this thread: https://github.com/rust-lang/www.rust-lang.org/issues/421#issuecomment-443098003 -- it looks like only one version was suggested and after small visual changes it was accepted. I do understand that design is not big priority for the team, and there are a lot of other more important things to work on, but still I think it needs much more work.
Np o 
Organizing all that stuff must be hard and I appreciate the effort. However, focusing on wider ecosystem would probably pay off much better. Even more so in the long term. Rust is still fairly young and it has a lot of curious users / tinkerers in this stage. People who like to experiment, build their own stuff or just play around. If we as a community expect that a **large majority** of games using Rust will use Amethyst, then yeah it makes some sense to make it a primary point of focus. Personally, I think that a large majority of Rust gamedev scene will not use Amethyst unless you make it an "official rust game engine". Also, once it has a "officially blessed monopoly", it will be harder for competing engines to get users and developers. This is how net WG defined it's goals: &gt;**First and foremost, to bolster the “grunt work” crates that provide core** web functionality. Crates like [http](https://github.com/hyperium/http) and [url](https://github.com/servo/rust-url) are examples of relatively mature core libraries in this space. We want more such mature crates! A big part of the effort is identifying and finding ways to improve, standardize on, and/or document such crates. &gt; &gt;Secondly, to build a serious framework on top of these crates, ideally as a very minimal layer. That is, whenever feasible we want to use existing crates, and when not, **we want to create small, separate crates rather than a monolithic** framework. &amp;#x200B; &amp;#x200B;
wrong subreddit
Great idea for a new crate.
I think there's already a clippy lint that does this
You can clone the crate index and parse it. You might also want to look into how dependabot does it
I can kind of understand it. A lot of feedback was processed, but you are obviously talking about the slogan, the color scheme, etc. I suspect that falls under the "a conscious choice that we know will upset some people but think is the right choice", and in such a case it's normal to ignore the yelling from the vocal people while you gather more feedback from your peers and try to get a feeling for whether there really is a problem or it's just a certain subset of people that is losing their shit over something that may still be doing more good than harm. As important as the community is, some work cannot be done by consensus, and you can't expect the people who do a lot of the hardest work on Rust to just immediately back off something they believe in and have presumably discussed with many people just because some people don't like it. You have to give them time to evaluate where they went wrong, who they forgot to include, and whether they really misjudged or some people simply need to get used to it. Anyway I think this redesign is designed to appeal to precisely the kind of people who don't feel the need to wade into a discussion like this one has unfortunately become, with lots of people arguing that, actually, it is a crime that their feelings have not been taken into account.
I’ll just share a tip: RLS in VS Code seems to have issues with windows-style line endings CRLF so RLS is practically useless outside main.rs on Windows. The fix is to set the setting in VS Code called eol (end of line) to \n instead of the default. Then it works good for me at least. 
 &gt;I really hope this is not actually the case, because if Rust really doesn’t support code reuse in these instances, I have to question whether it will ever have a healthy ecosystem. If you have time to elaborate then I'd like to know what makes you think it is the fault of the language and not the problem domain. I admit I know nothing about these frameworks. How would you solve these issues in another language and why is it not possible in rust? 
I think there's a balance to be struck, though. I'd much prefer a longer period of API refinement over [going from 4.x to 11.x in three years](https://en.wikipedia.org/wiki/Node.js#Releases). If `hyper`, for example, went from `6.0` to `12.0`, how can I trust that major version number to mean anything?
What if you could put electric fence around r/rust to prevent rust *players* to come?
&gt; But, the resize/rehash depends on the load factor, and because this method redistributes the key/value pairs regardless of when they get inserted (**takes away from the rich and gives it to the poor**, hence the name), the hashmaps could now have higher load factors of even 90-95%. It's worth noting that Robin Hood hashing only speeds up *lookups*. Clustering is still an issue during insertions and removals, and are actually worse since you need to do more data movement. Increasing the load factor is fine for lookup speed, but this has the downside of making insertion have potentially awful worst-case times, which is one of the things that made me dubious about the standard library's `HashMap` when I investigated it. Hashbrown is a lot better in this regard. 
Rust 2018 is cool and all, but I'd hardly call it an electric update.
The fact that it is colorful is a central aspect of the design. It's a small change but it makes the site have a fundamentally different flavor. Such a fundamental change of direction, if I understand correctly, is what is not currently up for debate. I don't speak for anyone though. I can understand it though. This has been worked on for a long while, and anything that is different is going to provoke more negative than positive reactions because the people who don't like it immediately pile on to point out that it is different and therefore wrong, while the people who like it don't feel the same strength of conviction because it would be just their opinion.
&gt; In the last three years I've used .NET Core 1.0, 1.1, 2.0, 2.1 and now 2.2, and in 2019H1 I'll be using .NET Core 3.0 Actually, I think this is bad. I used to use c# at my work before we switched to rust. I hate versioning and naming in .NET world, I feel totally lost. And what is the big difference between core 2.0 and 3.0? I've upgraded mono from 3.x to 4.x (several updates) to 5.x and I didn't have to change anything in my code but still I was afraid every time because it was major version bump. Rust devs bump major version only if they have to, not because it makes good marketing. I like it. From crates you mentioned, I think it is only shame that log is 0.x, it definitely should be 1.x. Rocket, futures etc. - they all require nightly or are still experimental, it would be missleading if they were 1.x. I think that version numbering in rust ecosystem is very profesional. It is 
Wow.
I am excited about * the move to gfx-rs * expanded and improved tutorial * some things getting made easier Good work everyone 
&gt; for example, went from 6.0 to 12.0 — releasing a major version on average every 6 months — how can I trust that major version number to mean anything? All the major version says is that all x.?.? releases will be compatible. What would be different? Right now we treat the minor version like the major one, so how do we trust that? How would you feel if they went from 0.6 to 0.12 in three years? But they don't, because they have stability guarantees. Which means they should be 1.0
Clearly the problem domain is not going to change, in this case, the DOM being what it is. So it could be Rust is just a bad match for the domain. In JavaScript there were (I'm not really following JS at this time) a few goto virtual-DOM implementations, that were easy to reuse. One could combine libraries like Matt-Esch's virtual-dom and hyperscript (similar to Yew's html! macro). So far I haven't seen any reusable libraries in this space in Rust. Maybe this is just immaturity of the ecosystem, but with all the attention on WASM, this seems like a space that would have more stuff available already.
Ah, I guess you'll be disappointed to learn that the diamond engagement ring was [created in the 1930s by De Beers](https://www.theatlantic.com/international/archive/2015/02/how-an-ad-campaign-invented-the-diamond-engagement-ring/385376/), with the support of the Queen of England and Hollywood (Sissi!) and had its narrative change a few times in the course of history to adjust it to the mercantile desires of De Beers then...
They seem to have totally neglected to include the best aspects of the Rocket website though.
so, how many years should a rand crate take to go to 1.0? I think if there's some well defined and used standard
maybe n should be at least a year? but also it should only apply to sort of well maintained crates. because if I use a crate that's 0.1, has known issues, and no one touches it for years it shouldn't magically become 1.0.
&gt; If you actually learn to write C++, it would be equal in speed to C I would note that there are quite a few "speed-traps" in C++, mostly related to: 1. Copy Constructors: it's easy to accidentally create a deep copy. 2. Implicit Conversions: it's easy to accidentally allocate during an implicit conversion. The following short program illustrates both: #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; int main() { std::unordered_map&lt;char const*, std::string&gt; map = { { "William Shakespeare", " Stratford-upon-Avon, Warwickshire, England" } }; // Performance issues on this line: auto value = map.at("William Shakespeare"); // Print it. std::printf("%s", value.c_str()); } Idiomatic Modern C++17; 2 unintentional memory allocations in a single line of code.
&gt; Also I think there's an unchecked access method to slices, but I don't know if it's unsafe. It's unsafe because it's unchecked :)
&gt; That's just how the borrowing rules work, for better or worse. I get it, I just hoped where is a way to make borrow checker forget, what the references point to the same memory block. I will take a look at std::alloc. &amp;#x200B; thanks for your help. &amp;#x200B;
Your take on 1.0 is well intended, however I'd argue that you've also identified the cause without perhaps meaning to. What is the common denominator between tokio, hyper and futures? Waiting for `async`/`await`. The authors of these libraries *know* that the presence of `async`/`await` will significantly alter their API and have been waiting for its stabilization to finally reach the mythical 1.0. This was the plan for 2018, and as all good plans it didn't survive contact with implementation, so it'll take a few more months and by mid-2019 I'd expect those crates to finally have switched to `async`/`await` and to have released a 1.0. It sounds rather normal, to me, that an author being forewarned of a large upcoming API-breaking change would choose to wait it out.
You have got to be kidding me... that worked!
`const char*` as key is not going to work the way you want because hash for pointers is not by value. `unordered_map::at` returns `T&amp;`, not copy. It will only copy if you want to perform copy
&gt; `const char*` as key is not going to work the way you want because hash for pointers is not by value. Updated example to add in mysterious hasher and equality predicates to the hash map type. &gt; `unordered_map::at` returns `T&amp;`, not copy. It will only copy if you want to perform copy. True. Yet a copy is performed still.
&gt; Right now we treat the minor version like the major one, so how do we trust that? I'm on mobile so can't find the link, but `0.x` has specifically this meaning in semver, IIRC. Major version 0 is saying that the public API is more likely to change. It's a subtle but important distinction. 
Awesome! Thanks!
You have to ask the `rand` maintainers. I'm on mobile so can't do a whole lot of spelunking at the moment, but would be surprised if the requisite consensus on a public API has been reached, this the major version of 0. 
I was thinking Italy, but yeah. Also almost none of the colours make me think "Rust". D is D-coloured, Python is Python-coloured, why Rust no Rust colour? Other than that, I do like the overall contents: There's a good bunch of interesting whats and a tiny bit of hows. But the fonts and boxes are so huge, that the first thing I read is a wholesome message I don't care about followed by a ton of spacing. "Why Rust?" and "Build it in Rust" should be the first things to see, IMHO. The old site immediately threw the meme-y bullet points of "zero-cost abstractions" etc. at me. That, and example code.
I care
GitHub recently added a feature that lets you subscribe to releases. Currently cargo doesn't automatically tag versions on publish, so it might not work for all crates, but it could be useful for some projects still.
The mockup from #[421](https://github.com/rust-lang/www.rust-lang.org/issues/421#issuecomment-443098003) looks absolutely gorgeous.
Kill me more if you can...
&gt; I'm on mobile so can't find the link, but `0.x` has specifically this meaning in semver, IIRC. It actually doesn't, Rust uses it's own version of Semver that makes 0.x compatible. [Semver itself explicitly says `0.y.z` has no compatibility guarantees](https://semver.org/#spec-item-4) and the API may change at any time, `0.1.0` is not compatible with `0.1.1`. Semver basically doesn't apply at all to major version zero. Rust just moved the versions to the right a bit and calls it a day. &gt; Major version 0 is saying that the public API is more likely to change Thats true, but quite a lot of `0.y` crates aren't changing the public API anytime soon. In fact they have strong compatibility guarantees given to them by Rust, that semver explicitly says they don't have. If you're [worrying about backwards compatibility, you should be `1.0`](https://semver.org/#how-do-i-know-when-to-release-100). If you have an API people depend on, you should be `1.0`.
You could use typed arena, designed for this use case among others: https://docs.rs/typed-arena/1.4.1/typed_arena
Thank you for the info on non-Rust semver, very informative. I don't think "just moved the number to the right and called it a day" is a fair interpretation of what is used in this community, however. As you said, major version 0 *does* have a distinct meaning, which is means it isn't "just moving the number." Whether an individual application or library is willing to use a version 0.x library is up to them. As long as I'm willing to migrate to backwards incompatible versions more frequently, I don't see a big problem with that. As another comment on this post said, there is a distinction between usability and stability. 
Which, I think, is the OP's point. The authors don't consider them out of initial development when they would have long been stabilized in most other PL communities. Developers have free will so it's their prerogative to decide when their libraries are stable but I agree that Rust's culture has developed a distinct disposition towards long pre-1.0 dev cycles in excess of what I've seen in other languages (relative to the scope of the code). A counterpoint is that Rust has some unique features that necessitate these dev cycles. Due to the trait system and orphan rules, low level crates have to be a lot more carefully designed with a lot more feedback from the community. If everyone is going to be using the Future trait including built in async/await language features until the end of Ferris-time, we really, **really** have to be sure of the design. For async/await there is no going back and for stuff like Error/Failure moving between the two can be painful. With traits the way they are, it can also be hard use semver during early development - imagine if Error was a ecosystem crate instead of language built in: Failure would probably still have made more sense as a hard fork, splitting the effort and slowing down both to stability. The OP's point about coworkers and bosses is an important one. Depending on your team, company, and industry, management will yse different naive heuristics like semver of ecosystem packages that may block language adoption. I've seen this firsthand (specifically with Rust) in firmware and payment processing. I just don't think there's anything we can do about it except throw more manpower at the problem. The reason that these industries will adopt Rust significantly in the future (my "bold" prediction) is the same reason that these libraries take so long to stabikize: the Rust community as a whole is dedicated to correctness and software quality. Those values combined with the unique traits (hey i made a pun!) of Rust will simply rub some programmers the wrong way in a variety of professional/business contexts for a while due to naive heuristics but the community shouldn't compromise its core value in a race for language adoption.
That's fixable in rustdoc, though. It might be a bit awkward to implement because rustdoc's architecture is kind of a mess by now, but it's doable (and worthwhile, I think - we can do the same for variance).
Is there really ever any point in any probing method other than linear? Seems to me that *assuming a good hash function* all of them will result in the same number of collisions, but linear will perform the best because of caching.
I believe quadratic probing used to be theoretically superior because it "spreads" the elements out more, thus compensating for poor hashing functions (ie, hashing which have locality). However, these days caches and prefetching is sp important that linear probing will always win.
The Instruction enum has a cycles function that looks it up.
But then, if most crates are 0.x, then it means the ecosystem really isn't ready for production use, doesn't it? Honesty is great, I agree, but if there are no mature libraries to help you do what you want to do then that does preclude the use of Rust in most production environments. 
&gt; Adding support for native OS compositors to WebRender If I'm reading this right, this is huge for me. I have been trying to switch to Firefox all year but have had to go back to chrome because my CPU usage is through the roof on my late 2013 macbook (which I suspect is the non-default resolution) while using firefox . Opening a page in a new tab is so slow, the page load is really fast, but the UI loading is really slow and hangs constantly. If this is fixed then I hopefully can move full time from chrome to Firefox. I'm excited!
I didn't make any claims. I asked a simple question about what the core contributors to the rust compiler think of the new site. 
&gt;True. Yet a copy is performed still. Because `auto` is to deduce type, reference is not type, so you actually need `auto&amp;` if I'm not mistaken
In addition to what the others said, when it takes the top 7 bits of the hash, that always leaves the top bit of the control byte 0. This is convenient, because when it's searching the control bytes for a match it can just do a byte equality test. If "full" was `0b1xxxxxxx`, then it would have to use an extra `OR` instruction to set the top bit of the value it's looking for to 1 on insert and on lookup. A small one-time cost to fill the control array with `0xFF` at the start is probably a good tradeoff to save an instruction on every insertion or lookup. There's no corresponding cost to deletion, because there it's always setting the control byte to a constant `0x80` anyway.
Thus, my opening clause
You should check out the memchr crate used in the regex crate. It's got excellent documentation of it's SIMD implementation. 
Having been on the safe languages side for almost 30 years now, while always advocating for safety best practices in C and C++, I have long learned that "Trust me!" doesn't work for people that don't share the same insights. Only having running software that proves those people might be wrong, and even then they might just hand wave whatever was achieved. So one just carries on and let history eventually prove them wrong. For example, I got some vindication on C vs C++ when all major C compilers just moved their code into C++.
ayfkm wow
Regarding that, see https://github.com/rust-lang/crates.io/issues/75
I remember when the idea of using a web browser as an operating system and running everything as x86 emulated by js JITed back to x86 was just a joke.
For anyone else that's curious, I really love [`dependabot`](https://dependabot.com/) to keep my dependencies in sync for Rust. Automatic PRs letting me know I can either immediately upgrade without a problem or need to do some work to fix things up? Yes please!
&gt; Actually, I think this is bad. I used to use c# at my work before we switched to rust. I hate versioning and naming in .NET world, I feel totally lost. And what is the big difference between core 2.0 and 3.0? I've upgraded mono from 3.x to 4.x (several updates) to 5.x and I didn't have to change anything in my code but still I was afraid every time because it was major version bump. Well, thats what changelogs are for. Major versions should change when *something* is going to break. It may not affect your code personally, but something happened to break backwards compatibility somewhere. A major version bump is to tell package managers and other software "you can't blindly upgrade people to this" and to tell humans "you should read the changelog and check your code". A major version bump shouldn't mean "everything is broken and all your code is invalid"
I absolutely love the design :P Adding a code sample / sandbox would be very good though.
&gt; But then, if most crates are 0.x, then it means the ecosystem really isn't ready for production use, doesn't it? No, because you're assuming "version 1.0" is interpreted uniformly by every individual that publishes a crate. There is no universal interpretation. Moreover, just because a crate is at 1.0 does not even remotely imply that it is "production ready." The version numbers are a way of signaling API compatibility to build tools (like Cargo) and for signaling expectations set by the author. In order to figure out whether a library is production ready or not, one must do their due diligence on the library. Glancing at a version number is not due diligence. For example, `libc 0.2` is very clearly production ready, and is likely included in the vast majority of Rust projects, including production grade projects. But its version number is `&lt;1`. Therefore, **version numbers are not accurate predictor of appropriate production level use.**
Quick question: I have a function written like this: pub fn foo&lt;T: Ord&gt;(a: &amp;[T]) -&gt; Vec&lt;usize&gt;; To make this as idiomatic Rust as possible I thought I'd throw it in a extension trait. Now how would I go about implementing this trait for all array-like thingies in the best way possible? Thanks in advance!
In that case nobody should be using `rand`, leaving a pretty large gap in the ecosystem. Either the API is stable and ready for use, in which case it should be `1.0`, or the API is unstable and shouldn't be used. All `1.0` should be saying is "There is a public API. It will not break randomly." And if it needs to change things and can't without breaking, `2.0` is not a bad thing. `1.0` is still there. And the exact same upgrading and breakages and whatever would happen if `rand` updated from `0.6` to `0.7` too, so whats the issue with `1.0`?
Thanks a lot!
Thank you
Thanks
I went looking for a bug report on github for this, and it looks like it was just fixed within the last day. https://github.com/racer-rust/racer/pull/1007
&gt; In that case nobody should be using `rand` That's quite a sweeping absolute statement. &gt; All `1.0` should be saying is “There is a public API. It will not break randomly.” This is explicitly not the case for semver in Rust. Breaks are not random between releases, breaking changes occur at a change of `x` for `0.x.y` and `x.0.0`. This may not be the case for other languages, but we're talking about Rust. For me, and a lot of other rustaceans I suspect, if a library went from `6.0` to `12.0` in the span of three years as is the case with `hyper`, I would think that they needed to spend more time figuring out an API to commit to in a `v0.x`state.
I am starting to build my desk. &amp;#x200B; Also, I am working on a parser generator (Panini). It will be truly advanced. I will move some code from the engine over to a more general library for CFGs.
I don't have a wishlist, just wanted to stop in and say thanks for maintaining this. I use this buildpack for [license-bot](https://github.com/JoshMcguigan/license-bot) which has been running as a scheduled job on heroku for around 8 months now with no issues. 
I agree with this. My team has been experimenting with making a game in Rust and we've used specs before but decided against it after 2 years, mainly because it acts as a framework and not a library and gave us a form a form of complexity we did not want. &amp;#x200B; (In reference to [http://tomasp.net/blog/2015/library-frameworks/](http://tomasp.net/blog/2015/library-frameworks/)) &amp;#x200B; So I agree, a set of good libraries for gamedev would be fantastic, not an all-encompassing framework. It's also unfortunate that glium isn't maintained like before because that's a really useful library.
Thank you for the detailed post. I have obviously missed something important about traits and breaking changes; is there a quick explainer in the docs anywhere?
I'm writing something similar. I'm using the `crates-index` crate to download and sync the crate index repo, and just polling it once a day. Crude, but fine for my purposes.
But would Hyper have gone from 6 to 12? Would every update from 0.6 to 0.12 have constituted a major version bump, in semver terms? Or would it have gone from 1.5 to maybe 3.1?
Yeah, it was definitely really strange that a lot of the helpful feedback in the last thread while it was in beta was just... ignored; meanwhile, some extremely minor suggestions or strictly positive feedback was responded to. Aside from the very odd color scheme, there's also a weird section on https://www.rust-lang.org/learn/get-started - Where it says "refer to Ferris with the pronouns “they,” “them,” etc., rather than with gendered pronouns", that concerns me for several reasons - first, I'm not sure if this is supposed to be a joke that I'm not getting, especially since there's only one Ferris, and animals that we don't know the sex of are referred to in the singular as 'it' (interestingly, doing some research does indeed reveal rare uses of 'they', but only when the animal in question is universally quantified). Second, why is Ferris or the 'Rustacean' terminology mentioned on the rust-lang website? It's very unnecessary and unprofessional, in my view. Additionally, it's extremely condescending to give a (likely wrong) English lesson on the website, especially since it's the English version. (Wait a minute - where'd the translated sites go? Maybe it does make some sense after all). It's also very odd to me that in all the colors that the Rust website now sports, it doesn't use the blue color that has been associated with Rust for so long. Thankfully, we can still see it on Rustup. I hope they reinstate that color on rust-lang.org. I'm glad they made some changes to the slogan - however, looking back to when I first discovered the language, I wouldn't be as affected by the slogan now as I was then - the old one intrigued me, precisely because it told me what Rust is, rather than what Rust 'empowers everyone' to do. I wouldn't have really wanted to know what Rust did for 'everyone' (what audience is Rust supposed to target?) - I would have wanted to know what Rust could do for me, and only I can make that decision, and putting the main features of Rust (and the more detailed feature list below, which they seem to have forgotten to add to the new website) front and center helps make that decision faster.
Outside of the Rust world, 1.0 *does* mean something is production ready (although many shops will wait for 1.1 just to be on the safe side), and 0.2 means "probably the second alpha release". It may not be right, but it's the way things are.
I believe so. It’s creator knows what they’re doing, and without real world use it’s hard to develop a library like that. Meaningful changes to an API can be hard in Rust without a breaking change, see the [relevant RFC for more info](https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md). 
Traits and orphan rules are a bit in the weeds, but definitely related. The higher level framing is that of private dependencies vs public dependencies. The former are crate dependencies that are not exposed in any way in the public API of your own crate. The latter are dependencies that are exposed. One common example of the latter is the implementation of a trait, e.g., from `serde` or `rand`. In particular, if `serde` or `rand` puts out a semver incompatible release, then it's possible for projects to build both the `x.0.0` and `(x+1).0.0` releases of a single crate in the same binary. This isn't a problem with private dependencies, but it is a problem with public dependencies because the traits defined in `x.0.0` are not equivalent to the traits defined in `(x+1).0.0`. But this isn't just about traits; no types in `x.0.0` are the same as types in `(x+1).0.0` of the same crate. Traits are just the most common manifestation of this problem and the hardest to work around. You can read more about it in this RFC that proposes to treat private and public dependencies differently in Cargo: https://github.com/rust-lang/rfcs/blob/master/text/1977-public-private-dependencies.md
I exist outside the Rust world too, and I've never seen anything other than arbitrary designations given to version numbers. Some designations may be more common than others, so YMMV, but this is definitely not a Rust specific problem.
Very good point, and yes, that would explain a lot of those crates holding off on 1.0.
I see the `0.x` problem rather as a cultural thing. The Rust community tends to be quite perfectionist. We have this amazing language we love that enforces correctness and safety and encourages really clean APIs, so our standards have gotten really high. I would say much higher than practically necessary. People want their crates to be perfect. They envision really clean APIs for their libraries. Thing is, that's great and all, but other people are already successfully using those crates in many large-scale projects, and the existing APIs, albeit not as good as the authors envision them, already work great for many people. To me, this is an indication that a library should be `1.0`, even if the author has breaking changes planned. Breaking changes in the future are fine, that's why you can release `2.0` and so forth. IMO `0.x` version numbers should only be used if the author really has doubts about whether the current APIs are fit for purpose.
Indeed. And I actually made a mistake, the key should have been `std::string`, which would trigger a conversion from `char const*` to `std::string` because while `std::map::at` accepts heterogeneous keys as long as they are comparable, `std::unordered_map::at` doesn't.
I hadn't heard about this crate before, somehow. At first I expected this to be another "wrong sub"... happy to have discovered I was wrong.
&gt; That's quite a sweeping absolute statement. It's not, though. If the public API is unstable and nonexistant, nobody should be depending on it having a stable public API. &gt; This is explicitly not the case for semver in Rust. And thats Rust's problem. And really, it's dishonest to call it Semver. Semver is a standard. It lays out clear rules. The fact Rust chooses to ignore those rules and make up it's own doesn't change anything. In fact, it makes it worse. Rust explicitly does not use semver. &gt; Breaks are not random between releases, breaking changes occur at a change of x for 0.x.y and x.0.0 Which just means that 1.0 and 0.1 are exactly the same. The version is moved to the right a bit. There is no tangible difference between going from 0.1 to 0.2 and from 1.0 to 2.0, except "the scary major version" didnt go up. &gt; For me, and a lot of other rustaceans I suspect, if a library went from 6.0 to 12.0 in the span of three years as is the case with hyper Thats exactly what it did, except the version was moved to the right a bit. Whats the difference? People are still depending on and using Hyper, right? People still expect it to have a stable API for it's current minor release, right? So whats the difference? Stop being scared of major releases. Though hyper is a bad example because they have arguably should be `0.y`, they depend on other unstable features which themselves have arguably should be `0.y`, in that their API is known unstable and going through rapid changes because of async and await and futures and all that. That said, you can also argue that since people use them they should've been `1.0` long ago, and async and stuff should just be `2.0`. It's the same ecosystem split and upgrades and breakages either way. AFAIK They've both existed longer than async and futures. But I don't know too much about this part of the ecosystem so I may be wrong there. &gt; I would think that they needed to spend more time figuring out an API to commit to in a v0.x state. Which they can't do, because Rust is giving 0.y releases compatibility guarantees, so they *can't* rapidly develop and stuff, because then all their users would break, and they can't just increase the minor all willy nilly because it would split the ecosystem or something, because everyone is using them and depending on them and expecting compatibility and stuff, which "Rust Versioning" gives them. The [semver FAQ](https://semver.org/#doesnt-this-discourage-rapid-development-and-fast-iteration) kind of touches on this kind of stuff. And see the [semver FAQ](https://semver.org/#how-do-i-know-when-to-release-100) on when to release `1.0`.
Rust semver is slightly different. 0.y.z means you just apply semver to y.z.
One of the biggest barriers to adoption is lack of rich OS framework bindings. The Windows Universal Platform crate for example is nothing but a readme parked on crates.io. How do I use Rust to access and use BLE on Windows without any bindings to the core framework APIs? Rust is being adopted in niche applications when OS frameworks aren’t used heavily like CLI programs, backend, some daemons and services. Until we can efficiently build a .NET or Cocoa application Rust won’t gain mass adoption and remain a curiosity. 
What exactly is Servo layout?
Works occasionally. 
But the exact same problem exists with minor versions too, so what does no `1.0` solve? `0.(x).0` and `0.(x+1).0`versions of crates will exist and have the exact same problems.
Layout is the part of the browser that takes the given HTML and CSS and figures out where all the elements on the page should be placed and arranged. Servo's schtick is that it does this in parallel, whereas other engines don't (or at least they didn't years ago when Servo was begun, I don't know of that's changed since).
The language is meant to be inclusive of non-binary individuals and the general concept of gendering things less when it isn’t necessary. Languages having mascots is a long and, in my opinion, charming programming language (and larger open source) tradition. I don’t think it’s unprofessional to introduce Rust’s on a section of the main site. And since Ferris has no specific gender (but is anthropomorphized, and thus gets “person” rather than animal nouns), the noun choice on the site is appropriate.
The docs explain the orphan rules (typically introduced with trait impl blocks) but I'm not sure there's anything explaining the ecosystem consequences. Basically, since you can only implement a trait for a type defined in your crate (with some wiggle room for generics), a library crate with nongeneric types (or if it has interconnected blanket implementations) must implement all other nongeneric library traits like Serde's Serialize/Deserialize if they want to be compatible with common patterns in the ecosystem. There are ways around it with newtypes and some tricks serde uses but they usually force a large ergonomics and maintenance burden on the developer, and dont work for all APIs. That means that the first 1.0 stability guarantee carries a lot more significance than the later x.0 breaking change guarantee. At 1.0, it means that you are stable within the Rust ecosystem as much as it means that your API is past initial development. Normally this isn't a problem because most crates are very specialized but for something that provides a core abstraction in the ecosystem like bytes this creates a catch 22 where you need more users to get enough info for stability but many professional users won't touch it until 1.0. If everyone is using different x.0 versions of a foundational library and it changes its core traits every year or two it would create large incompatibilities within the ecosystem. Once you are at 1.0, you are saying that other libraries can depend on your traits not changing. Nothing stops you from breaking those traits in reality but that's the significance 1.0 carries in the ecosystem (from my observations). Ideally your future x.0 versions would break your structs and their implementations without touching the traits. This also means that any library that exposes interfaces with pieces from a foundational 0.x library isn't really 1.0 stable because 0.x+1 might break compatibility in indirect ways. Futures is a great example because there are a *lot* of moving pieces for async/await. In nightly alone we have the Pin trait, generators, async/await syntax, and state machine codegen. Plus there's the community work on the stream/sinks concepts, tokio's and other popular libraries' continued development, and on and on. The relationship between futures 1.0 and all of these other pieces is circular and symbiotic.
You need rustup 0.16 and afterwards you need to `rustup toolchain uninstall stable` `rustup toolchain install stable`.
I never said otherwise. In no comment have I made an argument for or against the existence of 1.0 crates. In fact, the vast majority of crates that I publish that are also widely used as direct dependencies are already 1.0. Based on the content of your other comments in this thread, you might want to step back a little and chill out. In my GP, I was answering a question about how public traits can impact the API evolution of a crate in the Rust ecosystem.
&gt; If the public API is unstable and nonexistant, nobody should be depending on it having a stable public API. This is not the case for `v0.x` crates. &gt; There is no tangible difference between going from 0.1 to 0.2 and from 1.0 to 2.0 This is not the case for Rust semver. I am not talking about non-Rust semver. You refuse to address my posts with the relevant context. This is essentially: &gt; **me**: this cookie is sweet **you**: but this cookie is sour! How can your cookie be sweet when cookies are sour? Have a nice day. 
I have a few different thoughts on this. It's definitely true that there's many different worlds within the game development worlds - however, I believe that those worlds intersect at points that make or break the ecosystem you're trying to use. To work on android and iOS, you need to be able to create a rendering context and play sounds on that platform (just as an example); Unreal engine needs this just as much as something like LOVE2D would need it, even though they are targeted at completely different crowds. To make this possible, the language and its ecosystem need to provide an environment where these things are abstracted away, so that the engine can use them to do the same thing on different platforms. From my point of view, the blockers for rust in this respect are not necessarily the great engines that are in the progress of being built (amethyst, piston, ggez, and so on), but the underlying crates that create abstractions for those to use: `winit`, `gfx-rs` and audio libraries come to mind. Focusing on any of these engines with a workgroup to ensure platform compatibility would inevitably push forward the development of those, and in turn benefit all the other engines as well. Lastly, I think that there *are* engines that fill both spaces you mentioned, such as Unreal and Unity. They are both being used for hobbyist projects and by big companies alike, and amethyst definitely strives to be as full-featured as it can be; and in due time get close to projects like that. I'm aware that that's hella ambitious, but looking at engines like godot, with enough time I think it's possible.
Sure, maybe I was a little too harsh and failed to consider other implications. But even if anthropomorphized, Ferris is not, as I see it, anthropomorphized to the extent where it should be given a human-like pronoun - it definitely still strikes me as a crustacean in style and nothing more. And I agree that Ferris can have a place on the main website - but there doesn't need to be grammar lesson or an etymology lesson to accompany it - just link to rustacean.net. The site should assume people are smart enough to make the connection between Rust + Crustacean -&gt; Rustacean.
Is it different to Stylo? 
Good job, thank you! The api of rocket is very solid and clear. Waiting for async support in the future.
Great explanation, thank you.
It was that indeed :) Thanks!
&gt; This is not the case for v0.x crates. It is by the semver spec, but lets disregard that for a second. Then what sets them apart from `v1.x` crates? &gt; This is not the case for Rust semver. Well, one, theres no such thing as "Rust" or "Non-Rust" semver. [Semver](https://semver.org/) is a specific thing with a very clear, specific, definition. Two, What?! Yes it is. What difference do you think there is? Why are you arguing something you clearly and hilariously have no understanding of? "Rust Versioning" is literally what makes that a thing too! Semver says `0.1` and `0.1.1` are incompatible, Rust says they are, which means, in Rust, going from `1.0` to `2.0` is just as incompatible as going from `0.1` to `0.2`, and that their patch releases are compatible(which is the crucial point) &gt; You refuse to address my posts with the relevant context. It's not my fault you don't know what you're talking about and don't know your own context. &gt; &gt; me: this cookie is sweet &gt; &gt; you: but this cookie is sour! How can your cookie be sweet when cookies are sour? &gt; I don’t see any point in continuing to attempt to have a conversation if you can only reply in such a non-constructive manner. Have a nice day. What are you, five? Thats not even accurate. This is more accurate &gt; **me**: *holding a cookie* This is a cookie. &gt; **you**: *holding a bagel* This is a Bakery Cookie. How can cookies be cookies when my bakery lies? And the only one being non-constructive is you. You don't even know what the things you're arguing are! As you've *very clearly* demonstrated you have ***no idea*** what you're talking about.
The biggest difference from 2.x to 3.0 is Windows Forms and WPF, but only on Windows. Although a lot of the supporting parts will be x-plat.
abd waiting for the the stable support 
Excellent work! I find the API very idiomatic. Just one note : For some reason doing scroll with the phone in this page makes the text a little blurry, any idea about it? 
Copy/pasting the same screed about how houses are built when we're discussing car manufacturing in a car-related subreddit. 
what
well, I tried it out with the same result. I replaced v: Vec&lt;8&gt; with p: \*mut u8 and allocated memory with std::alloc::alloc(). &amp;#x200B; its seems to be impossible to return multiple mutable references to a same chunk of memory...
https://rocket.rs/v0.4/news/2018-12-08-version-0.4/#maintainers-1 This looks like a great decision from my perspective! I've grown cautious about single-maintainer projects and it's great to see that Rocket is no longer in that category of projects.
Like I said, I'm tired of steering you back on topic. `v0.x` in Rust is not the same as `v0.x` in the Semver you keep wanting to ascribe my posts. Going back to the well of arguing arbitrary definitions instead of the actual meaning of the posts is a common refuge of a poor argument, sadly. 
&gt; Like I said, I'm tired of steering you back on topic. Well, you didn't say that, you just said some random shit about houses and cars, made up a word, and claimed something about copy pasting. Clearly not on topic, since i sure didnt copy paste anything. Unless you're trying to say.. quotes? are copy pasting. Don't worry though, next time i won't give you the benefit of the doubt for the stupid crap i'm sure you'll say next. &gt; v0.x in Rust is not the same as v0.x in the Semver you keep wanting to ascribe my posts. I would suggest you look at bit closer at both of those things and my comment because you clearly still have no idea what you're talking about. Because thats **********literally********** what i fucking said. `v0.x` has the exact same comparability rules **********in rust********** as `v1.x` **********in rust**********
&gt; What are you, five? Insulting others is not tolerated in the Rust spaces. Please do not do it.
&gt; 0.x crates are certainly useable and not "randomly breaking". Thats funny, because [***you literally said they weren't***](https://i.imgur.com/4w3gFL1.png) you fucking "genius" "This is explicitly not the case for semver in Rust."
What are you, their alt? Go tell them that, with their childish nonsensical contradictory arguments and cookie shit.
Please don’t resort to insults :( Also, the next sentence: “breaks are not random between releases”. Nice try, though. 
Thats just arguing arbitrary definitions! Breaks are never "random", they happen because somebody broke something for some reason! 
The "short answer is X and the long answer is Y" suggests that Y is more informative and somehow expands on X. . I'm saying the short answer is "don't do that" and long answer is "do data-oriented approach and definitely don't do "Rc and Weak pointers". `Rc` and `Weak` should almost never be used. We shouldn't even mention their existence to new users, so to not give enough rope to hang themselves.
Maybe you can play around with `split_at_mut` for that. example: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=363088792ee4bf83af967da3b3ee91a3). Though I suspect the main blocker will be that calling methods on your struct will still trigger a borrow of the whole struck regardless of how you structure things internally.
Ah, I like "Maturity"... could be the aim for 2021 edition: 2015 Stability 2018 Productivity 2021 Maturity
Agreed. Maturity should be the 2021 theme. I'll do my Rust 2019 poat later, but the quick version is tjat I think 2019 should be compiler focussed. Specifically compile times and IDE support (which I believe are mutually supportive goals).
What kind of phone do you have? Does it have an OLED screen?
Shameless self plug....I’m working on a web application called Cratify ([https://github.com/twilco/cratify](https://github.com/twilco/cratify?fbclid=IwAR2zicxbpG_tFOlIvEOzwPLq6wF3D0dw1wfawPPpyet0_oaExSuJPw7KImI)) that notifies you via e-mail when another crate starts to depend on whatever crate (and optionally, crate version) you specify. This isn’t quite what you’re looking for, but I like the idea of Cratify also optionally sending notifications upon release of a new crate, so I will add that functionality in, too :).
I think you could just use `std::string_view` because `std::string` is allocating
Stylo is the part that maps CSS properties onto DOM nodes. Layout takes the properties and maps them onto rectangles and text runs in the display list. Webrender takes the display list and turns it into pixels. At least that's my understanding, I'm an observer and not directly involved.
For visual learners, Google gave an excellent presentation last year on Swiss Table https://youtu.be/ncHmEUmJZf4
I think the parent comment was poorly worded, to the point that it was not helpful or constructive. But I also think it contained an important point: "Rust 2018" was taken to be not only an edition, but as a vehicle for marketing. And this has created a dricing force in the project's decision making process which has been counter to the usual community consensus driven process. I agree with other posters on this thread that the new website is currently a downgrade on the old. I think it's a good direction, it's just not ready (aside from design issues, it's missing whole chinks of content). The reason it was launched when it was was because Rust 2018 was taken to be a Grand Project that required a coordinated release. This really is counter to the Rust project usual approach of releasing things when they are ready. I hope we never do a Rust 2021 (except as an edition with breaking changes), and simply release things like a new website as their own thing, on their own time schedules...
&gt; A lot of feedback was processed, but you are obviously talking about the slogan, the color scheme, etc. No, in fact I specifically, multiple times, referenced serious functional concerns. It is not a good change for beginners, it is not a good change for folks in the community, it is not a good change in terms of promoting consistency or discoverability to new or existing users of Rust. No, sorry, my qualms are not about colors, or even that much about layout, I honestly didn't even notice those things, I'm so used to minor redesigns -- I simply don't care about that stuff. Honestly, this is just another really intentionally tone-deaf reply that leaves me hoping "gee, I hope you're not part of the team that rolled this out because it explains a lot.".
I use `cargo install --bins --root ./package` as part of my build step. My Cargo project has multiple bins, so this works out nicely, then I point my package tooling at `./package` (via `make` for now).
I say go for it. While we're not a 100% on all stuff yet i think the lang is in a good position. Plus your students will be using the exact same tool set on all os. Also you wouldn't be the first one to start teaching rust. Here is a Stanford course on OS development. http://web.stanford.edu/class/cs140e/ Though rust idea support isn't the greatest yet. It's not a show stopper, just a bit annoying.
Good guess, and I am not sure but I think I M using a different one. https://github.com/GodotNativeTools/godot-rust/blob/master/README.md I need to see if these are actually the same thing. 
It is Pocophone F1, LED screen I believe
Yes, you can link a no_std crate into one that uses std.
Linear probing suffers from "primary clustering"; a collision to a chain of length `n` increases the chain of all of those elements by length-1. In quadratic probing, most of those will consist of elements from different chains, so although that particular element is offset to the end of the chain, the other chains only intersect at that one crossover point so aren't themselves lengthened (if that makes sense).
Wrong subreddit, you are looking for r/playrust/
Ah not sure then. Sometimes in high contrast white on black text OLED screens can get a little blurry but LED shouldn't have that issue
Serious question: will referring to Ferris as "it" be a CoC violation now? It seems like the core team or some relevant working group [has determined](https://github.com/rust-lang/www.rust-lang.org/issues/470) that Ferris has "they/them" pronouns but I'm a little unclear on what the process for that was. Presumably referring to a real person with the wrong pronouns would be a CoC violation so I just don't know where the line is drawn. Thoughts?
it should support `async`/`await`, of course.
Congratulations on the release! &gt; Not already using Rocket? Join the tens of thousands of users and hundreds of companies happily using Rocket today! Are these number correct? I guess I have no sense of the magnitude of Rust!
/r/playrust
We all make lapses sometimes. If you misgender someone, real or imaginary, you show that you haven't thought about something they hold important, so don't be surprised should you get called out on it. If that happens, you should apologize and correct your lapse. In that case, all is well concerning the CoC. If you find out your lapse before being called out, just correcting it should be OK. On the other hand, if you get defensive when being called out, you are no longer in line with the CoC, because in that case you value your own right to be wrong higher than another person's right to exist as they are.
I know my company used it ... got an app running in prod and it runs great!
I appreciate the thoughts. What I'm still not clear on, though, is whether using "it" to refer to Ferris is a misgendering.
oof yup sorry ;/
Yes, this is accurate. These can be thought of as steps in the rendering pipeline: * HTML and JS build a DOM tree * The style system (Stylo) applies CSS, which results in a "computed value" for each property for each DOM element * Layout decides geometry: the size and position of everything * Painting (WebRender) turns that into pixels on the screen
I used Rust as my senior project and had a great time. It helped me understand a lot of the things I had been learning but never really managed to put together in my head. That said, I'm iffy on teaching it as a primary language. As an elective, sure. But Rust does just enough to abstract important concepts away (pointers, strings/utf8, vectors) that I personally feel are incredibly important to learn and more visible in C/C++. 
The pull request upgrading Askama's Rocket integration to 0.4 just got merged, so Askama master now supports Rocket 0.4. I'll try to do a release soon.
&gt;Is this honesty? Or is it a cultural shared habit? Is it just "the done thing" or "the Rust way"? I think it is a cultural thing. It is "the Rust way". Rust itself is very cautious about committing to syntax and API, and many features that in other languages would have just been implemented by one of the core developers and pushed into the next version, are being heavily discussed in an RFC and spend many months in nightly before the Rust team is confident enough in all the fine details and design choices to consider those features "stable". Crate authors see that, and feel that they too should be cautious about declaring their creates' API as stable.
I think c is extremely important to learn and teach. It’s almost exactly analog to assembly, rust provides a lot of abstractions which are useful but can hide what’s really going on, especially with pointers. I think it really depends on the level of the course. At a certain point in CS curriculum the language is no longer important and it is just a vessel to learn something. If you think rust is a good vessel for what you are teaching than go for it. But if it’s an entry level class, or supposed to replace what was previously a C class, I would be hesitant. Good luck!
Misgendering or not, how would you react if someone referred to you as an 'it'? Ferris has been anthropomorphized for some time, so they probably would dislike the 'it' pronoun similarly. I don't think this needs a community decision, some common sense will do. Also you seem to harbor the impression that the core team is the final arbiter of the CoC. It is not, that happens to be the moderation team (full disclosure: I am one of its members).
Is this what concern trolling looks like?
And *you*, not Ferris/Ferris' creator, have declared Ferris' preferred pronouns to be "them/they"? Here I was thinking that everyone got to choose his own preferred pronouns; how wrong I was. Tell me, oh hander-out-of-preferred-pronouns, what are my preferred pronouns within your sovereign domain?
I've taught it twice now, going through the Blandy and Orendorff book in ten weeks and having the students do a project. It has gone great, and I highly recommend it. You will want to be reasonably fluent in Rust, so that you can answer the weird questions that will come up.
Holy cow typed URIs look neat, never thought that was possible
Undergrad and Rust user here. Rust's ownership made me better at memory management and pointers in C/C++. So surely teach them both!
&gt; Outside of the Rust world, 1.0 does mean something is production ready No way, man. Browsing nuget.org for two minutes makes it clear that *never using a version below 1.0* is that community's norm. Their libraries aren't more polished, `nuget spec` just defaults to version 1.0.
If anyone here is knowledgeable about diesel, the way the items generated by the table! macro work is going right over my head. Based on the docs, the table! macro generates a unit struct for the table and each column, so the model I've put together is that an import like this: ``` use crate::schema::dsl::&lt;table_name&gt;, &lt;column_name&gt;; ``` imports the generated unit struct(s), and the reason you can then do database operations with those is because they're generated such that they derive QueryDsl. Can someone please let me know how hot/cold I am? 
Why do you believe this is concern trolling? Wouldn't you be concerned if the Rust team/moderation team unilaterally decided to change your preferred pronouns based on "common sense"?
Curious: is there some article that explains how various layouts algorithm work? From bits and pieces, I know about CSS box model (have no idea how to actually compute the resulting layout from CSS constrains), cassowary (which I kinda understand how it works) and flutter's layout algorithm (which seems super cool because there's no any kind of global constraint solving there), however, I completely lack the understanding of the big picture. Would also love to learn how other UI toolkits (swing, Qt, etc) do layout. 
Why did you opt to write it in rust? Just because you could?
My undergrad languages class had a single project in Rust. It was kinda lame, though, because it was really just a series of easy exercises. Exercism is harder. I wish we did an actual project with it. I'm pretty sure none of my other undergrad classes will use Rust, which sucks. I will say this: knowing the basics of Rust lifetimes before taking the systems/C class helped a ton. It would've been so much more difficult without having that mental model.
*I* have not declared anything about Ferris' pronouns. *You* are the one concern-trolling over the presumed preferred pronouns of a fictional character. This is also not in line with the CoC. Besides, I have checked, there has not been any "consensus" over Ferris' pronoun: Some use "he/his", others "she/her" and others, like you, use "it". Apologies if I mistakenly assumed that your preferred pronoun is something else than "it" (my cultural bias is certainly showing here).
I have a dumb borrower question. The following code is a simplification of something I was trying to do. There are some easy ways to work around it. But I'm not 100% clear on why it doesn't compile, which is what I want to understand. &amp;#x200B; let mut values : Vec&lt;i32&gt; = vec![0; 32]; { let get_ref = |index:usize| -&gt; &amp;mut i32 { &amp;mut values[index] }; for i in 0..32 { let value : &amp;mut i32 = get_ref(i); } } Playground link: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3e4c26246cadaef894c74a2d79720689 &amp;#x200B; Error says "cannot infer an appropriate lifetime for lifetime parameter in function call due to conflicting requirements". I've got a container with a lifetime. Then I have a closure with a shorter lifetime which references that container. Then I have a loop with an even shorter lifetime that calls the closure which references the container. This seems like it should be valid? Thanks!
&gt; Besides, I have checked, there has not been any "consensus" over Ferris' pronoun: Some use "he/his", others "she/her" and others, like you, use "it". So can you just answer [my original question](https://www.reddit.com/r/rust/comments/a2qmct/hey_rustaceans_got_an_easy_question_ask_here/ebdjk0k/) of whether this is okay or not? *I* asked a question and *you* went off on this nasty condescending tangent explaining the concept of preferred pronouns to me. Thanks pal, I get it. Nevertheless I [repeated my question](https://www.reddit.com/r/rust/comments/a2qmct/hey_rustaceans_got_an_easy_question_ask_here/ebdn0db/) and tried to provide some context on why I was confused. The conversation went off the rails when you declared that preferred pronouns weren't something that needs to be decided by a person/a fictional character's creator, but instead could be determined by "common sense". That's a pretty shocking belief which is why I'm upset — that, and being declared a "concern troll" for asking (what I thought was) a pretty simple question which you still haven't answered. I asked for "thoughts" because I didn't want to exclude non-authoritative voices from the discussion, but since you are a moderator (as you feel the need to mention explicitly as if I can't see the "M" next to your posts) a simple "yes" or "no" would have sufficed (and still will).
Although I agree with what I think is the spirit it was written in, I agree that the specific phrasing is rough and feels a bit forced. They have been responding pretty well to improvement suggestions for minor phrasing and such, though, so I imagine a well-thought-out Issue or PR would be welcome.
You gonna post hog or what? Fucking propertarians man...
Wanted a fast safe language and loved the blend of features rust has. At the time rocket was what seemed the best web framework so we used that. We also have some web stuff written in Haskell, Elm, and some older stuff in PHP.
[relm](https://github.com/antoyo/relm) is good
&gt; doesn't exist right now Well, you can always call non-Rust libraries. Pango/HarfBuzz and Freetype are not going anywhere and still are great. What's new and exciting about the Pathfinder stuff is their usage of GPUs.
&gt; So here we are – I’m very hopeful that Rust will have a shining future. What are your thoughts? Aside from your idea for a GUI library, I agree that every one of your points are desirable goals. (Your idea reminds me of Java's AWT. Sure, it's "workable", cross-platform, and abstracts over the lightest GUI APIs on each platform, but it's ugly and takes a crippling "common subset" approach so it's the choice of last resort. Heck, even wxWidgets, which attempts to fill in the gaps, is a hassle to work.)
Yep I could but I wanted to be sure there wasn't something already out there. I was hoping for something in the stdlib but itertools's cartesian_product is exactly what I was looking for. Thanks. 
I think it's a good idea. Learning Rust has made me a better C++ developer. From an economic standpoint one reason we can't use Rust in production is when we grow we need engineers who don't need a ton of work to get up to speed, and since there aren't that many Rust developers out there yet. If we had more people teaching it at an undergrad level that problem would go away. 
Oh neat, need to bookmark that. Thanks!
Hi, I am a Cargo team member, working on making Cargo's dependency resolution better. Thank you for the feedback! I would strongly encourage members of the community to come help. I completely agree that the interactions between `dev-dependencies` and `build-dependencies` are not in a good place. Fixing it cuts across several complicated parts of the code, so the targeted fixes have not succeeded and a full fix has not yet been designed. &gt; API docs of cargo itself Currently we have no stable library api that we intend to stand by. Hence the limited documentation. I would love to see us bild smaller crates that have a stable api so people can depend on the parts that they need. Instead of depending on the entire thing, witch as you point out is painful. &gt; the exact dependency resolution algorithm used, why it works, is it formalized somewhere? It is not formalized anyware. Do you have examples of the kind of formalization/documentation you would like to see? Are there other package managers that have done a good job of this that I should look at? Thank you again for the feedback! 
(Ferris’s creator is the one who said they: https://twitter.com/whoisaldeka/status/774030536897683456 )
Great, this is the sort of factual response I was hoping for instead of the personal attacks I got instead. Hopefully "'It' ... is okay." is treated as equally authoritative.
To be clear, I don’t believe you’re posting in good faith here, but I do want to be clear about the facts.
[iui](https://github.com/LeoTindall/libui-rs) is pretty good, and crossplatform too. It's based off the [libui](https://github.com/andlabs/libui) C library.
This finally motivated me to set up RLS, and it is very pleasant to work with. Thanks!
Why wouldn't I be posting in good faith? Let's take a look at the insulting claim that I'm concern trolling. Here's what it would have looked like if llogiq or anyone else had just answered my question (say, by posing that twitter link): &gt; /u/belovedeagle: Serious question: will referring to Ferris as "it" be a CoC violation now? ... &gt; whoever: No; Ferris' creator said any of these pronouns is okay: [twitter link]. &gt; &lt;/conversation&gt; Wow, much troll, many disrespect. /s It seems to me that /u/llogiq is the concern troll here, by going off on a tangent about how important it is to use preferred personal pronouns. If I didn't already know that why would I have asked the question? I would be submitting a CoC complaint but I guess there's no point since there's no established process for submitting one when the person who's failing "to treat others with respect, patience, kindness, and empathy" has a presumably strong working relationship with everyone empowered to investigate such things.
They gave you a pretty straightforward answer, and you moved the goalposts. It’s pretty classic trolling behavior. And now you’re doing it here. My job here is done, I provided the citation.
One of the things that I found most useful in Uni was learning C. Not because C is my favourite language, but because it really helped me understand concepts like pointers, erferences and memory management, of course, in conjunction with computer architecture, operating systems and assembly. Introduce Rust after learning about all the pitfalls it solves and learning C? Sure. But I think it's a bit too high level for teaching stuff like computer architecture or teaching it alongside assembly.
Congrats! Typed URIs alone would make me want to switch over from Rails, if I wasn't already a convert to Rust. Really nice!
I haven't read the code in any great detail but Rust has great tooling to help you write idiomatic Rust that you should definitely take advantage of. * Use rustfmt to keep your code in line with community standards. `rustup component add rustfmt`, `cargo fmt`. * Give your code a pass with clippy. `rustup component add clippy`, `cargo clippy`. * Inline documentation comments are preceded with `///`. Module level comments are preceded with `//!`. * Rust 2018 is the new stable edition which brings in numerous changes. In parts of your code you seem to be using certain components of the edition but in other parts you aren't. From the looks of your inner attributes you are compiling with nightly, so just add `Edition = 2018` to your Cargo.toml to opt-in. * Rust discourages use of global mutable data by forcing you to encase access in unsafe blocks of code. Just because you can doesn't mean you should.
I had the freedom to choose a language for a project where we had to implement a few algorithms to find the 2 closest points in a set of points with arbitrary dimensions. I chose to use rust (my professor had never heard of it) and I was very happy with the experience.
This is a really great idea, but it would have a lot of moving parts, and I'm not familiar with all the tools involved. Would it be possible to create a small "Hello, world" repository that demonstrates how such a project fits together, with instructions on how to build it?
Cool, thank you so much for the help! * I definitely understand the importance of adhering to community formatting standards. I've mostly just been too lazy to adjust my style until this point, but future projects of mine will most likely be different. * I am using \`edition = "2018"\` and have been slowly updating the code to reflect it, but it's taking me a while. I actually posted this not too long after I got it to compile for the first time since updating. * I understand and appreciate how Rust discourages the use of global mutable data. For the most part, the fields I have used are *supposed* to be kept private and are only accessed by the main game thread. I would change this, but one of my goals has been to allow for external binaries to add content at runtime. Unfortunately, I wasn't able to work out a way for this to happen *without* using static variables. I guess I could implement an API such that it specifically requests certain kinds of information from other programs, but I was concerned that this would unnecessarily limit what those programs could do. The second problem I was having was allowing access to certain kinds of information, such as player data and area info, from any place in the code. I supposed I could store every single piece of information inside of a global context, but this solution was a bit unwieldy and difficult to maintain. I also worried that this solution was similar enough to using static variables, and thus wouldn't matter. I've limited my use of static variables to about 6 or so, I believe, but I'm not sure how to reduce it much further. Any ideas?
I'd guess this is based on download counts
? 1 in 100000 x 100 = 1 in 1000
Why are the suggestions downvoted?
Pango has a bunch of glib dependencies, as I recall. My understanding is that it's also not flexible enough to reasonably handle CSS layout. As a result its uptake is somewhat limited outside of the GTK+ ecosystem. I hope that we can produce an embeddable inline layout engine that will get usage in a variety of projects. Not only is it a service to the Rust community, it will also be a way to get testing before any sort of integration into Firefox (which as always I can't make any promises about, but we're certainly thinking about it).
Pass a reference to those functions that need access to the data. Do not use mutable statics, or any equivalent. You'll find that, in many cases, this pushes you to write better code. If you have a large, complex data structure (such as TheEntireGameState), you'll find that many functions just need to operate on one specific part of it (such as &amp;CurrentPlayerState or &amp;mut NetworkState). So at the appropriate places in your code, you can pass references to fields, which narrow down the scope. If you use global mutable static state, you might as well stop using Rust, because you're missing out on all of its actual advantages. 
You learn assembly in school anyways though. So why use C as a proxy?
Not everyone needs to know C. I learned Assembly in college and still can't do much in C. I can't even read complex types in the language, they look like gibberish to me since I've never learned the language.
Modern c++ abstracts them away as well
I learned all of those things in the Assembly class. 
You can (have to?) introduce those concepts when teaching rust 
The single reason that rustc produces way more useful error messages than any C++ compiler is enough for me to recommend it. Some other reasons: - unsafe gives the freedom to dig as low as C - type system is much closer to other academic languages e.g. Haskell - state of the art multi-paradigm concurrency support - dev environment much easier to setup across platforms - lifetime / affine type is itself a research topic
My Uni did it the other way round and I think there's merit to that too. We actually used Rust on a later class too.
https://preshing.com/20110504/hash-collision-probabilities/ [probability 1 - exp(-0.5 * 2 billion * (2 billion - 1) / 2^(64))](https://www.wolframalpha.com/input/?i=probability+1+-+exp(-0.5+*+2+billion+*+(2+billion+-+1\)+%2F+2%5E64\)) = 10.27%
Rust V? When did Rust IV come out? 🤔
I still don't have a complete picture of how I would achieve the same ends (in a tidy and efficient way) compared to what we do today in Java using Spring-boot (yes I'm aware that 'efficiency' doesn't apply in the Spring side but I'd like to improve on that coming to rust). Our typical pattern of a handler is: - Check authorisation (presuming that Authentication is already done) - Check if we understand the request and does it appear sane (API validation) (resulting in BadRequest on failure) - Delegate to service (These service methods expect API-edge entities) - Check that the request is sane within the scope of current system state (resulting a mixture of NotFound, BadRequest, Unauthorised, ServerError depending on the situation) - deal with request (possibly producing results - eg gets) - Return results in API-edge entities as appropriate Services are configured resources, generally not mutable after application start. That is, we'd configure the services at application start-up before the API is started. Most services aren't mutable though and the same configured service should be used for the duration of the process. How would you inject access to the set of services in a Rocket handler? Let's say I had a Services struct where each field is a service and we initialised this prior to ignite...launch, how would we inject access to this in each handler? For mutable services (ones that have state in the application rather than the datastore) Rocket offers managed-state. But as I understand it, managed-state is ensured to be accessible to only one request at a time (since it's mutable) - most services are immutable (operating only on service-lifetime configured state and request-scoped state) and shouldn't require this performance cost. How would someone structure their Rocket-based API to support this? 
The way the diagnostic message for `uri!` is generated is very tricky. From what I can tell, the `#[get(...)] fn person...` attribute generates a macro probably called `rocket_uri_macro_person` with the information about the arguments, then `uri!(person, ...)` invokes that macro, which does the rest of the work. That way, the `uri!` macro invocation can know about the original details of the person function without explicit compiler support. I like it.
What is the best/most elegant/idiomatic way to get a boolean value depending on whether a value matches a pattern? The best way I could come up with is to use something like this: let b = match a { Some(_) = true, None = false, }; which feels kind of ugly.
Thanks to you as well for the feedback. Unfortunately, while I agree that passing references and not storing variables statically is generally the best way to code, I'm just not sure how to pull this one off. There are times when I need to schedule for certain pieces of information to be retrieved at a later date (i.e. using a supplier function), but there's no way for me to verify that those references will be valid at that point (without using raw pointers). I'm not saying it's impossible because I know that's just how it's done, but I just haven't been able to figure it out, sadly. 
As you can see it's "Learning Rust V", not "Rust V" You can see all posts in https://medium.com/learning-rust
We need English 2018 edition to resolve parsing ambiguities
How often is GC the deal breaker in a backend service? If you need low latency, I would expect it would be cheaper to tweak your GC or optimize for to help your escape analyzer than to rewrite in Rust or similar—even if it’s just rewriting the hot path in Rust, I would expect the extra complexity in the build and deploy systems to be a considerable cost.
Man, I keep hearing this, but I’ve been picking up Rust on and off for 4 or 5 years and I’m still not very productive (and I come from a C/C++ background, so please spare me the “it takes a while to learn to reason about memory” :) ). Thanks to the recent survey though, I realize I’m not alone. I really like Rust in theory, but if I need to get something done I always end up reaching for Go. I’m not sure when I’ll get to that point where Rust is easier, but I hope it’s soon (I can live with boilerplate, but the huge decision matrix I’m confronted with every time I pick up Rust has real costs). Unfortunately it doesn’t look like it’s on the horizon for me. :(
In the case of `Option` you can just use `a.is_some()` or `a.is_none()` to get a boolean. `Result` has `is_ok()` and `is_err()`. Docs [link](https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok) for `Result`, and [link](https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some) for `Option`
Thanks, but this was just an example. I want to use it for more complex patterns.
I am surprised nobody mentioned that [www.rust-lang.org](https://www.rust-lang.org) uses rocket.Meaning that in some sense they rewrote the non-html/css parts of the website in rust.
&gt; Things like specialization and generic type constructors have been discussed for months now, and appear to be blocked on the new type system implementation. What is the new type system implementation that we're talking about? Is this the integration of chalk into the compiler?
firefox isn't currently using webrender (well, it's behind a flag), so I don't think this one thing will fix your problem. I'm not sure how moving to webrender in general would affect you, might use more power or less &amp;#x200B; Doing work to make firefox and servo use less power in general is awesome though.
Wow! Didn't know that!
Open source != libre
I don't know of any article that does a comparison of layout algorithms. The closest thing I know of is a series of posts by vjeux on [image layout algorithms](http://blog.vjeux.com/category/image). Browsers have a number of layout models (table, flexbox, absolute), but the main one is normal flow (not sure if there's a more official name). Servo put a lot of work into demonstrating that it was possible to parallelize normal flow and the servo team did a number of public presentations on it in 2014/2015 but I don't have a link on hand and a couple searches aren't pulling up the ones I'm remembering. It's been a number of years, but I don't believe swing has a default layout algorithm. The size a widget gets depends on what layout container you put it in or explicitly setting it. I never did Qt or GTK.
wow! That's *ridiculously* bad.
&gt; continuing fine-tuning of our processes, especially at the RFC level, adding more mentoring and outreach to help more people find more positive-sum outcomes There was talk about revamping the RFC process. I think it got put on hold (due to rust2018?). Anyone know if that is going to get picked back up?
Nevermind, the issue is that \`rustup\` is on version 1.14.0 inside the image, which has the old toolchain.
https://deps.rs/
I think in idiomatic C++, it's usually correct to avoid using raw pointers, and when they are used Rust's ownership/borrowing rules are usually supposed to apply anyway. Rust makes correct/optimal usage of references clear --- if you look into C++ standard library implementations of `std::string`, for example, you'll see that they do dynamically at runtime the same copy-on-write patterns that Rust forces at compile time. Also, I don't know what you mean that Rust "abstracts away" strings and vectors. C++ has both of those types trivially in the standard library, and if a course in C++ includes rolling your own `string` or `vector`, so could a course in Rust.
&gt; What if we want to debug log from our const function? That’s a side effect. Should we make logging and log-less versions? This reminds me of some "red/blue" issues I have come across with ownership when designing APIs. There is a fine line between builders and setters. Either way, there is the question of whether to have them take `self` (better for combinators) or `&amp;mut self` (better for modifying struct members). I sometimes have algorithms that work equally well working with references or owned data (e.g. `Fn(&amp;str) -&gt; &amp;str` or `Fn(String) -&gt; String`) and each would allow clients to better optimize their application, depending on what they are doing with the result.
I'm sorry but when I see `unsafe` spanning across many functions right in the main file, it's a disqualification. 
Yep. Similar to you, I came to rust from C#. I started learning about a year and a half ago, but I gave up after about 5 months. I'm always looking for a reason to pick it back up because I think it is a pretty cool language, but progress seems incredibly slow compared to all the improvements .net has seen the last couple years.
What do you get stuck on? (Just curious)
The entire point of editions is that they introduce features that could be incompatible with previous rust code. Python 3 is an unfair comparison, for one the lack of a runtime requirement greatly simplifies upgrading, and secondly you can mix editions in dependencies.
Any estimate on when we'll have a full-ORM support, like Django's, or SqlAlchemy? It's the only thing holding me back from using Rocket as my next server.
Sure thing. Thanks for pointing that out. Feel free to leave any suggestions for improvement.
Agree also. We have 4500 issues in the rust repository. This is more than any team can triage or any human keep in mind. So probably there are duplicates, outdated and related issues but too many to look at. It would be great to work on cleaning up, implementing designs and fixing things even if that means more boring releases for a while. 
That's confusing; I've always felt that one of specs' greatest strengths is that it takes care to act as a library of independent components rather than trying to be a framework. At its heart it's just a type-safe columnar data structure that you can do whatever you like with.
I would much rather see concentrated focus on independent, composable crates that are more broadly useful.
It looks really cool on mobile. Can’t say the same for rust-lang.org
This code will fail in the same way as your example: let mut value: i32 = 42; let get_ref = || -&gt; &amp;mut i32 { &amp;mut value }; let _ = get_ref(); --- error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements --&gt; src/main.rs:5:9 | 5 | &amp;mut value | ^^^^^^^^^^ | note: first, the lifetime cannot outlive the lifetime as defined on the body at 4:19... --&gt; src/main.rs:4:19 | 4 | let get_ref = || -&gt; &amp;mut i32 { | ^^^^^^^^^^^^^^ note: ...so that closure can access `value` --&gt; src/main.rs:5:9 | 5 | &amp;mut value | ^^^^^^^^^^ note: but, the lifetime must be valid for the call at 8:13... --&gt; src/main.rs:8:13 | 8 | let _ = get_ref(); | ^^^^^^^^^ note: ...so type `&amp;mut i32` of expression is valid during the expression --&gt; src/main.rs:8:13 | 8 | let _ = get_ref(); | ^^^^^^^^^ If you remove the last line, you'll get this warning: let mut value: i32 = 42; let _get_ref = || -&gt; &amp;mut i32 { &amp;mut value }; --- warning: captured variable cannot escape `FnMut` closure body --&gt; src/main.rs:5:9 | 4 | let _get_ref = || -&gt; &amp;mut i32 { | - inferred to be a `FnMut` closure 5 | &amp;mut value | ^^^^^^^^^^ returns a reference to a captured variable which escapes the closure body | = note: `FnMut` closures only have access to their captured variables while they are executing... = note: ...therefore, they cannot allow references to captured variables to escape = warning: This error has been downgraded to a warning for backwards compatibility with previous releases. It represents potential unsoundness in your code. This warning will become a hard error in the future. = warning: This error has been downgraded to a warning for backwards compatibility with previous releases. It represents potential unsoundness in your code. This warning will become a hard error in the future. So the problem is the fact that you have a FnMut closure, get\_ref, that returns a mutable reference to it's environment which becomes invalid after get\_ref finishes executing. This is why if you change it to an immutable reference it will work, because normal Fns can return references to their environments even after they finish executing: // This works let value: i32 = 42; let _get_ref = || -&gt; &amp;i32 { &amp;value }; Hope this helps. The error messages you get for your original example could definitely be better.
You can also use: ``` if let Some(_) = foo { true } else { false } ```
Anyone else liked the old website better? 
Undergrad rust user here who did his senior project in Rust, and I completely agree. I think it could be a very good learning tool for students who want to get into Systems Programming. Mostly because the compiler is so helpful, and libraries so easy to find/install compared to languages like C/C++.
There are quite a few ORMs in Rust. I like Diesel the best.
Have you looked at `std::sync::Arc`? Or any of the other synchronization mechanisms? 
I like the new one better for being more informative.Not a fan of the color scheme and the lack of code snippets in the front page though.
It's the opposite for me. On the old website, I knew what Rust exactly was on my first glance. On the new one, I have no idea what Rust is until I have read through the first few pitches. Even then its nowhere explicitly stated that Rust is a programming language. 
I thought rocket is slow while it's still sync? Wouldn't a node app outperform a rocket app based on throughput simply because it's async Vs sync?
https://github.com/jwilm/alacritty/pull/798
[other people](https://github.com/rust-lang/www.rust-lang.org/issues/612) noticed the same problem yesterday.
Exactly.
Depends what you mean by slow? It makes it harder to deal with a bazillion requests at once but a single request is blazing fast. We run with a large enough amount of workers that it handles our load quite nice and we’re quite capable of scaling horizontally if needed.
Ah cool. I haven't been active on this sub for a while so I assumed most people were okay with this change.
Automatically the fastest!!
If this is a common pattern you can rewrite as a macro: macro_rules! pat_matches { ($pat:pat, $expr:expr) =&gt; { match $expr { $pat =&gt; true, _ =&gt; false, } } } https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5abfe45dad8fd66965750b59914acfba If the pattern is always the same you can write it as a function instead.
I agree. Regardless of whether the unsafe usage here is completely correct or not, a rust beginner's project has no need to contain this much unsafe code. `unsafe` should be used as a last measure, not just to avoid the borrow checker.
Is the _feature_ tag a possible solution for this ?
I never heard about crev before. Collaborative code review of all popular packages with signatures etc. I hope that becomes popular: https://github.com/dpc/crev 
I think there's also a large disconnect between what C strings are (you have a `char *`, where's your string) and what strings end up being in the real world: a mess of locales, multi-byte encodings, inplementation-specific behaviour, OS-specific behaviour, and sometimes surprising questions like "why is `grep` 10 times faster when run with LOCALE=C?".
Total Rust noob here, but with some experience in programming as a hobbyist. I can't grok mod/use usage, compiler keeps flagging errors about my module interworking, and I don't understand the usage of the keyword 'crate' (within my own module hierarchy, not when importing external crates). I am not providing sample code because I have some fundamental misunderstanding that I have to sort out first. So my question to you guys is: besides the Book what's the best tutorial out there covering non-trivial usage of mod/use? Thanks 
I'd say that all the things you do prior to actually handling the request could be done with request guards in Rocket. You might want to read that part in the guide. https://rocket.rs/v0.4/guide/requests/#request-guards Regarding the services, you could probably have them as rocket managed state: https://rocket.rs/v0.4/guide/state/ The guide is really good and provides examples for pretty much every feature.
Since you cite AWT, I'll mention that its successor, Spring, is also widely derided as being ugly *and* bloated, despite the fact that it appears to be fast enough for JetBrains' IDEs. Then there's JavaFX, which looks good and has an OK-ish API, but is a rather large dependency. On the other hand, we may want to have a look at Lazarus / FreePascal, which has a library called LCL that can bind many different widget sets, while still being very lean, from what I hear. All in all, I think that GUI APIs are an unsolved problem and I expect multiple crates trying different sections of the design space to appear.
I think you meant Swing, not Spring &gt; All in all, I think that GUI APIs are an unsolved problem and I expect multiple crates trying different sections of the design space to appear. You're so right. GUI is so damn hard that i think there is never a way to a "one goto framework/library/whatever for all systems and all languages". If its convenient then its mostly bound to a language and/or paradigm, which makes it hard for languages not following these. if its cross platform its either trying to use native elements which makes it a least common denominator or draws its own stuff which makes it look not native. 
Hello! My tips: * **Forget** about `unsafe`. Yes, you don't need it. Just forget it exists in the language. You can do almost everything you need in safe manner. The main thing in rust is safety, so don't ignore it ;) * Don't use static variables without need. That's the first place of troubles in multithreaded code. Better use something like reference counting primitive (`Arc`/`Rc`) and pass the state of world everywhere. * Learn better about error handling in rust. Use `Result` and `?` operator. Don't overuse `expect`. * Use `rustfmt` for code formatting. Your code style is not perfect and not idiomatic. * Don't use raw strings as identifiers. Better prefer to create enums. It allows you to control everything in compile time. * Don't mix pub and private fields in struct. Use private fields and getters with setters. You should make api safe. * Learn about combinators on `Options` and `Result`. The following code: &amp;#8203; match index { Some(num) =&gt; return Some(registry[num].get_accessor()), None =&gt; return None }; Could be prettier: `return index.and_then(|num| Some(registry[num].get_accessor()));` `and_then` also produces `Option` and inner closure runs only if `index` is `Some`, otherwise `None` returned. * When you don't care about data like here `if let Err(_) = try_delete_options(player.player_id)`, better to write `if try_delete_options(player.player_id).is_err()` * Instead of duplicated function call, you can return result reference and use it once: &amp;#8203; match class { Melee =&gt; tuples_to_vec(&amp;BABYLONIAN_GODS), Ranged =&gt; tuples_to_vec(&amp;CELTIC_GODS), Magic =&gt; tuples_to_vec(&amp;HINDU_GODS) } // =&gt; tuples_to_vec(match class { Melee =&gt; &amp;BABYLONIAN_GODS, Ranged =&gt; &amp;CELTIC_GODS, Magic =&gt; &amp;HINDU_GODS }); * You like to format string with `+=` operator, prefer to use `format!` macro. &amp;#8203; match CONDITION { Ok(_index) =&gt; true, Err(_index) =&gt; false } // =&gt; CONDITION.is_ok() * Iterator with combinators sometimes makes code easier to understand &amp;#8203; for (area, (x, z)) in &amp;self.coords { if *area == typ { return Some((*&amp;self.town_num, *x, *z)); } } None // I'd write something like this =&gt; self.coords.find_map(|(area, (x, z))| { match *area { typ =&gt; Some((*&amp;self.town_num, *x, *z)), _ =&gt; None } }) &amp;#x200B; if let Some(ref area) = map[x][z] { if area.get_type() == "path" { return Some((x, z - 1)); } else { return None; } } // =&gt; map[x][z].and_then(|&amp;area| { match area.get_type() { "path" =&gt; Some((x, z - 1)), _ =&gt; None } }) * Curly braces are not often necessary: &amp;#8203; let index = effects.iter().position(| e | { e.name == name }); // =&gt; let index = effects.iter().position(|e| e.name == name); *Everything is only my opinion, some code could be written with possible mistakes*
This would very much depend on the workload, no? Specifically, if the web-application is CPU-bound rather than I/O-bound, I'd expect Rocket to pull ahead. So, for example, if it's a web-application which (1) retrieves a template from the database, which can be cached, and (2) generates a PDF document based on the template and parameters of the request, then I'd expect Rocket to outperform Node.
&gt; Rust 2019 — let us pursue composability Unfortunately, Rust's core goal of GC-free resource management and zero-overhead abstraction, does somewhat get in the way of compositionality as a basic property of the language. If composability is a core value for you, you'll find that other languages still do better than Rust.
I've actually never thought of composability quite this generally. To me, the first thing that comes to mind when someone says "composable" is "composition over inheritance" and [ECS](https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system)-like approaches. I love the ideas though!
&gt; If we had more people teaching it at an undergrad level that problem would go away. To be honest, I'm personally more a fan of academia NOT preparing junior engineers for language X or Y, but instead teaching a wide variety of programming language paradigms so that graduates can pick up any language and be at ease within a couple weeks/months. It seems that from a long-term perspective, since software engineers will likely use multiple languages in the course of their career, it is better to teach them to learn and show them how diverse the ecosystem is, rather than pigeonhole them into one "ready-made career" and leave them awfully unprepared for paradigm shifts and future developments. *Disclaimer: I was myself formed in a school which emphasized breadth over depth, and it has served me well, so I am definitely biased on the topic.*
Thanks for the comment! I don't think so though. If you read the blog post, it should become quite clear that I don't think of composability as restricted to a certain ecosystem and runtime. If that were the case, Haskell would be the strongest contender, and there would hardly be any practical language that would score even close. But I think of composability here as the practical ability of mix and match libraries, data types and functions across projects, languages and runtimes. Being as spartan as possible about the runtime requirements and being as flexible about requirements in general (as manifested by a highly generic/polymorphic typesystem) helps. Indeed, Rust's strive of zero-overhead abstraction might be at slightly odds with composability. But instead, I think that being GC-free makes it more composable than not. I wonder what languages you are thinking of? Zig comes to mind if you think in a certain way, and Haskell comes to mind if you think another way.
Will planeshift also work on Android?
With regard to logging, specifically, I think this is a special-enough case that it'd warrant being "white-listed" for `const fn`. I'd imagine a *per-evaluation* log buffer, which aggregates all logs of the given evaluation, and should evaluation fail (panic), then the log would be displayed to the user as part of the notes from the compiler, helping the user understand what the issue is. In the end, this is part of the idea of supporting a limited subset of I/O within `const fn`. However, while handling the Input part of I/O is relatively complicated (especially with incremental compilation), the Output part is seems much easier: imagine only accepting writes to files in a directory in `target/&lt;mod-name&gt;/&lt;file-name&gt;/`. This is self-contained, cannot affect the next compilation, and otherwise allows arbitrary writes (but NOT reads).
Why do you think you need a GC to compose a function?
Just thought I post a revision to my position on the **1.0** thing. Having learned a bit more about the orphans and traits and breaking changes thing, and also having seen the post about [Rocket 0.4](https://rocket.rs/v0.4/news/2018-12-08-version-0.4) with the note that ["Finally! Rocket 0.5 will compile and run on stable..."](https://rocket.rs/v0.4/news/2018-12-08-version-0.4/#whats-next) I feel like I understand the whole 0.x thing a bit better, and I accept that it's not just a cultural "Rust thing". My point about those version numbers holding back adoption (or even evaluation) of Rust itself still stands, though, and I still think that getting key libraries and crates, such as Futures, Tokio, Bytes, Hyper, Rocket et al to 1.0 is a good goal to aim for.
I plan on advocating for it in my 2019 post.
Recently I've been thinking about "move/borrow polymorphism", that is, functions that are polymorphic over argument passing style. Especially in cases the argument is `Copy`; it seems silly to have to put `&amp;` sigils to code like `map.get(&amp;1).unwrap_or(&amp;0)`. 
&gt; index.and_then(|num| Some(registry[num].get_accessor())) Even better, since the function always returns `Some`: index.map(|num| registry[num].get_accessor())
I did. Same result, although cool idea. could a Cell be a way forward? borrow checker complains about mutable borrows of thing. what if I made it immutable and used Cell for mutable stuff? never used Cell before...
You split your project into multiple, separate projects. Cargo allows you to have one project ("workspace") with multiple crates sharing dependencies, which should be easier to manage. https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html
“Sync” does not equate to slow. It’s a little surprising that the community as a whole has this mindset. It depends on the workload - both type and number of concurrent requests you’re handling.
If Rocket 0.5 is supposed to work on stable, is there any reason why it's not going to be Rocket 1.0?
Thank you so much for articulating so well what I also often contemplate. 
Hey! It looks like you did a great job! It's very impressive for someone who has just learned rust! My intention is not to discourage you with these recommendations, I just remember not being able to get recommendations on my own, and no one there to give me the feedback I needed. I hope you can benefit from this! &amp;#x200B; \#\[macro\_use\] is almost no longer necessary. You can now use the "use" keyword to import the macro, and then use it. &amp;#x200B; you use unsafe{} too much unnecessarily. Perhaps there is a better way to handle what you are trying to do. If you absolutely MUST use unsafe, only use it around the unsafe line of code you need. &amp;#x200B; Your toggle\_pause(...) can simplify things a bit more by using "\*is\_running = !\*is\_running;" &amp;#x200B; Your functions are missing documentation comments. Use "///" for documentation generation. You lack comments in a lot of your code. Some code of yours needs comments, and other code doesn't. &amp;#x200B; Adding Unit tests may benefit you in the long run. The cleaner your functions, the easier unit tests are to write. &amp;#x200B; Take a read at Martin's book "Clean Code" for more. &amp;#x200B; &amp;#x200B;
Isn't that more or less what `Borrow` is for?
The main reason that Rust isn't used for those kinds of classes is that schools want to teach students skills that will get them jobs, and Rust just doesn't have nearly as large of a job pool as C and C++ both do. That, plus the student employees that usually do most of the grading are probably gonna have no idea how to read some of Rust's more unique code at first. It would be nice though. I can think of a couple problems that took far too long to debug for projects in my Advanced Data Structures class that were all pointer/memory related and Rust would've solved immediately.
Most likely performing the custom formatting after is going to be the solution. I would encourage you to check out the `Bencher::bench` method. This can be used to get a `Summary` of your benchmark. [bencher](https://doc.rust-lang.org/test/struct.Bencher.html) [Summary](https://doc.rust-lang.org/test/stats/struct.Summary.html) In theory you could have one benchmark function that would manually call the others, providing the bencher argument and then sort the results. I am not sure it would be worth it, really. 
you'll have to provide some more context, because it is unclear what exactly you are asking..
I have used mpsc to communicate between threads and Mutex in a couple of places, but I've tried very hard to avoid using reference counting because it just seemed like I may as well use a garbage collector, instead. Maybe that's just the only safe option. Let me see what I can figure out. 
I mean the automatic return of function type.
&gt; I can't even read complex types in the language, they look like gibberish to me since I've never learned the language. I did mostly learn the language and they still look like gibberish to me. Good thing https://cdecl.org/ is a thing.
Is there no cargo subcommand check-deps?
Benchmarks should appear in alphabetical order. So then you can influence how you want them to appear, by using that. (Or a different benchmark harness of course!)
use super::STATIC_STR?
But why would you want to do this ? A more rusty pattern is if your main function passes around a struct with all your static stuff to the functions that require them.
If you try to use crate::STATIC\_STR inside of your module? https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=793a402e0effd94156846a3d0d0d81d1
Static's are pretty useless anyway 'cause mutable ones can't be used outside of unsafe code. If you want something that actually behaves like an immutable global, use a `const` if possible or the `lazy_static` crate if you must, and if you want a mutable global use `lazy_static`. Unless you're writing fairly low-level stuff then static variables aren't the best tool to do anything.
It can be a little confusing, but at at any point in Rust you have two namespaces for symbols. One is the local namespace, the other is the namespace of items visible from wherever you are. Any static is an item and `STATIC_STR`is visible from that method. But since it's not present in the local namespace, you'll need a [*path*](https://doc.rust-lang.org/stable/reference/paths.html#path-qualifiers) - I'm about 98% sure that replacing `STATIC_STR` with `crate::STATIC_STR` works. If you need to refer to `STATIC_STR` multiple times, `use` adds an alias in the local namespace. So `use crate::STATIC_STR`. Rust's system does eventually make a lot of sense, but it's a lot more disciplined about keeping the local namespace tidy than you'd find in most dynamic languages. And it's not the crazy mess that C (with the C preprocessor) can be. [Formally speaking `use` is a declaration](https://doc.rust-lang.org/stable/reference/items/use-declarations.html). It adds an alias to the local namespace for an item which already exists (usually this item exists elsewhere in the program). I can't find the reference for it right now, but IIRC the body of a `mod` declaration starts with a blank-slate local namespace (it only contains the `std` prelude). The same is true for a module in its own file. If you want to include the items from the parent module, `use super::*;` is a common declaration. You may also use `use` in the body of a function, to add aliases for items which are used specifically for that function. 
Take a look at [`impl Trait`](https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md), which is probably what you want.
This worked, thank you.
Every README on npm’s package pages is rendered by a Rocket service. Even just that is pretty huge.
The intention is to port it to a static site generator, since it doesn’t inherently need to be dynamic. Rocket was chosen while things were under heavy development to make things a bit easier.
I personally had make sure every single issue had been looked at in at least the past 12 months when we were at about 3200 issues. It is doable.
I've always seen generics/templates as great for composability, I do appreciate how trait bounds allow using them more extensively; I wonder if Rust will ever get module-level type-parameters - (e.g. imagine a whole maths library taking a Float type somewhere that can be swapped by the user for f32 or f64, without having to specify it on every function). I do miss the sharing of type-parameters throughout a class in C++, but module-level type-parameters would be superior to that. 
There have been quite a few proposed better designs. For example: [this](https://github.com/rust-lang/www.rust-lang.org/issues/421#issuecomment-443098003). Community feedback on those alternative color palettes has been quite positive from what I've seen.
Feel free to post some specific examples, and we might be able to give you more specific guidance. Rc is the right approach in many situations, and GC is not a dirty word. Both of those design approaches should be preferred over static mutable state.
The functions `game_time` and `update_game_time` offer a safe interface to a data race. That’s a bug. Reading and incrementing an `u128` are no atomic operations. `unsafe` is only for interfacing with the hardware directly/for FFI. Maybe also for optimizations, but only as a last resort. That’s it. You should basically never use `unsafe`.
That font choice is horrible. Raleway is a heading font, and definitely not a body font. It's far too light to be used at anything beneath 50pt.
I'm currently working on a similar library for python, and I think that this is a great idea. One note: services and signals are very different between Windows and Unix, so make sure those areas are quite extensible. Also, file-watching being implemented with signals seems unnecessary. Was there any reason that you didn't just use a separate thread or process to implement that?
I actually have no idea why I chose that, it's inherited from styles I wrote many years ago. Switched back to just generic families since I don't really care about your specific fonts.
Granted I'm just a beginner, but I have been looking into async Rust and it is very complicated. I cannot even find good and easy documentation for really basic examples like the TRPL does them. So I created a really easy example. Could someone fix this for me? I'd really appreciate it. I'm also willing to make a tutorial for this once I understood it. #![allow(dead_code, unused_variables, unused_imports, unused_mut)] use std::thread; use std::time::Duration; fn main() { println!("Starting main"); let result = long_running(); println!("{}", result); println!("Finished main"); } fn long_running() -&gt; String { println!("Starting long running function"); thread::sleep(Duration::from_secs(3)); println!("Finished long running function"); String::from("This was returned") } I have a long\_running function that waits 3 seconds and then returns a String. How can I do this with async/await ? I don't want to be using futures (only), but the actual async/await syntax that will be coming in the next version of Rust. Thanks so much in advance!
Those looks great! But this discussion (not to put any blame on you to politely trying to let me know relevant information! sorry if this comment sounds like that) is pretty much bikeshedding and will lead to nowhere.
This happens when nightly makes a change that breaks rustfmt's usage of rustc. You have two options, either: - wait a few days and keep upgrading nightly nightly until it's fixed and rustfmt is available again - downgrade to a specific nightly with `rustup update nightly-2018-12-01` and keep downgrading until you're before the breaking change. You can test with `rustup component add nightly-2018-12-01 rustfmt`. To use the downgraded toolchain you'll need to use the date in the toolchain name everywhere, as this is installed alongside the latest nightly. When nightly has rustfmt again, and you install it, you should be all good. Once you have `rustfmt` installed for a toolchain, it _should_ stop you from upgrading if the newest nightly has broken it. It'll say something like 'newer nightly doesn't have component rustfmt' and stop the update.
Rust noob here. let vec = vec![1, 2, 3]; vec.iter().next(); Coming from Swift, I was quite surprised this code compiles. `next` requires `&amp;mut self` even though `iter()` returns an immutable `Iter`. So what's happening here? Is `next` allowed to mutate the iterator because there's no other reference to it? It's not quite intuitive for me yet, but I understand how this can be useful. And also, shouldn't the compiler warn that we're ignoring the result here? It makes sense that you may sometimes want to call `next()` on some iterator without using the result, but here it doesn't really achieve anything because the iterator is directly discarded (unless I'm missing something).
Working on Amethyst means that you are working on independent, composable crates. &amp;#x200B; Amethyst is merely a high level wrapper over the other crates we are contributing to. * amethyst\_core: Specs wrapper * amethyst\_audio: rodio wrapper * amethyst\_locale: fluent wrapper * amethyst\_gltf: gltf wrapper * amethyst\_ui: gfx\_glyph wrapper and soon a ui layout wrapper (the layout logic won't be embedded into the crate anymore) * the list goes on.
How do Drops work with references? If a reference to something in the stack in an async function is passed as argument to another async function, what happens during a drop? What if that reference is e.g. a buffer passed to an async IO function that will fill that buffer with bytes from the network and awake the future when thats finished?
I agree with you 100%, but I'm looking at this like a MATLAB or Photoshop situation. Hook em on the tools in college to teach the theory, and they'll use the tools when they enter industry. 
The [rustfmt](https://github.com/rust-lang/rustfmt) installation instructions still say to install rustfmt-preview: `rustup component add rustfmt-preview`. I *think* this may be your problem. This was actually a point of confusion for me a couple days ago with the Rust 2018 release announcement. I had assumed that rustfmt should now be installed using the non-preview variant, but the README hasn't been updated to reflect that.
A big milestone would be the ability to create UWP components as seemingly as C++/WinRT.
The tooling that comes with the engines is also very relevant. Asset pipelines, graphical shading languages, debuggers for gameplay, GPGPU, profilers and the ability to cross reference the graphical data with the code that it originates from.
It will work via the GL fallback, but it won't really provide performance benefits. I looked into this, and Android's *public* APIs don't provide the necessary functionality to support `planeshift`. We would need Google to expose the native SurfaceFlinger API--in particular, the transaction support--as part of the NDK.
`.iter()` does not return an immutable `Iter`, it returns *owned* one (and even the phrase "returns an immutable `Iter`" does not really make sense - it's either bindings or references that could be called mutable or immutable, not values). That owned temporary value can be auto-borrowed as mutable reference, so that's why you can call `.next()` on it. Also, the compiler does not know whether calling `.next()` is going to have side effects, so that's why it does not warn that you don't use its result. Iterator functions like `map` and `filter` simply wrap up their arguments in new iterators without doing anything else, so they are annotated with `#[must_use]`, so calling them and then throwing away the result will generate a warning. Also, `Result` is annotated with `#[must_use]`, because most of the time something returns a result you really don't want to ignore it.
&gt; next requires &amp;mut self even though iter() returns an immutable Iter Not quite. `iter()` returns an `Iter` struct - a value, not a reference. Values don't have mutability, only references and bindings (variables, arguments), so a value not bound to a variable is effectively always mutable. Since it's "just" a value, you have ownership over it and can therefore mutably borrow it. The call to `next()` automatically borrows the iterator as mutable. &gt; And also, shouldn't the compiler warn that we're ignoring the result here? The compiler only warns about unused results when the function or data type is marked with the [#\[must_use\] attribute](https://doc.rust-lang.org/reference/attributes.html#must_use) - most notable use case being `Result&lt;T, E&gt;`. In this case it doesn't, since as you said there are times when you want to call `next()` without consuming the result. There could be an optional warning for your specific example, but I think it would be better integrated into a linter like [`clippy`](https://github.com/rust-lang/rust-clippy) rather than the compiler, because it would require special knowledge about the standard library (e.g that `next()` only mutates the iterator and is otherwise a pure function).
&gt; Do I need to switch between stable and nightly now every time I want to run cargo fmt or am I missing something? Nope, you can `cargo +stable fmt` (even better: get your editor to run this on save so you never have to think about it). Honestly I'd just drop the nightly rustfmt and use the stable one; while the formatting will be slightly less awesome you won't have commits that are mostly noise due to a nightly rustfmt change.
I like that we independently produced very similar answers!
Are you looking for C++'s return-type deduction?
Nice article! It's always a good reminder that a lot of the "magic" async stuff we like to do is really just a state machine, one that's not complicated in concept but comes with a lot of fiddly little parts. Which makes me wonder, if async is a nicer way of writing state machines, could it be useful for other things such as handling UI events or parser combinators or other non-IO tasks? Things you would represent as a state machine anyway...
Dropping the environment happens exactly the same as if the function had returned at the yield point. The variables stored in the generator environment are dropped in reverse order of their declaration. So first the future returned from the other async function you called would be dropped, that would unregister the buffer you had passed it from wherever it had set it up to be filled. Then the buffer itself would be dropped, and deallocated if it is on the heap; this is safe since when you previously dropped the future it had to release its borrow of the buffer. This is all checked by the borrow checker, since the lifetime of a reference must end before the referent is dropped.
Will stable rustfmt and clippy understand code that only compiles on nightly?
&gt;Values don't have mutability, only references and bindings Thanks! This made it really click for me. &gt;The call to `next()` automatically borrows the iterator as mutable. Is it fair to say that `vec.iter().next();` is shorthand for `(&amp;mut vec.iter()).next();`? Yesterday I learned that a method call automatically borrows/dereferences the value as needed. Is that what's happening here?
&gt;(and even the phrase "returns an immutable `Iter`" does not really make sense - it's either bindings or references that could be called mutable or immutable, not values) Thanks, this is what I was missing! It makes a lot more sense now.
It sounds like working on amethyst means you are working on a bunch of wrappers. Attention could instead be directed to specs/rodio/fluent/... directly.
This is already how many UI systems work in other languages. 
I understand this is not the exact code that rust generates but why is ManualGenerator represented as a struct and not an enum? As an enum the optimal struct packing problem would be a variant of enum packing where you wan't similar fields to line up right? Or am i missing something here?
 #[derive(Debug)] enum Testing { A(String), B(String), } fn main() { let s = Testing::A(String::from("This is an A")); println!("{:?}", s); } Is there a way to access/print out only the String "This is an A" from the enum? Something like `unwrap()` (which doesn't work in this case) ?
Maybe a minor point, but the article implies that C# represents async/await as a simple continuation passing style transformation. It isn't; it actually has the same state machine approach that Rust is implementing, for similar performance reasons.
That should be about right, yes. Furthermore AFAIK the compiler will create a temporary variable for the result of `vec.iter()`, as you can't take a reference to something that doesn't have a memory location. So in theory it's closer to this: ``` let mut temp1 = vec.iter(); (&amp;mut temp1).next(); ``` This is also why you can pass a reference to a literal as a method argument e.g `&amp;3`.
I'd say either the TRPL or "Rust by example". Both can be found here: https://doc.rust-lang.org/
As I see it, there are two choices: - `enum`: optimal memory packing. - `struct`: immovable fields =&gt; stability of pointers/references. And there performance concerns if moving fields too much in the `enum` case. It's not clear to me that the memory packing matters that much, all things considered. I guess it'd vary from one function to another.
Because you can keep internal references alive across state transitions you cannot move any of the “stack” variables after they’re created, so you couldn’t move from one state to another as that requires moving the variables out of one the current variant and repacking them in the new variant.
Haskell's do-notation is probably what you're looking for. Async/await can be seen as a specialized case of that. [Here's an example of do-notation for combinator parsing](http://book.realworldhaskell.org/read/using-parsec.html). You can think of `&lt;-` in those examples as equivalent to `await`. Unfortunately interaction with mutable state and lifetimes would make designing a generalized do-notation for Rust a rather daunting task.
Hey, thanks. I appreciate that. Actually, I do have an example, which is time-based events. Scheduling timed events requires access to two things: the current game time (not the actual time, which can be retrieved from the OS), and the timed event registry. Updating and processing all timed events is fairly easy without using static variables. * The first step simply declare `let mut timed_events: EventRegistry = Vec::new();` as well as `let mut game_time: u64 = 0;` and let both of those stay exclusively in the main loop. * Then, when it comes time to update the timed events, you call a function which accepts references to both variables and uses them to process the events. However, registering new events is not nearly as straightforward. Let's say I have an item that needs to inform the player that some effect has been applied. In order to do this, the item schedules a series of messages to be sent: * the initial message, which informs the user of the new effect, and * a second message, which will inform the user when the effect has worn off. This is a bit of an oversimplification, as the effect itself now also needs a reference to the event registry in order to send the message, and of course, something external will probably need access to both of them in order to trigger for the effect to be removed. You can start to see how this has spilled over for me. And moreover, there are lots of other locations that need to be able to schedule timed events (or access the game time) at will. For example: * Multi-part messages (again) * Potion effects (again) * Enemies attacking the player and vice-versa * Any other item use, as items have cooldown timers * Temporary activities that occur within towns * Temporary player dialogue * etc. So the question becomes, how can we allow each of these domains access to schedule timed events at will? I'm able to think of three solutions, which each have drawbacks: * Allow each of these variables to hold weak references to the event registry and game time (as well as any other registries they might need, such as a shop additionally accessing the item registries, and so on). * This requires a lot of boilerplate and an enormous number of references to be stored. I'm also not sure how I would serialized it to create save games, but I'm sure it's possible somehow. * Handle all time-based events through a game-update system, much like the majority of other games, wherein all active towns are updated each tick, and those towns will pass access to the current game time and necessary registries to all currently-active entities. * This may be the best of the three solutions. Perhaps I'm lazy, but it just felt a little extreme for a text-based game, which doesn't need to constantly render entities or keep up with their movement and velocity and things of that nature. * Use questionably safe / technically unsafe code in order to share access to static variables within a single thread only. * This has the potential to be implemented in a way that does not produce data races or any such issues, *but* it technically *allows* data races to occur, should the code be used incorrectly. Of course, I understand how the point of Rust is not only to create create code that is free of memory unsafety, but to actually create code that is *incapable* of leading to memory unsafety. Trust me, I love that and am not hear to complain about it. And I want to be very clear that avoiding this "unsafe" code is my preference, as well. I'm just slightly weary about its necessity in all applications, beyond good measure alone. So, I guess my question for you (or anyone else) would be: which of the first two solutions do you prefer, or are you willing to provide another alternative? 
Tried to clarify that, it's more that it's normally explained as a CPS-like transform rather than how it's actually implemented; and in C# that vs a state machine is not really visible, whereas a CPS-like async transform would behave very differently in Rust because of borrowing.
This, read the rust book, it's excellent and often considers users will be coming from a different language.
Hey, thank you so much for taking the time to write all of these. Most of these suggestions are fairly easy to implement and I'll definitely get right on it. My only uncertainty is handling identifiers without raw strings. Enums are definitely a much better option, but they don't allow an external source to add new types. I'm thinking that what I'll do is just use a `Custom` type that holds some other kind of secondary identifier. Anyway, thanks again!
Oh nice. I didn't realize that. Thanks!
That's pretty irrelevant for namespaces and name resolution though; consts and statics behave the same way.
It's true that this should probably use `const` rather than `static`, but global string constants definitely shouldn't be passed around in a struct.
&gt; if i had a cheatsheet or something I would at least be able to start getting a grip of what's going on without having to read an entire book about the language Here it is: https://cheats.rs/
Thank you for the positive feedback! I'm obviously new here, but I know I've got a long way to go. * I worked on removing the last few instances of `#[macro_use]` this morning and am working on refactoring things now. * I've been aware of how unit tests were handled in Rust and did have a few of them initially, but I removed them once I got the game running and sort of stopped. I see the advantage in adding more, however, and will definitely do so either soon or in future projects. * I'm also working on refactoring my code, at the moment. I've always disliked the comment style in Rust, but I also see the value in adhering to community standards and will be adjusting. * "Clean Code" is definitely a good suggestion and something I've had my eye on for a few months now, but I still haven't gotten around to reading it, outside of classes and whatnot, but I do plan on doing that as soon as I get the time. Thanks again! This was very helpful.
You could implement an equivalent of unwrap for Testing: impl Testing { fn unwrap_a(&amp;self) -&gt; &amp;str { match self { Testing::A(s) =&gt; s, _ =&gt; panic!("{:?} wasn't actually A", self), } } } or as a one-liner: println!("{:?}", if let Testing::A(a) = &amp;s { a } else { panic!() }); &amp;#x200B;
tangentially are there any resources that specifically compare languages , e.g. "from langauge X to language Y" I think you could probably map a lot o the standard libraries this way (stick boost on there for C++) 
Sex. I know I could've googled a cheat sheet but I like to go by recommendations so I appreciate it
Could you give me some feedback on what can be improved to make Specs more of a library / more composable? That definitely is a big goal, so I'm wondering what makes it appear as framework?
That's what I thought / hoped for when I first saw the `let x = &amp;[1, 2, 3];` syntax. Thanks again!
Thanks. This is now an atomic value.
Just glanced through the code. A quick question. How does truncate and get_mut interact?
Five seconds ago, bad things. Now, panics. :)
&gt; don't allow an external source to add new types But then your code isn't going to be able to handle those values. One further thing is to use a World struct instead of the globals, you could pass this into each function... or better yet, these can be methods on the World. Don't be afraid to have your functions take arguments, they make it clear that they are acting on/modifying. Functions without arguments are a red-flag/anti-pattern in any language. And they'll be no need for unsafe.
In one sense, async/await is a specialized case of do-notation... but in another sense async/await is more general. It handles all of Rust's imperative control flow, while do-notation requires extra work to "lift" the recursive functions it uses instead. And really it's not so much mutable state that makes a Rust do-notation difficult, but the types involved. The type of `(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b` requires a single type constructor `m` for all values that get piped through a particular instance of `Monad`, but `Iterator` and `Future` are traits instead of type constructors. `&gt;&gt;=` also requires a single type constructor `-&gt;` for all functions, but again Rust uses traits here. (Three of them!) Do-notation also relies heavily on tail call optimization, which Rust does not guarantee. Further, to support Rust's full control flow, we'd need a full CPS transformation, rather than Haskell's simple straight-line one, which only makes the above problems worse. See this Twitter thread for more: https://twitter.com/withoutboats/status/1027702531361857536?s=19 So /u/icefoxen- you probably don't want to use do-notation as your generalized async/await. Instead an algebraic effect system is probably closer to what you want. This codifies the concept of "sticking `async` in front of `fn` and gaining a new operation inside." But in the short term, async/await is already useful on its own for UI events and some other state machine-y things.
How come the latest nightly toolchain is from 2018-12-07? Aren't these created automatically every day?
I tried really hard for days now but I can't get my code to compile: This is the relevant function: ```rust fn part_1(input: &amp;str) -&gt; usize { // The idea is to drop characters from input into v one by one. If // the new character c and the last character d in v react then // they both vanish. If they don't react then v gets a bit bigger // and we go for the next drop. // For the example input "AaBCDd" I would expect a vector // v = 'B', 'D' (because A and a react and D and d react) // so the returned length would be 2. let mut v = Vec::new(); for c in input.chars() { match v.last() { None =&gt; { // v.push(c); } Some(d) =&gt; if react(&amp;c, &amp;d) { v.pop(); } else { // v.push(c); }, } } return v.len(); } ``` Link for the complete code in Rust Playground: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=dcb14fd6da0f006fffb25f34b16e8a9d For some reason I don't get the error in the playground, though. What I want is to uncomment the two lines with `v.push(c);` but I get this error: ``` error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable | 15 | match v.last() { | - immutable borrow occurs here 16 | None =&gt; { 17 | v.push(c); | ^ mutable borrow occurs here ... 24 | } | - immutable borrow ends here ``` In my opinion `v.last()` and `v.push(c)` should not conflict since the one function is long done when the second one is called. Can somebody help me understand how to solve this, please?
Something about this is not sound... The following corrupts the heap and gives a core dump: fn main() { let strings = region_buffer::region_buffer!["Hello".to_owned()]; let mut el = strings.get_mut(0); drop(strings); el.push('x'); println!("{}", el); } 
Really what we want is somewhere in between, where the object is laid out the same way as a normal stack frame. Pieces of memory can be reused over the course of execution as old variables die and new ones come into play, but single variables with pointers to them still stay in the same place while this happens. IIRC async-generated futures do tend to be rather large, today, and this sort of optimization *is* definitely something we want to do. Maybe someone from the compiler team can confirm or deny?
I was wanting a data structure like this at one point! Thank you for sharing! One small critique: Wouldn't it be more idiomatic for [`RegionBuffer::region`](https://docs.rs/region_buffer/0.1.3/region_buffer/struct.RegionBuffer.html#method.region) to take a [std::RangeBounds](https://doc.rust-lang.org/std/ops/trait.RangeBounds.html)? This allows the caller to express more types of ranges (including unbounded and inclusive), and fits more nicely with `Vec` and `slice`.
I don't think calling Amethyst a wrapper does it great justice. It's clearly more than that. But it holds in its very principles to be very modular, and is highly dependent on the whole ecosystem. In other words, if it implements anything non-trivial, it is likely to either make it available as a reusable internal subcrate (such as amethyst_renderer or amethyst_ui), or give it a dedicated crate (such as laminar [networking], sheep [sprite packing], etc.). Amethyst is such a broad project that working on it implies you work on the whole ecosystem.
Maybe this was addresses previously, but my main concern with async/await transformations, is how are we going to debug panicked processes once problems arise? Would the gdb output make any sense to figure out what was the state of generators? Or maybe, optionally, the Debug instance of the 'immovable generator ' can tell in what line the last yield was?
I’d add read-write lifetimes to your list. I’ve written some code that would have been really nice if it could take a &amp;mut self and return a read-only reference to some inner field without “locking” the lifetime of self.
Awesome post! I was just recently trying to figure out how these transformations work, and whent up to the future_from_generator. Do you know where exactly in the compiler transformation to a state machine happens? A link to source code/implementation PR would be awesome!
I've been toying with a macro to implemented a QML style UI, fully in rust: [https://github.com/ogoffart/propertybindings-rs/blob/master/examples/plusminus.rs](https://github.com/ogoffart/propertybindings-rs/blob/master/examples/plusminus.rs#L42)
I'm probably having a brain fart, but I don't understand why your last unit test compiles: 1. [`truncate` takes `&amp;mut self`](https://github.com/Aaronepower/region_buffer/blob/548f30ac109dd76ed6983fae1bddaf4f59d0ea22/src/lib.rs#L183) 2. [`get` takes `&amp;self` and returns an `Element` that borrows `self`](https://github.com/Aaronepower/region_buffer/blob/548f30ac109dd76ed6983fae1bddaf4f59d0ea22/src/lib.rs#L211) 3. [`Element` implements `Drop`](https://github.com/Aaronepower/region_buffer/blob/548f30ac109dd76ed6983fae1bddaf4f59d0ea22/src/lib.rs#L378-L382) 4. [In the test](https://github.com/Aaronepower/region_buffer/blob/548f30ac109dd76ed6983fae1bddaf4f59d0ea22/src/lib.rs#L538-L544), you: 1. borrow `foo` immutably by calling `get` and then store result in `_a` 2. borrow `foo` mutably to call `truncate` 3. borrow `_a` is used again because of `Drop` How does this not end up with a borrowing error?
I love it too, it's aggressive but in a nice way. &amp;#x200B;
Looks like the same unsound behavior of `get_mut` as [this comment](https://www.reddit.com/r/rust/comments/a4o5yf/region_buffer_an_array_that_safely_allows/ebgah6i/).
Oh, yes this is a problem. Right now I can't find a way for this to consistently happen on macOS for testing.
Not really, I don't think so? As far as I know there's no way in Rust to express a function that's overloaded to accept both `T` and `&amp;T`.
Try running under valgrind?
Yes this is a problem. I can't get this consistently occur on macOS for testing though so a fix will take me a bit longer.
https://jsdw.me/posts/rust-asyncawait-preview/ this might help. Notably, there's an example using delays as well, and this is all about using the new async/await stuff alongside the existing Futures ecosystem :) 
That’s the gist of what has been discussed in [rust-lang/rust#52924](https://github.com/rust-lang/rust/issues/52924), the storage space of the generator should be treated more like just a big bag of bytes that can be reused for different purposes as needed.
Your problem is wrong lifetimes on [`get_mut`](https://github.com/Aaronepower/region_buffer/blob/45d6c7b7754a1c420eea3fad17691d8b66fb3180/src/lib.rs#L222): pub fn get_mut&lt;'a&gt;(&amp;self, index: usize) -&gt; ElementMut&lt;'a, T&gt; { ... } Instead of `&amp;self` it should have been `&amp;'a self` - right now returned element does not borrow the `RegionBuffer` at all.
* Try [prettytable-rs](https://github.com/phsym/prettytable-rs). * Prefer if let Some(x) = value { /* use x */ } to if value.is_ok() { x = value.unwrap(); } --- Onto the borrowing problem. If you want to avoid using owned strings, look at the documentation for `Regex`: pub struct Regex(_); impl Regex { pub fn captures_iter&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t str) -&gt; CaptureMatches&lt;'r, 't&gt; } impl&lt;'r, 't&gt; Iterator for CaptureMatches&lt;'r, 't&gt; { type Item = Captures&lt;'t&gt; /* elided */ } pub struct Captures&lt;'t&gt; { /* fields omitted */ } pub struct Match&lt;'t&gt; { /* fields omitted */ } impl&lt;'t&gt; Match&lt;'t&gt; { pub fn as_str(&amp;self) -&gt; &amp;'t str } What binds these structures? The lifetime `'t`, which originates from the function `captures`, where `'t` is the lifetime of the original string. So for as long as this string lives, you can access the `&amp;'t str` capture matches. Your problem was borrowing from the `CaptureMatches` directly with `&amp;cap[..]` which binds to the lifetime `'r`, which is dropped at the end of each iteration of your loop. I've refactored your code to use `HashMap&lt;&amp;(&amp;str, &amp;str), &amp;str&gt;` [here](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e9552cdd0e6e69f48e0bfbf0e0b86dc0).
[this link](https://github.com/japaric/rust-san/blob/master/README.md) might be of some help. Your main issue here is that your ElementMut doesn’t hold on to your Region, so nothing stops the region from being dropped while you have live references to it. The simple workaround would be to create a drop implementation that panics if there are any outstanding borrows. That wouldn’t be so ergonomic though. Maybe this could be solved by each element holding a non-mutable borrow to the region struct.
/r/rustjerk would probably appreciate this more
There is a little support for debugging into generators currently, you can currently step through and inspect upvars. I have a change that also supports inspecting the “stack” environment, and I think the actual stack variables might work already but haven’t checked. The other thing that’s probably needed is being able to step to the actual location you care about, stepping to the “next” statement from an `await!` probably doesn’t go where you mean currently. Hopefully gdb is extendible enough that this should be possible to support, have it detect you’re in an `async fn` and use some script to calculate what “next” actually means.
That doesn't seem to effect it. I've [filed an issue](https://github.com/Aaronepower/region_buffer/issues/1) to track this.
Initial release of a Rust-based Alexa Skills SDK, to go along with the recent release of the Rust runtime for AWS Lambda. Would love feedback, issues, opportunities for improvement, etc.
Have you looked in to using an existing library like https://www.amethyst.rs/ . Or are you wanting to roll your own for fun?
[This validation](https://github.com/Aaronepower/region_buffer/blob/45d6c7b7754a1c420eea3fad17691d8b66fb3180/src/lib.rs#L197-L199) is not thread safe. You have implemented Sync for RegionBuffer so some other thread may have mutably claimed the same region in between those two lines. This is unsound because you would end up having handed out multiple mutable borrows of the same data.
You still wouldn't me able to call methods requiring `&amp;mut` on a partially borrowed struct, because this "locks" the entire struct rather than just the fields that are being used. So what would be the benefit of this feature?
Currently it looks like stable rustfmt understands the async/await syntax but clippy does not. Since clippy runs the compiler, I think it unlikely to support nightly-only code.
You’re probably right. Saw a blog post discussing this issue a while back and thought it’d map well against my use-case, but I think I might be wrong.
Thanks for your suggestion! I've implemented and published the workaround while I try to work on something more ergonomic.
I'm pretty sure they are different, but I don't know anything about Windows, unfortunately, so I can mostly just hope. But there sure must be \*some\* trigger to call the \`reload\_config\` method (the application can call it itself too). Becoming a daemon is actually in one of the sub-crates, there can be a completely different one for Windows. so I believe it is something that can be made to work. &amp;#x200B; I'm not doing file watching at all. Reloading config on SIGHUP is an old custom for unix daemons, something most daemons do. Reloading as I save the config in the middle of editing it seems like a bad idea anyway.
 fn foo() -&gt; impl Any { vec![0u8] } Will this return a `Vec&lt;u8&gt;` or an `Any`?
Ah, I misread the part about SIGHUP. I figured it was an old Unix convention, but wasn't sure. As for my library, it's not yet released, and I'm under contract not to distribute any source until v1.0 is officially released. Sorry.
It is still unsound with your fix. I left a comment in [Aaronepower/region_buffer#1](https://github.com/Aaronepower/region_buffer/issues/1) demonstrating that it still corrupts heap.
But values won't move if their variants overlap in their packing right? That's part of what i tried to say with 'fields lining up'. 
To check the current status of the various components (rls, rustfmt, clippy, etc.), check out this site: https://mexus.github.io/rustup-components-history/x86_64-unknown-linux-gnu.html You can use that to see how far back you need to go to find a working build.
I filed [Aaronepower/region_buffer#2](https://github.com/Aaronepower/region_buffer/issues/2) with some code that triggers the race condition.
It's monomorphized into a Vec&lt;u8&gt;.
I most likely would not write a serious game using something I had written from scratch. The reality is that writing a game engine can be monstrously difficult and usually requires large teams of people working together for some time. Without using an existing game engine such as Amethyst, I'm definitely a lot more prone to errors. But, that's not why I'm here. I'm not here to write a good game or even necessarily to contribute to any community (yet); I'm here to learn. So far, I've accomplished a server-client interface, a system for managing time-based events, 
I mean, both? It returns an anonymous type that implements `Any`. However, you could attempt to downcast it to a `Vec&lt;u8&gt;` and it will probably succeed. `Any` and `impl Trait` really shouldn't be mixed in most code.
Somewhat related, but allowing custom return types from `Deref` and `DerefMut` would help crate authors write APIs that could mitigate this (like RAII patterns around Arc&lt;Mutex&lt;T&gt;&gt;, property listeners, etc)
Yes it would be, this is something I hacked together at RustFest. Once I've fixed the soundness issues I'm definitely going to work on the API and making it more idiomatic and more like Vec.
[This post?](http://smallcultfollowing.com/babysteps/blog/2018/11/10/after-nll-moving-from-borrowed-data-and-the-sentinel-pattern/) If not, probably one of the other posts on this (Niko's) blog.
Which discussion do you mean? The discussion in that issue, or this thread? This thread exists because attempts to contribute via discussion on Github issues and/or forking have been pretty much universally rejected and locked if they happen to have to do with a particular set of problems. Since discussion of this set of problems is apparently out of scope for direct contribution or discussion in that context, this thread exists. This thread actually serves two purposes in my mind. First, it allows discussing the category of issues that tend to get locked when discussed on the Github repo (color choice, design, general content, tone, and accessibilty). Second, it allows discussing the sort of "meta-issue", which is the fact that discussion or contribution on those topics are being rejected in a way that indicates that serious community feedback and contribution on this site is not welcome.
I mean the description of `Borrow&lt;T&gt;` is a somewhat more flexible version of that. Likewise `AsRef&lt;T&gt;` but that one doesn't seem to have a blanked implementation.
I understand, that's why I asked. Have you checked the performance impact of using things like arcs? The performance hit might not even be an issue for what you're doing.
This is not correct. This function returns a Vec&lt;u8&gt;, not a trait object that can be downcast; however, attempts to use the value as a Vec&lt;u8&gt; will fail to typecheck (and indeed fail to infer the correct desugaring of method calls).
Ahh, I had missed that managed State&lt;T&gt; simply requires that T is Send+Sync - meaning that thread-safety is the responsibility of T. Yes that looks like a good fit then. If that proves cumbersome I suppose the handlers could be curried functions such that they already have the services baked in (hiding the implementation from the mounting code). Thanks, I'll have another play. 
Hey, as the author of this cheat sheet I'd just like to say that you are exactly the audience I wrote this for. If you think anything is unclear or missing, please let me know (or file an issue)!
hey, I wrote this within a few hours for a [registry][0] I wrote with rocket that lacked proper error handling. I really like failure and using `?`, but it that meant the api returns `500` for every error. I remembered failure has a ResultExt to extend `Result&lt;T, E&gt;` and I've used the same to add additional information to the error case, like "should this error cause a 404" and adding custom error messages. This also addresses a minor nitpick I had about error reporting in general (not just rust): By default all errors are "private", which means the information is available, but hidden from the user. Instead you can explicitly add "public context" to an error message to display a message to the user. [0]: https://github.com/kpcyrd/sn0int/tree/master/sn0int-registry
Thank you very much!
You're probably right. I was able to convert the dialogue registry into a mutex and it does seem to be working thus far, but that's just one registry and, again, using registries seems to be frowned upon. :/
Submitted a pull request to fix safety issues: https://github.com/Aaronepower/region_buffer/pull/5
The very first thing in the README is a screenshot: https://github.com/BurntSushi/ripgrep/blob/master/README.md#screenshot-of-search-results What specifically are you looking for?
Thank you again for this PR! I've just released a new version `0.1.5` with changes included.
Awesome, glad to hear it. I'll definitely let you know if I run into anything!
Actually just found something small: the section Idiomatic Rust overflows, causing horizontal scrolling on mobile (not that my primary device for reading this kind of thing is a cell phone, just figured I'd let you know though).
It is correct, though. We both know that the compiler knows what type it really is, but from an outside observer it’s an anonymous type that implements that trait. You have to treat it as unknown. However, because the Any trait includes the downcasting stuff it would be possible to dynamically cast the anonymous type back into the vector. 
Could you use a generic type with the constraint `T: Deref&lt;Target=I::Item&gt;`?
This, ladies and gentlemen, is a perfect example of precisely why you should not try to out-engineer Rust's safety bars.
This is because the playground uses the 2018 edition of Rust coming as part of Rust 1.31,which added non-lexical lifetimes,allowing for more flexible borrowing. Editions are ways to opt-in into language breaking changes (which happen every 3 years or more) on a per-crate basis,while still being able to use the crate in combination with other crates using previous/coming editions. The default edition if it is not specified in `Cargo.toml` is 2015. You can use the 2018 edition by updating to the latest stable release using `rustup update stable`,running `cargo fix`,and finally adding `edition = "2018"` to the `package` section of the crate's `Cargo.toml`. [The blogpost explaining the why and the what of Rust Editions.](https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html) [The blogpost explaining all the things that came in Rust 2018.](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html) 
I gave a similar talk at Desert Code Camp 2018. The slides are here: https://github.com/mysteriouspants/dcc2018 IMHO getting people to switch languages is super hard, so I focused on what Rust brings to the table that the audience can learn from. To me, the biggest thing about Rust is the borrow checker and how it enables memory safety, which enables thread safety. I spent time establishing ownership, then kind of flashed through Cargo as the other biggest thing about Rust that I like. Those were my thoughts, but you should follow your passion, because that's what people will key into the most.
I have. You just forget about successful redesigns since they mostly don't get any feedback.
&gt; Composability as a core value Btw, when will the orphan rules become more permissive? It's very important for composability of crates (so that one crate doesn't have to know about the other crates it will be composed with).
One thing in particular that we didn't like was that it was an easy solution to just make the specs world own almost all our data, but if we needed to do one-off processing of said data we'd need to request a &amp;mut reference to the data (Resource) from the world, so the specs world becomes very "infectious" in the entirety of the program. We could have copied data in but that seemed more like a hack.
Amethyst developers are also developers of the individual crates. Working on Amethyst is not mutually exclusive to working on something else. Amethyst is the user-friendly packaging of these amazing projects that provides a good experience for common game dev.
I was wondering what happened to Ruma. Glad to see it's not dead.
 &gt;I can't get this consistently occur on macOS for testing you could always spin up a VM. I keep a couple Linux distros around just in case. 
There’s a new read-only parser in the `xmlparser` (and `roxmltree`) crates, which I have found to be very good so far. It was easy enough to consume its output into an AST with a simple `FromNode` trait, and few `attribute_optional`-like helpers based roughly on FromStr, for a format I’m parsing with lots of enums (CSL). In this case I probably wouldn’t have used a Serde version even if it were available, because I’m parsing human input and producing descriptive `codespan` errors with hints for common mistakes, but the parser seems like a good foundation, and I can see how you could translate those helpers into a custom derive macro.
I don't agree. I don't see this as something that tries to out engineer Rust's safety guarantees any more than RefCell does. Maybe look at it as experiment that's trying to use Rust's safety guarantees to provide a more convenient abstraction? It would be nice if the README documented the library's experimental status, and in particular, the costs incurred by using this abstraction.
I'm talking more about the use of _unsafe_ to work around data sharing limitations than providing safe abstractions around typically unsafe operations.
Is this a Windows only thing or something? I did not have to do this and was able to use clippy just fine on Linux?
Yeah they only messed it up on Windows.
Okay, thanks!
Good point! I agree wholeheartedly. I think I add that point to the blog post.
The transformation [exists here](https://github.com/rust-lang/rust/blob/9cb38a84e7d593106946cae8e25d9cdbf24751ee/src/librustc_mir/transform/generator.rs). It was added in [#43076](https://github.com/rust-lang/rust/pull/43076).
This is exactly how `[T]::split_mut
Hey, I posted here a few days ago about a borrow issue with a custom collection that I had. I tried the advice I was given and I still had the same issue. So I thought that I would see how the std library handled the same types of operations. Turns out that the std library has the same issue. Here is the code I tried below (Note: The code below requires nightly). #![feature(vec_remove_item)] fn main() { let mut vec = vec![1, 2, 3]; let two = vec.get(1).unwrap(); vec.remove_item(two); let len = vec.len(); } I go the following output from the compiler error[E0502]: cannot borrow `vec` as mutable because it is also borrowed as immutable --&gt; src\main.rs:6:5 | 5 | let two = vec.get(1).unwrap(); | --- immutable borrow occurs here 6 | vec.remove_item(two); | ^^^^-----------^^^^^ | | | | | immutable borrow later used by call | mutable borrow occurs here error: aborting due to previous error For more information about this error, try `rustc --explain E0502`. error: Could not compile `demo`. I figure this issue happening on the standard library means one of a few things: * I don't fully understand the borrow checker (most likely) * There's an obvious work around to the code I'm missing. * I've run into a limitation of what the language will allow me to do. It seems like the mutable reference should have gone out of scope when the `remove_item` function returned. Then why does the second immutable borrow complain that there's an outstanding mutable borrow? Can someone explain to me how the scope of a borrow passed to a function works and what the work around to this particular piece of code would be.
Good luck! I’m working my way through the problems with Rust this year too.
Thanks and to you! Rust's closure and iterator suite makes my life so much easier
\#!\[feature(vec\_remove\_item)\] fn main() { let mut vec = vec!\[1, 2, 3\]; let two = \*vec.get(1).unwrap(); vec.remove\_item(&amp;two); let \_len = vec.len(); }
I think your mistaken, this is the Rust programming language subreddit
Nevermind, I looked back at the original answer I got and I think it makes sense now.
How come "vec\_remove\_item" is nightly-only experimental API ? It's a super basic thing!
ya I am, I have no Idea how to use Reddit lol
Cool, so I really should write the buffer filling future by hand so it can detect the Drop or reference count the buffer. Cause right now that buffer is passed to a C function as a pointer and then I await a oneshot Receiver, while the Sender is also passed to that C function. When the C function asynchronously finishes filling the buffer it calls back a callback I pass and in there I complete the Receiver. So if anything is dropped I get a load of dangling pointers. Thanks for the thorough reply!
Because it can be written in term of iterators it wasn't as urgent. Here is how to express it with iterators: let mut vec = vec![1, 2, 3]; let two = &amp;vec[1]; if let Some(removed)=vec.iter().position(|x| x==two ){ vec.remove(removed); } println!("{:?}",vec ); assert_eq!(vec,vec![1,3] ); &amp;#x200B; [Playground link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=610c6dde7aafe061f29afab47151a873) It's not pretty,but it can be used in stable.
You should probably yank the unsound releases. It won't prevent people from using the code, but I'll help :)
Update: Nrc says you cannot rely on rustfmt to play nicely with nightly code.
The problem is that the iterator over `objects_slice` borrows the slice mutable, because you may mutate each element in the for loop. But you also try to pass the whole slice to the `move_by` function. So, you try to create two mutable references pointing to the same slice, one for the whole slice and one for some element of it. This could lead to iterator invalidation or such. I suggest collecting a list of what move to make for each object, then applying them in a separate step. Or you might be able to just pass a reference to the current object into the `move_by` method, since it doesn't look like you need the whole slice.
You could call \`&amp;self\` methods. It's not a use case that comes up often but when it does happen it's really annoying to work around.
Now this was so usefull, thank you. I will need some time to read all of those links, but I could make my program work, which was super motivating. I guess v.last() still borrows v but gives it back after cloned because the borrowed value isn't used anymore? Is it possible to determine which values to pass by value instad of passing by reference? My thought was that when I pass them as borrows I have the garantee that they can't be messed with, and since I didn't intend to change them in any way that was a good thing. Thank you again, I will write a lot of code today.
&gt;Is it possible to determine which values to pass by value instad of passing by reference? My thought was that when I pass them as borrows I have the garantee that they can't be messed with, and since I didn't intend to change them in any way that was a good thing. They are mostly equivalent in terms of visibility of mutation,except for internal mutability. If you have a `&amp;` reference to an internally mutable type,you can mutate its contents in limited ways,and the mutation will be visible when returning from the function. The list of all (stable) internally mutable types in the standard library: * std::cell::{Cell,RefCell,UnsafeCell} * std::sync::{Mutex,RwLock} * std::sync::atomic::{AtomicBool,AtomicIsize,AtomicPtr,AtomicUsize} This is in case that you see these types out there.
Wow, thanks. This is pretty cool. I had the same feelings about the error handling in rocket.
Correct me if I'm wrong but isn't this something you could do in C++? 
It is explicitly mentioned in the video that the 2017 website redesign was scrapped.
The same speaker did the 2018 design.
Well then post some related links.
I think he goes on to talk about how he was indeed the one that later did the 2018 redesign too 
It's in the same talk at [16:14](https://m.youtube.com/watch?feature=youtu.be&amp;v=xzzz-1e6HCo&amp;t=974).
(they)
Post the more relevant part next time.
I think 13:30 is relevant context like "I actually had never built a website" and "There just wasn't really that much structure beyond like ugh we want a new design. But I don't really know that much about web site design so yeah. Since I'm a web developer I'm not really a designer it proved to be pretty difficult."
Post both then.
https://doc.rust-lang.org/book/index.html It's part of the official docs and by far the best intro to the language I've had. 
Go fjck yourself. The video starts at the exactly important tine for context. Not my problem he started talking about his mental illness. 
I think these are the other two developers mentioned in the talk: https://github.com/rust-lang/www.rust-lang.org/commits?author=technomoda and https://github.com/rust-lang/www.rust-lang.org/commits?author=efelger
I would Fasteriskck myself if I could.
Some unfinished things regarding rust, clippy and mutagen. $work and $life are still taking their toll, so my time is very limited.
Thanks! Yeah, I guess that is the most common usage of the word in programming circles – composing objects. But then again, you can compose almost anything. You can compose functions, and providing a library that has dependencies is actually composing those crates and your code into a whole. The only real requirement for composition really are that if the parts of the composition don't have any funny and surprising interactions that prevent them working together. Another thing that makes it easier is that the parts have "knobs" you can tweak to make them fit a bit better. That's parametric polymorphism, crate features, function parameters etc.!
If you have clippy and/or RLS installed, your toolchain only gets updated if those built successfully.
Me too, and I'm trying out [Pijul](https://pijul.org) and the [Nest](https://nest.pijul.com) for it too! The code is [here](https://nest.pijul.com/runiq/aoc2018), any comments are appreciated. :)
I'm still having the issue (in VSCode) with the latest version of rls (1.31.6) which uses version 2.1.16 of racer (which includes the changes in the PR you linked).
If I had money, I'd give you gold.
/u/icefoxen already explained the technical issue. I see a structural one here (which he also touched on briefly). Here is how your code operates. * Split off the first element from the slice. * Iterate over the rest, counting so you know at which index you are. * Pass the whole slice you're iterating over and the index **to the next element** to a function. * In that function, access the element by index. I am pretty sure that you meant to access the current element, not the next one. Even if that code compiled, it would panic at the end of the iteration. So, assuming you actually meant to access the current element, simply pass object to move_by. No need for any error-prone access by index, no need to fight the borrow checker over access too objects_slice. No need for enumerate!
&gt;Swing, is also widely derided as being ugly &gt; &gt;and &gt; &gt; bloated Is that accidental or necessarily so? The other wrapper toolkits i know of are IUP, Eclipse's SWT, Tk and libui.
new crate [https://docs.rs/env-lang/1.0.0/env\_lang](https://docs.rs/env-lang/1.0.0/env_lang) (edition 2018, 100% coverage) which return env LANG (like ``fr_FR.UTF-8@euro`` to struct with language, localisation, charset and variant like this ```rust EnvLang{ language: Some("fr"), localisation: Some("FR"), charset: Some("UTF-8"), variant: Some("euro") }) ```
A library (proc-macro) like [kaitai](http://kaitai.io/) where you define your file format in a YAML file but for serialization and deserialization.
and add screenshot for my another crate [my-pretty-failure](https://github.com/AlbanMinassian/my-pretty-failure) ![screenshoot default](https://raw.githubusercontent.com/AlbanMinassian/my-pretty-failure/master/assets/screenshoot_option.png)
I don’t know what happened or why, but I would wait for a blog post from the Rust team about what happened before jumping to conclusions. Something as important as a new website fully skipped the RFC process. Even if you disagree with the outcome, they might have their reasons and I’m sure that a lot can be learned about this when all those involved are given enough time to reflect on what happened.
It used to be the same way for me, but since I started coding AoC 2018 and updated all my components, RLS seems to be working fine for me on Windows. Still not very fast, still sometimes fails to give the right suggestions, but mostly it works. Which is a big difference from what I used to have, which is simply constant crashes of the RLS server.
On second thoughts you're right- I can't expect people to watch a video without context or some jist. 
As far as I know there's no way to control this currently. Even using `repr(C)` structs for the data of each variant doesn't guarantee that you will have those structs placed at the same offset for the variants. I also don't know of any way to change from one variant to another without at least logically moving the values (even if the compiler is able to elide the moving because they are allocated in the same locations).
Is it compatible with \`jq\` tool? 
You're looking for /r/playrust
I thought "Late Edit:" would give away that it is an edit?Also,don't know what about it makes you look bad.
&gt; Currently we have no stable library api that we intend to stand by. I think one way to fix this would be to provide a library that can call and interpret the results of `cargo metadata`. So that instead of using "cargo as a library", sub-commands would just use these other library that calls the cargo binary. &gt; Currently we have no stable library api that we intend to stand by. Hence the limited documentation. My issue with this was not that it's only hard to use cargo as a library because of this, but that because there are very few docs, it is hard to know how things are actually supposed to work, which is a pre-requisite to know whether they are working correctly or not, submit / fix bugs, fill issues, etc. I've worked on Rust projects of different sizes and by different people, and `cargo` was by far the most "spaghetti" project of them all. &gt; It is not formalized anyware. Do you have examples of the kind of formalization/documentation you would like to see? I'd like a detailed-enough specification of the dependency-resolution algorithm such that others can re-implement it from the specification. Dependency-resolution is a [Constraint Satisfaction problem](https://en.wikipedia.org/wiki/Constraint_satisfaction_problem), and there are multiple approaches and algorithms to deal with those, so it would be nice to know which exact algorithm / approach cargo uses and why. Rust programs rely on some invariants holding (e.g. only one global allocator, no cyclic dependencies, etc.), so it would be nice to have proofs that the algorithm appropriately terminates and detects these cases. Ideally, the dependency-resolution algorithm would be its own separate crate, etc. but this is something that could be said about lots of pieces of cargo. 
Constraint satisfaction problems (CSPs) are mathematical questions defined as a set of objects whose state must satisfy a number of constraints or limitations. CSPs represent the entities in a problem as a homogeneous collection of finite constraints over variables, which is solved by constraint satisfaction methods. CSPs are the subject of intense research in both artificial intelligence and operations research, since the regularity in their formulation provides a common basis to analyze and solve problems of many seemingly unrelated families. CSPs often exhibit high complexity, requiring a combination of heuristics and combinatorial search methods to be solved in a reasonable time. The Boolean satisfiability problem (SAT), the satisfiability modulo theories (SMT) and answer set programming (ASP) can be roughly thought of as certain forms of the constraint satisfaction problem.
I think [https://www.eclipse.org/swt/](https://www.eclipse.org/swt/) does a not too bad job. I wonder how it would feel without a GCed language.