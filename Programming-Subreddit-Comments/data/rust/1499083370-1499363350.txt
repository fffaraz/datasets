You may wish to look at https://github.com/Thinkofname/stylish. It's still pretty immature, but it looks like a promising start for pure-rust GUI.
How does oxidoc handle non-media HTML such as tables? Have you considered embedding a text-mode browser (elinks and friends) or using webkit and rendering to the frame buffer? 
unwrap_or_else sounds good, thanks!
I had lots of fun during the Kiev RustFest - definitely recommended for Rust enthusiasts and newbies alike! :)
After dabbling in Rust for about a year and a half, I've finally got around to trying it for the very thing that made me interested in the language in the first place: game development! So, I'm currently hacking on a simple Pong clone using Piston and related libraries *(which also entailed configuring a Rust dev env on my Windows machine; that wasn't as painful as I expected). It's progressing rather slowly though. It turns out the usual Rust fussiness is rather detrimental to prototyping games quickly. Simple stuff like sharing the state of game objects so that AI logic can observe them involves `Rc`/`RefCell` and all the associated boilerplate. Same for all the borrowing ceremony, especially with `Option`-wrapped values. Or the mandatory numeric conversions, even in trivial cases where C++ would just transparently perform a lossless promotion. But the worst offender is of course the compilation time, absolutely not conducive for tweaking constants and gameplay params. No wonder Piston devs started their own scripting language!
I started switching the design of my web browser [titanium](https://github.com/antoyo/titanium) to a single UI process (while still having multiple processes for web pages). This is harder than expected, but I believe I've designed a good communication protocol and it now kinda works.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/linuxunplugged] [GSoC project to write parts of GNOME GJS in Rust and potentially cut back on gnome-shell crashes](https://np.reddit.com/r/linuxunplugged/comments/6kzyjs/gsoc_project_to_write_parts_of_gnome_gjs_in_rust/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I've started working on re-implementing SQLite in Rust, as I've always wanted to write a RDMS. So far I've got enough to do simple `select` statements like `select first_name, age from people`. This week I hope to add support for: - Simple `where` clauses. - Using indexes - `insert`/`update` statements, without any transaction support
looks awesome!
https://is.gd/nJOi5E timeout_ms! macro code https://is.gd/1UvwQt (had to split for character limit)
[reqwest](https://github.com/seanmonstar/reqwest/blob/master/README.md) An ergonomic HTTP Client for Rust. Built on top of hyper, with a batteries-included mindset.
Let's hope this doesn't lead to antivirus false positives on innocent Rust software.
I've been updating the way our (Servo's) SpiderMonkey bindings work and are generated, and have also been chatting with lukenukem on IRC. GJS is using SpiderMonkey 52, while Servo is/will be tracking something like SpiderMonkey tip releases straight from mozilla-central. My understanding is that lukenukem plans on backporting my bindings work to 52, which shouldn't be too difficult all things considered. In summary, if you were worried about people doing similar things, and reimplementing the same work without talking to each other, then I think you can pretty much stop worrying :)
Also [select.rs](https://github.com/utkarshkukreti/select.rs), built on top of the html5ever parser used in Servo.
Whoa, that appears to be quite a sizable FreeBSD kernel interface in Rust, in addition to the module itself. Also I should really play with Xargo sometime, it seems cool....
What exactly is your problem? Idk if there is as specific crate for scraping but scraping regularly consists of multiple subdisciplines such as http request (handling), html parsing and various data science stuff. If your task is simple (which it sounds like) you can go and use an abstract http request crate as mentioned by u/meekstandt the [reqwest](https://crates.io/crates/reqwest) crate and use a little regex magic ‚Äì keep in mind that regex is not supposed to parse HTML (its a direct way to hell!!!) but to find a single number it sounds like that this could be an appropriate usage ‚Äì an exception if you will ‚Äì for regexing HTML either way [scraper](https://crates.io/crates/scraper) could be useful but i did not used it myself.
Oh I'm not. I was just surprised and wondered what I misunderstood. Thanks for the explanation! :)
I‚Äôve used [reqwest](https://github.com/seanmonstar/reqwest) and [scraper](https://github.com/programble/scraper) together, and I liked the results. I didn‚Äôt know about select.rs, so I can‚Äôt compare them. From a quick look at its readme: * select requires you to build the predicate using its API (`Attr("id", "hmenus").descendant(Name("a")) `), while scraper supports CSS selectors (`Selector::parse("#hmenus a")`). * select seems fairly up-to-date, while scraper hasn‚Äôt been touched in about a year (I‚Äôm working on a pull request to update its dependencies, but it still works fine)
Currently, it doesn't. I'm planning on adding a text-mode browser/link to graphical browser fallback for those articles.
Sure. I actually took inspiration from some of `librustdoc` since some of its abstractions worked pretty well for this project also (visiting an AST tree, wrangling the raw AST data into a neater format). Parsing rust source files is handled by the `syntex-syntax` crate, which is really an external crate of rust's `libsyntax`. It uses the visitor pattern to traverse the AST and you can do arbitrary things to the things it finds. A simple example is at https://github.com/kamalmarhubi/syntex-syntax-example. `oxidoc` uses this to create a hierarchy of modules and the documentable items they contain. After traversal, the data that results is converted into the actual documentation structures. The data types are pretty much the same as those of `syntex-syntax`, but with the `Serialize`/`Deserialize` trait for on-disk storage. Upon generation, each separate document is serialized in a path in the `~/.cargo` directory based on its module path. For the search index, I use a hashmap from single identifiers to every possible module path they could appear in. If the user inputs a partially resolved module path, the results are filtered so that the path appears as a substring in each of the results. The ordering is based on the Levenshtein distance between the module path and the query, but it could be changed so it is based on the number of imports/usages of the item documented instead. I would also have to do something more sophisticated for full text search and regex searching of documentation/identifiers.
lol maybe?
I just finished writing the first shot at all the required parsers to exhaustively parse [GLSL 450](https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.50.pdf). The [crate](https://crates.io/crates/glsl) is not ready yet as I need to write all the required unit tests to ‚Äúcertify‚Äù all the {,intermediate} parsers in use. I take contributions (see the `README.md` file for hacking around). I‚Äôll also publish a blog entry to announce the release of a stable version.
Yipeeee!
YAY, just the news I've been hoping for :D
Tor is only as secure as how you use it (folks mess up), and it's not 100% secure against extremely targeted attacks by state actors. For the purpose of most discussions, the latter is not relevant. The former is always relevant in any discussion of security.
^ has it. But as someone who has had to do this many many many *many* times before....be very sure to separate these concerns. Location resolution, page requesting, parsing, result storage, process progress storage and restarting. Any one of these might seem super simple in your case and you can just relegate it to some simple part of code as part of something else, maybe your result storage code is so simple you think it can fit easier within your parser, or maybe tracking your current page is super simple, resist this urge. this way lies pain and madness!
I miss some context. :-(
[removed]
Is there a specific reason why min and max functions are only defined for floating point primitives, but not for integers? I have often found myself trying to do: let a = b.min(c); with integers.
I implemented initial signal handling about two weeks ago, then recently implemented SIGTERM and SIGTSTP on top of the existing SIGINT handling. I've almost finished the job control features. Just need to support process groups, better process status detection, and a few more built-in commands.
The Rust Language Server shipped with the latest nightlies has been crashing repeatedly (at least since the 20th of Jun.) A fix was pushed to master on 24th but it wasn't until now that the fixed version was distributed through rustup.
You can do this: let a = std::cmp::min(b, c); I think the reason that there are methods implemented for `f32` and `f64` is that `std::cmp::min` requires `T: Ord`, which is not satisfied for floats.
I'll also add that we could really use more weight on the discussion issues for Ion. Ion discussions are largely absent of discussions.
What is `ri`?
Using gtk-rs, how to draw an SVG in a DrawingArea?
Most likely not. They probably use few crates (if any) beyond the standard library and `rand`, while Firefox incorporates an increasing amount of Rust code, thanks to Project Quantum, and Firefox is not at all obscure. It's likely that anything generic to Rust that they try to match on would trigger on the copies of Firefox they use to test their detection success on browser-exploiting malware.
https://ruby-doc.org/stdlib-2.2.3/libdoc/rdoc/rdoc/RDoc/RI.html TL;DR this but for Ruby
Okay, now it does. Embedded HTML should now be converted to plain text. I used an off-the-shelf library for converting HTML to text for now. I'll see how it goes.
The equivalent tool for Ruby.
How does this work? Isn't nightly RLS built.. nightly?
That's what I originally assumed too but it seems that new builds are pushed only occasionally for distribution.
I implemented a binary search tree in Rust to try and get a better handle on ownership and the borrow checker. I feel like I was constantly battling the borrow checker the whole way through. I was finally able to get it all working (discovering `Option::take` changed my life) but I still feel like it's a bit clunky. If someone doesn't mind looking at my code I'd really appreciate some advice on making this more idiomatic/less battling of the borrow checker. Thanks :) https://github.com/keeslinp/binary_search_tree
[Or you could do it right now](https://play.rust-lang.org/?gist=3d7aaaf1ef5613451c873595b7f89404&amp;version=nightly&amp;backtrace=0)
Timeouts/cancellations aren't really something that's supported well in `rusoto` currently. There's no way to configure one. One option that may be available is to implement your own [`DispatchSignedRequest`](https://docs.rs/rusoto_core/0.27.0/rusoto_core/request/trait.DispatchSignedRequest.html) for a `hyper` client, adding in your own timeout logic there (using `hyper` 0.10's [`set_read_timeout`](https://docs.rs/hyper/0.10.12/hyper/client/struct.Client.html#method.set_read_timeout)/[`set_write_timeout`](https://docs.rs/hyper/0.10.12/hyper/client/struct.Client.html#method.set_write_timeout)) or, with hyper 0.11, dropping the future if it's polled for too long. There [are plans to move to `hyper` 0.11 in the near future](https://github.com/rusoto/rusoto/issues/604) which should make this easier since you'll have direct control over the future, but it's not here yet. As for why the SNS client would be slow, that surprises me a bit. Have you tried comparing performance with your code in another language? Curious if we can isolate it as an issue with `rusoto` or if it may just be the behaviour of SNS itself. Which credentials provider are you using?
Oh, got it.
deleted ^^^^^^^^^^^^^^^^0.0313 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/11092)
deleted ^^^^^^^^^^^^^^^^0.2886 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/35962)
is there an up-to-date comparison of database implementation options? i've been searching lately and i've been unable to find anything that lists multiple options and weighs them for use-cases. or barring the existence of such, does anyone have a recommendation for my use case? i want to use a database to store data for an application. only accessed locally so i'm not worried about web scale concerns, just want to store and query a few tables.
Wouldn't it make sense to implement these for integers? Just to have a consistent API for number types?
Fair.
deleted ^^^^^^^^^^^^^^^^0.8486 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/44490)
I think you're looking for /r/playrust/ ;-)
I actually found out that the performance issue was due to logging. At the moment I'm rolling my own timeouts - I've linked the code in the post.
There appears to be some discussion on this topic: [25663](https://github.com/rust-lang/rust/issues/25663) An implementation has already landed, the libs team appears to be in favour of this change, so what you want might be available soon.
Haha thanks for the insight. What I'm ultimately trying to do over the next month of summer is to build a scraper with a decent GUI to continually monitor (refresh every ~60 sec) a handful of specific company websites to look for company news. So basically identify the news table, and look for changes in the first row of that table. I would like the GUI to have a 'start' and 'stop' button, as well as a list of companies monitored, and perhaps a manual URL-entry. I have done this in python before, without a GUI, and just had it running 24/7 on my Raspberry Pi. Wasn't very happy with it though, as even when pausing, the python script seemed to be taking a lot of processing power. Do you have any ideas about whether this could be implemented in a better way?
Thanks! Looking at this now.
Uh I'd love to attend (it's not far from where I'm located), but I guess I cannot, because money. Also, there are three other community events coming up I want to attend (One at my university, NixCon in Munich and CCC in Leipzig).
Oh, then it's completly ok ;) The address is websocket by which dashboard data flows and should be only used by page internals. I asked Firefox users to visit this address and make Firefox start using that address (by telling Firefox "use that address although cert. for this page is self signed) Go to: https://85.255.1.138/dashboard/show/demo and you should see demo dashboard. This whole Firefox thing is because of this: https://bugzilla.mozilla.org/show_bug.cgi?id=1187666 or maybe rather becaue I haven't yet add proper cert. Perhaps in near futere I could do that. :) 
Thanks for hint. I like the idea of having proper cert. but this probably requires domain registration, does it? For such a nice tip you are selected to propose domain, what do you think? :)
Ooh, flashy!
I know exactly where you're coming from, but you're looking at the wrong place. This is C/C++ land. And despite what most people said, about coming back to the language later and learning it, it won't really change anything. If you are using Java and you are looking for a Java substitute, Rust isn't it. In Rust you'll spend 50% of time just writing boilerplate to deal with lifetimes, allocations, mutability, shareability, ownership, pass mechanics, FFI, searching for crates and reading documentation. Rust is a C/C++ substitute (and you will notice a giant majority of Rust programmers are C/C++). If your job/hobby project requires C or C++ because of performance or because of low level work, then by all means consider using Rust. Otherwise, there is no point in picking Rust, if you're just going to do Java things. Even if you learn to master Rust, you are going to be less productive than in Java, or god forbid some higher level language. And in my experience just coding the thing in a the amount of time you're given is the issue on 95% of the projects out there. If you're going to spin up yet another website with database persistence I can assure you Rust's performance will matter 100 times less than how fast you can prototype that thing. Of course at this point someone will tell me that Rust is just as high level as Java. It has high level syntax, like pattern matching, but the language is lowlevel and 50% of time and code is spent on things that are completely orthogonal to what you want to do. Most people peg Java for being a "memory managed C++". They don't see other things JVM brings to the table. Stick to JVM for anything that doesn't require low level work or every ounce of speed the computer can muster.
RustFest does sponsor tickets (and perhaps flights?) sometimes. I'm not sure of the details however. /u/formode may know
cc /u/musicmatze Yes if you're having trouble affording coming please send us (team@rustfest.eu) a message. We will be opening a diversity ticket call and a little contest in the near future! 
In the meantime you can use your own traits as extensions, e.g. trait OrdExt: std::cmp::Ord { fn max(self, other: Self) -&gt; Self; fn min(self, other: Self) -&gt; Self; } impl&lt;T: std::cmp::Ord&gt; OrdExt for T { fn max(self, other: Self) -&gt; Self { std::cmp::max(self, other) } fn min(self, other: Self) -&gt; Self { std::cmp::min(self, other) } } fn main() { println!("{}", 1.min(2)); }
Well, the GUI part is going to be sucky since rust just plain doesn't have great support for that yet in a cross platform way. Sad, but true. personally I would make a GUI using c# (since it's what I use for my day job) then do all the nitty gritty multithreading and fun in rust. another option is python, or something else for the gui. I hate that since I still think rust could be amazing at this but...it is what it is. Otherwise it really depends on what your goals are. Is cpu cycle performance really that big of an issue? Do you care how 'up to date' the data is? Do you want to maximize network usage? etc etc. Even *how* to determine the resource to request could be important to the solution. A resource which can be resolved to some id number (www.example.com/page/1 vs www.somecomplicatedurl.com/you/need/to/scrapesomething/else/to/get.html) will require something different then a scrape based resource requesting. either way you can separate the 'resource to request next' determining code from the rest of things, but it's simpler in one than the other. In one you can just run some increment counter and go, in the other you actually need to request and parse an entirely different document before you can continue. Will you need to determine further resources based on a current resource. example: want to scrape all of wikipedia? you would need to keep track of every url then queue these up as you scrape a page, there is no 'master list' parsing is more fun. do you know if you will only need to work with utf-8? if so, things are *much* simpler than if you need to process other encodings. hope it's purely english! How about versioning of your parser? will the page always update across the board and stay in sync? ie, no A/B testing for example, the page template remains relatively constant, etc. A good parsing solution should remain stable even under change remember, so minimum context determination is useful, but under an unstable template it might be better to over contextualize and then be sure to have a way of detecting template change to stop the process to avoid junk input. etc etc etc. the context here is important and it will massively change your decisions because they could be important *business* or *policy* decisions, not technical ones.
Thats great. Thank you for digging that up.
For the GUI part you could consider exposing it via HTTP. That seems much easier than a native GUI and would even allow you to keep running it on the Raspberry Pi.
You write really well and the explanation is really useful. Thanks you.
Sounds like you want sqlite; there's a few crates. I like Diesel but it may be a bit too complex depending on what you're doing.
üòÇ my bad, thanks 
Great, now all I need is to get it to spew out completions. It either doesn't have that capability or I'm holding it wrong.
I've switched from VS Code to IntelliJ because of these crashes.
I'm working at FieldTable parser of my amqp crate, FieldTable is a collections of names, values and sizes. After I had implemented the float type, I realize that it must follow the IEEE754. After read a littler of IEEE754 I decided to use the create ieee754 = "0.2.2" (https://github.com/huonw/ieee754), so my available time is over and I'll return to this next weekend... I'm using the nightly trait TryFrom to parte values, something like bellow: ``` impl&lt;'a&gt; TryFrom&lt;&amp;'a FieldValue&gt; for f32 {...} ``` ``` impl&lt;'a&gt; TryFrom&lt;&amp;'a [u8]&gt; for FieldValue {...} ``` Maybe exists a crate to do this, but how the main purpose of the crate is to learn Rust, I decided write from scratch.
Sounds nice! I may attend. My rust project is too young to give a talk about though, perhaps it's something for next year. How much is the attendance fee? 
Oh, that'd be awesome. But honestly, I could just leave out NixCon and therefore attend RustFest - the money would be enough. Instead of "using" the community support I'd rather give someone else (who actually hasn't enough money to attend any conference) the opportunity to attend! But thanks for the suggestion anyways!
Code with comments here (only node): https://play.rust-lang.org/?gist=f2d7eba4eab57eed37c17fc420f5aad6&amp;version=nightly&amp;backtrace=0
i booted up vscode this weekend, following instructions from [here](http://matthewjberger.xyz/rust/Getting-Started-With-Rust/) to get started &amp; excited to do some learning... and then this hit me straight in the face :( glad to see it fixed, hope it stays stable by the time i boot in again!
[removed]
Interesting. So, if that were the route to take, the macOS' frontend would be written in Swift + Cocoa, then I'd need to write Swift bindings for Rust so I could interact with my backend, right? Seems tedious, tbh ¬≠‚Äîespecially, since you're practically maintaining "two" applications, but other than that, looks like something completely doable. EDIT: Grammar.
This blog post shares a few lessons I've learnt (mostly on what tools to use), after a few months growing and monitoring [nest.pijul.com](//nest.pijul.com), a hosting service for [Pijul](//pijul.org). Comments welcome!
[Tickets were to the order of 100 euro last time](http://blog.rustfest.eu/tickets-on-sale-and-timeline) (Zurich may end up being more expensive because it's Zurich, though? Unsure as to how much of the ticket cost derives from venue booking costs.)
Your problems are no specific to Rust. Games are written like that in every language. You probably want to use Data Driven Development model anyway, where you refer to everything via entity ID, as opposed to trying to organize it like a business logic with passing fine-grained smart pointers. And the game logic you want is in scripts anyway, for many reasons. So yeah. For a pong-clone it might seem like an overkill, but for bigger game you'd have to do this work anyway.
Yes, basically it's more of a design question than a Rust question (wrong subreddit then?) Anyway, thanks you to your and /u/ssokolow's clarification, I'll try this out: * cmd thread to receive * human player (readline loop) to send commands to cmd * robot player to send commands when active to cmd And an `mpsc` to connect them. I don't need to exit the robot player, just make it stop sending commands.
&gt; people that we don't actually want to enable. Even if the opposing state actor is e.g. North Korea? Or Turkey under Erdogan? (Don't get me wrong, I agree with the rest of your statement. Also, I'm obviously *not* implying that Ukraine falls into this category, nor am I defending the malware authors discussed in the article.)
This doesn't achieve what I wanted. What I wanted is to select a type based on whether I ever send it to another thread or not. `T: Send` is different bound.
It doesn't solve whole problem, but I admit it's interesting.
Well, I've read somewhere that HKT allow abstracting pointer types, so that probably confused me. The example you provided achieves different (although, still interesting) thing. Trivial counter-example would be `T`=`u32`. `u32` is `Send` but one may want to use `Rc&lt;u32&gt;` instead of `Arc&lt;u32&gt;`.
Yes I have the same experience. Lots of debug messages to show that RLS is running (often falling back to racer) but rarely do I ever get a useful completion - as a result, the learning goes slow. With something only a little better than a text-editor I also find the lack of examples for most crates (beyond the hello-world trivialities) makes the learning experience tougher. Of course I come from a language/platform spoilt in these regards (Java). I like Rust the language, but I'm feeling like it will take me a long time to be as productive in it.
Of course! Don't worry, I'm mostly familiar with the best practices of gamedev from waaaaaay back in 2000s when I dabbled in it more seriously :) What I wanted here, though, was a little bit of unconstrained hacking of the kind you'd do for time-limited compos like Ludum Dare. Bringing an entire game engine there is indeed an overkill (and often considered cheating!), so you'd typically just go with something like SDL/SFML and write ad-hoc code that directly stores &amp; operates on game entities. "Prototyping" seemed like a good word for that. It is somewhat amusing that even in game development, Rust semantics are steering you towards doing things The Right Way(tm) from the get go!
Hey there's some [catmark](https://github.com/bestouff/catmark) in there ! I'm happy to be of any use. Would you prefer for it to also be a library for easier use ?
http://editorconfig.org/ for anyone else missing context.
So corecursion is basically indirect form of recursion, where A references B and B references A. Recursion is direct - A references A. Is that correct?
nest.pijul.com is timing out for me
&gt; wrong subreddit then? No, I wouldn't say that. It's just that from your post it sounded like you wanted to make it work the way you had laid out and I though you might be better of if you rethought how to structure your program to make use of rusts features. The structure in your last comment sounds good. I hope it works! mpsc's are pretty awesome and they seem to be exactly what you need. I hope you are having fun! Sounds like a cool project!
Thanks! I'll try to make those changes tonight. Do you mind elaborating on this?: ` // Take notice you can have self: Box&lt;Self&gt;, it would simplify a lot of logic here. ` (line 120) Boxes have been weird for me sometimes because it seems to be transparent sometimes and opaque at others.
Yes, this is more conservative than your vision; it only uses the more optimal form when you know you can't be `Send`. I don't know how you would encode "this situation requires `Send`" in the type system.
I mean, it's good as a first project, but you could easily have made it a bit more elaborate ... like making an enum for the weekdays, adding test for when a date isn't valid, incorporating leap years, integrating it with chrono::DateTime, etc. Right now it's a 10-line function. While I do welcome beginners in Rust, do not expect many people to use this library. If you just did this for yourself, it's ok.
Doesn't look too bad! If you're looking for pointers: - I'd definitely switch to taking and producing `u32` rather than `usize` - as from a user perspective there'd be no reason why this needs to be the array-indexing type. - In the code, you do `let mut yy = y;` Since you don't ever use `y` after this, I think you could be more effective just with `mut y: usize` in the function signature. - If you want to improve the usefulness of the library, I would recommend making a `DayOfWeek` `enum` which you return, which would then have methods like `to_i32_sunday0` and `to_i32_monday0` (names WIP).
&gt; nest.pijul.com Gives me ERR_CONNECTION_REFUSED
It is very possible that I am overlooking something simple. Any help is greatly appreciated.
Yeah, that would be great. I needed library support and I didn't want to recommit on every change if something broke (before realizing I could just use `path` inside the `Cargo.toml`...). I can move the `catmark` code out and refactor it to what I need.
The active toolchain: rustup show Default host: i686-pc-windows-gnu installed toolchains -------------------- stable-x86_64-pc-windows-gnu (default) nightly-x86_64-pc-windows-gnu active toolchain ---------------- stable-x86_64-pc-windows-gnu (default) rustc 1.18.0 (03fc9d622 2017-06-06)
Update: I can confirm that building with other crates works as intended. Built successfully with the rand crate and the num_cpus crate.
Actually, it's my understanding that the problem lies with making a MacOS UI feel native while using a library designed to abstract away platform differences. If that's all it is, then Python or Rust bindings for Cocoa would do the trick (no Swift necessary), and both of those exist.
I kept forgetting to mention, since it's only alpha-stage, but there *is* an [effort](https://users.rust-lang.org/t/rust-qt-alpha-release-and-feedback-request/11312) to produce bindings for Qt which is looking promising. Just something you might want to keep an eye on and possibly join in the discussion around.
One can also install RLS directly from source and using the companion project https://github.com/rust-lang-nursery/rls-vscode it is largely equivalent to the vscode plugin. But yes the `The ${this.name} server crashed 5 times in the last 3 minutes. The server will not be restarted.` haunts my dreams.
Thanks for the writeup. I understand the concerns about diesel, sql performance and tuned queries. Does anyone have real world experience with diesel so far to understand if these concerns are valid? Or is diesel as awesome as it appears to be?
Rust is supposed to give the linker an explicit list of symbols to export. What is probably happening here is that either rustc is failing to use a linker script for pc-windows-gnu, or MinGW itself disregards the linker script for deciding exported symbols when some symbols are marked dllexport. I assume the lua library that you're linking to marks some functions as dllexport, hence why they are being exported instead of anything else. Could you try testing this with `pc-windows-msvc` instead (you'll need to install the VC++ build tools), to ensure that this is a MinGW specific issue?
Hey Sean! Good work on qp-trie! I've only had a chance to skim the code, but it looks nice :) I now realise that my [rust_radix_trie](https://github.com/michaelsproul/rust_radix_trie) is a QP trie, as it uses 16-way branching! It looks like the main difference between our two tries is that yours compresses the branching, while mine uses a 16-element array of pointers (you can see the impl here: https://github.com/michaelsproul/rust_radix_trie/blob/master/src/trie_node.rs). I'd be interested to compare the performance of the two approaches. If I have time I'll add your qp-trie to my [benchmark harness](https://github.com/michaelsproul/radix_trie_benchmarks). I started my radix_trie a couple of years ago, and have sadly never really found a use for it in any of my projects. I tend to use [sequence_trie](https://github.com/michaelsproul/rust_sequence_trie), which is just a bunch of nested hash maps with a nice API, but it has rather terrible performance by trie standards. As a result, I've been tempted to abandon `rust_radix_trie` a few times, but maybe now I should deprecate it in favour of `qp-trie`? I dunno :\
Please be nice.
Because this subreddit has rules and you are supposed to follow them. If you are unable to do so, please refrain from participating.
I developed a web service using Diesel and the web framework pencil. (And later, my own fork, sharp_pencil) I think Diesel was generally awesome, but it suffers from awful error messages and some limitations, mainly with joins. I think things are going to get better with some typesystem improvements on the pipeline, though. I managed to work around the limitations with joins by writing some of the queries directly with SQL, which Diesel allows. Edit: In case somebody's interested, here's the repo: https://github.com/golddranks/ganbare and here's a live instance, that requires login, so nothing much to see there, but anyways: https://akusento.ganba.re
being nice for me is different from what it is for you. fuck off.
Bye.
Hi, and welcome to Reddit! :) Relative to more popular languages, there aren't many Rust jobs out there right now, but the ones that I've seen all require more general programming knowledge in addition to knowing Rust. My opinion is that spending time diving into data structures / algorithms will not be wasted, no matter where your programming career takes you. Best of luck!
I'm investigating. Getting it to build on the msvc toolchain is apparently non-trivial: https://github.com/jcmoyer/rust-lua53/issues/69
Thanks! :D I'm realizing now that actually when I looked over your `rust_radix_trie` library, I confused it with `sequence_trie`, which led me to believe that besides the `qptrie` library I'm trying to replace there wasn't a similar, efficient trie option for keys which can be interpreted as bytes. I too would really like to see how they compare performance-wise. I don't think that your radix trie is actually a QP trie - the QP trie's whole shtick, really, is that compressed node scheme with the `Vec` instead of the 16-element array, with a `u32` as a bitset to describe what entries are stored in a given branch. That's why it's called a "popcount" trie - popcnt/`.count_ones()` is used to calculate indices into the `Vec`. Another key difference is that while I do note that I wrote this with an "emphasis on safety", I definitely have not shied away from using unsafe optimizations such as `debug_unreachable!` and `unwrap_unchecked` - although I have tried to ensure that when compiled with debug assertions, no undefined behavior will ever result (a panic will happen instead.) In any case, I cannot possibly in good faith recommend that you deprecate your `rust_radix_trie` library - it looks well-written and feature-complete, and definitely includes functionality mine does not. In addition, it is built with *entirely* safe code, and I can't claim the same for my library.
That's a good point - I've lodged an issue on it and I plan to come back and fix that when I have time. Thanks for looking so closely at my code! I've been gently chastised for incorrectly marking functions as safe/unsafe more than once this week, and I'd definitely like to remain on the safe side. :P
This was a recorded video conference from a recent Rust DC meetup. I've never done much embedded development, so I really appreciated how James lays out: * an approach that works with C code * debugging * a step by step approach that gets you to "hello embedded world" In particular, it was helpful to have a mental framework for approaching embedded development kits: 1. find the C "reference" or "demo" code provided by the manufacturer 2. look at the makefile 3. copy all the headers and includes (for bindgen) 4. copy all the weird compilation flags (for build.rs or .cargo/config) 5. start with lots of unsafe, and back it out from there 
Interesting! I'll have to look into how QP tries work in more detail! The ergonomics around strings are my main issue with the byte-oriented approach, i.e. that when dealing with strings you have to consider that the branching in the trie might occur mid-way through the byte of a character, as in this example: https://github.com/michaelsproul/rust_radix_trie/blob/master/examples/child_iter.rs You're probably right that deprecation is probably too strong a course for my radix trie. I might just let it kick along slowly (I don't think there are many active users, judging by the number of bug reports :P). edit: typo
I'm not sure what to think about this... I am concerned about examples in docs, as you might not be able to copy-and-paste them into your code.
&gt; In the code, you do let mut yy = y; Since you don't ever use y after this, I think you could be more effective just with mut y: usize in the function signature. I'd be careful with that advice. [Line 30](https://github.com/neosilky/dow/blob/master/src/lib.rs#L30) mutates `yy` with the assumption that it's mutating a temporary rather than making a persistent change to the original copy of the passed-in value. (It looks like the intent of taking `y` non-mutably and then doing `let mut yy = y;` is to get a working copy while guarding against producing side-effects.) While `mut y: usize` should be safe here, since it's taking ownership of a `Copy` type, it's an iffy habit to build generally before getting well acclimatized to borrows, since switching an `&amp;` to `&amp;mut` is *not* safe in this kind of situation and, without `Copy`, many situations need `&amp;` to successfully compile.
Well, Boxs are owned pointers. They are transparent when calling a method or field of the underlying struct due to a rust feature called auto-deref
Awesome! And yeah, `unsafe` can be tricky! I try to be super vigilant about that stuff because if the ecosystem starts violating the core safety guarantees of Rust, then its entire value proposition as a language could be called into question. I think we are doing great so far, but it's one of those things that I think could slip very easily, and all of a sudden find ourselves two years from now looking at CVEs because some crate in their dependency chain decided to make a function safe that was actually unsafe! :-)
Sqlite? There are multiple crates for accessing it. rusqlite is the most popular, though I am far from a fan how it works. I would just use libsqlite3-sys and write my own utility functions. It's easy enough to do.
The other day I was thinking about deprecations and how doing so isn't too useful without something like this. The awkward thing will be in using epoch features in an exported API. That'll be a semver breakin change.
On one hand I like this, as right now I just say that I target the latest stable release for my projects and that doesn't always work for package managers because they can't always target the latest stable release and this can help mitigate this. I run into many issues where users compile my software from source and not everyone uses rust up to get the latest version, and I dread to think the nightmare it will be pinning myself to an arbitrary version (which not all package managers target so I need to do the youngest one to reach the most users) without any semantic meaning to it (which epochs solves well). On the other hand I feel like this makes the latest "stable" version a bit obsolete for any one wanting to package their code. Perhaps this is just semantics, and just requires retraining developers to seriously target an epoch rather than a random stable version, but it never the less complicates what version of Rust to target. If changes are made to rustup (eg default to the latest stable epoch) then this shouldn't be that big of a change beyond a cognitive one (which needs to be still considered). On that note, why not just bump the major version and have it be that most package managers try to target that? That's how eg Python and Java does it and it *seems* to work well enough. Will this affect the rapid pace of development of the stable branch in some way that I'm not anticipating? Finally, while this isn't an issue currently, it could cause fragmentation later when there are other compiler backwards. C++ ran into this issue where Microsoft did not properly implement the C++11 spec for many years. This approach seems to be a "have your cake and eat it" scenario (eg, long term stability while also having a quick, stable release cycle). Rust is all about having your cake and eat it ("fast, reliable, productive: pick three"), but I think in this case it will just lead to fragmentation in what constitutes the official "stable" version for new comers to target. 
Does anyone know of any up to date crates to work with Kerberos? I've found a few from Google but it doesn't seem like they have many users or actively maintained. Would like to hear from someone who has experience using the crates before. TIA
A little late, but I just found this. [Decided to implement Lambda Calculus and it works great.](https://is.gd/byef5Y) If I was serious, I'd make some macros to make it easier. Then I decided "It's not turing complete unless it's vulnerable to the halting problem." Looking through the wikipedia page, I found `œâ := Œªx.x x; Œ© := œâ œâ`. That should recurse endlessly! A little coding later and: error[E0275]: overflow evaluating the requirement `&lt;Omega as Func&lt;Omega&gt;&gt;::Output` --&gt; &lt;anon&gt;:80:22 | 80 | println!("{:?}", apply::&lt;Curry2&lt;Omega, Omega&gt;&gt;()); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: required because of the requirements on the impl of `Func&lt;()&gt;` for `Curry2&lt;Omega, Omega&gt;` error: aborting due to previous error I managed to make the compiler stack overflow! That as good as an infinite loop, right?
Hey all, I'm the guy speaking in the video, let me know if I can answer any questions!
I think the idea of declaring language-level dependency is great, and making crates work across language levels is neat. On the other hand, breaking changes are breaking changes, and if you avoid one upgrade you will probably avoid them all and forever be stuck in an old epoch. Even without "breaking changes", I've seen many organizations stuck on upgrading java versions, and with big ones you end up in the python2-3 world.
java doesn't have incompatible changes and python split the community
I would assume that in the docs, it would state which epoch the example (and the crate) is using, so you can avoid accidentally copying incompatible code. If the changes between epochs are documented well, it shouldn't be too much of a hassel to mentally translate the doc snippets into your own epoch. Might be useful for rustdoc to display little warnings like: "this snippet is written for epoch 2016". I think the generated documentation should give us a dropdown to select which epoch to view the doc with. This of course doesn't help with examples or snippets, but it should make the the signatures and definitions appear correctly for an epoch. I don't recommend copying doc code anyway. Personally I only use it as a reference.
Good point. I think the epoch would have to be written in each example, because doc tests have a external scope thing.
The important distinction is that newer versions of the rust compiler will continue to support older epochs. 
I think the problem here is that (IIRC) unknown associated types are not object-safe, so to use a trait as a type, you have to define what type it is, even though in this case, there is only one possibility.
I'd say learn postgres and networking at least, and other technologies like redis, cassandra, gRPC, depending on which area you want to work in. Rust's is currently used in production in server-side software. Also learn machine learning / statistics / deep learning. If you want to go into gamedev learn graphics / physics etc... Combine multiple areas of expertise into one rare 'package' that's greater than the sum of its parts. Look at the Rust jobs that are currently advertised and what requirements they have, my impression is, it's mostly networking / backend stuff. https://rustjobs.rs/
Java does have. https://blog.goeswhere.com/2017/07/java-9-rebuild/
I believe this almost entirely depends on whether there is someone or some organization 1. who can do this, and 2. who wants to be funded. Is there?
FYI, you can always redeclare a variable. Personally I prefer to not use mut variables but re-declare them, as long as they keep their type. I dislike re-declaring with a different type, though, because it can get confusing quickly. ``` let y = 254; let y = 254 + 99; ``` 
This is an incredibly large and important feature for a language to have. All of the applications I've written these days run a server which serves up a website as my front-end, but having a GUI framework in something like OpenGL or Vulkan (hopefully also compiling to a WebGL target) would be absolutely incredible, and would honestly make me use Rust for everything. Is there any reason using OpenGL/Vulkan/WebGL as the graphical back-end would be considered a bad idea? Video games have been doing it with high-performance for decades. I definitely don't know about existing implementations well enough to comment on how the design of the API should look, however.
I'm planning on attempting to write at least the rendering component of one in the next few months using Webrender. I've put a lot of thought into how I'd go about writing a cross platform Rust GUI library, but I still have a bunch of things left to work out, mostly around layout, especially of text. However I have limited time so I don't know how much I'll accomplish. I have lots of free time for three weeks in August I plan on working on this problem, but I'm not sure how far I'll get.
As to your question of how much it would cost, it depends entirely on the approach and target functionality. I think a libui wrapper is done already so $0 but if you want to replicate Qt in idiomatic Rust that's tens-hundreds of millions of dollars. One big decision is if you want a native look, which you say you do, do you do it Qt/Swing style with your own rendering replicating it, or libui/React Native style wrapping native widgets. There's advantages and disadvantages to both, and huge differences in difficulty.
Fixed, thanks.
Well, "asynchronous" is one of the key words in all my blog post. That service doesn't make a single blocking call, including to the database server. It starts as many threads as there are cores in the beginning, and exactly one Postgres connection per thread, and never touches them after that. This also means exactly two buffers per core are allocated for Postgres, only when the server starts. AFAIK, Diesel is still synchronous, although there are plans to make it asynchronous.
The rust-cookbook has exactly the example you need :) https://brson.github.io/rust-cookbook/net.html#ex-extract-links-webpage
yeah, I mean I've [begun doing this](https://github.com/sharazam/explorer/tree/master/src), but I have to finish my [PDF library](https://github.com/sharazam/printpdf) first. Then I can work on a GUI library. [Here's what it looks like right now](http://i.imgur.com/ygwOxN5.png) and [here](https://upload.wikimedia.org/wikipedia/de/b/bf/Windows-Explorer_%28Windows_8.1%29.png) is what it's supposed to look like when its finished. Basically once I get the PDF library done, I'll be making enough money off of it (not the library itself, but the program I built it for). Then I can focus on UI stuff, because it is bugging me too. `conrod` is a bit of a pain to use. The system is built upon servos `rctree` for the layout, it recursively lays out any children like CSS's `display:flex`. However, everything is happening at compile time, the layout and re-rendering part takes ~1 ms (500 fps) using OpenGL and glium.
check this out: https://github.com/Thinkofname/stylish
On the other hand many others need something entirely different. A GUI layer that uses platform native controls or something very close to it. This is why the OP's idea is practically impossible. Both of these camps (native or drawn from scratch) are large and you can only please one.
&gt; requires retraining developers to seriously target an epoch rather than a random stable version It's not random. The RFC states that if you don't provide one, it will just default to 2015. &gt; On that note, why not just bump the major version There is a crucial difference between major versions and epochs: future Rust compilers will always have a legacy mode that supports the 2015 epoch. In contrast, a major version bump means old code will be stuck with an ancient compiler that receives no support nor bugfixes, and splits the ecosystem in two (this last part is really really bad for a programming language: see for example the Python 2 vs 3 fiasco). Epochs are a compromise that retains support, bugfixes, and ecosystem compatibility, but freezes the feature set.
I think the first step is to make good native GUI bindings for major platforms (Windows and Linux at a minimum, but hopefully macOS too). From there people can either make cross platform abstractions (think wx) or make platform specific abstractions (think winforms).
&gt; see for example the Python 2 vs 3 fiasco For another example, see dozens of languages that did not evolve fast enough and are now dead. They died quietly with no visible drama, but it doesn't make it any better for them. I do not consider Python3 a fiasco, though it could be handled a bit better.
What's wrong with using the quite nice GTK+ bindings ?
No need to please both as the OP stated, we can try and please the "from scratch" crowd, as custom elements seem like they would be a pain-in-the-ass if you choose the native route, and also pushes drawing onto the GPU (I don't believe this is done on all platforms, but I'm not entirely sure). If the proliferation of websites and video games have shown us anything, it's that native interfaces are absolutely non-essential to understand application navigation from a user's perspective (given they're done nicely, of course). Saying that, a common interface for other system-specific things (system tray integration, etc.) would be necessary as well (but could technically be a separate library, if wanted).
/r/playrust
There are 3 main use cases for a GUI framework: 1-Completely custom UI (e.g automotive, home automation) 2-Utility software with a lot of widgets, better if themeable (e.g software for industry or tools like Photoshop) 3-Platform application for existing desktop environment/OSes that have to look native (e.g Gnome, KDE, Windows, Mac apps) Case 3 is a completely different story than 1 and 2. 1 and 2 can be served by the same UI toolkit, whereas for case 3 is very hard to abstract to provide a common solution, so one has to rely on bindings for different system. I think we need something in pure rust for 1 and 2 and leave case 3 to bindings. The best UI toolkit today I'm aware of is Flutter. Having something like that in Rust would be a killer. 
&gt; e between major versions and epochs: future Rust compilers will always have a legacy mode that supports the 2015 epoch. In contrast, a major version bump means old code will be stuck with an ancient compiler that receives no support nor bugfixes, and splits the ecosystem in two (this last part is really really bad for a programming language: see for example the Python 2 vs 3 fiasco). Epochs are a comp It's also relevant that Rust has static type checking. This is a *huge* deal when migrating. (I haven't done this for Rust, but I have done it for Haskell code and it's basically trivial.) (Of course you must still provide a *path* towards migration (e.g. via deprecation + new APIs) and not just replace APIs from one version to the next... but that much is obvious.)
Great writeup! Iron is built on hyper so the note about it not being async is not correct unless I'm missing something (which may well be the case).
From a Business perspective. I would presume this: 1 UI Designer 1 Architectural/Lowlevel Systems Programmer 2 Rust Developers Business cost: one dev 50-75k‚Ç¨/pa the team 200k-300k‚Ç¨/pa For a total new ui system you might need at least 1 year to get a "beta" product. So lets say 2 years for a working product. This sums up to 400-600k‚Ç¨ :( Your mileage may wary! 
Good read: http://blog.johnnovak.net/2016/05/29/cross-platform-gui-trainwreck-2016-edition/
On the other hand, Ruby 1.9 was a similar change to Python 2 and 3 and worked out just fine. Swift is in its 4th rendition, with incompatibilities to old ones, providing very good migration tools. These things can be managed, we have examples for successes and failures.
For serving simple static webpages with iron, you're not missing anything. What "asynchronous" means in this case, is that everything runs in the same event loop, including database calls. Iron still needs to spawn at least one thread per request, because it doesn't know how to run different async IO processes in the same event loop. Basically, Iron handlers are supposed to return an `IronResult`, whereas they wold return something implementing `futures::Future` if they were asynchronous (i.e. a bunch of chained IO calls with callbacks).
GTK+ looks good on XDG platforms (eg. Linux) but I'm told it's not up to snuff on Windows or MacOS. (The last Mac I had was a Mac SE running System 7 and I never did enough Windows work to reach outside the realm of PyGTK plus GTK+ 2.x being "good enough".) Either way, I avoid developing with GTK+ 3.x because of how UX regressions keep slipping in when it's used in desktop environments which don't follow the GNOME aesthetic. (I do my GUI programming by writing the frontend in PyQt or PySide and trying to architect a significant enough portion of the application into a reusable module to justify the added build complexity of having a compiled backend. It produces a **much** more native-feeling UI than qmlrs or an HTML-based UI.) ...and, having used both PyGTK and PyQt, I am qualified to say that Qt APIs have many more productivity-enhancing bells and whistles than the equivalent GTK+ APIs. (eg. ready-made reposition/tear-off/hide/show/context-menu functionality for toolbar and panel widgets, with `QMainWindow` allowing you to serialize/deserialize customizations in a single method call.)
I am writing a small experimental game, and I am also facing this issue. In the meantime, I will hack something together that works for my use case, like all game devs usually do. However, something re-usable and theme-able would be awesome!
Just updated the readme to include more info.
The vast majority of which are toolchain/build related, Java has very few language level or library breaking changes, although they do happen.
As someone who has been working on pure-rust GUI for the past 3+ years, I'd be happy if we could at least first begin with decent, stable, cross-platform windowing and events. [winit](https://github.com/tomaka/winit) is getting there but needs help, contributions welcome!
As a MacOS user I have to say that GTK behaves better than QT
Why all the methods in iterator which examples tell me to use "&amp;" give me the error "cannot move out of borrowed content". For instance: let mut params = operation.parameters.clone().unwrap(); params.retain(|&amp;param| Some(param) != has_request); Would give me that error and no matter what incarnation of * &amp; clones and refs I use I can't get away of different kind of borrow errors.
History time: This is quite similar to my [first RFC](https://github.com/rust-lang/rfcs/pull/1147) which was rejected at the time. I presume I was just ahead of the time. :-)
Thanks for the clarification. That said, any support my creations have for MacOS beyond "I aim to avoid *all* portability gotchas I can remember and managed to get Travis-CI to run tests and generate build artifacts for MacOS" will be completely a volunteer effort by my users. I've run Linux exclusively for nearly 15 years, I run a KDE desktop and never have time to faff around reinventing wheels more than absolutely necessary to meet my goals, nobody I know owns a mac, and Apple doesn't offer an equivalent to Microsoft's http://modern.ie/ testing VMs. If I'm not getting paid to support MacOS, I'm not putting up with GTK+'s more primitive APIs.
FWIW, [this stupid variant](https://is.gd/SIxDHb) works: let x: &amp;Foo&lt;MyType=_&gt; = &amp;t;
You probably want /r/playrust
No way is that true.
Working hack: params.retain(|param| Some(param) != has_request.as_ref()) But honestly I'd just use the following: if let Some(req) = has_request { params.retain(|param| *param != req); }
The `lua` crate recently made some changes to linking in order to make it possible for the `lua` functions to be exposed. Maybe they broke something. Test with an older version of the `lua` crate (go back maybe a month to be safe), and if that doesn't cause the problems, file a ticket.
I'm already using Fedora on the Desktop. Before that I used LUbuntu (even contributed a bit), but I feel that Fedora has a more solid technical foundation.
&gt; but seem a little scary when it comes to scalability: are all my queries writable in Diesel? Will I need to rewrite all my code if not? Nope. http://docs.diesel.rs/diesel/expression/dsl/fn.sql.html
Will move it there thx.
&gt; some limitations, mainly with joins. These limitations are gone in the upcoming release FWIW
Awesome! As always, thank you for your tireless work!
I like 2.0 approach more and think that epochs introduce much confusion mostly due marketing reasons. Of course major version bumps should be extremely rear, not periodic like epochs. I think it's better to make 2.0 tooling to effortlessly download 1.0 rustc and stdlib to compile 1.0 crates and link them to 2.0 codebase. This way we will be able to keep 2.0 compiler slim without keeping deprecated luggage while continuing to improve 1.0 whenever needed. Also the overall approach is better and easier from the technical point of view and I think it will allow us to be more flexible with 2.0 changes. If someone is afraid about using "2.0" we always can call it Rust 2025, but I think it will be less honest. I wrote more about my view in the RFC [comment](https://github.com/rust-lang/rfcs/pull/2052#issuecomment-312829015). 
&gt; and splits the ecosystem in two (this last part is really really bad for a programming language: see for example the Python 2 vs 3 fiasco) So shouldn't we solve problem of the split by making 1.0 and 2.0 crates interoperable through 2.0 tooling by making rustc and stdlib in essence just another crate dependence? Instead of introducing potentially confusing epochs just because Python had experienced problems with migration and people afraid of "2.0".
I find somebody to begin do this(Rust + Flutter), so let's help together : https://github.com/lykenware/lyken (The best UI toolkit today I'm aware of is Flutter. Having something like that in Rust would be a killer.)
Flutter is mobile only no?
Cool! Thanks for letting me know =)
The real trainwreck there is the complete lack of code sharing amongst installed applications. In theory, all platforms allow shared libraries; in practice, only OS-provided software uses shared libraries these days because memory is cheap and shared libraries have many gotchas. I *wonder* if Rust shared libraries can do better...
GTK is pretty limited, they massively depends on gnu stuff, they are not flexible enough for custom stuff and they works well only on linux. Other than that they are very old style and uninteresting from a dev perspective, far from modern shiny "reactive" libraries.
Ooh, tokio postgres library that appears more useful for me than tokio-postgres... *grabs* - it's a shame the plugin is nightly-only, though.
I'd settle for pleasing one of the two camps, though. Right now we have neither. 
The issue is that each platform has a set of *expected behaviours* - just replacing the widgets with their per-platform variants doesn't work, because the UI is still laid out the wrong way and behaves the wrong way. Technically speaking, the only way to handle this issue is to build a different UI per platform, see React Native for example. GTK and Qt get close enough for most people to be vaguely ok using them, especially with some proper UX work put in.
Interesting. I figured that it was more likely that I had made a mistake. I'll see what I can figure out and file a ticket. Thanks for the tip!
Any plugin of this kind (mixing strings with struct field names) is going to be nightly-only, unfortunately. Tokio almost requires impl trait anyway, which is also nightly-only. You can define your instances manually though, it's just a few lines.
Wow, that's pretty cool, I didn't know about that.
1 : Flutter is modern power and beauful now .(support Android IOS Fuchsia) 2: flutter is open source , you can do more on top it to support other platforms 3: of course, i also want a native pure-rust GUI , but it need many people , much money, long time. 
Thanks!
Compiling with the msvc toolchain does indeed link the functions correctly. I'll see if I can find the bug in the lua crate. Thanks!
GTK3 *can* look good on Windows, except the file dialogs. MyPaint is the best (ok, and only) example I've found of a good looking Windows GTK app. Unfortunately I tried to reproduce the same with Rust's GTK bindings and it ended up [hilariously awful](https://stackoverflow.com/questions/37035936/how-to-get-native-windows-decorations-on-gtk3-on-windows-7-and-msys2). I have no idea how they did it and nobody responded to [my query](https://community.mypaint.org/t/how-have-you-made-the-window-decoration-native-on-windows-10/698).
I think a big problem is that it's not clear how to actually make a nice Rust GUI API. Rust just seems not suited to writing GUIs. It might be better to make a GUI DSL (like QML) that works really well with Rust.
As I understand it, this is expected at the moment but not necessarily desired. The explanation I've heard is that promoting implied constraints to actionable constraints risks introducing action-at-a-distance issues that could make debugging harder. On the other hand, some constraints (like yours) feel like they should apply because that was the whole point of writing them wasn't it? :) There is some work/thoughts on promoting implied constraints to actual constraints (in the same way that when you have type constraints for a struct, you probably shouldn't have to type them out again for each impl block for the struct). I personally avoid using associated types as much as possible (note: "as possible"; some times you really need them), as all constraints on them require repetition at each implementation site (until some ergo fix lands).
(not OP) Yeah this is the right direction. But I've been thinking about a more traditional-desktop-focused framework, with typical widgets included, and a QML-ish component model / language (with embedded Dyon instead of JS). Also an idea I had: instead of a library it should be a sandboxed executable "player" for the new not-QML, with RPC over a pipe with a different process for doing normal OS native things.
I agree, just look at all the organizations still using C++98 (or C++11) despite them being completely backwards compatible. However, I don't necessarily think that it's all that bad. Rust 1.0 was serviceable, if a bit spartan, but rust "2015" will be a perfectly fine language. Especially since you can still get the better compiler and tooling while sticking to the old epoch.
I just moved [gutenberg](https://github.com/Keats/gutenberg), a static site engine to use cargo workspaces to speed up compilation time which was getting slow. I'm now adding benchmarks and trying to speed up things in the `next` branch: https://github.com/Keats/gutenberg/pull/88 Any help welcome if you like to make things fast :)
I have though about this topic: - Once macros 2.0 lands, you can convert anything into Rust using `TokenStream`-s without using plugins. If you look at the main.rs file, you can see that the current layout is a bit of a mess so my idea was to use either macros or a compiler plug-in to convert something like JSON to Rust at compile time. - this also has use cases for automated UI testing, like asserting in your tests that none of your text overflows. - In the end, macros will be used for instantiating components plus you can use your own, custom widgets rather easily. Like `listview!(somedata, LAYOUT_EXPANDED)` for instanitating a list view that is expanded by default. Since everything is based on `flex`, it will automatically stretch to fill the parent container. Maybe theming for each platform. - Functions are handled by function callbacks or closures. - The layout is completely seperate from the renderer. For example, for properties like round edges, a renderer can choose to support them or not. The only thing a renderer must be able to render are rectangles, nothing more. Every DSL has the disadvantage of performance. But yes, either something like QML or JSON - but with compile-time guarantees. When I'm done with this, the system should consist of two libraries: a layout library and a seperate OpenGL renderer. 
Nice. I think it would be cool to eventually write a TrustedBSD (MAC) policy module in Rust! :) 
This is awesome! You've shown a "standalone output" example. How do you imagine it would look like when integrated with a RLS-enabled editor? (I'm probably going too much to the future with this question) I think that what is worth explaining the most are the things that are *implicit* in the language: especially, a few things come to my mind: * coercions (deref, but not only) ‚Äì where they happen, why they happen * desugaring of operators * showing which pointers are fat * types in pattern-matching (what types are matched with, and what are types of the resulting bindings) That would require going above syntax level though.
I really like this RFC. It addressed all of my initial concerns, and I think it would be fine if we just adopted this verbatim. However, I think calling these epochs distracts from what they really are: language versions. It's probably about time to start versioning the language and compiler separately. I know we really don't want to call anything Rust 2.0, but if you're breaking code that is what it is. It seems a bit drastic just to add a keyword, but that's what we have to do. The alternative is to end up like the C++ committee, endlessly trying to find suboptimal syntax that is technically legal for whatever new feature.
Please do not share this widely before there's anything to show off. We've only *this week* started work (as a startup of sorts) and it will be a while until we have a demo. If you want to learn more and maybe eventually get involved, you can contact me on IRC, but there really isn't much right now, only a rough plan.
&gt; How do you imagine it would look like when integrated with a RLS-enabled editor? Honestly, i have no specific opinion/vision on that. I could think of a select -&gt; right click -&gt; explain -&gt; overlay workflow (like the definition hover). But rls integration is not mandatory, e.g. in VS Code, i work a lot with the console. Distributing it via cargo and using it as a cli tool seems viable, too! &gt; That would require going above syntax level though. I think it goes on the type level. Currently, it just traverses the ast. This makes it possible to implement it easily as a component, as its only dependency is syntex. Going into the type level requires thight bonding with the compiler, which makes it heavyweight and breaks with nightly. But i agree that it is definetly an interesting topic to explore! Noted on my `want`-List :D Edit: rephrased to be more specific
Yeah, my idea is different, I don't want any Rust compilation happening for UI development, I want a QML-ish interpreter (with [Dyon](https://github.com/PistonDevelopers/dyon) instead of JavaScript) with hot reload (save the file and the UI layout updates automatically). So you run `thing myUi.not_qml` and you get a webrender based window that renders the UI that file describes. And for native functionality you run the `thing` from a program (in any language) and the two processes talk using some RPC protocol. You don't need much performance for UI scripting (like QML actions and such), it's mostly code like "when button is pressed, show panel". The performance critical parts should be written in Rust (e.g. a built-in layout component based on [cassowary](https://github.com/dylanede/cassowary-rs), etc.)
 Thanks, I'll use as_ref, I always forget about that method.
It depends on the behaviours in question. If it's feasible for the toolkit to provide a sufficiently high-level API, some of the variations can be abstracted away. If the toolkit doesn't restrict the person excessively and they know enough about the platforms they're targeting, platform-specific code is often a viable way to make one UI cover the rest of the variation. It's that "and they know enough about the platforms they're targeting" that's the hard part.
I think one thing that would help this RFC would be an operator that lets you name things the same as keywords, like C#'s `@`. For example: pub fn @return() {} We might only need the `@` in declarations so you could use that function like mod::return(); though that might be optimistic.
Today I'm releasing three things: - Vulkano 0.5, which adds a lot of safety checks and mechanisms. Despite being released only about one month after Vulkano 0.4, there have been 221 commits since then. Most importantly, command buffers have been totally reworked (see [this PR](https://github.com/tomaka/vulkano/pull/542) and [this one](https://github.com/tomaka/vulkano/pull/558)). - [Vulkano.rs](http://vulkano.rs) aims to provide a guide oriented towards beginners to teach low-level graphics programming. As explained in the introduction, it won't explain techniques such as rendering animated characters, lighting, or using a camera for example. Instead it focuses on how to interface with the GPU. Right now the guide is blocked on the lack of a feature in vulkano (clearing an image outside of a render pass), but once that is implemented new sections will be added. - [A patreon page](https://www.patreon.com/tomaka) for my work in open source (yes, that's my face). I've been maintaining a constant pace of contributions in Rust libraries over the past year for absolutely no gain, as I've always felt a bit guilty about asking money for this type of work. But I've received many encouraging messages about donations, and working on libraries such as vulkano is by far the activity I prefer (more than any of the jobs I have had over the years). Having a source of revenues for this work would encourage me to do more! Let me know if you have any question!
Have you ever read the interface guidelines for an OS? They cover a lot more than "this widget looks like this" - they cover things like "your application should be laid out like this, with widgets that do this sort of thing over here, and the icons should be pulled from this set", etc etc. Short of some way of describing UIs at that level - "I need a UI that's capable of doing X, Y and Z, with the ability for the user to do A, B and C in M, N and O contexts", there is no way to abstract this out to a reasonable level. If you can solve that, you stand to make millions.
I had a similar thought, but with different looking syntax on my mind, I was thinking of SQL DBs that support quoting identifiers to allow keyword-like field names and whatnot. At a quick glance it looks like MSSQL and Postgres use double quotes (select "select" from "table") and MySQL uses backticks (select \`select\` from \`table\`). Identifiers in quotes wouldn't probably look very pretty in code (SomeTrait::\`catch\`(&amp;im_making_this_up);), but using them would be a compatibility thing anyway, so hopefully less used.
Is Ion POSIX compliant?
It doesn't matter in practice, whether it is language or toolchain problem. You have to spend time fixing it anyway. 
that's already a thing that happens, especially to the compiler
first patron! woo! Honestly, I think people who are contributing such awesome stuff to open source should have methods of receiving donations from the community for their work. You've contributed tons of immensely valuable stuff to the Rust community, and I want to help support the work you're doing now and into the future, even though my contribution will just be one of many. As a software developer, 3d graphics is my biggest area of weakness, so I definitely don't use or know how to use Vulkano, but I hope that it will continue advancing so that one day, when I have time, I can start to learn how to use 3d graphics for visualizations that I want to do, and hopefully using Vulkano or a higher level library built on top of Vulkano.
Can I ask why? If has_request is None you will still traverse the entire vector for nothing
Thank you very much &lt;3 
No HTTPS? :( https://letsencrypt.org/
I've been meaning to for a while, but I was actually referring to my own comparative observations between what people seemed to agree on as being pleasingly "good and native UIs" for equivalent applications in KDE, GNOME, and the versions of Windows I've had sufficient exposure to (basically, everything pre-Ribbon). In other words, adapting between *de facto* interface guidelines rather than *de jure*.
You are now the first person I've supported on Patreon :D
Heh, I thought people wouldn't mind if a static website that doesn't take any user input wouldn't bother using HTTPS. The hosting service I used doesn't support letencrypt, and I don't want to bother renewing every 90 days I think. I think it should be possible to make my app automatically request a certificate from letsencrypt, but I haven't worked on it yet. On one hand I could simply grab a one-year certificate, but on the other hand it would be really nice if I could get this automatically-request-a-certificate thing working. 
Thank you!
It tends to come up more on macOS, being honest, since macOS has had a reasonably well-kept-to design across most applications over a number of OS releases. It becomes really obvious when an app isn't native as a result. As an example, whereas e.g. Chrome was perceived as "new and shiny" on Windows where a number of apps have different designs and behaviours anyway, I perceive it as "not adhering to how all my other apps behave" on macOS. The main window is laid out wrong (the tab bar is supposed to be *underneath* the toolbar), the menus behave entirely wrong, configuration-related stuff is all wrong. It's "native"... insofar as it doesn't behave like a webapp (*glares at Spotify*), but it's not "native" as in behaving like the other apps on my system.
Thanks for letting us help support you further tomaka, I just signed up &lt;3 Keep up the excellent work!
Rust and GUIs are a recurring topic around here. Personally I believe that Servo represents our best chance. Servo is the halo/headline project for Rust and ton of effort has been put into it, it makes sense to capitalize on that. Simultaneously Electron is massively popular, so the approach of using browser engine for gui is both familiar to many people and validated by real world apps. 
Thanks! You also deserve a lot of gratitude for your work on porting things to OSX.
This'll certainly be a lot more work and I guess thinks like scaring newcomers by linking them directly to an RFC might need a second thought, but otherwise, I think this is *just cool*. I don't know about integration into RLS, but what would make sense to me would be integration into rust playground, or have it on the web in some other way ‚Äí you either paste the code or provide a link to the source code somewhere. It would be great if the code itself could be turned into links (eg. that `'a` itself being a link). Just some random thoughts.
IRC-based Command &amp; Conquer ? It's still better than the PS1 version right ?
I'm curious about how the overall app is structured in regards to threading. Keep in mind I'm a bit of a noob when it comes to tokio, but I see that `amazon-ses` takes a reactor Handle, whereas `pleingres` is able to create new event loops. How is the base app structured? I guess that part is `httpserver`? Does it have one reactor per thread or is it a single threaded app running under one core reactor? Any insight there would be cool.
As someone who works on a code base with lots of Python in it, 3 absolutely was and still is a fiasco. The dynamicity seriously weakens what the 2to3 conversion tool can do, and the community's only answer is, "it's your fault for not having unit tests for everything, even all the tiny scripts that you wrote in 2 minutes to glue things together." Subtle changes cause infuriatingly difficult to debug breakage, and they didn't even fix the language's biggest warts (a standard library where every imaginable naming scheme is used and default arguments that are saved across function calls). We have probably wasted weeks of developer hours cumulatively on these issues, and considering what developers are paid that isn't cheap. Now multiply across all the companies using it, and you're talking about millions of dollars wasted so we could start putting parenthesis around print (). At my work we have python 2, python 3, PyPy for python 2, and PyPy for version 3 all installed. Anytime there is a problem the first question is WHICH python? 
What benefits does HTTPS provide for a static site? 
gfx-rs is cross platform, on gitter I've heard about qt5 integration. My humble opinion is gfx-rs is the future of cross-platform graphics. I have no idea how to manage a ton of UI objects though. Anybody got some nice examples?
I know nothing about FreeBSD kernel modules, or Rust, or anything else really, so i have two very basic questions. Firstly, why does this project include "copied from Rust source code, unmodified" versions of libstd_unicode, libcollections, and liballoc? Why can't it use the ones from the standard library? Is that because this project is no_std, but needs a few things from std? Is this the Best Practice way to handle this situation? Secondly, why does println inside the kernel module (as in 'Read 6 bytes. Setting new message to "Hello\n"') end up printing on the user's terminal? Shouldn't that go to dmesg or some such? 
No, that is not a goal of the project (see the README).
Keep it up man! Patron #3 here
Did you setup measurements already (e.g. using perf or oprofile)? Also for quick wins, it's often helpful to profile memory allocation, because sometimes one can reduce them for nice low-hanging fruit.
ISP can't inject ads.
It provides cryptographic proof that the content is from the source it says it is from. Also I don't like Comcast looking at my stuff.
privacy
Something is wrong with the responsive breakpoints on the website. When I make my browser smaller than ~half of my monitor, everything goes tiny.
I can't seem to figure out how to do the simplest things with [`nalgebra`](http://nalgebra.org/)! :-( Right now, I'm trying to have a matrix of generic size inside a struct: extern crate nalgebra as na; use na::{Scalar, Dim, MatrixN}; fn main() {} struct Container&lt;T: Scalar, D: Dim&gt; { x: MatrixN&lt;T, D&gt; } That gives me an error: error[E0277]: the trait bound `D: na::DimName` is not satisfied --&gt; src/main.rs:8:5 | 8 | x: MatrixN&lt;T, D&gt; | ^^^^^^^^^^^^^^^^ the trait `na::DimName` is not implemented for `D` | = help: consider adding a `where D: na::DimName` bound = note: required by `na::MatrixArray` Inserting that trait bound just leads to another, and so on, so chasing down that path doesn't seem to be the right solution. What am I missing? Isn't this how you're supposed to do it?
&gt; This'll certainly be a lot more work This is why i made a poc first - maybe it will inspire others to contribute :) &gt; scaring newcomers by linking them directly to an RFC Yeah that's a thing :D as i'm not aware of other resources, that's the only thing i can link to atm &gt; integration into rust playground would be super cool 
&gt; We have probably wasted weeks of developer hours cumulatively on these issues, and considering what developers are paid that isn't cheap. I see at as a lot more time saved by not migrating to entirely different language, which many companies eventually would do, if Python would stuck at version 2. Thanks to 3, Python is still a compelling option (in its domain). &gt; Now multiply across all the companies using it, and you're talking about millions of dollars wasted so we could start putting parenthesis around print (). Python 3 brings unicode support, but more importantly - became much easier language to teach. This means you can find now people who know Python easily. Without Python 3 and parenthesis around print, you could be left behind with everyone moving to Julia, Ruby, C# or whatever would took over, and all those companies would just spend billions just to continue to exist, with not even benefit of a parenthesis around print. Yes, migration had a cost. But not doing it would cost far more. 
Thank you!
&gt; However this guide doesn't cover actual graphics programming techniques, such as loading a 3D model or adding realistic lighting to a scene. Recommendations for good guide(s) that do?
I have a process that can be represented as a state machine, is there an idiomatic pattern to handle the different states and their transitions?
Also, better SEO
Unfortunately not really. I learned myself a long time ago and am not really up to date with all that. Especially now that WebGL exists, I think there are websites that guide you through 3D rendering but I don't have any link in mind.
Doesn't that make the project less prone to be adapted by lots of people?
That libui wrapper is unmaintained and unusable.
I am really impressed by you ambition of trying to introduce GPU programming to newbies by vulkano, since everyone yells how hard vulkan is and no any other programming language or library dare to claim this. Great work!
How so ?
&gt; Without Python 3 and parenthesis around print, you could be left behind with everyone moving to Julia, Ruby, C# or whatever would took over, and all those companies would just spend billions just to continue to exist, with not even benefit of a parenthesis around print. I hope this is parody.
Side note about the site: I'm on a full-sized desktop monitor (1920x1080) and the text is still small unless I make my window larger: http://i.imgur.com/eiDLOr9.png
Google likes it.
Very interesting! I was wondering if you are aware of my Askama library for templating? https://github.com/djc/askama It seems like it might fit your sensibilities.
I'm actually curious what you mean by "scalability" though. Are you concerned that our query builder won't support all the queries you want to write, or performance? It's worth noting that using our query builder is actually slightly faster than working with a SQL string directly.
That makes sense. macOS is sort of in an uncomfortable spot there, being both a small slice of the market share and much less Windows-like than most XDG-spec desktops (ie. Linux/FreeBSD/etc. desktops). (Sure, XDG-spec desktops try for a comparable degree of consistency, but their conventions tend to take enough cues from Windows conventions that it's not difficult to stumble on something mostly correct and it doesn't cost anything to spin up a Linux VM in VirtualBox for testing and refinement.) That said, Windows is definitely infamous for being a madcap scramble of applications with a tendency to have custom theming to a ridiculous degree. To be fair to macOS's high standards, though, my attitude toward my Linux desktop is quite similar. Within the limits of my free time, I put a lot of effort into ensuring everything follows the same UI/UX behaviours unless there's a **very** good reason not to. (In fact, that's one of the reasons I try to eliminate GTK+ 3.x applications from my desktop whenever feasible. The demands of the GNOME 3 HIG have pushed them to deviate uncomfortably from the common norms shared by the other apps which were developed based on actual Human-Computer Interface research, rather than cargo-cult copying aspects of the feel of macOS while missing the underlying theoretical rationales which drove them.) That said, on Linux (where scroll events always get delivered to the widget under the cursor, regardless of focus), the Chrome tab bar is such a productivity enhancer that I replicated it in Firefox using maximization, a press of my "undecorate" global hotkey, and an extension to make the scroll wheel switch tabs. (And for exactly the same reason that Apple chose to pin the menu bar to the top of the screen. Fitts's law.) From a theoretical point of view, you could say it's because the "all tabs in one window" browser workflow I use is like a second window manager nested within the main desktop, where efficiency improvements can have such disproportionate productivity gains that I'm willing to make an exception.
&gt; So what library or tool do you think is still missing in the Rust ecosystem None are missing. Those that exist are missing on features and maturity.
A great way to only make acceptable states and operations representable is [session types](https://github.com/Munksgaard/session-types). If you don't want the complexity this entails, a simple enum with suitable transition functions will do fine.
Can't really compare Swift to other examples though, since the alternative is basically not developing for that hardware/ecosystem
Scala does this. It's basically never used. It'd be useful to Diesel since it'd mean we could properly generate code for any database schema, even those with names that aren't valid identifiers.
&gt; if you're breaking code that is what it is. That's why this proposal does not break any code.
&gt; Is this the Best Practice way to handle this situation? Not that I'm aware of; xargo should know how to only build those crates and use them.
Yeah, Google likes sites over HTTPS https://webmasters.googleblog.com/2014/08/https-as-ranking-signal.html
I'm not seeing meaningful mentions of conrod. I'm in early stages of using it for a project (mixed feelings; should be good enough for a static GUI), is there something I should know?
I'm trying to remove sequential duplicates of a particular enum variant from a Vec. I've found a way to do it by creating a new Vec and cloning each element, but is there a way to do it in-place to the Vec parameter? I'm new to Rust, and I've been fighting the borrow checker on this one... Here's my code, the second function won't compile since I'm immutably and then mutably borrowing. fn remove_duplicate_newlines(tokens: Vec&lt;Token&gt;) -&gt; Vec&lt;Token&gt; { Some(tokens[0].clone()).into_iter().chain( // always include first element tokens.windows(2) .filter(|w| (w[1] == Token::Newline) &amp;&amp; (w[0] != w[1]) ) .map(|w| w[1].clone()) ).collect() } fn remove_duplicate_newlines_mut(mut tokens: Vec&lt;Token&gt;) { let indices = tokens .windows(2) .enumerate() .filter(|&amp;(i,w)| (w[1] == Token::Newline) &amp;&amp; (w[0] == w[1]) ) .map(|(i,_)| i); for index in indices { tokens.remove(index); } } 
cross post this to /r/vulkan I will definitely support you, because I've been using your glium wrapper rather successfully. Vulkan sadly does not run on the hardware that I have to support, stuck with OpenGL. EDIT: done. and retweeted.
There is exactly one reactor per thread, and pleingres does not create event loops by itself: if you look at the example on https://docs.rs/pleingres/0.3.0/pleingres/ , it spawns a connection to the server into the event loop, returning a `pleingres::Db`, which you can then use to interact with the database in the same event loop. httpserver does run any event loop either: the event loops are started in the main.rs, one per thread, and each of them runs an SSH server, an HTTP server, an HTTPS server, connections to the database, and sometimes an HTTP client to call out ot Amazon SES and OAuth servers.
This probably seems like a stupid nitpick and maybe it is but... You may want to add a title tag to nest.pijul.com.
One option is sort &amp; dedup: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort https://doc.rust-lang.org/std/vec/struct.Vec.html#method.dedup
Building arbitrarily complex queries, testing them in a command-line psql client, and modifying them based on that. I don't see how your query builder can be faster than what pleingres does, which is essentially: - one connection per thread, running forever (one thread per core, independently from the number of clients or requests). - parse the query the first time you see it, and then never again. - two buffers, allocated in the beginning of the connection, and only reallocated when their size increases due to big queries or answers. All that asynchronous, I'd love to know how you can beat it.
It looks great, thanks for the suggestion. I'm probably going to stick to maud though, I like the idea of generating correct and small HTML automatically, rather than writing HTML templates. I wonder how it will work if I ever get designers to work on this project, I guess I'll translate them myself.
&gt; I think of it as my duty to point out that the Electron framework carries a terrible potential for misuse when fallen into the wrong hands. The Monu OS X only process monitoring menu bar application built using Electron weighs no less than 189 MiB on disk! Yes, you read that right: a heavyweight cross-platform framework featuring a complete built-in browser engine was used to create a menu bar widget for a single platform! No disrespect to the program‚Äôs author, I‚Äôm sure he had the best intentions and he‚Äôs a nice person and all (even if he is clearly somewhat misguided in the practical execution of his ideas), but who would seriously entertain even just the thought that a 189 MiB menu bar app was going to be an okay thing to do, honestly? Electron devs in a nutshell
&gt; It's also relevant that Rust has static type checking. This is a huge deal when migrating. This gives you more confidence that when it compiles, it works, but getting there may not be easy, and language alone is just part of it. Such migration will most likely also involve updating dependencies and every single one of them may have different approach to handling epochs and backward compatibility - the situation of Rust here is far worse in this aspect comparing to Python. Having macros makes it even more complicated.
I personally recommend cloudflare. Super easy to set up, free tls and caching.
That's right, thanks.
I can't find it, but there used to be a website for untangling or explaining of statements with nested pointers and whatnot of C. I think it was written by someone involved in the LLVM/Clang community. Does anybody remember what that was? edit: found it, it was this: https://cdecl.org/ It just explains *a* statement though, not a series of statements. Also not related to LLVM/Clang either. 
This doesn't seem to be one of "the simplest things"! It looks like you are missing the other two bounds: where D::Value: Mul&lt;D::Value&gt;, Prod&lt;D::Value, D::Value&gt;: ArrayLength&lt;T&gt; I got these from the [`MatrixArray` docs](https://docs.rs/nalgebra/0.12.3/nalgebra/core/struct.MatrixArray.html). You'll have to add `typenum` and `generic-array` as dependencies and make sure the versions match what `nalgebra` uses (in particular, it uses a way out-of-date version of `generic-array`).
&gt; I don't see how your query builder can be faster than what pleingres does Based on what you said I'd assume they do the standard method of hashing the SQL query to lookup the cached prepared statement on subsequent calls? We're able to skip that step, since we can uniquely identify queries by their type at compile time. (This performance difference literally does not matter for PG though. SQLite is the only driver where IO/query execution are short enough for the overhead to be visible)
Rust doesn‚Äôt have a stable ABI. Maintaining the ability to link together crates compiled with different compilers is a much bigger headache than you seem to assume.
Makes sense, thanks for the feedback.
Why not Co-opt the React Native approach? It is proving popular abd gives there native components most apps need. Yet another alien UI is not a big step forward, just catching up to the 90s.
We'll probably release the async driver for Diesel soon
Each crate can be on a different epoch and it's fine. You don't have to update to a new epoch to use a dependency that's on a newer epoch.
I've assumed that real need for Rust 2.0 will not arise for at least several years, so there will be enough time to work on this [issue](https://github.com/rust-lang/rfcs/issues/600). Of course it's a prerequisite for that I've described, but either way I think stable ABI (inside major version at least) is needed for Rust in the long run.
What if I have a project on some epoch and I am using a macro a crate from earlier or later epoch is exporting? Will compiler follow that and tag generated code accordingly?
You should really try Netlify. They're doing a superb job in hosting static websites (CD from Github, automatic SSL and CDN included for free). 
&gt; Heh, I thought people wouldn't mind if a static website that doesn't take any user input wouldn't bother using HTTPS I think the main concern for this type of site is that some unscrupulous ISPs inject ads into the page, sometimes heavy ads (mini-movies :x), sometimes tracking ads, and sometimes ads that distribute malwares. With HTTPS, they cannot modify the page content, and thus cannot inject those nefarious ads.
Thanks for the info, curious, is that main.rs available anywhere? 
Must... resist... urge... to post a Stannis Baratheon gif.
Maybe something like https://learnopengl.com/? Granted, it's OpenGL-related, but I think it does a good job at teaching 3D graphics concepts.
&gt; 1 and 2 can be served by the same UI toolkit, whereas for case 1 is impossible to abstract I think you mean case 3 is impossible to abstract?
I would suggest crowdfunding on r/Ethereum platform. I'll be doing this in a few months, but it'll be months still after that before I can get to this. But essentially, one of the main ethereum clients (Parity) is written in Rust. It's how I found out about the language in the first place. So basically, you'll have a very willing and generous community that already has warm and fuzzies about production Rust code. Don't pretend to return any profits with App Coins, just do a straight up crowdfund on Ethereum. You can give people an ERC20 token as proof they donated if you want... that'd be nice.... like Unicorn tokens that Ethereum Foundation gives out for donations. Edit: Ok, not that I didn't expect downvotes (I'm used to it for the last few years), but do you *want* to let credit card companies and patreon to skim 2-5% of the raised funds?? I'm *legitimately* recommending raising funds on a platform that is well suited to this use-case. [Warm and fuzzies](https://www.reddit.com/r/ethereum/comments/621wlj/parity_fast_light_robust_ethereum_implementation/) about [Parity](https://parity.io) client...
I see. I never experienced these types of ads (I think it's a US-specific thing) so I didn't think of that. 
I don't know, for me it actually makes the project a lot more attractive! I'm using [fish](https://fishshell.com/) and I would never go back to bash.
Maybe this is crazy, but why do we version anything in a human readable way at all? Why don't we take function fingerprints and of compiled code (sha3 hash?? Truncate to desired length?) And then when compiling or sharing libraries/crates it looks for function definitions as-compiled? If a function doesn't change from one release to the next, then neither will the hash of its compiled code...
Last week I finally pushed a new version of both my device tree source parsing [crate](https://github.com/yodaldevoid/dts_viewer) and DTS viewer program. This week I plan on running the parser against some odd DTSs that I have access to through work. The parser already parses every DTS file in the mainline Linux kernel so I'm fairly confident that there are only a couple more parsing errors to iron out before it matches the DT compiler. Beyond that I have been thinking about taking a break from the usual coding projects and working on an RFC for dev build scripts.
Thanks for the reply! The main reason I don't want to use dedup is that I only want to remove sequential duplicate Token::Newlines, not sequential duplicates of any other Token. Additionally, I want to preserve the order of Tokens, so I can't sort them.
~~What about [dedup_by_key](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.dedup_by_key)?~~ Never mind, didn't understand this function
SAML. It's been superseded more or less by JWT et al, but SAML will be in use for a long time. 
A client for [Eureka](https://github.com/Netflix/eureka). I'd also like to see tiberius (MSSQL client) matured, and for diesel to integrate it. Very hard to pitch Rust at work until we have these libraries.
&gt; But yes, either something like QML or JSON - but with compile-time guarantees. As a current Qt / QML user, compile-time guarantees in the DSL would be a huge deal. It's incredibly frustrating when you write a few thousand lines of QML / JS only to have it fail with a runtime error that would be caught with minimal static checking.
Same as ususal for me : an idiomatic, cross platform, native (or at least native looking), GUI library.
Plus, HTTPS pages load faster (not because of the cryptography, mind you)
Any idea why I'm getting conflicting implementations here? https://is.gd/XAX12t But not if I remove the generic on the trait like so? https://is.gd/MVSrWr Surely the first is more constrained than the second? not less?
Yep. Edited and reworded.
Don't you have issues with other tools which rely on being POSIX compliant?
That would be really grate. I hope that orbtk will get some more attention through I think it is one of the more promising works so far. My calculation was focused on what would it cost a company to do this work if they have to pay the developers the full and fair price for the work. 
"free"
I've played with the qml crate before and it works well. If you wanted a pure Rust native GUI, I'd strongly advise just writing a native qml engine instead of making the DSL / toolkit from scratch.
I'm fully aware of that and its exactly what I meant, I think we agree completely, you just interpreted my comment uncharitably. I said hundreds of millions as the upper end of my range of how much a GUI library can cost, if you wanted to replicate every piece of functionality Qt has: dozens of platforms, hundreds of widgets, animation, 3D, a GPU/CPU vector graphics rasterizer, an IDE, media, automotive, bluetooth, charts, full unicode and localization support, rich text editing, gamepad, OpenGL, Vulkan, NFC, Purchasing, Serial bus, speech, being a Wayland compositor, SVG, embedding Chrome, maps, GPS... Qt definitely has had more than a hundred million dollars of development put into it, and it shows in terms of what it can do. But indeed you only need a small subset of that for most useful apps. Hence why I'm planning on working on this task in my spare time, but even a minimal library is a dauntingly large task.
Fast, idiomatic, generic: - SIMD - linear algebra (same scope as C++ Eigen3), - geometry (same scope as CGAL), - procedural macros for SoA / AoS, - MPI wrapper. 
My first order of business this August will be to write a Rust windowing library for OSX that creates an OpenGL context that works for UI libraries. I've been researching it a bunch and I think it's a reasonably small task at this point. It should be useful for Conrod, Servo and any other OpenGL GUI library efforts. The trick is (unlike winit) to not switch dual-GPU macbooks to the discrete GPU and support GPU switching, support live resize, support retina displays, support moving a window between retina and non-retina displays and to not render garbage for the first few frames.
Do you think it's possible to have Vulkano.rs linked on the main Vulkan website as a "language binding" library or something? It would be awesome if Vulkano.rs had official support from the Vulkan team!
A good small-to-medium-sized wiki server. I'm sick of everything being PHP, Javascript, or dead.
As another fish user: no, those tools run in shell scripts that call `#!/bin/sh`.
Looking at some recent posts in this subreddit, it seems web scraping is a poorly covered domain. Do we even have some equivalent of either lxml or BeautifulSoup from Python (a featureful, _resilient_ HTML parser)?
Yah I've seen stylish before and looked into it a bunch. It has a bunch of great ideas and is the closest thing to what I'm thinking of that I've found. However, my main worry with it is that it will just be a slow version of Servo with less features. It uses the same DOM/styling model as Servo (and other browsers) but without the highly optimized parallel layout and styling, and without the optimized DOM representation. Stylish uses string maps everywhere whereas browsers at least have optimized representations for common elements. Don't get me wrong Stylish looks great for small apps, but Electron is also super fast for small apps. My fear is that Stylish doesn't seem to be avoiding what makes Electron slow and bloated for larger apps.
Html5ever?
There's some discussion in the OP about it.
The trick there is that if you use Dyon you lose all type information, which makes interfacing with Rust painful. QML is actually pretty great, the only thing I don't like about it is the lack of type information, and that the dynamic nature makes super high-item-count things (e.g a Sublime minimap, or a trace viewer with 100k+ boxes) high memory. I don't understand how your idea improves on just having really good QML bindings for Rust. I agree that avoiding Rust compile times would be nice though. I'm thinking of possibly a stylish-style middle ground where the stylesheet is dynamic but the UI model is all in Rust. So at least tweaking things to look right is fast.
My day job is basically writing services that: a) parse protobuf b) interact with S3, SNS, SQS c) provide REST APIs d) cassandra e) MySQL f) Mocking As far as I know (e) is the only one with a stable library (I think deisel is 1.0 and supports it?) for it. Every one of those would require a stable released library behind it. Mocking in rust is still weak. 'double' looks promising but it's not nearly as easy as Mockito. I actually think language-level support for mocking would be really nice.
A good-quality LazyCell crate.
Isn't it because of coherence? In the second case, we need to know that `GameScreen` does not implement `UIScreen`, and since it is only possible to write this impl in the crate that defines both of these (ie. this crate) _and_ we know that this crate does not write that impl, we know they don't overlap. But if there is a type parameter like in the first case, another crate can define a type `Foo` and write an impl `UIScreen&lt;Foo&gt; for GameScreen`, and then the two overlap.
Not quite, you still have C and Objective-C at hand and fuckups in that department would incur high costs in the ecosystem. Say what you will about Apple, but they showed great care to make switches to the next big thing possible (as long as you work in their stack, RIP codewarrior).
This very annoying problem is a [known issue](https://github.com/rust-lang/rust/issues/24010) for several years, that will hopefully be finally fixed now that the trait alias RFC was accepted, since they are fairly useless if this issue remains.
My idea gets rid of the whole gigantic Qt C++ framework and uses WebRender :D Also my #1 practical problem with QML/QtQuick is that its DPI scaling is integer only (1x 2x 3x‚Ä¶ not 1.5x) which is FUCKING RIDICULOUS HAVE THEY NEVER EVER SEEN A 28 INCH 4K DISPLAY?!!?!
deleted ^^^^^^^^^^^^^^^^0.0449 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/28849)
deleted ^^^^^^^^^^^^^^^^0.1147 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/02577)
Thanks for the clarification!
Vulkano.rs is not really a binding, more like a rich/safe wrapper around Vulkan. The real binding would be the `vk-sys` crate, which is maintained by the same person. 
Why not bring these features to winit instead?
It looks like Gtk+ 4 is going to support rendering via Vulkan, see https://www.phoronix.com/scan.php?page=news_item&amp;px=GTK4-VLK-Wayland-Georges With [gtk-rs](https://github.com/gtk-rs/gtk) there already is a good Rust binding, I think they will also support version 4.
I would guess more like https://vulkan-tutorial.com/. 
Stylish does seem to have *much* lower memory usage than electron (not sure about servo). On the other hand, it currently uses ~5% cpu, even when idle.
Can confirm, text size scales with window size rather than desktop size. Which is annoying if the browser is not maximized. 
I've been thinking about such a thing and have an idea (maybe a stupid one but still...): why not using an HTML engine (like servo? :D) and make most of the rendering based on this? At least we'd have the support of the platforms right away. However theming would certainly be hellish...
Performance hasn't been my main focus for stylish so far as I just wanted to get something working as a proof of concept. That being said performance hasn't been too bad when I've used it in my game [and its actually been working well so far](http://i.imgur.com/aaHUP3H.gifv). It could be much better though and its something I'm hoping to work on.
Could you please educate me on why that is? I am curious now. I don't understand much about the web and internet protocols, but I would presume that HTTPS is basically just HTTP with extra steps (wrapped around in encryption, certificate verification, etc), so I don't logically understand how it can be faster, as both the browser and the server clearly have to do more.
Diesel needs an attribute in table definition, language change is not necessary for this.
&gt; native looking Having used wxWidgets, I can tell you that each platform's native toolkit has MILLIONS of bugs. And especially for Windows no one wants to fix them. Even Microsoft isn't using the native API for their applications anymore!
In theory HTTP and HTTPS should have the same loading time (or slightly slower for HTTPS, since there is more to do). However in practice browsers enable some features such as HTTP2 and brotli encoding only if you use HTTPS.
There's ways to compile Qt Quick apps that only include the small portion of Qt that it actually uses. I think you can get them down below 10mb and definitely below 30mb. It could be better but it's not that bad, and I don't expect a Rust rewrite could do that much better. I also don't think just rewriting it to use Webrender will gain much, since Qt Quick already uses a similar approach, in fact the current main author of Webrender (glennw) also worked on the Qt Quick renderer. The integer DPI scaling thing is unfortunate, but I bet it would be easier to fix Qt Quick than to rewrite it in Rust. To be clear I bet fixing it would be hard, just rewriting it would be way harder.
I'm not going to lie, I've been worried about the crypticness of Rust's syntax for a while. While I respect the work that you're putting into this tool, I think it's a mark against the language that it has to exist. This situation reminds me somewhat of C's atrocious ["declaration reflects use" syntax](http://c-faq.com/decl/spiral.anderson.html) for types. There's a point in K&amp;R where the authors admit that this syntax "is somewhat castigated" but it's okay because "truly complicated declarations rarely arise in practice" (gosh, wonder why). The authors decide the best way to resolve this is to exhibit a pair of programs that can translate between C declaration syntax and english, e.g.: &gt; `char (*(*x[3])())[5]` &gt; x: array[3] of pointer to function returning pointer to array[5] of char so that by reading, understanding, and running this program, students can come to grips with the syntax. I have always wondered at this. Surely the far better resolution would be to just go back and fix the syntax. Once K&amp;R got to the point where they had to write programs to explain their syntax, you'd think that they would recognize that they had made a mistake. 
Yah I read your post and I'm really happy about the work you're doing. I absolutely don't expect performance to be bad, I just expect it to be worse than Electron or maybe better than Electron but worse than Servo, unless you make some fairly significant changes. Electron and Servo are both fast, they're just limited by the DOM/JS model. All your examples and screenshots are small enough that they would also be plenty fast in Electron. RAM usage is harder to predict. Right now you'll definitely have lower base usage, but I don't know about marginal memory usage of each additional UI item since stylish currently uses strings everywhere instead of atoms(see https://github.com/servo/string-cache) and maps instead of structs. Servo/Electron use doubly linked lists though so each element costs at least 3 pointers, but I think yours are still bigger, and you don't get the cheap insertion of doubly linked lists.
I'm a total noob to graphics programming, so forgive me if this is a dumb question, but why does it take [400 lines of code](https://github.com/tomaka/vulkano/blob/master/examples/src/bin/triangle.rs) to render a triangle? I get that there are lots of options being set and infrastructure being constructed, but can't this be abstracted away, at least for beginners, so that there can be some progressive disclosure in the learning?
If I can I would like to, and if I figure it out I will, but so far it looks like doing it correctly might require a different API model than winit uses. Winit wants to let you do rendering on your own time and give you a run loop, whereas Cocoa wants to be able to ask you to re-render outside the event loop in a draw callback when it wants. For example OSX suspends the event loop on live resize and relies on the draw callback, so winit/glutin just doesn't support live resize and there's no good ideas for how to do so yet with the API they expose: https://github.com/tomaka/glutin/issues/445
Banged my head against quite a few sharp edges, so perhaps this toy project can help others who want to join the embedded rust fun.
Ah I see, thanks for the explanation :)
It would be /u/simonsapin's [Kuchiki](https://github.com/kuchiki-rs/kuchiki). It's based on Servo's html5ever and CSS selectors.
Pretty cool! I'm running through the guide and I've noticed a bunch of typos though. Can I submit a pull request on those or something?
Instead of let mut yy = y; if m &lt; 3 { yy -= 1; } writing let yy = if m &lt; 3 { y - 1 } else { y }; is a better style IMO.
I think this is meant to be a very low level but safe wrapper. Something you can write abstractions over.
&gt;I'm a total noob to graphics programming, so forgive me if this is a dumb question, but why does it take [400 lines of code](https://github.com/tomaka/vulkano/blob/master/examples/src/bin/triangle.rs) to render a triangle? &gt; &gt;I get that there are lots of options being set and infrastructure being constructed, but can't this be abstracted away, at least for beginners, so that there can be some progressive disclosure in the learning? Vulkan does have a lot of infrastructure that needs to be initialized. Personally I'm not a fan of the "nothing to triangle" metric, because in almost all cases that is what you start abstracting away. Maybe the examples should encourage this by providing pre-baked abstractions, but if you're learning Vulkan you should dig into them anyways. I'm conflicted. I'd say there are two schools of learning that should be catered to. Bottom up, which is quite well served by verbose, heavily commented code. And top down, where you value getting quick results with minimal code. For the latter, you are probably better served by using a game engine.
Meh. Anything complex will require a complex declaration. It doesn't matter which language you use. You commonly use abstractions and aliases to hide some of the complexity when the language allows. This is why you seldom see declarations like that in C. It has `typedef` to help you with that, for example.
Which is what we're doing, but it'd be nice to have the default generated code "just work"
It‚Äôs over 1000 LOC with less comments in the [first C++ example I could Google](https://github.com/SaschaWillems/Vulkan/blob/master/triangle/triangle.cpp) and over 900 in [D example](https://github.com/MaikKlein/VulkanTriangleD/blob/master/source/app.d). And those examples even have shader code in external files, unlike Vulkano one ‚Äì (edit:) although shaders in those examples are so short, it does not make a difference. I believe that‚Äôs just because of the Vulkan‚Äôs verbosity ‚Äì it forces the programmer to do everything explicitly. And AFAIK Vulkano is not meant to abstract over Vulkan ‚Äì only to provide safe, but still low-level and *vulkanish*, API on top of it, so a lot of that verbosity remains even for simplest tasks.
Setting up an autorenewal with cron or whatever isn't that difficult. I do it for all of my sites, but it's understandable if you don't want to bother.
Nice example! I'm looking forward to programming AVR with an unmodified Rust toolchain. A small observation: The IO port registers DDRx and PORTx (and PINx as well) are 8 bits wide, not 16, so you might want to define them as *mut u8 instead of *mut u16 :)
What would it do?
Looking at the [guide](http://vulkano.rs/guide/buffer-creation) I have a Vulkano API design question. When we are creating a `CpuAccessibleBuffer` we are passing to the `from_data` constructor the `device.clone()` parameter. But since the buffers are device dependent (Please correct me if I'm wrong) and the underlying Vulkan API is object-oriented, why isn't this rather implemented as a trait on the `Device` type? Then the usage would be something like `device.buffer_from_data_cpu_accessible(...)` or similar. Not that I don't like the design, I just want to know the reasoning behind it :) 
Yep. Indexing stuff is less common and with `.i(5)` still nice enough IMHO. But there is nothing we can do^(until the next epoch that is!)
All browsers decided to only allow HTTP/2 over TLS. (In part because HTTP/2 over plaintext often gets screwed up by proxies.) And HTTP/2 is an *excellent* speed boost.
There was a language that before Python was widely used in education and business, that is now gone from both of those places. Few applications that use it still exist, but large amount of them were rewritten since then. Certainly it wasn't done for free.
I think that's 100% just what you're used to. They're both visually distinct characters, the *only* difference is what you've trained your mental networks to recognize as generics. Over time, you can unlearn and relearn what symbol that is. For C++ and Java programmers, angle brackets make sense... and they're a huge percentage of the target population.
ooops! fixed :D
400 lines with *huge* comments, to be fair. But really: this is a *thin wrapper* around Vulkan. This is low level GPU access. If you want to quickly draw a triangle, maybe use a *game engine*.
I came here to say largely the same things. Math, especially native linear algebra. Eigen is a good comparison. Honestly, I expect Rust to have its own linear algebra package, and not just a wrapper to a C/C++ version. There's some nice starts, but none quite clinches it yet. 
Provide a constructor that takes an FnOnce and a constructor that takes a plain value. Implement a Deref that computes the value on demand. Provide a thread-safe and a faster single-threaded version. Use interior mutability (UnsafeCell?) so that a non-mut LazyCell can be dereferenced.
You should look at Delphi VCL component hierarchy. It's a good start point. Or the open source equivalent in Free Pascal/Lazarus.
For file io, I think it's recommended to use the sync up methods along with futures-cpupool (which integrates with tokio)
Usually not, like /u/icefoxen says, but for stuff that requires you to source the scripts you do have issues. In some cases these can be solved by [bass](https://github.com/edc/bass) though and otherwise it's usually quite simple to rewrite these utilities for fish.
Should one use a game engine for ones first attempt to learn graphics / game dev? If so, which one? Is there a good rust one?
The UNIX/POSIX story certainly needs improvement. We have std, nix and libc ‚Äî and going between them (when you need to go lower or higher level) is really not smooth. e.g. I recently needed [to add a waitpid flag to the stdlib's Child.try_wait](https://github.com/myfreeweb/ion/commit/ed036960c5cfbcf9b6b24319da4e749ac420f59b#diff-cc20bc374fba8d873a99948f7710250eR231) ‚Äî that required rewriting the function in a different way. I know that the standard library is very encapsulated because it's not POSIX-only and it's very good for writing Windows-compatible code, but I wish there were better ways to drop down to libc/nix from std everywhere. Command.before_exec is a very very nice API, we need more like that all around‚Ä¶
The thread-safe one sounds like https://crates.io/crates/lazy_static
That provides a global value, whereas I would need lazy fields. Edit: [found this](https://gist.github.com/cristicbz/25589338cadc218c6744).
Congrats! As always, great stuff!
`proc(): Send -&gt; T` looks like pre-1.0 Rust fwiw
[Lattice](https://github.com/andrew-lucker/Lattice) is preparing for a 0.4 release. This includes among other things documentation, examples, conditional rendering, and a solution to the view-state problem. All around it is great to be able to write stateful UI from the ground up and this is one of the huge differentiating factors of the Lattice approach. Ideally anyone could build off these foundations to create their own high-performance UI components and styles and deliver them to major platforms without too much fuss. That is the goal for 1.0 and we are one step closer to that goal. 
I was deciding between Haskell and Rust for writing a language implementation and ended up opting for Haskell in significant part because of the mature and well-maintained high-level [llvm-hs](https://hackage.haskell.org/package/llvm-hs) bindings. Rust has had a couple of [similar](https://crates.io/crates/llvm-alt ) [efforts](https://crates.io/crates/hllvm) but the other two adjectives unfortunately don't seem to be true of them. (EDIT: Whaddayaknow, it seems `hllvm` has had some updates since I last looked at them!) I wonder how hard it would be to transliterate `llvm-hs` more-or-less mechanically to Rust (maybe with the assistance of https://github.com/tcr/corrode-but-in-rust). It doesn't seem to make much use of the fancier GHC features. Of course, that *still* wouldn't by itself solve the "mature" and "well-maintained" problems.
sorry , i only think it is a good way for rust GUI, so i share it here.
It's definitely what you're used to. For me, coming from Haskell, I actually prefer as little syntax as possible. I really enjoy languages with a syntax similar to Haskell's (that is, almost zero syntax)
Rust targets C++ developers. C++ uses &lt;&gt;'s. There's basically no difference between the two except who uses them in which communities.
I am so new in Rust. It is quite nice to see people playing around with Rust and embedded software. Great job ! 
IIRC you previously claimed that Vulkan(o) was not for beginners graphics programmers. What changed? Do you feel the library is actually a good suit? Or do you still maintain that it is important to learn OpenGL first? Great site though, I can't wait to dig into vulkano, thanks for the amazing work!
What about Ion? I'm really tempted to use it, but I'm quite scared of incompatibilities. It seems like a well built shell, but I'm a very heavy user of the shell and do not want to have to compromise my workflow because of incompatibilities. Thoughts?
Ah. It seems you are right. Not sure why I didn't realise that before. I decided to solve it by introducing a netwype wrapper for UIScreen&lt;T&gt; that I implement Screen for ( https://is.gd/BPmG4m ).
The "deprecated luggage" will mostly be branches in the parser. It's not much. Rust doesn't have a stable ABI, nor will it in the near future. Being able to "link" crates compiled by different compilers is a nonstarter at the moment. Note that epochs don't necessarily imply breaking changes; they're a periodic thing that model stages in Rust's evolution. Rust today _already_ looks pretty different than Rust 1.0 -- while code written for 1.0 still compiles, current Rust has a bunch of often-used features that make it different. Having a way of taking about that is helpful. Epochs provide a mechanism for which parse-level "breaking" changes can be made in a way that doesn't break anything. 
Epoch features are not pervasive, they're mostly limited to the parse level. So they won't turn up in exported APIs -- if you read the RFC it mentions that the "core language" will continue to stay the same.
It's totally fine for a crate to be "stuck" on an epoch. You can use it from a crate on a newer epoch. This is not opening the floodgates to breaking changes. This is basically allowing for _syntax_ to be broken; which is really a minor issue, and being stuck on an old syntax is fine.
It's identical for users (because "everything just works"), but significantly different under the hood. Also proposed scheme allows us to be significantly more flexible in what we can do, e.g. to fix Error [problem](https://github.com/rust-lang/rust/issues/35943) or to [reorganize](https://internals.rust-lang.org/t/refactoring-std-for-ultimate-portability/4301) stdlib without leaving a lot of aliases to keep backward compatibility.
 While I wouldn't personally like indexing with parenthesis, having an "Apply" trait like scala would be neat, so .i(5) would be totally possible.
&gt;The "deprecated luggage" will mostly be branches in the parser. It's not much. But it still stays in the compiler. Over time we will have more and more of such cases, which will make code less and less clear. And what about deprecated items in the stdlib? &gt; Rust doesn't have a stable ABI, nor will it in the near future. Being able to "link" crates compiled by different compilers is a nonstarter at the moment. And as I wrote earlier I don't think we will need Rust 2.0 for at least several years, so no rush on this. &gt;Note that epochs don't necessarily imply breaking changes And it's a very bad thing, because it mixes two concepts marketing releases (which can be called LTS) and releases with breaking changes. Yes, it's smart from marketing point of view, because you ship sour pills with pile of tasty ones, but I personally think it's horrible from the technical point of view and somewhat dishonest. Also this "parse level" restriction is not a very good thing either for evolution of the language.
What is missing from something like [rulinalg](https://crates.io/crates/rulinalg)?
Some kind of `futures-fs` crate that wraps file system operations in Futures/Streams, either by using async io where available or by delegating to a threadpool like AFAIK libuv and other sync-fs-in-async-setting solutions do. Currently everyone's simply expected to roll their own for each fs operation they do, which I don't think is acceptable, as it's more work and may lose out on certain optimizations that someone may be unaware of. AFAIK, without such a library, many people will think they're doing async stuff but will be blocking if they do any fs operations. I saw seanmonstar (creator of Hyper) [created a crate](https://github.com/seanmonstar/futures-fs) but I'm not sure what the deal is with it. Also, and related to the above, more work or information on composing distinct async libraries and threadpools. The problem I don't want happening is each library in my program creating it's own threadpooled-synchronous-fs, so you end up with multiple threadpools when they could and probably should all be using the same one. I'm also concerned about this with respect to event loops/cores.
It's already known that `Drop` can interfere with tail call.
A cross-platform coroutine crate that doesnt require nightly.
The shell that a user uses doesn't really matter, given that valid shell scripts will always execute with their respective shell. POSIX shell scripts are always denoted with `#!/bin/sh` or `#!/bin/env sh`. Also to note is that Bash itself isn't POSIX either, and Python scripts work the same way. Ion's primarily oriented towards being the default shell for Redox, but if you want to use it on Linux or BSD, you can. Just know that Ion has a different syntax than POSIX shells or Bash, so you can't expect to throw Bash scripts at Ion.
&gt; Anything complex will require a complex declaration. It doesn't matter which language you use. I'm afraid I have to disagree with you. Consider the case of [`set_new_handler`](http://users.monash.edu/~damian/papers/HTML/ModestProposal.html#footnoteref1.1), "which takes a single argument (a pointer to a function taking no arguments and returning void) and returns a similar function pointer." In an ML, one simply writes: set_new_handler : (() -&gt; ()) -&gt; (() -&gt; ()) It's that easy. There's no need for "help" from a type alias. You don't need to think to write it, and you don't need to think when reading it. In C, however, the declaration is: void (*set_new_handler(void (*)(void)))(void); What's especially unfortunate about this state of affairs is that the cognitive overhead seems to psychologically trick unwitting coders into implicitly treating function pointers as "expensive" even though they really are not.
higher level maybe stupid question: Is there any frameworks built on top of Piston? I'd really like to try and use rust for an upcoming game jam but all the examples look a lot more complicated/with less abstraction than the stuff I'm used to doing. 
Yay! I ran into the same issue. 
Working on a few things! My first project in rust that I'm still working through is a abstraction layer over an audio plugin library for Rust. If you're familiar with JUCE for C++, I'm trying something similar. https://github.com/piedoom/rvst_synth It's still pretty nooby and takes up way more CPU than it should (probably allocating memory somewhere) but I learned a lot while doing so. Still a lot to accomplish. PS - if you're into audio programming and want to join a telegram group about making audio plugins in Rust, let me know so I can send you a link :) The other thing I'm doing: Tumblr API wrapper in Rust https://github.com/piedoom/rumblr Tumblr API wrappers are like my Hello World with new languages for whatever reason. This is proving a little harder than expected due to the way Tumblr formats data along with fighting the OOP nature of JSON, so it's on pause for a bit. Anyways, these are my first two projects in the language, like, ever. But I really enjoy it so far. The only thing I wish it had were fields on traits. 
Check out [select](https://crates.io/crates/select)
DSP
The `nix` crate could use some better documentation, and it's missing a few nix functions.
This is outstanding, a level of clarity I've not seen elsewhere. Please make it / demonstrate nested generics, because I can't wrap my head around that syntax at all; as soon as you get double angle-brackets I can't parse it any longer.
Thank you! So the solution _was_ chasing down the route of trait bounds after all! It looked to complicated to be right to me. It's unfortunate that all this is required just to declare a matrix. :-/ Anyway, I managed to go one baby step further and allow for non-square matrices: extern crate nalgebra as na; extern crate typenum; extern crate generic_array; use na::{Scalar, Dim, DimName, MatrixNM}; use std::ops::Mul; use typenum::operator_aliases::Prod; use generic_array::ArrayLength; fn main() {} struct Container&lt;T: Scalar, R: Dim, C: Dim&gt; where R: DimName, C: DimName, R::Value: Mul&lt;C::Value&gt;, Prod&lt;R::Value, C::Value&gt;: ArrayLength&lt;T&gt;, { x: MatrixNM&lt;T, R, C&gt;, } I'm sure I will get stuck soon again and come crawling back to this subreddit for help. Thanks again!
I enjoy the arguments about how equal temperament has downsides and that even a western tradition avoids it sometimes like when prefering to minimize beats in the case of piano tuning, but it's hard to take this post seriously when the English is so poor (particularly the grammar).
I think it would arguably be better to teach rustc/llvm how to do it (or approximate the effect, e.g. by minimizing the size of the stack frame across the recursive call)
Well, English is not my native language. But this post is actually [a gist](https://gist.github.com/suhr/317fb399adc3c65ac0779df468aa6aa7), so it's possible to fork&amp;edit it. 
Tried the examples. My feedback on this: * There are no screenshots on the readme for orbtk, would be nice to have some images of what a GUI looks like without having to compile it yourself. * The Filtered example doesn't register at all on Mac OS X * The text is not antialiased, might be a platform thing * Controls and layouts look pretty ancient Here's a couple of screenshots for the curious: [http://imgur.com/a/qnV8z](http://imgur.com/a/qnV8z) 
That bug got moved to https://github.com/tomaka/winit/issues/39 which was [closed back in February](https://github.com/tomaka/winit/pull/132): &gt; Fixes the issue where window resize events would not be emitted until the end of the resize. This PR fixes #39 by ensuring that the user callback given to either `EventsLoop::poll_events` or `EventsLoop::run_forever` can be called by each window delegate's resize callback directly.
This matches about 90% of what I do as well. My kingdom for solid mocking for easier tests. I'm still working on Rusoto for the AWS bits. My past few jobs have all been heavy users of AWS and without a solid AWS SDK, Rust is nice to know about but not relevant.
You know, it doesn't surprise me that C++ and D are *even worse*. In OP's comment, they write that they plan to make graphics programming teachable via Vulkano, which I think is an admirable goal. I've noticed that every time I've tried (admittedly, not very hard) to learn graphics programming, I'm hit with this unmotivated glut of "let's initialize the window, and the panel, and the graphics, and the buffer, and the texture buffer, and the whatsit, and the pipeline, and the other pipeline, and so on; don't worry about what this code is doing yet, just copy it and modify the triangle bit at the bottom," and it's a somewhat frustrating learning experience. What I would like to know is: - Why does it take so much work to set up the GPU? - What is this work actually doing? - Could I do it differently? What are the possibilities and tradeoffs? - What benefits are there to actually learning and understanding this initialization?
First of all, i've opened an [issue](https://github.com/MSleepyPanda/explain-rs/issues/6) for these kind of questions Some technical notes: If you restrict fat pointer annotations to vtables/trait objects, this would be possible on type level. Inspecting foreign types on their behaviour (do they store pointers, if yes how do they access, etc.) is probably out of scope. What do you mean by "type in pattern-matching"? To be more precise, in which case would you like a literate explanation when matching, and why? **Edit:** btw thanks for your input, these are very important aspects to cover. I didn't thought of them in the first place, as i considered them given.
I wrote a bit of rusoto code today actually and submitted a PR last week. It's actually pretty close to where I'd be ok putting it in production, personally. Right now the lack of timeouts and automatic retrying logic kills me the most, otherwise I have no complaints. I think hyper .11 was the only blocker for my issues.
Swift does this, using backticks. Since most Swift keywords are contextual, you often don't even need them when trying to use a keyword as an identifier. For example, with your "SomeTrait::\`catch\`(‚Ä¶)" example, if `catch` is a contextual keyword then it's obvious that `SomeTrait::catch(‚Ä¶)` isn't using that keyword, so it wouldn't even be needed there.
For now, I'm just adding benches to the potentially expensive parts and improving them. I didn't care at all about performances yet so there are very obvious improvements without needing to profile anything yet
You can automatically detect when type signatures change in a backwards-incompatible way, but there are other backwards-incompatible changes that cannot be automatically detected. Trivial example, take any function and rewrite it to do something completely different (while preserving its arguments and return type). Since it now does something different, this is a backwards-incompatible change for anyone who was using that function, but you can't detect this through automated analysis.
I usually get them in the US on free WiFi at cafes and airports and things. Never home internet though.
My understanding of this proposal is that rustc ver. X will always compile any code that rustc ver. Y &lt; X could compile, perhaps by means of a command-line option. That is good; fully agree. The issue with calling this "Rust 2.0" instead of "Rust Epoch 2018" seems to be the assumption that people will infer that a major version change of Rust implies that the tools (e.g., rustc) no longer work on "Rust 1.X" code. While people may assume that, it seems to me that proper marketing could correct this misunderstanding. 
Opened an issue, you can track notifications on it if you want to [link](https://github.com/MSleepyPanda/explain-rs/issues/5) :)
Yah I know it was moved and closed, but unfortunately it's not actually fixed as far as I can tell, that or every app I've seen that uses winit/glutin is using it wrong. I think they fixed part of the problem and gave up on the rest. See this recording of today's webrender demo not having live resize: http://imgur.com/a/d6GfO. My GIF recorder made it worse than it actually is, the window just goes blank when I drag it, it doesn't flash black and white. Still bad though. **Edit:** Actually it may still be broken, or not, but my GIF isn't actually evidence since webrender appears to use https://crates.io/crates/servo-glutin which is different. Weird since I thought that the whole point of Servo's custom glutin was to support live resize. Imma investigate more. **Edit 2:** It turns out conrod, which was the other place I had seen an absence of live resize, is stuck on a build of winit from January, so it may very well be fixed but not actually used places, but I haven't confirmed yet. **Edit 3:** See further comment below, the latest glutin does support live resize.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/BYYyPXL.gifv ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[state_of_imgur](https://np.reddit.com/r/u_imguralbumbot/comments/6i1huv/imgur_has_gone_to_shit) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20djscb83) 
As for the Haskell to Rust conversion: there's still significant questions (around monads, module system, type analysis...) that would need to be answered to even get close to a full conversion. Right now it's essentially useful in eliminating a lot of the grunt work involved in porting, with hacks specific to a single codebase. But I hadn't considered llvm-hs and similar libraries as candidates for porting to Rust; I wonder if there's enough libraries that it's worth broadening this approach?
Probably worth commenting on the `winit` bug to get it reopened if your testing shows that it is still broken there.
Somewhat relevant: https://github.com/seanmonstar/reqwest/issues/14
I didn't know Xamarin was available for Desktop applications. But, AFAIK, Xamarin was something of a hybrid solution. Acc. to the project's website, everything is native ¬≠‚Äîlook-and-feel, performance and API access. Since you seem well-versed with Xamarin, may I ask: How has been your experience with it so far?
&gt; Is there any reason using OpenGL/Vulkan/WebGL as the graphical back-end would be considered a bad idea? It is complicated, you have to care about batching (to reduce GPU calls) and mapping everything to GPU concepts. 
Thank you for the explanation! I ended up removing the associated type to work around it.
Oh, that's even better! Thank you so much for your insight, mate. I really appreciate it. You've been extremely helpful and supportive.
See my 2 edits, it turns out nothing I've tried is using a recent version of winit, and they changed the API a bunch so I can't just try them on the later version. I downloaded the latest glutin and tried out their example and live resize works there, so you are right, thanks. Unfortunately resizing the glutin window rendering a single triangle is waaay laggier and jankier than resizing a Preview app window with a whole bunch of widgets displaying an image. Maybe I'll profile and try and figure out why, I hope it's not a fundamental limitation of rendering with GL.
&gt; And what about deprecated items in the stdlib? What about them? They have to stay around, sure, but can be inaccessible in the new epoch. That's consistent. &gt; But it still stays in the compiler. ABI compatibility also stays in the compiler forever _and_ stagnates any ABI development including possible future layout optimizations. If you want a smooth Rust 2.0, "cruft staying in the compiler forever" is going to have to exist anyway. Far better for it to exist in a relatively simple part of the compiler (the parser). &gt; Also this "parse level" restriction is not a very good thing either for evolution of the language. It's not exactly just parse level, certain other things can change too (e.g. how modules work), but no core parts of the language. &gt; Yes, it's smart from marketing point of view, because you ship sour pills with pile of tasty ones Actually, no, it doesn't. You misunderstand, using a new compiler on an older epoch still gets you new features _except_ the ones that absolutely need that epoch to work. Typically, this will actually mean that you don't lose out on new "features". For example, the `dyn Trait` thing doesn't introduce a new feature at all, it's just a syntax change to make the language less confusing. Similarly, `catch` can exist in the form of `do catch`. It's not dishonest at all, because you can still upgrade the compiler and get new features without things breaking, and you can still use crates on older epochs. In fact, this will be the _default_ state, you have to explicitly opt in to having your code "break", and even then it will be just your code (not your dependencies) and will likely come with automated tools for upgrade.
Huh, what do you need in a eureka lib? I've gotten by pretty easily with a homegrown combo of reqwest + serde, although I admit my load balancing is kind of trash and all I do is service discovery, not registration. Now that I say it, I can imagine a couple requirements that would be nice to have.
&gt; What about them? They have to stay around, sure, but can be inaccessible in the new epoch. So after some time you will have "deprecated luggage" all over stdlib. &gt; ABI compatibility also stays in the compiler forever and stagnates any ABI development including possible future layout optimizations. ABI has to be stable only across major version to be able to link between major versions. So next major version can change ABI however it wants. &gt; but no core parts of the language. As understand those "core parts" will not allow to fix e.g. Error issue, which I've linked earlier. Or to reorganize stdlib. Or many other possibilities which could arise in the future. &gt; Actually, no, it doesn't. You misunderstood me. Just read Ixrec [comment](https://github.com/rust-lang/rfcs/pull/2052#issuecomment-312959731) in which he writes exactly about what I was talking.
The Rust ecosystem is really lucky to have someone giving this much attention to the language's 3D graphics story and library support. Game development doesn't get much official attention from the road map and such, so I'm pretty grateful somebody's burning the midnight oil to lay down such an important piece of 3D graphics infrastructure. I'm trying to get serious about game development and using Rust as the means to that end. I've been playing around with Vulkano for a project and I'm hoping to actually use it in a serious capacity once I'm more fluent with the Vulkan API and rendering pipelines in general. Any and all work towards making Vulkano more mature, flexible, and accessible is worth a monthly subscription from me! Keep up the great work!
Some basic image manipulation/drawing libraries would be nice. Currently using piston's image crate to open and composite a bunch of live-streamed jpeg images into one big image to serve up, but now I need to quickly overlay simple bitmap text. Quickly, as in, do this 15 frames a second, simply, as in 8x8 console font is fine. It doesn't seem like this is readily available yet, so I'm going to have to roll my own it seems. 
For those who don't know, [Diesel](http://diesel.rs/) is a self described "Safe, Extensible ORM and Query Builder for Rust." I already use it in a reasonably sized project and it's an absolute pleasure to use. Diesel hitting 1.0 is a blocker for my own project hitting 1.0, so this news is quite exciting for me.
&gt; So after some time you will have "deprecated luggage" all over stdlib. This was going to be the case anyway. If Rust 2.0 was a possibility (as I say later, it really wasn't), it would probably have been conservative in what was broken. So, no removing APIs. If anything epochs let us be more aggressive here since we can remove access to these. &gt; So next major version can change ABI however it wants. This splits the ecosystem. This is exactly what epochs prevent. You have to understand, Rust 2.0 is one of those "never going to happen" things. It has a whole host of potential problems, and is likely not going to have much benefit for that. Nobody on the team wanted it; and things have all been planned assuming it won't ever happen. Epochs are a compromise that have a very small fraction of the problems, and most of the benefits. &gt; As understand those "core parts" will not allow to fix e.g. Error issue, which I've linked earlier. Or to reorganize stdlib. Or many other possibilities which could arise in the future. Yep. We're stuck with that. You're talking about a hypothetical alternative that was never going to happen in the first place. &gt; You misunderstood me. Just read Ixrec comment in which he writes exactly about what I was talking. My understanding of that comment or yours has not changed. I'm not sure what you think the discrepancy is here. I get that there are two concepts being mixed here. I don't see a problem with that. The main benefit is the ability to talk about these points of evolution in a more concrete way. Because every year Rust "breaks" anyway. Not in the sense that old code stops compiling, but in the sense that new code may look dramatically different from old code. The language evolves rapidly, and this may lead to docs and stuff going out of date. Epochs give you a concrete way to talk about that in documentation and stuff. 
This is exciting! I still really want postgresql's basic [user-defined enums](https://www.postgresql.org/docs/current/static/datatype-enum.html) to be supported :( It's such a safer/less-error-prone and more Rustic way of expressing the meaning of certain columns than just using a bare integer or a varchar that could contain anything. Regardless, it is always exciting to see Diesel make progress! I'm sure enum support will come eventually.
Edit: disregard this comment, I used it previously because I was using the postgres crate previously. [Here's the issue](https://github.com/diesel-rs/diesel/issues/343) which tracks it in Diesel. I believe you can use user-defined enums, I used some previously. Searching my code to find it at the moment.
&gt; implicitly treating function pointers as "expensive" even though they really are not. Storing the function-pointers themselves? Or calling them? If the latter as well, I seem to recall differently from my CPU-design class; that predicting/prefetching the location of an unconditional but variably-destined branch is extremely difficult compared to predicting the decision of a conditional, fixed-destination branch. Or is it that doing so is possible but the hardware to do so forms one of the longest paths in modern designs?
This [glutin](https://github.com/tomaka/glutin/blob/master/examples/window.rs) examples support live resize on macos, and should also automatically resize/redraw when moving it across hiDPI displays on macOS. If not, it's a bug in winit, and probably overkill to start your own entire library for it, unless there's a severe case of NIH involved :) I have up-to-date branches for [glium](https://github.com/mitchmindtree/glium/tree/update_winit_0_7) and [conrod](https://github.com/mitchmindtree/conrod/tree/winit_update_0_7), though I'm waiting for either [this](https://github.com/tomaka/glutin/pull/897) or [this](https://github.com/tomaka/glutin/pull/900) to land in glutin before I do. And yes, servo's glutin was forked a long time ago. It would be great to see if it were possible to replace it with today's glutin.
Only if both the client and server support HTTP/2. Otherwise HTTPS would technically be slower.
Ahh just noticed this comment! &gt; Unfortunately resizing the glutin window rendering a single triangle is waaay laggier and jankier than resizing a Preview app window This might be because the glutin examples are setup to re-draw on every single event that occurs - If you change it to draw once before the loop begins and only on every `Resized` event, I imagine it might go smoother. Edit: The resizing would also likely behave much better if an upper limit on the draw frequency was set to something like 60FPS (or some similar interval) to avoid trying to redraw on *every single* `Resized` event.
&gt;This splits the ecosystem. This is exactly what epochs prevent. In the strict sense it does, but for user it will not matter as tooling will use Rust 1.x compiler and stdlib behind the curtain when needed. So all those horrors of Python 2/3 will not apply here. From the utilitarian point of view both epochs and 2.0 approaches almost equivalent in this sense, as you will be able to compile old code on Rust 2.0 without any changes. &gt; You have to understand, Rust 2.0 is one of those "never going to happen" things. Rust 2.0 in the strict semver sense indeed will "never going to happen", but I (and others) advocate for a different kind of 2.0, point it's seems you simply do not want to understand. So this "never" argument is completely irrelevant and not techincal in the first place. If it will make easier to understand for you let me reformulate it like this: Hypothetical Rust 1.xx (if you afraid of 2.0 that much) will have rustc1 and rustc2 under the hood, which will use std1 (current std) and std2 (current std with removed deprecated items, or maybe even completely reorganized) as standard libraries. For rustc1 std will be aliased to stdlib1 and for rustc2 to stdlib2. So it's boils down to tooling to let crates written for rustc1 and rustc2 to work together without friction. &gt; I get that there are two concepts being mixed here. I don't see a problem with that. And others (including me) see problem here. So lets agree to disagree on that.
So maybe an imagemagick port?
&gt; but for user it will not matter as tooling will use Rust 1.0 compiler and stdlib behind the curtain It can't, because there's no ABI compat. (And if there is ABI compat, again, you're freezing a much larger part of the compiler than just "oh we have to keep a few stdlib functions around") &gt; point it's seems you simply do not want to understand. You haven't really been clear as to what your proposal is. &gt; Hypothetical Rust 1.xx will have rustc1 and rustc2 under the hood, which will use std1 (current std) and std2 as standard libraries. This only lets you make breaking changes to the stdlib, not the compiler. Also, cross linking crates on different stdlibs doesn't make much sense either -- what happens to traits? What happens to coherence? The Error trait problem is still intractable in this model if you want to still be able to work with code written for an older stdlib. If you really prefer this approach I highly suggest you write an alternate RFC -- there may be something tractable there, but so far I don't see it. If it does exist a more structured approach (having an RFC that's discussed) may be better than just arguing on reddit :) &gt; So it's just matter of tooling to let crates written for rustc1 and rustc2 to work together. Again, that requires keeping around a lot more legacy cruft than epochs.
I do too, and I have never even used a language that uses square brackets. For those who think it‚Äôs just what you‚Äôre used to or that there‚Äôs no difference between the two: - Improved readability: `Foo[Bar[Baz]]` is simply easier to read than `Foo&lt;Bar&lt;Baz&gt;&gt;` in all fonts that I know of, for similar reasons to why having mixed-height letters is an advantage. - Easier to type on most keyboards: you don‚Äôt have to hold down the Shift key to get square brackets. - Reduced syntactic ambiguity: `&lt;` and `&gt;` are also used for comparison operators, which are *not* matched pairs, so text editors suffer. Parsers potentially suffer slightly from angle brackets too‚Äîif indexing is left with square brackets, you‚Äôd still have `foo::[T]()`, but if indexing were changed to parentheses, you could cut the `::` and use `foo[T]()`. - If you use parentheses for indexing, you have the potential to reduce function call and indexing concepts down to one more general concept which for various purposes would actually be much nicer. You could wind up having some sort of function calls which can be by-value, by-ref or by-mut-ref depending on context, just like indexing syntax now. There are certainly challenges to it, but if you got it right the language would have more consistent and arguably nicer semantics, though it would be less C-like. Seriously, I think the *only* argument for using angle brackets for generics is the social one of familiarity for users of C++, Java, C‚ôØ *et al.* The technical reasons are uniformly in favour of square brackets. I do find it mildly amusing that the purely-syntax part of things *could* actually be changed in the proposed epoch system. We couldn‚Äôt switch to parentheses for indexing, though; that would be a *much* more invasive change.
user experience. 
It's only special in `Self`, and the idea is that it won't be special forever. For now it is though.
We did at one point, just like almost everything it feels like. It ended up reverting back to `&lt;&gt;`. Like others, I'm pretty sure that this is "what you're used to"; I find `[]` for generics to be much more confusing than `&lt;&gt;`. But that's because I've only ever used languages where `&lt;&gt;` is used, and never ones where `[]` is used.
Awesome! I guess I'll probably strike that off my list of projects since you've already done it! One thing I still might do is make a script for wrapping your rust executable in a .app so that you can use the magic Info.plist key which makes it not switch to the dedicated GPU on dual-GPU macbooks. Unfortunately you can only do that with an app bundle. I'll also see if I can get Webrender set up with new glutin in a way that is nice, and then move onto my next small project of making Webrender scrolling and bouncing feel nice on OSX.
So is there a current theoretical reason why the compiler cannot accept whatever type `T : Deref&lt;Target=Self&gt;` as the type of the `self` argument? or is it just 'on the waiting list'?
&gt; And if there is ABI compat, again, you're freezing a much larger part of the compiler than just "oh we have to keep a few stdlib functions around" I think we will need stable ABI sooner or later regardless of this 2.0/epochs discussion, so I just assume when hypothetical 2.0 time comes we will have it. &gt; This only lets you make breaking changes to the stdlib, not the compiler. Can't see reasons for that. rustc2 can have all changes which epochs can give and more. &gt; Also, cross linking crates on different stdlibs doesn't make much sense either In the most cases it will be enough to have 1-to-1 mapping between types and traits to let 1.0 items be inter-operable with 2.0 ones, but for more complex cases explicit usage of std1 will be needed. (so those types and traits will be foreign to rustc2 version of std) It will largely depend on what kind of changes will be introduced into 2.0. &gt; If you really prefer this approach I highly suggest you write an alternate RFC I've considered it, will probably try to do it later. &gt; Again, that requires keeping around a lot more legacy cruft than epochs. If you'll count sizes of rustc1 and rustc2 together then yes. But the thing is, in this model rustc1 will be kept as a legacy and after some transition period will not be actively developed. So main activity will be inside rustc2 which will be smaller compared to rustc from epochs approach and with the smaller amount of the accumulated technical debt. And of course rustc1 will be optional for tooling which has rustc2, it will be downloaded only if unmigrated crate is lies somewhere in a dependency tree. Yes, it will be a case for a significant time, but after it only rustc2 will be needed.
No, it's also everywhere in China!
&gt; But the thing is, in this model rustc1 will be kept as a legacy and after some transition period will not be actively developed. This is going back into the "never going to happen" territory, because it's coming close to describing the hypothetical Rust 2.0 again. &gt; so I just assume when hypothetical 2.0 time comes we will have it. In which case I feel like you're talking about the far far future at which point this discussion is moot. ----- Anyway, I don't see much point discussing this further, your proposal seems to be jumping from here to there and it's very unclear what you're actually trying to propose. Additionally, no matter how I interpret it, I see the same disadvantages in epochs as in your proposals, and more, so I don't really see the point.
i stick everything into `.ionrc`, but i suppose you could instead source a file with your aliases.
I was suggesting hashing the compiled code of the function, so very implementation specific... to the point where if two programmers create the same function inputs/outputs and code, it'd get the same hash... I haven't thought this through too far... I'm also not a language designer... so maybe I'll ruminate on this some more before spouting off like I know what I'm talking about ¬Ø\\\_(„ÉÑ)\_/¬Ø
on the waiting list, mostly. Dispatch gets weird if you can define custom types there, though. E.g. what do you do when `MySmartPtr&lt;T&gt;` has a method `foo()` but you also have `fn foo(self: MySmartPtr&lt;Self&gt;)` for some type? (Currently, if you hack the stdlib and add such an impl to box, and then try to call it, it will fail to compile but not give you any recourse for disambiguation IIRC) There are a couple of things around Box that need to be decided, but it's very low priority. This would actually be a pretty useful feature, though, instead of having to do things like implement functions on `Arc&lt;T&gt;` via traits.
&gt; maybe last release before 1.0 Will Diesel 1.0 support async I/O? Perhaps that will be left for Diesel 2.0?
What's the point in hashing the code of the function? That doesn't tell you anything at all about whether it's backwards-compatible.
Something along those lines would be nice. I'm porting a script I wrote ages ago in Python - I use [Pillow](https://pillow.readthedocs.io/en/4.2.x/reference/ImageFont.html) in Python to do the image manipulation and text overlay. Rust is doing all the heavy lifting fine with the image crate - there's a max of 16 320x240 15FPS JPEG image streams that sniffed off the network, reassembled into their base JPEG format, then decoded to a raw image format, combined into one large 1280x960 image that's then reencoded back to JPEG and finally sent out at 15FPS. Threads in Rust have been nice for this! Now I just need to draw a bit of text on the composite image and I can retire that old script that chugs along at 2 FPS. Ideally, I'd link to libjpeg and muck about with the lossless jpeg stitching methods because they would suit my purposes exactly, but that might be a job for later. Much, much, later :-P 
A "blessed" cryptography crate. `Ring` is coming along, but not there yet. Convenience features are missing (such as init-update-finish signatures). It also depends on Rayon which in turn brings in more dependencies than I want in a straight crypto library. `rust-crypto` is abandoned. `RustCrypto` has picked-up the torch and split into hashes and block-cipher projects, but is missing signatures and public-key functionality. {Open,Libre,Boring}SSL wrappers exist, but are married to an antiquated API.
We need service discovery and registration capabilites, although not load balancing. I'm sure it can be done with just reqwest and serde, since eureka has a REST API. I started working on a client, but haven't gotten around to getting it finished.
I kind of want to smoosh together [ndarray](https://bluss.github.io/rust-ndarray/master/ndarray/index.html) and rulinalg. Both are good, but neither seems quite right to me at this point. ndarray is broader in its array support. It's also well-thought-out "under the hood," and has nice ties to things like Rayon. It seems like a solid start performance-wise, and I like some of its syntax. At the same time, I wish there was a native BLAS library that it included or linked to instead of C or Fortran BLAS. Doing so is pretty standard, but my guess is that Rust could hold its own against either if a native BLAS were available. Rulinalg is great also--it seems to focus on the flip side of the linear algebra need. I appreciate its focus on native Rust, and think it is on the right track in various respects. However, it doesn't seem optimized to me in the same way as ndarray, and it's either incomplete or missing documentation. Sometimes I think I should try to contribute to one or the other or both, but I've got so much on my plate at the moment, and want to feel more comfortable with Rust before I go contributing. 
- coverage support from out of the box - mature tool to manage dependicies, if features like: 1. hey you have different versions of one package in your first order dependicies, the same for second and more order of dependicies 2. something like cargo-add, but without rewriting Cargo.toml completly, it should only add line, plus it should add `extern crate` into `.rs`, and also tool to remove dependency 3. tool for optimizing dependency tree, like here another http lib, but it not requires 100500 dependency like http lib that you use - `#[test_setup]`, `#[test_unsetup]` - internationalization library that used by some big rust project, like servo or rustc, so it is ready for everybody else usage - xdelta/bdelta in rustup (loading nightly and all targets take a lot of time) - improved search engine on crates.io and some command line tool for searching in it
You should check what a subreddit is about, and not blind-post. You probably want /r/playrust.
Yeah, I remember learning similarly. However, do note that they're exactly as expensive as a virtual method call in C++, and those are syntactically indistinguishable from non-virtual method calls at use-site, so... I vaguely remember hearing about some intel optimization for function pointers because of the increased prevalence of vtables and C++.
I know it‚Äôs been *discussed* occasionally, but I didn‚Äôt think the language ever actually used square brackets. Citation?
A long time ago, it did: https://github.com/rust-lang/rust/commit/70b009178cf050d5bb78655ee46dfd8271f9eb79 and its parents through https://github.com/rust-lang/rust/commit/0107d6a81d2180d3a1e070e982e346038195cada was the series of patches that changed it. Maybe /u/erickt can give insight into why it was changed. You can see the change in the first few "frames" of http://brson.github.io/archaea/generic-type.html too.
This is a moot discussion at this point: Rust is too almost certainly too far along for syntax this fundamental to language without a deeper semantic benefit beyond being a little nicer for reading code. Maybe a coffeescript-esque dialect/compile-to-Rust language could do it along with whatever other clean-ups seem nice, but other than that, debating old, commonly-used, long-stable syntax seems uninteresting: syntax is generally both the easiest part of a language to change (implementing the change in the compiler), but also the hardest (updating all the source code in the world to match). The change would be particularly hard to sell because Rust is targeting a space with a lot of developers already used to `&lt;&gt;`, so switching spends Rust's "weirdness budget" on syntax, when semantics are the truly hard/interesting part of the language. As this very post attests to, syntax is something people end up [focusing on a lot](https://wiki.haskell.org/Wadler's_Law), and is of course their first impressions, so being vaguely familiar where it makes sense can help avoid repel people unnecessarily. Of course, what "makes sense" is very debatable, but most of Rust's other syntax differences to C/C++ have benefits that aren't just being nicer to read (if that even is one, of the feature in question).
&gt; (Currently, if you hack the stdlib and add such an impl to box, and then try to call it, it will fail to compile but not give you any recourse for disambiguation IIRC) I believe fully-qualified `MySmartPtr::foo(...)` vs. `T::foo(...)` calls handle this, although it is likely that one could never call `foo` with method syntax on a `MySmartPtr&lt;T&gt;`.
Hey! I got listed as a contributor! That's friggin neato! My contribution was probably the most important ^^^/s. I added a template for the issue tracker üòéüòéüòé
Ah, a long long *long* time ago. I‚Äôm going to go ahead and allege that that doesn‚Äôt count because it‚Äôs before even Rust 0.1. ‚ò∫
That would be possible if we were allowed to implement Fn for our own types, right?
I'm not so sure, I recall trying that, but I might have messed up (also this was like 2 years ago). So it might work. Dispatch on different kinds of self is tricky.
Im reading the guide right now and I gotta say, I really like your writing style. It is very easy to understand from an outsiders point of view. Keep it up! ( If I had the money I'd support you on patreon :( )
Is it _really_ so complicated that it would remove any notion of doing it this fashion?
That would also be in line with the general direction people want to take the reserved `become` keyword. (Basically, it would be an alternative to `return &lt;recursive call to self&gt;` that would mean "Either do tail call optimization or die with a compiler error if we can't") See: * https://github.com/rust-lang/rfcs/issues/271 * https://github.com/rust-lang/rfcs/pull/1888
Who are you???? I've never seen anyone type the '#' in C# correctly? lol haha. EDIT: Mine is wrong of course I don't know how to type correctly!
&gt; Why does it take so much work to set up the GPU? It has taken this much work for the past decade or so, it's just that last-generation graphics APIs all did this driver-side, leaving the programmer with no input unless they elected to use sometimes-unavailable API extensions. Providing the programmer with explicit control over everything the driver used to do automatically and inefficiently is one of the core tenets of Vulkan. &gt; What is this work actually doing? It gives you control over exactly what devices are used, by letting you know the relevant details of any graphics card or other vulkan-relevant compute unit on the system, and letting you choose what capabilities of what cards to use for the Vulkan pipeline you end up creating. Naive approaches that find the first available graphics card and use it still need to go through the process of actually finding it, hence the many lines of initialisation. &gt; Could I do it differently? What are the possibilities and tradeoffs? The possibilities are using another higher-level API to abstract away the specific details of the system, and have it manage everything for you. On this topic I want to mention something neat, and that's that the entirety of OpenGL can be built on top of Vulkan, and there are in fact efforts to do so with more efficiency than is currently available in drivers alone. It's important to remember that if you do not value the explicitness and power the Vulkan API gives you, you're probably better suited to sticking with OpenGL for the time being. Vulkan is always going to be more complicated. &gt; What benefits are there to actually learning and understanding this initialization? In a nutshell? Games can utilise multiple graphics card on a single system, including graphics cards from entirely different vendors. APUs and other mixed technologies can also be used. A game can squeeze every drop of performance out of your system by, say, using your Intel HD Graphics chip for rendering the relatively-cheap GUI and your beefy graphics card for all the big stuff. Vulkan was built off of the limitations of OpenGL, by an industry that was feeling the squeeze. It's the answer to every flaw the previous generation of graphics API had, and because of that, it's as low-level as it can possibly be without being vendor specific.
Isn't `.bash_aliases` just a convention? It's not a default that bash reads or looks for. Do some system bashrc files look for this on different OSes?
This is the very point of Vulkan. Be as close to the metal as possible while still providing abstraction over multiple vendors. If you want more abstraction use OpenGL or a game engine. 
I'd recommend you start with game engines instead of jumping immediatly into OpenGL, Direct3D or Vulkan. Game engines are a good place to explore the functionalities a graphics engine can bring you, like the different types of light sources, shadow mapping, skyboxes and other visual stuff. They also show how multiple video game related systems are incorporated together (usually through an ECS pattern or something similar). Learning about video game architecture is always good! Once you have decided you want to try your hand at the lower-level APIs directly, a good understanding of linear algebra and trigonomery is **mandatory**. Jamie King (on YouTube) has fantastic OpenGL and linear algebra tutorials, I can highly recommend him if you want to learn OpenGL and / or some math.
cairo/qpainter alternative. Aka 2d rendering library.
[You are both incorrect!](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/Treblecsharp5.svg/200px-Treblecsharp5.svg.png) But I totally agree, I prefer [] over &lt;&gt; as well, even though the latter is easier to type on my german keyboard layout.
Raw Vulkan is definitely not for beginners as there are hundreds of ways to shoot yourself in the foot. I probably said that vulkano wasn't for beginners either because there was no guide or tutorial or anything similar. The documentation supposes that you are familiar with the various concepts of graphics programming. However vulkano will never be a high-level library where you can just call `draw_sprite("foo.png", position)`. There are other libraries that do that and some people may want to use them instead. 
Sure! The repo is https://github.com/tomaka/vulkano-www
I am new to Rust and covered up to Method Syntax in "The Rust Programming Language Book". I tried implementing quicksort and heapsort and I have been struggling with 'usize' and 'isize' as we need usize to index but the algorithms use -ve values for terminating conditions or produce -ve values. How can I work around this? My code is here: https://gist.github.com/rudolphalmeida/96bd7f273eaafc51d936d7de77b637a9 and I have marked the doubtful lines with comments.
Putting the method on a trait means that the user needs to import the trait first, which turns out to be annoying in the long run.
+1 for mocking support. There are some nice crates but none of them are as easy to use and powerful as rspec (ruby) or nsubstitute (c#). Language-level support for mocking would be great advantage. Companies who use rust on production would benefit from it too.
pcwalton is working on Pathfinder 2 with full vector graphics support, and there is also https://github.com/nical/lyon and https://www.polydraw.com/ in development.
this is amazing! This is basically exactly how I learned to program back with QBasic and the QBasic IDE. Combine this with an ide with a list of 'what do you want to do? print to screen, to a printer, convert text into a number, download a webpage, etc etc etc' collection with examples and you will have recreated my childhood memories with my new favorite language.
^ and only this really.
Probably because Servo is bigger than the rest of your codebase combined?
nothing too much complicated but wrote something with rocket/serde/postgres/handlebars/bootstrap link: https://github.com/jaroslaw-weber/learn-korean-tools you can see working example at http://korean.jaroslawweber.com I really enjoyed the experience, it feels like flask with additional cool stuff like error handling and compiler time type check
start with something small (euler maybe) and compile early. use unwrap. after some time you will get the idea behind the language. and then you can start deleting unwraps from code and start enjoying rust.
Not sure about a framework built directly on top of Piston, but there is a game development framework called [ggez](https://github.com/ggez/ggez/blob/master/README.md) that I believe is intended to have a simpler API with more high level abstractions. /r/rust_gamedev would be a good place to look for more resources/libraries in general in the game dev space.
Good OAuth 2.0 server implementation could be useful for API development.
I've picked up my isomorphic rendering framework again, starting over with a new codebase. It's now called ismytope (pronounced isomorphic + asymtope). I'm using larlpop for rendering and a custom lexer based on the example given here last week, so thanks. Link is https://github.com/tmzt/ismytope
&gt; Right now it's essentially useful in eliminating a lot of the grunt work involved in porting Yeah that's essentially all I was thinking of too. My initial idea had been to hack something up with `haskell-src-exts`, outputting plain Rust source as strings directly (no intervening Rust AST), i.e. to not spend more effort on the conversion tool than it saves over doing the conversion by hand, before I'd heard about this project. But that doesn't solve the "maintenance problem"; what do you do when upstream `llvm-hs`, and/or upstream LLVM, see updates? (Probably not have time/energy to deal with it, in my case, putting us back at square one.)
I'm trying to work on https://github.com/Inner-Heaven/angel-whisper . Keep running into limitations that safety of rust puts me in. If someone can help me with handler trait that be nice. Any solution I came up ends up with too much boilerplate code.
For example, `access(2)`. (A function that's prone to being abused to accidentally create race conditions, but is the only way to safely check things like "I don't know my output filename yet, but I want to bail out early if I can't write to the target folder", given that filesystems with advanced permissions can be and have been configured to allow the creation but not deletion of a test file.) (I wrap `libc::access` in a `probably_writable` function in the codebase where I use it to make the race condition hazard as explicit as possible in the safe API.)
When it'll be out and have enough supporting.
And maintained by mozilla. So no worry about this.
&gt; Could any of this make sense as an extension to rusts existing semantics (without anything breaking), e.g. could you mark a type as 'pass-by reference by default' I don't think so. C# or Swift or Java have to make the distinction at the type level because the languages chose not to provide user-defined placement facilities, it's their alternative to choosing *when using the type* whether you want to allocate on the stack or the heap (note: they may also do escape analysis to stack-allocate a reference type, you as developer still get no control over it). Rust does not need this distinction because as in C++ the developer chooses at use-site whether they want to stack-allocate or heap-allocate, and if you want to force heap-allocation you can use a box type much like `Vec`[0] e.g. `struct Thing { data: Rc&lt;Inner&gt; }` there you go, reference type. [0] Vec is somewhat more complex, but you get the gist of it
There's actually discussion going on around whether `before_exec` represents a source of unsoundness in the language in its current state: https://github.com/rust-lang/rust/issues/39575
Point... though the one advantage JavaScript has is that it makes it easy to have [TiddlyWiki5](http://tiddlywiki.com/) as a single codebase. (TiddlyWiki5 added support for functioning as a more traditional SEO-friendly wiki using Node.js, but still also supports download into the self-contained "entire wiki in a single HTML file" format that TiddlyWiki classic pioneered, with the addition of a fallback change-saver that pops open a "Save As..." dialog if you don't have TiddlyFox installed... and, as a bonus, it's not strictly limited to being a wiki, being designed as a microkernel-based SPA framework where most of the code is stored within the wiki's data store so plugins are powerful and easy to install.)
What I expect from a basic matrix library is: - Pay for what you use. In Eigen you only pay for the types you use in, e.g., compile-times. - Generic: You can define Eigen vector/matrices/sparse matrices of dynamic or compile-time sizes, of dynamic sizes with compile-time bounds, with row or colum major order, and have them work with the rest of the library easily. You can also adapt your own types to work with the rest of Eigen, so it is very easy to incrementally adopt it in an existing project. - Efficient small matrices (vectors in Eigen are just 1xN matrices): that is, use optimal SIMD storage depending on vector size and target architecture. Use direct SIMD operations when manipulating matrices for simple things like addition of vectors, FMA, etc. They should also work inside CUDA kernels on the GPU. - Efficient large and sparse matrices. Different storage schemes. Offloading to GPUs. - Efficient tensors. - Kernel fusion: direct calls to BLAS/LINPACK are often slower than kernel fusion when it applies. - OpenGL compatibility: Eigen allows you to chose a layout compatible with OpenGL, glm, etc for interfacing with C. I actually don't expect anything else from a small matrix library. Building linear solvers, factorization algorithms, distributed memory, geometry, etc can be left to another library. Even offloading to accelerators can probably be left to another library. 
&gt; Sometimes I think I should try to contribute to one or the other or both Every time I think about doing this I realize that if we had type level values the library I would design would look completely different to what can be done now.
You can do this: use diesel::types::{FromSqlRow, SmallInt, Nullable}; use diesel::pg::Pg; use diesel::expression::AsExpression; use diesel::expression::helper_types::AsExprOf; use diesel::row::Row; use std; use enum_primitive::FromPrimitive; enum_from_primitive! { #[repr(C)] #[derive(Copy, Clone, PartialEq, Serialize)] pub enum UserRole { Admin, Customer, Driver, Client } } impl UserRole { #[inline(always)] fn as_expr(self) -&gt; i16 { self as i16 + 1 } #[inline(always)] fn from_expr(v: i16) -&gt; Option&lt;Self&gt; { UserRole::from_i16(v - 1) } } impl FromSqlRow&lt;SmallInt, Pg&gt; for UserRole { fn build_from_row&lt;R: Row&lt;Pg&gt;&gt;(row: &amp;mut R) -&gt; Result&lt;Self, Box&lt;std::error::Error + Send + Sync&gt;&gt; { let v: i16 = i16::build_from_row(row)?; match UserRole::from_expr(v) { Some(v) =&gt; Ok(v), None =&gt; Err(format!("invalid enum value: {}", v).into()) } } } impl&lt;'a&gt; AsExpression&lt;Nullable&lt;SmallInt&gt;&gt; for &amp;'a UserRole { type Expression = AsExprOf&lt;i16, Nullable&lt;SmallInt&gt;&gt;; fn as_expression(self) -&gt; Self::Expression { AsExpression::&lt;Nullable&lt;SmallInt&gt;&gt;::as_expression(self.as_expr()) } } impl&lt;'a&gt; AsExpression&lt;SmallInt&gt; for &amp;'a UserRole { type Expression = AsExprOf&lt;i16, SmallInt&gt;; fn as_expression(self) -&gt; Self::Expression { AsExpression::&lt;SmallInt&gt;::as_expression(self.as_expr()) } } And then you can add new cases to the enum as long as you increase the (hidden) tag number.
Rarely. The only issues I ran into are scripts that rely on `eval` to set up the environment, like `ssh-agent`. But it is possible to work around that.
You can just try it. I would probably not make it my login shell, but even then you could just run `bash` to get back if you need it.
Can you use raw SQL instead of a query builder yet? I.e, instead of: let results = posts.filter(published.eq(true)) .limit(5) .load::&lt;Post&gt;(&amp;connection) .expect("Error loading posts"); Can you do let results = posts.query("SELECT * FROM posts WHERE published = true LIMIT 5") .load::&lt;Post&gt;(&amp;connection) .expect("Error loading posts"); 
&gt; just using a bare integer or a varchar that could contain anything. You can always have a separate table that contains the possible values, with a foreign key into it. It's not exactly the same as an enum, but it's just as safe (in terms of making sure values are in the valid set) and it's more portable between DB engines.
I'm also interested in this. Can we write this up more formally like a RFC? So the parens would be overloaded as `Fn::call()`, `Index::index()` and `IndexMut::index_mut()`. `Fn::call()` returns by-value but `Index::index()` returns by-ref. How should the compiler disambiguate? Currently you can do `let value = v[index]` if value implements `Copy`. Or do you want to merge the Fn and Index traits somehow?
Will we ever be able to do that?
On the German keyboard, [] are definitely harder to type than &lt;&gt;.
It doesn't seem right to introduce your library by bashing another person's... I think you could improve your wording there to make it more friendly.
As someone who's done years and years of Java, i find Scala's use of square brackets for generics confusing. It is indeed just what you're used to. An idea that's been floating around for decades, and reinvented hundreds of times, is that languages could specify multiple textual syntaxes skinning a common underlying structural syntax. So, if you prefer square brackets, set your editor / post-checkout hook / Hurd translator to Scala mode. I'll set mine to Java mode. Maybe coder543 will set theirs to C++ mode, or COBOL mode, who knows what they're into. A bonus feature of this idea is that you can then choose a canonical syntax for representation on disk that sacrifices readability for ease of parsing, clean diffing, etc. 
Very cool! There's only so many features that can be safely jammed into `rustc`, which is expected to be awesome in several dimensions at once. It's definitely the _friendliest_ compiler I've worked with. Compilers speak meta-language (e.g. 'lifetime') and that's part of the learning process - learning the strange dialect of English that floats around Rust. I've thought of doing some postprocessing on `rustc` output, e.g. simplifying fully qualified types like `std::vec::Vec&lt;std::string::String&gt;` into `Vec&lt;String&gt;` wherever possible. 
Also https://github.com/bwasty/learn-opengl-rs
AFAIK there is none yet. It would be great if you could add it to reqwest :)
Hopefully it will be possible to add asynchronous support alongside the blocking API, with queries returning `Stream` objects. This would make it an additive change instead of a breaking change, making it more reasonable to release 1.0 without this support.
Is it a pattern? I thought it was a spring thing when I first saw it. 
Box is weird. Some effort has been put into making it look like any other generic container (Cell, Rc, etc), but it's clearly not. There's this, then there's the box keyword, and the idea that you might be able to destructure it in matches. I understand that [the compiler knows about boxes](https://doc.rust-lang.org/1.10.0/book/box-syntax-and-patterns.html#returning-pointers). If we can spread Box's superpowers to every type, then great, that would be amazing, and Box wouldn't be special any more. But if we can't, i think we've done ourselves a disservice by trying to pretend that this very special construct is just another struct. 
Most DAWs have poor tuning support so most synth VST developers don't even bother... I hope the situation changes in the future and opens more doors into unexplored territories. (I'm also working on software that allows people to experiment with different tunings.) What did you think of this album? [King Gizzard and the Lizard Wizard - Flying Microtonal Banana](https://www.youtube.com/watch?v=D0BsgJxw208)
It's a common choice for how to deal with that situation, if that's what you mean. I think "lookup table" is the usual term for it. I'm not aware of anything particularly spring-specific about it.
I cannot find any information about the supported databases. That should be the most prominent info for an orm!
I see, thanks (btw, I'm currently the only author of pleingres). Sounds like a good idea. I still believe that being asynchronous matters more for performance, but I might be wrong (I've not benchmarked that particular aspect).
No. It's not particularly interesting though, you just see a loop starting as many threads as there are cores on the machine, starting one event loop per thread, and spawning 4 different futures into that (HTTP, HTTPS, SSH, Postgres).
I agree that would be awesome. However, as I learned recently, it might be impossible because of how different conventions between OSes are.
`rust-protobuf` is stable, but it generates very anti-idiomatic Rust code.
The intro to the book says: &gt; This book is an compendium to a workshop exploring genetic programming. Genetic programming is [...] And in the appendix: &gt; I you are lucky enough to find yourself at a workshop, there are probably a few memory sticks lying around that contain the resources. Where is the workshop held? The phrasing of both statements makes me think that the workshop was held repeatedly/might be held again? Looking at the [linked github organization](https://github.com/darwins-challenge) it looks like the workshop definitely took place at [Rust Belt 2016](https://github.com/darwins-challenge/rust-belt-rust.2016), but possibly not since?
Without looking at your code, you have three canonical options: * use a (usize, bool) tuple instead * use an `Option&lt;usize&gt;` or `Result&lt;usize, usize&gt;` (depends on if your negative values carry information) or set up your own enum * use `isize` and live with the recurring casting and sign checks. It really depends on what you do.
I don't think this has any value in Rust. For me the distinction in C# or Swift is a necessary "evil" to circumvent the garbage collection. Something with such a sematic is needed to accomplish certain goals and this solution somehow has made its way and is maybe one of the bests. You will certainly see something similar in Java in the not so far future. But as i said ‚Äì for me ‚Äì it looks like an escape hatched to get value semantics in a garbage collected environment. Rust just has no need for this and other than that i don't see any value just by itself. In fact it can be a burden. You need a very clear vision of how you want your type to be used ‚Äì your implementation depends on it. But often ‚Äì at leas in my case ‚Äì i have no clear vision if i want to have a type on stack or heap. In Rust, C++ etc. you can switch very fast (just Box or new it) the implementation stays mostly the same. In Swift for example i had to rewrite most of the code that USED the type because i just want to switch from Heap to Stack (or vice versa) ... protocoll ... extensions ... you have to rethink your hole type. Something i don't really care in C++ or Rust. (Not so much experience in C#) So as i said ‚Äì i don't see a value in it by it self just as a tool to escape the garbage collection. 
Havev you tried Pandas for csv?
One of us mixed up the crate of the week ‚Äì the newsletter is showing last week's crate.
It's not impossible, just incredibly complex. WxWidget(native) and Qt(native like) achieved that for C++. SWT(native) and Swing(native like) achieved that for Java too.
Have you tried using Pandas for that?
I've got the async driver mostly implemented. The code is pretty messy though and needs a lot of work. I also need to figure out connection pooling, as our implementation is basically useless without connection pooling but there's no async connection pool that's useable for us. It's not a blocker for 1.0. The changes required are fully backwards compatible.
That actually is one of of the more important contributions. Things that enable work to be done faster have the largest impact.
[yes](http://docs.diesel.rs/diesel/expression/dsl/fn.sql.html) (We're working on a new raw SQL API that's more focused on full queries. It'll be in the 1.0 release)
PG, MySQL, SQLite
It's unlikely that we'll ever support them in the main crate, but the next release will have the groundwork required for them to be supported by a third party crate.
Didn't `Box` use to be its own special kind of pointer with its own symbol? What was the rationale behind making it look like another generic type?
I believe it's actually considered best practice, due to some limitations around adding new variants to enum columns (IIRC, you can't).
I fixed it. Thanks!
I found [contributing](https://github.com/nix-rust/nix/pull/629) into `nix` a pleasant experience. Don't fear submitting PRs! :)
&gt; Pandas Yes. It's a [standard NFA-style parser](https://github.com/pandas-dev/pandas/blob/97ad3fb9c87226ad983267e2891dbbf68432b8ea/pandas/_libs/src/parser/tokenizer.c#L736-L1102) that corresponds to old the csv Rust crate and also how Python's standard library `csv` module is implemented. I would be surprised to hear that pandas csv parser had different performance characteristics from Python's standard csv parser (other than pandas being slower, since it clearly supports a lot of features). In general, there's no real way a Python csv parser can be "fast." It doesn't matter that you write it in C. You still invariably need to build Python objects for every single field to pass back to the caller, which is quite expensive. The only way to do something fast would be to push your operation down into C that operates over CSV data in the aggregate without needing to construct Python objects for every single field. But by that point, you've kinda lost the benefit of using Python in the first place.
Hopefully the diesel team considers range types a 1.0 requirement. The time range types offer a great deal of functionality. I would contribute if I had the rust skills to do so. 
There was a push to make the language simpler and push some amount of complexity into the standard library before 1.0. Frankly, I agree with that - I've never been a fan of excessive use of sigils, and making built-in smart pointer types as similar as possible to user-created smart pointer types allows the latter to "feel correct".
If that can produce invalid values, why isn't it marked `unsafe`?
I reckon this is *the reason* the box keyword is unstable. The [placement new RFC](https://github.com/rust-lang/rfcs/blob/master/text/0809-box-and-in-for-stdlib.md) suggests it should work with other smart pointer types. I don't think it's reasonable to talk about unstable features as if they're part of the language - they're explicitly subject to significant change.
Diesel is a great lib in rust eco system. On minor feedback - It would be great if the docs show explicitly use of table! macro instead of just infer_schema! I was under impression that I must use have to use infer_schema to get all the goodies until I did a bit deeper search.
I would say it's the right thing to do when the set of variants isn't fixed for all time by its definition. The user roles in boscop's example look like a prime candidate for being a lookup table; i could imagine future developments in the business leading to Auditor, Dispatcher, BookingAgent, etc roles. On the other hand, if you are tracking comparisons of integers, an enum with values LESS_THAN, EQUAL, and GREATER_THAN seems like it is unlikely to ever need extension. 
Yes, there used to be `~` for boxed values and `@` for GCed values. I'm happy that they are both gone, because despite Box being a little bit special, it mostly follow the rules of all other types, especially Ownership rules, which I find much more apparent when using `Box&lt;Foo&gt;` instead of `&amp;Foo`. It has more similarity to other similar scenarios like `Arc&lt;Foo&gt;` then `~Foo` and `&amp;Foo`.
Tip of the week: Check out the crate of the week ‚ù§
Hack your keyboard. It's just a human-computer IO device.
&gt; Stabilize `sort_unstable` ü§î
I'm split on the issue. I'm inclined to think that anything that behaves in special ways and gets special treatment from the compiler should have a noticeably different syntax. Unless the end-goal is to completely remove the specificity of this type down the road.
Its also not possible. Setting aside that it implies ABI stability (a huge project), any solution which involves "fixing the Error problem" would break coherence, this is a fundamental problem.
C++ standards are not completely backwards compatible; in fact they're part of the model for the epoch approach.
Diesel isn't 1.0 yet, but should be pretty soon.
The library inconsistencies briefly referenced in that article is one of the things that I find mildly frustrating about the crates ecosystem. Often when I need to bind to a library written in C (eg when I targeted [wlc] (https://github.com/Cloudef/wlc)) , or another language (eg Lua) I find either nothing (which prompts one to write their own, [like I did for wlc](https://github.com/way-cooler/rust-wlc)) or you find many competing implementations, often very different in terms of capabilities (eg [here is the crates.io search for Lua](https://crates.io/search?q=Lua)). I wish that libraries would either try to work together more often or point to other, possibly better alternatives (which I do for rust-wlc, wlc.rs is a *much* better wrapper than mine). This is not always possible, but the lack of consolidation for more fringe libraries often forces difficult decisions (do I use this potentially incomplete implementation? Should I strike out on my own to make my own and just add to the problem?). Ultimately this is a social problem more than a technical one. However I think that we should look into making crates.io, and the general library discoverability process, easier to connect developers of libraries to better collaborate, indicate how complete bindings are, and mark when libraries are no longer maintained (and should no longer be used by new projects). This problem is obviously not endemic to Rust, but does seem more common due to its immaturity. But due to that immaturity, I think we are better posed to fix it. 
Love seeing Rust used in the context that C is usually used in. Speed, without the cost of safety, for use in apps mostly using higher level languages is a place where I think Rust is currently doing very well in. 
Box doesn't get special treatment from the compiler at present, aside from the issue in OP's post, where multiple core devs have suggested it will not be special forever. `box` syntax is unstable, and likely to be for the foreseeable future.
It appears to return a Result, letting you handle the case where the returned value was not deserializable into the type you specified. Thus, it is safe.
Parentheses could not be used for indexing because any type might implement the closure traits, so it'd conflict with that. There is nothing that means `Box&lt;Fn()&gt;` can't contain some arbitrary type `T` which also implements the indexing traits.
I follow Diesel, so I know which DBs it supports, but... I agree with /u/cars10k. Quickly poking around the website, the GitHub page, and the docs, there's no clear listing of which DBs are supported. The only place it is "obviously" listed is [the examples folder](https://github.com/diesel-rs/diesel/tree/master/examples). Maybe adding a note to a few different places wouldn't be such a bad idea.
I think it's easier to just use the Diesel CLI tool's print-schema command, which will print out all of the `table!` macros and stuff for your application, which you can then copy and paste into a file, for projects where you prefer for the build process to not make a connection to a database every time.
Curious, what does diesel hitting 1.0 mean for your project? If the current version works fine, couldnt you ship if you're otherwise ready? :)
GDAL, geospatial stuff. Yes, there are bindings, but they're not well maintained. proj4 equivalent (coordinate conversion) A good MVC framework like Laravel, but for Rust with easier deployment
The inconsistent capitalization of your SQL is giving me agita‚Ä¶
I'm sorry about that! Edited...
Personally, I disagree. I've been using C++ and Java at work for over a decade, and yet I find square brackets more readable. It's one of the many things I like about Scala syntax. Angle brackets have two problems: firstly, they are overloaded, sometimes those symbols are brackets, other times they're binary operators. Secondly, the square bracket font is slimmer and taller, it stands out more and highlight the contained block, whereas `&lt;&gt;` tend to blend together with the surrounding text.
Interesting, but it would be nicer if it just stored everything in git or hg.
When you shadow a variable but change the type, what's an EL15 on how it handles it on the stack? I'm learning about memory management but if you had: let x = 123123456; let x = x.to_string(); And say x initially occupied a 32 bit single address; when the shadowing was done, would x be realloacted to a seperate free address on the stack and the old x be freed up (I'm making the assumption the string might not be able to occupy a single u32 here)? 
Isn't this just in general a problem with method syntax? If `Vec::len` didn't exist then `Vec::new().len()` would just call the one on slices so in theory without a major upvate in SemVer breaking behaviour can be introduced via this which I never much liked.
What I don't get however is that `*const _` and `*mut _` are still getting special syntax. Surely those are even less special than `Box&lt;_&gt;`,as far as I know not special at all?
it looks a like it will take effort to learn diesel's API but it also looks very appealing since it integrates with rust rather than just shooting SQL strings around, so i'll give that a try. thanks
The simple answer is no. The Swift dev have looked at this, and they're [adding new keywords to the language](https://gist.github.com/Gankro/1f79fbf2a9776302a9d4c8c0097cc40e), in addition to struct/class, so as to enable Rust-style ownership rules. They can't do it with struct/class alone. It's a bit off-topic, but this struct/class thing is actually a pretty old idea. The Object-Pascal variant, Delphi, introduced it in the 90s -- largely for interop with C code, hence `struct` -- then its lead developer was hired by Microsoft and he developed C# -- initially a Delphi/Java combination -- that copied the idea. The syntax and semantics of C#'s in turn went on to inspire the designers of Vala and Swift. As others have mentioned, it's an _alternative_, rather than a complement, to Rust's approach. In Delphi/C#/Swift/Vala you must decide that _all_ instances of a type are stack* allocated, whereas in Rust you can do it per instance. ---- * Just to add, in C#, and I think Swift too, a struct is not necessarily stack allocated. Declaring something is a struct formally means simply that it has copy-semantics; it's up the compiler's optimiser to see should it be stack allocated.
`lyon` isn't exactly a 2d rendering library but is a key part of one. I've also seen a crate that users webrender for GUI rendering.
There is no promise they will occupy the same space on the stack. A binding is just a name, shadowing just binds the name to a (maybe) different place on the stack. The answer depends on the specific case and (I assume) optimization level
`ggez` has some basic functionality for mucking about with bitmap fonts. It's probably not directly applicable but might be useful for you to steal some of the guts out of.
How do cgmath, nalgebra, or euclid stack up? They're mostly designed for computer games/graphics work cases, but I'm curious what they're missing compared to something like Eigen.
What's the issue with `sort_unstable`?
Yet being very difficult to read(for someone who ocasionally trying to grok some code), because of overuse of non-alphanumeric combinators everywhere. 
TIL about [SliceExt](https://doc.rust-lang.org/core/slice/trait.SliceExt.html). Why aren't those methods implemented on slice directly?
`*const` and `*mut` are certainly more special, as dereferencing them requires unsafety and (normal) types in Rust don't carry information of being unsafe in themselves. They also drop differently, Box _owns_ it's contents (and subsequently drops it, following standard ownership rules), raw pointers just get removed from memory. Raw pointers are _very_ special in Rust, semantic-wise.
Just read `cargo install --vers` for the first time, seems like an unusual abbreviation. Is it too late to just make it `--version`?
There's no issue, it's just funny that the unstable sort is now stable. (Obviously it's a different kind of stability)
Why? Just have a function `unsafe Ptr::&lt;T&gt;::get(self) -&gt; T` and `unsafe PtrMut::&lt;T&gt;::set(self, T)` Dereferencing references can't be done with an ordinary function because of ownership semantics but with raw pointers it can.
I think your list should be enshrined as a set of Rust matrix/linear algebra goals. I wouldn't expect quite as much, although I think they're a good target. The only way in which I might differ from what you mentioned is that I would like to see factorizations also. 
Indeed, if `[]` were used for generics, I'd prefer them to not be used for indexing or for array declarations. Scala uses `()` for indexing, Eiffel `@`, and Ceylon's array declarations are similar to tuples. So, with enough bikeshedding, a solution could be found. But I'll leave it to future language designers. As for fonts, I usually use what comes with Ubuntu, and they don't do a great job at displaying `&lt;&gt;` like brackets. Do you have any recommendation?
`unsafe` is only about memory safety
I believe it's a coherency issue. The slice type is defined in the `core` crate, while the functions in SliceExt rely on implementations in `std`. It is not allowed to implement functions on types defined in other crates, so you get extension traits like this. edit: I'm wrong see below.
I agree. Feel free to open a PR if you have a place that you think it'd fit (the website repo is https://github.com/sgrif/diesel.rs-website)
nearlyfreespeech.net is also a good choice.
They are. All SliceExt methods are natively implemented in slices. Also, the trait itself is unstable. I think it was an attempt to allow generic code over slices and will be deprecated at some point.
I'm mostly just curious to hear people's thoughts. I'm also wondering how I *would* make the Rust faster than the Haskell, since I assume it's possible with sufficiently complex code.
Perhaps I've misunderstood but the whole proposal seems to be about breaking changes; it specifically calls out adding keywords as an example of a breaking change. It seems that code written for "Rust 2015" won't necessarily compile under "Rust 2018", i.e. "Rust 2018" introduces breaking changes. It seems like the actual point of the proposal is to begin versioning the language separately from the toolset, but it goes about this suggestion in a rather roundabout way and introduces a lot of unfamiliar terminology to do it. Why not just have rustc v1.56.3 able to compile Rust (the language) v1.x.x, v2.x.x, etc. The epoch system seems to give up the granularity found in semantic versioning and group a lot of changes together making it more difficult to upgrade a version.
I've only looked into nalgebra. I'm not really familiar with game and graphics programming, but for scientific computing the biggest issue that jumped out to me at first is limited sizes of the arrays being dealt with. I kinda tuned out after that, only because it was clear that that it was designed for a different purpose than what I need a linear algebra library for. I think of nalgebra as a game/graphics library first and foremost. 
Mostly vacation, but a little bit of work on [`uom`](https://github.com/iliekturtles/uom) (type-safe zero-cost dimensional analysis) where I'm working out how to implement conversions for thermodynamic temperature.
 impl JokeDetection for shadow31 { ... } :)
What I missed in `bash` is shared history on line, in bash you need close shell, and then new running instance see command history. shell with daemon that take care about history sharing would be great.
 error[E0277]: the trait bound `shadow31: Caffeinated` is not satisfied Sorry, I haven't had my coffee yet. 
So "invalid" in this case doesn't mean "possibly unsafe"? I was thinking if you return into a `str` from something like a bigint you could end up with invalid utf8 characters (which is defined as unsafe). Also, the way I see it, `unsafe` isn't necessarily _only_ about memory safety, it's just to allow functions to make assumptions about data that they would otherwise have to incur runtime penalties to check. Normally this is about transitively causing memory unsafety, but not necessarily.
The problem is that you make a copy of every substring, which isn't needed. If you use the following instead: let mut vec = Vec::new(); for (j, _) in s.char_indices().skip(1) { vec.push(&amp;s[j..]); } vec The code should be significantly faster. Full example: https://is.gd/XeuVgA --- **Edit:** Nevermind, apparently I skipped a significant detail: &gt; note that it must return a vector of owned Strings so as to be comparable to the Haskell.
You should also be able to pre-allocate the Vec, given the final length is entirely predictable. But to *really* be comparable to the Haskell, it should probably be written as an iterator.
I'm not sure if any meaningful conclusion can be reached from benchmarks which are dealing with such a small amount of data, and doing so little actual processing. However, here is some pure speculation on what might be happening: - Execution time is entirely dominated by time spent in the allocator (allocating the strings and resizing the vec) - Haskell is faster at allocation because it has a GC, and so allocation can be as simple as bumping a pointer. - On small inputs, the Haskell benchmark is misleading, because the GC doesn't run even once, so the overhead is not included, and so you're only seeing the positive side of the GC/manual memory management trade-off (faster allocation).
I'm not an expert, but I had a few thoughts. &gt; note that it must return a vector of owned Strings so as to be comparable to the Haskell. Ok, so the goal is for the 2 programs to do the exact same thing, even though something faster could be written in rust, right? * The rust program does not handle unicode in the same way at all. Haskell Chars are unicode code points, which probably means that they are 32 bits each, right? Rust strings are always valid utf8. This means that char_indices() is actually decoding utf8 to find character boundaries, while the Haskell program does not. * s[j..] is taking a byte offset into the utf8 buffer. My understanding is that this panics if the byte offset does not align with unicode code point boundaries. This requires even more utf8 processing. I'm not sure if the possible panics slow anything down or not. * The rust program allocates new strings while the Haskell program uses a garbage collector. My understanding is that allocation with garbage collectors can be super cheap.
This code actually still takes 99.0 ns for the smallest input, which is still slower than the Haskell (for inputs of size 20, the Rust is faster to return a `Vec&lt;&amp;str&gt;`). More to the point, I'm not sure this is a fair benchmark since the Haskell function does in fact "own" its result, whereas the function you point out does not. I'm not 100% sure how to make a fair comparison, since the code you posted above is indeed the more idiomatic code, but it's not strictly equivalent. You could in fact use the result of `suffix` in Haskell as many times as you wanted, e.g. you could append "-tail" to every suffix. That would not be possible with a `Vec&lt;&amp;str&gt;`. Anyway, that's why I think a `Vec&lt;String&gt;` is closer to equivalent. 
We do already. `Box&lt;T&gt;`/`Arc&lt;T&gt;`/`Rc&lt;T&gt;`. It's implemented as a library instead of being part of the language. (Technically `Box` is a magic language feature but that won't be true forever).
It has bare bones FS operations, but it works. I haven't heard from anyone, so it currently has just the pieces I need. It can be grown. What's your concerns about it?
No idea, and the book seems to be cut off at page 31 (and then continues with the appendix).
I see, that makes sense.
What I'm talking about are conventions. It's not just the texture of e.g. a button but also how things are positioned on screen. One interesting example is macOS using sheets - thing that doesn't even exist on other OSes.
&gt; (Technically Box is a magic language feature but that won't be true forever). Interesting (residual behaviour from the original ```~T``` I guess.. which I do actually miss, e.g. ```enum Foo { SmallVariant(a,b), LargeVariant(a,b,~(c,d,e,f)) /* avoid padding*/)}``` ... the original syntax did 'melt away' in the common cases; it would have been interesting if that could have been further generalized by some sort of 'sigil overload' if that was deemed 'too magic'. people complained about 'multiple pointer types' but thats unavoidable when we need this control. I should check on the details of how general rust smartpointers can be these days, i should look at the 'placement stuff' aswell 
Right, I wasn't sure if it was 1.0 but I remember it not being idiomatic rust (not based on personal use but from others in the community).
deleted ^^^^^^^^^^^^^^^^0.3609 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/06161)
Right, it shouldn't ever cause memory unsafety (I'll actually need to double check the string case, that's a good point). &gt; Also, the way I see it, unsafe isn't necessarily only about memory safety The function was originally marked `unsafe`, until I was scolded by the core team because `unsafe` is really really only about memory unsafety.
&gt; Anyway, that's why I think a Vec&lt;String&gt; is closer to equivalent. First of all, thank you for the writeup, this is an interesting case to consider! I would not agree. Given Haskells semantics, probably returning a Cow would be closer. Your benchmark copies under the assumption that any of those substrings could be modified, while Haskell would copy on actual use, leading to the impression that the data is editable. I checked out your source and tried on my machine: Blog Version: pub fn suffix_vec(s: &amp;str) -&gt; Vec&lt;String&gt; { let mut vec = Vec::new(); for (j, _) in s.char_indices().skip(1) { vec.push((&amp;s[j..]).to_string()); } vec } Results: test test::bench_suffix ... bench: 291 ns/iter (+/- 58) test test::bench_suffix_extra_long ... bench: 726,637 ns/iter (+/- 151,809) test test::bench_suffix_long ... bench: 16,116 ns/iter (+/- 2,846) Using Cows: pub fn suffix_vec(s: &amp;str) -&gt; Vec&lt;Cow&lt;str&gt;&gt; { s.char_indices().skip(1).map(|(j,_)| { Cow::from(&amp;s[j..]) }).collect::&lt;Vec&lt;_&gt;&gt;() } Results: test test::bench_suffix ... bench: 142 ns/iter (+/- 15) test test::bench_suffix_extra_long ... bench: 19,306 ns/iter (+/- 3,248) test test::bench_suffix_long ... bench: 1,674 ns/iter (+/- 282) Note that while this is not 100% the same thing convenience-wise (as the allocation of the string will not always happen transparently), its probably the closest to Haskells lazy behavior.
&gt; It seems that code written for "Rust 2015" won't necessarily compile under "Rust 2018", i.e. "Rust 2018" introduces breaking changes. Sure, but you won't get automatically upgraded from 2015 to 2018 unless you go in and change it; your code will never break out from under you. That's the key part. &gt; Why not just have rustc v1.56.3 able to compile Rust (the language) v1.x.x, v2.x.x, etc. Because "Rust 2.x.x" is very different from what this proposal suggests; it would allow *any* kinds of change, whereas this allows for very very minor kinds of change; it also communicates that to others. The kinds of changes we're talking about here are in line with other languages that are considered hyper-stable, like Java and C++; they also both have extremely minor breaking changes, but do not increment their major version. Well, Java anyway, C++ doesn't use anything but years. &gt; The epoch system seems to give up the granularity found in semantic versionin Is adding a new flag to a program a semver-major change to you? Because that's effectively what this is proposing.
I don't understand why the Haskell code is quadratic. If you want all suffixes of a linked list, isn't this just one list traversal (cloning each pointer as the head of a new list as you go)? I'm pretty sure that if someone asked for all suffixes of a chain of `Rc`d pointers, it would (i) be one pass, and (ii) probably less silly than either of the approaches presented.
I expect that the strings yielded by haskell are are aliased immutable pointers, not full copies, so I think `&amp;str` is a much more accurate comparison. If you were to append -tail to every string in haskell, you'd have to pay the cost of copying the strings during the append - this is largely the same as converting the `&amp;str` into an owned `String` at append time. Of course this is just a guess, and I'd encourage you to try appending to the resulting strings in rust &amp; haskell to see if the benchmark matches the theory. 
&gt; **Edit:** Nevermind, apparently I skipped a significant detail: &gt; &gt; note that it must return a vector of owned Strings so as to be comparable to the Haskell. No, it's a wrong significant detail. Haskell Strings don't work like Rust owned Strings.
What's being kept private? I always thought the URL was sent unencrypted, and I'm not sure what else you would send to a static site. 
Are you sure? The trait is defined and implemented in core and it doesn't seem to require any std featur
You're right, I was thinking of SliceConcatExt, which does have this issue. Not sure what the thing with SliceExt is then.
Thanks!
Anywhere I need a mock, I switch to traits and generics, with tests implementing a mock version of the trait. I haven't missed mock libraries when following this tactic.
It could certainly be added as an alias. Maybe it was considered to be too similar to `cargo --version`?
Can I say "`Option` is a monad"? (if I want to pretend to be smart)
I made two different Rust versions that should be faster than your Haskell version: - One is an improvement on suffix_vec_ref that just avoids iterating over the UTF-8 prefix every time, which Haskell doesn't do. This is I think the most comparable to Haskell - One that is analogous to Haskell in its signature, everything returned is a lazy iterator, but not analogous in what the benchmark does provided the Haskell `nf` function instantiates things in memory. My benchmark of it just loops in memory using test::black_box. See https://gist.github.com/trishume/aca4083cdbf237f04709633dbe55b643 where I posted my code and results. My computer appears to be faster but if I assume your computer is linearly slower than mine, based on the timings you gave my suffix_vec_ref should run in 59ns on your computer, faster than Haskell. And my full lazy one should run on 28ns on your computer.
I am not that familiar w/ WebKit internals, but w/ Chromium, they had `--single-process` but it has since languished because it was unsupported. Does the WebKit team commit to having the single-process model always work? Sadly, I fear it's the only modern browser left that may have good single process support. I hope they don't change their mind like everyone else.
You could go the QML route and ship components that look like native widgets. 
If there was a GCC-based Rust compiler (with its own version numbering scheme) then it would be very obvious that for it to evolve in parallel with rustc as Rust syntax evolves, then Rust-the-language would need a versioning scheme decoupled from the rustc release versions, and a well-defined way to distinguish *.rs files based on which language version they implement. Thinking about things in this context makes me favor the proposal better. With that said, once Rust-the-language gets its own separate version label, then every rustc release is going to have to indicate which language versions it supports, and bumping rustc's major version wouldn't necessarily imply anything.
Some background on me: I'm the sole author of the open source Nitro game engine (written in Rust). I started my project because I felt that other game engine projects didn't have the same priorities as me. I felt they pursued a lot of what I considered to be non-goals. Later on I started to run head first into the architectural problems of the system I had created. I wanted to do a rewrite. After designing my rewrite conceptually I realized that my idea was basically exactly what the Amethyst game engine was already doing, so I decided to join forces with them. I had looked at Amethyst before starting Nitro but at that time I decided to not work with it because I misunderstood what their goals were. The term data-oriented was used which initially put me off because it just sounded like a roundabout way of making a game. What was actually meant by data oriented I've discovered is that the engine is highly asset driven. This actually turns out to be a very user friendly and robust way of making games. So I think what we're seeing here in the Rust ecosystem today probably comes from insufficient outreach. I believe we require strong project leaders that are willing to take up the mantle of facilitating communication and work. To me this means IRC and Gitter links should be available for the project and prominently displayed in any space they can be. Ultimately this is going to require us to be less shy than many programmers may be accustomed to. Even when communication does exist sometimes the exact meaning trying to be conveyed doesn't quite make it. More noob friendly README.md files would help in this regard. One such example being that if you're introducing a new term I.e. "data-oriented" then go into detail on precisely what that means and how it impacts architecture. Community building is also important because let's face it, we're fickle. Others need to be able to take the torch when we have to or want to leave our projects. Make sure proper handoff is in place. TL;DR More organization repos, less personal repos. Prioritize community building, start by making Gitter and IRC links available everywhere you can. Good software projects are about more than good code.
Matrix factorization algorithms are a bit higher level than matrix storage and primitive matrix operations, so I put them with linear solvers of equations as something to build on top.
The sibling comments are close but not quite right: for coherence, only one crate is allowed to implement inherent (non-trait) methods on a type, usually this is the crate that defines the type but for built-in types there's no such crate and so instead one can nominate one. Since `std` is used most commonly, it was chosen, so that all the methods on slices can be inherent, even ones that allocate/need other functionality from `std`. However, `core` should be as compatible with `std` as possible, which means having the okay-for-bare-metal methods available on slices. Since they can't be inherent the only way to do it is via an "extension trait", `SliceExt`.
I think you're more optimistic than me wrt said marketing; most people have an idea of what "2.0" means, and aren't going to bother to investigate how it's any different.
You can go cheaper (roughly an order of magnitude) by not being in the Economically Wasteful Valley (or similar areas). 
&gt; The rust program allocates new strings while the Haskell program uses a garbage collector. My understanding is that allocation with garbage collectors can be super cheap. jemalloc uses many of the same optimizations that make this cheap, I'd be surprised if there was that much of a difference here.
Well, like I said, it's really a familiarity thing. Rust has tons of non-alphanumeric stuff everywhere. ` fn fit(&amp;mut self, X: T, y: &amp;Array) -&gt; Result&lt;(), &amp;'static str&gt;;` is a nice example of "perfectly readable once you understand wtf everything in there is doing." (In stereotypical haskell fashion, I spend way too much time below answering a likely rhetorical question you probably didn't ask--only to realize after I answered that you probably didn't care all that much) ---- That being said, in 90% of the code you'll ever see, the only combinators are: &lt;\*&gt;, &lt;$&gt;, $, and `.` which, to me, feels like much less of a learning curve than all of the syntax Rust uses (especially since all of them are optional) * The first two are infix abbreviations of *very* commonly used functions (which are more like default methods of a certain Impl than "functions"). &lt;$&gt; is infix `map`, and &lt;*&gt; can be thought of as an infix `apply` (modulo some mild hand-waving because I don't think there's a similar Rust equivalent to reference) * The $ is just the pipe-forward operator (seen in Scala, F#, etc) with an unfortunate symbol chosen. * The period is function composition and is analogously equivalent to unix pipes. The rest of the weird symbols are usually from `lens` packages and, to be honest, I don't really like those symbols either. Most of the time, they're used wisely and you can grasp them from context once you know what the function is doing. Other times, they're used to make perl 2.0. Thankfully, it's pretty rare to see them being abused. Well written code in Haskell should, ideally, be extremely readable; hopefully, even more-so than most languages since there's not a lot of anything getting in the way of what you're writing out.
I'm curious, what would you be looking for in a wiki server? I recently began using ZimWiki as a personal wiki, and while I'm not sure I like it, I was thinking of making something similar as a personal project for practicing Rust. I saw you mentioned git/hg and since ZimWiki uses a flavor of markdown, it can be merged easily.
TiddlyWiki began as a way to carry a wiki around on a thumbdrive and it plays well with version control. (I have a TiddlyWiki classic instance that I use as a bin of fanfiction ideas on GitHub Pages and it versions beautifully.) TW5 basically adds support for breaking out the internal pages into separate files and serving them up with proper URLs via a Node.js server. It shouldn't be too difficult to add a hook which causes it to do a git commit whenever you click the Save button.
Oh, that wasn't the issue I was thinking of. There are a million similar ways to break semver which are "allowed", basically stuff that breaks inference and stuff is okay. I thought you can't UFCS disambiguate between the two. But it turns out that you can.
&gt; note that it must return a vector of owned Strings so as to be comparable to the Haskell. This is basically cheating; this is forcing Rust to incur Haskell performance deficits while this isn't idiomatic rust. The Rustic idiom in fact could be: suffixes ( s : &amp;'a str ) -&gt; Suffixes&lt;'a&gt;; where Suffixes&lt;'a&gt; : Iterator&lt;Item=&amp;'a str&gt; Not even a vector; one may indeed argue that this is closer to the Haskell semantics because Haskell (well GHC anyway, yadiyadi nonstrict is not the same as lazy) lists like iterators are of course lazy so if you only want the first suffix it won't compute the rest just like with an Iterator. Furthermore you can indeed count on the Haskell implementation ensuring that memory is shared between all the tails in the Haskell code. Having said that this is however all this completely noncomparable. Haskell Strings are just lists of Chars which are implemented almost always as 32-bit. They are singly-linked lists and under the surface in GHC it gets even worse because everything is lazy they are lists of thunks which upon the first computation get replaced with their actual value so what the thing returned is in memory depends on how much of it is already computed. Rust strings are three words and a bunch of continuous memory on the heap that stores utf8 data and a `&amp;str` is just pointer to he heap and another usize for the length of such continuous utf8 data so what is done here oes not compare at all. The benchmark really cherry picks it; at some point it uses idiomatic Rust and opts for `&amp;str` rather than first defining `LazyList&lt;char&gt;` which features elaborate suspended computations but then it claims basically as a way to cheat the benchmark that the strings must be owned to be faithful to the Haskell version. Edit: I'm bored, here's my take on the iterator: https://is.gd/AGefcq 
&gt; The epoch system seems to give up the granularity found in semantic versioning and group a lot of changes together making it more difficult to upgrade a version. You're misunderstanding the proposal. If you download rustc 1.30, say, and run it on epoch 2015, it will still have most if not all of the features on the latest epoch. You could stay on epoch 2015 forever and still continue to get new features. Epoches make it easier to talk about the existence of features in documentation, and they make it easier to execute _parser-level_ breaking changes. Semver still exists. We're still probably never going to 2.0. You still can upgrade the compiler.
Correct.
It was. See also: http://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/ Back then we had "owned pointer" (`~T`), "borrowed pointer" (`&amp;T`), and "managed pointer" (`@T`). `~` was also used for String and Vec (`~str`, `~[T]`). This was kind of confusing; especially since `~` implied "owned", but for example `~"foo"` did not make an "owned string", it made the abomination `~&amp;str`. It was kind of confusing and pretty unnecessary overall. There also was a lot of unnecessary boxing because folks thought that was how you got ownership. Now `Box&lt;T&gt;` is a pretty rare type, used for trait objects (a rarely used but necessary feature), recursive types (also pretty rare), and for sticking really large things on the heap (also pretty rare). Rust smart pointers and wrappers are about choosing the semantics you want, and Box doesn't really get you many new semantics, unlike Vec or Arc or Rc. So in hindsight it was pretty good that we dropped the sigil. I think at the time the main justification was that it made Rust code look pretty ugly and was confusing to newcomers.
Yes but it also means you're packaging a several hundred meg codebase with your dozen meg app. This is my people hate on Electron.
I'm not sure to understand what you mean. I switched to a model similar to the one of Chromium (well, more similar to the one of the latest Firefox, that is with a limited number of web processes). Before that, I had one UI process per web process, but that was causing issues with the cookies not transferred between the different processes. By the way, I was able to make this thing work, with a huge hack, thought, to workaround a bug.
I got a good way through writing an editor like this for Java, some years ago, rendering straight from the AST according to the user's chosen style. The editor knew Java syntax, and was designed to have a one-key context-sensitive entry system for whole syntax structures (not far from ZX Spectrum single-key keywords, but extended a lot further). I had it all worked out. However there's been no time since then, due to work. But I'd love to try again sometime in Rust. Perhaps try Lua or Go syntax first, before going completely mad with the complexity of Rust syntax. Finding a good AST representation for the editor is important.
Well, webrender and lyon are great examples: - https://github.com/servo/webrender/wiki - https://air.mozilla.org/bay-area-rust-meetup-february-2016/ - https://github.com/nical/lyon/wiki I'm not saying it's *too* complicated, but yet it *is* more complicated. And requires a different approaches to do things. 
Distributed compilation via Incredibuild or SN/DBS, both proprietary solutions but both commonly used in game studios. It may be possible to hook cargo up to both of them right now but I just don't know enough about how cargo works to say.
In some senses, but it doesn't go as far; IIRC, allocation in hotspot is something like 5 instructions? I'm not as familiar with GHC's GC though.
&gt; We plan to enable async/await notation on the nightly Rust channel by the end of the year and position it for stabilization in early 2018. Yay! Also, are there publicly available estimates for the other features?
All right, good to know! I still would rather use Rust than node.js though. ;-)
You *can* do it now. https://stackoverflow.com/a/38673864/2977291
Sorry about that. But using fixed `Step` instead of having a data type for intervals is a really bad design choice. Also my writing was a little bit inspired by ‚Äú[What's wrong with Java Date &amp; Time API?](https://stackoverflow.com/questions/1969442/whats-wrong-with-java-date-time-api)‚Äù and ‚Äú[Working with Time is Easy](https://www.youtube.com/watch?v=saeKBuPewcU)‚Äù. 
Thank you!
The closest is that the lang team expects to have const generics "in nightly by the end of the year". We generally don't give estimates, as they are often wildly incorrect, in all directions :)
Say "`Option&lt;T&gt;` is an instance of a monad" instead, IMHO. Though usually what you said is close enough.
Of course, component themselves might look perfectly native. Yet, the whole product might look weird. (BTW in my work we're currently rewriting old macOS application with windows-like look into something that would look more native.)
The problem is that unlike in more algebraic languages, Rust structs can have non-trivial destuctors. For instance, how do you optimise the tail call out of [this function](http://play.integer32.com/?gist=f37c291db83321301c33d3f9d3338ae3&amp;version=stable)? Rust doesn't have any equivalent of `alloca`, so there doesn't seem to be anything you can transform it into that's semantically equivalent without all the function call stack overhead. 
https://internals.rust-lang.org/t/rust-release-milestone-predictions/4591 ^ If you find this page useful, bookmark it. It's almost impossible to find again!
Well, I don't see how to make a good piano roll for *every* tuning (except being able to change 7-5 pattern to anything else, like in Reaper). (I'm going to make one for 31EDO though) 
Not OP, but I believe some schools of thought (I thought it was in semver, but I skimmed through it and couldn't find it) say that your library isn't 1.0.0 ready unless all of your dependencies* are also &gt;=1.0.0 but obviously that's really difficult to do this early on since the crate ecosystem is still maturing
AFAIK only hostname is sent unencrypted.
Someone could theoretically modify the examples in the page and if some noob runs it it'd exploit their system. (I'm **not** saying this is probable!)
Ironically, Diesel will be going 1.0 before our dependencies do. Haven't decided exactly what we're going to do there.
I'm considering deprecating `infer_schema!` entirely in favor of `diesel print-schema`
I thought we already supported range types? I distinctly recall discussing a PR about them EDIT: [Nope.](https://github.com/diesel-rs/diesel/issues/676) Anyway, no it is not something that will block the 1.0 release. That doesn't mean that we won't add them, just that it's not a requirement for API stabilization, as they can be implemented fully backwards compatibly
Whoops. Sorry, my bad.
I don't see how that would make sense, given that square brackets denote arrays, not generics.
Just a heads up, but we are about to integrate appdirs with Ion, so the configuration file will be located in the correct xdg configuration directory, instead of dumping a file in $HOME. This will be important for future support for loading dynamic libraries as plugins to Ion too.
&gt; I'm not 100% sure how to make a fair comparison The only reasonable comparison I can imagine is trying to optimize both as much as you can and then compare the results. Even if that would mean using `Vec&lt;&amp;str&gt;` in Rust.
And I'd like to have access to signal() and killpg() without needing to use libc.
Yup. The API is basically everything in `LoadDsl` with `_async` at the end, where `Result&lt;Vec` is replaced with `Stream`, and `Result` is replaced with `Future`.
Our test suite actually has a full example of real enums now https://github.com/diesel-rs/diesel/pull/996/files#diff-adb305556a7304e0c82b2838ef950ad3
I'll probably try to finish it this week now that those two questions are answered :)
The Rust ARM embedded ecosystem is a lot further along. ARM chips are way more powerful and just as cheap as these AVRs.
Next let's debate the lexical syntax of multiline comments.
Note: [The answer wasn't helpful](http://i.imgur.com/JmHPRTE.png). I am a jerk to lemurs.
Isn't that just a matter of more high-level components? I'm thinking of something like [QFormLayout](http://doc.qt.io/qt-5/qformlayout.html), where label alignment depends on the platform, or platform-dependent placement of Ok/Cancel buttons in Qt dialogs. As long as you provide a high-level Dialog component which places its own buttons, you can still cover the guidelines of each platform. 
I don't know about the valley but here in Germany the company needs to pay half of all insurances, half of pension plan, for your work stuff (laptop, desk, internet, training,...) for your travel (to rustconf) also taxes and over stuff. So if a company employs somebody they need to calculate at least 1/3 on top of the devs income. So 50-75k for the company actually means 33-50 for the dev. I personally think that 30k is too low. 
impl Trait in 1.20?? That seems sooner than I expected. I know it's a rough estimate, so I won't hold anyone to that date, of course. :}
Messaging application in Electron: 4.5GiB in RAM. More than Bitcoin full node.
What about `TryFrom`?
I disagree. Implementation details should be verified to work in the capacity in which they are used but can still be wildly unstable and change constantly so long as the API and end behavior remains the same.
Congratulations! Exciting to hear. Regarding async/await notation‚Äîis there a reason why Rust chose that over a generalized do notation? I heard arguments that Rust requires higher-kinded types to support it, but GHC's `RebindableSyntax` doesn't [seem to require HKT's](https://ocharles.org.uk/blog/guest-posts/2014-12-06-rebindable-syntax.html). Is this an ergonomics issue, or does it conflict with affine types/Haskell's peachy attitude towards boxing. (I don't know if this argument was played out here before, searching reddit didn't turn anything up.)
Hmm, that is interesting. I wonder how far one can get with such approach.
JetBrain's contribution to improving the ‚ÄúIDE experience‚Äù with its Rust plugin to IntelliJ deserves mention too, regardless (perhaps especially because) of the fact that it doesn't use RLS.
I think it's still blocked on the never type.
deleted ^^^^^^^^^^^^^^^^0.0665 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/62458)
Well, even if RebindableSyntax doesn't need HKTs, how would you actually implement the control flow necessary for asynchronous tasks without something like Monad? (I'm not saying it's impossible, I'm just wondering how you'd do it)
I was thinking about Object Pascal.
Ah, I misread, yours is still multi-process. My apologies. I have been working on embedding a browser myself and am increasingly saddened there are no reasonable same/single-process options.
IIRC there are conflicts with affine types and stuff; in general do notation works better in a side effect free language with GC. I don't recall the exact issues, but this has been discussed often.
F# doesn't have HKTs either and yet it has it's own version of do notation. https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions Its `async` support is actually built on top of that.
Rust is cool, but I want it more like crystal and swift, &amp;&lt;&gt;' hurts code readability :-p
Dependencies are often part of your public API though.
Thanks for the info üëç
https://github.com/iron/iron/issues/359 has some info.
If they are then yeah that's a problem. They don't always have to be though. Opaque wrapper types are great at handling this.
Webkit has an option for single-process: it is even enabled by default.
Yes, that works if you lock the 0.x dependency to a specific version, and it is not part of your public API. I don't think that's the case anybody is talking about though.
I mean that's what this proposal is. It just doesn't call it "2.0".
The kdevelop Rust support is also being done without the rls.
I believe you want /r/playrust
*runs rustc --explain E0277* I appreciate the dedication to the joke!
Wrong sub?
Do you mean`nalgebra::core::Matrix*`? Are you using an old version?
No single syntax will make everyone happy. And every language I've ever used has at least one bit of syntax that pisses me off. In the end I think semantics and the power of the language are a lot more important. Once you know Rust the symbols actually help readability. It's a concise indicator that you're encountering one of the core concepts of the language. I mean, lifetime syntax really jumps out at you, and that's a good thing. Anyway it's way too late for this kind of bikeshedding and any change would upset as many people as it pleases. It's all been discussed to death.
Why can't you do the websockets on a different port?
&gt; It also depends on Rayon which in turn brings in more dependencies than I want in a straight crypto library. Does it? It looks to me like it only uses it at build time.
It is `nalgebra::core::Matrix`, although it is re-exported so I always just use `nalgebra::Matrix`. I forgot to say, but I am using an old version ('0.11.3').
I'm not who you're replying, but.. lifetime syntax is great, but `Type&lt;A, X&lt;B, C&gt;&gt;` instead of `Type A (X B C)` is unnecessarily noisy. But I agree that every language has some annoying syntax choices. For the most part, Rust syntax is *okay*. Now, I'm not on the camp that syntax doesn't matter much; ergonomic syntax is very important for language adoption. If syntax wasn't important, not having a `catch` keyword wouldn't be an issue, and nobody would propose shifting a bare `Trait` to mean `impl Trait` instead of a trait object, which is bound to make post-1.0 code snippets very confusing (here's bikeshedding for you!). Anyway.. yeah, it's too late for &lt;&gt;&gt;&gt; bikeshedding :( perhaps in another language...
Any more updates on non-lexical lifetimes? Are we on track to have that completed by the end of the year? Last I heard we were still working on getting the borrow checker ported to MIR, but that was a while ago. The tracking issue doesn't have too many updates either.
Why is the keyword *impl* needed in the upcoming impl Trait syntax? Example: fn hello() -&gt; impl SomeTraitName { ... } The question is, why not simply this: fn hello() -&gt; SomeTraitName { ... } ?
I haven't the faintest clue! I guess I should look for papers that describe how that control flow is implemented in Haskell/F#. I'm a very satisfied end-user of these abstractions; haven't got the faintest how they're implemented.
It's needed to distinguish between the trait object type and the invisible generic implied by `impl Ttait`.
I'm trying as hard as I can to convince myself that halfway-through-a-nybble approach is problematic w.r.t. prefixes. As far as I can tell, the fact that *keys* are constrained to be an even number of nybbles long should prevent issues with branching halfway through a byte. I'm going to try the snippet you've shown here with my QP-trie and see what happens...
It's not unnecessary; Rust does not have higher-kinded types, so it needs a distinction between type arguments and function arguments. Your suggested syntax lacks that distinction. Honestly, most criticism of Rust's syntax turns out this way; someone presumes that it is needlessly explicit and that the language designers failed to see a prettier alternative, but then someone points how how the prettier syntax isn't expressive enough. Rust is littered with `&lt;&gt;&amp;*:'` because it asks the developer to be explicit about many more things than most other languages, and while I definitely think this is initially off-putting and could be improved, I don't think any major syntax changes would be possible without the language working differently altogether. I think the worst of the ugliness of having a lot of special characters goes away with good syntax highlighting.
&gt; It's not unnecessary; Rust does not have higher-kinded types, so it needs a distinction between type arguments and function arguments. Your suggested syntax lacks that distinction. Can you elaborate? I can't see how this syntax interacts with HKT -- they would desugar to the same AST (oh and I meant `Type A (X B C)`).
You could do it via matrix transformations, like so: Matrix4x3::identity() * (matrix * Matrix3x4::identity())
Is there any plans on moving https://github.com/rust-lang/rfcs/issues/929#issuecomment-81355948 forward? Most people there seems supportive (and it _is_ quite useful). I just haven't seen any news there. Pretty much, imagine you have a function which takes two Options, and return true if they're equal and false if they don't exist or are not equal. What you have to do now is something like[1]: fn example(a: Option&lt;String&gt;, b: Option&lt;String&gt;) -&gt; bool { match a { Some(a) =&gt; { match b { Some(b) =&gt; a == b, None =&gt; false, } } None =&gt; false, } } https://play.rust-lang.org/?gist=fd54f4a56c18456c5f28a7610ffcacdb&amp;version=stable&amp;backtrace=0 What would be nice is to do something[1] like if (let Some(a) = a) &amp;&amp; (let Some(b) = b) &amp;&amp; a==b { true } else { false } A practical example where this can come in use is if one sets a "save user" cookie, and puts it into the database. Now, when you're reading it, you have to make sure that: 1. Database connects. 2. Record is there. 3. Cookie is there. Each level would require it's own match, which can get your code shifted quite far to the right. [1]. You _could_ also do something like: fn example(a: Option&lt;String&gt;, b: Option&lt;String&gt;) -&gt; bool { if !a.is_some() || !b.is_some() { return false; } let a = a.unwrap(); let b = b.unwrap(); a == b } https://play.rust-lang.org/?gist=f16f1043ce79bd2d827f4a7f0842d6e1&amp;version=stable&amp;backtrace=0 But .unwrap() (In my humble opinion, coming from an absolute Rust noob) seems to be a "code smell". [2]. I also like the guard let if idea, but that seems to be much more controversial. (https://github.com/rust-lang/rfcs/pull/1303).
type String = [Char] A Haskell String is an immutable linked list of characters. There's other types for packed data strings, but String is not that. As a result, prepending to a String is O(1), but appending causes the entire list to be rebuilt from scratch.
There are a couple of hardcoded files (which can be overridedn ith environment variables often even): - `~/.profile` - `~/.bash_profile` (ignores the former if the latter exists) - `~/.bashrc` - `~/.bash_logout` The rest is just sourced in those files. My own system via this has: - `~/.config/profile` - `~/.config/profile.d/*.sh` - `~/.config/profile.env` - `~/.config/profile.env.d/*.sh` - `~/.config/profile.ssh` - `~/.config/profile.ssh.d/*.sh` - `~/.config/bashrc` - `~/.config/bashrc.d/*.bash` - `~/.config/bash_aliases/*.bash` - `~/.config/bash_aliases.d/*.bash` - `~/.config/bash_aliases.d/*.bash` - `~/.local/share/bash_history` - `~/.local/share/bash-completion` What can I say? I'm neurotic about keeping a tidy organized filesystem.
I've whipped up something basic to tinker with, using an array of u64's to hold each 8x8 font character and a whole lot of right-shifting. I'll probably make it so that you feed it text and foreground/background colors and it returns a raw ~~array~~ ahem, vector that can be copied onto an image somewhere, then it's generic enough that other people can use it if needed. 
Then I'm surprised you haven't upgraded to zsh ;)
oops you're totally right. I misremembered what the slice operator does on str and got it confused with how some other languages do it, which is iterating from the start of the string counting unicode code points.
This is what I was looking for, thanks!
Well, you could also do this: fn main () { let a = Some(1u32); let b = Some(0032); if let Some(equal) = a.and_then(|a| b.map(|b| a == b)) { println!("equal? {}", equal); } else { println!("definitely unequal (not both some)") } }
Well, my point is haskell should be easier to read(than all these languages with lots of syntax), but i remember trying to read some libraries (multiple times), i got bogged down with these symbols(yes lens library seems to be the culprit) and i just ended up reading corresponding ocaml/racket code. Anyway it's off-topic, and i probably shouldn't have brought it up.
It‚Äôs actually arguably incorrect to write C‚ôØ; I investigated it one time a few years ago and found that although in designs they use the musical sharp symbol (‚ôØ) the written form of it is C# because ‚ôØ is too hard for most people to type. Me, it‚Äôs just `Compose+#+#`. I love my Compose key.
Because of the requirement that each substring be owned (and hence, each occupy a unique non-overlapping region of memory). Which, of course, does not quite match Haskell's semantics, as has been mentioned elsewhere in this thread. Anyway, presuming the substrings must be owned, then for each of *n* possible starting-indices *i*, a copy of the last *n-i* characters must be made. Copying is linear-time, so making a linear quantity of copies is quadratic; the length of each copy being *n-i* instead of *n*, merely causes a 1/2 constant multiple.
Using parentheses for indexing would be at best hard to implement in a backwards-compatible manner. Unifying the `Fn` and `Index` traits in some way would probably be a part of it; the fact that implementing `Fn` manually isn‚Äôt stable and that no types that implement `Fn` implement `Index` is going to be fundamental to it even being possible. It‚Äôd be an interesting thought experiment, but I would estimate the probability of Rust actually going ahead with any changes like that to be under three percent. And the only reason I didn‚Äôt say 0.04% was because it *would* actually make various concepts and neat abstractions quite a bit nicer. If done right, anyway.
Excellent! We love contributions, thank you. üòÑ Automatic retry in the credentials crate was recently removed but we haven't had a release of that yet. I've [made a new issue](https://github.com/rusoto/rusoto/issues/755) for bringing back timeouts to the relevant credential providers. Probably be making another one for all requests, which will be trickier since some operations, like a large upload to S3, could take longer than an aggressive timeout allows.
https://is.gd/qEQasL fn example(a: Option&lt;String&gt;, b: Option&lt;String&gt;) -&gt; bool { match (a, b) { (Some(ref a), Some(ref b)) if a == b =&gt; true, _ =&gt; false } } 
Trait objects obscure the things that they contain; something that takes a `Box&lt;Fn()&gt;` cannot possibly index on it: calling the function is all it can do without a concrete downcast (which is also, incidentally, unsafe).
Welcome! In general, I would recommend reading "The Book": [The Rust Programming Language](https://doc.rust-lang.org/book/) isn't geared towards any specific programming language background, but I found it fairly easy to understand and learn from coming from more dynamic languages. The Rust Programming Language has two editions, the second has incorporated a lot of feedback on the first edition, and I'd recommend starting with it: https://doc.rust-lang.org/book/second-edition/. As for improving node code, I can't speak very much to this - perhaps someone else can. I've know a little JavaScript, but I'm working mainly in Python and Rust at the moment.
+1 When I have multiple Options or Results and need to match on particular combinations of them, stuffing them in a tuple and matching on that works well.
One small typo: Your return type for `suffix_vec` should be `Vec&lt;String&gt;`, not `Vec`. I'm also really not sure about this statement: &gt;you can do things that you couldn't in Haskell (here, distinguishing references and values). Because everything in Haskell is immutable, and there is GC, is there a useful reason to distinguish between references and values?
As someone who is learning Rust and has a day-job in Node.js, Rust will not help you improve your Node.js code. Learning any language will result in techniques you can sometimes apply to other languages but I would not set out to learn Rust because of this. Rust is low-level. This means you must declare, reserve, and manage your application's physical memory unlike Node.js which allocates memory (and frees it) behind-the-scenes for you. Rust is better suited for graphics applications, system programs, video games, etc. whereas Node.js makes it easy to write applications that run on the server. The differences between the two are far and great. It would help to understand why someone would write anything in a low-level language such as Rust, C, C++. As for videos, I found this talk to be super helpful when I was first learning Rust. It talks on "Ownership" and why it's an important language design pattern. https://www.youtube.com/watch?v=lO1z-7cuRYI
I believe that the particular issue you're poking at is entirely existent in the `get_ancestor` functionality you have - which I don't actually support yet! It took me a little while to figure out what that actually did (hah.) Anyways I'd be interested in any possible solutions to that problem you might have considered - I'd like to implement that stuff in my library at some point, although I don't need it for my current use case.
Yep, definitely harder on some keyboards. I used the word ‚Äúmost‚Äù deliberately!
Worry not, for the problem is fixed. :P Yes, that is a frightening thing and that particular point has just brought into scope how badly I could mess things up if I do things wrong marking functions in a library that, for example, has functionality which when compiled in release produces undefined behavior on misuse but panics in debug. That happens to be the exact situation in which I was previously chastised and I now see the many errors (undefined behaviors?) of my ways.
`do` notation does not play well with imperative control flow, as it desugars to a series of closures. In Rust, that means anything using it would have to give up loops, break/continue, return, etc. It's currently looking like `async`/`await` in Rust will be built on top of generators, which are plenty general to warrant a language feature. They play much better with imperative control flow, and IMO should be viewed as an imperative control flow primitive.
&gt; I'm not sure this is a fair benchmark since the Haskell function does in fact "own" its result Haskell doesn't have anything like Rust's notion of ownership; instead, values are shared by its users using and their lifetime is managed using a GC. An inexact analogous in Rust's stdlib is `Rc&lt;str&gt;`, but that doesn't handle cycles.
&gt; how would you actually implement the control flow necessary for asynchronous tasks without something like Monad? Even without baking it into the language there are better ways to implement these sorts of new control flow in an imperative language. Scoped continuations are probably the closest equivalent, but there's not much reason to go all the way there.
Not video, but [the Newrustacean Podcast](http://www.newrustacean.com/) is an audio podcast that started out very oriented toward learning the language. IRC is good for help, irc.mozilla.org #rust-beginners will usually have someone that can answer your questions pretty quick. There's a Udemy course that worked out pretty well, I won't link it as I don't think it's proper to advertise a paid product, even if it's not mine. As for what it intends to be: Rust intends to be a systems level programming language with a focus on memory safety and concurrency. Roughly de-buzzworded means it's trying to fill the same sort of space as C/C++ but with some of the safety guarantees you find in languages like Python, without using a Garbage Collector. How it works is complicated, but the surface level elevator pitch is "Rust makes you explicitly state you want reduced safety for increased power, and that's enforced by the compiler". Rust generally defaults to safe behavior, for example things tend to be immutable by default requiring the programmer to explicitly override that behavior when it's needed. Things that can't be done completely safely require that the programmer use the `unsafe` subset of the language. `unsafe` allows *very* low level control but puts much of the onus of safety on the programmer.
Awesome, thanks! Spread the good word. :-)
I think it's fair to say that it's idiomatic rust to do so.
Why do you think parenthesis are less noisy? Particularly in tuples and function signatures?
&gt; I have no idea how to manage a ton of UI objects though Are you talking about qt5 specifically, or UI objects in general?
Are there other advantages to AVR? More power efficient, etc?
It has less delimiters. In my experience complex Haskell types are easier to visually parse than Rust types. (YMMV) Haskell deals with its type-level tuple syntax just fine.
Yeah, it's one of those really damn insidious things that I too forget for my static sites. Nowadays I just LE _everything_ because why not? It's free and works.
Some people need to study algorithms to actually understand what "stable" means in this context :P Hint -&gt; https://stackoverflow.com/questions/15125552/what-is-the-meaning-of-stable-and-unstable-for-various-sorting-algorithms
Strictly speaking, you *can* distinguish between references and values in (GHC) Haskell; references are of kind `*` and values are of kind `#`. (There‚Äôs a little more to the story as of GHC 8, but the basic gist is still the same.)
 fn example(a: Option&lt;String&gt;, b: Option&lt;String&gt;) -&gt; bool { match (a, b) { (Some(a), Some(b)) =&gt; a == b, _ =&gt; false, } }
Why the refs?
This is amazing. play.rust-lang.org should have a button to explain each function. And other sites that contain Rust code snippets, like rust by example, or even the Rust book.
I wrote it in like 5 seconds idk
Germany is still in the West - not as bad but still far from the global minimum - 30k here means 3 full-time junior developers doing pretty well for themselves. Living costs aren't the same everywhere but people eager to learn and build something meaningful are. The West's disdain for "lesser" regions of the world makes it blind to the costs of geographically concentrating an industry that does not have much more than ping milliseconds to gain from physical proximity.
I started trying to build a statically-typed clone of OTP/BEAM in Rust. I don't really have any idea what I'm doing (partially because I haven't written any meaningful Erlang/Elixir code) but it's a ton of fun. Right now I'm building the function that takes care of actually exciting the instructions on processes and am dealing with messy lifetime issues. https://github.com/tino-platform/tino
If you want to pass around pointers like you do in C/C++, you can do that by coercing a reference into a raw pointer, instead of using reference counting. That would let you escape the borrowing rules, at the cost of having to manually manage these pointers and their memory, as you would in C/C++ without the safety of the compiler. But as already stated, you should look into the entity-component system architecture. That's the kind of game design that works perfectly with Rust, without needing to forego safety as with raw pointers. Raw pointers are often used in data structures for performance reasons though, so don't forget that you game the option to opt into unsafeness.
yesssss EDIT: To clarify, I really loved infer_schema when I was the only contributor on a project (and if I were at a company with a mature dev environment I'd probably still feel that way), but there are definitely community contributions which shouldn't need a database to compile as a sanity check, but where opening a PR and hitting CI with a bunch of commits is a painful flow.
&gt;hotspot &gt;5 instructions That sounds impossible, but I'm quite intrigued. Do you know where you heard that?
I'm very much in this camp. I really dislike ot when languages make things that are in the stdlib have special compiler support. Like how `Iterable&lt;T&gt;` in Java works with foreach loops. Or how `IEnumerable` coroutines work in C#.
[use a serialization library to make an operating system... seems legit](http://i.imgur.com/rmUesqT.png)
On the Java side you still need some tinkering to get it to look *jus right*. It's still not perfect though.
those tuples are free right? Rather, the compiler does the dirty work and makes the appropriate branches, assuming it compiles and won't be optimized away.
Hmm not exactly sure what you mean by improve your node code but using something like [neon](https://www.neon-bindings.com) would allow you to reap the benefits of rust (speed, reliability, fearless parallelism etc) in a node app. I've been using it myself lately and it's worked well. You can look at how I'm using it [here](https://github.com/garyemerson/centroid) (mostly copied from [here](https://github.com/emk/electron-test)) if you'd like. 
The "Patches welcome" link seems to be broken?
Is there any document like [this](https://dlang.org/spec/declaration.html), [this](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID351) and [this](https://golang.org/ref/spec#Expressions)? A language reference that is organized by the grammar production rules.
Hence why they're soliciting patches.
The developer responsible for that oversight has been reprimanded.
IDK if you want suggestions for any reason, but just in case -- some theorists don't worry about the `log(x) * 1200.0` thing for calculations and just use `log(x)` or `ln(x)`, because the cents are just a holdover from 12TET and a waste of an operation. Second, it would be useful to have a trait `Pitch` that generalized over `Hz` and `Cents`, or whatever you want to call it, and maybe `Ratio` as well. It'd also be cool to have generators for various non-equal tuning systems like tempered meantones, but that's another ballgame -- just a good project if you're into this. A good exercise would be to write a parser for `.scl` Scala tuning files, which arbitrarily mix cents and ratios.
I'm working through the book now, I find it well laid out and easy to understand. Not to say there aren't valid criticisms, but solutions to many of the 'complaints' I've seen are well documented in the first half of the book. It's a solid learning guide, and it's free, so thanks!
polydraw looks interesting, but AFAIU it's GPU only, which is sad.
/r/rustjerk
Build cryptography using only clippy... Damn that is a hard one.
So here is my question. In [chapter 17.3](https://doc.rust-lang.org/book/second-edition/ch17-03-oo-design-patterns.html#requesting-a-review-of-the-post-changes-its-state) of the book there is a use of `state` as an `Option&lt;Box&lt;State&gt;&gt;`, and there is a use of `.take()` on this `Option` to consume the `Box&lt;&gt;` and replace the value with another `Box&lt;&gt;`. This is something that bothers me. I make a different version of the code that do not use `Option` in the struct definition for `State`, but directly the `Box&lt;&gt;`, but now I am realizing that maybe I am leaking memory. I mean, when I replace the value of the `state` field (that contains a `Box&lt;&gt;`) with another `Box&lt;&gt;`, Rust is not dropping the old value, isn't?
[into_rust()](http://intorust.com/) has screencast tutorials by one of the core Rust developers. Only a few on there so far, but the ones that are there are good, and focus heavily on the concepts that trip up a lot of new Rust developers.
Otherwise `rustc` thinks you're trying to pull out the `String` value from the `Option&lt;String&gt;`, and complains bitterly. It needs a hint that you just want a reference to those strings.
Why is that?
I'm pretty sure it does. You can check by implementing a c ustom drop for the inner value that prints
best solution: let a = Some("a"); let b = Some("b"); a.and_then(|a| b.map(|b| a == b)).unwrap_or(false);
To expand a bit on what /u/burkadurka said, `SomeTraitName` by itself *already* names a type, i.e. the type of a (dynamic-dispatch) [trait object](https://doc.rust-lang.org/nightly/book/second-edition/ch17-02-trait-objects.html). The only reason you don't normally see it by itself, and only behind a pointer like `&amp;SomeTraitName` or `Box&lt;SomeTraitName&gt;` is that it is *unsized* (because different types implementing the trait can have different sizes). There has been [plenty of discussion](https://github.com/rust-lang/rfcs/pull/1603) about making the dynamic-dispatch type require a prefix as well, e.g. `dyn SomeTraitName`, so that `SomeTraitName` could be freed up for what you suggest, and while a lot of people like that, it would obviously be a pretty pervasive breaking change, and Rust is trying hard to avoid these. (With [epochs](https://github.com/aturon/rfcs/blob/epochs/text/0000-epochs.md), it might be possible someday.)
I could, but most other web frameworks out there have this capability. Why would not this be possible using Rust?
Rewrite [Newsbeuter](https://github.com/akrennmair/newsbeuter) in Rust (because Newsbeuter crashes from time to time).
It will drop the old value - Rust doesn't leak unless you ask it to :) You basically don't ever have to think about dropping anything manually if you don't use `unsafe` blocks.
I was also thinking about this a while ago :) https://twitter.com/upsuper/status/844547314832199680
Hey, at least this gives hopeless detractors some new straw to cling to. I can still remember the "they released 1.0, but the `core` library isn't even stable!" arguments.
At least there was [this](https://github.com/rust-lang/rust/pull/42924) in this week's TWIR: &gt; This PR is another baby step for mir-borrowck; it is a piece of work that other people want to rebase their stuff on top of [...]
Huh, TIL! Thanks. :) I'm not sure where that information came from, then! I hope I haven't perpetuated the lie...
The ability to destructure owned pointers in match would be great. Having to open a separate match for unboxing and even simpler things like having to call as_str() on any Strings you want to match add just a little bit to the overhead and it would be nice if they weren't necessary. One way is to support matching on anything that implements Deref, either with a dedicated syntax, or with the &amp; indicator. References already implement Deref so it wouldn't require checking for 2 different conditions. Doing this would allow matching on Box and Rc, as well as String, Vec, CString (assuming match already supports CStr), Cow, and even user defined containers.
&gt; Combine rust-sdl2 and rust-sdl2 to finally make visual verifiable computation possible!! I don't know about the second part, but the first part? ... Done. I've successfully merged a library with itself! [EDIT] Second suggestion is "Transpile Java to Rust!!", which is likely impossible, though writing a JVM in Rust... that could be fun.
I think that returns suffixes, not prefixes.
Some of the issues I've posted on the repo could use some guidance. I'm more than willing to get the work done, but there's a lot I don't know about macros in particular. Any help would be appreciated, especially for the macro-specific issues like trying to make the order of blocks unrestricted, and getting away from unstable features!
That's interesting, thanks. I had not seen the *dyn* discussion before. Here's a couple of follow-up questions :) 1. Okay, so what about this then: fn hello&lt;T: SomeTraitName&gt;() -&gt; T { ... } ? 2. Will the *impl Trait* feature result in an extra layer of indirection, a reference or a implicit/hidden boxing, or will it result in template instantiation, or something different? Sorry for my C++ terminology. 3. I've seen *monomorphization* used quite generously where I have interpreted it as compile time instantiation of a generic/template function, is that the correct Rust term or is it only related and not equivalent?
Using tuples on match is a good option (no pun intended), but personally I'd still like to have if let behave a bit more like a standard if. Plus there are some cases where I think it would be more readable (this is subjective though), e.g.: let x = Some(42); if let Some(foo) = x &amp;&amp; foo &gt; 10 { .... } VS match x { Some(foo) if foo &gt; 10 =&gt; { ... }, _ =&gt; {}, }
Good idea, I will try this.
Looks like rsvg is a very nice library for that: https://docs.rs/rsvg/0.1.3/rsvg/struct.Handle.html#method.render_cairo
Thanks! What you describe looks like you might appreciate the rust [cookbook](https://brson.github.io/rust-cookbook/)
I've made something similar: * REST-like API * websocket * static files [here](https://github.com/xliiv/dashboard), but it works on 2 ports. * One for http/rest * One for ws Using 2 ports is so bad? 
This is probably not the same, but one of my early experiments with Rust was a data type which could only be changed through "actions", which would have a pre, and post-condition. It uses no macros, but also works on a very different level. https://github.com/skade/strand (No docs, sorry)
Oh, in that case there is something that I do not understand: Why is the example using `Option&lt;&gt;` in the first place? So IIUC is this what is happening? struct Foo {} impl Foo { fn new() -&gt; Foo { Foo {} } } let mut a = Box::new(Foo::new()); # The compiler detect that there is an assignment, so the old # value owned by `a` is dropped here. a = Box::new(Foo::new()); # If this is the end for a, the new Box is also dropped here Also thanks for the answer.
I sent a pull request regarding `Vec&lt;T&gt;` parameters. I also noted that you have some redundant type annotations in `main.rs`. These can be removed. Overall the code looks very clean.
i'm a little bit biased here so don't let me dissuade you. But without some static analysis i just kind of don't get it , Whats the point ? Having not looked at what code your macro generates, i can't imagine whats wrong with https://is.gd/aMeFnR ( but my imagination isn't all that impressive :) ) But what i might find valuable would be if your macro could generate : enum ContractFailure { Pre(..) Post(..) Invariant(..) } fn asdf(asda: bool, stuff: u64) -&gt; Result&lt;bool,ContractFailure&gt; { .... } 
In addition to /u/MthDc_'s comment, it may also be worth noting that `max_filename_width` can be written using iterators like so: pub fn max_filename_width(fileinfo: &amp;[FileInfo]) -&gt; usize { fileinfo .into_iter() .map(|f| f.formatted_filepath().len()) .max() .unwrap_or(0) } And `max_filesize_width` can be implemented in a similar manner. Minor nitpicks aside, the code is very well written!
You'll often see `Option&lt;T&gt;` in structs when the `T` cannot be filled yet at the struct creation. In other languages you'd just put in a null pointer/reference, but obviously Rust cannot allow that. Another reason is that with an `Option`, the struct can always derive `Default`. As for the code sample, that's correct. It can be enlightening to experiment with this, using an impl like this: impl Drop for Foo { fn drop(&amp;mut self) { println!("Foo {:p} dropped", self); } }
It uses pointer bumping. What happens is that every thread (or core) has its own allocation pool. That's just a chunk of memory it allocates from. To allocate, it gets the current pointer, sees wherever that's enough space available and, if so, bumps the pointer. The short garbage collection cycle goes though all of these memory blocks, move to the shared GC memory what's alive and resets all of them to empty and the process started over. This is extremely fast, but does require a moving garbage connector since objects psychically move in memory, and the pointers need to be rewritten. This mechanism is optimized for short lived allocations, assuming that relatively few objects will be moved to the shared space in general.
1. That means that the *caller* can choose any concrete `T` that implements `SomeTraitName` and your function is required to return it. `impl T` means that *the function* chooses the concrete type. 2. `impl Trait` is designed to prevent indirection. (Returning `Box&lt;Trait&gt;` would introduce indirection.) `impl Trait` basically just allows you to not specify the full return type of a function, by limiting it to "something that implements Trait". Internally, the compiler knows the exact type. This is useful for at least two reasons: * you can't name the type of a closure (each closure has its own unique type), so to return an unboxed closure you need `impl Fn(...)` * with API like iterator adaptors, that build up a type like `Take&lt;Map&lt;Zip&lt;etc. etc.&gt;&gt;&gt;`, it becomes increasingly frustrating to have to write this type just because you want to factor out the iterator construction into a function. (Locally, it's not a problem because of type inference.) But it's important to keep in mind that `-&gt; impl Trait` stands for a *concrete* (just unnamed) type. For example, this function does not compile because although both branches return iterators over `i32`, they are different types underneath: fn test(v: &amp;[i32]) -&gt; impl Iterator&lt;Item=i32&gt; { if v.is_empty() { (0..10) } else { v.iter().cloned() } } 
Uhm good points for `Option&lt;T&gt;` usage. Thanks for the help and the clues, now I have a better model in my head : ))
It's also kind of an amusing coincidence that this ended up producing sort of a Composition vs. Inheritance situation as a side-effect. In C#, the use of different definition mechanisms for stack vs. heap bears a superficial resemblance to how classical inheritance leaves you with an ever-growing bag of whatever your upstream thought you needed. In Rust, opting into heap allocation is quite literally accomplished by composing types.
Contracts are very useful for verifying internal logics. It is pretty dubious to use contracts for public interfaces (especially in Rust where you may make use of type-level safety), but types are less useful for more complex constraints which are relatively common in implementation details. (And since they are internal matters, they should panic when contracts are violated---that'd be a typical bug condition.)
Overall as already said, it is nice. Have you tried running clippy? It really helps if you're not sure if you're code is rusty enough. For instance, it is generally better to use `&amp;[FileInfo]` instead of `&amp;Vec&lt;FileInfo&gt;`. 
awesome.
The plan is to provide a blanket impl for TryFrom/TryInto whenever From/Into are implemented, using the never type as the error type, since, for example, "From" is semantically identical to "TryFrom where the error case is impossible". See the discussion on the tracking issue: https://github.com/rust-lang/rust/issues/33417
Excellent answers, thank you. This finally made it fall into place for me: &gt; impl T means that the function chooses the concrete type I did not see any point of new syntax until I read that sentence. Now I will go slightly off-topic and add in some opinion into the mix, would it not make more sense to use the existing syntax for Trait bounds? All trait bounds hide the concrete type, the only difference being if the caller code or the function provides the hiding, right? 
Well, there is a difference: * in the first case (`fn foo&lt;T: Trait&gt;(...) -&gt; T`) you get a `T` - you select it, so you can use all its API. * in the second case (`fn foo(...) -&gt; impl Trait`) you get some `T` that you don't know, and can only use the methods it provides via `Trait`.
Nice example. So I suppose the reasoning behind choosing to add new syntax is to make it clear to the reader who provides the concrete type..?
There has to be *some* difference in syntax anyway.
And now I'm curious, does it really need to? If yes, why is it needed?
&gt; Experiment with garbage-collected reproducible builds in Rust. Here's one for the infra team!
Eh, I'd say that's different. We have plenty of traits in rust given special treatment by the compiler, and it doesn't feel off. What's troubling is when a type behaves differently when used the same way as other types, but as someone else mentioned, the long term plan is to remove that small difference from `Box`.
progress at https://github.com/capnproto/capnp-rpc-rust/issues/23 I plan on cleaning this up a bit to serve as an example for others.
Because a signature needs to be unambiguous. Let's take this function: fn default&lt;T: Default&gt;() -&gt; T Which of the two is it? :)
`Result` is for cases where errors are not exceptional and may well be recoverable. Panicking is for cases where there is a logic error in your program, and it‚Äôs probably better to just give up at once. Preconditions, postconditions and invariants are all about detecting logic errors that can‚Äôt be expressed in the type system. Panicking is absolutely the right thing to do.
Sure. On the other hand, if you have a `let t: T`, what do you think `t(0)` should do?
Port Go to Rust
Having Tor on the [Friends of Rust](https://www.rust-lang.org/en-US/friends.html) page would be pretty damn awesome.
It depends on what is known about `T`; remember that without any additional bounds, all you can do with a generic type is store it and pass it on to something else‚Äîwith no further bounds on your generic type `T`, `t(0)` is illegal. But if `T: Fn`, naturally it‚Äôs function call syntax. If `T: Index`, it‚Äôd be indexing. Naturally the intersection between these two would need to have something done about it before any such functionality could work‚Äîas I‚Äôve said in this thread, it would be quite difficult to sort all of this out neatly in a backwards-compatible manner.
Is it because RLS isn't mature yet or because the protocol is fundamentally lacking that these two initiatives decided to skip it?
Have you look at the size of Qt DLLs or GTK libs to say that? :O
What about the [RustAudio crates](https://github.com/RustAudio)?
better error message is out of scope? As a beginner, it's my major problem.
Thanks, that looks very nice!
What I mean is, what about this: struct Foo; impl Fn&lt;(usize)&gt; for Foo { ... } impl Index&lt;usize&gt; for Foo { ... } fn main() { let f = Foo; f(0usize); } Making this syntax work if `Fn` is implemented, or if `Index` is implemented, but not if both are implemented, breaks current Rust ideas about semver (that it should generally be valid and backwards-compatible to add a trait implementation to a type). The only way to make this work would be to require that `&amp;Fn(usize)` can be called as it is today, but a type `Foo` that implements `&amp;Fn(usize)` must be called using disambiguation syntax (i.e. something like `&lt;f as Fn(_)&gt;(0)`, except that'd need angle brackets changed to something nonambiguous too...), and `f(0)` always defaults to `Index` (on all types except `&amp;Fn(_)`). Obviously, this is confusing and a non-starter - there are no other parts of Rust syntax which behave quite so drastically differently depending on which type you call them on. And changing how closures are called would be a non-starter for me as well - anything more complex than the current use of them would make closures very obviously even more of a second-class citizen than they are today.
Parallel AI in Rust? I would love to but there are great libraries out there in other languages, so I don't see the point.
/r/playrust
Oh, cool
Can such a function be declared with the current Rust? If yes, can you provide an example? If not, then that syntax could be used to indicate that the function named default must provide the concrete type for T. :)
I tried to get involved in the lib blitz but couldn't actually find any issues I thought I would have a chance to resolve. I don't feel like I'm strong enough in my rust-fu to really assist. Instead I committed a couple of examples to the [rust cookbook](https://github.com/brson/rust-cookbook), so I didn't feel completely useless.
Regarding the markdown, you should be able to simplify it a bit; if the "anchor identifier" in a link is identical to the "text" of the link, it can be shortened, I think the syntax becomes: ``* declares the [lifetime][] `'a` ``. You could maybe then also use 'function' instead of 'fn' for appropriate anchor ID, thus making it again more easily readable: ``The [function][] `test` ``
Hyper author strongly opposes adding support for websockets, there is no limitation in the languages. I hope that once tokio will become more popular, it will be easier to use it to combine various protocol support.
Well, like I said, afaik _everyone_ treats SemVer the way you thought it was defined, and also I personally think it's a more useful definition. I wouldn't be too upset.
As someone who came to Rust from a JavaScript-y background, I would say the main benefit learning Rust will have on your Node code is an understanding of how to avoid performance pitfalls. For example, Rust makes it abundantly clear that copying memory about is expensive. You can take that knowledge, along with the fact that JavaScript strings have copy semantics (passing a string to a function causes a new copy of that string to be created) to understand that passing strings about in Node will be expensive, and to use the Buffer type instead in performance critical situations. You might also find you like Rust better, and stick around! The Rocket framework is looking pretty good for server side web stuff...
For me, a proper REPL, ideally with working FFI (on Windows) and code completion. (See e.g. OCaml's `utop`.)
&gt; Using 2 ports is so bad? It has few drawbacks: 1. Right now in case of Rust we have mostly http-focused frameworks, and adding well-integrated ws support to them is not easy. And being integrated at the framework level is important here, as it makes a lot of things much easier for users. They often don't know much about protocols and won't integrate this themselves. 2. Deploying it means more work, that often would be not necessary at all. You can assume that everything will come with ports and infrastructure for http/https properly configured and ready to use, adding another one is a hassle and more chance for things to go wrong. Its not just port on some server, it is also configuration of the framework, dev/test environment, client libraries and so on. Its just unnecessary hassle and a lot of people (me included) are simply allergic to that. 3. It also makes things easier for clients. We can just tell them that they can start using ws (or http2 or whatever) without changing anything at all.
Sounds cool! How far is this supported? There are endless flavors of markdown and since i don't want to impose one on the end user, i'd like to be as compliant as possible by default :)
Haskell has further benefits when it comes to memory. Because in haskell, objects are immutable, haskell's GC only has to look at roots and can collect everything that is older (since older things cannot reference younger things). Here's the white paper on it if you are interested. https://simonmar.github.io/bib/papers/parallel-gc.pdf It can do that in parallel with application runtime primarily because it isn't a precise collection.
&gt; Can such a function be declared with the current Rust? Yes, it can. It is, in fact, exactly the signature of `Default::default`, just taken out of its trait.
JetBrain IDE have advanced framework to support multiple languages in a generic way, at some point it is easier to use the tools of the platform you are using if the platform is sufficiently advanced. In the case of Visual Studio Code, Atom, Sublime Text, ... they are principally text editor so have less modelling tool for languages so the RLS is a better fit. The protocol give a way to have info about the text at a position and do simple transformations, this won't be enough with full IDE.
Need more info.
A good way to help is to look at the guidelines checklist that is linked from every blitz post. There are many "easy" items, a few can even profit to be judged by a beginner. (For example, regarding the documentation.)
What's the never type? Isn't it the same as `!`?
/u/FallingIdiot has it right. It is often mentioned in Java JVM discussions, so I would say look there. I don't have any specific paper to point at as it is mostly a "well known" thing. You can think of it like this. When a GC allocates memory, it makes the check "Does my current heap have enough space?" That happens as follows - get the pointer's current location - get the max space - see if max space - current location &gt; requested memory - (on success) add requested memory size to pointer location and return the previous pointer location to the memory requester. - (on failure) trigger minor garbage collection. On a minor GC, the gc figures out what is not garbage, and copies it over to a new memory region, front to back in a contiguous block of memory. Then it moves the memory pointer to the tail end of that. It's that copying action that really allows for the quick allocation. Because that automatically compacts the memory down and removes fragmentation. It is that memory compaction that manual memory managers just can't really do since the exact address is generally known to the programmer of the language.
Building a concurrent OS for embedded devices using only html5ever? Didn't Mozilla already try that?
This is incorrect. jemalloc is great and all, but it can't do the same things that GCs do. Most of the really fast GC allocation strategies result in really fast memory allocation because memory allocation is just pointer bumps. jemalloc is a arena allocator. Whenever you do allocations in jemalloc it has to traverse its available memory, find a slot that is available, and point the application to that location. That skip list traversal is not free and can take some time to do when memory gets highly fragmented. jemalloc can't do what GCs do because there is no layer between the programmer's pointer to memory and the actual memory location. With GCs, you get an object reference, but where that reference actually goes can be changed. If jemalloc could move around the memory, it could do the same optimizations, but the programming model doesn't allow for that to happen.
I don't think it's fair to return `String`, since that's a mutable buffer. The idiomatic thing to do would be to return `impl Iterator&lt;Item=Cow&lt;'a, str&gt;&gt;` or just `impl Iterator&lt;Item=&amp;'a str&gt;`. Also, saying that a quadratic algorithm is "faster than" a linear one is intellectually dishonest. I don't know what you're trying to acheive with this post. Haskell _can_ be faster than Rust, and is particularly good at maintaining complexity over composition of algorithms because of pervasive laziness. Plus, it has the best asynchronous primitives of any language in use today. However, this benchmark is unrepresentative.
I wonder which crates are applicable for libz blitz. Most used ones? Low-level ones? Something else?
One of the points of pure functional languages is that they can share a lot of their data structures, which are immutable once built. My understanding of Haskell strings was as an immutable linked list of characters, and that the suffix of such a list would just be a pointer clone, once you navigate to it. I don't believe they need to be disjoint memory allocations.
Tuples are free.
&gt; Combine glium and html5ever to finally make the resilient blockchain possible!! This cracked me up.
&gt; Didn't Mozilla already try that? Haha!
Another article explaining "Why Rust?" for Railcar: https://blogs.oracle.com/developers/building-a-container-runtime-in-rust
&gt; Learn about a fridge using WebRender. wat
In general, in Rust, you do not have to manage memory, since Rust does this automatically for you with its ownership system and Drop trait. You do need to manage lifetimes (can be hard sometimes) and understand the difference between reference types vs value types, etc. Rust might help a Node programmer learn more functional approaches, due to the immutability by default and the use of iterators, etc. In general, learning a new well designed language (doesn't need to be Rust necessarily) is good for any programmer, regardless of what they do since it can help open them to new ideas.
I was thinking about macro that would help with declaring invariants for types (e.g. `self.x &lt; 42`) then checking them. I imagined something like this: #[invariant(self.0 &lt; 42)] struct LessThan42(u32); would generate these: fn new(val: u32) -&gt; Option&lt;Self&gt;; unsafe fn new_unchecked(val: u32) -&gt; Self; #[inline(always)] fn hint_invariant(&amp;self); //&lt; This would abuse `Void` to hint compiler that invariant holds and enable optimisations. To explain hint better, imagine this: #[inline(always)] fn hint_invariant(&amp;self) { unsafe { if !(self.0 &lt; 42) { unreachable(); // from unreachable crate; not a panic } } } fn get_value(&amp;self, arr: &amp;[u8; 42]) -&gt; u8 { self.hint_invariant(); // Now the compiler knows that self.0 &lt; 42 // Bounds check will be optimized-out arr[self.0] }
brb, writing a Dart interpreter in Rust
[Sounds like a plan, since things like gfx-rs, glium or volkano don't exist ;)](http://imgur.com/48nWD0M)
Sorry, can't say, you'll have to check it yourself for sure. But I believe it was in the original Gruber's article/script, and if so, then it should be universal.
Indeed, and that is why I think that Rust's String and Haskell's String are not actually comparable. Thus, my explanation applies to the flawed/suboptimal Rust implementation that returns Vec&lt;String&gt;, not to the Haskell algorithm that was attempted to be replicated in Rust. EDIT: ah, apologies, I did not notice that you were asking about the Haskell code initially. You are right; the Haskell code theoretically should not need to be quadratic; it is the author's attempt at a Rust reimplementation, which is quadratic.
I'll have to study that. Thanks! :)
Este es el subreddit del lenguaje de programaci√≥n Rust, no del juego.
Remember that implementing `Fn` manually is not stable‚Äîin stable Rust it can only be implemented by the standard library, functions and closures, which don‚Äôt have `Index` implementations. Of course, that alone isn‚Äôt enough to satisfy SemVer on API changes; `&lt;T: Fn + Index&gt;` would be a legitimate bound at present, though useless in stable Rust as it‚Äôs unsatisfiable. Either you‚Äôd need to say ‚Äúif it can be either, do this‚Äù, or add a new negative bound to `Fn` or something like that if you could come up with some way of doing so without breaking compatibility. In practice, you‚Äôd want to do some genuine unification of the two trait families, and that would depend on a few other moving parts as well (for example, `f() = x;` should be able to work, right?). There‚Äôs some tricky design work that would need to be done, but I *think* it would be possible, and I think the language would probably be better for it, from a purely technical perspective. I‚Äôm not going to try doing any of this design work, though, because I don‚Äôt believe that it‚Äôd be accepted into the language.
I disagree with your assessment of The Benchmarks Game. It has historically had very little oversight and some extremely boundaries-pushing code. Fundamentally it is *not* a controlled experiment, and though things have improved since then there's no reason to trust a benchmark that hasn't been audited by anybody.
https://doc.rust-lang.org/reference/ is the closest thing
I feel that indexing is dissimilar enough from calling a function or closure that it really, really shouldn't share syntax. As far as I'm aware, there are no other parts of Rust where dissimilar functionality uses the same syntax. The original issue here can be solved by integration with an improved version of the Rust Language Server to figure out whether you're in a position where the token `&lt;` means "less than" or "generic parameter", and a good font.
Thank you for the correction! Yes, you manage _ownership_. I would argue that you do need to know some low-level memory management though since it's uncommon for a JavaScript programmer to work with u8, u16, f64, etc (at least in my experience)
For context, LMDB is the Lightning Memory-mapped Database, a persistent in-memory (i.e. mmap-based) database with transactions which is designed for mostly read-only workloads: https://symas.com/lightning-memory-mapped-database/ LMDB supports multiple simultaneous read-only transactions or a single read-write transaction, which maps nicely to Rust's mutability semantics.
&gt; at some point it is easier to use the tools of the platform you are using if the platform is sufficiently advanced Sure, but the first solution that comes to mind would be to develop an adapter to port RLS' features to their own system. But they didn't do that, so I'm wondering if they think that RLS won't ever be as powerful as their own tools, and if so, why.
&gt; Incorporate the best ideas from visual COBOL into dyon... my eyes bleed‚Ä¶
This is getting way of topic of the original question but I will try to keep this going a little further. I've tried playing around with default and the type seems to be: fn() -&gt; _ {&lt;_ as std::default::Default&gt;::default} https://play.rust-lang.org/?gist=ca6f1b8ce924b4506347a64896b1246b&amp;version=stable&amp;backtrace=0 Is "taken out of its trait" a general concept I can read up on? I have also tried to figure out an example of "fn foo&lt;T: AnyTraitYouCanThinkOf&gt;() -&gt; T" but I can't seem to get anything to compile with that signature. To be clear, I'm not trying to find ways to whine about upcoming syntax, just trying to fill in the apparent blanks in my Trait related rust skills. :)
/u/hyc_symas fyi :)
Stores its files in a git or hg repository, Markdown syntax, file upload capability, user management, caches rendered pages instead of re-rendering everything all the time, sane defaults. I use gitit now, which is great but is only nominally maintained and also sometimes uses up all the memory on my server and gets killed. I started writing my own, natch, but got as far as "this can render and serve Markdown-formatted files" before descending into the madness that is libgit2 and losing interest.
Release the first crate for complicated math... Man, I can barely even handle simple math. Nobody is going to be better off using my attempts at the complicated stuff.
&gt; Rust is better suited for graphics applications, system programs, video games, etc. whereas Node.js makes it easy to write applications that run on the server. I respectfully disagree with this. Rust is intended to be very well suited to run on the server, at least once tokio/futures and async mature a bit.
&gt; Is "taken out of its trait" a general concept I can read up on? No, that is just how I tried to explain why the function looks different from what you'd find in the definition of `Default`. &gt; I have also tried to figure out an example of "fn foo&lt;T: AnyTraitYouCanThinkOf&gt;() -&gt; T" but I can't seem to get anything to compile with that signature. Easy: https://is.gd/VE7Ipp Granted, that specific signature only works with some traits, but you can imagine more complex ones where the output generic type is bounded by some aspect of the input. In any case, the two cases are pretty much different beasts, and deserve different syntax. Not sure what else I can say about it.
Scaleable roguelike, though? On it.
I've yet to see a benchmark I'd trust with my wallet, but IMO I have less reason to complain about [kostya's benchmarks](https://github.com/kostya/benchmarks) than The Benchmarks Game. Maybe one day it would be nice to run a proper cross-language comparison to show people how it's done, but the effort it entails is intimidating to say the least.
&gt; Sure, but the first solution that comes to mind would be to develop an adapter to port RLS' features to their own system. But they didn't do that, so I'm wondering if they think that RLS won't ever be as powerful as their own tools, and if so, why. Emma, GSOC developer on the kdevelop plugin, has a blog on that: https://perplexinglyemma.blogspot.com/2017/06/language-servers-and-ides.html
`Transpile BASIC to concurrent Rust...` Hooooo boy
The short answer is no. The long answer is, "No, because I wouldn't like it." In my day job I'm a C# dev, and the fact that we have to choose upon defining an object whether to pass it by reference or by value is an annoyance, not a desirable feature.
Thanks. It would be very helpful for me when it is finished.
Thanks. Not really my area of interest, other-language-wrappers are entirely the concern of those languages' users. Wrapper authors are always welcome to ask us for input/opinions, and give feedback on LMDB itself, as the py-lmdb guy did, but otherwise I stay out of it.
A couple years back I had good experiences with Panda3D for beginner stuff. It's python-driven and rather high-level. That made it easier to experience the system a game engine provides as a whole. After that it was easier to look into more specific parts (scene management, shading, physics, resource handling and so on).
Are you going to implement any kind of rusty ease-of-use features, like perhaps a macro for building queries?
I've just taken a look at pleingres, and honestly, I'm not sure how to use it. The `Handle` is bound to a specific `Request`... but I can't have more than one `Request` type per connection? So how do I use different queries on a single connection?
Wow, thanks for the great write-up /u/KodrAus. I am pretty stunned with how this has gone so far. Pretty much every time we do one of these, the dozen or so issues they generate are quickly picked up and fixed. It's really inspiring. To get a sense of what's going on, [here is the most recent status update](https://internals.rust-lang.org/t/rust-libz-blitz/5184/104). We've closed (and filed) 113 bugs so far. So there are kind of two sides to the process: combing over crates and filing issues, and then fixing those issues. And it seems like basically as fast as we can file issues people will pick them up and fix them. Right now the balance of manpower is in fixing the issues, so we could use more people running the evaluations and creating the issues in the first place. There's a [recent update here](https://internals.rust-lang.org/t/rust-libz-blitz/5184/80) explaining how to do it, along with a list of crates who's authors don't mind being bombarded with issues and PRs.
This is wonderful.
&gt; which is likely impossible Is it? Doesn't seem like it. You could just Arc&lt;T&gt; everything. I think you'd run into issues with HKT maybe and inheritance might be hacky but ultimately possible.
There are two answers to this, I think. Currently the stated goal is to start from the bottom up, targeting the most fundamental, battle-tested, and most widely used crates. To get an idea of the scope [here's the list we've been working off of](https://public.etherpad-mozilla.org/p/rust-crate-list). This seems a prudent and practical approach to me. But I don't want it to be limited to that list, and I've been meaning to try to pivot a bit for a while, cast a bit wider net. The more crates that release highly-polished 1.0 versions the better (just imagine if at the end of the year we could say there were 20 awesome 1.0 crates released this year, or 50!), and so I'd love to figure out how to make all crate authors feel welcome to participate and excited about their role in shaping the ecosystem. I'm hoping to do some more outreach along these lines soon, and would love ideas about what would be motivating.
Hello! author here, Here is a demo of svgbob, a diagramming model which uses characters that are easily found in your keyboards. I'd be happy to get your feedback and I'll answer some questions. [github project](https://github.com/ivanceras/svgbobrus) Edit: Big thanks to Jan Bujak (koute/stdweb) for his ergnomic stdweb library.
&gt; IDK if you want suggestions for any reason Suggestion are totally welcome. &gt; because the cents are just a holdover from 12TET and a waste of an operation They are still convenient to use. Any constant implies some kind of ET but cents are most common. Also 12EDO has a good appoximation of perfect fifth (700 cents vs 702). &gt; A good exercise would be to write a parser for .scl Scala tuning files, which arbitrarily mix cents and ratios. I'll probably write a `.tun` parser first because it doesn't have to deal with keyboard mappings.
I think your last example is very clear on why the new syntax is needed, thank you again! EDIT, in case the link breaks here is the last example: fn get_default&lt;T: Default&gt;() -&gt; T { Default::default() } fn main() { let def_i32: i32 = get_default(); let def_vec: Vec&lt;i32&gt; = get_default(); println!("{:?} {:?}", def_i32, def_vec); } I had no idea traits could be used as generic return types like this, I was under the impression that traits needed to be boxed or returned by reference. Is it working because the caller resolves the concrete type?
Ok, that makes sense thanks. Btw I see there's a wrapper list on your site and Rust link seems to be broken.
&gt; It has less delimiters. In my experience complex Haskell types are easier to visually parse than Rust types. (YMMV) I think it's fair to say that very few developers agree.
"It looks like... Java" was what one of my coworkers said when they looked at Rust first time.
Yes, one of the most widely used languages in the world. edit: Sorry, thought this was a different thread -_-
The mouseover for inspection of the underlying source is a clever interface. :)
Good question. The way I use it is to use an enum, which also gives me an overview of all possible requests my app can send. I understand you might not like that feature, but after using it for a while, and as my application grew, I started to love it.
Glad you like it.
Hi! You could also use https://nest.pijul.com/pijul_org/sanakirja, a 100% Rust crate inspired by LMDB, but with much less code. It's not (yet) as fast as LMDB, but comes pretty close. The reason I wrote it is that I needed a fork operation on tables in time o(n), where n is the number of entries in the table. In other words, something significantly faster than copying the whole table. That specific operation in Sanakirja is O(log n), and you get two tables that behave totally independently from each other after the "fork". Also, Sanakirja uses types to write things to disk, so you can choose your serialisation scheme based on the type.
/r/playrust is what you're looking for. This is for the rust programming language
I tried the third option and works well. Kinda repetitive though. Need to learn a bit more to use the 2nd I guess. Thank you very much :)
This actually isn't a bad one. The stdlib of Go is small and sane. If you build a good green threading system and make all of the IO async, you can get a lot of benefit of several libs already built for Go. Much easier route than waiting for cross-platform shared lib support in Go.
I get ERR_CONNECTION_REFUSED clicking your link
This article is much better IMO, thanks! :)
On the other hand, surely you have to essentially do... let dbreq = match dbreq { TheTypeYouActuallyWant(req) =&gt; req, _ =&gt; panic!(), } I assume you have a macro for this, or use `From`, but it just feels icky in comparison to handling this internal to the library in a typesafe way - i.e. box the request into a [mopa](https://docs.rs/crate/mopa) type, handle it internally as that, and downgrade it back into the type it was passed in as. Your `Handle` then wouldn't be bound to a specific `Request` type, and `.send_request()` could be typesafe from the consumer's perspective - pass an arbitrary `Request` in, get the same type out.
&gt; Right now the balance of manpower is in fixing the issues, so we could use more people running the evaluations and creating the issues in the first place That's an awesome problem to have :)
Funny story. Niko and I were planning on banking on the libz blitz to generate a bunch of issues, so that we could hold a bug-fixing marathon at our last Boston Rust meetup. But the issues got closed out so quickly that we could only use a couple of them!
What's wrong with? fn example(a: Option&lt;String&gt;, b: Option&lt;String&gt;) -&gt; bool { if let (Some(a), Some(b)) = (a, b) { a == b } else { false } }
Sadly, it results in 1FPS in my Chromium.
It is. The problem really is about uninhabited types: while `!` is usable as is, there are still issues with `Result&lt;T, !&gt;` and how it interacts with `match`, ...
Yes, sorry. Fixed
It's already being actively worked on, and there are new improvements pushed nearly every week. It's mostly an ad-hoc thing, though. That is, someone reports a confusing error message, someone else think "Eh, we could do better" and improves it. So the first step is to actually report which messages you find confusing and why.
Does is_XXX work correctly for every kind of enums, including those with struct variants? You should make sure it does. For unary enums, you can also provide into_XXX and as_XXX methods (the latter returning Option&lt;&amp;T&gt;). In any case, this definitely looks useful! Edit: also as_mut_XXX.
Holy shit! This is really well done!
I'm indeed using From. What you suggest would indeed be great, but is not compatible with other design choices, like using Tokio: the type of "requests" needs to be stored somewhere in the event loop at some point, so it is somehow tied to the connection. Since I don't want to ever restart connections, that somehow forces connections to know a single request type. And you couldn't really use `Box&lt;Request&gt;`, because that would need to be cast anyway. 
What version of chromium are you using? If you use latest browsers then wasm should make things faster.
Thank you! I'll address those when I'm home :) Edit: merged
I've never heard of clippy! I'll check that out! Thanks for the advice :)
Wow, that's a lot cleaner! Thanks for the heads up :) Edit: I've implemented your suggestion. It's on the repo!
59.0.3071.86 64-bit Linux
&gt; Instead I committed a couple of examples to the rust cookbook, so I didn't feel completely useless. That's actually great, the better the cookbook, the easier it is to get started with the library. A great library is useless if nobody manages to use it.
that is how GPL libraries work in any language, yes. LGPL would be a trickier question.
it's pretty snappy for me in Chrome, but very slow on Firefox (win10).
Can you open the developer console logs and look for something like "wasm has loaded..". If you can see it, then wasm is working, if not then the site fallback to the slower js. 
Side note I like this compare of json c/c++ libraries: https://github.com/miloyip/nativejson-benchmark . May be for xml you can find similar c++ libraries compare and take ideas from it. Another side note, it would be good to make possible to disable `include another file` feature in xml parser library, so not render file with something like `&lt;!ENTITY chap5 SYSTEM "/etc/passwd"&gt;`
 Loading webassembly version analytics.js Failed to load resource: net::ERR_BLOCKED_BY_CLIENT main.js:25 wasm has loaded.. svgbob-editor.w.js:190 trying binaryen method: native-wasm printErr @ svgbob-editor.w.js:190 svgbob-editor.w.js:190 asynchronously preparing wasm printErr @ svgbob-editor.w.js:190 svgbob-editor.w.js:190 binaryen method succeeded. printErr @ svgbob-editor.w.js:190 svgbob-editor.w.js:190 run() called, but dependencies remain, so not running printErr @ svgbob-editor.w.js:190 svgbob-editor.w.js:190 pre-main prep time: 837 ms printErr @ svgbob-editor.w.js:190
What does the Firefox develop console say? Did it load the wasm or the asmjs version.
Yes. This one is great. But I spent few days on mine and json one probably take weeks. Also I like this one: http://seriot.ch/parsing_json.php
Doesn't look like Oracle is listed on the [Friends of Rust](https://www.rust-lang.org/en-US/friends.html) page yet. Maybe someone should ask them if they want to be added.
Yep, as I said earlier, the caller decides the type in this case, so it's not "some trait" returned but it's exactly known what type.
These are two different mutability labels. The first one is a mutable reference to AType (*AType* is mutable). This means you can mutate the AType instance. The second is a mutable binding to a mutable reference to AType (the binding, *x*, is mutable). This means you can mutate the name, such as by reassigning it to a new value. 
&gt; Does is_XXX work correctly for every kind of enums, including those with struct variants? You should make sure it does. It doesn't handle struct variants correctly, but I'll be sure to fix this ASAP. It does, however, handle tuple variants of N items, and unit variants as well. &gt; For unary enums, you can also provide into_XXX and as_XXX methods (the latter returning Option&lt;&amp;T&gt;). I want to add this! I'm deferring those features until I get a good grasp on the "gotchas" that I'm not expecting. Thanks for the feedback! Edit: is_XXX generation for struct variants work now. Hooray! \o/
Wasm was working, maybe it could be just RAM, the app is not optimized to memory consumption yet. Do you happen to have a lower RAM?
Thank you! I was mostly interested because I wanted to know whether some of my crates would be applicable. Seems like probably not. &gt; or 50! While 50! would be really awesome number and it would definitely mean IT world take-over, I don't think it's realistic in one year. :'( Upgrading Alex Crichton to publish ~2E54 crates/second doesn't seem to be possible these days.
It's extremely slow in my MacBook Air, for both Chrome (&lt;2fps) and Firefox (~0.2fps). In both cases `native-wasm` was in use.
That is amazing! The only thing I can criticize is the spacing of text, like where it says "statistical charts".
8Gb. Two cores are completely used. i5 3570k. 
Wow, that much? Sorry about that, I'll optimize memory usage next.
No, you could make your code BSD for example, or anything else compatible with GPL. The resulting executable would be GPL'd though. (IANAL)
Thanks, and thanks for the feedback too. The text inside svgbob is only meant for labels in diagrams. It's also hard to do alignment with text since font-stretch is not supported by browsers such as safari, so appending the sentences into 1 text element will drift away the alignment in the diagrams when used as labels. For a more heavy usage of text there is https://ivanceras.github.io/spongedown/ which is just markdown with the svgbob graphs embedded in.
Thanks!
I believe this is a memory consumption issues, I haven't optimize the memory usage of the app yet. I'll address it.
That's why you don't use them either on Windows of OSX.
Obligatory [Nix](http://nixos.org/nix/)/[NixOS](http://nixos.org/) plug. Now if only cargo would push Cargo.lock to crates.io.
This is actually a big pain point in the language currently. The hope is that the `impl Trait` feature (https://github.com/rust-lang/rust/issues/34511) will let you write `tails&lt;T&gt;(slice : &amp;[T]) -&gt; impl Iterator&lt;Item=&amp;[T]&gt;`, so you won't have to write out complex iterator adapter types (or Future adapters, etc.). This isn't currently part of stable Rust, though nightly does have an implementation of this feature. Without `impl Trait`, I'm not sure there is a way to deal with the anonymous closure except for boxing it up (i.e., using Box&lt;Fn&lt;usize, &amp;[T]&gt;&gt; as the type in your complex return type).
Whether transpiling Java or writing a JVM, reference counting isn't quite going to cut it, since Java's garbage collection can handle cycles. I'd either need to wrap Rc/Arc with a cycle collector, or write a garbage collector in Rust from scratch. [EDIT] I've found 2 class file parsers, but they only seem to cover the header and none of the actual methods. Is there any good class file parser I can use, or will I just have to roll my own. I have made a toy JVM in Go so this isn't all new to me.