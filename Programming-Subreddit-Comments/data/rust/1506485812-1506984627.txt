I installed and used Firefox 57 and 58 (https://www.mozilla.org/en-US/firefox/58.0a1/releasenotes/) 20 days ago. Opening 280 tabs for now. Performance seems to be much better than Chrome I just enabled Rust-based WebRenderer (which is disabled by default) to see how it works
I used to be able to build redox with `make all`. Lately for the past few release I can't seem to build it. There would be a few errors to deal with. Right now, it is definition of an unknown language item: `str_eq`. --&gt; &lt;...&gt;/redox/rust/src/libcore/str/mod.rs:1363:1 | 1363 | / fn eq_slice(a: &amp;str, b: &amp;str) -&gt; bool { 1364 | | a.as_bytes() == b.as_bytes() 1365 | | } | |_^ Maybe there should be a corresponding nightly build locked to specific release. Say `tags/0.3.3` using `nightly-2017-09-20`
Fixed. Thanks.
Thanks for taking the time, that's a very good point. Do note that both loadTokenKinds and loadTokens are private and are meant to be called only once from the "constructor" of Board. Both functions exist purely for compartmentalization, testing and self documentation (they will get larger, loading stuff from the hard drive and what not).
In your example, the size of every allocated object is known. A Vec is a pointer, a size and maybe some other things of the same kind. Then the pointer points to a bunch of objects, all of known size. The only unknown thing is the *amount* of these objects.
To memory, there is no difference between an i32 and 10 i32's. To memory, its just 4 bytes or 40. There's really not a lot of difference between not knowing the amount of something, and not knowing something in this context.
Example of a simple website in Hyper
This was a nice read, even if many points are familiar. One small correction: Rust 1.0 dates from May 2015, hardly end of the year (unless you are using a non-Gregorian calendar I don't know of). üòé
Ah thanks. On it. Though one thing I am really interested in is can we use Rust threads in Node?
Keep in mind that `slice::Repr` and `TraitObject` are just library types that *happen* to be compatible, the actual implementation is buried in the compiler. There have been some proposals for "custom DSTs" (e.g. [RFC 1524](https://github.com/rust-lang/rfcs/pull/1524)), which, if ever accepted, would document everything that happens much better.
I read the end and am not quite sure what you're referencing. [Quantum](https://wiki.mozilla.org/Quantum) is an umbrella project for multiple sub-projects. Some of it applies to Android (especially changes to Gecko and the JS engine) and some does not. Android Firefox is definitely benefiting from the changes, but most efforts have been focused on desktop. I suspect that there will be a greater emphasis on polishing and improving Android after the bulk of desktop work has landed.
How does it affect compilation speed?
[There you go](https://www.reddit.com/r/rust/comments/72qhty/this_week_in_rust_201/)!
Those aren't quite the same. The C equivalent of your Rust would be: void main() { char* local = "hello, world"; uintptr_t local_len = 12; } A rust &amp;str is a pointer and a length to something stored elsewhere, in this case some static memory in the .rodata section (not the heap). The Rust equivalent of your C would be something like fn main() { let mut buf = [0u8; 100]; &amp;mut buf[..13].copy_from_slice("hello, world\0".as_bytes()); } which should indeed allocate 100 bytes on the stack and copy the string into it. Bare `str` (without `&amp;`) is a dynamically sized type and can't be placed on the stack, but a u8 array can be.
You don't need signed integers. You can take advantage of wraparounds. Rust has assertions to make sure overflow doesn't happen but only in debug builds. If you want overflow to be checked you have to use the wordy `checked_add` and `try_into` functions.
It's been a while since I've haskelled. How would a reader monad with the `connection`, in this case, be different than the user struct having a field with an immutable reference to the connection, `&amp;Connection`? Would the reader monad do more than just adding syntactic nicety, in not needing to explicitly pass the `connection` each time?
Disclaimer: I'm an author of [enum-map](https://crates.io/crates/enum-map) crate. That said, I still bring it up, because I feel like this is precisely the crate that is useful for this problem. Some time ago I made a crate specifically for this called enum_map. While it currently requires `lazy_static` macro for global variables (or a function returning a map), it otherwise simplifies the syntax. Your example for example looks like this. #[macro_use] extern crate enum_map; #[macro_use] extern crate lazy_static; use enum_map::EnumMap; #[repr(u8)] #[derive(Debug, Copy, Clone)] enum Token { ZERO = 1, DELIM = 2, SPACE = 3, CHAR = 4, } lazy_static! { static ref MAP: EnumMap&lt;u8, Token&gt; = enum_map! { 0 =&gt; Token::ZERO, b' ' =&gt; Token::SPACE, b'A'...b'Z' | b'a'...b'z' =&gt; Token::CHAR, _ =&gt; Token::DELIM, }; } fn main() { for i in MAP.iter() { println!("{:?}", i); } } (also, funnily enough I noticed that somebody suggested `array-macro` crate also created by me, `array-macro` is a low level interface used internally by `enum-map`, that said it's an option if you don't care about indexing an array with `u8` (required by `EnumMap&lt;u8, _&gt;`) instead of `usize`, that said, `EnumMap` does provide `as_slice` method to get a slice indexed by `usize`)
It doesn't require macro recursion limit increase as it's a procedural macro.
No need, Firefox for Android style system is already written in C++. You can reuse JVM integration even after replacing C++ with Rust.
What does that have to do with my comment? It's great that browsers ship dev tools, but the number of users using them is a fringe group.
Sorry, this is all quite off topic, and I am on my phone, so I'll be brief. The reader monad composes functions that take a shared value into another function that takes that value. So within the context of a reader, you can act as if the connection has already been passed in as the first parameter to all the functions, but at the end you get a function that, if passed the connection, will actually do the work under the hood. Uh, maybe [this blog post](http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/) explain it better. (Or myself when I am sober in the morning).
This looks great, thank you.
[I am the happiest nerd!](https://www.reddit.com/r/rust/comments/70szta/hey_rustaceans_got_an_easy_question_ask_here/dncvi1z?context=5)
:D
Maybe you can put some note in readme that array_macro crate is related to enum-map. I have found it using search, and didn't notice enum-map.
Rust is not very good at data-oriented design, but designing programs in a data-oriented way is the most natural way to design Rust programs. Ownership + borrowing make it easier to pass data around than to share data, so the frictionless Rust experience is a purely-functional data-oriented design. When one gets this, writing and testing Rust programs that are fast by default becomes painless. When you have a working program, ownership + borrowing let you optimize a purely-functional program by stepping into shared mutable state without making mistakes. The designs remain data-oriented though. EDIT: what I mean with Rust is not very good at data-oriented design is that currently, abstracting over memory layout in Rust is _hard_. For example, if I initially lay my data in a SoA layout, switching to AoS is painful. Ideally, I would be able to build up iterators that return Proxy references that "abstract over layout", but this is not possible because `Iterator`'s `Item` type must be a `&amp;`. C++'s support for proxy references in the STL1 was hacky, but it at least worked (and in the STL2 proxy references/iterators etc. are first class). 
Are they building a WebKVM ? As in a website/plugin can boot a whole OS through KVM ? 
From [this commit](https://chromium.googlesource.com/chromiumos/platform/crosvm/+/ab839e293da62aaff07d04503538808719ce83d9): &gt; To ensure dependencies don't accidentally get updated, their versions are fixed using the equals constraint. Isn't that what the lock file is for (which they also committed)? Anyone know why they would be doing this? Maybe they're just careful and don't want to accidentally overlook changes in the lock file if there's other changes like adding a dependency.
what apps were bundling Chrome?
yes
The FF debugger is a standalone web app. You can ask for features and [send pull requests](https://github.com/devtools-html/debugger.html)
Going to prototype implementing USB types in Rust
Can you elaborate on the layout? I imagine: 64/32bit ptr to destructor | u8: size | u8: alignment | padding | 64/32bit pointers to trait methods Or is it more like: 64/bit pointer to one trait method | u8: offset to next method | ...
They're all pointer-sized - `size` has to be, `align` could only be `u8` if it were encoding the power of `2` (but it's not, and `u32` is annoying to work with, so it's `usize`). So there isn't any padding. Nor do you need anything like intra-vtable offsets.
For me it's not at the level of Safari yet. It makes the cpu hot, and the scrolling stutter a lot compared to Safari.
Os? For a second I thought this was about optimise small.
It's not. I believe the author saw that the address was nowhere near the stack and assumed that meant it was on the heap. But in reality, it's in the static data section of the executable.
I would recommend `expect` instead of `unwrap`, since you can provide a better crash message in the buggy case. I only use `unwrap` for prototyping. 
It's not really related, it's just used as a dependency for it. array-macro can be used for things that enum-map couldn't be used for at all.
IIRC, you can run `cargo update` to update the indexes of all dependencies and if a newer version of a dependency exists, it'll use that instead, even if you have a lock file. 
I don't think so. That repository is part of the chromiumos project, which contains the base OS tooling for several Google products (chromebook OS, android OS, cloud container OS). I personally think this is an in-house implementation of [kvmtool/lkvm](https://git.kernel.org/pub/scm/linux/kernel/git/will/kvmtool.git/tree/README), with the goal of doing something similar to [Intel ClearContainers](https://clearlinux.org/documentation/clear-containers/architecture-overview.html). But this is just my speculation, I'm not related to Google.
Note that some of the branches are related to Eve which is expected to be the new Chromebook Pixel called the PixelBook. There are rumors that it will take it's containerized approach to Android apps and bolster it with KVM and possibly even rumors of supporting Windows guests. And it's written in Rust. I squealed when I saw this. Very neat.
There's a lot of activity even in core, about 60% more than before. The impl period is at hand, so many cool changes will land. If you want to join in, you just ‚Äì look for work for a great future Rust. https://www.rustaceans.org/findwork
Ops, sorry about that. I will fix it now.
Well if you miss the form fill enough, you can check out bitwarden. You can export your lastpass logins and import them on bitwarden 
It is expected behavior :)
&gt; So not only are its safety checks dynamic They use the hardware page tables, and only eat the performance hit when actually throwing an exception. You can read the details in .. the linked paper, funnily enough. &gt; they also admit false negatives, unlike a sound type system. They do not. What they do not guarantee is that deleted memory are immediately collected, and so if you access memory that you have deleted you may still be able to see it for a while. It seems akin to not guaranteeing "affine" rather than not guaranteeing safety of the type system. This is not new for a garbage collected language, so (as best as I can tell) they aren't changing the semantics, they just don't have an affine type system. If you want to get down on folks about having an unsound type system, ask about why `Box&lt;Any&gt;::downcast`uses a structural hash of the type, and therefore admits false positives.
Of course, you can use cpu pool to execute long computations and wrap it into a future
While you're at it, afaik "LLVM" no longer means "Low Level Virtual Machine" either. LLVM is now just the name. See [here](https://llvm.org/), the first paragraph :)
Glad to hear that. Your blog looks really good, i like the layout, picture choice and your Font ‚Äì those Chinese characters renders pretty well on my machine. Unfortunately i am not very versed in Chinese to read your posts but i like to see things getting done in Rust. 
Oh and if you are a student who wants to go, you can write to me and I would offer you a 50% discount.
But not everyone needs a calendar. My use case for example is very simple. I often need to get Unix timestamp in millisecons. I like how you can do it in Java, there is just one simple function `System.currentTimeMillis()`. And if you want timestamp in seconds you just divide it by 1000, simple. I can't find such function in Rust.
Issues with **v.redd.it**? Try these **Gfycat** mirrors!&amp;#32;^^[Why?](https://github.com/aquelemiguel/vreddit-mirror-bot/wiki/FAQ)&amp;#32;&amp;#32; * [**WEBM** (0.53 MB, Android)](https://giant.gfycat.com/FeminineZanyHoopoe.webm) * [**MP4** (2.16 MB, iOS)](https://giant.gfycat.com/FeminineZanyHoopoe.mp4) *** ^^vredditmirrorbot&amp;#32;|&amp;#32;[Creator](https://github.com/aquelemiguel)&amp;#32;|&amp;#32;[Keep&amp;#32;this&amp;#32;bot&amp;#32;alive&amp;#32;‚ô•Ô∏è](https://github.com/aquelemiguel/vreddit-mirror-bot/wiki/Donations) 
I am so glad you like it, the source code of this blog is in Github now. So if you are interested in this, you could do whatever you want with source code. As for Chinese, I am not a native english speaker, so I think it is reasonable that I write a post in Chinese :)
This subreddit is about the programming language Rust. You may want to go to /r/playrust
 ‚ûú git clone https://chromium.googlesource.com/chromiumos/platform/crosvm ‚ûú cd crosvm ‚ûú tokei ------------------------------------------------------------------------------- Language Files Lines Code Comments Blanks ------------------------------------------------------------------------------- C 1 126 71 37 18 Markdown 1 24 24 0 0 Python 1 235 176 8 51 Rust 82 36215 31954 2593 1668 TOML 13 126 110 0 16 ------------------------------------------------------------------------------- Total 98 36726 32335 2638 1753 ------------------------------------------------------------------------------- Indeed, this is... not nothing.
`b"hello, world\0"` ;)
Eyyyyyyyy we finally got rfold!
It's good to have resources in other languages! :D
What I got from what I have read so far is that this work makes it easier blend in off-GC memory handling into a GCd language. People already have off heap collections in C# and Java to hide from the garbage collector, this facility would make it first class and still be safe. This is great news! This also means that Rust needs to work even harder to be ergonomic since GCd languages can be more efficient in memory handling.
I think it can add higher performance memory handling to GCd languages like C# and Java. Not as correct as Rust and not has memory hungry as vanilla Java.
That makes sense, yeah. I think part of the justification for the "only inspect the function signature" design is that even with private methods, this stuff can get very confusing in larger codebases, where your caller's caller's caller's caller can change (maybe just by becoming `pub`?) and break you.
&gt; Implement Copy/Clone for closures Woohoo! Next thing you know we'll actually be able to treat closures like real types!
`volatile` usually also means "preserve the exact order and size of writes." The sizing restriction is a problem. Color images are most commonly an array of `u32`, but Rust should typically emit SSE instructions that write `[u32; 4]`. `std::ptr::write_volatile` is stable. So is `std::sync::atomics::fence`, and if anything more than `UnsafeCell` is needed, it would be a fence. The source for atomics uses `UnsafeCell` plus atomic op intrinsics. After sleeping on this I think the *most* I need is `UnsafeCell` and a release fence. But it'd be nice to find a guide that covers this wizardry.
Oh, the merged [RFC 2011](https://github.com/rust-lang/rfcs/pull/2011) is gonna be very nice! No more need for `assert_eq!`, just write the expression as you would in an if and it will print nicely. E.g. this: let a = 1; let b = 2; assert!(a == b); Will print this: thread '&lt;main&gt;' panicked at 'assertion failed: Expected: a == b With expansion: 1 == 2'
Several models of Chromebook support containerized Android apps right now but KVM might about increased Android Security or more guest oses 
You should probably change your secret key if not already done since you uploaded them to github: https://github.com/samrayleung/blog/blob/master/Rocket.toml
Sounds plausible to me. ClearContainers for Android apps 
&gt; Is the optimizer allowed to move writes across opaque function calls? I assumed it wasn't, for exactly this reason. Depends on the type. The optimizer is definitely allowed to move writes to a `&amp;mut T` across an opaque function call as long as the borrow is kept across that function call. After all, it's allowed to assume that no-one else has access to `&amp;mut`-borrowed memory, and can therefore essentially do whatever it wants with that memory while it's borrowed. It is *not* allowed to reorder writes to a `*mut T` or a `&amp;UnsafeCell&lt;T&gt;`, since these can alias. Remember: that's a `&amp;`, not a `&amp;mut` to the cell. A `&amp;mut UnsafeCell&lt;T&gt;` is a `&amp;mut` borrow, and therefore a strictly non-aliasing pointer. 
I have no time myself, but I wanted to tell you: You are a good person!
Looks good on mobile...
Happens to the best of us üëç
I assumed that it was a recursive macro, and that using it for such a large array would cause speed problems because actually doing so many recursions would take a long time. However, /u/MysteryManEusine says its actually procedural, which would avoid that issue.
Sorry, I don't understand what you mean by this (I'm a bit slow this morning). Is it just that you can always make a pointer wrap around as /u/Fylwind said?
Would love a minimal example. #lazyweb
Very nice! The writeup is good too, [Google Translate](https://translate.google.com/translate?hl=en&amp;sl=zh-CN&amp;tl=en&amp;u=http%3A%2F%2Fsamray.xyz%2F28) actually does a half-decent job with it (apart from the occasional statement like "cargo is Rust's tectonic system"). I was going to ask for an article about the structure of the blog, but the source code is very simple and easy to read. :-) So briefly, was it easy to get started and make something useful with Rocket and Diesel, or were there parts you had problems with? Also your words about the lack of a Chinese Rust community are interesting, considering I see so many events and meetups and such all over the world mentioned in TWiR (this week: Germany, India, Mexico, and US). I wonder how the Rust community can make that better?
thanks for your heads-up
I'm working on a library sorta like SDL. But inspired by my experiences learning to code during the late 16-bit era. (Tangent to a tangent: the GameShark was a hardware memory patching tool for cartridge systems, suitable for, I dunno, giving your Bulbasaur 500 speed and attack so he can sweep the Elite Four. One of the features on mine could watch the entire memory space and help you sift out the location of variables of interest. This was back when games were written in assembly with everything in global variables. It and MS-DOS with QBASIC were my first real experiences programming.) So, oh man, I really wanted an snes or C64 or... *Amiga*. (Looking back now, this was 200X-ish. I should have gotten a job and ebayed one.) Did you know those systems had hardware that could *blit for you*? That was really exciting at the time. OpenGL doesn't have blitting as a core graphics primitive and that makes me sad. ([Vulkan, though...](https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdBlitImage.html)) I'm not working on an emulator, but I do want to emulate the hardware abstractions of the era. (Fuzzy pixels, phase-modulation sound, sprites, etc...) And do this in software rendering, so that a new programmer can peel back the layers, see that a tile-map is built from blits, which in turn are one `ptr::copy_nonoverlapping` per scanline. Eventually I need to do something fairly opaque to get frames to the screen. But by using the lowest-level primitives reasonable (e.g. with Wayland you blit to shared memory, `attach`, `damage`, `commit`) I can maximize the amount of the "software stack" that is visible and hackable.
Maybe this is the wrong thread, but: is it totally crazy to write a language interpreter, where your "heap" is just a `Vec` of objects and objects point to each other with integer indices instead of real pointers? I'd be doing garbage collection on this array too. I'm asking because this is a lot more straightforward than messing with `unsafe` blocks and real pointers, but I don't know what sort of performance penalty it leads to. I'd be satisfied if it could get to somewhere in the ballpark of Ruby and perhaps CPython.
Someone thank them for LGPL-ing Qt.
I mean `cargo is Rust's build system ` ;-) as for making something useful with Rocket and Diesel, I think this depends on your project, If you want to build a big project, I think Rocket and Diesel is not your first choice, Spring or Django will be better. Because Rocket and Diesel are still immature, they could works fine, but just works fine. Taking my blog for example, I want to use `enum` in Postgresql, but Diesel does not support it, it is a little bit frustrated. Moreover, I have a complex query: SELECT date_trunc('day', access_time) , count(*) FROM visitor_log WHERE access_time&gt; now() - interval '30 days' GROUP BY 1 ORDER BY 1 just count daily page-view, but Diesel doesn't support this query, I have to use `raw_sql()`. Anyway, I am so appreciated about what Diesel does and help from community. As for Chinese Rust community, Chinese Rust community is inactive, just a few guys there, it is a little bit upset for me. Comparing with Golang community, they are so active in China, because Golang is easy to learn and so powerful that a lot of new companies in China choose golang to develop their business :(
Sure thing. We do just that in the [cernan](http://github.com/postmates/cernan) project. We call the feature "programmable filters", documentation [here](https://github.com/postmates/cernan/wiki/Filters). Source code is [here](https://github.com/postmates/cernan/blob/master/src/filter/programmable_filter.rs). The project uses a fork of rust-lua53 for want of this [pull request](https://github.com/jcmoyer/rust-lua53/pull/80) being merged, since cernan has to be buildable on systems without readline. Unfortunately this keeps cernan out of crates, so, uh, don't use my fork, probably. 
Awesome - does Servo use this by chance?
Glad to hear this :)
I'm working on exporting a library interface to the [Ion Shell](https://github.com/redox-os/ion/), initial work [here](https://github.com/redox-os/ion/commit/e9d865605f773e5e6183434185af8f46ec289ede), and using that to develop a distributed job server powered by Tokio + Ion, with a client/multi-node architecture. It will ultimately serve as a replacement for my previous Parallel implementation. So far, I have the service working pretty well. It can receive commands and inputs; spawns N amount of slots per loaded command, where N is the number of cores on the node; and listens for / processes inputs in parallel by generating the commands to be executed within the embedded Ion shell instance. What I have left to do is to obtain the outputs of the embedded shell executions and return them, develop the client that will be used to control the nodes, get TLS/SSL encryption for the connections, and to open source all the work.
It looks like you have // record visitor let ip_address = IpNetwork::from(ip.0); let new_visitor_log = NewVisitorLog::new(&amp;ip_address, 0); NewVisitorLog::insert(&amp;new_visitor_log, db.conn()); repeated a lot. I wonder if you can extract that out.
This is basically what an Arena is. Look up some Arena crates on crates.io to find one that works for what you want. But yeah i don't think it's that crazy
Say you have 16 bit pointers. 0xFFFF could be -1 or 64k but doesn't matter since 2 + that number is 1 no matter which you pick.
Even recursive macrosdo not cause recursion in the compiler so it should be no problem
First off...thanks for Neon! It's been really helpful for a couple of side projects and when I hit a small issue, you made the process of getting a PR merged simple and easy. Next, since you mention wanting the Neon site to be using Neon, have you thought about using Lambda or Cloud Functions? I mention this for a few reasons. One, it would be a quick (and cheap), low-commitment way to add any dynamic features you're wanting to the site without having to overhaul everything. Second, I think there's ways that building for FaaS platforms could positively impact Neon. Neon-cli currently generates a little bit of Javascript glue that's unnecessary when building for those environments. It'd be neat to give the cli have the ability to generate the skeleton for a bare module. And going beyond that, I've been noodling on what it would take to create a project around Neon that's basically [Serverless](https://serverless.com/) for Rust. Also, I'm curious what your stance is on projects designed to interact with or sit on top of Neon. I've got a mostly-complete crate (well...pair of crates) that handles mapping between `JsObject` and Rust structs using procedural macros. This allows me to hide the steps of calling `check::&lt;...&gt;()` and `value()` that makes dealing with a Javascript object feel different than dealing with a Rust struct. Do you have a problem with publishing those crates with a neon- prefix or should I pick a different name? Lastly, I'd love to help, but I'm not sure I have the time commitment or Rust abilities to be a core team member. I think working on some of the documentation/guides might be a good place to start since it would be a good way to improve my own understanding of Neon while being helpful. Has anyone signed up for that task yet?
That's what I thought, thanks.
What do you mean repeat a lot. Well, I think it works well, I could extract this out. And in your opinion, what is the best practice ? just try to improve my Rust code :)
Nice. As a Rust fanboy, I'd like to try this, but as a Vivaldi user, I'm not sure if it has everything I use. Namely tab stacks. I like having all my TVTropes tabs only take up the space of 1.
This is how I once implemented a Forth in Java, so basically, yes, go ahead.
&gt; whatever language is the Next Big Thing will have a safety model derived from Rust. I certainly hope so... there's nothing worst than regression :(
It should not. They rely on a segmentation fault signal being raised by the system, and *this* check occurs in hardware/OS for every single pointer dereference of C, C++ or Rust anyway.
&gt; We do not guarantee that all dereferences to deleted objects will throw an exception. While the weaker semantics is crucial for achieving good performance, it introduces non-determinism and may result in exceptions that only surface during real use. I understand this in two ways: 1. Since pages are handed back to the OS only when more empty than full, it is possible to access an object after its destructor has run. This means that you may sometimes get an exception and sometimes not. 2. Compiler transformations may result in a deferred load of the pointed-to content, and since the exception is only triggered by actual access to the content it may be delayed. A typical example would be passing `foo-&gt;bar` to a function when `foo` points to deleted content: the error will only occur when someone uses `bar` (and will not if it is not accessed at all).
True, though it seems to be largely generated source with bindgen that is adding to those numbers, I guess if you broke it down by crate though (not familiar with tokei)
Pretty sure it is not, as I would expect far more downloads were that the case.
I've immediately recognized the Firewatch background. :) . I really enjoyed it too.
Yeah, that makes sense - thanks.
"Extracting it out" means making it into a separate function, so that you don't repeat the same three lines in many places, but rather just call that function. 
Thanks, that makes more sense 
I think it would work as a separate function. I really love this btw. Great project.
My understanding (could be wrong) is that they do not hand the pages back to the OS, but just undo their bindings and trap on page faults. The trap then wanders off and double-checks the validity (because they may un-map a page with some valid data, and need to do the lazy copy). I think I mis-spoke when I said "aren't changing the semantics". They introduce a new operator, and it's semantics are: once you call `delete`, the destructor may run in the future. If you access the binding after `delete` (which would be a logic bug) you may or may not get an exception, but you will not see invalid data.
Maybe, but you could drop in unit tests to check the performance critical functions. I would consider this to be a compiler issue since a quick Google search shows people saying that llvm should optimize a consecutive integer match statement like this into a lookup table. This is also more appropriate symbolically. What you want is 'given x, I want y'. I'm not sure if there's ever a case where it would be faster to not do a lookup table, but doing it as a match statement does leave the compiler free to make that optimization. Perhaps if / when simd is added, doing 16 u8s at once would be faster than a lookup table for each one (not sure if any compiler wpuld do that optimization though).
Have you looked at phf or phf_codegen?
The Tree Style Tabs addon exists and works on Nightly/Beta.
Sounds interesting, but I have zero time right now.
it's noticeably faster right now if you're not on nightly (or beta now i guess) nightly is really nice though
Thanks, I try my best, but I am probably not always a particularily good person.
I don't know anything about chinese fonts but this is some of the best looking chinese text I've seen I think (as someone who can't read it).
Cool blog and I admire you writing the whole blog platform from the ground up. It's a little late to ask, but did you ever think of using a static site generator for your blog? There is a decent one written in rust called [cobalt](https://github.com/cobalt-org/cobalt.rs).
Nope! I've seen those called allocation pools or slabs, especially if they are homogeneous. You may still want `unsafe` to store objects of different types together. But that's a lot less scary since you mostly only need to worry about trap representations and alignment.
I am not aware of such a function in rust, although you can take [this stackoverflow answer](https://stackoverflow.com/a/44378174/25616). If you're willing to use the `time` crate, *that* Duration has a [`num_milliseconds`](https://doc.rust-lang.org/time/time/struct.Duration.html#method.num_milliseconds) method, which is convenient. There is [some conversation](https://github.com/rust-lang/rfcs/issues/1545#issuecomment-197352364) about why it's so inconvenient to use the built-in `Duration` type for this specific purpose in an RFC to enhance it.
Don't cheer just yet, I proposed exactly this four years ago and it was declined because `assert_eq` has stricter semantics than `assert`. I don't see this addressed anywhere in the RFC text. I've left a comment at the tracking issue: https://github.com/rust-lang/rust/issues/44838#issuecomment-332620616 EDIT: Fortunately it looks like the cause for my concern was obviated a while back; that's what I get for checking in on an issue once every four years. :P
Âä†Ê≤πÔºÅ
I've been doing this with rlua and it's worked great so far! I've also gotten a lot of miles with [rust-lua](https://github.com/kballard/rust-lua), but its API is much lower level and there's a [serious issue with it](https://github.com/kballard/rust-lua/issues/1).
in case anyone references this later, I ended up making the geolookup status part of the photo struct.
Rayon has a `spawn_future` method [which is currently underdocumented.](https://github.com/nikomatsakis/rayon/issues/234) I think putting together a working example or three is within my abilities, but I'm pretty busy until next week. Maybe then.
It's so pretty. I love a good font that's just really clean and clear
They used crates.io for the attack? That's nuts and really clever.
Interesting crate! I think you could implement this using a binary search to improve performance when there are many parts.
Looks nice! it would be better if you have `/article-slug-url.html` instead of `/26` (article id) Using IDs is not a good practice and also does not help for search.
To be pedantic rust functions are already partial(there are very few languages where functions are total).
Couldn't this be achieved with a macro, with no runtime overhead?
I'm not sure how much that would improve performance, as I'm only making the bound integrity check when adding a function under the debug mode. Mind explaining with a little bit more detail?
That implementation period almost sounds like Eclipse coordinated releases... but much more open and welcoming and approachable.
I switched because it was faster. I switched back because I preferred Mozilla's dedication to the open web to Google. I've tried to convince people to switch back, but they say that they won't use a slower browser. If Firefox can beat Chrome in benchmarks, techies will notice, and people listen to techies. It doesn't actually matter too much whether it's a better product, as long as the techies tell people it is, and the best way to do that is to win at benchmarks. That's how I got my parents to switch from IE (I was their techie) and that's how most of my non-techie friends switched as well. People like using what technically literate people use. I don't know if they'll beat Chrome, but they'll definitely get a *lot* more people switching if they can win the benchmarks and stay on top for awhile.
Interesting idea, I will look into it. Thanks!
Eh, I have all sorts of problems with both Chrome and Firefox for web-developing. I mostly use Firefox, but occasionally need to switch to Chrome. However, if I use Chrome for awhile, I get annoyed and need to switch back. They feel different, but they're both good web development tools.
You're duplicating the "published posts" logic a lot in https://github.com/samrayleung/blog/blob/master/src/dal/models/post.rs. Have you thought about pulling it out into a function? fn published() -&gt; posts::BoxedQuery&lt;'static, Pg&gt; { use self::posts::dsl::*; posts.filter(published) .order(create_time.desc()) .into_boxed() } If you don't want to box it, you'll just need to write out the return type: use diesel::helper_types::*; use diesel::expression::operators::Desc; type PublishedPosts = Order&lt;Filter&lt;posts::table, posts::published&gt;, Desc&lt;posts::create_time&gt;&gt;; fn published() -&gt; PublishedPosts use self::posts::dsl::*; posts.filter(published).order(create_time.desc()) }
The lower memory usage will probably be the biggest win. I honestly wish I could install Firefox on my wife's Chromebook...
Well, webrender (landing fairly soon, they say 58 or 59) will use the GPU a lot, which may make supporting Wayland a lot easier (not sure how much legacy X11-specific stuff there is). If it gets Wayland support, I may just build a simple kiosk-style computer for visitors to use.
So far I like bitwarden a lot. I just wish it worked with FF for Android (it's not working for me, not sure if I'm alone in this).
And with WebAssembly, the JavaScript engine will hopefully matter less and less since intensive parts of web applications will be ported to WASM.
 I gather from [this](https://github.com/rust-lang/rust/issues/19733) that the behaviour of `*mut _` is still not specified. Hence the `UnsafeCell&lt;*mut _&gt;`
I gave up on waiting for lastpass' compatible version of Firefox (that was last year though) and I ended up using a CLI password manager called [pass](https://www.passwordstore.org/). You can have cross-platform behavior by sharing your encrypted directory of passwords via something like Dropbox. The one thing that will slow you down is learning PGP and the `gpg` tool in order to understand how to properly share your passwords across your machines. That was a great learning experience for me, though painful at first.
I just wrote a toy program to compute the SHA512 of stdin. Here it is [on the playground](https://play.rust-lang.org/?gist=c0aaaeff288c2614dd9aa0a2914fbab9&amp;version=stable). A funny thing I noticed is that, when I give it a large file of input (a few gigs), it's consistently *faster* in debug mode than in release mode, by about 1-2%. I don't have any practice reading assembly, but is it obvious to anyone else why that might be?
I wrote process management tool [fectl](https://github.com/fafhrd91/fectl) with actix. It naturally fits into Actor model. It has multiple agents, which monitors externals processes, it accepts console commands via unix domain socket and most process related operations are asynchronous.
That's great news. The impl period has great facets of the language and tooling picked. Looks like 2018 will be the best year for Rust yet.
Today I had the time to come back to my rust project again after a hiatus. I switched my VScode extension from kalita-alexey's to the brand new rust-lang team's extension (to see if it fixed some problems I had with the previous extension) and made sure to replace previous settings. It came up with all kinds of rustup related errors. I tried to run the rustup update command from the command line to find out that the command is not recognised some reason on my computer, as if it does not exist. Then, I reinstalled rustup and it updated everything. I can remember that sometime during this, my Mcafee antivirus notified me that it removed some wierd file with a virus-sounding name in some .cargo related directory, but unfortunately I did not write down the specifics. I have done everything I can to try to find what it deleted, but I cannot find it. It seems that every rust related extension or command has gone haywire and produces too many kinds of errors and garbage for me to write here. I have no idea what to do or what to reinstall. Also, I should note that every rust extension I have ever tried in VScode fails in some way, and I can only use some of the features.
LLVM IR is a representation of machine code that is independent of the source language. x86 machine code is also independent of the source language, as are many other instruction sets. Just because LLVM IR is not x86 machine code doesn't mean "rustc" isn't a compiler. Is Clang a C compiler? All it does is generate LLVM IR. Not even "real" machine code. So, LLVM IR is a perfectly valid target for a compiler to compile to. Clang and Rust are both compilers, even though they're just frontends for LLVM, which takes the further step of lowering the IR to machine code. If all you have is a compiler that generates x86 machine code, and all you have is an ARM computer, you won't be able to build and use that compiler on that architecture either. LLVM IR is kinda like that. Cretonne is a backend written in Rust that is being developed as an LLVM alternative, but it doesn't change whether Rust is self hosting until then or not. You can't use (most) compilers without an operating system. Does the operating system mean those compilers are no longer self-hosting too? "self-hosting" means different things to different people.
I'm not very familiar with design-by-contract, but this is like putting asserts at the beginning and end of a function right? So these checks are done at runtime?
Oh, get it. thanks for your suggestion :)
thanks you, so glad you love this
thanks for your suggestion, I know the project has some boilerplate code, but I am not skillful enough to reduce it. you help me point it out :)
Ë∞¢Ë∞¢Âìà
thanks you for your heads-up 
&gt; impl Version&lt;1.0&gt; for Diesel `trait Version&lt;const N: f32&gt; { ‚Ä¶ }` Doesn‚Äôt strike me as quite so useful with floats as with integers, but hey, maybe someone can come up with a good use-case for it.
Glad to see I'm not the only one that's been playing with ideas for an actor system based on tokio. I've been working on one called aktorio, and recently been experimenting with running each actor on it's own thread/event loop at https://github.com/mr-byte/aktorio/tree/threaded_test So far I've been really happy with the direction it's been going. I've made some different API choices, but hopefully the frameworks can cross-pollinate ideas.
could you provide some simple example how your system works. it is hard to understand without example 
Too bad that floats can't represent version numbers with format Major.Minor.Patch!
Interesting. But llvm is a big part of the rust compiler. Clang is also written in c++. Which llvm is. It's self hosted imo. I get what you are saying about the other stuff but you have to draw some line depending on context. 
I'm guessing he means putting it in a if block with a macro would remove the need for a function call. But I think the same result could be obtained by defining your functions as inline (on mobile so if you're already doing this ignore me) Edit: actually I think the greatest benefit would be not needing an anonymous function. 
Thanks for running this, and awesome work to both candidates. I like the trait/`as` trick (and it seems like something clippy could flag, if not the language itself improving), and using crates.io's JSON to feed in secret information is... amazing.
is a C compiler written in C++ self hosting, since C is not a strict subset of C++ and especially vice versa? That's an odd definition, since I was talking about the C compiler mode of Clang. I recognize that Clang supports both C and C++, of course -- but I wasn't really even talking about whether it is self hosting or not, just pointing out that we can call Clang a compiler, even though its job stops at handing IR over to LLVM. But, it all depends on where you draw the line.
&gt; [Make the fallback of generator resumption be unreachable instead of using return](https://github.com/rust-lang/rust/pull/44747) I'm curious what the effect/reasoning of this was? Does it just improve the code generation/performance?
Yeah I guess. For me in this context, it would mean the rust compiler and backend are 90(or what ever a massive majority) if not 100 percent rust. Ie I can cargo build on any machine that as rust and cargo. Cretonne looks cool btw. I really like it. If I could get a gccrust frontend I would also be happy ;) I would take a crack at Mir to gcc but frankly their docs are not amazing. I can't really find any examples or good documentation about the internals and I don't have the time to dig through the source. It might be easier than I think though. But compared to llvm I doubt it would be. Writing a llvm frontend is so trivial. 
I tend to use tab stacks for reducing clutter in the tab bar as much as for grouping tabs. From what I can tell, tree-style tabs still display all sub tabs in the main bar. Another feature of Vivaldi I like is distraction-free mode that gives a header with nothing but the name of the page and the rest of the screen is for content. I consider it a better fullscreen mode on my macbook. A also like how Vivaldi can change parts of its colour scheme to match the website being viewed. Oh, and fast forward is amazing which binging Web Serials and Web Comics. It doesn't seem as though Firefox allows customizing the colour scheme of the reading mode and will only make the text so wide. My monitor supports 1920 pixels across and I want to use them. Also, the reader mode configuration bar is rather intrusive rather than a small gear icon in the corner. Especially jarring with the dark scheme because the bar stays bright and is more attention grabbing than what I'm trying to read. Another thing I use often is the F2 quick menu that lets me search my tabs, history, and settings to quickly find the page or action I want. Is it possible to hide a DOM element without deleting it entirely? These are all Vivaldi features that I've found myself missing in just 1 day.
As what I‚Äôm currently working on is still *very* much in the proof of concept stage and not ready for anything even alpha quality, I haven‚Äôt really added any documentation or examples other than what‚Äôs currently in the main.rs I use for testing purposes: https://github.com/Mr-Byte/aktorio/blob/threaded_test/src/main.rs Once I‚Äôve stabilized the interface and what I plan to do with the system in general, I‚Äôm going to buckle down on documentation and examples.
I see. my use case is different, main reason for actix, I needed simpler way how to create async control flow. if you just need async function, futures already works pretty well.
&gt; From what I can tell, tree-style tabs still display all sub tabs in the main bar. No, you can collapse subtrees
Correct! The idea is to do your own checks, but putting those checks into each "bucket" clarifies their intent, and can actually become part of a formal design process that encourages better thinking and design. Proponents of DbC may even think the consideration of pre- and post-conditions so important that they make it an essential part of the software design process (see http://m.wikipedia.org/wiki/Design_by_contract#Description for some more info). So, you could think of it that way -- some take it even farther and make it an integral part of their design workflow. :)
QQ Group: 303838735 RustÁºñÁ®ãËØ≠Ë®ÄÁ§æÂå∫
Also, since `PartialFunction.eval()` returns an `Option` - one could argue it's a "more total"(can still panic, but for what seems to be the indented usage more likely to return `None` in these cases)
QQ Group: 303838735 RustÁºñÁ®ãËØ≠Ë®ÄÁ§æÂå∫
&gt; Ie I can cargo build on any machine that as rust and cargo. Is this not currently true? To _have rust on a machine at all_ you need to have LLVM, as it's included as part of `rustc`. My definition of self-hosted would be that the compiler can be compiled by the same means a regular project in the language can be. Rustc uses LLVM to compile all rust programs, not just rustc, so does that really make it not self-hosting?
In the Tree Style Tab panel, yes. How do you do the same for the tab bar at the top? Since Vivaldi is written mostly in HTML, CSS and Javascript, it would be awesome if it were possible to switch it's backend from being Chrome based to Firefox based. Same with Electron.
That tab bar isn't supposed to be there, future versions of the addon will hide the top bar (this API just doesn't exist yet)
So if I don't have a c++ compiler and just a rustc/cargo I can git clone rust and build? At some point llvm binaries have to be compiled and you can't use rustc for that. There is no way it can be compiled like a regular rust program. I any be misunderstanding what you are saying though. 
Oh, OK. Got it! Thanks!
What??! This is great. I can actually see where this could come in amazingly handy in dealing with edge cases, which is strange because I don't remember anything like this being in C. Is that just a result of Rust being more functional?
‰Ω†Âèë‰∫Ü‰∏§ÈÅç‰∫Ü :), Ê≠§Â§ñÔºåÊàë‰πüÁúãÂà∞ËøáËøô‰∏™Áæ§Âè∑‰∫ÜÔºå‰ΩÜÊòØÊàë‰∏çÂ§™‰π†ÊÉØÁî®QQÊù•‰∫§ÊµÅÊäÄÊúØÔºåQQÁæ§Â§™ÂÆπÊòìÂèòÊ∞¥ÔºéÊàë‰∏ÄÁõ¥ËßâÂæóËÆ∫ÂùõÔºåÈÇÆ‰ª∂ÔºåÁîöËá≥ÊòØgitterÊòØÊõ¥Â•ΩÁöÑÈÄâÊã©ÔºéË¶Å‰ªéÊµ∑ÈáèÁöÑËÅäÂ§©‰ø°ÊÅØ‰∏≠ÊâæÂá∫ÊúâÁî®ÁöÑ‰ø°ÊÅØÂÆûÂú®Â§™ËÄóË¥πÁ≤æÂäõ :(
Git branches are pretty great for this... I do exploratory work in branches a lot, and sometimes just throw it all away.
I‚Äôm not sure I understand what you‚Äôre saying here. What I‚Äôve written is a system that spawns actors with a mailbox that you can message asynchronously, including piping the results of existing futures and streams to those mailboxes, while also spawning sinks as actors with their own mailboxes. It includes supervision of actors, etc.
I am running the beta now. I have 6 tabs open and each use 250 MB memory. Anyone else experiencing this? 
Well, the build instructions are in the [main respository readme](https://github.com/rust-lang/rust). It's not *quite* that simple. 
Wouldn't piecewise functions be a more accurate name? In any case, this seems neat.
Yeah, but modulo panics and termination, Rust is about as total as they come.
That's like saying 'modulo runtime exceptions &lt;almost any language&gt; is as total as they come'.
Write web page in Rust is not that easy, anyway good job.
To clarify. There is no big difference between this PR and the original one. A GitHub glitch forced us to create a new PR. 
Would be interesting to know how this compares to [Akka Typed](https://doc.akka.io/docs/akka/current/scala/typed.html) and [kabuki](https://github.com/carllerche/kabuki)? Could this hypothetically be moved to a distributed model? That would be cool :3
I mean, Rust eliminates partial pattern matches, null dereference, runtime type errors. The allowable errors are much more controlled than almost any other language.
Looking at using [rusttype](https://github.com/redox-os/rusttype) to make an [ROV](https://en.wikipedia.org/wiki/Remotely_operated_underwater_vehicle) interface pretty. The interface currently uses SDL to render everything. I considered switching to [ggez](http://ggez.rs/) because it has text rendering figured out, but my dev machine is stuck on OpenGL 2.1, [which is not yet supported](https://github.com/ggez/ggez/issues/143). :( Also planning on testing a REST API server I made with [diesel](http://diesel.rs/) and [hyper](https://hyper.rs/). It monitors a bunch of sensors, stores it in a database, and then exposes the data to other programs.
**Remotely operated underwater vehicle** A remotely operated underwater vehicle (ROV) is a tethered underwater mobile device. This meaning is different from remote control vehicles operating on land or in the air. ROVs are unoccupied, highly maneuverable, and operated by a crew aboard a vessel. They are common in deep water industries such as offshore hydrocarbon extraction. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
I have plans to add remote actors, just don't have enough time for everything :) any help is welcome!
I should be more clear. I am talking about more coarse actors, with complex logic inside.
I mean, my example there is basic simply because I‚Äôm testing the message passing aspect. I had no reason to make the logic of the actors complex for simple testing purposes. The application I‚Äôm using it in, has much more complex logic inside the actors themselves, including state machines and such.
Who invented floats? That's a design flaw! 
&gt; Rust needs to work even harder to be ergonomic since GCd languages can be more efficient in memory handling. Can be, theoretically, but most times they are not
You can totally do this in C or C++ with some dynamic dispatch.
I was unclear. This work shows how to enable GCd languages to be more efficient with memory via optional calls to `free`. So this increases the applicability of C# and Java and makes Rust jobs harder. 
&gt; Focus documentation primarily on `tokio`, rather than on `tokio-proto`. What's the reason / motivation here? Just that `tokio` needs better docs, or should I be preferring that over `tokio-proto`?
The RFC goes into the motivation for that in the motivation section: https://github.com/tokio-rs/tokio-rfcs/pull/3/files#diff-43595030113cf2d46e4316911bbf1389R57
Take a look at the RFC. One of the most common bits of feedback the Tokio team received is that the docs were confusing because they focused so much on tokio-proto, which is the part of the stack people are least likely to use. Not only does it have the narrowest use case, it also hasn't proved itself as a useful abstraction for its original intent. Part of the RFC is about de-emphasizing it.
Yes! There are currently two ways: you can "lock" the JS VM and synchronously do a multithreaded Rust computation, or you can asynchronously spawn a Rust computation in the libuv thread pool and have the result sent to a JS callback. I need to write guides about both of these use cases! In the meantime you can always ping me on slack for more details.
That's awesome, thank you so much!!
All contributions large and small are deeply appreciated! No need to sign up for any great commitment. :) I haven't given any though to serverless, mostly because I haven't learned it yet! Want to drop in the slack some time and tell me more? Feel free to use `neon-` in the name of your crates, but thank you very much for asking. Just FYI, I'm planning on expanding the main macro syntax to eliminate a lot of that boilerplate. I completely agree those idioms need abstraction. Documentation and guide help would be awesome! I think maybe what I should do is create a big checklist of all the things that need good examples so we can coordinate.
Not a problem, thanks for considering it. :)
Nope. https://en.wikipedia.org/wiki/Partial_function
Right, a partial function is just a function that operates on some subset of the domain, and is undefined elsewhere. Each function that is defined in a with call is a partial function, but the stitching of them together, and that they're specified in terms of pieces of the domain, makes them piecewise. And there's no reason you can't define a total function this way. Partial functions are a well known concept in programming languages, and basically can be expressed safely using Option, or unsafely using panic or non termination. But the concept is separate from defining the function in terms of pieces of the domain.
The compiler could eliminate the checks, and warn in the cases where they cannot be eliminated by using something like Z3.
You're right, thx!
Nobody uses Brave, Vivaldi, Safari, Gnome Web even if they all beat or at least are the same as Chrome in terms of performance. Google marketing people are not idiots, they invest in showing banners everywhere because it works.
Try the Beta for Android. Auto fill does not work, but you can view and copy passwords. Also they have an Android app which I think works better.
Yes, it is Firewatch background, is it ok that I use it as my blog background ? 
Did you consider choosing D? I feel like it's the main alternative to Rust when wanting something more ergonomic than C++.
Yes, something like [LiquidHaskell](https://github.com/ucsd-progsys/liquidhaskell) or [Stainless](https://github.com/epfl-lara/stainless) for Rust would be great for improving safety (and/or performance) even more.
Does anyone know if any of these attacks are resulting in concrete actions to avoid them happening in real life? Maybe introducing new lints?
Hey, I am the primary author of the rlua crate, and I'm happy to answer any questions. I wrote up a small example for you that I hope demonstrates the sort of thing you want to do. I understand how rlua can be a bit confusing, especially since a lot of times it requires a lot more type annotations and weird tuple wrapping than using "normal" rust. It sounds like what you need to do is pretty simple, so hopefully it won't be too bad. https://gist.github.com/kyren/b19d6e921343176cfdaad3eac1a24335 you can just write any old lua script and give it as an argument, but just for completion here was the one I used to test the code I just gave you: https://gist.github.com/kyren/ccdc63edad0dc2715660c31a656301e7
I think that the only thing that's unspecified at the moment is exactly how `*mut _` and `&amp;_` interact. I believe that `*mut _` itself is well-defined. While I'm not exactly sure what you're trying to do, I'm fairly confident that `UnsafeCell&lt;*mut _&gt;` is the wrong type. This type represents the case where the pointer *value* itself can have aliasing pointers *to* it. That is: you can mutate the pointer itself, so that it points somewhere else, though a shared ref `&amp;UnsafeCell&lt;*mut _&gt;`. If you want an aliasing+mutable pointers to something, use `*mut _`, or maybe something like `&amp;UnsafeCell&lt;_&gt;` or `&amp;[UnsafeCell&lt;_&gt;]`. If you want reads and writes to be side-effects, use the `std::ptr::*_volatile` functions, or manually emit fences. A cell in Rust is not volatile. 
How can I generate a random number to a certain range. Like from 0 to 10 using the rand crate. A way I have thought of doing it is by random_number%10. But this feels sort of restricting. Let's say I want to generate a random number from 1 to 27 then it gets complicated. I have looked the documentation and haven't gotten much help from it. https://docs.rs/rand/0.3.16/rand/
It sounds like you'd be wanting the [`gen_range`](https://docs.rs/rand/0.3.16/rand/trait.Rng.html#method.gen_range) function.
Thanks that is what I was looking for.
We should add semver primitives.
Nope. The community and ecosystem are very important factors in our decision-making when choosing a language...
&gt; I can git clone rust and build? No. The same way as any other language. &gt;if I don't have a c++ compiler LLVM is not a strictly C++ compiler. For example, Swift language also uses LLVM, but compiler itself written in C++. Dot it makes it self hosted in your terms?
No I meant llvm is written in c++. And also no. I can git clone llvm/clang or gcc and build with just a c++ compiler. 
I'm sorry what? I don't meant be rude but none of those things are true. Llvm is written in c++ and would have it's ir for testing among other things. And it is not written in assembly. Did you even look at it's source? It has to include assembly because it is a compiler that Targets it. But none of logic is in assembly. 
Also once again I know most need an operating system. But for this context I'm not counting that. 
I think ‚Äúrustc is necessary to build rustc‚Äù makes it qualify as a bootstrapping / self-hosted compiler, even though ‚Äúrustc is *sufficient* to build rustc‚Äù is not true.
Thanks!
Doesn't rust already do all these optimizations? The main benefit of a macro here would be nicer syntax: https://play.rust-lang.org/?gist=b587ffe9e78275592b13b0f5cb4dc8a2&amp;version=stable Note that I created an helper macro - `ineq!`. It allows writing chained inequalities - so instead of `0.0 &lt;= x &amp;&amp; x &lt; 20.0` we can write `ineq![0.0 &lt;= x &lt; 20.0]`. This makes it easy to make the branches accept regular conditions while still having a nice is-in-range syntax.
I extremely disagree. This might be a agree to disagree moment, but I could give you it bootstraps because you need it. But it is not self hosted. This is from the Wikipedia article. Rustc REQUIRES a llvm binary at the least. you CANNOT use rustc to generate that. Therefore it is not a fully self hosted compiler. If this was the case the go 1.4 compiler would be considered self hosted as well. If what you are saying is technically correct, then what is it called when you don't need dependencies besides that written in the target language. Rust needs that then. 
I was interested in doing this as a macro and it turned out to be surprisingly easy (although I haven't spent too much time fine-tuning the syntax): [playground](https://play.rust-lang.org/?gist=8850ec9348a52bb1e61d266ac9a81c01&amp;version=stable). It doesn't have the debug-time bounds checking which is a pretty neat feature in your library (although I think it could be added with a little extra work).
It's both!
why does `.build()` not return a closure which you can simply call? eg: let levels = PartialFunction::new() .with(0.0,20.0,|x| 1) .with(20.0,40.0,|x| 2) .build(); let level = levels(20.0).unwrap_or(-1); not much of an improvement, but somehow makes more sense in my brain :D edit: unfortunately this does not yet work: https://play.rust-lang.org/?gist=c14b5973ef2ba696ae05ba42f3eef26e&amp;version=nightly
Sorry OP wrong subreddit. This subreddit is dedicated to a programming language called Rust.
You want /r/playrust
* Brave - based on Chromium, so theoretically comparable to Chrome in speed, but it's still in Beta, so it's not even released (except on mobile) * Vivaldi - based on Chromium and is trying to have the featureset of Opera, and it's only been released for a year, yet according to Wikipedia it already has 1M users * safari - Mac OS only, and yes, lots of Apple users use it * GNOME web browser - definitely not faster than Chrome, only works on Linux and is missing lots of features; Konquerer is the same way So, the browsers you mentioned are either locked to a platform or so new that they haven't been able to get any traction. Firefox is well known, so it just needs to fix the main issues techies have been complaining about to regain quite a bit if it's market share, and I don't think 30% is out of the question within the next couple years if they can capture the interest of techies.
The Android app works pretty well, but I really liked the ability to one-click add a password to my vault, and the Android app doesn't recognize passwords in Firefox. I'll try the beta, hopefully it works!
panics are safe
Opera has been around since forever and has the same performance as Chrome with more features. Nobody uses it. Why? Because youtube, google search, google translate, G maps and the others do not tell users to install Opera. Also Chrome is bundleware. It has been installed as par of other programs. 
It's always nice when one's concerns get deprecated
I don‚Äôt know about anyone else, but this is where my own usage of ‚Äúbootstrapping‚Äù differs from that of ‚Äúself-hosting‚Äù: in the former, a Rust compiler is *necessary* to build `rustc`, whereas in the latter, a Rust compiler is *sufficient* to build `rustc`.
Finally the 8 cores on my phone are getting some appropriate use.
Path.join throws away preceding path if path being sdded is absolute? Seems buggy to me.... 
Opera is a unique case and I'm convinced they're less popular because they're proprietary. Many techies are open source supporters, so if it doesn't absolutely blow the competition out of the water, techies will use the next best thing, and Chrome is mostly open source. Opera could do also do a better job at marketing, and it's kind of embarrassing that Firefox beats then at that. However,. That's not the *only* reason people use browsers. Edge advertises quite a bit, yet it still doesn't compete well against Chrome even though they have a captive audience, and I blame this on their bad track record with IE.
They used it as a side communication channel to configure the exploit.
&gt; Most modern languages don‚Äôt have this distinction I disagree. Java is the exception, not the rule, for languages with static type checking.
My goal is a pointer type that allows mutation while advising the compiler that aliasing my exist even though it cannot be detected by data dependency analysis. To give a specific example: I have a function that writes to a framebuffer in shared memory and then makes an FFI call identifying which framebuffer I chose to write to. The framebuffer id identifier is an opaque u32. So assume my function, written in safe Rust: - makes a call to find a free framebuffer - this call returns a pointer to the buffer and the ID needed for FFI `(&amp;'_ mut, u32) - it calls a Rust function to fill the frame buffer - then another Rust function that wraps the unsafe FFI Assume the compiler inlines or at least examines the first call and determines it to be pure. The second call can't be proven pure because it isn't. Because it can't see that the buffer is aliased, it is allowed to execute the side-effect before, after, or during the pure computation. This incorrectly defined behaviour causes an observable compile-time bug when three factors align: - the compiler views a subprogram that contains both the modification of the framebuffer and FFI involving it. - the compiler marks a pure function as pure. Rust doesn't have a way to declare that a function is pure, but the compiler may examine it and discover purity. - the pointer argument to the pure function is marked not aliased (C11 `restrict`). This isn't the default in C but it is in Rust. If I work with `(UnsafeCell&lt;*mut [Color32]&gt;, BufferID)` (note that the UnsafeCell is passed by value) that will suppress the non-aliased declaration. `&amp;mut [Color32]` would have the above problem. The thing that's not clear to me from the docs is what `*mut [Color32]` would mean - it seems to not be specified as part of the "Rust needs a memory model" issue. Using `volatile` would work by making the framebuffer-updating function impure. But it would also force the compiler to always emit 32-bit store instructions even when it could use 128-bit SSE instructions. --- That said, I kinda feel that a struct with the shape of `(*mut [T], PhantomData&lt;[UnsafeCell&lt;T&gt;]&gt;)` expresses the intent better. 
Maybe that‚Äôs the difference between ‚Äú(partially) self-hosted‚Äù and ‚Äúfull self-hosted‚Äù? Anyway, I don‚Äôt really understand why not needing anything other than a compiler to build that compiler is an interesting property.
Because it's a dependency in another language that requires another compiler. Rust isn't going to replace C or c++ if it relies on llvm
Yeah I pretty much agree with that.
That is the intended behavior because it designed to work like a relative directory. You can have a configuration flag that sets where to store a file and allow your users to avoid having to play `..` games to go up. It isn't made to take an untrusted string.
I can comment with /* and */ in Rust. But it seems it's not used in crates and I did not found a documentation about this. Is it an hidden feature?
It's not "hidden" in that I think everyone knows we can do it, we just usually choose not to. I'm not sure why we choose not to but that's what I see.
Nobody said Rust would lead to the complete disappearance of C or C++‚Ä¶ That doesn‚Äôt make it less good for new projects.
&gt; Rust isn't going to replace C or c++ if it relies on llvm This is way too strong a statement. What does "replace C or C++" even mean? C or C++ aren't "going away" anytime soon, especially not the *software built with them* -- a huge amount of all infrastructure is built on them -- including other languages like python and Java. Pypy is written using LLVM as the core compiler. **If** C++ went away (and that is a BIG if) one would probably want to rewrite or (more likely) have a better replacement for, LLVM. That isn't happening in at least the next 50-100 years though. Even if the singularity hits I bet there would still be some software floating around that was originally written in C/C++.
And from where did you get a c++ compiler? From the same source, as the rust one?
Note that `random_number % N` does _not_ produce an even distribution over it's range, if `N` doesn't evenly divide the range of `random_number`. If you're just shuffling your MP3 playlist or something, then I'm sure it doesn't matter, but I think there are crypto applications where this is a big deal.
And of course [Rebol has them](http://www.rebol.com/docs/core23/rebolcore-16.html#section-3.9)
Not sure what the atmosphere of the early 90's was to lead to that aspect of Java's design. But it's incredibly obtuse. More than anything I think Rust just perfected the naming scheme for numeric primitives. I'd still like fixed-point primitives though.
Overflow checking only happens (automatically) in debug builds. This post is misleading. Aside from that I love how the type names are short and meaningful, unlike for example c++, where every project seems to have it's own aliases for integral types.
It probably wouldn't be super hard to make a pure rust backend that could be used in place of llvm. It just would generate pretty darn bad code.
It probably wouldn't be super hard to make a pure rust backend that could be used in place of llvm. It just would generate pretty darn bad code.
I get that argument but that isn't what I am talking about. Rust was partly boostrapped from ocaml. The thing is it isn't entirely rust. 
&gt; Opera is a unique case and I'm convinced they're less popular because they're proprietary. Google Chrome is also proprietary. &gt; and Chrome is mostly open source. Yeah.... just the parts that [spy on you are not](https://www.theguardian.com/technology/2015/jun/23/google-eavesdropping-tool-installed-computers-without-permission). But hey.... at least they are doing it for [legitimate reasons](https://gizmodo.com/5895812/google-patent-suggests-listening-to-background-noise-in-your-calls-to-personalize-ads), right? Google simply has better marketing people than any of the browser builders. All of your techie/geeky friends will switch to Firefox in the near future but there will be no major market share switch for Firefox. I really hope Edge will pick up steam. It's standards compliant, pretty fast and not based on Gecko or Webkit/Blink. It is exactly what the Internet needs to have strong standards.
I think there is a philosophical impasse that need not be. For a language to be self-hosted, does it have to compile into something that is usuable? What if all x86 machines vanished over night, is C no longer self-hosted? I'd argue what is targeted doesn't matter. What matter's is whether the language definition is made in it's own language or another language. Today Rust is defined via Rust. The *language* itself is self-hosted. The *language* is bootstrapped. Rust is not defined by all the various final ISAs and binary formats that it can compile down to, Rust is defined by it's language specification and it's implementation in the official compiler.
The underhandedness contest isn't about _attacks_ per se, but about hiding something nefarious in (presumably) trustable code. Indeed, most of the approaches here work by using absolutely usual behavior in an unexpected combination. Take, for example, the crates.io sidechannel: it exploits the fact that many build their software on the same machine they run it on. It then crafts it's own data format towards the crates registry format. There's not much we can do against that, except teaching people that one of the cool things about Rust is that running application doesn't need the package manager around (in contrast to, say, Ruby). All of the parts are sound there, except the user application, which was _specifically crafted_ to be exploitable and uses a sound piece of software to sneak into. On application platforms like Heroku, which have separate build and deployment stages, this wouldn't work. The borrow issue will totally be fixed.
Well, they fixed it in C++11 with an ugly `int32_t` and [company](http://en.cppreference.com/w/cpp/types/integer).
Instead of taking the bounds as arguments, why not just take a `std::ops::Range`? 
For the first part, I mean I have clang on my arm phone. Boostrapped yes absolutely. I can see what you mean but language definition I don't think is all of it. If llvm vanished rust would be(almost) entirely useless. I think it's less of a philosophical thing and more the fact rustc relies on llvm. Rust relies on llvm. A rust backend is not being developed. A language specification doesn't it make it self hosted. Python would be self hosted then
where `long` *probably* means 32-bit... I was confused by U1 / U2 / U4 / U8 notation the other day (byte count). Shows how much Rust's notation has become the "norm".
 using i32 = int32_t; ... there you go :)
Also llvm generates the ir, no? Rustc just used bindings to do it.
That's a technicality. Generating the IR itself wouldn't be that difficult. Letting LLVM do it has a few advantages.
No idea. IANAL, but as long as you're not a commercial entity, I don't think anyone will mind. In a sense you're providing a free ad to this little nice game.
&gt; where long probably means 32-bit... On Windows 32/64 `long` is always 32-bit, but on most other targets `long` is pointer-sized.
I was confused by your comment because I didn't see anything about arrays or vectors in the blog post. I think you mean "overflow checking" -- array bounds checking is indeed performed even in release builds in rust, but overflow checking isn't.
&gt;not to mention the only other note worthy implementation is mrustc, which is in C++. I'm not sure that's significant. 
&gt; I really hope Edge will pick up steam Eh, I'm happy if it stays at \#3, with Firefox and Chrome fighting for first place and Safari trailing at \#4. But yes, I definitely don't want Edge or Safari going away as they've both shown commitment to being standards compliant (though I wouldn't shed a single tear if IE goes away completely, though that's not happening for the foreseeable future). As for Chrome not being open source, [check out this reply from a Google employee who works on Chrome and Chromium](https://www.reddit.com/r/chrome/comments/1xsxjv/best_browser_google_chrome_vs_chromium/cfeku0r/). Some highlights: - they use a closed source PDF reader because it was way better than anything open source - some codecs and whatnot aren't open source, and Firefox just doesn't support those formats - Flash - definitely not open source and they felt they could trust their own update mechanism more than a system installed version to keep things secure - auto-update, crash reporting, usage statistics (e.g. the stuff that "spies" on you) - auto-update is better than no auto-update, and you can turn off the automatic crash report/usage statistics So yeah, it's a mostly open source project, and I think that's good enough for most techies that would be installing stuff on their friends' computers, especially since it was way better than anything else at the time. True, Google does much better marketing, but I don't think many people would switch if it didn't live up to the claims it made. It also has some nice features, like backing up/syncing bookmarks and whatnot, and now that Firefox has that with Firefox Sync (as well as importing from Chrome), I think the transition will be smooth enough for people to switch back. I'm not trying to claim that people will flock to it as quickly as they did to Chrome (again, marketing is important here), but I think that it'll certainly happen. Many people left because Google had a better product and *want* to return once Firefox is relevant again, and I think Project Quantum closes the gap and will pull people back again. Firefox has had successful marketing in the past, and I think it can do so again (I think billboards work reasonably well at getting the word out that a familiar product is worth returning to, and they've used those in the past).
This is a recently published blog post on a quite well-known consulting company here in Brazil inviting others to get to know Rust. There will be a podcast episode on their website next month as well chatting about most of the things resumed on the blog post. I expect it to be Translate-friendly.
Yes but we aren't getting around the fact that it would NEED llvm. I agree ir generation wouldn't be that hard. But something needs to turn IR/MIR/whatever into native code. And for the foreseeable future that will be llvm. 
Unsigned arithmetic in C and C++ is widely considered a footgun, and I think they wanted developers to not have to think about it. (See [comments by James Gosling](http://www.gotw.ca/publications/c_family_interview.htm).) They could, of course, have been stricter about conversions between signed vs. unsigned, as Rust does, but for the most part integer type conversions in Java work the same way as in C, possibly because they wanted existing C and C++ developers to already know how they'd work.
You want /r/playrust
Thanks so much. Im pretty new with this.
Should have a note above the post editor that says "r/rust (not the game)".
Sorry im not really sure what you mean. Is there any way you can dummy it down a bit further for me haha... Thanks so much for the help.. i really do appreciate it. 
Started building a JavaScript package installer, for no good reason at all. https://github.com/llambda/nary
Oh? I thought the destructor would run immediately, but the memory would wait to be released.
Interacting with hardware/binary formats in Java is really odd, since the bytes are always signed and literals are i32 (int) or i64 (long) only. Also chars are always 16bit. If I want to send 0xF1 to a port, I need to do `(byte)0xF1`.
So far, People have been coming in and out.. And i just want to say.. Even if it was just for a brief moment because you had to get on with your day. Thank you so much. To the end of the world and back.
I intuitively knew doing something like that would be wrong. And there was no way I was going to do that. I said that just to show that I have thought about the problem and look at the documentation. So it won't be just me asking you.
It is rather complicated http://www.unix.org/whitepapers/64bit.html
Rust also nests `/* /* */ */`. The syntax is documented [here](https://doc.rust-lang.org/beta/reference/comments.html). I find that Rust is expressive enough to reduce the temptation to write bad comments of the `/* do this */ do_this();` style. Good commenting is terse (easy!) but to the point (*very* hard) so there's not much need for block commenting unless your boss is making you do it.
s32/u32 is probably a slightly cleaner naming scheme in completely irradicating any notion of "one is more natural", but eh, close enough.
`//` is easier to type than `/* */`. Half as many characters, don't have to press shift, only need one key. I don't think there needs to be a reason other than that!
This still seems very bizarre to me, to be honest. Apparently it's a thing, but I would have preferred a "warning" here (maybe a disjoint return type), because it seems quite unexpected.
Is there any example out there of compiling C code to run on android? I don't know what to do with my build.rs. The normal cc::Build::new (gcc::Config::new) command always throws: Internal error occurred: Failed to find tool. Is `arm-linux-androideabi-gcc` installed? Regular rust only crates compile fine for android by simply passing --target=arm-linux-androideabi to cargo build.
I think it's also interesting to know that Bjarne Stroustrup now considers that using an unsigned integer for the size of collections and indexing into collections (such as `std::vector`) was a mistake and a signed type would have been better. If my memory is correct, he basically said that they went with unsigned to get one extra bit, but that in retrospect it was not really useful, and it forced programmers to mix signed and unsigned with potentially dreadful results (C++ has "interesting" conversion rules for mixed arithmetic). Personally, I used to be a fan of unsigned types, until I realized that there is one crucial issue: the most common value (0) is also a boundary, so that suddenly associativity and commutativity do not hold any longer (if you panic on underflow/overflow). It's painful to realize that `u + 5 - 3` and `u - 3 + 5` have different validity domains; sure the signed version *also* has different validity domains, but here we are talking about `[-5, BIG]` versus `[3, BIG]` and that left-hand boundary is awfully close to the values you actually operate on, whereas for the signed version it's just `[-BIG, BIG]` and you rarely have to worry about it.
My bad, corrected
Well unsigned variables are obviously more natural, while signed ones are more integer. :-)
long used to be double the pointer size back in the 16-bit days ;)
I'm not familiar with examples of Hyper directly, but Rocket has a really nice [example of a pastebin](https://github.com/SergioBenitez/Rocket/tree/master/examples/pastebin) and others have made similar things.
I can't explain why debug mode would be faster, that seems impossible to me. I will suggest that locking stdin should increase performance considerably: https://play.rust-lang.org/?gist=01b7bd1cbd8b1910c77069b05e53b71a&amp;version=stable
I need a little help with a lifetime problem. I'm trying to convert from one struct that holds a reference to some data to another struct that holds a reference to the same data. A reduced case follows: struct Bad&lt;'a&gt;{ problem: &amp;'a str, } struct Worse&lt;'a&gt;{ problem: &amp;'a str, } impl &lt;'a&gt; From&lt;Bad&lt;'a&gt;&gt; for Worse&lt;'a&gt; { fn from(bad: Bad) -&gt; Self { Worse{problem: bad.problem} } } fn main(){ let problem = "chocolate overdose"; let bad = Bad{problem: problem}; let worse: Worse = bad.into(); } And here's a link on the playground. https://play.rust-lang.org/?gist=e12e724d93a877c0c924d50e83f331c3&amp;version=stable I don't see why it shouldn't be possible, but maybe I'm missing something.
Found the reason the debug build is fast (but not the reason it is faster). The SHA512 is done with an [optimized assembly implementation](https://github.com/briansmith/ring/blob/master/crypto/sha/asm/sha512-x86_64.pl) so a release build will have little effect on the speed of that part. The rest of the time is just waiting for the OS to fill a buffer, there's just not much code there to be optimized.
By this logic, you might as well argue that no compiler is self-hosting, because they all rely on machine code to run. Just because rustc has a dependency on a binary that happens to be generated by C/C++ code doesn't mean that rustc isn't generated by other Rust code. The distinction you seek to make isn't very meaningful.
Fixed: https://play.rust-lang.org/?gist=9de2c250d460762824b155c0448b7d24&amp;version=stable You just need to be a bit more explicit about your lifetimes. It wasn't able to infer usage of lifetime 'a.
&gt; It's painful to realize that `u + 5 - 3` and `u - 3 + 5` have different validity domains Except that they don't ‚Äì that's rather the point of modular arithmetic. It's a manufactured problem in Rust because it panics where there only _might_ be a logic error, and very well may _not_ be.
Thank you!!
I think these things can be solved after [const generics](https://github.com/rust-lang/rfcs/pull/2000) become stabilized.
&gt; Yes but we aren't getting around the fact that it would NEED llvm. It'd need anything that accepts the LLVM IR. It's actually quite easy to generate CPU instructions from the LLVM IR. The result would be horribly inefficient, but it'd work. 
&gt; More than anything I think Rust just perfected the naming scheme for numeric primitives. You say "perfected", I say "had huge arguments for months that got so heated I actually cried IRL once", but yeah, I think we ended up in a pretty decent place.
&gt; &gt; where every project seems to have it's own aliases for integral types. ¬Ø\\\_(„ÉÑ)\_/¬Ø
Only if you think of paths as strings. If you think of paths as paths (works even literally, as a series of commands "start from root, go left, go right, .."), it makes a lot of sense.
I did try that, and I didn't notice a perf difference. (I think locking a Mutex on Linux is a single atomic swap and no system call, in the case where there's no contention? If that's right, it probably gets totally swamped by IO?)
Honestly using a user supplied string in a path is just asking to get owned in this way in general. Don't try and black list just white list.
I forgot about all those extreme bikeshedding arguments from the past. Let's just be glad that we cannot have that argument *again*.
It's not *above* the editor, but the form does say: &gt; submitting to /r/rust &gt; The Rust programming language. For the Rust video game, see /r/playrust 
I mean....kind of yeah. But that is what he bulk of llvm does. 
you should always worry about those edge cases. `[-BIG, BIG]` is not an excuse to ignore boundary behavior. java had a longstanding bug (way back in the days) where binary search wouldn't work for big arrays because `(a + b) / 2` overflowed (the solution is to use `(a + b) &gt;&gt;&gt; 1` (works only for wrapping signed ints) or `a + (b - a) / 2`). ignoring edge cases gives you hard to debug bugs in the long run. `u + 5 - 3` for large `u` is as problematic as `u - 3 + 5` for small `u`.
Calling it "attacks" was probably wrong of me; you're right that this is not attacks, but some of it is still just bad code, that at the very least can be footguns. Like the macro export issue for example; is there something we can do about that?
I know Python's pathlib is the same way.
According to the [repository](https://github.com/SimonSapin/rust-forest#no-maintenance-intended), the author simply does not intend to continue maintaining the project. I'm not sure why that motivated yanking from crates.io, perhaps there were fatal flaws in it which justified bringing it down? In any case the source code is still fully available.
Notably, the reason this matters it that the compiler currently has a bug; if you use an empty loop, you'll get UB, even though rust-the-language does not say that it is UB. https://github.com/rust-lang/rust/issues/28728
its true people should consider this when trash talking C++ here; I don't personally object to them saying 'rust is self hosting' , but it can be acknowledged that it *depends* on the C++ ecosystem (before criticising c++ *too* much)
Maybe /u/simonsapin can say more.
I am a bit biased, as the author of https://doc.rust-lang.org/book/second-edition/ :) It sounds like most of it is type 2, and the project chapters are type 1, so it might not be what you're looking for. &gt; Also I want to use Rust for lightweight and fast web services. Is it the right choice to use Rust for this? It's an area undergoing a *lot* of active work. The plan is for it to be excellent. There are lots of rough edges and work-in-progress bits. Depending on the kind of person you are, that's either disqualifying or exciting :) &gt; Final question is Rust good for cross-platform system development, like can I write iOS / Android app on it? Yes, you can. There's at least one game in the iOS store, and Servo does android builds. It's similar to writing one in C or C++ though; you don't get bindings to the native toolkits, you get an opengl context or whatever. You could combine Rust with the native language of the platform, and write all the logic in Rust, and the UI in that language, though.
I would question whether or not it's worth doing.. knowing rust has the optimisations of the C++ community behind it through LLVM is a big plus. I don't think it's something to be ashamed of. Trying to eliminate C++ is too ambitious IMO.
O.O, it's really strange to me when I find out people whose work I use are just online hanging out and posting on Reddit. It's almost unreal, like IMing your favorite author randomly.
The biggest issue with the example is that you do a 1-1 mapping of a solution. Yes we can write Java in Rust painfully, we can also write C++ in Java very painfully. Simply something as simple as changing the name of the method to something more like: user.sendOver(connection, "Hello"); Makes it IMHO easier to read and understand: we have a subject (user) that does a verb (sends over) an indirect object (a connection) used to do the action to the direct object (a string saying "Hello"). Still as you say, there's a few issues with `user` not being able to remember `connection` across calls (requiring relearning). Still maybe we could invert the relationship: connection.sendAs(user, "Hello"); Of course this is still a problem as a connection may forget things about users between calls. Then again, one is not a clear owner of the other: a user may be talking on multiple connections, a connection may be running for multiple users. Maybe the solution is to create a `Session` that mutates the connection (so there can only be one session on a connection at any time) and reads a user (so users can be talking over multiple sessions simultaenously). We can even hide this with a method `connection::as&lt;'a, 'b&gt;(&amp;'a mut self, &amp;'b user) -&gt; Session&lt;'a, 'b&gt;` and have that be the sender. So now we can do code as let user = User::new(); let connection = Connection::new(); if (let OK(user_session) = connection.as(user)) { user_session.send("Hello"); user_session.send("Goodbye"); user_session.send("Whatever"); } it does have clearer dependencies, with things that are only related to `connection` in `Connection`, things only related to `user` in `User` and things that need both in `Session`. The fact that only one person can talk over a `connection` at a time implies strongly the constraint of ordering. It also has strong implications about how a `Session` is something that completely depends on both objects. This could easily be done in Java, it would also be a lot of work and boilerplate and doesn't feel as intuitive in the language. It may seem more of a pain to write, but it's far easier to debug, and far clearer about where things start and end.
&gt; You could combine Rust with the native language of the platform, and write all the logic in Rust, and the UI in that language, though. Like I can write Rust logic in a separate lib, then bridge it and use from Java on Android?
Actually he explains it [here](https://github.com/SimonSapin/rust-forest/issues/6). Honestly I understand his reasoning, it is a lot of work to maintain a library. I wonder if he'd mind finding a maintainer for it. The library itself was useful.
Back when I [implemented this feature](https://github.com/rust-lang/rust/issues/66), I was told that it was intended for temporarily commenting out code during testing, while `//` is intended for actual comments.
Can you elaborate and/or define USB in this case?
You want /r/playrust
Thanks for bringing this to my attention, added some Way Cooler issues I won't get around to for a while :)
https://medium.com/@marekkotewicz/building-a-mobile-app-in-rust-and-react-native-part-1-project-setup-b8dbcf3f539f In the post is also a link to an iOS guide.
My first thought was of partial *application*, which is totally different. https://en.wikipedia.org/wiki/Partial_application 
``` 1.0.0_pre1_s -&gt; SemVar(1, 0, 0, Some(SemVarStatus:PrereleaseN(1))) ```
I'm wondering... how many use cases are there for every-day-applications to just life-lock with infinite loops? I only know this from OSDev as kernel implementations for `fn abort() -&gt; !`, but there I'm used to set the CPU to a low power state inside the infinite loop, which prevents that bug: // ARM loop { unsafe { asm!("wfe" :::: "volatile"); } } // x86 loop { unsafe { asm!("cli\nhlt" :::: "intel", "volatile"); } }
I think you could return an `impl Fn` that just forwards to `eval`, something like: fn wrap&lt;B, O&gt;(pf: PartialFunction&lt;B, O&gt;) -&gt; impl Fn(B) -&gt; Option&lt;O&gt; { move |x| pf.eval(x) } 
Emphasis on the plural aliase**s** per type. Even better when some are defined as for example int and others as short, but apparently they but supposedly have 16 bit.
From what I've heard, the main driving factor behind Cretonne is to have faster debug build iteration times. So, Cretonne would be a really fast backend, but the performance of the generated executables would be bad. It would also help `rustc` be backend-agnostic, so it isn't too closely tied to LLVM.
Another interesting point is that unsigned 32 bit numbers on a 64 bit machine can be slower. This is because you need to "manually" zero out the top 32 bits of the register (in order for the u32 to "wrap around" when you hit 2^32). Signed 32 bit numbers don't have this problem (at least in C, not sure about Rust) because signed integer overflow is undefined, so no need to constantly clear out the top 32 bits. See e.g. http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html#signed_overflow Also, things like DIV vs IDIV instruction costs are different (signed is faster on many CPUs).
If someone steps up and say they want to maintain this I‚Äôll gladly let them and give crates.io access etc. But I‚Äôm not gonna actively try to find someone. Been there, [done that](https://users.rust-lang.org/t/help-wanted-maintaining-rust-url/10707) (for a much more widely-used library), doesn‚Äôt work.
Single-line syntax is encouraged, both for comments and doc-comments with `///`. The reason, I think, is that `/* */` comments violate locality - it's can be hard to recognize without highlighting that you're looking at a comment.
No fatal flaw. This was only to push people to copy/paste the code into their own repositories if they want to use it, rather than have them send issues or PRs to me when the want to tweak or fix something. Because I‚Äôd procrastinate dealing with these for weeks or months and everyone would be frustrated.
:) I understand this, as I felt that way long ago too. The Rust crowd is generally very friendly and accessible.
Basically, Rust can pretend to be C, so you can call into it with JNI just like you would C code.
The important part is not that the code is useful, but that undefined behavior means that the program is not well-formed, and so therefore, the compiler can do *anything*. I would *much* rather have the compiler compile a useless program correctly than I would it compile into something other than what I intended.
Just the other day I was thinking about pains caused by UB in C, and I thought to myself, I wonder if there is any UB defined by Rust. I didn't get around to Google it but since you're "here" (as much as one can be "here" in a comment section), perhaps you could tell me the answer to that?
Rust the language (tm) [has been proven to be sound to some degree](https://www.reddit.com/r/rust/comments/6m46is/rustbelt_securing_the_foundations_of_the_rust). Rust the implementation is not necessarily sound, due to bugs in llvm, std api, implicit Impls, etc 
https://doc.rust-lang.org/reference/behavior-considered-undefined.html
The description of the patch is kinda confusing me... it says that it implements an idea for "supporting languages that require support for infinite loops with side effects, such as Rust". Surely C also "requires support for infinite loops with side effects", otherwise you wouldn't be able to have an infinite event loop! Does it really mean "languages that require support for infinite loops *without* side effects"?
Ah cool, now Rust shows up on the left in the language selector! Good work ;)
Okay, got it. I don't think that `UnsafeCell&lt;*mut [Color32]&gt;` is needed for it to work. As I said, this just says that the pointer itself is allowed to have aliasing pointers to it. I don't think it changes the aliasing properties of the `Color32`s that it points to. A `*mut [Color32]` should be sufficient, as this is already aliasing. &gt; If I work with `(UnsafeCell&lt;*mut [Color32]&gt;, BufferID)` (note that the UnsafeCell is passed by value) that will suppress the non-aliased declaration. So it sounds like you've tested this, and found that adding `UnsafeCell` changes the IR that rustc emits? I must admit that that's unexpected. &gt; The thing that's not clear to me from the docs is what `*mut [Color32]` would mean - it seems to not be specified as part of the "Rust needs a memory model" issue. It's poorly documented, but it has the same interface as `&amp;mut [Color32]`, except it's aliasable and not checked for lifetimes. The syntax for indexing it is `(*x)[i]`, unfortunately. Anyway, TL/DR: You should be able to use a regular `&amp;mut [Color32]`, just as long as the borrow ends before you make the FFI call. When a `&amp;mut`-borrow ends, all writes are "committed" and cannot be reordered across the opaque function call. Or you can use a `*mut [Color32]` instead, which has worse ergonomics. You shouldn't have to involve any `UnsafeCell`s. If it doesn't work, I'd say that it's a bug in the compiler. 
I noticed musicoin forked parity to something called [rmc](https://github.com/immartian/rmc) just to maintain compatibility with their upcoming fork and decided to give it a try to integrate it upstream in [parity](https://github.com/paritytech/parity/commits/a5-chains-musicoin). waiting for feedback now. how do I change my flair on r/rust?
There's two different ways to interpret that phrase- it caught me off guard at first as well. The first one I thought of, which you seem to be thinking of as well, is "infinite loops whose bodies contain side effects." The second, which I believe is what they mean, is "infinite loops that *themselves* have the side effect of halting execution," which implies that *infinite loops whose bodies contain no side effects* will still have defined behavior.
In addition to TRPL, I would recommend Programming Rust. It's helped a lot. Too bad O'Reilly won't sell you the work in progress without subscription.
Signed arithmetic is IMHO a much bigger footgun, just because signed overflow is undefined behavior in C and C++. (I have no idea why the Google style guide propagates signed arithmetic.)
Though it's worth noting that any unsoundness that arises without the `unsafe` keyword is guaranteed to be considered as a bug in the language that needs to be fixed eventually, even if that means breaking code in the wild (though we try very hard to make this breakage as painless as possible, this has happened at least once, and will probably happen again).
Remember the `str`/`String` one?
For the entry that exploits the borrow checker bug, that attack will be obviated when the two-phase borrows RFC lands, hopefully later this year. For the entry that uses crates.io as a remote control, I believe some change to Cargo's behavior has been introduced to make it less reliable, but I'm not sure what a bulletproof fix would even look like. For the entry that shadowed standard macros, I think macros 2.0 will help address that by allowing macros to use namespaces like any other identifier. And for the trait shadowing entry, the attack seems contrived enough that I'm not sure that any official action needs to be taken, though I wouldn't be opposed to extending clippy to catch it.
So what is the status of rust-url? Are you stuck maintaining it?
Because many of the most insidious bugs come from implicit conversions (again, most C and C++ developers don't fully understand the semantics), so they decided to prevent these by having only one kind of arithmetic, and not having signed arithmetic obviously wasn't an option.
Thanks. I find it very reassuring that UB is forbidden instead of allowing implementations to decide what they want to do when UB is encountered :)
Fair enough, I did not think of the implicit conversions, they are a pain indeed. However, there are compiler warnings for that and you can't get rid of them completely if you still have floats.
Sorry, I specifically meant implicit conversions between signed and unsigned arithmetic. Implicit floating-point conversions mostly behave sanely, although I think they're still bad on net.
Also, unsigned integer wraparound may not be undefined behavior, but if it happens anywhere you're not expecting it, you're still going to have a bad time. (In particular, if you use the wrapped-around value as an index into an array, then there's your undefined behavior right there.)
Erm, I am having a hard time finding the precise and unambiguous statement about what happens, but the text &gt; a dereference to a deleted object will either succeed as if that very object was not yet deleted, or result in a DanglingReferenceException. strongly suggested to me that `delete` does not eagerly invoke a destructor and potentially leave the object in an invalid state. Later they say &gt; The allocator processes delete requests by marking objects as free using a bit in the object header. The bit is also checked to detect double frees. but then they go on to not mention finalizers in the rest of the text. They do mention destructors, but only that this is where they put `delete` calls for memory the destructing class owns. I'll ask them. 
Of course you can always have a bad time when your code does something you don't expect. But with unsigned arithmetic at least your overflow checks won't be optimized away.
Do `rustc` and `cargo` work? What happens if you run those commands with the `--version` flag? Also, from what I've heard, McAfee is not a good antivirus. At all. So that might have f-ed things up.
That's exactly what I use it for, although I wonder what the harm would be if the compiler allowed the omission of the trailing `*/`.
As an alternative to /u/dodheim's solution, you could also take a look at the [`ordered-float`](https://crates.io/crates/ordered-float) crate.
It's true. There are and were good reasons, you have to dig into history to answer these kinds of questions, and that + backwards compatibility is tough.
Ask us mods and give some link to show you deserve what you want in your flair.
I still jokingly say that I want an epoch for String -&gt; StrBuf. It was like that for a week and was glorious.
Even if we don't do that... Can we please just capitalize `Str`?
Other end: it's possible to setup a web endpoint that takes safe Rust &amp; compiles it to execute logic. If the compiler is sound, this can be effectively made to be a sandboxed computation. With UB in the language you cannot expose that kind of interface (whoops, meant to respond to [LEmp_Evrey](https://www.reddit.com/r/rust/comments/7321fj/llvm_patch_for_infinite_empty_loops_with_defined/dnn1dq4))
The servo team in general maintains it pretty ok right now I think. I'm willing to devote more time to that if that's not the case currently.
heh. 'the singularity' should be able to safety-check C++ at compile time 
Returning a closure would require boxing.
I have a USB stack written in Rust for a microcontroller. I'm working on making it prettier/nicer by using Rust generics/traits!
I swear that I had already restarted the computer before running rustup, But now it is returning a new error message: the bin/rustc.exe directory does not exist. Rustup then refuses to remove and update stuff.
Though that might be a dangerous game to play, as new unsoundness bugs can get introduced over time...
This is going to sound condescending no matter how I phrase it: *do* you have `arm-linux-androideabi-gcc` installed? Cross-compiling Rust alone doesn't need a GCC toolchain, so you might not have needed it before. I think the Android NDK comes with a compatible GCC.
This isnt exactly every-day applications but in embedded you'll sometimes do it to force your microcontroller to reset due to a watchdog timeout.
Not a book, and I definitely hesitate to share this as it lacks polish, lacks context/notes (i.e. what I actually emphasize when discussing it), mixes horizontal and vertical slide navigation in weird ways, and has references aimed at my team (I might try and clean it up tonight)... but, I did put together a [Rust for Scalatians deck](https://hackmd.io/p/S1hnuE60x#/) highly targeted at getting Scala colleagues to grok as much Rust as reasonable in under an hour: In general it isn't nearly the depth your asking for, but I thought I'd mention it in case other Scala devs stumble onto the resources here and are interested in getting familiar with Rust with less of an initial investment.
It's built-in, so it being lower-case makes sense to me.
So is `Path`, `OsStr`, `CStr`, and plenty of others. ;P
Those are not special to `rustc` itself, whereas `str` is a lang item.
So is `Box`, literally anything in `std::ops` (all of which are capitalized), and plenty of other things. 
How exactly are you doing overflow checking?
Oh wow, a *language* that cares about us? I hope you're taking notes c. 
A language being total is a bright line - either programs written in the language can diverge (and thus can have the bottom type), or they cannot. In Rust, programs can diverge, and thus Rust is not total. Full stop. For a total language, see HOL, or Coq, or Lean, or Matita, or Idris with the totality checker enabled, or Morte, or Dhall, or...
https://crates.io/crates/chan
&gt; Except that they don't ‚Äì that's rather the point of modular arithmetic. This is what Wrapping(T) is for.
The best resources for Rust aren't books at all. As far as developing lightweight network applications, maybe you should look into the in-developnent Tokio project? https://tokio.rs/
Hey, guys, I just installed IntelliJ, and the rust plugin. I also did install rustup and got it to work after downloading the C++ build tools. My question is a simple one though. I'm trying to the traditional Hello World, but I can't seem to make it print out, or I am not looking in the right place. I'm following [this](https://rustbyexample.com/hello.html) guide but I just can't get it. I am pretty much an extreme beginner at any kind of programming, I only got this because my professor said he was going to be teaching us in this language. Any help is appreciated.
&gt; [look at the IR??] Oh, uh, [yeah I could do that](https://play.rust-lang.org/?gist=e4fea5ad80b0640502149d37c11ac5bb&amp;version=nightly). Turns out that rustc currently doesn't generate `noalias` for `&amp;mut` pointers either! A bit of digging turned up [this tracking issue](https://github.com/rust-lang/rust/issues/31681) - my summary: a LLVM bug means `*a = 1; assert!(....); *a = 2;` can panic without setting `*a` to 1 first. Thanks for the nudge in the right direction. I'm confident that `*mut T` is suitable for this use case (being the only writer to a buffer). Reading from shared memory which may be mutated, I still want to be sure that the owning structure (from which the borrows originate) is marked to have an unsafe interior. But `PhantomData&lt;UnsafeCell&lt;..&gt;&gt;` alongside a `*mut` pointer is far more ergonomic. 
Quantum DOM does a lot of clever things, but letting the JS engine manage DOM memory like Servo is not one of them. They still use refcounting and a cycle collector. further experimentation is needed in Servo before we know if its approach is better.
Cool, welcome to programming. Rust may not be an ideal first language (steep initial learning curve compared to, say, Python or Go) but it's not impossible to start with it. some background: Most often you'll start programming by interacting with the user through a TTY -- seriously old-school technology. Around 1900 AD people decided that the telegram was cool, but it would be even cooler to have a telegram-typewriter mashup, a teletypewriter or TeleType (a brand name, now genericized) or TTY (which is the abbreviation you'll see in Unix - nearly every operating system on a PC is either Windows or Unix) or text console (Windows name, also found in other PC operating systems). When computers became fast enough to interact with humans, teletypes were some of the first devices used for interaction. The keyboard sends letters to your program, your program sends letters to a printer (except, eventually computer operators got tired of paying for paper and switched to virtual paper on a video screen). and an answer: On IntelliJ it looks like you [press Alt+F4 and look to the bottom half of the window](https://intellij-support.jetbrains.com/hc/en-us/community/posts/205818039-Newbie-question-where-does-console-output-appear). You may prefer to use Windows Command Line or a Unixy "terminal emulator" to run your programs instead. This will be covered in class too. (Darn well should be.)
Thanks for a reply. I have learned Python as part of my community college courses, but this has come to bite me in the butt. Most of Davis requires me to have C++ learned. Especially my programming languages class. And unfortunately, I do not think it will be. I am just trying to see if I installed everything correctly by printing something out. Which I haven't quite done yet. EDIT: I ended up figuring out what I think the issue was. I was in a Java project file, instead of a Rust one. I looked at main.rs after creating the appropriate project, lo and behold, Hello world was printed. Thank you for your quick replys, I should be back soon enough.
You could also also do i32/n32.
True, but does the compiler actually know those by name, or just by their `#[lang]` attribute? But `str` is not *declared* in any crate, only its `impl str`.
Box won't be built-in forever. The others are Lang items not buit in types.
What platforms require the extra masking? Both x86-64 and AArch64 offer 32-bit views of their 64-bit registers, which do all the zeroing automatically and without cost.
I have the NDK installed that comes with GCC. From what I've found how other projects seem to do it is they manually run those compilers to create static libs. I guess I have to do that. I was hoping the gcc/cc crate was smart enough to figure out the NDK if I have target set to arm-linux-androideabi since you can't set that target without the SDK and NDK being installed.
Rust the language does not have UB outside of `unsafe` blocks. Rust the _implementation_ has a bunch of cases of UB, considered bugs. The infinite loop issue is one, but so are out of range integer casts (also being fixed). There are also ways to do normally-unsafe things in safe code (and thus have UB), and these are _mostly_ due to bugs as well (except for, e.g. writing to `/proc/self/mem` which is not categorized as a bug, it's categorized as "lol linux")
&gt; any unsoundness that arises without the unsafe keyword is guaranteed to be considered as a bug in the language that needs to be fixed eventually except, of course, writing to `/proc/self/mem`. That's not a bug. That's "lol linux".
Hey I remember when Sun was saying the exact same thing about Java. I don't think it's a good idea to say that thing.
&gt; allowing implementations to decide what they want to do when UB is encountered :) Rust is optimized in large part by applying such "creative" interpretations to UB. The difference is that safe Rust won't/shouldn't let you invoke UB via boneheaded mistakes. (Or even very clever ones.) Thus the only UB the optimizer sees should be unreachable artifacts of previous transformations. If you do write something UB and it gets to the optimizer without a compile error, the result will be "do the fastest thing that isn't what I want." [These excellent articles do apply to Rust](http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html) and can/will bite you if you write `unsafe`. It's worth noting that the "safe" references in Rust translate to big promises being made to the optimizer. Rust is potentially a *bigger* footgun than C when you are conjuring references from thin air, transmuting between types, implementing lock-free or heavily customized data structures, things of that nature. On the other hand, it's much more clear what the requirements actually are.
FWIW that framing isn't quite accurate, and embodies some misconceptions about how UB _works_ which leads to a lot of misplaced blame on compiler writers. It's not that compilers see UB and take that as a free ticket to do whatever they want. That's the _symptom_, not the underlying _problem_. If this was where UB came from compilers could be "fixed" to do something reasonable in most common UB cases. The problem is that the way compilers work is that they assume UB doesn't happen at all, and compute facts about the program based on that. They then use these facts to perform optimizations. If there is UB in the code, these facts will be incorrect, and the optimizations may be too aggressive and destroy the intended behavior. So it isn't that implementations are "allowed to decide what they want to do when they see UB", it's that implementations are "allowed to assume it never happens". The underlying issue behind both of these is the same, but the framing more accurately portrays what is happening. Also, Rust _does_ have UB, it's just that you can only trigger it within `unsafe` blocks [modulo compiler bugs](https://www.reddit.com/r/rust/comments/7321fj/llvm_patch_for_infinite_empty_loops_with_defined/dnnqnqo/). (There's also the related case of a library exposing a safe function that's actually unsound because it has incorrect unsafe internals, thus letting you trigger UB)
re-read my question
Yeah it's actually looking for `arm-linux-androideabi-gcc` as a binary. Is that in your path?
`uint` - because non-negativity is so important we can / should make modular arithmetic play second fiddle to it.
My god, yes. I want Rust to be so successful that I spend the next 20 years of my life teaching newbies to read `String` as "string buffer".
Depends on the situation, but creative interpretation of UB can cause the optimizer to nix a check that happens *before* the overflow. That doesn't happen with unsigned numbers.
Have you done much with Wrapping(T)? It requires creative things to make it useable, because *every* bleeping cast into and out of the wrapping type must be explicit. My personal best is `let w = Wrapping;` so that you can say things like `a0 += w(data[i]);` instead of `a0 += Wrapping(data[i]);` and boy did *that* hack take a while to discover. One of these upcoming rainy fall weekends I'll write a `Wrapping` type that sucks much less (mostly by better support for implicit conversions). Often it's much easier to spell out the wrapping methods: `let aligned_size = size + (size.wrapping_neg() &amp; alignment - 1);`
Awesome!
Java is not alone; there are many languages that don't have unsigned types as a feature. I disagree with the statement in general. It differs mainly according to whether a language is relatively high- or low-level, not how recent it is. He does say something to that effect: "systems languages" are more likely to have this as a feature. There's a big misconception that higher-level languages that have more sophisticated features are more recent, modern, and popular. While technically, there has been a trend in that direction, there are also many low-level languages that are popular and still actively maintained, and they are still very necessary for performance-critical applications.
They perfected the naming scheme for literally every keyword. There aren't any that are longer than 6 characters IIRC (`struct` is the longest that comes to mind). They've hit the sweet spot when it comes to brevity and clarity. Waaay better than Java's excessively long keywords like `synchronized, volatile, protected` that waste time and line space.
I wouldn't blame C completely; there are some valid historical reasons why C is the way it is. The computing landscape really was a lot different back then, what with computers barely able to run even simple compilers, a lack of widespread networking to expose vulnerable code to hostile parties, and a much more diverse array of platforms that demanded uncharacteristic flexibility for any language that aspired to be cross-platform. Of course, that doesn't necessarily excuse modern compiler authors of the sometimes overzealous lengths they go to exploit UB in the name of performance. And obviously I still think Rust is a better choice than C in many areas, particularly security-critical ones. :)
Too bad O'Reilly stopped selling completely.
Per the linked post, it apparently requires a lot of sign extensions inside loops on 64 bit architectures. However, I guess I'm not entirely sure of the details of why that's necessary (i.e. why you can't just use e.g. eax and friends).
Most discussion around `TryFrom` is about its implementation for integer types. This presents an alternate (and imo useful) implementation of the trait to consider when discussing stabilization. I'm curious as to what other conversions people can come up with. I was thinking that we could perhaps have [`TryFrom&lt;&amp;[u8]&gt;` for `&amp;str`](https://github.com/rust-lang/rust/pull/44916).
There's also `use std::num::Wrapping as W;` but that's not much of an improvement. I was pretty annoyed when I learned that `Wrapping&lt;T&gt;` doesn't even implement `Into&lt;T&gt;` or `From&lt;T&gt;`
Cool, thanks! :)
LOL proc self mem !!!! Mwahahhaaha the pooower! 
I‚Äôve added an email filter for more efficient procrastination if address :is ["To"] ["rust-url@noreply.github.com"] { fileinto "GitHub.rust-url"; stop; }
More seriously, to be fair there are several people who do help a little. But there‚Äôs still a pile of open issues and PRs that go without attention for months at a time, until I feel guilty enough to spend a couple days going through them.
Exactly! Not to mention that LLVM *could* be re-written in Rust, it's just that it would be a ***huge*** waste of time. Why rewrite something so large for the purpose of saying: "Look, Rust can be completely self contained!" If someone wants to rewrite LLVM in Rust, they can, but there's no real need. *Unlike* when C compilers were rewritten from assembly to C - because that was more *need*-based. Just like the move from punch-cards to assembly. ___ Anyway, my point is that Rust is *capable* of doing it, but it wouldn't be legitimately useful in *any* way.
If LLVM disappeared (and let's say C/C++ did, too), then a rust compiler would be written in assembly, then rewritten in Rust. The same exact way that C compilers were originally built. In reality though, writing something like LLVM from scratch is just ridiculously *unnecessary*, because we already have LLVM and it works very well. But can you *imagine* if LLVM was rewritten in every single low level language? That would be a hell no one would want to deal with. Lastly: I'm almost certain that even C compilers *depend* on some amount of assembly to work, too - does that make them not bootstrapping/self-hosted? 
&gt; requires another compiler Once you have a binary you don't need the compiler :P 
At the risk of shameless self-promotion, there is the so-called Gentle Introduction to Rust: https://stevedonovan.github.io/rust-gentle-intro. (I say 'so called' because gentleness is the ambition, not necessarily the reality)
You can use Rc/Arc+Mutex to allow multiple parts of the code to share the same receiver.
Hi @kyrenn - many thanks for this - the explanation is crystal clear and I really appreciate the sample code. IMHO this example should be added to the repo. thanks again.
If anyone would like to know more about how it works, Niko gave a nice overview at the recent London Rust Meetup. The video is [here](https://skillsmatter.com/skillscasts/10868-inside-the-rust-compiler). Incremental compilation starts at 20:00.
What do you mean by that?
You can't buy the PDF from their website anymore.
This looks very useful. BTW in some simple situations it could be nice to use decorators to specify contracts. Did you consider adding something like this? #[pre(x != i32::MAX, "cannot add one to input at max of number range")] #[post(y, y - 1 == x, "reverse operation did not produce input")] fn add_one(x: i32) -&gt; i32 { x + 1 }
Just out of interest, why is `str` a primitive type? It seems to me like it could just as well be implemented as a newtype around `[u8]`, as `struct Str([u8])`. 
Is there a way to find out the build directory of a particular crate with cargo? Like *target/release/build/somecrate-6gbds734df*. I need some files generated by a build script from another crate.
The thing to note is that your lifetime annotations can not change lifetimes. References live as long as they do given by their scope, just as you suggested. Note though that sometimes one might be surprised about the actual scope of something. Your annotations of lifetimes do one thing, they tell the compiler what to check for. You make claims about lifetimes of references within your structs/functions, and then the compiler does a check if it all adds up correctly. If they do, the compiler erases all lifetimes from your code and simply compiles, there's no trace left of your annotations in the final binary (it's probably more complicated than that). So what you have to check is "what's the claim I made?". Your baz method says "if self lives for a certain time, the output reference will live at least that long". The compiler can check that, and it's ok. But if you bind that lifetime parameter to the trait, that claim changes to "if self lives for a lifetime given by the trait, the output reference will live at least that long". Now the question remains "what's the lifetime parameter of the trait here?", and if you trace it back, that's the lifetime of the `data` parameter, which lives for the full body of `f` (even more, since it's coming from `b`). So you claimed "the reference returned by baz will live for the body of `f`", and the compiler told you "that does not compute", rightfully so. Making the lifetime parameter of `baz` independent of that of the input parameter of `f` (by virtue of removing it from the trait, which passes on that parameter) will allow it to work out. Note that `'a` is a local parameter, so the method `baz` does _not_ get passed on the lifetime of the input of `f`. I'm a bit hazy here, but I assume that there's an anonymous variable that data is bound to, that is restricted in scope by your braces, which in turn give the lifetime to `baz`.
Do you mean something like [this](https://play.rust-lang.org/?gist=738e9946f46baa64083fb8671e2f3a73&amp;version=stable)?
I am aware of https://github.com/lise-henry/crowbook-intl. https://crates.io/search?q=localization may have some useful crates as well.
You can use into_raw_fd() method from IntoRawFd trait.
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=30475 You can avoid this problem if you write the check differently. It is a bit tricky if you have to avoid underflows as well.
It has been renamed into rls-preview I think.
I'm on my phone or I'd look up the PR, but it almost was. There wasn't a ton of advantage, and lots of drawbacks.
Last time I check (about month ago) - there was nothing, sadly.
Thanks, that worked. :)
thanks for your explanations. when you say "if self lives for a certain time, the output reference will live at least that long" how do you explain the following : because if I have: ```fn g&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a i32;``` then I can do: ```{thing.g()} g.x = 3;``` and this works. the borrows does not occur for "at least" the lifetime of g here. 
Hopefully there's no trash taking C++ here at all.
I think it's the lifetime of thing that matters here
yes, sorry I meant 'thing' and wrote 'g'. so the example would be : ```{thing.g()} thing.x = 3``` so I don't borrow for the lifetime of thing
That's what I tried to say about an "anonymous variable". I'm not clear on the details, but I think it's just equivalent to `{ let y = thing; y.g()} thing.x =3`, which works the way I explained. The "deeper" explanation is that lifetimes are actually a constraint system (just my wording, I'm not a programmer), and the compiler looks for ways to satisfy it. In doing so, the compiler needs to take care of some conditions (i.e. the scope of things) and of course of the constraints you put on the lifetimes in your code. But is has some leeway in the lifetime it puts into the system, namely it can (sometimes) shrink lifetimes to satisfy the system (the keyword would be variance here, which does not apply to `&amp;mut`, which results in people sometimes getting confused when they change a immutable reference to a mutable one and get lifetime errors). So here `'a` does not need to refer to the scope of `thing` itself, but rather the smallest scope that `thing` could be living for when called with `g`, which is delimited by the brackets. And then it all works out. Did you look at https://doc.rust-lang.org/book/second-edition/ch19-02-advanced-lifetimes.html? It will surely help a bit with this. Also see https://doc.rust-lang.org/1.9.0/nomicon/subtyping.html in connection with this. (e) Maybe also see this recent discussion https://users.rust-lang.org/t/baffled-yet-again/13100/4, if you've got some time on your hands :)
[std::mem::ManuallyDrop](https://doc.rust-lang.org/std/mem/union.ManuallyDrop.html)
&gt; `trait Foo&lt;'a&gt; {` Foo owns `'a`, anything marked as `'a` lives as long as `Foo`. Defining the lifetime in the function (`fn baz&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a i32;`) works, as it's only local.
I think use after delete can be further prevented by compiler. My concern is that if programmer forgets delete some objects will result in memory leaks.
ok thanks again for your answer. I've read the corresponding part of the rust book but not the nomicon. I thinks it's getting clearer now. I'll try to rephrase it maybe. when you have a function with an input lifetime 'a on an input reference and a corresponding output lifetime 'a it means : the output will be usable for the whole 'a duration and therefore the borrow will last for exactly 'a. now we still need to compute the value of 'a. 'a DOES NOT MEAN the whole lifetime of the input. it means a lifetime compatible with the one of the input and also compatible with the one of the output. the compiler will therefore figure out what is the smallest possible lifetime 'a which is both ok for the input and the output by intersecting the lifetime of the output var and of the input var (with additional constaints in more complex cases). this is why in common cases the borrow only lasts for the output lifetime. is this ok ? now the only question left is "how do I understand the trait lifetime" ? does it constrains the input by saying : the input lifetime needs to be at least 'a ? which means trait lifetimes are very different from function arguments lifetimes. that's where the ambiguity lies in my example. if I go back to my example : I guess it makes sense this way. figuring out 'a in the baz function then becomes: - compatible with the input which is at least the lifetime of the trait which is at least the whole lifetime of variable b AND NOT just compatible with the lifetime of b - compatible with the output lifetime so -&gt; borrow problem 
That video was really interesting. Did I miss it being posted to /r/rust previously?
Yeah, I used this in practice on AVR MCU - there's no other way to perform a software reset and there was watchdog anyway.
every language has some zealots who trash-talk the others
&gt; is this ok ? Mostly. I don't think that part of "intersecting" is true, rather that in checking the lifetime constraints (remember, that's 'just' a check, not part of the compilation process) the compiler can shorten the input lifetimes if appropriate. The output lifetimes are dependent on the input lifetimes and then change accordingly. About that trait, I think you got that wrong (but I'm not on very sure footing here). Jump up one abstraction level: What `trait Foo&lt;'a&gt;` is expressing is that `Foo` is a trait parametrized by the lifetime `'a`. It's unspecified what this lifetime is during the definition of the trait, but it will be substituted by a specific lifetime when you use the trait. In your example, this usage is at the definition of `f`, and in that specific case `'a` is the lifetime of the input of the function. It can't be shortened during the specific check that gives you problems because if it is shortened further than the body of `f`, it would not satisfy the constraint that `data` has to live at least this long.
that's very clear. thank you again for taking some time to answer me.
Thank you, that's perfect.
If you want to transfer ownership to the FFI code, you can simply `mem::forget(_)` it.
Ah, the lovely policy of C compilers: "you did something the standard considers undefined so we'll do things to your code [that that will take you hours to debug](https://www.reddit.com/r/programming/comments/720oah/why_undefined_behavior_may_call_a_nevercalled/)." And that's the best case, the worst case is the introduction of very well hidden vulnerabilities.
I think a new version is called [type-arena](https://crates.io/crates/typed-arena). I remember an error in arena_tree dependencies when using `comrak`, but it got yanked, I notified the author of [`comrak`](https://github.com/kivikakk/comrak/issues/27) and he remove the `arena_tree` replaced it with `type-arena`
It's UB generally, not c compilers. Rust does have its own forms of UB too.
I missed the meetup but found the videos had been posted to the event page. Don't recall seeing them on reddit. [Intrusive data structures](https://skillsmatter.com/skillscasts/10911-intrusive-data-structures-for-rust) [three-rs](https://skillsmatter.com/skillscasts/10925-three-rs-high-level-3d-in-rust) 
Baed on the code provided in the [github issue](https://github.com/rust-lang/rust/issues/28728), what would be the expected outcome if there wouldnt be a bug? Infinit processing after the statement let n = foo(); is executed? Could someone try to ELI5?
There‚Äôs a commented example in the repo, I dunno if you saw it. If so, is there a way I should make it better? https://github.com/chucklefish/rlua/blob/master/examples/examples.rs
Damn, that's a pretty solution to move out data off the drop, but I'm gonna use the manualdrop thing considering that my problem is simpler.
Heh, that's awesome! Let me know if you have any further questions or comments. :)
It did not last long enough. The int bikeshedding was harsh but the outcome was great. The &amp;str/String will always be a huge disturbing mess. 
Apologies; did not read "with static type checking"
I've been using the `arrayref` crate for a while to do similar things. Does anyone who's used both have an opinion about which one feels more convenient? Edit: Woops! The crate is called `arrayref` and the macro in it is `array_ref!`.
&gt;Because of its privacy settings, this video cannot be played here. What does this mean?
I can't do that in the drop trait implementation, I get the "can't move out" error.
I understand that UB is to be avoided, but I do feel like there is a trend in the C compiler market to take advantage of UB to generate faster code at the expense of creating a lot of cases of broken but valid-looking code. I can't see rustc developers ok-ing a change that would lead to unsafe code with the implication that "the compiler users will just have to be careful to avoid this." Or are you saying this is purely the consequence of C and not C compiler vendors doing everything to get more speed?
Defined behaviour doesn't mean desired behaviour. Nearly every instance of unsigned overflow is a bug. The current advice now in C++ is to only use unsigneds for bit patterns and rightly so. Unsigneds don't even make APIs safer due to implicit conversions. I've never had to fix a bug due to signed overflow, but lost count of how many due to unsigned arithmetic. 
Naturals/integers are a very uncompelling notion to appeal to. First, naturals may or may not include 0 depending on who you ask. Second, we only have modular rings, and not the actual infinite set (BigInt).
I can't find a crate by that name. Would you mind providing a link?
Almost decent! We could have saved a lot of keystrokes if the types referred to the number of _bytes_ in the integer, not bits. `u1`/`u2`/`u4`/`u8` is clearly much more concise and obvious!... ..._runs_
https://crates.io/crates/arrayref
Sure, I don't think it would be the best notation. As unsigned int / int is already super common, I think Rust ended up in the best place.
it probably means some wankers don't want you watching from your location for some reason. This is of course a full proof way to make sure you can never see this video. In other news you should checkout youtube-dl . 
&gt; It's worth noting that the "safe" references in Rust translate to big promises being made to the optimizer. Rust is potentially a bigger footgun than C when you are conjuring references from thin air, transmuting between types, implementing lock-free or heavily customized data structures, things of that nature. On the other hand, it's much more clear what the requirements actually are. Can you elaborate on how this is worse than C? Obviously doing all those things is the potential for nasal demons, but C is surely just as bad?
First, let me give every declaration of a lifetime parameter a different letter. [There are three of them](https://play.rust-lang.org/?gist=d203179d843ae8b190926c29f0261c22&amp;version=stable) fn f&lt;'c, T: Foo&lt;'c&gt; + Setting&gt;(data: &amp;'c mut T) { This causes the function `f` to deal with exactly one external lifetime `'c` The error message says that the conflicting borrow ends at the end of the function; however, it actually has lifetime `'c` which continues *past* the end of the function (it's an external lifetime). After dispatch, autoref and autoderef `data.baz()` dispatches to `&lt;T as Foo&lt;'c&gt;&gt;::baz(&amp;*data)`. The borrow site (at `&amp;`) has external lifetime `'c` from the signature of `f`. Therefore the location `*data` can only be borrowed again with a shared (`&amp;`) borrow, not a unique (`&amp;mut`) one. A bad fix, but the simplest one that only changes the signature of `f`, is to ask permission to create a new lifetime `d` within the function. This is done with the `for&lt;'internal_lifetime&gt;` syntax, [like so](https://play.rust-lang.org/?gist=c04380cde529b9df8fecc689f275faf9&amp;version=stable). - takeaway #2: if a function needs permission to define one or more internal lifetimes using a type or trait template, use `for&lt;'internal_lifetime&gt;` in the signature. However, a better fix is to remove the lifetime parameter from `Foo`. Defining a lifetime parameter on a trait is only useful when it is necessary to connect a lifetime between different method calls. By moving the declaration of `&lt;'a&gt;` from `Foo` to `fn baz` several things happen: - lifetime parameter `'b` also moves to its corresponding `baz` - `for&lt;'d&gt;` no longer does anything - the dispatch becomes `&lt;T as Foo&gt;::baz(&amp;*data)` and the compiler is allowed to choose the lifetime of that borrow site. - parameters `'a` `'b` and `'c` all follow the default pattern and may be elided. And therefore: - takeaway #1: only use lifetime bounds on traits when lifetimes must be connected between calls or connected to the lifetime of ephemeral data. (such as the `'iterating` lifetime of an iterator or the `'locked` lifetime of a `MutexGuard`)
How on earth can ytdl access it when the browser complains? Both go to same ip... Thanks for the tip.
there are some tiny efforts, like https://github.com/rust-locale and my own totally inadequate, totally incomplete cldr crate, which i haven't touched in a looooong time. Maybe you can get somewhere by using bindgen and icu4c? If you have any success, let me know.
I will publish an experimental typesafe i18n crate soon-ish. But it uses proc-macros, so can't build with stable right now :/ You'll hear about it on this subreddit in the next few months :) EDIT: ahh, 12 upvotes, please don't expect anything special! It's experimental and probably sucks ¬∞_¬∞
Rust is [C with `restrict`](http://en.cppreference.com/w/c/language/restrict) everywhere. There's a tiny example at the end. Here I've translated it to Rust and pseudo-assembly. Safe Rust may be optimized by assuming that the arguments do not point to the same location. fn rfoo(a: &amp;mut i32, b: &amp;mut i32) -&gt; i32 { *a = 5; *b = 6; return *a + *b; } ; a in register 0, b in register 1, return in register 0 const32 5 to r2 const32 6 to r3 store32 r2 to mem at r0 const32 11 to r0 store32 r3 to mem at r1 return Unsafe pointers cause the compiler to assume that the store to `*b` may affect the load from `*a` (`a` and `b` might point to the same address) fn foo(a: *mut i32, b: *mut i32) -&gt; i32 { unsafe { *a = 5; *b = 6; return *a + *b; }} const32 5 to r2 const32 6 to r3 store32 r2 to mem at r0 store32 r3 to mem at r1 load32 mem at r0 to r0 add32 r3 into r0 return When you're writing unsafe Rust, you're responsible for not breaking safe Rust, which is more fragile than C.
I think you may be in the wrong sub. /r/rust is for the Rust programming language; you're probably looking for /r/playrust for the game.
This happens for me too. Try disabling whatever privacy/adblocking extensions you have enabled (maybe just go into your browser's private mode) - I assume skillsmatter videos are only playable from the skillsmatter website, but an extension may be blocking the referer header (or whatever mechanism they actually use).
Can I combine with QML?
Client side security
Thanks, i have privacy badger and abp, so might be one of those. Cannot be assed to check since i already downloaded it using yt-dl
&gt; I can't see rustc developers ok-ing a change that would lead to unsafe code with the implication that "the compiler users will just have to be careful to avoid this." That is what `unsafe` is. &gt; Or are you saying this is purely the consequence of C and not C compiler vendors doing everything to get more speed? I'm saying that it isn't because of C, it's because of the concept of undefined behavior. C is one language that has this concept, Rust is another.
I've never tried, but I've heard of others doing so, search the reddit.
[removed]
Might be worth sending a PR in for.
Here's another take on Rust from a Scala point of view, with slightly different emphasis https://koeninger.github.io/scala-view-of-rust/#1
You should be able to buy it drm free from ebooks.com once it releases. But yeah it sucks that you can't buy the early release directly from them anymore, because it's the best book on Rust by a significant margin.
thanks for the additional info. it is the first time I see internal lifetimes. the takeaway is also good advice. you see my problem was : - I mis-understood the rule for computing how long a borrow lasts. it thought it was just linked to the use of the output. with your help and /u/KillTheMule's help it's more clear now. - problem was with the trait definition but the compiler's message speaks of very different things. (and my real code example had even more different lifetimes to make it worse)
Until I need to port rust to PDP-11!
I think this might result in unintuitive behavior, since sharing a receiver would mean that each message will only be received by one part of the code. This could definitely be desired behavior, but I would expect that most users will want each message to be received by all receiving parts of the code.
&gt; Or are you saying this is purely the consequence of C and not C compiler vendors doing everything to get more speed? It's both. There's a common belief that UB problems are due to those-darn-compiler-authors, but that's not really the case? You could certainly design a compiler that operates on a superset of C where all UB has actually been defined. That would not be a very good compiler (and would be kind of equivalent to running ASAN/UBSAN-compiled code, i.e. this thing basically already exists and is not something you run in production) The C language is designed with UB. This gives the compilers the ability to make some assumptions that if violated cause weird behavior. They need those assumptions to do optimizations. And it's not like they notice "oh well you obviously meant X" situations and power through, this is way too late in the pipeline to notice. See also: https://www.reddit.com/r/rust/comments/7321fj/llvm_patch_for_infinite_empty_loops_with_defined/dnnqzqm/ &gt; I can't see rustc developers ok-ing a change that would lead to unsafe code with the implication that "the compiler users will just have to be careful to avoid this." unsafe rust code _absolutely_ does this already. The UB pitfalls of unsafe Rust code are actually slightly _worse_ than C.
A valid solution that doesn't require any third-party libraries would be to create multiple instances of a std::sync::mpsc channel for each receiver, then write each message to all senders.
So excited for this! I've been sprinkling // borrowck comments around my code as I'm forced to refactor due to lack of NLLs. I'm looking forward to deleting all of those comments and cleaning things up.
The weird thing is that they push the release date every month to the 25th of the following month.
This will remove so many borrowchecker fights that I lost in my first few days/ weeks of rust.
I'm similarly excited. But I'd also like to call out all the effort that went into education as well. Niko's blog posts, in particular, were very informative for me and this feature could have been implemented with a lot less emphasis on the communication side. The work that's been done to make complex technical topics accessible is also greatly appreciated. I've recommended those blog posts to a few people now and I believe anyone who hasn't read through them will find them well worth the time investment.
More info about what this is: https://github.com/nikomatsakis/nll-rfc/blob/master/0000-nonlexical-lifetimes.md
Yeah, probably this: ``` WARNING: Unable to download JSON metadata: HTTP Error 403: Forbidden ``` (from ytdl output). So the code running in the browser probably gets a 403 on the metadata, but it seems ytdl doesn't care. Yay!
I hope this will resolve some of the feedback here: https://blog.rom1v.com/2017/09/gnirehtet-rewritten-in-rust/#difficulties
You probably want /r/playrust instead!
"move" can also mean copy. The alternative is that the closure holds a reference to the variable `x` itself, which would technically make the type `&amp;&amp;'a isize` except with some more nuance about it still acting like the variable `x`
Great timing! I'm finishing a fluent-locale crate which is the core of fluent localization framework. I hope to release it next week and maybe release fluent-rs 0.1 soon after. Unfortunately, we still need someone to get CLEAR/ICU into Rust :)
Huh, I hadn't considered this before, but this actually sounds really interesting. I would only want to list some concerns I have with this: 1. Do you consider it worthwhile to implement this in Adhesion when this functionality already exists in [libhoare](https://github.com/nrc/libhoare)? There are several arguments I can think of, but I'm uncertain of their value and wanted your thoughts: * Especially nice is keeping the check names the same (i.e., `pre` instead of `libhoare`'s `precond`, `double_check` instead of `invariant`) * It lets users depend on a single library. 2. I don't believe that we can use non-string expressions in attributes right now, but I could be wrong. That's an implementation detail, though. :) 3. Adhesion currently is expected to work on stable, while custom attributes generally involve some hackery to work. I'm not sure how to get this to work, and would need some support to ship this (if it's possible). As an alternative, however, we might be able to make an alternate syntax possible when considering the next point... 4. How should this interact with the `contract!` macro? I might actually be able to implement an alternate syntax if the expectation is that a short version a la your suggestion will only work inside of a `contract!` block -- but I wonder if users might get confused if they try this outside of the macro usage. Some cases: 1. Attempted usage outside of `contract!` macro? 2. Attempted usage INSIDE a `contract!` macro? 3. Trying to specify `pre` and `post` blocks at the same time as the shorthand version should do...what? Should we accept it (if so, doing what?), fail silently, or throw an error? How important is it that the error be a good one? 5. Currently, Adhesion doesn't control conditional compilation -- that's still determined by individual statements and `cfg`s in the different check blocks. It would be necessary to offer similar control here, and some brief bikeshedding ( ;) ) on associated syntax would be necessary. What do you think? I'm more than happy to do the work to implement this suggestion, because I really like it -- I'm just worried that it may not be possible or worth the effort yet. EDIT: more details and grammar fixes.
I'm not sure if it would be possible, but it would be interesting if some Clippy lints could be made for workarounds that are no longer needed due to NLL.
Where is `build.rs` executed? Relative to the rest of the crate? When `build.rs` is a member of a workstation does this change? --- Solution: The location the `build.rs` is declared. Easy to write dummy `fn main() { panic!("{:?}", ::std::env::current_dir()); } `
Can't wait to get rid of those hacky blocks.
I've been reading about Rust for a while now, this is _the_ feature I'm waiting for to dive in. Thanks to everyone involved in making it happen. edit: grumer
Any TLDR improvement in numbers?
`move` closures vs non-`move` closures are about creating and moving the function object. They define whether the closure borrows **it's context** or receives ownership of it. If we translate your example to structs: struct PrintX&lt;'a&gt; { x: &amp;'a isize, } impl&lt;'a&gt; PrintX&lt;'a&gt; { fn call(&amp;self) { println!("{}", self.x); } } fn generate_printx&lt;'a&gt;(x: &amp;'a isize) -&gt; PrintX&lt;'a&gt; { PrintX { x: x } } fn main() { let x = 1; let f = generate_printx(&amp;x); f.call(); } As you can see - `PrintX` is taking ownership of `x`. The non-`move` version would look like: struct PrintX&lt;'a, 'b&gt; where 'a: 'b { x: &amp;'b &amp;'a isize, } impl&lt;'a, 'b&gt; PrintX&lt;'a, 'b&gt; { fn call(&amp;self) { println!("{}", self.x); } } Box::new(move || println!("{}", x)) fn generate_printx&lt;'a, 'b&gt;(x: &amp;'a isize) -&gt; PrintX&lt;'a, 'b&gt; { PrintX { x: &amp;x } } fn main() { let x = 1; let f = generate_printx(&amp;x); f.call(); } This doesn't compile - for the same reason your code would not compile if we removed the `move`. `&amp;x` should not escape `generate_printx`. However, if we used it locally: struct PrintX&lt;'a, 'b&gt; where 'a: 'b { x: &amp;'b &amp;'a isize, } impl&lt;'a, 'b&gt; PrintX&lt;'a, 'b&gt; { fn call(&amp;self) { println!("{}", self.x); } } fn generate_and_call_printx&lt;'a&gt;(x: &amp;'a isize) { let printx = PrintX { x: &amp;x }; printx.call(); } fn main() { let x = 1; generate_and_call_printx(&amp;x); } This works for the same reason non-`move` closures work when they don't escape their scope. How about `Fn` vs `FnOnce`? They represent a different aspect - borrowing vs moving the function object **when invoking it**. So, if we translate an `FnOnce` version of your code to structs style: struct PrintX&lt;'a&gt; { x: &amp;'a isize, } impl&lt;'a&gt; PrintX&lt;'a&gt; { fn call(self) { println!("{}", self.x); } } fn generate_printx&lt;'a&gt;(x: &amp;'a isize) -&gt; PrintX&lt;'a&gt; { PrintX { x: x } } fn main() { let x = 1; let f = generate_printx(&amp;x); f.call(); } This difference here is subtle so I'll point it out - `call` is receiving `self` instead of `&amp;self`. This means that: * `f.call();` "consumes" `f` - the ownership of `f` is passed into `call`, and you can't use it again. That's the meaning of the "Once" in `FnOnce`. * `(&amp;f).call()` will not work - so you can't, for example, borrow it multiple times to bypass the _call-only-once_ rule. PS. What about `FnMut`? Well, if `Fn` is `&amp;self` and `FnOnce` is `self` - `FnMut` is `&amp;mut self`. There is no version for `mut self`, because it does not change the signature(and even if it did - you could just accept a non-`mut` argument and pass it to a `mut` local variable) 
The reference `x` is also, itself, a value. This means it can be moved- in this case, into the closure, so that it can go with it when it's returned. This doesn't move the `isize`, only the `&amp;'a isize`. Without `move`, the closure instead contains a `&amp;&amp;'a isize` referencing the `&amp;'a isize` in `x`, which is destroyed when `generate_printx` returns. `move` does not automatically restrict a closure to `FnOnce`. That depends on how the captures are used- `Fn` closures take `&amp;self`, so as long as the closure body only accesses its captures that way it will be inferred to implement `Fn`. Only if it mutate its captures (requiring `&amp;mut self`) or moves out of them (requiring `self`) does the `Fn` implementation go away.
Just dive in. I‚Äôm just playing around with Rust for fun, and I‚Äôve never really had to fight the borrow checker for anything I‚Äôve made (not much).By the time this is implemented you‚Äôll have familiarized yourself with the language.
/u/somebodddy clarified the difference between `Fn` and `FnOnce` pretty well, so I just want to mention a case where the `move` distinction is a bigger deal. Look at the difference it makes here, when we try to _mutate_ a shared reference (that is, change where it's pointing): let mut x: &amp;str = "foo"; { let mut f = || x = "bar"; f(); } println!("{}", x); // "bar" vs let mut x: &amp;str = "foo"; { let mut f = move || x = "bar"; f(); } println!("{}", x); // "foo"!!!
It should work as expected. Here is an example in the [playground](https://play.rust-lang.org/?gist=435e847e42c98fea7c2b055820df1cf4&amp;version=stable). I'm not sure what is happening on your end that it isn't.
Nothing I know of but my RFC for external docs got merged and a first implementation is landing soon. You'll at least be able to document things in multiple languages with cfg flags soon.
I think it depends on what you're doing - if it's receiving jobs, a Mutex&lt;Receiver&gt; does make it clear you're doing what you want to be doing. On the other hand, it might have worse performance than a channel built specifically for that purpose.
Hmm, if `move` does not restrict to `FnOnce`, then how is it consuming the `&amp;'a isize`? If the closure `: Fn`, then that would imply that it has an implementation of `fn call(&amp;self, args: Args) -&gt; Self::Output`, but I would expect that to be impossible for the same reason the closure needs `move` for it to compile -- by the time we could call the closure, the reference would be out of scope.
I think your last code block kind of actually summarizes my confusion: with the closures version, you can call `f` twice just fine, but in your structs version, you cannot do `f.call()` twice.
In the PR, @Mark-Simulacrum linked to [this page](http://perf.rust-lang.org/compare.html?commit_a=0253d98382fa351d53880605a346d0ea2e941a07&amp;commit_b=b669ce1863e5451453545f892d1014eb16b9a878&amp;stat=instructions%3Au) that has some numbers. TLDR: almost 60% faster in some cases.
I've been looking at code samples and it seems to me that `.unwrap()` and `?` serve very similar purposes. Could someone explain what the difference is?
Constructing the closure in `generate_printx` moves the `&amp;'a isize` into the closure. Both the closure itself (containing a `&amp;'a isize`) and the `isize` it refers to are thus still around after you return from `generate_printx`. Then when you invoke the closure, nothing is moved. The closure that contains the `&amp;'a isize` is, instead, borrowed (`&amp;self`). Thus, the closure and the `&amp;'a isize` it contains are still there afterward in case you want to invoke it again.
Yup - that's because that last block is not a struct version of `Fn` - it's a struct version of `FnOnce`.
I was actually surprised the second code would compile - it's just so rare to use a `move` closure and **not** move it outside the scope. Then I remembered my own advice, converted it to struct style, and it all made sense...
I fixed the problem by running rustup self uninstall and doing the whole thing over again. My environment is running again!
I remember Bjarne Stroustrup mentioning absence of tools to update old C++ workarounds to new C++ standards being a large pain point for the language. Having something like this in clippy would make the language more appealing in that it improves discoverability of new language tools and helps update everyone to the same internalized model of what idiomatic Rust code looks like.
x.unwrap() =&gt; match x { Err(_) =&gt; panic!(), Ok(x) =&gt; x, } x? =&gt; match x { Err(e) =&gt; return e, Ok(x) =&gt; x, } One panics (which exits the program and prints a message), the other returns an error value from the current function.
&gt; In addition to environment variables, the build script‚Äôs current directory is the source directory of the build script‚Äôs package. http://doc.crates.io/build-script.html#inputs-to-the-build-script I assume this doesn't change in a workspace since that would break build scripts, but its easy enough to test. If you're trying to access some files of the crate in the build script the [build script environment variables](http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts) may be helpful.
Note: the ad mentions Portland and Mountain View for locations, but in practice this should be expanded to include Berlin, Paris, and San Francisco.
Yay! I tried rust about a year ago and I got turned off it because I was spending too much time fighting the borrow checker and things like that, and not enough time actually solving my actual problem. I'm excited to give it another try in a few months once this has been released!
Perhaps related, I've run into some issues with serde_yaml where reading a string sometimes fails because the string has one garbage character at the beginning. Not sure what's up with it. Which OS are you using?
Wait, what is happening here? Is `x` being copied?
Is anybody aware of a tool that used to be discussed on Planet Mozilla quite a bit that could apply diffs of syntax usage patterns to entire codebases? For instance, adding or removing semicolons or chage the order of arguments.
Fair enough :). I filed [an issue](https://github.com/rust-lang/rust/issues/44937) so at the very least this is tracked somewhere.
Actually, I take it back - it doesn't make sense with structs either. As /u/dead10ck says - `x` is being copied here. If we replace it with some custom type that does not `impl Copy` only the non-`move` one will compile: https://play.rust-lang.org/?gist=acf19328317ae1b32366c49623d63ffb&amp;version=stable https://play.rust-lang.org/?gist=67ed2a65a4b3569656a6b3ca1db78cf8&amp;version=stable
I am so excited for this. I think this has the potential to be *the* single biggest improvement to the language's usability. I will feel much more confident encouraging others to invest in learning Rust without worrying that they'll give up after fighting with the borrow checker.
Head over to r/playrust, this is about the rust programming language
In the `move` example, yes, just as if you'd assigned it to another variable. It might also help to try the exact same examples, but with `x` as an integer instead of an `&amp;str`. The result is the same.
Ahh I see thank you!!
If you can start thinking in terms of stack frames, I think things will become far clearer and there would be less concerns over the need to know when exactly something drops. There should be an intuition that something that lives longer will get allocated on the stack earlier, and will be pulled off later. It gets dropped when the stack pulls back far enough. For heap stuff that will have a reference on the stack, and when that reference gets dropped so does that heap allocation.
Relative paths are relative to the current working directory, usually the same as the one containing your `Cargo.toml`, so you want to open `"src/hello.txt"` or move `hello.txt` up to the same level.
Thanks. Wish error message had "No such file found on &lt;absolute path&gt;" like message :(
It pretty much just takes the error string the OS provides. I guess the stdlib could provide better error messages for given error codes but it'd be a lot of effort for not a whole lot of benefit. 
Unless I'm grossly mistaken, references cannot ever change when something is dropped (that's up to the owner), and NLL doesn't change that. So to know when something is destroyed, you can use the same block scope reasoning that you've been doing.
&gt; lot of effort for not a whole lot of benefit As I know many languages including Go, PHP,.... &amp; etc showing this type of meaningful error messages. And its a whole lot of benefit to identify exact issue and reduce the learning curve. And especially for newcomers, learn without expecting magic.
WAT
My advice: if you're fighting borrowck, just `clone`liberally and take things by value to eliminate the use of inconvenient references (and thus their angry lifetimes). Rust is still going to be way faster than "easier to use" languages anyway, and you will solve the actual problem first, after which you can get back to borrowck after you actually profile and figure where is it worth it. Yeap. I know it doesn't solve all the issues all the time.
Yeah, the main issue is someone's just got to make the effort. You're welcome to [open an issue](https://github.com/rust-lang/rust/issues/new) if you want, or I can do it for you. This would be a pretty good easy-ish task for someone to take on, though it'd probably have to be done separately for each platform.
done sir :) https://github.com/rust-lang/rust/issues/44938
There's [Coccinelle](http://coccinelle.lip6.fr/) for C.
Have you solved it?
NLL changes the rules to find lifetimes, but lifetimes doesn't affect codegen. So everything that worked before NLL, will work the same way after. But some code, that didn't pass borrow checker, will pass it with NLL. To summarize, borrow checker just checks the program and disappears before codegen even starts. 
You're in luck, the impl period has just begun. Go to https://www.rustaceans.org/findwork and find a project you are interested to help. You will be assigned a mentor, who will take you through the process to work on that project. I can only speak for myself, but every time I have worked on mentored issues, it was really awesome (thanks go to eddyb, nmatsakis, alexcrichton, manishearth and a lot of others).
Whoa thanks. I didn't know about that. So does this apply only to the issues the impl period tab?
No, there are in fact many Rust projects that will offer mentorship for easy issues. What's more, if you find a project you want to work on that does not supply mentored issues, you can ask for mentorship right here!
If you want to load a file at compile time, you may want to use `include_str!` macro.
I agree that lack of NLL is not a 'show-stopper' but it simplifies life in some counter-intuitive cases. Take a look at https://github.com/nikomatsakis/nll-rfc/blob/master/0000-nonlexical-lifetimes.md#problem-case-2-conditional-control-flow
wow, It's working!
Agreed - the hacky blocks are embarrassing. Especially when having to explain their necessity to others: "Yes my friend is _very_ clever, but can be a bit stupid in a pedantic way sometimes"
Okay, it seems to be related to the Visual Studio Code console. Both the normal windows cmd and PowerShell display it as expected. Thank you for the help 
Windows 10 64 bit. As mentioned above is a VS Code issue. But thanks for the heads-up, when I encounter it again in the normal cmd I'll look out for the invalid characters
Some cases...? How about average cases. Sorry for my naive question, not in a good place to look at the video right now..
Aren't there cases where the borrow checker can't prove something so it has to insert dynamic checks? Or is that isolated to bounds checking?
Rustc will sometimes insert dynamic checks for destructors, but lifetimes *never* affect when destructors run (in fact, they never have any runtime effects).
So I keep remembering this and was sitting down to do it when I read this HN comment thread: https://news.ycombinator.com/item?id=15369360 What do folks around here think? Is Mozilla Foundation something that I should give money to? Or is there another group that might be better for Firefox or an open web? EFF? I guess I could split up what I was planning to donate across a few orgs..
I updated to reqwest, and the problem appears to be gone.
[removed]
Yes in a sense, but it's not the borrow checker that adds the checks. If you need to use `RefCell`, for example, because the borrow checker can't prove your code, you're adding a runtime check, but that's the `RefCell`, not the borrow checker itself. The borrow checker never has any runtime semantics, it's just a fancy type-checker.
You wrote this for /r/programmingcirclejerk didn't you ?
no, this is just for you. &lt;3
This is a modified "Rick and Morty" copypasta, and sort of runs afoul of rules 3 and 4.
Rule 4 specifically is worded to only apply to "other" programming languages, as otherwise half of this subreddit would have to be banned.
That's why I said "sort of". I'm not a mod, so it's ultimately up to them.
I removed it. It's *sort of* humorous, but not enough to overlook that it adds zero to the discussion.
We have a few ideas how to handle some cases, but in general there is little cost in having those additional blocks.
You want /r/playrust
Urgh, friendly people and friendly communities.
- Type checker is just a fancy way form of grammar - Borrow checker is just a fancy type checker I mean in the end it's all semantics and you can just as well say programs that don't pass the type system aren't grammatical in which case you give Chomsky a headache but he deserves that ever since he came with that vague infalsifiable UG crap.
Assuming you actually need several threads doing things in parallel, you could make `score` an `AtomicUSize`. That way you can mutate it without having an exclusive lock. You'll probably need to `Arc` at some point, but I'm not sure if that should be the world or every player. In case you don't need multiple threads, you could make `score` a `Cell&lt;usize&gt;`.
You probably only need [immutable access](https://play.rust-lang.org/?gist=b6a93d5a5d22a73f918c7b4fd54fee05&amp;version=stable) to `World`.
What you wrote seems like it should work fine. You get a non-`mut` `&amp;` to `players`, which lets you access the `Arc`, the `RWLock` then acquire the lock, which gives you `&amp;mut` access to the `Player`. The only thing you can't do is add and remove players from the list.
You don't need to produce any references into the `players` vec here. You can simply `clone()` the `Arc` that you need. This works because you're allowed to produce multiple `Arc&lt;T&gt;`s which all refer to the same object. The trade-off is that `Arc&lt;T&gt;` is only allowed to produce `&amp;T` references rather than `&amp;mut T` references. However, `RwLock` is one of those special types (like `RefCell`) which allows you to produce a `&amp;mut T` from a `&amp;RwLock&lt;T&gt;`, so the two limitations cancel one another out.
This is going to be such a nice thing when teaching the language as well. One more wart removed.
`Vec` is only sync-safe (sharable between threads) when it isn't being mutated (adding or removing players). So your proposed data model is sync-safe, and you only need `Arc&lt;World&gt;` if you can live without adding or removing players. But I would warn you that if updating each player's score depends on the other players' data, your data model will give different results depending on the order in which the updates are evaluated. This problem exists if you're using one thread, but it's much more obvious with several.
Do this mean we don't have to deal with lifetime annotations anymore?
So why isn't `Vec` called `SliceBuf`?
To be fair though I feel that that `&amp;mut` is not called `&amp;uniq` or something like that causes a whooooole lot of misconceptons for people who just pick it up. A lot of code also tries to treat it like that in a lot of pretty big libraries using `&amp;mut` where it really is not needed and a shared reference could be used which opens up more flexible use but `&amp;mut` indicates the semantics of that it's mutable.
Post the code?
Total noob here, just read the official book. What will be the implications of this in terms of learning ? Can someone please provide before and after code sample ?
So everytime there is a IO error, the std lib would allocate a PathBuf? I think that might be a problem for some people. 
This RFC only deals with function-local borrows, so it certainly won't resolve https://blog.rom1v.com/2017/09/gnirehtet-rewritten-in-rust/#encapsulation. For that, see https://github.com/rust-lang/rfcs/issues/1215.
I got the answer : https://users.rust-lang.org/t/can-match-arms-return-more-than-one-value/13123 
The author of the RFC wrote a lot of great posts about it [here](http://smallcultfollowing.com/babysteps/blog/2016/04/27/non-lexical-lifetimes-introduction/). The main thing this will help with is the borrow checker. Often things that would be valid and safe code are not allowed in Rust right now. The reason being that it requires some more complex reasoning which is what the RFC for this covers. The TL;DR is beginners won't cut themselves on these cases that can be solved by NLL and overall simplify code for everyone not having to use hacky solutions to get around the borrow checker.
I'd vote for calling `[T]` "array" and `Vec` `DynArr` 
Not necessarily. It just means more cases that are actually safe and valid will pass the borrow checker. You still will need annotations when the compiler doesn't know how long something needs to live for.
Off-Topic-ish. I'm curious if anyone knows good resources for this type of stuff: &gt; Language Design, Compiler Optimizations, Garbage Collection, Static/Dynamic Analysis, Record-and-Replay Debugging, Parallel Algorithms, Graphics, Video Codecs, and Web Application Optimizatio *Without* getting a masters/ PHD of course :P 
So what do you call `[T; N]`? I am in favour of ·∏ßomogeous tuple" and just making `(T ; 4)` syntactic shorthand for `(T, T, T, T)`
Thanks for clarification!
You're welcome! If you want more info Nico had done a series of blog posts on NLL and it's a great read worth your time. You can find them [here](http://smallcultfollowing.com/babysteps/blog/2016/04/27/non-lexical-lifetimes-introduction/)
I would like to write tutorials / blog posts around Rust and figured Pokemon is a pretty widely-known and friendly topic. The original plan was to create tutorial videos but Rust is evolving so quickly and I am an absolute amateur video creator so that has the real possibility to be a trainwreck. Please provide feedback on the code and let me know what I can / should explain or change so I can target Rust beginners with this codebase. I am Phrohdoh just about everywhere online (including IRC which I hop onto every now and again) so feel free to hit me up with questions, comments, concerns, etc. Thank you!
That's a feature, not a bug.
The best way to learn is with practice, by working on stuff. 1) Work on your own stuff. Come up with cool ideas you are passionate about and work on your own personal projects. 2) If you want to contribute to Rust itself, the "impl period" is currently going on (see the other comment on this thread), which is a big development sprint to implement new major improvements to the rust language. There is plenty of stuff (of all difficulty levels) to work on for the compiler, std lib, etc. With all official Rust stuff, there is a mentoring system to help you and guide you. There was also the "libs blitz" initiative to get people to contribute to popular/important libraries in the rust ecosystem. 3) If you don't want to be involved in Rust itself and want to contribute to some other projects, look out for the "This Week in Rust" newsletter that comes out every week. There is a section in in that lists various projects that have asked for help with issues they have. Maybe you will find something you'd like to work on there. Or maybe submit a patch or two for some library you are using in one of your personal projects. :) Be sure to also check out other Rust documentation, blogs, the first edition of the book (it is written in a different style and covers everything in a different way, might be useful to get a different perspective and possibly learn something new). There are plenty of great blog posts on the web written by Rust devs about all kinds of interesting things: programming techniques, coding style, performance optimizations, the workings of the Rust language and compiler, etc.
Sort of. It's actually harder to teach in many ways. Basically, my view on NLL is, it's harder to understand, but tends to Just Work more often. So, it's positive as a whole, but it is more complex.
The original XKCD is also quite relevant to Rust, seeing compilation times ...
Thanks for the link as well. Awesome articles. Now i know what NLL is :)
Sized array. "Sized" means "all values of this type have the same size." Maybe "statically sized array" but in general we use "sized" and "unsized" rather than "statically sized" and "dynamically sized." The difference between a tuple and an array is that iteration is a sensible thing to do over an array and not over a tuple.
Curious, that page seems to imply that it's accounting for the compile and *link* of the whole package. If linking is 50% of the time and that's constant, compilation has to a whole lot faster than 60% for the total to be 60% faster. Now need a linker server that can do incremental linking :-) 
Yay :D
Thanks so much and you managed to mind-f**ked me.. but in a good way :) Can you explain how you managed to mutate the players via immutable access to world?
Do you mean something like a fancy AsRef&lt;T&gt; implementation for JSRoot&lt;T&gt; or some other kind of indirection? Are embedders of libservo using IPC to communicate with the engine or is the API a wrapper for that? Also, unrelated, but do you know of a working shell for Android using this?
Is that accomplished through accessibility APIs (a11y)? I know the caret functionality in FF and the old find-as-you-type were connected to that in some way.
What is the `rustc_private` used for in Servo, also, is `rustc_serialize` still used or has that moved to `serdes`?
I was concerned about the complexity too, but after using TypeScript 2, which has a related feature that allows types of variables to be different depending on control flow (as opposed to lexically), I've found that control-flow-sensitive typing is pretty natural. If anything, TypeScript's typing is weirder than NLL, as it pattern matches on various expressions like "typeof(x) !== 'string'" in order to refine types, which makes the purist in me feel dirty, but it works really well in practice.
Probably those numbers are misleading. Some preparatory work for enabling red/green stuff have introduced some serious performance regressions weeks ago. I'm not sure the improvement with only the last PR will compensate those regressions. We'll see in the future how goes performance-wise.
&gt; Are embedders of libservo using IPC to communicate with the engine or is the API a wrapper for that? &gt; There are no embedders of servo. This API is being built right now. I don't think it's using IPC. &gt; Do you mean something like a fancy AsRef&lt;T&gt; implementation for JSRoot&lt;T&gt; or some other kind of indirection? I don't see how AsRef helps. But yeah, basically an API where embedders can only see roots and/or manipulation is carefully tracked. Basically, take something like [rust-gc's rooting model](https://github.com/Manishearth/rust-gc) (which is safe and needs no lints) and shoehorn it into the types we give to the embedders.
Estupendo. Por el motivo que sea no veo mucho inter√©s por el Rust en los programadores hispanohablantes que conozco. Espero que esta situaci√≥n cambie. 
Via interior mutability. https://ricardomartins.cc/2016/06/08/interior-mutability
Link: https://xkcd.com/303/
[Image](https://imgs.xkcd.com/comics/compiling.png) [Mobile](https://m.xkcd.com/303/) **Title:** Compiling **Title-text:** 'Are you stealing those LCDs?' 'Yeah, but I'm doing it while my code compiles\.' [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/303#Explanation) **Stats:** This comic has been referenced 971 times, representing 0.5732% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dnq9y1o)
If I need to be able to deserialize static arrays with different lengths &gt; 32, is there a better way [than this](https://play.rust-lang.org/?gist=9092b93388627a784539961c7ced23f0&amp;version=stable)?
I mean, it would be less code to just serialize and deserialize Vecs instead of fixed length arrays for *most* purposes, but for extra long fixed length arrays with Serde, that appears to be as good as it gets, in my nonexpert opinion.
I'd suspect the "UTF-8 BOM" in this case?
This is all of my interests. Thanks, will look at it more later tonight.
As others are saying, it's hoped to be less important to have a precise model for reasoning about lifetimes because they don't affect program behavior at all, just whether your code compiles or not. You mention "the point a value would drop", but lifetimes refer to borrows, they don't ever change when a drop occurs. I think you've stumbled on, IMHO, Rust's worst terminology flub. "Lifetime" has a clear and intuitive meaning... that doesn't match how its actually used in the Rust language. It is similar enough that people don't realize it for a long time, though, until eventually they trip on it.
Thought so too but it was random letters. Unless there was some buffering weirdness going on when trying to print a BOM
So is systemd bricking your machine, clearing out your root directory and ignoring keys it doesn't recognize rather than errorring out and Wayland's inability to be useful for more than facebook browsing because it needs to be more secure on the 0.0001% of systems that have LD_PRELOAD, ptrace and an ability of users to modify their own PATH via MACs disabled.
You're looking for /r/playrust
/r/playrust Rust is actually a programming language as well (and check Firefox 57 when it's out to see why it does matter).
Note that by using `.expect("message here")` you are suppressing the built in error message, and replacing it with your own. You can use `.unwrap ()` to get the original message.
Yeah, I think we're on the same page. Things that feel natural can be tough to explain formally.
We're still sort of sorting it out. I'm on my phone and it's late, so the summary is, currently, we add new features to an appendix of he second version, and then at some period of time, possibly coordinated with epochs, we will roll them into the existing chapters. We've also been considering starting a third edition that's basically a copy of the second edition once it's done, and then integrating stuff as we go; it just depends. We'd like to keep some correspondence with print and online versions, and it would be nice to have new features added immediately, but also it can be better to do it in chunks. We're mostly focused on shipping the second edition ASAP, and then will sort out this stuff after.
In case the previous link wasn't enough for you, here's a different (brief) angle -- Keep in mind that the purpose of mut vs not mut isn't chasing some sort of functional purity, it's to eliminate shared mutable state. Typically that means having mutability xor sharing, but some types are able to enforce at runtime that there is no sharing happening in an unsafe fashion (in the case of `RwLock` by locking the data when it's being modified). In these cases, the types are permitted to break the rules as they see fit.
 fn select_policy(factor: u64, mut standard_reward: u64, flag:u64, number:u64) -&gt; (u64, u64){ let policy:u64; let reward:u64; match flag { 0 =&gt; (policy, reward) = reward1(factor, standard_reward, number), 1 =&gt; (policy, reward) = reward2(factor, standard_reward, number), _ =&gt; reward = standard_reward, } (policy, reward) }; The reason that this doesn't work is twofold: Most importantly in the last case of the match `policy` remains uninitialized so the compiler complains. It needs to prove that in every arm of the match both always get initialized to something or the function may return uninitializedmemory. Secondly, Rust at the moment just can't assign to tuples, it can pattern match and destructure them but it can't do an assignment like that. There is no reason why it couldn't but it's just not part of the syntax; there is no theoretical objection to it but it's just not there. So you can't do: let (foo, bar); (foo, bar) = (0, 1); But: let (foo, bar); foo = 0, bar = 1; Works fine. Having said that the response is correct that a far simpler way is simply: fn select_policy(factor: u64, mut standard_reward: u64, flag:u64, number:u64) -&gt; (u64, u64){ match flag { 0 =&gt; reward1(factor, standard_reward, number), 1 =&gt; reward2(factor, standard_reward, number), _ =&gt; (0, standard_reward), } }; 
Thanks for the information! Also good luck on shipping the 2nd edition! Makes sense that plans for post-2nd edition are still being considered. In particular, do you think NLL and impl Trait will be included in the 2nd edition?
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/W6Ca0WE.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dnqhuee) 
thank you bot, man you made my day 
a solid 11/10 mate
Wrong sub - you are looking for /r/playrust
Hay un [grupo de Rust en Barcelona](https://www.meetup.com/Rust-Barcelona/) pero lleva un a√±o sin planear ning√∫n evento. A medida que Rust vaya ganando en popularidad aparecer√°n grupos en m√°s ciudades y pa√≠ses.
Does it add 0? 
Dude needs a haircut 
So there‚Äôs no overhead if there‚Äôs no segfault. On the other hand, when a segfault occurs due to lazy patching, the overhead of both the segfault itself and any time spent figuring out what to patch sounds like a lot. It probably helps that the Windows kernel can process a segfault and jump to a user handler much more quickly than either Linux or xnu (macOS), at least as of a few years ago when I tested it. 
He got one in December after his wife called him a dirty hippie
With lexical lifetimes a `MutexGuard` or whatever would almost always be dropped exactly at the end of its lifetime. But the actual guarantee is no value will be dropped until after its lifetime. NLL will make it much easier to observe this quirk, probably with things that compile but deadlock. I love your username, btw. What alternative name would you propose? I like "lifetype". 
Draw your function as a flowchart. To determine the raw lifetime of local variable (say `a`), highlight every time it or a path rooted in it (i.e. `*a.base_ptr` is rooted in `a`) is named. Working backwards from those instructions, highlight every instruction that can lead to an access of that local variable. Now some assignments might not be legal because the pointer value in `a` must be assigned to `b`. In that case, highlight more of the flowchart with a's until you either make everything work or discover a borrow conflict. I didn't grasp everything in the RFC, but that's the core idea in the new borrow checker. The new error messages typically say "you borrowed `a` to make `b` at 1 but then tried to borrow `a` again at 2 when you need `b` at 3."
I thought this might be of interest to some folks - the speaker does a great job of describing some of the really interesting features of ATS - warts and all. It's probably good to be aware of their successes and failures so that we can learn from them.
Muy bueno! Parece que Rust esta creciendo mas cada dia. Y el trabajo por crear este sitio web es estupiendo y - estoy seguro - apreciado. Algunos pensamientos sobre la introduccion: &gt; Rust es un lenguaje imperativo, orientado a objetos y funcional, con gran soporte a concurrencia y de prop√≥sito general. Rust no es orientado a objetos. No soporte herencia. &gt; Rust toma influencia de C++, OCaml, Haskell y en menor medida de Erlang, Alef, Limbo, Swift y otros lenguajes menos conocidos. Es Rust inspirado por Haskell? Tiene sombraeando local (? en: local shadowing) e no tiene monades. Creo que es inspirado por ML. 
There's a cost of not shifting idioms to the new NLL and having two styles.
Wow, that is an annoying break. Thanks for the information. Helped me get back up and running after my update
It's not - `expect` sets the string printed before the error message when the value isn't `Ok`. For `unwrap` the string used is "called `Result::unwrap()` on an `Err` value"
Can't mention TTYs w/o mentioning [In The Beginning Was the Command Line](http://www.cryptonomicon.com/beginning.html)
Puedes ver https://doc.rust-lang.org/reference/influences.html para tener una mejor idea de las influencias de Rust.
Thank you for your submission! Very interesting video. However, it looks quite strange for me, that speaker briefly introduces linear types, memory safety, almost Rust-ish RAII based on ownership, and then basically says, that "ATS has some amazing ideas that I'm not seeing anywhere else". I doubt that such a person who is highly confident in type systems would never studied Rust in depth.
Thinking a bit more about it, the commenter appears to have tried to add NAN.
Oh, I've just read the video description and there we may find the following quote: "My latest passion is languages like Rust and ATS that use sophisticated type systems that allow safe memory access and high level abstractions over unboxed data structures." It is still unclear for me why he says that "anywhere else" thing.
Just saying copypastas are funny but also have some meaning. Funny doesn‚Äôt mean worthless, it‚Äôs just not as explicit (which is usually a good thing imo)
I fully agree. On the other hand, this NLL-style lint could be very trigger-happy in current Rust code, so we worry it might drown out the other lints.
So since you seem to be equating the community with software projects that you appear to have problems with, what's your problem with the community?
talchas on #rust IRC suggested [ArrayString](https://docs.rs/arrayvec/*/arrayvec/struct.ArrayString.html) from the arrayvec crate, which I think fits the bill.
ATS has extended their type system to make it almost usable enough to specify conditions and invariants that are then proven (by|to) the type system. This is basically design by contract and goes much farther beyond what Rust is (usually) doing. Mind you, Rust's type system is capable enough to encode proofs too, but the usability isn't there yet.
I think he's referring to things that rust doesn't have but ATS does, like safe, type-level verified pointer arithmatic.
It's like comparing Go's built-in channels to Rust's channels-as-a-library. One language builds in support for a specific use case, where as the other gives a bunch of language features that allow you to build it as a library. Go's approach is more ergonomic of the single use case, but falls down once you want to go outside what the language supports natively. Rust's affine type system is pretty geared around memory and resource management, where as ATS seems to allow you to use these kinds of proofs in a more general way, for things beyond that use case. That comes at a price though, in terms of ergonomics and learnability. It also seems to lack borrowing, which is pretty important for making linear and affine types useful. I'm guessing in the future we'll see more languages that generalise Rust's affine types and regions, and that's an exciting thing to see. Linear Haskell is pretty exciting, for example. Still lacks the borrowing side of things though.
I'm just saying that often features are bad design; I never called it a bug, just bad design. Like I said I dislike friendly people and friendly communities. Effectiveness and getting shit done &gt; feelings of weaklings.
Thank you for the detailed reply! So, to recap, author introduces us to some kind of ML extension that brings huge amount of type stuff including, but not limited to: - Linear logic and proofs as first class objects - Refinement types: ability to put restrictions on values, like n &gt; 10, on a type level - Ability to efficiently solve FP problems like list folding without "hacks" Author shows us how useful it may be if solution not only contains the logic, but also includes corresponding reasoning and even proofs. That way a whole classes of mistakes like off by one errors may be eliminated by compiler, which is impossible in modern Rust, IIUC.
The work with dependent types might help us with that, but it remains to be seen how ergonomic it will be, and checked APIs will have to be added in a backwards-compatible way. The advantage of refinement types is that they are often verified using SMT solvers (correct me if I'm wrong - they could be orthogonal), which can be a double edged-sword. They allow you to do much less proof boilerplate than dependent types, but at the same time can be harder to debug and sometimes extremely bad for compile time performance.
NLL isn't even implemented yet; the RFC was just accepted. I'm not even sure when it will land in nightly, let alone stable. `impl Trait` is in nightly, but I'm not sure if it's ready for stabilization, or needs more work to come inline with the RFC. Without knowing when these things are going to be stable, it's really impossible to say. That said, I'm not too worried about teaching NLL; it's mostly going to make code "just work", rather than be something you actively think about. `impl Trait` is also useful, but not super complex to understand in the usual case, which is the return position.
I personally think the amazing success of the Rust community so far is a powerful counterpoint to your argument. We are much more powerful than you're giving credit for. This is no accident. Turns out that on average those ninja rock star geniuses aren't quite as brilliant as they claim, and many of those turned away by their 'tude benefit this community much more than a few ***holes ever could.
Small note, they're planning on re-doing the tokio docs entirely, but that of course doesn't help you today.
Nah the docs are good. Its just I get bored with reading, I learn better by doing things, which has its disadvantages because many times I learn the wrong things.
&amp;str is always immutable. Use a stack allocated u8 array and do `std::str::from_utf8()`.
&gt; I personally think the amazing success of the Rust community so far is a powerful counterpoint to your argument. We are much more powerful than you're giving credit for. And yet the Linux dev community is far bigger and they purposefully avoid it and unlike Rust it was originally not backed by a large corporation. There are big projects where they have these American "code of conducts" and those where they purposefully don't. &gt; Turns out that on average those ninja rock star geniuses aren't quite as brilliant as they claim, and many of those turned away by their 'tude benefit this community much more than a few ***holes ever could. I have no idea who "those ninja rock star geniuses" are you bring up and what it refers to but I didn't mention them before.
Rust has seen Mozilla backing pretty late in the runup to 1.0, IIRC. Before it was a personal project of Graydon. Even now, Mozilla employees are in the minority among Rust contributors. Also since you bring up the Linux kernel project, I'm sure you don't have to look very far to find unkind people. Edit: also the Linux community is far older than the Rust community. If you want to compare fairly, you should compare with the Linux community around 1994.
The last example on https://doc.rust-lang.org/stable/std/str/fn.from_utf8.html has working code for this.
&gt; Also since you bring up the Linux kernel project, I'm sure you don't have to look very far to find unkind people. Which is my point, you claim that projects become big by enforcing kindness yet Linux is pretty darn big and Linus has always spoken out against this since he feels it stands in the way of efficiency (not to mention that America-style friendly people are the most obnoxious spawn on the planet) and it certainly doesn't seem to stop Linux development. I don't deny that quite a few people are scared away by a lack of kindness but I feel just as many are scared away too the moment they read this kind of code of conduct and can just sense the America-style fake smiles already and they get turned away just as easily. And this is probably why 8/10 of the top 10 contributors of Rust are apparently North American. Linux development seems to be far more worldwide. &gt; Edit: also the Linux community is far older than the Rust community. If you want to compare fairly, you should compare with the Linux community around 1994. No, because everything was smaller back then.
&gt; However, it looks quite strange for me, that speaker briefly introduces linear types, memory safety, almost Rust-ish RAII based on ownership, and then basically says, that "ATS has some amazing ideas that I'm not seeing anywhere else". I don't know ATS beyond what I watched in this talk, but he talks about *proofs* using linear logic, not just types. This would be as if `T: PartialEq` had ownership - once you used that proof once, you could never use it again (though he refers also to syntax for declaring proofs that are not linear). This is because ATS allows you to prove facts about program *state* at a particular point in execution, whereas Rust's proof system (what we call trait bounds) is designed to prove only universally true facts about your program (primarily that types implement traits). ATS's system is significantly more powerful and significantly more difficult to use. When he shows code like this: val (awesome_proof | fd) = open_file("some_file.txt"); val contents = read_file (awesome_proof | fd); That is something wildly different from Rust, maybe with Rusty syntax it would look like something this: let fd&lt;where AwesomeProof&gt; = open_file("some_file.txt"); let contents = read_file::&lt;where AwesomeProof&gt;(fd); You're passing around ownership of these type-level facts, not just of runtime values.
The main reason this doesn't really exist is that UTF-8 chars are encoded in variable numbers of bytes, so most mutable APIs (any that involve changing individual chars) wouldn't work. If you only need to support ASCII, you can use an array of bytes, or I believe there are libraries with nicer APIs than that.
We have both a proof system (trait bounds) and a linear type system (ownership) but they're pretty disconnected. ATS in contrast has a linear proof system. I'm not actually aware of ATS having linear *types* like Rust's at all (though I wouldn't be surprised if it does). In theory you could generalize the trait bound system to containing more complex proofs, and then some of them could be linear. In other words, its actually traits that are a limited/narrow form of what ATS has, not ownership &amp; borrowing.
Good article! I didn't know that `RawVec&lt;T, A&gt;` was already available on nightly. Are `Vec&lt;T, A&gt;` and the other collections on the agenda any time soon, or are they likely to be postponed until after the impl period? This feature would be useful for my project, but not quite useful enough to justify reimplementing the collections myself.
&gt; my post about why I stopped writing my projects in Rust. This link is broken!
I think there is a fixed width encoding for the full range supported by utf-8. I want to say it's called ucs-4.
I'm not entirely sure (especially the part about the Foundation being unable to sponsor Corp work I hadn't heard before), but I usually try not to overthink donations too hard. Rather, I try to approach it the same way I approach buying other products: are they doing work that I consider valuable? If they are (like Mozilla is, but e.g. the EFF is as well), then I'll trust their judgment on that more than I'll trust my own, and let them decide how best to use the available funds. Likewise, I'm not going to question whether the company producing e.g. my bedsheets whether they're effectively spending their money towards producing my bedsheets; I just care that I like those bedsheets, and that I'm willing to put that amount of money towards it. (And the primary reason why I'm doing so, is because charities and the likes are wasting a lot of money in having to explicitly justify all their expenses, e.g. by having important people do menial administrative tasks because hiring a secretary would be labelled "overhead". Mozilla doesn't have to justify why they need x employees to me, as long as I see that they've actively contributed to a free and open web.)
Thanks for reporting the issue. I updated the link!
You can still have high standards for accepting a patch without being a dick. I don't see the connection you are trying to make.
&gt; &amp;str is always immutable. Nonsense, you can easily obtain a mutable `str`: let s: &amp;mut str = &amp;mut String::from("Like this, you see?"); Of course there aren't that many things that you can use it for (except for slicing into smaller mutable `str`) that don't require `unsafe`, so the uses are limited.
No one talked about "high standards" and I've no idea here you get that from. There are two problems for me: - America-style friendly people are obnoxious and annoying to work with and interact with. It turns out that most of the world perceives the vaunted smile as dishonest and psychotic. - It's just not an efficient way of communicating if you have to consider people's feelings and constantly have to think on how to phrase everything as lightly as possible lest someone's ego gets bruised.
Awesome. Glad you're enjoying the conf :)
What extension should I use for VSCode: "Rust" or "Rust (rls)"?
Parent is correct, they said `&amp;str`, you said `&amp;mut str`, which are different types.
Even if you do use a 32-bit encoding for your codepoints, you're not out of the woods: [Let‚Äôs Stop Ascribing Meaning to Code Points](https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/) TL;DR: What we think of as a "character" (a grapheme cluster) may require more than one codepoint to represent and a single codepoint may not have meaning in and of itself (eg. one half of a flag emoji).
UCS-4 in Rust is `Vec&lt;char&gt;` / `[char]`, for what it‚Äôs worth. The only time I‚Äôve ever had a use for it was to implement Punycode, which encodes operations like "insert at this code point index".
Then the answer seems a bit like a non-sequitur, as if the OP asked "How can I make a negative number?" and the answer is "`u32` is always positive". It's correct, but could also lead one to believe that there are no negative numbers. You can also create a stack-allocated `&amp;mut str` with [`from_utf8_mut`](https://doc.rust-lang.org/std/str/fn.from_utf8_mut.html). By default it doesn't do much, apart from some ascii upper/lower-case functions.
I have not been to the US yet, so I may be missing some connections. However I see you are equating friendliness with weakness and this is something I disagree with. We can be strong and friendly at the same time. Regarding 'American' friendliness I think I have an idea what you mean, when the friendliness is just a front and the real motivations are hidden. If that is your point then your problem is the alleged inauthenticity of the interaction. Am I right in this assessment? I can only speak for myself, but I can assure you that I am really this way. I do agree that a fair comparison between the Rust community and the Linux community is probably impossible, given the differences in timeframe, history and goals. This still sort of invalidates your argument about the relative merits of their 'fuck you if your code isn't good' culture as opposed to our 'that code shows promise, let's make it better' culture. I will gladly admit that I respect Mr. Torvalds, and that I have a sense where he is coming from. I still enjoy working in this community much more. But that's probably just me.
Why do you say that out trait constraints are a proof system? Is that because you can do compile time computation with them (in lieu of dependent types), ie. defining impls on different types as a hideous form of type-level pattern matching? In fact I think I've just answered my own question... will post this anyway!
&gt; America-style friendly people German person here. What is "america-style" friendliness? &gt; It's just not an efficient way of communicating In my experience it's the exact opposite. Stuff like https://brson.github.io/2017/04/05/minimally-nice-maintainer has helped me communicate with people more efficiently. But I'm not sure if that is the kind of thing you find so annoying; is it?
I recently heard I will be next RustFest Paris' emcee So I'll be there in time introduce with a rhyme (Or some Uke) every speaker for thee.üòéüé§üé∏
&gt; German person here. What is "america-style" friendliness? Bleached teeth smiling at you asking "how are you?" like a ritual and saying "have a nice day" while not giving an arse when you walk away while thinking all the bad things you can't say because life's a popularity contest. &gt;In my experience it's the exact opposite. Stuff like https://brson.github.io/2017/04/05/minimally-nice-maintainer has helped me communicate with people more efficiently. But I'm not sure if that is the kind of thing you find so annoying; is it? Yes, I don't see how wasting time _making up compliments_ can possibly be efficient: &gt; A well-known technique to soften the weight of criticism is to pair it with praise. You‚Äôve probably heard of the ‚Äúcompliment sandwich‚Äù: surrounding the criticism - the meat of your response - with a soft and squishy bun of praise. The compliment sandwich is considered so delectable because it is simple and effective. Before you launch into what you really want to say, try to look for something positive to point out first. No, this is just an insult to the intellect of the submitter on top of that; they have to be pretty daft to not see what is going on and that you purposefully are adding compliments for the sake of it and just feel treated like a child.
&gt; Bleached teeth smiling at you asking "how are you?" like a ritual and saying "have a nice day" I don't see how this applies to online conversation. &gt; I don't see how wasting time *making up compliments* can possibly be efficient Well, there certainly are situations where there is nothing good to say, and then you don't say anything good. But those situations are also almost always those where you don't want any further contribution from that person anyway, e.g. because they want to totally change the direction of the project, or have repeatedly ignored feedback. And I don't think you need to be exceptionally nice in those cases (you should still be respectful, but that's just basic decency). In any other case though, you can always say things like &gt; * Thanks for putting your work towards &lt;thing&gt;, but &lt;issues with patch&gt;. &gt; * Thanks for the report, but you haven't added the log output as per &lt;documentation&gt;, I need that before I can investigate this issue. It hardly requires any effort. But it makes a world of a difference, because the assumption on the other side is usually not "everything is good, except the things pointed out negatively".
We learn what we need to, maybe you need "wrong" in order to recognise "right". Just as you get bored reading the "right" things from the start. There are whole businesses built upon providing "wrong" things to people :) it's not a detour, it's an experience opportunity, giving you arguments to support your beliefs other than "I read it in a book". You can say "I tried that, it doesn't work for shit". That said, I suggest you watch "Fast and Asynchronous 3 : Tokio Drift" ...when I'm done filming it.
Actually, it‚Äôs more than just ¬´ enjoying the conf ¬ª, I regained my confidence in developing Rust applications, thanks to you guys :-)
He cannot be stopped anymore! :o
I agree it's not the most useful thing, but neither is `&amp;mut str`, as you say :)
I'm not sure I'd agree, for example many people learn C the wrong way and unknowingly depend on all kinds of undefined behavior. Unlearning wrong expectations may be harder than just learning something correctly the first time.
Actually I was quite impressed by the way `match` handled functions.
I don't understand why it matters that UTF-8 is a variable-width encoding. You can store and change variable-width characters in a fixed-size buffer. You would have to do some error checking to ensure that you don't exceed the size of the buffer, but you would have to do that for a fixed-width encoding as well.
Unfortunately the fact that `&amp;str` is immutable makes it unacceptable for my purposes; I'm looking for a stack-allocated *mutable* string type.
How *mutable*? You can perform almost no safe mutable operations on strings (String or str). 
I mean, `push_str` is the most obvious example I can think of a mutable operation you can perform on a `String` but not a `str`. Anyway, doesn't really matter, I think ArrayString (see above) is what I'm looking for.
One of the problems with ArrayString, though, is that it appears to only support [certain array sizes](https://docs.rs/arrayvec/*/arrayvec/trait.Array.html) because Rust doesn't yet support [compile-time constants in generics](https://github.com/rust-lang/rfcs/issues/1038). This is pretty irritating. Maybe a macro could be used to dynamically create the missing `impl`s?
&gt; Having another specialised reactor in addition to tokio would help ensure futures become as general-purpose as possible. A good example might be a UI event loop reactor - perhaps as part of gtk-rs or winit. There's already [`futures-glib`](https://github.com/antoyo/futures-glib-rs) which is what I use in [`relm`](https://github.com/antoyo/relm), an idiomatic and asynchronous GUI library.
&gt; To me, this first day of RustFest was more than a talks day, it was an epiphany. Rust brings us more than just incredible technology, it brings us a family. &lt;3
It could, but also, https://github.com/rust-lang/rfcs/pull/2000 *was* accepted, and will end up being implemented by the end of the year, so they may just wait it out.
Yeah. I'm also sitting here waiting on const generics for a few ideas of mine (specifically a fixed-point math library and some related stuff). Const generics will really enable a lot of awesome stuff in Rust. I am also looking forward to something like ndarray but with const generics.
Which version of Rust will include this? 
First it had to be implemented. So whenever that happens it will be in nightly Rust. At some point it will be considered stable and move on to the beta channel. 6 plus weeks after that (because it depends on when it gets into the beta) it'll be released. This is like any other new feature. Some get stabilized faster and some like box syntax just haven't been. It really depends, but I hope soon!
El hecho de que no soporte herencia no quiere decir que no sea orientado a objetos, o mejor dicho, depende de la definici√≥n que des de POO. El propio libro de Rust explica que depende de la definici√≥n que apliques, se le puede considerar o no. Por otro lado Rust s√≠ que tiene influencia de Haskell, que a su vez es influencia de ML.
&gt; The first day is a series of talks from the Rust team (in Mozilla) For what it‚Äôs worth, two of the 16 speakers are employed by Mozilla. Anyone could propose talks to the conference, and I don‚Äôt believe a speaker‚Äôs employer‚Äôs name was a criteria in the choice.
I couldn't be stopped before either. üòÅ
Yep, sorry for that. I will update the blog post tonight. Thanks for reporting the issue.
You want /r/playrust
Aroa has been previously seen on irisk stream getting banned, yesterday I met him on rustopia and he triple domed three of us, as seen on the video my buddy got domed instantly. If any one knows this guys steam id it will be a HUGE help. Thanks 
You want /r/playrust
Every Rust conference I've been to so far has felt like this and it's wonderful.
How can I create a shortcut (.lnk file) on Windows?
You could also have your threads send/receive commands to a central mangment thread which then mutates the structure. Kinda how vulkan works. One thread serializes access and the others can work in parallel just fine.
&gt; So what should I absolutely know about tokio before starting? That Tokio is way over-hyped and one should understand it well before making a decision to use it. It is a complicated solution to a difficult problem. What is the point of a solution that is more complex then the problem?
Hmm I'm not sure. You'd have to ask somebody on the core team about that.
The problem is that it still uses inheritence‚Ä¶
Then would you recommend working with mio? I am doing this to primarily learn about async programming
Yes mio is great.
You could use the ids directly instead of references to entries, so you would do `update_entry(&amp;self, id: u64)`. It's not as nice but I think it's the best for your situation.
I don't see a problem if the concept itself is sound and sufficiently ergonomic.
inheritance was used to "extend" something in one part of the demo, but that kind of "inheritance" can be replicated in Rust by simply implementing a trait instead of extending a class.
The same way you would using C++ https://stackoverflow.com/questions/3906974/how-to-programmatically-create-a-shortcut-using-win32 I'd use the winapi crate for this, since it has declarations for the types and functions you'll need. If you're dealing with a simple API like MessageBoxU you can get away with just declaring an `extern "system" fn`, but when you're dealing with OLE/COM APIs the types get really complex.
The problem is you've grouped all the data together in Database, and the compiler doesn't know that `update_entry` doesn't access `entries`. You might want to make a subtype that contains `access_key` and implement `update_entry` on that type.
I had to take some liberties with what your methods do but here's some [code that works](https://play.rust-lang.org/?gist=f413b1d44f6969d61d9ddf02a742e2e5&amp;version=stable). The main problem is that your update_entry uses &amp;self, but you're iterating over the entries in the struct which requires a &amp;mut reference. This causes a conflict, even if you make &amp;self &amp;mut self you'll still get an error. You're just iterating over each entry and updating it though, so you can move that logic into the update_entry function and avoid all those issues since they're both using the same mutable borrow! :D The code I've linked also encapsulates the methods inside the Database type but not necessarily needing self so you can avoid other borrow check issues possibly. I think this is what you'll need. If you need a method to update a single entry just at that in as well so you can target a specific one rather than all of them! Hope this helps the problem you were having. Does this also answer your questions? It'd be good for you to understand why you were having the error in the first place so you can avoid it in the future. If I didn't explain it as well as I could have please let me know! I'm happy to clarify issues with it.
That's not false. ;) (Your talks were awesome though!)
&gt; let data = fetch_data_from_internet(self.access_key, entry.id); Looks like an operation with potential to fail. I would make this it's own method on **Database**. Perhaps a `get_external_entry(&amp;self, id: usize)` method that returns an `io::Result&lt;Entry&gt;`? &gt; fn update_entry(&amp;self, entry: &amp;mut Entry) Seems a little odd for a method to update an entry to update an entry that's passed into it, rather than an entry within the **Database**. Should be taking an **Entry** rather than a mutable reference to an entry.
My biggest problem with futures is the callback-based API. It's basically NodeJS all over again, maybe even worse because Rust closures are much harder to use (need to move captured values etc.). Unfortunately high-quality libraries with async support (e.g. `hyper`/`reqwest`, `websocket`) already made the decision to move to futures so we're already stuck. 
Thank you! I actually understand why borrow checker thinks the code is unsafe, but all of the ways I could think of to restructure the code added extra unwanted limits or assumptions. In your case you moved `eligible_for_update` into `Database`, which unfortunately doesn't work for me, because semantically it is the caller's responsibility to decide what to update. This could be mitigated by passing an `&amp;Entry -&gt; bool` filter function, but that would narrow the `Database` API even further. In the end I ended up doing something along the lines of /u/connicpu's comment above: I created a separate `Updater` structure that contains `access_key` and is responsible for updating entries. This way I could split the borrows.
Thanks! In the end I ended up doing something like this; I created a separate `Updater` structure that contains `access_key` and is responsible for updating entries. This way the borrows are split and do not interfere. What did you mean by subtype?
### 01 fn main() { let content = include_str!("hello.txt"); println!("{}", content); } ### 02 use std::fs::File; use std::io::Read; fn main() { let mut file = File::open("src/hello.txt").expect("file not found"); let mut content = String::new(); file.read_to_string(&amp;mut content); println!("{}", content); } ### 03 use std::fs::File; use std::io::BufReader; use std::io::Read; fn main() { let mut file = File::open("src/hello.txt").expect("file not found"); let mut buf_reader = BufReader::new(file); let mut content = String::new(); buf_reader.read_to_string(&amp;mut content); println!("{}", content); } bit confusing about **why 01 is not in any doc or cookbook?** ; **why we need 03 while we can do same with 02?** 
&gt; I would make this it's own method on Database. This function does not affect the borrow checker problem, so I just kept it simple in the example code. &gt; Should be taking an Entry rather than a mutable reference to an entry. Technically, there is no problem with updating an `Entry` that is independent of the `Database`. Also this lets me formulate the code simpler like "check if this entry should be updated; if it is, then update **it**" rather than "...then update **an entry from the database with the same ID**". I think I can link entries to the database via lifetimes, but that would uglify code with a lot of &lt;'&gt;s and bring little benefit.
Thanks! I did this as an interim solution initially; unfortunately this does not solve the problem of interfering borrows, so I had to collect IDs into a temporary vector and update entries in a separate loop, which was a bit ugly and non-straightforward.
Option 1 happens at compile time, so it isn't useful unless you're building an asset into the application. If you expect anyone to be able to change the contents of the file after compilation, like a settings file or arbitrary user files, you can't use that, since there is no file access at all after compilation. Option 2 is great for certain situations, particularly small files. Option 3 uses a BufReader which makes doing lots of small reads more efficient, since it buffers larger reads in the background, rather than directly doing tons of small I/O. Using BufReader with read_to_string doesn't help, and it's kinda useless. The reason you get a compiler warning is because read_to_string could have an error, and you must handle that result. You can "unwrap" or "expect" it to crash the program, or you can choose to do something else, but not handling it at all is suspicious, and thus you get a warning.
alignment issue on post, fixed
FYI callback-based usually refers to completion-triggered callbacks (bottom-up), which is expressly not how rust futures work.
If I'm not mistaken, structs wrapping stuff behave exactly as the stuff they are wrapping. Therefore `struct Foo(u32)` should compile the same way `u32` does.
Awesome glad you got something that worked out for you!
Now that I'm back at a computer... &gt; file.read_to_string(&amp;mut content); should be file.read_to_string(&amp;mut content).expect("could not read file"); or it should use some other method of handling the `Result&lt;T, E&gt;` that is being returned by `file.read_to_string`.
I'm a fan of C#'s `Task` type: public async Task&lt;int&gt; ReturnsIntAsync() { DoSomethingSynchronously(); await DoSomethingAsynchronously(); // Returns an int eventually }
yes, `file.read_to_string(&amp;mut content).expect("can't read the file");` fixed the issue. but I didn't get `Using BufReader with read_to_string doesn't help, and it's kinda useless.`
Right now Rust is a great replacement for C/C++. It fails completely as a replacement for higher level languages. Futures/Tokio is a failed attempt to solve the missing language features in a framework. 
I don't know what "completion triggered (bottom-up)" means. Care to elaborate?
&gt; missing language features What language features do you mean? Lightweight threads?
No async/await.
Nothing specific. I just meant a type that was going to be contained by Database :p probably misusing that word
Yeah, but this is not as ergonomic: look at how you would extend a widget from gtk-rs.
&gt; delete some objects will result in memory leaks. Yes. It's always a concern though, even in a GC'ed language if you forget to remove a session from the ID -&gt; SessionState map you are leaking! And from experience leaks are much easier to solve than memory issues, they have perfectly defined behavior.
A `BufReader` is only useful if you're doing lots of small reads. If you're reading the entire file into memory all at once, it literally does nothing. The `BufReader` will recognize that you're trying to do a massive read, and it'll just step out of the way. There's nothing it can do to help. But, if you are going through a file, reading it into memory one line at a time, processing it, and then moving on to read the next line, using a `BufReader` will help tremendously with performance. `read_to_string` is useless for large files, because you can't read a 30GB file into memory if the computer only has 8GB of RAM. It's only useful for small files that you expect to fit into memory easily. If you're not using `read_to_string`, then `BufReader` is very likely to be helpful and useful.
GTK was built around inheritance, not composition. Flutter was built around composition, not inheritance, and they demonstrate how to build a new widget in like 10 lines of code. I don't see how looking at `gtk-rs` is helpful here... the whole point is that current inheritance-based techniques don't translate to Rust very well, which is why Flutter is interesting. Looking at an inheritance-based toolkit and observing that it sucks is what we've all already done, right? Flutter doesn't really use traditional inheritance, from everything that I've seen. "Inheritance" was used as way to implement a trait/interface in the video.
&gt; I'm not actually aware of ATS having linear types like Rust's at all Rust [doesn't have linear types though](https://gankro.github.io/blah/linear-rust/). It does have affine types (move-only types), but it doesn't have real linear types, because `mem::forget` [can be written in safe code](https://github.com/rust-lang/rust/issues/24456), which makes types whose destructor must run unsound (see for example [the whole `JoinGuard` fiasco](https://github.com/rust-lang/rust/issues/24292)). ATS of course does have linear types and I totally agree with Aditya that more languages should have them.
node.js futures and those in other languages work by attaching a callback to them, like you've already seen. The callback is executed when the future complete, which is what the parent meant by "completion-triggered" callbacks. Rust futures don't work like that. In Rust, you build chains or graphs of futures and then poll them, running them through one step at a time. `tokio`'s part here is to associate futures to I/O objects like sockets and poll the futures when the socket is ready. This way can be more efficient, and also doesn't exhibit the rightwards drift you get in node.js. Instead, you have mostly linear structures like here: https://github.com/seanmonstar/reqwest/blob/master/examples/async.rs#L25-L37.
Does Clippy have opt-in lints? Perhaps it could be one, and graduate to an opt-out lint a few releases down the line.
Yeah, we have allow-by default lints. Perhaps we could split the lint to warn by default on the most egregious cases and be allowed otherwise. Or configure something.
Interesting, but from a user's perspective it's still the same callback-based code with long chains of `and_then()`s and many levels of indentation. Am I missing anything?
I know that Rust doesn't have linear types &amp; about every aspect of that you referenced. I was speaking imprecisely because the larger point is that a linear proof system is not just a fancier version of a linear type system.
&gt;I doubt that such a person who is highly confident in type systems would never studied Rust in depth. Well ATS does have features that Rust doesn't. And if you're just interested in the type system, Cyclone is what you would study. Rust is valuable in that it shows that these features can work in a mainstream, ergonomic language, but it doesn't do anything that's not grounded in established theory.
One thing often missed with Rust's futures is that closures aren't required, they are just possible through the combinators as many people may like the parallel to Promises from JavaScript. A future in Rust is just a state machine, and you can use them without callbacks/closures, and just poll them instead.
Well, for one, Rust [doesn't have linear types](https://gankro.github.io/blah/linear-rust/). He also talked about compile-time array bounds checking using proofs, which is of course also not possible in Rust. I think it's very fair to say that ATS is pretty unique. Almost all other languages with dependent types are purely functional. Maybe F* is similar but I know very little about it.
You shouldn't end up with deep nesting, though. API-wise it's like `then` for JavaScript's `Promise`s, if you want. There's also an experimental implementation of `await!`: https://github.com/alexcrichton/futures-await, although it comes with some big limitations and it's not clear how they will be fixed. Sorry if my explanations were somewhat hand-wavy, I haven't really used `tokio` or the futures in Rust.
I'm assuming from your interests you understand kinds.. The `where` clause takes as series of constraints. A bound like `: PartialEq + Send` is a kind function of the kind `type =&gt; constraint`. Currently in Rust the only constraints that you can express are by applying a bound to a type to construct a constraint. These constraints are then validated by the compiler when the function is fully instantiated. This is a proof system, which is why the chalk implementation is literally just a little logic solver. I would say we're very unlikely to extend this system to include proofs about program state (at least, any time in the next several years), but there are a variety of proofs about compile time information that we could allow you to express, such as: * boolean const expressions: `where { LEN &gt; 0 }` (LEN must be a const) * const pattern matching: `where LEN: 1..10` (again, LEN must be a const) * Implications between other constraints: `T: Send =&gt; U: Send` (this does not mean that either T or U must be Send, just that U can always be proved to be Send if T is Send).
Its not that it couldn't be its that many operations are not able to be supported (without some kind of runtime panic or something possible), for example: s[0] = '$'; Only works if s[0] was a single byte character. And s.swap(0, 1); Only works if the first and second characters were of the same byte length. These limitations are why there isn't one provided in the standard library.
Well your name checks out. `Future` is the bedrock on which async/await will be built, just as `Iterator` is the bedrock on which for loops are built. Its not failed, you're just early.
Well, flutter seems to use inheritance to create this new widget in 10 lines of code: We cannot do that in Rust. if you had to implement a trait, we would have to implement all the methods of this trait, so flutter seems to use inheritance to avoid this boilerplate. I took the example of gtk-rs because it also uses trait instead of inheritance, but it is painful to use.
A trait can have default implementations, which is the supposed advantage you're talking about inheritance having here. You only have to override the methods you actually care about with a trait, same as with a class.
I've always believed in the right language for the right job. Howerver, here, it sounds like this is the best web framework period. Is this really the best web framework around (barring immaturity)?
Those operations can still be done, they just won't be constant time since you may need to shift everything. You can still support those operations without returning errors if you are willing to accept potential data loss (e.g. throw away code points if there's no space). I doubt this is why it's not in the standard library. I think it's not in the standard library because it's a relatively niche data type that can easily be defined outside the standard library.
It might be too late now, but this is such a common confusion. Ideally there should be a bit of renaming. Edit: to include the current names: Current -&gt; Proposed - `Future` -&gt; `TaskBuilder` - `Reactor` -&gt; `TaskRunner` - `Task` -&gt; `Task` - `Future` -&gt; `TaskHandle` A `TaskBuilder` is a collection of closures/structs which create the state machine for a `Task`. A `TaskRunner` executes a `TaskBuilder` by creating a `Task`. However, `Task`s are an internal construct of the runner, so the `TaskRunner` should output a `TaskHandle`. `TaskHandle`s are poll-able like today's `Future`. Compared to today, only the names would be different, but with lots less confusion around the whole async task system. `Future` could then be an ergonomic sibling for `TaskHandle`, i.e. a `Condvar` around the result of the `Task` so that `Future`s are similar to every other language which has them. 
No worries!
Sorry, can you step back a little? I know that the "builder" API isn't related to the "pull" approach of futures in Rust; JavaScript does the same thing with Promises, API-wise. But I haven't written too much code using futures or `tokio`, and I'm not sure why you said I was confused. You're describing how things should look like, but I don't know how that relates to the API we have today.
Awesome talk! As for the benchmarks, he shows how it compares to some other high-level web frameworks, but given that it can do static file serving so easily I would really like to see how it compares to nginx.
Sorry, my bad, I meant there is a common confusion around futures, which your post corrected (i.e. the person you responded to was confused). You're entirely correct that Future's in Rust are polled and do not operate in a familiar manner compared with other languages. I just feel like it might be worthwhile if we renamed some of these constructs to eliminate that confusion. 
Oh, all right. But it might still help if you would edit your post to include the current names of those structs and traits. E.g., (*not having read the article yet*) I know there's currently a `Task` type, but you also propose a `Task` and I'm not sure whether they're related.
The thread-local-variable implementation of `task::current()` sounds very fragile to me, and places a much heavier requirement on the runtime environment. It would be much more straightforward to simply pass the task as an argument to `poll`, IMO. There has been some discussion on on this in [this issue](https://github.com/alexcrichton/futures-rs/issues/129). The main reason for the thread-local version seems to be a desire to support code originally written against the `Read`/`Write` traits. Despite rereading that thread several times, I still don't see how this can even work without a lot of accidental blocking. Comments like [this one](https://github.com/alexcrichton/futures-rs/issues/129#issuecomment-275210501) make it sound like any code you want to reuse with futures has to be written with non-blocking IO in mind anyway. [This comment](https://github.com/alexcrichton/futures-rs/issues/129#issuecomment-275268936), on the other hand, suggests that it should be possible to use a task argument by default, but use a thread-local (or field?) only in some situations where you *know* you can get away with it. I don't feel like I have anything to add to the issue thread, but maybe someone here knows something I'm just not getting, or has something to add?
Already submitted: https://www.reddit.com/r/rust/comments/73j4p5/a_not_so_gentle_introduction_to_systems/
What features of Rocket require a nightly compiler? It sounds like a great framework, but a nightly requirement is for me a non-starter. How many years should I expect to wait before something like this is available on a stable compiler?
Being willing to lose data off the end of your string seems like an even more niche use case.
Well, if your have a finite sized buffer, that's the assumption you make. I can't think of a situation where I'm very interested in memory usage for a mutable string *and* unwilling to lose data off the end.
"best" is probably a little subjective, but IMO it's going to really shine once it (and diesel) have async support.
No one seems to be answering the "why" of this question along with offering solutions. You're getting this warning because you ignore the Result that's returned by the call on line 8. Result is a type that indicates that an operation may fail at runtime, so ignoring it is probably bad for program correctness, hence the linter warning. `expect(...)` can be used to turn it into a panic which will abort the program, or you can otherwise handle the Result with a match, `is_err`, etc.
I copied the code of his new widget: class MyFab extends StatelessWidget { final VoidCallback onPressed; final Widget child; MyFab({this.onPressed, this.child)} @override Widget build(BuildContext context) { return new Material( type: MaterialType.circle, child: new InkWell( child: new Container(child: child, width: 100.0, height:100.0), onTap: onPressed, ), elevation: 12.0, color: Colors.green, ); } } And he uses it like this: new MyFab( onPressed: _incrementedCounter, child: new Icon(Icons.add), ) Now, let's translate it to Java(forgive me for the poor choice of language - it's needed). Java does not have named arguments(and neither does Rust!) so I'll use the builder pattern: public class MyFab extends StatelessWidget { private final VoidCallback onPressed; private final Widget child; public MyFab(VoidCallback onPressed, Widget child) { this.onPressed = onPressed; this.child = child; } @Override public Widget build(BuildContext context) { return new MaterialBuilder() .type(MaterialType.circle) .child(new InkWellBuilder() .child(new ContainerBuilder().child(child).width(100.0).height(100.0).build()) .onTap(onPressed) .build()) .elevation(12.0) .color(Colors.green) .build(); } } Now, note that we only implement two methods - the constructor and `build()`. What if our toolkit had something like this: public class StatelessWidgetAdapter extends StatelessWidget { private final Function&lt;BuildContext, Widget&gt; buildDelegate; @Override public Widget build(BuildContext context) { return buildDelegate.apply(context); } } Then we could just write this(imagine it's in some class): public static StatelessWidget myFab(VoidCallback onPressed, Widget child) { return new StatelessWidgetAdapter(context -&gt; new MaterialBuilder() .type(MaterialType.circle) .child(new InkWellBuilder() .child(new ContainerBuilder().child(child).width(100.0).height(100.0).build()) .onTap(onPressed) .build()) .elevation(12.0) .color(Colors.green) .build()); } And viola - the user code is without inheritance! In Rust, it may look something like this: pub fn myFab(onPressed: VoidCallback, child: Widget) -&gt; StatelessWidget { StatelessWidget::new(move |context| { MaterialBuilder::default() .materialType(MaterialType::circle) .child(InkWellBuilder::default() .child(ContainerBuilder::default().child(child).width(100.0).height(100.0).build()) .onTap(onPressed) .build()) .elevation(12.0) .color(Colors::green) .build()) } } No inheritance - only composition. 
Not sure why this was being downvoted since it is IMO a legit concern. Given the list of features (https://github.com/SergioBenitez/Rocket/issues/19), the fact that they are still adding new nightly features, and there are no concrete time plans for some of the features IIRC, my guess would be +1 year-never. Rocket's main focus has always been usability, and they are willing to put that above stable-compatibility, which is a stance I can respect. The main thing driving usabilty is probably the `plugin` feature, and until that is stabilized nothing on stable will come close in my opinion. If you want a web framework on stable, you should look elsewhere. I personally like Iron, but other people also had sucess with using hyper directly, so I wouldn't worry to much about the frameworks.
Specialization and a bunch of other features https://github.com/SergioBenitez/Rocket/issues/19
Hi, speaker here. This is a great discussion. Just FYI I did put some time into researching Rust. While I don't consider myself an expert I did a [Rust talk](https://www.youtube.com/watch?v=U3upi-y2pCk) at Strange Loop last year and have some [demo code](https://github.com/deech/shen-rust) as well. Also some folks have brought up linear vs. affine types. I admit to being fuzzy on the difference as I've seen conflicting definitions. If it helps ATS lets you both ignore a linear proof and tell a function to not consume it. All linear proofs must be consumed by the end of the program.
&gt; Is this really the best web framework around (barring immaturity)? In Rust? I'd vote yes. I like [shio](https://github.com/mehcode/shio-rs)'s API as well. In any language? It's hard to argue best when anything is available. I'll opt for explaining features of various frameworks. Rocket's RequestGuard concept is novel (to me at least) and I suspect only really natural in static languages with traits / type classes / concepts / ad-hoc polymorphism and there aren't a lot of those (Haskell, Nim, Scala?). It provides the concern separation that most frameworks get from middleware. The main difference is that it's on-demand so you can justify much more expensive operations. This is hinted at in the video but having an `AdminUser` parameter is asserting: 1. The request is properly formed 2. You have a database connection 3. The database is working 4. The user ID passed in as part of the request is valid 5. The user is an administrator If anything in the list above fails, the handler doesn't get called. That's a lot of checks that don't happen in handler code, which only has to deal with the happy path. Moreover, it's written in one place (like middleware) and all the above invariants are global to the application. Theoretically there's no limit to the amount of work you could farm out to this mechanism. If you were writing a forum and a some of your routes required doing some operation on the participants in a thread, you could have a `ThreadUsers` type and do the retrieval in its guard. This doesn't seem like a good design decision to me but I just want to point out that they're potentially a general mechanism for reusing tricky/expensive code. So, what's not there? No HTTP2. I'm sure this will happen eventually but the new standard offers a lot of shiny features for getting better app performance. Support for the protocol doesn't seem to be that widespread outside the Go community but it's pretty popular there. I'd like to see a Rust take on the [Event Machine's http decision tree](https://raw.githubusercontent.com/wiki/basho/webmachine/images/http-headers-status-v3.png). Getting all the details of HTTP correct is not something most people care about but if we're arguing about the best http framework, I think allowing the app developer to put in the minimum work to fully handle the spec is a valid point of comparison. [Finatra](https://twitter.github.io/finatra/) gets mileage out of Finagle's extensive middleware ecosystem. As an example, you can set per-route timeouts with fallback content. Having a similar ecosystem is a longstanding goal for Tokio so I expect it to happen but it's not there yet. It's kind of a fringe feature but [Seaside](http://www.seaside.st/documentation/tutorials/A%20Walk%20on%20the%20Seaside) exposes continuations as a concept, which makes implementing multi-step actions considerably easier. [Dropwizard](http://www.dropwizard.io/) has a large emphasis on handling the non-http part of building a web app. Rails has a ridiculously large ecosystem and an emphasis on consistent patterns. By virtue of being in the same language, the various node.js frameworks make it reasonable to render client-side template/view code on the server and substantially reduce the time to first meaningful paint. This is possible with other languages (I've seen it done in Clojure) but it's not nearly as widespread. So that's what I think of what Rocket brings to the state of the art in web development and a sort of bucket list of things I find neat about other frameworks. I think Rocket is pretty good on the whole.
I'm currently rolling my own event loops and state machines and that always seems much, much easier to me than trying to grok futures. 
ATS takes proofs very seriously. There's a whole proof level language that is an analog of the term level language just for constructing ad-hoc inductive proofs. I just didn't have the ability to show it in the time I had so just mentioned if off-hand at the end. I realize if you don't read ATS code (and even if you do) the following might be complete gibberish but I show it because it demostrates how much flexibility ATS offers at the type/proof level. This is a proof function that given proof of a C array at some address will split it into two proofs at some index. This is essentially slicing but much more flexible. I can go through it line by line but I thought it'd be more valuable to show just how familiar the syntax is to people familiar with ML compared to a full blown proof assistant. And that's just the beginning, ATS is a very intimidating but powerful language. prfun array_v_split {a:viewt@ype} {l:addr} {n:int}{i:nat | i &lt;= n} ( pfarr: array_v (a, l, n) ) :&lt;prf&gt; @( array_v (a, l, i), array_v (a, l+i*sizeof(a), n-i) ) primplmnt array_v_split {a}(pf_arr) = split (pf_arr) where { prfun split {l:addr} {n,i:nat | i &lt;= n} .&lt;i&gt;. (pf_arr: array_v (a, l, n)) : ( array_v (a, l, i), array_v (a, l+i*sizeof(a), n-i) ) = ( sif i &gt; 0 then let prval (pf1elt, pf2arr) = array_v_uncons(pf_arr) prval (pf1arr_res, pf2arr_res) = split{..}{n-1,i-1}(pf2arr) in (array_v_cons (pf1elt, pf1arr_res), pf2arr_res) end else let prval EQINT () = eqint_make{i,0}() in ( array_v_nil{a}{l}(), pf_arr ) end ) } 
Well, Rust has something like this, but it's still experimental: https://github.com/alexcrichton/futures-await
&gt; s.swap(0, 1); &gt; Only works if the first and second characters were of the same byte length. That works with any byte length. If `s`'s first character is two bytes and its second is three bytes, you can swap them by moving bytes 01234 to 23401.
ATS does support [borrowing](https://bluishcoder.co.nz/2011/04/25/sharing-linear-resources-in-ats.html) but it isn't obvious.
Just wanna thank you for being one of the absolute best programmers on twitter.
IIRC it was to solve an ambiguity
Can you link the specific ones (name &amp; author)? I'm using the one produced by the rust (nursery?) Team and it seems to work OK. However, the RLS tends to freeze every now and then so I need to do some investigating before I make a bug report.
it signifies our devotion to the turbofish
This is what i assumed, but...... what ambiguity could this possible be?
f&lt;a&gt;(x) `f`, `a`, &amp; `(x)` are all valid expressions. So it could be parsed as (f&lt;a)&gt;(x)
That‚Äôs an *inference* ambiguity. We‚Äôre talking about a *syntactic* ambiguity.
/u/steveklabnik1 possible teaching opportunity here: It sounds like wanting compatibility with `std::io::{Read, Write}` has been a major influence on the `Future` trait and all the related `Task` machinery, thought that's not really documented. A lot of people seem to have the "why are we using thread-local storage instead of adding an argument to `poll`" reaction, myself included, and putting a Read/Write compatibility example somewhere more prominent might help us wrap our heads around the whole thing.
~~‚Ä¶ except `bool` doesn‚Äôt implement PartialOrd, so that will never *compile*.~~ *(Actually, it‚Äôs just that chained comparison operators are disallowed because they don‚Äôt make much sense as it stands and can be confused in this way.)* You‚Äôve got to introduce multiple ‚Äútype parameters‚Äù before you can make it work. (e.g. `foo(f&lt;a, b&gt;(x-1))` passes muster.)
Async programming can be many things. Rust channels are way simpler than tokio and will take you quite far.
SIMD is not yet stable in Rust. However currently there's the impl period and they are looking for people who want to help getting SIMD on stable, so you may want to take a look here: https://github.com/rust-lang-nursery/stdsimd/issues/40 Here's the working group description with some help: https://paper.dropbox.com/doc/simd-9H0xb83w1TD8Tc1yEG75M
Interestingly, I've seen a similar idea to 'request guard's in some PHP frameworks, namely Laravel (https://laravel.com/docs/5.5/validation#form-request-validation). imho Rocket's is much more generic and powerful though 
This is not far off from the approach I use in my [UI library](https://github.com/christolliday/limn), which I think is the closest thing to a compositional UI library in Rust right now. I just use functions or builder types (depending on how complex the API is for constructing a widget), that return instances of a `WidgetBuilder` struct. That widget builder itself can be reused or modified by the caller or by other builder functions as well. for example, this is roughly what that example (I think) would look like in limn: pub fn myFab(child: WidgetBuilder, on_click: Fn(EventArgs)) -&gt; WidgetBuilder { let mut widget = WidgetBuilder::new(); widget .set_drawable_with_style(CircleDrawState::new(), style![CircleStyle::BackgroundColor(Color::Green)]); .on_click(on_click); child.layout().add(size(Size::new(100.0, 100.0))); widget.add_child(child); widget }
It looks like 11 separate features that are looking to be stabilized. Are any of these part of the impl period?
I'm not saying that using inheritance has any advantage over composition. And default methods can't solve this issue that easily. You still haven't told me how you would use traits to create custom widgets in gtk-rs, which is based on traits.
Wouldn't that determination happen much later than parsing syntax?
If one wanted to use composition in a UI for Rust, I'd crib from Objective-C and use traits as the target for [delegation](https://www.raywenderlich.com/46988/ios-design-patterns). Other behaviors I would implement as a `vec` of enums.
gtk-rs is not based on traits, to my knowledge. It probably has some traits in it, as happens when using Rust, but it is GTK, which is an inheritance based system. It isn't composition. I remember reading about some serious macro hacks they've been working on to add inheritance to Rust, basically. So, I'm not planning to tell you how to do anything with gtk-rs... there is nothing to tell. and, for the record, you have been saying inheritance has advantages, or you wouldn't be so worried about it. And you did say default methods were the solution, since you said inheritance allowed you to avoid all that boilerplate. If you haven't been saying these things, then your messages were very unclear.
Thanks for the info! I might be able to help.
For me this post kind of operated as a missing manual. It took me ages to figure out that you needed a reactor to process a future. That's absurd, that should have been one of the first things I saw on the readme. Every single thing I've read on how to use Futures immediately dived into how to use tokio and I'm like "No! I'm not using tokio I'm using futures! Teach me about futures!" I had to crawl the source code for quite some time before I figured out what a task was. Futures would probably have a much better reputation overall if this kind of writing was expanded and made front and center. This was excellent, more please.
I actually looked into ATS at one point and even wrote a few exploratory programs in it. And I agree, the proof facilities are very powerful, and better integrated than, say, in Eiffel or Ada/SPARK. With that said, while ATS is an important step in the right direction, I feel the ergonomics aren't there yet. I hope that future languages can learn from it and continue where it stopped to make full-proof programs the norm instead of the exception.
It would, but since the people who designed the language know that it will always fail, they could have decided to make the language always arbitrarily read it as a type param√©trer.
So why does this not apply in Java? Like `object.whatever&lt;Type&gt;(3)` in Java? Why is that not ambiguous. The upper-case names for types are mandated or something?
But bool _does_ implement PartialOrd with `true &gt; false` of course: [`((2 &gt; 1) &gt; false)`](https://play.rust-lang.org/?gist=5823b4f453052193c963db33727018d1&amp;version=undefined).
A parser shouldn't have to understand or make assumptions about the semantics of the language, imo.
The Rust way avoids C++'s infamous "most vexing parse" problem, I think.
Hello, thank you both for the examples. It will surely help me with my problem and help me learn Rust a bit more. (Sorry for the late response, was sick over last few days).
I didn't know this, but I really should have, because in retrospect I've definitely used this. 
I don't know about Java, but in C++ there are cases where you have to add `template` before calls to templated functions (`s.template foo&lt;T&gt;();`) , or `typename` before templated types (`typename Foo&lt;T&gt;::type`). See [Dependent names](http://en.cppreference.com/w/cpp/language/dependent_name), especially the examples at the bottom.
I was actually surprised that it didn't and looked it up I was like "that can't be right?" because it makes total sense for there to be Ord on bools with true &gt; false, like why wouldn't there be?
Apologies: I was misremembering the forbidding of chaining as a lacking PartialOrd implementation. My point that `f&lt;a&gt;(x)` won‚Äôt parse as an expression still stands, just for a different reason.
Hmm, yeah you're right `false &lt; true &gt; true`does not parse in Rust. Then I have no idea why we are Fishing turbots all the time.
In Java for generic methods it's `object.&lt;Type&gt;whatever(3)`, which is unambiguous, but similarly weird. In C++ this is a real ambiguity. C++ has a bunch of ambiguities which make template resolution and typechecking and parsing sort of loop in on each other (I don't recall if this is one of them)
Most Vexing Parse is different, but yes, this is a similar ambiguity.
You can get by with mio as long as your problem is fairly self-contained, or you're prepared to develop support for any additional functionality yourself. The point of a framework like Tokio (which uses mio under the hood, btw) is to provide a common baseline for a certain type of functionality, and let one reuse services developed against that baseline. E.g., if you need an async service which can query [MySQL](https://docs.rs/mysql_async/0.12.0/mysql_async/) and send mail via [SMTP](https://docs.rs/tokio-smtp/0.2.0/tokio_smtp/), you can do it with Tokio right away; not that easily with mio.
Yeah I know, C++' syntax is famously undecidable but to be honest I don't find that claim that spectacular when templates are involved because you can also just write a Lisp macro that recurses infinitely. Rust macros aren't Turing complete right? Also, `foo * bar;` is ambiguous in C without knowing whether `foo` is a type name or a variable. But that's not my favourite one, my favourite one is that Standard ML permits lower-case data constructors so in matches something like `foo` can either be a nullary data constructor or a variable depending on whether you defined the data constructor some-where. Meaning that a typo in any data constructor turns it into a variable which of course matches everything.
You could probably recover some ergonomics by using a bag-of-functions struct as base class and a default instance for stateless widgets. Then just overwrite the entries you need. Doesn't sound like great rust but I am assuming that is how trait objects work anyway.
Last weekend saw a fulminant RustFest in Zurich ‚Äì I'm so glad to have been a part of that. The [impl period](https://internals.rust-lang.org/t/the-impl-period-newsletter-week-1/5971) is well underway, and I'm mentoring some folks to make PRs to various project as part of [hacktoberfest](https://hacktoberfest.digitalocean.com/).
I mean, the latter is true of Rust as well. https://play.rust-lang.org/?gist=5be7fae07fb83b034eaf86aa51c0c14a&amp;version=stable
This is recently improving with incremental compilation. Not in all cases, mind you, but for a lot of cases, the wait is reduced quite a bit.
Most Vexing Parse only exists in a language with the insane declaration syntax of C++, notably, ``` Type name(constructor, arguments) ```
Holy variables in Rust can be uppercase? Wow, data constructors can even be lowercase. Man that seems like a bad idea. So if you `use Foo::*;` that suddenly changes everything and a variable is now a data constructor in the match?
I don't work on Tokio :) That said, I understand the team is going to be re-writing the docs soon.
Yup!
If this is the only source of ambiguity, maybe they could have banned the other meaning. I see no harm in requiring parentheses for such double comparisons.
&gt; It sounds like a great framework, but a nightly requirement is for me a non-starter. We would _really_ like to use Rocket in production at work. It's far better than any of the other Rust frameworks. But requiring nightly to build our code means that we can't, because maintaining code that potentially breaks every time somebody runs `rustup update` is a potential nightmare, especially for services which are updated less often. Nobody wants to try to fix a bug in service "Foo", and discover that it requires a specific 4-month-old nightly compiler. The practical effect of this is that we avoid writing serious web services in Rust. None of the other Rust web frameworks are particularly pleasant to use in my experience (though rustless is not _too_ painful for simple APIs). EDIT: [shio](https://github.com/mehcode/shio-rs) (mentioned elsewhere in this thread) looks lovely! I'll have to try it. It would be one thing if there was a specific roadmap to get Rocket on stable Rust at some point in the future (perhaps after macros 2.0 and specialization, or whatever). But I get the impression that Rocket adds new dependencies on nightly faster than the compiler team stabilizes features.
To correctly parse such constructs in C++ you need to understand if something is a type or not. And for this you will probably need to use SFINAE rules, execute constexpr functions, etc. And you will need this even if you simply want to highlight types and variables differently in your text editor.
Thanks, that's really gratifying to hear! :)
Couldn't you also remove the `Arc` from `players` type when the `World` is always wrapped in an `Arc`?
&gt; when you're dealing with OLE/COM APIs the types get really complex Unless you're living in 1990 somehow, OLE _is_ COM. ;-] (But agreed, COM APIs do get very complex, and not just from Rust.)
Variables can indeed be upper case, just the compiler spits out warnings, not because they can't be upper case, but to impose some common stylistic choices. Those warnings can just be ignored.
Ahhhhhhhhhhhhhhhhhhhhh Now I get it!:D
Yes, agreed, and I am pretty upfront about usability issues in the talk. EDIT: Also wanted to clarify that this proof function doesn't incur any runtime cost. This isn't like contract checking in Ada which does.
Among other things, I did an initial release of an x86 disassembler for Rust yesterday and am working on improvements for the next release later this week. It is a port from an existing C library (BSD licensed), but the internals are still using some unsafe pointers and such as I haven‚Äôt yet gotten everything cleaned up into nice, beautiful Rust. It is called Burst: https://crates.io/crates/burst and https://github.com/endoli/burst.rs I‚Äôll be adding support to it for things other than x86 as well ... I hope to have ARM, AArch, SPIR-V, WebAssembly, RISC-V and more over time. Contributions are welcome! It will be used to replace the Capstone integration in another project of mine ... 
&gt; That works with any byte length. Sure, if you're picking any two consecutive characters.. but I assume you were you just being pedantic? ;-]
&gt; The problem is that it still uses inheritence‚Ä¶ That was my first message: if it isn't clear that I find that as a disadvantage, I don't know what else I could say. I'm not worried about it. Since I'm developping my own idiomatic UI library in Rust ([`relm`](https://github.com/antoyo/relm), in case you don't know), I'm always looking for ways to improve its design. But `flutter` brings nothing to the table, in my opinion. It might have good ideas for mobile apps development, but it's not something I'm looking for. And for `gtk-rs`, yes, it uses traits to kind of simulate inheritance, but I think this is in the way you suggest to use it. For instance, a [`gtk::Button`](http://gtk-rs.org/docs/gtk/struct.Button.html) implements the traits `ButtonExt`, `BinExt`, `ContainerExt`, `WidgetExt`, `ObjectExt` and `ActionableExt` which allows you to use methods of all these traits like a class hierarchy. And the fact that GTK itself is based on inheritance is not a problem, there's many FRP UI library based on GTK.
I've fixed some issues with my crate [`mg`](https://github.com/antoyo/mg), which is a minimal GUI library based on [`relm`](https://github.com/antoyo/relm), √† la girara. I also fixed some issues in my web browser [`titanium`](https://github.com/antoyo/titanium): * scrolling not working in some cases. * load percentage was still shown after loading is done. I also prepared for the presentation I'll give at lambda montreal this wednesday.
My results on quad core: Intel(R) Core(TM) i5-4570 CPU @ 3.20GHz $ target/release/bench_vec -h benchmark-n01 bench_push_avec_elf 11.003 Œºs per iteration (+/- 1.07%) benchmark-n04 bench_push_avec_elf 12.043 Œºs per iteration (+/- 0.88%) benchmark-n01 bench_push_vec 11.432 Œºs per iteration (+/- 0.46%) benchmark-n04 bench_push_vec 12.879 Œºs per iteration (+/- 0.40%) benchmark-n01 bench_push_avec_heap 11.420 Œºs per iteration (+/- 0.47%) benchmark-n04 bench_push_avec_heap 12.710 Œºs per iteration (+/- 2.02%) benchmark-n01 bench_push_medium_avec_elf 1.711 ms per iteration (+/- 4.72%) benchmark-n04 bench_push_medium_avec_elf 3.596 ms per iteration (+/- 10.33%) benchmark-n01 bench_push_medium_vec 2.116 ms per iteration (+/- 2.99%) benchmark-n04 bench_push_medium_vec 3.983 ms per iteration (+/- 18.91%) benchmark-n01 bench_push_medium_avec_heap 1.863 ms per iteration (+/- 1.23%) benchmark-n04 bench_push_medium_avec_heap 3.701 ms per iteration (+/- 5.42%) benchmark-n01 bench_push_large_avec_elf 1.917 ms per iteration (+/- 0.80%) benchmark-n04 bench_push_large_avec_elf 6.073 ms per iteration (+/- 14.39%) benchmark-n01 bench_push_large_vec 2.295 ms per iteration (+/- 0.87%) benchmark-n04 bench_push_large_vec 6.931 ms per iteration (+/- 11.67%) benchmark-n01 bench_push_large_avec_heap 2.349 ms per iteration (+/- 0.54%) benchmark-n04 bench_push_large_avec_heap 6.927 ms per iteration (+/- 16.18%) Edit: grrr, formatting
but that's kinda *the thing*. Flutter objects don't implement a bunch of distinct features like that through inheritance. Flutter doesn't even have basic attributes like margins. You compose your objects. So you build a margin object, then place a text element as the child of that margin. In the GTK world, every element would re-implement the margin logic somehow, even if it's the default implementation inherited through the trait system. They're definitely different approaches. You may not find Flutter's approach valuable, and that's fine.
Right, it takes a lot of shifting if you use non-adjacent indices, which is the kind of hidden cost that Rust tries to avoid.
I quite liked React when I used it for UI doing web/mobile apps. Isn't that also composition focused? Although it really shined with it's declarative language JSX, wasn't too nice in pure JS. Not sure, but I think Rust could support DSL that transpiled to Rust and then went through the compiler?(I think that's what JSX did).
what does this mean? :- a&lt;b&gt;c() a&lt;b,c&gt;d() a&lt;b,c&lt;d&gt;e() etc .. C++ needs the symbols defined in a specific order to even be able to parse it's structure, hence extra complexity in the curse of header files. I'd gladly type an extra occasional ```::``` to avoid that (with most eliminated by better type inference)
This indeed sounds very much like React (philosophy-wise, though many details obviously differ). React does/did have a little bit of 'inheritance' with "mixins", but I think they've moved (or are moving) pretty decisively away from that in favor of decoration.
Regarding the runtime dependency on thread local storage: It's not a hard dependency, you can use tasks in `no_std` environments by using [task::init](https://docs.rs/futures/0.1.16/futures/task/fn.init.html).
A coordinate transformation crate using nalgebra. My hope is to build something with simple helper functions to translate between coordinate systems. As soon as I feel more comfortable I'll publish it on crates.io https://github.com/DaveKram/coord_transforms
Any opinion on Redux? I've seen a few projects attempt to port it to Rust but not seem to manage too well. I quite liked how state was composited and extendable via middlewares.
I've used `galvanic-assert` (one of the "trifecta" mentioned here) a bit for tests in Adhesion, my design-by-contract library. I haven't used a lot of its features, but the ones I have used have been pleasant, and the documentation was good!
We are using the basic "commands + stores" pattern and just pass all of the state + commands objects down the component tree. I haven't really found a more elegant solution for that yet. (For the stores we're using Monix and reducing mutable state as much as humanly possible, instead preferring to chain Observable[X]'s. The application "store" then just bundles all the store Observables up into a single AppState case class and gives that to the top-level application React component.) All in all it's pretty verbose, but it works and is pretty simple to wrap your head around.
&gt; because maintaining code that potentially breaks every time somebody runs rustup update is a potential nightmare, especially for services which are updated less often. Nobody wants to try to fix a bug in service "Foo", and discover that it requires a specific 4-month-old nightly compiler You can add [toolchain files](https://github.com/rust-lang-nursery/rustup.rs#the-toolchain-file) to projects in order to pin to a specific version. It's not ideal though. :/ 
I'd expect it to be in nightly by the end of the year, and in stable Rust early 2018.
Actually, no. Rust will error if you have a variable with the same name as a unit struct or variant.
Updated [on github](https://github.com/durka/macrolisp) now.
Updated [on github](https://github.com/durka/macrolisp) now.
Yo dawg, we heard you like browsers in Rust, so we put Rust in your browser in Rust so you can Rust while you browse rustdoc.
Hey, I'm not sure if this is the right place to ask this but the project I'm asking about is super new so there isn't a designated place to ask questions yet as far as I can tell. I'm playing around with this QT library https://github.com/KDE/rust-qt-binding-generator because I like its approach and the KDE umbrella is promising for future success. So my question is how do I use slots and custom signals? In QT you either specify a QT_INVOKABLE or a slot in order to call a C++ function from QML, I'm trying to figure out how to do that using this library. Thanks! Edit: I should probably ping u/vandenoever cause it's his library so he's probably got a good idea.
ALL GLORY TO THE TURBOFISH!
It's a warning, but yes.
Been working on my Rust/Lua game UniverCity. At this point its less engine work and more time spent adding features/fixing bugs. I did find time to work on the look of water though. https://i.imgur.com/ENPl8k7.gifv
Thank you for the write-up! I believe you've chosen the right strategy of explanation by going into the implementation details. Future-rs does certainly feel more accessible to me now. One think that strikes me immediately upon trying to implement a `Future` is the fact that `poll` doesn't consume `self` but has to return `T` by value. Assuming `poll` can be called at any time, this means either `T: Clone` bound (not always possible!) or throwing up on a `poll` after the value has already been returned. Wouldn't it be more versatile to separate polling from consuming the value? One could still implement the current `poll` by wrapping these two, but some of the clients would benefit much.
I think you have the reason: at the point it reaches the call to `x()`, it has not inferred yet that the missing type is `Foo`. This would require multiple passes of inference. Not sure how to solve that in your case though, maybe that's the reason no such macro exists yet? Although honestly, it wouldn't look too jarring to have a syntax such as `build!{ Foo, x: 1, y 2 }`.
I'm learning Rust with my project [media-toc](https://github.com/fengalin/media-toc), an application to "build a table of contents from a media file or split a media file into chapters". It aims at handling big media files and indexing at audio sample precision. One use case would be the indexation and extraction of individual audio tracks from a concert's video recording. The application uses Rust bindings for GTK and GStreamer. It is developed on Linux, generation succeeds on Windows and it should work on MacOS. Under the hood, the audio waveform rendering uses a double buffering mechanism. The application attempts to display the waveform in such a way the user gets the maximum of context around the sample being played. Seeking in the stream and zooming on the waveform are supported. I need to fix a couple of bugs, implement chapters edition, the actual export and beautify the look&amp;feel a bit :-)
From what I understand: - Affine: consumed at most once. - Linear: consumed exactly once. Rust types are Affine because it's acceptable to just "forget" the values. This means that modelling a state machine in Rust, with one type per state and functions as transitions, you end up either: - having all states be final, since it's not possible to force the programmer to continue, - in the event where the whole sequence happens within a single synchronous call to a function, force the programmer to go to a final state by returning it (assuming there is no other way to create it).
Not too bad, but I'm not giving up my [favorite theme](https://addons.mozilla.org/en-US/firefox/addon/herbal-guitar) :P
[It's an error.](https://play.rust-lang.org/?gist=b92056c2a0eabdb70be024a88c3d7211&amp;version=stable)
Sorry, I was only thinking about bindings in match branches. As seen in the example earlier, it yields warnings when an enum variant with the same name exists.
I'm also waiting on them to make a Barnes-Hut particle physics library for arbitrary dimensionality. I made a really terrible crate when I first started called zoom, but it doesn't provide anything useful because I found it difficult to do that without const generics. I am also curious if we will be allowed to use iterators of fixed size to create fixed sized arrays. It seems like this will be possible, but I don't know if the traits for fixed size iterators will change to use const generics.
[Enum variants will match, not bind to a variable/warn](https://play.rust-lang.org/?gist=3e1d788279e32f6d2e8b7afbf29da7cb&amp;version=stable). If Rust had the behavior you described, everyone would get a warning when they try to match against `None`. You're thinking of constants, which do bind to a variable (since they're treated the same as normal variables in that regard). However, shadowing a constant in a pattern warns, while shadowing a local variable in a pattern is fine.
It's how it is until const generics land. We could support typenum's generic array as a backing for arrayvec again, but the problem there is just the version coupling of using a public dependency -- it blocks arrayvecs 1.0. (const generics arrayvec is 2.0)
The type inference engine is only so lazy, some things require it to become eager, like that call to `x()`. Do you have the code for your macro written? It might be possible to sidestep the `Builder`, `Buildable`, and all these other complicated things. If you're using Custom Derive to `#[derive(Builder)]`, then you should be able to simplify this pretty heavily. But, to be honest, I'm not sure what the advantage of accepts_foo(build![ x: 10, y: 20.0, z: true, ].unwrap()) is over accepts_foo(Foo { x: 10, y: 20.0, z: true, }) which is not only shorter, but also doesn't require any custom syntax or code.
A Redis client that supports clustered deployments, pubsub, etc, built on tokio and futures. Hopefully releasing later this week. ~~On a side note, if anybody has had success with AFL recently I'd be interested in hearing about your build process.~~ [Figured it out, needed to use a nightly build from last April to get it to work with AFL compiled with g++ 4.9 and llvm 3.8.](https://github.com/azuqua/redis.rs/blob/master/tests/fuzz/docker/Dockerfile)
Mmm... then I would have thought this would work: https://play.rust-lang.org/?gist=ddd25626c4f2e5b30897bed05a698ba4&amp;version=stable Since it should first infer the type of the higher order function and only then look at the closure? &gt; Although honestly, it wouldn't look too jarring to have a syntax such as `build!{ Foo, x: 1, y 2 }`. Make it `build!{ FooBuilder, x: 1, y 2 }` and it'll even work with [the derive_builder crate](https://crates.io/crates/derive_builder). But I want to avoid having to specify the name of the type to be built - it should already be encoded in the signature of the function you pass this type to!
As a data point, while I'm pretty particular about Qt, it's not Qt itself that I'm actually demanding of my solutions, but rather: 1. Must look native in a desktop built from QWidget-based applications without forcing me to use a specific theme that the toolkit developer happened to clone. (ie. I refuse to go back to the bad old days of struggling to find matching Qt and GTK+ themes which I could tolerate. For this reason, I'm working to jettison GTK+ apps as they move from GTK+ 2.x to GTK+ 3.x and leave the unifying influence of QGtkStyle.) 2. Must not force me to reinvent common functionality that GTK+ lacked last I checked, such as... * Serializing/deserializing top-level window geometry in one line (QMainWindow) * Serializing/deserializing panel/toolbar configuration in one line (QMainWindow) * A key-value store for UI state with deferred/batched commit-to-disk (QSettings) * Hide/show/reposition/tear-off functionality for panels and toolbars (QDockWidget and QToolBar) * Having really good API docs Basically, I insist on developing Linux applications at something approaching the levels of convenience and consistency that I'd get from something like Windows+C# or OSX+Swift, but without having to tolerate GNOME's very "not me" design philosophy. (Currently, I accomplish that using PyQt... possibly augmented with rust-cpython if there's enough of a distinct "backend" to the code to be cleanly encapsulated.)
[When I came up with the term turbofish](https://www.reddit.com/r/rust/comments/3fimgp/why_double_colon_rather_that_dot/ctozkd0/?context=1) I never expected it to actually catch on. I smile every time I see it mentioned.
Pushing more on the [ggez](https://github.com/ggez/ggez/) 2D game framework * Fixed and cleaned up a lot of little filesystem edge cases, and updated examples to make them more ergonomic * Added a new example for graphics settings (thanks Manghi!) and worked on debugging graphics transform issues * Fixed some string rendering bugs * Added an official-ish way to poll events instead of having to use ggez's event loop or diving into the SDL2 code All in all a productive week! There's really just three big features (glyph caching, vertex shaders and gfx-rs drawing) and one big bug (transform stuff) to fix, and then we'll be on the cleanup phase to make a 0.4 release! Did some thinking about what it would take for me to want to call a release "1.0", which would be really cool, but all I can really say is "we're not there yet".
This project is a successor to my previous re-implementation of GNU Parallel. Rather than imitating GNU Parallel, this project is going to take a different approach, using all that I've learned over the last 2+ years of writing software in Rust. It's only had about three days of development, but the client and server are both functioning today. Some critical features are missing at the moment, and nothing's been optimized yet, but it's functional in it's current state. The server is implemented with tokio-io, tokio-core, tokio-proto, &amp; tokio-service. It also embeds the Ion shell, which now exposes a library interface, for executing commands (am the maintainer of the Ion shell and this is a side project). The general idea is to take commands, and generate slots for those commands that contain instances of the Ion shell. Upon receiving an input, the slot will generate the command, commit a fork, and capture the stdout/stderr of that fork to return to the client upon completion. The client is implemented with standard `std::net::TcpStream`. Nothing truly fancy going on there besides parsing arguments from a variety of sources -- differentiating between a file redirections, pipe redirections, and CLI arguments. And of course, pushing inputs onto a shared input buffer that's performing the connections to all the configured nodes, and receiving/printing results that are pushed onto an output buffer.
Ohh so I was looking for something like this about a month ago and didn't find anything so I was mentally preparing to write my own. I might end up contributing in future when I've got a bunch of things sorted on my own projects :)
Oh, most definitely! Nice catch!
Been working on [cargo-tarpaulin](https://github.com/xd009642/tarpaulin) the code coverage tool. Last week I started working on some issues that popped up after my last release. This week I aim to finish off and close those issues, I'm just wrestling with syntex_syntax right now. For some reason, when I'm walking the AST nodes some "pub mod x" statements aren't traversed deeper despite the modules being part of the project. I initially sorted this by parsing each file on it's own but that caused one of the aforementioned issues so I'm looking to actually solve the problem properly now. Anyone with any experience with syntex_syntax who knows what might be the solution is more than welcome to chime in. I couldn't see an immediate solution when I looked into it
Also that re-uses the same syntax for function pointers. Even if Rust used that syntax for variable declarations, you couldn't confuse it with `Fn(...) -&gt; ...`.
But C++ has syntactic problems that make writing it difficult. For instance only recently have you been able to write `&gt;&gt;` to close two templates, historically it meant right shift, forcing you to write `&gt; &gt;` everywhere. Similarly when writing the parser you end up with fewer abstractions because you can't know if `&lt;` means `PartialOrd::lt` or opening a template in this hypothetical rust so you need basically a `LessThan` sigil that will eventually be transformed once you know enough to do that transformation. Simplifying the grammar means that you can likely know which it is without even consulting what is a type etc.
Doesn't that still basically require the user to implement their own thread local storage...? I guess you could just use a global in a single-threaded environment, but I don't see how this helps reduce the runtime requirements all that much.
Why not use ssh as your client server layer? SSH gives you an interface for executing commands and as a bonus gives you a lot more security out of the box.
What a parser should or shouldn't do is entirely subordinated to what makes the language convenient to use, imo.
Originally tried to use Thrussh, but the crate has no documentation, and the only example provided didn't work at all. Therefore, I have instead opted to use Tokio, and will be implementing support for TLS/SSL encryption and private key authentication myself at a later date. I believe `tokio-tls` may provide that functionality. I will also look into implementing either Brotli or Zstd compression of streams (or both). Also, latency is pretty important for this application, so the least number of external commands invoked, the better.
The bindings offer a shared model that stays in sync by using signals and slots. You do not have to specify them, the signals and slots are created from the json binding. The signals and slots are al related to data that changes. This is to match nicely with the declarative nature of QML. So instead of calling functions, you set properties on the data model.
SSL doesn't provide the same level of security as SSH though. SSL will encrypt the stream and allow you to identify the server as recognized. However it doesn't not do authorization. SSH also has the benefit of pretty much everyone having a server installed with reasonable security defaults.
Authentication will be provided by provided by private keys.
By making the parser simpler, you make the tooling better, which makes the language more convenient to use too.
Yeah, with SPARK you can remove the runtime checks, but yes, the ergonomics put this out of reach for most projects, but those that demand the utmost in security (i.e. whenever enough lives and money are on the line). As I wrote, ATS fares a little better in that regard, but is still far from practical for larger projects (unless cost isn't an issue, see above). Rust takes a different position on the power/practicality scale, allowing to avoid large classes of error without requiring too much ceremony. I just learned about some ongoing work to extend our static analysis powers by /u/oli-obk that will enable us to specify invariants about the code (as opposed to at runtime) and rule out even more error classes. With [rust-clippy](https://github.com/rust-lang-nursery/rust-clippy), we already capture many low-hanging fruit error classes. With that said, I think of both Rust and ATS as good, necessary steps on the way to even better PLs. I hope to live long enough to see some of them come to fruition. 
I second this. SSH has a well-established authentication implementation with known security parameters. It also supports custom channels and "servers" such as sftp-server, or invoking commands with their own protocol over stdio such as `git`. In this way you could support both usage through existing sshd implementations as well as your own. Microsoft is even using this mechanism to support PSRemoting in their fork of opensshd. It would be really cool to support an enhanced ssh mode where stdio is returned from invoked process tagged with a handle and remote process evenrs can be returned out-of-band indicating process exit or job completion.
I started working on a library for technical analysis: https://github.com/greyblake/ta-rs For the first release it's gonna have basic indicators like SMA, EMA, RSI, Stochastic, ATR.
&gt; What alternative name would you propose? I like "lifetype". It almost doesn't matter what else. I honestly can't think of anything worse than "lifetime". The problem with "lifetime" is that is calls to mind the notion of a lifecycle: Birth -&gt; Life -&gt; Death. One would reasonably expect birth and death to be construction and destruction of a value, and life to be the time in-between, but it doesn't mean that at all in Rust. Instead, a lifetime refers only to a *borrow* of that value. Me to babysitter: I've come to collect baby. Babysitter: Baby is dead. Me: What??? Babysitter: ...Meaning I already returned baby to your husband. Me: Umm... Maybe we should use a different word for that than "dead"? Babysitter: Well, *obviously* I meant the death of *my time with your baby*. Rustaceans: Sounds reasonable to me. Me: I need my crazy pills.
[removed]
It's intended that `poll` never be called after a future completes, so it's supposed to panic if that ever happens: https://docs.rs/futures/0.1.16/futures/future/trait.Future.html#panics
thanks, especially for the documentation part. I try to keep that useful. If you have some suggestions I'll gladly consider them. I noticed your crate has an arbitrary block order in the macro. I had a quick look and seems you are using a simplified version of a push-down-automaton for this? I need to add something similar for the blocks in `galvanic-test`.
This is scary: &gt; Once a future has completed (returned Ready or Err from poll), then any future calls to poll may panic, block forever, or otherwise cause wrong behavior. The Future trait itself provides no guarantees about the behavior of poll after a future has completed. I'm not seeing why `Future` API shouldn't try to enforce this at compile time. e.g. `poll` could be consuming `self`, and then `Async::NotReady(Self)` would be returned if it's not ready yet.
Maybe I'm going about my problem the wrong way then. So my situation is that I'm creating a todo app (cause cliche) and I've got the list working and I'm trying to add new items to that list. What should I do so that pressing a button will add the text from a textbox as a new item in the list?
Started adding git repo support to https://github.com/llambda/nary (an experimental JavaScript package installer) via libgit2. I'm hoping to try playing with some security ideas around it. For example, it is already making sure paths are relative (not absolute) in the downloaded tarballs (not sure if other clients do this too). Eventually sha checking (other clients definitely do this already). Perhaps someday performing builds in a chroot jail or some other mechanism, to sandbox potentially malicious packages, etc. I think with current clients a malicious script could easily read files out of your home directory and send them to a remote host, for example.
it is dark, I like that and will give it a try! :)
Performance, since that involves moving the `Future` back and forth. But it's an interesting idea.
are you like a god or something?
I personally have always interpreted it as calls to different functions, because that's what generics in rust (can) do. E.g, a `fn concat&lt;T: Concatenate&gt;(a: T, b: T)` would generate different functions for each struct which Concatenate is impl'd for, so I then view `concat` as more of a grouping than a singular function. (I know this is not actually why this is done, but that's how I like to see it :) )
To add to the sibling comment: not only are most `Future`s going to be fairly large, they also need to be (able to be) immovable [in this sense](https://github.com/rust-lang/rfcs/pull/1858). If we start requiring that `Future`s be moved around, then they can no longer be implemented by generators that hold references to local variables across suspension points. Further, most `Future`s will be polled several times before completion. Requiring they be moved in and out every time complicates both executors and combinators quite a bit. Top-level `Future`s are generally heap-allocated, and so executors would need to start keeping them as `Option`s or using unsafe tricks to avoid a lot of needless allocation. Combinators have similar problems and make things worse as they would need to move all their sub-futures every time they poll them.
Thanks the author for not using ssh
Why is ssh bad?
A lot of this sounds like it's in the middle of changing, but here's some of my current understanding: You do need a reactor, but the simple `future.wait()` method counts as a reactor. It doesn't know how to do epoll IO or anything fancy like that, but it does set things up so that `task::current()` is a valid handle. If you say fire off a background thread to do some work, and then call `notify` (formerly `unpark`) on that task handle from that thread, it wakes up the `wait` loop and drives the future. I've been able to make toy examples work that way for playing with things like timeouts, which is a good way to see `NotReady` in action.
Yeah I get that. I eventually figured it out, this was mostly just me ranting about how long it took me to get there.
Probably the dependence on libssh, instead of using a native solution.
undecidable isn't the issue. undecidable is fine. rust generics are turing complete. rust macros used to be turing complete and may still be. The problem is that C++s syntax leads to weird loops of ambiguity where you need to know about the behavior of the types to parse things correctly.
Hi, I implemented many of the AVX intrinsics in rustc. If the process hasn‚Äôt changed since then, intrinsic definitions can be added to `src/etc/platform-intrinsics/x86/avx.json`. ([Example](https://github.com/rust-lang/rust/pull/32140/commits/37efeae8866c3c4d9827d0ca271b8e27f731c3e1).) Next `librustc_platform_intrinsics/x86.rs` can be regenerated by a script. (See [commit message here](https://github.com/rust-lang/rust/pull/32140/commits/c306853edafb8b740c3e224ce4fa1842a6924dc5).) For `__mm256_unpackhi_ps` we are out of luck though: LLVM does not have a direct intrinsic for it. This is the case for many reordering-related intrinsics. In Clang these are [implemented using `__builtin_shufflevector` instead](https://clang.llvm.org/doxygen/avxintrin_8h_source.html#l02518). I don‚Äôt know how to expose an intrinsic from rustc that compiles to the right shufflevector, but I think this might not be required; if you do the equivalent reordering just on the elements of the `#[repr(simd)]` type, LLVM might use the right instruction anyway after optimization. I think I tried this at some point, but I don‚Äôt remember the outcome. You should check the generated assembly to be sure.
Could you explain why it makes sense? And in what situation would that be useful?
Well, there is one limitation with web frameworks written in a language that doesn't compile to javascript (like Rocket): all the logic that you want to perform both on the client and on the server needs to be written (and maintained!) in 2 languages. Depending on how complex your website is, that can be a lot of work. Especially if you want to use React and do server side rendering. That's the reason I'm still using express.js instead of Rocket. I know there's been some experimentation with compiling rust to asm.js or wasm, but last time I checked (which was a while ago, to be fair) it wasn't very mature yet and there weren't many libraries. As soon as somebody makes a react-like virtual dom library in Rust, I'm going to port over everything. Edit: maybe I should do it myself? How hard can it be anyway?
Working on [SucreDB](https://github.com/arthurprs/sucredb), a distributed KV database with causality tracking (Riak/Dynamo style) and redis protocol (clients).
Doing this would make it tricky (and not free) for `poll` implementations to be panic-safe. Think about what's happening on the inside of an `AndThen` combinator. One of our fields holds some kind of future that we're responsible for polling. All we know is that this thing implements `Future`. In particular it's not necessarily `Clone` or `Copy`; we don't even know how to create another instance of it. Now when our `AndThen` gets polled, we have to call `poll` on this instance. If `poll` takes the instance by value, we have a problem: the compiler yells at us when we try to call it one of our own fields, because it leaves that field in an invalid cannot-use-after-moving state. Even if we _promise_ we're going to reinitialize it before we return, we have to plan for panics happening in between, which would mean we never get our original value back. _Especially_ since we're about to call a `poll` implementation that we don't control. The only workaround I know of for this is to make our inner field an `Option&lt;T&gt;`. Then we could `take` it whenever we need to poll, and assign the result back if we don't panic. (If we do panic, that's fine too, we can just panic again the next time we try to `take`.) It solves the problem, but there are at least two downsides to doing things this way: - Every future combinator now needs to have bookkeeping like this, which is extra trouble to read and write. - The `Option` isn't free. For future types that can't take advantage of null pointer optimization (most?), the `Option` adds at least a byte, and usually 4 or 8 bytes for alignment reasons. The current approach avoids both of those problems, in almost exactly the same way `Iterator` does, by letting implementations do whatever they want to bad callers. It also exposes the `fuse` method, again just like `Iterator`, which lets the caller request "good behavior bookkeeping" when needed. With `fuse`, a very large tree of futures can exist inside a single `Option`, rather than paying that overhead again and again throughout the tree.
x &gt; y is equivalent to x &amp;&amp; !y but saves you two whole characters! 
What exactly do you mean by "native"? SSH is available pretty much universally, the same way libc is.
You also don't need to depend on libssh, ssh is an IETF protocol with many implementations. libssh is just one of the oldest and most battle tested, and available everywhere. Frankly I'd trust libssh more than a rust implementation at this point.
No, I don't have the macro written - figured the macro itself would be easy - just convert the key-value style to method calls. I want to be able to get type inference work in this simplified case(single field, no macros) before I start a custom derive to automate things. As for the _why_: 1. This is supposed to be sugar over the builder pattern - not over struct constructors. So the main advantage is not having to write all the fields: accepts_foo(build![ x: 10, y: 20.0, ].unwrap()) vs accepts_foo(Foo { x: Some(10), y: Some(20.0), ... Foo::default() }) 2. I don't want to write `Foo`. The type is not just one more symbol - it's a new identifier! A new type I have to be aware of - and I don't want to, because `Foo` is not important. `accepts_foo` is important - it's the operation I want to do. `x`, `y` and `z` are important - they are arguments, each doing something relevant to the operation. `build!` and `unwrap` I consider syntax - they are just how the library works, and I would have to learn them once and use them in `accepts_foo`, `accepts_bar`, `accepts_baz` and so on. But `Foo`? `Foo` is just boilerplate. `accepts_foo` can only accept `Foo` - there is no extra user input required to make the decision to use `Foo` as the argument for `accepts_foo`. So why can't I use a macro to hide that boilerplate type?
I'm using it, looks particularly nice when browsing this subreddit.
`Foo` is not just boilerplate. Without knowing that it is `Foo`, how would they know what fields are acceptable? Or when they come back later to modify the code? It hides valuable information. Boilerplate is the code you have to type without any meaning whatsoever, because it's "just how the library works." `build![].unwrap()` is 100% boilerplate, and virtually identical in character length to the `Foo::default()` boilerplate. I see now that the problem is you're hoping to be able to construct a structure without _ever_ naming it to the compiler, except in the type of the parameter, and I don't think that's going to be a good user experience even if you managed to get it working. You could easily build a macro that reduces some of the boilerplate, and I would highly recommend not requiring the `unwrap()`, which is a code smell. Either make the macro check for the required fields at compile time, or automatically `unwrap()` at runtime, since erroneously providing the wrong number of arguments to a function is not a recoverable error. It's a bug in the code itself.
You may want to take a look at and comment on the Tokio [revamp RFC](https://github.com/tokio-rs/tokio-rfcs/pull/2). Which in my opinion outlines the reasoning for a thread local design a bit better, and splits out future execution from io events better so you can have more control here.
ATS, or Applied Type System, is indeed parameterized by constraint domains. ATS has internal solvers for certain such domains, like integers. ATS also supports external solvers (z3/dreal etc) for other domains, like sets/bags/floating numbers or even constraints involving PDE (see [here](https://groups.google.com/forum/#!searchin/ats-lang-users/differential%7Csort:relevance/ats-lang-users/FicryEdQz_M/-qGjUpWvCQAJ)). When constraints get really really awful to solve, one can always manually prove it using proof systems. So, you have a lot flexibilities to work in ATS. Solve easy constraints automatically using dependent types and internal/external solvers, and prove hard ones using manual proofs. 
I have read it- it doesn't seem to really be related to the question of thread-local vs parameter-based tasks. The thread-local default executor makes sense but that's a separate issue, IMO.
I think by "proof system", at least in ATS, it means that we can construct/manipulate proofs as first-class objects in the dynamics. In the talk, the speaker said proofs are "type-level", which is not entirely accurate. Proof objects are actually dynamic terms (that has a special sort), just like other program terms. It's just that proofs are erased after they have been validated. So they don't have runtime meanings. Indeed, one could use ATS as an interactive theorem prover just like Coq, except that it is not as expressive.
Not exactly. libssh is a dependency, and a dependency that certainly isn't supported on Windows. And it's also not implemented in Rust, so there's that, too. Anyway, there's really not much point to it when you can easily implement your own 'SSH' from scratch pretty easily.
Your confusion does help me a lot to understand how to explain Rust. If someone is familiar with Python or JavaScript or practically any dynamic language, the only kind of value they've seen is the rvalue. [Something like this may come as a surprise, to say the least,](https://play.rust-lang.org/?gist=fa9a0169ac11d1bd2ce5da32f2f6462f&amp;version=stable) because it manipulates locations as if they are just another kind of value. Rust converts between rvalues and lvalues perhaps a little *too* fluidly, because it obscures the fundamental truth: You can't borrow a baby (R `Baby`), only a location that contains a baby (L `Baby` -&gt; R `&amp;'borrow Baby`). Just like how that example doesn't borrow a number. The if expression chooses which location to assign into.
[Their web site says it is.](https://www.libssh.org/get-it/) &gt; Anyway, there's really not much point to it when you can easily implement your own 'SSH' from scratch pretty easily. That is a... a very concerning attitude to have. I'm by no means a security expert, but I'm fairly certain rule number one is "don't roll your own security."
I'm not sure what you mean. Proofs which are validated at compile time, then eliminating, having no runtime artefact, exactly fit the bill of "type level." And they certainly aren't dynamic objects if they don't exist in the runtime; all proof computation is performed by the compiler to validate the correctness of code. This is a very expressive static type system.
No one said I was. And the phrase is actually not to implement your own crypto. Anyway, anyone can easily integrate encryption and authentication using what's already there. In fact, that's what most software developers do when creating this type of application. All I'd really have to do is take advantage of tokio-tls to encrypt the stream, and then compare keys for authentication. Not that hard.
&gt; type level Well, ATS has two layers, _statics_ and _dynamics_. If we consider only "terms" and "types" in a language, then the "terms" in the statics are types, and the "types" in the statics are sorts. Building on top of this, "terms" in the dynamics are programs, and "types" in the dynamics are those "terms" of the statics. What I wanna say is that, proofs are "terms" in the **dynamics**, represented as total functions. On the other hand, types are "terms" in the **statics**. The types for a program are static terms of sort "type/t@ype" etc. The types for a proof are static terms of sort "prop" etc. However, I also want to point out that it is ok to say "type-level" in this talk, particularly. I believe the speaker only intended to mean "no runtime semantics". 
It allows you to place booleans in a BTree.
https://crates.io/crates/unidecode
SSL does have authorization, that's what TLS client certificates are for. They can be used in openssl using this https://docs.rs/openssl/0.9.19/openssl/ssl/struct.SslContextBuilder.html#method.set_client_ca_list
lovely, thanks!
Normally you'd call `insertRow` on the model of your todo list. The code generator should, but atm does not, generate code that overrides that function. When you are just starting it might be a tall order to send a pull request to patch this omission of functions for an understandably common use. `QAbstractItemModel::insertRow` is the function that would need be overridden in generated C++ code and for which the rust trait would need a function. You could open an issue for it [1] so I remember to add when next I have time. The todo list scenario is a good one for another tutorial on how to use the generator. [1] https://bugs.kde.org/enter_bug.cgi?product=rust-qt-binding-generator
There's no better way to learn I suppose. If I find the time I'll see about making a PR. Do you have a style guide or contributing rules? Ie, what version of C++ is allowed?
Note that while it can cause *wrong* behavior, it cannot cause *undefined* behavior in the language/memory-safety sense. Panicing when an invariant like this is broken is acceptable-- it's akin to an out-of-bounds access on a `Vec`.
Ha, I ran into something related just the other day. I had an enum variant `Implicit` but accidentally wrote `Implied` in a match. Luckily I got an error message (not able to move the value, I think?) but it took me a minute to figure out what it was trying to tell me.
[removed]
Is `Foo bar(baz);` a function declaration or an object initialisation? Place bets now! (at least I think that's how it goes, someone remind me)
 / \ . . / \ . . \ / \ / 
This might be the single most useless bot I've ever seen, and that's saying something.
SSH is also huge and messy, comes with a lot of baggage. It's nice as a hack to support running without an agent on the remote host, as every server can run it. Saltstack lets you choose SSH or zmq, for example.
pretty much. also between deciding if something is a template or chained comparison ops i think
You just successfully countered your own point üòÅ Despite IETF standards, SSH is implementation defined by libssh based on market share. For security sensitive code you want some combination of good static testing and real world hardening. We've been bitten at both ends: widely used code can have bad exploits for years, static analysis can't ever go far enough. At least Rust gets us closer.
Isn't it? 
Or you can have a look at the patch I just wrote which adds this feature. https://cgit.kde.org/rust-qt-binding-generator.git/commit/?id=7ea7dd1d5e98ff8e141504aaac5cd744def97a3a Now the generated trait has a function that corresponds to `QAbstractItemModel::insertRows` [0]. ```rust fn insert_rows(&amp;mut self, row: usize, count: usize) -&gt; bool { false } ``` It is overridden with `QT_INVOKABLE` so you can call it from QML. Reviews for features (e.g. `removeRows`) can go to the KDE review board. There's no style guide. I roughly follow KDE practices [2] for C++ and `rustfmt` for rust. [0] https://doc.qt.io/qt-5/qabstractitemmodel.html#insertRows [1] https://phabricator.kde.org/differential/diff/create/ [2] https://techbase.kde.org/Policies/Frameworks_Coding_Style 
And addition: in QAbstractItemModel adding rows is separate for setting data. The rows created with `insertRows` are default rows. The data in the rows can be changed with `setData`. When you implement `insert_rows`, take care to call `begin_insert_rows` before and `end_insert_rows` after adding the rows. This is required to signal to the UI that the model has changed. 