But it's Microsoft who designed their store like this. I'm not blaming them for not porting Office to the Store, I'm blaming them for making it hard to port existing desktop applications to the Store.
They allow shipping Win32 apps in the Microsoft Store now, actually: https://docs.microsoft.com/en-us/windows/msix/overview
Dumle is a virtual DOM library that takes a different approach to building virtual trees. Instead of allocating Vec:s of children it uses cons lists. Similarly for attributes. It is not a fully fledged framework - rather something that could be embedded as the backing VDOM implementation.
They usually don't, and shouldn't, be doing or saying anything different than what the main trait does and says. If they do, they're the exception, not the rule, and it can be shown anyway. Better yet, not shown and you can go to *their* page to read *their* documentation instead of bloating every other page.
[I did already](https://github.com/RustSec/advisory-db/issues/85)! :)
&gt; Then the first test which fails is the test I have to look at. I like to get all the tests to be executed anyway, so then the problem is not in the execution order, but in result printing order. You can execute tests in one order, and then print them in the order they appear in the source code.
`mpsc` issues aside, you can't just add `'static` to things and magically they work. That's not how that works at all. The code dictates the lifetimes, not the other way around.
I've been running it on three different machines for a few weeks now, and it's been fun watching botnets get stuck en-masse for days on end, with peaks of around 150 clients each, with some getting stuck for upwards of a week. Sadly they seem to have adapted, and now I'm seeing peaks closer to 10. Still TODO is some sort of stats export - for now it's just basic logging, but it would probably be good to have a Prometheus exporter or something.
Autonomous Tactical, a WIP game by webshinra. Here is their website: https://autonomous-tactical.net/, but it does not have a lot of content yet.
Any other arguments I should run? When I just use cargo run, it displays a generic “hello world” message.
Would be interesting to have the credits (name and link for each of the games presented here). &amp;#x200B; I am currently looking at Amethyst, and I really like the data orientation and concepts for game dev and it looks like a good base, it fits pretty well my project. The rendering/audio/UI parts on the other hand seem very early or at least not really documented in an accessible way. &amp;#x200B; I also suspect a lot of discussion must have happened outside Github because even after reading the RFC repo it is kind of hard to know really what is been working on right now and when major features will come.
It would be nice if Diesel could generate structs for inserting, though. I used to use Diesel and I hated that I needed to hand-write all my "insertion structs". It didn't feel like much of a step up over the plain postgres driver.
Hi &amp;#x200B; I am using it for some tests and it works very fine (even when it is hard to learn for a newbie as me). Also, it probed to be fast and rock solid (I found a couple of bugs that I have reported and were fixed in a couple of hours). Regards J
For only knowing Rust for a couple weeks, this is a hell of a project.
Excellent talk, very informative. The guy is a great speaker.
https://docs.rs/futures/0.1.26/futures/future/trait.Future.html#method.select
I think the maturity of our rendering, audio and UI stories has and will continue to move in lockstep with the maturity of the larger Rust gamedev ecosystem. Rendering is close to a watershed moment with the stabilization of Rendy plus the support of our WASM grant. Audio and UI will surely follow, but speaking timeline is just too risky at this point.
Diffing is one of main selling point of VDOM. and it matters not only because of performance, but also for CSS transitional effects, accessibility, etc.
Thanks, /u/vlmutolo! I honestly don't know where I'd be without the hand holding of the rust compiler. With RLS + VSCode, it was a constant feedback loop of where I was doing something wrong or when I had it right.
Dumle does do diffing? If nothing has changed then patching is a no-op. As for CSS transitions: currently not easily done but hooks will be added that let you add `MutationObservers`.
You're probably on a bot blacklist, I'd consider that as sucess
Of course, and I think this is fine. My point was more that it currently needs a lot of effort to know where things are. For instance without your comment, how would I know that a new rendering is close to being merged? Regarding the UI project, even after going through hundreds of line of Github posts I am still quite unsure of the statu, or even if any orientation was decided at some point, as I see contradictory statements (I guess part of the discussion has been outside Github as well). I think a quaterly/monthly update post could help summarizing the current dev effort, difficulties, and why not ask for help on specific topic or warn of coming deprecation/big changes. I noticed that there was some effort at some point with this week in amethyst posts, but weekly post probably take quite some effort to manage all the time and I understand that it is a big thing to ask from such a changing project, but maybe a fixed date monthly or bi-monthly could be a sane routine to have.
There are lots of forms of it: https://en.wikipedia.org/wiki/Ampersand
Zero-sized virtual dom can't be done for runtime-defined doms, right? Like, it still needs some representation in memory, doesn't it?
Newbie Here! I am trying to iterate through a range of numbers and put them in the right bin in a parallel manner using \`rayon::par\_iter()\`. The code is below: \`\`\` struct Bin { indices: HashSet&lt;i32&gt;, lock: Mutex&lt;i32&gt; } &amp;#x200B; impl Bin { pub fn new(hashset: HashSet&lt;i32&gt;, mutex: Mutex&lt;i32&gt;) -&gt; Bin { Bin { indices: hashset, lock: mutex } } &amp;#x200B; pub fn insert(&amp;mut self, idx: i32) { let tmp\_lock = self.lock.lock().unwrap(); self.indices.insert(idx); } } &amp;#x200B; fn main () { let mut bins\_tmp: Vec&lt;\_&gt; = iter::repeat\_with(||Bin::new(HashSet::new(), Mutex::new(0))).take(1024 as usize).collect(); let bins = Arc::new(bins\_tmp); &amp;#x200B; let vec\_k = (0..n).collect::&lt;Vec&lt;i32&gt;&gt;(); vec\_k.par\_iter().for\_each(|k| { let bin\_index = SOME\_FUNCTION(\*k); let this\_bin = &amp;bins\[bin\_index as usize\]; this\_bin.insert(\*k); } } \`\`\` However I am getting this error: \`\`\` error\[E0596\]: cannot borrow data in a \`&amp;\` reference as mutable \--&gt; src/main.rs:237:29 | 237 | let this\_bin = &amp;mut bins\[bin\_index as usize\]; | \^\^\^\^ cannot borrow as mutable \`\`\` I am not sure how to debug this. For some context, the reason I am separating the lock from the hashset is because I want to avoid data race during insertion, but allow concurrent read from the hashset later on. I am not sure if this is the right way to do so..
Was that pokemon puzzle league? Holy crap, I didn't know people outside of my circle of friends still knew about that game.
A tip: you can nest ``use``'s. Example: ``use std::{io::*, fs::*}``. This way you reduce the amount of use lines (which are a lot as I've seen in some files :P ).
That is true. For that you'd use `Vec&lt;impl Vnode&gt;` and store the data on the heap.
Try Silver-rs https://github.com/AhmedMostafa16/Silver
Might that be a bit reductionist response of my evalutation? I did mention other things?
That makes the docs so ugly, it breaks the signature in multiple lines instead of using the `where` part, that is proparly formatted.
&gt;Re Maybe thats what some people like to do on their free time. I apologize if it seems foolish.
Or make `rustfmt` do it for you: [I] 04-26 14:19 dpc@futex ~/l/crev (master)&gt; cat rustfmt.toml edition = "2018" merge_imports = true and then just `cargo +nightly fmt --all`
I use Atom
I was you maybe a year ago, I learned that Pokemon Puzzle League was based on Tetris Attack: https://www.youtube.com/watch?v=TQdrINpVtNU That's why there's two different tile sets in the game, I'm pretty sure. One to match the elemental types and one to match Tetris Attack
If Zulip were easier to deploy... I understand the pragmatic decision to pick products over products but I am going to be really crushed if they pick Discord or some other similarly proprietary pile of crap. How utterly embarrassing that we are this far into "the Internet" to not have a proper, wide-spread, non-proprietary solution to basic communication tooling.
yeah but http requests are not that hard that you need a debugger at all
Aw, sad to see #rust and #rust-beginners go. (OK, I guess they won't "go", they'll likely be migrated to whichever new system Mozilla chooses. But ... nostalgia.) &amp;#x200B; I'm curious what they'll choose because I can't immediately think of a system that solves those issues. &amp;#x200B; * Slack: Will it scale to the size of Mozilla's IRC channels? (#rust has 1232 users in it currently.) And what about the cost? * Discord: Same. * I'm a fan of Keybase Chat, but it doesn't have a good way to ban users from channels unless you make them invite-only. Plus it's a bit new and can sometimes be slow. * Riot? Ehhh....
Wrong rust. This subreddit is for the programming language. You're looking for /r/playrust
i would pick riot, but only because seems to be the general choice for programmers hopefully not discord
cheers
just, for the love of god, anything but discord
Locking as per request by author, please continue discussion [here](https://www.reddit.com/r/rust/comments/bhrm7g/mozilla_irc_sunset_and_the_rust_channel/)
Do people have experience with \[mattermost\]([https://mattermost.com/](https://mattermost.com/))? It seems like a reasonable alternative.
&gt; IRC is an ongoing source of abuse and harassment for many of our colleagues What avenues of harrassment would be closed by switching off IRC?
* Zulip, because we deserve better than unthreaded chat * Riot, because we have no other good open source / decentralized choices? * \~\~Discord/Slack\~\~: if Mozilla can't choose a non-proprietary platform for basic communication, what hope is left?
That's amazing work!
Great tip! No more wasted lines :) It's always satisfying getting to remove unused imports &amp; variables, this will give me that same satisfaction.
I haven't looked into rustfmt yet, but I'm very excited to use it now. Thanks!
I'm more impressed you figured out the most unintuitive website ever made: GitHub
u/NfNitLoop (responding to the other thread) I can't speak to your other concerns, but know that Discord scales at least as well as any other solution without dynamically created chat channels. So if #rust/#rust-beginners held conversation on IRC, it can work just as well on Discord. The developers also have said that the core server text/voice chat functionality will remain free (as in beer) forever. Some games' official Discord channels are truly massive and they take pride in keeping them running smoothly. The only thing Discord lacks for me as a public solution (as I don't personally care about the platform being free-as-in-GNU) is direct linking to deep chat history and a simple&amp;obvious way of preforming data export.
Discord: - runs on chrome - is proprietary - is extremely slow also, if the goal is to thwart harassment, discord is certainly not the choice. Try Riot please.
I doubt it would be able to handle 1000 people in a single channel
The company I work for uses Mattermost. It's basically slack but not quite as slick. There seem to be good integrations and bot opportunities, but it also has a tendency towards lagginess. It's chromium-based (electron, I believe?) which comes with all the usual problems that that brings, stuff which would probably be exacerbated in open-source software where most users/developers aren't necessarily going to have good computers.
A week? Seriously? Did you sleep at all? Sir, you are either brilliant or a liar, but this is certainly impressive either way. For the most part you follow best practices. Looks like fairly professional code, however I do have some things to say about player.rs: In cases such as \`let sb = SoundBuffer\[...\]\`, naming convention might be better off as "sound\_buf" to be more descriptive. The Player::play\_song function goes from 119 to 246. Maybe consider delegating to a few new functions? You should usually keep a spacer between right curly braces and the next line of code, which you seemed to follow flawlessly except there. &amp;#x200B; Also, error handling. You should never throw error messages away, and anywhere you call unwrap(), unwrap\_or(), etc should be handled instead with match, ending gracefully and potentially with a descriptive error message, rather than letting the program panic. Well done, by the way. Your code looks great.
I maintain the IRC server software that Mozilla IRC uses. I used to be in contact with the person who maintained the Mozilla IRC server but they passed responsibility onto someone else and in the years since the new person has not bothered even once to reach out to us about solving their issues with IRC. We have plenty of solutions available to deal with the kind of problems they claim to be having. If they want they can make it so people need to be logged into accounts to interact with channels/other users to solve abuse/spam they can do that. If they want a fancy modern client UI then there is several modern interfaces which are very accessible (IRCCloud, The Lounge, Kiwi IRC, etc). Ultimately it seems to me that they are just making a knee jerk reaction and deciding to jump to some other platform without knowing what they want to move to and without actually looking into seeing if any of their problems are solvable. ¯\\\_(ツ)_/¯
I have no hope of Rust actually switching away from Discord, but for anyone else reading, here is why Matrix should've been chosen: https://www.ruma.io/docs/matrix/why/ (there's also an overview of what Matrix is if you're not already familiar with it)
My primary concern w.r.t. the Rust community is that #rust-bots doesn't seem to have an analog anywhere else.
Huge Zulip fan here. I've used it both for xi and Recurse, and the latter is a good sized (mostly non-public) instance. It's also open source, with a good community, so any rough edges have a good chance of being fixed. I tried Discord but couldn't warm to it; I don't think it's geared to productive discussions. I actively dislike Telegram and that's one of the reasons I no longer hang out on the rust-vst channel (sorry folks).
Is there a way to not lose error causes when converting an error from another crate (which implements `std::Error`) to a `failure::Error`? For example: use std::ffi::CString; fn doit() -&gt; Result&lt;(), failure::Error&gt; { let invalid_utf8 = vec![b'f', 0xff, b'o', b'o']; let cstring = CString::new(invalid_utf8)?; let _s = cstring.into_string()?; Ok(()) } fn main() { if let Err(e) = doit() { println!("error: {}", e); for err in e.iter_causes() { println!("caused by: {}", err); } } } Here, the cause information that is embedded in the `IntoStringError` which says "invalid utf-8 sequence of 1 bytes from index 1" is lost. It seems like the `failure` crate completely ignores the `cause` and `source` methods, and assumes any `std::Error` is only 1 deep. Is there a clever way around this? Am I missing something?
In `std` there's [BufWriter](https://doc.rust-lang.org/std/io/struct.BufWriter.html) which only flushes when it is full, when it is dropped or when `.flush()` is explicitly called. If you're wrapping a `Write` impl then this might be the way to go. If you need more control, in [buf_redux](https://docs.rs/buf_redux) there is the drop-in replacement [BufWriter](https://docs.rs/buf_redux/0.8.1/buf_redux/struct.BufWriter.html) type which acts the same as the std version by default but is tunable and provides more methods for checking how much data is in the buffer, etc. If that doesn't fit the semantics of your program there is also [Buffer](https://docs.rs/buf_redux/0.8.1/buf_redux/struct.Buffer.html) which can act as a fixed ringbuffer, although it doesn't block when full, it just copies what will fit (if you use `copy_from_slice()` or `write_to()`). Disclaimer: I am the author of `buf_redux` and I'd like its API to serve as many use cases as possible.
IRC has a pretty bad moderation story. You have name and IP bans, that’s it. And nobody bans IPs. Other platforms at least require an email, which raises the barrier to trolling just enough it makes a surprisingly large difference.
You can define `#[bench]` functions in your binary the same as libraries. Are you running into problems? Can you say more about what you want to do and what you tried?
I don't think so. Can you say more about which flags you want to set?
Thanks, really appreciate the great feedback! It has definitely been more than a week, probably about 2.5 now. And I definitely lost more hours of sleep than I care to admit, trying to think about how everything should come together. Player.rs was where everything started, trying to get the lyrics to initially render, then the audio synced up, then finally connected to the channels and responding to commands. So it definitely needs some love and refactoring, it's my least favourite file to look at for sure. Error handling... yes, I kind of skipped this part :P I'm just unwrapping everything and hoping for the best! This is definitely my biggest area for improvement.
Thanks!
I hate to be blunt, but none of these address specific needs that the rust project has to a chat. Matrix still has no moderation guides and documentation, which is of crucial importance to Rust. When we were evaluating chats, only Discord would deliver in that area. I would argue that Zulip zipped past them in the recent months, but that's another story.
Make your editor fmt code on save, and after a while you'll be wondering how could have ever lived without it.
You should probably throw a link to [https://github.com/jeremyletang/rust-sfml/wiki/Linux](https://github.com/jeremyletang/rust-sfml/wiki/Linux) in your github. I've been wrecked trying to get this to run.
P. s Played no more than 45 hours, but does not change the essence
Is there some sort of *comprehensive* list of requirements that Mozilla has for an alternative option? I've been playing with the idea of putting in the work for an alternative and consequently I've been trying to get hold of an actual list of requirements for the past few months, but all I ever find is posts along the lines of "such-and-such doesn't meet all of our [unspecified] requirements".
This is a forum for the Rust programing language. You probably want /r/playrust instead.
heres the link to the project [https://github.com/Skytrias/everpuzzle](https://github.com/Skytrias/everpuzzle) theres a small discord community that plays tetris attack / pokemon puzzle competitively, they also have a lot of programmers there that make their own versions of the game or help you out if youre interested in getting mechanics right. &amp;#x200B; on my end programming the game was always a lot of fun to program and more of a starter project to get into engines im not working on it anymore since i messed up a bit on the project structure and generally want to work on original games.
&gt; Is there some sort of &gt; comprehensive &gt; list of requirements that Mozilla has for an alternative option? We're not Mozilla. I have a rough list here and would actually (for the reasons outlined in the post) be interested in helping putting thought in there. https://yakshav.es/from-the-rider-down/ It's hard to put down a strict list of requirements in a space where none of the tools quite fit.
Added to the README. This is very helpful, thanks!
Oh sorry. How can i change forum?
So the friendly helpful and easily accessible IRC channel gets axed and replaced by a walled-off, proprietary and electron (chromium) based application that won't even run everywhere. What a huge disappointment. I've had nothing but refreshingly positive and helpful experiences in the rust and rust-beginners channels, especially compared to some other communities. But I guess accessibility is no longer valued much? Or even the preservation of that environment, since it doesn't feel like anyone put much thought into this.
If it continues to be crazy then please do file an issue on github for us.
&gt; Is there some sort of comprehensive list of requirements that Mozilla has for an alternative option? Internally, yes, and I think that will be made public at some point, Mozilla is still in the early stages of picking a replacement. It's just very clear that IRC is not an option. Expect further posts from mhoye as this process progresses. But that's not too relevant: Rust isn't Mozilla. We just happened to use Mozilla's network. When Rust was looking at channels individual teams tried different things. People seemed to like discord and Zulip and that's what we use (different teams have picked different platforms). The bulk of the project shifted to Discord or Zulip, leaving a couple channels behind.
Are you not able to install through [https://launchpad.net/ubuntu/+source/libcsfml](https://launchpad.net/ubuntu/+source/libcsfml) ?
&gt; We're not Mozilla. It's really not clear to me who are making what decisions here. As I understand it, Mozilla IRC is managed by Mozilla, not by the Rust Community team, and it's Mozilla that's decided to shut it down for what seems like moderation reasons. Was the Community team involved in that? Was it a unilateral decision? As a random user in the community I frankly have no idea what's going on, who decided what where, or exactly why. &gt; I have a rough list here and would actually (for the reasons outlined in the post) be interested in helping putting thought in there. This provides *some* insight, but not really enough for me to understand what is actually *needed*. I have been following various discussions about eg. WGs moving to different platforms, and there were a lot of (sub)threads that went something like this: - User: Why don't you use X? - Team: It didn't meet our requirements for Y. I *want* to work on a better open chat/community platform for communities like the Rust community, but these kind of threads very much give me the impression of shifting goalposts; I would never know what requirements people/WGs/etc. actually *have*, and any attempt at building an alternative could be dismissed because of some undisclosed requirement not being met. Hence my question: what *are* the requirements? Judging from all the "we've evaluated X and decided it didn't meet our requirements" threads, it seems that there circulates *some* list of requirements somewhere, either written down or just in somebody's head - that being the list that things are evaluated against and dismissed. This is not really made any better by posts like [this](http://exple.tive.org/blarg/2019/04/26/synchronous-text/) that mention several 'problems' that *have* actually already been solved somewhere (eg. the firewall issue), which further muddy the waters. I'm not part of a WG, I'm not part of the Community team, I'm not an IRC oper on Mozilla's IRC network. Without some sort of input from the people that are running into issues, I - or for that matter, anybody else in the community - literally *can't* build a satisfiable alternative, because I don't know what to design for.
I work at Mozilla, and am sad to see them shut down the IRC server. That being said, they *do* have it set up as you describe... channel ops are able to limit their channels to only logged in users, folks can limit private messages to logged in users, and IRCCloud is available for anyone who wants it. I don't know the ins and outs of why they're making this decision, but it's not bc they don't know what's available.
&gt; Internally, yes, and I think that will be made public at some point, Mozilla is still in the early stages of picking a replacement. This seems counterproductive. I feel like we've collectively reached the conclusion a while ago that there are no existing open platforms that meet the requirements. That is something that the community *can* solve, but only if they actually know what the requirements *are*. Keeping this list private until a replacement is (being) picked, would basically rule out any not-already-existing option, and therefore automatically rule out any kind of open platform. Which is not desirable for hopefully obvious reasons.
This is really sad :(
Alright thanks. I think that our very long thread will finally come to a close. I appreciate your help.
No prob! Good luck!
&gt; I feel like we've collectively reached the conclusion a while ago that there are no existing open platforms that meet the requirements I don't think that conclusion has been reached at all, you're mixing Mozilla and Rust's requirements. Mozilla has different requirements and is at a different stage in the process.
Please don't pick something that pushes users of a FLOSS project into using proprietary software.
I got something installed with apt install libsfml-dev, just not cfsml. Turns out you need X11 to run this and I'm not running a full GUI.
So what exactly is the problem?
Ah, if only we could get our customers to agree to and fix their requirements before we start the programming project, our jobs would be so much easier. I don't think what you're asking for is very realistic.
&gt; &gt; &gt; It's really not clear to me who are making what decisions here. As I understand it, Mozilla IRC is managed by Mozilla, not by the Rust Community team, and it's Mozilla that's decided to shut it down for what seems like moderation reasons. &gt; &gt; Was the Community team involved in that? Was it a unilateral decision? As a random user in the community I frankly have no idea what's going on, who decided what where, or exactly why. It's simple: Mozilla shuts down their IRC. The Rust project has no say in this decision, we can only deal with the fact. I'll try to address the rest of your points later, but I really have to go to bed, as I'm currently running a conference.
I have to say, that's quite surprising to me. I would have expected them to at least coordinate it with one of the major users of the network... And alright, I'll read back later for any further replies. Thanks.
Maybe you can contact http://exple.tive.org/blarg/about/ to ask. From what you post here, I wonder if he knows you exist. From experience with other projects, Discord seems to have a much lower barrier to entry than IRC. I can't give more details. I prefer IRC myself, I just see everyone else moving to Discord. It doesn't help that IRCCloud, while nice, has a somewhat restricted functionality in the free tier. I run my own bouncers, but most people have no hope of doing that, and it's completely unneeded for something like Discord.
To be honest, this feels just as abrupt and ill-considered as the new website design did. Minimal community involvement, very little notice, just "hey, we're doing this now." It kind of gives a bad impression, even though the language and community themselves are great.
That's a nail to mozilla coffin. Mozilla is pro-censorship parody of itself now.
&gt; It's really not clear to me who are making what decisions here The rust teams made individual decisions to move off IRC around a year ago. The only channels that were left were non-team channels like #rust and #rust-beginners. Mozilla independently made its own decision to stop supporting IRC. With their own (not-yet-public) requirements. When we found out about Mozilla's plans, the Rust core team discussed finding a new IRC home for #rust and #rust-beginners. Historically, IRC has been very hard for us to moderate, and we're very reluctant to officially endorse a venue we cannot guarantee the upholding of the code of conduct for, so we decided against moving these to a new channel. The freenode channel exists (and is not unpleasant), folks are free to hang out there if they don't want to use Discord. &gt; Hence my question: what are the requirements? You're looking at this the wrong way, individual teams made their own choices here and basically ended up picking either Discord or Zulip. There wasn't a top-down decision with a single set of requirements here. It was also very much just _trying_ a bunch of things and picking what people liked best. So there's nobody with a full list of requirements; you'd have to ask all the teams. https://yakshav.es/from-the-rider-down/ mentions /u/fgilcher's personal set of requirements, for example. That's a starting point.
&gt;I would have expected them to at least coordinate it with one of the major users of the network... The IRC server is still there and from the message it will be there for many more months, so that's exactly what is happening?
&gt; I don't think that conclusion has been reached at all, you're mixing Mozilla and Rust's requirements. I can only really judge from my position as a user. As is probably clear from my posts elsewhere in this thread, it's been quite frustrating to me how difficult it is to get more details about what's going on and what decisions are being made - so it's quite possible that I'm missing some details. But so far, my impression from both Rust teams and Mozilla has been that they all really kinda just want to get rid of IRC, and that Discord looks like their future platform to use. I'm primarily interested in the requirements / platform for the Rust community here; what Mozilla uses internally is a separate matter. &gt; It doesn't seem like ruling out options has even begun yet. Right, but if that process starts before the requirements are public, then it's basically already too late for anybody in the community to contribute towards building a better option and/or fixing the issues with an existing option.
&gt; I have to say, that's quite surprising to me. I would have expected them to at least coordinate it with one of the major users of the network... They did coordinate with us. We have the option to set up official channels on whatever Mozilla picks as a replacement. We don't really want to at this moment.
&gt; But so far, my impression from both Rust teams and Mozilla has been that they all really kinda just want to get rid of IRC, and that Discord looks like their future platform to use I'm pretty sure Mozilla won't pick Discord, I think I've heard it brought up before and there are reasons (screen readers and data policies come to mind) that Mozilla won't go with that. I think you have a pretty skewed picture of what's going on here, and are mixing up decisions made by Rust with decisions made by Mozilla.
&gt; I think you have a pretty skewed picture of what's going on here, and are mixing up decisions made by Rust with decisions made by Mozilla. Then frankly, those who *do* have the correct information should community that information outwards more clearly.
Oh hey! Nice to see you're still at this - I gave up on running mine after I realized that running ssh on a weird port is annoying for my life workflow. I did get one bot to stick around for like 4 or 5 days, beacuse it tried like 4 times before moving on :) ( /u/Freeky and i were discussing our rust implementations a while back when the endlessh thing first was making the rounds. If anyone wants to offer critique of mine its here: https://github.com/sophacles/rust-endlessh I hope this isn't thread/post hijacking :/ )
The blog post above seems pretty clear about this. It mentions that Mozilla is shutting down their servers. It mentions that Rust had already moved to Discord and Zulip a year ago.
This, a million times this. Combine that with fmt on commit and you never have to argue with anyone about syntax formatting again. &amp;#x200B; Any standard is better then no standard.
https://yakshav.es/from-the-rider-down/ list some thoughts of a Rust team member on IRC (not necessarily reflective of the overall views of the team) http://exple.tive.org/blarg/2018/11/09/the-evolution-of-open/ has a lot of background on Mozilla's requirements.
&gt; It mentions that Rust had already moved to Discord and Zulip a year ago. Except it hasn't, because there's still a large and lively community on IRC, and just a few months ago the link to IRC was [readded to the website](https://github.com/rust-lang/www.rust-lang.org/pull/492), and there were various assurances flying around that "IRC has not been abandoned". This is *exactly* what I mean. Conflicting information, and then suddenly everything being changed under people's feet.
&gt; Except it hasn't, because there's still a large and lively community on IRC Sorry, the Rust _teams_. My comment was unclear, but the blog post very clearly talks about this. There were a couple channels left. Those folks can move to Freenode, the Freenode channel is pretty okay. There are also Discord channels providing the same functionality, so they have a choice. &gt; and there were various assurances flying around that "IRC has not been abandoned". And it hadn't, at the time. Mozilla's decision was enough to make Rust reevaluate whether or not we needed an official IRC venue. We decided against it. This is after repeated attempts at improving IRC moderation, lots of harassment, and in general just no good results.
The Python experience shows right there. I'm also coming from Python. When I look to Python code now, after learning and using Rust, I feel a bit scared of how many ways my code may break and I have no idea (yet! before the Jira tickets start flowing...).
The point is, we're unwrapping the option in most cases because we thought we were following the mutable borrow rules for the contents of the `Rc`. It's not clear what else we could do at that point if we need to mutate the contained value and can't. If instead we'd used `&amp;mut` the compiler would have caught our failure to follow the mutable borrow rules and told us so. There are definitely use cases where `Rc` is necessary for correctness or performance. It should be a last resort, though. Often you can restructure ownership to avoid it.
Pronouncing `crev` like `crew` as in `/kɹuː/` (IPA)? That seems a little weird (at least considering English). But you are the author! You came up with the name! You get to choose how it's pronounced! By the way, how did you come up with that name?
&gt; rust-vst channel The only reason I use Telegram still is for the rust-vst chat. It's the most friendly and helpful community I've ever encountered.
I dunno I've tried a few others, gitlab bitbucket etc and gitlab is far worse that anything I've used before.. GitHub seems fine
Reading that, it seems they are implementing implied bounds for impls and functions, but not for traits :(
Matrix.org project lead here - I’m intrigued by this thread, because the fact that Matrix lacks doc around moderation is a) true, b) something that genuinely hasn’t been on our radar as a gap. Nobody has filed a bug for it (unless i’ve missed it) and I don’t recall seeing it being raised in any of the public support rooms. And unfortunately I don’t think we had seen the https://yakshav.es/from-the-rider-down/ blog post until just now. For what it’s worth, we see moderation as critical to the success of Matrix as the public network grows - we already have a very very wide range of users and content present, and we have to empower users (and moderators) to filter out stuff they consider undesirable. For instance, we’re currently in the end stages of implementing reactions (which is surprisingly tough to do efficiently in an encrypted and decentralised world), and are baking in moderation tools as a first class citizen - hitting like/dislike on a post isn’t just annotating content with an emoji but providing an input for a decentralised reputation system. In terms of documenting how this (and the current stuff) works: the easiest piece of the puzzle is writing a guide! From the blog post: &gt; That being said, I do still believe that Matrix show the most potential for the next cool chat system if they can solve the problem of not only potentially providing many high-quality clients, but also practically. But that’s not their mission. I fear we’ll end up with a lot of nice crypto, but not many good clients. But their current overemphasis of technical subjects over social interactions feels like a bike build for spec, not for riders. For what it’s worth, our mission is fully documented in the governance docs of the Matrix.org Foundation: https://github.com/matrix-org/matrix-doc/blob/matthew/msc1779/proposals/1779-open-governance.md#mission, and explicitly *does* cover supporting end users and client developers (as the first bulletpoints no less) and providing moderation tools and maximising SNR for the network. Hopefully the improvements we’ve landed in Riot’s UX over the last few months reflect this too. (In other news, good luck finding Discord’s open governance docs...) &gt; I would argue that Zulip zipped past them in the recent months, but that's another story. We haven’t been following Zulip that much, other than occasional constructive chat with the developers and trying to support them with using Matrix for federation. I’d be interested in the rationale here (via some channel) if you have a sec :) I assume there’s something more at play here than “Zulip has threads”. My motivation here fwiw isn’t to try to change the decisions which look to have been made over Rust’s collaboration tools, but to clear up any misunderstandings which led to the current situation; better late than never.
Ah - okay I think I see what you mean. Your description made it sound like it inherently broke borrowing, but to me what you described is rather that we are not leaning into borrowing as much as we could. The code is still completely safe, it still abides by the borrow checker, but if we instead use `&amp;mut` we exploit the compiler more than with `Rc`.
Sure, but the only ones that people would obviously recognize are the ones with the circle at the top and bottom.
What does "virtual" mean here?
[removed]
It feels like Mozilla announcements for shutting down services should be done a little more officially than a random blog.
&gt; But you are the author! You came up with the name! You get to choose how it's pronounced! If everyone took that position we'd all be saying "jif!"
The thing I love about IRC, and is unlike other systems like Discord or Slack is that I can just pop into a channel, do what I'm there for, and leave if I need to. Slack and Discord both require you to join a group, which adds time when something like moznet already exists. I can currently go to #rust or #rocket just as easily as any other, and I don't need to join a new group to be able to access it. I shouldn't have to run an Electron app on my desktop that eats up hundreds of megabytes of ram just for a simple text chat, nor should I be forced to join _every_ room (Discord) just to have a single conversation. IRC is superior in those ways, and I don't see that changing any time soon.
Idk man, can't go wrong with dropbox
I agree that prenoucing it like "crew" is weird, and is probably just wrong. see-rev or krev are probably best ways. Code REView + the shorter the better + not relevant stuff already in google results.
The end of an era. :( I first came to the Rust project when the entire community was nothing more than a low-traffic mailing list and 50 people lurking in #rust, watching the three main devs working in the open. I joke that I learned more watching them work in that IRC channel than I did in four years of a CS degree. Despite my undeniable love/hate relationship with IRC, I can't help but mourn its loss. I think this will make the subreddit the oldest remaining community dedicated to Rust... very weird to consider.
Yeah, to be clear at the time the process was mostly "experiment with stuff and figure out what we can use", trying to _build_ the perfect solution (or trying to work with people who are building that solution) wasn't really a goal. We needed better harassment-free platforms as soon as possible, so providing feedback in the interest of getting such a platform in the _future_ wasn't really a priority. I'm also personally very gung-ho on Matrix becoming a viable alternative in the future.
Bit late for this response (and I'm not the person who was talking to you before), but you have to re-create the post there, don't cross post or link the post since it's fairly likely this one will be taken down.
Wrong sub. This subreddit is for the Rust Programming Language.
This is great! Here's a suggestion: for high precision timing in an audio stream you can use a callback scheme (this is what `cpal` does, and iirc it has an example of file playback with `hound`) to increment an atomic integer (like [AtomicUsize](https://doc.rust-lang.org/std/sync/atomic/struct.AtomicUsize.html)), just divide by the sample rate to get the elapsed time, and reset the counter to zero when you change files. Also consider sharing on rust-audio.discourse.group!
Mozilla were incompetent with managing the server. Spam prevention on IRC is very effective if done properly, and it's unfortunate that Mozilla just left it to die. Their server was fine. The admins were not.
&gt; The developers also have said that the core server text/voice chat functionality will remain free (as in beer) forever. It will be right until the point it no longer is. Call me jaded but I have seen corporate promises evaporate faster than isoproponol on hot plate.
I’m dumb.
Awesome. Start by telling us what were the pain points.
I ask you to refrain from asking, answering, or discussing the name of the company. It's not like it's hard to find out if you care, but I don't want this to be Google first page result for serach either.
I think you want r/playrust
&gt; We have plenty of solutions available to deal with the kind of problems they claim to be having If someone posts a shit ton of racist screed on an IRC channel, do we have any way of deleting it? Nope. That's baked into the protocol, no amount of tooling can fix that. People are forced to read that until it gets lost into the scrollback. Overall tracking abuse is pretty tricky too. Perhaps the server software can be made to support that, but I don't think any IRC servers currently support _that_ level of moderation tooling. It's all in-the-moment. If they want they can make it so people need to be logged into accounts to interact with channels/other users to solve abuse/spam they can do that. I don't think any of the modern interfaces provide always-online/full scrollback-with-search experiences for free either. &gt; If they want they can make it so people need to be logged into accounts to interact with channels/other users to solve abuse/spam they can do that. We already do that pretty often. That is the _bare minimum_ of moderation tooling we'd like. This does not solve harassment, by a long shot. And to be clear, Slack is terrible on moderation tooling as well (it's a workplace tool, moderation issues are expected to be handled by . Discord is pretty okay, especially since there's a community of third party bot tools that help. I'm more of giving an opinion from the Rust side, I can't say what Mozilla's requirements are, but I can easily see why IRC is insufficient for Mozilla.
You want r/playrust
[PSYC](https://about.psyc.eu/), with the intention to move to [secushare (aka PSYC2)](https://secushare.org/) once it's ready. PSYC is federated and does have social networking capabilities, you can do microblogs etc. Secushare will be fully decentralised by using gnunet as a backbone.
Because of the flushing on a timeout (assuming it has to be asynchronous, you'll have to use either threads or/and some asynchronous mechanism like mio/futures).
&gt; If someone posts a shit ton of racist screed on an IRC channel, do we have any way of deleting it? Nope. That's baked into the protocol, no amount of tooling can fix that. Sure, it's deleted every time you close your client: IRC doesn't *keep* it, and it can't resend it. That's baked into the protocol today.
I honestly hope the Game Store part of their service works as a revenue source for them. They've actually paid off the initial investment capital, it's wave two and three they're still paying off. Given how it's marketed, I suspect the worst they could do is gate video calls and servers over N users with partnered servers (of which Rust is one) except. Obviously it's not guaranteed. But it'd take some cold cold investor pressure to make them close off the core text/voice server service, because that'd kill their userbase.
I really found impl Trait worth it when using Fn, FnOnce, and FnMut traits. Really. But this is exactly because the types implementing such traits are generally anonymous.
This sounds like an IDE issue not a rust issue.
But people don't want transient history anymore. That's why e.g. bouncers are used on IRC and why Discord is more approachable: you don't have to be online to see when someone mentioned you. There's a reason no other chat client has history transience as a _feature_ (except maybe Snapchat, but that still allows you to see messages sent while you were offline). People so know the strengths of IRC love IRC. Those who don't, don't see the effort required to learn to love IRC as worth it when things like Discord exist with a lot easier onboarding.
God discord is so bad. It’s already become the new skype with all of the woes related to that software.
That's rather condescending towards people who don't use IRC.
Zulip uses electron. Yuck.
How did you overcome the "who will we hire" argument ?
&gt;I almost never use it. Why? Because it doesn't work in trait impl blocks. I'm not following, what do you mean by this exactly?
This post reflects a lot on the past. How about the future? What is the team looking forward to?
I'm in that group of people, and it's deliberately a simplification. Obviously some people don't use IRC because they don't know it exists. But in my experience, it's roughly correct: IRC _does_ have a steeper learning curve than any other chat platform. I "found" Discord early on, in its first few months when it was little more than, as I described it: IRC + Teamspeak server, but always online, and hosted. I'd tried getting my Skype group to move to IRC/Teamspeak (because they are definitely better than Skype for server-like groups) but Discord is what finally got us off of Skype. The permanence was the deciding point there for this particular group of tech-minded people. I really see it similar to the GNU/OSI/"Open Development" split. An open platform is _very_ important to a lot of people, a lot of whom are developers. For a large group of other people, what matters is that it's easy to pick up and use, not who happens to control the development. Discord could be miles better. IRC could be used as a backbone of a great modern system. I'm not arguing these points. Usability and accessibility (to "normal" people, unfortunately) are king in these decisions, though.
They all do.
Why is this the option? Why is this considered acceptable?
It never really came up. I planned to teach new hires myself, and it worked great. We grew from 2 people to 5 people, and initial 2 people were both Rust contributors and programmed in Rust since Rust 1.0. New hires were productive within a week.
A trait method cannot return `impl Trait` yet. This is being worked on, but has some thorny corners to work out first (incl. GAT).
Pushing everyone to Discord seems absolutely bizarre to me. Why not Matrix?
1. familiar technologies - an application that works on the web *and* across all major desktop platforms - a lot of people (sadly) don't care about the bloat \#2 is by far the most important point, since chat application developers already have to create a web app, and it's too easy not to just wrap it in electron and ship it to all the major platforms. I really can't blame them.
There is [Twist](https://twist.com/?lang=en) as well
Oh, right, trait methods, not impl blocks. Yeah, I'm looking forward to being able to do that as well.
Honestly, you won't find many of us willing to join and use a proprietary platform like Discord. Seems a little strange to be promoting a service whose audience are gamers and video game communities, too. I guess it works if you're already a gamer and don't mind being a part of a proprietary platform, though many of us aren't.
&gt; new skype source that please. Discord is many things but it’s nowhere near the atrocity that was Skype.
By far the single biggest pain point is const_generics. It can't be implemented and stabilized fast enough. I wrote an elaborate system of macros to solve the issue for our particular system. Loading the fixed buffer size from slice fat pointer instead of being a compile-time constant hurts, I measured &gt;10% penalty in some cases. Other pains included setting up a physical server at Busan which is 400 km away, waiting for regulatory paperworks to clear, dealing with fees, deciphering inscrutable protocol documentation from the exchange, convincing company firewall department to allow Rust-related URLs, dealing with gratuitous protocol changes from the exchange, dealing with [Korean SAT](https://en.wikipedia.org/wiki/College_Scholastic_Ability_Test) exception (to quote Wikipedia, "On the test day, the stock markets open late"... don't ask), etc etc, in roughly chronological order. But that's not specific to Rust, right? I mean, vcpkg-related URLs also needed clearing.
400 km is 248.55 miles
Do bindings count? I'm having a great time with [https://github.com/Gekkio/imgui-rs](https://github.com/Gekkio/imgui-rs)
You need to source it? Just open it. Perhaps you are blind and the accessibility software doesn’t show you how obnoxious it is?
At least with open source platforms, such as Mattermost, it is entirely possible to write bindings to their APIs, and subsequently develop desktop applications around them.
There’s about a thousand people already on the Discord.
Great argument you’ve got there. Should submit it for your masters thesis. I’ve been using discord since around 2015 and it’s been excellent, minus the new store stuff which is mostly annoying. Skype was *really* bad.
I'm not saying that desktop applications are a must, quite the opposite. I'm saying that Electon-based desktop apps are ridiculous for text-based communication.
Also with Iterator types like `Map` involving Closures.
We plan to port more modules to Rust, although GUI is based on MFC (don't ask) and will remain in C++. We implemented client-server split with gRPC, and although currently both run on the same machine on Windows, we will move GUI-less server part to Linux. We are also looking forward to run on JPX(Japan Exchange), although that is unrelated to Rust.
This is awesome! Do you deviate a lot in coding style from usual Rust idioms to squeeze the last bit of performance, e.g. use u8 array instead of str, using unsafe besides ffi? What do you think is the area where Rust is better than c++ latency wise e.g. better confidence in zero-copy because of the lifetime? What onboarding strategy you use to get c++ people in your team become productive in Rust fast?
Technically, they all provide REST APIs and web sockets that can be used to develop native clients in any language on any platform. They just only officially develop web interfaces that can run in a web browser.
I like fzf with ripgrep. Fuzzy search every file from root (I do below the current directory) and you can drop .ignore files if you don’t want certain folders.
*Learning the hard way* :-)
Seems completely proprietary?
I guess you're looking for a non-proprietary solution, but that is not part of the requirements I've seen. Zulip is a free version of twist pretty much, but twist is a bit easier to understand
It is getting steadily worse - more advertising on opening the app, necessary updates on every use, buggy in-game integration.... I think they've done a good job with the product saturating the market, but they're getting greedy. It won't be more than two years before it gets to be the average user's thorn in the side.
Rust data types vice JS/web\_sys nodes/elements.
We have more than a thousand people on our Mattermost instance for Pop!_OS. I'm certain you could do better with promoting an open source platform, and have more opportunity to get what you want from the platform.
Worth noting I think that there's an open-source service that bridges Matrix rooms and Discord channels (https://github.com/Half-Shot/matrix-appservice-discord), so if we wanted to have both there could be official matrix rooms but also a discord endpoint for convenience of users that would rather use it. From my experience using Matrix (via [Fractal](https://wiki.gnome.org/Apps/Fractal)), the bridge seems to work pretty well on rooms that use it. I don't know what the experience is like in Discord interacting with Matrix users, though.
There's essentially no reason to use the Electron applications for any of these services. They're nothing more than Chrome instances that load the website. They're virtually no different from having a browser tab open. I have two Mattermost and two Slack tabs in Firefox as we speak. Even though the UIs are pretty heavy, they at least share the same browser.
Seems you edited your comment. Not sure what you mean by "amazed a company like that can even get funded". &gt; God bless the CTO that choose to use Twist :/ Also can't tell what you mean by this
Ok correct me if I'm wrong, but isn't the point of having a code of conduct to be inclusive and allow a more diverse community? Because if so then you may have now the tools to enforce those rules with Discord, but also excluding everyone that either a) can't run Discord or b) who still avoids services that basically "sell them". I understand that this is probably a pragmatic decision, especially because I grew up with IRC and I know how hard it can be to moderate even a relatively small channel. But if you just consider a) you are now discriminating against people who can't afford the hardware that runs Discord well enough. What do you recommend in that case? Just violate the TOS and use an unofficial client? That might get them banned which means that they now can't access that part of the community anymore. Just because they don't have enough money at the moment. To me that makes that code of conduct argument a little bit dishonest, even though that might have not been intended. Whatever the choice may be I think if a project put the time and energy into being inclusive it should also consider that the communication tools they use are not exclusive. Otherwise what's the point?
Wow, that's really helpful! I was mainly looking at rodio and I remember there being a callback, but I could figure out how to make it work. I think I'm going to try this out, it'd be fun to make my own solution vs rely on however SFML does it. I'll definitely check out the discourse group, seems like a great community, thanks!
Matrix wasn't (and still isn't) mature enough in its moderation tools. Look around for the discussion with a Matrix dev in this thread for details.
It seems like a non-propriety communication solution is not a requirement for the Rust team that manages it, but it does seem like it's quite important to the community, be it IRC, or one of the Slack/Discord open source alternatives.
I haven't tried anything yet since I'm still reading about benchmarking (which I'm new to). I looked at a really popular benchmarking crate that said it doesn't work for binaries, and from what I've been reading, `cargo bench` is demonstrated with a library and not a binary. Thanks!
Thank you! I like trying to write async programs with pure 0.3 and I was sad that this didn't exist when I was looking for it.
&gt;Other platforms at least require an email You can setup irc to require registration with email confirmation, captchas and even phone number verification if you really want to. &amp;#x200B; It's just a protocol after all.
Huh, from the comments in this thread it seems like people don't want discord, not because it's proprietary, but because they think it sucks. From my point of view zulip is the best of all, but it does have a very confusing interface.
Except Jenkins requires minimum 200mb. Each build node is 2-3 threads taking ~2mb. That is just for POC setup. Actual production jenkins with a lot of plugins that you will need under load consume much more.
You guys run an HFT system on Windows? Might want to look into running on a real-time variant of Linux. There is a real-time kernel for Debian and there is also Redhawk Linux.
&gt; New hires were productive within a week. ... I'm awestruck. How was this magnificent feat accomplished?
You are why the docs suck. You write them for yourself and not people who aren’t “superheros” and don’t already know how to use crates they have never seen before. Take the feedback.
The state is not good. I wish I could say something more positive. I needed a drop dead simple settings UI for E-Nguyen. I tried several options and determined that they had dependencies I didn't want or were not more likely to run and compile than the Vulkano components in the separate "Mesmerizer" window. They lacked really basic widgets for manipulating typical structured data. I was no better off with a single one of the options than to just start hacking together my own UI using Vulkan. A lot of the work on the various UI libraries is focused around optimal immediate and retained mode rendering, very performance-focused kind of stuff rather than pragmatic UI components to slap together structured data editing, one of the bread-and-butter employments for UI libraries. We need garbage-tier built-in jquery UI. There is no arewegarbagetieruiyet.io Having worked on Kivy and used a lot of web and Android drawing technologies over the years gives me the impression that no single project for UI drawing is really ready to just be a simple turnkey crappy UI solution. These crap-tier libraries are under-celebrated. Part of my decision to start making my own UI was to have a low-effort Vulkan problem built in so that some work would not involve sophisticated rendering composition etc. I also wanted to have something that was more likely to run than the complex Mesmerizer to aid in establishing a baseline when doing debugging. If I have to guess, not one entry in the current crop will reach maturity. The first UI that prioritizes garbage-tier widgets and supporting light &amp; dark colors will at least pay back more than it's soaking up in development effort. It needs to focus on an API that is simple because it does almost nothing and not because it has some sophisticated implementation strategy to hide the details and optimally render. Being very lightweight on dependencies will also be a priority. ## Azul: Just take a look at the dependencies being maintained totally off of crates. I have a bad feeling that the wrong fight is being chosen. https://github.com/maps4print/azul-dependencies ## OrbTk No dropdowns. Other basic widgets were missing. Like, Azul, it almost looks fine out of the box, but then the lack of widgets and docs to create these gizmos bites again. ## Conrod It almost kind of works, but there was almost nothing in the way of widgets and out of the box it was kind of like starting with nothing but rectangles. I can also draw rectangles in Vulkan, so you can anticipate where this is going.
Yeah probably, once they burn through VC money and need to actually earn more income. My response to the parent comment still stands though, **currently** discord has a completely fine user interface, albeit with some minor annoyances. I think people forget how bad Skype was sometimes.
Another solution is for libraries to re-export any crates they use that are part of the library's public API.
Discord is so bloated, is there a lighter version anywhere?
This is on the agenda. See the other reply.
If you check all the comments, it's apparent that the main critique against discord is that it's proprietary. The other issue is that it's less tailored towards productive discussions and more towards gamers. And it runs on electron, but they all run on electron.
Is there a light version of Discord anywhere?It's pretty bloated
By hiring great talent and paying them well.
Rust is not that hard to learn once you appreciate what it's trying to solve. If you have experience with low level stuff in C or C++ you probably already know what you have to do to not fuck up, so by default you follow rust's rules, it's just nice to have it enforced and the other features are probably in some other language they have used. Besides code reviews help a lot, one useless clone spotted and the person learns why it exists.
Those specs are overkill. You should be able to run Rust on something as small as an Arduino. Just make sure to set up a proper cross-compiling environment.
Thank you for making me realize that my question was too vague. I've edited it accordingly. Casting that aside... One week of rampup even on an already-familiar language is already exceptional - for a person not familiar with the language, 1 week rampup for the language alone is more typical of Go, which is rather optimized for fast rampups. Rust, on the other hand, for all its marvels, makes one learn a lot up front.
That's true. I think a big part of this could be attributed to different work ethics/attitudes to work, both between the tech/finance industries, and North America/Korea. Finance firms have a reputation for a bad work-life balance in exchange for really good compensation (compared to regular tech companies), and Chinese, Korean and Japanese work culture (for lack of a better term) really encourages and normalizes long working hours. Definitely a herculean effort from the new-hires as well.
thanks
This looks really awesome. Seems like we might get more stories like this from other companies in the near future which is pretty exciting.
Awesome! I'm currently working on my own HFT bot (ongoing project for one year now), which is fueling my interest in Rust. How well does this kind of work pay professionally?
We'll be posting a roadmap and regular updates beginning May 1st. The past few months have been pretty busy with getting organized as a team under the non-profit organization, prioritizing features and getting them onto a roadmap, getting rendy integration properly scoped and on track to being finished, and other logistical/organizational tasks. We opted to spend the time up front to address this before trying to charge ahead with feature work. &amp;#x200B; 2019 should be an exciting year for us. In addition to the grant-funded WASM work, we've got the rest of the year planned out. Just took us a bit to get coordinated; there's over 20 org members scattered all across the globe. The organizational/logistical challenges have been...fun. =)
Do you use tower for gRPC? Also do you use protobuf 3 for it? What crate(s) do you use for it? Been meaning to write a gRPC client / server for our microservices in which the majority are go servers :(
I'm having trouble finding any comments saying the problem is that it's proprietary. &gt; I tried Discord but couldn't warm to it; I don't think it's geared to productive discussions. I actively dislike Telegram and that's one of the reasons I no longer hang out on the rust-vst channel (sorry folks). --- &gt;From experience with other projects, Discord seems to have a much lower barrier to entry than IRC. I can't give more details. I prefer IRC myself, I just see everyone else moving to Discord. &gt;It doesn't help that IRCCloud, while nice, has a somewhat restricted functionality in the free tier. I run my own bouncers, but most people have no hope of doing that, and it's completely unneeded for something like Discord. --- &gt;God discord is so bad. &gt;It’s already become the new skype with all of the woes related to that software. --- &gt;source that please. Discord is many things but it’s nowhere near the atrocity that was Skype. --- &gt;My response to the parent comment still stands though, currently discord has a completely fine user interface, albeit with some minor annoyances. I think people forget how bad Skype was sometimes. --- &gt;I’ve been using discord since around 2015 and it’s been excellent, minus the new store stuff which is mostly annoying. Skype was really bad. --- &gt;And to be clear, Slack is terrible on moderation tooling as well (it's a workplace tool, moderation issues are expected to be handled by . Discord is pretty okay, especially since there's a community of third party bot tools that help. --- &gt;But people don't want transient history anymore. That's why e.g. bouncers are used on IRC and why Discord is more approachable: you don't have to be online to see when someone mentioned you. --- &gt;I "found" Discord early on, in its first few months when it was little more than, as I described it: IRC + Teamspeak server, but always online, and hosted. I'd tried getting my Skype group to move to IRC/Teamspeak (because they are definitely better than Skype for server-like groups) but Discord is what finally got us off of Skype. The permanence was the deciding point there for this particular group of tech-minded people. &gt;Discord could be miles better. IRC could be used as a backbone of a great modern system. I'm not arguing these points. Usability and accessibility (to "normal" people, unfortunately) are king in these decisions, though. --- &gt;Discord: &gt;&gt; runs on chrome &gt;&gt; **is proprietary** &gt;&gt; is extremely slow &gt;also, if the goal is to thwart harassment, discord is certainly not the choice. --- &gt;All the communication apps use electron (Slack, Riot, Discord, Zulip, Mattermost). Matrix does have some clients that are native, but none as fully featured as Riot. --- &gt;I have no hope of Rust actually switching away from Discord, but for anyone else reading, here is why Matrix should've been chosen: https://www.ruma.io/docs/matrix/why/ (there's also an overview of what Matrix is if you're not already familiar with it) --- &gt;Matrix still has no moderation guides and documentation, which is of crucial importance to Rust. When we were evaluating chats, only Discord would deliver in that area. --- &gt;You're looking at this the wrong way, individual teams made their own choices here and basically ended up picking either Discord or Zulip. There wasn't a top-down decision with a single set of requirements here. It was also very much just trying a bunch of things and picking what people liked best. --- &gt;When Rust was looking at channels individual teams tried different things. People seemed to like discord and Zulip and that's what we use (different teams have picked different platforms). The bulk of the project shifted to Discord or Zulip, leaving a couple channels behind. --- &gt;The thing I love about IRC, and is unlike other systems like Discord or Slack is that I can just pop into a channel, do what I'm there for, and leave if I need to. Slack and Discord both require you to join a group, which adds time when something like moznet already exists. I can currently go to #rust or #rocket just as easily as any other, and I don't need to join a new group to be able to access it. --- &gt;Pushing everyone to Discord seems absolutely bizarre to me. Why not Matrix? --- &gt;Honestly, you won't find many of us willing to join and use a **proprietary** platform like Discord. --- &gt;Discord is so bloated, is there a lighter version anywhere? -- &gt;Ok correct me if I'm wrong, but isn't the point of having a code of conduct to be inclusive and allow a more diverse community? &gt;Because if so then you may have now the tools to enforce those rules with Discord, but also excluding everyone that either a) can't run Discord or b) who still avoids services that basically "sell them". --- &gt;I can't speak to your other concerns, but know that Discord scales at least as well as any other solution without dynamically created chat channels. So if #rust/#rust-beginners held conversation on IRC, it can work just as well on Discord. The developers also have said that the core server text/voice chat functionality will remain free (as in beer) forever. --- Correct me if I'm wrong, but there are only _**2 comments**_ that mention the fact that discord is proprietary. I really have no clue what you are talking about.
In its current form, I generally see it as a convenience for internal code. But I won't use it in a public API unless it's my only choice because it's too restrictive. It makes it difficult to, for example, return iterators that implement multiple useful traits (Debug, ExactSizeIterator, DoubleEndedIterator).
If you look at *all* the comments, quite a bit of people are bothered about using *any* closed source platform.
While I love IRC as much as any other guy who's been on it for 20+ years, but I do think it's time to let it go. I'm not positive that any of its replacements will beat it, and I don't think I'm only talking from nostalgia. It would seem quite ridiculous if Mozilla, with all its open-source ethos, would choose to move to a proprietary system. Especially when there are plenty of fine free ones available. Matrix seems to be quite hot right now. Also it seems like a good "investment" sort of choice, in the sense that (aside from XMPP and IRC) it seems to be the only Free choice with potential of good alternative clients. Many of them are already totally usable for an unencrypted channel (like almost all Mozilla's public channels would be).
Surely you know better than people who do HFT. because you know, Window$ $uck$?
Why do you upgrade to the last compiler version immediately? From experience, I know that for critical programs, the companies are very careful when doing this because of the potential regressions.
&gt; as recent events show one can have millions of downloads, and yet noone will look to see what are they actually using. The code was obfuscated, so it's not clear to me that review would have caught it either. I'm fairly certain that if you re-read my comment, you'll find an appropriate amount of hedging in my words. It should be extremely clear that I don't think *use* alone makes something trustworthy. (A good example that would support your case in the Rust ecosystem is actix. It grew quite popular, but it wasn't until someone looked carefully at the code that lots of inappropriate unsafe usage was found and subsequently fixed.) Adding a way to easily see diffs would be great. But I don't really see the rest of your comment as too convincing unfortunately. There is so much more to trust than code review on its own. I get that all models are wrong, and that some just do happen to be useful. But my model of trust is much more complex than what crev provides. I guess my argument boils down to this: crev's model of trust is both simultaneously too weak and too laborious.
Once again, I'm not seeing that. Maybe you are interpreting the comments differently, or maybe you think that 4 very low ranked comments is somehow indicative of the mood of an entire thread, but I think you are very mistaken about what people are bothered about.
Hey newbie here, learning rust is like banging my head to the wall, I work with JavaScript and python, any advice for me. Resources recommendations will be appreciated. Thanks for AMA.
Well what crates are used in your project, if they are public ofc?
I think you are in the wrong subreddit. This here is about the programming language Rust and not about a game which coincidentally has the same name.
I know you were making a flamey sarcastic comment, but the suggestion was not to indicate windows sucks, but rather that there are versions of Linux that allow you to exclusively run a process on a cpu core without kernel scheduling interruptions.
This was my experience. I have a strong C/C++ background, and after I accepted that the borrow checker was smarter than me, I became productive pretty quickly.
I think you are in the wrong subreddit. This here is about the programming language Rust and not about a game which coincidentally has the same name.
Make Browsers Game Again
What is a tarpit?
I've been meaning to write an mlocate+updatedb analogue for indexing stuff that's too bulky to go in my nightly incremental backups and has to be restored from manual DVDR+dvdisaster backups, but I have yet to get around to it. ripgrep's [ignore](https://crates.io/crates/ignore) crate is a good place to start since it gets you efficient filesystem walking and filtering for your `updatedb` analogue in a ready-made crate. So far, I've just got something equivalent to the `updatedb` from earlier `locate` implementations which don't do the I/O-minimizing merging that the "m" in `mlocate` signifies. (On the plus side, what I've currently got uses minimal memory because it writes a gzipped JSON index in a fully streaming fashion.) Speaking of which, be careful about using serde-json with mtimes or file paths. [It'll panic](https://github.com/serde-rs/json/issues/464) if it tries to serialize a `SystemTime` value that's prior to the UNIX epoch (less than zero) and either [fail or induce corruption](https://github.com/serde-rs/json/issues/465) on encountering a `PathBuf` with bytes that aren't valid UTF-8. (Fail if you build the entire data structure in memory and try to write it to file. Corruption if you write your JSON to disk using the streaming APIs.)
While I’m learning I like to write everything long hand, but thanks for the tip.
Number of "free email address for life services" I've belonged to: 3. Number that ended that offering early: 2. Number that ended free service early because going out of business: 0. Google Hangouts is going non-free. It makes no sense at this point not to control one's own chat destiny.
I just went through this process. Conrod: basically no documentation, takes a huge amount of code to get a simple window. Other than that seems the most complete in terms of widgets. Azul: Easy to get started with, fairly good documentation/tutorial and lots of examples. But pretty buggy and very few widgets. CSS support is also very incomplete. Druid: Doesn't seem usable yet Right now I think the best bet is to bind to gtk or qt. The bindings are immature as well but at least the underlying library is mature.
I actually use Discord for gaming, but I can't imagine using it for anything substantial. I almost certainly will never visit the Rust Discord.
Great suggestions. I recently fixed a similar problem with regards to \`from\_i64\` etc but missed this. I will raise issues and resolve!
It's hard to help you with so little information available about your project. I advise you to read the rust book ( https://doc.rust-lang.org/book/ ), and learn the language and tools from the ground up, as you seem to be struggling with basic concepts.
I've been considering these kind of standards albeit not focusing on them. Is there a specific use case that you're looking in to?
How does an HFT system work? Is it manual or do you use some kind if machine learning to predict the price?
&gt; Discord seems to have a much lower barrier to entry than IRC IRC: - download hexchat - select moznet on the server list - type in #rust when it's connected Discord: - download the client - sign up using email and phone number - allow sending off your all messages and other data to third parties - find a invite link to join - finally be able to write anything Also, I really don't want to have to have an additional account for work (even though it's spyware I still use it for voice chat)
When I started using it some 4 years ago it was rather fast, and it did what it was supposed to do: voice calls and text chat. Now, it constantly pesters me to get the 9.99€ subscription to get animated emoticons, for some reason scans my hard drive for games, for some reason shows news and ads as the first thing you see when starting it up. In 2-3 years it will suffer a fate worse than skype.
Likewise. I have a couple of friends I talk with on Discord but I've never been to the Rust Discord and, now, I'll just "google harder" next time I need help with something.
Nice post! I wish I had the time and energy to write a 3D thing: I'd love to try out `luminance`. Do you have a demo somewhere done with `spectra` we could look at? Would it be an appropriate framework for people in both my Rust course and my sound course to write a little demo in, or do you think it would be too hard?
This is really cool
If someone starts spamming links to gore or some porn, do we have any way of not seeing it? It's baked into the client, it will always expand images, no amount of tooling can fix that. People are forced to see it until it gets removed by a moderator meanwhile on IRC all anyone would see is a weird link also I'm wondering where the hell is all this harassment, I've spent countless hours on Mozilla's IRC and I've never seen any.
NickServ? Mozilla has it. Connect it up to Twillio or something and require phone verification and the trolling will stop since it will cost at least 5$ each time.
Awesome, I'm the creator of crossterm and I like to see it in use with some and a in-depth view on how the migration went. Awesome blog post! Two notes: - windows 10 uses ANSI escape characters too. Only versions lower than that use WinApi. - I don't use println however I do [use](https://github.com/TimonPost/crossterm/blob/master/crossterm_utils/src/macros.rs#L9) the 'stdout()' with 'write!' function directly, which causes a lock to happen . I am trying to think off ways to improve this.
And if you use a web client you can skip step one for IRC. And if the webirc points to Mozilla by default you can also skip step two.
I also think that it's easier to extend an existing system in an unfamiliar language, than writing it from scratch.
Nice post, and nice project! I feel you on the imposter syndrome part. I am aware of it for myself, and have gotten better at dealing with it as time goes on. But then you enter i.r-l.o, get hooked and excited on all the awesome and complex stuff people are talking about, but also equally aware of how much there is still to learn, even with all the knowledge you’ve gained in the years preceding. And so you go to your favorite online bookstore, and order some more books to keep learning, and hopefully one day be able to fully understand everything being discussed in i.r-l.o. That is, until you take the next step of actually trying to contribute to the compiler, and the cycle repeats. Boy, how I both love and hate the profession I chose when I was so much younger, and so much more naive: “What’s all this talk about pensions?! I’ll never stop learning, and never stop working, this is just too much fun!”.
I think you are looking for r/playrust
Same boat, same struggles, except I prefer to fallback to web programming instead of 3d programming, because of familiarity. I discovered [web-view](https://github.com/Boscop/web-view) yersterday and it may be the best option so far, being very light &amp; capable enough for my needs. I still need to try to use in a project, but it looks promising.
More of a cultural related question. Are your developers all Korean ? In my experience some aspects of East Asian culture is not always conductive for developing good software. For instance design discussions tends to be muted, as there is fine line between challenging a design on technical merit, and provoking a loss of face. Has this been a problem for you ? Or how do you organise the design process to ensure that everyone has a say, and the discussion is driven forward ?
There is [https://areweguiyet.com/](https://areweguiyet.com/) for this.
I'm not sure why you're arguing with me. I use IRC. I just notice that everyone else seems to be on Discord. So clearly the above comparison is missing something.
&gt; Sorry, the Rust teams. My comment was unclear, but the blog post very clearly talks about this. Not too long ago, the claim was that "it's up to each team individually what platform to use". There certainly wasn't anything communicated about a *coordinated* move off IRC of any kind, by Rust teams. Even the blog post says that (emphasis mine): &gt; *__Almost__ all the Rust teams no longer use IRC as their official discussion platform, instead using Discord or Zulip (as well as a variety of video chat tools for synchronous meetings).* This doesn't match the statement that "Rust moved to Discord and Zulip a year ago". &gt; There were a couple non-team channels left. Those "couple non-team channels" constitute a lively community of some thousand people and fairly constant activity, who now suddenly find themselves without a clear home. From all the messaging around this, including phrasing it as "a couple channels", I frankly get the impression that this community isn't really valued at all. &gt; Those folks can move to Freenode, the Freenode channel is pretty okay. There are also Discord channels providing the same functionality, so they have a choice. So they have a 'choice' between a) a proprietary platform, or b) an entirely different channel run by different people that is unofficial and therefore gets no influx from the rest of the Rust community venues at all (hell, even [the link to IRC has been removed already again](https://github.com/rust-lang/www.rust-lang.org/pull/750)). For an IRC-based community, that is not a "choice", it's an excuse. Once again, I get the impression that the open aspect of the community platform is totally ignored as if it doesn't matter. &gt; Mozilla's decision was enough to make Rust reevaluate whether or not we needed an official IRC venue. We decided against it. This is after repeated attempts at improving IRC moderation, lots of harassment, and in general just no good results. I frankly don't care whether we have specifically an official *IRC* venue, IRC is just a protocol. It has plenty of issues, and it would make sense to replace it with something more modern and usable. What I have a problem with is the unspoken conclusion that we don't need an *open* venue, which I find to be an especially disappointing decision coming from either Mozilla or the Rust team. The Discord channels are being presented as an equivalent venue, but they really aren't in the slightest.
Thanks!
Typically "on the web" does end up meaning "in Chrome" of course. Discord is a nice example, as the WebRTC stuff didn't (use?) to work in Firefox because they relied on the non-standard Chrome implementation.
&gt; who can't afford the hardware that runs Discord well enough What?
Thanks for the feedback. I have changed the implementation to use recursion. Will try to implement using iteration soon.
Thanks for the feedback. The code you have shared looks awesome. I'm a newbie and I think I need to practice and learn more to come to a point where I could code in Rust like that. Will keep asking for feedback till then.
Thanks for the feedback. I have changed the type to usize, as it was in @Boiethios's implementation. Do you think it is better?
I love Telegram and use it almost all of my personal communication, but I think it is absolutely \*not\* the right platform for Rust. IMO, it's not even remotely an alternative to IRC, Zulip or even Discord for projects like this.
Would you mind to tell me more about the cbindgen part? Currently c++ support is quite poor in cbindgen. How you overcome this? Would you need to write a thin c layer on top of your in house C++ library?
It gives you type safety - that's the main selling point.
Hi, thanks for being in touch. I'm running a conference until Monday, so should I not respond, please feel free to prod me. I want to give you a detailed answer. Also note that the post is rather old and predates the document that you link. I appreciate that you wrote all that down and will update the post after I had the chance to read through all of this. Yes, the threading model of Zulip isn't the concern, more the interaction with the project around these issues, e.g. Zulip now has rather good functionality around abuse and moderation that is also well documented, which wasn't the case when we evaluated.
Evil bots probe the internet for open ports of common protocols like ssh. They'll try go connect and are up to no good. A tarpit masquerades as such a service. But when a bot attempts to connect, the tarpit will "abuse" the service protocol by never Acking a response, or sending retry requests over and over, and much more complex tricks that result in the bot wasting huge amounts of time.
thanks for responding, and good luck with the conference :) meanwhile i might take advantage of the weekend to write a moderation guide before anyone else gets bitten by this!
How do I read messages that were sent while my computer is off with hexchat? How do I get notified of mentions that happen while I'm offline?
Very nice. Other HFT firms are doing rust in London. I myself built an hybrid KDB/rust analytics platform for a systematic shop. Hit me up if you need a hire in London ;)
You might want to look up React because it implements the same idea. But the gist is that we want to specify how the DOM/website should look in a declarative manner. A naive way of achieving that would be to, whenever state changes, simply re-create the DOM. The problem is that it's not very efficient, nor does it preserve the user's selected widget, etc. That's were the virtual DOM comes in. Instead of rendering the heavy DOM every time, we render a lightweight virtual DOM which only encodes what we need. Then we can patch the real DOM to match the VDOM while only touching the things that have changed. What this crate does is define a VDOM data structure that is often more lightweight than similar VDOM libraries, while keeping the implementation complexity down.
No need for real-time variant of linux for this. You can reserve cores all you want on linux vanilla, and I guess also on Windows. So the real-time variant reference was maybe hinting at something else useful for HFT?
I actually wrote such a program, which I called `lolcate`, but didn't publish it. r/free_are_we's interest motivated me enough to do so. I'll take the time to write a proper README, publish the whole thing to Github, then make a proper announcement on r/rust later today. Stay tuned !
Exciting! Looking forwards to seeing what's coming!
All this talk of inclusivity reminded me of one class of users that ends up excluded when we trade text for flash UIs: [https://support.discordapp.com/hc/en-us/community/posts/360032435152-Discord-Accessibility-for-blind-users](https://support.discordapp.com/hc/en-us/community/posts/360032435152-Discord-Accessibility-for-blind-users)
&gt; Seems a little strange to be promoting a service whose sole audience are gamers and video game communities This hasn’t been true for quite a few years now... React moved to Discord because Slack had a room limit, Golang have quite a big community on Discord (unofficial), there are other open source communities on there. Sure it started off for gamers, and they are still the dominant clients, but to say it’s solely for gamers isn’t true.
&gt;windows 10 uses ANSI escape characters too. Does this mean that termion works on Windows 10?
Telegram is great for 1-on-1 conversations and small group chats with friends, but that's about it.
As a day job I'm a C++ programmer and spend a lot of time optimising code. The last year of work has convinced me that (in my work at least) implicit copying is a worse default than implicit moving plus a borrow checker. A lot of code I see is just slower than it needed to have been because `std::move(...)` was too much effort to type. I believe Rust's implicit moves do require the programmer to think more, but the borrow checker and lifetime errors will (or ideally should) guide your thought to something that's fast and correct.
Partially, there are ports that tried that, however, there are some windows specific things that can not be done with ANSI codes. Termion is great but in my opinion, it is a bit too tangled into ANSI escape codes.
&lt;3 FWIW: I'd love there to be a new, modern, FOSS chat for open communities that tackles a lot of problems. I just can't invest much time.
Yeah but it can also be deleted. There's been tons of harassment, some team members even had to basically avoid the platform.
One minor thing I noticed is that you are using extern crate to import your dependencies, since you are using Rust 2018 you omit these lines. For reference here is the section in [The Edition Guide](https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html#no-more-extern-crate).
And generally iterator types where the specific type doesn't matter, just that it will be some sort of iterator.
Thanks for this post. I've always considered Rust an excellent candidate for trading systems. Usually, this industry (Fintech and related) prefers languages with powerful type systems like Haskell, OCaml and Scala, but for performance critical parts C++ and C are used. I think Rust is a good combination of a powerful type system and very good performance.
Actually, as someone who doesn't use IRC, it's pretty spot on. I remember playing around with it as a teen, and had some friends with pretty advanced setups, but I was never interested in learning all the tricks and intricacies. I want searchable history by default, not having to root around for an add-on. I want online notifications by default, not having to root around for an add-on. I want file transfers by default, not having to root around for an add-on...
I personally wouldn't trust it. Who runs their trading infrastructure on a windows platform. That's ameteur hour. They should be using a RTOS.
I feel it is a bit unfair to call it the new Skype, Skype was pretty bad even back in 2008 when I started using it. But what they both share is vdcomibg worse every commit.
Russian Rust community is Telegram-based since like day one. Simple, convenient and used in daily life by just about everyone.
Lol just commented this too. Should have scrolled...
Is spectra still a thing? Are there examples of luminance?
&gt; One week of rampup on an unfamiliar codebase even on an already-familiar language is already exceptional You may be reading too much in this; I interpreted sanxiyn's remark as meaning that the new hires were as productive with Rust as they would have been with C++, not as them having mastering the codebase.
It's not really intended to compete with Blink directly. The point of Servo is to prototype technologies that then get added to Firefox when they've proved themselves worthwhile and ready. It's where Firefox's Quantum CSS, Quantum DOM, and WebRender came from.
Also raising my voice against Discord. You can't seriously proposing a switch to something that is known for scanning your harddrive, adding "game jokes" in every email, wants you to buy a subscription and shows some animated gaming stuff on startup. Like seriously, it's not meant to be used for serious stuff.
I have only ever seen Stack Overflow using Windows Servers, and a complete Microsoft stack. Would you mind sharing some of the advantages you have found in using Windows compared to Linux? Are you able to reach wire-to-wire as low as 2.5 μs on Windows as mentioned by [Carl Cook here](https://www.youtube.com/watch?v=NH1Tta7purM)?
There wasn't a coordinated move. I mean, it was somewhat coordinated in that a Discord and Zulip server were set up and that teams liked them and this spread through the project, but no top down coordination. &gt; This doesn't match the statement that "Rust moved to Discord and Zulip a year ago". I'm sorry, I figured we were talking in the context of the blog post above. Communication is inherently imprecise, I shouldn't have to caveat each and every thing I say when I can rely on things that have already been said. Yes, most rust teams moved. &gt; Those "couple non-team channels" constitute a lively community of some thousand people and fairly constant activity, who now suddenly find themselves without a clear home. From all the messaging around this, including phrasing it as "a couple channels", I frankly get the impression that this community isn't really valued at all. It's pretty valued, however we're not able to guarantee that the code of conduct will be upheld there, and have _already_ tried hard to fix the problems. It's not something we can endorse. We'd need a much larger moderation team, and better moderation tools, and while this is something that can be built up it can't be built up _now_. And we've tried. In the future if a well moderated IRC community forms we can try to make it official. I personally plan to keep an eye on the Freenode channel and continue my attempts to scale moderation there. Rust's IRC community is something I've poured tons of time into, I value it a lot. &gt; So they have a 'choice' between a) a proprietary platform many don't care about it being proprietary. &gt; b) an entirely different channel run by different people That channel is run by some pretty well known rust community members, and there is overlap with the rust moderation team. I and others are planning to keep an eye on it as the transition happens. &gt; that is unofficial and therefore gets no influx from the rest of the Rust community venues at all Sure, that's a problem. But you know what? The unofficial Discord isn't linked anywhere and it's grown close to the level of activity of #rust, if not more, in a pretty short time. The IRC community can manage. There will always be folks who prefer IRC (hell, _I_ prefer IRC) and they will seek out that channel. &gt; EDIT: Actually, let me just ask this head-on: Does the Rust (Community) team intend to strive for an open official community platform at all, or is openness not a goal? Openness in our software is a nice to have. It's not something we value above all else. If people are getting harassed and in general people are being scared off a platform, that is a far bigger problem to us. A lot of folks, including me, would love for an official Matrix venue. Many of us evaluated it last year and it wasn't good enough on the moderation front. We _have_ strived for an open platform, but there's a limit to how much we value openness here. There's a comment from a Matrix project lead somewhere here that's promising for future prospects, but as it stands it's not good enough. Maybe later.
But databases can change schemas, so it really doesn't. You can still get type mismatches.
Yes, the way the scheduling works on windows and regular linux allows for variance in the timing of any task. Say you want it to check the result from a particular end point every 5 milliseconds, it could take 6 or 7. With a real-time variant it will have less or no variance. From what I've read about HFT those milliseconds can make a difference.
I have not heard that Diesel should be slower, quite the opposite in fact [https://hackernoon.com/comparing-diesel-and-rust-postgres-97fd8c656fdd](https://hackernoon.com/comparing-diesel-and-rust-postgres-97fd8c656fdd)
Flash guis?
/r/playrust
&gt; To me that makes that code of conduct argument a little bit dishonest, even though that might have not been intended. Are you also concerned about the people "discriminated" against because they use Windows 95, OS 7, or any number of other unsupported systems?
Good points; IRCCloud (and non-hosted alternatives like The Lounge) take care of that.
&gt; Discord works in the browser without downloading a client So does IRC. [Rust's community page used to link](https://web.archive.org/web/20190416155811/https://www.rust-lang.org/community) to Mibbit, which only requires you to enter a username and press Enter.
For file paths and JSON, the approach I took was to encode them as an object with two keys: `text` and `bytes`. If a path is UTF-8, then the text key is set with a normal string. If the path contains invalid UTF-8, then the path is base64 encoded and set to the `bytes` key. This way, the common case is easy to read, but all paths are still roundtripped losslessly. Alternatively, one could not use JSON, but that can be a tough pill to swallow. This doesn't unfortunately handle Windows paths correctly in all cases though. You would probably need to encode the raw UCS-2 code units somehow, possibly using a third key.
&gt; If someone posts a shit ton of racist screed on an IRC channel, do we have any way of deleting it? Nope. That's baked into the protocol, no amount of tooling can fix that. There is a draft specification for IRC to allow message edition and deletion. https://github.com/ircv3/ircv3-specifications/pull/304
In some match statements, I'm occasionally seeing `Ok(..)` (and others like `Err(..)`), and cannot make sense of it. What is the difference with `Ok(_)` here?
The irony would be for Discord to stop supporting Firefox, like Skype Web did a few months ago.
Hints I found so far: &amp;#x200B; * Mention of `Variant(..)` in [RELEASES.md](https://github.com/rust-lang/rust/blob/master/RELEASES.md). * [https://rust-lang.github.io/rfcs/1506-adt-kinds.html](https://rust-lang.github.io/rfcs/1506-adt-kinds.html)
&gt; Monsieur, mais quelle spaghetti are you talking about? As a native French speaker, I am afraid that the use of "quelle" here is off: - Spaghetti is masculine in French, so it would be "quel" or "quels" depending on whether you aim for singular or plural. - You may be interested in questioning the kind of spaghetti code, in which case it would be "quel genre de spaghetti".
My plan for round-tripping UCS-2 code units from Windows was to investigate how invalid UCS-2 looks when an NTFS partition is mounted on Linux and then replicate that.
So I either have to spend $5 a month on IRCCloud or standup my own server to use The Lounge. Whereas all I have to do to use Discord is sign up and I can begin chatting in the web ui right away. Is it any wonder users are moving away from IRC?
This post is a rewrite of the previous [_Unit Testing_](https://os.phil-opp.com/unit-testing/) and [_Integration Tests_](https://os.phil-opp.com/integration-tests/) posts. Instead of running unit tests on the host system, it sets up a custom test framework to run all tests inside QEMU. Along with this post, a update for the [_Minimal Rust Kernel_](https://os.phil-opp.com/minimal-rust-kernel/) post landed. Combined, you can now simply use `cargo xrun` and `cargo xtest` for running/testing your kernel. This makes the project ready for the [`std` Aware Cargo](https://github.com/rust-lang/rfcs/pull/2663) RFC. When the RFC is merged and implemented, `cargo-xbuild` will no longer be needed and the familiar `cargo build`, `cargo run`, and `cargo test` commands will just work. Note that this update affects some of the following posts too. For example, some posts received minor updates for migrating a test to the new framework. I tried my best to perform all required updates. Please let me know if you notice anything inconsistent.
Or find someone who hosts The Lounge for free. (In fact that sounds like a good idea, I'm going to look into doing that myself)
You can set priority and affinity all you like but without the real-time kernel it isn't a strong guarantee that you can rely on.
&gt; What? Discord isn't light by any means but it'll still run on a potato. Out of interest: What's the potato you're running the web based chat systems on? I'm on a laptop with 2GB of RAM, and if Mozilla wanted me to regularly use those, they'd have to rollback Firefox Quantum to not lock up my system.
That seems like a workable solution but surely it's obvious why many users prefer something like Discord?
A warning, this was merged very recently and is still only in nightly rustfmt (as far as I am aware).
Just letting you know, you should run spell check on your Readme. I will also note that there's a reason why I have a spell checker plugin in vscode, and it's because I need it or I'll have tons of spelling mistakes :)
I see, so Mozilla is looking for effective censorship tools and safe spaces. Gotcha. Luckily, a lot of solutions are available for that nowadays.
"It is for educational purposes"
Thanks, spellchecked. Too bad that there is no spellcheck in the github interface (the browser spellcheck is not active, I don't know why). If you see any other typo, feel free to open a PR.
Hi, \`stable\` certainly should contain the full set of components. The error message you're reporting suggests that you've not set the default toolchain properly. &amp;#x200B; Could you try \`rustup default stable\` and then try again with the command which was failing before?
Yeah, this is the idea! Happy you feel better though! :)
Yes, like many other closed platforms. They are easier to get into, and then the company decides unilaterally to make changes that hurt all or part of their users.
Slippery slope fallacy ?
Which RTOS would you recommend that supports Rust?
https://github.com/phaazon/outline-2017-invitro It’s very likely you won’t be able to compile it since I was using a local version of `spectra` (and I don’t recall which one…). You can find the executable on pouet.net ([here](http://www.pouet.net/prod.php?which=69698)) and [Youtube capture here](https://www.youtube.com/watch?v=sLT--TtkzSE). Currently, I wouldn’t recommend `spectra` (especially not the `master` branch that is currently highly WIP). I’m not satisfied with the current quality and design of `spectra`. It will get redone at some time.
Yes, because Windows 95, which practically nobody runs, is comparable to computers with low RAM, which is a *lot* of computers even today.
Lol, the IRC circlejerk is strong with this one.
It is but is a big WIP and I’m focusing on more atomic and smaller crates. `spectra` contained, back then, [warmy](https://crates.io/crates/warmy), [splines](https://crates.io/crates/splines), [cheddar](https://crates.io/crates/cheddar) and other things that I still have to move out from `spectra` (such as an animation scheduler).
I've set stable to default and now command `rustup component add rsl` presents me with: `error: toolchain 'stable-x86_64-unknown-linux-gnu' does not contain component 'rsl' for target 'x86_64-unknown-linux-gnu'` I've also tried `rsl-preview` as suggested in some issues.
The `_`is an unnamed binding, while `..` is an infinite range (in both directions). So they're equivalent when applicable (if you are matching on something where a range is meaningful). I would consider this very unidiomatic and you should probably just use `_` to indicate you're not interested in the particular value.
It is rls, not rsl.
Ok, what a dumb mistake. I misread `rls` as `rsl`. `rls` now installed fine but it is not working with VS Code extension but that is probably for another thread..
"why do musicians hate deaf people"
"whose sole audience are gamers and video game communities" What about the Rust community ? EmuDev community ?
Yes, thanks. I figured just as you mentioned.
Yes, it did. I was also the person that tied to get it replaces with better clients like KiwiIRC, but WebIRC means you don't see the source IP anymore, which in turn is one of the primary safeguards against spamming/brigading. I gave up that project, because I didn't want to invest the time to work past all the practical issues there.
You can change the number of spaces in an indentation in VSCode.
I haven't seen this before. If you change your `rustfmt.toml` to specify `tab_spaces = 4`, does the behavior persist?
We're not pushing everyone to discord. The discord server is WG and teams server primarily and not even all teams are there. It's just that given we got notice that the IRC is shutting down, we want to make people aware where other places are.
Hey folks, looking at [libsyntax](https://doc.rust-lang.org/nightly/nightly-rustc/syntax/index.html), how does the library expect implementations of Visit/MutVisitor handle errors?
&gt; When the RFC is merged and implemented, `cargo-xbuild` will no longer be needed and the familiar `cargo build`, `cargo run`, and `cargo test` commands will just work. Awww yisss
Imo, this is the best intro to writing OSes I've done. Phil has a [Patreon](https://www.patreon.com/phil_opp) if you want to support him for all his work with these posts (and updates too!).
There's a rewrite of FreeRTOS in rust that supports rust.
&gt; but WebIRC means you don't see the source IP anymore It doesn't. I tried joining with Mibbit earlier today, and here is the log from the channel: &gt; --&gt; mib_fooxxe (Mibbit@moz-al2ufj.progval.net) has joined #rust &gt; &lt;-- mib_fooxxe (Mibbit@moz-al2ufj.progval.net) has quit (Quit: http://www.mibbit.com ajax IRC Client) That's exactly like when joining with a non-web client: &gt; --&gt; pinkieval (progval@moz-al2ufj.progval.net) has joined #rust
&gt;Because if so then you may have now the tools to enforce those rules with Discord, but also excluding everyone that either a) can't run Discord or b) who still avoids services that basically "sell them". Or just people that don't want to run proprietary software.
Why shouldn't a chat program use a gigabyte of ram?
&gt; Web based IRC clients aren't much lighter on resource use. They are if you run them on a lighter web browser. The web browser is the part that's eating all your RAM.
[ABSOLUTELY PROPRIETARY]
Tbh, why care about Mozilla if they don't care about you?
Can you share your UI? I started experimenting with UI, taking as a base DOM and CSS (just as a pet project, exercise and curiosity) and want to keep the rendering independent of the main library, but will use for the main render library rendy, maybe I will end up having just a small project without too much functionality.
wrong sub bud, try r/playrust
This felt more like a stream of consciousness and less like a tech article. It talked more about JavaScript than it did Rust.
Have you got any examples/videos of spectra?
Because if Mozilla dies we'll be left with Google and that would be worse.
&gt; The thing I love about IRC, and is unlike other systems like Discord or Slack is that I can just pop into a channel, do what I'm there for, and leave if I need to. Slack and Discord both require you to join a group, which adds time when something like moznet already exists. Uhm... no. The problem is that you're applying a way too IRC-centric view on how Discord works. IRC makes it pretty awful to have a lot of individual channels for a single "group", whereas Discord makes it much easier. Whereas for a project like say `#rocket` would have one channel among hundreds on a shared IRC network, the same project might have an entire Discord server with 10+ channels and *guess what, it's way nicer to organize.* You absolutely still can pop in/out of Discord servers with ease. The only real problem here is that you have to explicitly right click and hit leave server which... really isn't a problem. &gt; I shouldn't have to run an Electron app on my desktop that eats up hundreds of megabytes of ram just for a simple text chat Fair enough. &gt; nor should I be forced to join every room (Discord) just to have a single conversation. I mean, Discord doesn't force having 10+ channels on anybody, you totally could make a Discord server with exactly one channel... Except nobody does that because having 10+ channels is *extremely nice*. You can just ignore those other 10+ channels if you just want a single conversation, and if anything it reduces the chance of you "popping in" being quickly drowned out by the next discussion.
&gt; Seems a little strange to be promoting a service whose sole audience are gamers and video game communities, too. That's how they're marketing it yeah, and I will admit some of the memes like in the changelog can be pretty damn obnoxious, but it's still extremely well featured if you ignore that.
Thanks for the ripgrep suggestion! Definitely will look into it.
Wow, thanks! I really appreciate you doing that for me.
There are browsers other than Chrome and Firefox.
Discord is actually rock solid for serious stuff if you just tune out all the obnoxious memes. Though yes I do understand why it could be icky in professional environments.
Low enough to not be able to run Slack/Discord/Zulip in a browser tab?
I've never heard of that. Is it this https://github.com/alexchandel/rust-rtos? I've only really seen RTOS platforms used on embedded systems. Trading systems seem more like an HPC environment. Are you building these kinds of systems in your work?
&gt; EDIT: Actually, let me just ask this head-on: Does the Rust (Community) team intend to strive for an open official community platform at all, or is openness not a goal? I can only speak for myself. Yes, I'd love there to be better options for free and open projects, not only in the chat space, but also in a lot of others. I don't see a good use of our time in building, maintaining and running such a piece of software currently. We're fundamentally a group that builds a programming language, everything else is a distraction. If we can support other projects to tackle the problems above, our channels are always open and we'd love to hop on a call to help out.
Perhaps you could explain to me, because I'm not well very well informed on this subject, how Mozilla dying could possibly be a good thing for browser diversity? It seems to me that Firefox is the only browser that can even come close to competing with Chrome/Chromium.
We've all been there.
We are [UTF-8 Everywhere](http://utf8everywhere.org/) codebase. All text is internally UTF-8 and converted to UTF-16 for display. We can't choose the exchange, so they give us CP949 stock names which we immediately convert to UTF-8. We are serious about C++17, so all binary is std::byte (new in C++17) array, which is u8 array in Rust. Rust does not touch any text, so no str type. We use GNU libiconv for conversion, &lt;codecvt&gt; was not worth it. I think coding style is normal, unsafety is mostly FFI, although we are not above using transmute to avoid serialization and deserialization. (No, that probably won't change. No, bincode isn't enough.) We static_assert is_standard_layout on C++ side. I am not sure about the right terminology, but we use more of "data FFI" than "code FFI", that is, sharing memory rather than calling functions. One reason is that cross-language inlining problem hurts. We had to be really careful about choosing code FFI boundary not to interfere with inlining. I heard using Servo components in Gecko basically has all the same problem. Overall, I don't think Rust is better than C++ for latency right now. The main interest was, besides "I want to use Rust!", correctness and stability. We had a number of crashes live which we debugged with minidump. You mentioned better confidence to zero-copy, but the correct answer is, you do zero-copy whether you have confidence or not, so Rust improves confidence not latency. Besides const_generics I wrote about elsewhere, there is also const_fn. We made aggressive use of C++ constexpr and C++ if constexpr new in C++17. Both are faked with creative use of macros. Will write about onboarding elsewhere.
There is a non-insignificant number of people who are currently using Firefox that would not be willing to move to a browser owned by Google. Most of these people don't realize how bad Firefox is for privacy and freedom these days. Killing off Firefox would cause these people to look for alternatives and having a significant user base looking for a good alternative would no doubt spark a lot of competition and innovation in a field that has been stagnating and regressing for better part of a decade. Firefox does not compete with Chrome, it is stuck to trying to recreate it, including everything bad about it. Even fucking lynx is a bigger competitor than Chrome since at least it's not just a carbon copy.
Cool! My understanding is that with the May 2019 Windows 10 Update console-based apps will be able to use VT sequences and a string-based, more POSIXy interface: [https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/](https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/)
Really, how often does that happen? I hanq around a dozens Freenode channels and never see any problem except the occasional spammer. I refuse to believe that Rust and Mozilla is so exceptional that it attracts idiots in mass. Banning someone from an IRC channel is easy and sufficient enough.
I am not an expert, but as I understand, real-time Linux or RTOS is about consistency not speed. (They are actually necessarily slower in average to guarantee consistency.) HFT is mostly about speed, consistency is important but not above speed.
To be able to run that, plus the rest of the apps a person might use? It will slow down a lot of computers.
No new hires had any prior experience with Rust. 2 had extensive C or C++ experience, 1 never had any.
Why not? Impl Debug +Iterator +... Works just fine
This is correct interpretation, sorry for confusion. Of course learning the codebase takes time, although it was greatly improved by pair programming and extensive code review.
This is very true. Basically all subsystem level design (ownership, etc) was done by 2 Rust veterans. I think another big factor is that learning Rust is greatly enhanced by having someone always available to ask as soon as you are stuck. This is very important. We emphasized that being stuck is normal, so don't try to solve anything for more than (say) 5 minutes, err on the side of overasking, etc. I think learners still underasked even after me repeating this over and over.
I'm always happy to see.a new episode. Thank you for doing what you do!
No one will ever write another rendering engine from scratch ever again. Even with all of Mozilla's might, Firefox is struggling to keep up. Kill it off and the web will be nothing but Chromium-based.
We use C++ for gRPC. C++ gRPC implementation is mature and first-rate. We have no plan to use Rust here.
Which ones? I'm in HFT in London and I got tired of C++ template hell. I once wrote a mini-compiler in DynAsm and I'm keen to try dynasm-rs, if I have a chance.
what's inclusive about a crappy chat protocol from the 90s whose only constant in it's ecosystem is how arcane and user-unfriendly it looks to outsiders ? how many non-white, non-male, not-the-usual-hacker-stereotype people have you met on IRC this decade ? discord running in a browser tab is literally the same thing than reddit, it's a service not an application. I don't see you up in arms about how terrible reddit is because it's not some overcomplicated federated ecosystem bullshit with 15 different unfinished clients
It pays very well. I got paid a lot more than any of my previous jobs, although that doesn't mean much, since I am more experienced. On the other hand, previous jobs included Samsung Electronics, Naver (#1 search engine in Korea winning over Google), and very profitable startup (they in fact paid more than both Samsung and Naver).
Webkit exists. And just because you use different browser doesn't mean the rendering engine couldn't be reused. Most of the "advancements" in this area over the past five or so years are mostly superficial anyways. Just because there isn't much incentive (and consequently interest) in writing new ones currently doesn't mean that there wouldn't be if Mozilla was killed.
All developers are Korean. I worked at Samsung Electronics and I think I know (very well) what you are referring to as culture, but I don't think it is East Asian in any sense. We have very frank design discussion and don't have that problem. We grew from a small team, all initial members didn't have that problem, and all new members were in part chosen not to have that problem.
We don't use any machine learning now although we hope to in the future.
I'm not quite a beginner but definitely not advanced. I'm writing a daemon which will be dealing with a large-ish amount of data and I'm trying to optimise for lower memory usage. Performance isn't a huge issue (handling only a few updates/sec) and there's a lot of duplication. Initially I was storing data in a format like `HashMap&lt;IpAddr, HashMap&lt;Ipv4Addr, MyData&gt;&gt;`. All up there are around 200mill instances of the `MyData` struct but only about 900k uniques. I spent some time changing it to `HashMap&lt;IpAddr, HashMap&lt;Ipv4Addr, Rc&lt;MyData&gt;&gt;&gt;` so I could do something like this: ```rust let store: HashSet&lt;Rc&lt;MyData&gt;&gt; = HashSet::new() let instance = Rc::clone(store.get(&amp;data)?); inner_hashmap.entry(addr).or_insert(instance); ``` I figured by using `Rc` I'd end up with a single instance of the data on the heap with multiple pointers. Memory usage is about the same though at run time. Have I misunderstood something obvious about how Rc works?
It's all or nothing though. With concrete types, they can conditionally implement some traits depending on their input types.
That sounds like super narrow case. Never happened to me, impl traits works just fine
&gt; Except nobody does that because having 10+ channels is *extremely nice*. You can just ignore those other 10+ channels if you just want a single conversation, and if anything it reduces the chance of you "popping in" being quickly drowned out by the next discussion. And as result, get notifications for every single message in every single channel, each loud and annoying, which needs to be fixed in well-hidden menus?
We don't make use of any C++ support for cbindgen. I don't understand the last question: cbindgen generates C header, so it is directly usable from C++. Maybe you are thinking of bindgen? We do make use of C++ support for bindgen and found it to be adequate. We enable_cxx_namespaces. We actually had to fix [a bug in bindgen](https://github.com/rust-lang/rust-bindgen/issues/1435), but isn't that a perk of hiring a compiler hacker who contributed to both Rust and Clang, aka me? :)
If Mozilla had actually worked with us IRC developers, we'd have been able to possibly help. There are modern, and useful clients. There are integration tools that allow changing history. Had mozilla and the rust teams worked with these projects, it'd have been easily possible to combine them into a hosted tool Mozilla could run, with nice web UI, requiring email verification to access, with mobile and web clients, accessibility, moderation tools, and all being open source. There has been zero communication from Mozilla on this.
&gt; And as result, get notifications for every single message in every single channel, each loud and annoying, which needs to be fixed in well-hidden menus? First of all, if you were using IRC instead this would *still happen*, and you would have not a single chance of muting it. Second, public servers should set their notification option to [only explicit mentions](https://i.imgur.com/vbSqdvc.png) which completely solves this problem.
We have confidence in our testing setup. (I could talk all day about it, but later.) Rust upgrade never caused any problem for us. At the end of the day, we upgrade because I have full technical authority to do so (so it's ME that should be very careful, and I am!) and I feel like it.
Yes i was thinking of `bindgen`, Thanks for the reply and sharing this awesome experiences with us.
Do you require a heuristic function to estimate who is winning from a board position? I thought alpha-beta pruning chess was intractable without one.
&gt; how many non-white, non-male, not-the-usual-hacker-stereotype people have you met on IRC this decade ? That's a stereotype that doesn't even apply to the people developing IRC software (many of the people in the IRCv3 working group are LGBT, women, and most are from outside the US) and doesn't necessarily apply to the users of IRC either.
I already mentioned bindgen and cbindgen, they are the largest item. Our first use of Rust to test the water was to load and save properties, for which we used serde and serde_json. We use std: std is very cool! A lot of extremely high quality code including collections. Everything else is custom and we don't use any other crates.
Servo has nothing to do with javascript, so V8 isn't part of the discussion. That being said... Servo was written from the ground up to use newer programming methods and to take advantage of new ideas that simply would be too costly to prototype in older engines. Gecko and Blink both have a crazy amount of what's called "technical debt", old code that runs well, but is complex and hard to change without breaking a ton of stuff. Thus, it's hard to test out new ideas in the browser without breaking things left and right. Servo fixes that by, well, being brand new. It's biggest advantage so far is being natively written to be multi-processes. Both Gecko and Blink have added multi-processor to their engines, but nowhere near the scaling of Servo. Servo will use as many cores as it can get for almost every step of the rendering process, meaning it's crazy fast. It's also light on resources. While Servo technically doesn't support all of the HTML spec that Gecko and Blink do, the last tests I saw put it at half the RAM usage of both. Add into that the easy ability to test out entirely new ways to do things due to it's clean, small codebase and it's easy to get excited. Take WebRender for example: using the GPU to render a webpage using the same driver paths/optimizations that 2D videogames use. It's a decently complex idea, and prototyping it on older engines would just make the devs want to scream in rage. Google, a giant company that employs very good developers, expressed interest in adding WebRender-like functionality to Chrome when they saw the work that Servo was doing, and here we are in the present day without so much as an alpha to that work.
[gtk-rs](https://gtk-rs.org/) is also alright for traditional widget applications.
I'm aware, that's not very useful now, though. (And for stuff like this you need a threshold of most popular clients supporting it so that the majority of users have a pleasant experience)
We've had team members be harassed off, and we've had constant spam on Mozilla's network. The rust project is pretty big, this kind of thing happens.
&gt; First of all, if you were using IRC instead this would *still happen*, and you would have not a single chance of muting it. So what's this? https://i.k8r.eu/1jls5A.png https://i.k8r.eu/0wVYUA.png Most importantly, with IRC and Slack, I can change my global default to "only with mentions", with Discord I have to do it each time, and have to manually mute every channel that doesn't interest me separately.
The \`MyData\` struct is about 36 bytes whereas I'd expect an \`Rc::clone(&amp;data)\` to be 8 bytes, so I was hoping to see \~75% reduction in memory usage by storing references.
We want to move away from Windows. It is a historical accident. (Long story I can't tell.) I really can't give latency number, but no, we are far from 2.5 μs. We know our tech is bad, but we aspire to be better. We also know our tech is not terrible, because 1. to state the obvious, it makes money, on the other hand it made money even when it was 10x (not an exaggeration) slower! So that's not much. 2. From postmortem analysis of data feed, we make educated guess of capability of other market participants, and as far as we can tell, we are not that bad, for particular markets we participate in, and for particular strategies we run, for now. Of course that can all change tomorrow if good players join. But then past performance is no guarantee of future results and in principle everything can change tomorrow by market's whim even if our tech is good.
I wrote about RTOS above. My amateur assessment is that RTOS is unsuitable for HFT. You are basically accusing me of lying... I thought I had standing and track record in this community. I mean, I got the flair. I earned it.
Mattermost is an other alternative
Not really. Having to list out all of the traits the types implement really complicates and obscures the type signature IMO.
I never had to use more than 3 traits in a row. In most cases if you list say 10 requirements you probably doing something wrong. Beside that, it's the only option to return futures from the functions.
noooo.. don't kill mozilla
But I thought that the formatter in vscode was provided by the RLS plugin. Am I wrong?
putting this setting makes the vscode formatting matches `cargo fmt`
I've just noticed that I have an old setting in vscode specifying 2 spaces for tab. But I've never seen `cargo fmt` changing all my files to 4 spaces before, is this new default value new in `rustfmt`?
I've just noticed that I have an old setting in vscode specifying 2 spaces for tab. But I've never seen `cargo fmt` changing all my files to 4 spaces before, is this new default value new in `rustfmt`?
\&gt; how many non-white, non-male, not-the-usual-hacker-stereotype people have you met on IRC this decade ? &amp;#x200B; i went to DALnet the other day and it's India
You set Arc&lt;Mutex&lt;T&gt;&gt; but trying to get just Mutex
Very well said! I agree 100%.
I'm not sure. I was in the same situation as you (using two spaces for tab) and then I found out about rustfmt and saw it used four spaces so I changed my VSCode settings. Not sure if it used to be two.
&gt; If someone posts a shit ton of racist screed on an IRC channel, do we have any way of deleting it? Nope. I think you mean "If someone posts criticism of a core team member, do we have any way of deleting it?". Because we've certainly seen you do that on Reddit and Discourse. I know this comment will be deleted too but [the Internet never really forgets](https://www.ceddit.com/r/rust/comments/bhrm7g/mozilla_irc_sunset_and_the_rust_channel/).
I'm giving my experience to answer the OP. They can make up their own mind. &gt; Beside that, it's the only option to return futures from the functions. As I said: &gt; But I won't use it in a public API **unless it's my only choice because it's too restrictive.** I don't understand what it is you're hoping to achieve.
Yes, I really look forward to it! It should also improve IDE support.
Show your code not your dogma
Thanks so much!
Rust's presence on IRC was the best thing to ever happen to IRC, to my belief in IRC and to my belief in human, decent, supportive communities.
Exactly. Manish was the one who decreed that "criticizing an individual isn't allowed" and therefore the community "couldn't be trusted" to express negative opinions about someone being appointed to the core team. The sea of "[removed]" on that infamous Reddit thread is his dream. So you can bet one of the main reasons to get rid of IRC is that it will make it easier for them to stuff critics down the memory hole.
Yes, the required trait `Game` has an associated `type Fitness: Ord + Copy`. For my chess bot I am mostly counting the remaining pieces, which is enough to have an elo of ~1700 on lichess and does not require much knowledge about chess.
The work that I got done on E-Nguyen was about as far as filtering / folding winit events up to abstract input events. Very quickly you get to event bubbling behavior being a thing. There's a lot that needs to be done for a raw Vulkan UI that is also relevant to working with Vulkan in general. It's not as simple as changing a css class. You need to change pipeline, push constants, spec constants, or an actual buffer to get an appearance to change. It feels like overkill for a UI, and it is, but this layer of control can likely be abstracted away. Sadly I decided I needed to switch to the lower level ash bindings, so it will be a while before the settings UI becomes something useful. I can't accept PR's until ash is used for rendering.
I might try that. I also have code to draw to an image face, and just draw the image, which may also be faster.
Even as a newbie to Rust (as well as operating system development), your articles are super easy to read and understand. Thank you for (I'm sure painstakingly) documenting this!
&gt; So what's this? https://i.k8r.eu/1jls5A.png A solution to a completely different problem. The comment I was replying to said two things: 1. You will now get notifications from 10 different channels instead of 1 2. Notifications are automatically complete loud push notifications. The first point is what I meant with "this would still happen in IRC" because in IRC all your messages would go into a single channel as mentioned above. (or they would not happen at all, a net negative). With Discord I can control notification settings on a per channel basis, and since discussions usually happen in the relevant 10+ channels, I have much finer granularity over what discussions I care about. &gt; Most importantly, with IRC and Slack, I can change my global default to "only with mentions", with Discord I have to do it each time And for the second point, they're not unless the server is misconfigured, which I have *never* had as a problem in my years of using Discord, no matter how many Discords I popped into for simple questions. And it's not a "well hidden" menu either. &gt; and have to manually mute every channel that doesn't interest me separately. ...compared to IRC which encourages putting every discussion in a single channel, which would be analogous to muting the entire server for Discord, which is trivial to do. And even then you can mute channel categories which still accounts for "but a lot of projects have a `#project` and a `#project-dev` channel." I agree a "mute all channels except this" would be cool especially for "pop in pop out" behavior, but when comparing IRC to Discord, *Discord still already wins without this.*
Have you tried yo use [`typenum`](https://github.com/paholg/typenum) and [`generic-array`](https://github.com/fizyk20/generic-array)? They are less powerful than true const generics and result in less convenient signatures, but otherwise work quite well.
I'm very glad to hear that! Let me know if you have any questions.
The "diversity" movement in open source tends to treat Asians as white or pretend they don't exist. The truth is too damaging to the narrative.
The overhead of the additional `HashSet` might be canceling out the memory savings of the deduplication. By default, `HashMap` and `HashSet` will overallocate so they don't have to reallocate on every insertion. Maybe check the capacity or call `.shrink_to_fit()` on each map/set and see how it affects your memory usage. This of course is a pessimization if you intend to continue adding elements.
As I remember, Skype started going to shit about when Microsoft bought it in 2011 (I doubt that's a coincidence). Before that, I found it pretty good (for the time).
&gt; qt I've developed Rust Qt Binding Generator. It's working great for me and gives me access to all Qt GUI elements. The downside: while you can write the logic of your app in Rust, the GUI bits are done in QML or C++.
Can you add a bit more context to your code example? It's currently rather difficult to reason about.
&gt; how many non-white, non-male, not-the-usual-hacker-stereotype people have you met on IRC this decade ? For starters, it's where I met most of the trans women I know... but I suppose we're something of a hacker stereotype too ;P Perhaps the Rust community should focus on active outreach to under-represented groups, rather than simply proclaiming how much better you are than those *other, non-inclusive* communities. From where I sit, you've been doing that for over a decade without achieving the stated goals.
Thank you Phil for this great series! Your articles are great inspiration for me and I learnt a lot from them.
It’s been four spaces forever.
Ok, I think my brain is good for the bin x)
They are equivalent when there’s only one bit of data. Imagine you’re matching on a tuple: (a, _, c) Vs (..) Does that make sense?
Don't forget about [https://github.com/makepad/makepad](https://github.com/makepad/makepad)
&gt; Then I think it may be possible to use `OsString::from_wide` This is the intended path for you to follow using the standard library. There is no way to get an `OsStr` from a `*const u16` (or `&amp;[u16]`) directly because the internal representation of `OsStr` (along with `OsString`, `PathBuf` and `Path`) is actually [WTF-8](https://simonsapin.github.io/wtf-8/) and not an arbitrary sequence of 16-bit code units. If you don't care about Windows paths that are invalid UTF-16, then you could just use [`String::from_utf16_lossy`](https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16_lossy) and then do whatever you want with the string.
Thanks! I'll consider my design and have a try right now.
There's the [smallvec](https://docs.rs/smallvec) crate which does exactly that.
Honestly, I think your comment is a really good description of why IRC is a bad fit for what Mozilla/Rust seem to want: to get close to the baseline functionality needed requires that users select the right clients (out of dozens of options...), and providers install custom integration tools which they have to combine with hosted software, and requires them to manage all of it themselves. Further, it isn't enough just to get a setup working, they'd have to continue to sink effort into it or the whole thing will "rot". None of this sounds cheap, easy for users, or easy to maintain.
I thought that XMPP scaled even better than Matrix (because based on TCP rather than HTTP), and had several modern [clients](https://salut-a-toi.org/) in development too ?
I think if you check back in a few months/year, then support for this use case might be considerably better. Today, crates tend to support either `no_std` with no alloc support, or the full standard library, and nothing in-between. This is because `no_std + alloc only` [was only recently stabilized](https://github.com/rust-lang/rust/pull/59675) (and won't hit stable Rust for another release cycle or two). Some crates might support the `no_std + alloc only` use case using nightly features, though, I'm not sure how many do.
If you can use a crate, [widestring](https://crates.io/crates/widestring/) has a `U16CStr` type that implements `Debug` and conversion to other types of strings.
Chromium uses Blink, which is a webkit fork. The ui bits of a browser are irrelevant in the fight for keeping the web an open platform, what's at the core of the issue is having multiple differents rendering engines implementing a *standard*, rather than having just one being the de-facto standard.
&gt; None of this sounds cheap, easy for users, or easy to maintain. Slack is even more expensive. &gt; to get close to the baseline functionality needed requires that users select the right clients (out of dozens of options...), and providers install custom integration tools which they have to combine with hosted software, and requires them to manage all of it themselves. We could have built an opinionated solution that provides all in one, if someone had at least talked with us :) And the real question is: Why should we IRC devs, often making no money, or in my case ~50€/month from this all, host this tech stack for Mozilla, a multi-million dollar company? The only reason Slack and Discord are able to provide this is because they subsidize it with paid subscriptions and VC money. If Mozilla would pay for the hosting, I’m sure we (devs of IRC clients and servers) could provide what they want in less than a year, easily. With all the features they want, while still keeping it entirely open and free software.
It is already possible tough, check out this link for more info.
Take a look at their front page. It has text like this: &gt; All-in-one voice and text chat for gamers &gt; Stop paying for TeamSpeak servers &gt; JOIN OVER 250 MILLION PLAYERS TODAY &gt; Sell your game Along with imagery associated with gaming culture. The sole audience is clearly gamers.
&gt;At this point I think the "Rust is soooo hard to learn" thing is way overblown. With NLL in particular, I've introduced people to rust and they've been up and running very quickly, with minimal help.
&gt; I really can't give latency number No surprise here; I've been glad to Carl Cook for his talk ever since he made it as it makes a useful point of reference without breaching NDAs :) &gt; We want to move away from Windows. Since you already your CI under Linux, it seems to me you are not that far from it, so I'll wish you luck in your endeavor.
As per my [previous comment](https://www.reddit.com/r/rust/comments/bhrm7g/mozilla_irc_sunset_and_the_rust_channel/elxb6al/), Discord doesn't seem to consider itself as a platform for anything but gaming. They don't seem to see that as a valid use case for their product. &gt; React moved to Discord because Slack had a room limit There are open source alternatives that do not impose such limits. Mattermost, an open source Slack alternative, does not impose any limit, so you're only limited by what your hardware can support. We have 1300 members in the general channel on our Pop!_OS Mattermost instance. &gt; Golang have quite a big community on Discord I find this humorous because Mattermost is an open source solution written entirely in Golang, so I would expect to see Golang using a solution written in... Golang, given that it exists and is widely used in the industry (incl. by the US Army and Social Security Administration).
&gt;Using these ingredients only, and now starting to write any kind of code, over time, you are absolutely certain to end-up with a nice plate of concurrency spaghetti! How often do you see people exclusively using `Mutex`? My experience using `Mutex` for concurrency is that it causes bugs (eg:re-entrancy causing deadlocks) frequently enough that I naturally get pushed towards channels (or other push-pull style concurrency) in medium-sized projects anyway,leaving `Mutex` only for the things I know can be done atomically.
❤️
And there are about 1250 people on the #rust IRC channel, at the moment of writing. I'm not sure what the point here is.
My only point is that a lot of people are already using the discord.
You want r/playrust
Sorry for the late reply but ddh is now on crates.io. I'll be making it usable as a library as well. https://crates.io/crates/ddh
r/linuxquestions
When doing embedded develop I found it very difficult to specify the return type functions that wrote. It's common to have complicated types for an output pin for a microcontroller. This allows the type can represent all of the features of the output. But, when you really just want an `OutputPin`, it can make the function signature _much_ more clear.
thanks!
&gt;Webkit exists Chromium's engine *is* a renamed WebKit.
My point was that most of my functions end up being methods returning futures, and methods are often refactored to trait methods, at which point I have to box the future up anyway.
&gt;What's the potato you're running the web based chat systems on? I had to use a 1GB dual core Pentium M laptop for a bit due to circumstances. It's not fun but it still runs the latest Firefox and most of the internet. Just not all at once. &gt; they'd have to rollback Firefox Quantum to not lock up my system. You should file bugs about that. I'm sure they'd be very interested to fix it.
I don't see why. You just need to recommend a client that supports it, for users who are new to the community. Hopefully one that's otherwise usable, as well. This is really not any different from pointing at Discord. People who still decide to use a different client, probably know what they're signing up for with that decision.
&gt; Most of the "advancements" in this area over the past five or so years are mostly superficial anyways. Yeah, I'm going to have to disagree with you on this one. &gt;Just because there isn't much incentive (and consequently interest) in writing new ones currently doesn't mean that there wouldn't be if Mozilla was killed. You realize that *even Microsoft* literally gave up on this a few months ago? Let's be very clear here: if Mozilla dies off the only thing you'll ever be using to browse the web will be a Chrome(ium) clone.
&gt; Even fucking lynx is a bigger competitor than Chrome since at least it's not just a carbon copy. Lynx doesn't render most of the internet and this is reflected in its userbase. This isn't a serious argument.
Awesome as always, looking forward to next part!
Threaded chat is actually on the roadmap for Matrix/Riot as well: https://github.com/vector-im/riot-web/issues/2349
Do you use protobuf? From what I heard it would be relatively slow for HFT applications?
The problem is, "don't open too many tabs" doesn't really work for me. Even with just a Rust toy project, I'm easily in the range of 50+ with open discussions, manual pages, example files and such. When I'm playing with Gtk it doubles because I need to have the original docs *and* the bindings docs. My solution these days is to run all the very JS heavy things in Vivaldi. That starts to stutter under load, but doesn't stop my whole system. Otherwise I have Firefox now pinned to a single core, and try to remember to restart it once or twice a day. I'm lucky in that most of my work happens in a terminal on remote servers, so browsing is the most resource intensive thing I do. If I had to do local development of a reasonably large Rust project, I'd probably think about getting a beefier machine. But not everyone has that option.
Do you have a finance background? How did you make the transition from typical software engineering roles into a quant finance kind of role? Or are you building the platform your quants use (rather than being a quant yourself)?
But a lot of people (more, even, despite the worse persistence characteristics) are also using IRC? Like, if anything, these numbers - flawed as user count numbers invariably are - support the original claim that many people don't want to deal with a proprietary system like Discord.
The claim was “many people won’t be willing to use discord.” That may be true, but clearly many are; in fact, in about a year, it’s almost the same size as the 10-year old IRC rooms.
&gt; I don't think use alone makes something trustworthy I know. And I am not saying that review alone makes something completely trustworthy. :) &gt; But my model of trust is much more complex than what crev provides. It seems to me that for some reason you have very... absolutist(?) view into using crev. Or rather you judge it like... if you use it you have to aim at relying solely on it, etc. and somehow change whatever you were doing before. In essence crev just let you publish your own code reviews and circulate them, so others can see what you looked at and what your opinion on it is. I just can't see a downside to it. And in recent releases the focus is on bringing in as many other metrics and methods of judging the crates as possible, to help any existing ways of people judging their dependencies. So at the minimum `crev` should be helpful even if you ignore the whole reviewing thing. &gt; I guess my argument boils down to this: crev's model of trust is both simultaneously too weak and too laborious. In a sense I agree: crev's trust model is meant to be used just as another line of defense. And it is too laborious, if the intention is to do it entirely on your own. That is why the actually intention is: use a wide WoT, get as many reviews from other people as possible and do only what you really have by youself. It is not perfect, but it should be much lower effort, while still providing some value.
Interesting. I take a glance at the code but is far different to this simple enum. But look like is for a different use case.?
If you've ever maintained a server, you'll be used to seeing in your process list things like: postgres: autovacuum launcher process postgres: stats collector process mosh-client -# host.example.net | 1.2.3.4 60001 ntpd: ntp engine It's quite nice, so I was a bit surprised not to find any existing crate interface. So, behold: use proctitle::set_title; set_title("hello, world"); On BSDs it'll set the process title via `setproctitle()`, on Linux it'll set the name of the current thread (so not identical in semantics, but as close as it seems possible to get safely), and on Windows it'll set the title of the current console, if there is one. OS X does have mechanisms for this, but they're undocumented and I don't have a machine to develop it on. Feel free to [have a bash](https://stackoverflow.com/questions/4217947/setting-process-name-on-mac-os-x-at-runtime) if you fancy. It is possible to get more process-global title changes on Linux by mangling the process environment, but doing this safely looks quite difficult - for example, lxc does it by reading `/proc/$$/stat`, parsing out the giant whack of numbers it spews out and using it to alter the VM maps. Also while I've covered most of the BSDs `cfg()`-wise, I've only tested it on FreeBSD. If anyone fancies testing on others, that would be nice.
Set dom.ipc.processCount to 1.
&gt; It's pretty valued, however we're not able to guarantee that the code of conduct will be upheld there, and have already tried hard to fix the problems. Yet as has already been criticized elsewhere, that 'trying hard' does not seem to have extended to engaging the community, or talking to the IRCd developers, or talking to the IRC protocol developers, or talking to developers of alternatives like Matrix, or... I don't know what has been tried exactly, but it certainly seems that nobody else outside of the core team has seen any of it. Which makes me feel like it wasn't tried particularly hard. &gt; many don't care about it being proprietary. The comments in pretty much *every single venue* where people are discussing this, seem to disagree. I'm not sure where you're getting that idea from. &gt; Sure, that's a problem. But you know what? The unofficial Discord isn't linked anywhere and it's grown close to the level of activity of #rust, if not more, in a pretty short time. The IRC community can manage. There will always be folks who prefer IRC (hell, I prefer IRC) and they will seek out that channel. That's a great way to kill the diversity in said community, by making its existence contingent on people actively seeking it out against the 'official' advice. I don't believe that this will lead to a healthy community, especially in the long term. &gt;Openness in our software is a nice to have. It's not something we value above all else. If people are getting harassed and in general people are being scared off a platform, that is a far bigger problem to us. "Openness" and "a pleasant environment" are not mutually exclusive. I don't know why people keep acting like they are. Not to mention that I don't consider openness a "nice to have" at all - it's a crucial ingredient for diversity and inclusiveness, which I hope we can agree is important. &gt; There's a comment from a Matrix project lead somewhere here that's promising for future prospects, but as it stands it's not good enough. Maybe later. What concerns me is that this was never even communicated to the Matrix team when it was "evaluated last year". I'm not sure how you'd expect them to build something that solves your issues, if you never communicate the issues in the first place. If this had been communicated at the time it was discovered, there's a good chance that we wouldn't be having this discussion at all, and the headline would be "We're moving to Matrix!" rather than effectively "We're shutting down IRC!".
Already done that, but I think Web Content processes, the UI process and maybe some others are still separated. Pinning to a single core fixed that and gives my system a bit more breathing room. A simple "I don't care about speed but I like low RAM usage" setting would be a godsend :)
&gt; We could have built an opinionated solution that provides all in one, if someone had at least talked with us :) Figuring out exactly what needs to be built is most of the problem :) The companies you mentioned have spent countless millions on R&amp;D over many years. It isn't fair, but I suspect that the unwritten requirements include things like "streamlined interface designed by a team of UX experts", "actively developed with a stream of new features", and "all clients regularly updated to support features as they are released". Yes, I'm sure Mozilla could spend a whole bunch of money making those happen but at that point it stops being a tool they use and starts to be a product they develop (and one facing a huge amount of well funded competition!) &gt; And the real question is: Why should we IRC devs, often making no money, or in my case ~50€/month from this all, host this tech stack for Mozilla, a multi-million dollar company? If you had to pick between software built by volunteers on a shoestring budget or by a well funded company with an O($100 million/year) budget, which would you choose? Is there even an organization you can mail a check to if you want a custom IRC solution?
&gt; Yet as has already been criticized elsewhere, that 'trying hard' does not seem to have extended to engaging the community, or talking to the IRCd developers, or talking to the IRC protocol developers, or talking to developers of alternatives like Matrix, or... Yes, we're looking for solutions, not looking to _build_ solutions. &gt; I don't know what has been tried exactly, but it certainly seems that nobody else outside of the core team has seen any of it. I wasn't on the core team when I tried to fix this. This was stuff I tried to do as part of the moderation team, and nearly burnt out because of it. &gt; The comments in pretty much every single venue where people are discussing this, seem to disagree. I'm not sure where you're getting that idea from. Sure, because most people who agree won't comment. In a blog post about shutting down IRC very few will come by and say "eh i didn't care anyway". The fact of the matter is a lot of people don't care that much, and that is evidenced by the vibrant communities _both_ discords have grown. For the people who care: Freenode exists. &gt; "Openness" and "a pleasant environment" are not mutually exclusive. I don't know why people keep acting like they are. They were in the options presented to us at the time when teams were evaluating options. &gt; What concerns me is that this was never even communicated to the Matrix team when it was "evaluated last year". I'm not sure how you'd expect them to build something that solves your issues, if you never communicate the issues in the first place. We don't expect them to build something, though. We were looking for solutions, we found things that worked, that was the end of it. We didn't have the time to coordinate with a bunch of other projects and hope that they would build what we needed, we wanted our teams to have something they could use and not have to deal with toxicity, spam, or harassment _now_, not some promise of a better tool in the future.
I was just experimenting with rust on a couple blue pills myself cause I had the exact same idea. I noticed you're the guy behind the blue pill quickstart repo. Thanks for your work on that.
Because [NonNull](https://doc.rust-lang.org/std/ptr/struct.NonNull.html) is `Copy` and `let a = n` does not move `n`.
&gt; The companies you mentioned have spent countless millions on R&amp;D over many years. It isn't fair, but I suspect that the unwritten requirements include things like "streamlined interface designed by a team of UX experts", It's worth noting here that in most organizations, the *vast majority* of this budget isn't actually spent on UX. Rather, it's spent on marketing and 'engagement optimization', euphemistically *called* UX. That is, it's spent on building the most addictive and revenue-generating design possible. If all you want is just good, user-friendly, accessible UX... then it's going to be *far, far* cheaper. &gt; Is there even an organization you can mail a check to if you want a custom IRC solution? Sure. Hire basically any contractor shop that works outside of web development and isn't tied to specific language, and you can probably have them build this.
That's hardly surprising, given that it's linked from the website as *the* community during a time where Rust is getting popular, and onboarding is comparatively easier. That frankly says more about the marketing and presentation, than about the willingness of the community to use proprietary platforms.
We did so for the IRC for those ten years.
Nice demo! The graphics are great. Thanks much for the info: greatly appreciated.
&gt; If you had to pick between software built by volunteers on a shoestring budget or by a well funded company with an O($100 million/year) budget, which would you choose? Is there even an organization you can mail a check to if you want a custom IRC solution? Not yet, but the IRC.com project is moving towards that, and providing exactly that — providing IRC software designed by a team of experts, on an actual budget :) And if you look at e.g. my own project run on a shoestring budget, you’ll see that UI/UX isn’t any worse than e.g. Slack: https://quasseldroid.info/ :)
&gt; Yes, we're looking for solutions, not looking to build solutions. Talking to developers of other systems isn't "building solutions", it's the bare minimum effort of conveying what your requirements are, and seeing if *they* want to build it for you. Which, judging from the response from the Matrix project lead elsewhere in this thread, they are indeed willing to do. If you'd only asked. Which you didn't. And that absolute lack of effort in outward communication and collaboration is what I take issue with here. &gt; re: ircd: see https://www.reddit.com/r/rust/comments/bhrm7g/mozilla_irc_sunset_and_the_rust_channel/elvuxap/ , a lot of the requirements are beyond what irc can provide. maybe ircv3, but even then a lot of the things there are just proposals, and getting some of this in most popular clients is a lot of work While I'm not convinced that IRC is a good option, the particular issues listed in *that* post have all been addressed quite well, and argued to be non-issues. And again, the problem here is that nobody even *bothered* to reach out to IRCd devs and investigate the possibilities. &gt; This was stuff I tried to do as part of the moderation team, and nearly burnt out because of it. The work of the mod team is largely invisible overall. This is a significant part of my complaint. Ask for help! The community is quite willing to help address these sort of issues, but they can't do so if nobody ever tells them that there's a problem. Keeping it quiet from the rest of the community is neither healthy for you as mods, nor for the community as a whole. &gt; Sure, because most people who agree won't comment. In a blog post about shutting down IRC very few will come by and say "eh i didn't care anyway". In my involvement with Archive Team, I've tracked *many* threads around services being shut down, and I can tell you that the amount of agreement around this shutdown is *astronomically* low, even taking into account that disagreeing voices are louder. Seriously, this is a negative signal from the community. Normally there's at least a decent handful of people who will defend a shutdown. &gt; For the people who care: Freenode exists. Which, as I've already pointed out, is going to lead to a significant lack of diversity if it only consists of people who specifically searched for it. &gt; They were in the options presented to us at the time when teams were evaluating options. Yet nobody reached out to see if it was possible to get both. &gt; We were looking for solutions, we found things that worked, that was the end of it. I don't agree that the current solution "works", in the slightest. There's significant pushback from the community - rightly so, as it's pushing the entire community into a walled-off venue that doesn't even allow custom clients - and the IRC community is *already* starting to fragment and fall apart. It might "work" for the mods, but it certainly doesn't seem to be working for anybody else in the community. &gt; I'm probably not going to respond further, this is getting increasingly in the weeds and it's very clear to me that you have much higher expectations about the amount of work the Rust project should put into this, which isn't something we're going to agree upon. The Rust project has been quite explicit about how much it values building a healthy community, and how that means putting a lot of work into it, and how the Rust project is focusing on that. I'm not sure what expectations you *thought* people would have, when presenting things that way. My expectations aren't even *much* higher; all I would've really expected here, would be some attempts at reaching out to third parties and the community, to see if it would be possible to pass off the work of building a workable open alternative to somebody else. I'm not expecting the mod team to build it themselves, or anything like that. And if reaching out to other people to maintain an open and healthy community is considered too much work, well, then I can only really say that I'm quite disappointed at the Rust project, and that the community (leadership) certainly isn't what I was led to believe it would be. If you don't want to respond any further, that's totally fine - I think the discussion has pretty much reached a stalemate anyway, and all my questions have pretty much been answered. But I do want to implore you to take the feedback from the (unusually constructive) community seriously, and see it as the early warning signal of something going wrong that it is. There seems to be a significant gap between the community and its leadership, and if that isn't addressed, that doesn't bode well for the future.
Agreed. Funny those butthurt sjws downvotes.
Unrelated to Rust (although awesome that you're using it in your work!): for someone interested in HFT strategies, are there any resources that you could recommend? Or is much of it taught in house and behind closed doors?
Your articles are always so interesting to read. I’m currently trying to learn Rust and C++ BUT am super into Operating System Development. Where did you learn all of these concepts which you write about? I hope to do the same but in C++.
pretty sure both have an `unwrap_or_else` method that takes a closure, but I'm not sure that would work with `unreachable` because of the expected return type
Unrelated thought: I never liked "pub(crate)", can't it just be "crate"? Or some other keyword like c#s "internal"?
You're right! Besides it appears the \`ConPTY\` has already been available since the October Update release and some 3rd party apps are already using it: [https://www.hanselman.com/blog/TerminusAndFluentTerminalAreTheStartOfAWorldOf3rdPartyOSSConsoleReplacementsForWindows.aspx](https://www.hanselman.com/blog/TerminusAndFluentTerminalAreTheStartOfAWorldOf3rdPartyOSSConsoleReplacementsForWindows.aspx)
Yes, but it seems existing `rustfmt` will not mess with merged imports, so `+nightly` can be used from time to time, and it will stick.
I think unreachable returns the never type, which unifies to type. So it should work!
&gt; My expectations aren't even much higher; all I would've really expected here, would be some attempts at reaching out to third parties and the community, to see if it would be possible to pass off the work of building a workable open alternative to somebody else. I'm not expecting the mod team to build it themselves, or anything like that. Remember, the choices to switch to Discord and Zulip weren't coordinated. This was individual teams making these choices. I keep having to repeat this. Yes, as a project if we were doing a coordinated move we should have reached out more, but it wasn't coordinated that way. It was teams experimenting. Many spent like a bunch of months on Gitter, even, before realizing it was too buggy. I think some other platforms were in use too, but I don't remember. This could have been done differently, but we very explicitly didn't want it to be a top-down decree (the pushback would have been ten times worse!). Rather, some teams that were experiencing problems started trying out new venues, liked them, and the word spread. Others tried yet other venues and disliked them. At the end of all this, almost everyone moved somewhere. Some teams were still on IRC, and we're working with them on where they should go (embedded wants to move to Discord, libs is still discussing it). The problems with Matrix that you say we never told Matrix -- those aren't the _project_'s problems with matrix, those are the objections from _one_ team member who wrote them down. A team member who had influence over the decision for one team, but not the whole project. There may be other objections out there, i don't know. There's still nothing stopping a team from moving to Matrix. In fact, given that some libs team members really liked IRC I suggested just that. If the Rust project ever decides to have a One True Chat Platform we'll definitely put more work into it. That's not the situation as it stands right now, currently teams are split across Discord, Zulip, some IRC, and some Telegram. The IRC teams may be moving to Discord, Zulip, official Freenode channels, or something new (I've suggested Matrix, and some people have suggested they wait until Mozilla picks its next platform and move there). Teams are free to decide to go elsewhere at any time. I think it's unreasonable to expect individual teams to do the legwork of working with chat software and getting it up to scratch. Expecting the _project_ to do this, maybe, but the project never made a decision here. The one top-down decision that's happened here is that the teamless #rust, #rust-beginners channels aren't going to exist in official IRC form anymore. And yeah, that's sad, but we don't have the time to get a replacement working _now_. But some of us are definitely interested in checking out Matrix and working with them (I've told them a bunch of times already that I'm happy to list any requirements I know). There's a chance that in the future we'll have an official Matrix server. There's also a chance that in the future the Freenode channels will be made official (that is, if my continued attempts to fix moderation succeed on this new channel). I can't guarantee either of these things, but I personally am going to keep pushing on them. So yeah, the situation is: - when teams switched to Discord and Zulip last year, it was a per-team decision that happened to coalesce on two platforms due to network effects. As it was largely organic there wasn't really an opportunity for the project to try and work with folks to fix it. There isn't really a team that owns the communications channel stuff either, it could be the community team but historically it hasn't been. - when we're switching _now_, we don't have the time to fix things (maybe whatever Mozilla picks will be good, and we can use that, but they haven't decided yet). However some of us at least are working to fix things in the future so that we may have open venues again. I hope that clears things up.
Wow, didn't know that was even possible! Negative points on me for not reading `unreachable` docs better, sorry :s. Thanks for the information!
No worries, that's what we're here for :)
He's referencing the fact that Electron (+ et al.) is reinventing the problems with accessibility that Flash had.
Yes, what you want is to declare a [feature](https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section)("gpu" probably") with specific dependencies.
The way they implement it makes accessing the elements of the SmallVec do no branching, because it stores a pointer which either points to its inline array, or to the heap. Branching does however happen when you go to add elements to the vec or ask it for its capacity, because it has to check if its pointer is pointing to its internal array or to a heap allocation. I'd say try out SmallVec, as long as you aren't doing lots of resizing, it should completely avoid the performance cost you're worried about.
Discord is also blocked in China, which prevents quite a few people in China from participating.
Something like that [dependencies] rand = "0.6.5" bincode = "1.1.3" ndarray-parallel = "0.9.0" serde = { version = "1.0.90", features = ["derive"] } gnuplot = "0.0.31" lazy_static = "1.3.0" # No-GPU [features.default] ndarray = { version = "0.12.1", features = ["serde-1"] } [features.gpu] ndarray = { version = "0.12.1", features = ["serde-1", "blas"] } blas-src = { version = "0.2", features = ["intel-mkl"] }
You can then build with either \`cargo build\` or \`cargo build --features gpu\`
Have no more than four compression actors?
Is there a disadvantage to using `unwrap` here? Is it about clarity? Or is the compile better able to optimize when using `unreachable`?
That was the idea, which you can see in [issue 50248](https://github.com/rust-lang/rust/issues/52048), but `crate` alone as a visibility modifier wasn't stabilized.
I'm not the person to ask - but for me it was about clarity. `unreachable` expresses my `foo.expect("unreachable")` in a more clear, language friendly manner. It also mentions that the compiler can optimize code in some cases, but that's not why I'm doing it. I also don't like having `expect()` in my code in cases that _aren't_ `unreachable`, so seeing `unreachable` instead of reading a hand message is also handy.
Feel free to contribute to keyberon then! And welcome, happy that the quickstart is useful.
How's the UX of those solutions?
Not sure if you're serious, but having to pay money will instantly make a large amount of users utterly uninterested in it, which isn't really acceptable. It also pulls in *yet another* external service.
Do you mean UI? The irc network hackint has implemented this, after registration with NickServ they send you a link that you need to open to confirm your email address and during attacks you also need to complete a captcha. The registration part is done over irc, the captcha is done in the browser.
But it's not just `pub(crate)`,it's also `pub(super)`/`pub(super::super)`/`pub(in module0)`. All of those have a use,and collapsing them down to a single (unparameterized) keyword would not be an improvement over the current situation.
I'm using it with Alacritty in Windows now! https://i.imgur.com/7MweQzv.png
Using expect or unwrap is idiomatic and should be interpreted as meaning the same thing as using unreachable! explicitly.
sorry, I'm a bit late, but you can simply do this: `let filename = if filename == "" { &amp;self.filename } else { filename };`. I think it'd be nicer to pass an `Option&lt;&amp;str&gt;` though; then you'd do `let filename = filename.unwrap_or(&amp;self.filename);`.
It's idiomatic, but with example and temporary code all over the internet using `unwrap()` or `expect()` it makes it hard to know what is unreachable, and what is accidentally left in. I like being able to check for `unwrap`'s and failing if there are any. Thoughts?
&gt; We did so for the IRC for those ten years. Sure, for most of which it was obscure. &gt; But again, the point is that saying “nobody will use the discord”, which is what this thread is about, is false. "Nobody will use the Discord" is not something that was claimed at any point. The exact claim was this: &gt; you won't find many of us willing to join and use a proprietary platform like Discord. Which, as far as I can tell, still holds given the above statistics.
Uhhh, can you even return unreachable at runtime? I mean in most type systems you can't instantiate the type for obvious reasons. And even if you could (and imagining it made sense), what would the compiler do to assure that it couldn't in the 'result'? tl;dr: isn't the 'unreachable' supposed to be expressed as a type during the construction of the Result instead, so that its 'new' can make sure that you never pass anything but the concrete value and not a error?
It's [just a macro](https://doc.rust-lang.org/src/core/macros.rs.html#492-505) wrapping `panic!()`.
Profile first, optimize after. `Vec&lt;T&gt;` already does not allocate for the case of zero elements, so you're really just 'optimizing' the case of 1 items, while pessimizing the case of 0 items.
What do you mean by "without dependencies", exactly? No external Rust crates? No external graphics stacks? No OS?
Only the OS.
What is "the OS" in this case?
&gt;Windows.
I (sadly) have the habit to edit my questions for several minutes after posting them because i figure out after writing them 'no this is stupid' and iteratively hone in what i really think is fucky.
Then you're going to need to do something like [this](https://docs.microsoft.com/en-us/windows/desktop/learnwin32/creating-a-window), except using [`WNDCLASSEXW`](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagwndclassexw) and [`RegisterClassExW`](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registerclassexw) if you want to set the color of your window to something that's not the default Windows background color. You'll have to manually translate all those structures and extern function signatures into Rust, though (or copy/paste the definitions from the [`winapi` crate](https://crates.io/crates/winapi).
If I weren't so bloody lazy I would try to experiment with a Rust OS on another platform than x86 (I hate x86 since I had to read the Intel Programmer's Manual). But sadly RISC-V isn't yet supported and doing anything completely without some sort of BIOS-services is a bit work overload as well :(
The "Embed Links" channel permission can be used to disable link previews. Even if that didn't exist, you could write a bot that immediately deletes any message that includes a link that isn't wrapped in `&lt;&gt;` (which disables the preview).
Alright, I'll have to use the windows API I guess, but it's fine. Thank you. I will use the windows API. And this isn't for any specific purpose, but just out of curiosity, how does one write something like the windows API?
\&gt; If all you want is just good, user-friendly, accessible UX... then it's going to be *far, far* cheaper. That's a good point. Though I wonder how inexpensive it can actually get. Far cheaper than $1 billion doesn't necessarily mean affordable... \&gt; Sure. Hire basically any contractor shop that works outside of web development and isn't tied to specific language, and you can probably have them build this. Haha, fair enough. Though if they don't have a bunch of other clients asking for similar designs I can't see this costing anywhere in the ballpark of what you'd pay just to sign up with Slack, and similar
While CBOR has no no_std-but-alloc support, it should be quite easy to add, and the developers are supportive if you send PRs from my experience. (Source: did first half of adding no_std support; alloc is just something I didn't have a use case for, but could be just another feature, with a separate gate and generally moving from std::{vec,...} alloc::*).
You don't really "write" an API - you write a graphics stack, or a widget toolkit, or a compositor, or any of the, like, five hundred other things the "Windows API" provides access to, and then you expose an interface for other applications to hook into.
Then how was the windows API made? What was the code involved? There has to be a way.
Perfect. That is just what I was looking for. Thank you!
Yeah. I ended up just modifying quick_protobuf to work. I completely screwed up writing support, but I only need writing on embedded targets anyways (although I'll probably hack it to work for everything later). Anyways, CBOR has a large overhead (encodes key names), which I don't want to deal with.
CoD is a political virtue signaling mechanism, nothing else. As you've already noticed, in fact it is meaningless and a collection of hypocrisy. Politics doesn't belong into technology. At all.
I was not aware of the Vec&lt;T&gt; and zero elements. \&gt; Profile first, optimize after Know how do that is another area, and is not as simple for folks like me that haven't worked on low level before, so I don't know how build a really useful case for my questions (and this is not the only one). &amp;#x200B; I'm not aware of resources about rust about how do it, but I'm interesting to know..
What you're really asking is "how was Windows itself made", and the answer is - by stacking abstractions on top of abstractions on top of abstractions. Right now we're on the "widget toolkit" level of abstraction - we have the concept of a button, and the concept of a text box and whatnot. If we peel back the abstraction layer a bit, we can see that all of those things are really just drawing pixels to the screen in response to input events. So how do we read input events and draw pixels? By going a step further down the rabbit hole, to the compositor level. The compositor is a program whose job is to route events from input devices to windows, and pixels from windows to output devices. How does it do that? Well, it does that by getting the events from input device drivers and sending the pixels to the graphics device drivers. How do the drivers work? Well, they take data from the device, translate it to some common format and send it over to applications, or receive data from the applications in some common format and then send it to the devices in a format that the device itself understands. How do the drivers communicate with devices? Well, there's usually a lower level driver that interacts with buses like USB or PCI-e to send and receive packets of data over the physical link. How does it do that? By talking to a special piece of hardware that's part of your CPU that actually implements the wiring needed for the bus to function. How does it communicate to that piece of hardware? Usually by writing to a special location in memory, or issuing special processor instructions. How does it do that? Well, the compiler... Basically, the rabbit hole goes very, very, very deep, and we've probably missed the exit to Wonderland and are now going straight to complexity hell. You just need to pick a level to stop at and stop there.
I hope you understood every comments, I felt like these were not very clear. Don't hesitate to ask if you need it.
I would like to choose the compositor level. I think it fits my needs, or at least from my understanding of it.
Simple question... how can I get started with Rustlings? I have VS Code, do I use that with Rustlings? I am on Windows.
I solved little similar problem, I have cache for http request and write to cache is blocking and tokio has limitted number of blocking threads, so I decide to limit run only one blocking task at the same time (not production ready code bunch of panic and println): ``` let cache = futures_locks::Mutex::new(cache) let (save_cache_tx, to_save_into_cache_rx) = futures::sync::mpsc::unbounded::&lt;Vec&lt;Data&gt;&gt;(); let fut = to_save_into_cache_rx .for_each(move |item: Vec&lt;Data&gt;| cache.lock().and_then(move |mut guard| { println!("get data {}", item.len()); let ret = tokio_threadpool::blocking(move || { println!("another thread"); guard.save(item) }); let save_ret = match ret { Ok(Async::Ready(x)) =&gt; x, Ok(Async::NotReady) =&gt; panic!("You already use all blocking threads"), Err(err) =&gt; panic!("the threadpool shut down: {:?}", err), }; println!("save_ret {:?}", save_ret); Ok(()) } )); tokio_executor.spawn(fut); ```
Then read the links I posted earlier - they tell you how to create a window and draw pixels into it. If you want to actually write your own compositor, that's not really a thing Windows lets you do - the best you can do is take over the entire screen if you're a DirectX application running in exclusive fullscreen mode, but even then the compositor will technically still be there, it'll just do its best to not get in the way of you rendering.
To do what you are asking for, you use the windows api. Since the windows api was not written in Rust, there are wrapper crates that simply define what the different api functions are. That's all they do. They don't add any further functionality other than define the api. Here is a popular one you can use: https://crates.io/crates/winapi At least that give you a list of apis that you can use. Otherwise if you don't even want to use that as a "dependency", then you're gonna have to open the code of that crate, and copy the part that defines the api you will be using. Based on your questioning, I can see you don't actually know the api you need to use. Most people here won't be able to help with that. You're gonna have to find someone's code for using windows api to draw a pixel in something like C++, and translate it into Rust. Understand that drawing a pixel involves a lot more than just drawing a pixel: You're going to have to create a new window, and set up events on the window, being able to redraw parts of the window when resized, etc. It will probably require about 5 to 10 api calls total.
&gt; 1. It seems tricky or impossible to define a recursive error type. If you basically try _source: Box&amp;lt;MyError&amp;gt;_, then you get an error saying it doesn't impl Borrow. I’ve used Snafu in one (small) project, and this was the only issue I ran into. Other than that, everything was very clean and ergonomic.
&gt; 5 to 10 api calls total Found the Linux user. (jk) (but not really)
I don't word my sentences well. Of course I knew the API I needed to use, I just needed to know if there was another option.
I have the following code let hazard_predicate = predicate::function(|x: &amp;String| { if (x == "You got it right!" || x == "You got it wrong!") { return true; } else { return false; } }); let mut cmd = Command::cargo_bin("rust-starter").expect("Calling binary failed"); cmd.arg("hazard").assert().stdout(hazard_predicate); It doesn't compile. It complains that hazard_predicate doesn't implement a particular trait. Here is the error message error[E0277]: the trait bound `predicates::function::FnPredicate&lt;[closure@core/tests/test_cli.rs:31:48: 37:6], std::string::String&gt;: assert_cmd::assert::IntoOutputPredicate&lt;_&gt;` is not satisfied --&gt; core/tests/test_cli.rs:39:32 | 39 | cmd.arg("hazard").assert().stdout(hazard_predicate); | ^^^^^^ the trait `assert_cmd::assert::IntoOutputPredicate&lt;_&gt;` is not implemented for `predicates::function::FnPredicate&lt;[closure@core/tests/test_cli.rs:31:48: 37:6], std::string::String&gt;` error: aborting due to previous error For more information about this error, try `rustc --explain E0277`. So How do I implement that trait for my predicate function?
It is exactly just simple enum, look at https://docs.rs/smallvec/0.6.9/src/smallvec/lib.rs.html#313 enum SmallVecData&lt;A: Array&gt; { Inline(ManuallyDrop&lt;A&gt;), Heap((*mut A::Item, usize)), }
If you don't know how to perform even the most basic profiling, how will you know whether your 'optimizations' actually improve things? I would strongly recommend that you create a simple yet working implement of your language first, and write some programs that you suspect might be considered 'representative'. Tten measure execution time. *Then* comes the time to evaluate execution times. Since your language is interpreted I strongly suspect that special-casing the case of 0 or 1 elements will make an unmeasurable difference next to the cost of interpreting. So just use Vec always.
I don't understand, how do you intend to draw a dot on a screen without using dependencies or APIs? Rust was built to be extremely dependent on libraries. Without dependencies, you can't even print a hello world message. (println! comes with the standard library, which you can disable if you want.) Why do you not want any dependencies?
Example code should try not to use unwrap in lieu of `?`. But I don't know what that has to do with what you do in actial code. There's no need to invent another way of expressing unreachable code. That's exactly what unwrap/expect are for.
Yes we use protobuf. gRPC and GUI client are for after-the-fact monitoring and online configuration and things like that. While they shouldn't be too slow, they are not on the critical path and have no real time requirement.
You can make a hello world message without dependencies: [https://os.phil-opp.com/minimal-rust-kernel/](https://os.phil-opp.com/minimal-rust-kernel/) Scroll down to the output. My reasoning for not using dependencies is because I personally think of it as using somebody else's code for personal benefit, and although even programming in Rust may be using somebody else's code at some point, I like to minimize the amount of dependencies I have.
`serde` has no_std support: https://serde.rs/no-std.html
In the case of Windows, you're going to either want to use `winapi` or, indeed, write your own operating system and "bypass" Windows. Not sure how much of a learning experience you're willing to undertake, but writing your own operating system to draw some pixels would be a pretty good (but hefty) one!
Yep, but the problem is finding a protocol that supports no_std. I'd prefer to use Protobufs (which is what I ended up doing) or something that already exists so I don't have to write my own protocol.
Thank you. That would be quite a learning experience indeed. I will try it out. I got past step 1 in the operating system tutorial, but I'm sure the next steps will get 10x harder for each one.
You can use bincode: https://github.com/TyOverby/bincode/blob/master/readme.md
I'm deleting this. Now I'm just getting a wave of downvotes.
Bincode doesn't support `no_std`, which is exactly my problem.
The example you posted here literally writes up a small operating system and interacts directly with the computer chipset. That code will *not* work in windows. If you want your code to run in windows, you will need to use dependencies or the windows Api. If you don't want your code to run in windows and instead want to direct interact with the computer chipset, then you will have to read into graphics memory. Based on your comments, I'm a bit confused why you are trying to do any of this in Rust.
I was aware of them and rejected them at the very beginning as overkill and not being exactly aligned to our needs. So no, not really tried. The thing is, you know what it should compile to, so writing macros to make it so is in a sense straightforward, conceptually if not actually. But then you need slightly different ad-hoc things and code starts to grow... Maybe I should revisit the decision, but current setup is not elegant but working and there is no pressing need to change.
This is for aarch64: https://github.com/rust-embedded/rust-raspi3-OS-tutorials
Thanks for this series. I'm sure it takes a lot of time and just wanted to say it is wonderful and much appreciated.
I have no financial background. (I guess I have now...) Before starting I didn't know what a derivative is. Other people did, although not all. Transition: my friend of &gt;10 years was the first on the team and asked me to join. Note: I don't consider it a transition. It IS software engineering, all the same. I have no idea how things "normally" work in the industry, this is my first time. I don't consider myself a quant: my primary work is not to come up with viable trading strategy, although I am encouraged to. I haven't so far. I don't think I am building the platform: we work very closely with trading strategy people, and the code isn't generic or modular enough to call it a platform. I think the best analogy is: I work on an engine part of a game using a bespoke in-house engine. My primary work isn't gameplay design, although if I can contribute as a gamer, that's great. The engine won't be useful for other games and is not for sale.
very cool! took a look at your code and you seem to have a really good understanding of rust. since I'm working on something similar, let me ask you a question :) [My project](https://github.com/andysalerno/reversi_rs) is to create a generic game-playing monte carlo tree search agent. Of course, this involves creating a tree. I did my best to create a generic 'tree' interface, since I wanted to test out different implementations of a tree (Rc nodes, Arc nodes, the "arena" strategy, etc). But it looks like your tree has a const root node and static nodes? I'm really confused about how that works. I thought anything with a static lifetime needs to already exist at compile time? How can you already know what nodes your tree needs at compile time? I'm just missing something to understand that.
I think you'll find that despite all the talk of inclusivity, Rust is a project mostly worked on by wealthy white people from California who might ultimately *want* to care about stuff like that, but simple *don't really.*
Have you checked out [tower-qos](https://github.com/tower-rs/tower/blob/tower-qos/tower-qos/src/lib.rs)? It's built with handling a dynamic number of requests to a service in mind. It might be worth having a look at to see how it is implemented.
Last I checked, Discord explicitly does not offer the right (documented) endpoints to implement a third-party client. If there *are* any, they, and anyone using them, are taking the risk that Discord won't decide they are technically an unauthorized bot, and ban them.
It made sense. Thank you for checking back. I got it working exactly as you described.
So the best case scenario I think is using either buffered or buffer_unordered - but tokio error messages can get very messy. The two things (in my experience) that make tokio error messages hard to deal with is the length of type names, and the way bad types carry through before getting printed as more complex errors later in the code. The first thing I’d recommend is taking complex closures and breaking them out into separate functions. Separate functions need to be explicitly typed, and form a hard barrier in the type inference algorithms of the compiler. Consider some code similar to foo(bar()). If bar is a separate function, then your error messages will be either “the return type of bar’s signature isn’t acceptable as an input type to foo” or “the return type of the code inside of bar isn’t the same as the return type in bar’s signature”. In either case, it is easy to narrow down which piece of code has the error. If bar was an in-line closure, then the error message would be “the return type of the code inside bar isn’t the same as the input type to foo”. When you add crazy amounts of generics, this form of error message can get really complicated, and you won’t know where your error is. The second piece of advice I could give, as a temporary debugging tool, is to create some trait objects in the middle of combinator chains. Again, the purpose of this is to separate “a.b(...)” into either “a was built wrong” or “you’re calling b wrong” rather than getting a big type error that reads as a combination of both. Another advantage is that trait objects have shorter type names in compiler error messages. I wouldn’t advise leaving the trait objects in if you can avoid it though, as they’ll hurt performance. Hope this helps, and good luck.
I really really can't answer this. Sorry. Okay, let's be incredibly vague and generic. You want to discover regularity in the market. It's not completely random. (It's not! You better believe it. Say it every morning. For inspiration.) If you can do better than random guess, even a tiny bit, and you can run it "high frequency", it's nearly no risk guaranteed profit. Law of large numbers means 51% edge is basically 99%. Practical note: if edge is too tiny, you won't earn your fees. Even with large edge, if volume is too low, profit won't recoup development cost. Regularities tend to weaken and disappear, so you have to take into account expected lifetime of regularity. If you overfit, you will find fake regularity; if you run it, you will be sorry. Don't deceive yourself. In principle, you can do all your research with Python and data feed archive. As far as I can tell, this is how things are actually done here! You just can't run it without capital, equipment, line, real-time data feed access, market access, license, risk management, escape valve, et cetera. So you won't get feedback on your guess, so you won't improve. As I understand, this is the reason you can't do it outside. Everything other than running and validating it can be done, even cheaply, at your home on your laptop.
Reddit actually has a public, documented API extensive enough to fully implement third-party clients (even, if you want, as a *static web page* doing everything in clientside Javascript!). Discord explicitly banned the use of userbots (whatever that meant) at some point, and does not currently have a documented public endpoint for reading channels if you're not using a bot account that has to be explicitly invited into the server by a moderator. So from that alone, I consider discord at *least* one step below reddit. As for IRC: In theory, the protocol could be extended, and if enough servers and clients agree on the extensions, it could literally do anything. From the sounds of it, such efforts are currently slow, but "from the 90s" seems about as relevant as it does to email and HTTP. "That hasn't evolved much since the 90s" could be a fair statement, but at least it acknowledges that IRC has the capability to improve over time if there is enough community demand and developer will.
Huh, that's different from what I did, I took what I thought to be the logical next step of `Parser`. `Parser` described in the article is made from `Fn(...) -&gt; ...`, and uses combinators to combine them and make them more complex. My `ParserMut` and `ParserOnce` use the same combinators as `Parser`, but with different bounds to to allow `FnMut(...) -&gt; ...` and `FnOnce(...) -&gt; ...`. I then had to basically duplicate the entire api (with some exceptions) to allow for the two new traits, which is where I extensively used macros to ease the monotony. You can use closures or functions to build the initial irreducible parts of the parser and then use the combinators to expand what they can do. This way the users never have to touch the `Parser*` traits. But this way did have some issues, with type inference (mostly because I didn't want `Parser`'s combinator functions to have different names from `ParserMut`/`ParserOnce`). One problem that came up when building up these large parsers is recursion. The way I solved it was by realizing that the size of the parser is exactly the same as the state captured by the irreducible closures. This means that with a new combinator (defer), I can convert my parser into a zero-sized parser and then `Box` it to get all the benefits of `Box`ing (indirection to allow recursion) without allocating a single byte. The defer combinator simply builds the parser every time it is called to be parsed, which should be very cheap. I thought that I could build a zero-allocation parser very cool. --- Your design looks very cool. I didn't think of integrating iterators into parsing, that is an interesting avenue to take! How do you handle backtracking on a failed parser? For example the if you wanted to implement the `either` combinator?
Lynx renders most of the web just fine. The world wide web isn't just the web n.0 javascript webapp shit. It's a serious argument in that "competition" that just tries to copy you 1:1 is not really competition at all. Even the very minimal user base of Lynx has a bigger impact.
Have you had a look at https://doc.rust-lang.org/book/ch11-01-writing-tests.html?
&gt;The ui bits of a browser are irrelevant in the fight for keeping the web an open platform The ui bits aren't what's spying on the user. The rendering engine is about as irrelevant as the ui bits are in this regard. EME isn't part of either rendering engine or ui bits and that's also both privacy and freedom issue. &gt;what's at the core of the issue is having multiple differents rendering engines implementing a standard You don't really need that many implementations as long as the standardization process works and has openness as the goal. Don't know about you but in my eyes W3C is a huge failure in pretty much every way.
You can check out this crate: https://github.com/devashishdxt/desse This gives zero-cost abstractions for binary serialization and deserialization and is almost 10x faster than bincode. This also supports no_std. P.S.: I’m the author.
Yeah, I was following that a little myself. I think I paused on step 1 or 2 as well, but I definitely want to go through it all at some point.
I also noticed this crate when checking out possibilities—unfortunately, the inability to store dynamically-sized types is a deal breaker for me. For my game, I need to be able to have a dynamic amount of levels and items per level. Thanks though!
Yeah. Support for dynamically sized types is still under development.
Our Pop Planet community has been attempting to organize some Rust developers for the development of Rust bindings to Mattermost and a GTK Rust client. https://gitlab.com/pop-planet
&gt;Chromium's engine is a renamed WebKit. Forked and renamed, but sure. &gt;The only new engine that was written in recent years was Servo (coincidentally written by Rust and Mozilla people) and you can try it out to see how well that works with the real internet. The rendering engine is pretty irrelevant to the actual use of the browser. As long as it's reasonably stable and complete that's fine. No amount of work in this area will ever fix the spying crap built into the browsers. You don't have to make your own rendering engine to make a new browser that is freedom and privacy respecting. &gt;Given what you said before about alternatives to Firefox I have to assume that's what you're actually using right now? I use multiple browsers. Tor-browser is somewhat decent alternative when it comes to privacy. Note that not all alternatives have to be complete rewrites.
&gt; You realize that even Microsoft literally gave up on this a few months ago? Their new Edge browsers will be Chrome reskins. Microsoft's users won't give a shit if it's Microsoft spying on them or if it's Google spying on them. Many of the Mozilla's users probably would if they realized the extent of it happening. &gt;Let's be very clear here: if Mozilla dies off the only thing you'll ever be using to browse the web will be a Chrome(ium) clone. Your speculation is about as valid as mine. There are alternative browsers besides Chrome and its clones and Firofox. I don't see why Mozilla dying would lead to the alternative browsers also dying instead of them gaining users that don't want to move to Chrome. If you think Chrome (and the clones) and Firefox are the only browsers out there then you're sorely mistaken.
I finally got around to going through this series. I had seen a lot of praise praise for this before, and so far I'd say it's all been warranted. Great for both Rust intermediates and people interested in Operating Systems.
Do you have any strategy for dealing with panics (for example: never call \`unwrap()\`)? Has the code ever panicked in production?
A very good question! No, we don't have a good solution. We deal by code review. We have been lucky so far. Luck probably will not continue.
I'm a bit confused, does your `ParserMut` trait not require `ParserOnce` the way `FnMut` requires `FnOnce`? Only my `ParserOnce` has the `map` trait method, the other two traits don't need it. `Map` then implements `Parser`/`ParserMut`/`ParserOnce` where `F: Fn`/`FnMut`/`FnOnce` respectively, and it al works out beautifully thanks to variance. ([Playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4a547aaf62f7283170c981831055621d)) It took me a bunch of tries to get to this design, but this was the clear winner. All other designs I've tried had insurmountable flaws, so I'm really curious to see how you came to a useful design. Generally, trait methods live on the "highest" parser trait that can implement it. So `map` is defined on `ParserOnce` and e.g. `many` is defined on `ParserMut`. As a result, most duplication is in the parser trait implementations of the parsers themselves, but so far it's really not that bad. Can you show me how `defer` works? Turning it into a zero-sized parser sounds amazing. Using the fact that `Box` doesn't allocate space for zero-sized values is very cool. I've solved the recursion problem by writing a procedural macro that takes the code that returns the parser and puts it in the `parse` method of a new parser, basically. So each time this "opaque" parser parser something, the underlying parser is generated and `parse` is called on it. I wasn't able to turn this into a combinator though. My `choice` combinator doesn't backtrack – if the first parser consumes input and fails, the entire parser fails. The `.attempt()` adapter restores the input stream to its initial value if parsing fails. I currently only support `&amp;str` and `&amp;[T]` as inputs and these are both `Copy`, so I don't have to clone anything. I'm not sure yet how I'll do this if I want to support arbitrary iterators as input. Also, holy shit, I just realized you're the author of the article that taught me how closures work in Rust. That's amazing, your article has been immensely helpful.
So I have a pretty good handle on the wild tokio error messages and it almost always comes down to having a bad type. I tried `buffer_unordered`, and the error wasn't long (I just assumed it was when I tried), I just couldn't understand what I was doing wrong. Intead of `tokio::spawn(f)` of the `fs::read` future, I instead `.map` and return the future instead. Then I can use `.buffer_unordered(4)` on that stream of futures. However when I pass the resulting future to `tokio::spawn`, I get: the trait bound `tokio::prelude::stream::BufferUnordered&lt;tokio::prelude::stream::MapErr&lt;tokio::prelude::stream::Map&lt;tokio::prelude::stream::Filter&lt;tokio::prelude::future::FlattenStream&lt;tokio_fs::ReadDirFuture&lt;P&gt;&gt;, [closure@src/compress.rs:32:25: 37:18 processing:_]&gt;, [closure@src/compress.rs:38:22: 69:18 staging_dir:_]&gt;, [closure@src/compress.rs:70:26: 76:18 in_dir2:_]&gt;&gt;: tokio::prelude::Future` is not satisfied --&gt; src/compress.rs:78:13 | 78 | tokio::spawn(t); | ^^^^^^^^^^^^ the trait `tokio::prelude::Future` is not implemented for `tokio::prelude::stream::BufferUnordered&lt;tokio::prelude::stream::MapErr&lt;tokio::prelude::stream::Map&lt;tokio::prelude::stream::Filter&lt;tokio::prelude::future::FlattenStream&lt;tokio_fs::ReadDirFuture&lt;P&gt;&gt;, [closure@src/compress.rs:32:25: 37:18 processing:_]&gt;, [closure@src/compress.rs:38:22: 69:18 staging_dir:_]&gt;, [closure@src/compress.rs:70:26: 76:18 in_dir2:_]&gt;&gt;` | = note: required by `tokio::spawn` Essentially it seems that `BufferUnordered` doesn't implement `tokio::prelude::Future`. [BufferUnordered](https://docs.rs/futures/0.1.26/futures/stream/struct.BufferUnordered.html) implements Stream and Sink like the other combinators, so I don't get why it's complaining here.
I'm using`mpsc` channels as values within structs which live for the length of the entire program, but the messages in the channels never stop: they're streams. I'm wondering if this is causing a memory leak. Do the `mpsc` channels remove the messages from their memory once they've been received by the Receivers?
I do that all the time in Emacs, but idk how to with VSCode
That is the case, RT is about hard deadlines, not necessarily speed. I work with the RT kernel for testing our missiles at work and if the IMU you're emulating runs at 600Hz, then you better be done in under 1.66ms, but you don't get any points for being done before then.
To whomever's interested, the actual core repo of "Evolution Island" seems to be [https://github.com/amethyst/evolution-island](https://github.com/amethyst/evolution-island)
My `ParseMut` does require `ParseOnce`, but I ran into some issues along the following lines [seen here in playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c68b79b12707f106205e927c016d364b) Basically there is a bug in the type-checker that prevents me from reusing the combinator methods directly in the way I have it set up. `defer` is basically a combinator that takes a closure that returns a `ParserOnce` (`Fn*() -&gt; impl ParserOnce&lt;...&gt;` depending on which type of `Parser*` is needed) and when asked to parse an `input` it calls the closure and forwards the `input` to the `ParserOnce`. Oh, you read my article, thanks for the praise! Ok, so thats how `choice` works, I took the easy route and just cloned the `input`. The `ParserOnce`'s parser once looks kind like this for me. trait ParseOnce&lt;Input&gt; { type Output; type Error; fn parse_once(self, input: Input) -&gt; (Input, Result&lt;Self::Output, Self::Error&gt;); // Combinators here } I chose this because it gave me the most flexibility when selecting the inputs, and when writing the parser. It made it much easier to find bugs than when I used a `&amp;mut Input` where I forgot to reset the input on a failed parse in one of my combinators.
Wow thanks for the resource. I should probably practice using the tests module.
If you have a large community, you could say that you have many people using a specific service, but that many could still only be a small fraction of the community that would have been a part of it if it were on an open source platform. About a thousand people seems pretty small to me for the Rust community. I consider Rust to have a much, much larger following than Pop!_OS. Few people, even within the Linux community, have heard of it. Yet we do have quite a lot of members that have personally registered on our private instance of Mattermost. The point was that, proportionally, the vast majority are likely to be unwilling to use a proprietary platform. In other words, only a minority of the community would be willing to use a proprietary service. In addition, not just Discord, specifically, but any proprietary platform. Developers are the least likely of any type of user to openly accept the idea of using a proprietary service, especially when open source alternatives exist. This holds especially true of most of the Linux-based developers/users, which seems to account for a sizeable portion of Rust's community. Windows-oriented developers may have a higher chance of willingness to partake in proprietary platforms, given that they are already using a proprietary platform; but Linux-oriented developers will range from disfavor and distrust, to outright refusal with every fiber of their being. It can be difficult to find Linux developers using any kind of proprietary service, if they can help it, myself included. They're often very privacy-minded and freedom-oriented. We get a lot of people asking about what sorts of data Pop!_OS collects (none) and what we're doing to prevent them from having their data collected. Many of them would refuse to a proprietary service to reach us, and we get a lot of compliments for using an open source service. Self-hosted open source solutions should be the goal. There's a bit of peace of mind knowing that the service you are hosting is unlikely to be storing everyone's password in plain text for the NSA (Facebook, Instagram, Yahoo, etc.). Or that the service is unlikely to abuse the user with arbitrary code, or collecting their data to sell off. When you partake of a proprietary platform, you have little to no say in the terms of usage, the code you must run on your system, what data is collected, or getting support for valid use cases. At least with an open platform that you can host yourself, you can decide your own rules.
I never said that "nobody will use discord", though :P
The company I work for uses Mattermost, and I really like it. It's similar to Slack, but open-source, self-hosted and free. It can be used directly in the browser, and is very customizable.
Thanks!
Ah, you're talking about [this bug](https://github.com/rust-lang/rust/issues/26085), right? It's indeed annoying. A workaround for `map` is to just remove any bounds that involve `F`, so in your case the `Map&lt;Self, F&gt;: ParseOnce` bound. For `many` this doesn't seem sufficient, so for now I have `many` and `many_mut`, but I'm hopeful this bug will be fixed at some point. When I try to implement `defer` the way you describe it, my parser still expands to a recursive type because `Defer` contains the type information of `F`, which contains the type information of the parser it returns. So it looks like I'm still missing something. How exactly does the `Box` come into play? &gt;It made it much easier to find bugs than when I used a `&amp;mut Input` where I forgot to reset the input on a failed parse in one of my combinators. I had the same issues at first, but this is exactly why combinators shouldn't reset the input, in my opinion. It's a lot of duplicated code and it makes them less predictable. With the `attempt` combinator that resets the input if parsing fails, and all other combinators not resetting the input, everything composes beautifully. You should consider it :)
Dear god, I love that I can start a Rust project and be productive and functional with very minimal boilerplate. Seeing how much this repo has, just as a repo template, spikes my anxiety. Who's this for? Who \*wants\* to have support multiple build toolings?
That looks like a Heroku VM. It doesn't work over HTTPS, though. I'm on my phone, do I can't look at the source code, but it probably shouldn't.
There will be people integrating Rust into existing multi-language projects, and for them experiments like this might be very useful. I agree with sentiment though. In many languages building is more of a problem than actually coding. :D
The Conan package package manager was just a fun experiment. But the real idea was to build a project with Cargo and Meson working side by side.
There's a typo in your README.
I didn't mean to be dismissive, it's more than I am ignorant. Is this for a case where you are orchestrating a multi-language build? With Meson calling Cargo or something?
I think I fixed it. You where probably talking about "meons" right?
Skype was decent when it first came out for similar reasons to discord - market saturation and simple use case. You used skype to make a camera call to another user. Now Skype is trying to replace the cell phone or something. Integrated contact lists and text messaging on top of screen sharing and camera calls and voice calls etc etc. They got greedy. Should have just been the de-facto camera caller on computers, people wouldn't have wanted to blow their brains out when management comes down and requires it for communications.
I was talking about ["Downloding"](https://i.imgur.com/iRDtJO5.png)
In writing up a more complete example for you, I found my issue. There was some bad logic in checking whether I already had an instance and so I was unnecessarily creating duplicates. &amp;#x200B; Thanks for taking a look!
My experiment is a multi language project where I use Cargo to do it's work. Conan as an alternative that performs the almost all the same functionality as Cargo but only when pared with Meson build system. I will build a crate that will be downloaded as an external dependency for this unique project. I am not sure if there are any crates using meson and please me correct if I am wrong.
You basically have two options, depending on where you want the network connection to be: 1. Run [GDB or a terminal frontend for it](https://softwarerecs.stackexchange.com/q/37633/49889) on the remote machine. 2. Run gdbserver on the remote machine and connect to it using any frontend which supports remote debugging. (I've never used VSCode, but I know [gdbgui](https://www.gdbgui.com/) supports remote debugging.) In the latter case, if you can *only* use SSH (eg. because of a firewall), then read the SSH manpage for instruction on how to tunnel ports through SSH. (ie. Your frontend connects to a localhost port that SSH is listening on and the remote SSH server connects to the gdbserver inside the firewall. Traffic for that connection then flows alongside your regular SSH session.)
Personally, I would handle it as if it was actually possible, using expect and writing the actual error saying what was missing just as if I thought it was going to happen...then document that it should never happen and why in a comment. &amp;#x200B; Why? Because code changes. What was an invariant before can change later on. Environments change, what was not possible before for platform reasons or technical reasons can suddenly become possible, especially when adding new platforms. Code contexts change, your code may never see this invariant ever, but your code may be used somewhere else. &amp;#x200B; With expect you can at least provide some diagnostic for the next programmer trying to figure things out and with the code comments you can at least let people know that you think this should never happen and why. It protects you from change and informs the next person who comes along later.
Sorry about that problem fixed.
&gt; Do the mpsc channels remove the messages from their memory once they've been received by the Receivers? Yes. You won't leak any memory if you're consuming all the messages you're sending. However, if you use an "asynchronous" channel (`mpsc::channel` as opposed to `mpsc::sync_channel`), it is possible to build up a backlog of messages that grows and grows, if you're producing them faster than you're consuming them.
Rust noob: what benefit do Zero Sized Types have here? Does it mean it takes up no memory?
Hey! I wrote [Postcard](https://github.com/jamesmunns/postcard) for exactly this use case! Let me know what you think.
You should get a spellchecker plugin for your text editor
/r/playrust
?
I don't think LLDB supports ssh directly, but you can configure ssh to forward debug port to the remote machine, after which you should be able to remote debug as usual.
&gt;Honestly, I think your comment is a really good description of why IRC is a bad fit for what Mozilla/Rust seem to want: to get close to the baseline functionality needed requires that users select the right clients (out of dozens of options...) Yeah, and perhaps we oughta just use Chrome (with various skins) for the web.
I think he meant the cost of getting new throwaway phone numbers to use for registration. But I also think they cost significantly less than $5.
That looks a lot better! Something along those lines would be much less redundant (and useful.)
You're in the wrong subreddit. /r/rust is for the programming language called Rust; /r/playrust is for the game called Rust.
I believe that crates.io is hosted on Heroku. It seems plausible that rls might self-check for updates or something.
The compiler might be able to handle that, but you could also use `std::ptr::copy` or `std::ptr::copy_nonoverlapping`; something like this: `std::ptr::copy(the_string.as_ptr(), the_buffer.as_mut_ptr(), the_string.len());`
You could run vscode remotely and connect to that. I've been using [https://github.com/cdr/code-server](https://github.com/cdr/code-server) for remote development. Might need to install the appropriate vscode plugins for debugging.
Building a Rust binary with no dependencies: rustc src/main.rs Building a shared library from Rust sources with no dependencies: rustc --crate-type=cdylib src/lib.rs This will give `liblib.so`, which is not ideal: probably better to pick a name: rustc -o libhello.so --crate-type=cdylib src/lib.rs It's only when dependent crates get involved that things get hairy. Assume I want to link my program against the `num` crate. I can build that crate using Cargo in the top-level directory and then say rustc --extern num=num-0.2.0/target/debug/libnum.rlib \ -L dependency=num-0.2.0/target/debug/deps/ \ src/main.rs Which is gross, and assumes I've successfully retrieved and built `num-0.2.0`. So…yeah. You can use another build system, but it's probably going to want to get Cargo involved ASAP for anything interesting.
Haha, awesome. Years ago I worked for a company called TuneWiki, our product was a similar thing: synced lyrics for your phone's music player or in Spotify.
Downloading creates, maybe? It shouldn't check for updates by itself.
 let mut buf = [0u8; 1000]; let s = "Hello World"; buf[0..s.len()].copy_from_slice(s.as_bytes());
I think it is AWS. As far as I remember, Heroku doesn't have their own servers, and uses AWS.
I can't think of many times you need to iterate yourself. In addition to the answers, you might also want to consider the `Read` and `Write` traits. ``` use std::io::Cursor; use std::io::Write; use std::io::copy; fn main() { let inp = "Hello world!".to\_string(); let mut read = Cursor::new(inp.as\_bytes()); let mut write = Cursor::new(vec!\[0\_u8; 40\]); let amount = copy(&amp;mut read, &amp;mut write).unwrap(); let out = write.into\_inner(); println!("amount {}", amount); } ```
There's also this crate [https://docs.rs/bytes/0.4.12/bytes/](https://docs.rs/bytes/0.4.12/bytes/) &amp;#x200B; Sometimes when working with byte buffers it's the thing.
IIRC all of these features were already there in 2011. I remember that I specifically started to use Skype for its screen sharing and group chat with history features - since it was so much better, than, say, Steam chat. This is also why when I researched an open solution for messaging and group chat, I picked XMPP - I expect a modern solution to have all of these features ! (At least in the protocol, if not in all clients...)
Thank you, it's great to hear that!
Thank you! I am only using this tree in constants during examples and [tests](https://github.com/lcnr/rubot/blob/master/src/tests/completed.rs): What you implemented as [`pub trait Node`](https://github.com/andysalerno/reversi_rs/blob/master/monte_carlo_tree/src/lib.rs) is actually more similar to my [`pub trait Game`](https://github.com/lcnr/rubot/blob/master/src/lib.rs#L103). As you mentioned, my Nodes only work in static environments or by leaking memory :) I am probably going to change them to use a `Vec`, which I am already doing while [fuzzing](https://github.com/lcnr/rubot/blob/master/fuzz/fuzz_targets/to_completion.rs) so this will remove some duplicate code, with the trade off that I can't use them in constants anymore.
Thanks! I'm currently working on the upcoming heap allocation post, but it will probably take some time.
Was there an update to the book? Or is it posted just like that?
`!` can be coerced to any type just to not force users to call `absurd` function each time unreachable happens in one of the branches.
it needs to download the crates to check whether your program compiles, so I'd say you're right
This is a great introduction to embedded Rust! Will the cc crate set CC and CFLAGS automatically when crosscompiling if there are none from the env?
Rls runs cargo
Thanks! I learned the theoretical foundations at university. For the practical parts, it was mostly reading resources like the OSDev wiki or the official manuals, and of course lots of experimenting.
Thanks a lot!
Thanks so much!
This is something I've been thinking about -- making suggestions based on [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) when rustup is given a component, target, or whatever which doesn't match any known ones.
That doesn't help. With targeted or general harassment, you want it to never reach the target by having a mod see it first and flag it. (visually, it's okay if the mechanics in the client is "you received a message, but the mods decided to delete that message). And yes, we have both to an amount where this is a constant work to the mods teams.
Someone in r/playrust might be able to help. This sub is for the rust programming language.
Mostly :) . So am I correct from reading your and Lehona\_'s responses that in cases where I would get the same result using `..` and `_` in match statements, that it is preferred to use `_`? And, if I see code bases using `..` over `_`, would it make sense to open pull requests to change them to `_`?
I think OP fears that people reading his/her code will think of the unwrap()s as sloppy error handling.
Not an infinite range here, but a placeholder for any amount of fields. For Ok this is unnecessary since a) it has only one field and b) this will never change. For other structs it can be helpful if there is a lot of fields, or you want to keep behavior unchanged if fields are added.
A simple then() call is possible the worst possible case for await/async syntax's relative performance, but still that's pretty awful...
Here are benchmarks: [https://www.reddit.com/r/rust/comments/bi9yzs/async\_is\_not\_zerocost/](https://www.reddit.com/r/rust/comments/bi9yzs/async_is_not_zerocost/)
You are using async/await, you should pay for the async/await runtime. What zero-cost is What you don't use, you don't pay for, **What you do use, you couldn't hand code any better.**
&gt;What you do use, you couldn't hand code any better. Actually there is a better solution for \`async fn ready\` and this is [https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.15/futures/future/fn.ready.html](https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.15/futures/future/fn.ready.html) with the same functionality and behaviour. But faster.
The benchmark compares the async/await version with the hand coded future, so I think his claim is valid - the hand coded version is 1.8 times faster.
Summarizing the various comments: - RLS (Rust Language Server) uses Cargo to obtain the dependencies of your project. - Cargo connects to `crates.io` to download said dependencies. If we look at what IPs `crates.io` resolves to using an online resolver, we get something like: No. Domain IP 1 ww.crates.io.herokudns.com 52.202.60.111 2 ww.crates.io.herokudns.com 52.203.53.176 3 ww.crates.io.herokudns.com 52.72.145.109 4 ww.crates.io.herokudns.com 52.22.145.207 5 ww.crates.io.herokudns.com 52.54.84.112 6 ww.crates.io.herokudns.com 34.226.180.131 7 ww.crates.io.herokudns.com 52.7.169.168 8 ww.crates.io.herokudns.com 34.206.36.121 As you can see, the IP you give is listed as No. 2 above.
Obvious question first, do you compile in Release? (I'd expect so, but just in case...) Next question: have you inspected the LLVM IR or assembly to pinpoint the difference between the two examples? Tight loops, in general, are very susceptible to optimizations, and it could very well be that the optimizer is tripping on a little detail which prevents it from optimizing one case as thoroughly as the other. Oh, and in any case, have you reported the issue to futures-rs? It sounds like something the authors would very much want to know about!
&gt;Obvious question first, do you compile in Release? (I'd expect so, but just in case...) Adding this profile helped a little bit: [profile.bench] opt-level = 3 debug = false lto = true debug-assertions = false Now futures are **\~1.2** times faster than my solution. Thanks for pointing this out! &gt;Next question: have you inspected the LLVM IR or assembly to pinpoint the difference between the two examples? No. I would be happy if someone does it for me =)
Nice! btw, there's [palaver](https://github.com/alecmocatta/palaver) which is an attempt at having one central place for all such cross-platform things, to avoid the proliferation of tiny crates :) Also, how about `setproctitle_fast`? (probably should be detected dynamically via dlopen) &gt; target_os = "hardenedbsd" I'm 99.99% sure HardenedBSD is *not* a separate target, just like TrueOS and GhostBSD aren't. They're all still "freebsd". And "dragonflybsd" might actually be "dragonfly", but I'm not *as* sure about that.
HTTP+JSON vs custom-XML-thing is not a big deal :) XMPP is faster because it just relays messages, it doesn't do as much as Matrix does — Matrix is a federated *replicated log* — every Matrix room is copied to all servers that have clients participating in the room. Matrix prioritizes high availability and mobile friendliness :)
The Electron wrapper is completely optional for Riot. Thankfully, it's just a web app that runs fine in a Firefox tab.
&gt; No. I would be happy if someone does it for me =) I'll pass this time; the last time I decided to peek at an optimization issue, I lost all my week-ends for a month =) If you report the issue on future-rs, I'd expect it to pick someone's curiosity and lead them to investigate.
Did you or someone from your team organize learning, using a structured plan/map of some kind or leave it unstructured? What is your definition of new-hire productive?
If your org is managing multiple prime broker relationships for margin and what-not, you may have fun writing or re-writing a margin optimization engine in Rust. OR problems can be rewarding nuts to crack.
&gt; It seems to me that for some reason you have very... absolutist(?) view into using crev. Or rather you judge it like... if you use it you have to aim at relying solely on it, etc. and somehow change whatever you were doing before. No. Let me explain more. Using `crev` is already a ton of work, even when it's distributed, because reviews become stale the moment a new version is released. If crev is supposed to help me trust stuff, but doesn't actually provide a reasonably complete picture of the inputs that go into trust, then that means crev is itself only part of the picture. Which means I have to use crev in addition to other stuff. I get that this is intended, but I basically would expect more value out of something that I (or others) would have to put so much work into before it became useful. &gt; And in recent releases the focus is on bringing in as many other metrics and methods of judging the crates as possible, to help any existing ways of people judging their dependencies. So at the minimum crev should be helpful even if you ignore the whole reviewing thing. That's great news. It certainly assuages some of my concerns. I guess one of my most pressing concerns remaining is docs. It seems to me like there really should be a more detailed user flow in the docs in order to grok how to use the tool. It might help to walk through crev usage in the context of normal crate operations.
Then leave a comment explaining why the unwrap is impossible.
That is my experience as well (only worked on RTOS in college, however). I work with kernel-bypass solutions (linux), one of the main selling point of this kind of stack is reduced latency. I was wondering whether rewriting DPDK in rust would be a good idea. Most rust projects are greenfield, meaning that allowing them right now the ability to switch to a pure userland stack might be better than introducing the concept in 10 years. Do you think this might be useful in HFT as well? I only work in networking and cloud infrastructure myself.
__This person is a pedophile. Judging by his post history his mental illness is untreated and he has no place here__
__This person is a pedophile. Judging by his post history his mental illness is untreated and he has no place here__
__This person is a pedophile. Judging by his post history his mental illness is untreated and he has no place here__
Zulip is a great alternative. They've gone a long way in the Zulip project using Python (Django).
&gt; I was wondering whether rewriting DPDK in Rust would be a good idea... Do you think this might be useful in HFT as well? This sounds very interesting. Yes, I think so.
It's unstructured. Being productive means landing code changes to the repository.
Oh oh oh... I don't think it's wise to discuss brokerage setup here... I heard we lucked our deal thanks to... I better stop there. Let's focus on Rust, or at least tech. Okay? :)
I’m not sure if there’s a strong convention.
For future reference, when pointing out typos it's prudent to actually say what they are. "A typo exists somewhere in a file" isnt very helpful.
Why use `[T; 0]`/`[T;1]` over `()`/`T`?
A lot of the overhead comes from the TLS usage in the current implementation, but the fact that accessing TLS takes some time and it inhibiting optimizations when you have many small layers of futures. &amp;#x200B; I have a POC implementation of \`async\`/\`await!\` that doesn't use TLS (mostly to show that we can definitely get something that works with \`no\_std\` even if generator resume arguments never come). Switching your implementation to use that significantly reduces the overhead in my testing (although in my benchmarks the \`async\`/\`await!\` implementation is \_waay\_ more slower than you show, probably because I'm testing on a MacBook Air). You could try applying this patch and seeing how it performs for you: [https://gist.github.com/Nemo157/df15a2afcddb35f79800b9706e4c8ab7](https://gist.github.com/Nemo157/df15a2afcddb35f79800b9706e4c8ab7)
I was thinking that this could be a security issue - can you make a room where all past users have to agree to be able to add a new user ?
Yeah, I have just expanded `future::map`, here is the code: ```rust pub async fn map&lt;Fut, U, F&gt;(future: Fut, f: F) -&gt; U where F: FnOnce(Fut::Output) -&gt; U, Fut: Future, { let future_result = await!(future); f(future_result) } ``` And expanded code: ```rust pub async fn map&lt;Fut, U, F&gt;(future: Fut, f: F) -&gt; U where F: FnOnce(Fut::Output) -&gt; U, Fut: Future, { let future_result = { let mut pinned = future; loop { if let ::std::task::Poll::Ready(x) = ::std::future::poll_with_tls_context(unsafe { ::std::pin::Pin::new_unchecked(&amp;mut pinned) }) { break x; } yield } }; f(future_result) } ``` Thanks for sharing!
Traversy Media on YouTube used some kind of plugin on VS Code to improve the formatting. He said it was Prettier, but Prettier only seems to support web languages. So I'm not sure if there's some similar extension Rust or I need to configure something. :\
Using pijul for a smaller personal project and I think it is really nice! A few rough edges here and there but I think it is very promising :)
I was on a phone, okay, and typing requires effort! I could have created an entire pull request to fix every typo I found if I have my PC. But without it, I can only notify the author with good will and reply to you with annoyance. How about you learn to be a bit more tolerant next time?
It was [posted on Hacker News](https://news.ycombinator.com/item?id=19766713) recently, so OP probably thought it's a good idea to post it here based on the number of upvotes on HN.
I benchmarked your ready\_embrio with embrio\_async::async\_block, here are results: &amp;#x200B; lto=false = [https://vanya.convertio.me/p/uBI1WWHEbhnBfyCLP6q0XQ/e28c7fbf572b694011b69786ce6c9dc6/futures\_ready\_embrio.png](https://vanya.convertio.me/p/uBI1WWHEbhnBfyCLP6q0XQ/e28c7fbf572b694011b69786ce6c9dc6/futures_ready_embrio.png) &amp;#x200B; lto=true = [https://vanya.convertio.me/p/3WsnMSR4k9bxUx\_6sVsh3Q/e28c7fbf572b694011b69786ce6c9dc6/futures\_ready\_embrio\_lto.png](https://vanya.convertio.me/p/3WsnMSR4k9bxUx_6sVsh3Q/e28c7fbf572b694011b69786ce6c9dc6/futures_ready_embrio_lto.png) &amp;#x200B; So without lto your solution is better than mine but worse than futures-rs, with lto your are far await from futures-rs or async solution.
&gt; btw, there's palaver which is an attempt at having one central place for all such cross-platform things, to avoid the proliferation of tiny crates :) Which ironically would add eight other dependencies to your program if all you wanted was a setproctitle(). &gt; Also, how about `setproctitle_fast`? (probably should be detected dynamically via dlopen) Not sure it's worth the effort/complexity. It's only about 3x faster in my tests, and it's already faster than prctl(). It's also about 3 orders of magnitude faster than SetConsoleTitleW(). Good call on the target_os's. There's also a `bitrig` target, though that project seems quite dead at this point.
Well that is the current state of things. I think that if the Crate's developers would just add Meson build scripts along side their existing Cargo.toml files that both Rust programmers using Cargo and or Meson build system should be able to link against the crate. That is the issue that will be resolved hopefully with some inspiration.
Your code is so long, even reddit can't handle it :) Use 4 spaces to indent code.
Pics from the comment:
I guess this is posted in the context of [Piping curl to s(hell)](https://0x46.net/thoughts/2019/04/27/piping-curl-to-shell/)? I find it really hard to care about this. Let's say Rust was delivered as a set of RPMs or debs. The procedure would be: - Developer blindly adds repository to system packager configuration - Developer blindly calls apt-get install rust - Developer blindly pays no attention to the packages actually being installed - Developer blindly pays no attention to the postinstall scripts executed in the process - Developer blindly pays no attention to the files that were actually touched on their disk - Developer blindly executes arbitrary code now installed as 'cargo' and 'rustc'. Compare to the status quo: - Developer blindly executes arbitrary code, but in one line If someone cares about what they're downloading, they will download and inspect it before executing it, this is true in either case. For everyone else, the approaches are equivalent from a security standpoint, but one is far more convenient
fixed
I think the best solution would be to make rustup available to all distros like in arch, or is there a specific reason why only rust stable is available but not rustup on may distros?
Is there a difference between downloading and running an unknown shell script versus an unknown executable?
Agree, it's not much different from distributing pip for Python.
[Alternative ways](https://forge.rust-lang.org/other-installation-methods.html) are already linked from the main site. My bet is that with popularity of programming there came lack of general knowledge of security issues and sysadmin basics. Even if someone uses an alternative method - are you sure one will check the .asc signature correctly, i.e. building and checking a WoT? With all that negativity towards GnuPG lately and its usability issues? I've seen people not checking SSH server's fingerprints or accepting an SSL exception to many times to believe that majority of the audience would benefit from more complicated methods. In practice \`curl | sh\` over SSL/TLS will be good enough with projects that should keep their sites safe (not pwned).
You're mixing up Korea and Japan.
Thanks as Rust is new to me.
I was checking that out too (thank you for adding no_std to the categories so it shows up on https://libs.rs)! However, I didn't see support for the Vec from alloc, only heapless.
&gt; margin tell me-- what does your firm's profitability have to do with Rust?
mainly that if you want to analyze the executable(beyond comparing it with a hash) they have to get a program to decompile it and it'll be harder to read
So we could probably add a note to only run the curl | sh command when the user knows what he is doing? There are tons of people out there who don‘t know that this imposes a security risk. And frankly if everybody is doing it nobody is going to change this.
Basically we should teach new users to inspect the scripts before running them if they don‘t know that the source is to be trusted.
I might be wrong about this, but I'm pretty sure it's that the shell script can be hijacked. In comparison, the alternative has everything be signed. However, it looks like they just changed it. I checked on [here](http://web.archive.org/web/20190420212844/https://rustup.rs/), which was April 20th, 8 days ago. curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh They're not piping into `sudo sh`, and now they're guaranteeing that it's using a good version of TLS. Maybe, I dunno if tls 1.2 has any vulnerabilities. Probably, because I think the most recent version is 1.3. So, it should be over TLS, and not be MitM'd. The biggest problem now is if the server was hacked, and the shell code was replaced with something malicious. &gt;If someone cares about what they're downloading, they will download and inspect it before executing it The most important part is that it's signed by the developer. Not just a hash from the server, but signed. A hash could also be replaced, so it really needs to be signed properly. Not entirely sure how to go about doing this, though. Really, it works better to have rustup be in all the repos, or maybe some form of install stub, so it can be allowed to update itself. Expecting people to inspect everything is dumb. Nobody's going to do it. That's why we sign things, so we can trust that the developer actually got their code to us. This shell code issue isn't about not trusting the dev, but the dev being hacked. Remember, Linux Mint, I think, got their server hacked and isos replaced, along with the hashes. If those were signed somehow, then they would be more obviously invalid. This is a similar worry, with the shell code. We trust the rustup devs, but they're not ensuring that the code they give us is their code. Sure, the connection is fine, but if their server is hacked, the files aren't guaranteed to be good ones.
I missed a step in the deb/RPM version :) - Developer blindly calls apt-key
What's the big alternative?
But this doesn't really solve anything. At the end of the day, they're still running third party code on their computer with all the risks that come with that. Inspecting the shell script didn't help in the slightest. To put it another way, should we ask users to read of the source code to rustc, std, cargo, and llvm as well? If not, how is this any different than reading the shell script?
Somebody can steal the signing keys too. At some point you just have to trust someone.
I am not a Rust developer, I am C# developer, so my answer maybe not accurate for Rust, but in C# we are not using async/await for CPU intensive workloads. Async/await is used in IO intensive workloads. For CPU intensive workloads we are using Parallelism. In your example your methods returns integer constant value which is no a IO operation. So I think you should not expect performance improvements.
Web Assembly Question? What's the correct way to pass an array of bytes from the host into a running wasm module? Right now I'm directly writing bytes to linear memory location `0 =&gt; bytes.len()` from the host, then doing this inside the wasm module: let input: &amp;[u8] = unsafe { slice::from_raw_parts(ptr as _, len as _) }; However, I worry that I'm writing to a location in linear memory that might be used for other things. I read somewhere that LLD leaves memory-space `[0...1024]` free so I think I'm OK, but this still feels really dirty. Note that I'm not using `wasm-bindgen`.
But is that _better_ than using a pattern specially designed for impossible scenarios? I can see the argument that `unreachable!()` is not better than `expect("helpful message")` _(though I'm not sure I agree even there)_, but certainly `unreachable!()` is a more clear language convention than `unwrap()` in this case, no? It seems unreachable is just objectively better than unwrap. You can use a comment on both, and it's a stdlib language pattern for this exact scenario. Thoughts? You seem to be pro-unwrap, so I'm trying to understand your thoughts here.
I don't see the difference. Also you might need to rustfmt the code.
That's a fair point. `unreachable!()` with a stack trace and comment at the code location would be more clear than a non-stack `expect()`, but that's unlikely to happen I imagine. Using `unreachable!()` in prod code would likely result in a stack-less panic, right? So an expect might be the only way to give more context. What would be best imo is perhaps an `unreachable!("reason")` macro to panic with a message. Bonus points if the panic message includes the file and code line, to help debug an impossibly-not-impossible scenario.
Rust fmt is what he probably used
&gt; But is that better than using a pattern specially designed for impossible scenarios? Sorry, but I feel like a broken record at this point. That's what `unwrap`/`expect` _are_. Proper use of them is specifically in cases where it should never fail. &gt; Thoughts? You seem to be pro-unwrap, so I'm trying to understand your thoughts here. You are arguing for an explicit change in idioms in an ecosystem that has been using `unwrap`/`expect` for years as a signal to indicate that absence (or an error) should never occur, and if one did, _then it would be a bug_. I see absolutely no reason to change that. I'm in favor of the status quo.
Yes, that one. It is very annoying. `Map&lt;Self, F&gt;: ParseOnce` is the bound that I have. I don't have any bounds related to `F`. &gt; When I try to implement defer the way you describe it, my parser still expands to a recursive type because Defer contains the type information of F, which contains the type information of the parser it returns. So it looks like I'm still missing something. How exactly does the Box come into play? This is by `Box`ing and then coercing the box into `Box&lt;dyn Parser&lt;...&gt;&gt;`. In the case of strings it was `Box&lt;dyn for&lt;'a&gt; Parser&lt;&amp;'a str, Output = ..., Error = ...&gt;&gt;`. This erases the type information though dynamic dispatch, and that allows recursion. But because `defer` will probably be zero-sized (unless you borrow across the closure you pass to `defer`), you will not allocate due to some guarentees in `Box`. There is another reason why I didn't use `&amp;mut Input`, that `fn(Input) -&gt; Input` is logically the same as `fn(&amp;mut Input)`, but you can't easily decompose the input in `fn(&amp;mut Input)` into it's constituent parts which means that here is strictly less types of parsers that you can write. Now for ease of use I did allow you to use `Fn*(&amp;mut Input)` if you don't need that level of control. But the core parser does pass through the input. Now, had I gone the other way around, and based by parser off of `Fn*(&amp;mut Input)` instead, I would not be able to safely provide an api for `Fn*(Input) -&gt; Input` without promoting panics to aborts. &gt; With the attempt combinator that resets the input if parsing fails, and all other combinators not resetting the input The attempt combinator does seem nice, I will look into it. I am also going to rework how reseting the input works, but making a new trait to handle that. That way resetting could be more efficient for `Clone` types and you can use `!Clone`types if you want to.
I've not used Futures much _yet_, but I was planning on using it in CPU-oriented workloads - or at least to bench it. I know it's not the overall goal, but I had wanted to bench heavy CPU workloads in a very IO realm. Specifically a web server doing a lot of IO work, _and_ a lot of CPU work. I was hoping to make the CPU workloads have breakpoints to allow the async runtime to job steal. While I'd love for the CPU workload to be parallelized, my main goal was to prevent the CPU workload from stealing a Async Thread for too long. So, I don't know if that will end up being viable, but I guess I just mean that there are times where CPU intensive workloads might be spread over Async. I know my goal was not strictly for performance gain, but still. Food for thought :)
The rendering of code blocks is different between "new reddit" and "old reddit". Yes, really.
Gotcha, sorry for being thick, and appreciate your thoughts on the matter. Thanks :)
I don't think that would be impossible to implement, but I honestly haven't heard of any systems that have such features
One more thing you could try is to liberally sprinkle `#[inline]` or `#[inline(always)]` on the small combinator functions.
&gt; it's already faster than prctl() hmm, I remember Postgres devs were specifically complaining about slow setproctitle on FreeBSD as compared to *Linux*. I guess they don't use prctl on Linux, but some direct access to the title string via a vDSO symbol?
If someone wants to dig into the assemly code: https://gist.github.com/cynecx/fed19ae9053eb6837a1b38228a7ddb47 cmd: `cargo rustc --release -- --emit=llvm-ir` (no lto) note: did some asm cleaning
For everyone's benefit: it's "*pique their curiosity".
Because it allow to uniformly take a slice without extra conversions. &amp;#x200B; This is for make vectorized operations on data alike [kdb+](http://www.timestored.com/kdb-guides/kdb-database-intro): let prices = [$100 $200 $20] * 10% let prices = $100 * 10% let prices = [] * 10% Make all like a array make this easy.
Not based on the votes but yes, I saw it on Hacker News first.
One strategy that worked for me was grabbing a book with a project in a language I know and then doing it in Rust. I got [Writing an Interpreter in Go](https://interpreterbook.com/) and I'm implementing the Monkey language in rust. It's a fun project, I'm learning something new, seeing it in a language I'm familiar with so I can comprehend the idea easily, and then actually doing it in Rust has proven quite interesting! It is so much more than just "translating" because good practices and data structures between languages can change so much, I have deviated from the book quite a lot.
Wow, looks great! How much is this library tested? I have been needing a good timer implementation for futures 0.3 for a long time, and after the library I tried to use segfaulted on me multiple times I decided to create a naive solution (ab)using the timeouts of `crossbeam`.
They [directly modify `**argv`](https://github.com/postgres/postgres/blob/97c39498e5ca9208d3de5a443a2282923619bf91/src/backend/utils/misc/ps_status.c#L56-L58) on Linux. Seems like bit of a dubious thing to be doing in Rust. Or just in general, really.
I only did basic tests in CI and more testing on my Windows machine. So I can only say that Windows implementation should be without troubles, but extensive testing on other OS would require someone to do it in real code :)
I fully agree. &amp;#x200B; I've had 'this can never happen' situations go south on me before. Parsers getting values that make no sense. Machines getting values while in states that should be unreachable (what do you mean you disabled the emergency stop button!), callbacks which ran when the system explicitly said it would never run them under those conditions... &amp;#x200B; Software has to interface with the real world and it has to interface with humans and other software that humans have built. I know you might have noticed this, humans are not known for building perfect things =-P
Well, systems (like IRC) where message history is not built-in (and mandatory) don't have the same issue, obviously...
I picked things that are well defined and try to implement them in Rust. There are networking protocols (or any other RFC), well known algorithms and stuff you already know by heart but maybe wrote in another language. And then there are tons of "are-we-\*-yet" for all possible topics and they list stuff that's still missing from the Rust ecosystem. Maybe try something from there?
I'm not sure how. Maybe I don't understand what you're talking about. &gt; all past users have to agree to be able to add a new user I read that as "when someone wants to join, there's a vote among current participants and the new user is only joined if everyone voted yes".
What does TLS expand to in this context: Thread Level Speculation or Thread Local Storage? I’m guessing it’s not Transport Layer Security.
Ah! Thanks :)
Do you have any other interests / specialties?
To be fair, I think the best way here would be to create a Rust Lib / Tool which actually generates the Meson Build Scripts based on a \`Cargo.toml\` file :) I - IMHO - think that 90% of Rust Crate Owner just won't care about Meson etc. at all, so the burden will always be on the side of the people who are in the situation of having to integrate a Rust Project with their existing Meson / C++ Setup. Such a tool would then help these people since they then no longer depend on - possible a hundred different - crate owners to provide Meson Build Scripts.
Thread Level Storage. Generators can't accept arguments for `resume`, but futures get passed a context when they're polled, so async await stores the context in TLS to pass it to the generator.
Woah! That's a pretty big difference! What is embrio doing to make async/await so much faster than the manual combinator?
Actually sounds nice. Thanks.
Well, considering that I'm sick and tired of making cruds and react apps, I want to challenge myself with something that I never tried, like writing a game or desktop application(god I hate electronjs) with something like rust. Just any kind of application that will be not standard(from point of view of a freelancer) and challenging. But the problem is that I lost all my imagination, and for the past 2 days I couldn't think of anything that's worth trying(like a desktop app to do what?)
This will be handy when I'll learn rust and try to get used to it. Thanks.
Oh, snap! I misread. Thanks for the input.
People with RES can add this CSS snippet to fix things: code { white-space: pre !important; display: inline-block; padding: 3px 5px 3px 5px !important; margin: 0 !important; } Reddit really is that lazy.
The best way is to join an existing project, so you also get mentoring.
I doubt I'm experienced enough in rust to do this, anyway would be glad to be a contributor for a crate, the development of which can help me learn Rust faster.
&gt;well defined Well in that case, I have horrible judgement on what to reimplement. I swear most of what I try ends up either missing most of the specs, or has had a defacto standard for too long that doesn't completely follow the spec. :P
This is great! I'm sure to start using this quite often.
This Week in Rust sometimes has "help needed" issues that are suitable for beginners. There's also https://www.rustaceans.org/findwork/. I'm also tempted to tell you about some projects I've been meaning to write for a long time now, but I shouldn't involve someone else when I can't really find the time or motivation to do them myself. They're also web-related, anyway.
I love it, especially when I want to try out smaller things without having to fire up a browser. &amp;#x200B; I'd love to have it execute my code using *cmd + return*. &amp;#x200B; p.s. the app icon is beyond terrifying: [https://i.imgur.com/iJDQokX.png](https://i.imgur.com/iJDQokX.png).
I mean I don't mind doing web on Rust, that'd be a completely new exp for me, but anyways thanks for the link
&gt;Yes, that one. It is very annoying. `Map&lt;Self, F&gt;: ParseOnce` is the bound that I have. I don't have any bounds related to `F`. That's exactly the bound that is causing `F` to only implement the `FnOnce` trait, because it only needs to implement `FnOnce` in order for `Map&lt;Self, F&gt;` to implement `ParserOnce`. Remove that bound and your code will compile. It's not ideal, because you want to ensure that the `map` method always returns a parser, but it's a decent temporary workaround until the bug is fixed. I don't think the trait object method will work for me, because almost all of my combinators take `self` and thus require `Self: Sized`. Although it may still be useful to make `Parser` object safe... Hmm. Do your combinators take `&amp;self`/`&amp;mut self` where possible? &gt;Now, had I gone the other way around, and based by parser off of `Fn*(&amp;mut Input)` instead, I would not be able to safely provide an api for `Fn*(Input) -&gt; Input` without promoting panics to aborts. True, but what does owning the input give you here? I can't really think of anything.
&gt;cargo rustc --release -- --emit=asm Where can I find that asm code in my target/ directory?
Personally, I agree that it should be more clear. `unwrap` and `expect` so terms to carry the connotation that there can be a programmer error. I believe that there should be a separate method for turning `Result&lt;T, !&gt;` into `T` and make it clear that it is a total function unlike `unwrap` and `expect`. I'm not sure if the compiler understands it yet, but you could try `let Ok(x) = x;` and have the compiler recognize it as an irrefutable pattern, but if that doesn't work, `unwrap_or_else(|x| x)`would work.
How to get runtime errors with [tui](https://github.com/fdehau/tui-rs) ? When the program panics and exit it seems to clear its output so I never get to see the panic message, how do you guys go around this?
Just in case you're interested, one is a file sharing server (to send files to friends / coworkers), and the other is a feed reader.
The file sharing stuff doesn't sound bad actually. I tried handling files over tcp on several languages, gotta read about it for rust lang.
It's [here](https://github.com/lnicola/rusty-share/), although the code is quite ugly, so perhaps it's not the best learning project (:.
The `mus` variable only exists inside the braces for that first if statement.
Is there a way to make it exist outside of it?
Wow, I see you wrote your own orm there. So I have one question, impl in rust is the same as class ~~that implements an interface~~ in java/c#/whatever c-family oop language?
In `target/release/deps/&lt;crate&gt;-&lt;hash&gt;.s`.
Is there an issue about removing TLS from the implementation of async await?
&gt; I think it is AWS. As far as I remember, Heroku doesn't have their own servers, and uses AWS. Now it all makes sense, a reverse dns lookup gave me an AWS server back, I was kind of freaking out a little.
There are some options. For example, if there is a sane default value for it, let mut mus = someDefaultValue; if music == "mpd" { mus = Command... } Another is to wrap it in an option type: let mus = if music == "mpd" { Some(Command ...) } else { None // note the lack of a ; }; // then later in the code if let Some(mus_) = mus { table.add_row...; } If you can, the best option is to refactor the code so that you only need to test `if music == "mpd"` once so that you don't have the variable set inside one if block and used in another.
I got only .text .file "futures\_async\_combinators.apjf5g5p-cgu.0" &amp;#x200B; .section ".note.GNU-stack","",@progbits
My firewall has a rule to allow outbound connections from `cargo`. Since there's no real `fork` call in Windows I assumed that was enough to cover scenarios like this one. Seems i was wrong
Actually I'm using diesel.rs, which is a very thin ORM. impl introduces the implementation of a struct. Traits are similar to interfaces, and structs are like classes (or rather C# structs). Check out https://doc.rust-lang.org/book/ to get started with the language.
Thank you for the detailed response. You actually helped with some other issues I had too.
I'll try removing the `Parser*` bound and see what happens. Owning the input doesn't get much for strings, but I don't want to limit the api that much. Also because closures can be trivially converted to a `Parser*` the users don't ever need to see this api. But it does allow the user to own the input if they want to.
I think the issue he's describing is that when talking in an IRC chat (that isn't publicly logged), you know exactly who will receive the messages, i.e. only the people currently in the channel. If the server provides history from before you joined, just about anyone can read it.
This is great! Not sure if it supports it yet _(I've not yet installed)_, but a nightmode would be huge. Especially since the playground as is only supports half-darkmode, it would be great if this supported it proper. Also love the Xi base! Planning on doing an extensive plugin for Xi myself, so it's cool to see this :)
&gt; WebIRC means you don't see the source IP anymore At least with unrealircd, you can [set trusted webirc clients](https://www.unrealircd.org/docs/WebIRC_Support) that may forward (spoof, actually) the user's IP.
Maybe I'll reconsider once I start allowing other inputs than `&amp;str` and `&amp;[T]` :) These two are so common that I'm optimizing for them first. And my main concern isn't really that the user would notice anything, but that it makes the library code noisier – so far `&amp;mut Input` has helped me prevent bugs, I feel like, because it composes so naturally (but only because my combinators don't ever have to restore the input).
Not until [this](https://github.com/rust-lang/rust/pull/60260) lands. Seriously though, you probably want /r/playrust.
What is that
I am new so I don’t know much
cmd + R will run the code. And heh, yea, the icon is definitely a placeholder, but I’ve said that before so we’ll see...
cmd + R will run the code. And heh, yea, the icon is definitely a placeholder, but I’ve said that before so we’ll see...
i32 uses 4 bytes of memory and i64 uses 8 bytes. It's faster in practice because you'll often be comparing values. If the two values you're comparing are similar in memory (E.g. all but the last byte are the same), the computer is spending more time comparing more bytes. This is true for any integer. i8 is "faster" than i16, i16 is "faster" than i32 and so on.
This works tolerably well with the system night mode.
Ah, and I was wondering why your post hardly received any points when I was browsing r/rust yesterday. This looks awesome, I'll consider contributing once I'm less busy.
Alternatively, teach Meson to run Cargo when needed. I think that's by far easier, and would allow Cargo to fetch the crates it needs. Reinventing Cargo as a Meson tool written in Rust sounds like a Sisyphean task.
This worked perfectly for me. Thanks a lot.
A lot of processing will be limited by bandwidth to RAM, and a i32 is half the size of an i64.
Do you have any evidence for that?
This is not the subreddit for the rust video game. This subreddit is about the Rust programming language. I recommend reading the sidebar before posting on any subreddit next time.
Well, I have no idea, perhaps you can try this: https://gist.github.com/cynecx/1df96f94dbf3116da5ce81d4cc1582cd
Sorry my bad
I may be totally mistaken but I thought that that is the feature of a more bit processor. Let's say I have an instruction. The instruction is processed for some constant time on fitting number bits. As if each bit was processed in parallel circuitry. So on 32 bit processor the instruction will take the same time for 32 bit number as for 64 bit number on 64 bit processor. Please correct the terminology as I am not very hardware aware.
Question regarding memory freeing: Let's say I'm implementing some trait for `Vec&lt;T&gt;` fn someFunc(&amp;mut self, ....) { *self = vec![]; } Why does this compile? What happens to the memory referenced by whatever was previously in self?
That doesn't make any sense. Any integer up to the machine word size is going to be loaded into a single register and compared in a single instruction.
Also all normal CPUs have a small cache build in to reduce the latency of asking the memory (ram) for some data, because the response time of those is a few CPU cycles where it can't continue calculations. Because of the limited cache size if you store 32 bit numbers double the amount can be accessed fast. So if you have Arrays / Vecs of ints you need to process more than once for example 32 bit numbers can give a speedup. Maybe there are also some pipeline optimizations of your processor but I never experimented with that.
I'd love to help port this to Windows and Linux. Just this weekend I found myself with spotty internet and a desire for a local-only playground to try some snippets, but I'm primarily a Windows user with some Linux experience. The core code and the Xi-based elements should be shareable between frontends, yeah?
&gt; the computer is spending more time comparing more bytes. I don't think it is though??
Looking forward to it!
The stuff that happens in the registers often isn't the bottleneck. It has more to do with caches getting full, and having to turn to progressively much slower storage until RAM (and in a whole system, perhaps to storage thereafter). When the data is doubled in size, you can exhaust your caches more quickly.. and the same happens with code (instructions stored in cache, the consequences of branch mispredictions, etc.). However, it can be more complicated too. It's often helpful to be able to move around 64-bits at a time (e.g. two 32-bit values at a time) even when you don't benefit from the ability to calculate larger values. In theory, some things ought to be faster with 32-bit code, and some with 64-bit.
Not all Futures use TLS, but the Waker API encourage that
I thought the playground's main purpose is to try out Rust **without** having to install anything, and to share code snippets on websites like Reddit.
TBH I was really passionate when I first read mhoye's post but after going through lots of comments and posts elsewhere I understand the effort. I have to thank you for explaining it in more detail :)
First of all thanks for benchmarking those things! That's incredibly helpful to see if someone missed something. I think as already pointed out the benchmarks are not perfect yet due to optimization, but it's a good starting point. /u/Nemo157 already pointed out that some of the performance differences are due to required TLS. I have figured out that some additional overhead is also that the composition of async functions leads to generated `Future` objects which are bigger than necessary, and probably a lot bigger than what a hand-written `Future` in the form of a state-machine might require. [Issues like this](https://github.com/rust-lang-nursery/futures-rs/issues/1473) or [this](https://github.com/rust-lang/rust/issues/59087) demonstrate that. The additional overhead can in some situations be an exponential growth - which is really a huge problem. On the positive side there is some work underway to improve that situation. I think we would need to wait until that one has landed in order to reevaluate how much zero-cost async/await actually is.
If I'm not mistaken, an executor is not required to poll a future unless it triggers a wake, and there's no guarantee that the waker passed in the first time is still valid on subsequent calls.
&gt; DataFusion uses around 100x less memory than Apache Spark for these benchmarks (80 MB for DataFusion and 8 GB for Apache Spark). Goodness; that's a lot!
@ /u/Nemo157: That expansion also moves the Future. Do you think that's another source of future sizes growing? Or is it expected to get optimized away. I think in total there are tons of those things in futures-rs for scoping purposes. And if these things can't get optimized then certainly another good strategy needs to be found to avoid the overhead.
The question is where do you put the waker?
Seeing as I already have Rust and frequently use the playground, I treat it more as a REPL. Sure, I could make a file locally and run it with cargo run, but then I've got a file in my repo. Perhaps the best solution would be to write a plugin for my editor that could take a snippet of code, write it to a temp file, run it and print out the output.... but.. it seems easier _(in my specific editor/case)_ just to use the playground.
That's impressive indeed. It's also means we can a lot data analysis task in 1 server. I'm looking forward for this project.
If you're doing a lot of SIMD, 32-bit might also help there since you can fit more values in.
In another there was a mention of a server with more than 1.3k users, https://www.reddit.com/r/rust/comments/bhrm7g/mozilla_irc_sunset_and_the_rust_channel/elyk9p5/ by /u/mmstick
While this isn’t a good way to talk about “speed”, yes 64 but operations actually are slower, for the most part (on Sandy Bridge): * ADD &amp; SUB: Same instruction for both 32 &amp; 64 * MUL: 3 instructions for both 32 &amp; 64 bit operands * DIV: 30-94 instructions for 64 bit, 20-28 instructions for 32 bit. Reference: https://www.agner.org/optimize/instruction_tables.pdf Of course, number of instructions to complete an operation is probably the worst way to talk about performance, but there’s some evidence for you...
yeah… that was kind of an odd way to say it. I know about that "issue" and I honestly don't care. Having history is the norm in all other chat systems. I hate unlogged channels.
aligned u64 access is as fast as u32 access on 64 bit systems (This is because of the CPU always fetching 64 bytes from cache/ram) on 32 bit systems loading 64 bit numbers is half as fast - on x86 in particular you can only fit 2 32 bit numbers in the registers which means that it has to frequently use RAM/Cache Arithmetic is a very different story. Depending on the architecture the time it takes may be the same (64 bit machines), it might be half as fast (32 bit machines supporting 64 bit arithmetic) or it may be emulated in code (very slow) If you add optimizations into the mix things can look very different once again, some new instructions only support 64 bit operands or you might be able to run more loop iterations at once if it's using 32 bit datatypes.
&gt;I have figured out that some additional overhead is also that the composition of async functions leads to generated Future objects which are bigger than necessary &amp;#x200B; I started implementing benchmarks and I came to the same conclusion, so I benched **ready** and saw than async fn added unexpected overhead. So it's a start point to optimizations. I will dig into how composition and await! macro affect performance.
It's not constructive once again... I told you that if examples didn't fit you, you could provide more information about what you'd want or even add them yourself and therefore contribute to a nice project but instead you're just being aggressive. I'll just stop commenting on this thread.
Is your issue with Rust (compiler/stdlin), or with crates?
Yea, this is designed with the idea that it might be ported to additional platforms. The implementation is pretty hacky atm, and I’d want to clean the API up before really encouraging anyone to develop against it, but this should definitely be possible.
&gt; saying “nobody will use the discord” You are misrepresenting what has been said, and the difference between someone saying "a lot of people do not want to use" and "nobody wants to use" is not trivial here.
As always, you have to ask the question "faster for what purpose / by what measure?" Then, the only way to know the answer, is to measure. Measure, measure, measure. There are tons of reasons why one might be faster than another, in different situations. There are no shortcuts -- you just have to measure.
&gt; non-male Hello, female user here, please don't speak for me.
No need for the About page, they will be made aware of this thread. (Hi, various.)
Thanks!
Your example essentially boils down to this: let mut some_vec = vec![1, 2, 3]; some_vec = vec![]; The previous vector is dropped/freed, because it no longer has an owner. It's allowed because you can modify the object with a `&amp;mut self` reference, which includes assignment.
That did it, thanks.
I suspect fetching from memory is where the bottleneck is, not performing computations. And on a 64-bit system, which is a pretty safe bet for most systems, everything is already done in 64-bit blocks. PBut I'm also no expert!
There are no limitations to the number of people in a channel in Mattermost. You're only limited by what your hardware can support. Considering Mattermost is written in Go, you'll get reasonable performance out of your hardware. We have ~800 people in Redox OS's Mattermost instance, and over 1300 people in Pop!_OS's Mattermost instance. Feel free to join chat.pop-os.org to see it in action.
The memory is freed as the destructor is run on the old instance. I believe it happens in this order: * the expression on the right side of `=` is evaluated and stored in a temporary; this is done now so `self` (the mutable reference) is still valid in case of a panic * the value in the temporary is swapped with the one behind the reference so that `self` is left in a valid state if the destructor panics * the `Drop` impl of the type is run on the temporary which now contains the old value, cleaning up any allocations or handles that instance is responsible for This is safe specifically *because* Rust has no copy constructors (no user code is run between step 2 and 3) so the value behind the reference is never left in an invalid state in case of a panic.
Ok, that makes sense. I think I'm going to stick with restoring the input inside the combinators because I've already got it working, but if I had to start over I would definitely use a reset combinator.
We haven't had any lag on our instance with 1300 members. It's also not required to use the Electron client -- I have two Mattermost instances in two tabs in Firefox.
Sorry if this rude, but you should try to ask coding questions like these on Stack Overflow if you haven't already. There are people who will answer these questions probably within a day or so. I cannot provide any help since I am a complete beginner.
Wrong subreddit
You mean [these](https://github.com/rust-lang/rustlings)? There's instructions for Windows on that very page.
Sorry, I need to update my post. I was confused about instructions written in those pages.
What exactly were you confused about? Please be more specific.
I am confused about where it says "clone the repository, checkout to the latest tag". How do i do this?
It gives you the exact commands to run right under that line - you just need to have Git and Rust installed on your system, and then run those commands in Command Prompt.
Ok thanks, I'll edit my post to say that I need to have Git and Rust installed. But then the question is, how should I install Git?
To my knowledge, an entire cache line is always read from memory which means reading and i32 or and i64 doesn't really make any difference in terms of memory bandwidth
r/playrust
[Here](https://git-scm.com/download/win) - it's the official download page for the official Windows version of Git. To make things easier for you, make sure the "add to PATH" option is enabled when you install it - I believe it should be by default, but it's been a while since I used Git on Windows.
Presumably that i32 or i64 will have other data nearby that you also need (adjacent struct fields or array elements, etc.) and the i32 leaves more room in the cache line for the other stuff.
Should I do git for bash only or git from the command line and also for thrid party services?
True but if that's the reason wouldn't i8 be even faster :) Wouldn't it be more correct to say that i32 is always faster on 32bit system but on 64bit systems they are the same speed. However due to it size the number of fields in each cache line is less which might impact performance
Bandwidth and latency are a different issue. Sure, the cache line latency is constant but if 32 bit variable suffices, it will result in better bandwidth utilization than wasting half of the bandwidth to transferring zeros.
Normally: in an Arc. If you don't have alloc, I've been putting them in the same array as the Future objects themselves. The library has an AtomicWaker to make it easier for implementers of futures to trigger the wake-up.
Git from the command line is what you want. Don't install any of the third party tools, you don't need them right now.
I just updated the post with more info about memory usage, and with new benchmarks with Spark memory constrained to 1 through 8 GB.
Here's a playground that shows i64s being slower. This is a simple benchmark, results may vary on your computer, yaddi, yaddi, yadda. https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=af5795f195c95201c704935d92cc22a7
That might be true on an embedded CPU perhaps. Any x86/x64 CPU (that i can think of) since at least a decade will fetch and store in cache-line sizes, which makes that wrong. Cache-lines are much larger than either 32 bit or 64 bit.
Isn't that only true if have related fields in the same 64 byte? I mean a cache line will read 64 byte anyway regardless if you use i32 or i64
Coming from c++, as far as I'm aware using a uint64_t for eg a loop counter gives the best performance compared to either int32_t or uint32_t
Yes, i8 can be faster, but there are often alignment issues when loading into registers. But if you move from iterating in an array of i32 to one of i8 it will be much faster.
good point, forgot about alignment
Yes, in linear consecutive reads it can make a difference if the overall performance is bound by memory bandwidth. In random access it doesn't make that much difference.
&gt; True but if that's the reason wouldn't i8 be even faster :) It would. Time summoning an array of 1M integers of various sizes. You'll find that the runtime is a linear function of the size of the array...
The guy who wrote mIRC, the most popular irc client ever, is of Palestinian/Syrian origin and named Khaled Mardam-Bey (Arabic: خالد مردم بي ).
It gives all or nothing; either both the cmd and 3rd party stuff or i have to choose something else.
There should be three options - only use Git Bash, use just Git in command prompt, and use Git and Unix tools in command prompt. You want the second one of those.
Why didn't you focus on Windows first? macOS is nowhere \*\*near\*\* as popular as Windows.
Typo: &gt; Spark acutally needed 3 GB of RAM to be able to beat DataFusion. That’s 37.5 x more memory than DataFusion needed (3**0** GB vs 0.08 GB).
Thanks for sharing the Spin\_Sleep crate, simple idea but it had never crossed my mind. You mention real time priority but you should also make sure you use the real time scheduler, otherwise real time priority does nothing. \[Here\]([https://stackoverflow.com/a/52501811/1364755](https://stackoverflow.com/a/52501811/1364755)) is a good run down of priorities/niceness and how they relate to different schedulers. You might also profile whether thread pinning to a single core (test different cores) is helps in your case.
Easy Question Regarding Rayon: ```rust let mut c = 0 as i32; a_slice.iter().enumerate().for_each(|(index, addr)| { c += *addr * m_b[RM!(index, col as usize, size }); c_slice[col as usize] = c; ``` I am doing a matrix multiplication to understand the workings of rust. I want to use par_iter() here, but I get the issue of c being borrowed multiple ways here. Is there a way to do this reduction easily? (RM is row major indexing: (index * size + col))
Doesn't matter. If the cache line is of whatever size, you will be able to fit twice as many i32s as you can fit i64s. Therefore if you data is grouped your accesses will get more cache hits
Nice! We want to know about the rough edges too!
Thanks! Also "acutally" ... fixed both
That's only true if your program performs 1 memory access... total, or if it performs completely random memory access and never needs adjacent data. Neither scenario is very realistic. Many real programs are seriously limited by memory bandwidth and cache sizes. In the tiny L1 cache every byte counts, so minimising memory accesses can be a huge win for overall performance.
In addition to the comments on memory bandwidth, it's also useful to keep in mind that on 32-bit processors (quite common in the embedded world), native 32-bit operations would be faster than emulated 64-bit operations.
The waker API doesn’t really encourage TLS that I know of. This is specifically about the builtin async/await syntax which _currently_ uses a TLS variable to pass the context from the `Future` implementation into the generator backing it. That is an implementation detail that is waiting on generator resumption arguments to remove (or something similar for the specific usecase if generic generator resumption arguments won’t happen/are too far away).
i32 requires alignment at Quad word addresses, just like i64 requires alignment at double quad word addresses. no real difference. i32 at unaligned addresses incurs a nasty penalty too.
I'm already in the Redox Mattermost, haven't looked at it in a while, but it seemed not that busy for 400 people.
I recommend a play button
I don’t think embrio is faster than the manual implementation (it’s basically impossible for it to be for this very simple combinators). Without LTO it’s in between the builtin await and the manual implementation, which is exactly what I would expect. With LTO it’s _waaay_ slower than either, which seems very odd to me, the direct pointer manipulation it’s doing must be really tripping up optimisations somewhere.
Thank you. I was writing a long reply explaining my situation and in the process realized that I don't really need it at all.
You are not measuring the performance of i32 vs i64 arithmetic operations, which is my interpretation of the linked section in the book. Your benchmark simply measures the time it takes to sum consecutive 1s. I don't think many people would be surprised that i32 is faster here because you can store the i32 numbers in half the space as the i64 numbers. &amp;#x200B; The book, in my opinion, implies that it is faster to add, subtract, multiply, or divide i32 vs i64. In general, there is not much difference on modern architectures. We are talking the cost of operations themselves, not cache line efficiencies.
I think the waker would have to stay valid even after future poll calls (or at least until the end of the next poll call). Otherwise there’s a race condition if the future first checks if it can make progress, then stores the waker somewhere to be notified. If something happens to allow it to make progress right after it has checked but before it updates the stored waker, then the old waker will be used to wake it up. If it has already been disconnected from that future you have a missed wake that could lead to deadlock.
Whoops, I thought it was far away on the other directly.
Conversations on Redox are largely spread out across 2-3 dozen public channels.
This is about accessibility. IRC is fundamentally not a feature-rich messaging service. It's built to do basic chat, and to go beyond you need a considerable time and learning investment, meaning you either put in the work to get your custom client, bouncer etc setup, or you get a subpar experience with something like a web client, and thus don't get offline messages, don't get your nick reserved etc, in a nutshell you can't communicate as well, and you feel inappropriate. There is no reason this should be like this. Communicating should not be hard, or tiered. The funny thing is this core point ( make good communication easy ) is largely the same as the well-upvoted parent reply, but I happen to disagree on IRC being "accessible" versus Discord not being. I think the hardware requirement point is bullshit if you think about it for 10 seconds ( if you can't run discord you can't run *practically everything* in this webapp-dominated world of today where IDEs take 2 gigs of ram at idle ), and that "just follow this 32-page guide to IRC" isn't a valid rebuttal for how truly shitty the experience of using it is. And no, anecdotal evidence of a handful of girls or LGTB folks doesn't change anything. If we're going to play the game of shoddy anecdotal evidence, I can tell you 60% of people on my project's discord have never used IRC, and probably less than 10% use it on a regular basis.. Indeed I decided on using Discord simply because more people of more diverse horizons, not just hackers and oldschool programmers, but also end-users, artists, modders and all sorts of people who would never go on IRC, because it's inconvenient, scary or both.
[Cache timings](https://www.prowesscorp.com/computer-latency-at-a-human-scale/) If it fits in cache it runs much faster.
&gt; i32 at unaligned addresses incurs a nasty penalty too On what architectures? I've seen it stated that on most if not all x86_64 processors unaligned access is effectively free but on ARM it can incur a performance penalty.
Haven't tested this but I assume something like this would work: let c = a_slice.par_iter().enumerate().map(|(index, addr)| { *addr * m_b[RM!(index, col as usize, size)] }).sum();
Effectively free, it is not at all, even on x86 or amd64. It is just hidden by behind the scenes operations, stalling execution, adding cycles to that unaligned access.
I'm not a part of Mozilla or Rust's community so I'm not sure how your comment would apply to me. I don't think outreach can help so much, at the end of the day a project's stance might scare off potential contributors by being openly toxic or discriminatory, but beyond not doing that there's not much you can do. When someone reaches adult life, most of their preferences and the general direction of their life is largely set. Sure you can change that course, but most people never do that. Computer science faculties, for instance, have a massive gender bias. But they can't fix it themselves, they can't summon women and magically turn around 18+ years of upbringing where a career in IT was never something on the table. Even with massive "positive" discrimination, there is only so many that will be interested. I think for some people, at some point, diversity becomes the end goal, rather than making great things and having diversity and openness in general as part of your work culture. I don't see the point of the former.
&gt; That's exactly the bound that is causing F to only implement the FnOnce trait, because it only needs to implement FnOnce in order for Map&lt;Self, F&gt; to implement ParserOnce. Remove that bound and your code will compile. It's not ideal, because you want to ensure that the map method always returns a parser, but it's a decent temporary workaround until the bug is fixed. Tried it, and it worked perfectly. Thank you for the tip.
Can I speed it up more by using i8, or is 32bits minimal amount per variable? Sorry, I have no idea how this low level stuff works.
In the link the OP posted, there's no language that explicitly says that arithmetic operations are faster, just that `i32s` are faster: &gt; So how do you know which type of integer to use? If you’re unsure, Rust’s defaults are generally good choices, and integer types default to i32: this type is generally the fastest, even on 64-bit systems. The primary situation in which you’d use isize or usize is when indexing some sort of collection. On my machine, `perf` reports that there are twice as many L1 cache loads and L1 cache misses in the i64 version than in the i32 version. I assumed this is likely what the book meant.
There is also a play button.
I meant that if you have i32 values, they will generally be aligned by the compiler. If you have i8 values in a struct, with those values packed - they will not be aligned. I believe (though this might have changed) that there is a slight penalty to reading these values into a (32 bit or 64 bit) register as required to do any maths in x86. A Mask / shift is required or similar, though I think there are (slightly costly) instructions for this. So (without measuring to confirm) I think that random access to i8s (in arrays or part of structs) is slower than random access to i32s because the former require more work to load into a register or save back. However, if your struct is smaller (due to i8s) there is a very good chance you'll get lots more cache hits by using smaller types which will more than offset the cost (i.e the access is no longer random). You might get similar effects in the "random" access above if the total array is small enough. So I claim (without measuring) that a struct of mostly i8s and i16s will be faster than the same struct of i32s only. But only assuming you are accessing many members from the struct and the whole (i32) struct is larger than your cache lines. It's a trade-off between raw CPU throughput (where native types i.e i32, 64 win without SIMD) and Memory / Cache performance (where smaller and packed is always better)
i8 takes up 1 byte's space. i32 takes up 4. Have a look at these two documents. The first is for C++ but that is similar to rust in this area. [https://www.tutorialspoint.com/cplusplus/cpp\_data\_types.htm](https://www.tutorialspoint.com/cplusplus/cpp_data_types.htm) [https://doc.rust-lang.org/nomicon/repr-rust.html](https://doc.rust-lang.org/nomicon/repr-rust.html) And here is a tutorial that appears to talk about how to learn more about this... [http://pramode.in/2016/09/13/using-unsafe-tricks-in-rust/](http://pramode.in/2016/09/13/using-unsafe-tricks-in-rust/)
Nice! I like how easy it is to get started editing the examples.
I doubt it would matter for a loop counter, unless you're doing so little work in there that the loop overhead becomes significant.
[https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-optimization-reference-manual](https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-optimization-reference-manual) &amp;#x200B; 3.6.4 Alignment Alignment of data concerns all kinds of variables: •Dynamically allocated variables. •Members of a data structure. •Global or local variables. •Parameters passed on the stack. Misaligned data access can incur significant performance penalties. This is particularly true for cache line splits. The size of a cache line is 64 bytes in the Pentium 4 and other recent Intel processors, including processors based on Intel Core microarchitecture. An access to data unaligned on 64-byte boundary leads to two memory accesses and requires several μops to be executed (instead of one). Accesses that span 64-byte boundaries are likely to incur a large performance penalty, the cost of each stall generally are greater on machines with longer pipelines.Double-precision floating-point operands that are eight-byte aligned have better performance than oper-ands that are not eight-byte aligned, since they are less likely to incur penalties for cache and MOB splits. Floating-point operation on a memory operands require that the operand be loaded from memory. This incurs an additional μop, which can have a minor negative impact on front end bandwidth. Additionally, memory operands may cause a data cache miss, causing a penalt
Thank you so much. That does work. I was trying the same without enumerate, which is why I was facing issues.
This is not true. Data is packed based on it's size. So you can fit 4x i8s next to a i32 and they are the same size. Their combined size (those 5 fields) is the same as a i64. See [https://doc.rust-lang.org/nomicon/repr-rust.html](https://doc.rust-lang.org/nomicon/repr-rust.html)
All the old 32 bit instructions still exist. And they all work on 32 bit maths. They have special registers for this. Then there are new instructions, which work on 64 bit maths. They have their own registers. The most important thing is that the instructions that load and store memory work with 64 bit pointers. Since all this hardware is separated, for the very best speed you'd do a mix of 64 bit, 32 bit and float work in the same code. So really just don't worry about it.
If you think of the cache as just some memory, the more stuff you can put there, the better. And in that sense, yes, i8 is better. &amp;#x200B; The important thing is that modern caches are built up of lines, which are associated to parts of the main system memory. This means that the smallest amount of memory that a cache can copy/hold is 1 line, which is usually 64 bytes. (So 16 pieces of i32 values, or 8 pieces of i64 values, or ...) If those are continuous in memory. (Such as contained right on successive indices in a Vector.) &amp;#x200B; But. &amp;#x200B; But. &amp;#x200B; If you use multi-threading, in a real multi processing setting (meaning you have more than 1 cores in you CPU, and/or you have more than one CPUs), then you have to be very careful to hand out non-overlapping chunks of work to those cores. And this is where that cache line thing comes in. Cache lines can't just be copied anywhere where there's a free/empty/unused cache line. Usually L3 caches are 16-way associative, L2 is 8-way assoc, and L1 is 4-way assoc. Meaning one line of main system memory can go to 16, 8, or 4 places. (Associativity is important for replacement policy, and conflict misses, see below.) &amp;#x200B; So. The important thing is, cache lines cannot be "split", meaning the main memory is "predefined" into 64 byte long chunks. And if you want to work on data that is continuous in the main system memory, in a multi-processing setting, then you have to align it on cache-line boundaries (and hand out at least 64 byte long chunks to worker threads/cores). Otherwise the cores will bounce cache lines between each others' L1 cache (or L2 if they are on different L2 caches, or even L3, if they are in different CPUs).
This is irrelevant nowadays, but on SPARC, unaligned accesses just kill your program. Thank god I never have to see SIGBUS on computers nowadays.
I've published a crate that can help aligning your data on cache lines: https://crates.io/crates/cache_line_size
Just register a SIGBUS handler and emulate the un-aligned access in software.
&gt; aligned u64 access is as fast as u32 access on 64 bit systems They are the same when considering a single access. Depending on your access patterns, using u64s might translate to cache missing up-to twice as often.
This is cool! Anyway to make it compatible with High Sierra?
Is it possible to have the server running outside the browser? Either on wasi or just on bare metal?
&gt; reviews become stale the moment a new version is released The review is still... fresh... meaning "OK for consumption" :D . Just not for the non-latest version. Also, it's not stale when new version is released, but when you decide upgrade to it. I don't think people unconditionally upgrading as soon as new version appears is actually a good thing. For a lot of more serious users, a policy of waiting some time until considering a new release, is probably a good idea. Right now `crev` is missing some tools like: "which packages I can upgrade and still have them reviewed by someone in my WoT" and the other direction: "which version can I downgrade to get it reviewed". But at this point there are very little reviews available anyway. &gt; It might help to walk through crev usage in the context of normal crate operations. I want to record some videos, but it very hard for to actually find the time to sit down, turn on the microphone without kids running around, or me being too exhausted to actually talk. Will get there eventually.
The server runs on bare metal, the *clients* can either be javascript or wasm. This is a library that makes it possible *to* run WebRTC servers on bare metal, if it was in a browser then you would just use WebRTC support in the browser directly. This would be mostly useful for games that want fast low-latency networking and dedicated servers, with wasm / javascript web clients.
RIGHT!!! As promised, I somehow found time to actually write a moderation bible for Matrix. A first draft can be found at: [https://docs.google.com/document/d/1GodW0ONnp3dmg0MGfcvGXgn\_oqD3jsmmvPC2nLCHdvM](https://docs.google.com/document/d/1GodW0ONnp3dmg0MGfcvGXgn_oqD3jsmmvPC2nLCHdvM/edit#) (Disclaimer: hasn't been reviewed yet; is probably missing some of the moderation tricks we have available; and the final chapter is somewhat future-looking :) It really frustrated me to hear that Matrix had been discounted not due to its lack of features, but its lack of moderation documentation, so hopefully this will help address that in future for anyone going through a similar decision process. Thoughts welcome!
As I said in my post, I don’t think anyone is questioning i32 vs i64 performance in consecutive memory access. My point, and I think OPs point, is that the wording “i32 is faster than i64” is vague. I would argue most people would interpret that as arithmetic operations. You say they don’t spell that out explicitly, which is fair, but I counter that immediately going to consecutive memory access (which most in this thread seem to be doing) as what was meant by the book is a larger assumption than arithmetic ops.
Cool! Can webrtc be accessed from wasm modules inside the browser?
I vote for keeping the icon.
I'd suggest having written documentation before videos, personally.
\&gt; I just can't invest much time. FWIW something is going horribly wrong if the admin of a system like Matrix or Zulip or whatever is having to invest any time in fixing/building/expanding the system to make it do what they want. At this stage in the maturity of FOSS-collaboration-tools, the projects themselves should be ensuring they are fit for their users' purposes. However, it does require the users/admins to report the gaps they find... :)
[Yes!](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.RtcPeerConnection.html)
Nice! RLS Support would be super sweet!
Have you seen evcxr? It's a repl for rust
You would do this during serialization/deserialization of the struct. For example using serde you can serialize to whatever format (JSON, bincode, whatever) which will be contained in a `Vec&lt;u8&gt;` (or String, same thing for our purposes). Then use something like [sodium](https://docs.rs/rust_sodium/0.10.2/rust_sodium/) to handle the encryption.
You should probably serialize it using something that contains information just about the *data* itself, and nothing relating to Rust, the runtime, etc. If it's a large data structure, perhaps using something like [`packed_struct`](https://docs.rs/packed_struct/0.3.0/packed_struct/) to serialize the data to a buffer would work? I'd avoid `bincode`/other Rust-specific implementations that embed type metadata or other implementation-specific details. From here, you can use something like `ring` to RSA or ECDSA-sign the data: https://briansmith.org/rustdoc/ring/signature/index.html Your question is very broad. You should probably provide more details about your specific requirements like cryptographic algorithm desired, what you've tried so far, what's holding you up, etc.
You could use bincode and openssl::rsa. use openssl::sign::{Signer, Verifier}; use openssl::rsa::Rsa; use openssl::pkey::PKey; use openssl::hash::MessageDigest; let bytes = bincode::serialize(&amp;your_struct).unwrap(); let keypair = Rsa::generate(2048).unwrap(); let keypair = PKey::from_rsa(keypair).unwrap(); let mut signer = Signer::new(MessageDigest::sha256(), &amp;keypair).unwrap(); signer.update(bytes).unwrap(); let signature = signer.finish().unwrap(); you can then use the openssl verifier to verify the sig. You'd want to save the keys you generate too, or use your own.
\&gt; aligned u64 access is as fast as u32 access on 64 bit systems &amp;#x200B; often you're talking about more than 1 integer though, in which case u64 access is twice as slow, since it's now a bandwidth issue, not latency
That's what crev-data crate is doing if you're looking for an example.
Wow, not sure how this one slipped my radar, but yes this seems like the "correct" approach. Thanks
It depends on the alignment of the stored i8. If you store each i8 somewhere with aligment 4, then each will actually take up the same size as an i32 on memory (with the remaining 24 bits filled with zero padding). For a Vec&lt;i8&gt; you should save space and have four i8 in the space a single i32 is stored. This can be a massive speedup if you are processing a lot of elements. Why might you want store an i8 on a larger aligment? A reason is if you want to eliminate false sharing by having two unrelated i8s not share the same cache line. This is important when you do multi-threaded code (this is what /u/Pas__ is talking about when he or she says about aligning to cache line boundary) Note also (something unrelated to cache size): when you do arithmetic with them, they will typically be extended to whatever word size of your processor (32 bits for 32 bits processors, and 64 bits for 64 bits processors). So adding two i8s isn't faster than adding two i32s. (But: there might be SIMD integer operations that makes adding a bunch of i8 faster than adding a bunch of i32, at least on some processors) But regardless of that, having more numbers fit in the same cache will still be a big win. So, operating on a Vec&lt;i8&gt; is typically much faster than on a Vec&lt;i32&gt;.
Thanks. Eh. You're right it's high priority.
You could also take a look at craftinginterpreters.com, which is entirely free. =)
If you're just adding you can use AtomicUsize::fetch_add etc... with zero locking
yea, this is a reasonable request. This began as an experiment, and I just went with the default project settings, which target 10.14. Supporting back to 10.13 should definitely be possible without too much hassle (he said, optimistically)
Good to know. I’ll have a go at making it compatible myself and submit a PR if all goes well
But why not just use rustc?
Please keep the icon, that's amazing.
Thanks! That makes sense.
Just out of curiosity. What dynamically allocated datatypes are you using?
Rust can't call directly into C++, it needs a C interface. Bindgen doesn't automatically do that for you. The only safe interop is through functions/structs declared `extern "C"`. So C structs and functions work. As a rule of thumb, STL types cannot be shared across any language boundaries. They need to stay in C++. Use `std::string::c_str` to gets C string you can pass through FFI.
Vec (to store levels and items within levels) and String (for level names) mostly.
Do you use “alloc”?
Yep. I have a custom global allocator set to use C's malloc.
I don't know details but "All Rust packages in F28 and F29 are outdated and some are FTBFS" does sound bad to me. I hope someone knowledgeable explains the situation.
Smiley faces are always so unnecessarily condescending.
I think he meant a play button (triangle instead of a happy face) as the icon.
I do, but you have to clean up after each run.
You might be interested in this: https://www.reddit.com/r/rust/comments/9irjm7/evcxr_a_repl_and_jupyter_kernel_for_rust/
What does fragmentation around loop mean?
Vectors also have spatial locality. They are just heap-allocated instead of stack-allocated. Both are contiguous in memory, though. Other than that, I have a feeling that what you want probably exists somewhere in the ecosystem as a safe abstraction. One of the benefits of using Rust is the memory safety. No segfaults if you stick to Safe Rust. Maybe Crossbeam has what you’re looking for. Worth a glance.
Not sure about the other stuff, but the reason your code is seg faulting is because when you try to set an element the previous value (in this case an uninitialized Mutex) is dropped, which obviously fails. You need to use std::ptr::write instead. And honestly, I would highly recommend using a Vec. It may not be as performant, but it deals with the unsafe code for you. Otherwise, you're probably going to end up with UB like what just happened.
Is that straight to webrtc, or is there js glue in between, like what is needed for dom access? How much latency is added compared to a bare metal client?
Hey all, Still new to Rust and I'm having trouble with my tuple and vector. I have a function that gets a vector and an index passed into it in the form of a tuple. Im trying the check the ith position of that vector, this is basically what ive got: fn function ( choice: ( Vec&lt;u8&gt;, usize ) ) { if (choice.0).[choice.1] == 49 ... Its got an issue with the first ' [ ' saying its an unexpected token, not sure where im going wrong here....thanks in advance!
You want ``` fn function(choice:(Vec&lt;u8&gt;, usize)) { if choice.0[choice.1] == 47 { ... ```
LOL!
There are javascript shims currently, as with all of the wasm-bindgen generated APIs (*eventually* there won't be, once the wasm "host bindings" proposals are implemented?). Comparing to a bare metal client using plain UDP, there doesn't seem to be much latency overhead. Running the included webrtc-unreliable echo_server.rs example on one machine and a web browser on another machine connected via ethernet, I get 1-2ms round trip (timing from `channel.send` to `channel.onmessage`)
You can use [`arrayvec`](https://github.com/bluss/arrayvec) here. Also I would highly recommend not to use `unsafe`, if you are not completely sure that your code is indeed safe (it requires a certain amount of experience and knowledge, you can start with [The Rustonomicon](https://doc.rust-lang.org/nomicon/)).
Note: it really is a better idea to use a Vec. All the mutexes will be in line in one continuous section on the heap, instead of on the stack. There's not really a particularly large difference. Accessing anything in the Vec itself is just bringing that one line into the cache, compared to something like an array or Vec of Boxes/Rcs/etc, which has an additional layer of indirection. That is to say, you shouldn't be worrying about stack or heap in this particular spot, in compared to a Vec of Boxes, if you're worried about locality. What's more worrying is all the mutexes, which all need to call the kernel and need a context switch, I think. Those are a lot heavier. Are you really sure all the mutexes are necessary? If so, what you should do is make a Vec with capacity n, and loop through n times making new mutexes. The other standard ways of directly making arrays and Vecs need for T to be Copy/Clone, which you can't do. So it's best to loop through to make the Mutex a lot. Also, really try not to reach for unsafe. It's a bad idea, and I've never had to so far. Either someone's made the thing you're looking for, or you're thinking about your problem wrong. Or your code is incorrect. If you plan on wrapping that array in an Rc and don't want the double indirection, you should be able to convert the Vec into an array and move that into Vec. Or there's probably an RcVec crate out there.
Can you post a more complete example? In general it should be fine to borrow `arr` mutably in one `crossbeam::scope` and then mutate it later, after the `scope` has finished. For example: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0bdf6c0d486f2d79ff72c5058f894681
My experience coming from JS to Rust has been: - Take on a project, because it will force you to learn what you don't know. - Suffer - Power through it and learn a ton of new stuff - Learn how to read the documentation and search docs often - Ask questions here if you get suck - After you learn a lot, go back and re-read the books you've read - Watch videos on the parts you don't know - If the code you write doesn't look simple, then it probably is not the best way of writing something. Find the most idiomatic way to do it in Rust and strive for simplicity. There's no progress without pain.
Why isn't this more popular? Doesn't this also open up interesting possibilties with webrtc?! Like, I could have clients send traffic to a central server for re-broadcast to other clients, etc, right?
Array/Vec of Mutexes will probably share the cacheline, which will lead to [false sharing](https://en.wikipedia.org/wiki/False_sharing) and lower the performance.
Ah, yeppers yep thank you haha
&gt;In general it should be fine to borrow arr mutably in one crossbeam::scope and then mutate it later, after the scope has finished. For example: Is it because they forgot unwrap?
thanks for the response. I suppose I want to use an array because I believe vector.iter() doesn't necessarily get you the vectors in order physically right?
&gt; Why isn't this more popular? Well, it's not popular because it's *REALLY HARD* to do "properly", WebRTC is NOT a friendly standard to implement. I'm hoping we can make a rock solid way to do this in rust, and that will help open up a huge new wasm game space. &gt; Doesn't this also open up interesting possibilties with webrtc?! Like, I could have clients send traffic to a central server for re-broadcast to other clients, etc, right? I mean, WebRTC already allows P2P connections via TURN / STUN, in fact that's *all* it allows, which is why this project has to go through a TURN / STUN dance for clients to connect even though it's absolutely pointless. &gt; I guess I'm sort of imagining webrtc in place of rtmp for live streaming? Is this silly? Are people doing this? I think people use WebRTC for streaming, I mean the standard is designed specifically to do teleconferencing and stuff like that. Using it for p2p audio / video is using it as designed, using it for client &lt;-&gt; server UDP is NOT using it as it is designed :P
Like with any other language, I think it's just writing a lot of Rust. If you have the time and the inclination, try solving programming puzzles, you'll get to the know \`std\` and all the types/data structures which act as building blocks pretty well. When I was getting started, I ported a bunch of CLI tools at work to Rust, which helped me get familiar with the more unusual parts of rust. They're just the right size, not too big, not too small and Rust has excellent library support in this area. If you can find something similar, maybe try starting there. Also don't worry too much the borrow checker beforehand, the error messages are usually very informative and if you're lost people are very helpful on here/discord.
&gt;The problem with this (and the main reason this is not commonly done afaict) is that WebRTC is a WHOLE PILE of protocols, HTTP, ICE, STUN, DTLS, SCTP (over DTLS!), and then finally the DataChannel connections themselves. Nice! I have been interested in such a thing for a while: using WebRTC to communicate to a rust server and thought that it was daunting to reimplement what you've listed here. There is some effort in place to *properly* support WebRTC, but for games it's 90% not needed! I will be checking this out :)
At least Rust has the most wonderful compiler. Pulling in crates is a dream and the error messages are super descriptive. They usually give you very very good hints also. Just dive in! I also find the design of graph datastructures in Rust dauntiing (though I wouldn't in C++) though I have coded a Chess AI in it and am well on the way to coding my own game logic in it also. PS: If you did want to do Graph libraries or Linked list, there are libraries for both of these. Or you could use a ECS like Specs and that sidesteps the pointer issue by letting you use "Entity" which is an array index in disguise.
So the problem is I have an array that is read-only for some part of the code (only when it's necessary), but I must use an Arc to read it inside the crossbeam scope. If I have an arc, then I can't borrow mutably later on... How do I fix this?
I think the most complicated part is SCTP support, and it's awkward to use existing C SCTP libraries since it's SCTP *over* DTLS. I think you can use usrsctp only by there being a callback hook to mutate packets in-flight, usrsctp afaict has to drive all of the I/O :( I know there is an [existing effort](https://github.com/simmons/webrtc-sctp) to implement SCTP in pure rust, and I hope it gets a bit further and I can replace the terrible 5% of SCTP implementation in this crate. Another frustrating requirement is DTLS, which required that I depend on OpenSSL, but at least here there is a clear way to properly use it. It would be nice if [rusttls](https://github.com/ctz/rustls) supported DTLS also. I genuinely hope *proper* WebRTC is implemented in Rust as well and makes this crate obsolete :)
Okay, by "fragmentation" I mean the data is spread around in memory. By "around loop" I mean that the same code (which is using that data) is running a lot. For instance, if you hold 1000x elements in Vec&lt;YourStruct&gt; then all the data is stored in one large lump. If you store your data as Vec&lt;Box&lt;YourStruct&gt;&gt; then as you loop through the data it has to follow a pointer to a (most likely) new place in memory. Those places can be scattered everywhere especially if your program has been running a long time (and has allocated memory in the meantime). (assuming that YourStruct doesn't have mostly pointers like boxes, Rcs or Strings in it), as if YourStruct is mostly pointers then those will still be costly. Keep your data together in one place and you will get better memory performance. For the basic case, Use Vec and avoid Heap types if you can.
`vec.iter()` does return the items in the original order. A Vec is just a small wrapper around a slice of memory; it doesn't do anything that would the cause the items to be stored in a different order.
If you're using crossbeam::scope, you shouldn't need any Arc. You can use references, as long as the things they borrow outlive the entire `scope` call. You can either have many threads with shared (immutable) borrows of the entire array, or with unique (mutable) borrows of non-overlapping chunks of the array.
Related (I think): [impl of negamax algorithm in rust](https://github.com/kinghajj/minimax-rs)
I think that this probably resolves the concern? If the room is set to *Members only (since they joined)* then your messages are only visible to the people who are in the room at the time.
The borrow checker is an acquired skill that you get by using the language. It’s unique to rust. What made it click for me was simply researching the hell out of rusts memory model (there’s tons of great articles about it I can link when I’m on my pc), and, for some reason, reading up on the different string types and slices truly made it click.
I would advise against implementing data structures in Rust for practice. The design of the language makes data structures significantly more difficult to implement than in other languages. Writing code for some project or solving a specific problem will most likely be easier. &amp;#x200B; You might want to look at this nonetheless: [https://cglab.ca/\~abeinges/blah/too-many-lists/book/README.html](https://cglab.ca/~abeinges/blah/too-many-lists/book/README.html)
&gt; I also wanted to simplify error handling and not return reqwest::Error Do it then, it's just a `pub enum Error {...}` away. Have a look at the failure modes and decide what an API consumer would want. You don't have to map every error - you can group them into error classes that match the application model you're trying to provide. P.S: Please, no `println` in library code. If you need logging, feature gate it or use a crate that makes it configurable by the consumer (like envlogger/log/slog).
&gt;If you had to pick between software built by volunteers on a shoestring budget or by a well funded company with an O($100 million/year) budget, which would you choose? Is there even an organization you can mail a check to if you want a custom IRC solution? In your world, there is no Linux, no LibreOffice, no Firefox, because all of these projects run by volunteers on a shoestring budget have alternatives sold by multi-zillion $/€/whatever companies.
I'm going ask this one again. Web Assembly Question: What's the correct way to pass an array of bytes from the host into a running wasm module? Right now I'm directly writing bytes to linear memory location `0 =&gt; bytes.len()` from the host, then doing this inside the wasm module: let input: &amp;[u8] = unsafe { slice::from_raw_parts(ptr as _, len as _) }; However, I worry that I'm writing to a location in linear memory that might be used for other things. I read somewhere that LLD leaves memory-space `[0...1024]` free so I think I'm OK, but this still feels really dirty. Note that I'm not using `wasm-bindgen`.
Allocate in the module and then pass the pointer up to the JS to tell where to write the bytes.
[Ported my old devlog to Zola](https://twitter.com/ozkriff/status/1119212330246656002). Preparing [a 0.5 release](https://github.com/ozkriff/zemeroth/projects/2) of my [Zemeroth game](https://github.com/ozkriff/zemeroth): writing a giant announcement post.
t_bang is a great crate for getting the data type of a variable. It exposes a few macros but I don't know if it impacts the runtime. I'm not the author, just a satisfied user.
Thanks for the reference. Here's some results showing that unaligned reads are effectively free on newer Intel processors in most scenarios: https://lemire.me/blog/2012/05/31/data-alignment-for-speed-myth-or-reality/ "I see no evidence that unaligned data processing could be several times slower. On a cheap Core 2 processor, there is a difference of about 10% in my tests. On a more recent processor (Core i7), there is no measurable difference. "On recent Intel processors (Sandy Bridge and Nehalem), there is no performance penalty for reading or writing misaligned memory operands." (A counter-example is also linked at the bottom of this page and is worth reading.)
I gave up on [`leetcode`](http://leetcode.com) after seeing that lots of their problems involve linked data structures and their Rust implementations, which are generally awkward and unhelpful. That said, I think they were looking for something more like this ([playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=88dd64a66627d52f58d951cf9365868a)). Cloning the `Rc` is innocuous and makes everything easier.
awesome, thanks for the pointer. Just to be clarifyy though, that's cloning the Optional, right?
I'm reading a C book about ncurses and translating the exercises to Rust because I want to create a kanban board for the terminal.
Intervals are tricky. There are three different timing methods that you have to decide between, with varying implementation complexity: - Time since last use finished. This is what you get when you start a new one-shot when you've completed the previous one, with the same fixed interval. - Time since last invoked. This is what you get when you start the new one-shot *before* you do the actual work, with the same fixed interval. - Time since last scheduled. Here you also have to take into account the delay between when the one-shot timer expired and when the continuation actually gets invoked. The latter two also have to deal with flooding, i.e. what happens when the task takes longer than the interval? Is the new task scheduled concurrently, possibly overwhelming the program with tasks eventually? Is the new task scheduled to execute after the previous one finishes at the earliest? And if so, do subsequent tasks get delayed permanently, or does the program try to catch up? An interface that allows the user to make these choices without burdening him with the implementation complexity would definitely be something that could be a useful library. (And is also kind of something I'd expect in a "timer" library.)
Cloning the `Rc`'s for the `left` and `right` fields of `root`. I notice you were doing something like this, too. After reviewing your code more carefully, I think the key difference is that I define the empty tree to have path sum 0. If they reject this, the easiest way to proceed would be to do a check for the empty tree before calling this code.
My experience, coming from JavaScript and Clojure: The book Programming Rust is wonderful, especially the early chapters that contains explanations and diagrams about memory layout and ownership. I'm at chapter 15 on 21, so while not finished yet I know I can already read and understand small snippets and function signatures clearly. It's complementary to the official book online, which is kept up to date. I also use the API doc and source code. After that I hope to contribute to something of interest for me to solidify my learning. My 2 cents, hope this helps!
I agree. Generic parameters and their constraints are part of the signature, and the IDE should display them.
is there Python bindings available?
This would also enable crates to provide the same flexibility as Arc with possibly a lower overhead in a single threaded environment.
It's really nice that we've moved to a world where CPUs are basically infinitely fast and all we have to do is put stuff on GPU or use SIMD to get world-class performance. The test you linked to discovers that the penalty for non-alignment doesn't matter when reading in sequence through an array. This lines up with the intel document linked above which said that the latency goes from 1 to 2 (essentially nothing) when you cross cache lines and 1 to 20 when you have a cache miss due to that cross (not going to happen with this test case). In case you didn't know, modern CPUs have a cool optimization where they discover that you are reading in sequence (or in specific strides / hops) and they do speculative loading from RAM into cache before you even request the data. That means if you iterate through a flat array you are unlikely to have cache misses. So I think that this test will not be exercising cache miss penalties. I bet there are real costs to non-alignment but they simply don't matter for many use cases because they are dominated by raw RAM bandwidth.
It's really nice that we've moved to a world where computation in CPUs is basically infinitely fast and all we have to do is put stuff on GPU or use SIMD to get world-class performance. The test you linked to discovers that the penalty for non-alignment doesn't matter when reading in sequence through an array. This lines up with the intel document linked above which said that the latency goes from 1 to 2 (essentially nothing) when you cross cache lines and 1 to 20 when you have a cache miss due to that cross (not going to happen with this test case). In case you didn't know, modern CPUs have a cool optimization where they discover that you are reading in sequence (or in specific strides / hops) and they do speculative loading from RAM into cache before you even request the data. That means if you iterate through a flat array you are unlikely to have cache misses. So I think that this test will not be exercising cache miss penalties. I bet there are real costs to non-alignment but they simply don't matter for many use cases because they are dominated by raw RAM bandwidth. I think the counter example deliberately exercises more cache misses.
Thanks a lot for posting this, it has provoked a very interesting discussion.
Have a look at [https://github.com/fdehau/tui-rs](https://github.com/fdehau/tui-rs)
Starting the first in a set of video tutorials aimed at beginners struggling to find project ideas in Rust.