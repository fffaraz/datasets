&gt; The implementation in ATS is notably less straightforward... *completely different algorithm using multiple loops and what appears to be a lambda function* It seems to be the same algorithm, just with syntactic overhead and using recursion instead of an explicit loop.
4) using what I'm assuming is unsigned ints (nat for natural) in the ATS version, but signed in C and Rust.
Wouldn't the compiler be able to optimize that C function into `return 0;`, since the end result is undefined anyways, and there are no side effects? That should give a massive speed boost.
The explanation [here](https://www.reddit.com/r/ATS/comments/7m5pcz/outperforming_rust_with_ats/drrxnrs/) seems to be correct. There may be a bug in the Rust compiler - I wasn't able to get the Rust as fast as the ATS even with this in mind. Either way it's a pretty nice example of programming with theorem proving.
I myself can't say which one is the "right answer" as the uninitialized value l in C, is actually initialized to ... 1 in the Rust version ;)
&gt; This to me makes this an apples to oranges comparison as far as Rust/C to ATS is concerned: No, it's the same algorithm. The algorithm is pretty much trivial - it's just a question of how it is implemented. In particular, there are *not* multiple loops. &gt;you'd need to write the same (functional) version of the algorithm in Rust Rust doesn't optimize recursion, so this would likely make it slower. Recursion is basically the FP way to do while loops, so it's a fair comparison.
It's included in the `.cabal` file's flags. I used `-O3`, `-flto`, and `-mtune=native` with `gcc`. 
Why do you ever do a `match` on a 0? what's wrong with just using if. it makes the rust code look ugly.
Assigning through a pointer is not a side effect. See the C standard. &gt;However, C guarantees that all loops terminate, so if your C compiler can see through printf due to LTO and see that in this case it always returns it can actually eliminate all that code because it contains an infinite loop and that is UB so it can’t be reached. This is wrong, see https://stackoverflow.com/a/15595658 (has reference to the standard).
You can re-run the benchmarks with `i &amp; 1` - the Rust performs about the same. With unsigned integers it gets faster. 
I don't think it's the `match` on a `0` that's the issue here, it's the match on a single value and then a `_`. That's better as an if.
Thanks
&gt; Either way it's a pretty nice example of programming with theorem proving. Agreed!
&gt; The author makes some incorrect claims about the Rust and the C here, specifically that things are heap allocated. I updated the blog post. It should be correct now. &gt; I haven't dug in to figure out the details of why we're slower here though. In the case of the generated Rust I still have no idea. In the case of C/ATS, it seems to arise from `n != 1` instead of `n &gt; 1`. 
&gt; I updated the blog post. It should be correct now. &lt;3
I tried to implement the ATS implementation in rust [here](https://play.rust-lang.org/?gist=40f76a0a19fe17d702badb6f03ab8fe4&amp;version=stable), but with unsigned integers it seems as slow as the original rust code. I don't know ATS though, so I might have missed something. On the other hand, both the recursive and iterator based implementation are as fast as the reported ATS code. The rust version just seems to be written in a way the compiler doesn't understand.
What are the arguments for calling it `unsafe`? My intuition says that the connotation of `unsafe` provides appropriate backward pressure against using it until necessary.
Useful exercise often doesn’t resemble performance. Songs are not scales and arpeggios. There are no automobile tires on the field during a football game. A fight is not a kata.
I couldn't reproduce the benchmark numbers. I got (on a 2014 macbook) running 3 tests test bench_collatz_106239 ... bench: 460 ns/iter (+/- 127) test bench_collatz_10971 ... bench: 350 ns/iter (+/- 98) test bench_collatz_2223 ... bench: 240 ns/iter (+/- 65) I'm a bit more on board with these numbers, as the corresponding numbers of iterations are 354, 268, and 183; if you think the running time should be linear in the number of times around the loop, which I think makes sense with `cmov`, you would expect the times to be 4 : 3 : 2. The cited times are more along the lines of 7 : 4 : 2. It would be cool to see the ASM for the ATS version. Apparently it performs Collatz iterations in about 0.72ns each.
I realized that Rust can do a very compact quine: [`fn main() { println!("{}", include_str!(concat!("../", file!()))); }`](https://play.rust-lang.org/?gist=92f825ce38f660ef60b5c859c78b04f1&amp;version=stable) Just a fun little thing.
When I added #[macro_use] extern crate serde_derive; to my program, I could not use a println! on any of my data types because of "the trait bound `MyVal: serde::export::fmt::Display` is not satisfied". I tried workarounds such as implementing Display myself but it would result in a stack overflow.
Also, while the author laments the use of imperative programming, you can write the program recursively in Rust as: pub fn collatz_length(i: u64) -&gt; u64 { if i == 1 { 1 } else { let i = match i &amp; 1 { 0 =&gt; i / 2, _ =&gt; 3 * i + 1, }; 1 + collatz_length(i) } } and for me at least on godbolt it generates literally the same assembly as the imperative version. Hooray for tail recursion being solved not at the language level!
Performance of this program can be noticeably improved by using builtin`%` operator and replacing `i64` type with `u64`. This seems fair considering the functional example says `nat` which I believe is a requirement that `n` must be at least 0. The code: fn collatz_fixed(mut i: u64) -&gt; u64 { let mut l = 1; while i != 1 { i = match i % 2 { 0 =&gt; i / 2, _ =&gt; 3 * i + 1, }; l += 1; } l } And benchmarks, ran with blackboxed 1235 argument. test fixed_collatz ... bench: 274 ns/iter (+/- 3) test native_collatz ... bench: 336 ns/iter (+/- 3)
Not a nitpick at all. I should have noticed the `b.button` part.
Wait what how? It's not even a tail recursion - how can it produce the same assembly as an imperative version?
I just felt like OP is stating that having implemented a linked list or a graph (both notoriously difficult when mapping an implementation directly from another language to idiomatic Rust) is a prerequisite to knowing how to solve *real* problems in Rust, which I myself did not find to be the case.
It sure is. :) You can go check it out at https://rust.godbolt.org, drop in the above implementation and also pub fn collatz_length(mut i: u64) -&gt; u64 { let mut l = 1; while i != 1 { i = match i &amp; 1 { 0 =&gt; i / 2, _ =&gt; 3 * i + 1, }; l += 1; } l } I literally just did that, dumped each of the output asms into a text file, and then Echidnatron% diff test1.txt test2.txt Echidnatron% but they are small enough that you can just eyeball it too.
Could anyone with more experience with 'ats' help me get the other versions running? I've installed all the dependencies he's mentioned in the README, but none of them supply the `pats-filter` utility which he seems to rely upon. (using https://github.com/vmchale/ats-benchmarks)
&gt;let go I think the universe wants to send me a message :(
OK - **that's** amazing...
Btw, I'm def interested in Rudy, but in my case the sparse arrays are kinda mandatory (stuffing serialized (key,val) pairs in, and relying on (i) key being compressed, (ii) vals landing in-line if small). I did try it out, but loading up some graph data (e.g. `(u32, u32)` data) caused it to explode (due to lack of sparse array nodes, I would guess). Maybe there is some tasteful way to progressively migrate Judy ideas into the ART implementation (adding node types, stashing metadata on proper cache lines, etc).
I think many people put `$HOME/.cargo/bin` on their path. And/or symlink it into `$HOME/.local/bin` which is on some peoples' PATH as well.
This was a serious performance regression when I tried it. Before: running 3 tests test bench_collatz_106239 ... bench: 460 ns/iter (+/- 127) test bench_collatz_10971 ... bench: 350 ns/iter (+/- 98) test bench_collatz_2223 ... bench: 240 ns/iter (+/- 65) After: running 3 tests test bench_collatz_106239 ... bench: 734 ns/iter (+/- 85) test bench_collatz_10971 ... bench: 550 ns/iter (+/- 158) test bench_collatz_2223 ... bench: 379 ns/iter (+/- 113) The `if` statement actually turns in to a "conditional move", which pre-computes the two possible results, performs the `i &amp; 1 == 0` test, and then overwrites the one value with the other if appropriate. There is no control flow interruption, so it isn't as costly as a jump, and does the thing you actually want it to without threatening multiplications. :)
`OsStr` is a slice type, the equvalent of `str` but with different semantics depending on the os (`str` is always checked utf8). `str` can be cast to OsStr safely, but not the reverse.
The compiler is just that good. Feel free to try out http://ridiculousfish.com/blog/posts/will-it-optimize.html (this assumes GCC, but LLVM is very comparable).
An even better informational site about mastodon is joinmastodon.org 
Ah, good to know! [Looks like](https://github.com/vmchale/ats-benchmarks/blob/747aaf56e28f00fadcc7d7dad4487a3f10540998/rs/Cargo.toml#L7-L8) they use LTO for rust as well. Maybe add `-C target-cpu=native` as well?
I think confusion is here because they doesn't have any top level abstraction for this. Say ruby has gone of gems for networking, to has probably even more, python has good stuff too, java, well, java has all. That means in any of this languages i can immediately working on my project implementation and worrying about what's under the hood. Tokio service was supposed be that, but ended up being in awkward inbetween place and you still have to know wtf Tokio is and how to use it. With ruby you just ok I any rack-compatible framework and any rack-compatible server and focus on your projecg. With spring boot i can do the same in java, a few line chances and i have grpc services speaking to each other with automatic discovery.
At tue bottom of this page: http://ats-lang.sourceforge.net/DOCUMENT/ATS2TUTORIAL/HTML/c1063.html is claimed automatic memoization. Maybe this can help explaining why the ATS code is faster? 
Just put `~/.cargo/bin/` in your PATH. Or `ln -s` rustup into your /usr/local/bin. When you switch toolchains and cargo and rustc don't exist for whatever reason, just run `rustup component add rustc cargo`. You can always list installed components from the active toolchain with `rustup component list`.
Is it possible to just `#[derive(Display)]`? Other than that, you probably tried to implement `fmt()` by calling `format!("{}", self)`, which recurses infinitely. At least that's what I can guess without a code example.
Only if the compiler could prove that the while loop terminates for all n.
I think it's undefined in any case. If we never visit the while loop body, we never initialize `l` and then return it, which is undefined behavior. If we visit the while body, the first time it will increment an uninitialized value, which is undefined behavior. So the compiler is free to do whatever.
Rust doesn't *guarantee* tail call optimization, but it does do it (as part of generic LLVM optimizations) when it's able.
Got it, I didn't realize that loop *was* the function name. As far as recursion, my concern is that there could be certain optimizations or other register (probably not cache) implications that a recursive algorithm would be more conductive for. With such few instructions involved, I would even be concerned about differences in the order of assembly instructions since that might allow the processor to generate something more optimized for the CPU's internal pipeline. However this is mostly speaking out of ignorance of such things and wanting to rule that out. The analysis people are doing above is just past the level that I can do, I've only had to get close to that level for moving algorithms into SSE. But you're right that I recall it being mentioned that (tail?) recursion optimizations aren't implemented for Rust yet, so that would destroy the comparison.
The arguments are that it's too late to fix it :) We could use epochs to change it but it's a relatively core bit of functionality with lots of stuff written about it so idk.
I see &gt; now we can use a good licensing system instead of RubyEncoder could you elaborate on that?
Correct me if I'm wrong, but I think it actually doesn't terminate for n=0.
You see [similar things with the Fibonacci function](http://flyingfrogblog.blogspot.co.uk/2016/05/arm-code-generation-quality.html) too. 
Even if not, [loops with no synchronised or externally observable effects that don't terminate are UB](https://stackoverflow.com/questions/3592557/optimizing-away-a-while1-in-c0x).
Your blog still says "Here, we do something that is not possible to do in C..."
I've tried messing around with this library. Its nice but it needs work for sure. I was running into a lot of issues with the onclick closures in my apps. I was actually taking some of my Elm code and trying to one for one implement it into Yew to see how it would work out and Yew felt much more opinionated then Elm. 
How do I explicitly change my version of rust though? I don't want to have to run: $ ~/.cargo/bin/rustup run 1.17.0 rustc &lt;stuff&gt; every time I want to compile something in a different version. Also even the documentation for rustup doesn't tell you have to run a previous nightly build, only the latest. The latest nightly build doesn't work with Rocket framework atm.
Apparently, if this post is right https://stackoverflow.com/a/15271236 , the C standard guarantees that 'int l' will have some unspecified but valid numerical value or a bit pattern that encodes a trap representation. If I understand this correctly, then "l += 1" is undefined behavior (as in "format the hard drive") only if the int type has trap representations. If it doesn't, the value of l is merely undetermined, and has no influence on whether the loop terminates or not. I think it is "save" to assume that there are no such int traps on the used C platform. 
`rustup toolchain default &lt;version&gt;` Then the rustc, cargo etc. executables of that version will be in the `~/.cargo/bin` directory.
This is an amazing post! One thing that surprised me is that I would have expected there to be an `unsafe` block when dereferencing the State pointer? In the example code you just wrap it in a `&amp;mut` and pass it down.
(author may not go by "he", fwiw)
Wow, I've never heard of that! So anlumo is right, the compiler will be able to optimize the loop away and return a random int value.
This actually caused a bug in rustc, as this kind of loop is well-defined in Rust.
FYI, you can also use `rustc +1.17.0 &lt;stuff&gt;` (or `cargo +1.17.0 &lt;stuff&gt;`, *etc.*), assuming the rustup proxies are on `PATH`.
In Rust self-referencing structs are a thing that many people want. However, as you have already found out they are a bit troublesome to implement in Rust. What I would recommend instead of raw references is to use indices instead. So instead of taking the address of the (e.g.) `n`-th element of `buf` you simply store `n` in `MyField`. Further: You can (and should) introduce some types to wrap those indices and provide them with a "meaning" instead of using raw unsigned integers. That's at least how I would tackle this problem in Rust today - but maybe there are better ways.
Could not get rustc +&lt;version&gt; to work, same with the cargo variation. `rustup override set nightly-&lt;date&gt;` didn't work, and `rustup toolchain default &lt;version&gt;` didn't work
I don't think there is, but I've been considering setting one up. Need to think of a clever domain name. I'd buy manish.earth but I don't think anyone else would like that :p
 let i = match e { Event::Input(i) =&gt; i, _ =&gt; return "my error" }; let b = match i { Input::Button(b) =&gt; b, _ =&gt; return "my error" }; let k = match b.button { Button::Keyboard(k) =&gt; k, _ =&gt; return "my error" }; match k { Key::A =&gt; {}, _ =&gt; return "my error" } println!("aaaa"); 
There are some crates to workaround this. I quickly found [self-ref](https://crates.io/crates/self-ref) but I remember reading about another one. Never tried them as I always use other patterns such as indices or change the code so i can properly split owner and borrower.
What is the behavior in Rust?
&gt; deed there is no consistent way to parse a time zone from its abbreviation, because multiple time zones can have the same abbreviation. For example, “CST” can mean either Central Standard Time and China Standar This is unfortunate but there should probably be some way to workaround this (like a config parameter?). Having abbreviations is very common.
The other one was likely [rental](https://github.com/jpernst/rental).
&gt; I recall it being mentioned that (tail?) recursion optimizations aren't implemented for Rust yet This is correct. There's at least one [RFC](https://github.com/rust-lang/rfcs/pull/1888) trying to figure out a way to add tail recursion optimizations to Rust.
To do what they say they are going to do... loop forever
I don't think so. The benchmarks are run on a particular number, i, not all numbers up to i.
Rust's no different to C in this respect.
You should just `#[derive(Debug)]` and then `println` with `{:?}` (which uses `Debug`) instead of `{}` (`Display`). This has nothing to do with serde except there's a compiler bug which screws up the error message; it really refers to `std::fmt::Display`.
I'm new to this, but as I far as I understand, there's no mutable global variable in Rust... And if there is, it's not recommended at all.
There absolutely is. You can either use an unsafe mutable static, or wrap the context in a Mutex and put that in a safe immutable static.
I am working on [actix](https://github.com/actix/actix-web) optimizations. numbers are [pretty good](https://github.com/fafhrd91/benchmarks) at the moment
LLVM is nice enough to compile obviously infinite loops (eg. `loop {}`) to infinite loops. The issue only comes up when the compiler can't prove either way.
Oh, Sorry! TIL
Huh, I had no idea. I found a good counterargument though: http://blog.frama-c.com/index.php?post/2013/03/13/indeterminate-undefined.
One of my favorite talks this year.
Can you control what gets passed as the "data" parameter?
S/he/she Unless I'm very mistaken, the author is female. :)
I think that's his point, not sure.
`stdweb` actually added support recently, as in within last week. :) 
Yeah I loved it too, been getting into rust this year and this was a good explainer into the designing of a rust system
Looks like this uses `stdweb`, which means one can just use the new `wasm` toolchain without additional configuration beyond a `rustup` command instead of instead of being forced to use `emscripten`'s rather heavy toolchain.
Thanks - fixed.
That's a good point! I've been working to fix my writing habits, but still have a ways to go. Fixed it for this post! :)
I think rocket.rs has an approach which I would call MVC-like. 
Rocket + [maud](https://maud.lambda.xyz/web_frameworks.html).
How does rental's approach compare to self-ref?
Just curious, why not use [lettre](https://crates.io/crates/lettre) to send the mails?
:tada: I'm on the new contributors this week! And for a commit in someone else's PR too, amusingly. Hopefully if the issue I've been poking at gives way I'll be able to give a "proper" contribution this coming week. It has been a fun learning experience diving into a project on a larger scale than I've ever done before. And I've mostly used JVM languages and the magical debugging that allows before I fell in love with Rust, so I'm about to install and learn GDB for the first time as well... TL;DR I'm having fun giving back, and that's when you know something is great &lt;3
Rustadon?
&gt;* prevent unwinding past FFI boundaries (finally!) 404 not found. I think it was ment to go to https://github.com/rust-lang/rust/pull/46833.
Congrats! I love the Rust community and how welcoming it is to newcomers, and it's great to see that other people feel the same way too.
&gt; e other one w Yes. Thanks!
Fixed. Thanks!
I’ve been learning Rust as I️ thought it would make a good replacement for the C++ when I️ want to write some parts of my python programs faster. I’m mainly a python dev in the data science world, but recently have needed to build some libraries to be faster. I️ thought this was a common use case for Rust, but haven’t seen any examples of it in the wild. Do you have any examples of how this was done well? Is this not the right tool for the job?
It is also possible to use `if let` to avoid rightward drift: if let Event::Input(i) = e { if let Input::Button(b) = i { if let Button::Keyboard(k) = b.button { if let Key::A = k { println!("aaaa"); } } } }
I've only just heard of `self-ref` now, but from a quick look over, it appears that strict safety is a non-goal, rather it's directed at one very specific use case linked in the docs. I haven't reviewed the motivating example in depth yet, but just focusing on the implementation, it's most certainly unsound. I've put a significant amount of work into making sure structs generated by rental have a strictly sound interface in all cases. Any soundness bug is considered to be of grave importance and will be addressed ASAP. In other words, if you don't want to manually reason about lifetime invariants but rather just want to rely on the borrow checker to do its thing, rental is for you.
It is definitely possible, but it might take efforts to implement it efficiently. I guess the best you could achieve is O(log n) time with O(min(n, m)) extra memory, where n is the length of the range and m is the number of lock acquirement. It seems like a big overhead though...
For the last few days I've been porting the SeetaFace C++ face detection library. Here is the intermediate result: https://github.com/atomashpolskiy/rustface#----rustface . It works, but needs SIMD support for better performance.
Yeah to me it isn't at all clear what he meant with &gt; - we safely stack-allocate a function argument. One can stack allocate function arguments in C (and Rust), and one can even use `alloca` in C to dynamically allocate stack variables (this is not available in Rust, I think)... so... I have no idea what /u/vem_ means with this statement.
&gt; Rust doesn't optimize recursion, Rust performs tail call optimizations as long as you write tail-recursive code (which is easy to do manually). FWIW C, C++, D, Nim, ... and pretty much any low-level language with a LLVM or GCC backend does this as well. What Rust and most of these languages don't have is "guaranteed" tail-call optimization (there is/was an RFC for a `become` keyword in Rust), that is, generating a compiler-error of the tail-call optimization does not trigger. so this would likely make it slower. 
I took a look at the asm for the ATS version, after a bit of cleanup it looks like: collatz: cmpl $1, %edi movl $1, %eax jle .L19 .p2align 4,,10 .p2align 3 .L21: addl $1, %eax testb $1, %dil jne .L23 sarl %edi cmpl $1, %edi jne .L21 rep ret .p2align 4,,10 .p2align 3 .L23: leal 1(%rdi,%rdi,2), %edi jmp .L21 .p2align 4,,10 .p2align 3 .L19: rep ret I immediately noticed that this only does one `sarl %edi` whereas the C version's loop body is more complex, with both a `shrl` and a `sarl`. My hunch was that this is a signedness difference. I also noticed that the ATS version declares `n : nat` which sounds unsigned to me. So I changed the C from `int collatz_c(int n)` to `int collatz_c(unsigned n)`, which indeed made the asm look much more similar. And with no other changes, the C version started beating the ATS version for me: benchmarking collatzStack/2223 101.7 ns (100.1 ns .. 103.3 ns) benchmarking collatzStack/10971 148.9 ns (147.4 ns .. 150.5 ns) benchmarking collatzStack/106239 201.9 ns (199.4 ns .. 205.5 ns) benchmarking collatzC/2223 96.97 ns (95.84 ns .. 98.13 ns) benchmarking collatzC/10971 141.9 ns (140.7 ns .. 143.4 ns) benchmarking collatzC/106239 186.1 ns (184.3 ns .. 188.1 ns) In the end, the only difference was the signedness of `n`.
I'm currently building an async server that needs hashing and symmetric crypto. I've made some of my helper functions re-usable and published them as a crate. Looking for feedback of all sorts! Is this type of thing useful for others? What could I improve on the APIs?
I mean native licensing systems (DRM) are more secure, much more widespread and more flexible for a customer (server-based licensing support and so on). RubyEncoder is just too primitive.
Yes, you are correct :)
I'd have preferred `unsafe` -&gt; `unchecked` and `unwrap` -&gt; `get_or_panic`, but the second change is unlikely as it is not in line with Rust's DOS naming conventions.
Thanks! I must have deleted a line of code by accident. It's fixed now. The first line of the `update` function should have: `let mut state: Box&lt;State&gt; = unsafe { Box::from_raw(state_ptr) };`
Oh wow, I've been staring at that for *months*. Should be fixed now :-). Thank!
&lt;3
Ah nice one, I didn't think of that. The latest version on crates.io (0.4.1) should compile out of the box now. But it's still necessary to get the seed from JS.
You can usually trust Arg 0 to be the path to the executable, unless it isn't inside the same file tree as the file you want to open or you're using a bizarre OS for some reason. For debug purposes you can use one of the env vars to get there, like CARGO_MANIFEST_DIR. But you need to remember to not ship it like that or users will get strange errors with the exe searching for unknown file paths.
I'm confused why this code builds, and what it does: ` fn testing(test: &amp;Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; { *test }`
`String` is easiest and always possible (just add `.to_string` is necessary). `&amp;str` is very useful as you don't need to allocate memory. If you *sometimes* need to create a string but other times can just point to (part of) an existing string, check out `Cow&lt;str&gt;`. More complicated but very cool and has a great name. 
Hi! I took a bit of a look at the code. First off, I think it's very clean and readable and looks well-structured. One thing I noticed was that you have a lot of 1-variant enums like this: ``` pub enum Program { Program(Variable, Block) } ``` Is that intentional (so you can add extra variants later)? If you're sure that there's not going to be any new variants, you could instead use a tuple struct like this: ``` pub struct Program(pub Variable, pub Block); ``` which would remove a lot of nesting from the interpreter code. 
My rule of thumb is: Is it a substring of another string? Then `&amp;str` is the right way. Is it a new string? Use `String`. Err towards `String`. There's a couple of optimisations, like using `Box&lt;str&gt;` when you know the string should never be modified or `Cow&lt;str&gt;` to delay copying, but `String` is a good first approximation.
Looks like this is completely insecure. No only does it support the ECB mode, but there are no authentication tags, so the ciphertext can be modified without this being detected. And no modern cryptography tool should propose MD5 and SHA1.
There shouldn't be single quotes around the api:{} format string. They are a feature of the shell, not the Command library. You don't even need them in the shell, because the quoted string api:key-1234 doesn't have any special characters in it.
Not really. The data parameter brings data from the library back. 
Great!
You can use std::ops::Range&lt;usize&gt; to fulfill the purpose`&amp;'a [u8]`. use std::ops::Range; struct Field { data: Range&lt;usize&gt; } struct Record { buffer: Vec&lt;u8&gt;, field: Field } impl Record { fn test(&amp;self) -&gt; &amp;[u8] { &amp;self.buffer[self.field.data.clone()] } } 
Rust is able to optimise out the recursion in this example, and seems to do a [better job](https://godbolt.org/g/y2fjzv) than the while loop version. Notice that there's no branch now, it being replaced with a conditional move. I can add some comments to the assembly if you like.
I think your problem is indeed in that line. `img_ptr` seems to be a pointer toward the `ImageBuffer` struct instead of the raw data. `glTexImage2D` uses the raw image data (RGBA in this case), so you need to give it a pointer to the raw image data. You can access the raw image data using `image.into_raw()`, which returns a `Vec&lt;u8&gt;`. You can then access the raw data using the `as_ptr` method on `Vec`.
Sorry, my mistake.
I implemented a few more of those in the [`average`](https://crates.io/crates/average) crate.
If you can do that, use `&amp;str`, but I doubt you will be able to do this in many cases, considering a borrowed string needs to be a slice of a string provided by an user or a constant string.
Did you take a look at the Ring crate and the sodiumoxide crate? They provide high-level crypto APIs in the sense that they combine multiple crypto primitives to form a new API with better guarantees (e.g. authenticated encryption). They may not fit your usecase, but keep in mind that they are preferred by many as they are easier to use safely.
Here's something that's puzzled me for a while - there's an `AsRef` conversion from regular UTF-8 strings to `&amp;OsStr`, and this always succeeds (cool) and is cheap. But, say we are on Windows - would this not imply a conversion to widestring (which requires allocation)?
What do you mean by 'it'? Extending Python? Writing data science libraries?
I tried to read the README, and the OP's explanations, and to be honest I just have no idea what this Jostle Tree is about. I guess it's the kind of things for which a picture is worth a thousands words :)
Based on few quick optimisations, here's a version in C that should have comparable speed (not sure because too lazy to setup ATS): uint32_t collatz(uint32_t n) { uint32_t l = 0; while (1) { if (n % 2 == 0) { n = n / 2; } else if (n == 1) { return l; } else { n = n * 3 + 1; } l++; } }
I think two-phase borrow can be thought of as an extended NLL where the borrows starts *later* than lexically indicated.
&gt; unless C++20 bounces back with concepts, modules, and more powerful compile-time metaprogramming To be honest, even if concepts and modules finally make it to C++20, I'd probably still go with Rust 1.22 in general for a project from scratch, and it's only truer if we think of Rust 1.x in 2020 (with `const fn`, ATC, ...). The problem of C++ is dual: 1. Shaky foundations: No amount of pretty paint over the cracks is worth solid foundations. 2. Backward compatibility: Each new feature increases language surface, and when not orthogonal with old features this increase is geometric.
&gt; IMO, Rust makes it harder to implement complex data structures because of its overly restrictive safety precautions, than other languages, for example C++. Having implemented a number of data-structures in C++, not even that complex, I will disagree here. Oh it's easy enough to get the C++ code to compile. Sure. Your job is now 50% done. The next 50% are to ensure that your code is correct... *oh*. While in general I have a rather low amount of UB surfacing in C++ code, data-structures code is an exception. It's *so* easy to forget to update a back-pointer, re-allocate storage without updating all pointers, etc... Rust is challenging for a C++ developer because we expect to be able to do some things or define some APIs which Rust balks at because of their unsafety... but I find this comforting, actually. It leads me to structure my Rust code differently than my C++ code: a minimalistic unsafe core (compiler-enforced) wrapped in a full-featured safe API. With the compiler tracking that the unsafe doesn't leak.
this isn't specific to data science, but a good example of using rust to fix some performance issues with python. https://blog.sentry.io/2016/10/19/fixing-python-performance-with-rust.html
Still working on [ggez](https://github.com/ggez/ggez/), a 2D game framework modeled on Love2D. And the 0.4 release is [almost finished](https://github.com/ggez/ggez/milestone/3)! All we need to do is update Speaking of which, is there anyone with more MacOS development skills than I and half an hour of free time who can explain to me how to distribute Rust code with C dynamic library dependencies? That's the main hole in our [build docs](https://github.com/ggez/ggez/blob/master/docs/BuildingForEveryPlatform.md#mac).
Interesting! I'm getting some C++y template meta programming vibes from this, except uninhabited types took it a step further. I wonder if something similar would be possible in C++...
I would, if I were still working on it, but actix doesn't really seem to be a web server.
And based on this, I would suggest using `u32` in Rust: - unsigned seems to generate better code, and matches the problem domain better anyway, - ATS and C seem to use 32-bits, so why is Rust stuck with 64-bits?
&gt;There's a couple of optimisations, like using `Box&lt;str&gt;` when you know the string should never be modified Could you explain this one? Are strings copied otherwise?
I'd strongly recommend you investigate my Rust crypto library Miscreant, as it supports streaming authenticated modes (and furthermore, misuse resistant ones): https://docs.rs/miscreant/0.3.0/miscreant/stream/index.html
What do you mean a web server? it is in same category as rocket?
Also take look at [RustCrypto](https://github.com/RustCrypto) crates, if you are interested in a pure Rust solution.
I have advanced this example to deal with named structs and enum struct type variants under [github.com/n3phtys/typescriptify](https://github.com/n3phtys/typescriptify/blob/master/typescriptify-derive/src/lib.rs). Horrible, horrible written code that does not even yet work with tuple types, mainly coded with copy&amp;paste, but at least my first rust macro at all. Thanks! Maybe I will revisit the code once I have improved my skills. For now it's good enough. I'm adding an endpoint to rust that returns the given file as one big string containing all definitions. My npm build on the other end calls curl to make it into a file, and I'm all happy. Maybe one day serde_json will just output swagger / raml or even just json schemata data, but it doesn't yet. 
Actually, with both `String` and `Box&lt;str&gt;` you're allocating a new string -- but the difference is that you can think of `str` meaning "read-only string". `Box&lt;str&gt;`, therefore, is an OWNED value of a string, but you've put the data behind a read-only interface. That make sense? :)
A project to implement a Mastodon instance in Rust may bring more users into the network.
Hi, thanks for the feedback! :) I think you are right, a lot of the enums I have are single varient and could absolutely be tuple structs instead. I think the reason I had the single-varient enums with to begin was for consistency, and also because of some issues with polymorphism I ran into early on. I originally was using all structs for the AST and tried using inheritance in rust, that did not work, so I switched over to enums 100%. I think the single-varient enums were just a product of that switch. I didn't really think of mixing enums and structs but I see now that it should work, and reduce alot of the nesting like you said.
I must admit being very disappointed in this blog article /u/vem_ . --- Much like the difference between good journalism and newstainment, this blog article is missing a crucial piece of any good benchmark: *analysis*. A benchmark result which cannot be explained is not worth talking about. Benchmarks are useless in themselves, they are only interesting for their *predicting power*: we use benchmarks as a stick to estimate future performance. Only analysis can inform us whether a benchmark has predictive power or not. Without analysis, it's unclear whether the result is a fluke, is specific to a particular condition of the experiment which actually will not hold in the wild, ... Without analysis, running a benchmark is hurtful: one's mind may attribute predictive power to the benchmark when it has none. Such as suggesting that ATS is faster than Rust or C in general. There are very good reasons for which ATS could be faster than Rust or C in specific cases, however without identifying such cases there's nothing to talk about. --- In this specific case, one thing that jumps to attention is the difference of type used: signedness and bitwidth. This is very suspicious. ATS uses an `int` (likely a C `int`) and constrains it to being unsigned (and positive?) while C uses a (likely) 32-bits signed `int` and Rust uses a 64-bits signed `i64`: - the C and Rust program never checks that their argument is `&gt; 0`; note that the loop is infinite in this case. - the Rust program uses a weird `modular` function which is just an overcomplicated `%` for positive integers. - the use of 64-bits integers in Rust may (1) increase register pressure and (2) slow-down some operations (such as `%`). Ideally, one would look at the assembly emitted by the ATS, C and Rust compilers and attempt to explain the difference. For example, I expect different signedness and bit-width to produce different instructions, and therefore working back from assembly it should be possible to uncover the (probably unintentional) differences. Once those slight differences are fixed, one can rerun code generation and check again if there is any glaring difference in (1) the results and (2) the assembly. If there is none, congratulations you have proved that a higher-level language like ATS can generate code that is as fast as that generated by C or Rust! If there are still some, rinse and repeat, and possibly identify missed optimizations opportunities in the toolchains.
&gt; you can think of str meaning "read-only string". Not really, `str` can and sometimes is still modified, for example, by ASCII lowercase/uppercase operations https://doc.rust-lang.org/std/ascii/trait.AsciiExt.html#tymethod.make_ascii_uppercase.
It's simple: If you can return &amp;str, return it. If you can't (as you are creating a completely new string), return String. If sometimes you can return &amp;str but sometimes need to return something new, return Cow&lt;str&gt;.
`&amp;str` has 16 bytes, `String` has 24 bytes (because it also stores the capacity of the currently allocated data). `&amp;str` is not owned, though, so rules of borrowing and not of ownership apply. `Strings` allocate on the heap, though, so they can own and manipulate the data. `Box&lt;str&gt;` is the in-between: it allocates on the heap and _owns_ the data, but it doesn't have a capacity. It therefore has 16 bytes, but other rules apply. Note that this doesn't mean that the 2-pointer slice structure is on the heap, just that the data is on the heap. (this is a good example where `Box&lt;T&gt;` is not only one pointer long. Now, writing this, I'm asking myself why the Rust stdlib doesn't have an `Str` type that is basically a `Box&lt;str&gt;`.
That being said, it's a great PR :D There are so many languages where it's a *guideline* (ahem... C++) and things go all kinds of wrong when it's accidentally violated. It's great to automatically enforce it by default.
Hmm, that's actually really important. Maybe a better way to phrase it is "`str` can't be resized"?
Whoa. I've actually taught a college-level software design patterns class, and double-checked locking is, in that course, touted as THE safe solution for lazy thread-safe singletons; the class loader is merely suggested as an interesting alternative. After reading that. whitepaper, I want to make sure that this technique gets purged from anything that the course touches. TIL, thank you!
TIL about Uninhabited Types. This is actually a really useful and neat trick!
Ah, yes, [Welford's Method]( https://www.embeddedrelated.com/showarticle/785.php)
is domafic still being updated? it looks like the last commit was in July.
Yeah that would be correct. Think of `str` as `[u8]` - anything you can do with `[u8]`, you can do with `str`, the only thing `str` does is marks the contents as valid UTF-8 sequence.
the claim makes me sound skeptical, a decent imperative language gives you as complete as possible model of what the machine can actually do , so there should be no way to outperform it; functional programming to me is about convenience rather than intrinsic capability.
It sounds like you have another copy of rustc and cargo installed somewhere, in addition to those managed by rustup.
It's less about imperative vs. functional languages and more about the restrictions of a language and how a compiler can use these to further optimize the code. If you're looking at an optimization like fusion in Haskell, which can get rid of intermediate data structures, then this optimization is only possible because of the immutability and pureness guarantees.
Can confirm, it's wonderful. My college email still works and I am enjoying it.
&gt; which means we can provide a placeholder for Err part of Result which can't be actually constructed, and compiler will know that this operation is infallible. So the Rust compiler currently can actually reason about uninhabited types nowadays? Because this does not currently compile on the playground: pub enum Void {} fn producer () -&gt; Result&lt;(), Void&gt; { Ok(()) } fn main() { let Ok(()) = producer(); } Complaining that the pattern is refutable and that Err is not covered.
Iron is a sweet crate, but how can I list all available paths + HTTPMethod on a given server struct?
I think it's currently handled at LLVM level. It could be probably possible for Rust to allow omitting unreachable match branches, but it could also lead to surprising behaviour in context of generic implementations where sometimes you would add extra match and sometimes it wouldn't be required.
How can this possily be handled at the LLVM level? This is part of Rust's type checking which I doubt LLVM has any knowledge of; all of that is done once LLVM gets to work on the code.
TIL, thanks! :)
Stfu
Rust's iterator fusion is expressed at the language level, and seems more reliable than Haskell's, though.
UPDATE: the Rust client, server generators are now available in the latest stable release of Swagger Codegen v2.3.0. Please refer to the release note for more information: https://github.com/swagger-api/swagger-codegen/releases/tag/v2.3.0
This actually works on nightly with the [never_type feature](https://github.com/rust-lang/rust/issues/35121). #![feature(never_type)] fn producer () -&gt; Result&lt;(), !&gt; { Ok(()) } fn main() { let Ok(()) = producer(); } [Playground](https://play.rust-lang.org/?gist=4b5600c6bc72e2fa4b25804b0451320a&amp;version=nightly)
Use ‘strace‘.
Because it isn't possible to do in C. 
Oh! I was talking about [actix-web](https://github.com/actix/actix-web). Here is [user guide](https://actix.github.io/actix-web/guide/)
Yes, I'm aware of this. GHC is still a quite amazing piece of compiler technology and shows where language restrictions might have an advantage in the case of opimizations. I don't quite know how much of the instability of the fusion optimizations is about changes of GHC internals and how much they're a prinicipal and hard to solve problem. 
As mentioned above, avoiding branches for uninhabited types becomes possible in Rust side only with never_type feature. For now, they are just optimised out at LLVM level. If you look at the generated IR, you will see that Rust still generates instructions for these branches, even though they contain just unreachable instruction: https://godbolt.org/g/ngcpDu
It's not that simple! What if you want to change your implementation later in a way that requires you to create a new string? Returning `String` or `Cow&lt;str&gt;` lets you do that without causing a breaking change.
Still not sure if I can follow. I expected this to work then: `let img_ptr: *const c_void = image.into_raw().as_ptr() as *const c_void` but leads to black texture as well. `as_ptr` alone is not sufficient as that would give &gt; expected type `*const std::os::raw::c_void` found type `*const u8` 
That line gets a pointer to the start of the data but then the `Vec` is deallocated. Might I suggest building on top of a library like [`glium`](https://docs.rs/glium), which provides a safe interface to OpenGL? That way you don't have to deal with unsafety pitfalls, in both Rust and OpenGL's API.
of course! but a few features like random are so fundamental that C opted to include them in the standard library. I'm not talking CSRNG here, even a simple pseudo rng would suffice.
Thank you for sharing this enjoyable talk. It was just what I needed to go along with my morning coffee.
Oh! That makes much more sense then.
"Web application framework" would be a more accurate description, I suppose. Just takes longer to type.
I am aware of the existence of `glium`, thanks for mentioning though. But no, that's not what I want to use here. Why is the Vec deallocated before it gets used? Is `TexImage2D` async or rather only uploading the data on demand?
You need to put the `Vec` returned by `into_raw` in a variable if you want it to live for longer than the statement it's in. Alternatively, you can move the entire `image.into_raw().as_ptr() as *const c_void` into the `TexImage2D` call, that would also keep the temporary `Vec` alive long enough.
Not possible, unfortunately. There is an rfc undergoing to fix this, but until then you will have to work around it. Maybe you can pass a reference around instead? Or you can use a trait with a single method to represent the closure instead?
The `Vec` gets deallocated because it is being dropped. In `image.into_raw().as_ptr()` it gets dropped because it went out of scope. It is roughly equivalent to the following block: { let vec = image.into_raw(); vec.as_ptr() // Vec goes out of scope and gets dropped } Because the `Vec` is being deallocated, the data stored in it will be deleted so you can no longer access it. When `TexImage2D` tries to read it, it should only see garbage. If, however, you keep the `Vec` with the image data in scope, it should work fine, for example: let img_data = image.into_raw(); let img_ptr: *const c_void = img_data.as_ptr() Because the `Vec` is still in scope and you can still access it, the image data won't be deleted and `TexImage2D` will read your image data instead of garbage.
one exists (full disclosure: i'm one of the main devs), but it's going very slowly atm, and is mostly in the specs and design phase atm (masto is a Really Big piece of software! even just federating with it is rather hard)
Thanks for the suggestions! &gt; Or you can use a trait with a single method to represent the closure instead? Do you mean something like the `Pattern` trait for `str` functions? If so, could you elaborate more? I'm not clear on how I can clone functions by using closures behind a trait.
To play the C implementation's advocate: when you read the uninitialized `int`, you get a trap representation. Of course no bit pattern actually exists for an `int` trap representation on x86, but that's ok: reading a trap representation caused UB, so the compiler can use whatever's convenient as the trap representation's bit pattern. It's totally demented, but IMO nasal demons get them off the hook.
The description there is not very clear. What actually happens now if a panic reaches an FFI boundary?
It seems that there isn't a single *general* approach because there isn't a single *general* intention when returning a string.
A quine without reading the source directly would be: fn main(){let x="print!(\"fn main(){{let x={:?};{}\",x,x);}";print!("fn main(){{let x={:?};{}",x,x);}
Perhaps you need `#![feature(clone_closures)]`? Note that cloning a closure primarily has to clone all values captured in the closure. This could be painful if anything large was captured. But usually they'll just be references, which is cheap, unless it was a `move` closure. I think I'm general you should just pass `&amp;Fn` though, since they're called by `&amp;self` anyway.
Rust newbie here. In D it's possible to do the following (this example is about struct fields instead of enum variants, but I think it's similar): struct Foo(bool allow) { int x = 5; static if (allow) { int y = 123; } } Depending on the compile-time value of `allow`, one of the fields is disabled in the template instance. Will it be possible to do it as effortlessly in Rust?
UTF-16 conversion is done in the OS-facade functions, like [`File::open()`](https://github.com/rust-lang/rust/blob/master/src/libstd/sys/windows/fs.rs#L258). `OsStr` on Windows is a wrapper around WTF-8 strings, which is a UTF-8 based encoding with loosened restrictions designed for easier conversion to UTF-16 (UTF-8 is valid WTF-8 but not necessarily the other way round).
Panics will become aborts when they reach a function that is not using rust abi (extern "C" usually).
Or more likely, it's able to elide the `n != 1` check in recursion with `n * 3 + 1`... in C: uint32_t collatz(uint32_t n) { uint32_t l = 0; while (n != 1) { next: if (n % 2 == 0) { n = n / 2; l++; continue; } else { n = n * 3 + 1; l++; goto next; } } return l; }
Closures can have and own arbitrary data, and that data is not necessarily clonable.
Thanks for the feedback! In my case I needed AES in CFB mode, which alas neither Ring nor sodiumoxide support (yet?). I agree on the usability aspects. The usefulness of my crate comes from its integration with futures, but there is no reason it could be based on ring instead of openssl in the future!
I think it's because saving 8 bytes on the stack hasn't been seen as very important, and in the majority of cases, the cost of creating `Box&lt;str&gt;` from a `String` (assuming the string has extra capacity) is more than the space that would be saved.
Thank you very much for the explanation! My texture still is black, so I'll try to work out what is going wrong opposed to the C++ impl that works, but I learned something here, so thanks again for that!
Thank you very much for the explanation! My texture still is black, so I'll try to work out what is going wrong opposed to the C++ impl that works, but I learned something here, so thanks again for that!
Thanks that's very helpful. 
It should definitely work, with some kind of tree structure and some unsafe code. I think the main reason it hasn't been done in a standardized way is that a lot of the use cases work just as well (and more efficiently) using a single RwLock/Mutex and split_at/split_at_mut on the resulting reference. In particular, if the caller is trying to arrange things so that it never fails to lock a range in practice, probably the same code could be adapted to work with split_at.
Closures capture data - which isn't necessarily clonable. If you want a _function_, you want `fn()`, note the lowercase. This is guaranteed to be just a function pointer, it can't contain any data, and works for closures which don't capture anything. `fn()` is cloneable (and copyable). If you do want to copy around an `Fn()`, you'll either need to wait for `#![feature(clone_closures)]` to land, or store it in an `Arc&lt;Fn()&gt;` and clone that. (probably not possible for nostd?)
Cool. And will this get added to the reference or is it just a best-effort mitigation kind of thing?
Please stop being needlessly aggressive here. Just in case you haven't noticed: Rust already is an enterprise language, with success at heavyweights like Google, Oracle, Dropbox, etc. You also fail to articulate your reasoning: XY 'sucks hard' doesn't cut it. So if you are really interested in discussion, you're welcome to – just follow the same rules as everyone else (you'll find them in the sidebar). On the other hand, if you only want to troll, get lost. You don't get to dump on other's accomplishments because you have none of your own.
I downvoted because the title and the content have a poor attitude. RLS has not reached maturity, so of course the autocompletion and other related things will have issues. This is not some secret. There are tons of community-driven open source projects written in Rust, and Rust itself is one of the most community-driven languages I've ever seen. Go is far more driven by Google than it is by the community. I use it at my full time job, so I'm quite familiar with it and its community. Your second bullet point is so aggressive and opinion-based that I'm not even going to address it.
In rust you can do this with configuration variables, but not with generics. struct Foo { #[cfg(allow)] bar: i32, baz: i32, } 
because the arguments to `--user`, and all `-F` are different? In the direct-curl case, you're actually using bash (or some other posix-like shell) which is parsing the arguments and executing `curl`. This shell processes the single quotes (`'`). In the rust+curl case, the single quotes are being passed to curl itself.
Even more interestingly, there appears to have been [a matching post on /r/golang.](https://www.reddit.com/r/golang/comments/7mcfl2/ban_me_delete_this_post_ignore_the_truth_but/) I can only assume it was saying "sorry, guys, I go back to rust, a programming langauge..." at the end, but I can't find an undeleted copy of it.
When you have specific needs like AES in CFB mode, you need a library that exposed combinations of primitives, so it makes sense that you are looking at using openssl directly. I don't know whether there's a better option in the rust world, as I've only had unspecific/flexible usecase where I could make use of the higher-level libraries :-)
Rust nightly now has a builtin first-class uninhabited type: `!` or the never type. The compiler can reason about it so that eg. `Result&lt;_, !&gt;` can never be `Err` so `Ok(_)` is an irrefutable pattern.
I must admit that, naively, I would instead lift the trait one more level. That is, I would use `trait MyEnum`, and then provide two implementations `enum MyEnumTrue` and `struct MyEnumFalse` (no variants) which would implement `MyEnum`. This allows me to specialize the storage (and avoid uninhabited variants completely), implement common operations only once (generics on `MyEnum`) and is rather straightforward. Thoughts?
Interesting but why not just return the naked value (why wrap in result?)
It's actually fairly simple. There are two regions of memory, the stack and the heap. The size of all values on the stack have to be known at compile time. Local variables are on a "stack frame" that gets popped and pushed. When a function returns, the stack frame for that function is destructed. To make a value "outlive" the function that it was created in, you have the heap. Heap memory is not freed when the function returns. The stack is fast, the heap is slow. Memory is cleaned up automatically on the stack, on the heap you have to do it manually (RAII). Variables on the stack cannot be dynamically changed in size, variable on the heap can. So far, so good. You cannot return a `&amp;str` if that reference was **created** inside the function. Why? Because &amp; is a pointer into the stack frame. When the function returns the stack frame goes poof and where would your pointer now point to? Garbage memory. However, if the &amp; points to memory that was in the parent function (the parent stack frame), then it would be ok to return a `&amp;str`. Rust automatically creates "invisible lifetimes" on each function, which correspond to one stack frame. Example: fn something(input: &amp;str) -&gt; &amp;str { return input; } What would be the "invisible lifetimes" on this? Rust knows that you cannot return a pointer into the stack frame, so it has to assume this: fn something&lt;'a&gt;(input: &amp;'a str) -&gt; &amp;'a str { return input; } This is the only thing that would make sense. The input has to live as long as the function itself. The output cannot point to a function-local variable, because when the function returns, that value is destructed (this is a common bug in C++, for example). So it has to assume that the output lives at least as long as the input. But what if we pass a String? Here you have to know about RAII. As I said, heap memory is not automatically freed. In C you would do this: char* my_string = (char *) malloc(10 * sizeof (char)); // allocate memory on heap free(my_string); // free memory on heap // also: you can still access my_string (points to garbage) This is dangerous, because these two lines can be hundreds of lines of code apart from each other, if something goes wrong between them, the `free()` function may never called (bad). In Rust (and C++), the "free" happens automatically when the scope (i.e. the curly braces) end. So: { let my_string = String::with_capacity(10); // allocate } // my_string goes out of scope, automatic free() called This is called "RAII" - an object (in this case `String`) contains a pointer to memory on the heap. Meanwhile the `String` is passed around on the stack. When it goes out of scope, the heap memory is freed. You can never forget to free memory this way. But let's look at this: fn something(input: String) -&gt; &amp;str { return &amp;input; } // memory of input is free'd! return value would point to garbage! This will never compile. Why? Well, where should the `&amp;str` point to? It can only point to something passed into the function, in this case the String, which is destructed when So TLDR: - if you created the string from inside the function, return `String` - if the function borrowed the string, you can use `&amp;str`. You can copy the value in `&amp;str` and make a new `String`, via copying the contents. This is possibly not performant. - `&amp;String` can be coerced to `&amp;str`. The compiler can accept a `&amp;String`, even though the function wants a `&amp;str`. But not the other way around. But there is no general rule. You need to understand the stack / heap memory model, then you'll understand the difference between `String` and `&amp;str` and when to use which. Otherwise, Rust (in general) won't make sense to you.
To be fair this only applies to nullary constructors though.
I agree! Let's see what Mr "squint into distance while trying hard to look intelligent and deep" thinks. 
What I mean is you can't clone a closure, but you can create a struct that acts a lot like a closure and clone that. Example: #[derive(Clone)] struct Foo(bar: Baz); impl Foo { fn call(&amp;self) -&gt; { .. } } It's basically the same as implementing the closure manually. It's not possible to combine with closures, so it can easily get too verbose to be practical.
That's a really bad reason. If the API changes meaning, you should be using a new name.
 trait FooY { type Y; } impl FooY for True { type Y = i32; } impl FooY for False { type Y = !; } struct Foo&lt;Allow: FooY&gt; { x: i32, y: Allow::Y, }
Yeah, that does make sense, thanks! (Although not exactly an "optimization".)
Is there an RFC for cursors or something? I can find [this](https://internals.rust-lang.org/t/pseudo-rfc-cursors-reversible-iterators/386) from 2014 so.. kind of ancient in Rust time.
Looks like this could be done with [GADTs (Generalized algebraic datatypes)](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type) here! I've personally wanted them more than once in Rust: enum Allow { AB, B, } enum MyEnum&lt;const T: Allow&gt; { A : MyEnum&lt;T&gt;, B : MyEnum&lt;Allow::B&gt;, } You can also do nice stuff like: enum Expr&lt;T&gt; { Bool(bool) : Expr&lt;bool&gt;, Int(i32) : Expr&lt;i32&gt;, IntEqual(Box&lt;Expr&lt;i32&gt;&gt;, Box&lt;Expr&lt;i32&gt;&gt;) : Expr&lt;bool&gt;, BoolEqual(Box&lt;Expr&lt;bool&gt;&gt;, Box&lt;Expr&lt;bool&gt;&gt;) : Expr&lt;bool&gt;, } fn eval&lt;T&gt;(e: &amp;Expr&lt;T&gt;) -&gt; T { match *e { Expr::Bool(x) =&gt; x, Expr::Int(x) =&gt; x, Expr::IntEqual(ref x, ref y) =&gt; eval(&amp;**a) == eval(&amp;**b), Expr::BoolEqual(ref x, ref y) =&gt; eval(&amp;**a) == eval(&amp;**b), } } Note how we don't need to return a result here, because we are leveraging the type system to check things for us!
**Generalized algebraic data type** In functional programming, a generalized algebraic data type (GADT, also first-class phantom type, guarded recursive datatype, or equality-qualified type) is a generalization of parametric algebraic data types. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
There's also owning_ref
Everything in that C function happens on the stack / in registers. There's no heap involved. I really don't understand what you mean by saying C can't do stack-allocated arguments in this case.
Generally, if that would be just one enum, it would be probably fine, but I have ~30 of them and these generic parameters must be passed down through all of them.
I would argue that whether a string is owned or not is, much of the time, irrelevant to the meaning of the function. What about this kind of situation: struct Person { full_name: String // ... } impl Person { fn get_full_name(&amp;self) -&gt; &amp;str { self.full_name.str() } } But then later, you change the implementation: struct Person { first_name: String, last_name: String // ... } impl Person { fn get_full_name(&amp;self) -&gt; String { let mut result = String::new(); result.push_str(self.first_name); result.push(' '); result.push(self.last_name); result } } Has the `get_full_name` method changed in meaning?
Yes. Before it was a low cost (no allocations) function that returned a reference. The new version is code that logically tries to create what's assumed/estimated to be their full name. For many names, like mine, combining just two names is inaccurate. Similarly, making the same assumptions on the first or last name can be equally flawed. The new method is more akin to `assemble_approximate_full_name ` which should likely have a companion method `get_or_assemble_full_name` that returns a `Cow &lt;String&gt;`. My understanding is that, in Rust, allocating in a `get` function or method is frowned upon,-- given the cost and expectations)
&gt; Yes. Before it was a low cost (no allocations) function that returned a reference. In a lot of situations (I'd almost say most), the cost of a function that doesn't take more than a few milliseconds is essentially irrelevant anyway. The rest of your post is arguing against the parts of my post that are there for illustration, and are beside the point of the actual argument.
You might be able to statically link the runtime, though I'm not sure precisely how you would do that. In the meantime, I think installing the [VC++ Redistributable](https://www.microsoft.com/en-nz/download/details.aspx?id=48145) on the target machine should be sufficient? You may also be able to get away with just copy deploying `vcruntime.dll` alongside your executable.
Assuming allocations are still available, which isn't always the case with Rust. Even regarding the so-called illustratry examples. Code creating something from two parts is a different meaning from getting something that already exists. The meaning of those two methods*are different*
Wouldn't using the `gnu` target also work?
Box&lt;T&gt; == Unique&lt;T&gt; == NonZero&lt;*const T&gt; so I think it's always one pointer long?
Great article, I find I mostly agree. The only thing is, I think that the narrow sense that "explicit" is defined at the start can be used to reduce the use of the word completely. Technically speaking, everything is explicit, since presumably it is coded that way somewhere - maybe not your own code, but the library you are using, or even the standard library. I feel like the word "explicit" by itself is pretty meaningless unless you imply at least some amount of locality. But then again, maybe it's a good idea to taboo the word "explicit" altogether, if people cannot agree what it actually means. Explain what you want in a non-ambiguous way.
You probably want [static CRT linkage](https://github.com/rust-lang/rfcs/blob/master/text/1721-crt-static.md). That or build using the `gnu` toolchain on Windows, which bundles a static libc that itself links to `MSVCRT.dll` which is on every Windows ever. Well, modern ones, anyway.
I think this seems true mainly because Rust is explicit in that sense about so many things - specifically because it has no runtime and a very expressive type system. In many other languages, you just have no idea what the memory layout and set of valid values are for any type (or class, if you will).
Having these type of issues makes realize how lucky I have been learning Go... Rust should really default to producing single binaries.
This is worth it for the phrase "syntactic salt" alone. For some reason, the thought of *deliberate* syntactic salt never occurred to me as a thing before, although I'm sure I've argued for it before. Funny what giving things a name can do to how you look at it. :) One thing on the actual content: I don't have a name for this thought, either, but I think a useful property that gets conflated with explicitness is... "natural reading". Being able to derive some piece of information from the source code is one thing, but having that information be the natural, normal interpretation is something else. There are times I've argued for "explicitness" when what I *think* I was trying to get at was: "yes, you can work this out, but you'd have to put effort into doing so, and you might not realise you *need* to put that effort in at this specific spot in the source. I think it should be more explicit so that readers do not either miss what's going on, or misinterpret what's going on in favour of a more obvious/less obtuse/more commonly appropriate interpretation." Or, to put it in other words: what will people generally think the code is saying if they're skimming through it, as opposed to really meticulously parsing every part of the code?
"Natural reading" seems closely related to noisiness, maybe even just a more charitable expression of the same idea. The question is not whether the information can be derived from the source, but whether it pops out at you.
Go doesn't default to it necessarily either. For example, any Go program that uses network connectivity will be default link to libc when compiling for Linux. Of course, you can produce a truly static executable by twiddling compiler flags. 
Hmm, respectfully disagree. May be have an _option_ to do that, but bloating binaries with all possible options seems like an inefficient solution at best. 500mb executable for a simple command line app? Just write Java in that case. 
In think you need to use the musl target for full static linking. Or at least, that's the only way I've ever made it work.
"Use musl for full static linking" is a Linux thing. I haven't confirmed, but everyone keeps saying that the MinGW versions of the compiler (The Windows glibc targets) do full static linking for the same reason the MSVC targets don't. (What's likely to be installed as part of the "system libraries")
Yes, it did as it's not really a `get` anymore but a `create` or `eval` - the function is constructing and returning a new value on each call now. Correct way would be to put this either in constructor or under a lazy interface and still return a reference to the same stored value each time.
&gt; In a lot of situations (I'd almost say most), the cost of a function that doesn't take more than a few milliseconds is essentially irrelevant anyway. In a system programming language, it's very relevant.
I remember seeing a commit which enabled the static CRT linkage that Quxxy [talks about](https://www.reddit.com/r/rust/comments/7mif9i/how_to_compile_binaries_without_dependencies_on/dru9ogu/) for cargo, so I concur that it's probably what you want. TL;DR: See if setting the `RUSTFLAGS` environment variable to `-C target-feature=+crt-static` before calling `cargo build` fixes your problem.
Or, to translate it to something that we've all probably heard before, "Visual Basic sometimes outperforms hand-coded C because the guys who wrote the Visual Basic DLLs are better at writing efficient code than you are."
IMHO Go's default is more useful as it makes the least amount of assumptions by default. E.g. it doesn't assume some DLLs to exist and by extension it doesnt assume the target machine has internet access and can obtain and install the DLLs (corporate machines often dont have those on some machines for security reasons)
I'd call that "intuitive" vs. "unintuitive". 
Taking advantage of the holiday downtime to work on [Criterion.rs](https://github.com/japaric/criterion.rs), a statistics-driven benchmarking library. I've already made it stable-compatible, fixed some bugs and added a debug-output option, plus (with some help from generous contributors) replaced outdated dependencies and added better error handling. I'll probably do some internal refactoring and rework the command-line output next. If you're writing high-performance code or just want to measure the performance of the code you have, check it out and let me know what you think.
Go’s runtime does make a LOT of assumptions, and when they’re wrong, leads to very tough breakage: https://marcan.st/2017/12/debugging-an-evil-go-runtime-bug/ Not every OS truly supports fully static linkage. The question is, do you go with the platform, or do you try to force it? Both have downsides.
Only if T is Sized. That is, all of the things you say are one pointer when T is Sized, but two when it is not.
Many C libraries allow you to pass an extra "userdata" pointer to the callbacks they take. Ie, something like this: ```void register_callback(void (*cb)(u32 command, void *data, void *ctx), void *ctx)``` Are you sure yours doesn't? 
For me "explicit" means "opposite of implicit", where "implicit" behaviour is one derived by the compiler. None of the two terms imply any reason nor are they valuing, they just describe a feature, like when you say the sky is white or it is afternoon. "explicit is better than implicit" is surely not always the case, I agree with that. I think the example for the "burdensome" is not nice. By choosing "#[repr(boxed)]" as the example, the blog post seems to imply that everyone who opposes "#[repr(boxed)]" wants to make people who want to put stuff onto the heap avoid doing it. But there are a ton of other reasons to still be opposed, like e.g. additional complexity. For Go, complexity is a big deal. A better example would probably be pointer arithmetics where the Sub/Add sugar isn't enabled. You need to use the `offset` function manually. I'd say the main reason for this is so that it discourages you from using pointer arithmetics directly by being burdensome on purpose. If your language makes an unsafe version of an often used feature easier to use than the safe version, you'll make people feel bad for using the safe version and this is not a good ending. It's hard to categorize all explicit features of Rust into the categories the blog post lists. C++ member functions have a feature of "implicit this" where you don't have to type `this-&gt;sth` but can use `sth` directly. Rust lacks such a feature. Is that feature "manual" like the manual drop, or is it "explicit" as how the blog post defined the term? I'd say it's both.
Yes, I'm sure. The signature of the call back is what I showed above and the setter of the call back just expects a function pointer as an argument with said signature. I'm going with the Mutex static mentioned in another comment. Now I'm fighting string-keyed hashmaps. It's been a somewhat bumpy ride until now, but I'm powering through hoping it'll get better down the road.
`*const T` is not always `usize`. For example `*const Trait` is the full size of a trait object.
&gt; But there are a ton of other reasons to still be opposed, like e.g. additional complexity. Of course, I didn't mean to imply there were arguments against that feature that weren't about syntactic salt (every feature I discussed has other arguments for and against it).
Bravo. Thank you for articulating these thoughts. There is one misspelled “cewrtain” I noticed.
`Display` is not derivable, you have to implement it yourself.
Both? Writing a library in rust with the main intention being to use it in Python. 
Right, but that's just regular clever, not cheeky clever. ;)
I was more thinking about creating `Box&lt;str&gt;` from `&amp;str`. This can be interesting when reading input data that you want to keep around on the heap, but never change.
How about `&amp;s[("static_part ".len())..]`?
What exactly separates the static from the dynamic? If there are expected keywords which you want to strip out of the string, the term you're looking for is 'parsing'. The next question is how complicated is your format you want to get the dynamic part out of? If it's extremely simple, using regex might be a good choice for finding parts. If it's more complicated, a "parser combinator" library will make things easier. For simple patterns, this is a fairly comprehensive solution: extern crate regex; let input_string = "static_part dddddyyyynamic_part_______"; // create this once // if you aren't familiar with regex: // - `()` mark a section to be able to grab out of the string. // - `.*` matches any character let re = regex::Regex::new("static_part (.*)") .expect("expected this to be a valid regex"); // match the regex let result = re.captures(input_string) .expect("expected input string to match the described format"); // 0 = the whole string, 1 = the first () let dynamic_part = result.get(1) .expect("expected known regex to have 1 capture group") .as_str(); println!("{}", dynamic_part); (playground: https://play.rust-lang.org/?gist=87818cc3d9eb33279d61bb04035e20b8&amp;version=stable) If your format is more complicated than simple static parts and dynamic parts, using one of the parser at http://libs.rs/parsers/ can help.
Note that if Rust had better type level programming, you could also do nifty stuff like: #[derive(Copy, Clone)] enum ExprType { Bool, Int, } impl ExprType { fn repr(self) -&gt; type { match self { ExprType::Bool =&gt; bool, ExprType::Int =&gt; i32, } } } enum Expr : &lt;ExprType&gt; -&gt; type { Bool(bool) : Expr&lt;ExprType::Bool&gt;, Int(i32) : Expr&lt;ExprType::Int&gt;, IntEqual(Box&lt;Expr&lt;ExprType::Int&gt;&gt;, Box&lt;Expr&lt;ExprType::Int&gt;&gt;) : Expr&lt;ExprType::Bool&gt;, BoolEqual(Box&lt;Expr&lt;ExprType::Bool&gt;&gt;, Box&lt;Expr&lt;ExprType::Bool&gt;&gt;) : Expr&lt;ExprType::Bool&gt;, } fn eval&lt;const T: ExprType&gt;(e: &amp;Expr&lt;T&gt;) -&gt; T.repr() { match *e { Expr::Bool(x) =&gt; x, Expr::Int(x) =&gt; x, Expr::IntEqual(ref x, ref y) =&gt; eval(a) == eval(b), Expr::BoolEqual(ref x, ref y) =&gt; eval(a) == eval(b), } }
Is there some aspect of existing Rust that you think is *not* explicit in your sense?
Bleh. I would have expected this to work too: match producer() { Ok(()) =&gt; {} } This works though: pub enum Void {} impl Void { /// Eliminate a void value. We should never be able to run this code, /// so this can unify with any type T. fn elim&lt;T&gt;(&amp;self) -&gt; T { match *self {} } } fn producer () -&gt; Result&lt;(), Void&gt; { Ok(()) } fn main() { match producer() { Ok(()) =&gt; {} Err(x) =&gt; x.elim(), } } https://play.rust-lang.org/?gist=e717188e791cfd8cdf8b8c4943bde79d&amp;version=stable
Also, "familiar" vs. "unfamiliar"
This is a problem with the exhaustivness checker not pruning out all the impossible cases, as demonstrated in my other comment. This is a type checking problem, not a code gen problem.
The trouble with this is that the type is not parametric over that cfg, and therefore you can’t use both forms at the sane time in your code.
While I finally launched my little data visualization library [Gust](https://github.com/saresend/Gust), there's still a lot of features and other housework that I'd like to finish up. I'm also working on building an effective http stress testing tool, called [Fae!](https://github.com/saresend/Fae)
The most obvious ones (including the example) are the things we leave unspecified to enable optimizations. For example, its not explicit in the code (usually) whether a function will be a real function call or if it will be inlined.
Please show what coffee you've written to do this, along with inputs, actual outputs and expected outputs.
I would add panicking to this list as well, particularly in the "locality" sense of explicitness. The actual panic is of course explicit, and by convention, one layer up is typically explicit too (everyone knows that unwrap may panic when they see it). But after that, you don't really know what can panic unless you read the docs (hopefully) or the code itself. This isn't a trivial example either. There are people that would like to see panicking more explicit, but (IMO) the pervasiveness of the possibility of panicking makes this infeasible outside niche (albeit possibly important) use cases.
Very true. Here's what I came up with, using the same approach as /u/RReverser... it's pretty clunky with structs. struct Yep&lt;T&gt;(T); enum Nope {} trait Allowed&lt;T&gt; {} impl&lt;T&gt; Allowed&lt;T&gt; for Yep&lt;T&gt; {} impl&lt;T&gt; Allowed&lt;T&gt; for Nope {} struct Foo&lt;Bar: Allowed&lt;i32&gt;&gt; { bar: Bar, baz: i32, } 
Fabulous post--I love discussions of programming languages through an HCI lens. Your definition of whether something is explicit is essentially whether it can be determined through static analysis (presumably: variable usage and dataflow, lifetimes, and types). I think this is a good definition, in particular because it points to an onus to develop better IDE support for viewing statically analyzable information about a program that would be difficult for a user to infer themselves. If something could be determined just by looking at the source code, then that information should be available to the user. This is why type-inferenced languages are difficult to read without proper IDE support, for example to deduce the type of an un-annotated variable.
How to you "generate" unique tests name based on tested function and its arguments? Please see my detailed descriptions in the code, thank you for your time! /// filename: tests/lib.rs #![feature(test)] // there are two functions: foo() and bar() fn foo(n: u32) -&gt; u32 { n } fn bar(n: u32) -&gt; u32 { n } #[cfg(test)] mod test { use super::*; // I'd like to write test cases for both of them. I can write four tests to test // foo(1), bar(1), foo(2) and bar(2) as below. #[test] fn foo_1() { assert_eq!(1, foo(1)); } #[test] fn bar_1() { assert_eq!(1, bar(1)); } #[test] fn foo_2() { assert_eq!(2, foo(2)); } #[test] fn bar_2() { assert_eq!(2, bar(2)); } // But the above tests are too verbose. I'd like to write a macro to reduce // duplicate code. However, the following macro build failed. I googled and // found currently Rust didn't support create new ident in macros: // - Tracking issue for `concat_idents`: https://github.com/rust-lang/rust/issues/29599 // - Eager expansion of macros: https://github.com/rust-lang/rfcs/pull/1628 // // My question is how do you guys write tests elegantly in such situation? // How to you "generate" unique tests name based on tested functions and its // arguments? Thanks! macro_rules! test_function_with_n { ($func:ident, $n:expr) =&gt; { #[test] fn $func_$n { assert_eq!($n, $func($n)); } } } test_function_with_n!(foo, 1); test_function_with_n!(bar, 1); test_function_with_n!(foo, 2); test_function_with_n!(bar, 3); } 
thx
I agree that it must include a locality parameter. I agree with this article, but I think, outside of locality, it constructs mostly strawman arguments. I haven't seen anyone use "explicit" to mean noisy or burdensome. I've pretty much only seen it used to describe an element of locality. The more places you have to look to understand one snippet of code, the less explicit.
The examples you give are really examples of the locality/ease-of-use tradeoff. Using `offset` instead of operators means you know where it's defined (where the main struct implementation is), while a `+` overload means you need to look everywhere in scope for the trait implementation, which might not exist. In both cases, static analysis can reveal what you're looking for, but my definition of explicitness is basically that of necessary locality. Side-effects are a great example of non-local code. You know it interacts with some code... somewhere. But you don't know where. So you have to look through every definition of every function you use for side-effects (theoretically). Exceptions are another good example of this.
This is awesome! Just want so my code improvement fn gen_next_block(&amp;mut self, data: Vec&lt;u8&gt;) -&gt; &amp;Block { let prev_hash:Sha256Hash; let next_index:u64; { let prev_block = self.latest_block(); prev_hash = prev_block.hash(); next_index = prev_block.index() + 1; } let next_timestamp: u64 = now_in_millis(); let next_hash = Block::calc_hash(next_index, next_timestamp, &amp;data, prev_hash).unwrap(); let new_block = Block::new(next_index, next_timestamp,data, next_hash, prev_hash ); { self.add_block(new_block); } { self.broadcast_latest(); } return self.latest_block(); } Becomes fn gen_next_block(&amp;mut self, data: Vec&lt;u8&gt;) -&gt; &amp;Block { let prev_block = self.latest_block(); let next_index = prev_block.index() + 1; let next_timestamp: u64 = now_in_millis(); let next_hash = Block::calc_hash(next_index, next_timestamp, &amp;data, prev_block.hash()).unwrap(); let new_block = Block::new(next_index, next_timestamp,data, next_hash, prev_block.hash() ); self.add_block(new_block); self.broadcast_latest(); return self.latest_block(); }
It's quite simply not possible. `concat_idents` is unusable and attempts to fix it (like the eager expansion RFC you linked) have been postponed with vague promises of "eh, we'll do it in macros 2.0" but no actual plan, which is frustrating.
[@Tatrics's latest tweet](https://i.imgur.com/lxMgs2m.jpg) [@Tatrics on Twitter](https://twitter.com/Tatrics) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
[extend_from_slice does not return the Vec](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.extend_from_slice). It returns nothing, AKA `()`. Instead, it modifies the Vec in place.
Pass in the concatenated idents works. Thank you! 
I see. However it does not make so much sense to me. In my mind I am creating a vector that happens to be modified and then bind to my variable. I do not understand why the last modification should prevail. 
&gt; In my mind I am creating a vector that happens to be modified and then bound to my variable. The `Vec` is not bound to the variable. The expression evaluates to `()`, which is bound to the variable, while the `Vec` is dropped because it is not used.
Ok, I am beginning to understand thanks! But is there a one line way to create a vector from two vectors then ?
`let c = a.to_vec().extend_from_slice(&amp;b);` Perhaps it would help to break this expression down. let c = { let temp = a.to_vec(); // create a copy of a as a new Vec let ret = temp.extend_from_slice(&amp;b); // modify `temp`, but doesn't return anything ret // return 'nothing' }; extend_from_slice() is simply not meant to be used in this way.
&gt; But is there a one line way to create a vector from two vectors then ? `let x: Vec&lt;_&gt; = a.concat(b).collect();`
I think another perhaps separate tradeoff/aspect of natural reading is for beginners. For example abbreviations and sigils can be nicer for experienced readers and writers but a beginner has to learn them as opposed to being able to guess.
Maybe ICPC needs to change?
It depends on how the code is written. I wrote collatz_length like this: pub fn collatz_length(mut i: u16) -&gt; u16 { let mut l = 1; while i != 1 { if i % 2 == 1 { i = 3 * i + 1; l += 1; } if i % 2 == 0 { i = i / 2; l += 1; } } l } An input of 106239 gets me ~120 ns, instead of the ~400 ns I was getting with the way the rust code was written in this post. I do like seeing that functional languages can keep pace though.
I don't see why. It's a sport.
What you refer to at the end is in the article, as local. That is if I see a line that looks like: foo.bar(foo.baz()); Is there a lifetime issue? Well it all depends, what does `bar` and `baz` take foo as. Say that you had to borrow explicitly, so then you could write all the valid interpretations foo.bar(foo.baz()); &amp;foo.bar(foo.baz()); &amp;mut foo.bar(foo.baz()); foo.bar(&amp;foo.baz()); &amp;foo.bar(&amp;foo.baz()); &amp;mut foo.bar(&amp;foo.baz()); foo.bar(&amp;mut foo.baz()); &amp;foo.bar(&amp;mut foo.baz()); &amp;mut foo.bar(&amp;mut foo.baz()); With nll some should compile, but done clearly are absurd things moving a value and then trying to use it after move. Still the verbosity doesn't justify this advantage of being able to see for yourself because the compiler can very quickly explain if there's a problem and give you the context you need to understand. Moreover in order to know which call you'd need to use, you'd have to look at the method in the impl, which means you'd have to look it up when it's wrong and *also when it's right* unlike the non local solution that isn't as redundant and therefore avoids the hassle.
My preferred way is this: let f = a.iter().chain(b.iter()).cloned().collect::&lt;Vec&lt;_&gt;&gt;(); This works via iterators, and is a bit longer, but it is going to be slightly faster than other methods (since it can know &amp; preallocate the full length), and it succinctly states what's happening.
There is a quote, of course: "The only intuitive interface is the nipple". The thing we call intuition is very much shaped by previous experience. From everything-is-on-the-heap languages, the value/reference distinction is not intuitive.
I agree on whole, but I still think intuitiveness is essentially what /u/Quxxy is describing by "natural reading". Something is intuitive if you are likely to get the right answer on your first try, or after not much reasoning. That said, I also think there's more to intuitiveness than "just" previous experience. It's also about being consistent within the language, so you can quickly aquire "previous experience", having a good "short explanation" that allows you to work with a concept without fully understanding the intricacies, and having the "full explanation" not be surprising and obtuse once you've learned the short version. That stuff is influenced by past experience, but there's some value in judging it separate from experience too.
Beginners struggle to see important signal in noise. They will get full types in error messages like `std::vec::Vec&lt;&amp;std::string::String&gt;` and not see the `&amp;` that's causing their problem. It's explicit but not so visible.
&gt; man nipple Wait shit
Totally. It's very good that Rust is relatively free of magic - ('explicit' again.) Choosing the short explanation to present is very important. Naturally, it gets hard to remember what Rust first looked like to the untrained eye - it did appear quite noisy at first. Deep familiarity comes from typing, not from reading.
I like the post and especially the language critique in it, but would like to say a word or two about unhelpful comments and language. I've grown to be okay with these comments. Any critique of the use of English language in international projects has to live with the fact that many participants don't speak English as a first language. Even when speakers seem fluent, they may lack vocabulary and ways to phrase things. Also, language school in many countries doesn't prepare for conversational situations (for example, in my french class, people couldn't book a hotel room after _8 years_ of learning the language). I'd prefer to get rough feedback in that case, instead of none. Asking feedback to be complex puts an extraneous burden on those that don't have the proper language education. Another thing that comes into play here is that "explicitness over implicitness" was and is also used to promote Rust by some community members as a phrase (me included). It's catchy. I tried talking about "better local reasoning", but that doesn't fit an elevator pitch. People pick that phrasing because it's what they know early on. It's the "principle of least astonishment" of the Rust world. Blog posts like this help tremendously with that, by teaching people a bit of English :). Making the above situation clear in my mind helped me tremendously in dealing with the aggravation, though.
One important aspect of explicitness is duplication, which is a reliability feature pretty much necessary for detection of accidental errors. When duplication is there, you can make mistake at point 1 and it will create a mismatch and compiler error at point 2, thus detecting the mistake. For example the pair "define name + use name" as opposed to just creating a [definition on use](https://github.com/rust-lang/rfcs/blob/master/text/2115-argument-lifetimes.md). If the use site or definition site contain, for example, a typo, it will be caught and won't silently compile. (The linked RFC provides other error detection heuristics though.) Another example is explicit integer conversions - if you use a wrong integer type in one one side, this will be detected on the other side and the type can be adjusted. 
Create a file called `.cargo\config` with the following contents: [target.x86_64-pc-windows-msvc] rustflags = ["-Ctarget-feature=+crt-static"] [target.i686-pc-windows-msvc] rustflags = ["-Ctarget-feature=+crt-static"] `cargo build` will now produce binaries that do not depend on the CRT and can easily be distributed without having to install anything on the target machine. I do this for all my projects and also think that this should be the default.
Excellent blog post, I think you nailed it. The suggestions presented in the conclusion is precisely what I would like to see more of too. The usage of "explicit over implicit" as an argument is an example of what I would like to call "Reasoning by mantra chanting" or "Parrot based reasoning". I don't think this is in any way unique to discussions relating to Rust but rather a common human behavior in general, that should be questioned.
Yes, I see. Thank you. To be clear: `sizeof(*const T)` is 16 (two pointer long), if T is Unsized type (such as `[T]`, `str`).
I like the article a lot, but disagree with the definition of explicit. For example your demonstration of explicit can be described as other things. Structs member definitions are local, in that they define what they contain and not (think of python members, were members are defined when they are first set) where the struct is named. The references are a manual definition: you not only have to state that it's a reference, but you also have to specify were the lifetimes come through, and pipe them through generics. I could go on but I still feel that it doesn't cover explicit clear enough. Or maybe it does and I am misunderstanding (when in reality I might completely agree). I feel that explicit is orthogonal to the cases, not an alternative. That is adding syntactic salt, or making something noisier or more burdensome might make things more explicit, but it might also make things less explicit. My definition of explicit, what I at least believe people want to define, comes from Linguistics itself. Specifically this quote I think covers it: &gt; Languages differ essentially in what they must convey and not in what they may convey. (Roman Jakobson) Basically what is explicit about a language is what it *must convey*. The idea is that all turing complete languages can express any idea from another language, there is no mathematical difference. The core difference is the things that *must* be conveyed on the code. So you can't make a language were you can't describe something (even toxic code, such as memory leaks or such). You can make languages were you have to explicitly declare things. For example Rust requires that you define lifetimes in structures that contain references, this means that when you describe a concrete type you have to define you also have to specify any extra lifetime constraints that limit it. Then there's things that are implicit. Implicit things can be explicitly stated easily or with difficulty, but they are not *required* to be defined. This is why you have to think of programming languages in the contexts they are used on. The question is: why should you always, whenever you write or read a line of code, have to be aware of something? Again lets look at human languages: in spanish or japanese when you refer to someone else the way you talk implies how you rank compared to them, there's a way to talk with reverence and respect, and other for more casual talk. When you talk to someone you always have to be aware of how you rank compared to them. In chinese when you talk about your aunt or uncle, you have to specify if they are your father's or mother's sibling, and also if they are older or younger than your parent, the language requires you to always be aware of your full family tree. In Java you have to be aware about what class something belongs to, you're always are aware of classes (even if not objects!). In Go you can only code with either explicit data types or implicit interfaces that expose functionality, Go requires you to always be aware of the specific datatype (interfaces are vtables and are well known) you are using. In Rust you are always aware about the lifetime of something, and explicitly state when you do something that doesn't (by borrowing). So when we want to make something explicit the question should be: why should developers be aware of this all the time they touch this feature? Why should they always care 100% of the time? Why does this matter more than other things that are not explicit? And this brings us to the point. Implicit is not as bad. Implicit is forward-compatible. Implicit sometimes is faster, such as member order in memory. Implicit sometimes is clearer such as lifetime elision (not needing to define lifetimes that have no importance to the code, distracting from what matters). Sometimes it's better to not have to think of everything.
Yes, thank you!
I think for most people it's less about explicit vs. implicit and more about the mental models. I would argue that everyone prefers implicit as along as he has a good mental model of the operation, if the implicit behaviour is conceptionally sane, because then you somehow intuitively get the behavior with less intellectual burden and less noise on the information side. The art is to decide which operation should still be explicit, because on one side you don't want to create an expert only language and on the other there's also a limit how much implicit behavior people can handle. The important aspects to decide between explicit and implicit behavior are how much noise a behavior creates, how much it's a fundamental part of the language, how easy a reader might get a wrong meaning or how easy it might provoke misbehavior. I also think that `?` operator is somehow the perfect compromise. It's explicit without being noisy. Error handling is a fundamental part of the language, so having a bit of a higher learning cost is acceptable and one can't really get any misbehavior, because at the end there's still the compiler catching type mismatches. 
Speaking of pass by reference, I think it is unintuitive. Let's say you have a function that takes in a doggo and a park and does some fancy astrology voodoo to predict whether the dog likes the park. Let's say the return value of this functions is boolean: true or false. I should never have to worry about it changing the state of my dog or my park outside the method. I guess rust doesn't have this problem because immutable by default? How does this work?
I just released bui-backend 0.2.1. The big change here is a new demo frontend written in Rust web assembly (wasm). This lets you ship an application written in Rust as a single file with a browser-based UI.
I don't have anything to say about the article (I took a vaguely similar trajectory - I learned Pascal and C in school, moved on to Python and abandoned low-level stuff, only to move on to Rust because I wanted native compilation that didn't make me feel like I was constantly walking a minefield of my own design) but I do want to reply to the comments. Hopefully you'll direct them here. &gt; Unfortunately, I have to support armel (older ARM processors) for still some years to come. To my knowledge, Rust does not support such CPUs This depends what you mean by "support" - there's no nice pre-compiled toolchain to use, sure, but LLVM as a backend means Rust is already a highly versatile cross-compiler. You can run `rustc --print target-list` to see what Rust supports, and `rustc --target &lt;one of them&gt; --print target-cpus` to see which CPUs within that target it supports. You can get even finer-grained control by writing and supplying a target file, to which you can supply any `llvm-target` LLVM understands; [Xargo](https://github.com/japaric/xargo) helps by compiling and caching libcore and (at your request) other parts of the Rust standard library. If I and [Theo Belaire](http://csclub.uwaterloo.ca/%7Etbelaire/blog/) can program the Game Boy Advance like this, I don't think whatever platforms you have to support will be a problem. &gt; I feel I cannot do anything useful without the help of Rust std library. don't get me wrong Rust std library is great but for example i want to implement a simple linked list then i must use Box. [Linked lists aren't simple.](https://github.com/rust-unofficial/too-many-lists) They're also not very interesting to implement, so Rust [gives you one](https://doc.rust-lang.org/std/collections/struct.LinkedList.html).
Very neat
Nice.
Nitpicking: members in a `struct` aren't guaranteed to be allocated on the stack vs heap; it's more a direct vs indirect distinction, where a variable takes the (direct) allocation method of its parent (which could be stack of heap), while `Box` or `Vec` stores it content indirectly, always on the heap.
O(1) for space, which is ideal. Obviously, running statistics requires at least O(n) time.
I made this short script to help with setting up new dev's env: (it's a bit more complicated than most people need, but we had to support Win2k3) :: download either https://download.microsoft.com/download/A/6/A/A6AC035D-DA3F-4F0C-ADA4-37C8E5D34E3D/winsdk_web.exe :: or https://www.microsoft.com/en-us/download/details.aspx?id=8442 (GRMSDKX_EN_DVD.iso - strangely x64 version, because x86 will fail to install) :: install compilers, headers and x86 libraries :: download rustup-init.exe from https://win.rustup.rs/ set RUSTFLAGS=-Ctarget-feature=+crt-static -Copt-level=s set TRIPLE=i686-pc-windows-msvc "%~dp0build-prerequisites\rustup-init.exe" --default-host %TRIPLE% --default-toolchain nightly -y call "C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\setenv.cmd" /release /x86 /xp setlocal enableextensions md "%~dp0build\binaries\%TRIPLE%" cargo +nightly-%TRIPLE% build --release --target=%TRIPLE% --manifest-path "%~dp0nsdc\Cargo.toml" &amp;&amp; ^ copy "%~dp0nsdc\target\%TRIPLE%\release\nsdc.exe" "%~dp0build\binaries\%TRIPLE%" &amp;&amp; ^ "%~dp0build-prerequisites\strip" "%~dp0build\binaries\%TRIPLE%\nsdc.exe" 
The section on manual has the following comment: &gt; // Must explicitly call this, or the string will be leaked: Which seems to suggest that you do think of the manual call as more 'explicit' or you wouldn't have written the comment that way. Having something being determinable from the source is a great feature, but I don't think it maps exactly to what people generally mean when they say explicit. If I give an instruction and something else will happen as a consequence of that, that other thing is 'implicit', regardless of whether it can be deterministically inferred.
I love this post. Defining precise terminology helps us communicate better. An interesting exercise to do here would be to look at various kinds of straw man proposals of "implicitness" and see where they fall. These are just random ideas, not necessarily things I feel we should actually be doing. - C++ style `self`-implicitness in methods - "not local", kind of - Making it so that `foo.bar(x)` will work even if `bar()` takes an `&amp;x`. The call still counts as a move. - Noisy? This one is interesting and might be a different kind of explicitness - The same proposal, but the call no longer counts as a move. - Hmm, this one is interesting as well. It's a mix of nonlocal and noisy, and distinctly different from the previous one. - Making elision _always_ work, by choosing some sensible defaults (output params are unbounded, or output params are bound by all input params) - This doesn't really fit in the categories, but that might be because this isn't just a matter of implicitness, it's making a very deliberate and opinionated choice that will very often be wrong - Auto-splatting/unsplatting tuples, i.e. `foo(1,2)` is the same as `foo((1,2))` if it must be that type. This means `Some(1, 2)` will work. - Noisy? More examples? Thoughts on my categorizations?
It's a pretty common use of terminology to use "allocated on the stack" vs "allocated on the heap" to mean "could be allocated on the stack" vs "must be allocated on the heap".
I suppose I found the "I know all of this data will be allocated on the stack" a bit strong.
Yeah my current use-case requires an easy to merge distributed data aggregation so it works perfectly. Porting some code from python to rust to handle distributions aswell with O(1) Space Complexity if you are interested (based on successive binning)
You don't need to worry about what to put in the `Err(x)` branch, as it will be never reached anyway, so I personally prefer putting `Err(_) =&gt; unreachable!()` there to help the future reader of my code.
Yup, exactly.
I am not sure if duplication as a tool to avoid ambiguity or accident is about explicitness; I see it more as a kind of "error correcting code" thing. I always hesitate between terseness and "ecc" duplication in syntactic debates; both are valuable.
How to ignore errors in `Stream`s? I use `websocket` like this: let server = server.incoming() .map_err(|InvalidConnection { error, .. }| error) .for_each(move |(upgrade, addr)| { // ... }); handle.spawn(server .map_err(move |e| info!("Error in WS: '{:?}'", e)) .map(move |_| info!("WS: Finished."))); Sometimes an error [happens](https://github.com/cyderize/rust-websocket/blob/874bba4141d651e9dce2c680bc3cccc523a6c2b3/src/server/upgrade/async.rs#L227 ) ("Connection dropped before handshake could be read"). The problem is, that the whole Websocket-Server stops. I just want to ignore the error/client to be able to handle other clients. How can I do this? Can I just ignore an error within a `Stream`? 
Oh yeah, nesting value into the struct sounds like a good idea too. Although for enums it could become way too clunky to match against - currently I can do `MyEnum::MyVariant(_ /* skipping condition */, a, b, c) =&gt; { ... }`, while with `Yep&lt;T&gt;` I would have to nest all of these values into both type param and enum variant?
&gt; The section on 'explicit is not manual' has the following comment: &gt; &gt; // Must explicitly call this, or the string will be leaked: drops are implicit. You could have them mandatory, yet manual (i.e. explicit), by requiring the user to call either `drop` or `forget` at the end of each function. Not that I'd want that, eh :-) But more generally, what boats calls "noise" may be someone else's signal.
&gt; Linked lists aren't simple. They're also not very interesting to implement, so Rust gives you one. I guess by simple he means not double-linked list… But in any case, I mostly surprised by the fact that one would not one to reach to Box? AFAIK, elements need to be heap allocated… C(++) provides `malloc` / `new` (or any make_*smartptr* ) for that purpose, Rust provides `Box`. Is there any other way around this in C ?
&gt; This lets you ship an application written in Rust as a single file with a browser-based UI. That's cool!
&gt; but I don't think it maps exactly to what people generally mean when they say explicit. Of course not! As I said in the introduction, the point isn't that people are *wrong* when they say something isn't explicit, but that it would be more productive if we could break up the space of explicitness into more fine-grained concepts. The narrative conceit that "explicit is not X" may muddle this point.
Isn’t libc practically universally available, while vcruntime is literally the opposite? Seems like a disingenuous reply or at least misleading.
&gt; Another thing that comes into play here is that "explicitness over implicitness" was and is also used to promote Rust by some community members as a phrase (me included) ... It's the "principle of least astonishment" of the Rust world. This is an unfortunate situation because "Explicit is better than implicit" is from the Zen of Python and I don't know that it has ever been considered a core design tenet of the language. It seems to contradict this stated "non-goal," which has been in the FAQ for as long as I've known about Rust: &gt; We do not intend to be 100% static, 100% safe, 100% reflective, or too dogmatic in any other sense. Trade-offs exist.
&gt; Thoughts on my categorizations? All of these features can be discussed in terms of how they impact the noise, locality, burden, etc of different kinds of queries you might want to make about your code. You usually can't categorize features into different sorts of explicit/implicit dichotomies *per se*, though often one or two factors will predominate.
libc is indeed universally available on Linux systems, but the version you compiled your Go program with might not be.
For unsupported platforms, https://github.com/thepowersgang/mrustc is a possible alternative. It compiles Rust to C, and is now able to compile `rustc`, meaning it is starting to mature. You still need `rustc` for its borrow checker, `mrustc` currently skips that step and expects that there are no lifetime errors.
what do you mean linked lists are't simple? implementing a singly linkedlist is compsci 101
You could define a new trait, and implement for Vec: [clicky](https://play.rust-lang.org/?gist=51555fbe9a92def88929448dcb838fe4&amp;version=stable).
&gt; what do you mean linked lists are't simple? Implementing a linked list which will please Rust's compile-time checks isn't as simple as people expect.
But it isn't *just* a sport. It also trains 'the best coders' who have a vested interest in the broader applicability of their skills. Of the ICPC/C++ archetypes I have come across, they will defend to the death the suitability and applicability of that language. You tell me whar a man gits his corn pone, en I'll tell you what his 'pinions is.
Doesn't seem like a blocker. Have an ICPC crate the pulls those in. Arbitrary distinctions shouldn't keep a language out.
I really don't think you should worry about it taking two lines versus one. The performance of your program isn't determined by how many lines of code it uses, and using two lines of code here doesn't hurt the readability of the code... it might even help make the code more readable.
I wasn't aware ICPC bills itself as such. Yes, I am well aware of the harmful effects this "competitive coding essentialism" has on students; I've seen way too many kids who think this is the core of programming rather than one important facet (which tends to be overrepresented in interviews). I've been called "not a coder" because I don't participate in this sport. I consider it a sport. I think ICPC considers itself a sport as well, though I could be wrong. I am very aware and annoyed by the hordes of students who feel that it is the essence of CS.
&gt; C++ style self-implicitness in methods NO. GOD. PLEASE NO. This is one of the misfeatures of C++ IMO - if you see an `x = 5` in a function - you don't know if it means `this-&gt;x = 5` or if `x` is a local variable declared a few hundred lines earlier. It's makes programs harder to debug and to reason about. You basically have to reference the header file to be sure. Extra points if the class has a field `x` and the function has a local variable `x` and you have to look which name one shadows which.
You have a typo in the code: for substring in substring { should be: for substring in substrings {
Unfortunately, changing to only 16 bits breaks the code on the test inputs. The maximum values of i achieved for the three benchmark numbers each will overflow a u16. 2223: max_i = 250504 10971: max_i = 975400 106239: max_i = 104674192
I don't see that as a huge problem. It is an okay first approximation and that's all it is. Rust, after all, is a language that makes a lot of things that were _implicit_ before _explicit_. "Why do I have to note that down explicitely?" is a standard beginner question. When given the choice between verbosity and letting information slide, Rust has always erred towards the former, only breaking it with good reason. Sure, as the post mentions, this has boundaries to where things are undefined. Also, it also point out right that the term is extremely fuzzy and needs to be filled with more complex meaning once you start discussing. It's the same as with "safe". We say Rust is "safe" and next up, we have someone who assumed that memory leaks are not safe.
`unreachable!()` doesn't really capture the same semantics - it's for places where you can't prove to the type checker that the code path is unreachable, but you want to ensure that if it _is_ reached, you blow up. In this case we can (via the `elim` method) eliminate the `Void`, so there's no need to fudge it with a panic.
Are you sure `wasm32-unknown-unknown` uses jemalloc? The target doesn't list an allocator and - to my knowledge - in this case the systems allocator is used. Generally, jemalloc is used for all desktop/server environments.
&gt; Are you sure wasm32-unknown-unknown uses jemalloc? No, I'm not sure. I assumed `jemalloc` was the default. Thank you! As far as I've been able to figure out, WebAssembly only provides [an initial `(memory ...)` allocation and `grow_memory`](https://stackoverflow.com/questions/43543846/webassembly-growing-memory-and-importing-malloc). So Rust must be getting an allocator from somewhere, maybe from a C runtime of some sort? Let me dig around and see if I can figure this out.
I love the word 'spatting' but it's the opposite of noisy - it's too quiet. Yet another implicit bit of syntactical sugar. I may have written `Some(1,2)` before but was happy to be corrected. 
&gt; so there's no need to fudge it with a panic It really doesn't matter, since the contents of the match (including the panic) won't appear in even non-optimised generated code, so putting `unreachable!()` there is as good as `{}` (if you don't need a return) or your `.elim()`, the only difference is clarity for the future code reader.
You misunderstand me, I've put forth examples of implicitness and categorized the explicitness that they replace. Splatting isn't noisy, the thing it replaces is.
Uh, I know, I'm not proposing this. I explicitly said these were not actually things I necessarily felt we would be doing to avoid folks bickering over the actual ideas.
Ah, this helps!
Oh, sorry, didn't see that.
This was the guy's point! That even simple stuff to do is difficult in rust. It is simple in every other language.
&amp;thing is a read only reference; &amp;mut thing is a read/write reference &amp;mut can only be created by typing the word mut at least twice; once when you make the original binding, once when you make the reference to pass into a borrowing function Methods which take &amp;mut self implicitly only require typing mut once, at the original binding, because method syntax implicitly handles the self parameter and wraps all the mechanics under the . operator.
Echoing everyone else that this is a great post. A lot if people are saying "yes, and..." which shows how much it got the conversation going. My addition is that another aspect is discoverability vs terseness. A big topic imo in `try!` vs `?` was that `?` is hard to learn about (e.g. cant search) while `try!` is just a macro so its trivialy easy to understand learn about. Rust went through a glyph happy phase. Thankfully (imo) it was rejected. But not dogmatically.
Other languages also let you do dangerous things like dereference raw pointers without putting big warning stickers on it and writing a paragraph of documentation about why dereferencing this pointer is totally okay, promise. That doesn't make them right.
I don't think that was the point. The point was that (for him) the incredible difficulty in even writing simple, run-of-the-mill data structures in Rust wasn't worth it.
Personally I've long been of the opinion that tuples should be usable directly at function call sites if they match the type of the call, and be splattable. If I have a function that takes two arguments of type A and B, I should be able to call that finding with a tuple of (A, B); conversely, if I have a function that takes a tuple (A, B), that function should (in the source) take an argument list of the splatted tuple. &gt; myrr wtf Sometimes I like assembling my call parameters from various choices ahead of time in a single binding, and sometimes the glyph `Ok(())` annoys the hell out of me Are we using `%` for anything because I'd be down for an explicit splat operator
 for substring in substring { let n = substring.parse().unwrap(); numbers.push(n); } Shouldn't this be for substring in substrings { with an 's'?
Sorry, knee-jerk response to what appeared to be a feature list. But is `Some((1,2))` noisy or just an explicit consequence of the type system?
&gt; I think it is often very good to be explicit in the sense about many things. There’s always a trade off in choosing to ensure that something is explicit like this (for example, the compiler can’t silently decide to allocate data in the heap instead of the stack, or vice versa, as an optimization). But it can sometimes decide to allocate data on the stack instead of the heap! LLVM understands malloc (I can only find [this](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53082#c0) about it).
The `wasm32-unknown-unknown` target uses a re-implementation of [`dlmalloc`](ftp://g.oswego.edu/pub/misc/malloc.c), which you can see in [dlmalloc-rs](https://github.com/alexcrichton/dlmalloc-rs/blob/master/src/dlmalloc.rs). It is comparable small, but might indeed be too much for simple wasm use cases.
It uses `dlmalloc` not `jemalloc`.
&gt; It is simple in every other language. It's simple to get something that works okay. It's not simple to get something that works well.
I agree that syntactic salt is bad, for heap allocations or type conversions. But: &gt; I know what fields any of these structs could have (unlike some dynamic languages). Unless the dynamic languages interpret their source nondeterministically, they are equally explicit. If interpretation/compilation happens deterministically, it's totally explicit! The difference is only in the amount of info that's not immediately/locally visible. So even the most magic is actually explicit if it's deterministic magic! That's the real conclusion from this post! (Following the author's logic.)
Cool. So, I have little experience with data science specifically, but as for extending Python, I'd encourage you to look at milksnake: https://blog.sentry.io/2017/11/14/evolving-our-rust-with-milksnake
It can be both.
This does get murkier when you add generics to the mix (so do the existing bits of noise-reducing coercions like deref coercions, though). `%` is modulo
This is a common problem in debates(not just technical ones). We First debate on whether some general concept is good or bad, and only then we try to agree on the definition of that concept...
Question: How can I use `cos` and `sin` functions with `#![no_std]` (since sin and cos are defined in std and use LLVM intrinsics)? I was experimenting with WASM to port a projection library (with lots of heavy math) and the general problem here is size. I got it down to 16KB, but this is still a lot, considering that the original code is roughly 2KB in JS. Now, I only need `Box&lt;&gt;`, `Vec&lt;&gt;` and `f64::PI`, I don't need anything else. So I should be able to get a very low size. I tried cutting out the standard library, but if I do that, I can't use `cos()` and `floor`, and so on, because they are defined in libstd. Does anyone who does embedded development never use cosine functions or am I the exception here? Is there an alternative library?
A nice high-level Rust API for libhydrogen would be fantastic. Right now, there is only a `-sys` crate: https://github.com/jedisct1/rust-libhydrogen-sys
Of course, some say that if a language needs special IDE support, then that's a problem. But this seems uncessarily purist. IDE support helps with Rust because the exact types are (at first) hard for humans to infer. Ironically, IDEs also help with something hopelessly explicit like Java because it makes it easy to pull in all those named types. I definitely find explicit typing very _noisy_ so I prefer Rust. However, Rust still has ceremonies, like making up constructors for structs. I have no problem reading them, but an IDE can help by _generating them_. Verbose is fine for reading, tends to slow down typing. (I know that many prefer compile-time generation of boilerplate). 
Linked list is not the only one. Even creating a simple thread-safe stack (which usually is done by using atomic CMPX in a loop) has to resort to the unsafe code. From tokio-curl: https://github.com/tokio-rs/tokio-curl/blob/master/src/stack.rs 
There is an IRC server. Some very helpfull people can be found there. Check the sidebar (or ctrl-f IRC)
Go back to writing docs and crying about gender, the real programmers are talking. 
Great work! What alternatives other than electron do we have for making it standalone? Only CEF and Webkit? When will servo be embeddable? Last week I built the webkit dlls for 32bit and 64bit windows (cairo port, not depending on apple). My plan was to use it as frontend for VST audio plugins with Rust in the backend and PureScript in the frontend. But the webkit dll has a weird COM API where all functionality is provided by one function that you pass function IDs to :( Apparently there are some other ports of webkit, e.g. for Qt but I'm not sure which of those would be the least work to integrate with Rust, has anyone else already embedded webkit in a Rust application?
Actually, `dlmalloc` looks pretty reasonable, in terms of code size. It's about 1,500 lines with tons of assertions and plenty of whitespace. It would certainly be possible to write a smaller allocator, but at that point, you'd probably also want to sacrifice most of the standard library.
You have to resort to unsafe code in other languages, too. *All* code in C or C++ is what Rust considers to be unsafe. All the `unsafe` keyword does is mark sections of code where you have to be *as careful as when writing C*. That means that if you trust yourself in doing those things in C and understanding the semantics, you can go ahead and do the same in Rust by simply adding `unsafe`. If you feel dirty doing that because you feel like you need the Rust compiler to hold your hand and check lifetimes or make sure you don't have any data races, you shouldn't be using C (or C++) in the first place. 
The QT webkit is only on QT 4, so I probably wouldn't.
[removed]
I hate to say it, but I hardly think that this is a valid point. Once you go low enough on the tech stack, reaching for `unsafe` becomes a necessity -- otherwise you simply could not implement some things! `unsafe` isn't evil -- it just means you should consider carefully whether you need it or not!
I'd say the same, and also if you're always going to return a static string you can use &amp;str for that too.
Depends on what your function does. - Does it select or search for part of a `str`? You probably want `fn(&amp;'a AsRef&lt;str&gt;, ...) -&gt; &amp;'a str`, but `fn(&amp;str) -&gt; &amp;str` is fine. - Does it generate a string for some kind of output or IO? You possibly want `fn&lt;W: fmt::Write&gt;(&amp;mut W, ...)`, but only if you worry much about performance or supporting multiple output encodings. - Otherwise, you can't really go wrong with `fn(...) -&gt; String`. At worse it'll be lower performance (but still like Go or Java).
In that case you could code an LCG in like 6 lines really fast. It's inconvenient, but it would suffice.
Except that linked lists are only "run-of-the-mill" in an artificial context. As that "Too Many Lists" book points out: 1. For the vast majority of tasks, there are much better choices. (Outside of their use as a workaround for expressiveness limitations in functional languages, linked lists are about as niche as tries and nobody makes a big deal over those.) 2. Rust provides a ready-made one, as well as a package manager, so the average programmer doesn't need to care about how easy or difficult they are to implement. Beyond that, there are plenty of components that are difficult to implement in other languages and we're used to using ready-made versions of those without anyone complaining that they're difficult to successfully implement from scratch in C. (eg. concurrency primitives)
I had not considered making it fully standalone, as I figured everyone has a browser already and one of my use cases is controlling the app from a LAN. That said, standalone would help end users by eliminating the distinction between backend and frontend, which can be confusing otherwise. For example, when the browser tab is still open but the backend process exited. Alternatively when browser tab is closed but the backend process is still running. Both these issues can be mitigated, but I think not completely eliminated, with careful design. So indeed something like packaging with electron would be interesting.
If you do well at ICPC, you are pretty much guaranteed an interview at GFAAM (Google Facebook Apple Amazon Microsoft). So the languages that ICPC uses are seen as vehicles to those jobs. I'd love it if it was just a sport. My much preferred competition style is download a dataset and crunch it for answer which is then checked by the online judge. https://code.google.com/codejam/
Thanks. I was able to do something similar with an UnsafeCell similar to RefCell I think. Here is a result: https://github.com/austinstig/range-lock
But can you link go library into C++ executable compiled with microsoft toolchain? Well, not really, but then you may select gnu toolchain if you don't care about that niche use case.
Look at it this way: what happens if the error type is changed in the future? Then you'd have a bunch of places where originally you thought you didn't need to handle errors potentially panicking. By explicitly handling the value you ensure its not dropped on the floor later. One could rename `elim` to `unreachable` if readability was a huge concern. Another option would be to use a sub-match: match producer() { Ok(()) =&gt; {} Err(err) =&gt; match err {}, }
Hmm, there is reserve_exact...
I like it. My initial thought was just "why not use only one enum for all nodes types?" It would probably simplify your tree-visitors... But by doing it your way, the type system won't ever let you make an invalid tree, which is pretty cool. Anyway, this is neat. thanks for sharing!
&gt; drops are implicit. You could have them mandatory, yet manual (i.e. explicit), by requiring the user to call either drop or forget at the end of each function. Not that I'd want that, eh :-) Treating drops as manual is a thought experiment in the context of the article.
let mut tmp = String::new(); tmp.reserve_exact(s.len()): tmp.append(s); tmp.into_boxed_slice()
Excellent post. Clearing up terminology is worthwhile and makes communication easier. As a word of caution: be aware of bias that might occur against folks violating it and the ideas they try to convey. I fear this can otherwise lead to a more hostile environment for newcomers.
&gt; However, when typing in something like "Duration", are you typing `Duration`, or `chrono::Duration`? The prelude seems to import `DateTime`, but if it doesn't import `Duration`, then you would need to type `chrono::` first, probably. But, more generally, the Rust Language Server is still under development. Autocompletions and other functions simply don't always work yet, but that should change pretty soon, hopefully.
This is true - I guess my point is that if Box&lt;str&gt; was widely used, new users of Rust could jump to it as a performance increase without considering other overheads. It's definitely possible to do it efficiently, but if you're turning the result of `format!()` or any other string manipulation without `reserve_exact` into a `Box&lt;str&gt;`, it's worse (and new users could be thinking this is better).
Ok I feel pretty convinced, this is a good reasoning. Personally, I don't mind runtime panic for branches that were supposed to be totally unreachable but became reachable due to some coding mistake or a change in types (after all, this is exactly what `unreachable!` is for), but I agree compile-time `match err {}` is even better. Cheers :) Either way, hopefully this all will be unnecessary soon when `never_type` becomes stable.
Please read the subreddit rules in the sidebar. Specifically, "Respect our Code of Conduct," "Constructive comments only," and "Chill out."
Well actually even Box&lt;str&gt; can be resized by replacing it with the new content. (Think std::mem::replace().) The only difference is that String is more efficient if you do several modifications.
Hey, I have an enum and a "to string" function to. In most cases the to string is basically supposed to return the enum type in all capitals or that with something after it. What would be the best way for me to generate such a function? Also, if the answer is procedural macros (which I suspect it is), anyone got a recent guide on it with all the latest "tech"?
I object a little to the term "noise" because it implies garbage information that obstruct the signal. What people often argue for when they say they want "explicitness" is "redundancy". Noone wants random garbage, but stating the same information two times in different ways can aid understanding. Use indentation even when brackets are sufficient. Use type ascription in function headers even when the usage of the argument in the function body would make it clear etc. Beside that, thank you for the blog post. I think this is an area where the discussion is very muddled in the rust community and its super useful to discuss it.
This is patently wrong. I've written only very few lines of `unsafe` code so far, and I've been working on various Rust projects since 2015.
Yes, I've read it, thank you. But, in that thought experiment, he makes `forget()` implicit instead of `drop()`. Drops when going out of scope are implicit in Rust. They happen, predictably, but you have to know that it's how the language works. The lexical capture of variables in nested blocks is implicit too for example in most languages (except PHP where you must specify which parent scope variable you want to access in a closure). Implicitness is a silent default. You have to know how the language works with some depth to understand non-obvious constructs.
I don't understand why using iterators would outperform extending an existing vector, shouldn't extending take no longer than allocating a new vector with the same amount of elements?
Even typing `chrono::` doesn't help :( Oh well, using the documentation is good enough for me right now. 
I must be misunderstanding what article you are referring to (or the text has changed). A page search of OP's linked article didn't return any instances of "forget".
I couldn't find anything in the docs or the RFC, what are the advantages of crossbeam-channels over the channels in the futures crate? Is it performance? 
I know that's possible, what's your point?
 // Must explicitly call this, or the string will be leaked: string.drop(); He makes leaking implicit instead. An hypothetical language could mandate that you either free or leak memory, explicitly. Not doing one of these things would be a compile-time error.
It is easier to use framework that already support regex routing. Check [actix](https://github.com/actix/actix-web) or shio-rs 
My apologies, my first time on Reddit. And thank you. 
Yup you're spot on, I wanted to take advantage of Rusts type system for the AST and it worked like a charm :)
The truth is that linked lists are complex no matter how you slice 'em. Different languages just deal with that complexity in different ways. In higher level languages with GC, the complexity is offloaded to the runtime and the user won't necessarily see it right up front. But that doesn't mean the complexity isn't there, and sometimes that complexity will come back to bite you later on even if in a different form (such as having to fight with/tune the GC or other aspects of the runtime). In languages like C or C++, the complexity is left largely as an exercise to the user: One can throw together a linked list that will "work" in basic cases, but the language will just as happily compile a subtly invalid linked list as it will a valid one, and sometimes the user will be blissfully unaware there was a problem at all until the stars align years down the road and they suddenly get bizarre errors at runtime. Meanwhile Rust forces you to acknowledge up-front that what you are doing is complicated instead of trying to pretend that it isn't, and while it will do what it can to help you be correct through its type system and borrow checking, there are some nitty-gritty details that you will need to implement via unsafe code. But once you've done that and properly upheld the required invariants in doing so, Rust's safety features step in to do the rest. Either way, the use of unsafe Rust in an implementation shouldn't be seen as some sort of deficit or defeat on the part of the language or on the part of user code that requires it. The true super-power of Rust isn't that you never have to write unsafe code, but instead it's that you can create safe abstractions over that unsafe code without requiring a GC or other heavy runtime.
I'd say that Rust actually has quite a lot of magic. Deref coercions, lifetime and generic elision, trait object syntax and semantics... You very much have to know what the rules are, and Rust is not a simple language so there are lots of rules that interact with each other. But once you DO know the rules there are very few exceptions. And the rules get very carefully chosen by exactly the sort of process we're talking about.
It's exactly these kind of absurd straw-man arguments that puts people off rust Rust programmers like to pretend that very simple things are, in reality, "very complicated" and that no one else was doing it right, to justify the silly lengths one must go through to accomplish things in Rust. Ok, ok, in a 0.00001% situation perhaps the horrible usability and hoops in Rust make things worthwhile -- but meanwhile 99.9999% of programs using a "naive" linked-list implementation get along just fine. My supposedy naive linked-list implementation has never caused issues in large complicated programs, and i'm sure the same is true for other C/C++ programmers. You guys are sacrificing usability for a 0.00001% case, you're optimizing for that 0.00001% case and then saying everyone else must be doing it wrong. Get over yourselves.
It completely depends on your needs. For simple enough cases, you might be fine with basic string processing on `req.path()` (think exact match, starts with, etc.). However something like regexp would be better if you need to parse certain arguments from the url.
TOML is probably the best choice right now. Since it's used in Cargo, more people are familiar with it. And tools for manipulating toml in rust are quite mature.
You can always bust out `unsafe` and do it the exact same way you would in C.
So what you're saying is that the terminology isn't explicit enough? ;)
I could also say that writing linked lists is a 0.00001% case, and that once you've got a safe implementation for your case it's not like you're gonna have to write it over and over again, so how much is it really costing you to have to deal with the borrow checker when first doing it vs how much will it potentially save your bacon further down the line? Maybe you really are the mythical programmer who will never ever put a use-after-free bug into production. And if so, more power to ya! But that doesn't change the fact that those kinds of bugs can and do end up in real-life code anyway, and that they can and do cause problems. There's enough people out there writing enough code that even a 0.00001% chance of error ends up being not so small after all.
The closest thing I've found is the [`m` crate](https://crates.io/crates/m), but it hasn't yet been released with those functions. There is a [PR](https://github.com/japaric/m/pull/15) to add them which has been included in the [`auto` branch](https://github.com/japaric/m/commits/auto), so you could conceivably build with that branch as a dependency for now.
FWIW most auto-complete tools would give you "fuzzy" matches too. So they'd list the most relevant match first, and then list similar matches (e.g. in other name spaces) so that you don't have to remember to type chrono:: first. I take the point that RLS is in development etc. though. 
The code he originally posted didn't just allocate one vector, but two because of using `.to_vec()`. Without iterators, let's look at the process: let mut d = a.to_vec(); // allocate a new vector with a.len() elements d.extend_from_slice(&amp;b); // re-allocate a into a new space with a.len() + b.len() elements (since a.len() can't fit a.len() + b.len()) In iterators, it's just "allocate a vector with a.len() + b.len() elements". Even though it goes through several functions via the iterator traits, the only allocation that happens happens for the final length. 
did some looking for you and the main advantages seem to be much better performance, and an expanded API with important features (for example `crossbeam-channel` can select over senders, the senders implement `Send` and `Sync`, timeouts, fairness for `select`, etc.). Here are some sources: * RFC has some info on the shortcomings of `std::sync::mpsc` and comparison with Go: https://github.com/stjepang/rfcs-crossbeam/blob/channel/text/2017-11-09-channel.md * Blog post with critical examination of Rust's channels and motivation for `crossbeam-channel` https://stjepang.github.io/2017/08/13/designing-a-channel.html * Benchmarks from stjepang https://github.com/stjepang/channel/tree/master/benchmarks * `crossbeam-channel` repo has a nice like table with some feature comparisons: https://github.com/crossbeam-rs/crossbeam-channel 
Take something that is "good enough" and "simple to read and write by a human", TOML matches this, JSON doesn't, YAML - maybe does.
Interestingly, the Rust language has no concept of the stack and the heap (the scope-based ownership/borrowing model just maps neatly). https://doc.rust-lang.org/reference/ has exactly one mention of "stack" and one of "heap", here: https://doc.rust-lang.org/reference/types.html#array-and-slice-types
If it's not complicated, TOML is good, and there's a style preserving editing crate available. Additionally, most Rust people already know it and don't detest it since Cargo uses it. If it requires deep maps or such, TOML's absolute paths don't scale. Here YAML wins because it allows many more things and the nesting is self evident. But the whitespace sensitive syntax triggers some people (and may lead to a higher number of user edit errors), and the complexity leads to inconsistent support. But if you only use Serde's data model in YAML, that shouldn't matter. [RON](https://github.com/ron-rs/ron) is a newish option that tries to solve a number of these issues (see the README). But it suffers from being less known, and I don't know if parsers exist for other languages yet. But to be honest any text serialized format that is user edited is going to be messed up. There's a reason that computers became mainstream after the GUI.
`TOML` is pretty great TBH
I know it sounds really dumb but in the mean time until you have a proper solution can't you just call out to javascript for those functions?
Does anyone know of examples for nice zero copy writer apis? Looking for anything that controls the underlying memory, but has the user write to it.
It would be awesome if we could collect 1M invocations of grep across a wide range of problem domains. Maybe we could look at a corpus like github? No, log all the executions (program and arguments) on a single linux box for x hours. Then make a rs-grep that meets that use case.
That it is possible. Didn't know you knew. :) Didn't notice that detail about from().
Sure, there is non-zero amount of unoptimized code already. A while ago I thought that format_args!() is efficient...
Clearly xml is where it's at. It is used by well loved applications such as ant, msbuild, visual studio, maven, and basically anything enterprisey in java. By providing a dtd/xsd, some™ text editors will be able to provide autocomplete. Contrary to some other formats *cough*json*cough* you can even add comments. What's not to like? :p
Exactly! My point is not that `Box&lt;str&gt;` is inefficient, simply that it gives people another easy to reach for way to write inefficient code which might be thought to be efficient.
If you meant `std::mem::replace` on `&amp;mut Box&lt;str&gt;`, then I'm not sure it counts since it's replacing what reference points to, not resizing the original string.
I've started working on jsonpath implementation: https://github.com/greyblake/jsonpath-rs So far I've implemented a limited set of selectors. The library is based on top of serde_json. At the moment I tokenize expression on my own, but I have a plan to migrate it to normal grammar based PEG (can you suggest a preferred library for such thing?)
It's really not that complicated. There's a spec for POSIX grep. You just need to implement it. The Rust regex crate doesn't implement POSIX compatible regular expressions, since they require backreferences which is incompatible with the DFA/NFA implementation strategy of the regex crate. You could probably use [fancy-regex](https://github.com/google/fancy-regex), which is built on top of the regex crate and adds backreferences, but you'd still need to implement POSIX regex syntax, both basic and extended. Anyhow, if you're interested in implementing it, I'd be willing to help you navigate the specs and put together some acceptance tests.
I dind't mean for 'noise' to be pejorative but it definitely can be taken that way.
Great news, Jim! :) Looking forward to picking it up when I can. I've been wanting to get stuck into Rust for awhile now.
rust's xml dom parsers aren't very mature and there's no dtd/xsd validation
I'd have to agree with xml. If cross language compatibility is a necessity, there is no shortage of xml parsers available, they most likely have mature parsers, and xml is well understood.
you're being quite aggressive but for the record, singly linked lists are just as simple in Rust as any other language. A few dozen lines of totally safe Rust.
If you're okay with using nightly/unstable features, you can use the intrinsics directly: ([Playground](https://play.rust-lang.org/?gist=b65aea6bcc3a491ec60327330b6995c1&amp;version=nightly) with the `#![no_std]` lang items) #![no_std] #![feature(core_intrinsics)] use core::intrinsics::{floorf64, cosf64}; use core::f64::consts::PI; fn main() { unsafe { assert_eq!(floorf64(cosf64(PI)), 1); } } There are no trig instructions in the WASM spec, so LLVM appears to use a library call to some `cos` function instead (it's unclear if this is the Javascript `Math.cos()` or something LLVM provides). This generates basically the same code as the std-API version so it may or may not work. `floor` has its own WASM instruction so that intrinsic should work fine at least. If you get errors about `cos` not being defined, I'd just swap that out with a [Taylor series expansion](https://en.wikipedia.org/wiki/Taylor_series#Trigonometric_functions) which may well be faster in WASM than calling into Javascript anyway.
Mine's not coming in till the 2nd :(
Most professional sports have additional benefits. Being good at football can get you into a good college in the US. ICPCs focus is quite in line with what the big companies focus on during interviews anyway. I have problems with this, but as it stands it makes perfect sense too.
/u/jimblandy, any idea when it'll be in brick and mortars? 
Put a println! at the start of 'get_next_p_given_current_ps' to see when that function starts executing. It's not that they're not being changed inside that loop, it's that the function is being called again from nth.
A hashmap has very fast lookups (you typically have to look at only 1-3 entries IME). A vector has very slow lookups unless the elements is very near the beginning of the vector (you have to look through the whole vector in the worst case). In this situation, you almost cetainly want a hashmap. The docs have a section on [when you want a `Vec`](https://doc.rust-lang.org/std/collections/#use-a-vec-when) and [when you want a `HashMap`](https://doc.rust-lang.org/std/collections/#use-a-hashmap-when). 
I think this is the best solution for this sort of thing. Here's the [playground link](https://play.rust-lang.org/?gist=545c29c7ffee67a9ec22e6c9c50f7572&amp;version=stable) in case /u/Oaredo wants to see it in context.
I totally missed the section in the docs :-\ Thanks a lot!
Can confirm. I got mine two days before Christmas. Thought this was intentional as a Christmas surprise. 
You are right! Thank you!
Thanks, this milksnake looks like exactly what I need. 
I’ve been enjoying the ePub, but my hard copy should arrive tomorrow. W00t!
[enum_derive](https://crates.io/crates/enum_derive) might be the crate you're looking for.
I hate YAML more and more because I always doubt if my string is written as expected.
Thanks a lot, I think this is what I was looking for. The rust-based math library is sadly half-finished and - as you said - flooring and other instructions have their own special instructions, so that couldn't have helped. I think I'm ok with nightly, I need that anyway for lang features (if you disable std, you also have to redefine the panic things and other stuff. So using no_std on stable is pretty much impossible right now. Calling into JS would not be a solution, because the point of this is that I need to transform loads of coordinates extremely fast, so that would be probably slower than native JS. Thanks.
*me runs to check amazon order* &gt; Arriving Tuesday \\(oo)/
Something like this: https://crates.io/crates/fifo ?
is there a problem with rust installer? was trying to install rust on ubuntu got this error ``` curl https://sh.rustup.rs -sSf | sh curl: (7) Failed to connect to static.rust-lang.org port 443: Network is unreachable ```
That's not a problem with implicit self, that's a problem with implicit shadowing. `-Werror=shadow` fixes it. In Rust the best you can do is use a linter like clippy to catch shadowing.
I'd say this is the simplest and easiest-to-grasp explanation I've yet encountered.
If you want to lookup by key and one value per key then map is what you want. From what I see from you code, you are most likely want a Map
I've never seen "Network is unreachable" when a server was down. For me, it's always meant that something went wrong with my router and packets couldn't reach the public Internet. (ie. there was no matching, functional route in the output of the `route` command.) I'll assume your browser works. Is it possible that you have some unusual connection requirement (eg. a proxy server) that isn't getting passed along?
...and the only `unsafe` code I had to write was a call to `libc::access` to make my "script" bail out early if the destination directory for a later stage of processing was unwritable. (Given that I couldn't find any crates which wrapped it, my best guess is that people though `access(2)` was too prone to abuse and providing a safe API would exacerbate that.)
`*` is Mul and `&amp;` is BitAnd but that doesn't stop those from being used in memory ops I should write a splat rfc
Which audience are you targeting with your tool? If it's for rust development, TOML is the best choice. If it's somehow related to the Ruby ecosystem, perhaps YAML is the standard choice. If it's javascript... I guess JSON? But yeah, TOML is generally good... My point is that you should integrate with the ecosystem you're trying to enter.
Agreed, “Network is unreachable” is strictly a local error.
What a great resource this has been for learning Rust with Advent of Code :) Congrats!
When I pattern-match a value against two branches, a specific possibility and a wildcard capture, why does the compiler still think that that specific possibility can occur in the other branch if that branch consists of mostly a second pattern-match on the captured value? https://play.rust-lang.org/?gist=b753bd29ea438d953cf79ef4d1f33068&amp;version=stable
ePub and/or pdf are available? Any link where I can buy? 
I won't be getting a physical copy, but I am a member of O'Reilly Safari. I've been reading the pre-release version online, now it'll be awesome to read the final version! Awesome work and thank you so much! :)
i can't access ``` https://static.rust-lang.org/rustup/dist/x86_64-unknown-linux-gnu/rustup-init ``` from my browser either and apt-get works as well 
Been benefiting from this book for a while now. Thank you so much for writing it. Congrats! 
As always benchmark it. If you have less than a 100 elements a Vec is probably faster. But really, benchmark it.
This is missing an API to write bytes directly to the fifo, it can either copy from a `Read` or `&amp;[u8]`. I am looking for something that gives you the buffer or output stream to write to directly, but presents it more nicely than `get_buffer(size: usize) -&gt; &amp;mut [u8];`. (I realize the original question was a bit vague)
I'm a huge fan of `Hjson`. Unfortunately the Rust crate for this format isn't updated for Serde &gt;=1.0, and the author is looking for help in that regard, I hope someone picks it up at some point.
funny thing ! I can get a trace route to work . ``` traceroute to static.rust-lang.org (198.245.51.138), 30 hops max, 60 byte packets 1 gateway (192.168.1.1) 2.909 ms 3.618 ms 4.307 ms 2 * * * 3 218.248.168.126 (218.248.168.126) 187.270 ms 187.187 ms 187.094 ms 4 218.248.235.141 (218.248.235.141) 186.492 ms 186.439 ms 186.357 ms 5 218.248.235.142 (218.248.235.142) 186.400 ms * * 6 14.141.139.145.static-chennai.vsnl.net.in (14.141.139.145) 186.523 ms 34.851 ms 36.343 ms 7 172.31.167.53 (172.31.167.53) 40.214 ms 137.847 ms 141.987 ms 8 172.31.29.245 (172.31.29.245) 143.965 ms 143.919 ms 143.858 ms 9 ix-ae-0-4.tcore1.MLV-Mumbai.as6453.net (180.87.38.5) 83.018 ms 85.011 ms 84.963 ms 12 if-ae-11-2.tcore1.PVU-Paris.as6453.net (80.231.153.49) 1048.936 ms 1044.960 ms 1042.958 ms 22 po7.bhs-3a-6k.qc.ca (198.27.73.14) 279.923 ms 280.825 ms 284.724 ```
Yaml is nice to read (compact), but not nice to write and not as portable. Toml is more natural to write, not necessarily nice to read. That's why for long/machine-generated configs, that humans just view or alter, I use Yaml, and for something that humans are supposed to edit a lot, Toml. My previous answer in similiar topic: https://www.reddit.com/r/rust/comments/7izxrg/toml_or_yaml_for_config/dr394xj/
Are you sure it's reaching the end? Traceroute will work up to the point that the problem is no matter whether something works. Try `ping`.
I'm curious what "we safely stack-allocate a function argument". Honestly, I can't think of a case that violates memory safety in C if no pointers/arrays are used.
If your browser works for other HTTPS URLs but doesn't work for `static.rust-lang.org`, then I can think of two reasons: 1. Something's wrong with your HTTPS support and sites with certain cipher configurations or root CAs aren't working properly (Unlikely) 2. The problem exists outside your computer but also outside our stuff. (More likely) That would put it in the realm of "report a problem to your ISP". (eg. On rare occasions, I've been unable to access some sites but not others because either my ISP or [Level 3 Communications](https://en.wikipedia.org/wiki/Level_3_Communications) (one of their uplink providers) had misconfigured their routing. It could also be that your ISP is doing some kind of anti-piracy filtering/firewalling and *that* is misconfigured.) 
**Level 3 Communications** Level 3 Communications was an American multinational telecommunications and Internet service provider company headquartered in Broomfield, Colorado. It ultimately became a part of CenturyLink through a complex reverse-merger process where Jeff Storey sold the company and also became CEO of CenturyLink. Level 3 operated a Tier 1 network. The company provides core transport, IP, voice, video, and content delivery for medium-to-large Internet carriers in North America, Latin America, Europe, and selected cities in Asia. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Just ordered my copy, can't wait!!
Nice spear headshots, but this is the wrong subreddit. Try /r/plarust
Sorry will delete! And thanks:)
&gt; static.rust-lang.org ``` 64 bytes from ns506727.ip-198-245-51.net (198.245.51.138): icmp_seq=1 ttl=52 time=263 ms ``` 
this is getting weirder...
The one that takes the `Read` impl does give you the output buffer when it calls `Read::read()`. It'd take some creative finagling but you could achieve zero-copy that way.
what is my isp doing eh..... `netstat -r` gives me no misconfiguration I'm using Lubuntu would that be a concern? ``` kernel IP routing table Destination Gateway Genmask Flags MSS Window irtt Iface default gateway 0.0.0.0 UG 0 0 0 wlp2s0 192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 wlp2s0 ```
You can look up the docs of HashMap to get a sense of what it's doing to make lookups constant time. I'll just add that in the case of Rust's HashMap in particular (but not all hash maps in general) there's not much of a difference in allocation. Everything still ends up in a single contiguous allocation, as it would in a Vec.
Any iptables/nftables/whatever that could be at play?
Thanks! Yes, for our book, that stage took *much* more time and patience than I had expected. Hang in there!
now I have eliminated quite a no of possibilities 1. I can ping 2. there is no weird routing problem on local 3. `openssl s_client -connect static.rust-lang.org:443` works this is really weird
According to the Nielsen BookScan data (which Amazon makes available to authors), there have already been a few copies sold at physical book stores. Cincinnati, NYC, and Washington DC have the most sales so far. ¯\_(ツ)_/¯ It doesn't seem like my local bookstore, Powell's Books, is stocking it yet. :( Honestly, I'm not sure how physical stores decide which books to stock. There are so many, and they have limited shelf space. I assume strong online sales figures would encourage them to take the risk.
nope Kernel IP routing table Destination Gateway Genmask Flags MSS Window irtt Iface default gateway 0.0.0.0 UG 0 0 0 wlp2s0 192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 wlp2s0
Just realised O'Reilly no longer actually sends the books themselves, but redirects to Amazon - whose prices are. ZOMG. $22NZD for an ebook - that's... I really wish there was a place to buy ebook+physical - still, will enjoy reading this on my Kindle shortly :)
That’s the routing table. Iptables is completely unrelated 
I received my copy today! I have used Rust in a professional setting for a year now -- this is a fantastic resource, and I know I'll use it moving forward.
Congratulations, you have stumbled over a badly designed C API ;). Do you need any help with the HashMap?
Looking forward to it! Congratulations on the hard work. Mine should be here in the first week of January, (international shipping).
I'm using Lubuntu 14.04 LTS and I don't seem to be having any problems. Judging by your interface names, you're running a newer version, but that's very unlikely to be significant if everything else works.
The best book about Rust so far 🎉 Congratz!!!
B&amp;N in the bay area tend to stock OReilly books pretty regularly; heck, I've seen copies of very niche [tech books](https://www.manning.com/books/type-driven-development-with-idris). I'll post back if I see it around.
I appreciate the 'few exceptions' meta-rule. Most mainstream languages feel very arbitrary in comparison - e.g. the enormous lengths that C++ goes to be both C and a modern language, and all those little features that makes Python easy to learn but hard to master.
Agreed, it's a particularly bad choice for user-facing configuration - the rules are too subtle.
Thank you very much, this seems to be what I wanted.
Try in /r/playrustserver
I think vscode does that automatically. I've written a language server for it, and it does add other matches to the list, certainly when the LS returns an empty list.
The book as bit too expensive for me to buy as a bit of hobby reading, but I got my company to order it for our library, so looking forward to it arriving some time in January as well!
Try reposting in /r/playrust – we Rust Programming Language adherents care little for the game that has the same name.
You could of course become a Rust Language Programmer and simply stop playing the game. If that's your thing, we'll be glad to help. Otherwise try asking /r/playrust
... oops. 
Now that Oreilly has migrated to subscription model and only allowed customers who purchased the early release book to download it as PDF, ePub, mobi, you can buy DRM-free Oreilly books from ebooks.com as far as I know. https://www.ebooks.com/95914803/programming-rust/blandy-jim-orendorff-jason/ 
One common solution is you create a trait and then implement that trait for all closures with the correct signature. [(playground)](https://play.rust-lang.org/?gist=646839631477a5ac7c4f70d836bb45aa&amp;version=stable)
I'm working on a NetworkManager plugin for Wireguard. Checkout [the screenshot](https://github.com/manuels/wg-p2p-nm-plugin/blob/master/Screenshot.png) and [the code](https://github.com/manuels/wg-p2p-nm-plugin). Still needs some time until it works reliably.
HashMap will have constant time lookup and use slightly more memory than Vector (but both are linear in number of elements). To find item in unsorted Vector you have to iterate through whole Vector, thus search time is linear in number of elements. However, if you sort your vector you can use binary search (and search time will be logarithmic in number of elements). But seriously, this is not Rust question, but question which basic data structure and algorithmic course will teach you. Read stuff like this https://mitpress.mit.edu/books/introduction-algorithms it will be very beneficial to you. 
/u/jimblandy This was definitely one of the best programming books that I've had the pleasure of reading. I bought the digital edition on iBooks a few weeks ago, and it definitely made starting Rust a heck of a lot easier.
Hm, I didn't pre-order and it's sold out in Germany. :( Well, I'll put myself in the queue.
not easier
Would this be useful in your case https://crates.io/crates/url ?
I thought this needed to be in the global cargo config! This is awesome news, thanks!
Threads aren't supported on wasm yet. If you try to start a thread on the wasm target, it'll panic. Threading is definitely in wasm's future, but quite a bit down the road yet. You'll probably see stuff with async/futures/promises first.
You can indeed run WebAssembly inside Web Workers: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate#Second_overload_example Thus, by shuffling things around here and there you can achieve parallelism. This isn’t the most *elegant* thing, and it won’t let you do anything like the pure awesomeness that is Rayon, but it’s a start.
This is not a non-sensical question - one of WASM's goals is to make multi-threading programming possible in in the browser. Currently, there's no support for threads in WASM. chris-morgan pointed out that you can use Web Workers, but those are much closer to multi-processing than multi-threading. Using WASM inside a WebWorker will allow you to use more cores, but would have a big IPC cost - the data must be copied manually.
yeah... me too...
In the fetch_result function you use `unwrap()` multiple times. This function *panics*/crashes the program if the value is not `Ok`. You should use `try!` or `?` to return `Error` early instead The point of using the `Result`type is that you can represent unsuccessful outcomes of your function. In case of HTTP requests, it could be caused by your service being down, connection being down on the client, JSON being invalid. You don't want to crash the program in any of those cases, and return `Error` instead. Avoid using `unwrap()` unless you're *certain* the value is `Result::Ok` or `Option::Some`.
Just do JSON. If someone is editing it by hand there is few chances to screw up by putting the wrong amount of spaces, and lists and associative-arrays (aka objects) easily nest infinitely deep which is nice. Also every platform and language has great parsers for it, and there are many great binary formats compatible with it for when you need it. 
Thanks.
Main things I see: - Everything is stringly typed (string results, mostly). This is not necessarily bad, but if you wanted to expand the library to fit what most Rust libraries do, you'd probably want to do some parsing into numbers when that's what things are. - `fetch_result` will panic when newton service fails. This is a large red flag! Right now, if the newton API returns something that isn't json, or doesn't contain a string "result" key, you will crash the entire application of whoever is using your library. `.unwrap()` should only be used for cases when you've completely ensured that what you're unwrapping is valid, and the "wrong" state means there's a logic bug in your program. In your library, though, you are unwrapping Results which are from parsing external data! I would recommend making your own error type for your library so you can return both `reqwest::Error` and other types of errors for when the server's return result is malformed, then having that as your error type instead of `reqwest::Error`. If your error type implements `From&lt;reqwest::Error&gt;` and `From&lt;serde_json::Error&gt;`, you can use the `?` operator on those kinds of results to automatically convert the errors. The simplest error type (and what most libraries use) is an `enum` with one variant for each type of error, plus one variant for each other kind of error. There's also the [`error-chain`](https://docs.rs/error-chain/) library which will generate such an enum automatically. Hope that's not too much elaboration. Even if you don't go for a full custom error type, I would definitely recommend doing some kind of error return on invalid json rather than panicking: unwrap is never meant for things which can fail. 
Yes, this was something that bothered me too. Normally in another language, eg. Golang, I would propagate back any error that occurs using the `error` type, but since Rust didn't have a global error type defined, I limited it to returning the `reqwest::Error`. I see now that I have to create my own error type.
I guess it is, but the whole reason of the program is interfacing with DLLs exposing such an API. I actually need a bit of help, but not with the HashMap. It's already established I need some sort of global variable, I think, in order to make this work. I wanted to make a global variable be the target of the call back. The equivalent of the pointer I would send to C otherwise. My issue is that I can't, for the life of me, figure out a way to add an element that needs a lifetime specifier to a global Vec or HashMap. I don't want the element to have a static lifetime because it won't live through the whole program. At some point, it should be removed from the vector because the dll will be unloaded and another one loaded instead. Maybe I'm overcomplicating things... i don't know. I'm new to Rust, so maybe it's just growing pains. But I want to figure a way to make this work. It's the only stumbling block for me right now. The rest of the implementation should be pretty straightforward.
A custom error type is something that I will definitely be implementing. Although `failure::Error` looks promising, i'll look into it, too.
If you *really* don't want to create your own error type, you can return `Box&lt;Error&gt;` to wrap all possible error types.
The `failure` or `error-chain` crates can make this a little nicer.
Oh really?
OP didn’t mention that his be intended for use by Rust developers. I think it’d be more important to match the format expected by users rather than the language a tool is written in. &gt; And tools for manipulating toml in rust are quite mature. Last time I checked, the toml crate didn’t even support mutating the parsed DOM, so I’m rather skeptical about the maturity. The only usable way for using TOML right now seems to be with Serde. 
I thought it would have been a great opportunity to get my hands dirty but this is too pricey for me. Congratulation anyway :)
tl;dr: Vec is like an array, searching for the correct String is an O(n) operation. HashMap is a hash table, searching for the String is an O(1) operation. Hash tables are usually implemented using arrays. A naive implementation would pass the String to a hashing function which would turn it into a number between 0 and n, where n is the size of the array (we call this function a hashing function). Then it would store T on heap and a pointer to it on the hashed number position. To get the value back, you hash the string again and look for the position given, if it's not null, it's a pointer to the value and if it is null, the value is not on the table. That's a very naive and barebones explanation of the workings of hashmaps.
No problem! `failure::Error` is more useful for applications than libraries IMO. `failure` deriving can be nice for custom error type formatting though.
Is there any user thread implementation in rust? Maybe use that as default for wasm.
Looking at the `toml` docs, I don't really see what kind of mutation you think is not possible. `toml::value::Value` even has a few `_mut` helper methods. If I had to do a ton of mutation, I'd probably want a more highlevel API to do it, but that could be added as an extension trait in a secondary crate (assuming mutating the dom directly is a niche use-case). If you do have a use-case that is truly impossible with the `toml` crate as-is, you should probably open an issue describing it in detail.
Considering the hard copy is only shipping now, and the digital version is available since some time: Are there any differences compared to the digital version? I am eager to get my hands on it (ordered on Amazon)!
What's the output of: curl -v 'https://sh.rustup.rs' -o /dev/null
Most likely it's just RLS flaking out. It's still very unreliable and often doesn't work properly. Hopefully this will improve as it continues to be developed.
Sentry.io is doing exactly that in production. Check out [Milksnake](https://blog.sentry.io/2017/11/14/evolving-our-rust-with-milksnake).
Maybe related to IPv6. Try strace to see what address curl is attempting to connect.
There isn't such thing as "user thread implementation" in a library. Threads is something that needs to be provided by the underlying system, be it VM, OS, CPU, etc. You can use coroutines and futures without threads though.
Usually i'd agree with you but in this case it rather looks like the problem is understanding the data structures in general. Therefore I'd say rather use the data structure that is build for the given purpose and not optimize prematurely. Optimizing is great when thinking about hot code edge cases, but not when generally needing to understand the benefits and trade-offs for different collections.
[removed]
When debugging network problems, Wireshark can be very useful.
622 pages!? I guess I'll go for the digital version.
Anyone else think it’s a tracesty and, well, pathetic that these vendors don’t make quality hardback books? Technical books like these need to be hardback.
&gt; Using WASM inside a WebWorker will allow you to use more cores, but would have a big IPC cost - the data must be copied manually. Not entirely sure about that. There are SharedArrayBuffer constructs which can be shared across js threads. I'll need to run a test for whether they can be used to share memory.
Compiler checks each `match` separately, without propagating this info between them. Once you match the value as `x`, all known information about possible values of `x` is forgotten inside that match arm.
The difference between Path and PathBuf is roughly the same as the one between &amp;str and String or &amp;[] and Vec, ie. Path only holds a reference to the path string data but doesn't own this data, while PathBuf owns the string data itself. This means that a Path is immutable and can't be used longer than the actual data (held somewhere else) is available. The reason why both types exists is to avoid allocations where possible, however, since most functions take both Path and PathBuf as arguments (by using AsRef&lt;Path&gt; for example), this usually doesn't have a big impact on your code. A very rough guide for when to use Path vs. PathBuf: For return types: if your function gets passed a Path[Buf] and returns a subpath of it, you can just return a Path (like Path[Buf].parent()), if you create a new path, or combine paths or anything like that, you need to return a PathBuf. For arguments: Take a PathBuf if you need to store it somewhere, and a Path otherwise. For arguments (advanced): In public interfaces, you usually don't want to use Path or PathBuf directly, but rather a generic `P: AsRef&lt;Path&gt;` or `P: Into&lt;PathBuf&gt;`. That way the caller can pass in `Path`, `PathBuf`, `&amp;str` or `String`. As for your strip_prefix example: Calling to_str() on a Path[Buf] is very often a bad idea. In fact, the reason why it returns an Option is that some paths simply aren't valid utf8 strings. Then, once you implement proper error handling (in the most simple case just use the Error type from the failure crate), this example might just shrink to: `path.strip_prefix(env::current_dir()?)?` which looks more reasonable.
WASM memory cannot be shared yet.
Yeah, you seem to be right. You don't seem to be able to set the memory right now to some chosen ArrayBuffer. So yes, one needs to copy everything atm. That's still better than no parallelism support at all though.
1. The relation between `Path` and `PathBuf` is like `str` and `String`. Meaning, `Path` is the borrowed version (just a pointer and a length), while `PathBuf` is heap-allocated and owned. (essentially a `Vec&lt;u8&gt;` or `Vec&lt;u16&gt;`, depending on platform) 2. Returning `&amp;Path` will not always work, especially if the path is constructed from scratch (similar to how returing `&amp;str` from methods that construct a new string won't work) 3. `Path.parent()` returns a sub-path of itself, so it doesn't need to allocate a new `PathBuf`. That's similar to how, when you take a substring of a `String`, it won't return a `String`, but a `&amp;str`. 4. All methods that can return `Option` or `Result` can fail in some way. The `?` operator should help you in this case (though Option and Result in the same method is still kind of a hassle, you can look at the `ok_or` combinator for `Option`). 
I've got to be honest I've given up on VSCode Rusts tooling at the moment, RLS is always flaking out and crashing, nightlies go days and days without rust-fmt or RLS support and I spent stupid amount of time trying to fix things. I just use the bog standard syntax highlighting and the command line now.
How can I find the implementation of a certain method I am using? I have a function `f()` I debug, that, internally calls `x.g()`. My problem is, `g()` is no where to be found. Is there a way to convince the compiler to provide me something like `TraitA::g() comes from file.rs`? 
To add to the other responses, here is a playground link with the strip prefix code. https://play.rust-lang.org/?gist=95bb036e3e3b4a28206389049769a0e4&amp;version=undefined
Your link seems broken.
I'll add that `PathBuf` doesn't define `parent()` itself, it comes from the `Deref` implementation to `Path`. The natural deduction is that `Path`, which is merely a view over some data, returns another view from the same data and you wouldn't expect it to allocate anything on its own.
Well said and good advice for others, especially about AsRef and Into.
no
To 2.: PathBuf derefs to Path, so instead of as_path you just can pass &amp;PathBuf in place of &amp;Path. 
Excellent advice, I think a lot of my issues stemmed from not getting (didn't even know it existed) as_ref. This meant I was converting to &amp;strs needlessly. What paths would not be utf8 strings? I need to convert to them eventually to generate anchor tags.
Try this? https://play.rust-lang.org/?gist=bcd9dcd7d3d2e92cf4acac9578b1a5d2&amp;version=stable
The latest non-crashing RLS, in my experience, is in the nightly-2017-12-14 toolchain. To get it to work currently you can use [this workaround](https://www.reddit.com/r/rust/comments/7la5oi/updating_rustup_installing_rls_directly_broke_the/drlo2kw/?context=0).
&gt; "Copyright © 2018 Jim Blandy, Jason Orendorff,. All rights reserved" Cool, you wrote it in the future! :-) 
Looking forward to Amazon selling the paperback in the UK! The Kindle edition is the latest one, but the paperback is 400 pages and was released in August 2016? I nearly accidentally bought it..
Another reason for the awkwardness is that PathBuf is just a pretty thin layer around OsString, which isn't guaranteed to be valid Unicode. So every time a string comes out of a path it has to be checked, and that check might fail. I rather want a nicer library with slower but simpler path handling, more akin to Python's os.path module. But, haven't gotten around to writing it yet.
SharedArrayBuffer would be JS memory. There would still be a penalty from writing WASM &lt;-&gt; SharedArrayBuffer but it might work as a blackboard for large data structures across webworkers.
&gt; I need to convert to them eventually to generate anchor tags. My advice would be to convert only what is needed and to do `.to_str().ok_or_else(|| ...)?` with the `...` replaced with whatever error handling logic you have to report to the user that that part of the path is unsupported for your needs.
What about performance of the compiled code?
The link is broken or the code errors? The link works for me. Yes, the code errors but I was figuring that it still sufficiently worked as an example of how to pipe the types together that it didn't matter that `strip_prefix` fails.
Also direct from Oreilly, http://shop.oreilly.com/product/0636920040385.do and Amazon https://smile.amazon.com/Programming-Rust-Fast-Systems-Development-ebook/dp/B077NSY211/ref=sr_1_2?ie=UTF8&amp;qid=1514559078&amp;sr=8-2&amp;keywords=programming+rust 
On Linux at least, file paths have no defined encoding, other than that they may not contain the NUL byte. Otherwise, they are just arbitrary bytes (probably with some max). Example: $ echo -e '\xFF' | xargs touch $ ls ? $ python2 -c 'import os; print(os.listdir("."))' ['\xff'] If you need UTF-8, then you need to make a decision on how to support file paths that aren't UTF-8. I think you have two choices: ignore them or lossily transcode them. In the latter case, you can use the various `lossy` methods in the standard library, which will in this case turn invalid UTF-8 sequences into instances of the Unicode replacement character. Being able to access the raw path is important in general though. If you're writing a system utility that needs to be able to handle file paths exactly as they are, then you might need to deal with the invalid UTF-8. For example, if I wanted to write a utility that joined file paths in some way, then it would be critical to be able to do this even if the paths weren't valid UTF-8.
I pre-ordered it from Amazon way back in February. Finally arrived just yesterday! Can't wait to read it.
Thanks. I wish rustup would output those fixes when you update and components are not available. 
My credit card was stolen, cancelled, and Amazon cancelled my 6 month long preorder of Programming Rust. Thank you technology :/
Good stuff!
[removed]
My bad, no code was showing when I tried, but it seems to be working now. Don't know what happened.
Paging /u/steveklabnik1 - I saw some tweets about a wasm interpreter. Also, I may be interested in working with you on this. I've got an idea for a sandbox-oriented OS that uses wasm as the native executable format. 
I imagine, because you're asking a question like this, that you are free to ignore if my guess was wrong and it's not relevant to you... **Don't bother using paths.** Most of the time, if a function calls for anything pathy, what it's asking for is any `T: AsRef&lt;Path&gt;`, which means that it's perfectly happy to get a string slice. This is usually way more ergonomic.
I bought the pdf from ebooks.com I had previewed this book on oreilly safari and wanted to have my own copy. Just wasn’t sure where to buy it. 
In cases where the map will end up with a very small number of elements, the vec is usually the quicker option. The biggest issue here (and I had to deal with this in a real-world situation at work the last time I made this choice) is that vec and hashmap have a completely different api, which means that--should you ever decide to add more elements--changing your backing store will be a pain in the ass. What I did was to write a class based on List(T) that implemented the dictionary interface, which meant I could swap out the implementations at any point. This was probably a terrible idea. I mean, for one thing, the dynamic dispatch enforced by using `IDictionary&lt;T, U&gt;` as opposed to `Dictionary&lt;T, U&gt;` probably killed any speed benefit I was going for. For another, that company declared bankruptcy just a few weeks ago. ...Although you probably can't put *all* the blame on me, since I left there almost two years ago. At most, I'm 49% responsible. :) (Note to lawyers: the above is a joke. Do not come after me.)
I'm not sure when O'Reilly switched to an entirely subscription based model for digital content. Sorry if I caused any confusion. Do you like the book?
So far so good. The only thing I miss as a rust newbie is if it had end-of-chapter exercises etc. But still for the content, so far, I’d give it full 5 stars. 
The joke's on you: the digital version is the same length!
40€ for a ebook? Guess I will wait for a sale
Some backstory: I am involved in some VR / gaming projects where we need machine learning. Our problems are not super large (few thousand examples), and libSVM has shown excellent results. Unfortunately though libSVM is not really optimized for games: It allocates a lot each call, has bad cache efficiency, and does not support bulk-classification. Since I wanted a reason to play with Rust anyway I thought "Why not re-implement a libSVM-compatible classifier in Rust, with emphasis on speed?" Right now this is half a "pet project". I'm not so much sharing this because of the library itself. Instead, I thought some of you might be interested in more "real world" performance numbers, and how SIMD (Faster), Threading (Rayon) and others affected its speed during development. For more graphs and discussion, have a look at the [performance history](https://github.com/ralfbiedert/ffsvm-rust/blob/master/docs/performance.adoc). 
I pre-ordered mine from bookdepository in January 2016, but they're still not shipping yet. At least I do get it at €35.79.
It has a crustacean on the cover!
I don’t think you should be using Path and PathBuf at all, since those are intended to represent *filesystem* paths, which have different rules and semantics for URL paths. IIRC, URL paths can even have NUL bytes embedded in them (possibly percent-encoded). You could just use the `url::URL` code from Servo, if not directly then at least as a guide. Use the right abstraction for the job. Just because two things are path-like doesn’t mean they’re both identical, and they shouldn’t be handled identically. The one case where I do think it’s fine to represent URL paths as Path[Buf]s is when your router has determined that the path is actually to be loaded directly from the filesystem instead of from a webapp endpoint. At that point you know it must reference a location on the filesystem, so you can convert to a PathBuf (and fail if, e.g., there are internal NULs). 
o/p * Rebuilt URL to: https://sh.rustup.rs/ % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- 0:00:02 --:--:-- 0* Trying 54.215.0.2... * TCP_NODELAY set 0 0 0 0 0 0 0 0 --:--:-- 0:00:03 --:--:-- 0* Connected to sh.rustup.rs (54.215.0.2) port 443 (#0) 0 0 0 0 0 0 0 0 --:--:-- 0:00:04 --:--:-- 0* ALPN, offering http/1.1 * Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH * successfully set certificate verify locations: * CAfile: /etc/ssl/certs/ca-certificates.crt CApath: /etc/ssl/certs * TLSv1.2 (OUT), TLS header, Certificate Status (22): } [5 bytes data] * TLSv1.2 (OUT), TLS handshake, Client hello (1): } [512 bytes data] * TLSv1.2 (IN), TLS handshake, Server hello (2): { [111 bytes data] * NPN, negotiated HTTP1.1 { [5 bytes data] * TLSv1.2 (IN), TLS handshake, Certificate (11): { [2466 bytes data] * TLSv1.2 (IN), TLS handshake, Server key exchange (12): { [333 bytes data] * TLSv1.2 (IN), TLS handshake, Server finished (14): { [4 bytes data] * TLSv1.2 (OUT), TLS handshake, Client key exchange (16): } [70 bytes data] * TLSv1.2 (OUT), TLS change cipher, Client hello (1): } [1 bytes data] * TLSv1.2 (OUT), TLS handshake, Unknown (67): } [36 bytes data] * TLSv1.2 (OUT), TLS handshake, Finished (20): } [16 bytes data] 0 0 0 0 0 0 0 0 --:--:-- 0:00:05 --:--:-- 0* TLSv1.2 (IN), TLS change cipher, Client hello (1): { [1 bytes data] * TLSv1.2 (IN), TLS handshake, Finished (20): { [16 bytes data] * SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256 * ALPN, server did not agree to a protocol * Server certificate: * subject: CN=sh.rustup.rs * start date: Dec 11 02:05:09 2017 GMT * expire date: Mar 11 02:05:09 2018 GMT * subjectAltName: host "sh.rustup.rs" matched cert's "sh.rustup.rs" * issuer: C=US; O=Let's Encrypt; CN=Let's Encrypt Authority X3 * SSL certificate verify ok. } [5 bytes data] &gt; GET / HTTP/1.1 &gt; Host: sh.rustup.rs &gt; User-Agent: curl/7.55.1 &gt; Accept: */* &gt; 0 0 0 0 0 0 0 0 --:--:-- 0:00:06 --:--:-- 0{ [5 bytes data] 0 0 0 0 0 0 0 0 --:--:-- 0:00:18 --:--:-- 0&lt; HTTP/1.1 200 OK &lt; Server: nginx/1.4.6 (Ubuntu) &lt; Date: Fri, 29 Dec 2017 16:59:30 GMT &lt; Content-Type: text/x-shellscript &lt; Content-Length: 9374 &lt; Connection: keep-alive &lt; Vary: Accept-Encoding &lt; x-amz-id-2: lzMqdo3gthfrKSPlzJFADDztnww4EsyWnQnB70lLuevd3Zwomu1cwtOyEHks75vYfMh9pSfSfGM= &lt; x-amz-request-id: CBC7E66E9AF7B0EC &lt; Last-Modified: Tue, 19 Dec 2017 15:41:05 GMT &lt; ETag: "868e9f9e16f96872d8a1f0cf9e1225d8" &lt; x-amz-meta-s3cmd-attrs: uid:1000/gname:alex/uname:alex/gid:1000/mode:33204/mtime:1513563906/atime:1513697900/md5:868e9f9e16f96872d8a1f0cf9e1225d8/ctime:1513695797 &lt; x-amz-version-id: Tfp4rRP3VyMIkM3ULfr_.tro0I0uuvpB &lt; Accept-Ranges: bytes &lt; Content-Disposition: attachement; filename=rustup-init.sh &lt; { [9374 bytes data] 100 9374 100 9374 0 0 520 0 0:00:18 0:00:18 --:--:-- 1988 * Connection #0 to host sh.rustup.rs left intact 
My copy should arrive between 12 and 19 January - shipping to the UK. Really looking forward to reading it. Good things are worth the wait. Congratulations!
That is exactly the situation i'm in right now. Building a file browser that serves up 404's if you go astray.
everything always completely depends on one's needs.
log and slog are good.
nope sudo iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination 
The lookups performance is true at large sizes, however I would not be surprised to be told that for small sizes (handful) or even medium sizes (10s/100s depending on the type) a linear search is faster.
Hi, after looking for a bit I haven't found an answer : can I convert a &amp;[u8] into a &amp;[usize] without having to iterate over the slice ? I'd like to do something like : let usize_slice = u8_slice as &amp;[usize] Should I rather try converting the array that the slice is referencing then get a new slice from that?
log doesn't log into a file
Sure, but you haven't stated what your actual needs are. There is no one 'proper' way, please give us some idea what URLs you want to match &amp; what kind of info to retrieve out of them. Like I said, if it's a few static routes, go with `req.path() == "/hello-world"`. 
dynamic routes
Using it with [log4rs](https://rust-lang-nursery.github.io/rust-cookbook/logging.html#ex-log-custom) will get you that I think. Either way I think slog is best.
[fern](https://github.com/daboross/fern) supports this out of the box.
Then I'm afraid manually matching the path with regexp is your best choice. There is also this [hyper-router](https://github.com/marad/hyper-router) project but I don't think it has been updated for the latest (async) hyper.
I got mine in the iBooks store on my iPad.
Very nice explanation. You should submit this for addition to the Rust Book: https://doc.rust-lang.org/book/second-edition/ and/or to the FAQ for Rust: https://www.rust-lang.org/en-US/faq.html! Great Work!
Since String: Ord, you ought sort the Vec and then use the binary_search method. Unfortunately, the interface isn't quite as nice as the Maps in std::collections; does anyone else know of a crate with an extension-trait or wrapper-type that adds Map/Set-like functionality to sorted Vecs?
[RegexSet](https://doc.rust-lang.org/regex/regex/struct.RegexSet.html) is ideal for this! Also check out my [reset-router](https://github.com/kardeiz/reset-router) crate that provides regexset based routing for async hyper.
yes I am lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 17.10 Release: 17.10 Codename: artful 
https://crates.io/crates/parity-wasm I have no idea about safety audits, but that's the big one in Rust.
I don't know why it didn't work and my networking arsenal was empty after all various combinatorial tests. Thanks guys for helping me ! I found a workaround, pasting it; in case someone else stumbles on the same issue wget https://static.rust-lang.org/rustup/dist/x86_64-unknown-linux-gnu/rustup-init chmod a+x rustup-init&amp;&amp; ./rustup-init I think it might be some issue with ubuntu 17 and curl and open ssl 1.02g combination, donno for sure...
`u8` and `usize` aren't the same size in memory, so you'll need somewhere to store those new values. So you will have to iterate over them. Here's a way to copy a `&amp;[u8]` into a `Vec&lt;usize&gt;`: let usize_vec = u8_slice.map(|x| x as usize).collect::&lt;Vec&lt;_&gt;&gt;();
Agreed. I find that this nice consistency tends to be a feature of languages that are more designed than grown, by people who aren't afraid to ditch ideas that don't fit.
I agree. I have a soft cover book on Python that looks is no more than a year old that looks completely thrashed while my hardback C++ reference manual is still going strong after ~10 years. Sure don't make 'em like they used to...
If you need a *simple* library, I would suggest https://github.com/Drakulix/simplelog.rs. Most of the logging libraries out there definitely have an enterprisey feeling. 
But no Ctrl+F :b.
That was hard to read as the formatting is broken (I don't think \`\`\` is supported in reddit). Having said that, this shows no problems at all. So I don't think it's a curl issue as you speculated in another comment. The problem is just not there any more.
Sorry but I can't quite picture your problem description. Can you post a minimum example on play.rust-lang.org on how you would like it to look like? Up to the point where your lifetimes don't work.
Agreed, though where did you find monads in Rust? It's not aggressive (like "you don't need loops, use recursion"), but there are minor nice things that are encouraged. In addition to what you said, it's returning values from statement blocks, and chaining iterator adapters.
`Option` and `Result` types follow the monad pattern. :)
Are there any good examples of using the `hyper::server::Server`'s method `run_until()`? I am trying to create a server that dies after responding to a specific request but I have been struggling.
r/playrust
Thanks a lot!
Absolutely! Sorry for not providing this upfront https://play.rust-lang.org/?gist=da8461cebc638d4bfe7787fce75f7c88&amp;version=stable 
Shameless plug: [`$ cargo modules`](https://github.com/regexident/cargo-modules). (A cargo plugin for showing a tree-like overview of a crate's modules.)
I'm not sure if this fits your use case (minimum examples usually lose nuances, which in Rust are often important), but you can pass the handler down to the closure: https://play.rust-lang.org/?gist=666245c88a018436dbfa8a6d216e2bd4&amp;version=stable
Yeah, it's a contrived example. At that point (in the real at https://github.com/avenuesec/fix-rust) I dont have access to the handler. 
IMO, the best parts of functional programming are pretty standard "best practices" for designing a programming language nowadays (pattern matching, closures, algebraic data types, ...) so a well-designed general purpose language will usually end up being at least in part a functional programming language.
Rust doesn't have higher kinded types so technically monads can't be implemented in rust
It isn't, though. It places a priority on type safety, which is where things like parametric polymorphism and pattern matching come in, but beyond that it doesn't resemble FP much at all IMO. Even modulo syntax, idiomatic Rust looks nothing at all like idiomatic Haskell. As for the presence of particular monads, I don't think this means anything. It is true that there's a list monad, but literally every language supports lists. Result is also a monad, but I can count on one hand the number of times I've used do-notation with `Maybe` or `Either` in Haskell! Instead, what you usually want in Haskell is not Result, but ResultT, which is a monad *transformer* - i.e., I already have some monadic functionality, and I want to add short-circuiting failure at each step in the computation. Rust really doesn't have anything like this - if you want it, you have to hardcode these two pieces of functionality together from the start, which what they do in Tokio. But IMO the true nail in the coffin is the inability to cleanly curry and compose expressions. Rust closures have lots of extra type baggage that doesn't exist in Haskell, and this really destroys the ability to translate even simple, beginner-level Haskell code to Rust code. You simply have to approach everything in a different way from the ground up. So no, I would say Rust has a relatively good type system, but it's not *functional*. And it doesn't have to be - Rust competes in a space that Haskell simply can't due to its huge runtime and GC.
Yet!
Nothing beats programming in fullscreen. /s
If you don't have access to the handler, where do you get the closure from? Can't you pass a ref to the handler along with the closure to the caller?
&gt; Can't you pass a ref to the handler along with the closure to the caller? The few times that I've tried something similar, the whole lifetime can of worms opens up. But I'll give it a fresh try. Thanks!
&gt; As for the presence of particular monads, I don't think this means anything. It is true that there's a list monad, but literally every language supports lists. Result is also a monad, but I can count on one hand the number of times I've used do-notation with Maybe or Either in Haskell! Instead, what you usually want in Haskell is not Result, but ResultT, which is a monad transformer - i.e., I already have some monadic functionality, and I want to add short-circuiting failure at each step in the computation. Rust really doesn't have anything like this - if you want it, you have to hardcode these two pieces of functionality together from the start, which what they do in Tokio. This is a really interesting perspective! Can you elaborate on the Tokio bit? Does the Try trait help alleviate these issues?
Isn't the `try!` pattern pretty close to this?
&gt; the whole lifetime can of worms opens up I know that feel :@ It's a pretty good exercise though. The more you fight the borrow checker, the less it will surprise you in the future. TL;DR on why you approach won't work on Rust: Rust has no way to know handler is still alive at that point (AFAIK there is no way to guarantee that a closure will get dropped before its container). You can either move it into the closure (and lose ownership, won't work here) or keep a reference somewhere. You can't keep a reference to the handler in the closure itself since the closure can outlive the handler. This pattern works in GC languages since the handler will just get a counted reference to the handler but I can't see it working on Rust (you might be able to contort the code into using Rc but I don't think it's the way to go honestly). I'll let the Rust guru's chime in though.
You're talking about the languages but it's clear your also talking about the communities around the languages. I suppose humble is a way to say the thing you're getting at, perhaps low-key is better. To me even the latter is more happenstance than anything else, so that's what I'd rather call it. Happenstance. Functional programming, especially the typed-lambda-calculus ML style, wields many benefits with regards to safe and somewhat provable code. A lot of those claims really do stand, and putting that out there was necessary to build up those languages and their communities. Now Rust has demonstrated another way forward with regards to memory safety. You can even forgo functional constructs, even if it's no longer idiomatic, and still benefit from this level of both type and memory safety. Of course it's preferable to use a mix of imperative, data-oriented, and functional programming. So functional isn't the end all be all, merely one facet of Rust's strengths, that can be used where it's suited. I also think Rust exists simply in a different era. Much of the language had been demonstrated in concept with older research languages and papers. So there was simply less hype in tandem of a language being developed on the tails of hot-press research. The excitement was in the opportunity to start over and put wisdom into practice that was struggling to see the light of day. To me Rust was a language that was trying to get it's semantics and constructs right, and further has been part of a general movement to create a modern static, compile-to-binary, language experience. So you have Go, Nim, Swift, Julia, Crystal, Pony, and then Rust. Plenty of choices to pick-your-poison. Rust doesn't really need or want to attract people who would only be grieved if Rust was not the right choice for them. It's the era of DSLs. Plus Rust is a language that had early corporate backing, so it's mission statement was always pragmatic and it had an easier time getting past that "bootstrapping a community" curve, so to speak. So while there has been some lamentable evangelism, there has also been, and I'd say mostly, the other pragmatic side that wants to let the results do the talking. Lastly, I also don't think in saying any of this is to diminish what other language communities have done or are doing, but I think might speak to the differences, which I wouldn't dare turn into a humble-brag. 
They can actually be implemented, as you can somewhat already use Higher Kinded Types (the only thing that doesn't work is Higher Kinded Lifetimes), it's just a bit unwieldy at the moment.
I can't help with the actual question but [this](https://github.com/rust-lang/rust/issues/24140) and [this](https://github.com/rust-lang/rust/issues/44868) helped me understand `Borrow` vs `AsRef`.
It seems like you can cut a lot of the mutex stuff and just have a bare global, or have a constructor that returns a pointer that js calls at the start to initialize the world, and then passes back to rust each time. This is "safe" because wasm is all single-threaded, but it's not future proof because wasm won't always be single threaded. It also means that your wasm version might look quite different from your rust version (most people don't want to pull off the same trick in rust). But it is an option to just switch to raw pointers if the mutex is getting in your way and you know you're single threaded.
This allows `&amp;Sequence&lt;T&gt;` to automatically use the implementation for `Sequence&lt;T&gt;`: impl&lt;'a, T: Sequenced + ?Sized&gt; Sequenced for &amp;'a T { type Item = T::Item; #[inline] fn next(&amp;self) -&gt; Self::Item { T::next(*self) } } This can also be used recursively. With this, `&lt;&amp;&amp;&amp;T&gt;::next` just calls `T::next`. You may also want to repeat this implementation for `&amp;mut T`.
Here's an implementation of Monads: https://play.rust-lang.org/?gist=71c8fbd70d5a08afff36552ccda91887&amp;version=stable
I was thinking [of this bit from futures](https://github.com/alexcrichton/futures-rs/blob/master/src/poll.rs#L20), where they include the error parameter very early in the process. The reason the monads/transformers approach is so powerful is that it allows me to isolate specific bits of vocabulary and later explain what I mean. For example, I can easily say in Haskell I want to talk about Redis, so I'll create a vocabulary of three words: `get`, `set`, and `delete`. And I want to describe functionality using *only those three words* and pure functionality. So I can say get this comment data, if it contains something I don't like, delete it, etc.. I can describe all sorts of functionality using *only* these three commands and pure expressions. Haskell will assert for me that I never use any vocabulary outside of this monad. Then, after I've written my logic in this super simple vocabulary, I can later *transform* that monad and say "Ok, in reality, every Redis command has the possibility of an error, so take everything I just said and add an error branch to it, and handle it like this." And I can do this as many times as I want, because the entire process is *algebraic*. There's nothing special or privileged about any of these pieces. It's about separating specific bits of vocabulary, creating a small world for yourself to play in, then later explaining how that tiny, safe vocabulary and all ideas expressed in it can be represented in a larger world - ultimately, IO! (If you want to read more about this, this approach is called the Free monad, but I'm trying to describe why we use it rather than what it is).
It kinda sounds like you are describing the `?` and `map` operators for `Result&lt;T&gt;` and `Option&lt;T&gt;` in rust. https://doc.rust-lang.org/std/result/enum.Result.html#method.map Unless i'm totally missing something.
Running easykana.exe gives this error: thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: WindowError(SdlError("Couldn\'t find display mode match"))', src\libcore\result.rs:906:4 Not sure what to make of it. I'm running at 1440x900 on a single monitor, but AFAICT I'm running my _second_ display as my main monitor (according to Windows at least :P)
It doesn't say it in the Wikipedia article, but if you do try the Taylor series expansion for `cos`, you need to normalize it to `[-pi, pi]` or else you'll get nonsensical results. I learned that the hard way.
Well here the error handling is intertwined with the functionality. You have to say "ok get the comment from Redis (and if that command failed then blah blah) and then check some condition and delete it (and if that command failed then blah blah), etc." I'm trying to say that it's possible to write all of the functionality in one place, then handle all of the error cases later *without* any builtin privileging of some sort of try-catch exception mechanism. With the algebraic approach, there's no hidden magic. I simply get to explain what my words mean at a later time. I can easily do things like specify that certain commands can only fail in certain ways (e.g., you cannot get a "database full" exception from a delete command!). I can even explain my words in exotic ways, like saying actually, I wrote all this logic for Redis, but... I can define valid meanings for these three words in Postgres, so hey, let's use Postgres instead!
After all the [great discussion](https://www.reddit.com/r/rust/comments/7a9w1c/rust_is_now_an_official_part_of_stanfords/) on the previous thread, I wanted to follow up by sharing this year's inaugural final projects, 53 in total completed by 75 students with many Rust-related ones. Also, you can find the other Rust-centric assignment "SparkLite" on the website: http://cs242.stanford.edu/assignments/assign7/
I've done [a similar thing](https://github.com/justinas/tokio-dabblings/tree/master/shutdown) with Tokio. What's giving you trouble?
You cannot write a general Monad trait, but Option and Result are Monads because they satisfy the operations bind and return, in conformance with Monad laws.
If your slice is usize-aligned, you can convert it directly. Otherwise, converting it into a `(&amp;[u8], &amp;[usize], &amp;[u8])` could help. [bytecount](https://github.com/llogiq/bytecount) has such a function, but it is private and only used internally.
And collection types as well, of course.
Note that the Taylor series needs about 7 iterations to reach the accuracy of the intrinsic: https://play.rust-lang.org/?gist=563db40af4a4b69e38ec7dbb96229b3f&amp;version=stable The input also needs to be normalized to `[-pi, pi]` or else the results are wildly inaccurate.
really clear explanation: https://github.com/rust-lang/rust/issues/24140
I wouldn’t say Haskell is the archetypal functional language though. I mean, it’s certainly the archetypal *pure lazy functional language* but there are many FP languages that are not quite so... *academic*.
I'm learning Rust and going through the Project Euler challenges. I have completed #10 but it took far longer than I expected to run which I imagine means I'm doing something very inefficiently. Can anyone spot what it is? My solution is [here](https://gitlab.com/snippets/1691023)
Wow. This feels very very fast, but I'm not sure if it's because typical JS A* demos are poorly written, intentionally slowed down for instructional purposes, or if JS is actually that much slower. 
Hey, I'm Jake, the creator of this little demo! Thanks for posting Steve. This was really fun to make! It's my first stab at really digging into rust and wasm made it very approachable after reading a few recent blog posts. The rust docs were very helpful too.
Yeah, I think some others have mentioned alternatives like this. Check out [this issue](https://github.com/jakedeichert/wasm-astar/issues/3) i made for the purpose of discussion about this. I'm new to rust and i'm excited to hear about other solutions! The mutex pattern caused a few issues for me and forced me to add extra curly braces in some spots... very ugly. 
For this release I'm happy that we have Jim Turner, who has developed the “headline” features which are improved subview and slice taking. He also wrote the release announcement. For ndarray my goal has been that it is something useful that other things can be built upon. It does not have the most features, but we have steady improvements and a solid feature basic feature set. ndarray has also, at times, erred on the side of being more general or universal: providing the traversals and higher order methods to implement numerical functionality with, instead of providing them directly.
You hinted at this, but I’ll state it a bit more directly. The real power of monads is the ability to compose any side effects in. Want a sync and async redis client? No problem just compose your monad stack differently. Want to inject logging for every redis command? No problem in inject it everywhere with a dozen or so lines of boiler plate. Want a different implementation for tests, you get to reuse exactly the same mechanism. 
IIRC, `Mutex` on the wasm-unknown-unknown target is just a `RefCell`, so there's no extra runtime cost.
I also heard that, but the readme.md _specifically_ cited issues with mutex locking and unlocking so :(
Yeah, alex covered my approach pretty well in that first reply :3
I agree with you, but I hope no Haskellites come in here and read that. ;)
It is not just about performance, it's also about correctness.
^Try ^pressing ^^`Alt+Return`
but they’re not applicatives or functors, right? and afaict a monad must also support that functionality too
You’re welcome! Thanks so much for writing this up; these kinds of reports are invaluable, and it’s an awesome project!
On the flip side, though, the compiler can reason that, because any program where printf returns would exhibit UB, printf can never return here, and thus delete all the code that comes after the call (including a function epilogue). It could even tail-call-optimize the call to printf. Which is the reason why the argument "integer overflow is harmless on x86" doesn't work.
One thing that jumps out is that you always iterate over all primes: `filter` just skips all primes bigger than the root. You want `take_while` instead.
Given #[cfg(...)] dependencies, the resulting C code is probably target-dependent.
Is the order of a HashSet guaranteed? 
Is there a benefit using `AsRef` over `Into`?
They are. Functor is just something with a `map` method. Applicative describes something that can arbitrarily wrap a piece of data (`Ok` for `Result`, `Some` for `Option`). It's rare to have a functor that isn't applicative. `HashMap` is an example of something that is a functor, but not applicative or monad
There are a lot of invalid UTF8 paths in Chinese + Linux. Files from Windows usually have GBK paths (in zip or rar, or a USB drive with improper mount options). Also there are files from the past when UTF8 wasn't widely used. You need to decide what to do with them. You may decide to not support those, but since you're using Rust you shouldn't crash (like Python 2) when the filename has unexpected bytes.
You're welcome.
Yeah, there is a reason that even the old timey languages like C++ and Java are racing to get as many of these things in them was possible.
It should be noted that the HashSet iterator will give the elements in arbitrary order, so `take_while` won't work with it because it may stop without giving all elements that fit the condition.
2 second still seems kind of slow. This: fn prime_sum(limit: u64) -&gt; u64 { let mut primes = vec![2]; // We only need to consider odd numbers since even numbers // (barring 2, which we already added) can never be prime. for i in (3..limit).filter(|i| i % 2 == 1) { let root = (i as f64).sqrt() as u64; if primes .iter() .take_while(|x| **x &lt;= root) .all(|x| i % x != 0) { primes.push(i); } } primes.iter().sum() } runs in about half a second on my rather slow laptop. Also you want to make sure you include 2 in your list of primes.
it has `log` in its dependencies. why not to use `log` directly?
That was compiling in release mode. Running your version takes about 1.8 compared to 1.9 for mine. I'm running on an old netbook so I'm not expecting lightning performance. 
I want to be able to have a user define a `format!()`-compatible string to customise the output of my data. `format!()` requires a string literal for its first argument, i.e., the actual format. Is there any way or workaround to either give a variable in place of that literal to use for formatting, or an equivalent?
I'm not sure what pattern matching, destructing and monads have to do with functional programming. Pretty much any language but C has closures. About a decade back actually I said you could—and should—apply a Hindly-Milner type system to a language that is as low level as C and that you could even use substructural typing as a form of "deterministic garbage collection" as I called it which is pretty much exactly what Rust is humorously enough.
So I need to write this up on my blog, but I just spent some time porting a personal project to wasm32-unknown-unknown, using stdweb and cargo-web. Verdict: This stuff is amazingly nice, and feels surprisingly robust and mature for something so new. I spoke with some folks at Faraday.io, and we've decided to try porting some of our in-house Node JS extensions from native Rust code (using Neon) to wasm. This will allow our extensions to work cross platform without recompiling. After having played with Rust wasm, I'm prepared to invest heavily in learning and using it. The web is about to change again...
The biggest thing I miss (coming from python, which I used and abused to write in functional style) is compose. The nature of rust closures being always unique types can be pretty limiting. 
`log` just provides a standardized API for logging (e.g. the macros like `info!`), it does not implement any logging logic. See https://docs.rs/log/0.4.0/log/
I don't know the DNS specification very well, but I thought DNS' case insensitivity was only about ASCII characters. The backtraces and usage of `String`/`char` here indicate that you're paying the heavy cost of Unicode casemapping. Is this really necessary and required by the DNS spec?
You’re the second person to make this comment. It’s definitely possible. But I’m really not dude what that means in a world where we could move to utf8. The RFC’s are not clear about utf8 support, only punycode is directly commented on, and punycode is such a horrible hack in a world of utf8.
I would love to read about that!
For very small collections that fit entirely in cache the vector solution may be faster. For most cases the hashmap will be better.
Might be interested in looking up transducers. I think that's similar to what you're referring to? There is a rust crate or two for it, not sure how well it works. There were also some attempts at reactive extensions(RX) port to Rust, but that didn't seem to pan out well with language limitations I think at the time.
DNS's text format is ASCII. Non-ASCII values are presented in `\DDD` escape sequences. For example the UTF8 `🦀` would be `\240\159\166\128`. Punycode and IDNA come in to play for encoding unicode into a hostname compatible format.
In this post all I care about is the binary format as this is all about the server performance for serving records. For zone files, test the escaped sequence is technically correct, though, long over due for an update to allow utf8 in the file. I support both in trust-dns zones.
Well you _sort of_ can write a trait that meets the definition but it's pretty crude: https://play.rust-lang.org/?gist=045a3482330704864995200baf2e2067&amp;version=stable The trick is that the trait rather than taking one parameter let it take three and letting it take the input and output type of the bind function as parametres to the trait and just implementing it generically over them. So where Haskell's type classes can take type constructors themselves as parameters but can't (without extensions) take multiple parameters Rust can't take type constructors as parameters in traits but can take multiple parameters so you use that to solve it. So basically rather than `Monad Maybe` you implement `Monad (Maybe a) a (Maybe b)` and with that you can I believe just write any monad.
Do you have a good example of this handy? Would love to look at it. 
Great library, excited to check these new features out. 
Could someone speak to whether this is more oriented towards learning rust or mastering it?
slog is neither simple, nor light
it doesn't work -- https://github.com/rust-lang/rust/issues/27812
Then which method is `(&lt;*&gt;)`, on `Result` and `Option`?
Parametrizing the input and the output? Looks more like Haskell's *arrows*, I'd guess.
There's [strfmt](https://github.com/vitiral/strfmt). The published crate hasn't been updated in quite a while but there's some relatively recent activity on the repository. I've never used it myself.
Thanks for the shout-out :) And congrats for beating bind on this benchmark, your work with trust-dns is really amazing. I'm curious, did you have experience with DNS before starting working on trust-dns?
I couldn't agree more. Rust seems like the first truly innovative thing in language design in twenty years.
According to [this comment](https://github.com/rust-lang/rust/issues/27812#issuecomment-224004191), you just haven't added `log` as a dependency in your `Cargo.toml`. Have you done that?
Did you add `log` as a dependency? If not, you're trying to use `rustc`'s private `log`, not the normal one.
I'm not sure from your response that I conveyed what I intended. So sorry if this redundant but just to be clear, the answer to /u/sp3d's question is that an ASCII insensitive comparison is all that is necessary (for both the presentation and wire format of names). In my implementation the parser doesn't accept UTF8 because I think it'd be surprising behaviour for the crate to take in `example. 0 IN TXT "🦀"` and then emit `example. 0 IN TXT "\240\159\166\128"` (which it does accept of course).
I suspect you may be looking for /r/playrust.
beyond using it, no. I started it because I was really frustrated with the existing management tools out there... I have yet to actually build the stuff I want to make that better ;)
Fuck me thanks
Sorry. I responded quickly. Two kids demanding my attention ;) I think your correct in what you describe, and that does seem to be a decent restriction to make for consistency sake. What I’m annoyed with in DNS is that these simple things haven’t been updated. I will implement punycode at some point but it’s so annoying because utf8 doesn’t conflict (I’m pretty sure) with any of the existing label rules. To me this means that we should have an RFC to ditch punycode altogether, and migrate to UTF8. We’d probably need an EDNS option to specifically my that utf8 is accepted.
I mean the "Result -&gt; Option" Monad instance absolutely cannot not obey the monad laws. So that extra power isn't really all that useful. It's also worth noting that every major Haskell compiler has support multiple parameter type classes since before Rust even existed. 
Is this more about convenience/ergonomics of manipulating multi-dimensional arrays, or is there some magic going on relative to memory layout? For example, row-span vs column-span vs-nth-dimension-span etc?
&gt; So you have Go, Nim, Swift, Julia, Crystal, Pony, and then Rust. I know it's not meant to be memetic, but it always catches my attention when someone puts Pony in a list of languages following another one whose name could be used as an adjective or Swift before one that could be used as a noun.
All monads can implement that method in terms of `pure` and `&gt;&gt;=`
&gt; Oh and when you’re ready we should review those other PRs of yours, I’m not sure of their current status. Yeah I took a break for christmas. I came back today, so I'll be back to it next week :)
cool - this works, thank you. In my particular case removing the `?Sized` constraint has no impact ... can you explain why you included it and what its relevance in this context is? I've seen it in std code but never known what it was for exactly.
The `ndarray` crate provides an *n*-dimensional array type `ArrayBase` with flexible memory layout (row-major, column-major, custom strides, etc.). The `ArrayBase` type has methods for slicing, iteration, view-taking, indexing, transpose, broadcasting, some mathematical operations, etc. If you're familiar with NumPy, `ArrayBase` is somewhat similar to NumPy's `ndarray` type. The biggest new feature in 0.11.0 is an ergonomic improvement for creating a view of a subset of an array. (Now "slicing" and "subviews" can be combined in a single operation.) The release announcement provides an example. In addition to the release announcement, you can get an [overview of the `ArrayBase` type](https://docs.rs/ndarray/0.11.0/ndarray/struct.ArrayBase.html) or read more about [the implementation of the biggest new feature](https://jim.turner.link/pages/impl-slicing-subviews-ndarray/).
It allows for using the trait on unsized types such as slices (`[u8]`) and trait objects. By default, generics are assumed to implement `Sized`.
Any plans to integrate with SIMD?
I mean that is just an unnecessary number of qualifiers. It's the archetypal pure functional language and also the archetypal lazy functional language. You only need one of those 2 qualifiers and don't need to limit to statically typed languages for it to be the defacto standard. I also don't think that the academic complaint about Haskell is all that fair anymore, Haskell is very focused on industry and practical programming these days.
`ndarray` has experimental support for BLAS (e.g. OpenBLAS) for matrix multiplication, which AFAIK uses SIMD. There's an `ndarray-linalg` crate which provides linear algebra operations using LAPACK, which AFAIK uses SIMD. `rayon`-based parallelization (threading, not SIMD) is available via the `ndarray-parallel` crate. I'm not sure about any plans for integrating SIMD directly into `ndarray`; that would be a question for /u/neutralinostar.
thx
Hardback books are such a small market, you can take any book and get it library bound. Just a sample, http://longs-roullet.com/Word%20Docs/customer%20service%202015.pdf but about $20. 
When I am going "all in", I methodically cover the book in duct tape. Still have the Perl 5 book intact. In middle and high school, covering your hardback textbooks in paper bag paper was a right of passage. 
Why don't you do a reading in Portland?! Many would attend.
- Some leftover TODOs: https://github.com/ChristopherRabotin/hifitime/blob/bebfd4c5292669e3c007d4ed0ea5200685c7346b/src/lib.rs#L2 - I don't like shortlinks in comments: https://github.com/ChristopherRabotin/hifitime/blob/bebfd4c5292669e3c007d4ed0ea5200685c7346b/src/lib.rs#L28 - `return` can be omitted: https://github.com/ChristopherRabotin/hifitime/blob/bebfd4c5292669e3c007d4ed0ea5200685c7346b/src/instant.rs#L196 - If you have assumptions, do not expose the struct fields: https://github.com/ChristopherRabotin/hifitime/blob/bebfd4c5292669e3c007d4ed0ea5200685c7346b/src/utc.rs#L75 That's all I caught. Maybe use clippy to detect something else?
Check out [unicase](https://docs.rs/unicase/2.1.0/unicase/), it's zero-copy and maybe more optimized.
very cool. thanks for the link!
Trying out some Russian sites DNS seems to respect unicode case.
Your `to_lowercase` could be improved further; currently it iterates twice over the string.
It depends on what you attribute to "functional programming." I would not classify rust as a FP language at all, not even a humble one. To me, for a language to be considered as supporting FP, it makes the following idiomatic, the default, and forces you to go out of your way to avoid them: 1. immutable data 2. pure functions / referential transparency 3. functions are first class 4. lexical closures Note I didn't say anything about pattern matching, destructuring, or monads. Those are tools of convenience, not defining qualities of FP. Rust actually makes those things difficult to achieve. 1 is made difficult by not allowing final / const to be defined by the struct. The rest are all made difficult to achieve because of the borrow checker being the idiomatic default. FP languages usually include a garbage collector for good reason. Between all the lexical closures and the freedom of passing references around by all data being immutable, it becomes very difficult to reason about how long what resources will be held by what components. A GC alleviates a lot of that complexity and allows the programmer to focus on the logic instead of the resources.
LOL. I'm often at the PDXRust meetups, held on the first Wednesday of the month when we get our act together: https://www.meetup.com/PDXRust/ If Powell's stocks it, I'm going to guerilla-autograph them...
Case folding is done as part of Punycode/IDNA/Nameprep conversions from unicode to hostname format. So while the DNS is only insensitive to ASCII letters your user-agent can compensate.
Tell that to the golang folks :|
Many thanks! I've implemented these recommendations. Concerning the short links, I've only added a notice explaining why I use short links. The main issue is that the validation tools I use (NASA HEASARC and timeanddate.com) generate ridiculously long links preventing `rustfmt` to format my code. The work around is to add `info/` between `goo.gl` and the unique ID of the link.
In the worst case, you're definitely correct. But it does return early on the first loop. I didn't want to allocate a String until I knew that it was needed though. I'm open to suggestions of course.
Right, you can do this without losing the early return, by remembering the position at which the first non lowercase character was found and memcpy-ing till there in the new string. memcpy is a loop as well, but a cheaper one since it won't be redoing ascii checks.
The ebook forms and the printed book are both produced from the same source, which we finalized in late November. It seems like the physical book lags the ebook by a few weeks.
I'm really glad to hear it's been useful to you. That's music to our ears. :)
https://play.rust-lang.org/?gist=3443c8b0028ecd625b477b2e20a22759&amp;version=stable Could you help me compile this? What I wan is a mutable ref to the linked list (value) corresponding to the min key
You could use `BTreeMap`s `.iter_mut()` method to get an iterator sorted by key, so `.next()` will return an `Option&lt;(&amp;K, &amp;mut V)&gt;`, of which you can mutate the value.
On windows iirc paths are UCS2 code units, which means they may contain unpaired surrogates, which means they can't be converted to UTF8. 
Here's an [introduction to using free monads](http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html). The Redis example is [from an article I wrote a while back](https://identicalsnowflake.github.io/Redis.html), but it's in Agda and the main focus is about how to make Redis type-safe rather than explaining what Free is. But make sure you're fluent in the basics first!
&gt; Even modulo syntax, idiomatic Rust looks nothing at all like idiomatic Haskell. If you're looking at the architecture of programs, then there's quite a bit of similarity, because writing pure code in Haskell and satisfying the borrow checker in Rust isn't at the end that different.
Just write the links as: /// This is a ridiculously long [link][link_label]. /// /// [link_label]: https://............................................................ and `rustfmt` won't mess with them.
Which projects use `ndarray` successfully? Last time I tried to use it I found it very hard to use :/
`&lt;*&gt;` isn't super-useful in languages without currying, like Rust. Actually, applicatives in general are just clumsy in such languages; you need some way to abstract over function types' arities, which is what currying gives you—in a language with currying, all function types unify with `a -&gt; b`, so this signature: (&lt;*&gt;) :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b ...means that `&lt;*&gt;` works with *any function*, of *any arity*.
Windows is now UTF-16, and technically macOS's internal string representation is also UTF-16, but I'm not sure if that gets bubbled up to Rust. 
Unless something has changed in the last 6 months, the very issue is that Windows is not actually UTF16, unpaired surrogates being illegal in that case. 
Those are all cool projects, but may not be the easiest to contribute to. Check out [TWiR](https://this-week-in-rust.org), it has a list of easy, mentored issues.
The reason for punycode instead of UTF8 is, of course, compatibility with existing, deployed DNS software. While technically labels can contain any octet value, there is this mythical thing called hostname that restricts the values to ASCII letters and numbers and dashes. There are servers out there that are somewhat picky about this. I was told that Microsofts DNS servers will refuse underscore labels. Worse, if a recursor enforces these rules you break lookup for all its clients. The likelihood that some ISP or Wifi access point hands out the address for such a recursor is pretty high. A consequence of this backwards compatible encoding is that all the old rules still apply. In particular, a label is still a sequence of octets and comparison still only needs to consider ASCII-case. Particularly from a performance perspective, this is kind of nice. Even better: IDNA really only is a translation step when passing names into or out of DNS, allowing an application the choice whether it wants to support it or not.
That helps. I did the same in school. The paper cover doesn't work that well with soft cover books, but duct-tape sounds like it would help; I tend to rip the soft cover books in half after a few months of study. I have a nearly eidetic memory for anything I write on, so my books don't see that much use, so it pisses me off to pay for something that falls apart so easily; in the end it just feels wasteful. On several occasions I have printed and bound my own hard cover copies of some technical books for this reason. To clarify, I have no problem paying for the content (I usually donate to the author(s) if possible regardless), but giving money to a publisher for a shit quality binding that will likely end up in the recycling bin a few months later makes me angry.
Do you have an example of something in it that was hard to use?
I really wish Java was more C#ish. I think C# has done some good stuff recently especially when compared to Java counterparts. I think the JVM is really cool. Maybe it's about time I gave kotlin a try.
It would be very exciting to do so. - We take advantage of SIMD in some inner loops just by virtue of autovectorization - As soon as the new simd crate is relatively solid but before it's stable, it can be used as an optional dependency
For master files, I also started out assuming only `u8`s. Non-ASCII characters can turn up in two locations: comments (where they can be safely ignored) and the `$INCLUDE` directive where whatever you get needs to be translated into a `Path` – and if this fails, so be it. But then, on Windows a master file may actually be encoded in, what is it, UCS2? So I decided to re-implement the parser on top of an `Iterator&lt;Item=Result&lt;char, io::Error&gt;&gt;` and have all my bases covered.
You can use `#[cfg(all(feature = "feature_1", feature = "feature_2", ...))]` to conditionally enable tests that require multiple features. You can also write integration tests (in the `tests/` directory) and declare what features they require with [the `required-features` key](http://doc.crates.io/manifest.html#the-required-features-field-optional). These tests will only be run when those feature flags are enabled. 
I see, there seems to be a consensus on this :) I'll take this as a rule of thumb. Thx! 
I would be super-happy to learn about what you think could or should be improved :).
Thanks! The fact is that this list is not only about Rust. Tere are a lot of lists for different languages, such as C, C++, Python, JS etc..
(S)he can make the font smaller to pretend the book is quicker to read :-)
`Into` takes ownership and allocates. See [this](https://ricardomartins.cc/2016/08/03/convenient_and_idiomatic_conversions_in_rust).
As much as Rust is inspired by functional programming, it's not a functional language. It's not based on the lambda calculus. It does not have inductive data types. It does not have any kind of formal theory regarding how its types or evaluation work. Rust is great, but it belongs to a different family, and this post is every bit as obnoxious as an overzealous functional programmer.
Out of curiosity, are you already using [wasm-gc](https://github.com/alexcrichton/wasm-gc)?
Yeah, it doesn't work properly in a lot of cases. If I run it, it simply deletes the WASM file. It also isn't that great at minimizing files, I tried minimizing a 60KB file, it minimized it to 50KB, which is not much better. If you look at all of these WASM games, their file size is still in the 60KB range, which is a lot (in terms of load time). 16KB is obviously better (the reason was that I enabled `panic = abort`).
I'm getting the expected compile time error: https://play.rust-lang.org/?gist=1637cbce8924a4519ad2d69005a38dc8&amp;version=stable Mind sharing the code in question?
I'm getting the expected compile time error: https://play.rust-lang.org/?gist=1637cbce8924a4519ad2d69005a38dc8&amp;version=stable Mind sharing the code in question? 
That would mean the code would panic instead of returning `Result` if someone accidentally missed the return type of the function signature. I don't know about you, but I wouldn't want my code to panic because of a simple mistake. Worse, the reason for the panic wouldn't be obvious.
Doesn't #2 exclude both the MLs and the lisps, which practically speaking is all FP languages? The only practical pure language I know is Haskell and referential transparency requires purity.
Panics are a very different beast to `Result`s, and I think it would be a mistake to conflate them syntactically. A `Result`-returning function can be expected to return `Err` as part of normal program execution. There is nothing "abnormal" about seeing an `Err`. Panics *are* abnormal. They should only appear if there is a bug in the program, or possibly a problem in the environment which the program is powerless to recover from (e.g. mandatory configuration file that's missing). `Err` *must* be handled gracefully; panics typically *cannot* be handled at all. Sure, in some cases you can do sensible things on panic; a sensibly compartmented web server should probably serve up a 500 Internal Server Error, e-mail the error to the sysadmin, and restart the worker. But it cannot *recover* and just have the worker keep going as if the panic never happened. That's not the purpose of panics. Now, I do agree that it would be *useful* sometimes. I'm personally a fan of allowing debug builds to defer certain compiler errors to runtime, and instead have it, say, automatically attach to a debugger if that error is reached. But that would be for prototyping only, and not an actual language feature. And you were right the first time: `?` is an operator, not a macro. 
To combine what a few people here have already posted, and add some more information, you're likely going to need two crates, an "interface" crate and an "implementation" crate. This is fairly common pattern. * `log` for your "interface" crate. This defines an API for logging. * I recommend `log4rs` as your "implementation" crate. `slog` solves a much more complex problem than what you have (by the sounds of things). I've used `log4rs` in some side projects and found it handy. 
I think it would be pretty obvious what the reason of the panic is, the panic would tell you the line it happened in, and could say a message like "Used ? on a function that returned an error: (fmt::Debug of the error if possible)". 
I'm suggesting the compiler *doesn't* throw a compile time error, but instead panics when reaching that code.
&gt; So I need to write this up on my blog, but I just spent some time porting a personal project to wasm32-unknown-unknown, using stdweb and cargo-web. Verdict: This stuff is amazingly nice, and feels surprisingly robust and mature for something so new. Author of `cargo-web` and `stdweb` here. I'm really glad to hear that! I would also love to read about your experiences.
Thanks for sharing. I haven't looked at it, but my first thought was that naming it "s3" will be lead to some confusion and not good searchability.
The purpose of the question mark operator is to make an early return of a Result type (in future also the Option type) while reducing boilerplate that might be involved in a match expression. For something small where you are just trying out things and are you are pretty sure that unwrap() is safe for your purposes, then just unwrap() or except(). However, the moment you want to do anything slightly serious you want to be making use of the Result + Option types, including using the ? operator. It more verbose than you might find in other languages, and esp dynamically typed languages like Python or JavaScript. The biggest benefit of languages like Python or JavaScript is that its really easy to prototype or get something small done very fast. However, the benefit of a language like Rust is that it almost completely lacks a Null type and many errors would be run-time errors in other languages are caught at compile time. These two types + the compiler constraints forces you to write code with some reasonable error handling (unless you write unwrap/expect everywhere) and is very predictable.
I think you are looking for `.expect("...")`?
Promoting compile-time errors to runtime errors implicitly sounds like a bad idea. It doesn't matter if the panic is obvious when it only occurs in production. 
thx
Seems like a bad idea. The fact that broken code almost always fails to compile in Rust is a good thing. It means that when something compiles, it usually works, which isn't generally the case with any other language exactly because they allow things that cause runtime errors to compile quietly. Also, having .unwrap() after all unhandled errors makes them easy to spot when you want to handle them later.
My whole reason for using Rust instead of Python is so that, if I don't explicitly handle every error, it'll fail at compile time. It's bad enough that there exists no tool which I could hook up to promote the existence un-caught panics (either in my code or in dependencies) to compile-time errors unless they're in a whitelist of manually audited panics I maintain.
+1 eagerly awaiting its availability on Amazon UK.
FWIW, it has closures and first class function atleast. 
If your "to string" function is basically a debug print, you should look at [Debug](https://doc.rust-lang.org/std/fmt/trait.Debug.html), which is derive-able. Otherwise, you could implement [Display](https://doc.rust-lang.org/std/fmt/trait.Display.html).
The compiler doesn't know exactly how you want your data to be pretty-printed, so you have to implement it yourself, as said by /u/steveklabnik1. However, the compiler is able to derive debug for you since it can put the data into a format where it prints all of its members, but may not necessarily be pretty.
IMO in these situations I just define one function for testing `foo` and then have many assertion cases.
&gt; I could not for the life of me figure out how get a Name implement a Borrow&lt;Q&gt; where Q would have been DecodeName&lt;'r&gt; (or RrKey to DecodedRrKey&lt;'r&gt; which is what would have been needed). [...] So I leave that as a challenge to someone who knows Rust better than I. Cross-referencing here the URLO thread: https://users.rust-lang.org/t/making-trust-dns-faster-than-bind9/14727. In general I think it is great to hit and record this kind of dead ends on your issue tracker so that other can look at it. I personally like the [tracking](https://github.com/kbknapp/clap-rs/issues?q=is%3Aissue+is%3Aopen+label%3A%22M%3A+mentored%22) on clap project.
That could possibly be because it panics. To ignore an error you could always `let _ = thing_returning_result`, but IMO it is always better to at least report the error. You should look into why it stops when an error happens.
Are you sure your internet is working? Try `wget` or `ping`ing `sh.rustup.rs`.
I wanted to share with you all this latest mad science experiment. I'm a strong believer in web components. They let us create reusable blocks of HTML without caring about the tech behind it. I think instead of trying to recreate React in Rust, it might be more beneficial for us to think of how we can create Rust web components that co-exist with other JS technologies.
You could condense this into one match (something like [this](https://play.rust-lang.org/?gist=f1d81a035e874edc0c530cb50328384e&amp;version=stable)?).
At the moment I can't see the benefit of that approach as long as the main part is written in JS (all inside the `js!` macro). Do I miss something?
Seems the definition of 'functional programming' varies between people. It's certainly not *pure* functional. I'd describe it as multi-paradigm certainly to avoid confusion
What's the advantage of elfkit over using musl?
I agree, ideally I would like native Rust methods for modifying the DOM of the element that's currently handling an event. The interesting thing to me in this proof of concept is that the code for setting up the web component definitions is abstracted and could be put into a library ideally.
As far as I know ignoring a normal `Result` different from a `Future`/`Stream` result. So your `let _ =` approach would not work here, does it?
&gt; I mean that is just an unnecessary number of qualifiers. It's the archetypal pure functional language and also the archetypal lazy functional language. You only need one of those 2 qualifiers and don't need to limit to statically typed languages for it to be the defacto standard. Fair point. &gt; I also don't think that the academic complaint about Haskell is all that fair anymore, Haskell is very focused on industry and practical programming these days. Yeah. I meant more in the sense of having a really rich type system and explicit connections to category theory. Compare eg. to Clojure whose type system is both dynamic and very simple by design. No endofunctors or catamorphisms there—it doesn’t even have an option type in the standard library!
Since you're creating a string and attache it (`element.innerHTML= ...`) it would be cool to use a template library like [maud](https://maud.lambda.xyz/) for building the html string. Do you think that would work?
Looks cool :) I don't see why it shouldn't be possible. Looking at that website seems to indicate you can just take the result of that macro and turn into a string.
Can elfkit be used to rename symbols in an existing ELF object? For example, prefixing every public symbol in an object file with a crate hash?
&gt; I can count on one hand the number of times I've used do-notation with Maybe or Either in Haskell! Really? When I coded in Haskell, I used very often, typically in a pattern like this: foo = fromMaybe someDefaultValue $ do one &lt;- someOpReturningMaybe arg two &lt;- anotherOpReturningMaybe anotherArg foo -- etc. return $ someFunc nine Interestingly enough, you can [replicate it in Rust](http://xion.io/post/code/rust-iife.html), too, using the `?` operator for `Option` inside an immediately-invoked closure followed by `unwrap_or`/`unwrap_or_else`.
It seems I wasn't clear enough so allow me to clarify some. I'm writing (with the goal of learning rust) a small 8086 emulator. In this emulator I have a few instruction enums of opcodes with similar logic: ```rust enum Jumps { Jo(Word), Jno(Word), Jc(Word), Jnc(Word), // And so on. } ``` Now, I would very much like the emulator to be able to print those instructions, so I have a disassemble function which currently has a lot of: ```rust let opcode = match *self { Jumps:: Jc(_) =&gt; "jc", Jumps::Jnc(_) =&gt; "jnc", // And so on. ``` Now, that is rather a pain which can also include stupid errors. I have not been able to make the enum_derive crate the person above you suggested to work (the macros fail on me and I have no idea why) so for now at least I'm back to doing it manually until I figure it out. 
&gt; lisps, which practically speaking is all FP languages As there is no definition of what FP is, there will never be consensus. Just like OO (Smalltalk, Java, C++, Go can all be defined as being and not being OO). As a Haskeller, lisps are imperative languages to me, but I understand this is just my opinion :)
It has been answered at SO. Aperrently you need to add the `main` function and surrounding elements yourself, prepended with a `#`, like so: /// # Examples /// ``` /// # #[macro_use] /// # extern crate advent9; /// # fn main() { /// /// let bytes : &amp;[u8] = b!("this is a bytestring"); /// /// assert_eq!(bytes, [116, 104, 105, 115, 32, 105, 115, 32, 97, 32, 98, 121, 116, 101, 115, 116, 114, 105, 110, 103]); /// /// # } /// ``` #[macro_export] //bla macro_rules! b { ($string:expr) =&gt; { $string.as_bytes() } } 
Not sure this is an easy question, more a general architecture question. I would like to use Rust (for the first time, complete newbie) to replace a Haskell program that parses a large XML file, and serializes part of its content into a binary file. The Haskell program is a tad slow, and uses way too much memory, so I thought Rust would be perfect for that task. I already tried a few month before, but the libraries I found were horribly slow. There is now the `quick-xml` crate that is fast enough, based on my first tests. So my question is : how do I write a complicated parser on top of it? In Haskell I used the `hexpat` bindings to get the even stream, just like `quick-xml` seems to provide. However, I know how to abstract over this in Haskell (here, a `parsec` instance), but I have absolutely no clue on how that is done in Rust. From what I can understand, it seems very, very tedious. So how do you guys parse non-toy xml files?
I rewrote the web component in src/main.js entirely using Rust and updated the small README example to use entirely Rust based API. Hopefully it shows the potential more clearly.
Because it's a type error, not a runtime error. It's like asking "Why doesn't a function that takes an i32 panic when passed a string?" Because it's a type error that can block compilation.
/u/kouteiheika I would graciously appreciate your opinions on this POC
Alternatively... impl&lt;T&gt; Option&lt;T&gt; { pub fn liftA2&lt;U, V, F&gt;(self, other: Option&lt;U&gt;, f: F) -&gt; Option&lt;V&gt; where F: FnOnce(T, U) -&gt; V, { match (self, other) { (Some(x), Some(y)) =&gt; Some(f(x, y)), _ =&gt; None, } } }
As I understand, OP want to replace ? with .unwrap() inside function that doesn't has an Result return type. 
https://doc.rust-lang.org/stable/rustdoc/documentation-tests.html#documenting-macros
`?` is defined to unwrap any Result or Option. So your revised design requires changing the error message at compile time. This is obviously not backwards-compatible.
So, &gt; taking ownership of the slice Slices don't have ownership, so you can't "take ownership from the slice", you have to copy. It inherently *has* to do the copy if it's not UTF8, as it needs to replace parts of the string. The only way to get around copying is if it is valid utf8, in which case, you can use `from_utf8`. If it's sometimes valid and sometimes not, you could use `from_utf8` first and then if it returns an `Err`, use `from_utf8_lossy`.
That's because it's not a functional programming language. 
That's what I thought, too, but was lured by the sweetness of typing 's3' on the command-line and decided to go with it anyway. However, I am super-open to alternatives, ideally acronyms that spell out major security best practices. What about 'apts - avoid plain text secrets' or 'npts - no plain text secrets' :D?
&gt; Slices don't have ownership, so you can't "take ownership from the slice", you have to copy. Ah you're right. I probably should have mentioned `Vec` instead. &gt; If it's sometimes valid and sometimes not, you could use from_utf8 first and then if it returns an Err, use from_utf8_lossy I was thinking of this as well, but we'd still have to clone things when for example reading all invalid data (say the output of `/dev/urandom`). This isn't too common, but I was hoping there's a way Rust could just take a `Vec` of sorts and modify it in-place when replacing parts of the string. Is there anything like this, or perhaps a lightweight-ish create for that?
What about "sheesy" (**SH**ar**E**-s**E**crets-**S**afel**Y**)? https://www.urbandictionary.com/define.php?term=Sheesy
&gt; I was hoping there's a way Rust could just take a Vec of sorts and modify it in-place when replacing parts of the string. You can't make this guarantee in any real useful way. � is three bytes long; unless the amount of messing up is exactly divisible by three, this just can't work.
&gt; I noticed my macro recursion limit went really high very fast. Yes, that is unfortunately necessary until I make the `js!` macro a procedural macro. (Still waiting for procedural macros to stabilize; I rather not maintain two implementations of the `js!` macro simultaneously.) Also, your recursion limit of `256` isn't really that high; `stdweb` itself has it set to `1500`... (: (In case you're wondering - this is why `stdweb` compiles so slowly currently.) &gt; I would graciously appreciate your opinions on this POC Well, it certainly an interesting experiment. I'm not super familiar with web components so I'm afraid the feedback I can give you is quite limited. A few suggestion I could give would be: * Your `WebComponent` trait is stateless; I think it would make a lot more sense to make it stateful. (That is - every method should take a reference to `self`.) * The `window.currentElement` global you're using seems like something which you could get rid of if you make the `WebComponent` stateful. * You could replace some of the JS snippets you're using with methods from `stdweb`, e.g. you could use [`stdweb`'s add_event_listener](https://docs.rs/stdweb/*/stdweb/web/trait.IEventTarget.html#method.add_event_listener) instead of your own wrapper, you could use [`stdweb`'s alert](https://docs.rs/stdweb/*/stdweb/web/fn.alert.html) instead of defining your own, etc. * You have a comment which says "giving arrays to stdweb isn't possible or expensive" - it's certainly not zero cost, but it is supported and should work. (: In general I wouldn't worry about the performance too much in a proof of concept like this. * `result.as_str().unwrap().to_string()` -&gt; `result.try_into().unwrap()` is more idiomatic and efficient (`result` is a [`Value`](https://docs.rs/stdweb/*/stdweb/enum.Value.html) here; for `try_into()` to work you need to import the [`TryInto` trait](https://docs.rs/stdweb/*/stdweb/unstable/trait.TryInto.html)) Hope this helps!
Lovely! Now let me see if I can make it into something that can be typed comfortably in a shell... .
/r/playrust
"shsy"
/r/playrust
That would be a terrible idea. To build stable and reliable software you need to catch as many errors as possible at compile time.
Ah, in that case I think I'll go with your earlier proposal to use `String::from_utf8` with `String::from_utf8_lossy` as a fallback. Thanks!
But partial application is still possible in Rust, via closures: `|x| { f(true, 5, x) }`.
Great! Will do. This also has the added benefit that I can announce the next version again, and in an entirely new year :). Thanks for the suggestion!
This looks pretty cool. I'd love to try this out. One thing that struck me as odd, though: the README says &gt; deploy as single binary, no additional executables or dependencies are required to use all of the features And then the next thing it says is: &gt; Don't reinvent the wheel, use gpg for crypto You may want to reword the first goal, since it has a dependency on gpg. I'm not sure you'll be able to achieve the first goal without using something like `rustls`, which is not security audited yet.
You're welcome.
If you have a `Vec&lt;u8&gt;` (or something similar that can be grown), you could go over the content once and count the number of characters that need replacing, then add twice that amount to the end of the string, and finally work your way backwards, moving legal sequences and replacing illegal bytes as needed. No idea if that is more efficient than just allocating a new buffer of the right size and being able to non-overlappingly copy legal sequences. 
Thank you! I have reworded the README a little - hoping it's a bit clearer now. Indeed, it became evident later that `gpgme` is not functional without a `gpg-agent` present or available on the system, so a `gpg` installation will always be required. Using `rustls` is out of scope, too, even though it could be interesting one day in the far future!
Yup! That's why OS strings (and, by consequence, paths as well) use [WTF-8](https://simonsapin.github.io/wtf-8/) internally.
Hey, thanks for the shoutout to my optimisation article 🙂 One thing to note about lower-case comparisons is that you can use `&amp;[u8]` and then [AsciiExt::eq_ignore_ascii_case](https://doc.rust-lang.org/std/ascii/trait.AsciiExt.html#tymethod.eq_ignore_ascii_case), which wastes less space and might improve your +/- numbers since it's the same speed every time. If you're worried about deduplication you can use a [`FnvHashSet`](https://github.com/servo/rust-fnv) instead of a `Vec` for elements that want to be deduplicated, but I think that using `eq_ignore_ascii_case` removes the need for hte deduplication.
If you're happy with Debug but want more formatting, you can use print!("{:#?}", val), which will pretty-print the Val.
&gt; having seen what pass actually is and how difficult it can be to use it especially in conjunction with gpg Could you explain this? I've been using `pass` for a while now, and it seems to integrate pretty seamlessly with gpg. What issues did you run into?
You can use parser combinator libs like nom to parse the format string, then either use this at run time, or in a procedural macro
You can use parser combinator libs like nom to parse the format string, then either use this at run time, or in a procedural macro
The qualification &gt; it makes the following idiomatic, the default, and forces you to go out of your way to avoid them makes those qualities apply to MLs (and even Schemes), quite well, ime.
This is exactly the sort of low-level discussion and zealotry that has got me to stop writing Rust and consider leaving the Rust community. This is an entirely self-congratulatory post that has no hint whatsoever of irony (praising the language for being humbler than all the others??). "None of the condescension"... aside form insulting functional programming communities? Nothing technical that has been said here is true, and it is *transparently* wrong. So your reward for cutting through the smugness someone saying "Rust is a humble functional programming language" when it doesn't even optimize tail recursion. What a stellar community. 
I'm not an expert in the field, but I don't know how you could hold this view unless it's from total ignorance of PL research. This is not a knock on Rust, btw. I like it very much. But there's been heaps of astounding innovation in language design over the last 20 years, and Rust is mainly just cherry picking some of these results.
Calling this S3 is a pretty poor choice.
I’ll take a look. Thanks for the pointer!
OK, granted. I may have been engaging in some hyperbole. What I meant is that I feel personally, as a non-academic who has been working in the industry for about 25 years, that Rust is the first language/community/etc that has come along that I've seen that actually seems to have sufficient momentum and direction to actually do something about the stagnation we're in with dynamic/gc'ed languages and result in something that truly is a "better C/C++" and actually solves the modern multi-core problem in an efficient, useful, and productive fashion. When I dug into things like Haskell, although I found the ideas elegant and powerful, not unlike scheme/lisp, I generally walked away feeling this is not going to gain any real traction in the wider industry and is not producing efficient enough, close-to-the-metal code. On the other hand, when I started reading up on Rust, digesting the RFC's, and reading the trials and tribulations of the Rust community, I felt like, "Yeah, I can see this becoming a major player. I can see myself coding large project productively and usefully in this." I find the whole borrow checking and concurrency safety to be a truly comfortable way to think about issues of memory management once you get your head wrapped around it. I guess, at the end of the day, I just, "Like it"!
Yes. All of these are valid. I know that I *need* to support punycode, it’s just an annoying thing. I might work on that next. In terms of MS not supporting underscore, they must have fixed that by now? It’s required in SRV and TLSA record types.
This is an interesting one! My experience is based on setting up tooling around `pass` and `gpg` for by now more than 250 developers on OSX and various Linux hosts. The goal was to make it as easy as possible for the common user who really has no interest in learning GPG or pass, to get started with crypto. Additionally they must easily integrate the stored secrets into their build pipelines. `pass` is just a bash script, which actually is not self-contained. It depends not only on `gpg`, but additionally on `tree` and `getopt`. You would be surprised by the amount of system configurations which don't have 'tree' or which are sent straight into a loop when `getopt` was installed with `brew` (I have no idea why it does that, `brew reinstall gnu-getopt` will fix the issue though). `gpg` unfortunately has a terrible user experience out of the box. It starts with the non-hierarchical layout of arguments which make it hard to get started with zero knowledge. On top of that you have undescriptive and downright misleading error messages, which are great at hiding the root cause of the issue. To make using `gpg` even harder, it turns out that minor version changes can affect the available program arguments so it prints out things like 'trying to guess what you mean', which makes it hard to cater to all possible versions out there. `s3` (or soon `sheesy`), tries to get rid of the dependency on the `gpg` program, and get direct access to the gpg-errors to help wrapping them into something more explanatory and useful to people who don't know anything about the GPG web of trust, and all the reasons that might cause decryption failure.
You are welcome to suggest better names - there is already a thread about this further up. The project is still early in development, and I don't mind yanking a few crates and changing some names to the better.
That sounds odd considering Lisp was specifically designed to map the lambda calculus.
A bit more concice, your labels can match the text immediately: /// This is a ridiculously long [link]. /// /// [link]: https://...
The lambda calculus is pure though. 
Oh I see. I'm just one person, so the dependency issue isn't a problem for me. Also, even though I use `pass` almost every day, I never actually need to interact with `gpg` directly. My gpg agent prompts for my master password and that's pretty much it. I do agree that gpg has a less-than-ideal UX. I use it infrequently enough that I haven't committed its various incantations to memory, and I always find it difficult to re-learn it when I need it. But this doesn't have anything to do with my use of `pass`!
That use also allows you to avoid managing a Web of Trust, which would involve importing keys, and (locally) signing them, or trusting them ultimately. The Web of Trust is an awesome idea, and I really, really want it to be usable thanks to `s3/sheesy` and maybe even provide a visualization for it. But right now, it's easier for the tooling described above to just make it very easy to locally sign they keys with simplified user interaction. After all, I didn't dare to just use 'alwaystrust' such as `gopass` does (https://github.com/justwatchcom/gopass/issues/305) to workaround people not being allowed to encrypt content..
Probably something in an unsafe block is dereferencing a bad pointer. It is hard to say more without more information. Can you share a link to the code? Or a small example? 
Very impressed by this as a first crate. Only a few comments and nits: Module documentation should be in the module being documented: https://github.com/ChristopherRabotin/hifitime/blob/master/src/lib.rs#L80 ### Consider re-exporting to better encapsulate your API Might want to consider keeping those modules private and re-export (`pub use ...`) only your public API to make your crate simpler to use. use hifitime::utc::{Utc, TimeZone, TimeSystem}; use hifitime::instant::Duration; use hifitime::julian::ModifiedJulian; Becomes: use hifitime::{Utc, TimeZone, TimeSystem, Duration, ModifiedJulian}; ### Use clippy (linting) A few cases like this: https://github.com/ChristopherRabotin/hifitime/blob/master/src/julian.rs#L66 This should be `into_*` as per the budding API guidelines: https://rust-lang-nursery.github.io/api-guidelines/naming.html#c-conv You can catch these and a number of linting violations if you install and run clippy: $ cargo install clippy $ cargo clippy
I was looking at this just a day or two ago, and I'm wondering why from_utf8_lossy doesn't return a `Cow`? The majority of the time, it probably doesn't need to make a copy, but if there *is* invalid UTF8, then it could make a copy as needed.
All `let _` does is make rust stop shouting at you about unused results.
i believe it could have and this was an oversight, IIRC.
You could `#[derive(Debug)]` on it (and `Word` and what it contains) and see if it is satisfactory?
Is that something possible to change in the standard library now? Or at least can we add a new API to do so?
I can't wait for JS support in Rust game engines now. Being able to write Piston/... code and run it in browsers too is great, but right now everyone seems to be writing their own JS interface.
thanks! Do you know by chance what exactly the differences are?
I think the same is true for the `vault` subcommand, which may lead to people expecting hashicorp vault integration.
I am having a hard time understanding how I need to set up the shutdown signal channel/future. The problem probably stems from my last if understanding of using channels to communicate across threads and how futures work in Rust. Thanks for your example I am going to have to spend some time with it to understand what is going on.
I like the look of this. Have been hoping for a multi-person `pass` like tool to replace my [blackbox](https://github.com/stackexchange/blackbox) usage, and this feels like it could fit the bill :-)
While we’re on the topic, it's good to note that to_lowercase and other similar functions could also probably return Cow. It would be a breaking change, so I don't think it's possible to fix in the near future. It would be nice if we could get some Cow APIs for these functions added.
`String::from_utf8_lossy` probably should return a `String`. But adding `::std::str::from_utf8_lossy` sounds like a good idea.
Strings internally are of type UNICODE_STRING, I can't find any super great references on this but here's an OSR (NT kernel dev) thread on it, where they confirm it's intended to be UTF-16: http://osronline.com/showThread.CFM?link=238475 https://simonsapin.github.io/wtf-8/#motivation describes some of the well-formedness issues in more detail
Since Cow derefs to the underlying string, would it really be a breaking change?
Is this mostly intended for Linux, or would Windows benchmarks be of any use? I don't really know how any of this works, and if it would depend on that. It overflows its stack each time I ran the benchmark, but not sure if that's expected and still valid, or if it's because of Windows. Seemed to get wildly (100s mb/s?) different result each time it ran, but again, this might be because of the aforementioned things, and not sure if that's even the metric to go by. Can post more details or an issue later if it's actually any use.
Yes. The type still changed, `Deref` isn't enough. I'd imagine this would break a lot of currently compiling code.
We'd need a new API, yes.
Initially I thought it was a play on [Shamir's Secret Sharing](https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing).
[Doesn't it return a `Cow&lt;str&gt;`?](https://doc.rust-lang.org/collections/string/struct.String.html#method.from_utf8_lossy)
That’s exactly what I was looking for, thanks! I now wonder how I’ve never found that... By the way, do you perhaps know some resources to look up the difference between `expr`, `ident`, `tt` and so on? Because I found some description in the rust book(s), but am still a bit lacking in knowing when to use which one in my macros.
To whatever degree a particular Lisp models the lambda calculus, it follows those rules, because the lambda calculus has those traits. Features that go against those rules are deviations from the lambda calculus. Maybe a good rule of thumb for judging how functional a language is would be to examine how frequent the deviations are.
I was thinking of something else related then, like to_lowercase, but I've had a busy morning, so I didn't properly check before commenting. I've been doing a lot of string stuff lately.
And what if you don't care about � symbol, and just use some single byte character instead, or just remove all invalid bytes. Then you'll be able to do it in place.
Also `Cow&lt;'a, str&gt;` derefs to `str`, not `String`.
Easy. Just add a PR with a `Cow::from_utf8`/`Cow::from_utf8_lossy`, mark as `unstable` and see what happens.
Why isn't there a way to check the element pointed to by an iterator without changing it's position? As far as I can see, all iterator methods that return something seem to call `next()`, which increments the pointer to the underlying data. Even `peek()` calls `next()` if it hasn't been called before for a particular element. TL;DR - Why can't I just do `let var = some_iter.curr();` to access the value pointed to by an iterator without modifying the iterator?
Yes. It's not really what you're supposed to do, but you could do it. Removing the invalid bytes would also be copying much of the data.
It's pretty new, so I'm not sure people really know about it. It is linked from the doc home page. The book and https://doc.rust-lang.org/reference/macros-by-example.html are the only two bits of documentation right now.
right, that too.
With hyper, you write it yourself, basically. As for shio, https://github.com/mehcode/shio-rs/issues/11 suggests that maybe some support exists, but I couldn't find it. I imagine it's the same, though I'm not sure. Another option, which is common in the Ruby world at least, is to have nginx in front of your application server and let it handle static file serving.
I am trying to write a shell in rust and need to have signal handlers/send signals to programs. I have been looking around and mostly found stuff referring to libc, is this still the recommended method?
Some lisps are more FP than others. Schemers treat mutation as a dirty optimization. Common Lisp is closer to C++ on the functionality spectrum.
I disagree with the claim that Rust is better than C++ at preventing memory leaks. Rust and C++ are pretty much the same in that regard, both relying on RAII for this (stack allocation and unique / reference-counted smart pointers).
I've used https://marketplace.visualstudio.com/items?itemName=webfreak.debug in the past.
Rustfmt returns the following when I try to place the link with a label: ``` Rustfmt failed at stdin:30: line exceeded maximum length (maximum: 100, found: 342) (sorry) ``` Here's how I changed the code exactly: ``` As an example of how this is handled, check the Julian //! day computations for [2015-06-30 23:59:59], //! [2015-06-30 23:59:60](https://goo.gl/QyUyrC) and [2015-07-01 00:00:00](https://goo.gl/Y25hpn). //! //! [2015-06-30 23:59:59]: https://heasarc.gsfc.nasa.gov/cgi-bin/Tools/xTime/xTime.pl?time_in_i=2015-06-30+23%3A59%3A59&amp;time_in_c=&amp;time_in_d=&amp;time_in_j=&amp;time_in_m=&amp;time_in_sf=&amp;time_in_wf=&amp;time_in_sl=&amp;time_in_snu=&amp;time_in_s=&amp;time_in_h=&amp;time_in_n=&amp;time_in_f=&amp;time_in_sz=&amp;time_in_ss=&amp;time_in_sn=&amp;timesys_in=u&amp;timesys_out=u&amp;apply_clock_offset=yes ```
This will already help a great deal, thanks!
Hmm.. A better word for it might be 'loud'. And thanks for the great blog post!
Archetypicality aside, Haskell is firmly rooted in some uncommon paradigms beyond FP, such that the difference between "Haskell-like" and "typical" (in this case Rustic) idioms encompasses a lot more than FP-ness -- which affects the salience of the original comment's comparison.
It's not mythical. RFC 953, 1034, 1035, and 1123 all recommend names without underscores. 1034 and 1035 say: &gt; The labels must follow the rules for ARPANET host names. They must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen. There are also some restrictions on the length. Labels must be 63 characters or less.
I specifically gave the jump instructions as an example because Debug is not satisfactory to me. Some instructions (like, lets say, Aaa or Xlat) are simply that, one word and everything good. In the case of the jump instructions they are supposed to look like `jc 0x1234` which is rather different then what debug outputs. When I get to the more complex opcodes I'm going to have to be able to print something like `mov bx, word cs:[bp + 0x7]` with the cs coming for an opcode prefix and the other things from a postfix and what not. I *can* use regexes on the debug output but that is simply a complete hack for something I expected to be rather simple...
Please see the chain above you with Restioson. My problem is most definitely not a lack of formatting, the exact opposite in fact. To summarize, I need only the name of the enum value without any matter to what it holds inside it or any formatting.
Any time :)
If cargo works on another machine, run `cargo build --verbose` to see all the `rustc` calls. This will require downloading and compiling all transitive dependencies as well, so be warned :)
I just looked up "trusting trust." There's some really cool hacker history in Ken Thompson's 1984 paper ["Reflections on Trusting Trust"](https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html). Check out the "Moral" section.
You can take a look at https://github.com/seanmonstar/futures-fs.
It is always possible. To compile a crate, you need 1. to compile its dependencies 2. to pass the correct flags to rustc This is true of your program, regex, which it depends on, and every crate that regex depends on, and every crate that depends on that. `cargo build --verbose` will show you all of the invocations it makes.
I would need to share a lot of code, in order for you to reproduce the results. I do use some assembly functions inside Rust, so they are the only stuff inside the unsafe block. Is there any way to get backtrace inside the bench tests?
Thanks, didn't know about that. Looking at the verbose output it looks like regex gets compiled with a bunch of other modules and produces a libregex-e12695b1b063c1f0.rlib. I thought I would just be able to take the produced libregex from my one pc and move it to the other so anytime i wanted to use regex I was just do rustc test3.rs --extern regex="libregex.rlib" (I renamed the libregex) But somehow even this doesn't work, is my assumption that I only need the libregex somehow wrong? Do you know what the minimal environment I need to be able to compile with regex is? The error C:\Users\Admin\Desktop\rust&gt;rustc test3.rs --extern regex="libregex.rlib" error[E0463]: can't find crate for `aho_corasick` which `regex` depends on --&gt; test3.rs:1:1 | 1 | extern crate regex; | ^^^^^^^^^^^^^^^^^^^ can't find crate Thanks so much for the help!
Please see: https://tools.ietf.org/html/rfc2782 SRV records now explicitly allow underscore in labels. TLSA records as well. I believe this would also mean CNAME records may contain underscore. 
ugh, this path is beset with problems upon problems... it runs fine in the console, but it keeps finding new excuses to not work when I try the same on code.
Thank you!
Well it's because ggez+SDL2 will throw an error if the requested screen size is less the real screen size.
Thank you!
&gt; I thought I would just be able to take the produced libregex from my one pc and move it to the other so anytime i wanted Only if they have the same architecture, and only if you compile it into a static library, rather than a dynamic one.
Mm, well for your JSON example, you're just referencing a value deep within a structure, and for that, we have something [much cooler than monad](https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Lens.html) ;)
Yeah they have the same architecture? Do you know or would you be able to point me in the right direction to figure out how I can produce a libregex.rlib that won't give me the an't find crate for `aho_corasick` which `regex` depends on error?
You ain't going to be able to write something brief like `g &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z`, and that's the point.
There are plenty of lambda calculi that are impure. [This thesis](http://www.cs.princeton.edu/research/techreps/TR-713-04) presents a System F (polymorphic lambda calculus) with general references. Or in other words, a model of ML. [Later work](http://www.ccs.neu.edu/home/amal/papers/linloc-techrpt.pdf) uses linearity to allow strong updates, i.e. those that can change the type of a memory call. Rust is related, though not exactly the same. Relationships with some lambda calculus don't really help us resolve the question of what "functional programming" is.
It took `just a bit` longer than expected. 🙃
IIRC, rlibs are dynamic, you would need to compile it with `--crate-type staticlib` to get a static one.
I am personally a huge fan of Kotlin. You should try it.
This makes lots of sense, and now I totally understand where your initial comment was coming from. Thank you for expanding and contextualizing. It is instructive for for me in addition to being clarifying.
`rlib`s are not specified to be anything in particular, but currently they are regular static archives do not bundle any dependencies. You cannot produce an `rlib` that would bundle dependencies with rustc alone (and `staticlib` is yet another thing entirely).
I'm curious, since this uses gpg, does it get around having to encrypt the same file once per user?
Do note that `from_utf8_lossy` _contains this fallback itself_. This is why it returns `Cow&lt;'a, str&gt;` and not `String`: if the data is fully valid UTF8, it will return `Cow::Borrowed` containing an `&amp;str`, otherwise it will return `Cow::Owned` with the owned string.
Afaik, even GPG doesn’t do that. Instead it encrypts a key for all users, and uses that key to encrypt the content. S3/sheesy uses gpg.encrypt(), it doesn’t do anything itself really when it comes to the cryptography.
Does shadowing a binding result in a drop of the previous value? let foo = something; let foo = something_else; Will `something` drop at the new binding of `foo` (before `something_else` drops) or at the very end of the scope (after `something_else`)?
This is a pretty common misunderstanding. The section you've quoted is talking about compatibility with host names. Similarly 953 is an update to a different protocol and RFC 1123 is also talking about hosts. Note I'm not saying that serving host records (eg: A, AAAA, MX) from a domain name that is not a host name will result in anything useful. I'm just pointing out that host names and domain names are not interchangeable terms.
Now the question is was it worth the wait?
No. Case in point: let x = 1; { let x = 2; // x shadowed here } // second x dropped assert(x == 1); // 1st x dropped
Cool, thanks.
One upside to Punycode/IDNA is normalisation. Two strings containing different byte sequences that appear identical to a human will encode to the same name.
Hmmm... I see what you mean. You can always implement it yourself, or implement display yourself. I don't think there will be any derive based solution that will know exactly what you want. 
Hey, so am I. Perhaps we can join our efforts!
&gt; Removing the invalid bytes would also be copying much of the data. Sure, but this can be done in place, as the buffer only shrinks. So while you do copy, you do not *allocate*, which I think is the core of the OP's complaint since they mention 2x 100MB.
&gt; In terms of MS not supporting underscore, they must have fixed that by now? Quite a few Microsoft products have leant on SRV records for a decade or more so I assume this is from some time ago.
I'm suddenly wondering if an alternative API: fn from_utf8_lossy(buffer: Vec&lt;u8&gt;) -&gt; String wouldn't be ergonomic. If the buffer is already UTF-8, then it just converts it into a `String`, and otherwise it can edit it in place anyway.
wouldn't that be better named `into_utf8_lossy` and be implemented directly on `Vec&lt;u8&gt;`? But, it turns out [I was wrong](https://www.reddit.com/r/rust/comments/7n1oz2/is_there_a_way_to_use_stringfrom_utf8_lossy/dryj8w0/) about this particular function.
Iirc there were some plans (by you, I suppose) to use gfx-rs in Webrender some time ago. What happened to those plans? Deemed not suitable, not for the time being or what?
Could you share your concept? I'm curious how much our designs are compatible. 
&gt; With hyper, you write it yourself, basically. How?
Ah, never mind, it's been a while since I used pass, so maybe I was misremembering something.
why?
`Cow` isn’t just for strings though, seems like a strange place to put the API. 
Well, I don't have to much atm. I'm the developer of the metal os project that was floating around a couple of weeks back. I wasn't really sure where it was going. Originally thought about making it a desktop os, but I'm thinking now that it'd be fantastic for server-side. My design was to follow the concept between SingularityOS for the basic stuff, take the idea of lightweight processes and process-communication from Erlang, stuff like that. https://github.com/metal-os/os I'm waiting on cretonne to be in more of a working state before I start getting wasm integrated.
Because it offers a way to serve static files without buffering them in memory.
Oh I missed both of those cases. I might fix comments because I discard those. `$INCLUDE` is a little hairier as I allow for an entry to be presented to a `String` or an `io::Writer`. I'm not fond of accepting things I won't emit so I might hedge on that till it comes up in the wild. I'd also not considered that Windows (or any other platform) might use a different text file format. Since that's not a use-case I care about (I do care about working on Windows more generally though) and handling it would likely impact one I do care about (parsing com in a reasonable time) it looks like your crate will have a few features over mine ;)
&gt; I started it because I was really frustrated with the existing management tools out there... I have yet to actually build the stuff I want to make that better ;) hah, this could have come out of my mouth verbatim :)
Quite fair!
Try something like https://github.com/steveklabnik/sparkles/blob/e3e10dc2e684f4b6c9749b784f34ff788cf379d2/src/server.rs#L144-L172 I haven't audited this code, it may have security vulnerabilities, etc.
Whoa, this is quite different (and way more adventurous) than my plan! I was thinking of using the Xen hypervisor where each domU boots into a WASM interpreter/JIT. WASM tables would be used to pass capabilities provided by dom0 or other privileged domains (such as the GUI domU, which I'm thinking would run an RTOS or similar) to the application. My OS would be ideally usable in server, IoT, and desktop settings, and with application code running in Xen-isolated WASM interpreters that communicate using capabilities, it should be flexible enough for all of these possibilities. I wonder how much we can share in the WASM interpreter. I'd think a fair amount!
Very cool! The initial motivation was to create an os that didn't have context switching (which have significant overhead), but still was secure, which I came up with after seeing *The Birth and Death of Yavascript* (great talk btw, I recommend it). wasm should be able to be tested before executing to make sure it doesn't do anything malicious, and then, since it's compiled to native, it should be *nearly* as fast as regular applications. But, since it doesn't use syscalls, it could potentially be faster, maybe much faster.
What about wasmstandalone isn't safe, may I ask?
I have seen that talk. It was very good, and with the development of WebRender as a very fast DOM renderer, I actually do think a WebRender-based GUI domU is in the cards for my OS. Another reason for my choice of Xen - I have another concept for building high-performance mesh network routers, and it turns out that with IOMMUs, we can do zero-copy networking via VFIO. If this were to be successful, I could build my mesh routers on top of this OS instead of fighting with DPDK. 
it just read files, that's it. I can read a file using File as well.
Oh, it actually contains an interpreter. I'll check it out, thanks!
That's super cool! I'd like to see that in action. Right now, I'm in the midst of applying to universities and schoolwork, etc, but after I'm out of this mess, I'd love to help you out. I'm helping out with the redox os team, and interesting how my idea is similar to their's just it all runs in the kernel (although it's ironically still a microkernel). Do you prefer a specific way of communication? I'd like to keep touch.
The port has been accomplished by a small research team from Szeged university (Hungary) over the course of 2017. They talked about it at the local [Mozilla Roadshow](https://www.meetup.com/Rust-Hungary-Meetup/events/244086300/) meetup: &gt; Gábor Lóki &amp; Team — Servo's WebRender research at Szeged They've got WebRender working on gfx-rs pre-ll GL + D3D11 with pretty much full reftest coverage, which is pretty impressive. However, I don't want to push for this [fork](https://github.com/szeged/webrender) to go upstream because half-way 2017 we had realized that it's `gfx-hal` that we want to see in WebRender in the end, not gfx-0.17... Stay tuned for more news! ;)
I think it's pretty bad that you're being so heavily downvoted that both your comments have been hidden. (-16 now) This subreddit normally only downvotes people that are being obnoxious or unfriendly, which you're not. Guys, let's not downvote people like this. 
The traits you mentioned, pattern matching, destructuring, etc, aren't inherently 'functional programming'. It should be mentioned full monads aren't expressable in rust's current type system. The other stuff are common to many languages, functional or not; they are aspects of modern type systems more than anything. I don't know how you can say Rust is a functional language when most code you write is going to cause mutation. Higher order functions and returning functions is also possible but not common in Rust (you have to Box functions to return them). I love Rust, and I love functional languages like Haskell. There are a lot of similarities in the type systems, but I wouldn't call Rust "functional".
There is two part: defining which test should run / compile and running there tests. For there fist part, see DroidLogician answer. For the second part, you should use the `--features` option of cargo. To run the tests with various combinations you candidature Make simple shell script. I can also recommend [multitest](https://github.com/dzamlo/multitest/).
Maybe the borrow-checked kept complaining? /shows himself out
It's returning a `Stream`. I have some code using it, but it's rather awful right now, so I feel bad giving it as an example for others. I'm just learning the language and Hyper myself. You can find it here: https://github.com/lnicola/rusty-share/blob/master/src/main.rs#L222-L234.
I've read about Free a few times but what threw me off was I also read it has a significant runtime cost, because your algebra is going to be interpreted at runtime. It's my understanding that traditional mtl code is faster than Free. Is that the case?
I need to serve static files! `Stream` by itself doesn't do that.
How is that better than just reading a file via File? Given that static assets often are small
Good point. On the other hand, `Cow` is the return type of a function beginning with "from", as do most `from_*` functions. Also we do have some precedent in specializations for `Add` on `Cow&lt;str&gt;` pertaining to `String`s/`str`s. And I fear putting the function in `str` would lead to more, not less confusion.
Screw fizzbuzz, tell me more about wyrm! Especially: * Can I do recurrent neural networks in it? * Is it possible to add GPU support in future? * What about sparse inputs (like one hot encoding of text, which is that transformed using embeddings)? 
It depends; so many sites load megabytes of JavaScript and images these days, which is not exactly small (I might call a 4 KB file small). If you want to read them like that, you can use the solution here: https://www.reddit.com/r/rust/comments/7n2u0v/how_to_server_static_files_in_hyper_or_shiors/dryuquh/. It's still better than doing it directly because it doesn't block the `hyper` main loop (which would be bad). In my case, I'm interested in serving files in the 10 MB - 30 GB range, so buffering them is not an option.
&gt;Is this mostly intended for Linux, or would Windows benchmarks be of any use? It is meant to be cross platform, so yep benchmarks on any platform/OS are equally useful for me. The only constraint is gcc/clang must be used - the C files do not work with mvsc. &gt; It overflows its stack each time I ran the benchmark I have never experienced that and I have no idea which part of the code would overflow the stack. Could you provide some more details on that? Also a few more questions for what I'm looking for specifically : * Did the overflow only happen with benchmark? As in `cargo test` ran fine? * Have you tried switching to `pure-rust` for test and/or benchmarks? (Instructions attached in post) * If so, were there overflows in either test or benchmarks when in pure rust? &gt; Seemed to get wildly (100s mb/s?) different result each time it ran That is somewhat expected. A lot of the work is split into parallel jobs and then done by the rayon crate, so the accurate performance of each run highly depends on your system workload at the moment, and other things that affect threading etc. So don't worry about the noise, I am mainly looking at the performance in the rough hundreds of MB/s anyway. &amp;nbsp; Thank you very much for your time! I didn't expect there to be issues on Windows so that's an important result for me.
TBH I don't think `&lt;*&gt;` is that useful even in languages with currying. You don't usually need `map` with functions that take more than one argument in any language. It's the same reason that it's exceptionally rare to see someone pattern match on `(Some(x), Some(y))` in Rust.
as I've said: I need to serve a whole directory too. 
&gt; s3 (or soon sheesy), tries to get rid of the dependency on the gpg program I don't understand, you said elsewhere you do depend on gpg, which would make this not actually self-contained either? When do you have to interact with gpg using pass? The only places I can think of are key generation (which you do once) and adding keys to the store (which only one person needs to do). What are the scenarios where this helps with? 
It's still a WIP, but the general thrust is that it'll be a way to efficiently fit small, sparse models. Consequently, 1. I'm pretty sure you can, but I haven't actually tried yet. It's on the list. 2. I think so, but it's not very high on my priority list. 3. Absolutely, that's the main goal. Have a look at my example of a [factorization model](https://github.com/maciejkula/wheedle/blob/master/src/lib.rs#L301). The same implementation would work for word-to-vec like models.
What do you mean? My code builds a file path from the configured directory and the (HTTP) request path. It can serve whole directories that way.
People use the "idiom bracket" `f &lt;$&gt; x &lt;*&gt; y` pattern **all the time** in Haskell. It's hard to overstate how pervasive the `Applicative` class has become. Like, [they made breaking changes to the standard library to integrate it deeper](https://wiki.haskell.org/Functor-Applicative-Monad_Proposal), and [added special syntactic support for the class](https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo). It's way, way useful. &gt; It's the same reason that it's exceptionally rare to see someone pattern match on `(Some(x), Some(y))` in Rust. So what about `Future::{join, join3, join4, join5, join_all}`? (See [here](https://docs.rs/futures/0.1.17/futures/future/trait.Future.html).) There you have it, `Applicative` in Rust (and something similar to a `Traversable` instance thrown in to boot).
I'm a bit confused, would you have an example for the `match` you're suggesting? My output needs to be a String, so I'm not sure if I can work around `into_owned` when using `String::from_utf8_lossy`.
Well if guerilla signing them is an option, how about guerilla stocking them? I am sure O'Reilly sent you a couple boxes no?
The print quality of most books has dropped to the point where legit copies feel like knock offs. The hardback technical books still had pulp for paper, poor ink coverage, etc.
I see this error with Firefox 58b13 on Mac: Error loading Rust wasm module 'rust_webcomponent': InternalError: too much recursion Stack trace: [object Object] rust-webcomponent.js:143:17 seems to be related to the recursion limit.
The general rule under Posix is that by the time you catch the SEGV signal (which is possible) the process is too broken to print its own backtrace, (much less panic and recover). But you can build with debug symbols and use a debugger. `gdb` and `lldb` work well with Rust. 
Ah sorry, yeah, I missed that you needed a `String` output specifically. Using `String::from_utf8` first does seem ideal in that case.
kotlin is cool BUT i think it's brain-damaged they dont even have array literal syntax...
Thanks for your feedback everyone. I just published this on crates.io! W00p w00p!
Why is this a good book? (honest question, from a potential buyer)