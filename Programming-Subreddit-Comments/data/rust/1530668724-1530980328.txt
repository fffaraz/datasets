You can call date.succ() repeatedly until it reaches what you need.
I finally figured out how to pass a string to C# COM interop (ie, when the type library says BSTR). Link: https://paste.ee/p/gvZJb My question: is there a better way to handle this than all the bit and byte fiddling? 
I'm currently prototyping a parser, but I'm running into architectural issues, specifically on how to represent tokens. I've prototyped two lexers, one using enums and the other using traits. --- The enum approach has one data type with many variants (one per token type). The main problem with this approach shows up when I build the AST. As far as I know, I cannot make a function that tells me "Is the value X a variant of type Y" using Rust if I want Y to be a variable. For example I can't have: enum Animal { Cat { name: String }, Dog { name: String }, } fn main() { let animal = Animal::Cat { name: String::from("Sparkles") }; debug_assert!(is_variant(animal, Animal::Cat)); } In short, I want it to check if the enum instance (animal) is the variant Animal::Cat, regardless of field equality. Without being able to create this generalized function there would be A LOT of boiler plate code, such as "is_open_parentheses", "is_close_parentheses", and so on. Otherwise, I think using an enum would be the preferred approach. --- The trait approach would require one struct per token type, and for each struct to implement a Token trait. This means a couple of things. First, there would be a lot of boiler plate code, which is made worse by the fact that Rust macros cannot define structs. Second, I plan on collecting tokens in a Vector meaning I'll have to Box them. Ideally I'd like to avoid the heap. Third, I'm having trouble with ownership during the AST phase. Here is an example of the ownership trouble I'm having: https://play.rust-lang.org/?gist=fa055be76ea483e2bbf69d5afefbdd5f --- In summary, I have the option to use enum or a trait to represent my tokens. I think it'd be better in the long run to use an enum. Ideally I'd also have a generalized "is_variant" function to make my life easier. I've also ran into ownership issues when using Boxes and would like clarification on how to solve it. Also I'd appreciate it if any one has any general parser advice, or can point me to an example of a simple parser written in Rust. I've found some crates that help you programmically define a parser, but I'm looking for something more basic. I'd like a hand written parser targeting a single (preferably minimal) language.
Yep, this is an area where one can feel the Lisp inspiration in Ruby, and this is how it should be done in a very high level language, in my opinion.
&gt; I wonder if what they like is just being able to avoid having any mental model of their program at all. I'm gonna disagree this notion. Dynamic typing, especially if you don't have type annotations, forces you to keep much more of the model mental. The trade off is you can be much more flexible in your model, especially if the language is duck typed (Python, for example) - the runtime doesn't care if that thing is a Foo as long as it supports all the same operations that a Foo does. The two big cons are you have much more to carry and in your brain, not just in the session but session to session. And your mental model differs from someone's mental model, if only slightly. Tools like flow and mypy help with the mental model issue as you can put more of it into the code itself. For statically typed languages, you have the opposite trade off: your mental model is as explicit as the types will allow you but you trade off flexibility - which is why you deal with things like interfaces or trait objects to get around the flexibility problem. 
Itâ€™s addressed in the post.
So easy to write, so easy to test, so hard to read.
DataFusion currently is "just" a SQL query engine .. i.e. it can parse SQL, create a query plan, and then execute that plan against some data sources (Apache Parquet, and CSV, primarily). It uses Apache Arrow for the memory model, allowing for efficient columnar processing. It is really suited towards analytical queries on so called "Big Data". Or at least will be once it supports partitioning and parallel execution. The 0.3.0 is another small step on the way towards this goal. 
thanks!
Discord is quite a bad idea here. The channels and text within them are owned by Discord. If anything I'd look at something like Slack.
The sizes of the arrays are checked at runtime, so arrays of different sizes can be passed in. The number of dimensions is checked at compile-time, though. I.e. passing in a 2 x 2 x 2 array into `xs` would fail to compile, because it's expecting a 2D array. This is in contrast to something like [nalgebra](http://nalgebra.org/), where array sizes are verified at compile-time. Instead of using integer generics, nalgebra uses [typenum](https://crates.io/crates/typenum) to do type-level numbers at compile time. Apologies if I misunderstood the question; the word "dimension" can be kind of confusing.
Does that mean wasm powered ggez would be a thing?
&gt; (or better yet, `Obj.magic`) What? `Obj.magic` is very much _not_ anything like an `Any` type; it's similar to `transmute`, i.e., something you shouldn't ever use.
Taking this job sounds like it would be a bit of a gamble.
This looks and sounds wicked sketchy, and is _probably_ illegal. This sounds like one of those things where the creator gets paid after-the-fact, in which case... Why wouldn't the developer just create it on their own?
it is interesting that JS is both open-source by default and high-level, (aka widely-adopted.) I don't think the article focused on those aspects, not being an idiom. For instance, it's also easier to learn JS simply because of all the knowledge and resources out there, vs rust for example. Don't think low-level libs are bad, but their platforms can be. Paradigm is what it's all about at the end of the day. High-level languages are really expediting that exploration process.
&gt;do you really want to add me to Discord no, not really
Iâ€™m a big fan of this. I personally have not found time to take part in IRC, but Discord allows me to passively checkin in on conversations without too much effort. The post style seems to reduce too many empty comments.
Well, let users to decide, right? Whether they care about mystical ISP ads or theoretical mitm injects, or they care about loading speed and traffic amount. If you use public wifi, https on docs.rs won't protect you, there are millions other attacks. Use VPN at least and.. now we don't need https again. 
I've multiple times seen supposedly real developers write stateful singletons in Spring. It's kind of mind blowing. Their thought process is, the unit tests pass, so it must be ok, right?
I suspect this was meant for /r/playrust, but honestly, I don't think they'll want it there, either.
I wish I could view without have to create an account. It'd be even better if I could use some bridge so I can keep all chats in the same place.
Thatâ€™s the dream app isnâ€™t it... all messaging in one place. (Btw, I just use GitHub oauth for better or worse)
The article title claims to compare Rust to C, but the article content only seems to compare Rust macros to Rust traits.
A small correction, Javascript supports labeled loops as well. Though I didn't know that rust supported this also :) [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)
If it's possible bro keep Gitter and IRC in sync, can't the same be done with Discord ?
Please take a look at matrix and riot.
Well, with IRC and Gitter (since it has an IRC bridge), I've been able to do that. Discord told me to go away (well, create yet another account, but same thing).
We've been getting a bunch of articles with the content basically being TL;DR: Rust isn't automatically hyper optimized compared to manual optimization in C, thus Rust isn't good.
Yeah. Weâ€™re not going to overlap here: slack, discord, logged into gitter once, email, GitHub, gchat, sms, Twitter, etc. Gah...
In the spirit of the bikeshed in all it's forms, I'll add my 2Â¢: The project should use what meets it's needs, but everything about synchronous messaging in 2018 is terrible and kind of tragic.
So that all comments are not anti-Discord I have to say that I really like Discord. I know this was covered in the post, but the main reason that I would prefer Discord over IRC is the ability for asynchronous communication. I don't live in an "odd" timezone, but every time I have to use IRC to communicate in any community, be that Rust or otherwise, I have a problem of not being able to leave a message for someone who is not online. Maybe I just don't know the tool well enough, but the experience of trying to use IRC over the years has pushed me away from trying to learn it, and I am one of those folk who work at something till they get it (I learned Rust when the first book was all there was, after all). Discord is much more inviting and it is simple to have asynchronous communication between multiple people.
&gt; And hereâ€™s a good place to mention that Rust stable still canâ€™t generate new function/variable names in macros This seems like a legitimate complaint. I ran into this when generating benchmarks at one point and used the same solution they did. And the trait code is slower than the macro code, not slower than some C code. The 'clean' solution has a cost - this is something Rust strives against.
I don't really care where communication happens I just want it in one place, really. That said, IRC is really annoying and limited and I hate every client I've ever used and the web client I've tried disconnects all the time and blah blah blah whatever. Literally anything is better, so that's good.
Use a free communication system like Matrix or Gitter. Discord is unacceptable for a FLOSS project
It's slightly difficult to get started with, but there are web clients? There are web clients for discord too? So why IRC? I can't send formatted data. I can't send more than a very, very small amount of data. I have to put things in gitter's to share even tiny snippets or error messages. Clients for Linux have, in my experience, been terrible (terrible text zoom for example - a deal breaker for me, as I have poor vision. Browsers scale far better) and unmaintained / unpatched etc. What is the *upside* to IRC?
PBX is a company?
I don't mind Electron personally but moving to a chat platform without free clients is concerning :(
We already use GitHub, a proprietary platform, to develop Rust. We love open source, but are also pragmatic. (Gitter, again, is discussed in the post.)
I meant there's nice web clients now since that's usually stated as a pro for Gitter/discord/whatever. For IRC, it's useful for newcomers or people who don't want a dedicated client. &gt; No formatted text. Seems mostly useful, actually. Keeps things simpler. &gt; Super long messages / pastes. Again, I view this as a plus. Sometimes I hop into other Gitter channels, and the walls of pastes really hurt discussion in my opinion. Slack is similar. If you wanted to write a really long message, I'd offer that should probably be a comment in a bug tracker, or an email, or discussion board, since I'd rather push as much larger discussion as possible into async formats. I see chat as useful for asking small questions. &gt; Linux clients I use HexChat on Windows, which I believe is XChat, and rather like it. &gt; Upside to IRC Besides what I mentioned so far, the biggest is that it's **open**. I don't need to give away privacy to join in. And the protocol has a standard, allowing bridges to exist to convert it into literally any other platform. If I could connect to the Discord channel over IRC, I likely wouldn't have complained at all.
Had a doubt while reading "The Rust Programming Language." [https://doc.rust-lang.org/book/second-edition/ch03-05-control-flow.html](https://doc.rust-lang.org/book/second-edition/ch03-05-control-flow.html) Recommending "for" loops over while loops, the author reasons: "Itâ€™s also slow, because the compiler adds runtime code to perform the conditional check on every element on every iteration through the loop." Q: Is this (the slow part) correct? As far as I understand, all types of loops would require conditional check on every iteration, unless it has been unrolled or optimized. Also same optimizations should apply on both types of loops. If this isn't the case, can someone please explain why? How writing in one form convey more information to the compiler than the other form?
&gt; Seems mostly useful, actually. Keeps things simpler. How is me opening up a separate service, github, to share code, simpler than inlining the code? &gt; Again, I view this as a plus. It can be. But it's also a pain in the ass when you actually want to write words - and it's made much worse by the need to share urls because there's no formatted text. &gt; which I believe is XChat on Linux, and rather like it. I believe when I tried this the text scaled quite poorly. Perhaps that has changed. It did the classic "text gets so big it no longer fits in the box it's supposed to go in" thing I get from almost every program that isn't a browser. &gt; Besides what I mentioned so far, the biggest is that it's open. I don't need to give away privacy to join in. I don't get it. What privacy do you get with IRC? It's a public channel - anyone can log it, listen in. I don't think we're going to agree here, because I think we're both *just used* to different ways of communicating. And that's alright. I guess the big, nice thing about IRC, is the interop - because what I care most about is having *one place* to ask my questions.
What's being referred to here is the dynamic check on *accessing* elements. *i.e.* the actual `a[index]` expression has to check that `index` is valid. A properly written iterator can avoid this check by ensuring `index` can't ever be invalid in the first place. The problem is that this statement is *definitely false* in this case. LLVM is smart enough to notice that the loop condition ensures the index is never invalid, and subsequently skips the checks. Heck, if you replace `println!` with something simpler, it goes even further by unrolling the loop. So the statement in the book is true *by default*, but there are definitely non-pathological cases in which it isn't true. You should still use `for` loops because they are *generally* better by default, but having an optimising compiler means that isn't always true in *specific* cases. So, pretty much like anything else in the language, really.
Your `is_leap_year()` function suggests that the year 1900 was a leap year, but it was not, so right there you've got a problem.
I wish that comp.lang.rust existed. Get off my lawn....
Have you looked into [Rocket.Chat](https://rocket.chat/)? I haven't had the chance to try it out yet, but it looks like a nice project.
From the text: &gt; I want to remember to hit the `n = 0` edge case later, but donâ€™t want to implement the error handling logic quite yet. So using unimplemented would be the more idiomatic way, since the author doesn't want to handle the error. The function is designed to take empty vectors, do using assert here seems wrong to me.
&gt; Sharing code. Oh, I meant simpler for everyone else, the readers. Sure, pasting straight into the chat is easier for a writer, but then everyone possibly engaged in other topics in the same channel have to ignore the paste. Likely the comments they wanted to see got bumped off screen. Is using Gist or Pastebin or Hastebin so bad, when it could help keep the chat room less cluttered? &gt; Privacy Really it's more about pseudonymity than absolute privacy. While I use the same handle everywhere, the principal either allows those who for prefer to be more anonymous to do so, or as in Discord, forbids it. And yea, as you touched on it, the root of my interop point is really about pro **choice**. Let me interact in a way easier to me, and let you likewise. That's what I want!
Hi, I need to parse files of the form: timestamp1 tx1 ty1 tz1 qx1 qy1 qz1 qw1 timestamp2 tx2 ty2 tz2 qx2 qy2 qz2 qw2 ... Where all the values in each line are floats. I wanted to learn how to use `nom` to do this since it seems to be a very interesting project. But I can't figure out how to read the last float of each line. Basically, my issue boils down to : println!("{:?}", nom::float_s("42.14")); // -&gt; Err(Incomplete(Size(1))) I guess the file format is so simple that it would be very simple to do it directly with string splitting but I wished to understand why this is not working. Don't hesitate to let me know if there are other nice parser combinators in rust also!
You are never going to get some people off irc, so please pick something that has interop with it.
If IRC gets dropped, will there remain any official medium through which rust users can reach out to rust developers without entering into legal agreements with third parties? I mean, I'm enjoy rust as a hobby and am willing to click "accept" on what large blob of text gets presented to me to create an account (e.g. this reddit account), but I'd have a hard time justifying to management entering into a one-sided legally-binding agreement just to report a bug or contribute back in official capacity as a company employee. IRC and email have the advantage of having almost no legal overhead because they're open protocols. By dropping support for official channels that use open protocols, rust risks preventing people in my position from participating or otherwise giving back to this project. At least during work hours. As a suggestion: Would the rust project consider using Matrix/riot? It's a good modern alternative to IRC that doesn't have the drawbacks that are inherent to services like discord. Failing that, I ask that at least a mailing list be set up so that those of us who don't want to create another account or can't create one have a place to reach out. I think it would be far more beneficial for rust take down briers rather than erect new ones. Thank you.
String FFI is kind of a complete mess, though that's *mostly* C's fault. :P The one thing that jumped out to me is the use of `WideCString`. I'm not *certain* that this is correct. IIRC, a `BSTR` has to be null terminated, but it's safe to include nulls inline (since it also has an explicit length). Presumably `WideCString` behaves like `CString` does and fails if the string contains null. But that's a minor point. If you polish this up a bit, you could probably donate it to either `wio`, or another COM-focused crate. I actually have a crate to handle every possible kind of string FFI (including `BSTR`, various C representations and encodings), but it's been stuck on a DST bug for... over a year now, I think, so that's not much help. 
For future reference: some temporary workarounds that may work: 1. Set your system time back to when the cert was last valid. 2. If the site is not included in your browser's internal HSTS list, "forget" the website (though this may not work depending on how your browser and the doc.rs server are set up). 3. Use a local proxy that doesn't refuse to connect on HSTS violations, and connect to that. This proxy can work at the socket level, or at the application level (if you want to get around internal HSTS lists) 1 is usually safe (unless the cert's private key has been compromised). 2 is hi- r-miss, and must never be done when you need security or privacy. You have to be very, very careful with 3. Unlike the previous two methods, this method will affect all your https traffic and can have persistent effect on your browser even after you remove the proxy. Use at your own risk.
&gt; what is strong typing giving me besides a lot of pain Eh if you're saying that you're probably not using the type system well. 
&gt; They have a price, and in many situations the cost isn't worth it Not really true with modern type inference and modern type systems. 
Agreed. Thank you for posting workarounds. People should always have the final say in what their machines and software does.
&gt; For me what make dynamic languages a more approachable experience is the REPL Haskell has a REPL and it is statically typed. 
&gt; last float of each line try trimming it before putting it through nom. Seems like a LF or CRLF that wasn't expected.
&gt; Caring whether the data is on the stack or the heap GHC already does this and it's a statically typed language. 
A friend whose company uses it has endless complaints about it being sluggish -- almost unusably so.
I tried using discord to play chat with teammates playing games and it barely worked. Havenâ€™t used it since. Would rather something like slack or whatever. My 0.02
Does https://zulipchat.com/ seem to be a viable alternative. It's topic based tags seem great to revisit any conversation later on.
We had a similar situation once when we moved the public channel for an open source project from IRC to slack (actually via hipchat ðŸ˜†). What we ended up doing in order to give everyone the choice of their tools is using a bot that mirrors conversations - even with this choice available almost no one stayed with IRC. Every community is different though, but given it's 2018 I think we have the tools to accommodate everyone. (And I guess y'all know that too ðŸ˜€)
I don't have time to go in depth but the first answer to "this creates lots of boilerplate" is probably macros. Makes the enum pattern way easier to deal with. Though I find it odd you say that rust macros can't define structs, since I've used them to do just that. Frankly I think Rust's facilities for doing/generating Useful Reflection for arbitrary enums is pretty impoverished, but there's lots of crates providing macros and derives to fill in some of the gaps. Including apparently one called `derive_is_enum_variant` thatight be interesting to you. ;-)
I'm finding the test program crashing some of the time, so there's some issues to clean this up. Good point about the null Terminator and WideCString. I might borrow it's underlying as_wide function instead of wrapping that type. 
Among several other nitpicks: it is actually possible to defer type errors to get the supposed productivity boost of dynamic language. GHC has a [flag](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--fdefer-type-errors) for this.
Using Rust since 2015 but only once a few weeks, I find the stratefied feedback model a little frustrating, the extreme opposite of the positive aspects of dynamic languages. First, get your whole program syntactually correct. Now, fix the types. Ok, you are now worthy of glimpsing your borrow check errors... but not for long, since the necessary refactor may well break the types or perhaps even syntax half a program away and you'll have no idea whether that new formulation of the struct will actually fix the borrow problem until the whole program type checks. Obviously this is not a big deal once you know which way to go at each step, but it sure is a distraction when I am in learning mode. I've now gotten somewhat better at understanding what the compiler wants (and definitely the compiler has gotten better at telling me), but I still wish I could see all kinds of compiler feedback at the same time. I would even like a mode where I can check if a test passes while some dead code has a syntax/type/borrow error. 
&gt;Well, let users to decide, right? No. Do you trust the average user to make the right decision on an internet security issue? The same average user that uses `password` as their password..? I don't. &gt;Whether they care about mystical ISP ads or theoretical mitm injects These things have happened and still happen. There's nothing mystical of theoretical about them. &gt;or they care about loading speed and traffic amount. That's negligible though, especially with HSTS and HTTP/2. HTTP/2 over TLS is even faster than plain HTTP 1.1 in many cases (see [this](https://www.httpvshttps.com/)), and all major browsers only support HTTP2 if used over TLS. &gt;If you use public wifi, https on docs.rs won't protect you, there are millions other attacks. Would you happen to have a list of those millions of attacks? Because AFAIK, if you use a modern browser and only browse websites that follow best practices (HTTPS, HSTS, even HPKP if you don't trust CAs), then you're pretty much safe. (Assuming you've visited these sites before on a connection that wasn't tampered with. Also not considering potential attacks that haven't been made public or haven't even been discovered yet...) &gt;Use VPN at least and.. now we don't need https again. That protects you from the hacker in the coffee shop, but not from the malicious actor that could be sitting between the VPN server and the web server. HTTPS protects you from both (as long as it cannot be stripped of course, which is why HSTS is important).
&gt; Is using Gist or Pastebin or Hastebin so bad, when it could help keep the chat room less cluttered? Generally these newer chat tools solve that problem by collapsing large pastes/code snippets/etc by default. The ability to paste images/code/etc *directly* into the chat client is *sooo* nice. Going back to a separate service for everything is an enormous pain.
I haven't used IRC in years (I really don't like async group messaging at all), but at that time people used to extend the clients all the time with useful stuff. Does not any client support pasting via pastebin etc? Seems like a really simple feature to add for bigger pastes. As for URL:s that was mentioned, they are usually auto detected in the text by the client and converted to a clickable link, no need for the sender to do anything special to make that work. There used to be MD-style rendering in some clients as well, I'd be surprise if good clients don't do that.
Matrix and Gitter have their own huge problems, just like IRC. It would be great to use open protocols and tools for everything, but that's (rightly, IMO) not higher priority than usability. Especially for something like synchronous messaging where switching every once in a while doesn't really cost you much.
It really seems like this job posting is for entertainment purposes only.
I use Slack every day for work, and hate it. :) To each their own, but then that's why I'm arguing for choice.
Many channels have a bot that help with communications to offline users and are also backed up to a web-logg. You write something like @user in the message and the bot will resend the message to the user when the user logs back on.
Discord has a bunch of problems which all seem to not be really addressed: \- Non-free \- Non-federated \- Everything probably belongs to discord, discussed on their channel. \- Discord is at the moment just living on venture capital, so you will see them trying to sell something. And what is better to sell than user data? Other alternatives, except gitter where not discussed in this post at all. It kind of looks like somebody wanted discord and everybody else did not care, instead of trying to find the best solution. Matrix would be a really good alternative. Especially, with the bridge to irc and other networks.
I did a C++ REPL some years back and that was most definitely statically typed. It was fun while it lasted. 
You don't have to really create an account. You can just choose a dummy username and then you can join. No need to use your email address.
"Rustscript" is a cool idea but it would not be Rust, altho a great entry drug. Currently looking for something a little different: a statically typed scripting language that integrates well with Rust and is not Gluon 
If you want to treat the data as an untyped blob of stuff you can do that in rust. If your application does not care about the internal model of the data then do not represent it as a collection of structs. Simply do something similar to what you do in perl. You can do untyped stuff in a typed language. For everything where you need types it will be there. I'd still write it in rust:)
In my case that is not the issue apparently. It really seems to be that the last character of the slice is part of the element to parse since: println!("{:?}", nom::float_s("42.14")); // -&gt; Err(Incomplete(Size(1))) println!("{:?}", nom::float_s("42.14 ")); // -&gt; Ok((" ", 42.14))
This... doesn't make sense. Beside benchmarking the optimization efficiency of a compiler, I can't think of a single use of benching marking unoptimized code. You could write a piece of code that improves the unoptimized benchmark, but (blindly to you) slows the optimized benchmark. Or vice versa. The reading is so unreliable that there just isn't a single thing it would be good for. It's like making a ruler out of play d'oh
If there's open source IRC client that is not terrible (with feature like text zoom), maintained, can read formatted data, having inline gist, would you also like it? Personally, I would be happy too for a client like that to exist. Especially if said client can also run with minimal resource. &gt; What is the upside to IRC? From personal experience, IRC is quite accessible for people with poor internet access.
&gt; The nice thing about having a static type system in your other systems (front end, server, other services, etc.) is that you can update the structure of the corresponding type and let the compiler errors guide your refactoring. I have seen cases where this would benefit, such as where an upstream API changes slightly without notification, and the data being injected into the database is changes, depending on database strictness, this can cause data type conversion at the SQL level and sometimes you get empty/null fields for all new data where usually there was a value some percentage of the time, but that data is under a new field now. A more strongly types (or really, more strict conversion from JSON to a record for insertion) might help there, but so might turning on strictness features in the database. It's usually not a super big deal for the way I work, which is to always store the data to disk as well, in a date-hashed location with identifiers and a timestamp, so reprocessing (to the level of replaying all data) is generally possible. &gt; I've seen the argument from fellow engineers that "well, if you have tests, you don't need types," and that's true - good tests can obviate the need for types. I'm not even sure I would go that far. I definitely see a use for strong typing, I'm just not sure it works really well in the specific use case I outlines, and since there seemed to be "dynamic has no reason to be" type of vibe going on from a few parent comments, I figured it was a worthwhile counterpoint.
Sure. I don't even care if that client uses resources, honestly. My understanding is that the IRC protocol is not exactly great though, so things like handling text limits, unicode, formatting, etc, would be hard.
Small question: [Here](https://github.com/jonhoo/tokio-zookeeper/blob/master/src/proto/mod.rs#L155) you loop while self.outlen() != 0, but you never iterate more than once. Should the while be changed to an if, or should you keep trying to read and let try_ready return from the function. Of course that means the flush isn't called but since you added it when implementing start_send from Sink maybe it isn't needed.
Please consider Matrix instead. Ruma has a good [introduction to Matrix](https://www.ruma.io/docs/matrix/) that explains what it is for those not familiar.
The PBX is the "core" of a telephonic infrastructure, it handles incoming calls, voicemails and provisions VoIP phones and analogic / digital phone lines.
https://play.rust-lang.org/?gist=8719bfe2aff12b72d73d4fc27d13e488&amp;version=stable&amp;mode=debug&amp;edition=2015
Read https://doc.rust-lang.org/book/second-edition/index.html Do shit in Rust
So as an aside while it is one more piece of software to configure. I often use a bitlbee server and just interop with discord, gchat, sms, etc through there. And fot slack I usr weeslack.
There is logic, of course, but so far it's minimal, and data syncing and retrieval *far* outweighs it and for the most part, will for the foreseeable future, since I'm reimplementing something I've written professionally previously. There's lots of data being harvested from websites, manipulated, and stored. There's lots of data retrieved from multiple remote APIs that's stored, There's lots of data being submitted by clients (browsers) using the system, which is also stored. I still see a lot of possible benefit to using Rust for some of the API and web-scraped data processing, since it may be dealing with low 10's of GB of uncompressed JSON a day (probably as a FFI module, I'll be testing at that point to see the overhead involve there and whether it's worthwhile insert directly from Rust and maintain two language schema mappings at that point), but for prototyping and getting a web service up (which is really receiving input from browsers and responding with JSON that's handled by Vue), I didn't see a major benefit for having that slim layer that has fairly minimal, specific and well tested logic be in a strongly typed language given what (to my admittedly amateur abilities with regard to Rust and static language techniques for web services) seemed to be quite a bit of scaffolding and specific type definitions for something I *already* did that for in the database.
See my reply to /u/Tramboi.
Really? Because sometimes in Rust I have to change my program since I can't express something in the type system. It lacks higher kinded polymorphism, for example. Or type level integers. You could write my program in C easier because I can just use function pointers (basically untyped)
This is what I was looking for, not in isolation, but for use with Diesel. I know I could just put something in a data type that's similar to what I would want in a dynamic language, it's the need to then format it as an insert or update with little or no change to the actual data which made the endeavor seem far more complicated that the benefit it was providing at that time, for my needs. It's entirely possible there's a way to do this, and it might be obvious, but it wasn't to me, and the time I had allocated towards examining promising alternative and new technologies (I also looked into reasonml) was running out. The extra effort I assessed it would take seemed to weight against using it because having something minimally functional quickly was becoming more important, and even if I wasn't a novice in Rust, the extra effort required to correctly type each request and convert the data for Diesel (still much quicker than rolling it manually, IMO) which might be *another* record type, seemed to indicate I was going to pay quite steeply in development time for limited benefit (since it's already going to a typed datastore that will catch 95% of the problems the typing is expected to help with in the language, at this point at least).
I like IRC but chat has evolved past sending tiny ephemeral text snippets to each other. I like discord a ton and am glad for expanding communication options.
Rain supports multiple formats of encoding data that goes over the network, Arrow is one of them. You can find the full list here: https://substantic.github.io/rain/docs/user.html#object-content-types.
thank you, but what is TRPL, std API docs?
Hear, hear. Most of the web-based forums are not a patch on a good nntp client. Imagine being able to track which individual articles and replies you have read, instead of â€˜everything up until nowâ€™. Humbug.
Rust has a matrix room at #rust:matrix.org and there is talk of bridging Discord to a matrix room.
I will just add that you can transfer any data formats; everything is "just" a blob for us. We provide build-in auto-serialization API for some formats and Arrow is one of them.
Rain allows you to define large end-to-end data processing pipelines with complex inter-task dependencies (beyond map-reduce pattern). The pipelines can consist of various tasks ranging from external applications, through python code, to various built-in tasks (and also offers easy extensibility). Rain features direct inter-governor(worker) communication that makes inter-task data exchange very efficient and if you set your working directory to be RAMDisk it has NO filesystem overhead.
The official book
In Rain, you can define an arbitrary computational graph, not just map-reduce pattern. Rain is also directly prepared for integration with external programs and other codes. On other hand, in the current version, Rain does not directly support HDFS.
Yes, that is what I had in mind.
So it seems that this occurred because I added a new dependency and cargo cannot resolve the dependency tree. Just managed to solve it finally by removing all references from Cargo.lock of the added crate and then let cargo do its thing. Still keen to here if there is a better way perhaps.
Usually, it is enough to do git checkout incoming_branch_name -- Cargo.lock on your branch and then rebuild. That way you'd inherit locks from the incoming branch. Also individual updates may be done using Cargo update -p package_name
Hmm, I'm just an end user of Spark on AWS EMR, so all I can really say is that this is an interesting project I will be following. I'd love to replace my current workload with a Rusty solution - is it in this project's roadmap to provide an alternative to Spark clusters in that environment? Is there some literature I can look at that can open me up to more possibilities beyond my business-y reality?
Leaving aside the fact that Dask primarily focuses on Python-based pipelines (and does the job pretty well!), Dask is also implemented in Python which we have seen to be a performance bottleneck for some workloads when scaling beyond tens of compute nodes. Unfortunately, at this moment, we don't have any head-to-head scalability comparison between the two. 
Actually any non numeric ending will work fine so `println!("{:?}", nom::float_s("4.12A"));` is a perfectly valid input. So I think the issue here is with the design of the function, as it is "greedy" where it takes characters until it hits an invalid state. So with a string like "42.14", all of the characters are valid and it ends in a state where it is a valid float, but it also can take 1 more digit. How to fix it? I don't actually know...
Is that in the Roadmap or is something else a more likely usecase?
There is a crate that tries to solve that problem, however the macro was called `m`, which is a bit hard to Google..
Ok, thanks anyway for trying :)
HDFS was only mentioned in internal discussions about scheduler architecture. However, we have not fixed a roadmap for the next version yet and we are actually using this reddit post to gather what users needs. So if HDFS support makes sense, we can start to think about the implementation more seriously.
1900?
Well, GitHub ist proprietary but the underlying protocol â€“ git â€“ is not â€¦ This would actually be more similar to using the Matrix.org homeserver (proprietary â€“ or at least not self-hosted) with the matrix protocol (free).
Enabling and easy deployment of Rain in standards cloud environments such as AWS is one of our priorities for the next release. For now, we have (an experimental) [deployment script](https://github.com/substantic/rain/tree/master/utils/deployment/exoscale) for [Exoscale cloud](https://www.exoscale.com/) that, after some tweaks, should work with any CloudStack deployment. We keep track of our Roadmap in [project's Github issues](https://github.com/substantic/rain/issues/64). If there is anything you miss or would like to see in one of the upcoming releases feel free to comment there or open a new issue.
Now you're talking about weak typing rather than dynamic typing. All of C's weak typing is available in Rust with `unsafe` and `transmute`. The difference is that outside of unsafe, you get all of Rust's safety guarantees that C doesn't provide. Even within `unsafe`, most of the really unsafe behavior is still harder than type safe behavior. Type level integers should be coming... eventually.
JavaScript is actually Scheme with a C makeover.
That Matrix room is not endorsed by the Rust team in any capacity. It's just a small group of Rust enthusiasts who use Matrix.
The article is wrong: &gt; And hereâ€™s a good place to mention that Rust stable still canâ€™t generate new function/variable names in macros (or interpolate idents in Rust terminology) which add minor annoyance to copy-pasting and correcting function names in all macro invocations. Of course it can, I use https://github.com/SkylerLipthay/interpolate_idents all the time to do this. 
The official rust community embracing ephemeral, proprietary VC funded *corporate* communications channels is abominable and I will never abide it
Of course people like you would love for rust to be a proprietary language developed by Oracle because you are insane to see the benefits of free software and open source. I hope you get the panopticon world you deserve and that your boss knows all your porn viewing habits and other vices.
Anything can be done with Rust, but with extra typing unsafe or box
&gt; I can't think of a single use of benching marking unoptimized code. I tried to explain above. I want to use the benchmark as a test. Simply compile &amp; run it once, disregard the timing. Makes a lot of sense to me, since I've spent time writing and designing the benchmark, and I've already had cases where I broke it.
Author here. Just wanted to mention, that this article is kinda different from usual posts on this topic. A whole bunch of posts was already written by community, that explain basic concepts of Rust, it's syntax etc. So, I decided to concentrate more on philosophical aspects of software quality, and through that find Rust's place in the industry. Also I tried to explain "why Rust" using very general ideas, so that even people that are not very familiar with the programming world could understand it. Hope you'd find it useful!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/stallmanwasright] [Rust developers considering moving all official discussions for a free programming language to proprietary, VC funded Discord platform](https://www.reddit.com/r/StallmanWasRight/comments/8w03ez/rust_developers_considering_moving_all_official/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
If I may offer a word of advice: Don't. Long explanation: Discord currently rides a wave of hype, and that wave will end in, let's say, three or four years. We will witness it falling out of favour like all the other messaging services that were So Hot Right Now. And then you'll have an uncomfortable discussion about which messaging service to move to. IRC, on the other hand, has always been there, and it will be there for quite a while as it seems. Also, what kind of attitude is this? If the free, open-source protocol has flaws, why not make backwards-compatible additions? Why throw it away for a proprietary fad nobody will ever be able to make additions to once the VC funding runs out? Are you aware of [IRCv3](https://ircv3.net)?
This is true. I hope that eventually it will become official.
I also don't want to have to log into Discord when I'm at work.
For anyone who wants to see Zulip in action, try: https://chat.zulip.org/ which is the official chat used by Zulip developers. To login, I used Github OAuth without having to create a new user account. The topic "streams" (threaded conversations) makes it relatively easy to follow discussions without getting lost. There is also a "#test here" stream to try out the chat functionality, which I found useful.
&gt; Performance might be a tough sell: Maybe not performance, but memory usage (i've seen Hello-World web servers in Java which use around 160 MB) and disk usage (a minimal Docker image with a binary can be much smaller) which might affect your cloud bill quite a bit.
I don't think programming's for you mate.
After porting my software renderer from c/c++ into rust i have to decide which UI i want to use. ...after some thoughts and comparing libs, build states, community etc.... I will build the renderer as webassembly target and create a little Web-Portal based on Node.js. So i have a great flexible UI for my project. Happy c0ding @all
To be fair, so would be this: pub struct Pub(pub());
Lots of people are against but I'll put my voice in as in favour of discord :) only had good experiences. Can always change later if need be.
Out of curiosity which client do you use? I always had trouble with history. In the past I was just using weechat + botbotme history search, but they "recently" removed the search feature. At the moment I just use the matrix web client, but it is terribly slow. I guess the best thing would be to setup a vps server.
&gt; but I'd have a hard time justifying to management entering into a one-sided legally-binding agreement just to report a bug or contribute back in official capacity as a company employee. I'd think GitHub would still be open? Also, {users|internals}.rust-lang.org are definitely official
Hi, thanks for posting. As a type systems researcher, I do have a few comments and quibbles about your article though. &gt;In the most strict and complex approach, program correctness is _proven_, not _verified_. This is a bit of a nitpick, but it's a departure from what is typically seen. Usually, we would say that testing is used to _validate_ programs (by confirming that they conform to a specification on a fixed test vector) and formal systems are used to _verify_ programs (by creating a mathematical specification and proving that the program conforms to it). &gt;Only through constructing such proofs may you gain 100% confidence that the program is correct. While it is strictly true that programs in Coq are correct, it's important to point out that the are correct with respect to their specification. Less familiar readers (who seem to be precisely the target audience) may mistake this formal notion of _correct_ with the intuitive notion of _right_. (If your spec is wrong, your program can be correct _and_ wrong). &gt;For a long time, it was a killer feature of functional programming languages like Haskell to formally prove the code, whereas traditional imperative programming languages remain mostly unprovable, due to extensive use of shared mutability, unsafe pointer arithmetic, and uncontrolled side effects. Assuming that by formally prove the code, you mean formally prove code _correct_, I would be very interested in seeing the examples you had in mind to this end. There was a recent [experiment with modern theorem provers &amp; proof assistants](https://hillelwayne.com/post/theorem-prover-showdown/) that talks about how this really isn't so clear-cut. A close statement might be that pure functional languages were the first kind of languages to get denotational semantics (i.e. models that describe what a language means directly in terms of mathematical objects) as opposed to operational semantics (i.e. models that describe how programs in a language are evaluated). Scaling the former to languages with mutable state and side effects was a decades long research challenge (and one that Iris builds on directly). &gt;It is trivially provable for a safe subset of Rust I would love to see the language model you've built for safe Rust and its proofs of type safety! I've been [working on this](https://aaronweiss.us/pubs/ml18.pdf) for a while, and definitely wouldn't describe it as trivial.
How do you guys approach listening to podcasts? I can't focus on listening to this content without having a PC or at least some notepad in front of me. 
&gt;The right part of the chart above shows concurrency and memory safety issues that are fundamentally impossible to get in the safe subset of Rust. Well, you can easily get integer overflows in release build. And buffer overflows bugs is still a thing, yes, code will panic instead of exposing glaring security hole, but it's still a bug, which if not handled correctly can endenger human lives as well.
A different example of a variadic macro that I use in my math lib. https://play.rust-lang.org/?gist=8038c3774e438a3d8d9ec39b641fcde1&amp;version=stable&amp;mode=debug&amp;edition=2015 
Thank you very much for the detailed comment. You're absolutely right about the probably not-so-careful word selection of mine. On the other hand, I thought, that it would overcomplicate introduction level article with a lot of details. \&gt; I would love to see the language model you've built for safe Rust and its proofs of type safety! I've been [working on this](https://aaronweiss.us/pubs/ml18.pdf) for a while, and definitely wouldn't describe it as trivial. My bad. I definitely should've paid more attention in this case. My original intention was to say, that it may look trivial when compared to a full model with unsafe and pointer arithmetic. I've been following you, as well as Ralf Jung, and really appreciate your work!
I don't care what you think.
re-read it
so what? I'll have to create a new - with a new name - env. variable for every app I have 
you blind? I've already gotten a lot of help
Yes, you've made that obvious.
One thing that hasn't been talked about (and *is* available in Java through javadoc-plugins although rarely used) are doctests, which ensure your doc examples are working. types being easier to create and cheaper to use (algebraic data types + value objects) means you will use the type system much more than in Java (where it's more of a hassle to create a new class, and each indirection exacerbates pointer chasing). Disallowing uninitialized fields (instead of using default values) ensures you won't miss a field by accident.
I've edited the article and used less controversial words. Thanks again for your feedback!
Would love to read something about microcontrollers! :D
I'm pretty sure the Matrix.org homeserver is open source and possible to self-host.
thanks! I am writing code with a ton of these and the possibility was bugging me...
You can find the C code in FFmpeg/Libav. The primary target audience of these posts is not the general Rust community. And that audience already know where to find the C code and roughly how it looks. I submit those posts here because they provide the perspective of a multimedia C developer who is porting code to Rust without daily interaction with the Rust community. 
Does anyone have experience with https://www.mattermost.org? Mattermost is an open source, self-hosted Slack-alternative. Iâ€™ve used it only briefly in relatively small team, but the experience was quite pleasant. Might be one option to reconcile the needs for openness and control with modern UX. I enjoy Discord, but the focus on gaming is a bit distracting - and I understand the concerns about openness, control and sustainability.
Let me rephrase to see whether I understood you correctly. &gt; Websites should be allowed to choose what they send to protect its users at the expense of their freedom. &gt; Browsers should not cooperate, especially they don't make clear to the user that they cooperate.
I don't know if that's true. But I do know that's not the sentiment of this post.
Additionally: &gt;So, just by using Rust they could prevent roughly half of the bugs of that period. Er, no. A significant amount of a kernel requires things that could either only be done with unsafe Rust or would be too inefficient with Rc pointers.
https://crates.io/crates/m
Could not agree more. Still, whilst in real time environments panic is always an emergency, it's still better than silent data corruption. Mainly because your system may be prepared for that and may perform some emergency actions like do a reboot coupled with detailed integrity check. As for integer overflow, I believe, it may be handled either by leaving overflow checks on even in release mode, or by using special operations, like \`saturating\_add\` or \`checked\_add\`.
Yes, 1900. And 2100, 1800, 2200, etc. All divisible by 4, but not leap years.
Well, \`could\` prevent does not mean that they are absolutely \`must\` do to that, right? Also I think, that it would be fair to refer to the [Redox view on unsafety](https://doc.redox-os.org/book/introduction/unsafes.html) here.
I personnally do not care about it being open-source. I know many people do care a
The most important functionality in SDL2 is the input handling, imo. SDL2 has API for controlling on screen keyboards and a cursor API to make it easy to handle text selections that are unicode aware. It also has a controller API that Steam works with to give somewhat automatic support for Big Picture mode and the Steam Controller. Adding a platform to winit is fairly trivial since it's just for getting you a GL context so that's not really a big deal. All of the other functionality of SDL2 for that platform is another thing though.
Who will own the `&amp;Calendar`?
Sounds like this is less a criticism of Rust than it is a mismatch between Diesel and your DB access requirements. But that doesn't mean there is a more appropriate library available :/
From my point of view, it is totally acceptable. Proprietary software isn't evil, we can use it.
This is my experience. Python isn't hard to write, but can be hard to *read* because rebuilding that mental model without the guidance of a type system can be difficult.
I am not just dividing by 4. I explained in detail what I do. and the Calendar doesn't say 1900 and 2100 are leap years.
Yep, Rust's type system is actually quite expressive, though not always in an obvious way. Lack of specialisation is a significant limitation, but will get fixed. `unsafe` and `transmute` don't always help that much getting around strict typing in my experience, unless you want to transmute the lifetime (unsafe) or make assumptions of the layout of fat pointer types (undefined behaviour).
Nitpick: you misspelled Idris. Otherwise, great post. 
I mean as in for some bugs it couldn't be prevented with Rust. It's pedantic - a lot could - but I don't want to oversell what Rust is capable of.
Why MAC only?
Copying the format of your examples: 316 = 1900 - 1584 79.0 = 316 / 4 ...which according to your rule means that 1900 is the 316th leap year since 1584. Except that 1900 was *not* a leap year, so your rule doesn't work.
You don't have to give every variable in your program a unique name, thanks to scoping rules. What about your system prevents you from from doing something similar for your program? (Use the same environment variable name for all programs, but set it differently for each one.) Heck, given how shell scripting works you can even do it in the same scope: #!/bin/sh YOUR_ENV_VAR=foo ./a --database-url="$YOUR_ENV_VAR" YOUR_ENV_VAR=bar ./b --database-url="$YOUR_ENV_VAR" # This won't change what ./a has YOUR_ENV_VAR=baz ./c --database-url="$YOUR_ENV_VAR" # This won't change what ./a or ./b have Think of your shell environment as a bundle of variables that get implicitly passed by value into function calls, and every subprocess as a function call.
lol
What are the huge problems with Matrix in your opinion?
&gt; Maybe as a single programmer it's not helping you very much. But if you're designing the same system to be worked on by numerous developers, potentially over many years, and with the ability to grow to a much larger size, static typing will greatly help ease the maintenance burden. To be honest, me reading my own code in a few months feels like it was written by a different developer. 
One of the commenters on the blog claims the performance difference is only due to inlining and could be fixed with a few `#[inline(always)]` annotations.
Besides the solutions based on macros and traits, `build.rs` could be used to generate Rust code. This would probably be closest to the C preprocessor, but arguably still more work than it would be in C.
It is. The [matrix.org](https://matrix.org) homeserver is either Synapse or Dendrite (can't remember if they made the move for the official homeserver yet). Both are open source on github.com/matrix-org.
&gt; Well, you can easily get integer overflows in release build. Signed integer overflows in C are undefined behavior and much scarier than in Rust.
The bar is moving all the time, whats an example of a modern type system? The one's I have been paying attention to are Haskell and racket.
That protocol is only for uploading and downloading code; we are one of the heaviest users of Issues, for example. That stuff has nothing to do with the protocol itself.
Email still exists. But you still have to â€œsign an agreementâ€ to participate in the Rust project; thatâ€™s the code of conduct. And to report bugs or publish to crates.io, you need a GitHub account, which requires their terms of service. Pretty sure Mozilla has some terms on using their IRC network, etc.
Zulip is my personal favorite, by *just* a smidge, but many people find its UI quite confusing. Threads are useful but also hard to use.
Discord has stated how they plan on making money: https://support.discordapp.com/hc/en-us/articles/210544537-How-is-Discord-making-money-How-can-I-contribute- We did look at and even try a number of things, but we also didnâ€™t want to elaborate on every last detail in the post.
&gt;it may be handled either by leaving overflow checks on even in release mode, or by using special operations You can leave debug assertions in release build, but it will be horribly inefficient. Or you could use `Wrapping` type, but wrapping is usually not a desired behaviour. Using `checked_*` and other similar operations everywhere will be quite tedious and code will not be pretty. It's a good solution if you have only a handful of places where overflow can happen, but without a proper fuzzing it's quite hard to catch all such places.
I have not tried it.
Give me some ether?
starting from 1584: - 1600, 2000, 2400, 2800 are leap years and - 1700, 1800, 1900, .. , 2100, 2200, 2300, .. , 2500, 2600, 2700, .. are no leap years is that correct? I think should be easy to add an exception for that. didn't know what you were talking about, had to read up leap years in ,ore detail. Currently, I am using the chrono thing anyway. https://github.com/aspera-non-spernit/calendar thanks for the info
So this wasn't what I thought it was. It turns out that the dependency that lead to the error (grpcio) links its own boringssl lib (i.e. it wasn't a transitive cargo dependency). To solve this I built the grpc lib (from the included version) by hand with EMBED_OPENSSL=false and prefix=/opt/grpc-old/ and then set the environment variable GRPCIO_SYS_USE_PKG_CONFIG=1 and adding /opt/grpc-old/lib/pkgconfig to the begining of my PKG_CONFIG_PATH environment variable for my cargo build and then I could use the openssl crate with my installed 1.1.0 version (after specifying the environment variable OPENSSL_DIR) while grpcio used 1.0.2. fun times.
i am looking for a Developers, that wanna make money
I care about not being able to choose my client.
in my country its llegal, but not for rust
Definitely. Actually one of my favourite refactoring techniques is to just make a change I'm sure will break everything because of the type system, and then just track down all the errors and fix them. Much harder to do in dynamic languages where a lot of those errors don't crop up till runtime.
As a mantener of cargos resolver, when it failed to resolve the dependency did it do so fast and with a clear error message?
in case you were on the edge of your seat with my question last week re: openssl version conflicts during linking, I figured it out and added the solution as [a reply to myself](https://www.reddit.com/r/rust/comments/8tooi0/hey_rustaceans_got_an_easy_question_ask_here/e1mre8y/)
&gt; sometimes in Rust I have to change my program since I can't express something in the type system. It lacks higher kinded polymorphism Indeed. That is a feature of Rust, not of static type systems in general. &gt; You could write my program in C easier because I can just use function pointers C is a statically typed language. 
Yeah it only works if it's borrowed, in this situation it's probably only workable with static variables.
Should https://github.com/rust-lang/rust/issues/50202 be included in the tracking issue list?
Rust or Haskell are the most interesting IMO. But ATS or Idris have the bleeding-edge features. 
Compiler has no way of verifying that someone will implement both `test` and `From` traits in some third-party crate, which will result in two implementations. One theoretical solution is to use negative trait bounds (otherwise called "mutualy exclusive traits") `trait Test: !From { .. }`, but quite unfortunately work on it [haven't progressed](https://github.com/rust-lang/rfcs/pull/1148) much.
I have a couple of comments here that I don't want to C&amp;P. https://internals.rust-lang.org/t/exploring-new-communication-channels/7859/32?u=skade
&gt; But you still have to â€œsign an agreementâ€ to participate in the Rust project Not at all. I've never had to accept any legal agreement when I connect to and make use of mozilla's IRC servers. &gt; And to report bugs or publish to crates.io, you need a GitHub account I agree, which is why I specifically mentioned reporting bugs as an example. With no tangible benefits over just using github, I bet many people will find it hard to justify engaging in a legal agreement with yet another third party to their employer. Heck, I'm finding it hard just to justify signing up to myself :/ Finally, there is a big distinction between a legal document to which you explicitly agree, and a document that some party unilaterally and without your explicit agreement declares that you're legally bound to it. I doubt the courts would entertain me if I said "by discussing this topic with me, you agree to pay me 1$ for each word you wrote". As another more topical example: While I believe I was and still am in good standing with respect to the the rust community's code of conduct, I never have agreed to the coc, and I will likely never do so. 
Follow up: Figured out a better way - just use SysAllocStringLen. Program doesn't crash at all now. 
You're disregarding the time? I don't see where you mentioned that before, but okay, that makes sense. In a sense, your benchmark is a misnamed integration test, then, correct?
Inline is always a first step.
You mean to say you haven't managed to *trigger* any further crashes, right? :P
&gt; I doubt the courts would entertain me if I said "by discussing this topic with me, you agree to pay me 1$ for each word you wrote". This is true, but Terms of Service are very much a thing courts follow. You're right *in general* that not every single contract like this is binding, but this is a pretty common pattern.
[Yes.](https://wiki.alopex.li/TheStateOfGGEZ2018)
yyeeeahhhhh
I think complete inference of record subtypes (as promoted by the Algebraic Subtyping paper from a couple of years ago, see [https://www.cl.cam.ac.uk/~sd601/mlsub/](MLSub) would go a long way towards addressing many people's complaints about static typing. I encourage you to try it out: it will automatically infer which fields your function needs and figures out the correct type signature, while allowing you to pass around more-or-less dynamic records.
What are the other viable alternatives?
the way you're using them here is equal to proving their values to "--database-url" directly.
A simple google shows that this is not the case. Many courts including U.S. Court of Appeals for the Ninth Circuit concluded that users must explicitly accept an agreement for it to be binding. If Amazon (zappos) and Barnes &amp; Noble got bitten by it, I doubt Mozilla will fair any better. You need explicit acceptance for a legal agreement to be binding. See this article for a good overview on the subject: https://www.lexology.com/library/detail.aspx?g=0316cf22-d2d8-42a6-8a3c-f75ac6554e42
you dont need to register to join Discord FYI.
I'm hoping for a low friction medium that is built on open protocols and no requirement to accept legal agreements like email or IRC. As far as I know, both GitHub and Rust's discourse instances (whether hosted or SaaS) do not satisfy these requirements.
One thing that's cool to do in languages like python is have lists or dictionaries containing lambda functions with different types. As far as I can tell this is impossible in safe rust, and I'm not even sure if it's possible in unsafe rust.
How would you do a dictionary containing closures of different types, like this One thing that's cool to do in languages like python is have lists or dictionaries containing lambda functions with different types. As far as I can tell this is impossible in safe rust, and I'm not even sure if it's possible in unsafe rust. Here's a real world example I've used this some_parser(some_text, converters={"date": datetime.datetime, "first_name": lambda x: x.split(" ")[0]})
I love Zulip, but I was frequently bitten by annoyances. (e.g. it doesn't persist read state properly) My biggest problem is that it doesn't allow for moderation properly. Still, I love it for being a proper rethink of the chat model.
&gt; - Non-federated I don't understand how a federated tool would help here?
Sure, that's simple for anyone who has notable time down with IRC, but everyone else will scratch their head coming from the services that _just do the intuitive thing_.
Sorry if I haven't been clear enough :) I wrote &gt; I've now been able to make my criterion benchmark run as a test on CI and figured that would be enough to understand me. My bad! It's misnamed on CI, since I only want it as a test there, but I'm using it as a real benchmark on my local machine. Of course, that means that I need full optimizations locally, that's why I asked about the compiler flags in the other comments, because that can make this work automatically after some setup. 
Good catch! Fixed in \[this commit\]([https://github.com/jonhoo/tokio-zookeeper/commit/5d674e4ac91940bf249919886929a517a5e3b455](https://github.com/jonhoo/tokio-zookeeper/commit/5d674e4ac91940bf249919886929a517a5e3b455)).
Matrix?
Nope. Because you will have a hard time sending the reference over and continuing to run both functions. You couldn't run them concurrently. `&amp;mut T` and `&amp;T` can't alias in Rust, this is one of the fundamental guarantees of the language and can't be broken in safe Rust. Yes, for a _very_ detailled discussion, you'd need to talk about aliasing specifically, but for an educational example, choosing operations as functions is very useful.
At least you need to get a username, right? How many guest user will know about it stops at that step?
Winit is gaining quite a bit. They have direct input controllers in the latest version and the first part of a PR for webasm just started yesterday. Also, they can do any graphics backend.
Doesnâ€™t Haskell, Elm and more have `Result`-like types for handling errors? 
From an ergonomic point of view, I prefer discord. I think they should just make a community vote about whether to switch to discord or not. 
Post your code?
The Rust Programming Language (official book) and the standard library documentation (everything in std and core).
It would be better if you put the lines of code that won't compile at the place where one would attempt to put them rather than after the introductory comment of each section. Something like: // passing a parameter also moves ownership // x2 is left uninitialized let x2: Vec&lt;i32&gt; = Vec::new(); ownership_move(x2); // COMPILE ERROR: let z2 = x2 instead of: // passing a parameter also moves ownership // x2 is left uninitialized // let z2 = x2 will not compile let x2: Vec&lt;i32&gt; = Vec::new(); ownership_move(x2);
My intent was just to point out how confused I am by your claims of needing to give every application a unique environment variable name. 
They are technically undefined behavior, but in practice most implementations are twos complement and wrap around as expected. Nobody should have to know what their compiler is doing on this front, but it isn't that much scarier. Rust still does allow the same sort of overflows in release mode that C typically has. Personally, I accept this and strive to use wrapping and option-regurning operations where appropriate, but it is concerning that its possible for the code to have such errors and go mostly unnoticed. Luckily, I usually find myself using things like usize implicitly or explicitly, which I've never had a wraparound issue with because I run out of memory first. In typical coding logic I find i32 to be a rare occurrence and so its okay to remember what operation type to use on them, but I wish there was a less-scary alternative where the type system could protect me (maybe integer newtypes?).
As the other guy said, post a minimal example on https://play.rust-lang.org/
I respect that, but from a practical point of view, I prefer to have a client I can run in my terminal. Which is why I'm for an open protocol allowing us to use whichever client we prefer.
Yes. Although I was initially excited about Mattermost, the development team is extremely community-hostile and refuses to accept community-developed features that would compete with their proprietary offerings, but doesn't even acknowledge this directly, preferring to distract and delay until people give up. It's very upsetting to see this happen, but it completely erased my confidence in Mattermost as a possible open-source alternative to Slack. Here's an example of how this dynamic has played out in the past: https://github.com/mattermost/mattermost-server/issues/6320 For what it's worth, I also think Discord is a bad choice for similar reasons of proprietary control and misplaced incentive structures.
I don't know C well, lol
C is a weakly typed language
`#[do_not_recommend]` sounds like a cheeky alias for `#[deprecated]`.
Discord's API uses HTTP, which isn't proprietary, so it seems like we're good on this front.
This is python not C, thinking about it now I think it's possible by dynamically allocating the closure, then putting it into a struct which contains type information as an enum or something, and use a raw pointer to the heap-allocated closures. I may actually try this
Slack is fairly terrible for open communities. It's designed for enterprise-y customers and it shows. Like, arbitrarily eating backscroll for any channels on non-paying servers is just extremely inconvenient, but last I checked there is no way in slack to put people on an ignore list, which is just incredibly insufficient outside of the context of an enterprise environment with a functioning HR department.
Rust is more conservative language â€“ you can basically say that there is no "new" feature in Rust that is not very well tested in the wild (academia). What makes Rust unique is the combination of features that are not really common in current mayor languages paired with modern well functioning tools (cargo). But there is no mayor feature that no other â€“ especially academic languages â€“ have not seen before, for a good reason. Rust is lifting those features to the mainstream (hopefully) 
I already have a vps server for other reasons, so installing ZNC was simple. From there, I use HexChat to connect to it. I was using IRCCloud when it was provided by my previous employer, and felt it was excellent.
I don't have pretty printing on mobile, I thought you posted Rust code, lol.
Does `getopts` allow multiple arguments per option? I'm trying to build a cli that follows the form of : program -a arg1 -b arg1 arg2 arg3 ... -c arg1 arg2 arg3 ... But `getopts` never seems to collect anything past `arg1` for each option. I even set the parsing style to `getopts::ParsingStyle::FloatingFrees` . I can get it to work if I surround args1-3 in quotes, but this seems like a workaround to me, and it wouldn't be the most ergonomic to thing to type every time. Do I need to use a different argument parsing crate, or did I over look something? Here's a super basic example of what I have: extern crate getopts; use getopts::Options; use std::env; fn main() { let args: Vec&lt;String&gt; = env::args().collect(); let mut opts = Options::new(); opts.optopt("a", "args", "Option Flag", "ARG ARG ARG ..."); match opts.parsing_style(getopts::ParsingStyle::FloatingFrees) .parse(&amp;args[1..]) { Ok(m) =&gt; { if m.opt_present("a") { println!("{}", m.opt_strs("a").join(" ") ); } }, Err(err) =&gt; {}, } } Then `./program -a arg1 arg2 arg3` simply outputs this `arg1`.
I like the idea of Matrix quite a bit, but in my experience it's got a lot of bugs tracking who's online, quite a bit of message lag, and a UI that's painful to use. (That last one's being worked on, at least!)
The main benefits of Dynamic languages, for me, is exploration... and refactoring. You have a large code base, with ~100 implementers of `Interface`, and you'd like to change `Interface` because it doesn't quite match the current usecase: say, you need to split a method in two different ones (each taking a subset of the arguments). In a Dynamic language, you do the change for `Interface` and **one** of its implementation, then take that for a spin and see if it works. If it doesn't, you can tinker, test out various ways of cutting the methods, maybe add a third one, maybe move the parameters around. And then, finally when it works out with one implementation, you apply it to another and check it out, etc... In a Static language, you cry. Every time you change the `Interface`, you have to align all implementers for the program to compile, before you can even test. **Iterating becomes impossible**. Our grandfathers, who developed on punch cards fed to a mainframe by an operator team overnight would tell you that we're lucky, and in their time they really had to think hard since feedback was a day away. However, in complex code bases, exploration is often much faster than staring hopelessly at the code. But... that is not an issue of Static **languages**, it's an issue of Static **implementations**. There is no reason that an interpreter/byte code VM cannot be made for a Static language, and that a number of checks cannot be deferred to run-time instead. For example: - Type not implementing Trait properly? Panic when attempting to cast value of Type to Trait. - Expression not matching explicit Type? Panic when attempting to pass Expression as Type. - Function does not exist? Panic when attempting to call it. - Function exists but not with these arguments? Panic when attempting to call it. In essence, you could imagine replacing a substantial set of compiler diagnostics with an insertion of `panic!("&lt;diagnostic&gt;")`. This would not change the *language*: all possible correct programs would continue to execute correctly, all possible incorrect programs would fail to execute (completely). It only changes the implementation. It's a ton of work, though...
&gt;Websites should be allowed to choose what they send to protect its users at the expense of their freedom. I wouldn't call it freedom, but yes. [docs.rs](https://docs.rs) has no obligation to allow users in. It should anyway, but it has the right to restrict access, just like a password-protected website. &gt;Browsers should not cooperate, especially they don't make clear to the user that they cooperate. I wouldn't call it cooperation either, but yes. For the user, it's a restriction rather than cooperation. And last time I checked, Firefox doesn't just make it unclear, it says something like â€œyou can't add an exceptionâ€, which is incorrect.
IRC may not be very pretty, it may not be very 'modern', by the values of modern which apparently require a text chat app to consume several hundreds of megabytes of RAM and so on, but it has certain clear advantages. 1. Accessibility: IRC is a protocol simple enough people can speak it via telnet (and sometimes do), and so there are clients to fit practically every possible need and mode of access. 2. Parsimony: people can IRC from practically anything smart enough to do TCP/IP, even under conditions of very limited RAM, CPU and bandwidth. 3. Automation: it's trivial to write IRC bots to log, reply to things, act as platform bridges, and so on. 4. Autonomy: IRC doesn't depend on any third party to exist (and I'd dare say by the time Discord is no more, IRC will continue to exist). For these and many other reasons I consider the change away from IRC harmful. 
&gt;https://github.com/SergioBenitez/Rocket/issues/19 Hey! nice experience tales. Have you work with user authentication/authorization or something like OAuth in Rust/Actix-web? I'm think off starting an API using actix-web.
This is amazing, looks like the Rust ecosystem for GraphQL is shaping up nicely.
Turning on overflow checks does not imply turning on debug assertions, which is more expensive. Overflow checks arenâ€™t free, but I'm pretty sure their cost is manageable for many applications.
(Author here) I think this is where gradual typing (or more broadly, [gradual programming](http://willcrichton.net/notes/gradual-programming/)) shows a lot of promise. In an ideal world, a mixed dynamic/static language provides the ease of prototyping a new program/system, but then allows the programmer to write down and statically verify details like types and lifetimes, providing their mental model a concrete shape enforced by the compiler.
The list is only for things that are in their Final Comment Period.
This is exactly what I'm looking for. Great job!
But is the API that is on top of HTTP documented / published? Can it be used freely to implement free server / clients?
Right, but for the purpose of comparing with GitHub, Matrix.org is similar in that it is not self-hosted but a service â€“ so it would not matter what software is actually running. The important part is, that you can still write/use your own servers/clients.
&gt; While it is strictly true that programs in Coq are correct, it's important to point out that they are correct with respect to their specification. The last time I read about this difference was, if I remember correctly, reading about how the `sort` method of `Ada` was proven to be correct. Turns out that the "specification" was just "output is sorted", which meant returning an empty array was a valid implementation. The author of the article then went through the steps they took to improve on the specification: - first adding equal length: `[0, 0, 0, ...]` is correct, no matter the input, - then adding that elements in the output must be in the input: `[in[0], in[0], in[0], ...]` is correct for all non-empty inputs, - ... It took them 4 or 5 steps to finally wrangle the correct specification: the output must be a permutation of the input, and sorted. They also mentioned not even trying to prove the *stability* of the sort.
Zomg! 
&gt; They are technically undefined behavior, but in practice most implementations are twos complement and wrap around as expected. You wish. Let's take a [trivial example](https://godbolt.org/g/9mE6UT) compiled with gcc trunk (9.x) with all bells and whistles (`-O3 -std=c++17 -pedantic-errors -Wall -Wextra`): #include &lt;cstdio&gt; int main() { int i = 0; for (; i &gt; 0; ++i) { printf("Hello, World!"); } return i; } As can be seen in the assembler panel, it's optimized to: int main() { return 0; } Thank you C! 
Seems like a perfect case for optionals (https://doc.rust-lang.org/std/option/).
Technically that is correct. It should warn you though.
&gt; You can leave debug assertions in release build, You don't have to leave *all* debug assertions, you can selectively active overflow checks. &gt; but it will be horribly inefficient. That's quite dramatic. It will be inefficient for math-heavy work-loads programmed naively, but: 1. Many work-loads are not math-heavy to start with, turning on overflow checks on a run-of-the-mill codebase would be a few % at most. 2. Usual optimization guidelines apply, you can selectively rewrite hot spots to regain performance by switching to wrapping semantics where it's acceptable.
Which one is the recommended one. And which one should be avoided and when? use std::io; fn main() { // some code } fn main() { use std::io; // some code }
Why didn't you use rhusics instead ?
No moving the goalposts!
thank you. what I don't like here is that implementors have to pass None, if the Weekday is unimportant. So I could just pass any weekday or an option, does*t make a difference. pub fn render&lt;'a&gt;(by: By, start_date: NaiveDate, epochs: i32, week_begins: Option&lt;Weekday&gt;) -&gt; Result&lt;Calendar, &amp;'a str&gt; { if By::YEAR.eq(&amp;by) { Ok(Calendar::Yearly(yearly(start_date, epochs))) } else if By::MONTH.eq(&amp;by) { Ok(Calendar::Monthly(monthly(start_date, epochs))) } else if By::WEEK.eq(&amp;by) { Ok(Calendar::Weekly(weekly(start_date, epochs, week_begins.unwrap()))) } else { Err("ERROR: Unknown") } } Maybe I understand it wrong? Above asks of a Weekday option. So the invoking fn has to pass Some(Weekday::Mon) or if doesnt matter it passes None. Right? It's not more convenient for those who want a Yearly, Monthly Calendar, they still have to pass something that doesn't matters.
I put `unwrap` (and `expect`) into the same bag as `assert`. It definitely belongs into production code, but to catch bugs, not check input or so. In that specific example â€’ it depends. You could call not having enough entropy a bug in the OS/deployment. But if you ever expect your code to run on eg. a router, then you better consider this as something that as well may happen and handle it somehow. Or just follow the advice in docs and use the EntropyRng.
The closure implements Fn because that is the bound on server::new [server::new](https://docs.rs/actix-web/0.6.11/actix_web/server/fn.new.html) . You could clone the state passed. Iâ€™m not at my computer, but if you could pass the parameter by reference you can use a move closure to move the parameter in the closure object.
I have a Windows laptop that I never use, what does this take in the way of building? Do I need to download [Visual Studio](https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-relnotes) ?
`cargo run --release` should work just fine with a standard rust using rustup also it works on linux (tested) and you may be able to make it works on macos with moltenVK though I can't test. (maybe you worry because of the appveyor script line ?)
Awesome, I'll give it a go.
it looks like that doesn't fix it, it just switches which bounds is remembered. the last one wins.
Woohoo! I can count that as my first open source contribution.
IRCCloud is a really nice web client. Or if you enjoy the settings of your terminal, weechat runs in it and is also excellent (with tons of customization options as well).
What would the type of such a hashmap be, since the functions have different types. The first is a function from str -&gt; date and the other is from str -&gt; str
because I didn't knew it existed I can't say that much right now: * It's probably more idiomatic to use with specs (though my current workflow is I think OK) * Also it looks to have less feature for now
`&amp;Fn(Arg) -&gt; Return` where those types contain all the info you need :\^)
Ah crap, botched it. I meant `i &gt;= 0` :p
I think what you're supposed to do is use CompleteStr as the input type to your parsers so that they know when they're at EOF that the input is complete. You can't use float_s in that case but if you look at the implementation you can copy/paste it to your own 'float_cs' which takes a CompleteStr as input. #[macro_use] extern crate nom; use nom::{float_s, recognize_float, IResult}; use nom::types::CompleteStr; pub fn float_cs(input: CompleteStr) -&gt; IResult&lt;CompleteStr,f32&gt; { flat_map!(input, call!(recognize_float), parse_to!(f32)) } fn main() { let input = "3.14"; println!("{:?}", float_s(input)); //Err(Incomplete(Size(1))) println!("{:?}", float_cs(CompleteStr(input))); //Ok((CompleteStr(""), 3.14)) } It may be cheating you of something but you can see a complete solution [at this gist](https://gist.github.com/ian-p-cooke/d3d737c260a41bbb78d7e4acabce6000). I've only used nom a few times so this might not be completely right but it works.
I bumped into that mesa bug two weeks ago, really happy to hear there's some fixes for it!
You could change your `By` enum, such that it has a `Week(Start)` variant. Then, if a user wants to render weekly, they have to include the additional field in the variant. Users aren't bothered when using the other variants.
Thanks! That's some concrete information to work with :)
Nah one huge enum is not what I'm trying to do. 
Doing housework works great for me.
I haven't tried this, but use `Any` maybe? If you don't want to check that every case is taken care of, then there is an escape hatch
And yet, much of that can be verified in isolation and only exposed through a safe interface. See https://os.phil-opp.com/, for example.
https://discordapp.com/developers/
D'oh, right, I misread the headers. Anyway, I'm not too familiar with the process, how will a FCP get triggered for that tracking/stabilization issue?
I've been using clion for rust and enjoying it. I'm assuming this stuff applies to clion as well? Also how come Jetbrains makes 40 different ide's instead of selling plugins. It feels weird hopping from clion to webstorm when I want to program Javascript when the experience is so similar.
I'll try IRCCloud - thank you. I *much* prefer to run anything I possibly can in my browser.
How does Clion compare to VS Code for Rust, in your opinion?
When it seems that enough discussion has taken place to make a decision, a member of the relevant team can propose FCP. Then rfcbot will ping all the team members, who can either sign off or object to the proposal. Once the majority of team members sign off and there are no remaining objections, the 10-day Final Comment Period begins.
That kind of parameter handling seems non-conventional so it's likely that libraries don't support it. I think that a more standard way would be `program -b arg1 -b arg2 -b arg3` or `program -b arg1,arg2,arg3`. If you really want this, you can always implement your own command line parsing.
Unfortunately, this is not true. There is an infamous GCC issue where the compiler optimized away an overflow check, because overflow is undefined behavior and thus assumed to never happen. This can result in CVE-worthy bugs.
I have very little experience with VS Code so I'm not in the best position to compare. Prior to writing any rust I used IDEA for Java programming so jumping to Clion from that felt very natural. When I went to try rust out initially I tried using vs code and ran into some issues. It was probably just something messed up with my install somewhere but I wasn't really in the mood to fight with my setup at the time so I figured I would just try clion and see if I had the same issues. I generally prefer a more full-featured IDE to alternatives so I probably would of preffered clion anyway. The Rust plugin seems to support the language well and I dont notice any obvious pain points. Most annoying thing was it didnt come with a debugger out of the box , You gotta install gdb yourself. Only after you install the first version that you see via mingw does it tell you that you need a newer version than the one you just installed. IIRC I had to get it from cygwin. So tldr; Can't really comment on VS Code but my experience in Clion has been great.
Side node: Seems this needs to be `RUSTFLAGS="-C opt-level=0" cargo bench`.
I don't disagree with your gripes, but for anyone else reading, I want to emphasize that what you're talking about is the public Matrix homeserver run on matrix.org, and the web client Riot. These are implementation issues that will be ironed out eventually. The Matrix protocol itself is still a good choice, for its openness and interoperability. That said, until client and server implementations mature, your issues do create some practical issues for Rust adopting it all.
Generally most people would use 1 over 2. I think 2 is really only used when the import is only used within the function and nowhere else.
actix-web constructs a new `App` for each worker thread, which is why the closure passed into server::new is a Fn and not FnOnce. The easiest way I've found is to construct your State in the closure, e.g.: info!(log, "Starting server..."); server::new(move || { App::with_state(AppState { recommender_engine: recommender_engine.clone(), logger: log.clone(), }).middleware(middleware::Logger::default())
What's not great about it?
Are there some elegant rustic way to implement/design a generic function depending on whether a generic type implements a required trait or not? (Do X if trait is satisfied, otherwise do nothing) [Play Rust Example](https://play.rust-lang.org/?gist=614e80dc549ca9844db3e2cce67f21e8&amp;version=stable&amp;mode=debug&amp;edition=2015)
https://github.com/dtolnay/mashup You pick what to name the substitution macro so feel free to call it something other than `m`.
Generally you want to go with the first option. I use the second really only in one scenario: it's useful within a utility function dealing with a lot of types which aren't used anywhere else in the file. Ex: // in cratea enum SomeEnum { A, B, C, D, E } // in our crate impl From&lt;cratea::SomeEnum&gt; for MyEnum { fn from(other: cratea::SomeEnum) -&gt; Self { use cratea::SomeEnum::*; match other { A =&gt; MyEnum::A, B =&gt; MyEnum::B, C =&gt; MyEnum::C, D =&gt; MyEnum::D, } }
It's fixed in the latest Mesa version, but a number of non-rolling-release distros still use the old one. ggez's solution is more a workaround than a fix: you just turn off sRGB rendering and all your colors get a little wonky but your game stops crashing. :-/
For projects which are a bit larger than hello world IntelliJ Rust plugin is just too slow and totally unusable. Every keystroke causes constant 100% CPU due to code analysis, this is barely acceptable, especially on laptops. Code analysis and navigation is pretty good though. VS Code is way faster and works great with CodeLLDB debugger plugin.
Is rhusics preferable over nphysics?
&gt; https://play.rust-lang.org/?gist=8719bfe2aff12b72d73d4fc27d13e488&amp;version=stable&amp;mode=debug&amp;edition=2015 Okay, so the common technique I am seeing here is the recursive `$($tail)*` call of the macro. I think I still need to study more (I don't quite understand the semantics of `$($x)*`) but this is a good place to start. Thank you.
`getopts` seems to follow unix command line option standards for most things, and that's really not a common usage. In standard utilities, arguments which don't start with `-` and don't have a `-x` option behind them are position independent relative to `-` options. e.i. `tac file-a file-b -s SEPARATOR file-c file-d` is equivalent to `tac -s SEPARATOR file-a file-b file-c file-d` and `tac -s SEPARATOR -- file-a file-b file-c file-d`. `getopts` assumes you want standard unix handing of arguments, since this is how people will assume your program behaves. Since standards make program configuration predictable, I believe this is a strength. I'd definitely recommend rethinking the way you take arguments. If you really do want to do it this way, you might need a different options crate.
Have you given a try to Amethyst?
I have started to use it only recently, found it bearable. Threading helped us continue conversations at a later date. As you said, UI wasn't appreciated by all my colleagues. It takes some time to get used to.
I downloaded and built with, cargo run, but, it pops up a full-screen that says, "Connect a Controller...". Does it not support keyboard/mouse? Is a game controller required?
CLion works pretty smoothly for me. Medium sized project, plenty of libs and modules and I can have three-four instances of CLion opened at a time. Compact Linux laptop 12G + SSD. I don't miss VSCode at all. Parses macros, completion, debugging. All that's missing IMO is some refactoring abilities other than renaming stuff.
Depending on how far back you tried it, there've been tons of optimizations made to the infrastructure and it works just fine now. My WoW guild uses them for voice chat and it's fine.
maybe #[no_recommendation]? #[disable_recommendation]
I would say the book explains it correctly, matching on ```&amp;val``` is basically the same as matching on ```val``` directly and then later dereferencing it with the * operator, hence it gives you a value directly, instead of a value behind a reference. ```ref``` does the exact opposite, it matches on a value, but to prevent moving it, it will give a reference to that value instead. An example of ```ref``` usage would be let opt = Some("test".to_string()); match opt { Some(ref val) =&gt; do_something(val), None =&gt; ..., } println!("I can still use val: {}", val) As opposed to let opt = Some("test".to_string()); match opt { Some(val) =&gt; do_something(&amp;val), None =&gt; ..., } println!("I can still use val: {}", val) // error! 
&gt; It would be stupid to have to pass any Weekday even if it's not needed. I don't mean to go off on a tangent, but I'd suggest encoding by locale instead of by the first day. i.e. you pass US or UK. I believe for the US that is Sunday, and for the UK it's Monday (although in practice it can be a mix based on what you look at). [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) states it starts on a Monday too. So that's an alternative way of encoding this. I would imagine you may need to have that set anyway to handle the differences in date format by region (i.e. 'day month year' vs 'month day year' layouts).
**ISO 8601** ISO 8601 Data elements and interchange formats â€“ Information interchange â€“ Representation of dates and times is an international standard covering the exchange of date- and time-related data. It was issued by the International Organization for Standardization (ISO) and was first published in 1988. The purpose of this standard is to provide an unambiguous and well-defined method of representing dates and times, so as to avoid misinterpretation of numeric representations of dates and times, particularly when data are transferred between countries with different conventions for writing numeric dates and times. In general, ISO 8601 applies to representations and formats of dates in the Gregorian (and potentially proleptic Gregorian) calendar, times based on the 24-hour timekeeping system (with optional time zone information, e. g. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I would wager there's no idiomatic bindings, but you can definitely pull in https://crates.io/crates/winapi and add the "winsvc" feature to get the win32 api functions needed. You will need unsafe code, however.
Well, yeah, it's not really a criticism of Rust at all, it's a criticism of the idea that strong typing is *always* the best choice, at every level (even if you are getting those benefits elsewhere). 
that would be cool. It took me a while, until I figured out how to 'stack' the enums correctly, and how to use them. #[derive(PartialEq)] pub enum Start { Day(Weekday) } #[derive(PartialEq)] pub enum By {Year, Month, Week(Start), Day} pub fn render&lt;'a&gt;(by: By, start_date: NaiveDate, epochs: i32) -&gt; Result&lt;Calendar, &amp;'a str&gt; { match by { By::Year =&gt; { Ok( Calendar::Yearly(yearly(start_date, epochs)) ) }, By::Month =&gt; { Ok( Calendar::Monthly(monthly(start_date, epochs)) ) }, By::Week(start) =&gt; { Ok( Calendar::Weekly( weekly(start_date, epochs)) ) }, By::Day =&gt; {Err(FUNC_NOT_IMPL)}, _ =&gt; {Err(FUNC_NOT_IMPL)} } } and invoke the whole thing with: let by = By::Week(Start::On(Weekday::Mon)); match calendar::render(by, NaiveDate::from_ymd_opt(ro[0] as i32, ro[1], ro[2] as u32).unwrap(), ro[3] as i32) { Ok(calendar) =&gt; { println!("{:#?}", calendar) }, Err(e) =&gt; { println!("{:#?}", e) } } It took me a while to figure out how to do that. First of all, I got double Names for structs and enums, then I did not know how to eq the By::Week correctly, but with the match it works and looks a little bit more like Rust :) When I look at my code, I always think of a split personality. the for-loops and if else doesn*t look much like rust :) Thanky you very much.. let by = By::Week(Start::Day(Weekday::Mon)); match calendar::render(by, NaiveDate::from_ymd_opt(ro[0] as i32, ro[1], ro[2] as u32).unwrap(), ro[3] as i32) {..} 
We have had issues with Dask dropping messages at high volumes, so I will certainly be investigating Rain for our cluster
yes a game controller is required, and yes it is not very clever for an example game. I think xbox controllers work fine on a recent enough linux. But I don't really know. I have a xbox360 controller.
actually not since a very long time. the reason is that I need to do some very specific shader stuff in my other games and so I use vulkano (maybe I should give gfx-rs a try also). amethyst is a complete engine and use specs inside. (I actually learned ECS and specs from them)
I think the situation you described is not quite what the book is describing. RPL describes the difference between **matching** on `ref` vs. **matching** on `&amp;`. So, in terms of the code you wrote, it would look more like ``` let opt = Some("test".to_string()); match opt { Some(ref val) =&gt; do_something(val), None =&gt; ..., } println!("I can still use val: {}", val) ``` versus ``` let opt = Some("test"); match opt { Some(&amp;val) =&gt; do_something(val), None =&gt; ..., } println!("I can still use val: {}", val) // Can you? ``` Of course, I could be wrong, but I feel like the language RPL uses implies my version, or something like it. The book specifically contrasts how "`&amp;` matches a reference", but "`ref` matches a value". As a side note, I'm not sure if your first example compiles. Isn't there a scope issue with using `val`? What what I've learned, values in Rust die when they leave their local scope.
Works damn fine for my 6kloc project. Sometimes it freezes if left unattended though. 
IDEA is horribly slow, but rls is useless (works only on hello world level projects). PS: I'm using IDEA.
You can't do *anything* without unsafe. Like, the entire standard library is built on unsafe. Yet, here we are, with a pretty full, (mostly) safe standard library built on these unsafe abstractions. Similarly, I like to think of the Rayon crate, which sort of has three 'layers' of code - the very unsafe layer, a more abstract somewhat safeish-er layer, and a safe layer (I have butchered the explanation, but you get the point). An OS would not have any more serious problems than these projects and it would not take any different approach. You build the unsafe layer and add safe abstractions on top. And then auditing is something even a novice can do.
The 2018 release is much improved in regards to speed. 1000+ line files take about 10 or 20 seconds to index for me now instead of pretty much not indexing on whatever 2017 release I had.
I don*t think I want to pass US or UK only. There are over two hundred countries in the world and I have my Calendar starting on Sundays, although Monday is commonly used. I think it has nothing to do with the UK or US, it's more of a religious thing.
You're right, I mixed up ```opt``` and ```val```. The example I gave was more to show the usage of ```ref``` to avoid moving variables, it's not a very good example to show the contrast between these types of matching. Direct comparisons are not that useful in this case anyway, since these features do the exact opposite. An (very contrived) example of ```&amp;``` matching would be let x = &amp;5; match x { y =&gt; { let z = *y;}, ... } let x = &amp;5; match x { &amp;x =&gt; *x, // impossible, x is not reference _ =&gt; unreachable!(), }
You're just not replying to what I posted. I know Rust fixes some bugs, it's just disingenuous or ignorant to say that 'just' rewriting 20 million lines of C using Rust could fix half the bugs of the entire Linux kernel.
Thanks. I think this clears it up. 
&gt; `#[derive(PartialEq)] pub enum Start { Day(Weekday) }` That doesn't seem necessary? An enum with just one branch that has just one field can just be replaced. Instead change your other enum to: #[derive(PartialEq)] pub enum By { Year, Month, Week(Weekday), Day. } or #[derive(PartialEq)] pub enum By { Year, Month, Week { start : Weekday, }, Day. }
The UI, memory usage, emphasis on gamers, it's proprietary and you have to use their client, and many other things that other people have already brought up. 
ok. i changed that to the first example. The thing is often, my attemps don*t work on first try, then I try an try again, and try to do what the compiler says and then my code is messed up. thanks for your help
I have a few HTTP bindings I want to write that connect to end points which only work with JSON. It basically boils down to using Serde + Reqwest/Hyper/whatever. I see this as a pattern I want to use against several APIs (some public and some internally at work). Are there any crates which exist that make it quick and easy to build this?
&gt; `cargo run --release` :-( $ RUST_BACKTRACE=1 cargo run --release Finished release [optimized] target(s) in 0.13s Running `target/release/airjump-multi` thread 'main' panicked at 'failed to create instance: IncompatibleDriver', libcore/result.rs:945:5 stack backtrace: 0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace at libstd/sys/unix/backtrace/tracing/gcc_s.rs:49 1: std::sys_common::backtrace::print at libstd/sys_common/backtrace.rs:71 at libstd/sys_common/backtrace.rs:59 2: std::panicking::default_hook::{{closure}} at libstd/panicking.rs:211 3: std::panicking::default_hook at libstd/panicking.rs:227 4: std::panicking::rust_panic_with_hook at libstd/panicking.rs:511 5: std::panicking::continue_panic_fmt at libstd/panicking.rs:426 6: rust_begin_unwind at libstd/panicking.rs:337 7: core::panicking::panic_fmt at libcore/panicking.rs:92 8: core::result::unwrap_failed 9: airjump_multi::graphics::Graphics::new 10: airjump_multi::main 11: std::rt::lang_start::{{closure}} 12: std::panicking::try::do_call at libstd/rt.rs:59 at libstd/panicking.rs:310 13: __rust_maybe_catch_panic at libpanic_unwind/lib.rs:105 14: std::rt::lang_start_internal at libstd/panicking.rs:289 at libstd/panic.rs:392 at libstd/rt.rs:58 15: main 16: __libc_start_main 17: _start
The functions *could* execute concurrently is my point. There's nothing preventing the functions from running concurrently, only that they can't share `&amp;mut` data while doing so.
It doesn't seem that disingenuous, for the reasons I posted.
It seems like all of the memory management strategies can be libraries on top of static memory management like Rust does. In fact, Rust already has some of the (like reference counting) through crates/modules/libraries. In addition, I believe there was proof-of-concept GC as a crate/lib for Rust. I'm not seeing what baking it all into the language actually accomplishes.
Well I don't know how specific your stuff is, but Amethyst does allow for quite precise handling of meshes and shaders.
Does your gpu have vulkan?
`#[do_not_suggest]` or short `#[no_suggest]`?
\* backs into corner \* I don't even know what it is. Maybe this isn't for me.
`#[nope]`
Huh? If you call iterate_over_vec you have already reborrowed the mutable reference it took, so there's no problem sending it to another thread (using something like crossbeam).
&gt; I'm not seeing what baking it all into the language actually accomplishes. well you can look at D for that. or, less negatively: ergonomics. writing @a instead of having to construct a GC and calling gcify(a, &amp;mut gc) or similar.
Hey thatâ€™s fine :) Which OS are you on?
I know f32 and f64 both have .to_radians() functions, but I'm trying to implement a generic function for this as a toy example and really struggling. Here's what I have: use std::f32; use std::f64; use std::ops::Div; trait HasPi { fn pi() -&gt; Self; } impl HasPi for f32 { fn pi() -&gt; f32 { return f32::consts::PI; } } impl HasPi for f64 { fn pi() -&gt; f64 { return f64::consts::PI; } } pub fn deg_to_rad&lt;T: HasPi + Div + From&lt;f32&gt;&gt;(deg : T) -&gt; T { let denom : T = T::from(180.0); let pi : T = T::pi(); let denomdivpi : T = denom / pi; let result = deg / denomdivpi; return result; } I get an error on this line: let denomdivpi : T = denom / pi; Because the result of the RHS is std::ops::Div::Output. Am I using the wrong trait for Div?
Ah! :-) Ubuntu 17.10 (Linux 4.13.0-46-generic). I tried Rust stable (1.27.0) and Rust nightly (1.28.0-nightly). Also, I have an Intel HD Graphics 620.
You probably need to install the Mesa Vulkan support. â€œsudo apt install mesa-vulkan-driversâ€
I see. That does rely on not encountering undefined behavior. That is a little concerning.
You might consider implementing your automata using my trait centered grid simulation library: https://github.com/evomata/gridsim
It worked immediately after doing that! Now, "Connect a Controller to start the game"â€¦ Can you send me a controller? ;-)
Haha, unfortunately I canâ€™t do that ;-)
It is on crates.io as well if that helps.
While parts of the discord API are documented and open, these parts are more aimed at building bots, and definitely not ideal for making alternative clients.
Not the most diplomatic way to put it, but I agree.
This seems to be the correct answer, but I'm curious -- how do you find out which type of dependencies you will need for some of the operating system specific rust crates? Trying to build this same program on linux means I need a different set of dependencies, but I would like to know if there's a good way to find which dependencies I need for each operating system I wish to build for.
Its also parallelized with rayon as well.
I like to play emulated games on dolphin so I bought a GameCube adapter to usb and original GameCube controllers. Also the PS4 controller works really quite well with ds4drv. Itâ€™s a user space program but I have it daemonized in runit. 
There are a couple of smallish, but useful local refactorings besides renamings: * extract variable via `ctrl+alt+v` or `.let` postifx snippet, * switching between `mod foo { ... }`, `foo.rs`, `foo/mod.rs` style modules, * many tiny intentions: swapping things around `,`, filling of `match` arms, moving conditions from guards to if expressions, etc. 
What does â€œand its dependenciesâ€ mean? You could always use the â€˜net stop &lt;service&gt;â€™ command
I tried "sudo apt install game-controller", but, it didn't work! :(
Hey, I thought I'd let you know I got it to work thanks to @rcygg 's post below. However, I think that it still leaves me with some questions about how to deduce which libraries may be missing on a given machine. [https://github.com/TheYokai/rust-cpp-cmake/tree/master](https://github.com/TheYokai/rust-cpp-cmake/tree/master) The above is the master branch of my rust / cpp program made with cmake. The program is buildable on linux machines (or VMs) and can probably be configured to work on windows if you simply change the .a references to .lib files. Going into the build directory and running $cmake .. $make Should produce a valid executable. And yes, cargo is run through my Cmake configuration. The bindings should be auto generated through cbindgen (I haven't thoroughly tested the build-dependencies entry in the toml file.) [https://github.com/TheYokai/rust-cpp-cmake/tree/random\_number](https://github.com/TheYokai/rust-cpp-cmake/tree/random_number) Here, however, I am missing the additional libraries needed to build rand. While rcygg gave me what I needed to know for a windows specific build environment, I am curious to know how one reasonably finds the system level dependencies for a crate such as rand. The build procedure should be the same as above btw, but will produce the following error on the random\_number tree. ../rust_test/target/release/librust_test.a(rand-d742f089d4f5ed66.rand13-3bb38a84cc458c1b196e23822738feaf.rs.rcgu.o): In function `std::sync::once::Once::call_once::{{closure}}': rand13-3bb38a84cc458c1b196e23822738feaf.rs:(.text._ZN3std4sync4once4Once9call_once28_$u7b$$u7b$closure$u7d$$u7d$17h8391722b2fc155fcE+0x4c): undefined reference to `pthread_mutexattr_init' ....SNIP, too long for reddit.... /checkout/src/libstd/sys/unix/process/process_unix.rs:222: undefined reference to `pthread_sigmask' collect2: error: ld returned 1 exit status CMakeFiles/RustCPPTest.dir/build.make:95: recipe for target 'RustCPPTest' failed make[2]: *** [RustCPPTest] Error 1 CMakeFiles/Makefile2:67: recipe for target 'CMakeFiles/RustCPPTest.dir/all' failed make[1]: *** [CMakeFiles/RustCPPTest.dir/all] Error 2 Makefile:83: recipe for target 'all' failed make: *** [all] Error 2
Documentation link seems to be a 404.
I don't think referring to let x1: Vec&lt;i32&gt; = Vec::new(); is correct 
 &gt;QuietMisdreavus commented 2 days ago &gt;To all those who are asking docs.rs to be an official thing: Onur is on &gt;the rustdoc team now, and the plan is to do just that. We haven't had &gt;the opportunity to loop more people into the project yet. 
Nice, I wanted to create something like this, and now I don't have to :)
The docs suggest using OsRng I believe, though EntropyRng looks like it is simply a wrapper around it that will try JitterRng if OsRng fails, and will panic if it cannot do either. I may actually use EntropyRng now that you told me about it, but I don't believe the docs suggest it anywhere they seem to suggest OsRng. 
``` if { condition_a =&gt; { do_a(); do_b(); } } ```
 match () { () if condition_a =&gt; do_a(), () if condition_b =&gt; do_b(), _ =&gt; do_c() }
IntelliJ Ultimate has plugins that give it all the functionality of the language specific IDEs. If you are doing multi-language development I highly recommend getting Ultimate. The first time you open a file (in Ultimate) for a language, it will ask if you want to install the plugin for it it, or you can just install the plugins manually. 
Ah OK, I'm currently playing with rhusics and was wondering if I'd better go the nphysics route. I don't really need the features now, I just thought it would be easier to use. Thanks for sharing your code BTW.
It seems the lang specific IDE's have the plugins as well though. Right now I can install the rust plugin in clion,webstorm, and IDEA. I can also install javascript templating plugins in clion, that come default with webstorm. Yet I could probably do rust development in webstorm exclusively if I had to. They way they have it \[[https://vgy.me/p2WcAK.png](https://vgy.me/p2WcAK.png)\](setup) seems really strange to me. Why would I ever get the all products pack if I can get all the functionality in IDEA via plugins. When there is so much feature overlap between the IDE's it would make more sense to just ship 1 IDE and sell plugins for it. 
Bots have been made that bridge discord and irc, it's one of the first things people were making with them.
Last I checked not all of their ide's are available via plugins. Clion specifically.
You can install all editors functionality on any of them via plugins, but from what I understand, the plugins are not as up to date as the platform/language specific editors.
Intellij IDEA Ultimate is much more expensive than getting one or two specialized IDEs.
There's nothing in your code that says division results in `T`. It could be anything, so you need to be more specific. T: HasPi + Div&lt;Output=T&gt; + From&lt;f32&gt; 
Thanks
Maybe something like that should be the preferred way. Does rust have a way of making this let foo = if condition_a { 0 } else if condition_b { 1 } else { -1 }; Look as clean as this let foo = match { if condition_a =&gt; 0, if condition_b =&gt; 1, _ =&gt; -1 }; I mean this is a nice explicit way of saying here's a sequence of dependent cases. I wonder if they produce drastically different assembly.
I figured it was something like this or little exclusive features on the specific IDE's(It's hard to tell what features are unique to an IDE and what can be achieved via plugins). If this is the case doesnt this result in me having to use pretty much 1 IDE per language to achieve the best experience possible in a given language. I don't mind having multiple open but it's def not an ideal scenario.
Looks like you're right about CLion. https://intellij-support.jetbrains.com/hc/en-us/articles/206558629-Is-there-a-community-edition-for-CLion-Is-CLion-available-as-a-plugin-for-IntelliJ-IDEA- I use Ruby/Python/Java in IntelliJ Ultimate.
Thanks a lot, that's what I was missing! This is new from version 4.0 apparently so that's why I didn't see it mentioned in guides I guess. It seems to be a concern for some people that they couldn't reuse their parsers for both streams and complete slices. I'm wondering if it could be possible to have a "mapping to complete" function like so: fn to_complete&lt;F, G&gt;(f: F) -&gt; G where F: Fn(&amp;str) -&gt; nom::IResult&lt;&amp;str, f32&gt;, G: Fn(CompleteStr) -&gt; nom::IResult&lt;CompleteStr, f32&gt;, { // No idea what to put here! } I'm still very new to Rust and macros are out of reach for me now.
My crate [Anterofit](https://crates.io/crates/anterofit) was designed for this, but I haven't worked on it in a while. I left it at kind of a crossroads in API design, but what I really want is stable attribute macros to make service trait definitions really clean.
You would like Common Lisp (cond macro ! [http://clhs.lisp.se/Body/m\_cond.htm](http://clhs.lisp.se/Body/m_cond.htm)
I'd suggest adding a screenshot to the README, humans love screenshots!
(side note: if you ever see `match ()` in the wild, it is an abomination that must be purged)
Judging by the downvotes I guess this isn't universal, get I get the same thing. I'm on a desktop (4690K) yet IntelliJ freezes for at least two seconds after practically every keystroke. Doesn't really matter how large the project is. It's totally unusable.
I've already written up several chapters. There's a [rendered] version online if you'd like to have a look. There's also [a tracking issue] on github if you'd like to help out and contribute ideas/code/documentation. [rendered]: https://s3.amazonaws.com/temp.michaelfbryan.com/index.html [a tracking issue]: https://github.com/Michael-F-Bryan/rust-ffi-guide/issues/64
Exact same issue on my Mac 2015 with idea ultimate. The only project open is my toy rust project. It becomes so unresponsive that I can't even type. I tried VS code with official rust plugin, I was surprised how well that behaved. I am addicted to intellij because of day work in Java, so I am looking forward for the rust pluign to stabilise. BTW I am saying 'rust plugin' because same idea version with 6 large java projects on a lower speced windows machine work fine.
The author meant it is uninitialized after the move I think.
My inclination would be to use e.g. `#[cfg_attr(feature = â€œsome_ci_exclusive_featureâ€, test)]` and `#[cfg_attr(not(feature = â€œsome_ci_exclusive_featureâ€), bench)]` so that itâ€™s treated as a benchmark locally and a test on CI, although I really think you should just run the benchmark on CI. Of course, you still have to sort out the function signature if you want to use this, but generics might work fine here.
 &gt; The main annoyance is that you can use $size passed as macro argument to define array sizes but let foo: [u8; Self::SIZE] inside trait is not allowed. This looks weird, but it seems the author is right, so I [filed an issue](https://github.com/rust-lang/rust/issues/52070). 
Right, my bad - the enum solution above will be better. 
&gt; The closure implements Fn because that is the bound on server::new . Thank you, i overlooked this part. Cloning works, even though i am not sure that's optimal.
&gt; actix-web constructs a new App for each worker thread Interesting, thank you. I don't want to create the state in the closure since i want to pass a data storage in the state since i need them to be exchangeable. But maybe this is not the correct approach.
In most cases, wouldn't you just match whatever you were checking? match thing { a =&gt; do_a(), b =&gt; do_b(), c =&gt; do_c() };
Not if `condition_a` and `condition_b` are more complicated than just comparing the same value against multiple constants.
I just started learning rust and one of the things I read was that if a rust code compiles, then you are guaranteed safety from out-of-bounds errors right? How come you had that error? If I'd have to guess, were you using some unsafe block or something?
For now nightly-only (as specialization hasn't yet been stabilized), but I use a [trick](https://llogiq.github.io/2018/03/03/opportune.html) that will eventually be stable in [mutagen](https://github.com/llogiq/mutagen).
Why can't Rust be ported to OS/2? Does clang not run on OS/2? It seems like the least of the hurdles. Sounds like blaming Rust for the fact that Firefox (and no other major browser from the sound of it) can find justification for investing time/energy in supporting OS/2 anymore. Should they also support Windows 3.11, Windows 95, Windows XP? I'm fairly certain that getting Rust working for OS/2 is the least of the problems here.
Rust has arrays, which have a static size known at compile time, and vectors, which are dynamically sized and have a length that can only be known at runtime. Since array length and access are dynamic, Rust has no way of knowing at compile-time whether `vec[x]` is valid or not. So instead it inserts a runtime check -- when you execute `vec[x]`, it checks if `x &lt; vec.len()`, and if it isn't, it `panic!()`s. In that same scenario in C/C++, what would happen is that the access may read from undefined memory, in which case you might falsely believe that your program was working as intended because it didn't crash.
[Wonder no more...](https://play.rust-lang.org/?gist=42ad00a0c592da9952ad7613047542b1&amp;version=stable&amp;mode=release&amp;edition=2015) They actually do produce different assembly. The version with a plain if/else if/else block made the following: xorl %ecx, %ecx // Set the a scratch variable to zero testl %edi, %edi // Test the argument value setne %cl // Set the scratch value to 1 if the argument wasn't equal to zero movl $-1, %eax // Move the value "-1" into the return value cmovnsl %ecx, %eax // Move that scratch value into the return value if the comparison said that the argument was not negative retq While the match w/ guards version gives this instead: testl %edi, %edi // Test the argument value js .LBB6_2 // Jump to the block below if it was negative. setne %al // Set the lowest byte of the return value to 1 if the argument wasn't zero, or 0 if it was. movzbl %al, %eax // Zero out all the other bytes retq .LBB6_2: movl $-1, %eax // Set the return value to -1 retq I'd lean towards the first version being faster since unless the data has long runs of positive or negative values the branch in the second version won't be predicted well.
&gt; It's a security feature where websites ask the browser to make certificate errors non-overridable for the user. HSTS isn't really fundamentally about making certificate errors non-overridable, although that is also a security feature. HSTS prevents connections over http, which would otherwise not require any kind of overriding to begin with. And I don't think it's bad to allow competent users who take appropriate precautions to override certificate errors. Of course, most people probably don't understand what these errors really mean, and even those who should know better (developers who understand what TLS is) aren't always as cautious as they should be. But for something like docs.rs, it seems alright to examine the certificate, see it's invalid because it recently expired, and not for any other reason, and add a temporary override knowing that you're not transmitting sensitive data (accounts, etc.) to their server.
Ah.. that makes sense. Thanks.
Would it be impossible to use mrustc to transpile Rust to C and use that to compile Firefox? Or does the Firefox build system make it unfeasible?
Is there a commercial use case here? I'm just trying to learn about what OS/2 is and why anyone would care about running a modern web browser on an OS that seems to be associated with ATMs and retro computing enthusiasts. If there are any OS/2 users around I'd love to hear about what people are doing with it.
Not the case with me, but it does burn CPU - just no locking up/ blocking lag like that. But once in a while every core on my computer pegs to nearly 100%
I'm not surprised but do wonder how much the output was due to the triviality of the cases and their results. I'll grep for some real examples in our code bases and see how they compare. I expect you're right though, match is not intended for this kind of use and probably will continue to produce flows that predict poorly.
a service can have other services as dependencies and if you stop it from the service manager, it will prompt you to alert that other services will be stop as well. I'll give a try to the command thank you! 
You really should program keyboard support in.
Duuude this amazing, I had no idea you were one of the Actix devs! I really _really_ love what you've done with Flask (it was how I picked up Python). Knowing you're working on Actix, its definitely what I'm using for my next project. Thanks for the great work!
`Box&lt;Option&lt;T&gt;&gt;` or `Option&lt;Box&lt;T&gt;&gt;` for a linked list like structure?
&gt; Sounds like blaming Rust for the fact that Firefox ... can find justification for investing time/energy in supporting OS/2 anymore. Come on. The previous toolset worked for OS/2, so there was no need to "invest time/energy". Rust was added, and that broke it. Rust is not blamed, but the decision to make it an essential part of firefox. About the small number of users: FF has made that mistake before, and look where they are now.
What's the patent story regarding FAT32 today? I remember Microsoft demanding royalties from Linux users who used FAT32 with long file names.
Yeah that might be a possibility. I've shied away from making a feature for CI, because I like the fact that I can have the CI specific things in the CI yaml files. At some point I might have to introduce that, but for now I'm quit happy simply setting an additional env var in the CI test script. 
I was looking for this about two months ago when I was working on the same kind of project. Glad to see it finally done ! Good job :)
From trpl, &gt; In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. I am wondering what language does this? Why is it called "smart pointer" if you have to manage the resource manually?
Thanks! Thatâ€™s true. I will update the documentation link when pushing the new version to crates.io. :)
That's quite a stupid wish. People are used to the current syntax from other languages, it's easy to read, write and understand. 
&gt; FF has made that mistake before, and look where they are now. Care to elaborate? I'm not sure what you are referring to here. And I have another question. I googled a bit to find out what OS/2 is. Apparently it's this really old operating system originally written by IBM that is now maintained by some users, yes? So users of OS/2 apparently don't care about using the newest technology. Why not just stick with the last non-Rust FF then? 
Cheers
Is this w/ release optimizations?
This would enable const generics, and we have a better solution for that coming up
FWIW, I think a well-written RFC for *addition* of the `cond` construct has non-negligible chances of being accepted: * This can be expressed as desugaring, so it has very small cost in terms of cognition/interactions/implementations. * there are studies (no citation, I think I've seen this on graydon's blog?) that show that programmers make most mistakes in conditions and choices and that richer constructs in this area helps. * multiway if definitely comes out in practice a lot. 
You would have to box the closures, and then they can be stored in the same container. (Although lifetimes can be a bitch, since _essentially_ closures are structs that borrow by default). Assuming of course that the closures have the same interface of course :). Dynamic languages box implicitly.
Sounds doable with a macro?
Can be done. Quite apart from ton of work, it would not be Rust tho. 
Afaik the patented one was exfat. Fat32 should be fine.
I can agree on that point. Source: i am human.
I think this is inline with Rust's approach to safety, though. The integer literal is a different thing to the float literal, and explicit is better than implicit
Definitely was immediate. Just stated that the file could not be parsed. With the --verbose option it did specify which dependency was causing the failure so was easy enough to trace considering I knew which crate I had added.
This is wrong characterization of OS/2 users. Users of OS/2 care about using the newest technology with OS/2.
&gt; i want to pass a data storage in the state exchangeable from the outside. But maybe this is not the correct approach for the data layer? I'm not totally sure what you're asking -- but if you're dealing with some sort of data storage you're sharing across threads it likely needs to be synchronized anyways -- cloning an `Arc&lt;Mutex&lt;Foo&gt;&gt;` or `Arc&lt;RwLock&lt;Foo&gt;&gt;` is pretty cheap and still refers to the same underlying Foo. In my example, `recommender_engine` is just a struct with exactly that -- `Arc&lt;RwLock&lt;Recommender&gt;&gt;` #[derive(Clone)] pub struct RecommendationEngine { recommender: Arc&lt;RwLock&lt;Recommender&gt;&gt;, } Plus some convenience methods that take a ReadGuard from the RwLock before delegating to the real method. If you're dealing with an external DB (e.g. using Diesel) you need a connection per thread (or a pool like r2d2, which you'll also share across threads).
&gt; I'm fairly certain that getting Rust working for OS/2 is the least of the problems here. Given that it is a report from a developer of Firefox for OS/2, it is very likely your certainty is mistaken and the developer is right.
[exFAT patent in question](https://patents.google.com/patent/US20090164440A1/en?oq=US2009164440). However, FAT [is patent-encumbered as well](https://en.wikipedia.org/wiki/File_Allocation_Table#Patents) and Microsoft apparently still sued competitors in 2010 for infringement.
The diversity to lose is probably so small that it's essentially zero, heck, you had the whole debacle when they stopped supporting anything else than PulseAudio on Linux. Though I have to say, I love the title of this post, super clever :)
&gt; Rust was added, and that broke it. Rust is not blamed, but the decision to make it an essential part of firefox. You're getting downvoted because you are writing this as if the parts written in Rust were some kind of trivial plugin that is easily toggled on or off. This is not the case; these are core components that are the driving force behind the massive performance improvements in Firefox Quantum: https://wiki.mozilla.org/Quantum
`Option&lt;Box&lt;T&gt;&gt;` because it compiles down to a checked nullable pointer so you don't need to allocate extra space for the enum tag (and you don't need to allocate space for an extra node up front).
done :-) humans, but the game here is not really the point, you may be disappointed
I know. /u/zzzYetc. says it "sounds like blaming rust", but my point was: rust isn't blamed, but the FF leadership. They also abandoned 32 bit support for OSX, but I don't think anybody blames Apple for that.
Beautiful. Perfection. No I see your point, that's pretty bad. I guess this is why we have `if let` for matches.
I did implement such a macro in that playground link :)
I'm not sure I could really even get behind adding more syntax to Rust for such a small benefit. If it turned out that it was really, really worth it then maybe. I guess you might see that RFC somewhere down the line.
But what if the syntax people are used to is wrong?? Besides, as I said, I don't think it's worth *adding* to Rust now anyway.
What is the use-case for OS/2?
I took a (very) brief look. Some things I noticed: * `Cargo.lock` is in the repo, but this crate appears to be a library, so it shouldn't be checked in. * It's MIT-licensed. While this isn't too big of a problem, most of the ecosystem is dual-licensed under Apache-2.0 and MIT (and since there's multiple people involved it might be hard to change this now). * `.travis.yml` doesn't test on a fixed Rust stable version. This is useful in addition to testing on stable and nightly because it ensures that your crate builds on a minimum Rust version. I don't know anything about WebDAV, so I can't really help with issues in the code itself, but the crate appears to be reasonably well documented.
&gt; Sounds like blaming Rust for the fact that Firefox can [no longer] find justification for investing time/energy in supporting OS/2 anymore. Fun fact: Mozilla has never officially supported OS/2. They have accepted patches for it though. It's likely an entirely volunteer effort. The addition of Rust may have made it untenable at this point.
I am not an OS/2 user, but "I want to continue to use what I am accustomed to" seems good enough reason to me. In comparison to Windows XP, the latest OS/2 (named eComStation) release is newer than Windows XP, and unlike Windows XP, the latest OS/2 release is supported by its developers.
So, just to be clear, are you suggesting that FF leadership made a mistake in choosing huge performance and security improvements over niche platform support?
I think one defensible position is that Mozilla should have ported Rust to all platforms with active Firefox port, prior to making Rust required to build Firefox.
Just for your infromation it could be better to have a default function that use the `rand::thread_rng` like you have done but also provide a more specific function that takes any `R: Rng`. This will permit the user to use a seed based random generation.
Thank you for the insightful comments. I have no experience with this yet, thus miy naive questions. My goal is to run a web service where the data comes from a database. In a local version the database is e.g. Sqlite, when the web service runs in the cloud, the database might be a database service like RDS. My inital approach for this was * a struct like `"WebServerState` which provides both session state and the concrete database client * a function like `serve(web_server_starte, port)` The session state probably needs to be thread specific, the database client could probably be shared between threads. I don't know yet.
Say that again after writing an array of 32 float literals to test a posit library. So many `.0`s. What's nicer, `10 * 0.3`, or `10.0 * 0.3`?
It's subjective, it can't be wrong, considering it's subjective. When something is subjective and variations offer no tangible benefits (e.g. if syntax) the best solution is for as many people as possible to agree on a standard.
I can't see how you would write something like `to_complete` but if you want to accept either a CompleteStr or a &amp;str you should be able to make it generic. For example instead of float, float_s, and float_cs it could be one generic float like: #[allow(unused_imports)] pub fn float&lt;T&gt;(input: T) -&gt; IResult&lt;T, f32&gt; where T: Clone + nom::Slice&lt;std::ops::Range&lt;usize&gt;&gt; + nom::Slice&lt;std::ops::RangeFrom&lt;usize&gt;&gt; + nom::Slice&lt;std::ops::RangeTo&lt;usize&gt;&gt; + nom::Offset + nom::InputIter&lt;Item = char, RawItem = char&gt; + nom::AtEof + nom::InputLength + nom::InputTake + nom::ParseTo&lt;f32&gt; + nom::InputTakeAtPosition&lt;Item = char&gt;, { flat_map!(input, call!(recognize_float), parse_to!(f32)) } I figured out the Traits needed by not having the where clause and then adding all the traits the compiler yelled at me about not having :)
So far we have been mainly focused on adding features. If you found any performance problem, please let us know.
No: just that OP blames them, not rust. I am a bit concerned about FF alienating its userbase, though. You could say that OS/2 had it coming, wasn't viable any longer, was a worthwhile sacrifice, etc., but it should be considered carefully. It's got nothing to do with Rust though, as the 32-bit example shows, only with FF's struggle for market share. It would be unfair if rust's lack of OS/2 support was seen as the cause.
AWWW YISSSS LOOK AT THOSE CIRCLES
Honestly, I'm surprised OS/2 is even still in use today, much less actually being developed for. I remember hearing about it being a thing back in the 90s, but even back then I never actually encountered any computer running it IRL. This sounds to me to be pretty much the equivalent of people porting modern software to Windows 3.1 or Amiga Workbench. A niche project only interesting to a very tiny community of hardcore fans.
How come you disable Wayland support?
It is so niche that they raised $12,650 for browser funding campaign. http://articles.os2voice.org/category/voice/17-new-web-browser-for-os2-roadmap-update-4.html
&gt; It seems like all of the memory management strategies can be libraries on top of static memory management like Rust does. I agree in principle. In practice, pluggable GC is a bit challenging though, because the collector must be aware of how to scan the GC-managed memory for references, and possibly how to compact the memory too; and any code that writes to GC'd memory must be consistent with that, as well - it's a bit like having an in-memory database, or something. I think that's why it's not yet something that has found common use in Rust, in contrast with ARC.
There is no definitive answer, but IMO Mozilla has been ignoring its users over and over again, while Google went out of their way to please everyone. Mozilla managed to drive away their end users and upset their technically savvy "hardcore" users. I worked at a company where we had to support FF 3.6 for a very, very long time, because the client wanted FireFox. It wasn't really the client, though, it was their IT department. At one point, Mozilla let them down, Chrome was already super fast, and now the client no longer cares about support for FF, only for Chrome, and Google isn't going to let them down any time soon. There's no way for Mozilla to win them back. MicroSoft's history is similar. So, I think Mozilla should be very careful with 10% or so they've got left. You almost can't win people back unless the other party seriously messes up.
As far as I can tell, neither clang nor rustc can run on or target OS/2 because LLVM itself lacks OS/2 support.
Now this has been done once, couldn't it be merged in with the main body of the rust project allowing others in the future to just do rustup on a haiku system?
I just had a quick skim through the source code and from what I've seen it looks pretty cool! You may want to have a look at the [error handling] chapters from *The Book*. They show you how you can use the `Result` type to deal with errors cleanly, which means you can remove all those `unwrap_or_else(|| process::exit(1))` calls. The [failure] crate makes this pattern even easier to use. You'll also want to be wary of `std::process::exit()` because it'll kill the current process **without** calling any destructors, which may be a problem if you've got open file handles or whatever. I usually [error handling]: https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html [failure]: https://github.com/rust-lang-nursery/failure
Naive question; but Rust has been recently ported to the volunteers-driven HaikuOS. Why can not the same be done for the seemingly commercially supported OS/2?
when fullscreen the image is not resized, though this may have been solved in new versions of winit. also if you need to grab to cursor you can't do it in wayland AFAIK
It can. I think it can even be done by a single person, if sufficiently skilled and motivated. It's just that no such person is known yet.
I see, thanks. I was wondering if there was some peculiarity of OS/2 that would make this process especially cumbersome and/or difficult.
I think that is a typo. It should be just referring to a pointer. AFAIK the definition of a smart pointer includes automatic memory management. It could be referring to using `malloc`, `calloc`, `realloc` and `free` in C though.
I feel your pain. I also pre-ordered at no starch (a loooong time ago) and my company only pre-ordered their copy a few months ago at Amazon and that copy is due to arrive monday while mine is also still waiting to be shipped.
Yes, but the Rust project would need a Haiku system to automatically run tests on, and therefore they'd need somebody familiar with Haiku to maintain it and fix problems. Haiku isn't supported by TravisCI or Appveyor, so it would be a custom thing... Definitely possible, but not free.
Rust's platform-specific handling is mostly handled by LLVM, and LLVM already supports Haiku, so porting Rust was a reasonable amount of work on top. LLVM doesn't support OS/2.
Do you (Mozilla/etc) have a legal agreement with Discord that they will not make money off our data? Discord's own privacy policy essentially states they can do whatever they want with it. The business may also be bought by another company, at which point the few limitations in their privacy policy become essentially irrelevant. What stops Discord from suddenly changing their policy one day and deciding they need to make more money?
&gt;Mozilla should have ported Rust to all platforms with active Firefox port They did. Mozilla have never officially supported Firefox for OS/2. That has always been an unofficial, volunteer-driven port.
Dependency injection at least keeps your spagetti in bowls rather than strewing it all over the floor. Still not ideal, but occasionally something demands the spaghetti bowl. 
It would only need this if Haiku were a tier-1 platform. On tier-2 they just guarantee that it builds, and on tier-3 they keep support in the codebase but without an CI, so it's YMMV as to whether any particular build works. In fact, it looks like Haiku already is a [tier-3 platform](https://forge.rust-lang.org/platform-support.html), though only with support for building std and not all of rustc. To get rustup to be able to work, you'd need to do the work to make it a tier-2 platform, which is basically just automating the setup of the cross compilation infrastructure so that it could be cross compiled from one of the existing build machines, and being willing to help maintain that infrastructure in case it breaks. Making it a tier-1 platform is a much bigger commitment, as you actually need a target system to run tests on, and all changes would be gated on tests passing.
This looks like a library, not like an application or at least cdylib. Why does debian package rust libraries?
Hi! First off, thank you very much! :) Second, you are absolutely right, and I'm trying to deepen my knowledge of Results in order to do some nice error handling. Also, yeah, exit doesn't seem right here. What else can I do in order to stop the program execution right there is return I guess with an Error Result, right? Also, also it seems like your comment is cut off prematurely? Also, also, ALSO thank you for pointing me into the direction of failure crate!
See /u/zzzzYUPYUPphlumph 's post in this thread - the issue is with implicit casting can create loss of precision; it's one of those nasty side effects that Rust is specifically trying to avoid. So yes, you could argue it's a little more syntactically nicer, but that is far outweighed by correctness issues.
So that applications can be packaged. Debian policy is that all build time dependencies of Debian package need to be packaged. This means Debian packaging can climb dependency chain only one step at a time. This just started, so that's why bytecount is first. bytecount has no required dependency.
I said "active port", not "active Mozilla port".
Rebuild-the-world gonna happen often however many packages theyâ€™re planning to package.
I don't know why you were downvoted. I upvoted you to try to balance it out.
By the way, Haiku cross compile setup is already in-tree: https://github.com/rust-lang/rust/tree/master/src/ci/docker/disabled/dist-x86_64-haiku
Don't worry. Rust crate packages are new, but rustc/cargo packages have been there for a long time. (They must, because they are build dependencies of Firefox!) Debian rustc/cargo packages do not conflict with rustup setup.
Nice to see this step! Will other crates depending on bytecount be linked to bytecount dynamically? What will happen if two crates pin different explicit versions of bytecount in their cargo.toml? 
LLVM mostly cares about CPU architecture (as far as back-end handling) not so much OS. It doesn't seem like it should be insurmountable to get LLVM/Rust working on OS/2. It's X86 after all. Just sounds like there is insufficient interest in the OS for anyone to bother.
I don't think LLVM supports z/OS as a target.
Well, itâ€™s not like impl and dyn _force_ the compiler to use static and dynamic dispatch, respectively; the implementation strategy can be considered as a technical detail. What they require the compiler to do is to implement specific _semantics_, and those are different between impl and dyn so bringing them together seems nigh impossible.
LLVM can target Z, so it would probably be usable on zLinux with just the usual Rust porting procedure. Supporting z/OS is another story though since it does not have LLVM. There isn't even a C++ compiler with complete C++11 support on z/OS. You would have to cross compile and implement the z/OS executable format.
That effectively outplays the situation the example sketches: yes, you can convince the Rust compiler that you are actually not mutating through the pointer for a while and than you can do this. It's a code sketch for a slide where functions are used to represent operations. Yes, filling them with non-communicated bodies may help you fulfill the letters of the exercise. But thats around... a mile beyond the point?
&gt; Edit: (at least) 7 downvotes? You'll need to frame fundamental criticism in sort of a positive envelope to avoid downvote avalanches.
Ah, I see a use case for [mrustc](https://github.com/thepowersgang/mrustc)! At least if zOS supports enough of the C11/C++11/C++14 features it uses.
Basically for the first the compiler creates a function in the binary for each type that implements said trait. The second the compiler knows it will receive a reference to something that implements the trait, so it doesn't need to know anything about the trait, it just knows it gets a pointer in which you can call the functions specified in the trait.
1. It's all static linking for now. 2. The latest version is packaged as librust-bytecount-dev, old versions are packaged as, for example, librust-bytecount-0.2-dev.
One thing you could do is have two newtypes - `SingleLine(Event)` and `MultiLine(Event)` with separate `Display` implementations.
&gt; Cargo.lock is in the repo, but this crate appears to be a library, so it shouldn't be checked in. This is debatable. If you want to ensure that people can retest with the environment you tested with, checking in `Cargo.lock` makes perfect sense. You can always have a travis run that runs "cargo update" first. &gt; It's MIT-licensed. While this isn't too big of a problem, most of the ecosystem is dual-licensed under Apache-2.0 and MIT (and since there's multiple people involved it might be hard to change this now). I disagree with the necessity to do this. https://github.com/skade/leveldb/issues/18#issuecomment-170520139 
In fact, zLinux port already exists. It's called "S390x Linux" at https://forge.rust-lang.org/platform-support.html.
I have a strong feeling that having a port of Rust is going to be the next big deciding factor on whether alternative OSes or out-of-date but otherwise user-maintained OSes (like PPC MacOS) are going to be seen as 'viable' or not.
I don't know how to solve the Python packaging problem on Linux. lldb requires Python to build. However, AFAIK Linux distros don't necessarily agree on which version of Python one ought to build against. But, building Python as part of building lldb also seems bad, for one thing this build might not have access to system Python packages (due to path issues and also versioning issues). On macOS, though, I think the build can rely on the system Python. At least, that's my hope. Even on macOS the result may be a bit of a pain, depending on whether lldb must be code-signed.
Company I work for, we have a couple web applications built in Rust. Diesel and either Rocket or Actix-web. Rocket is generally great. The code quality is fairly high and everything is well documented. Diesel so far has been a combination of great and frustrating. Great in that it's very flexible and can do just about anything these days. Frustrating in that the kinds of error messages it generates are verbose and hard for people to really comprehend. The error message situation for Diesel \*should\* be improving at some point after certain nightly Rust features stabilize. Actix-web I am still evaluating. Unlike Rocket, I like that it doesn't depend on nightly. I have some concerns about the code quality and it has some unsafe code that can lead to crashing. (Though they have been working on this). Having said that however, they do go about ticking a \*lot\* of boxes in regards to expected middleware and such. 
Another option is to have enum variants wrapping ```Event``` with a single ```Display``` implementation, that matches on the enum to determine behaviour.
Given that z/OS Hardware is not easily available and generally of niche interest, I only see the path of a sponsor supporting the work of porting and further maintaining the LLVM and rustc over to the z/OS. It's a _doable_ thing and there would definitely be people around taking up such a contract. My company (asquera) would be among them.
This is awesome. I'm gonna use this for a rouge like. Thanks for sharing. 
simple matter of programming
It's not quite big enough for that IMO, but having *a* browser on your platform is very important, so Firefox using more Rust is going to increase the importance of getting Rust working on your toy OS.
https://play.rust-lang.org/?gist=262ffec4847664fb03114aa536a4b54e&amp;version=stable&amp;mode=debug&amp;edition=2015 Basically, you need a new type like /u/K900_ suggested. But you can use an enum that wraps any compatible type. That way you can wrap it where you need to display it rather than worrying about it the whole code path.
When doing the napkin math on how many linux bugs Rust might prevent, you need to account for what &amp;#37; of a linux rewrite would need to be unsafe, and it could be a rather large &amp;#37; in the case of an operating system. I don't know if that is on the order of \~5&amp;#37; or \~25&amp;#37; but some attempt to napkin-account for that would be good.
&gt; they'd need somebody familiar with Haiku to maintain it and fix problems. Apple supports [Swift Community-Hosted Continuous Integration](https://github.com/apple/swift-community-hosted-continuous-integration).
Ah, ok, I see the point.
Good idea the "compiler guided" traits approach. I couldn't have figured the content of the function though XD. Need to ramp up my Rust ^^
Targetting WASM (or some other bytecode) may be a partial solution to these kinds of niche platforms.
Just posting this one for consideration. https://www.reddit.com/r/discordapp/comments/8tukek/ripcord_unofficial_native_discord_client_no/
lol, I think you mean "rogue like". I doubt you're trying to make cosmetics with Rust ;P
I don't think I need it but I like it! For me the underscore in the macro name makes it harder to read the error message if I screw up the syntax. So in order to enrage more people I renamed the macro "case". http://play.rust-lang.org/?gist=57d52b592513fae494b72866cd417e49&amp;version=stable&amp;mode=debug&amp;edition=2015 ... now if someone new to Rust reads that he or she might think it's a switch case but I didn't had a better short name right now. Maybe I should keep this macro a secret.
Letâ€™s assume that FF gets more a more oxidized over time. Letâ€™s also assume that the end goal is to have the JS engine in Rust as well. To support WASM youâ€™d still need LLVM + Rust, and now + the JS engine in Rust able to JIT for your platform. LLVM is intended to be the cross platform answer... and it would still be needed. For other user space apps once all the other work is done, WASM might be good, but that would be more for compile-once and run everywhere, like Java.
&gt; Do you (Mozilla/etc) have a legal agreement with Discord that they will not make money off our data? Nobody has any special agreements whatsover. &gt; What stops Discord All of these points are good, but *also* apply to almost anything else. &gt; Finally, will you actually gain more community members than you'll lose? It's hard to predict the future, but that's the belief. We'll see. &gt; And is there an alternative - a self-hosted chat service, a better web-based IRC client (e.g. a fork of The Lounge or similar), whatever - that would appease both sides? There's more than two sides here, and no, I don't believe it's possible to make everyone happy.
That's a race condition, but not a data race. A data race is two accesses to a single memory location, without synchronisation, and at least one of the accesses is a write. Your example has multiple accesses, and they include writes, but the accesses are synchronised (by the mutex), so it isn't a data race.
The term is described here in the book: https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#mutable-references A data race is similar to a race condition and happens when these three behaviors occur: * Two or more pointers access the same data at the same time. * At least one of the pointers is being used to write to the data. * Thereâ€™s no mechanism being used to synchronize access to the data.
I believe, the most detailed description [may be found in the Nomicon](https://doc.rust-lang.org/nightly/nomicon/races.html).
The size of a niche can hardly be measured in donations. Especially enthusiastic niches are very ready to pay surprisingly large sums to such endeavors. It certainly shows they are _active_. 
I'm relatively new to rust myself, but I'll take a crack at it. As I understand it a data race is a more narrowly defined thing than a race condition. A data race happens when one thread tries to access a memory value at the very same time that the value is being modified by another thread. This is undefined behavior in C, anything could happen. There are no guarantees about what value will be read, it could be completely random. Safe rust completely prevents this scenario. Rust does not prevent all race conditions, you could substitute your variable example with a file on the hard drive, or really any externally mutable thing. The point though is that Rust does successfully prevent code that could utterly corrupt the value in memory (or worse!) and that's definitely a win.
Major ones that come to mind: 1) dyn Trait can be done only for traits that are "object-safe". impl Trait doesn't have this limitation. 2) impl Trait is not a specific, actual type like dyn Trait is, so you can't store impl Traits from from different sources in a vector or other collection because the underlying types are different (they aren't "monomorphic"). You can store dyn Traits however. 3) for the same reason, you can't use impl Trait in extern interfaces.
Checking in `Cargo.lock` is recommended by the [Cargo book](https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html). The [FAQ states](https://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries): &gt; If all libraries were to check in their Cargo.lock, then multiple copies of the library would be used, and perhaps even a version conflict. ...which seems bad, but I'm not sure if this is actually correct, because there's no (easy) way to change a `Cargo.lock` of a dependency and the downstream `Cargo.lock` fully specifies all versions of all (transitive) dependencies - I'm not sure if Cargo even cares about upstream lockfiles. Regarding the licensing issues: I guess this is more of a matter of consistency throughout the ecosystem (allowing a user to treat all MIT/Apache2 dependencies in the same way). Of course, crate authors are free to choose whatever license they want - in order to help avoid the "license hell" I've mostly moved to CC-0 by now.
&gt; All of these points are good, but also apply to almost anything else. Given the amount of existing input that Mozilla put into Rust, combined with Mozilla's goals as an organisation, I strongly believe that something hosted by Mozilla would not have the same issues. The primary concern here, honestly, is splitting the community - as it is right now, I can join #rust and find people working on many of the major codebases that I use, and ask for help and advice, and even have some degree of input into them. With Discord, when people refuse to use it - and they have good reason to - we lose that almost-unique feature of the Rust community as group A moves to Discord, group B sticks on IRC, group C tries out Matrix/Mattermost/Zulip/what-have-you, and group D decide not to bother with all this mess any more and retreat to solely communicating through issue trackers, private messaging, and in-person meetings. And, of course, I'll note that until yesterday, the attempt to move the Rust community to Discord appears to have happened in a group that looks more like D than anything else, given that there has been no communication that this was even a possibility that might happen - rather than include the community, we've been left hearing whispers of something that appears to have been decided in private.
&gt; And, of course, I'll note that until yesterday, the attempt to move the Rust community to Discord appears to have happened in a group that looks more like D than anything else, given that there has been no communication that this was even a possibility that might happen - rather than include the community, we've been left hearing whispers of something that appears to have been decided in private. The post talks about numerous previous discussions on this topic.
Looking forward to trying this out. 
No, the post talks about some previous discussions (the link being to one in 2016 - certainly nothing recent) about spawning *additional* places to communicate about individual niches, not shutting down IRC as a primary method of communicating about Rust.
I might be going about this the wrong way, but I've run into a little confusion. I had a quick google and then search of the Rust docs, but either I'm crap at using the right terms or nothing relevant showed up. I know that if I want to print a variable I'd use `println!("{}", some_cool_phrase);`, but how do you go about expanding variables in other functions? I'm trying to generalise a function that opens a specific file (`/path/to/file_1`) to one that opens `/path/to/any_file_here` so that I don't need a separate function for opening different files in that directory. In Python I'd do something like `filename = "file_2"; file = open(f"/path/to/{filename}", "r")` but I'm not sure of how the same is achieved in Rust.
Yes, and this post also says that this is an *additional* place some teams are experimenting with, and no decisions have been made regarding any sort of official change.
The correct spelling of "rogue" on the Internets is r-o-u-g-e. English is a weird language.
The whispers I've been getting are, essentially, that the stewards of the Rust community want nothing to do with IRC any more. The statements from several names that I recognise in this thread and on the Discourse seem to support that. The fact that there has been no official communication regarding this, combined with the Rust core team and a number of working groups moving to Discord, makes this seem all the more likely. It seems likely that this is only intended to be an additional place in the short term.
This *is* the initial communication. Iâ€™m not sure how weâ€™re supposed to discuss this topic before discussing it.
I feel that porting and maintenance of Firefox on a platform is more demanding than for rustc.
This obviously isn't the initial communication, given that I've been hearing for weeks now about the topic of moving Rust communications to Discord, in non-officially-Rust-related spaces. Initially, I googled it and couldn't find anything, so put it down to rumour - and then more and more people had more and more details of what's going on.
&gt; Every platform that dies is a loss to the technical diversity of the Mozilla community, no matter how you choose to put a happy face on it. This seems to be basically arguing "never depend on a language newer/less-widely-supported than C++ in a big open source project." If I can put it that way, it sounds a lot less defensible than when it's specifically about Rust. C and C++ can't be the way to write systems software *forever*.
Yes, as the post mentions, the core team decided to give it a try, and then we mentioned it to the other teams, and now we're mentioning it to the broader community. This is the first mention of it broadly, as we wanted to get some feedback from the teams first before bothering. If all of the teams despised it, there wouldn't be much point in telling everyone, and there is a degree of fatigue here, so making twelve announcements about different chat platforms isn't good.
Making an announcement of "IRC isn't working for any of us at all and we're intending to entirely replace it with something else" in the first place probably would've been a good start, surely?
And don't packages usually do something like librust-bytecount-2-dev to mean the latest 2.x version?
This is a really, really mistaken post, and it says a lot about where you're coming from that you didn't even know what OS/2 was, but speak on it's community as an expert.
no Rust support for ZX Spectrum either, what a shame
PulseAudio is essentially a server atop ALSA, so ALSA continues to be supported on Linux. Also JACK. There are various bridges and compatibility hacks between these things. Linux's audio story is kind of a nightmare, but lack of diversity is definitely not a part of it.
rustc is a hard dependency of Firefox these days, so theyâ€™re at least equivalent.
This should more or less be handled by [specialization](https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md) once it's implemented.
What's the use case? The same code will always compile the same way, so it's not really conditional. The only one I see is basically unimplemented!. To me this just introduces side effects where implementing a trait can break an entirely unrelated trait. 
Personally: I'm a huge fan of nalgebra, so staying in the nalgebra ecosystem has great appeal to me!
Like the answer to your SO question, what you describe _is_ specialization. The next step is to ask, what do you want to achieve with this and why? Perhaps you can just have two separate functions: `fn do_something&lt;T: TraitA&gt;()` and `fn do_other_thing&lt;T&gt;()` and just have the user of the API pick whichever is appropriate? When you compare this last approach with a single function supporting both use cases, what does it _add_ to be able to write it like you show vs just having two separate functions? (Eg. must be able to call the function from within a generic context). You can keep asking _why?_ all the way up the chain and perhaps a design can be discovered that doesn't require specialization.
This is the sort of stuff that the rust developers want to love and endorse https://www.reddit.com/r/discordapp/comments/8tukek/ripcord_unofficial_native_discord_client_no/e1toruy/?context=8&amp;depth=9 &gt;You are not mistaken. We do not support 3rd party clients, and they are not allowed per our ToS/API ToS. 
That is contradictory to what an employee told me personally, but your rhetoric here doesn't help your argument.
I opened an [issue](https://github.com/rust-lang/cargo/issues/5684) hopefully we can improve this case for you!
First of all, I really do appreciate the criticism. Just in case anything I say below comes across as too harsh, you actually took the time to look over my little toy, so that means a lot. That said, the point of your comment is that it *should* be possible for a person to configure it in such a way that they get *deterministic* maps from the machine if they so choose; that is, provide a seed and always get the same series of maps generated. I did consider that when I was looking into random number generation for this project and decided, given that I was writing this for an audience of one (me) that I did not want a means to always generate the same series of maps. I then *decided* to specifically choose to publish under MIT license to GitHub, not just for the attention (small ripples in a noisy ocean), but on the off chance that if someone should find my toy, and find in nearly useful for their purposes, they could feel free to make alterations as they see fit and do with those changes as they please.
Thank you for the suggestion. It's been a long time since I've studied automata (I'd have to look at a calendar and cross-reference with other notes to determine how long). The purpose of the exercise wasn't so much to use automata as it was to port a bit of C code found on the 'net to Rust as an exercise. And while I was at it, to have a nifty little map generator that I might or might not re-purpose to something else. I will certainly keep your Crate in mind when I come back to this project with the intent to use this toy in something bigger.
...and, though I don't remember a URL to cite, the choice of data races was a conscious one after determining that statically preventing all race conditions was unfeasible.
If the `Miles` and `Kilometers` examples above aren't just contrived examples and you're actually doing something involving units, may I suggest using [uom](https://github.com/iliekturtles/uom) (a zero-cost, featureful unit crate)?
I'm sorry if my comment sounds like I made fun of OS/2 or its users. My intend was not to judge, but only to understand the situation! (Please note that English is not my native language, so my words might not reflect what I really wanted to say) I used the term "really old" simply because OS/2 is older than me. Everything in the tech world that's older than me is "really old" in my brain :P And the statement about "not caring about the newest technology" wasn't supposed to judge either. I'm just honestly (and probably naively) wondering about that. Please explain to me why people who care about having the newest version of software would use OS/2! I just don't understand :) 
Am I the only wondering if such a sum invested into LLVM would not be sufficient to create a LLVM backend for OS/2?
This is exactly what the `std::path::Display` struct is all about! It's a field struct and not a newtype, but it's conceptually equivalent -- its only member wraps a `Path` and implements the `std::fmt::Display` trait. [Docs](https://doc.rust-lang.org/std/path/struct.Display.html) for reference here. :)
That's hardly a month work for a senior developer in a mid-range salary position. Yes, it would be a nice sum to encourage an enthusiast, but not commercially viable.
You can use `format!` to construct a string without printing it. 
Given the previous post where [TenFourFox complains about dropping Firefox on OS/2](https://www.reddit.com/r/rust/comments/8w7sd8/another_one_bites_the_rust/), I think that Rust may indeed hinder the continuous usage of Firefox on exotic OSes unless a port is usable. Of course, the main issue for OS/2 is that apparently it is not supported by LLVM; so that's an immediate barrier for Rust adoption.
&gt; What else can I do in order to stop the program execution right there is return I guess with an Error Result, right? Yep. What I'll usually do is have a `main()` function that reads all command-line arguments into some `Args` struct and then it'll invoke an inner `run()` function (typically with a signature along the lines of `fn(&amp;Args) -&gt; Result&lt;(), Error&gt;`). ([playground example](https://play.rust-lang.org/?gist=0f8f165d96fc819ae1ef17b6201ab085&amp;version=stable&amp;mode=debug&amp;edition=2015)) &gt; Also, also it seems like your comment is cut off prematurely? Oops. I believe I was about to say that I do all my business logic in the `run()` function (which will drop everything and clean up when it exits), allowing `main()` to call `std::process::exit()` at the very end if there's an error.
&gt; That's hardly a month work for a senior developer in a mid-range salary position. Maybe, but I have no idea how much work is needed to start with. OS/2 is "just" an OS, aka, it turns on CPU that LLVM already supports which I expect to be the most difficult part here.
Are there plans to add the wasm32-unknown-unknown compile target as well? 
The elixir `cond` seems like it would fit the bill (`if` in erlang ironically) cond do truthy_expression -&gt; some_expression another_truthy_expression -&gt; different_expression true -&gt; catch_all_expression end In BEAM languages, it scans through each guard until it reaches one that evaluates to true, otherwise raises a runtime error. Elixir actually does have standard `if/then/else` and `unless` but they're implemented as macros and are generally not used a lot. Honestly it's kind of weird something like this isn't provided in a language that offers pattern matching.
You find a package and you generalize something or there is a welled defined policy that should be spotted here?
Thanks. My prior "solution" had been \`let full\_filename = "/path/to/".to\_owned() + filename\`, using \`format!\` feels a lot cleaner :D
ZX Spectrum doesn't run on top of protected-mode x86, OS/2 does. (And LLVM porting is mostly about the CPU, not the OS) "no Rust support for DPMI (protected-mode DOS) either, what a shame" would be a more apples-to-apples comparison. (And a sentiment I'd share. I have to make do with Free Pascal for maximally type-safe hobby efforts.)
Hmm, there seems to be only source code in there, but the package is available for different architectures?!
Nice trick!
But can rust technically keep ABI compatibility to match the semver compatibility? If not it will be more tricky. Apps and crates will need to be packaged with different versions than upstream so you don't end up with 25 different versions of bytecount in the debian repos at the same time.
I wanted that to compile things to AVR while the target is not ready.
&gt; Letâ€™s also assume that the end goal is to have the JS engine in Rust as well. I'm on the JS team -- that is not one of our goals. Although I think on a practical level we'd happily sneak in as much Rust code as we could get away with, because it makes memory ownership so much more explicit, and the JS engine is heavily multi-threaded.
Since z/OS is a proprietary operating system running on proprietary hardware, it would require a significant investment in build infrastructure to provide a fully supported build. Rust's build infrastructure right now mostly relies on CI systems that provide free support for open source projects, as well as paid support by Mozilla, which funds development for Tier-1 and some Tier-2 platforms. It would probably require someone making an investment in build and CI infrastructure for LLVM and Rust, in addition to the development effort to do the initial port and maintain it. So, it would be possible, but it would likely take some investment, it's not likely to be something someone would do just for the fun of it or in their free time. On the other hand, someone recently ported [Mono to AIX and IBM i](http://www.mono-project.com/news/2018/05/29/mono-on-aix-and-ibm-i/), and [it turns out they did it in their free time with a machine they got secondhand for free](https://news.ycombinator.com/item?id=17187500). So it is possible someone could just up and decide to do this. It's possible, but it would take some work by someone interested and with access to z/OS. It's not likely to just happen based on a suggestion, but if you had funding you could find people who could work on it, or you could work on it yourself.
The [Rayon FAQ](https://github.com/rayon-rs/rayon/blob/master/FAQ.md) has an interesting section on this: &gt; **But wait, isn't Rust supposed to free me from this kind of thinking?** &gt; You might think that Rust is supposed to mean that you don't have to think about atomicity at all. In fact, if you avoid interior mutability (Cell and RefCell in a sequential setting, or AtomicUsize, RwLock, Mutex, et al. in parallel code), then this is true: the type system will basically guarantee that you don't have to think about atomicity at all. But often there are times when you WANT threads to interleave in the ways I showed above. &gt; Consider for example when you are conducting a search in parallel, say to find the shortest route. To avoid fruitless search, you might want to keep a cell with the shortest route you've found thus far. This way, when you are searching down some path that's already longer than this shortest route, you can just stop and avoid wasted effort. In sequential land, you might model this "best result" as a shared value like `Rc&lt;Cell&lt;usize&gt;&gt;` (here the `usize` represents the length of best path found so far); in parallel land, you'd use a `Arc&lt;AtomicUsize&gt;`. Now we can make our search function look like: &gt; fn search(path: &amp;Path, cost_so_far: usize, best_cost: &amp;Arc&lt;AtomicUsize&gt;) { if cost_so_far &gt;= best_cost.load(Ordering::SeqCst) { return; } ... best_cost.store(...); } &gt; Now in this case, we really WANT to see results from other threads interjected into our execution!
`cargo build --target `s390x-unknown-linux-gnu` generates machine code for a `z10` CPU, you can choose a different CPU by using `-C target-cpu=...`. LLVM supports many SystemZ linux targets.
While I can see the difficulty in porting rust to OS/2, I would think that it wouldn't be too hard to maintain support for Rust targeting OS X on PowerPC, since Rust and LLVM already has support for newer versions of macOS and PowerPC. I'm wondering why the TenFourFox developers didn't decide to just do the work for getting support for OS X on PowerPC as at least a tier-3 target, instead of deciding to just stop updating the base version.
How does Amethyst measure up to Piston ? I made a very small game, with a circle and line of sight controlled by mouse, but it took quite a bit of time. I find that Piston lacks a bit of documentation, or maybe a complete user guide (not just examples)
&gt;existing companies like Mozilla which pay for Rust development would just do out of the \[BLUE\]. Maybe "BIG BLUE" could take it up?
And then I asked how this feature made it more likely and you didn't answer.
Just a guess but since not all source code supports all architectures it probably makes sense to manage them as separate packages for officially supported architectures.
How can something well older than 20 years still be patent encumbered? Patents are only for 20 years. Did the Patent office allow MS to get new patents on existing technology? If so, that's the problem. 
Which was precisely my point. Rust, by itself, isn't essential for third-party systems like Haiku, but software with it as a hard dependency. Rust is a hard dependency of Firefox, so if you want Firefox, you need Rust.
Yes, that would make sense, and they have already [offered a bounty for AltiVec support in Rust](https://www.bountysource.com/issues/46345753-altivec-vsx-support). If this does become a priority for IBM, they would probably do that, but I think Rust is still niche enough that they're not likely to any time soon.
It's a Debian packaged Rust crate, what assumptions are there to be made?
The problem is that they give equal weights to each elements when considering the diversity but actually itâ€™s unequal for these majorities to be treated as equal.
I thought that it was only necessary to draw attention to situations which prompted Rust's decision to only allow inter-function type inference with closure. (ie. The same reasons Haskellers tend to type-annotate heavily, despite the language not requiring it or why TypeScript is gaining popularity as a dialect of JavaScript which adds an extra compilation step in exchange for nothing except more Rust-like explicit typing.) I actually have prior experience with that example I gave in Python, where I had to deal with junk like `None` or `&lt;object's string representation&gt;` in rendered output or even stored as unwanted garbage in databases. When I tracked down the source of the problem, it turned out that the undesired type had to cross multiple function boundaries before being coerced to a string representation... something which Rust would have caught at compile time.
Ah I see now, I misunderstood you. Yes, agreed :)
There's not only one package: https://qa.debian.org/developer.php?login=pkg-rust-maintainers%40alioth-lists.debian.net
They are just contrived examples, but I'll keep 'uom' in mind if I ever do some physics simulations.
&gt;Types aren't ensuring your system works, there constraining it this seems like a false dilemma, as it's unclear that constraining isn't a form of ensurance. also, type's constrain because types *are* constraints. boundaries in the space of states.
I don't understand why I have been downvoted but whatever... this links is really more appropriate for such an anounce. Or maybe my english is not good enough to understand domething. Here is another I found which is a draft. Did not read yet. https://internals.rust-lang.org/t/debian-rust-packaging-policy-draft/4453 I maintain debian package on a private repository, and I'd like to known the state of the art of packaging rust on debian. 
Might want to wedge a `BufWriter` in between.
I have a feeling this is likely from the Perl influence on Ruby (as quite a bit is), but that doesn't necessarily make you incorrect, as the Perl implementation may itself have been inspired by Lisp.
Also, doesn't write! get a lock on the file-stream? So, repeated write!( fs, ... ) like this: &gt;write!( fs, ... ); &gt; &gt;write!( fs, ... ); &gt; &gt;... Will repeatedly acquire and release the lock on the fs. My understanding though, is that in non-contended environment, the overhead of this is pretty minimal, but, in a contended (multi-threaded with large chance of contention on the fs) you can get some really unpredictable delays and effects. So, if you're doing anything mult-thread, you should definitely consider lower-level or alternative API where you can lock the fs, perform a number of writes, and then release the fs.
I thought Rust only locks stdout not file streams?
A constraint can limit whats being done, and that limitation is a helpful form of communication. But the type is in addition to, not part of, the functionality. I would be happy to see a counter example or a different way of viewing it.
Yes, now that I think about it you might be right. It may only be print/println and eprint/eprintln that have the issue I'm talking about, not write!( fs, ... ).
I see it like extra functionality to certain functions, like optional dependencies, but as you pointed I think another option is to make to separate functions. I think this *conditional compilation* has less practical uses after seeing the asnwers. 
The use case I have seen is like *optional extra futures on a API*, like my method does something on error, if your provided type implements let's say `Debug` I will format my output error including your Type debug format, if not just return a generic error. So if someone is using your API and it's type is implementing `Debug` the compiler will check that, and will include the code that works with `Debug`, in the other case it will include the code that just returns a generic error.
Right. The locking on stdio is a property of `io::{Stdin, Stdout, Stderr}` itself. Namely, a read/write to any of those will internally first acquire a lock, and then execute the actual read/write on `io::{StdinLock, StdoutLock, StderrLock}`. You can avoid the overhead of locking by, e.g., `let x = io::stdout(); let stdout = x.lock();` and then writing to `stdout`.
This is going to be a single threaded executable, and will be run in a virtual + automated environment where even fs contention should be minimal. That said, I'm afraid this still doesn't answer my question above regarding how write!() treats format strings, where we're rendering a potentially deep hierarchy of `Display`\-able objects. Allocation count + overall memory usage is my big concern here, especially if someone tries to really abuse the input spec this executable will be reading + rendering from.
Cool! I didn't know this was going on. I'd like to start a discussion with distro maintainers about what they need from a crate like bytecount. We are currently thinking about moving to stdsimd/coresimd (and this will certainly be the way forward in the long run), but we worry about backwards compatibility.
Most of it looks great, but I am a little sad that mod.rs files are being abandoned I find it a little confusing that 'src/foo.rs' isn't placed inside the directory named 'src/foo'. That will make the code harder to navigate. 
/r/playrust
It's funny to see winapi [packaged](https://packages.debian.org/source/sid/rust-winapi-i686-pc-windows-gnu) for Debian :) Will all transitive dependencies be packaged, even if they are not required for any Debian target?
you can do this in ruby case when condition_a then do_a when condition_b then do_b else do_c end 
At least it will solve [the multi-`mod.rs` tab bar of doom](http://www.seas.upenn.edu/~aburka/tmp/Screen%20Shot%202018-07-05%20at%204.54.29%20PM.png) though. 
Presumably everything will be compiled with the packaged version of rustc, avoiding any ABI issues.
That is a [race condition](https://en.wikipedia.org/wiki/Race_condition#Software): problems that can arise when two or more threads run concurrently and interfere with each other in a way that break the expected behavior of the program. But it is not a [data race](https://docs.oracle.com/cd/E19205-01/820-0619/geojs/index.html): when two or more threads concurrently access the same memory with at least one of them being a write. It is also an atomicity violation: when two or more threads concurrently access memory in such a way that their atomic regions are either non-existent or not broad enough to ensure the expected behavior of the problem. Note that race condition and atomicity violation depends on what the intended semantics of the program is. The data race does not. In fact an atomicity violation is a race condition, but a data race is not necessarily a race condition since it might be a [benign data race](https://docs.oracle.com/cd/E19205-01/820-0619/gecqt/index.html) that does not alter the correct behavior of the program. Also, it is important to mention that, AFAIK, the only of these terms (data race, race condition, atomicity violation) that has a general agreed upon precise definition is data race. The other concepts can have different interpretations, but I think the definitions I gave are the most predominate. 
The code in std::io::Write here: #[stable(feature = "rust1", since = "1.0.0")] fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt; { // Create a shim which translates a Write to a fmt::Write and saves // off I/O errors. instead of discarding them struct Adaptor&lt;'a, T: ?Sized + 'a&gt; { inner: &amp;'a mut T, error: Result&lt;()&gt;, } impl&lt;'a, T: Write + ?Sized&gt; fmt::Write for Adaptor&lt;'a, T&gt; { fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result { match self.inner.write_all(s.as_bytes()) { Ok(()) =&gt; Ok(()), Err(e) =&gt; { self.error = Err(e); Err(fmt::Error) } } } } let mut output = Adaptor { inner: self, error: Ok(()) }; match fmt::write(&amp;mut output, fmt) { Ok(()) =&gt; Ok(()), Err(..) =&gt; { // check if the error came from the underlying `Write` or not if output.error.is_err() { output.error } else { Err(Error::new(ErrorKind::Other, "formatter error")) } } } } Seems to indicate that the formatter would be called at the top-level, which would format everything to an &amp;str which would then be written to the stream with "write\_all" in one fell swoop. This doesn't seem ideal and wasn't what I'd expected to find when I went looking. 
A ridiculous consequence of not having different sets of dependencies for different platforms. Is there anything planned in this regard? Because it's also annoying with crates.
In Fedora, we've been patching non-Linux dependencies out of each \`Cargo.toml\`. That's annoying to do, but hey, at least we don't need \`winapi\`. :)
It is possible, you write it like this: [target.'cfg(windows)'.dependencies] winapi = "0.2.6"
I feel the same instinctively, but giving it a second thought, I hate having multiple files called 'mod.rs' enough that I'm willing to accept a completely different layout.
Good point, but I would personally prefer to solve this problem with better editor plugins. Here is an [issue](https://github.com/Microsoft/vscode/issues/41909) for vscode. They mention a [plugin](https://github.com/joshwcomeau/nice-index) for atom.
What crates will be packaged? And will binaries be packaged as well? 
Doesn't any good IDE/text editor display them like this: `mod.rs - src/folder1 | mod.rs - src/folder2 | ...` ?
I don't think liking new, innovating software and using old, stable operating systems are mutually exclusive, right? Most of us use Windows or Ubuntu, not bleeding edge operating systems like Arch (which I use) or Redox. Stability is valuable. This is just, uh, an extreme of that.
IntelliJ will append parent directories (or the first character for many) to ensure unique tab names, which I like a lot
First I liked the idea, but now that I tried it for a few weeks in some of my projects, I changed my mind. It feels wrong to have "two items on one file system level" for one module. Like `foo.rs` and the folder `foo`. 
I work at Distil's Arlington office and help run the Rust DC meetup. We work in more than just Rust but have several large-ish projects in it. Feel free to DM me if you have any questions.
Mhh yeah. I remember someone mentioning that it still pulls in all that stuff when building but maybe I am wrong.
Yes, but Cargo will still insist on having that dependency present, ["optional, platform-specific, or not"](https://github.com/rust-lang/cargo/issues/4544#issuecomment-332846630).
Interestingly enough the following variant will produce the same assembly as `if` variant: match (condition_a, condition_b) { (true, _) =&gt; 12345, (_, true) =&gt; 67890, _ =&gt; -1234 } Looks like compiler can't properly optimize pattern guards for some reason.
Now I may be a little bit biased as I work with the Amethyst project, but here is my input on that. While piston is good, its overly modular nature hurts it in the sense that it becomes hard to gather all the tools one would need to make a large enough game. Prototyping is also slow as there are little utility provided (unless you spend even more time finding them as a module). Amethyst however aims at being more of an Unity-like experience. It gives you the tools you need and make you think at a higher level. Its ECS also creates an organized environment to work with so that your game's source remains coherent. I think I can claim that prototyping is easier with Amethyst. As soon as you get the ECS concept, which isn't that hard, everything is high level enough so that you can focus on actual game logic. Regarding documentation, Amethyst has been a little bit behind because it grows fast. We rely a lot on examples, but the pong example and its associated tutorial in the book are large enough so that you can understand how to get started, and it acts as a platform for you to go and fly by yourself. Our upcoming website redesign might also help to understand better what Amethyst is in the first place, and I am also working on a video tutorial series on how to make a game with Amethyst.
That assumes you have enough horizontal space to fit tabs that wide, given the number of tabs you have open.
why foo.rs + foo/* instead of foo/foo.rs, basically renaming mod.rs?
The latest Windows is called 10.
Thanks! So any package which depends on bytecount is linked statically to the exact one packaged here, ie it wont be compiled again? Maybe I am having a misunderstanding here, but will this exclude optimizations like LTO? Considering that Rust projects are highly modular, I would expect this to be a possible performance disadvantage compared to e.g. c++ which tends to be more monolithic in my experience. Or am I missing the point of LTO?
C++ started its life with an implementation that compiled to C. I think "compile to C", even with all of its disadvantages, is a sound strategy. This wouldn't have happened if Rust had well supported compile-to-C implementation.
Binaries (like ripgrep) are primary goal of packaging, and crates to be packaged are exactly build dependencies of those binaries. My understanding is that if no popular binary uses, say, actix, actix won't be packaged however popular actix is as a library.
$ lsb\_release -d Description: Debian GNU/Linux unstable (sid) $ /usr/bin/rustc --print target-list | grep wasm wasm32-experimental-emscripten wasm32-unknown-emscripten wasm32-unknown-unknown
Trying to coerce a constant to a type it doesn't fit in should be as compile error, otherwise I see no reason to disallow it.
Super nice! I've actually been creating a [library for variable binding](https://github.com/brendanzab/moniker) using the 'locally nameless' representation, which I'm using on [Pikelet](https://github.com/pikelet-lang/pikelet). But HOAS has it's advantages too though! I do wonder about reference cycles though, when implementing languages that support recursion...
If you are referring to pointer constraints with grabbing the cursor, that is possible with wayland, but the compositors needs to support it.
opimionated lel
Unlike for example C libraries, Debian's Rust library packages do not contain a pre-compiled binary to link against, they just contain the source-code. Therefore, when building a Rust application, all the source (binary and libraries) gets compiled at once with Cargo, and all the usual optimisation is available.
`dyn Trait` provides trait object semantics; the ability to choose the method to call at runtime. `impl Trait` provides a special case of this where you can select the method at compile time. Naturally, the compiler won't be able to automatically pick one of of these, since they both look the same in code. For instance, it would have to know whether you intended to store data homogeneously or heterogeneously in a generic context, which it can't do because the usage patterns would look exactly the same in either case. Look at this: let mut v = Vec&lt;auto Trait&gt;; v.push(MyObj::new()); v[0].my_trait_method(); // Which method do we call? How do we signal that we want a generic `Vec` or a dynamic `Vec`? You have to use something `dyn` or `impl`... All in all, this idea is way too much magic for a language trying to be as explicit and low-level as Rust. In addition to that, different parts of your code would seem to randomly fail to compile because the compiler might take one mistake you make and propagate it back through your code under the assumption that you want to be dynamic rather than generic (or vice versa) and some things are errors under one assumptions and different things are errors under the other. It could be quite a big mess. 
The paper gives an example of safe Rust function miscompiled by LLVM under current semantics. The paper proposes a new semantics which fixes the bug.
Could you elaborate further? It possible that I'm completely off base (and please correct me if I am), but if there are multiple versions of rustc in debian repos, wouldn't that necessarily imply the existence of multiple versions for every packaged crate? (i.e a precompiled version of librust-bytecount-0.2 for rustc 1.23, rustc 1.24, and so on) If so, wouldn't it significantly effect storage requirements (# of compilers * # of versions for each package).
This way (module `foo` is in `foo.rs`, while module `foo::bar` is in `foo/bar.rs`) is the way Haskell's module system works.
They donâ€™t update every six weeks. Debian stable packages rustc 1.14 (they missed 1.15 by two days!)
This was also a relatively recent addition so many people donâ€™t know it exists.
You wang /r/PlayRust, my friend.
That's a good point. I wonder if there's such a thing as a generic LLVM backend targeting C? I think I heard of a computer reimplementation project that didn't even bother with a borrow checker, with the thinking that projects could rely on standard rustc to check their soundness first.
It's much easier to package the source code of winapi than to patch packages to not depend on it and Cargo to not pull it in. Plus, the source code supports all platforms, and we want to allow people to cross-compile. (Debian packages a full mingw cross-compiler toolchain, for instance, and some packages compiled for Windows as part of the Debian installer, which includes a Windows-based loading mechanism.)
That's the plan, yes. There are a handful of specific binaries planned for the first wave of packaging, and all libraries currently being packaged are in the dependency tree of those binaries.
`foo/foo.rs` already defines a module `foo::foo`, though.
There is. Julia Computing, Inc. is working on it: https://github.com/JuliaComputing/llvm-cbe
It's abusive, but you could implement `Display` on your type and reuse the various properties of `std::fmt::Formatter`, basict hijacking the format string language for your own dark purposes. Probably better to just make a wrapper enum for your type though.
Watch out for those rouge angles of satin!
Unfortunately we'd still need LLVM if running the rustc mrustc builds is desired. I don't think mrustc is designed to be used with arbitrary rust programs, it seem more for bootstrapping rustc without a cross compiler. You'd still need to compile LLVM on the OS though, and have a valid LLVM target if you want to be able to compile native binaries with rustc.
[removed]
this phone's battery is at 5% and needs charging! --- ^^I ^^am ^^a ^^bot. ^^I ^^use ^^OCR ^^to ^^detect ^^battery ^^levels. ^^Sometimes ^^I ^^make ^^mistakes. ^^sorry. [^^info](https://np.reddit.com/r/phonebatterylevelbot)
Wrong sub. You want /r/playrust.
Ty sorry 
Rust crates are good enough that they don't need package management. Static link all the things.
There are degrees of "baking it into the language". For example, `@a` could be accomplished as a syntactic sugar for a trait, similar to `?`, paired with something analogous to the work that's been done to stabilize selection of a default allocator for the non-GC stuff Rust already has. Then, you'd still have to initialize a default GC, but, beyond that, you could have `@a` in an ergonomic fashion without baking it uncomfortably deeply into the language. Heck, it could even default to having `@a` backed by `Rc&lt;T&gt;` or `Arc&lt;T&gt;`.
It works both the old and the new ways in the preview. rust:rust2018 lambda$ tree . â”œâ”€â”€ Cargo.lock â”œâ”€â”€ Cargo.toml â””â”€â”€ src â”œâ”€â”€ foo â”œâ”€â”€ foo.rs â””â”€â”€ main.rs 2 directories, 4 files rust:rust2018 lambda$ cat src/main.rs #![feature(rust_2018_preview)] mod foo; fn main() { println!("Hello, world! {}", foo::bar()); } rust:rust2018 lambda$ cargo run Compiling rust2018 v0.1.0 (file:///Users/lambda/tmp/rust2018) Finished dev [unoptimized + debuginfo] target(s) in 2.30s Running `target/debug/rust2018` Hello, world! 42 rust:rust2018 lambda$ mv src/foo.rs src/foo/mod.rs rust:rust2018 lambda$ rm -r target/ rust:rust2018 lambda$ tree . â”œâ”€â”€ Cargo.lock â”œâ”€â”€ Cargo.toml â””â”€â”€ src â”œâ”€â”€ foo â”‚ â””â”€â”€ mod.rs â””â”€â”€ main.rs 2 directories, 4 files rust:rust2018 lambda$ cargo run Compiling rust2018 v0.1.0 (file:///Users/lambda/tmp/rust2018) Finished dev [unoptimized + debuginfo] target(s) in 1.29s Running `target/debug/rust2018` Hello, world! 42 You can also always [specify whatever path you want for a module](https://twitter.com/horse_rust/status/517408273750704128), so if you don't like either convention, feel free to put your files wherever you want.
From what I remember, compiling Rust to C is difficult because C doesn't standardize how to achieve some of the semantics present in Rust IR. (ie. At best, the correctness of the output depends on vendor-specific pragmas and language extensions which may not exist in whatever version of whichever C compiler you want to target.)
It depends on what features the firefox code uses, and if someone wants to make a libstd patch for 1.19 that targets OS/2.
I like how C# handles modules, where it's fully handled by namespace, and the directory structure doesn't matter at all. You get to organize your files however you like, the only thing you need to keep track of is the namespace.
Compiling to vendor-specific C is still vastly superior to, say, porting LLVM to ESP32 architecture.
&gt; I don't understand why I have been downvoted but whatever... Because you insinuated that OP was maybe lazily "generalizing something", without giving any indication that you knew anything about the topic.
The first workaround only fixes limited cases as you noted. If you want two methods each calling a different one you should use the second workaround to work with it. I haven't seen if the second workaround works when you'd want to be able to use both Add traits.
Worth mentioning that it goes beyond just conservatively fixing the bug, it proposes some additional semantics for raw pointers (in this context, meaning pointers constructed by casting from integers, so LLVM knows literally nothing about them) so that they don't completely destroy optimization potential. I'm not so sure about the proposed method, but the overall idea that a raw pointer may only alias allocated memory and that this can be used to exclude aliasing between a pointer and local variables which only become active after the pointer has been created seems valuable.
You're talking about zLinux (i.e. Linux on the S390X architecture), OP is talking about z/OS which is the native mainframe OS.
Unfortunately the IBM compiler for z/OS doesn't support any C++14 AFAIK.
Can Linux distros *please* stop doing this? They've already fucked up Python, Ruby and Node.js by doing this. *Nobody* uses these packages, and *So Many People* get trolled by them. Creating a Bizarro Mirror Land of every language's package repo is horrendous and frustrating. Like, please - either don't package Rust applications, or package apps only and rely on Crate's dependency resolution.
Sounds like a bad design on cargoâ€™s side here.
It's not a `2.x` version though, it's a `0.2.x` version- thus the `0.2`? Once bytecount reaches `1.0` it could potentially have a `2.0` version, then `bytecount-2-dev` would make sense I think.
Nice! I do mentally consider the whole \`if {} else if {} else if {} else\` to be one construct, so having it be more obviously so would be nice. But it does have the double-indent disadvantage for non-trivial bodies, so it's not always better. (BTW, I appreciate the explicit acknowledgement that it's not changing.)
These packages will never be used by `Cargo` or user builds- they are purely for having all dependencies of rust binaries _published as debian packages_ in-tree. I don't believe this is analogous to any dynamic languages (python, ruby, etc.) because none of these packages will be installed on any consumer's machine. They are purely for when building the debian packages written in Rust which depend on them.
I really like the "compile to WASM and use that sandbox" suggestion!
That doesn't fix things like cmd-T though. Multiple `mod.rs` is the most annoying thing for me in Rust.
Completely noob here. But, what's the `crate` keyword is there for? Only to be "interpreted as starting at the current crateâ€™s root"? Can it be replaced by `self` keyword when used in the root of a crate? Or, maybe add a `root` keyword that can be interpreted as "current crateâ€™s root" when used in a crate, and "current application's root" when used in an application etc?
Hmm... That works for me as too, but I have trouble compiling an actual program to wasm on Debian/Sid $ rustc --version rustc 1.26.2 $ cat hello.rs fn main() { println!("Hello, world!"); } $ rustc hello.rs --target wasm32-unknown-unknown error: Could not create LLVM TargetMachine for triple: wasm32- unknown-unknown-wasm: No available targets are compatible with this triple. 
Hmm, `psub` is exactly the instruction needed to implement [`ptr::offset_from`](https://doc.rust-lang.org/std/primitive.pointer.html#method.offset_from), which would be nice.
Thanks a lot. I've just skimmed the paper only but it sounds interesting.
There seems to be a lot of confusion on the technical structure of these packages, so I think some information is useful (as far as I think that I understood it, may be wrong in some details). Once the packages with executables are built (e.g. `ripgrep`, `pulldown-cmark`, `debcargo`â€¦), the users will be able to install them directly, and that's all they will see. If a user runs `apt install ripgrep`, then only the `ripgrep` package will be installed, and it will contain a statically compiled `/usr/bin/rg` executable. This is how that works: * The source packages are named `rust-&lt;package&gt;` by default, for example `rust-bitflags`. * The resulting "binary" packages of library crates don't contain any executable or shared library files, but merely the source code stored at a defined location (`/usr/share/cargo/registry/&lt;package&gt;-&lt;version&gt;`) including a `.cargo-checksum.json` file, just like it is done with vendored packages. * The name of the "binary" package is called `librust-&lt;package&gt;-dev`, and an additional `librust-&lt;package&gt;+&lt;feature&gt;-dev` package gets created for each feature. These feature packages don't actually contain any source code, they will only be used as a build dependency so that the depending packages can ensure that the feature exists. An example of such features would be `librust-lazy-static-dev` as the standard package with `librust-lazy-static+spin-dev` and `librust-lazy-static+spin-no-std-dev` as additional feature packages. * These packages will also contain a `provides` entry for the semver-versioned package name, e.g. `librust-lazy-static-dev` also provides `librust-lazy-static-1-dev`. * Packages for crates which have dependencies, will have build dependencies on these named packages. * If multiple versions of a library crate are required in a dependency tree, the older will be packaged as `rust-&lt;package&gt;-&lt;version&gt;`, with `&lt;version&gt;` being the relevant semver version, e.g. `0.9` or `1`. * Debian source packages for crates with an executable inside will provide an additional binary package containing the statically compiled eecutable file. For example once the `rust-pulldown-cmark` debian source package is finished, it will result in these debian packages being built: * `librust-pulldown-cmark` containing the source code and providing the virtual versioned packages. * `librust-pulldown-cmark+getopts-dev` as a nearly-empty package, providing the `getopts` feature for other crates that depend on `pulldown-cmark` and require it. * `pulldown-cmark` mainly containing the `/usr/bin/pulldown-cmark` executable. * If a user wants to install a binary package, they just do `apt install pulldown-cmark` and it will be installed without any dependencies, as it already contains everything that is required. They will never see any of the `librust-*` packages. * Most of the above "magic" is abstracted by the fantastic [debcargo](https://salsa.debian.org/rust-team/debcargo) tool, invented by /u/joshtriplett and now mainly developed by Ximin Luo, and it processes the information that is stored in the [debcargo-conf](https://salsa.debian.org/rust-team/debcargo-conf) repository. If you want to help packaging, these are the most important places to look at. Of course, there are some details which I left out here, and some which I don't fully understand yet.
Ah, that'd be because it uses system llvm, which presumably doesn't have wasm enabled. I guess there are two bugs to file here: \- that rust is configured to enable targets that llvm doesn't support (I'd argue it's a rust upstream problem, rather than a Debian problem) \- that llvm in Debian doesn't have wasm enabled.
You could have helper functions that return `impl Display`, something like this: use std::fmt::{Display, Formatter, Result as FmtResult}; pub struct Event(i32, i32); struct EventDisplaySingleLine&lt;'a&gt;(&amp;'a Event); struct EventDisplayMultiLine&lt;'a&gt;(&amp;'a Event); impl Event { pub fn display_single_line&lt;'a&gt;(&amp;'a self) -&gt; impl Display + 'a { EventDisplaySingleLine(self) } pub fn display_multi_line&lt;'a&gt;(&amp;'a self) -&gt; impl Display + 'a { EventDisplayMultiLine(self) } } impl&lt;'a&gt; Display for EventDisplaySingleLine&lt;'a&gt; { fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; FmtResult { write!(f, "[{}, {}]", (self.0).0, (self.0).1) } } impl&lt;'a&gt; Display for EventDisplayMultiLine&lt;'a&gt; { fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; FmtResult { write!(f, "[\n {},\n {},\n]", (self.0).0, (self.0).1) } } fn main() { let event = Event(1, 2); println!("single: {}", event.display_single_line()); println!("multi: {}", event.display_multi_line()); } 
It could be extended with something like the tiled-parser crate to store the result in the Tiled-format. That way it would be easy to post process or combine the levels with human designed ones.
Then a couple of helper functions can be used. struct SingleLine&lt;'a&gt;(&amp;'a Event); struct MultiLine&lt;'a&gt;(&amp;'a Event); impl Event { pub fn display_single_line(&amp;self) -&gt; impl Display + '_ { SingleLine(self) } pub fn display_multi_line(&amp;self) -&gt; impl Display + '_ { MultiLine(self) } } And using it will be simply: println!("single: {}", event.display_single_line()); println!("multi: {}", event.display_multi_line()); 
I really like this macro. If you're not interested into putting it into a crate, I'll certainly do it. :)
For the following example code: if let Some(mutably_borrowed) = object.get_mut() { // Do something } else { object.do_something_that_requires_object_to_be_mutable(); } Why doesn't this compile when the programmer can *clearly* see that object is only gonna be mutably borrowed/used once? 
Oh nice, i'll check this out. thank you
I'm not planning on it, so please feel free to! But if you do - as others have said - the name `cond!` or `case!` is probably better than `if_!` :P
Yes, I don't like the macro name, "just" the macro content. But thanks, I'll keep you up-to-date about its release.
One possibly surprising thing that follows from uniform paths is that this works: ``` use std::collections; use collections::HashMap; ``` Why is this a problem?
That's not actually true, `fmt::write_str` (and thus, `Write::write_all`) will be called for each string chunk. [I think it's best to look at the output of this example playground](http://play.rust-lang.org/?gist=72745cf2eeb1fb6178bc575a866f1994&amp;version=stable&amp;mode=debug&amp;edition=2015). u/djs-code So your `write!` should be allocation-free, although to avoid a syscall in each `write_str`, add a `BufWriter` as it was suggested before.
Rusts write^1 is mostly "you get only what you asked for". So if "bar" is a string and file_stream is `File` then then if call`write!(file_stream, "foo {}', bar);` it'll probably just get these syscalls: write(fd, "foo ", 4); write(fd, "bars contents", 13); If say bar is `(42, " bazs")` with `write!(file_stream, "foo {:?}", bar)`. You'll get something like, write(fd, "foo ", ..) write(fd, "(", ..) write(fd, "42", ..) write(fd, ", ", ..) write(fd, "\""); write(fd, " bazs", ..) write(fd, "\""); write(fd, ")", ..); With zero heap allocations. (Exception for `File` all the above is in libcore and `File` doesn't buffer at all (File is just `File(c_int)` or `File(HANDLE)`) But syscalls are expensive. So if you wrap you use `BufWriter&lt;File&gt;` the writes are written to a fixed size buffer before being written to Disk when the buffer is full. (or `Write::flush` is called) 1: In phil oppermans Rust OS tutorial you println working very quickly because there's basically no overhead. https://os.phil-opp.com/
Whoever wrote that should've more prominently linked to UnsafeCell for the idiots who are going to go ahead and do it anyway.
You can do this in Rust as well if you want. #[path = "path/to/foo"] mod foo;
I don't mind a license change, so it's up to /u/MaxwellTheWalrus. Also might want to switch to Gitlab CI, it's superior to Travis IMO.
This paragraph is concerning: &gt; Starting from version 1.20.0+dfsg1-1 the Debian packages of rustc no longer &gt; fail the overall build if &gt; 0 tests fail. Instead, we allow up to 5 tests to &gt; fail. In other words, if you're reading this in a binary package, between 0 and &gt; 5 tests might have failed when building this. &gt; This is due to lack of maintainer time to investigate all failures. Many &gt; previous test failures were reported to upstream and did not receive a timely &gt; response, suggesting the failures were not important. I was then forced to &gt; patch out the test to make the build proceed, so several tests were being &gt; ignored in practise anyway. 
Fully disagree. Nothingâ€™s more annoying than trying to guess where code lives. Iâ€™m generally not a fan of unqualified imports for the same reason.
&gt; ... when the programmer can clearly see ... Because the borrow checker is not as smart as the programmer. [NLL](https://github.com/nikomatsakis/nll-rfc/blob/master/0000-nonlexical-lifetimes.md) should fix this, as far as I understand. 
The Rust content team had created a small boilerplate to quickly get a decent blog with code highlighting up on GitHub pages or any other static site host supporting Jekyll! Let's hope that eases some pain for some of you!
When reading foreign source code I particularily liked that I could just look at the `use`-statements and see where all the items came from. The new rules make that less clear.
Just FYI, the link to https://o0ignition0o.github.io/rust-lang-blog-boilerplate/ seems broken!
I have a very stupid question: ``` #[derive(StructOpt, Debug)] pub enum ScriptSub { #[structopt(name = "script")] Script { #[structopt(short = "v", long = "verbose")] verbose: bool, #[structopt(parse(from_os_str))] script_file: PathBuf, }, } fn my_fct(script: &amp;ScriptSub) { } ``` How do I access to `verbose` and `script_file`?
You need to match the `ScriptSub::Script` variant, just like any other enumeration.
Oh, certainly... I just don't want people to underestimate the difficulty of ensuring Rust's guarantees get preserved in a compile-to-C scenario. Also, vendor-specific C requiring certain minimum compiler versions. Let's be clear about that. (eg. I doubt DJGPP's port of GCC is new enough to have all the requisite language features and it wouldn't surprise me if various more niche embedded targets are in a similar "It works well enough for us. No need to burn effort keeping up with mainline." GCC ports.)
Yeah that's what I meant, I was talking about the general pattern for package naming, not necessarily for bytecount specifically.
How did I not know this... thanks!
Good catch, thanks for pointing it out ! I've just added the steps to fix it, and marked it as a good first PR :) [https://github.com/rust-community/rust-lang-blog-boilerplate/issues/1](https://github.com/rust-community/rust-lang-blog-boilerplate/issues/1)
#[do_not_want]?
ayy das my friend's post, how nice
They don't ship precompiled versions of the crates. The "binary package" for these libraries actually just contains the source, and is a build-depend of the application. So when you are building the application, you fetch the packages that contain the library sources, and build it all with the same compiler.
Well, that's true for stable, but Debian Testing does update a lot more often (though towards the end of the release cycle it gets frozen). These new packages for crates are all only in Debian Testing, and rustc will likely be updated a few times in testing before the release freeze. But it doesn't matter because the library packeges don't contain compiled artifacts; they just contain the source, and everything is compiled at build time for the final application with the same compiler.
Interesting read. Thanks for linking! &gt; Here's an example that curls example.com without any libraries what-so-ever (not an idiomatic use of the http protocol - prefer a library for doing http requests): Does he mean the lack of listening to Content-Length and reusing connections? 
&gt; They've already fucked up Python, Ruby and Node.js by doing this. Nobody uses these packages Sorry to disappoint you. I ship software as a Debian based distro, and I use Debian packaged libraries. This allows me to have one package repository to mirror so I can get consistent builds, and one single snapshot of package versions, rather than dealing with N different ways of managing dependencies per language (setup.py? setup.cfg? requirements.txt? pyproject.toml? virtualenv? virtuelenvwrapper? pipenv? poetry?) time M languages (npm? yarn? gulp? something else I'm not yet hip enough to have heard about yet?). Having each language ecosystem re-invent the packaging wheel is also a significant problem. What if you have inter-language dependencies? You just write up something in your README.md and let your users figure it out? Or just set everything up once in a Docker image and then let your software bit-rot as you never bother to update your dependencies and turn out to be vulnerable to huge numbers of problems?
There is a general procedure: [Rust Packaging](https://wiki.debian.org/Teams/RustPackaging) on the Debian Wiki, and the [Rust Packaging Policy](https://wiki.debian.org/Teams/RustPackaging/Policy). There is a tool that automates this process, [debcargo](https://salsa.debian.org/rust-team/debcargo/). These have been in development for a while. What's new is that it's finally at a point where the resulting packages are being uploaded to Debian Sid (Unstable); which is a great start for getting tools written in Rust like [ripgrep](https://github.com/BurntSushi/ripgrep) packaged on Debian and Ubuntu.
I think there may be a language barrier here, so probably better to give /u/mardiros a bit more benefit of the doubt. I think he was trying to ask about the policy and process for packaging Rust libraries and applications, rather than insinuating that OP was being lazy. He could have been using "you" in the sense of "one"; "does one find a package and look at that as an example for how to package crates on Debian, or is there a more well defined policy", which I've since linked to.
You are looking for /r/playrust
oops, sorry, i'll delete this
The url scheme kinda reminds me of what I've read about Plan9. Not that I've programmed for it :)
Thank you for your answer. That was what I was asking for.
Nice! I seem to recall having seen some discussion of this kind of thing in some of the memory model discussions, good to see that this has found actual problems in LLVM, and that there's a proposed fix. Reading through the paper, I was pretty confused about this example and what followed: &gt; char *p = malloc(4); // (val=0x10, obj=p) &gt; char *q = malloc(4); // (val=0x14, obj=q) &gt; char *r = (char*)((int)p + 5); // (val=0x15, obj=*) &gt; char *s = r +inb 1; // (val=0x16, obj=q) &gt; *s = 0; // OK Until I read the footnote: &gt; Note that while this example is not correct in memory models with data-flow provenance tracking, it is ok in our model. Even though we build a pointer into `q` based on `p`, this might be the result of the compiler propagating an equality that established that `p == q + 4`. Could this have been written with a more clear example in which it was obvious that the compiler could have established that equality, rather than one using `malloc` which I would think the compiler has to assume is a black-box that returns non-aliased pointers which have no provenance relation? It seems like having an example that is clearly incorrect, only to disambiguate in a footnote, is not the best way to present the information.
I believe (and I could me mistaken) that Redox took some inspiration from Plan9.
Thought this deserved some attention since it seemed actix-web took a serious hit in reputation after [this post on the subreddit](https://www.reddit.com/r/rust/comments/8s7gei/unsafe_rust_in_actixweb_other_libraries/). 
I never really understood why Redox OS doesn't use the GPL license. Having a non-copyleft license can allow companies to "proprietarize" the code. 
/r/playrust
Cool! Hope some people take this as an opportunity to make new rust blogs! (I recently [extracted](https://github.com/killercup/jekyll-theme-scribbles) the Jekyll theme of my deterministic.space blog as a repo, too, if you're more into that kind of style.)
Nice to see. To me this is Rust "unsafe" serving the intended purpose. Focus attention on potential security issues EARLY before they blow-up 10 years later (or are quietly exploited for 10 years).
Would it be fair to say that some future version of Faster could leverage SIMDeez to get the best of both worlds (iterators &amp; run-time detection)?
Solid turnaround time - happy to see it.
This is really cool stuff, looks like so much fun to write code for actually haha
Hi everyone, I've got what (I think) is an easy question about threading. I'm trying to figure out the idiomatic way in Rust to process messages from a mpsc receiver "as they happen", as opposed to after the threads have been joined. I'm able to do this by using a thread counter and sentinel values: let (tx, rx) = mpsc::channel(); let mut thread_count = 0; let words = vec!["contrived", "data", "for", "question"]; for word in words { thread_count += 1; let ttx = tx.clone(); thread::spawn(move || { for n in 0..4 { ttx.send(Some(format!("{}:{}", word, n))); std::thread::sleep_ms(250); } ttx.send(None); }); } let mut threads_done = 0; loop { while let Some(msg) = rx.recv().unwrap() { println!("{}", msg); } // Got None, so a thread is done threads_done += 1; if threads_done == thread_count { break; // All threads must be done } } println!("Yay \\o/"); [Complete playground link](https://play.rust-lang.org/?gist=a2f568cd46b4540cb5291b3220e2a8f4&amp;version=nightly&amp;mode=debug&amp;edition=2015) I imagine this is not the right way to do such a thing but haven't been able to find an example of what is. I can't clone the receiver because it's not Sync, so generally how do people do this? Thanks! ðŸ˜Š
You can create a GPL fork at any time. If it were GPL to start, you couldn't go the other way. Also, the Redox BDFL just prefers the non-copyleft. Nothing wrong with that.
Seems like your second sentence answers your first. While many consider proprietary code "evil", many do not, and making your project available for a commercial fork can be seen as "not a bad thing".
I agree! I do think that it makes sense to say "If you use this then please also give back" in a license when it comes to something which so heavily depends on drivers and a big community without it being fragmented. GPL works well for OSes, imho.
I think, but am not sure, that Rust would need some changes to make both iterators and runtime detection possible at the same time. If that becomes possible, or if someone figures out how to do it now, then probably one of us could shut down and help the other. The overall idea is similar and they perform similarly.
The best thing about actix-web is its documentation. It's just excellent. Everything is properly documented, with examples. That's a huge difference compared to Hyper.
nice!
Awesome job, everyone involved!
Be interested to see if this exercise has resulted in any performance compromises. Regardless, props to the author - I thought that flak he caught was in some cases unfairly personal and if it were me I'm sure I would have sulked off for at least a week or two before doing anything about it.
Reading this article really made me reflect on [https://www.tedunangst.com/flak/post/accidentally-nonblocking](https://www.tedunangst.com/flak/post/accidentally-nonblocking) I wonder if even allowing non-blocking sockets makes sense. Just give people events, and they should never have to make a blocking call to read. If it does block, then it's a programming error. I wonder if Redox can lead the way here.
I would also say just how awesome and responsive the author is on gitter. I had a few questions, some pretty noobish and he answered them all regardless. Absolute unit.
Iâ€™ve never hand-written any SIMD, and I do not know about it a lot, so my question might be stupid, butâ€¦ Would the example given in README work with slices whose length is not divisible by 8? What happens in the last iteration of `distance_avx2` in such case? Ie. when doing `AVX2::loadu_ps(&amp;x1[i])` when there are only eg. 3 elements left? Do I think correctly that in `distance_avx2` definition to handle this such situation one should first call `distance::&lt;Avx2&gt;(x1[..trimmed_to_8], y1[..trimmed_to_8], x2[..trimmed_to_8], y2[..trimmed_to_8])` with slices trimmed to multiple of 8, and then merge it with result of `distance::&lt;Sse4&gt;()` on the remainder trimmed to 4, and then again call hand-written simple-loop implementation for the last 1â€“3 elements?
Iâ€™ve never hand-written any SIMD, and I do not know about it a lot, so my question might be stupid, butâ€¦ Would the example given in README work with slices whose length is not divisible by 8? What happens in the last iteration of `distance_avx2` in such case? Ie. when doing `AVX2::loadu_ps(&amp;x1[i])` when there are only eg. 3 elements left? Do I think correctly that in `distance_avx2` definition to handle this such situation one should first call `distance::&lt;Avx2&gt;(x1[..trimmed_to_8], y1[..trimmed_to_8], x2[..trimmed_to_8], y2[..trimmed_to_8])` with slices trimmed to multiple of 8, and then merge it with result of `distance::&lt;Sse4&gt;()` on the remainder trimmed to 4, and then again call hand-written simple-loop implementation for the last 1â€“3 elements?
Iâ€™ve never hand-written any SIMD, and I do not know about it a lot, so my question might be stupid, butâ€¦ Would the example given in README work with slices whose length is not divisible by 8? What happens in the last iteration of `distance_avx2` in such case? Ie. when doing `AVX2::loadu_ps(&amp;x1[i])` when there are only eg. 3 elements left? Do I think correctly that in `distance_avx2` definition to handle this such situation one should first call `distance::&lt;Avx2&gt;(x1[..trimmed_to_8], y1[..trimmed_to_8], x2[..trimmed_to_8], y2[..trimmed_to_8])` with slices trimmed to multiple of 8, and then merge it with result of `distance::&lt;Sse4&gt;()` on the remainder trimmed to 4, and then again call hand-written simple-loop implementation for the last 1â€“3 elements?
Iâ€™ve never hand-written any SIMD, and I do not know about it a lot, so my question might be stupid, butâ€¦ Would the example given in README work with slices whose length is not divisible by 8? What happens in the last iteration of `distance_avx2` in such case? Ie. when doing `AVX2::loadu_ps(&amp;x1[i])` when there are only eg. 3 elements left? Do I think correctly that in `distance_avx2` definition to handle this such situation one should first call `distance::&lt;Avx2&gt;(x1[..trimmed_to_8], y1[..trimmed_to_8], x2[..trimmed_to_8], y2[..trimmed_to_8])` with slices trimmed to multiple of 8, and then merge it with result of `distance::&lt;Sse4&gt;()` on the remainder trimmed to 4, and then again call hand-written simple-loop implementation for the last 1â€“3 elements?
I think they're saying you should be using a library, because you really should.
Iâ€™ve never hand-written any SIMD, and I do not know about it a lot, so my question might be stupid, butâ€¦ Would the example given in README work with slices whose length is not divisible by 8? What happens in the last iteration of `distance_avx2` in such case? Ie. when doing `AVX2::loadu_ps(&amp;x1[i])` when there are only eg. 3 elements left? Do I think correctly that in `distance_avx2` definition to handle this such situation one should first call `distance::&lt;Avx2&gt;(x1[..trimmed_to_8], y1[..trimmed_to_8], x2[..trimmed_to_8], y2[..trimmed_to_8])` with slices trimmed to multiple of 8, and then merge it with result of `distance::&lt;Sse4&gt;()` on the remainder trimmed to 4, and then again call hand-written simple-loop implementation for the last 1â€“3 elements?
There's also a Rust-Godot binding in the works: [https://github.com/GodotNativeTools/godot-rust](https://github.com/GodotNativeTools/godot-rust)
You nailed it. If you want to handle slices whose length is not divisible by 4 and 8 (and possible other numbers) you need to handle the remainder. You can see one approach to handling that here: https://github.com/jackmott/rust-simd-noise/blob/master/src/noise_helpers.rs#L81 I have been thinking about ways to provide a helper function to make this easier in SIMDeez. 
This seems to be what you want: `controllers![UserController&lt;User&gt;]`
ah thank you very much. This was it - and some other things .. this works now: controllers![UserController&lt;User&gt;]; listen( vec![ Box::new( UserController { id: String::from("user-controller"), models: vec![ Model::Custom(User { name: String::from("James"), age: 42 }), Model::Custom(User { name: String::from("Jane"), age: 22 }), ] } ) ] );
It's common for authors to take knowledge for granted. I tried to improve the documentation and examples of hyper in 0.12. Is there any specific areas I can improve them?
`Receiver::recv` returns `Ok(msg)` if there's a message, or `Err(mpsc::RecvError)` if there are no more messages in the queue and there are no senders that could send new ones. You can make use of this - just don't forget to drop original sender after creating worker threads. [Playground](https://play.rust-lang.org/?gist=6948be2266d025da5a8361b66b5e3438&amp;version=nightly&amp;mode=debug&amp;edition=2015)
Aha, Thank you! This is similar to what I came up with while working through it but it blocked forever (because I didn't drop the original `tx`)! 
Indeed. I feel like it was a significant issue, but I think some people were a little harsh about it. Good to see that despite the somewhat heated exchange, there have been significant improvements on this front.
Yeah, that's fair, thanks for the elaboration :)
&gt; Only to be "interpreted as starting at the current crateâ€™s root"? yes.
That's my point, you shouldn't be capable of benefiting from Redox OS code without contributing back. That is was copy-left licenses guarantees. To me it should have been licensed to GPL from the start. But also it's not my project, I'm not a Redox OS developer, so, they can do whatever they want.
For me IT IS "a bad thing". I don't mind running proprietary games let's say, they are not a fundamental part of my computing life. But I cannot tolerate other important components of an OS (like the kernel) to be proprietary. Let's take BSD as an example, It's mostly used on servers only with the exception of proprietary forks (Like the Playstation or mac OS), but this proprietary forks never mention the BSD part. I don't like that.
I totally agree.
&gt;you shouldn't be capable of benefiting from Redox OS code without contributing back. That is not a useful thing to say about something you did not create. I'm a huge fan of the GPL and Stallman, but use/not use of and preference/not preference for a particular license is entirely a creator based decision.
Here are valid arguments against the MIT license (in comparison with GPL): - It will encourage companies to fork rather than contribute - It benefits proprietary software -- which I believe is evil innately -- by giving them a jumping off point (more so than tooling, for example) Here is an invalid argument against the MIT license (in comparison with GPL): - I want to use this software, but I don't want to run proprietary software The answer to that is simple: Don't run proprietary forks. The MIT license doesn't make your software proprietary.
I honestly don't think it was harsh. But Nikolay handled better than I could have. 
I just wish their "getting started" guides wasn't so confusing. I'm basically only now understanding it as I enter hour 10+ because I stopped trying to follow the guides and started reading the documentation. That said, having trolled the documentation a bit, the guides make a lot more sense now...
You may want to post this on internals.rust-lang.org so the right people look at this.
&gt; We have implemented the new semantics in LLVM in order to show that it does not require major changes to the compiler and it also does not degrade the performance of generated code. I wish more papers were this thorough! I've often been disappointed with papers when the results of the author are based on code that is not shared, and I've been unable to reproduce them, to the point of making me doubt the methodology entirely.
At a glance it seems like `Quoter.requote` should be unsafe, since it trusts its caller. Not a big deal though, since it's an internal-only API.
Yeah I'm just curious if the author was thinking of anything specific
I agree. But GPL eliminates proprietary forks ENTIRELY. They cannot exist bu definition.
Okay, but what do you care if there's a proprietary fork somewhere in existence? It doesn't hurt you if you don't use it.
I am primarily a Go programmer, and I haven't written even 1000 lines of Rust in my life (and also 0 lines of Pony or Nim), but I feel like the author kinda missed the point of Rust. Rust, to me, is the `-Wall -Wextra -Werror -pedantic` of programming languages. Is it annoying? Yes. Is it for everyone? No. Does it deliver better results in the end? I feel like the answer is "Yes". Or the one missing the point might as well be me.
i think that it should be assessed how much of the interop infraestructure can be moved into a metaprograming framework ( ctfe and or macro based ) . If that is impractical then the community should still think twice before bloating the language unnecesary features 
I would theoretically like to use a lib like this or faster, but for my own biggest use of simd (a software renderer) almost all the speed to be had is in the specialized simd unpacks that libs like this don't seem to support as well :(
If we could talk about one instance of this "self healing" ability of \`unsafe\` code in Rust in a "release of Rust edition 2018" i would pick this one and show how great this turned out â€“ how the community is checking about them self. And maybe we should also work out in a broader sense how to make this more pleasant for the project owner because as far as i have witnessed it, it was stressful w must do to have an idea of what the code is about in a security sense is \`grep unsafe\` and if the result is unusually hight for this kind of codebase â€“ people can complain with solid reasoning and look at specific ranges of code and find UB. This is a really good thing that just happened! Image this situation in a C based project?! How difficult would this be to achieve the same quality of review? It would require like multiple people with &lt; 10 years of programming experience in C with really digging into the code. All it takes â€“ even for a non Rust coder â€“ is to understand \`grep\`. If we could talk about one instance of this "self healing" ability of \`unsafe\` code in Rust in a "release of Rust edition 2018" i would pick this one and show how great this turned out â€“ how the community is checking about them self. And maybe we should also work out in a broader sense how to make this more pleasant for the project owner because as far as i have witnessed it, it was stressful for Nikolay. He talked about it himself as a "shitstorm" â€“ mostly because of the many people (with also hight reputation) involved. I am mostly happy with the way it turned out, but i think the need to put some though process into a solution on how to make this a "not shitstorm" for the project owner! 
/u/steveklabnik1 Your timeline is probably broken. &gt;* Tue, Jul 3, 2018 at 11:57 PM UTC - Bug reported to secu...@rust-lang.org &gt;* Tue, Jul 3, 2018 at 12:13 PM UTC - Steve responds, confirming the bug Both PM? Still not sure how I feel about jumping the gun on the announcement. I understand your argument, still just rubs me the wrong way.
That's a really good new. Well done to everyone would worked to get here, and especially /u/fafhrd91. Unfortunately this â€œdramaâ€ isn't over yet: confidence in Actix-web was really badly damaged by the sloppy use of `unsafe` and it will be hard to restore: â€if the developers overlooked security and introduced UB in there previous code, why should trust them to be diligent in the future ?â€. Network-facing software are really exposed to exploits which can have disastrous consequences. Running someone else's code in such situation requires trust, and Actix will need do do something to build trust back before people start to use it again. I sincerely hope they will manage to do it though, because the Actix project had a really good start, and is really well documented.
&gt; Both PM? Sigh, I guess the second one would be AM, yeah. I responded 16 minutes after the email came in. Thanks.
This was discussed here previously: https://www.reddit.com/r/rust/comments/8qvcqe/systems_languages_an_experience_report/
Thanks for all of the awesome work you do!
Axtix-web recommends using dedicated sync workers for the database connection and using message passing to communicate to your web-facing App. They have an example in the docs for setting up this system using Diesel https://actix.rs/docs/databases/ 
But `Result::Err` is not exception, may be better use `std::variant&lt;OkType, ErrType&gt;`, like rust_swig does?
For what it's worth, I also posted this in https://www.reddit.com/r/rust/comments/8vfzml/livecoding_an_asynchronous_zookeeper_client/. @OP: I generally always post recordings to /r/rust after I publish them :)
at any rate the goal should be an integral language , that interacts with others of a similar capability to ease porting legacy code ; not that encourages that for the sake of it . 
&gt; if the developers overlooked security and introduced UB in there previous code, why should trust them to be diligent in the future? I think that's pretty obvious and self-explanatory. They were very publicly rebuked, and they obviously took those words to heart. &gt; Actix will need do do something to build trust back before people start to use it again. They already have. I think you're in the very small minority of people who are still holding a grudge and lashing them for the mistakes of their past.
It does hurt me if some company does a proprietary fork from an open-source project and releases it to the public. If they use it internally, that's fine.
&gt; â€if the developers overlooked security and introduced UB in there previous code, why should trust them to be diligent in the future ?â€ You should trust them because they made a targeted effort to greatly reduce unsafe code in just under a month after the issue was raised. To me, that is a very good sign for the project. If there are any other issues, I'm sure they will address those too.
It's been my experience too. My reply to: &gt; If the language has the problem that people are fighting with the language in order to become productive with it, perhaps something is wrong with the language, and not the programmers? Is the problem, in the case of borrow-checking, is squarely on the programmers' side: few programmers have been trained to reason correctly about memory safety, and none that I know of get it right 100% of the time. I've always found the *complaints* about the borrow checker rather perplexing. Coming from a C++ background, I had to learn about the rules by debugging crashed programs with corrupted memory; sometimes so corrupted that the debugger itself would get confused (or crash). By the time I got to Rust, I had already internalized the rules, a necessity to survive the harsh battles with gdb, though I of course slipped up once in a while^1 . As a result I've never fought the borrow checker, and I've been somewhat frightened by the regularity at which it's been pointing slip-ups! I think it's important to realize that Rust does not *invent* anything here, it simply *codifies* the correct practices that any good C or C++ programmers has internalized, for its own sake. Programmers fighting the borrow checker are not fighting Rust the language, they are fighting manual memory management^2 . Yes, it's a tough fight. Be glad that `rustc` lets you run through the gauntlet in easy mode, those of us who learned with `gdb` still have the scars to prove it! ^1 *I have no idea how many of the bugs I coded are still out there, waiting to prey on the next unsuspecting sob...* ^2 *Most of the times; there are (a) short-comings with the current borrow checker and (b) this nagging issue of static checks always being limited and thereby unable to reason their way through some constructs which are otherwise safe.*
I found the examples to be a lot more helpful than the guides, personally.
Also, the code was ALWAYS available. It wasn't hidden that they were using "unsafe". They weren't claiming to be a 100&amp;#37; no "Unsafe" library while doing the opposite. What happened is that during development, they thought that certain things could be only achieved by use of "unsafe" and they thought they were dotting all the i's and crossing all the t's, but, they were mistaken. Once it was pointed out to them that they were creating UB, they took it to heart and addressed the issue. Again, I say that this is a prime example of the "unsafe" keyword doing the job of highlighting "foot-guns" and allowing relatively simple code-review and awareness that a library/application has some likely issues that need addressed without auditing every single line of code.
Ultimately, this situation only enforces the idea that you must audit your dependencies. That's how these issues where found, that's how all future issues will be found.
How does it hurt you? How is the situation worse than if they started from a different proprietary kernel, instead of a non-copyleft one?
What attitude adjustment are you talking about I read the whole article and there was a small section on rust, other then that there was more info on Pony and other languages.
The examples are still really scarce. Hello world/echo servers are not good examples because actual applications need to share states. And I couldn't understand how to it based on the current documentation. See https://github.com/jedisct1/rust-doh/issues/7 -- This is a trivial server using Hyper 0.11, but I couldn't find how to port it to 0.12.
Looks like a good practice issue for the security team?
actix is great again ;)
I think he's referring to the opportunity cost (is that the right word here)? The BSD licensed code may have had more contributions made to it by companies that would not have shared their changes under a more permissive license. At the same time, those companies may also have chosen not to use the software at all, which means there is a 0% chance of them contributing back instead of a lesser on. Personally, I generally prefer MIT over BSD but I also have never had to maintain or manage an open source project anybody cared about.
Pretty much. Just real enough to be real, just minor enough that it reduces the pressure a bit.
A couple things: The main code related comment I have is on line 107 you're cloning your World object every frame which is pretty inefficient and unnecessary. You don't need to actually end up owning the data in the iterator since the data you actually want (the numbers) implement Copy and are therefore silently copied (pass by value). So, you can just use `.iter()` and then dereference the values in the iterator to get their values. let positions: Vec&lt;(f64, f64)&gt; = [self.world](https://self.world) .iter() .map(|(x, y)| (\*x as f64 \* CELL\_SIZE, \*y as f64 \* CELL\_SIZE)) .collect();
Seems like an interesting idea, though this together with the related proposals seems like the C++ standards groups are looking to fundamentally reshape C++ in a major way, in a very short period of time, with a lot of proposals in the air at once. As the [intro to the zero-overhead deterministic exceptions paper says](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0709r1.pdf), many C++ developers work without exceptions, which means they're already working in a fairly non-standard dialect of C++, but these changes would essentially standardize on another dialect of C++ with a different way of handling errors, along with some compatibility glue between the two dialects. That seems like a pretty big change to get done in just a year or two, if this is targeted for C++20. A couple comments on the proposal. Note that I have just done a quick read over this and the zero-overhead deterministic exceptions proposal, and don't have a lot of the background context. It's been many years since I've programmed extensively in C++, though I've been following along the evolution from afar. &gt; We can do even better again for C++ because of C++'s proposed std::error, and specically that we can create a custom errorred status code domain which quacks just like a C++ exception throw. C++ code can therefore receive Rust failures, unmodied, and work with them directly. To see if I can understand this, means having a discriminant that indicates a Rust error, and a value that is a pointer to type that wraps around the Rust type and can provide any information that C++ expects of an error type? Howe would different Rust error types be handled? Would there be a different discriminant in `sdt::error` for each Rust error type that was being mapped, or would the Rust error type be something like `Box&lt;Error&gt;` which indicates a fat pointer to a vtable for implementation of the `Error` trait plus the pointer to the object? &gt; Going the other way, I simply do not know enough about Rust to say if a C++ std::error instance can be somehow mapped into a Rust failure. My guess is that it is not possible: Rust's Result&lt;T, E&gt; assumes a domain-specic E for each localised use case. These are, by denition, incommensurate, thus forcing match mappings between failure types at boundaries where multiple domain-specic potential failures meet, something which in the C++ standard library we have gone out of our away to avoid as it is information lossy. As long as you could express the `std::error` type in Rust with bindings to the implementation, then you can have any type you want in the `E` of `Result&lt;T, E&gt;`. You should be able to return `Result&lt;T, cxx::std::error&gt;`, like you show in your mappings table below. It seems like this would be the natural thing to do by default. If users want to add extra context information to that error or extract information from it, they can do that with an `impl From&lt;cxx::std::error&gt; for MyError` that extracts and wraps the underlying error however they want. One candidate for a built-in implementation would be [`std::io::Error`](https://doc.rust-lang.org/std/io/struct.Error.html) in Rust, which is probably the closest match to the `cxx::std::error` proposal, as it consists of a discriminant and a pointer-sized value, with variants for the OS error type, one of a high-level [`ErrorKind`](https://doc.rust-lang.org/std/io/enum.ErrorKind.html) enum, or a `Box` (owned pointer equivalent to C++ `std::unique_ptr`) containing a custom error type, which consists of an `ErrorKind` and fat pointer to an `Error` object. The exact best practices for error interoperation between libraries and applications is still a bit up in the air in the Rust world, but there's a lot of flexibility allowing for exploration outside of the standard library, by not specifying a type for the `E` of `Result&lt;T, E&gt;`, but allowing convenient interoperation by providing the `?` syntactic sugar for an early return along with using `From` to convert errors between two types. This means that libraries can provide custom enums with exact errors as simple value types, and users of libraries can either dispatch exactly on all of the enum variants, or they can wrap up errors with extra context information using crates like [error-chain](https://github.com/rust-lang-nursery/error-chain) or [failure](https://github.com/rust-lang-nursery/failure).
I'm not sure if people were even aware of such functionality...
I see they want to keep c++ alive, but this language is dying. C++ had it's time but it's over. It was a great lang gave a huge boost to the industry. But I doubt if it can be reformed such that it can keep up with modern languages. The only great advantage of the proposal is that it can help deprecate the c++. The goal shoud be to let the c family die gracefully while industry selects the next successors and easy the lang switch. (Ex once we had fortran, it was unbeatable in its time, but now there left only some f2c converted c files. Hardly anyone knows how to write fortran codes but no one says, it we a bad lang. It is just simply outdated.)
Pretty sure basically none. It has been completely undocumented for years.
Let me know what you need and I'll add it if possible. Use cases which high level libs don't handle well are exactly what I want to know about and try to address. You can open an issue on the github repo. 
https://github.com/Lokathor/retro-pixel-rs/blob/master/src/u32_ext.rs#L251 So, what we're doing here is taking an array of u32 data, treating it as an RGBA color with 8 bits per channel. The catch is that the operations for R, G, and B are very different from A, so we take in 4/8 lanes of pixels with 4 channels each, and basically transpose that data around into 4/8 lanes of all the same channel for each of R, G, B, and A. Then we process each channel, and reverse transpose the results back into pixels at the end. Line 251 is the sse2 version, there's also an avx2 version elsewhere in the file, and other supporting stuff, if you want to look around.
I don't think so. I read that as "please don't do it this way".
Same article with a different URI was [already discussed about a month ago](https://www.reddit.com/r/rust/comments/8qvcqe/systems_languages_an_experience_report/). I thought that [while the author's way of presenting it could use some work, there were some reasonable complaints](https://www.reddit.com/r/rust/comments/8qvcqe/systems_languages_an_experience_report/e0ndzdv/), around the ergonomics of working with reference-counted pointers.
I think some of the issue comes up in the cases in which there are annoying issues that you hit that really don't have to be if the compiler were a little smarter. For instance, we have a whole rewrite of the borrow checker in progress for this reason; there are plenty of perfectly valid programs the current borrow checker doesn't allow, as well as a few invalid programs that it does. Right now, you have to hit an error, then find some workaround that might even serve to make your code less readable, and if you're feeling frustrated by that, reading that you just need to adjust your mental model might make you feel like there's a problem with the language and not you. I feel the same way as you in most cases; I think that the extra safety provided by Rust is worth some of these occasional inconveniences, but different people have different thresholds for that, so it would at least be good to let people know that the inconveniences are being worked on, and there will be fewer in the future.
I'm excited about this possibility! Small extensions to the C ABI for this kind of stuff would be great to have. Some feedback: &gt; The Rust failure monad, `Result&lt;T, E&gt;`, is not marked with `#[repr(C)]`, and thus cannot currently be legally used by C functions. I'd probably steer clear of the term "monad" throughout the paper- `Result` isn't, on its own, a monad, and Rust doesn't even support the necessary type system features to define a monad anyway. Not to mention the term is fairly opaque to many people. `Result` is nearly the same thing as `std::expected`, so maybe just use the same terminology here as you do there? Or if you want something more Rust-specific you could call it an `enum`, sum type, etc. &gt; How C interoperating with Rust code which returns an Result&lt;T, E&gt; would work [i.e. `#[repr(C_Either)]`] The calling convention part of the Rust ABI (and AFAIK this applies to C++ too!) doesn't tend to show up at the language level. The `#[repr(C)]` attribute is instead about memory layout- struct field order/alignment/padding. How a type gets passed and returned is a fairly orthogonal question, decided by the platform ABI. (One exception is `#[repr(transparent)]`, which specifies that a struct type with a single field follows the same calling convention as that field's type.) Thus, as `_Expected(T, E)` is a metatype anyway, this could be handled without any source-level changes at all: simply specify that a `Result&lt;T, E&gt;` return type on an `extern "C"` function uses `_Expected(T, E)`. There is even precedent for this in `Option&lt;T&gt;`, which does not have any `repr` attribute at all, but for cases like `Option&lt;&amp;T&gt;` is specified to be represented as a single nullable pointer, including for FFI. &gt; How C++ interoperating with Rust code which returns an Result&lt;T, E&gt; would work [i.e. `extern "C++"` that converts arbitrary Rust `Result&lt;T, E&gt;` to `_Expected(T, std::error)`] I don't think we need an `extern "C++" to make the error conversion work. (It would be useful for platforms where the C and C++ calling conventions differ, but that's an orthogonal question.) It is idiomatic in Rust for various error types to implement the `From&lt;OtherError&gt;` trait for `OtherError`s that they can meaningfully represent, because the `?` operator will automatically perform those conversions. So `cxx::std::error` could implement e.g. `From&lt;std::io::Error&gt;`, and you would write `rustfunc` like this: ```rust // I use `extern "C"` here because there's no particular need for a C++-specific calling convention, but you could use either. extern "C" fn rustfunc(a: i32) -&gt; Result&lt;i32, cxx::std::error&gt; { match a { 0 =&gt; Err(libc::ERANGE.into()), // explicitly convert libc::ERANGE; could also write `Err(libc::ERANGE)?` or whatever idiom we end up with _ =&gt; Ok(1024 / a), } } ``` &gt; `extern double func(int) noexcept; extern "C++" fn _Z4funci(i32);` There's a typo in your table here- you left out the `-&gt; f64` on the Rust side. :)
C and C++ will not be going away for a long time. There are very few mainstream systems projects that are not written in C or C++. The Linux kernel and most of the GNU userland, Gnome, Qt, xnu (the macOS/iOS kernel), all of the BSDs, the NT kernel, most major webservers, most major web browsers, GCC, Clang/LLVM. Heck, even newer OSes like Fuchsia are being written in C++. There is also still Fortran code that is [pretty widely used](https://qa.debian.org/popcon.php?package=lapack) and [actively maintained](https://github.com/Reference-LAPACK/lapack/commit/b8865c18cf44cfce51ee59f192132b19e03c756b), so even that analogy is not really accurate. I'm a big fan of Rust, and glad to be seeing more written in Rust over time, but C++ is still growing as well and it makes a lot of sense to try and work on more interoperability so that both of them can grow and develop without being entirely mutually exclusive.
&gt; It would seem that actually having this as a generic type with a defined discriminant and payload, with a suggestion for an optimized calling convention, would be maybe a bit more useful for interoperability as there may be cases in which you want to be able to embed such a value in a structure and refer to it. On the other hand, Rust's enum optimizations are still in flux, as we find more ways to squish things around. Restricting the use cases of `_Expected` to ABI and leaving the in-memory (as opposed to in-registers) representation flexible is probably a good call.
Yeah, that's fair, I can see some value of it, was just wondering what the rationale was.
I offered that as my first option for valid reasons but they didn't accept or agree with it. I think they're just complaining.
I think you're looking for /r/playrust.
While I'm happy the count went down, there are still too many uses of `unsafe` in the code for me to feel good about it: First, the number 15 seems to come from the Github search function. If you open any of the found results, you can often find 3 - 4 uses of `unsafe` within them respectively. Also, these uses are sometimes large blocks such as this one: unsafe { if let Some(ref next2) = self.next { let n: &amp;mut Node&lt;()&gt; = &amp;mut *(next2.as_ref().unwrap() as *const _ as *mut _); n.prev = Some(next as *const _ as *mut _); } let slf: &amp;mut Node&lt;T&gt; = &amp;mut *(self as *const _ as *mut _); slf.next = Some(next as *const _ as *mut _); let next: &amp;mut Node&lt;T&gt; = &amp;mut *(next as *const _ as *mut _); next.prev = Some(slf as *const _ as *mut _); } Or [src/ws/mask.rs](https://github.com/actix/actix-web/blob/2a25caf2c5d8786bfcf4b2b5ddb47bb3d6c3abda/src/ws/mask.rs), which has a whopping 59 lines in one `unsafe` block of pointer magic. Third, the tracking issue has been closed, which makes me fear the remaining uses of unsafe won't be addressed.
I believe the Rust leadership already know of this. I circulated an early draft to them some weeks ago.
In my proposal, any erroneous result would appear as a thrown deterministic C++ exception to C++, and any thrown deterministic C++ exception would appear as an erroneous result to Rust.
&gt; // I use `extern "C"` here because there's no particular need for a C++-specific calling convention You might need `extern "C++"` for proper name mangling. But I suppose this example could work in `extern "C"` if declared as such in both Rust and C++.
Thanks for a concrete example. Does this simple state example of a request counter help? https://github.com/hyperium/hyper/blob/master/examples/state.rs
I think this implicit criticism of Hyper and its documentation is unwarranted. Have you seen the documentation at the [Hyper website](https://hyper.rs/), such as [this step-by-step server example](https://hyper.rs/guides/server/hello-world/), and all the (usually commented) [examples in the repository](https://github.com/hyperium/hyper/tree/master/examples)? On the flip side, actix-web may have a lot of examples, but in my experience they're often hard to follow.
The new documentation for Hyper is great. I really appreciate the effort you put into it.
That's what [bindgen](https://rust-lang-nursery.github.io/rust-bindgen/cpp.html) is for.
The code block you provided here is part of what looks like an implementation of a linked list. The Rust pointer syntax makes it super noisy, but there doesn't seem to be anything crazy happening there. We could rewrite it in pseudocode like this: fn insert&lt;I&gt;(&amp;self, next: &amp;Node&lt;I&gt;) { if self.next.is_some() { (self.next).prev = Some(next); } self.next = Some(next); next.prev = Some(self); } `next` and `prev` are `Option` values, and that's being respected. It _seems_ like `next.next = Some(self.next)` is missing, but that shouldn't lead to any UB, since the `Option`s are being used normally. There isn't any transmutation of the `Option` directly into a value that is assumed to be `Some` or anything like that. Rust makes that `unsafe` code hard to read, but it doesn't seem that scary, it isn't like the other issues that existed in `actix-web` that were actual UB safety issues. This is some discussion of `mask.rs` on this issue: https://github.com/actix/actix-web/issues/365
Did you consider adding a new type implementing the `Simd` trait in a not-vectorized manner? One that would just pass `Simd` traits operations to regular `f32`, `i32`, `f64`, `i64`, etc. arithmetic, and would allow one to just do eg. `distance::&lt;Scalar&gt;()` and get a one-by-one loop implementation from the same generic code as `Avx2` and `Sse4` ones? Would that be problematic?
&gt; if this is targeted for C++20, along with also having to be accepted in C C++ 20 has just one meeting remaining left for it, so all these are for C++ 23 and C 22. None of these are profound changes, in fact we already have Boost C++ Libraries solutions (https://ned14.github.io/outcome/faq/#can-i-use-outcome-to-write-zero-overhead-deterministic-exceptions-as-is-proposed-to-enter-c-23). We're just standardising said library solutions into the language. &gt; Is it important that this not exist as an actual type? Yes, very. An actual type must partake in the C type system. A metatype, which is this proposal, merely describes other types. This specific bit of metatype applies only to values returned from function calls, and nothing else. It's basically a fancy way of standardising use of a CPU flag, or other such discriminant. &gt; To see if I can understand this, this would mean having a discriminant that indicates a Rust error, and a value that is a pointer to a type that wraps around the Rust type and can provide any information that C++ expects of an error type? With the proposed Rust C++ calling convention, Rust would wrap up whatever the `Err()` value is into a `std::error` instance and hand that to C++, where it provides all the querying, semantic comparison and other such functionality as per `std::error`'s APIs. The point to not is that the actual Rust `Err()` value is used directly, and Rust is invoked, as needed, by C++ to perform the querying, semantic mapping, etc. So when I say "works directly with Rust's Err type", I *literally* mean it. &gt; If users want to add extra context information to that error or extract information from it, they can do that with an impl From&lt;cxx::std::error&gt; for MyError that extracts and wraps the underlying error however they want. Oh, for sure. `std::error`, or rather its subclassed implementation, can carry arbitrary payload, incidentally. And absolutely Rust can expose the querying and semantic comparison methods provided by `std::error`. &gt; One candidate for a built-in implementation would be std::io::Error in Rust, which is probably the closest match to the cxx::std::error proposal I suspect you have not read the `std::error` paper in full (http://wg21.link/P1028). `std::error` can represent any arbitrary coding with a payload of `intptr_t`, only one of which is the POSIX `errno` coding. You can also throw value types other than `std::error` in deterministic exceptions, indeed P1028R1 (not written yet, but its reference implementation is up to date: https://ned14.github.io/status-code/) has a whole factory for arbitrary instances of them in `errored_status_code&lt;&gt;`. So, `cxx::std::error` could represent many forms and types of Rust `Err()`, and Rust would probably need to do a match on it to extract the right one.
Word!
Yes, and in fact I have such a thing. There are two problems with it, one is that performance of the scalar version will often be a lot worse than it should be, for instance a SIMD algorithm with a branch in it is just done fundamentally differently, and does extra work. That would get done in the scalar version too. (perhaps not if we got \*really clever\*). Then there are some simd instructions that just have no reasonable translation in scalar form. I might bring it back in, but its a lot of work to keep it in sync with the rest of the instruction sets and I'm not sure many people would ever use it. 
I think C,c++ is used because right now there is no alternative. There are emerging langs but they are too young to be expected. I known most (almost all) OS are written in C. In autoom we are hardly allowed to use anything else and it's still a long way while anything new will be accepted. Ok, The scope of fortran is quite domain specific. Used for large scale scientific calculations but it is not used for general calcs anymore. C, matlab, python replaced it outside that domain. I'm not against interop, I'm against the lot of work to reshape something that is too outdated. C++ evolves so slowly and it has so many traps. They just simply cannot deprecate features (and this far they weren't really willing to) those are too dangerous and too easy to hit. I'd give more space for the newcomers. When you have to give a list of banned language features to the programmes (misra) that they must not use, then something is wrong. But these thing cannot be removed from the language because they are there for too long, and we have compatibility. 
Sorry for being unclear. My point was that there are still larger blocks of `unsafe` in the code. They might be correct now, but each of them will require special care during future development or refactoring in the future as they switch off all memory safety guarantees. Right now these issues in actix receive lots of attention, but we should not forget that actix received 1500 stars and UB before anyone noticed. What structural measures are in place to prevent this from happening again? Avoiding all but the most trivial uses of `unsafe` would give me most confidence. The larger an `unsafe` block is, the more likely it is that a bug will manifest in it in the future. Also, I believe `unsafe` should be encapsulated into the smallest, most easily testable, most reusable unit. 
Yes, thank you, I basically retyped their problem 2 example. 
Rust folk may not also be aware at how much the threat of the upstarts has affected C++ :) Standards meetings are processing 25% more papers that before the upstarts turned up. Standards releases have been moved to a three yearly cadence, up from every eight years. We have been actively lifting the best features from the upstarts, and implementing them even better in C++, which is possible because we have the benefit of hindsight and we can avoid where the early adopters make mistakes. Much is made of Rust's memory safety, but I can testify from experience that if you start a new code base today using C++ 17 idioms and recent C++ tooling throughout, unseen memory corruption simply doesn't occur any more. We put that one to bed years ago. Most people's outdated perceptions of C++ are caused by use of legacy idioms and design patterns. We have fallen a little behind Rust in terms of closeness to the bare metal, but we are intending to simply leapfrog Rust and leave it far behind on that point. You'll see some of that land in C++ 23, and a lot more in C++ 26, particularly in optimisation strength where you'll be able to rewrite the AST during compiles. We fully intend to make C++ the number one choice, bar none, for bare metal applications, and huge effort is currently going into making C++ the sole choice for kernel, embedded and HPC programming. Anyway, we'll see how it goes, and it'll be great to see how you guys respond to the enormous amount of resources being invested recently into C++ by the big multinationals in response to the upstarts. Competition is great!
&gt; I'd probably steer clear of the term "monad" throughout the paper- Result isn't, on its own, a monad, and Rust doesn't even support the necessary type system features to define a monad anyway. Not to mention the term is fairly opaque to many people. I didn't know that. Easy fix. &gt; Result is nearly the same thing as std::expected, so maybe just use the same terminology here as you do there? Actually, it very much is not. There was an active push to avoid Expected being anything like Rust's Result. It sufficiently upset some people that there is a rearguard action to make Expected more like Result. Such is consensus forming. &gt; Thus, as _Expected(T, E) is a metatype anyway, this could be handled without any source-level changes at all: simply specify that a Result&lt;T, E&gt; return type on an extern "C" function uses _Expected(T, E). I kinda hinted at that in my paper. It's very doable, but would require active work by you guys to make it so. And I can see some potential tricky corner cases. &gt; So cxx::std::error could implement e.g. From&lt;std::io::Error&gt;, and you would write rustfunc like this: Oh ok, thanks. &gt; There's a typo in your table here- you left out the -&gt; f64 on the Rust side. :) Was that literally my only mistake? I am very surprised if it was. I haven't written in Rust since the MaidSafe contract back around 2015. I am quite rusty (!). Thanks for the spot, I'll fix it.
Actix is a different crate
Thanks! Looking through the sse2\_do\_pixel\_work it seems like everything there should translate into SIMDeez as is, but I may be missing something. Am i? I do see that you are using aligned stores and loads elsewhere which I haven't put in yet but I can do that easily. 
&gt; There was an active push to avoid Expected being anything like Rust's Result. Oh, in what sense? I was mainly just trying to extend my point about the "monad" terminology. :) &gt; I kinda hinted at that in my paper. It's very doable, but would require active work by you guys to make it so. And I can see some potential tricky corner cases. I'm not sure it would require any *more* active work on our part than a hypothetical `#[repr(C_Either)]`, though. There are a lot of corner cases with `C_Either`, around when the attribute applies- we don't really have "attribute polymorphism." And on the other hand `rustc` would have to handle the ABI regardless of how it's written. Which sort of corner cases do you see with `extern "C" fn f() -&gt; Result&lt;T, E&gt;` being specified as matching the ABI of `_Expected(T, E) f(void)`?
There are plenty of things we can do to increase the visibility of `unsafe` code. People have debated it to death, and the conversation always goes the same way. Someone just needs to step up and do something at this point I think. I have some ideas I'd like to try for my own projects, but I haven't found the time. With that said, at the end of the day, the thing that _really_ matters is the culture around `unsafe`. No matter how many tools we have, folks will always need to be vigilant and folks will always need to demand that `unsafe` is used _correctly_. The nature of UB is that our tools will (probably) always fall short of perfect detection of incorrect use of `unsafe`, so until that's no longer true, humans will continue to need to be vigilant. Making this a part of the culture of our ecosystem is, IMO, the most important structural measure we can take.
&gt; C++ 20 has just one meeting remaining left for it, so all these are for C++ 23 and C 22. Oh, sorry. Not sure where I got the impression they were targeted towards C++20. My mistake. &gt; I suspect you have not read the `std::error` paper in full (http://wg21.link/P1028). Nope, I had not. I had gotten confused between the proposals referenced, so I had read http://wg21.link/P0709, and glanced at http://wg21.link/P0786 but decided it wasn't really all that relevant to understanding this proposal, and thought those were the only really interesting ones to look at for this proposal; I'd missed that http://wg21.link/P1028 is the meat of the `std::error` proposal. Reading that now.
Is there a reason to not use `std::collections::LinkedList` here?
&gt; as they switch off all memory safety guarantees. I'm not sure which way you meant it, but I've seen people get confused sometimes, and maybe it's worth clarifying: unsafe doesn't actually turn off any of the checks the compiler normally does. It only allows additional unsafe operations like pointer dereferences, which are unchecked.
I'm not sure. that's a question for the author, and they seem very accepting of people opening issues on the Actix repo to discuss things.
There's an interesting [intersection between Return-Value Optimization and enums](https://github.com/rust-lang/rust/issues/42047), such as `Result&lt;T, E&gt;`. Suppose you have the following fn: fn callee() -&gt; Result&lt;T, E&gt; It can, in theory, be automatically lowered to: fn callee_abi(ok: &amp;uninit T, err: &amp;uninit E) -&gt; bool This way it is possible to eliminate the apparent copying of the the `ok` value from its supposed enum wrapping and have `callee` *construct* the value directly into its final place instead. All of this would happen behind the scenes of course at the MIR level of code generation. This is an active subject for discussion and an important area of optimization considering how frequently values are wrapped in `Result` and `Option`. 
whereas rust pretty much already has the features\* it needs and a software ecosystem built around them, c++ is still figuring out how to update its language , which is years away from happening in a meaningful way and even then it will be a work in progress . For devs there will be a lot of waiting and or catching up to new features to be even be able to rewrite their code in modern c++, which will still be bloated by dangerous , outdated features , ( its disfunctional type system ? ) and the new ones they injecting into the language . Even as it ( nightly rust ) stands now , it is guranteed to be more elegant than that eventual c++ , but while that langauge is catching up to modern programing standards , we could further colapse features by introdcuing full support for first class types and going zigs way 
Naa, I think of it more as `#[if_you_really_want_this_youll_find_it_through_google]`.
Is there any movement to implement a glsl optimizer using your crate? That seems like something that could be very valuable to the rendering backends written in rust like glium or gfx.
I'll try to explain the lines you expressed uncertainty or misunderstood about: use std::io::prelude::*; // I need this for some reason to use io::stdout().flush().unwrap(); Rust allows anyone to add new functions to anyone else's objects, so, to avoid naming collisions, you have to import the ones you want to use. io::stdout().flush().unwrap(); // I need this so the input appears after "Input: " Actually outputting stuff is a bit heavy, so, for performance reasons, it's pretty normal for programs to buffer output until they've accumulated the whole line and then send it all at once. Flushing stdout tells the program to stop waiting for the end of the line and send it right now. let mut input = String::new(); // Requests input from user... io::stdin().read_line(&amp;mut input) // Honestly I don't really know what this does. .ok() .expect("Couldn't read line"); In JavaScript, you treat strings and their contents as equivalent but, in Rust, you can reuse the memory. The `let mut input = String::new()` line creates an empty string and then the `io::stdin().read_line(&amp;mut input)` requests input from the user and stores it in the empty string you created. let mut rng = thread_rng(); // Creates a... randomness thread IDK dude? There are all sorts of ways to generate random numbers, each with its own advantages and disadvantages. `thread_rng` is the simplest to get started with in Rust and the "thread" part is short for "thread-local" (ie. if you program has multiple threads, each one will get its own random number generator rather than all sharing the same one.) let mut counter = -1; // Counting begins at -1 to add an extra roll. let mut result = 0; let mut result_list:Vec&lt;i32&gt; = Vec::new(); // Makes a blank vector for the result list. let mut rng = thread_rng(); // Creates a... randomness thread IDK dude? loop { counter += 1; if counter &lt; rolls { let current_roll = rng.gen_range(1, sides+1); // stores the current roll result_list.push(current_roll); // appends the roll a list result += current_roll; // also adds the roll to a running total called result } else { break } }; Tip: You can write this much more cleanly like this: let mut result = 0; let mut result_list:Vec&lt;i32&gt; = Vec::new(); // Makes a blank vector for the result list. let mut rng = thread_rng(); // Creates a... randomness thread IDK dude? for counter in 0..rolls { let current_roll = rng.gen_range(1, sides+1); // stores the current roll result_list.push(current_roll); // appends the roll a list result += current_roll; // also adds the roll to a running total called result }; ...or, if you get the hang of functional style, you can compact it even more: let mut rng = thread_rng(); // Creates a... randomness thread IDK dude? let result_list:Vec&lt;i32&gt; = (0..rolls).map(|_| rng.gen_range(1, sides+1)).collect(); let result: i32 = result_list.iter().sum(); // Tally up the total 
Yessss. Thank you. I wasn't sure if I'd be able to get this kind of help with rust. I'm going to be referencing this a lot, I really appreciate it.
\- gnome is being rewritten in rust , fuchsia is being written in many languages , including rust \- the rest of the sotware you mentioned ; compiler backends , web browsers , unix utilitities , web servers , now have rust alternatives 
&gt; Oh, in what sense? I was mainly just trying to extend my point about the "monad" terminology. :) Yeah, your Result type got discussed *a lot* during Expected. A majority felt, strongly, that the mistakes in its design must be avoided in Expected. They won out. A minority felt, strongly, that the mistakes in its design were easily rectifiable, and a better-than-Result ought to be Expected. Everybody agreed on the "obvious" mistakes in your Result. That argument continues at WG21, and as I'm not here to argue about Rust vs C++ (and hence will be ignoring all threads which try to start that), I'm not going to delve into exactly what's wrong with your Result type. I will say that it's serviceable, but often less is more in design, and clean orthogonality is easily lost in a rush to get a thing done. I suspect most of those here with a really deep experience with Result will agree. Anyway moving swiftly onwards ... &gt; Which sort of corner cases do you see with extern "C" fn f() -&gt; Result&lt;T, E&gt; being specified as matching the ABI of _Expected(T, E) f(void)? It's more my spidery sense tingling. I don't know enough about Rust implementation details to say for sure, but I get vague feelings of worry. And those are usually right.
https://github.com/xd009642/tarpaulin/issues/124 Just created this - I think coverage for unsafe would be super cool, and something we can badge and advocate for as clear signal. Agree though that diligence is fundamentally the way to go here - both on the producer and consumer.
None that I know.
No problem. I'm glad I could help.
I'm not sure what you mean here. Unsafe doesn't turn off type checking, yes, but it does disable checks that guarantee memory safety: - You can derefence raw pointers that can be null. - You can trivial cast a value to any other, even if they aren't actually equivalent. - You make multiple mutable aliases to the same pointer. - You can access shared memory without synchronization, easily allowing a thread to read partially written data which is invalid for the type. - You can derefence a pointer offset larger than was allocated (hello heartbleed). - You can then derefence any of these conversions you've done, and if any weren't correct, horrible things happen.
I'm not at all trying to start an argument, just curious. Could you maybe point me to the discussion you're referring to?
It seems that Websocket issue was closed without addressing several of the concerns. They're still there, even if the issue is closed...
\&gt;in the case of borrow-checking, is squarely on the programmers' side: Remember that the borrow checker can reject correct programs that it is unable to prove are correct. That will get better with NLL but it will still be true. So it may be better to say that it is \*mostly\* on the programmers side, rather than squarely or entirely. I think it is fair to consider that gap between the set of all correct programs and the set of programs that rust will accept as a problem, and we should try to shrink that gap as much as possible.
You're looking for /r/playrust
My copy as well! O frabjous day!
I don't disagree. I certainly think that issue is more interesting than the linked list.
&gt; No matter how many tools we have, ... Does ubsan work with Rust? Just curious.
Would anyone hold it against me if, just this once, I posted a questionably constructive comment so I could link to a [Jabberwocky-themed piece of music](https://www.youtube.com/watch?v=TlyrweRsILk) that I believe deserves more attention?
Well, there is a risk that a proprietary fork could take most users, and potentially devs, away from the open source version, but I figure that's only likely if the company manages to buy out the core team, which I doubt would ever happen (at least in this case). I'm not sure that's enough of a reason to use copyleft over non-copyleft though, especially since copyleft doesn't prevent that completely either. A company could still do the old Embrace, Extend, Extinguish and make their own copyleft fork with new features that pulls the userbase to away and then rewrite the software under a proprietary license while abandoning their open fork.
Gnome is not being rewritten in Rust. The idea of using more Rust in Gnome has been discussed, one library, librsvg, has been substantially rewritten in Rust, and there's been a lot of good work on GObject and Gtk bindings for Rust to make it possible to do more work on porting to Rust or writing new apps in Rust. But you know what that porting process involves? More interpretability with C and C++, so the port can be done incrementally rather than by boiling the ocean. Fuchsia does use Rust, but the core kernel, and lowest level drivers and services, are all written in C++, and the UI is generally written in Dart. Large amounts of Firefox is being rewritten in Rust, but that process also relies on better interoperability between Rust and C++. Bingen and cbindgen are major parts of that, and being able to return `Result&lt;T, E&gt;` directly from Rust into C++ without having to do as much manual conversion between types would be a big win.
&gt; The impact is limited due to the plugin functionality being long deprecated and being unusable on all current versions of Rust, as the required library is not shipped to users. I'm a bit confused about why patch releases are necessary. Are you disabling a feature that's already disabled? 
In order to create a plugin, you need to use rustdocâ€™s ast type. But we donâ€™t distribute rustdoc as a library. But what it does is, load up the dynamic library and transmute the types. So you *can* make one, and use it on stable, but itâ€™s so impossible to do nicely and completely undocumented that we deprecated it a year ago and literally nobody commented on the tracking issue.
I see. So to make the "exploit" you would use a super old compiler, but then it could be distributed to newer installations. 
Yeah we're totally on the same page. I think the idea I'm trying to put into words is something like "if your code is failing to compile because of lifetime or ownership errors, putting it in an unsafe block won't make it suddenly compile."
&gt; GLSL transpiler (you can output GLSL from a parsed GLSL AST). Wait, if it's going from GLSL to GLSL, wouldn't that make it a a *cis*piler?
Just the block, no, but it will allow you to easily erase the lifetimes and borrows, and suddenly code compiles. And *that* is very dangerous.
Quite happy (er, as happy as one can be about a CVE, anyway) to see that the security reporting process is functioning as intended. Kudos to whoever's job it is to regularly sift through that inbox that's doubtlessly overflowing with spam. :)
The link is 
[removed]
&gt; Yes, very. An actual type must partake in the C type system. A metatype, which is this proposal, merely describes other types. This specific bit of metatype applies only to values returned from function calls, and nothing else. It's basically a fancy way of standardising use of a CPU flag, or other such discriminant. Sure, but whatâ€™s the advantage of doing it this way? ABIs already treat the way a type is passed in and out of functions by value as an entirely separate concern from its memory layout. So even if Either needs to be treated specially for function return (by using a CPU flag for the discriminant), that shouldnâ€™t interfere with it also being a real type that can be used in other contexts. From a compiler perspective, making Either a real type would probably be easier to implement, not harder. Compilers already have to support a large menagerie of different types; easier to add one more than to implement it as a bunch of special cases, especially in C++ where it would have to interact with the template system, `auto` returns, etc. 
Not sure that would really get you anything for the targets you're thinking of-- while there were concerns with mobile graphics drivers having terrible optimizers 5+ years ago (which motivated Aras's old glsloptimizer project in Mesa), I don't think that's even the case any more. You'd need to define some IR for optimization, since this crate is just parsing to an AST. I started playing with the project because I'm (long term) interested in something like this for Mesa's GLSL compiler infrastructure, which would be a shorter path to an optimizing GLSL-GLSL compiler than building your own stack from scratch .
Thanks so much for the info. This clears it up. 
I don't know about ubsan. But asan, tsan and msan seem to work: https://github.com/japaric/rust-san
Alright, thanks. I suppose you wouldn't happen to be on a computer? I'd like to copy the author's name here to double check with him, but I'm on phone and it ends up just clicking the link to go to his profile. It was something really complicated and I think random even so it's not easy to remember.
Even if I'm a huge fan of Rust, I don't think Rust is the best language for scientific computing, it lacks interactivity just for being a compiled language. Even then there are some crates at "are we learning yet". On the other hand, it would be cool to write a language like Julia in Rust, or just writing a library for another language in Rust.
huh
Itâ€™s me and Alex :) &lt;3
And there's RISC-V fans who are still waiting for a widely available board. :(
I'm very curious. What are the "mistakes in its design" for the Rust Result Type. I haven't heard this complaint before. Can you point out an synopsis about what C++ guys think is wrong with it?
Wouldn't a panic translate to an exception and an err equivocate to std::variant::err or null? Why would an error be exceptional?
Read up on denotational semantics of programming languages. Types define the problem that your program is attempting to solve.
Is it known how Red Hat found it? Reading lots of code?
They didnâ€™t give me that level of detail; I assume itâ€™s something like that. 
You could also just compile it to SPIR-V with glslang and run spirv-opt on it, and then either use SPIR-V directly in 4.5 or compile back again with spirv-cross. Alternatively there is also a bidirectional spirv &lt;-&gt; llvm ir compiler, but I am not sure how usable it is. 
The `rustdoc` manpage mentions the default that is problematic, although it actually says a more outdated `/tmp/rustdoc_ng` path.
Nice I am looking forward to see cheddar. Also if you have any questions about SPIR-V, don't hesitate to ask.
&gt; Result isn't, on its own, a monad, and Rust doesn't even support the necessary type system features to define a monad anyway. Result *is* a monad because it satisfies the monad laws. Just because monads aren't formalized within the rust language doesn't mean they don't exist within it. Two sheep are two sheep because they are sheep and there are two of them, not because someone has made a formal declaration of `TwoSheep` in a `Field`.
Maybe the 'alternative' to C++ that people want is little more than a further evolved C++. Maybe that's why people keep working on C++. Maybe that's why this whole thread exists in the first place.
Is it a sick joke?
&gt; Most people's outdated perceptions of C++ are caused by use of legacy idioms and design patterns. Most of the C++ code I work on day-to-day is legacy code with legacy design patterns. These aren't outdated perceptions of C++. These are perceptions of C++ that exists and is being written *today.* These are *current*, *modern* perceptions. The "outdated" perception is that this should be the status quo and acceptable practice.
You should really look at the sub before you just blindly post in it. I realize there is a game by the same name but come on. 
Got mine recently as well :)
`actix` itself still had a number of unsound `unsafe` usages which got fixed as part of this, though.
You must be new here. People searching for Rust the game end up on this sub frequently. 
You are looking for r/playrust
I think that's how it works. /u/steveklabnik1: do you know if plugins are automatically loaded in rustdoc from the found directory, or will this only happen if a user on the current stable does something to request a plugin and then a malicious actor replaces the file?
I don't think there's any level of searching going on. They just type "Rust" into the subreddit field, completely fail to read the warning that the subreddit is specifically *not* for the game, and hit post.
That was rather pedantic... But sure I know
Very happy to see it too. `unsafe` is not a bug, its a feature: undefined behavior is a bug, and `unsafe` allowed to audit a large code base and fix many bugs pretty quickly. Many people are skeptical about whether Rust programs having less bugs of certain types than C or C++ programs. This has not shown otherwise, but it has shown that at least safe Rust has less bugs than programs that make an unrestricted use of unsafe code, and that unsafe annotations help auditing and fixing certain types of bugs.
[removed]
actix-web is great for this 
A lot of scientific code is written in Fortran, C, and C++, including most of the code that gets executed when you use SciPy, Matlab, Octave, ...
Yeah, what I fail to understand is how you can just post on a subreddit without first taking a look at the posts it has on the front page.
I'm not aware of any multivariate KDE implementations in Rust currently. However, depending on your peformance requirements, resources, and the number of statistical functions you need, there are a few options: 1. Call high-level statistical functions from Rust using the various interfaces to python, R, Julia, etc. The performance and usability of these varies, but you'll have full access to their functionality. 2. Call C/C++ statistical functions for possibly more performant options. 3. Implement the statistical functionality yourself. Rust has some decent linear algebra crates (e.g., nalgebra and ndarray), so it's quite possible to build what you want on top of them.
&gt; You should really look at the sub before you just blindly post in it. That might also fix their grades: &gt; but my grades weren't the best 
Wow. After all the stink that was raised... I'm impressed.
Yes, I was overreacting but I can't stand it when people blindly post everywhere whitout reading a single post or anything. I'm not talking about this specific subreddit but it happens way too often.
I doubt it. Just to mention some: We wanted variadic template. We got something that is really unergobomic, hard to debug, hard to read, write. Take a look at D as a comparison with respect to templates. We wanted move semantic. It s hard to get it correct at first time and implement all operators correctly. That's not a problem. It's hard to get the borrow checker right too. But in rust you get compile error. In c++ many thing just compiles that will just simply self destruct the whole system and goes unnoticed for ages.
&gt; Remember that the borrow checker can reject correct programs that it is unable to prove are correct. Most (all?) of what can be done with NLL can be done without it by structuring the code slightly different (e.g. adding local variables, scopes, etc.). 
His github: - https://github.com/jD91mZM2 His apparently suspended twitter: - http://twitter.com/LEGOlord208 His email - me@krake.one His username on that site: - jD91mZM2
This is not the rust you're looking for.
I've just discovered that `cargo` passes `--cap-lints allow` for upstream crates, which means this is not true actually, and `RUSTFLAGS` can be used to check entire workspace, excluding dependencies.
is it?
&gt; I am not very happy about this shitstorm atm â€” fafhrd91 Ouch. This may or may not be exaggerated, but that someone feels the need to say it should make you think. A *code review*, of all things, should not be able to bring anyone in this situationâ€”especially not in a community that publicly describes itself as welcoming and friendly. Some people said it would be best to not touch any project the actix team members ever worked on, which would effectively bar them from contributing anything. Where was the welcoming community hiding that day?
Huge thank you! Assuming his reddit username is the same one: Pinging /u/jD91mZM2. Can you confirm whether or not you were thinking of anything specific?
Yeah no I wasn't
Thank you!
I definitely agree with you on this: we can trust the developers to listen to security feedback and react quickly is someone reports a security issue. What still concerns me is: what will they do, during the design, the development or the testing process, to pro-actively prevent security issues (and I'm not only talking about memory safety, there are lots of attack vectors on a web-server). Listening to community reports is a good thing, but that's not enough in my opinion. If a project doesn't have a serious security mindset at the design phase, I'm not willing to invest in it before it has really been battle tested and is big enough to be sure that trivial security holes have been found. That' what I have always done when using C projects, but I hopped Rust would bring more confidence. I can understand that not everybody feels the same tough, it's kind of the difference between Linus and Theo de Raadt.
You seem to doubt it, why?
&gt; Its FFI layer cannot directly represent a Result&lt;T, E&gt; to C code, nor vice versa, I thought `Result&lt;NonNull&lt;T&gt;, !&gt;` and similar types (e.g. `Option&lt;NonNull&lt;T&gt;&gt;` worked fine with C FFI ?
Why wouldn't I doubt?
&gt; Yeah, your Result type got discussed a lot during Expected. A majority felt, strongly, that the mistakes in its design must be avoided in Expected. They won out. A minority felt, strongly, that the mistakes in its design were easily rectifiable, and a better-than-Result ought to be Expected. Everybody agreed on the "obvious" mistakes in your Result. That argument continues at WG21, and as I'm not here to argue about Rust vs C++ (and hence will be ignoring all threads which try to start that), I'm not going to delve into exactly what's wrong with your Result type. Could you at least point us to the document that discusses the mistakes in `Result` ?
I'm very confused by this attitude. You create this thread because you're looking for a good web framework, and seemingly immediately disagree with the first incoming answer. Is there something about actix that bothers you? 
It was giving tough love, which is a rarety among any tech community. Everyone is better for this episode.
Do you hire remote workers?
As someone who is at many times ignorant about something that others know more about, I decide whether I trust that they know better than I do and accept their work, take the time to understand way more than I ever wanted to, or move on
you're helping to shape that culture but doing so among the trenches (message forums) won't reach as many as, say, blog posts and conference talks 
&gt; Rust allows anyone to add new functions to anyone else's objects, so, to avoid naming collisions, you have to import the ones you want to use. More specifically this is done via *traits*, so to have a trait's methods you need to have this trait imported somehow. Here, the relevant traits are std::io::Write (so you can flush the output stream) and std::io::BufRead (so you can read lines from the input stream). Which are conveniently both packaged in the "IO Prelude" (as well as a pair of other useful traits). "Prelude" is a concept from Haskell, it basically means "stuff which is imported by default" but here it's used as a convenient bundle of imports you may but will not always need: if you're going to do IO, you can just import de IO prelude and be mostly done with it.
&gt; Remember that the borrow checker can reject correct programs that it is unable to prove are correct. Yes, sure. That's exactly what note (2) is about. However, from experience helping people resolve their issues on StackOverflow, the vast majority of cases (99%?) is the programmer making a mistake. &gt; I think it is fair to consider that gap between the set of all correct programs and the set of programs that rust will accept as a problem, and we should try to shrink that gap as much as possible. I am not sure there is much value in attempting too hard to shrink the gap. If there are easy wins, by all means. If it requires epic contortions and intricate sets of rules, then I'd rather not. Having seemingly innocuous changes inexplicably "break" compilation with no idea why is really annoying. 
Is there an easy way of testing a crate for Redox in travis-CI? I'd like to start supporting Redox in some of my crates.
Right, it's not a question of if your program has types, but what those types are and how and when there checked. I really put in a low amount of thought to my original reply because the OC was even more silly. As someone working in a poor example of a type system I have first hand experience that you it does quite the opposite of encourage good mental models
Heh, I just now noticed your username. Well played.
Note: due to how privacy works, the number of lines in an unsafe block is not a good indication; `unsafe` contaminates the whole module it's invoked in.
&gt; Where was the welcoming community hiding that day? I am afraid there is blame to distribute on both sides: 1. The author's first responses were quite dismissive of the issue, 2. Which prompted harsh comments, including the one you cite which indicates a serious loss of faith/credibility, 3. And things went downhill from there. I am glad that actix is better now that it was, but I am certainly not proud of how the community (including contributors, reporters and general public) behaved here. As a moderator of r/rust, it was a though thread to handle, with comments spanning the whole continuum from helpful/concerned to harsh/dismissive/disrespectful (often times mixed with valid remarks), making it quite difficult to draw a line between okay-ish and not.
It's still early days. We need first of all to get a proper NumRs - that's why I have been contributing to ndarray even if my interests lie in the machine learning area. We need to double down on getting the basic bricks right.
While I would be interested in the fastest JSON parser, it'd be a deal breaker if it used threads behind my back. I don't think I am unique in this requirement, so I'd encourage you to make sure that the ability to parse in parallel is strictly optional.
Those benchmarks results without units though... I don't even know who is fast and who is slow. Is that "time to parse an x", or "x parsed per unit of time" ?
Congrats, and thanks to everyone for their hard work on what's been done. Now let's look again in a year and see what changes.
Absolutely agree. There are lots of environments where multi-threading would not be an option (e.g. embedded systems). It would be behind a feature flag or even be a completely separate crate (hyperjson-parallel?). I just used rayon as an example for what can be done in Rust that can't easily be done in many other languages. That said, I think it would be great to finally put use those multi-core machines to good use. Tools like [ripgrep](https://github.com/BurntSushi/ripgrep) show that it's possible to beat legacy tools, that were already highly-optimized, with new approaches. The whole point is to think about writing encoders from a new perspective and try ideas that would be hard to do in C/C++.
Whoops, forgot the unit. Thanks for the hint. The metric is hyperjson calls/sec compared to other popular JSON parsers. That's the old benchmark suite which was taken from [ultrajson](https://github.com/esnme/ultrajson/) (hyperjson is a play on that project). This benchmark suite is quite dated (it was started in 2012 or so) and it's not really statistically sound. Therefore it will be [replaced with a new one based on pytest-benchmark](https://github.com/mre/hyperjson/issues/18), which provides Mean, StdDev and Median for all operations and measures execution time in microseconds.
Do note that in the case of a webserver, for example, the webserver itself is most probably already using parallel threads to process multiple requests in parallel, so there'd be a slight throughput loss from parallelizing json decoding/encoding (though it might be offset by latency gains, maybe). It would probably take very specific workloads to benefit from multi-core json processing. On the other hand, ILP gains for faster processing on one core is likely to be appreciated regardless of the environment, so I'd be interested in seeing how clever use of SIMD could be put to use here. In particular, for *decoding*, I wonder if there are speed-up opportunities from using SIMD to extract the *structure* of a document (positions of keys and values, start/end of objects and lists) without actually decoding the keys and values themselves. In short, a first "indexing pass" with minimum memory requirements, used to then allow "lazy perusal" of the actual content.
Echoing others, I'd be super-interested in a write up of what some of C++'s new features learnt from other languages and what C++ improved.
Great idea! Seems like [pikkr](https://github.com/pikkr/pikkr), which also supports SIMD, could be interesting to experiment with. 
Yep but no one uses C or C++ directly for that, that's my whole point. 
&gt;f it requires epic contortions and intricate sets of rules, then I'd rather not. For sure, and we don't want to make compile times any longer to cover rare cases! 
ubsan and tools like that are definitely useful, but Rust's safety guarantees are much stronger than what such tools are able to detect. Specifically, even if someone's existing code does not trigger UB, in Rust it is a bug if it exposes an *interface* that allows UB. Many of the actix issues were of this sort. In general you can't detect this kind of problem with any sort of runtime sanitizer.
For my 2c, I have found Hyper to be well documented, and you to be an extremely responsive library author. 
I never said I was doing anything optimally. Blog posts and conference talks are tons of work. Both easily consume weeks of my time. I can barely write one blog post a year. Moreover, I don't like writing persuasive blog posts. I'd rather just lead by example.
So... This *isn't* the `conduit` crate?
The standard [`LinkedList`](https://doc.rust-lang.org/std/collections/struct.LinkedList.html) lacks support for some basic linked list operations, such as insertion in the middle of the list. O(1) insertion is often the reason why linked list gets chosen as data structure, and is what the quoted `insert` function implements.
A monad consists of _three_ parts that must satisfy the monad laws together: the type itself, and the return and bind operators. When u/Rusky said `Result` isn't, _on its own_ a monad, they meant that `Result` is only a monad when combined with the `Ok` constructor and the `and_then` function. Some types can form law-abiding monads in multiple distinct ways, so it doesn't technically make sense to call any type a monad on its own.
&gt; Yep but no one uses C or C++ directly for that, that's my whole point. I literally know hundreds (maybe thousands) of people that do use C++ directly for that. 
Where are your osha results so that we can see before vs after?
My entire PhD was done in modern Fortran. I know of a ton of industry and academics that are still using those low level languages for scientific computing. A lot of us don't use higher level languages because we need the speed the low level languages bring us. It's one reason I'm trying to help introduce fundamentally necessary numerical libraries to Rust for it to succeed in the scientific computing area. Also, I like using python to post process my data, but I would never use it to actually generate the data. It would be way too slow even if it was based on numpy. However, I've also found that even now some of my data sets need to be post processed using something even lower level than python + numpy. 
Go tell your mom that someone disagrees with you. And cry. 
You as a user have to pass â€”plugins to activate plugins. Check the patch.
I work with kubernetes clusters regularly as part of my job and devops as been in my remit before. What is a service mesh and what is conduit? Is service mesh a fancy way of saying "HTTP proxy for internal services?" I'm having a hard time imagining a junior dev or manager reading your website and having any idea what this thing does. I had to dig through the docs before I found any mention of HTTP.
Is the proper foundation ndarray rather than nalgebra? (nalgebra has dynamic array types..) Btw, do you happen to know why can't both crates use the same underlying types (or at least the same traits to describe matrices), so that data produced from one can be fed into the other?
I'm inclined to agree with you, but I could see how others wouldn't. Part of me wonders why the C++ designers didn't just skip all the ceremony and print a core dump for every syntax error. :)
That's a point, I guess, but I don't really see the value in including or focusing on the "*on its own*" qualifier. Seems a bit pedantic to deny important structure because just it happens to not be useful for the present task. A screwdriver can't turn screws *on its own*, but nobody is going to deny that screwdrivers can turn screws.
Slightly OT but anecdotally I can't get the performance of v8 on firefox. Are there reasons for this? Or am I wrong? I hope I am :)
You're not wrong, Walter, you're just an asshole.
They *have* done whatever they want.
And here is the final (improved) version of your macro: https://github.com/GuillaumeGomez/macro-utils/blob/master/src/if_match.rs
Rust uses a nominal type system, so the only thing you need to do to use the same types/trait as another library is agree on what those types/trait should be and put them in a shared dependency.
The "top two" choices at the moment are Rocket and actix-web. Generally, you can think of Rocket as: more ergonomic, not supporting web sockets (unless things have changed?) and only works on nightly. I've built things in it and found it a very pleasant experience. Actix-web is the other major contender, and it works on stable and supports sockets. I don't have a lot of experience with it, but people seem happy with it. This is making many assumptions about your use case. Namely, I'm assuming you're building a fairly standard business application. But if your needs differ, then expand on your use case and people can give more specific recommendations.
Correct.
nalgebra is not optimized/designed for handling n-dimensional arrays, which is a must for being a proper NumPy equivalent candidate. Integration between the two libraries is not impossible I guess, but they serve two different purposes.
The first google hit for me for â€œservice meshâ€ is https://blog.buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/ by these exact folks.
Oh, didn't know. Neat. 
Firefox's and Chrome's engines have different performance profiles. We are better at certain things, and they are better at certain things. But we're mostly comparable. If you're seeing Firefox as significantly slower than v8 across the board, that is not what we measure, and something is seriously wrong. What are you measuring that on?
Yep, I wish they did this!
We have a few engineers working remotely, but I know we're looking for on-site specifically for this position.
Yeah sorry that's not what I wanted to say. For working on a cluster C is still the main tool, CERN has Root but as far as I know it is used mainly by physicists working on HEP. I've been working on astrophysics and then as a data scientist and in both cases python was the main tool. Of course big cosmological simulations were run on tools written in C. But given that you want a substitute for the KDE used in Scipy that's a whole different story, we're not talking about cluster computing using hundreds of cores. For that kind of work I think it would be better to stick with python using C written libraries. If I remember correctly there have been some attempts to write a REPL for rust (I can only remember rusti right now) but I don't know the current state. Even then I would be more worried about the ergonomics of the current numerical computing libraries. On the other hand there is Dask for python which is an interesting hybrid being able to work on your laptop and also on several machines for parallel processing, there is something like that for Rust (don't know if is as flexible as Dask) but I cannot rememeber its name right now. 
I have no idea what you wrote but from context I'm guessing you'll want to go to https://www.reddit.com/r/playrust/. This is the subreddit for Rust the programming language, not Rust the game.
Dutch here you are on the wrong redit! For the game go to the game rust Reddit group 
There's actually a nice series of discussions on this topic in one of the (issues)[https://github.com/anowell/are-we-learning-yet/issues/14] on are-we-learning-yet?
It's worth noting that while some ideas from pikkr could be used, it does not provide the same guarantees as serde - I believe, at least. So invalid json may be parsed as valid, as an example.
what does proper name mangling mean in this context? Every compiler mangles the symbols differently.
and gotham?
As I know one of the most time consuming part of json parser is parsing of `double/f64`. Do you use standard code to parse doubles or your own? And by the way the most tiny C/C++ do not parse double's correctly, because of many functions from C stdlib depends on locale. For example you can look at Dropbox's c++ library discussion: https://github.com/dropbox/json11/issues/38 
And according https://github.com/mre/hyperjson/issues/16 , I suppose your profiling data is useless. You definitely need profile release build, just turn off stripping symbols.
I've been working with kubernetes and service-mesh related things a lot. Here's my brief description: A service mesh is basically a set of proxies sitting in front of your cloud applications. There are two kinds of service meshes: those that just consist of a data plane (like Envoy or Linkerd 1.0) and those that have both a data plane and a control plane (like Istio, Conduit, and Nginx Plus). Those with a control plane take most of the manual work out of maintaining the proxies. Istio uses Envoy as its proxies, nginx plus uses Istio's control plane with nginx proxies, and Conduit has its own proxies built with Rust). A service mesh lets you do intelligent/secure routing, and gain telemetry while doing so. For example, I can configure mutual TLS between my services, and when service A calls service B, it makes the call over HTTP, but the two proxies in between perform the TLS handshake. Mutual TLS also gives each service an identity, so you can say "Only Service C can make DELETE requests to Service A and nothing else". The control plane manages all certificate-related things including issuing them, maintaining them, rotating them, etc. Additionally, since the proxies are intercepting the traffic over HTTP, it can inspect this traffic to extract metrics like how many 2xx, 4xx, 5xx etc HTTP responses go between two services, and send those metrics to something like Prometheus. And the proxies can inspect the HTTP headers so the proxies can Extract spans using the OpenTracing API, create child spans, and Inject the SpanContext into the headers of outgoing requests. This lets you get tracing information between your services without having to instrument your services. And it includes tags like the HTTP method, the URL requested, etc. All pulled from the requests/responses. Finally, the service mesh lets you manipulate traffic. You can do fault injection, induce latency artificially (or based on HTTP headers or cookies), do circuit breaking, and more. You can route traffic between two different services using different rules ("Send 10% of users to v2 and the rest to v1") or something based on headers ("send people with x header to v2, but noone else"). This is mostly related to Istio since that's what I have the most experience with, but I imagine it's similar with Conduit 
Yea, they're buzz words and marketing jargon. I believe we're going to deemphasize the jargon, and just call it as you say: "a debugging (plus extras) tool for your internal services". Conduit injects proxies into all your services with minimal (or none) config in a couple seconds, you then get metrics, tap, TLS. If you hate it, it uninstalls in a couple seconds as well. If you manage some clusters in Kubernetes, may as well try it out and see what it gives you. I promise it doesn't take long ;)
I don't have a Travis config to supply, but this is how we do it with the Ion shell's GitLab CI: https://gitlab.redox-os.org/redox-os/ion/blob/master/.gitlab-ci.yml
Okay, I'll try. Didn't know you could strip off symbols but keep the remaining optimizations. Is there a tutorial for that somewhere? To be fair, the benchmarks always ran with `--release`. ;-)
hyperjson is just a tiny wrapper around serde-json, so we just piggy-back on top of that. I assume, that serde-json is doing a great job there, but I don't have any proof for that. At least all Python unittests pass regarding doubles.
The GPL didn't work out so well for GNU Hurd... Just having a GPL license does not guarantee that you are going to get any contributions. Nor does having a GPL license stop fragmentation -- that is more of a community issue than a license one. Linux was simply in the right place at the right time, so it was able to reach critical mass. People contribute to Linux not because they have to due to the license, but because they need to do because they rely on it.
The foremost goal of the project is safety. Lots of similar projects are fighting with segfaults. The [issue tracker of ultrajson](https://github.com/esnme/ultrajson/search?q=segfault&amp;type=Issues) is quite sobering in that regard. If we can have safety and speed, we take both of course. ;-)
A convenient way to create glsl static analysis/lints would be *really* useful. In webrender we regularly run into glsl compiler bugs (especially on Mac) and having a way to detect them before they hit nightly users would be great. 
Would anything stop this library effort from being usable in Java, C#, and Ruby too?