Emscripten?
 &gt; It seems that even a fairly lightweight render loop is enough to invoke the GC and drop occasional frames. Out of curiosity (and because I want to learn), have you determined that it is the Javascript GC and nothing else that causes the occasional frame drop? And if so, how did you come to that conclusion?
\&gt; Since qtcreator 2.8.0 you can set up real rust projects. I think this is a typo as the LanguageClient plugin released with 4.8 which released earlier this month (heads up Ubuntu's qtcreator PPA is on 4.6.2). &amp;#x200B; Thanks for the heads up, Qt Creator was my favorite C++ editor and a welcome addition for Rust. :)
Can someone knowledgeable weigh in about IntelliJ vs QtCreator?
There’s a laundry list of problems with the npm ecosystem, not just node’s braindead module system. Cargo shares only a few of them, but mostly just the “trusting random packages” subset. After being neck-deep in it for years, “garbage fire” is me being polite. 
well damn that was one of my idea for my first real project while learning Rust. I was going to do the LAN protocol first though, so maybe if I can find some time I can work on it for your crate. I've been considering this for months though and it just hasn't happened.
I write numerical/scientific code for a living and this comment is pretty much spot on. I would also like to note that working in a language such as Julia or Python allows you to easily check that your code works. You can easily examine intermediate steps in your calculations and plot the results which is invaluable when first trying to get numerical algorithms written. I often prototypes ideas in Python and check to make sure it's doing what I expect, and then I'll port it over to a lower language such as Fortran, C, C++, or Rust. I'd say if you want to learn Rust and use it for numerical analysis type stuff first do the work in an easier language and then do a "direct" port over to Rust. After you've ported it over, you can then work on rewriting it in a more idiomatic Rust style. 
I really enjoy the book so far. Reading about errors now! I'm new to programming and there is a lot of stuff that is new for me since I have only played around with Python before. The explanations and examples in the book are really great and easy to understand. Really awesome resource, thanks for that! I have also had some question on Slack and people have been very helpful. I'm not sure if Rust is the language for me (more of a sysadmin/linux person) but the main focus is to understand how things works in the background, like the difference between storing things in stack/heap. It feels like a language like Rust is great for that. And then hopefully be able to write some smaller applications in the future. So I can't compare Rust to other languages but I really like it so far as a beginner.
It's difficult to prove absolutely, but I have spent a good deal of time in the profiler and I'm fairly certain. At the moment the application code is trivial, does no heavy lifting, and generally completes in under a few milliseconds (called ~60 times per second). All it's doing is computing some simple values, updating the DOM with them, and executing some low io WebGL calls via threejs. The only call trees I've observed taking longer than 5ms have been because of a GC sweep. Admittedly these pauses don't happen very often, but they do happen and I expect them to increase as more functionality is added.
I have enough knowledge to know intellij is written in Java and qtcreator in cpp. That should tell you all you need to know ;) Hint: Ram hog
This is great news! I just installed JUST the QtCreator. I would really like the ability to right click a function and say "go to definition". Also, I get a "Unable to create a debugging engine" error when attempting to debug. If anyone knows how to get debugging working - then I can do without the definition follower. Also - ctrl-f for searching tends to search my target directory as well. This is a minor inconvenience - does anyone know how to ignore the target directory when doing project searches?
Also compile time
While this is generally true, IntelliJ is actually very efficient and snappy. PyCharm on the other hand, complete RAM hog. Also Im fortunate enough to have a good amount of RAM (8gb)
&gt; no globally cached dependencies, This is being worked on. It technically works already but never gets cleaned. There is progress being made on a cleaner. So there is hope. &gt; linking against two different versions of the same library... Fixing this to aggressively has its downsides too. I am working on impl the "Public Private Dependencies" RFC. Witch will hopefully make this rarer.
I'd be happy to have your help on the LAN stuff (or whatever else)! Feel free to PM me or comment on/create issues if you do decide you want to help out!
&gt; I am working on impl the "Public Private Dependencies" RFC. That would be superior to cabal. But in the meantime what we have is unfortunately quite poor - particularly galling given how many people are being paid to work full-time on it.
Er, isn't PyCharm also IntelliJ?
Yeah but it's a custom IDE based in IntelliJ, not a plug-in for IntelliJ. So slow. Sad that it's the only real option. 
I'd like to see something more like "jsweet".
I guess you may be right relatively speaking about efficiency but on my 4gb, I could only ever run a single intellij instance and it blocked out the possibility of running any other Java program for more than a small amount of time. 
I only ever use IntelliJ for Rust, which is a C-like, close to the metal language, so I don't have that problem. 
Qt's biggest selling point and pride is that they are x-plat. So I'm guessing all.
I have trouble following the issue. Perhaps an example would make things more understandable?
Well if you weren't originally a web-boy from a boot camp, you'd know what I'm trying to say. 
No, I understand what you're saying. Also I'm not a web boy, never have been. Also I've never been to a boot camp. 
Sorry. I was rude. Although bootcampers act like they know more than others. I don't see the need for explaining what rust is unless it was a joke 
Lol actually I've met so many programmers at my college recently who've never heard of rust. Nah I just am super excited about it and I felt it was relevant because it's a good deal faster than Java, which means I need less CPU and RAM to run large rust programs than I do for Java programs. 
OMG THAT 6TH POINT!!!! NO WAY!!!! HAHA Seriously though, I have friends who do C++ who swear by QtCreator. So thank you very much for probably spending hours figuring this out and then telling us.
I thought IntelliJ was Jetbrains general IDE framework, something all their IDEs use? I see no reason why Pycharm specifically would be slow and not all their other IDEs based on the exact same thing?
Dude don't ask me, all I know is my RAM and CPU spike way more when I open PyCharm vs when I open IntelliJ. 
Ah, *if the state owns a resource.*. Thanks that makes sense. Maybe we're equally confused now. Like, an unsafe block which copies something not copy-safe and then calls safe code? Whoopsie. 
Maybe ask the question over in /r/actix ([https://actix.rs/community/](https://actix.rs/community/))
They aren't actually called immutable references, but shared references. However I just checked various versions of the book, and for some reason they slightly shifted away from calling them shared references and are now calling them immutable references. I'm honestly not sure why.
I'd really like to see the laundry list. I think calling node's module system "braindead" is a little silly, considering the history of JS. As for trusting random packages, that's obviously something JS has a small problem with, but blaming npm for it is kind of ridiculous. I really think if Rust ever gets as popular as JS, it will have the same or at least extremely similar problems, and any problems that it solves, it only solves because npm had to solve them first (e.g. left-pad). Problems like the event-stream one seem to be only exclusive to JS because JS is basically the most popular language and npm is basically the most popular package manager. After being neck-deep in it for years, I *wish* Cargo were as mature and had such a robust ecosystem. Fortunately, Rust and Rust's standard library make up for the shortcomings in this area.
In the chapter you reference, there are places that refer to `Box&lt;dyn State&gt;` directly: trait State { fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;; } so, yes, it's possible. The use of `Option` in `Option&lt;Box&lt;dyn Trait&gt;&gt;` is explained in the chapter (see the paragraphs just below listing 17-15). But basically, if you were writing code with two variables, you can move owned memory out of one variable into another, such as: fn some_func() { let first_owner: Box&lt;dyn State&gt; = ...; let new_owner = first_owner; // first_owner can no longer be used after this point ... } but you can't do that same thing with a struct: let post: Post = ...; let new_owner = post.state; // Move out of a struct not allowed // otherwise post would be invalid Basically, the authors of the chapter designed a solution to work around temporarily moving ownership out of a struct. There are other API approaches you can take (see something like [this post on state machines](https://hoverbear.org/2016/10/12/rust-state-machine-pattern/) for how you might design an API where an object consumes itself and produces a new intermediate object), but `Option` seems like a reasonable decision. As a reader of the code, you should see `Option` and think "OK, this state can be cleared / moved out at some point, so I should keep an eye out for it".
Cool, thanks!
In the pre-1.0 days there was a proposal to rename `&amp;mut` to `&amp;unq` to better reflect the semantics of non-shared pointers. It should have happened, IMO, but it didn't go down well (possibly the proposal was misunderstood?) and caused a shitstorm known as the [mutpocalypse](https://www.reddit.com/r/rust/comments/2581s5/informal_survey_which_is_clearer_mutability_or/). After that no one was brave enough to challenge the terminology even though it is acknowledged to be somewhat misleading.
The most noticeable difference is boot time. I just clocked the two on my admittedly old/low ram system with a new SSD: Intellij took \~45 seconds from run to files being editable, Qt Creator was about a second. In general I find Qt Creator to be very snappy for code navigation.
I found myself down a surprisingly deep rabbit hole when I started looking into array initialization, so I wrote this blog post to share my findings. The post also announces [arr_macro](https://github.com/JoshMcguigan/arr_macro), a procedural macro I wrote to make it easier to initialize arrays. 
TLDR: immutable references can link to mutable stuff so it's a misnomer. this can lead to easy-to-make bugs when you pass "immutable references" to functions who expect actually immutable stuff (ex: keys in maps).
It makes sense since in the game you usually spawn on the beach 
I noticed some points in this post that didn't sound quite right to me. These might be unnecessary nitpicks, so please ignore them if they don't seem helpful. But since we're talking about trying to nail down some tricky terminology, maybe nitpicks could be helpful. &gt; There is absolutely no guarantee that immutable references will actually avoid mutation of data I think that goes to far. Many types do provide that guarantee, just not all types. &gt; In the old scheme, `Fn` could have been used to guarantee that a given function is pure and deterministic. I don't think that's true. A `Fn` function is perfectly within its rights to read bytes from `/dev/urandom`, or even to write to some shared file and communicate state with other `Fn` functions. As far as I know, that was always the case. &gt; This isn't necessarily a bad thing, but it becomes a pitfall when you pass such a container type to an object that expects to control the value of data and only hand out immutable references (like the key type in the Map/Set structs). Interior mutability is only one of many ways to confuse a `HashMap`. Doing IO inside the key type (like the `/dev/urandom` thought above) is another large category of ways. Maybe for all these sorts of reasons, I tend to focus on definitions like "shared references can be aliased, mut references cannot be aliased" part of the definition as the most important part.
Cool stuff! &amp;#x200B; For LAN protocol stuff, I have a library that might be useful: The \[\`lifx-core\`\]([https://crates.io/crates/lifx-core](https://crates.io/crates/lifx-core)) crate contains the low-level protocol stuff, and an enum for nearly every message type documented in the LIFX docs. &amp;#x200B; I also have some in-progress and unfinished code to use this library to interact with bulbs. It's in the same repo as lifx-core, if you want to poke around. &amp;#x200B; I've also been sitting on the \`lifx\` crate, but haven't published anything to it. We should find some way to put it to use, either by collaborating on a release, or a new project or something.
[cargo outdated](https://github.com/kbknapp/cargo-outdated) shows a list of dependencies that have newer versions available, but it is not interactive.
I've heard that a good way to think of them is as "shared" and "unique" references. The problem is that it was named "&amp;mut" not "&amp;uniq" so now everything is just considered "mutable" or "immutable"
Does LLVM roll that back into a loop or something if there's lots of elements? I feel like this would generate a lot of code if LLVM doesn't.
Great! For reference LLDB integration in VSCode works fine for Rust including debugging across FFI into C. 
The nomicon still calls it shared references vs. mutable references, but I guess the nomicon is fairly unmaintained anyway.
They are based on the same framework (pycharm is almost on feature parity with intelij + the python plugin barring I think some django specific stuff). Perhaps the python code base being opened in pycharm is very large, or something? I myself use all three: pycharm, intellij and clion heavily every day and only clion is an outlier in terms of high memory and CPU usage (which is an issue being worked on by jetbrains). 
Anyone know if it has type hinting/switch statement autocomplete? The type hinting in IntelliJ has been very useful for me.
I've decided that [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=cd4b3ee3e70cf978ace7910691836498) is probably the most safe way to do this. The only thing I'm unsure of is exactly what `T: RefUnwindSafe` requires of T, but it's auto implemented for my basic type. The only performance cost I can see is having to copy T into/outof `ManuallyDrop` wrappers, but we're already copying T into F and back, so this seems acceptable in my mind. It has the added benefit of not caring about a panic in F. If F does panic, F will drop it's T, and the T remaining in outer scope never gets dropped because it is still `ManuallyDrop` while the stack unwraps. And all other things remaining on the stack get correctly dropped (see the example in my other reply). I'm very interested if you see any problems with it. PS: Sorry for so many replies, this is an interesting concept to me, and I genuinely want to find a 100% safe solution that is still as generic as possible.
Big if true
I hope that wasm will never become practical/widespread, although having seen WebDev "evolving" during the last 7 years makes me rather pessimistic. JS is quite bad for user sovereignty even today (ads, tracking, ...), but at least it's still forced to use a common, kinda semantic API: the DOM. That's what enables you to block ads, view pages with custom fonts/in reader mode etc. Once what you describe becomes practical/efficient enough using wasm I see publishers shipping their proprietary UI rendering framework and the DOM will consist of a canvas element and nothing more. That will effectively disable all ad blocking attempts and make DRM enforcement much easier (not secure DRM, but hard enough for most people to circumvent, kinda like the good old anti right-click scripts :facepalm:). I see why you'd like this functionality, but please don't help in enabling this future :/
Say I am devoloping my crate very rapidly. For example I have a file `sample.py` which uses the python wrapper functionality of rust crate. If I added a function in `my_crate` named `foo`, and wrote a wrapper using `rust-cpython`. In order to use the function `foo` in `sample.py` I do ``` from python_my_crate use foo ``` To get this working do I have to rerun the crate every one in a while?
Poga did something interesting on Actix, scripted with Lua in https://github.com/poga/streaming-data-parsing-with-actix-lua What of that might help you?
Honestly, this should just create an array of MaybeUninit, which is safe, and then initialize all elements, and transmute the result to an array of T
IntelliJ is efficient and snappy? I want your specs ;(. I have no choice to use it for Java right now, and I am sick of it freezing for ~10 s every so often - I would never recommend it for Rust, where VS Code works well enough and is relatively much faster.
I'm assuming given how dynamic Python is, their code analysis component for Python has to do a lot more work to make sense of types and compile auto-complete lists than for say Java or Rust.
I have debugged and fixed the GC in a scheme vm before. In general GC was is pretty straight forward by itself, if it is just mark and sweep. But the stuff I was working on was not so straightforward. We would have both C++ reference counted classes and references to java VM objects in the object tree. So circular loops would usually traverse the boundaries of these 3 languages. The 3 most valuable tools for debugging this mess whould be: 1) Who function - to trace out the reference graph to who owns a particular object. 2) Generation counter (debug). All created cells would be tagged with the current "test generation number" 3) List all cells of a particular generation. Then a typical test sequence would be: 1) Start up system 2) Run testcase (this would compile new code the first time) 3) Run GC 4) increase generation counter 5) Run test 6) Run GC ... ) increase generation counter ... ) Run test ... ) Run GC ( Repeat last cycle a few times ) Then finally you would list cells with generation = 2 and 3 for instance. Anything left with those generation numbers would be a possible leak. So this could be flagged as a fail in your test case. If you want to debug what is holding on to these cells, you use the "who" mechanism described earlier. 
you can also use intellij IDEA Community (which is free and also open source) with the rust plugin
I've gotten a few bizare results when debugging where the call stack/line of code the debugger thinks its at, and the variables in the current context don't seem to relate at all. Do you know why this would be?
MaybeUninit is not stable yet, unfortunately, so it's not part of Rust proper yet.
Nice work! Always good to see more people using Rust for games. I've been using it to develop /r/veloren, and it honestly feels like the perfect game development language for me. I hope more attention can drive the library and tools ecosystem to a new level of maturity.
The subtyping page was completely rewritten a few weeks ago, and the commit history shows maintenance.
We're having a bit of a terminology problem here, might be a mistake on my side.... When I say "a reference lives" I mean that the reference is valid, i.e. the thing it's pointing to is "alive" in the sense that it's initialized. That definitely works: As long as x is valid, the output is valid, because the both point to "the same thing". That's the thing the signature claims, everything else is for the compiler to reason about at the call site. 
I can't review the whole crate for you. I think it would be good to document the crate if it should be reviewed, or find someone to do a simultaneous documentation and review scan of the whole crate. I can see that `Address::new` + the `write` method on `Address` allows writes to arbitrary non-null raw pointers, which is completely unsound, so I expect there to be several minor or major soundness issues in the library. Example code: Address::new(NonNull::new(1 as *mut _)).write(1)
I have seen some odd things with cargo dependency overrides, but other than that, it’s been great for me so far. 
That's really interesting, especially when Rust + QML becomes a nice thing!
&gt; To get this working do I have to rerun the crate every one in a while? I'm not sure what you mean here, but, if you mean re*build* the crate every once in a while, then it's no different than any other Rust crate. Think of the Python API wrapper crate like a `[[bin]]` crate. Rust links statically by default, so you need to rebuild the wrapper whenever you want it to pick up changes in any of the libraries it depends on. `Cargo.toml` is expressive enough that you can have them together in a single local project where you just ask to rebuild the wrapper and it rebuilds the core library if necessary.
OK. I will be clear. What I want is I want my crate to be automatically build, when ever I make a change, so that I can use in the `sample.py` file. For example, in python we de `python setup.py develop`, by that installation when ever we make a change in `python` source files it automatically reflects. But here I think we need to go to the `crate` built it, and then use it. Is there a way to automate this process. Any crate which does that? Thank you for the reply.
tried to set it up with cmake project, too many small but annoying issues. For example if you will type `for ... {` and press enter, it will not recognize the indentation. So yeah, qtcreator is very good for C++, but vim and vscode are still my editors of choice for rust 
But as far as I know, debugging only works with clion, which is paid . 
Thanks for the post.
There's a community edition of CLion too; not sure if debugging works there.
Interesting, I hadn't really thought much about that. In general, I think custom rendering frameworks would require too many bytes over the wire for most websites, and would also incur a performance penalty as compared to browsers' native capabilities. I could see it becoming a thing for certain high-value high-traffic sites like Youtube though. Hopefully there would still be ways to thwart ads and trackers, perhaps by blacklisting domains and IPs instead of element selectors. It would be a real shame if WebAssembly turns out to be more of a constraint than a liberation, but then again that's pretty much the course of most technology.
I don't think so. There is intellij community edition. There, you can install rust plugin , and everything works except for debugging. Debugging only works in clion, which is their paid c/c++ ide. 
Does this also work with Kdevelop, which I believe shares a lot of code with QTCreator?
This has been debated a few times, actually, including to the run-up to the 2015 release of Rust 1.0. Technically speaking, `&amp;T` is a shared reference and `&amp;mut T` is a unique reference. However, from a *teaching* point of view, it is more useful to focus on the capabilities than the bare technical facts, and therefore a white lie is perpetrated: `&amp;T` is an immutable reference and `&amp;mut T` a mutable one. Why lie? Because that's how teaching works. When a 5 yo asks why planes fly, you don't launch yourself into the specifics of drag, lift, etc... And when a new rustacean asks how to write a hello world program, you don't launch yourself into the technical subtleties of shared and unique references. Then, when the querent learns about `Cell` or `Mutex`, and starts questioning how that works, it's time to explain that immutable/mutable was a white lie, and only applies to 90% of situations, then deliver the full explanation and demonstrate how it links to that white lie and why this lie is in fact a pretty good approximation.
Unfortunately, as mentioned in the article, there doesn't yet seem to be a consensus on how to use `MaybeUninit` safely for this: https://github.com/rust-lang/rust/issues/54542
(On mobile) Cursory glance: should probably mark ManagedHeao::gc(), Traceable, and GcRoot as unsafe. Incorrect rooting / tracing might cause a block to be freed prematurely. Even though you abstract away memory with Block, you might get a double unique reference to the same block. Another point: on Traceable, it's kind of stange to have both mark() and trace(). From your LinkedList test, mark() appears to be doing the job of trace(). Marking probably should be handled by the GC itself. Blocks have headers so there should be a standard marking scheme... Have you checked out any of Manish's or withoutboat's GC posts, by the way?
[setuptools-rust](https://pypi.org/project/setuptools-rust/) will integrate Cargo into your `setup.py` in the same way Python has native support for calling C and C++ compilers to build native modules. Here's some example code from a project (that's been on hold for a while) where I use a rust-cpython backend, a PyQt frontend, and [just](https://github.com/casey/just) for build scripting: # --== game_launcher_core/Cargo.toml ==-- [package] name = "game_launcher_core" version = "0.1.0" authors = ["Stephan Sokolow &lt;http://www.ssokolow.com/ContactMe&gt;"] [lib] name = "core" crate-type = ["cdylib"] [dependencies] # ... [dependencies.cpython] version = "0.1" features = ["extension-module"] # --== setup.py ==-- #!/usr/bin/env python3 from setuptools import setup # Workaround for https://github.com/PyO3/setuptools-rust/issues/2 try: from setuptools_rust import RustExtension, Binding except ImportError: import subprocess, sys errno = subprocess.call([sys.executable, '-m', 'pip', 'install', 'setuptools-rust']) if errno: print("Please install setuptools-rust package") raise SystemExit(errno) else: from setuptools_rust import RustExtension, Binding setup(name='game-launcher', # TODO: Unify this version definition with the source version='0.0a0', url='https://github.com/ssokolow/game_launcher', author='Stephan Sokolow', rust_extensions=[RustExtension('src.core', 'game_launcher_core/Cargo.toml', binding=Binding.RustCPython)], packages=['src'], # rust extensions are not zip safe, just like C-extensions. zip_safe=False # --== Justfile ==-- # # ... # rebuild: # "rm" the "copied into place" copy to work around an intermittent # "needs rebuild" bug that may or may not still exist. rm src/core.cpython-*.so || true python3 setup.py develop unittest: rebuild cd game_launcher_core &amp;&amp; cargo test nosetests3 # # ... # I can then type `just rebuild` or `just unittest` (or press up in my bash/zsh shell to pull it out of the command history) whenever I've made a change to the Rust code, and 
You can compile Rust to WebAssembly instead.
Yes same here. Whats really annoying is that because of this my QtCreator lags at startup quite a bit...
Yes. And I was under the impression that spam reports are permanently recorded against a user, possibly leading to an eventual site-wide ban.
The title should obviously read **Using C libraries in Rust**. Sorry for the typo.
&gt; but you can't do that same thing with a struct: Actually, you can very much partially move into and out of structs. The problem is moving out of a *borrowed* struct, such as in a function on said struct taking `&amp;mut self`. But that can also be trivially worked around `std::mem::swap` or `std::mem::replace`, or, of course, our friend `Option` if you need the owned value to build it's replacement and can't get by with a reference. See for yourself on the [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=67ee073d3800bb9934f19bc2d3e118bd)
&gt; It appears at one point Rust even had garbage collection. So fine, the clock starts at 2015. Let's see where it is in five years time. Fair enough. &gt; This has more to do with the fact that so few Rust developers are using it at work. If the only developers using it are those who have chosen to use it for their own pet projects, then clearly that class of developers is going to have the greatest love for the language. I'm sure it's true that people will enjoy a language more if it's self-selection, but the StackOverflow survey doesn't tailor the "What's your most loved language?" question based on what languages the respondent is using, nor does it intentionally skew the sample toward people who have tried Rust. &gt; Aside from the "obscure syntax," as a person on the outside looking in, I think it's more held back by the "solution looking for a problem" conundrum. It's low-level, but for most applications C/C++ is stable and good enough to the extent that they won't feel the need to migrate. Also C/C++ developers tend to be a bit older, more set in their ways, have complex codebases to support, and have little desire (and energy) to throw another language's ecosystem into the mix. I shouldn't have used the word "just" so flippantly, but I think it's also that we're looking in different places. While migrating problem points to Rust actually *is* a significant segment of its use (eg. rewriting hot loops and live monitoring components in Rust to reduce their footprint, rewriting parsers for untrusted data in Rust to get stronger static guarantees, etc.), it's actually getting it's most visible gains by creating a new niche. Rust has been gaining a lot of ground in the niche of scripting language developers who don't feel qualified to write safe, reliable C or C++ code, but do actually want some mixture of more performance and a type system capable of better static guarantees... similar to how Node.js became so hugely popular because it allowed client-side developers to start developing server-side code too. That's why safe "compiled extension for..." abstractions like [Neon](https://neon-bindings.com/), [Helix](https://usehelix.com/), and [rust-cpython](https://github.com/dgrunwald/rust-cpython) came about so quickly. That's also why I say that the wait for async/await is holding it back so much. The parts of web applications you code yourself typically aren't CPU-bound but would benefit hugely from better static guarantees and tighter, more predictable memory footprint. (It's a well-known rule of thumb that a GC performs optimally when given about twice the RAM the problem would need with the kind of direct, deterministic memory management that Rust automates.) However, even with things like Neon and rust-cpython, it's simply not worthwhile to constantly jump back and forth between whatever language your web framework is written in and Rust, so, to truly shine in that space, Rust needs offerings that compare favourably to frameworks like [Express](https://expressjs.com/) and [Tornado](https://www.tornadoweb.org/en/stable/). That's where async/await comes in. &gt; These are all points I'm sure you've heard before, but it'll be interesting where Rust goes. Unfortunately Firefox doesn't have the browser market share it had 8 years ago when they started investing in Rust (from 30% to 5%), so things are going to be significantly more challenging for them. Even more worrying than I though. When I checked a few weeks ago, the source I found said 10%.
Note that other languages, such as C++, also have this feature. In C++ struct/class members can be marked with the `mutable` keyword to allow their modification in `const` methods, and this serves the same purpose as our `Cell` types, for the same reasons. So Rust isn't alone in allowing modification of "immutable" data. &gt; There is absolutely no guarantee that immutable references will actually avoid mutation of data Thats a bit much, only types that contain `Cell` have this property, and this can be (and is) statically checked by the compiler in cases. Immutable types are still safe, and if you absolutely must avoid interior mutability i imagine it wouldn't be too hard to build a tool to detect it.
Thanks for sharing. I want to second your statement about the quality of documentation produced by the embedded working group. It really is top notch, and I think the most obvious sign of that is the quantity of people who are able to give back to the community, in the form of embedded HAL drivers, board support crates, and further tutorials, immediately after reviewing the existing official resources. 
IntelliJ has its own compiler for Rust which shows a lot more errors and is a lot more accurate than the RLS. RLS aims to be faster at the compromise of having a simplified understanding of the program which can lead to false positives. IntelliJ is amazing for Rust, yet RLS is still fine.
I actually thought it meant someting like “Using C libraries? Un-rust! Making a sys crate”. No worries, still a good read though!
Thank you guys for all the responses. I've went thru all of them. I have watched a few videos (speeches) on youtube and now I'm on the official [book](https://doc.rust-lang.org/book/index.html) I will have probably a few next "dumb questions" in a future.
I'll try this when I get a chance it looks very good. How did you specify your build? cargo build --target thumbv7em-none-eabi or did you change it as a default somewhere?
What you want to achieve can be done entirely within actix-web. Actix-web features its own client. This example shows you exactly how to accomplish what you seek: https://github.com/actix/examples/tree/master/async_ex1 Try to spend time looking at the actix-web/examples repo. Further, the documentation is avail at https://actix.rs. It isn't sparse, relatively speaking. You just don't know how much worse it can get.
RalfJung’s comment in that issue is one of the many ways to use MaybeUninit correctly there.
Why should N be less than 32
Oh dear, why is *that* in the Book? Okay, I'll relax. Dynamic dispatch and OOP aren't always evil. But there is a decidedly functional-programming version of the same idiom: the state enumeration. Advantages of using a trait: - Additional types can be added to an existing trait from outside the module. - Often less boilerplate. Advantages of using an enumeration: - Much easier for the compiler to avoid a run-time dynamic call (somewhat faster) and to use inline calls (often *much* faster). - more closely related to the formal, comp-sci definition of an FSM. - source code often forces you to consider and plan for all possible state transitions (exhaustive match rule). - preventing other modules from adding states is often cleaner - avoids the `Box&lt;SmallType&gt;` pattern, which makes both automatic and manual optimization easier. 
(This)[https://www.msi.com/Laptop/GL72-6QF/Specification] is my laptop. I have 8gb of RAM in it, @ 2666 MHz. Processor is i7-7700HQ @ 2.8 GHz. It has a built in graphics card, a GTX 960M (not really relevant here). Storage is a 250gb SATA SSD. (Here)[https://www.amazon.com/dp/B074GRXR2R/ref=cm_sw_r_cp_apa_i_Lv4hCbT852AE0] it is one Amazon. I'm not usually a big spender, it was a steal at $750 when I bought it. 
Some people already used to do that using Macromedia Flash. It fell out of favour as people realized: 1. It's antithetical to SEO, which they're also obsessed with. 2. No matter how hard you think it is to reinvent the browser's accessibility features, it's actually harder. 3. It doesn't adapt well to different viewports. 4. There are certain browser APIs you can't reinvent for security reasons and hacks to use the browser version in non-idiomatic ways are painful at best. 5. It interferes with comfortable use of the browser's developer tools (Basically, they realized that it was a false economy at best, because you eventually wind up having to reinvent an inferior copy of everything you threw out, and, if there's enough information for proper SEO and accessibility, then there's enough for a browser extension to implement things like ad-blocking and DRM-busting.)
Thank you for your reply. Making them unsafe seems to be the right call, I will definitely do that. Trace is just a bad name. The method is meant to be used to update all of the addresses, when the gc is actually moving memory around. I didn't know withoutboat. Will definitely look into it :) 
Yeah, I haven't gotten around to writing a decent documentation. Address is definitely unsafe. The user isn't meant to create his own addresses though, he just receives them. I will mark more methods as unsafe in the future, so things like this will be clear. Thank you for looking into it :)
I already knew the concept or reentrancy, so `FnMut` pretty clearly corresponded to the concept of a non-reentrant procedure. `Fn` implies reentrancy, just as much as `Send` is a thread-safety marker and `Copy` marks whether copies may be trivially created and destroyed. (You can even explain a non-reentrant C interface to safe Rust system by exposing `FnMut` values of a singleton zero-size token. The ergonomics would likely be bad but `&amp;mut self` methods would be better.) I agree that the order these concepts are taught, *especially to people who come from a dynamic language background,* needs to be adjusted.
Thanks for your reply. The thing with the generation counter sounds pretty useful. Currently is simply allocate and free in a loop and check, that the number of used and free blocks is correct. But looking into when the thing was created is a good idea.
IntelliJ does not have its own compiler, but it's own analysis tools.
Oh i seem to have forgotten to upload the .cargo/config. It should be in the repo now, there you can find it
Good work! I was looking for various solutions to the same problem just yesterday, but in the end decided to construct arrays manually cos they are &lt; 10 elements in my case. I was rather disappointed that it's impossible to write such a thing with normal rust macros. On the other hand it's reassuring to see you can do it with procedural macros!
This guy rusts.
Can you please elaborate on this? 
The Firefox debugger uses a lot of Babel internally. Maybe this can speed up their work.
Wow lights connecting straight to your wifi? Now your lights can spy on you and become part of a botnet :D
It's hard to create a benchmark that reflects real world use case. Why do you want that data? As the TechEmpower benchmark shows, ASP.NET can be crazily fast in some cases (despite it's running on JIT). I consider Rust's main advantage to be its strong typesystem, followed by the more stable resource usage as a system programming language. (BTW, I'm not a fan of FaaS. Before talking about cost or similar things, you should consider alternatives. A recent article on this is Serverless Computing: One Step Forward, Two Steps Back - https://arxiv.org/abs/1812.03651)
At any rate, it'd be beneficial to document that this is an implementation of *some* protocol (eg. by linking to the tokio framed codec) rather than giving the impression that yet another length-value protocol is being invented here.
https://twitter.com/rauchg/status/1076150773099126784
The chapter is about OOP, so it shows the OOP idiom. Most of the book isn’t like this.
That’s a pretty recent development.
The official terminology is “immutable reference” and “reference”. We had a huge discussion about the two “the mutapocalypse” and decided that the pros outweigh the cons. People *really* care about immutability before they really grok Rust.
From zeit on their server less platform: https://twitter.com/rauchg/status/1076150773099126784?s=21 Not sure on cold start vs warmed up, but generally looks promising. 
That's why I specified a few weeks ago, and throughout the last year, there are multiple merged pull requests every month. If there is a preference to change how shared and mutable references are listed, it should be understood that it is not unmaintained to the point that a pull request or issue would go ignored.
Oh totally! I’m glad you brought it up, I just wanted to mention that things have gotten better recently after a long time.
Due to a mobile snafu, my previous comment was deleted while you were replying. Re-posting as a reply to yours &gt; That's why I specified a few weeks ago, and throughout the last year, there are multiple merged pull requests every month. If there is a preference to change how shared and mutable references are listed, it should be understood that it is not unmaintained to the point that a pull request or issue would go ignored. and that makes sense! I'm glad it's picked up. I should have scrolled back more to realize there was a longer lull of inactivity :) 
Because we don't have const generics yet, some traits on arrays are basically implemented by hand. Thus they must be re-implemented for each particular array type with a different `N` (by a macro, last I checked), so `N` must be finite. Currently, those traits are implemented for `N` up to 32. It's been increased a time or two, but I think we want it to stay fairly small because just automatically adding thousands of generic trait impl's to `std` probably won't help compile times or code size much. Tuples have the same problem.
Oh yeah, the book heavily prefers Rust-y solutions. But they wanted to show that Rust *can* do polymorphic OOP as well, although in trivial examples it's usually not terribly idiomatic.
It's more or less just how JetBrains does their thing, every IDE of theirs has their own analysis engine and in some cases their own compiler as well. The IntelliJ Rust plugin is open-source and written by a few programmers at JetBrains plus volunteers.
Very good post! I looked at it and the first thing I thought was "gosh, doesn't rustc elide simple initialization when the array is never read before it is written to?" And the answer is, apparently, [probably not](https://godbolt.org/z/FbTL7m)!
&lt;3
Thanks! I'll try to see what's going on there. And possibly make glium the default backend (at least on Linux).
There are pro's and con's to each... This is one of the wonderful little semantic nitpicks that ends up inadvertently shaping how we view the world. As other people have pointed out, alas, this is one of the things that has been discussed to death so much that nobody really wants to seriously revisit it, so it remains as a minor wart. Fortunately, Rust isn't the last programming language in the world, so there's hope for the future. Personally if we were to do it all over again, I would ditch the name "reference" entirely and just call them "borrow"'s. :D
Amazing post, thanks for sharing :) What I found even more amazing is how prolific the author is... On his GH, he has a few big Rust projects, a popular ObjC app (Sparkle) and a JS HTTP library. I have no idea how one person could manage all that!
Yea you got that right. But I've only ever used replays myself to reproduce bugs, so they're not super usable. They will almost certainly not work version from version for example. But you can leave them in. `stats` just print out some engine timing issues, you can leave them in but they might slow the game by gathering the data. And `verifications` is what stores the game state every turn. That one should definitely go away.
Thanks! I agree completely :-).
You can use a hal, as stm32f103xx-hal and stm32f1xx-hal. They should work on your board.
Just a guess, but maybe the reason you see web front ends is because GTK and Qt crates aren’t mature yet
Main Job Description Here [https://www.cwjobs.co.uk/job/developer-javascript/x-machines-job84586516](https://www.cwjobs.co.uk/job/developer-javascript/x-machines-job84586516)
No need for PMs. Kind of like terrorist cells. Small covert operations working in isolation toward a common goal. Even one succeeds in getting "the backdoor" to reveal itself, can publish it, and it's hard to take it offline ever again. The problem is, if there's no back door, what's the gain? (If someone documents and proves that they managed to get one, there's no guarantee that the other chips of the same make and model are to be trusted too. Or if they make the chip themselves, then they can't really sell it, because anyone buying would need to buy the whole system to verify it too - as you mentioned.) Anyway, unless you're a big state you can't gain much, but they are the ones that can lose the most if they can't verify their information infrastructure. &gt; If everyone doesn't verify themselves, they're getting a binary somewhere, and all someone has to do is hit the distributor with a wrench. Yes, that's why ideally people would go deeper (ha-ha), get a very minimal set of source code and its checksum, verify it on many setups, and then simply verify the components used for the source code verification to eliminate possibilities of even deeper backdoors (such as Intel ME, or other firmware-based vectors).
Is there a reason you're only considering the UK? Is it a legal thing, or a timezone thing?
Link doesn’t work (for me). Looks interesting. Is UK only because of time zones or something else?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/kubernetes] [Remote Backend Developer - Javascript \/ Rust \/ Docker \/ Kubernetes (UK)](https://www.reddit.com/r/kubernetes/comments/a8vmm3/remote_backend_developer_javascript_rust_docker/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thanks for the correction and playground link!
The whole of Europe is pretty close to that timezone, that can't be the reason. Getting working permits for Brexit UK is probably just impossible.
We would prefer a UK based developer, however we are open to candidates further afield. It is dependant on whether the Candidate is Willing to work in the UK, face to face, for the first few months or so, then once a month there after. @mtsr Any timezone that allows that allows us to work into the evenings UK time, is an advantage for us. **THE FULL JOB DESCRIPTION HERE** (For those who cannot access link above) **Winchester, Southampton, Bournemouth offices** £300 - £400 per day Contract length: **4 - 6 months** (with strong likelihood of extension) Start Date: **January 2019** **JavaScript Engineer / Developer / Back-end / Rust / Docker / Kubernetes** We are looking for a hard working, flexible backend developer to join our start-up to build the backend of our system, working alongside our Frontend Developer. Our platform is a global marketplace for industrial machinery, which will revolutionise the industry - we are spearheading this move, and the platform will be the first of its kind. It is an extremely exciting time to come on board, and we have just received another significant round of funding. Currently we have architected a backend in our techstack, which allows the creation and storage of listings. Performance was a key metric, hence our stack. We are seeking a developer who can build upon and improve what we already have. We are flexible, and would consider altering the stack provided it was for good reasoning. You will be working alongside a small, dynamic and capable team on one of the most exciting projects out there right now. The role is 90% remote, with occasional visits to our offices required. **Tech Stack Requirements:** \- Strong Javascript \- Rust \- Docker \- Kubernetes &amp;#x200B; **Extra Skills** \- Gitlabs \- Google Cloud Platform \- Capable working around a React frontend \- Node JS **Payment Systems:** * We will need to construct a payment system, in order to charge monthly subscriptions to our users * Charging per hour per listing, then billed at the end of each month * Each subscriber will spend a unique amount per month * Profit Sharing - If a user refers a new paying subscriber, they will need to be automatically paid between 25% - 40% of the new subscribers expenditure each month. **Mobile Application Development:** * The second stage of the project will be building the Mobile App for both IOS and Android devices. The frontend will be built in React Native, and will work very similarly to the webapp, therefore the database layer of the backend will need to work on both platforms. Experience working within a mobile app environment would be very beneficial. **For more information please** **contact or tel:** **A Slowen - CEO** **+44 7734 254617**
If you add `#[allow(warnings)]` to the top of your crate's root module, that should silence all warnings. Just make sure to turn them back on ;). Alternatively, installing the RLS should give you inline error markers in your editor.
Your example also uses an enum: the `Option` type. In a linked list, at some point, you need to represent the distinction between "points to the next thing" and "end of list". In Rust, your options boil down to an enum of some sort, or a collection, such as Vec. 
That's absolutly true. I guess a better way to put my question is whether there's a reason to use an enum as the *top-level* data structure instead of using a struct there? I'll edit the question to clarify that point.
That ASP.NET is so fast is very interesting as Java, which sits in a very similar design space to C#, has horrendous cold starts (classloading is slooooow) 
This is a hot execution, I think? 
As a long time user of QtCreator, I wouldn't switch to it for Rust projects yet, too many things that would bother me: * The automatic indentation seems to have some issues with Rust, after pressing enter on specific line it doesn't place cursor on the column you'd normally expect text editor to do. * Auto-completion for some reason doesn't automatically pop-up, you have to force it with key shortcut. * Highlighting of variables doesn't work. * No context-menu with "go to definition" (although that doesn't work for me in vscode either). From a positive side, this has lots of potential, and definitely looking forward to using it. Just a note that you can also do these tricks to help yourself with Rust: * In the Environment -&gt; External Tools, you can add rustfmt command, and then in Environment -&gt; Keyboard give it a key shortcut (same can be done for any other rust tool, e.g. cargo check). * In Text Editor -&gt; Snippets, you can add the... well, snippets. This is something that vscode has out of the box.
If a struct is the top level data structure, you can't represent empty lists
Great macro!
\&gt; If you add #\[allow(warnings)\] to the top of your crate's root module I added it to my main.rs and every mod.rs. It doesn't seem to work. I wonder if you could elaborate more. I'm a bit new to Rust. Thank you.
Sorry, I was on my phone and didn't type that correctly. It should be `#![allow(warnings)]` (note the `!`).
It's supposed to `#![allow(warnings]`.
It's supposed to be `#![allow(warnings)]`
Works like a charm. Thank you!
I guess I am still a newbie in Rust. I should have recognized that. I know that syntax... And it works now. Thank you! &amp;#x200B;
Why so many downvotes. This comment should have -10 karma or greater.
The key difference with your list is that it's non-empty. You could allow it to be empty by changing it to: struct LinkedList { value: Option&lt;u8&gt;, next: Option&lt;Box&lt;LinkedList&gt;&gt;, } but then it could be in a bad state (what if `value: None` appears in the middle of the list?). Rust by Example uses an enum at the top level so it can represent the empty list without any bad states. Both implementations are valuable though! In situations where I want a non-empty list, I'd use something like your implementation.\* (Aside: in a theoretical future Rust with [enum-variants-as-types](https://github.com/rust-lang/rfcs/pull/2593), the Rust by Example linked list can be used for both, with `List&lt;T&gt;::Cons` as the type of non-empty lists, which is neat.) \* Well, probably not, but just because linked lists have poor performance in both time and space. The standard library's `Vec` or `VecDeque`, or [im's `Vector`](https://docs.rs/im/12.2.0/im/vector/enum.Vector.html) are generally preferable.
I think there's no guarantee of immutability in the sense of generics, e.g. this could mutate: fn debug&lt;T: Debug&gt;(t: &amp;T) { println!("{:?}", t); }
Maybe a boring answer, but I like the standard library. It receives a lot of care, for sure...
It should be pretty easy to build a good benchmark for this. Just a chart of binary/package size with the cold-start time. This is just a measure of cold start time, not language performance, so I think it's pretty well scoped for a benchmark. As for that article, it's really only talking about performance. There are a ton of other reasons to choose serverless - like solving package management (most orgs aren't even close), lowering cost of maintenance/ operations work, etc.
Nice ! So if I have: struct Game{} impl Game{ fn new()-&gt;Self{} } I can do fn create_game(_:Python) -&gt; PyResult&lt;Game&gt;{ Game::new() } Or there is another way like impl PyObject for Game{} Also with rust-cpython you can only expose function or you can expose a whole class definition ? Thanks for your clarifications
I agree. I saw the difference in asm, but I couldn't find what distinctively made it faster...
You're probably right in saying that `Fn` never really was pure. I think it would be a nice language feature to separate "pure" items without side-effects for those cases where interior mutability is not expected, especially in the case of `HashMap` where it can break things.
I use Windows daily, Rust should be well supported. I use both VS Code and clion with the rust plugin.
I think that's a great answer! Was looking to branch out beyond the standard library, but from what I've seen so far the attention to detail would be hard to beat. Reading through bug reports against the stdlib was inspirational. So much care and craft put into every decision being made about the language. 
Some quick answers Windows is absolutely fine. A VM would be a bit less friendly for development in my experience. VS CODE with Rust plugin or CLion/IDEA are good IDEs. I have not used much of debugging but CLion debugger is usable. Also note that with Rust you might be need debugger a bit less frequently than other Lang. For projects you could just pick something simple like building a web API if that is something you do in other languages. Or you could try write a command line tool. If you feeling more adventurous you could write a parser or compiler. Just few ideas, there is no limit here but it would be good to pick something simple. I would stay away from programming challenges though.
You mentioned static type checking and it made me start to think about potential solutions. Do you think something like `auto trait Pure` would be useful? Then we can mark items like `RefCell`, `FnMut` from std and core to indicate that they don't follow the interior mutability guarantees, and then they can be a trait bound on types like `HashMap`.
Thanks for the reply! I actually have a copy of Visual Studio Enterprise and will look into seeing if I can get a Rust plugin to work with it. Otherwise, I'll toss a copy of VS Code on my dev machine. Thanks again!
Writing a parser or compiler sure would be fun. I actually have Visual Studio Enterprise so I'll look into seeing if I can get a Rust plugin to work with it. Otherwise, I'll toss a copy of VS Code on this machine. &amp;#x200B; Thanks for the response!
The Rust in Action MEAP book from Manning has a bunch of really great projects in it. I've gotten to chapter 6. Some of the projects are creating a GREP program, writing a small Virtual Machine, and making a Command Shell. If web dev stuff is more your speed look into Rocket for making servers or Rqwest for making a web client. 
C# and Java are both really fast in TechEmpower, because cold start time isn’t a consideration.
I can think of a couple areas where people have tried to define some amount of purity like what you're describing. One is `const fn`, some of which just recently landed in stable. Another is [`StableDeref`](https://kimundi.github.io/owning-ref-rs/stable_deref_trait/trait.StableDeref.html), where you try to assert the cases where two separate calls to `deref` are guaranteed to return the same pointer. I think there have been some cases where people wanted to bring the `StableDeref` notion into the language itself (rather than just in that crate), but I don't remember exactly what problems it was solving, and I don't think anything has happened yet.
Not really picky about web vs desktop/embedded. Thanks for the book suggestion! I will probably test the waters out a bit and see how I feel before picking it up, but those projects do sound awesome. Thanks!
I'd second the recommendation for this book. I'm looking forward to the release of the print version. 
Well, that's one of the best READMEs I have ever read. Thanks for taking the time, and I appreciate the subtle tone of humor that interweaves the interesting technical explanations.
The mutpocalypse was in the pre-1.0 days, well before the "inner mutability" mechanism was well understood. We've since stopped thinking of interior mutability as some incredibly obscure hack, and started thinking of it as "how Rust allows for endowing shared references with mutability". &gt; People *really* care about immutability before they really grok Rust. The notion that "shared references are understood to be immutable *by default*" is not exactly hard to grok. What's quite hard to grok is this weird (and arguably obsolete) notion that "immutable references" can somehow be made to work as merely "shared" ones through this hack known as interior mutability.
No problem. Don’t be afraid to ask for more help if stuff goes wrong!
The lessons from the mutapocalypse aren’t really about this kind of thing, IMHO. It’s about people who have no exposure to Rust. “Rust is immutable by default.” is a big draw. And the details are weird enough that it’s totally fine as a first approximation. This is how learning works for most people.
On a side note, [the Haskell source code for tuples](https://github.com/ghc/ghc/blob/master/libraries/ghc-prim/GHC/Tuple.hs) be interesting. &gt; {- Manuel says: Including one more declaration gives a segmentation fault.
Calling shared references 'shared' doesn't really negate the "Rust is immutable by default" message. It just tweaks it slightly into "Rust is immutable by default, and this is exposed via *shared* references - you *can* think of them as immutable." The reason for calling them "shared" can be clarified later.
[This playground link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=00304cbaceb1cd836a2f546ccf34ba81) is a more direct translation from the python code for finding the index of the max value. But this will certainly perform worse than the rust in your blog post, because it requires iterating twice.
https://github.com/burntsushi
For learning new languages, I've used [https://adventofcode.com/](https://adventofcode.com/) in the past. They're not useful int themselves, but are self contained and small.
If just want to get triangles on screen, I would recommend checking out [`glium`](https://crates.rs/crates/glium). It provides a nice abstraction over OpenGL. You can get a triangle onscreen in probably less than 50 LoC. `gfx-hal` is more useful if you need to get absolute maximum performance or want to learn the gritty details of the graphics pipeline.
you can't use `Iterator::max` if the items of the iterator do not implement `Ord`. That said, I still think the code in rust can be written more cleanly than presented in the blog post here.
Some minor nitpicks: In rust the normalize function feels kind of unidiomatic. You could replace the items of the row inplace. There is no reason to create a new Vec for each one. &amp;#x200B; In both the Python and the Rust solution you could use zip instead of enumerate in the inner loop of `calculate_nets`: # Python _net = sum([round(a * b, 4) for a, b in zip(row, unit)]) _nets.append(round(_net, 4)) // Rust let net = unit.iter().zip(row.iter()) .map(|(a, b)| a * b) .sum(); The same goes for your `update_units` function where you could zip over `unit[i]` and `row`.
Why the warning against programming challenges?
That's a really cool thought actually. I completely forgot about \`zip\`!
You can use fold to find the max of f64 by assuming that nans cannot happen.
Ah, good point. I missed that he was operating on floats. 
A word of warning: the plug-ins for VS proper had stopped development a while ago, largely (I think) because the VS Code- and IDEA- based solutions started taking off. I'm not sure how successful you'll be using the plug-ins for VS, but if you have good results, I'd be interested. I certainly prefer VS proper, I just don't have time to maintain a plug-in for it.
i tested on linux but should work on windows as well.
Thanks for the follow up. I [took a shot](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e93305e308b7b0c44f5077da6830a22d) at making it generic. 
yes i was getting this message when i tried to use rust from gentoo ebuild AND put some stuff in language client arguments.
r/playrust
The one thing that I would say is "not idiomatic" about the standard library is how heavily it uses `unsafe`. Your code shouldn't have anywhere near as much `unsafe`, in large part because the standard library already has well-vetted abstractions over all the different kinds of unsafe you may want to use.
for me intellij is just unusable due to performance issues, i'm on old hardware. also atrocious interface.
Doesn’t VS proper also support the LSP nowadays? You might be able to use the RLS with it.
In your result tables, do you have Rust and Python reversed? It looks the inverse of what I see in the graphs. 
thank you for the external tools tip
I'll have to check. I remember some talk around that getting ported back to VS proper. I think it's one of the core features of VS Code. I haven't checked back on VS support in a while, largely because it's support was so lacking. Personally, I use the IDEA rust plugin in IntelliJ, most of the time. The biggest downside there is the lack of live debugging. I think I'd gotten some debugging working with some Frankensteining, but I don't remember what I had done to do that. Something with multiple IDEs
Structs and classes still have room for improvement, because that's the biggest point at which Rust and Python type systems diverge. to make `PyResult&lt;Game&gt;` work, you have to `impl cpython::ToPyObject for Game`. ([api docs](https://dgrunwald.github.io/rust-cpython/doc/cpython/trait.ToPyObject.html)) Unfortunately, that can't currently be done automatically, because there's no One True Way to translate between a type system that uses classical inheritance and one that uses structs and traits. I'd probably do one of the following for implementing `ToPyObject`, depending on the type of struct: 1. Convert to a Python tuple. 2. Use the [`py_class!`](https://dgrunwald.github.io/rust-cpython/doc/cpython/macro.py_class.html) macro to define a Python class which wraps your struct and then have `ToPyObject` work by wrapping it around the given `Game`. Then you could have getter and setter methods on it to manipulate the internal struct from the Python side. (I'm not sure if rust-cpython supports Python properties yet. If it does, you could use those to emulate direct field access.)
Check out the `structopt` crate for arg parsing - it's awesome, and shows how rust can be much more ergonomic with dudicious use of codegen.
I should mention it in the blog the two assumptions: &amp;#x200B; \- Lists will never be empty \- There wouldn't be any NaN behavior
I actually prefer the interface to eclipses
Neat! Unfortunately the initial snippet posted didn't handle the case where the first item of the slice was `NAN`. I adjusted it, but this version can not be generalized easily because it deals with `NAN` explicitly.
That's true. Your statement is underlined by the strange and complicated bugs that are found from time to time... But the APIs are very well designed and always an inspiration for me. Apart from that, BurntSushi knows their craft! Ripgrep is very well written.
Nice catch, thank you! I updated it. :-)
well eclipse is pretty much malware
An example would be [noisy_float](https://crates.io/crates/noisy_float), which panics on occurrence of illegal values such as `NAN`.
I used it for years just fine. It's not so bad if you have a decent computer. 
Not when they’re on their own subnet and subject to a strict firewall!
I made a crate a while ago called `newtype_array`, that allows you to generate fixed-length arrays longer than 32 elements that implement all the traits you expect. I meant it to be a temporary solution until const generics lands
Wow! I have seen several of those projects around and heard them spoken highly of, had no idea they were written in Rust. Nice. The code is indeed very clean and well written, just what I was looking for. 
That all sounds great! I’m going to finish up the HTTP API portion in the next couple of days, and then let’s plan to chat about future plans. :)
Hey all, I thought you'd enjoy my Rust oriented example of how to do a very basic virtual DOM. Everything is done from scratch, so I hope it's a great way to learn a very basic way to do this and some challenges of WASM-JS communication.
Not long ago exercism.io sent out an email saying that they had a lot of users but not that many moderators, so it was hard to keep up with all the tasks to review. The reviews are done by unpaid volunteers, so I would think that you have to take some weeks into account when waiting for review. All the reviews I've gotten have been excellent and I am so grateful for the amazing feedback mentors have given me. I would think that during Christmas you should probably expect a longer delay as the mentors have vacation and probably prioritizes time with family and close ones. It is great that you're learning rust and I fully understand it might be frustrating to wait a long time for feedback. My suggestion is try some of the bonus tasks or perhaps start a miniature project. Feel free to ask any questions here or other places if you meet any roadblocks. Welcome to the community! 
Thank you, just what I needed. I am still pretty confused on what to do with the kilometers of code that bindgen spews out for the header files. I was thinking to edit it down, and just keep the more salient bits.
Thank you for your reply, makes sense. Cheers!
Things to add: Attributes and events.
I use it in a web environment w/o node, to my knowledge wasm-pack doesn't support building w/o modules so I developed a short build script: cargo build --release --target wasm32-unknown-unknown --features "wee_alloc" wasm-bindgen --no-modules --no-typescript --out-dir pkg target/wasm32-unknown-unknown/release/pathfinder_rs.wasm wasm-gc pkg/pathfinder_rs_bg.wasm -o pkg/pathfinder_rs_bg_gc.wasm ../../WebAssembly/binaryen/bin/wasm-opt pkg/pathfinder_rs_bg_gc.wasm -O4 -o pkg/pathfinder_rs_bg_gc_op.wasm If you want debug symbols and all, remove the wasm-gc and wasm-opt calls
That's next up on my experimenting :)
I like looking through the Rust compiler's source code when I want to implement something similar that they do. For example: I am writing a toy programming language, and I want to have a custom string implementation. The first place I looked was the standard library's String, to see what `struct String` looked like. Spoiler alert: [it's just backed by a `Vec&lt;u8&gt;`](https://github.com/rust-lang/rust/blob/6f288ea33712b34c8eabcd57bb10607ab01f0cdb/src/liballoc/string.rs#L294). Simple is indeed better than complex.
Thanks for posting this! Interesting to read through the code I do agree that the main trade off here is speed vs ease of use. It’s kind of shocking how much faster Rust is - but even acknowledging that there’s no way I’d try to do any serious ML in Rust, if only because it’d be such a pain to write! What inspired this?
Another place you can look at us the compiler itself. You don't have the advantage of having a well known entry point as with std, but the compiler code is for the most part very readable and we'll organized. My preferred way to introduce people to the compiler is to try and fix a diagnostic bug, as that way you have something to grep for. There's also [the Forge](forge.rust-lang.org) with documentation on getting around `rustc`.
Here are some idiomatic Python changes, which should also improve performance: def generate_random_units(col_len: int, row_len: int) -&gt; list: return [ [round(random.uniform(0.0, 1.0), 4) for _ in range(0, col_len)] \ for _ in range(0, row_len) ] def calculate_nets(row, units): return [ round(sum(round(r * u, 4) for r, u in zip(row, unit)), 4) \ for unit in units ] def main(): ... with open(args.csv_file, 'r') as csv_file: unnormalised_dataset = [ [float(x) for x in line.split(',')] for line in csv_file ] In fact, using numpy for matrix manipulations will both significantly simplify the code and also result in superb performance.
I think you're using your kappa incorrectly. You don't want the key length that has the largest kappa value, but the key length that has the kappa value closest to that of the target character distribution.
How do you import de Serialize and Deserialize macros then?
Nice post! :) For testing -sys crates you might want to take a look at [ctest](https://crates.io/crates/ctest), and it might make sense to mention [gir](https://github.com/gtk-rs/gir/) instead of bindgen/etc for GObject/GLib-based C libraries (and it can also crate safe wrappers around the -sys bindings to some degree).
`use serde::{Serialize, Deserialize};`
Also `time = "0.1.12"` is `time = "^0.1.12"`, not `time = "=0.1.12"`, which is clear in the [documentation](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-cratesio), but non-obvious when reading toml files imo.
Last time I skimmed serde-json I was quite impressed. The fastest JSON parser in the world written in 100% safe Rust.
In my informal testing a Rust hello world Lambda is ~40-50ms cold start.
Why does this only work in the 2018 edition?
And the relevant Rust idiomatic implementations: fn normalise(rows: &amp;mut [Vec&lt;f32&gt;]) { for row in &amp;mut rows { let vector_length = row.iter().map(|x| x * x).sum().sqrt(); for x in &amp;mut row { *x /= vector_length; } } } fn generate_random_units(col_len: usize, row_len: usize) -&gt; Vec&lt;Vec&lt;f32&gt;&gt; { let mut rng = rand::thread_rng(); std::iter::repeat_with(|| Standard.sample_iter(&amp;mut rng).take(col_len).collect()) .take(row_len) .collect() } fn calculate_nets(row: &amp;[f32], units: &amp;[Vec&lt;f32&gt;]) -&gt; Vec&lt;f32&gt; { units .iter() .map(|unit| { row .iter() .zip(unit.iter()) .map(|r, u| r * u) .sum() }) .collect() } fn main() { ... let mut dataset: Vec&lt;Vec&lt;f32&gt;&gt; = reader .records() .map(|result| { result.unwrap().iter().map(|x| x.parse::&lt;f32&gt;().unwrap()).collect() }) .collect(); ... let mut units = generate_random_units(__unit_length, neurons); ... for unit in &amp;units { println!("{:?}", unit); } ... for i in 1..=epoch { } Notes: * There is no need in passing usize (primitive types) by reference * I find for\_each to be more verbose than a simple \`for\`-loop * In most of the cases, there is a way to avoid manual \`push\`-ing into vectors by mapping/filtering &amp; collecting
It changes how macros can be used and imported into scope.
I agree. Rust is brutal. So many null pointer exceptions, invalid memory dereferences and index bound errors slain by the terror of `borrowck`.
[https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html](https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html) Maybe this one
It is also useful for abstracting over multiple graphics APIs.
It works fine in 2015, too.
Baffling.
Three. That's also the maximum.
As recent actix is built on top of tokio, you are free to return a `Box&lt;Future&lt;...&gt;&gt;` from a handler and the result will automatically be waited for. There's even an alias type https://docs.rs/actix-web/0.7.15/actix_web/type.FutureResponse.html to help. Just do whatever combinations you want and return a future wrapped around what you were going to return before. It'll "just work" and the thing receiving the result won't know it comes from a future at all.
Mostly because the challenges require very basic features of the language. You would do fine without knowing much of the language. Those challenges make us think of the solution in a language agnostic way. But if you are building an application, you would think about modules, external crates to use, may be generics and other features. This is my reasoning YMMV. 
Even simpler than `glium` is `kiss3d`: https://github.com/sebcrozet/kiss3d which I would strongly recommend as a minimal "I just want stuff on screen" library.
Wow that is perfect, thanks
Thank you! This was mostly a university assignment (the Python part) and I was genuinely just curious to see how Rust would look in terms of code and perform. 
We've been meaning to do some more formal benchmarking of this. I'm curious if you can share the code you're using to benchmark cold-starts on Lambda.
I [fully acknowledge](https://twitter.com/Sunjay03/status/1076979676235497472) that I might end up being the only person using this crate, but I spent many days thoroughly documenting and testing it anyway. :D The documentation should fully explain the purpose of this crate and what it provides. Feel free to ask me any questions!
One thing I haven't found yet is how to import the 'serde' macro, eg `#[serde(rename_all = "PascalCase")]`, where is that serde macro located?
It's likely you can use [whitelisting](https://github.com/rust-lang/rust-bindgen/blob/master/book/src/whitelisting.md) to slim it down.
There is none -- that's an attribute recognized by `#[derive(Deserialize, Serialize)]`.
That isn't actually an attribute macro. It's just arbitrary syntax parsed out by the derive implementation. If the derive fails, the compiler doesn't know to ignore the attribute and so it raises an error. In 2018 you import derives just like the traits themselves. So make sure you `use serde::{Serialize, Deserialize}` or `serde_derive::{Serialize, Deserialize}` if you aren't using the `derive` feature on `serde`
Rust string literals are not null terminated, so your C code ends reading past the buffer given to it and making your program undefined.
Custom derives can signal to the compiler which custom attributes it uses. Those are visible to the custom derive. So the serde drive macros (both Serialive and Deserialize), in its source code, tells the compiler that it claims the serde attribue.
Make sure you have the 'derive' feature enabled for serde in your cargo.toml. I didn't, and the derives were working (or at least compiling), but those attributes weren't...
Witty lol. But you forgot colors ;)
Looks just what I was looking for
Thank you! Of course that's the problem. I'll take this as another reminder for why we use Rust not C :)
Oh interesting, I didn't know proc macros could do that. (cc /u/doctorocclusion /u/orangepantsman /u/nicoburns ) If I remove my `#[macro_use] extern crate serde;` and find and replace all `Serialize` by `serde::Serialize` (so the final result is a `#[cfg_attr(feature = "serde", derive(serde::Serialize))]`) the compiler still complains about serde being an unknown attribute. (for reference: [my code](https://github.com/CasualX/pelite/blob/master/src/lib.rs#L17-L20)) Something I'm doing wrong? Paths not working in derive position?
most crates that i have used on [crates.io](https://crates.io) use [carat matching](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-cratesio) and don't upload the lock file, so, i don't think this is the case.
I'm not sure...AFAIK macros must be imported before use. I don't have access to a dev machine right now -- otherwise I'd have a definitive answer for you!
Yeah I think I misunderstood what the comment I was replying to was trying to say. You're completely right, especially in the case of when every variant has those fields.
Paths to macros, including derive macros, must still only be a single word. You'll have to `use serde::Serialize;` somewhere and then use `derive(Serialize)`. You'll also need to do `#[cfg_attr(feature = "serde", serde(untagged)]` for each serde attribute.
Much to my surprise, this seems to work. [playground link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b8343aef5de5284b621fd6a71088cbc1) Do you have `edition = 2018` set?
No, they do not. They can be executed on firecracker or legacy. 
okay, I don't care *why it errors* (or why it *should* error), I'm saying there should be a way to make it *not* error. There should be a way to abstract it over the lifetime argument to Cow in *both* cases. There's no unsoundness here. There may be a bug, but it's insignificant, and I'd vote for keeping it.
Sure do! [link](https://github.com/CasualX/pelite/blob/features/serde2018/Cargo.toml) I am using the new path resolution so I don't have to import them, because these imports would have to be cfg'd I found it easier to just reference `serde::Serialize` directly. You can follow along with the errors [in the PR](https://github.com/CasualX/pelite/pull/131) (see the appveyor CI links, ignore the travis-ci as they don't check with the right features enabled: [link](https://ci.appveyor.com/project/Casper/pelite/builds/21208868/job/yg0oll3apndi6mut#L125)). (cc /u/ErichDonGubler /u/isHavvy ) If I try by importing `Serialize` directly instead of using `serde::Serialize`, I get the same error. This is on latest Rust stable, 1.31.1
This works in 2015 edition too, though. 2018 just removes the need for `extern crate` too.
I've been reading over the code of [jordanbray/chess](https://github.com/jordanbray/chess) as I start to implement a chess engine. It's very much **not** idiomatic rust, but I'm very much been enjoying the style, it seems to be thoughtfully implemented and generally good code. Once/if I get a bit further along with my engine we'll have to see if my thoughts change.
~~Note~~Shameless self-promotion: i wrote a crate [null-terminated](https://docs.rs/null-terminated/) for dealing with null-terminated strings, which defines a macro [str0_utf8](https://docs.rs/null-terminated/0.3.6/null_terminated/macro.str0_utf8.html) for writing null-terminated string literals. (You can also do so by appending "\0" to the literal, but `str0_utf8` makes sure you won't forget.) 
It's not a Rust 1.30 thing. This has worked for a very long time. It's the same reason you don't need a crate other than Diesel to use our derives
Off the top of my head, I believe this has been true since 1.21.
They're powerful meta-programming tools. Some uses: -Functions that accept arbitrary arguments -Make your own syntax/sub-language. (Want to implement JSX in Rust? Macro. Don't like how there's no Hashmap literal? Make one). Making an API and think Rust's too verbose for your use-case?... -Create an arbitrary number of structs/enums/funcs etc that follow a pattern. -Lots more.
Wrong rust
wat?
I think I know what game I got banned from nerd 
I have been wrongly imprisoned please donate to my gofundme and pay me restitution 
r/playrust, not r/rust. This sub is for a programming language called Rust.
Thank you. Do you have any resources or examples? 
Donate to my patrdon ("here")
send your ____
[The Little Book of Rust Macros](https://danielkeep.github.io/tlborm/book/index.html) [Rust book](https://doc.rust-lang.org/book/ch19-06-macros.html) Neither of these are as in-depth as I'd like, and only cover declarative macros. There's a more powerful form I don't understand called proc macros. The only guide I've found was just published, and is more broad overview than tutorial: [Proc macros in Rust 2018](https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html) 
https://www.areweblessedyet.com
As I said, my "methodology" has been triggering the Hello World lambda occasionally I built after the launch as well as a slightly more complicated lambda (who's code I'm happy to share offline, because it's an implementation of a tech test we've been working on for hiring :-) that takes a Base64 encoded message \`{ "message": "blahblahblah" } which is essentially a fancy CSV file. &amp;#x200B; tbh, I think a combination of an Alexa skill Lambda might be ideal for testing b/c of the largish JSON &amp; serialization of request response :-)
If you are on Windows, just install WSL. Then you can use (or not) all of the bash-y goodness in Ubuntu whenever you like.
oh this might be a cargo bug, it sounds similar at to * https://github.com/rust-lang/cargo/issues/4866 * https://github.com/rust-lang/cargo/issues/4664 while not _completely_ identical they both relate to cargo improperly handling user specified features vs default features. 
If you are worried about performance or memory overhead, don't use cons-style lists in Rust. 
Yeah just looking at your Cargo.toml / .lock it very much looks like memchr is the problem. All kinds of std dependencies in your Cargo.lock depend on that, so it very likely depends on std too.
I don’t think they forgot colors. You shouldn’t be using mesh data to represent colors. Use three lines and use a fragment shader to color. You should probably finish reading the tutorial...
That seems pretty useful, I'll have to remember it when I get back to working on game logic! One suggestion: the first block of code in your crate-level documentation that actually does anything is an example of how to write code *without* your crate. If you're just skimming, this is pretty confusing; maybe lead with the basic use example, then contrast it with the naive equivalent afterwards?
I just ran into this the other day and was *very* confused -- in my case I was actually unable to use certain macros because rust couldn't find them deep inside a library module. There is [an official documentation page on this](https://rust-lang-nursery.github.io/edition-guide/rust-2018/macros/macro-changes.html) which I found very useful. I haven't actually needed to add the `features` option to `Cargo.toml`. There's also [a Rust blog post](https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html) on the subject of macros that was an informative read. After the initial confusion and some compiler battles I am pretty excited, this is *much* cleaner than the `#[macro_use]` (and double `serde`-related library import). 
Glad you find it useful! Let me know if you have any questions. Regarding your suggestion: If I'm not mistaken, the first code block in the documentation*is* a basic use example. I definitely agree that it could be more skimable. I'll try to make some edits to make it really clear that the example is *without* my crate so there isn't anymore confusion. Thanks!
\&gt; Everything is done from scratch &amp;#x200B; I red that as everything is done in Scratch and I was very confused.
Maybe don't cheat at video games? It's also pretty insensitive to compare being banned from a game with going to prison.
[removed]
Please, use indentation to insert code, not tripple backticks.
I didn't know qt all. Is there a source on it being fastest? Is it for reading or writing? How about msgpack?
Consider using `std::ffi::CStr` to deal with ffi instead of raw pointer cast. It will remind you that rust string must be nullterminated via conversion method names.
This is exactly what I was looking for.
Yes, Ho do I import the corresponding traits then?
As well as need in separate dependency line for the derive crate.
Thank you! I will give them a read.
Problem with your implementation of linked list is that it cannot be empty.
https://github.com/rust-bitcoin
Good point. https://github.com/serde-rs/serde/issues/1441
"OOP with leveraging struct, impl and traits in Rust" Oof, please no.
The attraction from the crypto crowd is probably going to be in aggregate the worst effect of Rust's adoption. I don't even want to think about how many countries worth of energy consumption Rust is helping to waste.
Great stuff! Thanks for the in depth walkthrough in the readme. I wonder if and how much faster it could be than a DOM based react app. I suppose there's a big opportunity to keep scrolling offsets in react state and be able to access it without forcing a style recalculation. It's like nobody can really make good apps today that modify/observe scroll position, because there are so many perf cliffs and problems. Also curious about event handling and inputs. React already has its own system abstracted from the dom, maybe you can fit that interface with this project? Minus the nativeEvent stuff of course. Last thing is I see you're using hooks, but they currently don't support an early bail out from rendering, like shouldComponentUpdate does today. Would caching sub trees of components translate well to caching display lists for webrender?
I take it you were not allowed to use numpy for the numerics? I'd expect execution time a fair bit closer to rust if you did.
https://github.com/iotaledger/MAM
Hey! I'm getting paid for C# since 2013 and I defenitely use VS all this time so I could be handy here ;) Back to your questions: 1. Windows development is completely fine unless you try to build some wrapper around C code. Rust community is a bit discriminant to Windows users. They could often suggest you some linux tools if you report a problem, but once you say "hey, I'm running on Windows" they become silent, and only tumbleweed remains in the question topic. But if you don't deal with FFI (and have no FFI dependencies, like libssl, for example) you're golden. I have written a whole web-server with bot web hook in windows and never had any problems. 2. VSCode + msvc toolchain / IDEA (or CLion, if you can afford it, since it's the only way to debug) + gnu toolchain. Quick tip: ***do not*** use VS as your IDE just because it's convinient and habitually. It will be pain. Choose one of above and stick with it. I personally use CLion since RLS is very unstable and lack much of basic features. 3. I'm participating in one chat in my messendger where people send memes and other funny pictures. The problem was that sometimes users didn't read the chat and resend same images over and over again. It wasn't good because people was tired of repetitions. So it gave me an idea to write a bot, that analyses all images and detects if image was previosly sent by someone. I have spend 8 months or something, 7 of them I was writting `cv-rs` crate to be able to analyze image in smart way. I tried SURF/SIFT/... analysis, several techniques, fighted FFI and cross-platform support and finally fot it. So the main idea here is like with any of your programs you could want to write: identify any problem you are tired in real life of, and fix it with the code. Regards ;)
How does it help you having IDE support?
Most definitely would be closer. Your assumption is correct however. I wanted to stick to std lib for two reasons: &amp;#x200B; \- Legibility \- Dependency issue(s) &amp;#x200B; Which is why I opted for little to no external dependencies in both scenarios (Rust just uses \`rand\` crate). Hope this answers your question :-)
Just looked at this now and looks \_very\_ promising. Thanks for the suggestion.
Yes, thanks. Also, it's always fun to implement something from scratch. 
Interesting, it looks like `newtype_array` solves a different, but related problem. While I was totally focused on the construction of large arrays, this crate provides trait implementations for them. For some use cases, a person might need both the techniques in this blog as well as `newtype_array`. Thanks for sharing. 
This is because features are additive, which means that throughout your *entire* dependency tree *and* every possible dependency(including dev- and build- ones), if any crate specifies a feature and you use that crate, you're stuck with that feature. There are several longstanding issues on this, [4866](https://github.com/rust-lang/cargo/issues/4866), [4664](https://github.com/rust-lang/cargo/issues/4664), and for your case specifically [5730](https://github.com/rust-lang/cargo/issues/5730), and more i believe.
Forgive me, but no. That's just `serde` re-exporting `serde_derive::*` when the "derive" feature is enabled. Even before `use` was usable on macros, you could always do `#[macro_use] extern crate serde;` and depend on serde with `features = ["derive"]` instead of `serde_derive` directly. It has nothing to do with either the macro use statement nor with rust 2018. See this commit, which added this feature nealy 2 years ago: https://github.com/serde-rs/serde/commit/13886435a600bd049e4e9db6e22fac6a0113784a.
I swear I thought of this in advance, and am not giving this response just to save face: I'm using it incorrectly \*on purpose\*. &amp;#x200B; Right now the algorithm has an implicit assumption that the ciphertext has a uniform distribution (see issue #2). Given that assumption, the scenario where an incorrect key length somehow arranges for a large kappa value by virtue of anything \*other\* than alignment with the original key length intuitively seems like a "lightning strikes" scenario, so in line with that Alexander Pope quote about places where angels fear to tread, I chose to not worry about it (and, indeed, I haven't encountered any such pathologies since introducing the confidence interval calculation). &amp;#x200B; But, you know, if two methods are effectively equivalent, and one of them is more pedagogically correct, it makes sense to use that latter one, if only not to confuse people on reddit. [Your comment is now issue #5.](https://github.com/BenH11235/XORcism/issues/5)
Cool, thanks, did not know that!
It’s because `Rc&lt;T&gt;` is essentially just a wrapper around a pointer `&amp;T` and thus you can convert an `Rc&lt;T&gt;` to `Rc&lt;dyn Trait&gt;` just like you can convert `&amp;T‘ to `&amp;dyn Trait‘. `RefCell`on the other hand is a wrapper around ‘T‘ with some additional metadata to provide interior mutability. You cannot convert from ‘RefCell&lt;T&gt;‘ to ‘RefCell&lt;dyn Trait&gt;` just like you cannot go from a regualr ‘T‘ to ‘dyn Trait‘. You can however create a `Rc&lt;RefCell&lt;T&gt;&gt;‘ and convert it to ‘Rc&lt;RefCell&lt;dyn T&gt;&gt;` (a common pattern actually).
I think that even if you need maximum performance you'd start learning new thing with simple triangle.
Isn't holochain written in Rust too?
Hey, did you end up doing that?
It's crazy how much I relate to this. 
Iirc, they get imported as well, [with the same statement](https://github.com/serde-rs/serde/issues/1441#issuecomment-445511681).
Zcash also has a number of core libraries in Rust: https://github.com/zkcrypto/
:) I do like the 2018 edition but I think it's even cooler how much isn't special to it. Rust 2015 just keeps working and has many (if not all) of the improvements in it too.
`dyn Trait` means "I have a value of an unknown type that implements `Trait`". Because the type is unknown, so is the size that value will take in memory. Since the compiler needs to know the exact arrangement of the variables in each stack frame in order to access them, you can't put types of unknown size directly on the stack. This means you can only even have a reference to these values. So, if you can only have a reference to the value, where is the actual value? There are two possibilities: 1. On the stack, somewhere where it's not `dyn`. For example: trait Foo { } struct Bar; impl Foo for Bar {} fn baz(foo: &amp;dyn Foo) { } fn qux() { let bar = Bar; baz(&amp;bar); } Here, `bar` inside `qux` has a concrete type - `Bar` - but when we pass it to `baz` it becomes a `&amp;dyn Foo` - a dynamic type with unknown size. `baz` does not know the true size of the value, and it doesn't have to - because `qux` is the owner responsible for storing and freeing it. 2. On the heap, using a container type like `Box` or `Rc` that uses `unsafe` code behind the scenes to manage the allocation and freeing of the value. So, `Rc` can have a `dyn Trait` because like `Box` it stores the value elsewhere and only holds a reference to it internally. `RefCell`, on the other hand, holds the value on the stack, and only deals with mutability: use std::cell::RefCell; fn foo(a: &amp;RefCell&lt;i32&gt;, b:&amp;RefCell&lt;i32&gt;) { *a.borrow_mut() += 1; *b.borrow_mut() += 1; } fn main() { let num = RefCell::new(1); foo(&amp;num, &amp;num); assert!(*num.borrow() == 3); } The value is wrapped with `RefCell` to allow multiple "mutable" borrows, but it's still on the stack, `main` is still the owner, and therefore its size must be known at compile-time and it can't be a `dyn trait`. 
"How to be an intermediate C# programmer in Rust in one day"
To add to the useful resources that other have posted, I'd like to mention that as a beginner to Rust you may end up _using_ macros often (`println!`, `format!`, etc) but it doesn't seem likely that you'll need to define your own any time soon. I think the simplest macro I needed was for populating fixed length arrays with a non-copy type i.e. a shortcut to writing `val x: [Foo; 8] = [Foo::new(), Foo::new(), ...]` but that now exists in crates like this one anyway: https://docs.rs/array-macro/1.0.2/array_macro/
It's not so much that the wrong key length might give a large kappa value, as that if you compare each kappa with the expected kappa you can know if that key length is correct, i.e. k or some n*k, or not. The smallest correct key length should be the one you're looking for.
`Rc` and `RefCell` are orthogonal to each other, neither can do what the other does. * `Rc` is a heap allocated pointer that allows shared ownership to the data but only provides `&amp;T` access (implemented with a reference counter). * `RefCell` is a plain struct without a pointer indirection that allows turning `&amp;Self` access into guarded `&amp;mut T` access. 
Wrong subreddit. :) -&gt; /r/playrust 
Since when did the official terminology switch back to "immutable reference"? I distinctly remember that we started using `shared reference` vs `mutable reference` as the terminology pair after the whole mutocalypse deal had settled.
https://github.com/solana-labs/solana
In all but one specific case, if you are defining lifetime parameters, you are always defining generic ones. A function like `fn foo(&amp;A)`, which is ellided short for `fn foo&lt;'a&gt;(&amp;'a A)`, means "for all lifetimes 'a, the function is defined as such...".
Okay, so basically they are insufficient to get a good feel for the uniqueness of a particular language. Thanks, good to keep in mind.
**Reminder**: criticism is at its best when substantiated with facts and alternatives presented. --- With regard to the specific criticism about crypto-currencies wasting energy, this is a known issue of *some* crypto-currencies, and alternative models are being worked on based on other costs than CPU time (and thus energy) such as storage. As such, it's important to remember that there is no equivalence between crypto-currency and energy consumption; it's an accident, to an extent, that the current crop of popular crypto-currencies happen to consume a lot of energy.
What I mean is that you're probably not going to see a kappa value larger than the expected value anyway, so "look for the expected value" and "look for the largest value" resolve to the same answer. But I agree that "look for the largest value" is probably not the Right Thing To Do(tm), just a easier hack that happens to give the correct answer in practice.
The format you're proposing is pretty similar to [netstrings](https://en.wikipedia.org/wiki/Netstring). Another popular alternative is the json-lines format, where individual json documents are separated by linebreaks.
Writing a wrapper for the [CLIPS](clipsrules.net) rules engine. They’re on crates.io as clips-sys and clips. I’m using the rules engine to implement the rules of a collectible card game. So far it’s a pretty nice fit. 
Simply put, macros are a mechanism to generate code automatically during compilation, while also allowing parameters to customize what individual code should get generated. For example, invoking the std macro `vec![1, 2]` would generate code similar to this: let mut tmp = Vec::new(); tmp.push(1); tmp.push(2);
For `default-features = false` to do anything, **every single** crate that depends on that library needs to specify it. For popular crates that typically have many dependents in the same application, this means that default features are close to impossible to disable. If you’re designing a library and want to make something optional, consider **not** making it default or it might end up close to non-optional.
In other words, you can’t turn off default features. You can only choose not to request them yourself.
I had this vague idea recently to write a bloom filter to cut down on the data hitting the database by removing invalid entries, and to prove it out I wrote a little POC, a bloom filter served over a rest API https://github.com/abhijat/invalidator. It needs some more work especially in terms of test cases but it is minimally functional. I've always wanted to work on distributed systems so making the filter distributed across multiple nodes might also be a next step. Also wrote a little medium post to work through some of the reasoning behind it [here](https://medium.com/@malviya.abhijat/filtering-data-with-bloom-filters-and-rust-c92563bfc0ce). I haven't written any blog posts before so kind of new to that area. Any suggestions towards improvements (both writing and code) that I can make are most welcome.
`RefCell` does not heap-allocate - it stores the inner type inline. `dyn Trait` types are unsized, meaning they must be behind some kind of pointer indirection (reference, heap allocation, etc.) to exist. Since `RefCell` does not have any of this indirection, `RefCell&lt;dyn Trait&gt;` is also unsized, and cannot exist on the stack.
```rust || { assert!(self.triggered); panic!("if you are not paying their bills, how can you tell their consumption (of any resources) is a waste?") } ``` There is a whole discussion on importance of cryptocurrency in one of those listed (Grin), I invite you to read, study and participate: [https://www.grin-forum.org/t/emmission-rate-of-grin/171](https://www.grin-forum.org/t/emmission-rate-of-grin/171)
Modern cryptos are making the move to proof-of-stake algorithms, which do not require large amounts of energy. Besides, even if you think crypto as a product is destined to fail, it led to major advances in decentralized exchange of information. While it's fair to not be a fan, cryptocurrencies certainly don't just waste electricity.
There's also [lighthouse](https://github.com/sigp/lighthouse), a client for Ethereum 2.0
Rewrote my [named-args proc-macro](https://github.com/djmcgill/named_args/blob/master/src/main.rs) to use \`syn\` and \`quote\` instead of messing around with the \`TokenStream\` myself. Next up: better support for references, generics, and then also make a macro to improve the call syntax, and then also add support for default arguments. &amp;#x200B; Additionally I plan to hook up my arduino zero (SAMD21) to a gps chip.
Which iterator functions are not zero-cost? Functions like `.chain()` incur [additional performance cost](https://www.reddit.com/r/rust/comments/5ez38g/rusts_iterators_are_inefficient_and_heres_what_we/dag7rnb/) unless the `.for_each()` function is used in conjunction. Similarly, [a loop over all pairs](https://gist.github.com/rust-play/4aa893276a6e723fb2035c8a1e89b238) using `.flat_map()` is 15% slower than traditional for loops on my computer. Is there a resource listing all functions that break the zero-cost principle?
Fun fact: years ago I pulled out all the stops on [microoptimizing an AES implementation in Python](https://github.com/serprex/aespython), which has since been used as the fallback in [btcrecover](https://github.com/gurnec/btcrecover) If I disapproved of "wasted energy", I'd have to decide whether to feel guilty of supporting AES-in-Python, or feel better that at least they're not using caller9's less efficient implementation. In reality, Andreas captures it perfectly when he says "But Christmas lights are pretty!"
Yeah the claim doesn't seem right. Here's [some benchmarks](https://github.com/serde-rs/json-benchmark). If I would have to choose, I would say that [RapidJSON as the fastest JSON library in the world](https://github.com/miloyip/nativejson-benchmark).
It's generated using bindgen. My idea for the library was to make this purely generated, then build higher level abstractions in a different crate.
Apologies, it was copied from Discord. What's the difference?
I can't wait until we release a Rust version with a description as explosive as this! (/r/playrust)
I wanna give a quiet little shout-out to https://github.com/MaiaVictor/Symmetric-Interaction-Calculus?files=1 It's just one of the coolest ideas in computation I've personally come across. It re-imagines the lambda calculus without garbage collection. It's beautiful and can (in theory) be executed asynchronously or in parallel. It's just a beautiful concept that fits like a glove into rusts linear type system.
&gt; alternative models are being worked on And zero of them are proven to work. &gt; alternatives presented [There's no alternative to cryptocurrency… *for criminal payments*](https://youtu.be/xCHab0dNnj4?t=1057). (Please watch the whole talk, it explains everything wrong with cryptocurrency as a concept.)
I have added generics to my programming language tox over the weekend but I need to fix some bugs with the implementation and readd the typechecking of closures and add monomorphisation. I'm also starting to improve my Java skills as I 've got to use in intro to OOP.
Update: it got merged!
serde parsing to struct (which is equivalent to what rapidjson does) is faster than rapidjson-clang in all benchmarks and faster than rapidjson-gcc in all but one benchmark.
I'd prefer an open-source alternative to Sciter for this, like (I think) Servo.
The repository is far from perfect and I've not yet found the best approach for many cases. The 'default' command line option is served when there is no file found from the root directory provided. If the default file doesn't exist, the server will respond with 'internal server error' and in memory serving will panic.
It's an exciting idea, I hope I can help.
After re-reading your comments and his post multiple times … I think he means lines of code … not graphical lines that make up the triangle … 😂😁🙈
Mostly a bunch of miscellaneous things that I've been putting off for a while, like fixing minor bugs in my RSS reader server process. Also reading a book on Bayesian statistics and trying to think of uses for a new computer I bought last week. I'll probably set it up as a GPU-enabled CI build machine for RustaCUDA, but that leaves a lot of cycles unused so I'd like to run other stuff on there as well. On the open-source front, working on some internal refactoring for Criterion.rs that should enable some improvements to the reports. Also handling issues and code reviews for RustaCUDA, which seems to have attracted more active contributors than Criterion.rs.
Please read subreddit description before posting.
I've started to learn Rust this December and right now I'm in this very uncomfortable spot where I've gotten used to the basics of the language, learned how to read the documentation, played with some crates and begin to be dissatisfied with my toy programs. So I want to begin to work on something actually useful and took a couple of hours yesterday to shop around for open source projects that I may contribute to. That was an overwhelming experience... So, what I'd like to read, is some advice as how to go from knowing the basics of Rust to being able to contribute to open source projects as someone who has never done any professional coding. If it's relevant: I have advanced degrees in mathematics and theoretical computer science, just very little real-life experience coding.
Any plans to add fastcgi support?
lol
&gt; You can however create a Rc&lt;RefCell&lt;T&gt;&gt; and convert it to Rc&lt;RefCell&lt;dyn T&gt;&gt; (a common pattern actually). Silly question, but how do you do that conversion?
This is a rather unfortunate solution, but right now I'm relying on dropping the `Sender`s. It works and the messages still flush (even if they haven't flushed when I drop the `Sender`s), but it's not optimal for everything I'm trying to do.
It's hard to estimate but I think it could be (in future) way faster (like 10x or more) because it's intentionally taking shortcuts in the scope. The web platform cannot do the same without breaking existing web pages. &amp;#x200B; It's not meant to be 100% compatible with react-native either. At this point I'm really just exploring what is possible and how far it can take me. &amp;#x200B; Events) I'm still thinking about it, I have few ideas but nothing is set in stone yet. For example I'm not sure if there is going to be any event bubbling at all - I think it can be replaced with Context.Provide and useContext() but I have to validate this idea first. &amp;#x200B; Hooks) not sure what you mean or if that answers your question but I expect people to use mobx/redux and everything is made in a way that if there are few changes in a tree (or that subtree does not need an update) there should be minimum rendering work. Or at least it's designed in a way that this will be possible in the future. &amp;#x200B; Scrolling) yeah, this is tricky, do you have any specific use-case where you need to read/mutate scroll offset? Again, not sure if this is what you've been asking but scrolling in webrender is very fast if there was no modification to the scene (if you're just scrolling). It keeps some state between frames.
It's an implicit type coercion (assuming you fix the typo dyn T -&gt; dyn Trait).
I followed all your advices, and I'm creating a crate of binding for python, so I choose to use the pyo3, because of the nicer api. ( I assume you have a big knowledge in both rust and cpython that I don't have.) I facing a little issue, I have my struct `Game` in my base crate. So I choose to create an `IGame{game:Game}` to glue python and rust. So I used `#[pyclass]` like the doc for generating the impl traits. but there is this error `the trait \`pyo3::PyTypeInfo\` is not implemented for \`game::IGame\`` I have to manually implement the trait ? It's the purpose of `#[pyclass]` no ? What I'm doing wrong thank you so much 
Sometime before 1.0, I don't remember exactly. We needed something that could be used consistently throughout docs and error messages, and that's what was settled on.
Triple backticks formatting is not supported on old reddit and also in some apps. 
I don't believe there is, because it's not necessarily universal; optimizations can apply or not apply in certain circumstances, and optimizers can have bugs.
I'm genuinely curious, how would fastcgi help? Isn't it for integrating with web applications?
To add onto /u/somebodddy's excellent answer here: when reading the API docs of any struct or enum that acts as a "wrapper", the word to grep for (and to examine all occurrences of, not merely the first one) is "`Sized`". To be more specific: you can tell whether or not this wrapper, like Rc, will work with `dyn Trait`, by checking to see how this wrapper constrains its inner type-variable(s) on the `Sized` marker-trait. A `T: ?Sized` constraint on a type-variable means that unsized types (eg `dyn Trait`) are valid instantiations of the type-variable, whereas a `T: Sized` constraint, or no constraint, means they aren't. This of course can happen at either the data-structure level or the `impl`-block level - a type might be instantiable with an unsized type, but in that case might not have all of its methods available because one or more impl-blocks' constraints weren't satisfied.
More advent of code probably. My game written in rust is pretty much done. I have some music to complete for it, which i'll need to write a simple music manager for in the game, but that'll probably happen in January.
Hey, we should talk - I work on the rubber duck crate ([https://crates.io/crates/rubber\_duck](https://crates.io/crates/rubber_duck)). It seems like it does the same thing you're working on. Maybe we should collaborate on a single crate? If you don't want to collaborate, here are some things I found very useful: * Structs, functions and macros live in different namespaces. That means with a single import, you can import a struct, a function and a macro that all have the same name. This is very useful for allowing things to be imported - a user won't have to remember to import things other than the function they care about (though as I think about it, I'm not entirely sure how it plays out using fully qualified paths... * It is possible to create a type-safe builder - that is to say, you can code up builders that require a function to be called exactly once before build can be called on it ([https://dev.to/mindflavor/rust-builder-pattern-with-types-3chf](https://dev.to/mindflavor/rust-builder-pattern-with-types-3chf)). You can mix it with methods that are allowed to be called zero or one times. You can even use it sort of a state machine where the \`next(some\_arg)\` method takes the next arg in the struct (for positional only args). They are very ugly to write by hand, but luckily, we're using macros :D. [https://dev.to/mindflavor/rust-builder-pattern-with-types-3chf](https://dev.to/mindflavor/rust-builder-pattern-with-types-3chf) * Declarative macros can be exported from proc macros on nightly, (proc macros can too, but it's pretty useless since crates exporting a proc macro can \*only\* define proc macros. You'll need the proc\_macro\_hygiene flag as well as declarative macros. This powers my nightly only macro syntax. Declarative macros are nice because they actually live in module where they live without any funny macro export stuff - like proper functions, structs, etc. The one downside is that the docs don't reflect this - they still lift macro definitions to the root of the crate. * Lastly, you might want to take some time to poke around the darling crate ([https://crates.io/crates/darling](https://crates.io/crates/darling)) - the docs are a little obtuse (I had to read them several times - so maybe it's not obtuse and I'm just slow :)), but it does make attribute parsing a \_lot\_ easier.
You can do it explicitly (using as) and the compiler does it automatically for example for function arguments amd returns.
You'd probably need the serde attributes to be behind the cfg_attr too. like ```#[cfg_attr(feature = "serde", serde(untagged))]
It is and it's also used by random tools that can be accessed via http when you hook them up with fastcgi. I thought if this supported fastcgi, I could use it as a developer's test server, not bothering with production http daemons.
I never said that any crypto-currency was proven to work, let alone alternative models using disks or others. I fully agree that there are plenty of issues with the current crop of crypto-currencies; the wave of vulnerabilities in "smart-wallets" leading to them being siphoned, market manipulation at scale, criminal dealings, an electricity-bill that could stagger a small state (though it may compare favorably to the amount of electricity wasted to illuminate buildings &amp; cities at night for aesthetics), etc... To be honest, I haven't even really made my mind on whether a decentralized currency is a good idea in the first place. There is a tension between security and freedom (underlied by anonymity), and like any engineer I like to explore the trade-offs of various solutions before pronouncing myself. In this spirit, I find the experiment of crypto-currencies valuable.
Somewhat flattered this project is using some of [Inko's](https://inko-lang.org) source code. Not sure if OP is also the author of Enigma, but if so then [Inko's implementation of Immix](https://gitlab.com/inko-lang/inko/tree/master/vm/src/immix) might be of use. 
This: https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.poll_read ? As mentioned in the docs, it's called from read_buf, which "typically will not reallocate". So if there are more bytes to read than the size of the passed buf, then the buf will be filled, and the number of bytes read (buf capacity) will be returned.
I will bear that in mind thanks! I'm just messing around and am not especially interested in putting too much more work into this idea. I was planning on coding up the function call part using a proc-macro _pretending_ to be a declarative macro and used in expression form using: https://github.com/dtolnay/proc-macro-hack Mostly because I find proc-macros much easier to work with than the old style macros. Thanks for the tips, I'll message you if I have any questions and feel free to do the same.
In 2017 crypto was using [as much power as iceland]( https://www.digitaltrends.com/computing/bitcoin-ethereum-mining-use-significant-electrical-power/)
Holy shit this is a good idea. Kudos.
Oh yeah, I was on mobile and didn't notice. Thanks
What's the preferred way to find unit test coverage these days? I saw two projects out there and neither immediately worked. I wanna know what people prefer before I start putting time into one of them.
Cranking away slowly but steadily on [`ggez`](https://github.com/ggez/ggez/), a lightweight cross-platform game framework for making 2D games with minimum friction. The `gfx_glyph` crate we use for glyph caching and text drawing made some major but awesome changes earlier this year, splitting apart into the `glyph_brush` crate which does the actual glyph caching and having `gfx_glyph` be just an implementation of it for drawing with `gfx-rs`. After some messing around it really looks like it will be way easier to drop `gfx_glyph` and just use `glyph_brush` directly, since all it really needs are two callbacks to be provided for "copy texture" and "draw mesh". Hopefully this will get us text drawing that is both nicer and simpler. After that and one or two other graphics issues and probably some cleanup, we should be in shape to at least make a release candidate for `0.5.0`! I still think we can do at least that before the end of the year. `0.5.0` is *not* going to be perfect, since there's some underlying bugs in some edge cases of `winit` and such that are going to need to be solved by upstream, and I am NOT going to have time to explore that too hard before new year's. And there's the [Great HiDPI Design Issue](https://github.com/tomaka/winit/issues/591), which may or may not get solved before release. But we'll be able to have most of the improvements at least!
Awesome, do you have a github link to your programming language or such? I'm interested in programming languages and different ways of implementing generics are something I've been pondering.
It seems from the lack of punctuation and argument that you were cut short while writing your comment, in case you have not realized :x
I found it valuable in the early days. I liked the idea of international donations with pseudonimity, without revealing personal information… You're right that it was an experiment. But now it's an experiment gone wrong — you just listed how exactly…
Very nice; short and sweet. One thing I've noticed is that matrix math code is basically the place where Rust's lack of const generics hurts the *worst*. For most other use cases I've played with, you want to represent everything as slices anyway, or even if your slices *could* be better served by fixed-length arrays generic over array size, it doesn't make a big difference. Even though the existing hacks to get around const generics are awful, in most cases you don't need to deal with them.
Very nice; short and sweet. One thing I've noticed is that matrix math code is basically the place where Rust's lack of const generics hurts the *worst*. For most other use cases I've played with, you want to represent everything as slices anyway, or even if your slices *could* be better served by fixed-length arrays generic over array size, it doesn't make a big difference. Even though the existing hacks to get around const generics are awful, in most cases you don't need to deal with them.
The problem here is that dev-dependencies can activate features for your no-std crate, which is ridiculous.
A macro is a function that runs during compilation, and outputs a piece of Rust code that then gets compiled.
I'd be interested in checking out the Hello World lambda! I wonder how much we can improve in terms of best practices with regard to building a tiny release binary without compromising on performance.
That's great to hear, good luck with your project! A simple example or scrolling would be chat apps like Slack. They jump all over the place and it's because the ownership of scrolling offsets and logic belongs to the browser. The browser also decides when it's time to output a frame, so it's very difficult or impossible to do scroll back of history when even reading three offsets can cause a performance cliff.
Very true, but we all have to start climbing [the ladder](http://wiki.c2.com/?WittgensteinsLadder) somewhere.
Thanks for the reply, but it appears [I'm doing just that](https://github.com/CasualX/pelite/blob/master/src/pe64/debug.rs#L175). [See here for the compiler output](https://ci.appveyor.com/project/Casper/pelite/builds/21208868/job/yg0oll3apndi6mut#L125). Note that it's _only_ the `serde(untagged)` attributes causing an error (which appear on the type itself instead of its members), the others I'm using appear to be fine. However as per doctorocclusion's playground link above that shouldn't be a problem. 
Yup - structs, functions and macros live in different namespaces. That means you can have three items named the same, and import them all with a single import statement.
Yeah, I think I see the problem now, my *-sys crate depends on bindgen as a build-dependency which depends on regex which depends on memchr, which also depends on libc which explains the problem I was having earlier. Is there any fix or workaround for this? What I'm thinking of right now is using a script for bindgen instead of a build.rs, at least temporarily.
A nice overview, but also one that leaves out a lot of details. The hard part of Rust is not understanding the individual pieces, but how the pieces fit together. I can barely even explain fully how ownership works within one hour, let alone grok it completely enough to be able to absorb everything else on the list.
You might want to try asking in the serde IRC channel (#serde on irc.mozilla.org). They've been very helpful to me in the past.
Great! Thank you!
Ha! I've been messing around creating a basic game in amethyst the last few days and found myself running into this exact problem: selecting all the components that you need to operate on together gets a bit unwieldy. I'll check it out!
I would suggest that you start with a small to medium sized fun project in order to get some reps with the language. Maybe start with a very small project where you can build the concepts into something a bit more complete. A game, or something that solves a real-world problem that matters to you. If it turns out to be useful, you can open source it - but probably it will just be a stepping stone (you can still pop it into Github and Travis). In the mean time, keep your ear to the ground for projects that interest you. Something will catch your eye eventually.
What is the best way to learn about the macro changes in Rust 2018? I've been putting off learning macros, and I am thinking now is a good time to get with the program. So, yeah, kinda beginner. Thanks!
Looks like you’re making multiple calls to `graphics::present`. It’s intended to be called only once per frame, after all drawing has been done. Remove it from the individual entity drawing methods and put it at the bottom of your main loop.
Yep, that fixed it. Thanks!
It is definitely a good idea. It should be added in the future.
Thanks!
Many of the most powerful tools around Rust (and Node, and others) are accessed from a command line, and thus scriptable. If you haven't walked that path yet, let me tell you brother, I was once in your shoes. I stuck to the IDE entirely. Linux has become ubiquitous on the server side. This means bash is available everywhere you want to be. So you can write build scripts, etc., in bash that string together some Cargo commands with a zip or tar, deploy some files over there... that kind of thing. And it is all throwaway code. Once you get used to not having to click, click, drag, click, confirm, click, copy... on every build cycle you do, you won't want to go back. Also, you can transfer your scripts to a server and run them there without modification. If you are using projects on Github, you will notice that many of them default to bash commands in their documentation. Knowing your way around bash is a very good thing! If you are not using a command line in conjunction with your IDE, you are missing out. :)
Was having a hard time finding an idea, before realizing I am still using Python's http.server in production, so I tried to make a static file server. Would be appreciated if anyone reviewed my code, as I'm still new to Rust. https://gitlab.com/admicos/staticserve
Build dependencies affect dependency resolution of the final binary - its a known issue.
I mean, I agree that it is ridiculous, but this is also why there is only a single lock file for dev and non-dev builds. When this is fixed, we will need a different dependency tree for each type of build.
I wonder... Clearly const generics are useful for embedded rust, but I wonder if their main use case would actually be high performance game engines?
You've go me hooked. I cloned the repo and checked out the branch and replicated the issue. The only explanation I can give at this point is that I think it's a bug with cfg_attr expansion.
The problem I have with it is that different languages lend themselves to different programming styles. I had a project about six years ago where I had to re-do a UI that was a performance and maintenance nightmare. When I got into the code, I discovered that it looked like JavaScript programmed by highly competent C# programmers. (This is largely because that's exactly what it was.) But what worked great in C# didn't work so well in JavaScript. No matter how similar the languages look, they work very differently and coding one like you would code the other is not effective. I feel like it would be a disservice to budding Rust programmers to suggest - as the fourth bullet point in an introductory article - that they should emphasize OOP. Sure, you can sorta kinda code in an OOP-like style in Rust, but if you go into Rust like you want to figure out how to write a Java program with it, you're not going to be as good as you could be.
Unfortunately, I've never used PyO3, only rust-cpython. I care a lot about minimizing maintenance burden (that's part of the reason I'm migrating from Python to Rust), so I'm still waiting for PyO3 to become usable on stable-channel Rust.
Just to add to this - integer generics is the 80% of this feature - as in its great to have any constant useable as a generic, but ints (or perhaps stuff stored in contiguous blocks of memory e.g. str) will satisfy 80 of people (or 99)
Hey guys, I’m a bit confused about lifetimes. I have two questions: &amp;#x200B; 1. The Rust book gives examples like this: [https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-function-signatures](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-function-signatures) &amp;#x200B; I still don't understand why a compiled language needs us to manually annotate this. Couldn’t the Rust compiler see that this function could return either x or y and so x and y need to live as long as one another? &amp;#x200B; 2. The Rust book also originally gives an example of a dangling reference as a problem which lifetimes solve, but then goes on to use the example I linked to above to demonstrate how lifetimes work. As far as I can see (and I’m relatively new to Rust) there isn’t a possibility of a dangling reference within that function, is there? I’m not really sure what problem lifetimes solve in the given example. &amp;#x200B; 3. I’m also a bit confused about the statement from the book “Lifetime annotations don’t change how long any of the references live” when a few paragraphs down in the same section it says “The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime”, which sounds to me like they do change how long references live… &amp;#x200B; Any help with understanding this stuff would be appreciated. Thank you!
Now that I've researched a little more on building an SCM, including some interesting CS problems (like [longest common subsequence](https://www.wikiwand.com/en/Longest_common_subsequence_problem)), I believe I'm ready to start implementing! I'm thinking the way I'll put it into projects-rs is using a submodule because since this is a large project, it ought to have its own commit history.
In addition to what I said earlier, I got the call syntax working: #[named_args] fn foo(a: i32, b: u32, c: String) { println!("a: {}", a); println!("b: {}", b); println!("c: {}", c); } pub fn main() { named!(foo(a: -4, b: 5, c: "n".to_string())); } It's quite a bit more basic than your version of it. In addition because mine is stateless default arguments are going to be hard - in mine the call site knows nothing about the declaration site it just constructs a struct based on the function name and the args you've given it. Rust will give a type error as if you were trying to construct the struct `Args_foo` with the wrong fields.
I know people ask about GUIs pretty often here, but I would like to ask what other Rustaceans have tried that worked reasonably well for them. I have a project I have been working on for while, but have had a hard time deciding on how to implement a GUI. I really like the functional design of [Azul](https://github.com/maps4print/azul), but it doesn't seem to be ready for use. [Relm](https://crates.io/crates/relm) is one I just started investigating that seems to be the most fully featured GUI crate. I have also considered writing a C++ GUI (qt or wxwidgets maybe), or using electron or something similar. However, I would much rather use a rust crate, if possible. I am still relatively new to rust. Do any more experienced Rustaceans have recommendations on what has worked best for them? My main requirement is that I will need to make a custom text input (the project is sort-of like a fancy hex editor), and that I want the GUI to be able to at least look native and/or modern.
Most people here have found success using [GTK+ 3 rust bindings](https://github.com/gtk-rs/gtk)
I just released [zeroize 0.5.0](https://crates.io/crates/zeroize/0.5.0) - a crate for zeroing memory for use in cryptographic or other secret-keeping contexts. This release is notable in that it's a total rewrite: where previous versions of zeroize used FFI to bind to OS-specific APIs for securely zeroing memory, this release is now pure Rust, and leverages `core::ptr::write_volatile` as well as `core::sync::atomic` fences. This makes it simple, portable (now tested and working on wasm), and allows it to operate on all of the core Rust scalar types and slices/iterators thereof. In doing this rewrite, I learned a lot about Rust's memory model (or lack thereof) and the current state of Rust's volatile write semantics. I did an extensive writeup of what I learned here: https://docs.rs/zeroize/0.5.0/zeroize/#what-guarantees-does-this-crate-provide
Annotations don't however they help the compiler show how you intent code to work. Therefore allowing your code to pass the checks
I think Relm is a layer on top of gtk-rs to make it more friendly to idiomatic Rust. I'll take a look at gtk-rs on it's own though.
1) It doesn't _need_ to be manually annotated, but I believe Rust has chosen this because it didn't want to do that kind of static analysis. Rust also has the goal of being able to understand the lifetime of a return value _just from the signature_. 2) For example, consider that Rust let you return a non-lifetime-tracked reference from the function. Let's say it's the input parameter x, referring to your first example. The user gets the reference. Then they get rid of x. Now your return value is a _dangling reference_. With lifetimes, you can guarantee that the return value will only live as long as x, and no longer. 3) Lifetime annotations _don't_ change how long each reference lives. They are there to relate to the _other_ references passed into/passed out of the function. I can have a function `fn foo&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str`. All the lifetime annotations are doing are saying how that reference's lifetime relates to the others. In foo, it shows that the return value is constrained to live as long as x &amp; y. If x lives slightly longer than y, it will still live longer. But the return value will only live as long as y, due to the annotations. *sorry for the wall of text*
Oh I see, thanks anyway. 
&gt; It's low-level, but for most applications C/C++ is stable and good enough [http://cve.mitre.org/](http://cve.mitre.org/) begs to differ. 
1. Perhaps `x` and `y` will have different lifetimes in some calling contexts. You don't want the compiler to bully you by refusing to let you write that code. I'm having a hard time finding a clear example using the given function, though: the modern compiler tends to help you in these contexts. 2. Yes, the example doesn't really deal with dangling references. The problem lifetimes solve in this example is making sure that you can't use the result reference unless both of the argument references still are valid. 3. The distinction being made here is that the actual lifetimes are a thing implicit in the program: things live as long as they live. The lifetime annotations are constraints that tell the compiler to reject code when actual lifetimes don't obey the constraints. In other words, the compiler will never "fix" your code to make things live longer when a lifetime annotation is not obeyed, it will just reject your program.
2. But where are we getting rid of x? We are returning x while x is still in scope, aren't we? How would this result in a dangling reference? 3. Do lifetime annotations in functions affect anything outside of that function? Or are they only annotating within the function scope itself? Also, still confused about this... If we're annotating that x and y should live as long as each other, doesn't that mean x won't go out of scope as early as it would normally (at the end of its block)?
There's a bunch of crates around that provide implementations of standard CS data structures and algorithms. These tend to be small and easy to understand, and also tend to need some love. (I know mine do.) Those might be a good place to start.
Very nice! Thanks for sharing. If you have any questions on specific design points, feel free to ask in Gitter: gitter.im/tower-rs/tower
&gt; for the sole purpose of avoiding garbage collection Rust is first memory safe and then zero cost. Lack of garbage collection is incidental, it's not a primary design choice not to have it, it used to have it early on. &gt; I stated that Rust was written with the intention of rewriting Firefox in it. Rust is a general purpose systems programming language and doesn't have much to do with Firefox aside from being informed by and dogfooded with a real world application which is Servo, not Firefox. Which is only a good thing because many new languages too often start only as academic experiments that don't progress to where they need to be to be usable in the real world. &gt; it will never be able to avoid whatever disadvantages that come with being a part of a system heavily dependent upon garbage collection. JS engine is only a part of a browser engine, rendering engine is a extremely complex and computationally costly part of engine and it's written in C/C++ in all browsers other than Firefox. Obviously 6 year websites written in GWT can't be helped but there is such a thing as judicious use of JS that doesn't bottleneck speedups gained in rendering engine. 
&gt; There should be a way to abstract it over the lifetime argument to Cow in both cases. This is like saying "There should be a way to make 1+1=3." You've written code which doesn't abstract over the lifetime argument to Cow. Lo, the code doesn't abstract over the lifetime argument to Cow. While HKT could allow you to write something *similar* that works, the code as written doesn't work because it's not written in a way that should work any more than 1+1 should be 3.
One workaround which I think would solve your immediate problem, since it seems to be related to pulling in all of bindgen as one of your `build-dependencies`, is to require bindgen be installed somewhere in the `PATH`, and have `nspire-sys`'s build.rs directly execute it as a program, rather than using the Rust API (which I believe is just a Rust "DSL" for doing the same).
Thank you!
I think the Alexa skill response on https://github.com/arienmalec/alexa_rust is a reasonable choice. It mostly serializes/deserializes structs. I just triggered it three times -- got: `REPORT RequestId: e45d30de-07ad-11e9-b57b-67fb68c817a4 Init Duration: 29.29 ms Duration: 1.43 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 22 MB ` `REPORT RequestId: e95fb1bc-07ad-11e9-a4c3-69ec64d46f32 Duration: 17.48 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 22 MB ` `REPORT RequestId: eb36e26c-07ad-11e9-b4d8-4f50b0629aa5 Duration: 1.36 ms Billed Duration: 100 ms Memory Size: 128 MB Max Memory Used: 22 MB` That second invocation seems to be warm. Based on again mostly unmethodological testing, there seem to be three modes here: one centered on ~1.1ms, one centered on 7-17ms (maybe the Lambda machinery finding the sandbox?) and a true cold start that's pretty consistently 30ms with an "init". To note, even the "Hello World" binary is about 8.7MB, whereas a vanilla Rust binary is about ~600Kb. As you know, the cold start penalty is only an issue when: a) you have tight SLAs &amp; b) you hit enough cold starts often enough to make your P99 or P99.9 or whatever your measurement target is degrade. Last year, we looked at Lambda for a project that needed to run at at P95 SLA of 300ms. Our conclusion was that with Java, any cold start would kill our SLA and we'd hit cold starts often enough to matter. With Rust current state, we could *probably* hit our SLA hitting all cold starts as it is; pulling the cold start penalty down to 20ms &amp; that would be a no-brainer. Of course, then we have the issue of how to teach Rust to ~100 developers who know Java/C#. A team I work is in Seattle looking pretty hard at this with the AWS team early January. Stefano is going to be part of that workshop. I mostly wash dishes, change tires, and play with Rust on the weekends. 
Given these assumptions, and based on the SO answer by Emily, why not this code? fn index_of_max(values: &amp;[f32]) -&gt; Option&lt;usize&gt; { values .iter() .enumerate() .max_by(|(_, a), (_, b)| a.partial_cmp(b).expect("Found NaN")) .map(|(index, _)| index); } 
&gt; With Rust, are there any resources I might want to read up on when dealing with very large data structures? Mostly not. The lack of GC and automatic boxing makes these a lot nicer/easier to work efficiently with in Rust than in most languages as nested structures don't entail extra pointer chasing. The main thing to be aware of is that you will probably need to heap allocate large data structures (either by storing them in a Box, Vec or similar wrapper), as otherwise they will cause your program to overflow the stack.
I should've in hindsight actually. I'm trying to avoid adjusting the code on the post once it's been posted (unless there's an error) to avoid conversations becoming out-of-date or irrelevant. :-)
Contributing to other people's projects is (often) hard – don't worry if it seems overwhelming. You might find it easier to try some small projects of your own; often people suggest [Project Euler](https://projecteuler.net) for this kind of thing. It's quite maths-oriented, which put me off it originally, but from your description of yourself you would probably be better-suited to it than me.
Here's an example adapted from the book. I'll write lifetime annotations on the blocks to show you lifetimes (but you can't actually write them out like this). fn main() { 'x { let string1 = String::from("short"); let result: &amp;'x str; 'y { let string2 = String::from("very long"); result = longest::&lt;'y&gt;(string1.as_str(), string2.as_str()); } println!("The longest string is {}", result); } } The lifetime that `longest` ends up using is `'y`, because you can use a longer lifetime somewhere that requires a shorter lifetime. So, the output of `longest`is a `&amp;'y str`, no matter which string is actually longer. Then, we try to assign a `&amp;'y str` to the variable `result`, which is a `&amp;'x str` and this is illegal, because `'y` is shorter than `'x` and thus `'y` will not be valid for the entire time that `'x` is alive. 
I've only done minor coding on `rustc` itself; but I have to disagree with the compiler being a clean codebase. The parts I looked at (especially lints, libsyntax, ..) seem to be deeply stateful APIs with functions that span over 100 lines. There's also a glaring lack of comments in the older parts of the code. What's worse is that these are all barriers to entry for new developers.
Out of curiosity; have you benched in-ram + write to socket, compared to in-os-cache + mmap?
A generic 404 error would be nice for the case where there is no default file. Especially for the in-memory case where requesting a file that doesn't exist currently brings down the whole server! Beyond that, I like these kind of simple servers. Two use cases I have: - Local development /preview of static sites. - Ad hoc method of sending files to people on the local network. Looking forward to https support!
One relevant huge annoyance for me regarding generics is that you need to use the parameter in your item. This makes sense most of the time, but if the parameter has e.g. an associated type you want to use, and not the actual type itself, it is very restrictive. The restriction should really be dropped, since const generics won't have that restriction anyway, right?
Another common application is in optimising allocations (e.g. smallvec/smallstring). I suspect once the feature lands, people are going to find uses for it all over the place.
Such a trait already exists in the standard library but is not exposed: ``` /// Compiler-internal trait used to determine whether a type contains /// any `UnsafeCell` internally, but not through an indirection. /// This affects, for example, whether a `static` of that type is /// placed in read-only static memory or writable static memory. #[lang = "freeze"] unsafe auto trait Freeze {} impl&lt;T: ?Sized&gt; !Freeze for UnsafeCell&lt;T&gt; {} unsafe impl&lt;T: ?Sized&gt; Freeze for PhantomData&lt;T&gt; {} unsafe impl&lt;T: ?Sized&gt; Freeze for *const T {} unsafe impl&lt;T: ?Sized&gt; Freeze for *mut T {} unsafe impl&lt;T: ?Sized&gt; Freeze for &amp;T {} unsafe impl&lt;T: ?Sized&gt; Freeze for &amp;mut T {} ```
Look, I'm happy to hate on Bitcoin and its power consumption all day, but you could at least bother to acknowledge or respond to literally anything in the grandparent's comment. Large power consumption is not an inherent property of cryptocurrencies.
RefCell does not subsume Rc, they're different things that provide different guarantees that can be composed https://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/
I never thought of doing so.
Thanks for suggestion.
Here's the link https://github.com/Lapz/tox/tree/generics
Good point! That's just not something I've had to do. And yeah, I bet there will be all sorts of applications once we have it. Similar to how the killer feature for async/await is async IO, but they're also going to get used for GUI's and state machines.
Join /r/rustcryptofin/ . :)
I recommend intellij (community edition) on windows, and installing via [rustup.exe](https://rustup.rs/). Once you've done that I've had zero issues between linux and windows - I switch between them quite often.
It's a bug! Because it if you add this in the [lib.rs](https://lib.rs), it doesn't add any new errors: \`\`\`rust \#\[derive(Copy, Clone, Debug, Eq, PartialEq)\] \#\[cfg\_attr(feature = "serde", derive(serde::Serialize))\] \#\[cfg\_attr(feature = "serde", serde(untagged))\] pub *enum* Name2&lt;'a&gt; { /// Resource ID. /// /// Technically allows \`u32\` ids, but some Windows APIs will be unable to use resources with an id which isn't \`u16\`. Id(*u32*), /// UTF-16 named resource. Str(&amp;'a WideStr), } \`\`\` But if you add it anywhere else (like resources/mod.rs) it causes an extra error. That is to say, going the cfg\_attr route without the extern crate macros works for any items defined in the root of the crate (lib.rs). Additionally, even when you remove the \`#\[cfg\_attr(feature = "serde, derive(serde::Serialize))\]\`, you still get the same error messages. That makes me think that cfg\_attr combined with custom derive macros are broken when used outside the root of the crate.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rustcryptofin] [Cryptocurrencies written in Rust](https://www.reddit.com/r/rustcryptofin/comments/a98nnu/cryptocurrencies_written_in_rust/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Specifically, the first code block *that actually does anything*. A bunch of derives don't give me a complete picture of how to use your crate.
&gt; I don't even want to think about how many countries worth of energy consumption Rust is helping to waste Rust is a technology, and it be picking sides on who uses it. If it's any good, it has to be used both by people and projects we support, and those we don't. As it is today, Rust is extremely well suited for cryptofin, because it is an application that combines demand for high security in hostile environments, high reliability, and high performance. Instead of throwing unresearched and ignorant opinions around, we should celebrate every user.
Oh wow, thanks a lot for finding the bug and a workaround! I can confirm the workaround (prefixing with double colon) compiles without error. This also explains why it couldn't be reproduced in the playground as it's a single file. I believe it's unrelated to cfg_attr as the same error appears without, the key distinguishing factor appears to be it appearing in the root file or not being prefixed with double colons.
Thanks for the hint, I have never heard of this tool before.
There could probably be something like \[\`PhantomData\`\]([https://doc.rust-lang.org/std/marker/struct.PhantomData.html](https://doc.rust-lang.org/std/marker/struct.PhantomData.html)) but for integer generics to solve that problem.
I would recommend threads, channels and a synchronous approach, until the Rust async story has settled and stabilized. Mpmc channels has been working great for me for similar situations. See https://crates.io/crates/crossbeam-channel 
I'll take a look. Thanks!
First off, your local filesystem operations are done in a blocking way. This is a limitation of POSIX; there's limited support for doing reads and writes in an async way but nothing for opening files, traversing directories, etc. So the thread doing `walkdir` will block on local disk, and you'll be happier if you accept that and don't try to do anything else on that thread until `walkdir` is done. That means your `walkdir` thread needs a way of communicating to another thread that it should start a request now. There are several ways to do that, depending on if you want to use a synchronous or async API to issue the https requests. Here are a few that come to mind: * Enqueue async futures onto a tokio reactor via `tokio::runtime::run` * Send stuff on an async channel to an async task via `futures::sync::mpsc::unbounded` or `::channel`. * Enqueue synchronous work onto a threadpool, maybe with `rayon::ThreadPool::install` * Send stuff on a synchronous channel to some worker threads via `crossbeam-channel`.
I'd expect them to be similar if the mmaped filesystem data is actually in-memory. `mmap` can be a bit of a pain though: * you have to call `mlock` to ensure the data you want stays in RAM. And stock Ubuntu systems (for example) don't make it possible for users to call mlock without adding a line to `/etc/security/limits.conf. * if the file shrinks while you're serving it, the process will receive a `SIGBUS` error (and crash, unless you've written a very clever signal handler).
&gt; Project Euler The issue I have with these kinds of exercises is that they don't often force me to learn how to become a better programmer. They are intended to strengthen my problem-solving abilities. But those I already have trained for many years (being a mathematician). What I really need to learn is how programming is managed in real life applications and bigger code bases.
That's a brilliant idea. I'd imagine that some of those could benefit from having a mathematician look at them. Thanks!
&gt; And zero of them are proven to work. So the thousands of purchases using /r/nanocurrency actually involved no transfer of value whatsoever?
Holy moly that's a long chain
Thank you! I'll do some research on those.
Thanks :) &amp;#x200B;
Why do you need a match block, could you not just say `let _ = free_foo(foo);`?
You certainly can, I didn't consider that.
The official book has some brief Windows instructions. Any chance following that works for you? https://doc.rust-lang.org/book/ch01-01-installation.html
Note that with lifetime elision, this signature should work as well: fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str { // ... } That section of the book uses explicit lifetimes to help explain what's going on. Most real-world code doesn't need to write them all out like that.
Tried but does not appear to work: $ rustc 'https://rust-servers.net/server/147335/` error: couldn't read https://rust-servers.net/server/147335/: No such file or directory (os error 2) error: aborting due to previous error
This subreddit is dedicated to the [Rust programming language](https://www.rust-lang.org/). I believe you're looking for /r/playrust.
How about something even better and just use GTK+ for making UIs?
ITT: People that don't understand the economics of cryptocurrency.
"intermediate Rust programmer in one day" I haven't come across such a bold claim for even for javascript.
I'm a simple man: I see a new language and try to implement Dwemthy's Array in it. Currently I'm looking for a way to delegate method calls directly to the first element of a array (through Deref and DerefMut I think?) Not as shiny as other projects but fun nonetheless ¯\_(ヅ)_/¯
Basics work. What I did figure out from the documentation is that part of my problem is it's a package - I needed to compile with cargo. Of course, now the issue is the mysql library they've chosen doesn't appear to be supported on Windows. Guess I'm spinning up a Linux VM....
memchr also has a no_std toggle: https://github.com/BurntSushi/rust-memchr
`PhantomData&lt;[(); N]&gt;`?
Or just `drop(result);`. 
Out of curiosity, what would that be testing, and what’s the difference between in-RAM and in-OS-cache?
Huh, that's pretty cool - I haven't even thought of Software Guard in forever, but Rust seems like a pretty solid fit for it, given the obvious issues of potential memory-based exploits in software the kernel can't really monitor. Did Intel ever do anything about / is there a software mitigation for that timing attack from a few years aback?
why dont you guys allow us to choose our gender? still didnt understand it. please. im not a skinny red short hair woman, im a brown short hair man. example: dying light - "your character is male, and thats the story." that makes more sense than "this is your character. theres 5000+ servers, every server you join is different, this isnt good for the game. there isnt a lore, even on the helicopters and the supply drops, no sense at all.
Depending on your requirements, could be as simple as having each URL discovered spawn a new thread that writes its result into a common channel. The fancy crates will be helpful, but will also have the overhead of learning them. Rolling your own would be a fun way to learn the "low-level" (not very low-level) asynchronous primitives Rust provides. Two things you might have to deal with if you roll your own: * If there's a lot of URLs, you may have to queue them and let a limited pool of workers work through them to avoid ridiculous numbers of concurrent threads. This makes the crate-based approaches more attractive, since they handle this for you. I'd say it's reasonable to spawn something like 1000 concurrent threads on a modern Linux box: no idea about other platforms. The threads will mostly just block anyhow. * The results will likely be delivered out-of-order. There's a number of reasonable ways to handle this if it matters: the easiest is just to pass a serial number or some similar identifier to the thread and sort things out later.
Looks like you want /r/playrust . This subreddit is for the Rust programming language.
The two options out there are kcov and tarpaulin. My personal sense is that tarpaulin, being purpose-built for Rust, will ultimately be the way forward (it produces more accurate output in some cases already), but for the moment it's nightly-only which may or may not be a problem in your workflow. It's what we're using at my work, but I think some people are sticking with kcov at least until things stabilize.
FYI, i am not the author of Enigma.
It seems to be one of those use cases where a select/epoll based model would scale very well, which leads me to say that tokio might be worth the struggle, but only if it’s really performance critical. The compiler errors in particular are the stuff of nightmares. You do gain an intuition for it after a while, so I don’t necessarily want to discourage you, but I do think that tokio as it stands only carries its weight when you need a certain QPS per core. 
It seems difficult to wrap c++ api. Pytorch is trying to rewrite backend from c to cpp and merge caffe2, so tt is harder to find the real api :(
Last time I looked doing custom widgets with gtk-rs is not easy or possible. Not sure if things have changed or documentation was just lacking.
Still .. learning.. rust.
My experience is that any exercise that isn't marked as being one of the key ones will simply never be reviewed.
Just a quick suggestion, I'd swap the axis on the plots. In physics time usually goes on the time axis because it is usually the independent variable that affects the other (smt like car position x time). However here time changes according to the number of lines (and both codes share the same number of input lines but not the same timings). I am not sure if this kind of benchmark plots are always like this but seeing rust plot skyrocket made me think that it performed worst than python until I looked at the axis labels
I tried `bindgen` but failed. ``` --- stdout cargo:rustc-link-lib=stdc++ --- stderr thread 'main' panicked at '"std___shared_count___shared_count&lt;_Lp&gt;" is not a valid Ident' ```
Hello [![the _other_ kind of rustacean](https://vignette.wikia.nocookie.net/cavesofqud/images/5/5f/CoQRustacean.png/revision/latest?cb=20150813140850)]. I'm trying implement a `struct` that works for all numeric types (using the `num_traits` crate). I first need to get my head around casting in Rust and so far I gather the `std::convert::From` and `::Into` traits are involved. However, while it is valid to do ```let x: f32 = 0; let y = x as i32;``` [there is no standard lib](https://doc.rust-lang.org/beta/std/convert/trait.From.html) `impl std::convert::From&lt;f32&gt; for i32`. What is the actual mechanism for doing the cast above?
Probably the best would be the chapter in the 2018 book. The biggest changes are: * Proc macros are now partly stable. There have been a couple of posts about those in this subreddit recently. Search for those (timeframe of about a week) * macro_rules (a.k.a macros by example) are to me, harder to write/maintain but incur less crate structure overhead. The little book of macros is a pretty good resouce. A 2018 edition change is that you can import them like regular macros now.
Thanks for the detailed writeup! I really appreciate you taking the time out of your day. &gt;To note, even the "Hello World" binary is about 8.7MB, whereas a vanilla Rust binary is about \~600Kb. That 30ms init surprises me. Stefano observed (informally...) much lower cold-start times. I wonder how much that can be cut down by: - [not using jemalloc](https://github.com/rust-lang/rust/issues/36963) and instead using default system allocator provided by Amazon Linux (use 1.32, beta train), - not building musl binaries (if you are!) - ...and dynamically linking to OpenSSL. &gt; With Rust current state, we could probably hit our SLA hitting all cold starts as it is; pulling the cold start penalty down to 20ms &amp; that would be a no-brainer. Of course, then we have the issue of how to teach Rust to ~100 developers who know Java/C#. Go might be a really solid option there if you're nervous about the education costs. That being said, I'm of the opinion that the learning curve of Rust is overstated (e.g., Sergio Benitez noted in a talk recently that he taught students in an OS class Rust in about three weeks, and made the same or greater progress than had they learned C + GDB). Plus, the whole mindset of serverless/Lambda/eventual consistency is probably more mind-bending than Rust itself, IMO. &gt; A team I work is in Seattle looking pretty hard at this with the AWS team early January. Stefano is going to be part of that workshop. I mostly wash dishes, change tires, and play with Rust on the weekends. I didn't know! That's pretty cool.
Raw numerical casts don't always have a `From` equivalent because the policy with `From` implementations is that conversions must be lossless. Not all values of a 32-bit integer can be converted losslessly to a 32-bit float, and obviously converting a float to an integer is going to lose the entire fractional part. Have a look at the `cast` module of `num_traits` which models these lossy casts as methods returning `Option`.
https://github.com/zeromq/zmq.rs You should contribute here.
I wouldn't consider myself an expert on this topic, but my instinct is to embed the interior mutability directly into the type itself. Presumably with one of the field of the MemoryBackingStore being an Arc&lt;Mutex&lt;T&gt;&gt; or Arc&lt;RwLock&lt;T&gt;&gt; around the actual data (you may want to consider to `parking_lot` crate for faster versions of Mutex and RwLock if performance is important). Is there a problem with that approach?
look just make the `eventbus` crate work with reference-holding types like `Cow&lt;'a, str&gt;`. I don't care how the language feature actually works, I just care that it exists. and it currently doesn't exist. so it needs to be made to exist. that's all I care about. I only care about getting ppl to use my library.
no it's exactly THAT bad
You can also look at std::convert::TryFrom, although it is currently nightly-only.
Thanks. Actually I'm using the `num` create, not `num_traits`. They look rather similar. I think I get what you mean. Still I'm annoyed that `x:f32 as i32` works, but `x:f32 as T` where `T` eventually becomes `i32` doesn't.
in-ram: read whole file into a variable
Wait, wait, wait. Back up. I have so many questions, but I think you can be helped. What exactly do you plan on doing with a `for&lt;'a, 'b&gt; &amp;'a mut Cow&lt;'b, str&gt;`? (Of course the `for&lt;&gt;` bit actually lives in the surrounding function's type signature, but you know what I mean, or at least I do.) The usefulness of such a type is limited. You can't store a `for&lt;'b&gt; Cow&lt;'b, str&gt;` in a static (such as your `HANDLERS`), that's for sure. Why have you done `Cow::Borrowed(&amp;String::new())`? Is that an actual expected usage pattern? Because the whole point of `Cow` is that you could do `Cow::Owned(String::new())` instead. Upshot of the above questions: if the `Cow` is only ever a `Cow&lt;'static, str&gt;`, which is a common use pattern, then just write that, don't try to stick references to locally-owned strings into it, and [it works](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e7560877a5f2bba68b1d2f00bd16a6fb).
Thanks! I'll improve the docs. :)
Great work. Very interesting problem space to address :-)
More gba work. Sadly got somewhat stalled by travisCI breaking :(
Oh wild! I recently went on a volatile tirade myself. Lead to me putting a PR in for rust itself (turning the NonZero*::get method `const`). I _also_ did a write-up about it which I'll publish just as soon as that PR finishes the FCP so my examples build. I actually looked at your crate as part of my long rant because I had to look at all the top volatile using crates as part of it. Your use is quite different from mine though, I was targeting the MMIO usage stuff.
One more note to add is that unlike Macros in other languages, Rust Macros are generated from the Syntax Tree and not text.
Thanks! Fortunately, the order of the results doesn't matter at all.
Have a look at [`num::cast::AsPrimitive`](https://docs.rs/num/0.2.0/num/cast/trait.AsPrimitive.html) then. That gives you lossy casting between various numeric primitives in a generic context.
I took a look at the documentation and guides on the Tokio website it seems slightly less daunting now. Thanks for the advice!
That's a good point, makes a lot of sense. I'll go ahead and update them shortly :-) 
It uses only crates for which you run `cargo doc` + dependencies. If you add another dependency and run `cargo doc` again, your type can get another trait implementation and few methods with it.
Also, you really don't need so many Arc. For serious. So many. I don't want to sign up for $githubCloneOfTheWeek, but here's a patch to remove two Arc layers (and then a bigger patch which is just formatting): https://pastebin.com/ShfHyEME. (If you're not familiar with the patch format, don't worry, `git am` is.)
I guess the number of lines of Rust will only increase over time replacing c++ and assembly whenever possible over time.
I guess that the issue is that you *must* lock every data, even the one that is stateless. It is not super efficient.
I already seen similar crates. https://crates.io/crates/shrev is one of them
This is only needed for type parameters because of variance, It will not apply to const generic parameter
Trying ML in rust 
`num` is a supercrate of `num_traits` and many others.
Hi! I'm the author of Enigma. Both Inko and your [rust-hosted-langs/book](https://github.com/rust-hosted-langs/book/i)) were really useful in getting started (especially given this is my first rust project)! Without the reference material, this project probably wouldn't have existed. I've been looking at your immix implementation, but one thing I wondered was regarding per-process memory usage. [From what I could tell](https://inko-lang.org/faq/#header-how-does-immix-work), each process would get it's own blocks; each block being 32kb at minimum? Because Erlang tends to spin up hundreds/thousands of processes, the OTP implementation tries to be efficient and has a 233 word default heap size, (so ~500 bytes). Most data types are also very small and tend to be unboxed (not heap allocated). As such, most processes would rarely consume more than a few lines of a 32kb block. I was considering making the block size smaller, but at such small heap sizes I'm not sure if it would perform better than a regular mark-and-sweep GC. (Which is why I shelved GC until I can give it some thought). Was also looking at [Golang's GC](https://blog.golang.org/ismmkeynote), which could benefit Inko as well ("[..] Go programs have hundreds of thousands of stacks. [..]")
I believe, it is worthwhile to add some updates at the end of your post, so the readers who come across your post not from Reddit can benefit from these discussions.
It works properly now.
Hi! I have a use case where I have a `struct` with multiple fields. In this `struct` I have a private `Vec` and I would like to have a mutable reference to the items in `Vec` while still maintaining the ability to mutate the rest of my `struct` . I do not need to change `Vec` other than to put more items into it.
Most of the projects in this list don't intend to use Proof of Work
&gt;From what I could tell, each process would get it's own blocks; each block being 32kb at minimum? Correct, a big part of Immix is that it uses thread local allocators instead of only using a single global one. 32KB might not be a problem though, depending on how large objects are. In Inko for example every object is 32 bytes in size, except for 63 bits integers; these are stored as tagged pointers. At 32 bytes per object, 32KB allows for 1020 objects to be stored (the first 128 bytes is reserved). Most processes will likely consume that amount rather quickly. I would recommend to stick with the 32KB blocks, until your implementation is more mature. At that point you should have more data to determine what to do with the heap size. Reducing the size may result in more time being spent allocating and garbage collecting.
I went ahead and updated the graphs as recommend. I do agree that it's a lot clearer now, thanks!
Good point, I added a note at the very top linking to this post so that people can discuss further. Thank you.
ZMQ is amazing, and a Rust native implementation would be awesome. I'd love to contribute, although at this time the scope of that project and the skills required to implement it properly are beyond me. It is on my wish-list though.
thanks.
The problem is that appending to a `Vec` is *the* primary reason the kind of solution you're looking for is inherently unsound; at some point the `Vec` is going to have to reallocate which is going to leave all those old references dangling. The perfect alternative, in this case, is to store indices into the `Vec` instead, which are only invalidated if you move or delete items from it. Then index into the vector only when you need to refer to those items.
Thank you for your interest in the rust programming language. Here are a few useful resources to get you started: - https://doc.rust-lang.org/book/ - https://doc.rust-lang.org/rust-by-example/ If you ever feel stuck, don't hesitate to come back, and ask for help. Good luck
Thx for the link, if you have any more crates with same/similar functionality please post them. I was unable to find similar crates to bus\_queue when I was looking for them. I'll look into shrev to compare, and learn from, perhaps contribute some added functionality from bus\_queue.
can you elaborate?
If you want finer grained locking, then you should be able to use just an Arc&lt;T&gt; in your struct implementing the trait, and then push the mutex's/locking into the struct that's pointed to. There are also crates like [CHashMap](https://docs.rs/chashmap/2.2.0/chashmap/) (concurrent hash map) that you might be able to use instead of Mutex's depending on your use cases...
(👁 ͜ʖ👁)
Try using WSL, the Ubuntu on Windows thing. I've used that to great effect. Run the rustup command that the site tells you, and navigate to the proper `/mnt/c/` folder. Then it should compile and you should be able to open it as you were doing before.
Thanks. I’ll take a look at that
This is very cool! It would be nice to drop the restriction on using capturing groups by rewriting them as non capturing using the regex-syntax crate. Not all regex users know about the difference, and it would remove an ugly edge case. You could also generate named capture groups, but then you would have a performance penalty and have to handle name collisions for a complete implimentation.
My first macro was test parameterization, [mentioned on Hello Rust #6](https://hello-rust.show/6/). It was very useful and approachable because you're basically feeding two arguments and populating a function with them. 👍
If a dependency takes very long to compile, wouldn’t compiling it twice for dev-dependencies and runtime dependencies also be "ridiculous"? Sometimes an "obviously better" choice is in fact a trade-off.
Woop, I'll have to compare with mine and see what I can learn/steal :D https://github.com/jsdw/advent-of-code-2018 Was a tougher year than last, more tedious problems but a couple of gems as well (I particularly enjoyed the regex day.. 19? And um day 22 and 23..)
How do I check if an iterator begins with the exact elements in other iterator?
Every ordering used is `Ordering::Relaxed`, which means sending a message from one thread and receiving it from another is a data race. At the very least, `Ordering::Acquire` and `Ordering::Release` should be used somewhere. Or am I missing something?
Yeah, I enjoyed the reverse-engineering ones. My solution to the clustering one (where you find the position with most nanobots in range) was probably not the way you're supposed to do it, but it worked, so *shrug*.
I guess it should only be compiled twice if features are different. Additionally there could be a key in Cargo.toml that indicates that the crate may need to be compiled differently for dev-dependencies, like syn, which you can‘t really use at all as a normal dependency
You are right, I was using \`Ordering::Relaxed \` as a placeholder until I get to optimizing the internals. There are also optimizations to be done in how the ArcSwap is being used atm. Using method \`lease\` \`load\` etc. 
I’ve been using this year to finally dig in to learning rust. The solutions I’ve already come up with seem like ugly hacks, but it’s nice to know it gets cleaner. I’m saving this to review once I finish all puzzles.
I read his problem as the Vec is inside his struct. I would implement the following function: fn split(&amp;mut self) -&gt; (Vec&lt;Bar&gt;, FooWithoutBar) { (self.bar, FooWithoutBar{self.x, self.y}) } I recently saw a crate who did all this boilerplate with macros. It's called partial-ref.
In these cases, I find myself writing ‘free_foo(&amp;foo).ok()’, which I read as “free_foo is always considered ok”.
Diesel is the way to go if you are not going to directly execute SQL. Diesel is hard to learn, but I hope you can understand. I recommend reading the API reference, that one is quite detailed. And regarding FromRow, what you mentioned is the implementation for tuples which shouldn't be used with many items anyway. The correct way would be creating a struct with `#[derive(FromRow)]`.
This comment needs to be pinned somewhere. /u/kibwen can we have a "* Responsible introduction to rust performance" with this comment linked? /u/ManishEarth /u/llogiq
If you know how many elements you want to check, you could combine `take` and `eq`. If you want to use all the elements of the shorter iterator, you could combine `zip` and `all`.
This isn't true sadly, there are 2 parts to wasm-bindgen. The first part generates metadata as part of the rust build. The second is a cli app that takes that metadata and generates the JavaScript glue.
Me too. It seems the intent of the crate is to out right prevent you from using the success portion of the result in these situations. Using `.ok()` still forces you to deal with the Option though, so if you end up trying to use the resulting value, the compiler still forces you to deal with the fact that value might not actually be there. (Unlike unwrap... which I wish just didn't exist.)
How does the compiler force the Option to be used? I don’t think it’s annotated with #must_use, and thus can be silently discarded.
&gt; Instead of throwing unresearched and ignorant opinions around, we should celebrate every user and project using Rust. I think this attitude abdicates moral and ethical responsibility and is generally problematic in tech. There are lots of technologies for which you absolutely want to control and pick sides as to who uses it. If my work mplementing a library helps make some military aircraft better which then helps to kill people, or if it helps facilitate tax evasion (related to crypto currencies) or an economy wherein democratic control is harder, then that's a problem. While I might not be in a position to do anything about their use of my library, I still have a responsibility to do something by other means.
It most certainly can be silently discarded. And I use it for this effect. If you read the rest of my comment: &gt; so if you end up trying to use the resulting value You literally can't use the value without dealing with the fact it might be None now that it's been converted to an Option. This is a good thing. If you don't care for the result, you throw it away and everyone is happy.
One wouldn't even need the `PhantomData`, i think.
Cool. It is much clearer now. One more suggestion: why are you using thousands of milliseconds instead of seconds? I think that seconds is a much clearer unit. 
`(foo,)` or `[foo]` also works. Tuples and arrays are never must-use.
I didn't get the import project part. I couldn't select my dir. I clicked on the projects button and went to open project.
The dependency in question is using `bindgen` and `cc`, not `wasm-bindgen`: https://github.com/coolreader18/rsspire/blob/weird-std/nspire-sys/Cargo.toml#L10
Let me see if I can give a better example. Here's a function that pushes a new `&amp;str` into a vector of other `&amp;str` references: fn insert_string&lt;'a, 'b&gt;( my_vec: &amp;'a mut Vec&lt;&amp;'b str&gt;, my_str: &amp;'b str, ) { my_vec.push(my_str); } This function requires at least some manual lifetime annotation. You can leave out `'a` if you want to (I've included it here to be explicit), but if you leave off `'b`, you'll get a lifetime mismatch compiler error. The vector's type says that it contains references of a certain lifetime, and if you try to insert something that might be sorter-lived into it, Rust knows that's going to lead to dangling references and forbids it. Now the big question that you were asking is, could Rust have inferred all this without us explicitly writing it down? Probably yes, at least in this case it certainly could've. So why didn't the designers make the language smarter? Well, definitely one reason is that doing analysis like that is expensive, and it makes the compiler more complex. But I think the main reason, is that global inference makes it difficult for libraries to publish **stable APIs**. (This is a recurring theme in Rust. A lot of other complicated rules -- like what trait impls you're allowed to write -- stem from this same concern.) Consider our `insert_string` function. Now in this case it's super obvious what it's doing, and of course it's never going to change. But suppose it was called `query_database` or something more interesting, and maybe it was a big long function with many more arguments besides the vector and the string. Perhaps the string represents some kind of query, and the vector represents some kind of cache. Now maybe in the first version of this function, it didn't insert the string into the vector, so their lifetimes were unrelated. But then a clever programmer came along and decided that `query_database` should update the cache, and so they added a `push` line like we have above. Suddenly *the API of the function has changed*. There might be callers that used to compile before, which no longer compile. If this is a public library function, the change might've broken callers in other libraries that we don't even know about, or even broken _their_ callers. Now luckily these are all compiler errors and not runtime undefined behavior, but still, breaking your callers' builds with a trivial internal change is bad for the language's stability story. With explicit lifetimes in the function signature, the public API of a library can't change unless the programmer edits the line that starts with `pub fn`. That's a lot more explicit. If an internal change like our insert is going to bubble up to affect five different functions above it, the compiler is going to make sure the programmer knows that. And as a helpful bonus, but borrow checker never needs to reason about more than one function at a time, so the compiler gets simpler and faster. I think it's interesting to compare these design decisions to a language like Haskell, which does do global type inference. I don't have much Haskell experience, but my impression is that because Haskell is garbage collected and doesn't have to deal with type lifetimes, the API issues are less of a problem. If the compiler has inferred that your type `T` has to support the `Query` interface or whatever, maybe it's more obvious to the programmer how that happened. But lifetimes in large Rust programs are ubiquitous, many of them are implicit, and even in small functions it's sometimes hard to figure out why the compiler has decided something needs to live longer. Global lifetime inference would probably lead to some exceptionally confusing situations, especially for beginners.
[Actix-web](http://crates.io/crates/actix-web) has this method `with` that takes a function where you just kind of define what you want from the request (or a tuple, if you need multiple things). In the [very first example](https://actix.rs/api/actix-web/stable/actix_web/) it pulls out data from the path, but just like there's `Path`, there is also `Form` (for form data), `State` for the app state, and so on. How is this achieved? I have tried to read the code and come up with a as simple as possible gist, but there is so much going on, that I can't quite wrap my head around what is happening.
&gt; But where are we getting rid of x? We are returning x while x is still in scope, aren't we? How would this result in a dangling reference? I believe this was referring to the caller who supplied `x` (maybe a `&amp;str` pointing into a `String` that the caller owns) getting rid of it. &gt; Do lifetime annotations in functions affect anything outside of that function? Or are they only annotating within the function scope itself? Changing the lifetimes in a function signature might cause some callers to fail to compile, but other than that they won't change what any calling code is doing. &gt; If we're annotating that x and y should live as long as each other, doesn't that mean x won't go out of scope as early as it would normally (at the end of its block)? As above, the lifetimes don't affect when `x` (or more importantly, the owned value `x` is pointing to, if any) goes out of scope. All they can do is make the program fail to compile if things are going out of scope in some order that's incompatible with the lifetime constraints. This might be unnecessarily verbose, but just in case it helps, here's how I like to read these signatures out in plain English: fn foo&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str For _any_ lifetime `'a`, if this function is passed two arguments that live _at least_ as long as `'a`, then it must return a value that also lives at least as long as `'a`.
This was great I typed a variable name wrong and it gave an error immediately. . I couldn't get completion options to work. Nor did clicking the run with bug arrow did anything for me. 
I've found that the trick to diesel is to treat it as a query builder, not an ORM. Its goal is not to make your database objects look like structs in the language, its goal is purely to build SQL queries and collect the results in a type-safe manner. I found diesel much less frustrating when I realized that.
I’m not finished with them, but my Rust solutions are https://github.com/d3zd3z/adventofcode2018 here.
&gt; how do I introspect the target triple at compile time? I don't know specifics but I believe there's either environment variables or `#[cfg()]` for everything that's in the target triple. However, from the shape of the question this feels like a weird problem. What problem are you actually trying to solve?
&gt; I’ve been using this year to finally dig in to learning rust. Me, too. Working on my first ever open source project contribution as we speak ✋ 
Traits are not data structures you can return from a function. They are interfaces which data structures can implement. You started by trying to return a trait from a function, which doesn’t work in Rust. Instead, you can: - Use `impl Trait` to return a type implementing a trait. - Use type constraints to return some type `T` constrained to implement your trait. - Return `Box&lt;dyn Trait&gt;` to return a trait object, which is a pointer to some unknown type implementing the trait, with dynamic dispatch at runtime to call the appropriate functions for the concrete type being pointed to. I recommend you read the official Rust book’s section on traits.
Traits are not types. When you write `Trait` in type position, it's actually a (legacy) shorthand syntax for `dyn Trait`. `dyn Trait` is always unsized, because it could be any type that implements the trait. When you use `dyn Trait` you have to use it through a layer of indirection, like `Box&lt;dyn Trait&gt;` or `&amp;dyn Trait`, so that you don't need to know the actual underlying type and size.
Hm, makes sense
I think `mysql` is really nice to use (as is the author's async version [mysql\_async](https://docs.rs/mysql_async/0.16.0/mysql_async/)) once you become familiar with the API. You can certainly query more than 12 columns, it is just not as easy to extract deserialized values from a row for more than 12 values; you just have to manually extract them from the `Row` object. Actually, it has been a while since I have done so, but I think you can extract to something like `(Tup12, Tup12)` to extract, say, 24 values. Also, check out my [dbi](https://www.reddit.com/r/rust/comments/9xd6cs/dbi_a_procmacro_based_database_interface_inspired/) library for some attribute based convenience wrappers around `mysql_async`.
What is cloud abi lol Anyway you have cfg for os, cfg for bitness, cfg for nightly , probably nothing for rust version and not sure if cfg for abi (gnu vs msvc)
Or Qt. But sciter does sound cool at first glance
Like nmap?
to add onto that, you can also use generics (`fn do_something&lt;T: Animal&gt;(animal: T)`) to monomorphize the function. It will then generate a different function body for each concrete type used as an argument. All of this should be explained in the rust book, so perhaps you should revisit the relevant chapters there.
Hi I just bought the game and I tried to run it once I got in the main menu I tried to join a official server it took 10 minutes to load then once it was finally done the game just shutdown and dissapreared &amp;#x200B;
[removed]
My solution to day23 was different from everything else I saw, but I think I'll go back and try a partitioning based one to see if I can get it it faster (mine takes about 300ms atm on my machine but I feel it could be under 100!)
I believe you’re looking for /r/playrust
This subreddit is for the Rust programming language, you are looking for the /r/playrust subreddit which is for the Rust game.
This is probably where you want to look: https://doc.rust-lang.org/nomicon/ffi.html looks like you need a `#[link(libname)]` attribute. Also `i8` doesn't correspond to `int`. For a quick and dirty test, you can use `i32` (matches on most 32/64 bit platforms I believe), but the correct way to do it is to use the `c_int` type from the `libc` crate.
lmao rippppppppppppppppppppppsry 
sryyyy 
Hey, just a small suggestion - rename the days from 1 to 9 with a leading zero, so they get sorted properly :)
`rustc --print cfg` produces a list of compiler-defined cfg vars
I think you meant to post here https://www.reddit.com/r/playrust/ This sub reddit is about the programming language called Rust. Good luck with your game :)
&gt; but the correct way to do it is to use the c_int type from the libc crate. Isn't the `libc` crate only necessary if you're actually using functions from it? There *is* `std::os::raw::c_int` after all.
Submit a PR!
Yea, its a nice feature, thanks!
https://docs.rs/crossbeam/0.3.0/crossbeam/sync/struct.ArcCell.html also similar, I think
Relevant plug: I built [cargo-nono](https://github.com/hobofan/cargo-nono) to debug \`no\_std\` inclusion, as long as there isn't better support for it in cargo.
There's a lot of projects out there that could use improved documentation. It's one of the easiest things to do, one of the best ways to improve your understanding of the crate (one of the signs of truly understanding something is being able to explain it well to other people), and one of the most needed things in the rust ecosystem right now.
&gt; could use improved documentation True but that's also not what I want to focus on right now. I want to learn how to actually do the thing and I've found a few nice, simple crates to practice on. I make an effort to deliver a decent documentation with my code but I wouldn't currently want to limit myself to that aspect.
&gt;I still don't understand why a compiled language needs us to manually annotate this. Couldn’t the Rust compiler see that this function could return either x or y and so x and y need to live as long as one another? For a simple example like this, yes, it's probably possible to write a compiler which automatically derives that. The decision of what the compiler should allow you to elide vs. what it should require you to write out explicitly comes down to how complicated it would be to implement in the compiler, and how intuitive it makes your code look. Even if the compiler had a really advanced lifetime elision system, if the human reading the code can't figure out what those derived lifetimes are, it does you no good. In general the compiler won't look at the body of your functions to automatically determine lifetimes, only the type signature. The compiler *will* derive lifetimes for this simple function which only has one borrowed input and a borrowed output: fn id(s: &amp;str) -&gt; &amp;str { s } And for this function which takes two borrowed values but returns an owned value: fn longest(x: &amp;str, y: &amp;str) -&gt; String { if x.len() &gt; y.len() { String::from(x) } else { String::from(y) } } Because for both of those functions there's a single intuitive set of lifetime requirements which makes sense even if you only look at the type signatures.
Yes, bus_queue also works if you replace ArcSwapOption&lt;T&gt; with ArcCell&lt;Option&lt;T&gt;&gt;. In the future I'll try to implement a more generic version which would allow the user to chose between a few of these. 
[Here's an example of something that would be a danging reference if the compiler didn't enforce lifetime rules.](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9bdc3cb6a10f4f582ec7fc3d9a6bd5af) We're not necessarily saying x and y should live as long as each other, we're saying that x and y both need to live at least as long as or longer than the reference that we return.
&gt; I think this attitude abdicates moral and ethical responsibility I think that it abdicates and arrogant point of view that I am capable of judging things as complex and vast the whole world and pretense that my point of view is necessarily the only true, valid and universally applicable for everyone. It also abdicates a silly idea, that for a work to be worthwhile it has to be morally righteous. If anything, the history of XX century is showing us that biggest moral catastrophes, and millions of innocent lives were lost due to actions implemented mostly by morally righteous, politically active youth, that fallen in love with their simplistic ideas about how to "make the world a better place". Hell is paved with good intentions.
[Type casts are built in to the compiler.](https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions) From and Into are traits that handle generic type conversion, but you need to use `Type::from()` or `value.into()` in order to use them.
Eh, I'm on windows and it does order them correctly :P
How low do you want to go? # with rustc To link `/some/path/to/libtesting.a`, you call rustc with `-Lnative=/some/path/to -lstatic=testing` # with cargo You need a build.rs that tells cargo about the c library. https://doc.rust-lang.org/cargo/reference/build-scripts.html#outputs-of-the-build-script Examples: - https://github.com/alexcrichton/rust-ffi-examples/tree/master/rust-to-c # with something else ... Many other build systems try to make this simpler. Nix, Bazel, Buck et al have their own alternatives.
Ah, so lifetimes aren't really about what happens / the scope of within functions, but are really about what is being returned from the function? Like how long the return value lives after the function exits?
That looks really useful, thanks!
Read a file that is on the desktop, when the project file is in a different place?
[See the rust reference section on conditional compilation.](https://doc.rust-lang.org/reference/attributes.html#conditional-compilation)
you can go around the 12 column limit, just write your own row parser thingie. I also complained about this, they are methods for ease of use, but not the only way to get the data.
I also wrote some solutions, see: https://gitlab.com/KonradBorowski/advent-of-code-2018
Yeah, most of the stuff you'll do with lifetimes tends to be around giving stuff to a function or using what a function returns. The other big place you'll see lifetimes are in data types, where a struct needs to ensure that it will live as long as a reference that it holds for example.
Wow, that `text_io` crate is quite nice.
If you'd link it statically, you'd violate the license, no? Also, why even use OpenSSL? Why not, say, for example, BearSSL, or BoringSSL, or one of the numerous other SSL implementations with significantly fewer baggage than OpenSSL. On a vaguely related question, have you considered decentralizing Pijul, ala GitTorrent? Pijul seems doubly suited for this as there already exists [a very good Rust library](https://crates.io/crates/bendy) that one could build such a thing on top of, which you might also, independent of that idea, want to consider for use in Sanakirja.
How about in GitHub? Most people will not clone this repo
Tonight’s nightly at UTC midnight should fix it.
What about using diesel for directly executing SQL? You use it to generate the query and execute it through another mean (like tokio-postgres).
&gt; I think that it abdicates and arrogant point of view that I am capable of judging things as complex and vast as the whole world and pretense that my point of view is necessarily the only true, valid and universally applicable for everyone. I never said that you have to have exactly the same view as everyone else. There are degrees here. I'm sure you agree that taking a stand against racism for example should be demanded of everyone. If someone uses Rust for racist deeds, why should I celebrate? You also don't need to judge things as complex as the whole world to take moral responsibility in your local context. &gt; And that my software is the right place to try to impose such view on everyone. I did not say that your view must necessarily be imposed in software (licenses); There are other ways to act. For example, I could participate in various peace movements or on making sure that crypto-currencies don't become mainstream by outlawing companies from doing exchanges with them. &gt; If anything, the history of XX century is showing us that biggest moral catastrophes, and millions of innocent lives were lost due to actions implemented mostly by morally righteous, politically active youth, that fallen in love with their simplistic ideas about how to "make the world a better place". I would settle for not facilitating making it worse. I'm not expecting you to become a political activist...
&gt; hit a remote DB That's not stateless! The state is held by the DB. If conceptually your repository is the same kind of thing, it 100% should do it's own locking and expose an interface of reentrant (i.e `&amp;self` vs `&amp;mut self`) methods. `MyThing&lt;MockRepo&gt;` will have a field of type `T = MockRepo`, so Rust just embeds a `MockRepo` value within a value of `MyThing` The mock very possibly would have an `Arc&lt;Mutex&gt;` or `Arc&lt;RwLock&gt;` of something but that's the part that's acting like a database. I don't see the disadvantage of having that additional struct. --- Forwarding through `Mutex` isn't a great idea (in general) because it changes the safety characteristics of `&amp;self` methods. `&amp;self` methods are reentrant, specifically meaning: - you may have multiple calls to `&amp;self` methods on the stack at once. If the type is `Sync` safe, you may have those multiple calls on the stacks of multiple threads. So you can call a `&amp;self` method passing a closure which also calls a `&amp;self` method. And even more complex situations should work. Now let's say you forward the calls through Mutex. Your forwarding implementation locks and calls the inner method. In the same situation, you will double-lock the Mutex. That doesn't cause a safety violation, but it doesn't work either. It'll either deadlock or panic. In more complex situations involving different threads you're much more likely to just deadlock. As a result, you've turned an interface which allows you to alias `&amp;` references into one which doesn't. Rust prevents you from causing a data race or whatever, but "safe" code is allowed to have resource-wasting misbehaviour such as leaking or deadlocking. That's the general reason why `Mutex` doesn't forward traits. If you have a trait where aliasing `&amp;self` within the same thread isn't likely to happen in any way, then you might have an argument for forwarding it. 
Also, note that this is a C function. If it were a C++ function it would be a much larger pain in the butt to call.
PoS isn't truly trustless/decentralized/secure. Also it consumes other resources instead of electricity, it's just less obvious.
I'm glad to see someone who isn't judgemental of what people purchase with their own hard earned money. Keep it up!
I understand that you'd rather see the world without having to burn electricity, build tanks, aircraft carriers, guns, door locks... I'd love to see the world in which people just get along, don't steal, don't murder... Unfortunately, it's not realistic and we have to do many these things to protect ourselves from thieves and murderers. It sucks, but it's the best we have. Or do you have some other way of making everyone to not be a criminal? I'd be very happy to hear!
And everything trying to implement secure (even from government) currency must have to use PoW.
I just finished an MVP: [https://github.com/wbw1974/slider](https://github.com/wbw1974/slider) I start the refactoring tomorrow to turn the CLI app into a GUI game.
As a general rule, you should use `Ordering::SeqCst` as the placeholder if you are not sure which ordering to use.
Unfortunately, many of those alternatives aren't secure (from government intervention) and I doubt there will ever be something that doesn't consume big amount of some resource and secure at the same time.
That article doesn't cite any references, nor does it explain how the consumption is calculated, so why should anyone believe it?
Unfortunately it is currently inherent property of **secure** cryptocurrencies. The word "crypto" in "cryptocurrency" refers to how it's governed, not to anything else (otherwise USD and EUR would be cryptocurrencies too, because they use cryptography, then the word loses its meaning). Gold is governed by nature, fiat is governed by government and cryptocurrency is governed by math. If a cryptocurrency is not secure from government, then it can be governed by government, thus ceases to be cryptocurrency. Currently the only trustless/secure cryptocurrencies are those consuming lot of electricity, Bitcoin being the most secure of all.
As someone who is starting with rust and is also making repos of challenges like this where there is a series of solved coding problems is this the recommended way to organize such a repo? directories representing problems and then a cargo project within each of those directories? Is there an advantage to doing this over of just having .rs files and a gitignore the excludes the binaries? I do like this style and now I am kinda regretting organizing my repo as: /prob01/p1.rs, /prob02/p2.rs, etc. 
That can make a difference for FFI.
Yeah, because everyone having more than 10000€ on Cyprus account was a criminal, every Venezuelan trying to save money is a criminal, every Indian using cash is a criminal, every gab.com user is a criminal, every creator accepting donations via anything else than Patreon is a criminal, every competitor to Andrej Babis (Czech prime minister) is a criminal, because government has nature-given and God-given moral right to take whatever property they wish to take, to imprison you for just anything they come up with, to kill you whenever they want, and anyone trying to protect from them is just a bad person that must burn in hell!!! /s
Did you ever think about what "outlawing" is *physicaly*? What it really is, is governed saying "if you do X, we will take your property, your liberty or your life". Would you really want to kill someone, kidnap someone or steal from someone, just because he voluntarily entered into a contract with another person who is completely unrelated to you? Do you think *that* is moral?
&gt; Did you ever think about what "outlawing" is physicaly? What it really is, is governed saying "if you do X, we will take your property, your liberty [..]. Would you really want to [..] kidnap someone or steal from someone, just because he voluntarily entered into a contract with another person who is completely unrelated to you? Do you think that is moral? What happens if you refuse to pay your taxes or if some company violates regulations? Either they pay fines or executives go to jail. It's no different here. I think that cryptocurrencies such as bitcoin are harmful to society (bitcoin specifically is deflationary) and undermines the ability of governments to function. &gt; Would you really want to kill someone Capital punishment is **never** OK.
I don't think there are any guidelines for this, it's just personal taste. For me it was easier to keep the problems separate this way, and not sharing any code means the problems are frozen as they were when I completed them, so there's no danger of accidentally changing something when I do another day's problem.
This looks awesome! Question: Is there any recommended best practices for passing around secrets (into functions and whatnot) such that they are not copied, cloned, and generally stay in one place so they can be safely zeroed after they are finished being used?
I like the drop approach, though, because I think it makes it a bit more clear that a value is being ignored. 
I have chosen a more module-based approach, with a few top-level crates one for each year, one for shared code, and one for the solution runner. You can find it at https://github.com/Saser/adventofcode Perhaps a bit more complicated, but I get niceties such as immediately detecting if changing the shared code breaks something, both through the compiler and through unit tests (I aim to have a unit test for each day and part, with my actual input and the expected answer). It also lets me introduce project-wide changes easily, for example I intend to add the ability to benchmark solutions at some point. Downsides are that it is a bit more of a hassle to set up, and compile times seem to be longer.
It's stateless in the sense that the state is held externally to the application, so it's already shared by virtue of not being inside the app, this is what I meant. And yes I agree that using &amp;self methods with mutexes is prone to deadlocks, in this case the trait in question does use &amp;mut self methods. &amp;#x200B; I don't see why using &amp;self is a given for a repository, take the Redis crate for instance, the connection object itself has &amp;mut methods and you often want to have multiple independent connections in different places to make sure they don't interfere with each other, e.g. with multiple repository instances; in many cases (in my case) you end up with several threads each with their own instance. So now because the repository must take &amp;self it's suddenly crippled and needs to either use a Mutex/RefCell for no other reason than to satisfy the trait. This is what I mean by interior mutability being "baked in" the trait, it seems unnecessarily restrictive and arbitrary in some cases, and god knows how many times I've been too explicit/specific with my traits just to come back a few weeks later and think "what the hell was I thinking here".
Thanks!
Hi. Cool crate. Would be nice if you could format it with rustfmt though
I'm wondering where you stand on name squatting in crates.io. I see you have quite a large number of crates allocated, most empty but some with quite good content. Are you keeping these safe for people with a legitimate case to use them, or are you holding them all for yourself? I ask in part about [curves](https://crates.io/crates/curves), which I'd like to use, but I'll come up with a different name if not.
It sounds like you're asking "how do I read bytes from a file in general?" Have you looked at https://doc.rust-lang.org/std/fs/struct.File.html or https://doc.rust-lang.org/std/fs/fn.read.html?
Yep, definitely agree, although you'll notice I still had to do a bit of manual parsing for some of the problems.
Yeah, that's a good general rule to follow, I did the complete opposite :)
Thanks a lot. It works
thanks. ;)
Haven't read it yet, but based on the title this is exactly my preferred learning style (start with the lowest level and go up) so thanks!
I started working on a HTTP health check tool: [https://github.com/greyblake/hellcheck](https://github.com/greyblake/hellcheck)
I will be happy if it can help you😃
Hey Paul, I'd be more than happy to watch your presentation and give you some feedback. Thanks for the updates, everything looks awesome!
The Reddit title is very misleading. 
Author here One of the most striking things as I ran the numbers for this post was the incredible growth of of the Rust programming language among developers. I consider myself to be reasonably tech savvy and this completely took me by surprise. The growth is admittedly off of a small base (4-5% of US developers who took the Stack Overflow survey) but still quite impressive and it bodes well for the future of the language. Would love to better understand from folks here who might know better - why the growth? I'm sure mean reversion eventually kicks in here, but for now this is a very exciting trend - Rust developers and fanatics that that community is growing A friend of mine (former Israeli military programmer) who is a fan of Rust recommended I post on this subreddit specifically. Hope you all enjoy the broader post and take a chance to bask in the future glory that is Rust. Happy to answer any questions on the analysis
There's a risk of confusing people if async/await features are referred to as "coroutines" because there are "(stackful) coroutine" libraries for Rust out there, with a different approach.
I think I mentioned in blog “coroutine in this blog refers to stackless coroutine based on rust generator instead of green thread(stackful coroutine) which is obsoleted by rust earlier”. Should I explain that there are some community projects have implemented green thread？
I'm referring strictly to the title (here, on github, in the table of contents, etc.), not the content (which is clearly about async/await), to be clear. Replacing "coroutine" to "coroutine (generator) async" or similar might be enough. Too bad reddit post titles aren't editable :(
Thank you! I'll contact you end of January to schedule a call if that's still ok with you.
stackless coroutine may be better. I will change some ambiguous titles when I get my laptop. Thx
`for&lt;'a, 'b&gt; Fn(&amp;'a mut Cow&lt;'b, str&gt;)` works fine in a 'static. The point is that events should be able to have locally-owned references in them. For example: ``` struct WorldEvent&lt;'a&gt; { world: &amp;'a World, ... } ``` You don't wanna move the World around or copy the World around. You do want a reference to it. But how can you have this when the type system is so limited?
The "excessive" use of Arc allows what I call "freelocking". Mutating a Vec can be slow, and we don't want to block the readers too much. As such, we spend very little time in the read lock, and take an Arc to the inner Vec instead. We can then easily lock for writing regardless of fairness, and spend a short amount of time on the write lock as well.
Here's a fix. The [BufRead::line()](https://doc.rust-lang.org/std/io/trait.BufRead.html#method.lines) consumes the original buffer, returning a Lines iterator. The BufReader's ownership was moved into the `BufRead::line()` function and never returned, so calling `f.lines()` multiple times is an error. You collect the Lines iterator into a Vec first, then just operate on a borrowing iterator inside the while loop. BUT! Can you explain what you're trying to accomplish? I have a feeling that the structure of the program itself is wrong and that the entire outer while loop can be removed.
I feel this is especially because C is such an awful language. I guess many people who write high level languages like Python, JavaScript, Ruby, Haskell, ... see the need for / and would like to write faster and more memory efficient code sometimes. But using C is no fun at all if you're used to high level language constructs. Rust finally fills this gap.
&gt; Most people think that programming is how you speak to computers. Really, it's how you speak to other developers. Good observation -- takes some people a while to understand this. &gt; Would love to better understand from folks here who might know better - why the growth? Can't speak for the broader community at all. But I spent a stint at Dropbox, and we were perhaps one of the larger adopters of Rust. Wired [did a story](https://www.wired.com/2016/03/epic-story-dropboxs-exodus-amazon-cloud-empire/) that mentioned it, so should be public knowledge. Rationale behind decision is included somewhat in there, although I don't want to go into much more detail. I imagine that there are a number of other tech companies out here in Silicon Valley who work with servers on the cloud that have to do heavy lifting and are light-weight in memory, and I suspect a similar decision might be made at those companies. Chucklefish (indie game dev, Stardew Valley fame) also [engaged here with the community](https://www.reddit.com/r/rust/comments/78bowa/hey_this_is_kyren_from_chucklefish_we_make_and/?st=jq4n7roz&amp;sh=ad2ab63e) in a pretty cool way -- the indie-game-maker scene is pretty niche but pretty cool, so that might have an effect on popularity of rust. I'm pretty sure telling a bunch of passionate game-makers "Rust is not yet ready for game development" is a good way to make some nerds want to try....... And then of course [we won the StackOverflow "Most Loved Language"](https://www.reddit.com/r/rust/comments/842adc/rust_voted_most_loved_language_for_the_3rd_year/?st=jq4n55ol&amp;sh=3b0ef068) 3 years in a row (pls ignore small n lol), which probably attracts some more folks and maybe helps build a virtuous circle as people come see what all the fuss/love is about -- and then stay once they see it too! Anyways -- just my thoughts on why Rust looks like such a huge outlier on your chart. I could be way off or missing something... **TL;DR -- [ small sample size X high amounts of passion ] + [ big name tech company usage ]**
Enjoyed reading the article. Some typos from those that i has noticed: men::replace &amp; men::swap i guess should be mem.
Nah there's a new module in the standard library that allows you easily get rid of annoying men. It includes functions like `std::men::{forget, swap, replace}`. :P
Isnt Phantom Data Zero sized and thus optimised away?
This was an otherwise good article, but a couple of things seemed odd to me. &gt;While Rust is technically a general-purpose language, due to its low-level nature, it is best used for embedded systems running close to bare metal. This feels kind of hand-waivy. Just because Rust can be suitable for embedded development on some architectures doesn't mean it is *best used* for embedded development. Would you say C is best used for embedded just because it is low level? &gt;Rust is often known to create fanatics among its users. I think you probably didn't mean anything by this, but I'm not sure if you're aware that the word "fanatic" has a connotation associated with it. It characterizes people who have extreme and uncritical devotion. Religious cults, the alt right, and ISIS are examples of fanatics. In my experience, the Rust community is known for being very grounded and accepting of criticism. Maybe the word you were looking for is "enthusiastic."
In C++ there exists an alternative to push_back on vector (or other containers): emplace_back (see e.g. [here](https://stackoverflow.com/questions/4303513) why). Of course you cant do exactly the same thing in rust, but is the underlying problem also present in rust, and if so, how is it solved?
Thanks for reading and commenting Agree that being low-level is not a complete recipe for being "best used" for embedded systems. My guess is that this is more of a "necessary but not sufficient" trait when it comes to working with bare metal. Would you agree with that framing (maybe "necessary" is too strong)? Correct - did not mean anything by "fanatics", and the word has no negative connotation for me (there's even a \~3k employee sports apparel company named [Fanatics](https://www.fanatics.com/), so I'm not the only one). Totally aware of and understand that others use it differently however. Thanks for calling out. Again, appreciate the time spent and your thoughtfulness!
I simply don't understand why the Rust team simply don't adopt the usual term for such things, wasn't it already "generator" standard practice? Looks like I'm watching the "reference" vs "pointer" nomenclature mess all over again. Long time ago Rust used to use the term "pointer" for what it has adopted "reference" today, and that caused a lot of confusion for those that were used to see reference as a synonym for alias, which has been standard practice and is implemented in a bunch of other languages, C++, VB.NET, PHP, C#, etc. To use "reference" to mean "alias" has been honored even by a Turing award, since 1974. Despite that, I've seen Rustaceans completely oversee that and blame the other languages for causing confusion in people's mind about what references are!(?) Now comes the coroutines (also generally called generators???).
Cool thanks, I was wondering if it would be something like that. I tried and it's fine now.
Pointers and references are not the same thing. As far as the type system is concerned, the type `&amp;u64` does not exist: a reference is polymorphic over the pointee's lifetime so it has to be `&amp;'static u64` or `&amp;'a u64`. The borrow checker assigns each reference a different (unnameable) type based on the life of the data it points to and uses that extra type information to verify that Rust's aliasing rules are not broken. This is why Rust has a separate type, raw pointers (`*T`), that suspend those rules - mostly for use in unsafe code.
LLVM refers to them as coroutines iirc. It is a bit sad that "references" have multiple meanings and people get confused, but it should be noted that they arent the exact same as pointers, they have requirements that raw pointers don't have.
You are right, of course! But the array trick is good for golf ;-)
Last time I had numbers from exercism for Rust, every mentor would have to cover 20 reviews per week to keep up with the influx. So: yes, it's indeed used a lot and the moderators are active, but there's much more mentors needed.
People really want a C++ replacement and all the other languages that claim to be one (Go, D etc.) don't have zero-cost abstractions so they are not a C++ replacement. And Nim's design &amp; type system is not as good as Rust's (and more brain power is dedicated to Rust's design).
In C++ land there's a mildly similar dichotomy, but there, the pointers with additional rules came to be referred by smart, so, smart **pointers**. This is why C++ has those enriched types, smart pointers, that resemble the raw ones, but add those rules - mostly for use in safer code. Things that have been usual of pointers: - Dereference to get the value - Pointer to pointers Things that have been usual of references, as aliases: - no dereference to get the value - a `swap` operation that can swap outer variables can exist through them - no reference to reference (the nature of aliases is to end up collapsing) Of these what causes me the most estrangement is seeing dereferentiable references (which barely from naming feels natural, but isn't, since dereferentiation has become particular of pointers and nonsense to aliases).
It would be interesting to do another chart where the data of multiple years is taken into account, to put a curve to each language's growth &amp; extrapolate the future direction for each language..
&gt; ...and undermines the ability of governments to function. This is the whole *raison d'etre* for crypto. Government action has been misused to prevent people engaging in mutually exchanges, so much so that it is economically viable to sink huge amounts of resources into getting around it. Yeah, it would be better if those resources didn't have to be expended, but that would require governments embracing laissez-faire capitalism and rejecting fiat currency. Given the apparent unlikelihood of *that*, creating a workaround is the next best thing. The endeavor is heroic. &gt; Capital punishment is never OK. But jail is? People need liberty and property to live; they use their time and effort (i.e. their life) to gain them. Taking them from someone *is* taking their life, just not all of it. Those three punishments the previous poster outlined differ in degree (and perhaps reversibility), but not in kind. Obviously, the question still remains of what degree of punishment is justified for what crime, but the government is destroying people either way. Is it the proper function of government to destroying people because they engaged in certain types of mutually voluntary transactions? I agree with you that there's no difference between locking someone up for selling/buying something the government has deemed illegal, for refusing to pay their taxes, or for violating regulations. As long as the action hasn't violated anyone else's individual rights, ([life, liberty, property, pursuit of happiness](http://aynrandlexicon.com/lexicon/capitalism.html)) it would be wrong for the government to punish the actor for it.
Had the same issue yesterday. Had to reinstall rustup without nightly.
When you use trait as type you actully use `dyn Trait`. It is unsized type that holds any type that implements `Trait`. Since it is unsized you can't return it from function unwrapped (can't use it in argument or put on stack either). But `&amp;dyn Trait` is sized, same as `Box&lt;dyn Trait&gt;` and other pointers. So your first error is about `dyn Animal` type being unsized. Once you add `Sized` bound to the `Animal`&lt; trait you completely disallow `dyn Animal`. Why? Because `dyn Animal` is unsized and this violate trait bound. Later you tried to call `create` with `Self: Sized` bound via `&amp;dyn Animal` and it failed for the same reason - `dyn Animal` is not `Sized` so bounds on the function disallows it. Actually there is deeper reason, but typechecker cought you first.
To be clear, rust does not use llvm coroutines.
If you have yet to try Discord for calling, I bet you'll be impressed. You can do screensharing too, even for groups very easily. It's cross-platform and very stable. You guys can easily meet up in the Rust Discord server: https://discordapp.com/invite/rust-lang Good luck with your talk, and thanks for making Tantivy.
According to the homepage the latest version is 1.31.1, and has been for days, however the standalone installers (https://forge.rust-lang.org/other-installation-methods.html) are (at the moment) still at 1.31.0. Is that a bug or did nothing change for the standalone versions? Also: The link to "Past releases can be found in the archives." is also broken. So the tarball installs don't seem to receive enough love? :-/ Where to report such issues? (that probably broke with the new webpage) 
I usually use Google Hangout for that. Is it better?
In addition to what others said It looks like you are trying to use the factory pattern. This pattern requires you to distinguish between the factory and the object to be created. This would look like [this] (https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a731708421e855e5738a66f749c27421 If you don't use a factory, then you code will most likely look like [this] (https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a49b90d53e08bf716e7195958f2a9636) Note that there is no need to mention the trait all the time. The cat can create sounds without knowing that it is an animal.
Basically , You need to use type parameters to determine whether it is covariant or invariant in relation to lifetimes. If you store &amp;'a T, you can store &amp;'static T too, that is covariance. But if you store &amp;'a mut T, you can't store &amp;mut 'staic T. or something like that. This also applies to function argument, and return values, So variance of closures is aloso inferred. This is automatically performed by the compiler, and propagatet throughout the structure definitions.
Good work. Thank you for tantivy. We moved from sphinx to it. Now almost our stack is rust-based.
Glad to hear! Can you share what do you use it for?
Audiobooks online library (1 millon/month users), news agency platform (1.5 million/month) and smm tool which analyzes billions of news, publications from twitter, facebook etc.
And yes, next summer I want to integrate it into admin of my system for music festival: [https://www.reddit.com/r/rust/comments/8xdsx5/rust\_actixweb\_in\_the\_on\_of\_the\_biggest\_music/](https://www.reddit.com/r/rust/comments/8xdsx5/rust_actixweb_in_the_on_of_the_biggest_music/). 
The sports teams are using it in the same context, fyi. As in they are such loyal fans that they are extreme and uncritical when it comes to their team. They are proudly using a word with a negative connotation jokingly to say they are the biggest fans. The word "fan" comes from the word "fanatic" because that joke is so longstanding in a sports context. Outside a sports context it is a pejorative term. Modern English is really weird when you look.
Wow that's awesome!
I don't understand why you're bike shedding Rust names using examples from a language whose only connection to Rust is through the C ABI, which does not have a concept of smart pointers or anything even remotely resembling high level memory management. Do you expect Rust to implement trait inheritance and enum templates too? I'm being facetious here - those concepts do have analogues in Rust - but just because the concepts have a passing resemblance doesn't mean that Rust should try to shoehorn in terms that make no sense in the bigger picture. Rust's place as a systems language doesn't mean that its concepts must be expressed using the same terminology as other languages filling the same niche. You had a good point with the coroutines/generators dichotomy because Rust "coroutines" cannot be resumed with new inputs (except indirectly through the unstable async/await/futures api) which limits them to the generator subset but C++ references are simply nothing like Rust's references. A C++ reference is basically an immutable `*mut T` with a single `Deref&lt;Target=T&gt;` implementation, a non-null guarantee, and a very weak aliasing guarantee (you might as well just stick it in a `const *T`). Working with such a type in Rust would require putting almost everything in an unsafe block, entirely defeating the purpose of the language. 
I have a Rust 2018 library named `foo` that includes a binary: Cargo.toml src/ lib.rs bin/ main.rs How do I access `foo` in `main.rs`? With `extern crate foo` I get the error "can't find crate for \`foo\`" and without it I get the error "use of undeclared type or module \`foo\`".
And Parity is working on a Zcash client in Rust https://github.com/paritytech/parity-zcash
Hey Richhyd, just letting you know that I tried out `structopt` on a different algorithm and it was *really* awesome. the problem I have with it right now is that is does not support ignoring certain fields in a struct. The following is a trivial example: #[derive(Debug, StructOpt)] #[structopt(name = "BerlekampMassey", about = "A Rust implementation of the BerlekampMassey algorithm")] struct BerlekampMassey { len: usize, #[structopt(short = "s", long = "sequence")] s: Vec&lt;i32&gt;, } `len` is derived from the length of `s` however I cannot omit it from being passed in the CLI. Apparently it's an [issue](https://github.com/TeXitoi/structopt/issues/8) with the `Clap` crate. The above is quite a trivial example so I'll probably get some workaround going.
&gt; This is the whole raison d'etre for crypto. Government action has been misused to prevent people engaging in mutually exchanges, so much so that it is economically viable to sink huge amounts of resources into getting around it. Yeah, it would be better if those resources didn't have to be expended, but that would require governments embracing laissez-faire capitalism and rejecting fiat currency. First, I think the idea of apolitical money is a fantasy; Yanis Varoufakis discusses that [in a lecture](https://www.youtube.com/watch?v=zi-dXc0bKUM). Using bitcoin as an example, since it is deflationary (which is harmful since it incentivizes hoarding money -- a bit of inflation is useful..), if it would become widely used, it would create major problems for the world economy. Further, I disagree with this raison d'etre. If the goal is to undermine the ability of governments to finance universal healthcare and other things that we have democratically and collectively decided, then government should use coercive means to stop you from doing so. &gt; Given the apparent unlikelihood of that, creating a workaround is the next best thing, heroic even. Maybe in the Ayn Rand-ist world view, which is fortunately fringe even in the most "libertarian" of circles. &gt; But jail is? Yes; capital punishment is an irrevocable form of state sanctioned murder and revenge that does not prevent harm. Justice should be restorative and focused on reducing harm. &gt; Is it the proper function of government to destroy people because they engaged in certain types of mutually voluntary transactions? It's should not be the goal to destroy anyone; but if a company engages in behavior that is harmful to most people, it should be prevented from doing so. It doesn't have to be so dramatic, companies would likely stop conducting transactions in crypto currencies given such legislation. &gt; As long as the action hasn't violated anyone else's individual rights, (life, liberty, property, pursuit of happiness) it would be wrong for the government to visit any degree of destruction upon the actor. I disagree with the notion of regarding private property, as opposed to personal property, as an indisputable and absolute individual right. Indeed, many governments have the concept of [Eminent domain](https://en.wikipedia.org/wiki/Eminent_domain) limiting that right. Liberty is vaguely defined here. There are other things I would consider human rights, e.g. healthcare, somewhere to live, and free public transportation, that are necessary for true liberty. As Anatole France put it, "The law, in its majestic equality, forbids rich and poor alike to sleep under bridges, to beg in the streets, and to steal their bread." -- if the only way to be heard is through drowning out everyone else's voice by having control of all media through capital, then what is the use of free speech? I think the notion that you may do as you will without consideration for how you pollute the climate, that you may employ workers with no job security, that you sell some non-tested drug that is harmful to others, or that you refuse to pay taxes but yet want to take advantage of roads and other infrastructure, is all untenable. Doing so would demonstrably infringe on other people's liberty and welfare.
Eminent domain (United States, Philippines), land acquisition (India, Malaysia, Singapore), compulsory purchase (United Kingdom, New Zealand, Ireland), resumption (Hong Kong, Uganda), resumption/compulsory acquisition (Australia), or expropriation (France, Italy, Mexico, South Africa, Canada, Brazil, Portugal, Spain, Chile, Denmark, Sweden, Germany, Panama) is the power of a state, provincial, or national government to take private property for public use only if the government provides fair compensation to the property owner. However, this power can be legislatively delegated by the state to municipalities, government subdivisions, or even to private persons or corporations, when they are authorized by the legislature to exercise the functions of public character.
€100.000 in Cyprus.
You need to write `::foo` func(::foo::CONST); use ::foo; func(foo::CONST);
Rust puts additional constraints on the developer. Because of this classes of mistakes are eliminated, what's more it forces the developer to re-evaluate his existing ideas he had about programming. I think both of these outcomes are very attractive. Same goes for Haskell.
Seems like the account was deleted and then recreated recently: https://github.com/purpliminal. Might be a name squatter? 
Yeah we are not a cult and striving to be open ^^^(except ^^^with ^^^the ^^^heretics) ^^^^/s
Why are all the things implemented \`asyncio\` required at all? Can't all of this boilerplate already be provided by \`mio\`? 
I tried that in a new repository and it worked. However, in the repository where I have this problem I also have this line in `Cargo.toml`: [lib] crate-type = ["cdylib"] And when I add that line to the new repository and try `::foo` I get this error: "unresolved import \`foo\`".
https://github.com/NuxiNL/cloudlibc
For me, lifetime variance was key to better understand lifetimes. [https://doc.rust-lang.org/nomicon/subtyping.html](https://doc.rust-lang.org/nomicon/subtyping.html)
I think that is a fairly minor factor in Rust's popularity. More important is the lack of garbage collector. If you don't want / can't have that what choices are there? The only ones I know are C, C++, Rust, and Zig (I think?).
I prefer my men with `no_std`
To be honest, I am not sure that any alternative is scure from government intervention. For anything that consumes resources, a government is quite likely to have more resources that a motley collection of individuals. The bitcoin model, for example, which requires that 50+% of the network approves a transaction is quite susceptible to hostile take-overs; when you know that the top 5 or 6 miners account for a very large portion (90+%?) of approvals, a collusion between 2 or 3 of them may be sufficient.
Congrats for the new release! Tantivy always excites me, but as I remember from Lucene, it allowed dynamic fields in each document, meaning It did not need a schema, but tantivy seems like it works with strict schemas. Am I wrong? Is there any plan for that? 
The way I would handle this is to have one struct that matches your command line args, and another that matches what you need for your algorithm, and then implement `From` to get between them. This should end up getting optimized to what you would have written by hand using 1 struct. It has the advantage that the mental model is easier, and you can change your algorithm struct without it being seen in your interface.
&gt; I fixed this Oh, well :) Then `foo` without leading `::` should also work for you. See my latest edits. 
That's definitely a cool way to approach it. Thanks! 
` # git clone git@github.com:tantivy-search/tantivy.git Cloning into 'tantivy'... git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. ` 
That's a question for GitHub I believe :). Have you tried the https url?
I was a contributer a while ago to that project, and the author hasn’t been responding for dome time... i’m not too surprised that he deleted the account
Consider spending the entire time sharing query examples and their performance, rather than presenting a comprehensive overview. As a member of the audience, I don't care about the details of the system as much as what I can do with it (and why I would use it rather than something else). Examples: How can I use tantivy and radon to walk through a directory of academic research pdf documents and find those that mention certain topics? Arxiv.org and ssrn.com share research without a firewall.
\#metoo
Audible?
Wow, just saw this! Can you talk about your server hardware and networking?
Your team is doing all the cool Rust work. Concerts and now this? 
yes i just meant might want change the readme file.
This looks like the AoC challenge. InnPatron already gave the answer, but here are few more tips: * All inputs will be integers so you can replace the f64 by i64. * There is no need to use a HashMap with dummy values, you can use a HashSet instead. * You can use numbers as keys in HashMap, no need to convert to string first. * This is a nice usecase for the iterator cycle() method, which will repeat the elements of an iterator forever. * If you do want to use two nested loops instead, you can use labeled loop to break directly. Replace outer by loop by `outer: while`and the break by `break ’outer`. I am not criticizing, the code looks fine as it is apart from the one compiler error, these are just some tips to improve your Rust skills.
Lack of GC and safety. safety is provided by before mentioned constrained, and the alternative for GC is also made with help of those constraints. I think the root cause of popularity is adding additional constraints.
I wouldn't call C awful. C++ is. C is doing his job well enough. But Rust can replace both in most cases.
Not specific to large-data, but by far the best verbal description of ownership / lifetime I have seen is this tutorial: [http://intorust.com/tutorial/ownership/](http://intorust.com/tutorial/ownership/)
Ah I see! Thanks! Fixing it.
Amusing; I would rather have just a few data-points / examples and a deep dive into the internals and what the architecture is that enables the performance; discussion of pros/cons of certain architecture choices; insights on the key performance enablers that push it ahead of other stacks; etc...
Almost among all English speakers have a negative association with the word "fanatic", so the "others" constitute in fact the majority understanding.
I think we can all settle on *difficult* rather than *awful*. C and C++ do not forgive the slightest mistake; they're harsh, and therefore make the life of their developers difficult.
Hmmm... I think Lucene requires a schema. But maybe they added a feature recently? Or are you thinking of Elasticsearch? I think they try to abstract a schemaless search on top of lucene by inferring your schema from your data. There is a ticket to mimick a have a somewhat dynamic field. The most tricky part is what to do with fieldnorms.
I am developing an experimental DBMS in Rust. see the [StellarSQL](https://github.com/tigercosmos/StellarSQL). 
To be honest, I am not a fan of the year-on-year growth model. There's even an xkcd about it: https://xkcd.com/1102/ If you have 1 user and get another user, you have 100% growth... but it's still only +1. I find Go's growth much more impressive, because of its larger base.
Pretty sure it's code generations and some unsafe trickery along with traits 
Have you looked into the example directory? It is not that bad.
https://xkcd.com/1102/
That jobs list is looking pretty good this week, with 7 jobs!
The following works with Lucene, without declaring a schema first: &amp;#x200B; `FSDirectory dir = FSDirectory.open(Paths.get(INDEX_DIR));` `IndexWriterConfig config = new IndexWriterConfig(new StandardAnalyzer());` `IndexWriter writer = new IndexWriter(dir, config);` `Document doc1 = new Document();` `doc1.add(new StringField("yes", "3", Field.Store.YES));` `writer.addDocument(doc1);` `writer.commit();` `Document doc2 = new Document();` `doc2.add(new StringField("id", "3", Field.Store.YES));` `writer.addDocument(doc2);` `writer.commit();` `writer.close();`
Providing an implementation of Display as well (even if only on request) would establish a nice symmetry. Another would be a 'slack' mode where any punctuation implicitly gets surrounded with \s*
I think it heavily depends on the audience composition.
Does crates.io have a policy for reclaiming such crates?
If the projects were released under a FLOSS license, it should have, since the author can't decide to revoke it retroactively, so distribution and extension would still be permitted.
It’s not a problem to fork the code. The issue is with the crates.io entry and the trust people have in it. It’s hard to transfer this without the original developer giving their consent. 
I think we should retire the name if the original developer does not consent to give it to someone. 
There is more than one author on the package though.
is that your channel?
Ah. So the problem is that github allows account reuse and cannot be trusted?
Yeah. Crates.io would have to disassociate reused github users from older packages. 
would like to let you check an implementation for a multiplexed p2p network which is written in Rust. Welcome to PR [https://github.com/driftluo/p2p](https://github.com/driftluo/p2p)
The forge has its own tracker, report them there. None of this has anything to do with the new site. Each subdomain is a different one. 
oh I see what you mean then! Yeah I am not entirely sure what is the best solution is here.
Yes I considered doing that, but didn’t feel like the data was coded consistently enough across 2017 and 2018 to make the comparison. Probably possible, but would require some data cleaning. Might go through the exercise once I have some more time
Fair point, and one that I would likely make myself if I was a third party seeing this data. However I would note that there are many languages with about the same level of penetration among developers as Rust but not nearly as much growth. In that sense, relative to its popularity, Rust is growing disproportionately quicker than any other language of similar scale. That is notable in and of itself. But yes, the absolute growth rate of 100% does not, by itself, tell the full story
Trying to learn futures, for the purpose of creating a high-level Fetch API with wasm_bindgen. Eg like Python's Requests or Rust's reqwests, but compatible with the wasm32-unknown-unknown tgt.
Yes, the underlying issue does exist. It isn't really solved yet, except relying on optimizations to elide the copy. There is a potential feature that will fix this - placement new; if you had it, you could do something like `vec.back() &lt;- MyStruct { foo: "bar" };` (not totally clear on the syntax), which would be basically equal to C++'s `vec.emplace_back("bar")`.
Could you please open an issue [here](https://github.com/intellij-rust/intellij-rust/issues)? I just tried to use RegexSet and completion [works fine](https://imgur.com/a/vbVDww5), so this is an interesting case.
All I want for Christmas is a c++ but without some of the more insane or broken design decisions, particularly when it comes to accidental data sharing or references going out of scope, but also the basics like integer promotion The problem at least for me is that every language I've tried other than c++ trends to hit a pretty firm brick wall of functionality where it lacks the power of c++ and you're forced to write crappy code which is why I'm hesitant to jump on the rust train. I have no idea if there's any equivalent of non type template parameters or making c function pointers from templates or parameter packs etc which is what makes me hesitant to jump on board It does seem like if you just want a better *C* then it'd be a massive improvement in its current form though
&gt; stabilize Rc, Arc and Pin as method receivers &gt; stabilize min_const_unsafe_fn in 1.33 &gt; stabilize Vec(Deque)::resize_with &gt; stabilize Pin &gt; stabilize underscore_imports It looks like there are some exciting stabilizations in the pipe for 1.33!
Unfortunately, completion for `RegexSet` doesn't work because this struct and impl are defined via macros. We are working on [this problem](https://github.com/intellij-rust/intellij-rust/pull/3015), hope it will be ready soon :) &amp;#x200B; Also, with regard to rustc errors, you can try cargo check inside IntelliJ Rust via `Preferences -&gt; Languages &amp; Frameworks -&gt; Rust -&gt; Cargo -&gt; Use cargo check to analyze code`
I don't think serde will cause any issues with endianess -- it's perfectly capable of dealing with it. That said, if you just are serializing to some custom format, it's fine to hand write the serializing code. The ideal case for serde is when you have some general format and you have a bunch of different structs you want to serialize and/or deserialize them all to this format. It'll work, but might be overkill. Either way you might want to use the byteorder crate though https://github.com/BurntSushi/byteorder
I thought that the "smart" pointer name predated c++'s usage, and dated to objective-c back in NeXT days, where they were often the source of memory leaks due to them being a leaky abstraction for implementing reference counting when message passing in objc. The reason for them being so-called "smart" were just because objc was mostly built on C, specifically gcc, and the message-passing syntax of smalltalk conflicted with the c-language syntax and runtime usage of pointers, and a broken mish-mash resulted, with smart pointers resulting as the name because they were pointers, and they tried to be smart, but they generally weren't. Anyway, opaque references, which are common, seem to be a better naming convention to indicate what rust is providing than naming them them for raw pointers with (historically poorly-enforced) enrichment rules.
I'm not being C++ specific is most of my arguing, I brought it in specific at **one** point of comparison (the initial paragraph of the previous message), for having two points of comparison regarding honoring standard nomenclature. Anyway, you're right, this is bike shedding, and won't stop Rust's disregard for standard practices. They may give new meanings for general terms, or equate them to the more specific ones, as they please.
&gt;Highlight usages of unsafe code. It should allow you to correctly understand what piece of code in `unsafe` function or block is really unsafe That seems really cool and super useful yet pretty trivial (in the sense that I'm surprised I didn't think of it, not surprised that it wasn't implemented already) &amp;#x200B;
I'm not disputing the origin, just pointing that their name honor what they do and/or resemble, and most importantly, don't dishonor previous nomenclature (smart pointers cold have been misnamed smart references).
As the other comment mentioned, its a AoC challenge problem. You needed to run through file of numbers looking for a specific sum that appeared twice and return that number. Thanks for the \`collect\` method, I'll read up on it, I feel like I'm going to be using it a alot.
Oh wow, that's great news. Didn't realise they were macros. In fact I think macros tend to be the bane of IDE plugin writers (CPP preprocessing in Haskell made it a pain when I was giving that a go). Good to know about the cargo check mode, shouldean I don't need to use vscode anymore. 
Appreciate the input, thanks. I'll look into this stuff.
Yes, macros support is a real challenge for IDE writers. In the case of Rust, we cannot provide good code insight and analysis without macro expansion and indexing, because macro-defined items are everywhere.
Honestly often makes it hard to read and understand the code as a human too. 
Rust doesn't have the concept of a move constructor, if that's what you're referring to (given you may be allowing copies). Every move is just a memcpy and "forgetting" the old stack location. For actually immovable types, this is now accomplished by the `Pin` pointer-wrapper, which guarantees that you won't move the pointee after creating the pin (if it doesn't implement `Unpin`).
[Pin](https://doc.rust-lang.org/1.27.2/std/mem/struct.Pin.html) might be what you're looking for. It's in nightly only right now, and extremely unstable, recently there have been talks about this feature, so I do NOT recommend using this in production. Unpin may be ralted, I recommend reading the RFCs about those before using them (it's so unstable that there is next to no documentation). However it does basically what you described: you can create it, clone if it implements Clone, and then Drop ("destroy" equivalent). You can mutate it and read it. But you cannot move the value. It's useful when you have a raw pointer (without a lifetime) pointing to your struct, so you can't afford this struct being moved into another struct, or down/up in the stack or whatever (otherwise the referenced memory by your pointer becomes invalid and something something hits the fan).
I'm not as familiar with the C++ terminology, but based just on your description Rust can make types like that. Rust gives you complete control over mutability, so you could write a type with private fields and only `&amp;self` methods that can never be modified. One thing to note about this is that you can use the concept of "interior mutability" to modify a struct even when it appears to be mutable like this. I believe there is a `mutable` keywords in C++ that provides similar behavior in const methods. 
Given that, is there a way to make a type truly immutable? (as opposed to just an immutable binding, that can later be moved/rebound to a mutable one). E.g. something that would produce an effect similar to the following: `let x = MyType::new();` `let mut y = x; // ERROR`
No, if you own a value you're always allowed to move it. If you don't need ownership anymore though, you can use shadowing: let x = Type::new(); let x = &amp;x; It's now impossible to use the owned value, just the shared reference, so it's not possible to move the value to a mutable binding.
You said something that finally clicked for me about unsized items not even being able to put them on stack because you don’t know how big they are. Thanks.
There's a little section at the bottom of the intro in the rustdoc about those sorts of libraries. I'll quite it here: https://docs.rs/zeroize/latest/zeroize/#what-about-clearing-registers-mlock-mprotect-etc &gt; This crate is laser-focused on being a simple, unobtrusive crate for zeroing memory in as reliable a manner as is possible on stable Rust. &gt; &gt; [...] &gt; Other memory protection mechanisms are interesting and useful, but often overkill (e.g. defending against RAM scraping or attackers with swap access). In as much as there may be merit to these approaches, there are also many other crates that already implement more sophisticated memory protections. Such protections are explicitly out-of-scope for this crate.
Well, it's much newer, if that's indicative. I can just tell you from my own experiences, I've had ~100x more success with it than skype and google hangouts (in terms of ease of use and performance). Like, you can select a better geolocated, intermediary server to improve call quality; there are so many small things that are hard to list. And since you can download the client to your devices, you have 0 software load time, so restarting it doesn't involve bootstrapping a heavy app again and again. It's better by every measure, imho.
C++'s const is subtly different from Rust's immutability, afaik. I may have worded my question too low-level. In C++ you can do something like this: class Immutable { Immutable(int a, int b) : a_(a), b_(b) {} const int a_; const in b_; }; void func1(Immutable immut); void func2(Immutable immut) { immut = Immutable{1,2}; //ERROR Immutable newimmut{1, 2}; // can never change this (without misusing const_cast) func1(immut); // Initializing by copy is fine } &amp;#x200B;
Thank you, this clarified my confusion about Rust's semantics.
No specific policy, no. There is a general “we reserve the right to do whatever”, of course...
Did you file an issue for this? If not we should do that soon
Note that casting const away from an object that was originally qualified as const is undefined behavior. So there really is no well-defined way to alter a const member. 
Exactly the behavior I was wondering if Rust supported! :) Making it not possible to modify a member at it's declaration site.
Pin is pretty close to being stable, there’s one last discussion about the name of one trait, and that’s it.
&gt; However I would note that there are many languages with about the same level of penetration among developers as Rust but not nearly as much growth. That's a good point; I wonder if it'd be worth seggregating the matrix based on "initial" number of developers (by order of magnitude: 10,000+, 100,000+, 1,000,000+, ...) to compare apples to apples. 
I think you're biased towards what you know in the language(s) you know, which is fine, but IMO rusts' use of references doesn't do any particular harm and it is pretty clear. It's interesting that I don't think the opposite of "honoring" prior art is exactly "dishonoring". Maybe you're thinking of "disregarding" since the use of the term reference is broad both in the field of computer programming and more generally. And since the term predates computers it seems like honoring or respecting or etc. prior usage only demands a good-faith effort to effectively reflect any prior meanings, which I think rust does.
Pin was [stabilized](https://github.com/rust-lang/rust/pull/56939) a few days ago. 
The rename of unpin is the only remaining question, I wouldn’t describe that as “extremely unstable”. https://doc.rust-lang.org/nightly/std/pin/ is also a pretty decent amount of docs, though we will add more...
yuck
Seems like you can’t auth as that user since the internal user id changed. Only looks misleading in the UI. Only discussed it on discord. 
I'm not biased, I checked history (1976), I follow Rust since shared sigil times, I recall "references" being called pointers, I see many devs coming from other languages confused, expecting to use terms like "pass-by-reference" (since there are references) and fail (since Rust references resemble pointers, dereference is needed to be applied, they don't alias outer variables). I could keep listing reasons why I don't consider it biased, just observing practices and their deviations.
emmm...Fixed it, thx
Bincode is a serde-compatible binary serialialzation crate. I tend to have many more problems getting serde to work with binary, space-efficient (potentially data-specific) serialization than for say, json.
&gt;Why are all the things implemented \`asyncio\` required at all? Can't all of this boilerplate already be provided by \`mio\`? mio is just a low-level non-blocking IO library, it should be easy to encapsulate to support a variety of API abstraction of different concurrent models. stackless coroutine is just a kind of API abstraction, it can be used in different situations like async IO, async calculation etc. You can implement \`asyncio\` based on libuv instead of mio. However, in most cases, you needn't implement it by your self, community project like \`tokio\` will do this job for you.
It looks like you got beaten https://www.reddit.com/r/rust/comments/a9pqkp/barriers_and_twophase_borrows_in_stacked_borrows/?utm_source=reddit-android
JSON is the flagship Serde format so it has had the most attention paid, but Bincode is also quite mature. What sort of problems do you remember hitting?
&gt; First, I think the idea of apolitical money is a fantasy Today, absolutely, but that's only because of government's involvement with the economy. When the government applies force to the marketplace instead of removing it, businesses have to play the political game to survive. &gt; Further, I disagree with this raison d'etre. I'm not saying that its a good one, only that it's the *actual* reason. Personally, I think it's ultimately doomed to failure, for the reason you just said: the government can, and eventually will, use coercive means to put an end to it. &gt; Maybe in the Ayn Rand-ist world view, which is fortunately fringe even in the most "libertarian" of circles. I don't agree. A large segment of libertarians are hostile to government qua government and would see subverting it as heroic. Unlike them, Rand sees government as a positive. She's only hostile to it when it acts outside it's proper role, i.e. preventing and punishing the initiation of force. &gt; capital punishment is an irrevocable form of state sanctioned murder and revenge... Jail time is likewise irrevocable. The difference between them is how much of the person's life is destroyed. &gt; Justice should be restorative and focused on reducing harm. The goal of punishment should be to ensure that the transgression not happen again. Once someone uses force against another, they have rejected the concept of rights and by extension, rejected their own rights. The punishment should be as harsh as is needed to prevent repetition, and no harsher. &gt; if a company engages in behavior that is harmful to most people, it should be prevented from doing so If you're talking about a company poisoning a river that people drink out of or something, then I agree. Such an action would be a violation of their property rights. If you're talking about selling drugs to an individual or moving jobs overseas or not offering employees company health insurance, I don't. &gt; There are other things I would consider human rights These things cannot be rights. A right is a "freedom from physical compulsion, coercion or interference by other men." What happens to your inalienable right to health insurance on a deserted island? The things you're listing are *permissions*, given to individuals by the government. We can talk about whether the government should afford its citizens some permission, but it isn't a right. &gt; I disagree with the notion of regarding private property, as opposed to personal property And the difference is what, that one is small enough to carry with you? To own anything is to control its use and disposal; it always excludes others' ownership, regardless of how easy it is to make another. For the record, I disagree with eminent domain as well. &gt; then what is the use of free speech? Knowing that I won't be jailed and fined for making a meme, or forced to drink hemlock because I advocated for my ideas. Knowing that I can search for a platform whether the majority wants to hear me or not. &gt; you may employ workers with no job security They've clearly decided that working for me is better than whatever alternatives they have. &gt; that you sell some non-tested drug that is harmful to others If I am upfront with them about what I know and don't know about my product and they decide that the potential upside is worth it, what's the problem with this? Obviously, if I misrepresent my knowledge, this would be fraud. &gt; that you refuse to pay taxes but yet want to take advantage of roads and other infrastructure First, it's not that one should refuse to pay for the government, but that one should not be *forced* to pay for the government. Second, I'd be more than happy to pay for the privilege to drive private roads.
It would be more interesting to see the full-reach of unsafe code, which I guess would be closer to a taint analysis. For example, in a `Vec`, the `set_len` method is `unsafe`. It can be called with as small a block as `v.set_len(7)`, however that's deceptive as a call to `v.push(...)` immediately after extending with `set_len` would drop uninitialized memory: fn main() { let mut v = vec!(); unsafe { v.set_len(7); } v.push("Hello World!".to_string()); // unsafe, an invariant is still not re-established! } I wonder if it was possible to "taint" a variable after `unsafe` was used on it; though finding the exact limits of safety is probably complicated...
I removed the other post since Ralf is more likely to reply to comments here, and there was no comment there.
/r/playrust
You're in the wrong subreddit. You're looking for r/playrust . This subreddit is about rust the programming language
Thanks for the update Ralf, and good luck with the preparation of your PhD.
I think at this point, for me, the changes to the intellij plugin have a greater impact on my day-to-day rust development than the changes to the language.
Working from time to time on my git\_prompt for getting the git repository status as part of my prompt in a way that is shell independent. [https://github.com/aignas/git\_prompt](https://github.com/aignas/git_prompt)
Sweet! I can immediately make use of this.
Last week I wrote a program called [`ubuffer`](https://github.com/drbawb/ubuffer/) to scratch an itch. I was having performance issues w/ TCP transfers when using `scp` and/or `mbuffer` inside of a WireGuard VPN tunnel. So I made this program to replace `mbuffer` for my usecase, it uses [UDT](https://en.wikipedia.org/wiki/UDP-based_Data_Transfer_Protocol) for the transfer, and I was lucky enough to [find a crate](https://github.com/eminence/udt-rs) which wraps it. If I have time this week I'm hoping to (A) print real-time measurements to stderr (the "measuring" part of `mbuffer`), (B) look into contributing the udt-rs bindings to give them IPv6 support, and (C) add some tunables to my command line and do some various benchmarking to find good defaults.
There are some general docs on https://sn0int.readthedocs.io/en/latest/ but that doesn't include the sandbox design yet, I'm adding this to my todo. The sandbox works differently depending on your OS, but it's always a child process that talks to the parent process through stdio. The scripts are sent to the child process and the stdlib that is available for scripts was designed to be secure even if no additional sandboxing is applied, for example there are no functions to access files or spawn new processes. In addition, if you're using linux, the child is automatically chrooted into an empty folder and a seccomp profile is applied to filter syscalls. On openbsd I'm using a combination of pledge and unveil. Doing https without disk io turned out to be complicated, I wrote the chrootable-https crate specifically for this.
Here’s a related post: https://users.rust-lang.org/t/rust-dotenv-repository-disappeared/22737
Oh wow, so during the time it took me to change trains and submit the link to Reddit, someone else already did the same.^^ Not sure if there's anything I can do about this now?
Should slack mode look like `#[reformation("{a}, {b}", slack=true)]` Replacing symbols `,;:` (What else?) and following space symbols (if any) with corresponding punctuation and `\s*`. Or should punctuation be specified explicitly? `#[reformation("{a}, {b}", slack=r"[,;:]")]` Regarding display, it would also require adding mode for auto-escaping all regular expression special characters (Which is rather desired anyway). Currently I see it this way: `#[reformation("{a}, {b}", no_regex=true, display=true]` If flexibility of regexes is essential, then display could be specified explicitly: `#[reformation(r"[xy]={a}, {b}", display="x={a}, {b}"]` (Well, this example makes little sense)
In hindsight it would be nicer if [crates.io](https://crates.io) used username/cratename same as packagist instead of choosing the npm style /packagename this solves a lot of those kind of issues.
I've created it, yes. 
My bad about the documentation, I read that and only saw a few lines: https://doc.rust-lang.org/nightly/std/pin/struct.Pin.html , and I read the RFC and the "documentation" checkbox was still unchecked, so I thought that was it for the documentation of this feature.
It’s cool! There’s more work to do for sure.
A team of what and 150 hours of what?
Yes - details are awkward. I'd say that slack should be fairly stupid, since anything further can be expressed in full mode. There's plenty of opportunity here for experimentation: people are usually happy with reasonable shortcuts, if well specified, as long as the full way allows enough control
He probably means "anyone interested in teaming up for Rust (the game)? Must have &gt; 150 hours (play time? I can only guess) and be on discord" -- most likely thinking this sub is for rust the game.
It just occurred to me that you are probably looking for the Rust game. This isn't it. This is the Rust programming language. However, before you go, if you ever get bored playing games and want to learn something cool check it out at https://www.rust-lang.org
JSON is a dynamic format? (a lot of times the JSON format differs and some keys are missing, so it fails?), It's also not that intuitive like for example in Python or this one: [https://github.com/maciejhirsz/json-rust](https://github.com/maciejhirsz/json-rust)
You will probably have more success over at /r/playrust
Sounds fascinating - can't wait to hear more.
The graph divisions feel very arbitrary. I was quite surprised to see the cutoffs and scales used. A logarithmic horizontal axis for percent with 10% as the division feels like a way to vastly over represent the languages with small shares, and the vertical division at 20% threw me off as I was expecting a positive/negative growth division. I don't mean to harp on about it, but it feels like the graph was scale hacked until everything clustered in the center and the outliers looked nicer.
One that happened yesterday, trying to interpret 0u8 as None while &gt; 0u8 use TryFrom&lt;u8&gt; to produce Some(T), if that makes sense. Just ended up with baffling type errors I didn't understand. 
For an algorithm to tell you where the unsafety "ends" it has to actually understand its effects and then it could also tell you that you screwed up or not. I'm not sure it's possible, after all, unsafe exists because this stuff in general cannot be understood by the compiler.
&gt; Today, absolutely, but that's only because of government's involvement with the economy. &gt; When the government applies force to the marketplace instead of removing it, businesses have to play the political game to survive. This is ahistorical. It's in the nature of capitalism that capital accumulates and this has been the historical trend. That's just how the profit motive and market forces work. When capital accumulates sufficiently, monopolies develop because that is more efficient due to economies of scale. &gt; I'm not saying that its a good one, only that it's the actual reason. Not necessarily. Someone can use cryptocurrencies purely for personal financial gain and not because of some political goal. &gt; Personally, I think it's ultimately doomed to failure, for the reason you just said: &gt; the government can, and eventually will, use coercive means to put an end to it. I hope so. Maybe in the Ayn Rand-ist world view, which is fortunately fringe even in the most "libertarian" of circles. &gt; I don't agree. A large segment of libertarians are hostile to government qua government and would see subverting it as heroic. In in principle favor of dismantling government entirely; especially the more coercive aspects such as militaries or miltaristic police forces. This requires a gradual process in which government is transitioned to providing more and more things as general welfare as well as introducing work-place democracy. As for "libertarian", I intentionally put the term in quotes as actual liberarians seek to abolish capitalism and private ownership of production means. &gt; Unlike them, Rand sees government as a positive. &gt; She's only hostile to it when it acts outside it's proper role, i.e. preventing and punishing the initiation of force. This is true; however, wrt. the direction of travel, Rand wanted to reduce the size of government. from the perspective of social democracy / socialists, this is undermining government. &gt; Jail time is likewise irrevocable. The difference between them is how much of the person's life is destroyed. That might be; but the difference is huge. Another difference is that capital punishment is cruel for the same reason as torture is. It also happens not to deter transgressions. &gt; The goal of punishment should be to ensure that the transgression not happen again. &gt; Once someone uses force against another, they have rejected the concept of rights and by extension, rejected their own rights. &gt; The punishment should be as harsh as is needed to prevent repetition, and no harsher. Restorative justice is good at just that since it is rehabilitating wherefore it facilitates reintegration into society. Reintegration into society is a key factor in preventing recedivism. &gt; If you're talking about a company poisoning a river that people drink out of or something, then I agree. &gt; Such an action would be a violation of their property rights. What about emitting CO2, methane gas, freon, or some other substance which is harmful on a global scale but which does not affect someone so directly? By saying that it is a violation of their property rights, you've acknowledged the concept of public and common ownership. It seems to me that it's quite difficult to dilineate where public ownership begins and ends if you see this in terms of property rights. &gt; If you're talking about selling drugs to an individual or moving jobs overseas or not offering employees company health insurance, I don't. I think it's entirely fine for government to for example have a monopoly on selling alcoholic beverages above a certain %. Indeed, this is exactly [what Sweden does](https://en.wikipedia.org/wiki/Systembolaget) and I think it works well. &gt; These things cannot be rights. A right is a "freedom from physical compulsion, coercion or interference by other men." &gt; What happens to your inalienable right to health insurance on a deserted island? Rights are social constructs and only work in relation to other people, particularly governments. There's no such thing as an inalienable or natural right; this is fiction. Your definition of a right is by no means universal. In fact, I think the view as a purely negative thing is a) not meaningful and vague because "interference" is not well defined; emitting CO2 could be construed as interference. b) a minority position; while the UDHR has its flaws, it states: &gt; (1) Everyone has the right to a standard of living adequate for the health and well-being of himself and of his family, including food, clothing, housing and medical care and necessary social services, and the right to security in the event of unemployment, sickness, disability, widowhood, old age or other lack of livelihood in circumstances beyond his control. &gt; (1) Everyone has the right to education. Education shall be free, at least in the elementary and fundamental stages. Elementary education shall be compulsory. Technical and professional education shall be made generally available and higher education shall be equally accessible to all on the basis of merit. &gt; The things you're listing are permissions, given to individuals by the government. &gt; We can talk about whether the government should afford its citizens some permission, but it isn't a right. You can call it foobar for all I care; my point remains that no moral society is without these affordances. &gt; And the difference is what, that one is small enough to carry with you? &gt; That it isn't used for production? The distinction isn't fine; but it largely is one between means of production and things which you use for yourself. A factory is clearly not personal property, your toothbrush clearly is. &gt; To own anything is to control its use and disposal; &gt; it always excludes others' ownership, regardless of how easy it is to make another. &gt; It can always be used for productive work, even if isn't normally. That some things are typically used for profit making and other things are used for your personal consumtion seems to me a key difference here. &gt; Knowing that I won't be jailed and fined for making a meme, or forced to drink hemlock because I advocated for my ideas. &gt; Knowing that I can search for a platform whether the majority wants to hear me or not. Where do you make this meme if you have no place to express it? Where do you advocate for your ideas if no place actually exists to do so? The internet offers a platform, that is good; but it isn't sufficient. Equality is necessary to make freedom of expression and assembly truly great. The point is that everyone's opportunity to pursue happiness isn't equally distributed. Without a right to education and a roof over your head, there's no equality of opportunity or even before the law. &gt; You can't control people just because you have a louder voice than everyone else. &gt; People can always decide to listen or not and to agree or not. This is one of those things you can say but which aren't actually true in practice. Humans are not rational machines. &gt; They've clearly decided that working for me is better than whatever alternatives they have. This is reasoning about things without consideration for what effect it has on society as a whole. If there's no job security, companies can easily fire you for joining a trade union. This inevitably leads to a downward pressure on wages. Eventually most people have no choice but to take low wages and work multiple jobs. To me, job security is about actual practical freedom. &gt; Obviously, if I misrepresent my knowledge, this would be fraud. And fraud is what? physical compulsion? coercion? interference? You should motivate why fraud should be illegal in your model of rights. &gt; First, it's not that one should refuse to pay for the government, &gt; but that one should not be forced to pay for the government. A distinction without substance in my view; of course profit driven companies will seek to not pay taxes. &gt; Second, I'd be more than happy to pay for the privilege to drive private roads. &gt; Ditto for basically all infrastructure. &gt; I'm not looking to freeload, only to decide for myself what services are worth paying for. This is impractical, inefficient, and untenable. It takes massive resources to build rails, roads, and to fund basic research in universities that may not pay dividends until 50 or 100 years later. Furthermore, not everyone has the same means to pay. If healthcare is going to be based on need, and not on wallet size, then it won't work if you can pay for only the bits and pieces you want.
No particular reason for it to be unsafe.
Iirc, the is an account I'd that is not reused, but a lot of stuff uses the account name, which can be reused. There was some bugs opened about that in the gerrit-oauth plugin.
It's the trait trickery I'm interested in. Would bum me out if it was code generation though :(
Technically should be /r/playrustservers, /r/playrust doesn't want server advertisements either. For OP, this subreddit is for the programming language Rust, which is unrelated to the game Rust.
Can you share the code with type errors? This sounds like it should work (and it should work the same across all Serde formats).
\&gt; I even would go further and ask for a way to write my own panic handler and output while still using the std. &amp;#x200B; [https://doc.rust-lang.org/std/panic/fn.set\_hook.html](https://doc.rust-lang.org/std/panic/fn.set_hook.html)
Not sure about generators specifically, but this should work if you use a trait object: `Box&lt;dyn Generator&lt;...&gt;&gt;`
If I have a function like `fn put&lt;A: Thing&gt;(a: A) -&gt; Rc&lt;A&gt;` whose body returns `Rc::new(a)`, how can I have this function also accept an `Rc&lt;A&gt;` which it then just returns?
Once there is something claiming to be performant/fast/optimized, there should be benchmarks. Could you, please, point me to them?
My implementation is here if you want it. It uses many if the above points. https://github.com/Morganamilo/adventofcode2018/blob/master/src/1-2.rs
thanks! looks the next release will use this repo: [https://github.com/apiraino/rust-dotenv/pull/1/files](https://github.com/apiraino/rust-dotenv/pull/1/files) 
Does it support the WASM MIME type? That would be really useful!
Hm... looks it was moved from the website to forge at about the time of the redesign... and broke in the process :-/ https://github.com/rust-lang/rust-forge/issues/175
&gt;Once there is something claiming to be performant/fast/optimized, there should be benchmarks. Could you, please, point me to them? after\_success\_2 [https://travis-ci.org/rust-iendo/v\_htmlescape/jobs/471740072](https://travis-ci.org/rust-iendo/v_htmlescape/jobs/471740072)
If only I could take the intellij plugin and stick it in my vim setup... Oh well, a man can dream.
It's free open software developer meeting. So it's developer talking to developers about the software. It's usually for talks about internals, progress reports, or show and tells to get more contributors. Not marketing of the Foss software looking for users.
Sounds like a usecase for [NonZeroU8](https://doc.rust-lang.org/std/num/struct.NonZeroU8.html)?
Thanks for your comment. This may sound odd, but a cut off at 0% would be just as arbitrary as anything else, other than the fact that it would divide positive and negative growth. One could say the same about drawing a cutoff at 50% for market share, simply because it’s half of the maximum. As I created this, I tried to avoid exactly what you pointed out - arbitrariness. To do that, I made the cutoffs the respective medians for growth and share, which seemed at least defensible. This just happened to be near 10% for market share. Believe I explain this in the post but let me know if I’m mistaken. Given market share distributions tend not to be normally or uniformly distributed, but rather, power law distributed, I used a log scale for that axis, which is more natural for such a distribution. There are simply many languages with small share and few with high share. All in all, I felt this was the most principled, least arbitrary method, given that the growth-share matrix framework does not prescribe specific cutoffs, as far as I know. Completely understand how this could come off as arbitrary, but I honestly think that has more to do with the framework itself than any choice on my part. All good points regardless
You could make your own trait: ``` use std::rc::Rc; struct Thing{} trait AlmostRC&lt;A&gt; { fn rcit (self) -&gt; Rc&lt;A&gt;; } impl AlmostRC&lt;Thing&gt; for Thing { fn rcit(self) -&gt; Rc&lt;Thing&gt; { Rc::new(self) } } impl AlmostRC&lt;Thing&gt; for Rc&lt;Thing&gt; { fn rcit(self) -&gt; Rc&lt;Thing&gt; { self } ``` and then have your function accept an `AlmostRC&lt;Thing&gt;`. 
The contents of the installers are at static.rust-lang.org, regardless of where the links to them live.
I'm working on something very similar to this...hmmm...
AFAICT Pin only affects heap allocated data structures. If you create a struct that has Pin (!Unpin) members and return it on the stack, it will still move around in memory (though it may not due to optimization).
Could you summarize what Remy is?
I've always thought a tool like this should exist! Good job and thanks!
What are you working on? Maybe there's an opportunity for you to use my crate or collaborate on it. :) I'm specifically working on a standalone diff tool that can display the changes side-by-side like Phabricator or other code review web tools and have "nice" diffing like patience diff, ignoring whitespace, etc. The core diff logic is very standalone though; ignoring whitespace is just a matter of tweaking that `equals` function, for example.
Glad you found it useful! If you got any ideas or run into any issues, I welcome all kinds of contributions on github
Check out [this post](https://ferrous-systems.com/blog/rust-analyzer-2019/) by the original author of the IntelliJ plugin where he talks about his plans for 2019. What you want is possible, and he's working on it. That said, it looks like a monumental effort, and I doubt a single person working on it could manage this in a year.
Have you compared tantivy speed with sqlite3 fts5?
Tantivy looks awesome ! I have some experience with Rust and Lucene (well Solar/ES) , I'm living in Paris and I'd be glad to help you with your presentation if I can.
This looks really interesting; every time I need awk or sed even for something simple I end up having to look up the solution, and this looks like a nice tool for those cases.
Released version `0.2.0` of my crate [lis](https://crates.io/crates/lis)! Now provides a function for diffing two lists and made main LIS function to a method on slices.
This is fine unless you put it inside a Pin, on which case you must be careful not to allow it to move ever again.
Install tldr and do: `tldr sed`
I'm working on a diff library that I intend to use in an SCM I'm creating. It's similar to your API, but the result of the diff contains references to the pieces that need to be glued together, so it's a little bit easier to "apply" the diffs.
Smell my bum
I am very interested in the idea of RFCs need to become heavier as they seem to be a major loss in community time reviewing them. It is a heavy burden though to have an implementation that might be completely tossed out as part of an RFC but I think the community would probably benefit from this overall.
\&gt; Note: although sed does have a nicer regex syntax with -r, it is a non-portable GNU-ism and thus doesn't work on MacOS, BSD, or Solaris &amp;#x200B; It works just fine on these OSes. You just have to install GNU sed, just like you'd have to install this tool
Is your diffing specifically for strings? I think this whole API is easier to nail down if I concretely pick strings as the thing I'm diffing since I can just provide string slices in the diff operations. The general API seems hard to me though, there's no guaranteeing that the underlying thing has 
I've set a toy project to learn Rust. It's a fractal drawing app. But I'm still investigating how to do the internal model and how to use a GUI toolkit with Rust. I'm leaning toward [http://relm.ml/relm-intro](http://relm.ml/relm-intro), even though I don't like GTK.
I'll give that a try. However, it seems like `Into` or `From` should be able to do this, too, but I can't get the generics right. The return type should be `Rc&lt;Type&gt;` and not `Rc&lt;Trait&gt;`.
I really like the idea of negative RFCs to be able to set a community wide vision. Although no HKTs ever would make me very sad. 
This idea could operate in tandem with changing RFCs to a "tiered" model, where it goes through several phases before being accepted. I'm not quite sure yet what to think about adding implementations to RFCs. But it's definitely interesting to think about.
Sure, its possible to "just brew install gnu-sed". But that assumes you are aware of the subtle differences between BSD, GNU, etc sed's and specifically want the GNU one. Most people are not aware of this, and cross-platform usage of sed without caution can easily [break things](https://github.com/NZSmartie/IoTNode/issues/4). &amp;#x200B; And even with this consistency, you're just back to square one with all the other warts and quirks.
I'm new to statically typed language (new to anything but Python really) so going through the rust book I explicitly specify all the data types when creating new variables. I ran into an issue where I created a variable used for indexing an array, and the compiler told me slice indices are of type usize or ranges of usize. Fair enough, usize works. But if I'm on a 64-bit system isn't u64 and usize the same thing? Is the compiler complaining because the data types actually are different or because it's better to use usize in case the code's going to run on another system?
Or [tealdeer](https://github.com/dbrgn/tealdeer) since we’re in /r/rust :-)
Yes thanks. This is the one I use too.
You could also just learn awk at that point. But why bother with all that friction just to find &amp; replace, when you could re-use the perfectly adequate regex knowledge you already have? 
&gt;``` &gt;fd -t f --exec sd 'from "react"' 'from "preact"' -i {} &gt;``` `fd`? What? Where?
\`fd\` refers to [https://github.com/sharkdp/fd](https://github.com/sharkdp/fd). You could also just use find with xargs, but its a bit clunkier so I prefer fd :) &amp;#x200B;
I'm going to try `sd` by the way. I was more suggesting using the `tldr` "database" for all those commands we forgot how to use.
I love this. I've been considering writing a similar tool myself for a while. Especially the find/replace with literal strings is such a stupidly simple task, yet it's way too hard with common shell tools to replace some arbitrary string with another arbitrary string.
And you could actually just use `fastmod` for this use case.
Oh, TIL. You might want to add a link in your README.
The answer is both. Because the index size may differ, Rust chose to use usize for index arrays. And while ssize and u64 are the same size on your platform, they are different *types* and can't be used interchangeably. 
Maybe by returning must-use single-method tuple-struct guards that hold mutable borrows? Even still, you can’t always encode the exact Operations that would get you back to safety. Like functions that need to be called with some x &gt; y.
You don't need to install GNU sed. You can just use the `sed` included in macOS or FreeBSD. [POSIX has standardized `-E` for this purpose](http://austingroupbugs.net/view.php?id=528), and it is supported on GNU sed as well as others like [FreeBSD](https://www.freebsd.org/cgi/man.cgi?query=sed&amp;sektion=&amp;n=1) and [macOS](https://opensource.apple.com/source/text_cmds/text_cmds-97/sed/sed.1.auto.html) (for some reason, Apple no longer puts their rendered man pages online, so linking directly to the source). For some reason it doesn't seem to have made it to the published standard, though I haven't figured out why that is; but it is widely supported. For another of your examples, you said you couldn't get this to work with `sed` due to quoting issues, but `sed` supports using any alternate character you want as delimiters for the regular expression. If you do that and use `-E`, you get something quite close to your `sd` example: echo "{((sample with /path/))}" | sed -E 's|\{\(\(.*(/.*/)\)\)\}|\1|g' Yes, `sed` has its warts and quirks, but it's best to provide a fair comparison. And for your first example, I would have just used `tr` instead of `sed`. tr '\r' ',' I think you can still sell the simplicity of `sd` vs. `sed`; you have to know about `-E`, you have to remember `s///g` in `sed`, you have to know about the fact that you can replace the delimiters, etc.
Remy is a tool for quickly compiling multiple executables for your Rust programs, so that you can spend less time debugging any particular platform, and more time working on the app itself. Remy is similar to cross, but with different platforms supported.
-E isn't perl regex though, which is what a huge amount of people are familiar with. Few things are as frustrating as trying to write a regex in a different regex dialect than the one you are used to.
I think you're right and a fairer comparison could be provided. Could you submit a quick PR? I'd really appreciate it.
I've been working on optimizing my programming language built in rust! It's purely functional, and over the past month I've made a ton of improvement on it. Now I've written things like [Tic-Tac-Toe](https://github.com/adam-mcdaniel/maroon-lang/blob/master/examples/tic-tac-toe.m), [Collatz](https://github.com/adam-mcdaniel/maroon-lang/blob/master/examples/collatz.m), [Fibonacci](https://github.com/adam-mcdaniel/maroon-lang/blob/master/examples/fib.m), [Almost an Adventure Game??](https://github.com/adam-mcdaniel/maroon-lang/blob/master/examples/adventure/main.m) in my language. It's super cool, and I plan to keep improving it, or make something big with it :)
sd uses the regex crate, which supports a syntax that is very similar to POSIX extended regexes. Moreover, POSIX extended regexes are also very similar to Perl regexes. Notably, POSIX extended regexes and Perl regexes both share roughly the same escaping rules, unlike POSIX "basic" regexes where most implementations that support meta characters like `+` require one to use `\+` to get the desired effect (among other meta characters). Of course, Perl regexes support many more features like look-around that aren't in either basic or extended regexes. However, extended regexes can, to a first approximation, be viewed as a rough subset of Perl regexes. (There are more subtleties that make Rust's regex crate more similar to Perl regexes than extended regexex are. For example, `foo|foobar` and `foobar|foo` are equivalent extended regexes, but are not equivalent Perl/Rust regexes.)
Is type here something else than the format the data is stored in? Is it some kind of flag used to tell rust how to interpret a certain set of bits? i.e. the value may be '0101' for both values, but one is flagged as usize and one is flagged as u64 and when using it as slice indices rust only checks the flag and determines it's the wrong type. Something like that?
I'd imagine the more compelling unified interface here would be support for in-place replacements. I don't think there is consistency there across BSD and GNU implementations, and I know that's bitten me more than a few times.
[https://github.com/rust-iendo/v\_htmlescape/tree/master/v\_escape](https://github.com/rust-iendo/v_htmlescape/tree/master/v_escape)
After thinking for a bit, I wonder if this isn't better: trait Diffable { fn len(&amp;self) -&gt; usize; } /// Common impls impl Diffable for String {...} impl&lt;T&gt; Diffable for Vec&lt;T&gt; {...} ... fn diff_by&lt;T: Diffable, U: Diffable&gt;(lhs: &amp;T, rhs: &amp;U, equals: Fn(T, U) -&gt; bool) -&gt; DiffChangeset { ... } fn diff&lt;T: Diffable + PartialEq&lt;U&gt;, U: Diffable&gt;(lhs: &amp;T, rhs: &amp;U) -&gt; DiffChangeset { diff_by(lhs, rhs, |lhs, rhs| lhs.eq(rhs)) } I haven't actually tried it, but you get the idea. Everything would just magically work on common types but also give me flexibility for more advanced ways of determining "equality" for diff purposes. Given this, how should the return structure look? I'm pretty unsatisfied with the `usize` indexes in there.
My diffing is for lines of strings, so it is easier to provide references. I believe that for strings (and chars in general) the four russians method can be used to speed up building an LCS table.
&gt; the connection object itself has &amp;mut methods We're looking at [Redis-rs](https://github.com/mitsuhiko/redis-rs), yes? `Connection` only has `&amp;mut self` methods for pubsub mode. &gt; So now because the repository must take &amp;self it's suddenly crippled and needs to either use a Mutex/RefCell for no other reason than to satisfy the trait. I wouldn't call it "crippled," no. Either the interface is reentrant or it isn't. If it is, it very likely requires locking to implement. If it isn't reentrant, it's likely to be a rather serious pain to work with. Rust makes things easier by checking your work, but those design decisions are still firmly in the programmer's hands. I don't think in C you'd want to expose a non-reentrant interface - the chance of Somebody Else's Code messing things up is too great. Rust allows you to, but that means the user will still be responsible for correct use - the only reason this is even a practical option is that Rust will hold that other code responsible. To oversimplify things `&amp;mut self` arguments are more convenient for you *now* while you're trying to implement the mocked repository. But they're probably *less* convenient for you or whoever is writing the code that uses a repository (real or mocked). Which is why you're now asking "can't I just make `Mutex`do the heavy lifting in the middle?" And my answer is "quite possibly, but it'll be easier to avoid deadlocks if you think about what's happening inside the repository implementation instead of blindly wrapping every method in a `lock` / `drop` pair." 
So, LISP meets square brackets?
No, but if you want to contribute, it is relatively easy to add an engine in tantivy s search benchmark. https://github.com/tantivy-search/search-benchmark-game TBH I am more interested in comparing with systems that I expect to outperform tantivy on some queries. It gives me a hare to run after, and I can pick on good ideas from other engines, and assess their potential. 
Thank you! I'll be in Paris the week before FOSDEM. I'll ping you then to see if you can meet and help me with this presentation.
I like the idea of tiered RFCs with hard requirements for moving between tiers, but I don't think there's much value in negative RFCs. The primary benefit is shutting up people who want whatever is in the negative RFC, and the primary downside is making the people who want those things feel explicitly unwelcome. So at least in my mind, they seem more like a tool for blowing raspberries at people you disagree with than a tool for building a language.
`sd` isn't perl regex either, it's Rust regex. Perl regex uses backtracking and so can support things like lookaround and backreferences; Rust regex is finite automaton based so has better worst-case performance but can't support some features like that. POSIX extended regular expressions support the same basic syntax of most other regular expression engines, with differences mostly in some of the features it doesn't support (it's designed for compatibility with automaton-based regular expression engines, so it doesn't support backreferences, even though POSIX basic regular expressions do) and some more advanced or obscure features. Also, PCRE is not Perl either. It is "Perl-compatible", although it's only mostly Perl-compatible, if you look at `man pcrepattern` you'll find places where there are differences listed. And Python, Ruby, JavaScript, C#, all have their own regular expression syntax. Again, most of the basic features have the same syntax as Perl, PCRE, POSIX, Rust, etc, but there are differences in both syntax and semantics. The two major axes on which regular expressions vary are on whether some meta-characters need to be escaped to act as metacharacters (POSIX basic regular expressions, Emacs) vs. act as metacharacters without an escape (just about everything else), and support for backreferences which requires a backtracking engine (Perl, PCRE, Python, Ruby, JavaScript, POSIX basic regular expressions) and so is not supported by those that support automaton based engines (Rust, Go, re2, POSIX extended regular expressions). On the two main axes of variation, Rust and POSIX extended regular expressions are similar; they have the same basic syntax without needing to escape metacharacters, and they both support automaton based implementations so don't support backreferences. There may be some other features that Rust regular expressions supports that POSIX doesn't, but not most of the day to day features.
&gt; The primary benefit is shutting up people The primary benefit is arranging for a controlled limit to the otherwise endless growth of the language. That is the entire point of the article.
Thanks for the comment. I will be in the search room of FOSDEM. This conf typically drags a public of experts or semi-experts. Also most ppl will have no interest in rust or tantivy, and will have to stay in the room to keep their seat for the next presentation. Given these constraints, I'll stick to tantivy's internals.
I'm not sure people would be too happy to donate money to a server that is subject to random restarts. 
Great comment. You're always good on the details. :-) &gt; There may be some other features that Rust regular expressions supports that POSIX doesn't, but not most of the day to day features. Indeed! The top of this list is probably (almost) full UTS#18 level 1 support, and of that, my favorite is probably character class set operations. e.g., it can be fun to search for things like `[\p{letter}--\p{ascii}]` to find "interesting" uses of Unicode. The other thing is probably leftmost-first matching, which I personally find much more useful than leftmost-longest. e.g., The latter does does not technically support non-greedy matching, which I do find it somewhat commonly used.
Submitted: https://github.com/chmln/sd/pull/2
This code is very ugly but when I try to deduplicate code I get errors like `expected struct 'reqwest::Response', found struct 'std::fs::File'`. Any recommendations on how to clean it up and make it more idiomatic? ``` fn parse_urls(production: bool) -&gt; Vec&lt;String&gt; { let mut urls = Vec::new(); if production { // should have some more error handling and retries here let urlhaus = reqwest::get("https://urlhaus.abuse.ch/downloads/csv").expect("reqwest issue"); let mut rdr = csv::ReaderBuilder::new() .comment(Some(b'#')) .from_reader(urlhaus); for result in rdr.records() { let record = result.expect("csv read problem"); urls.push( record.get(2).expect("cvs parse problem").to_string() ); } } else { let urlhaus = File::open("dev/csv").expect("error reading file"); let mut rdr = csv::ReaderBuilder::new() .comment(Some(b'#')) .from_reader(urlhaus); for result in rdr.records() { let record = result.expect("csv read problem"); urls.push( record.get(2).expect("cvs parse problem").to_string() ); } } urls } ```
`sed -i -e s/before/after/g` is what I which seems to work well on both. I have been bitten by the differences before, though, and you need the `-e` to make this work. I'd actually be a little concerned about in-place editing without a backup file, however. The naive implementation (which indeed is how `sd` implements it) would just write out to the same file that it read in from; which can easily lead to a file that is truncated if the disk fills up while writing, which is a surprisingly common occurrence if you have a runaway process writing to a log file quickly. Then what you thought would be an idempotent substitution can end up truncating the file. The safer way to do it is to write to a temporary file, sync, and rename over the original; that way, you can catch any error writing, and do the rename atomically. You do need to make sure that the presence of a temporary file won't bother any other applications that may be watching the directory, though. Now, this might not matter that much if you're doing it on your source checkout and are not likely to fill up your disk, and you can just `git checkout` to get the original back if something does go wrong. But if someone puts this in a script running on a server, in which something goes wrong and writing fails, you can wind up with a lot of files truncated to zero bytes and wreak all kinds of havoc on a system.
thanks &amp;#x200B;
I disagree. Take HKTs, for example. I would like to see HKTs in Rust, but I would rather know that they will never exist than to have people spend time and energy working out HKT implementations that are doomed from the start.
Bad bot
I'm having a bit of trouble trying to get around this borrow-checker issue. I'm very new to Rust, so it could be something really basic. This is a snippet of how my program looks: fn bar(&amp;mut self) -&gt; Result&lt;Node,ErrorType&gt; { // not a pure function .... } fn foo(&amp;mut self) -&gt; Result&lt;Node,ErrorType&gt; { let mut my_var = self.bar()?; // POINT ONE loop { // prop::test() takes in &amp;self match self.prop.test() { // POINT TWO Some(Blah::No) =&gt; break Ok(my_var), None =&gt; break Ok(my_var), }; // prop::do_something() takes in &amp;mut self my_var = match self.prop.do_something() { // POINT THREE Some(Blah::Yes) =&gt; { let other = self.bar()?; // POINT FOUR my_var = Node { first: Box::new(my_var), second: Box::new(other), } }, _ =&gt; break Err(ErrorType::SomethingHappened), } } } When I try to compile, I get three errors: * POINT ONE is a mutable borrow, and POINT TWO is an immutable borrow * POINT ONE is a mutable borrow, and POINT THREE is another mutable borrow * POINT ONE is a mutable borrow, and POINT FOUR is a mutable borrow BUT, when I change the question marks (e.g. [`self.bar`](https://self.bar)`()?;`) into `.unwrap()`s, all the errors go and it compiles perfectly. Is there a reason for this? I've been trying to rearrange my code but everything I try fails to compile, other than just leaving the unwraps in there. The goal is basically to call self.bar() once, then, while a condition is met (dependent on the state of self), update self, and keep calling [self.bar](https://self.bar)() and nesting the result deeper in the object.
Are you using `cat` to pass the file in?
Knowing where the language is going to go in 1, 5 and 10 years is extremely important to make the decision on whether to use it or not for this project or that project. If there had been an RFC stating "we're never going to add any async/await style functionality" I would have never even considered Rust for any sort of network service because using tokio and futures without it is just a horrible experience and kills any sort of productivity. Same goes for other features in the language, I can think "yeah, I'll take the hit for missing feature X right now, but I know it's going to come eventually, so it's going to be fine", and then it's not fine because it was never even in the plans and any proposals are shut down or "postponed" (which is just a nicer in appearance way to shut it down, but actually even worse because it states it might happen in the future). This is especially true for a language like Rust, where in the past 5 years I've been using it the answer to any question relating to something which was/is impossible to do was either "oh, there's this RFC that hasn't been touched in 2 years, so it might come eventually", or "yeah, it's going to come, but no solid plans or proposals", or "no idea" and then 2 months later someone within Mozilla comes up with a proposal and implementation which gets fast-tracked. Personally I've always looked at Rust as the meeting point between PLT research and the pragmatism of the industry, when I decided to use it, it was never for what it provided at the time but because of its potential to grow in the "right" direction and what I thought it was going to provide in the future, it was an investment. It's important for everyone involved to know whether Rust is right for them or not, and if it isn't they can spend their resources on something else.
I don't see how negative RFCs do much to combat endless growth. You'd either need to play whack-a-mole with a correspondingly endless array of negative RFCs or they aren't going to make a dent — the language can still grow endlessly minus the few things on the negative list. You'd need to have other filters in place, and if you have those, what are you getting from negative RFCs? Basically, it makes sense to have systems that filter out avenues of growth where the cost-to-benefit ratio is too low. All the rest of the article seems to be going in that direction, with negative RFCs being the odd one out. If a feature can get by the filters that are in place, then it seems like either the feature is in the subset of features you do want, or the effort you'd spend writing and debating a negative RFC could instead be spent improving the filtering mechanisms.
TL;DR -- Graydon makes good points in the abstract; but to me it lacks concretion wrt. the relevance of the points and a demonstration of some of the enumerated possible problems. --------------------- &gt; The costs are combinatorial with many dimensions of the project and language size, and almost always increase. No, they don't almost always increase; notably, I've written 3 recent and accepted RFCs that purely remove user facing complexity while at the same time allowing more valid programs (completeness): - https://github.com/rust-lang/rfcs/pull/2300 (stabilized) - https://github.com/rust-lang/rfcs/pull/2302 (stabilized) - https://github.com/rust-lang/rfcs/pull/2535 (implementation under way) A fourth one that hasn't been accepted yet also removes complexity by making type ascription work generally instead of just in `fn foo(x: u8) {..}` and `let x: u8;` - https://github.com/rust-lang/rfcs/pull/2522 Here's two more RFC that also eliminates inconsistencies (I didn't write these): - https://github.com/rust-lang/rfcs/pull/2565 - https://github.com/rust-lang/rfcs/pull/2602 - https://github.com/rust-lang/rfcs/pull/2515 The common theme here is that they take some concept that already exist and apply them uniformly. The goal is to reduce the overall number of rules ("complexity"), and in particular special cases, that a user needs to keep in their head at the same time. Instead, you learn two concept once and then they compose; if they don't, understanding the language becomes more complex. Good language design, to the extent possible, should be focused on composability and avoiding a feeling of ad-hoc / special casing. ------------------------ &gt; Reputation for overcomplexity, loss of users. Becoming the next C++ or Haskell. Haskell's lack of users isn't due to complexity but rather because of: a) lack of stability; most `{-# LANGUAGE #-}` pragmas should have been added to the report a long time ago, but people are too conservative. b) lack of good documentation: Haskell code is usually well documented but not with examples and in a fashion that most programmers think in. c) lack of libraries for non-PLT/type theorists: Haskell has many excellent libraries, but because much of interesting PLT research is done with Haskell (Agda, Idris, Haskell itself, ...), many of the libraries cater to academics rather than industry. d) being different than other most languages; the inertia of imperative/procedural programming is slow to get rid of but it has been happening gradually. There's a certain cycle: industry wants Java, so university teaches Java, but now since so many people know Java, industry wants Java, so university teaches Java, ... That said, I don't think Haskell is even nearly as complex or ad-hoc as C++ is. In particular, given that Haskell feels close to basic maths, I find that it's easy to teach Haskell to someone who has never programmed before. There's no pointers, allocation, mutation, or any of the usual pitfalls that beginners face. Someone who is used to stateful impure programming in a language with subtyping will have a rocky start with Haskell tho. The semantics of Haskell are also quite simple which is evidenced by being able to desugar into System FC, which in turn can be described in a single A4 page (including typing rules). The syntax is remarkably consistent as well. Admittedly there are a bunch of extensions; but many of them you can do without and they are deprecated. All in all, I would say that Rust the language (as opposed to idioms encoded in common libraries..) is significantly more complex than Haskell. ---------------------------- &gt; The strains on the people working on the language. Some parts of the project can be delegated, de-synchronized, proceed in parallel with as many hands are available to work on them. Not so the shared technical artifacts. The language, being a shared technical artifact, can be worked on in parallel; for example, WG-NLL, WG-NLL, WG-grammar, the async stuff, ..., are all largely being worked on by different people. The same people who do language design (e.g. myself) do not necessarily also do the implementation work. However, there are "sync points"; in particular, when T-lang stabilizes a language feature, the whole team needs to check their boxes; that might take a day for the team member to do, but usually it takes much less than that and stabilizations are not that frequent a thing. Furthermore, when stabilization is proposed, a report is usually written which condenses all relevant info for team members so that not everyone has to do deep research. ---------------------------- &gt; I think the project needs to pause, reflect, consider collectively, and put some controls in place. Before pausing, I think problem should be more clearly demonstrated. &gt; Embrace negative space. Make a process for defining features and concepts out of the future trajectory of the language. Allow (or encourage) RFCs that say "Rust will never have X" for some value of X. What would the process be for accepting a negative RFC? Does it get accepted if all team members agree or does it get accepted if just one does (by virtue of that the positive RFC wouldn't be accepted by that same team member...) I think one problem with negative RFCs is that the world of software changes, and with that, we may need something we didn't before. Maybe someone found out a really useful application of a feature that makes the lives of many rustaceans better, but because we said never, now we can't do it even if requirements change. A more fruitful path is in my opinion to consider what [future possibilities](https://github.com/rust-lang/rfcs/pull/2561) there are and then we can evaluate proposals and keep tracjectories in mind instead. &gt; paint certain categories of expressivity permanently out of the type system (eg. dependent types, HKTs, etc.) We'd need to start by unapproving [RFC 2000, `const` generics](https://github.com/rust-lang/rfcs/pull/2000) since it amounts to const-value dependent types. I personally hope to break the runtime barrier one day; If Rust is to truly put its goal of empowering *everyone* to build *reliable* software a reality, dependent types help a lot. Higher kinded types may also be quite useful one day but their interactions with lifetimes might not pan out. I think we should experiment here. I would be opposed to a negative RFC for these. &gt; or out of the set of kinds of item (eg. anonymous record types) There's an RFC which I wrote that proposes adding them... https://github.com/rust-lang/rfcs/pull/2584 I don't see how I'd all of a sudden accept the exact opposite: a commitment to never add them. &gt; or out of the set of inference obligations in the middle-end (eg. constant value synthesis, implicit arguments) We already have implicit arguments; `fn foo&lt;T&gt;` &lt;-- `T` is an implicit argument. Without value inference ("synthesis") I think const generics would be in a bad state. &gt; lines of code in the compiler Seems like an artificial limit; not all lines are created equal and having limits could incentivize lower code quality. &gt; percent test coverage, percent of documents allowed to be marked as "incomplete" Seems useful; in particular, I think we should much more heavily document `rustc` and work of the technical debt. &gt; number of productions in the grammar I think the number of productions have actually been reduced recently ;) &gt; Allow the moderator team to apply rate limits or cooling-off periods to particular discussions as a whole. Sometimes an outside perspective that a discussion is just too heated overall is an easier way to de-escalate than shining a spotlight on a single person's behaviour. I think we already do this? --------------------------- Happy new year!
&gt; What would the process be for accepting a negative RFC? Does it get accepted if all team members agree or does it get accepted if just one does (by virtue of that the positive RFC wouldn't be accepted by that same team member...) &gt; &gt; I think one problem with negative RFCs is that the world of software changes, and with that, we may need something we didn't before. Maybe someone found out a really useful application of a feature that makes the lives of many rustaceans better, but because we said never, now we can't do it even if requirements change. A more fruitful path is in my opinion to consider what future possibilities there are and then we can evaluate proposals and keep tracjectories in mind instead. My opinion is that "never" is a bad idea in most cases, but some "we ain't doing this" per edition (I don't remember how often editions are intended to come out) would be good. Honestly there are things that are actually never going to happen and completely out of scope for the language as far as I'm concerned, but that "completely out of scope as far as I'm concerned" I assume is quite varied among people who are actually part of the Rust teams, so it would be nice if those things were at least agreed among the teams and the community at large. All of that would help to shape roadmaps for more than "hey, what are we doing next year?" and form an overall vision for the future of the language.
&gt; My opinion is that "never" is a bad idea in most cases Yeah :) &gt; I don't remember how often editions are intended to come out ~3 years &gt; but some "we ain't doing this" per edition would be good. That seems more reasonable and can be part of the roadmap; However, we should keep in mind that sometimes an architectural change in the compiler such as Chalk can suddenly enable useful things like const generics, GATs, `for&lt;T: Debug&gt;`, or other high-power type system features which were previously blocked all at once. &gt; Honestly there are things that are actually never going to happen and completely out of scope for the language as far as I'm concerned, but that "completely out of scope as far as I'm concerned" I assume is quite varied among people who are actually part of the Rust teams, so it would be nice if those things were at least agreed among the teams and the community at large. *I think* one such broad consensus is around Java-esque inheritance and pervasive subtyping that doesn't arise from lifetimes.
I spent a bunch of time writing bindings around https://lcboapi.com/ until eventually noticing the notice that it's shutting down in half a month. Apart from that, working on Advent of Code. I first started learning Rust a couple of years ago by doing AoC, so it's interesting to see each year how much I've improved.
Is Rust growing uncontrollably? I don't see language features like HKT or overloading or default arguments or any of the wide range of wants on the RFC track being in any way comparable to how most languages are judged as "bloated" like how large the Java / C# standard libraries are or how complex the grammar parsers for C++ are. A lot of RFCs are basically compiler-internal complexity when processing the same code you were already writing, maybe letting you put a name you already had in a place you couldn't before but could now thanks to the compiler doing more work. I said it on the HN post and I'll say it again here - it doesn't make the language easier for anyone for you to run into a situation where you want to do something but cannot because the language isn't expressive enough to support it. What is considered bloat in most languages is not a mark on its expressiveness but on its verbosity. It is very important to distinguish the two, but concepts you cannot express now only lead you to overly complex hack job solutions to work around the absence of the feature. Or maybe you just don't use Rust at all for your problem. 
I'm not sure what "in the works" RFCs you would want to say "never" to. HKT and such are evolutions of expressiveness rather than, say, bloat of a standard library with esoteric container types. Rusts design is good enough to avoid almsot any kind of bloat in the core language by having an extensible field of crates to support it - what we end up with in the RFC pipeline, especially that which is popular and desired, is almost exclusively patching holes in the expressiveness of Rust. And it would be a major 180 in what I have felt the direction of the language has been for years to start putting up "never" roadblocks on expressiveness proposals. Its not like they aren't thoroughly audited before adoption - there are a hundred features gated on nightly, some that have been there for years, that have just sat without stabilization because the core team doesn't want to commit on the long term expansive scope of the language some of those changes entail. At the end of the day Rust *is* a kitchen sink. It is a native language that provides the latest and greatest kinds of zero cost abstractions *without* compromising the integrity of memory safety. Developers from all walks are approaching it to solve radically different problems *because* its expressive. Don't stop that forward march in the name of purity, that is the bed so many functional languages have died on.
why would you use this instead of ripgrep, which also supports replacing?
Yeah, I disagree with the never, see below some elaboration, it's more about roadmaps and expectations rather than purity of design or whatever. 
Wrong subreddit. You're looking for /r/rustgame
I love what you are saying, especially in regards to consistency - in my experience a language isn't hard to approach because its book is long, its hard to approach if the number of arbitrary gotchas and the required memorized eccentricities of the grammar and control flow overwhelm my ability to be productive when writing it. A single line of C++ can throw me down an endless rabbit hole of fear about how it could break the program or cause undefined behavior or leak memory or produce a null pointer. Every glyph you write in a .cc file is a bomb waiting to blow in some undefined undocumented way. That is an *immense* burden to bear, much worse in the long term than having to google a few more error messages to understand a cohesive and consistent model. I like to use JS as an example of this - modern JS/ES6 is not really that much more complex than ES4. There is *more* to it, but that more has supplanted the need by many for third party replacement libraries and frameworks that were necessary when the language wasn't naturally expressive enough. If you can't implement a concept in concise intuitive grammar you end up writing a thousand lines of hacks to make it work in really ugly and hard to manage ways. Likewise, Javascript has traded complexity in the language (like async and its myriad type definitions - classes, lets, etc) for patching older eccentricities that made the model so flawed a decade ago. Someone getting into JS now has more they could potentially learn, but the fundamentals have only gotten easier since 2008. There is more beyond fundamentals now, but those just let you actually write the code you want rather than ending up having to work around holes in the language in complex ways. Rust has very much strayed on the side of avoiding undefined and esoteric behavior in the language in exchange for a greater burden of upfront learning to understand how it avoids the pitfalls. But it makes it the most easygoing language to actually write in practice - you don't have to memorize all the gotchas and quirks to avoid if the language actively avoids having them by expanding its expressiveness when due. That is something that should *never* slow down, as necessary, because the alternative is that solutions are written and depended upon and reused and internalized in the community that introduce actual overhead and complexity to the process that will actually drive people away from adopting Rust.
You could say that lmao
You're on the right path here. Rust uses the type to not just determine the shape of the data in memory, but also how it can be used. For instance, a `String` is represented in memory as a `Vec&lt;u8&gt;` (indeed, it's implemented as a `Vec&lt;u8&gt;` under the hood), but the two cannot be used interchangeably. An `(i32, i32)` might represent a coordinate in some system, or it might be a Gaussian integer. Multiplying Gaussian integers makes sense—multiplying coordinates less so. In Rust, you can define `struct Point(i32, i32)` and `struct Gaussian Integer (i32, i32)` (or `struct Point { x: i32, y: i32 }` and `struct GaussianInteger { re: i32, im: i32 }`; they all have identical representation in memory), and implement different traits for each type, and the compiler will keep you from using one when you meant to use the other. Wrapping (generally a simple) type in a wrapper with nothing else in it is called making a newtype (the name coming from Haskell where `newtype` is a keyword for this purpose). For instance, you might have a system with both user IDs, product IDs and order IDs. All of them are represented by `u64`s, but by wrapping them in newtypes, you: * Make it clear from function signatures what type of ID is required or returned by different functions * Can have the compiler guard against accidental confusion, passing a uid where a pid was wanted * Prevent nonsensical operations from being performed on the value, like multiplying a user ID by a product ID, or adding two order IDs together. Bringing this back to `usize`, by keeping it a separate type from `u32` or `u64`, you can compile the program on either size architecture without having your variables holding indices be too big or too small. Because Rust doesn't automatically translate between numeric types, it also makes it clearer where you're, e.g. using an `i32` as an index since you need to add appropriate casts. This steers you towards using `usize` where you want an index, so you can avoid lots of extra casts, and raises warning flags for where you might want to double-check your assumptions (e.g. what if that `i32` is negative, or if the `usize` is too large to fit in the `i32`?)
You can use `Into` [like this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7a9a09bc9467e176b4416363efc87b6b), but it won't know what `A` to choose, so you'll have to always specify it by either turbofish or having sufficient information where you're using the return value.
You probably want r/playrust.
ripgrep's primary function isn't for replacements, although you're right, it does support them to an extent. A key feature that this program supports is in-place replacement. That is, it will modify your files if you tell it to. ripgrep has no option to let you do that (and likely never will).
Since your two cases both implement `Read`, you can split out everything from creating the `ReaderBuilder` on into a function that takes something that implements `Read`. Additionally, you should be able to `collect` directly from the csv Reader instead of having to `push` manually. Something like: ``` fn parse_urls_from_reader&lt;R: Read&gt;(reader: R) -&gt; Vec&lt;String&gt; { csv::ReaderBuilder::new() .comment(Some(b'#')) .from_reader(reader) .records() .map(|result| { result.expect("CSV read problem") .get(2) .expect("CSV parse problem") .to_string() }) .collect() } fn parse_urls(production: bool) -&gt; Vec&lt;String&gt; { if production { let urlhaus = reqwest::get("https://urlhaus.abuse.ch/downloads/csv") .expect("reqwest issue"); parse_urls_from_reader(urlhaus) } else { let urlhaus = File::open("dev/csv").expect("error reading file"); parse_urls_from_reader(urlhaus) } } ```
&gt; I love what you are saying, especially in regards to consistency &lt;3! &gt; in my experience a language isn't hard to approach because its book is long, its hard to approach if the number of arbitrary gotchas and the required memorized eccentricities of the grammar and control flow overwhelm my ability to be productive when writing it I think that's exactly right and we should work hard on trying to eliminate sharp edges and inconsistencies. If things can be split into subcomponents and understood by their composition the amount of things to learn can substantially decrease. &gt; That is an immense burden to bear, much worse in the long term than having to google a few more error messages to understand a cohesive and consistent model. Indeed! I think we need to think about enhancing terror-free refactoring-friendly programming; this is why coherence (and type safety) is great -- you don't need to think about the provenance of implementations so there's no `HashSet` problem. /u/edwardkmett gave an excellent talk about coherence in 2015: https://www.youtube.com/watch?v=hIZxTQP1ifo. [Parametricity](https://en.wikipedia.org/wiki/Parametricity) is another such property that makes refactoring and local reasoning easy; somewhat sadly we'll see it completely go with specialization (of course we hopefully win other things in exchange...). Recently we got `const fn` and while the original motivation was just CTFE, it has the nice side effect (^.^) that you get determinism and better local reasoning.
I see value in negative RFCs that simplify "positive" RFCs. For example, pretty much any non-trivial syntax extension has a huge wall of comments explaining why it doesn't play nice with some other hypothetical syntax extension like named/optional arguments, do-notation, etc. Having a negative RFC that says, for example, "named arguments aren't going to happen" means we can stop tip-toeing around anything that might be used for that feature.
I can't understand how you can truely believe that Haskell is not complex for everyone. Yes it's like Math, a lot of people don't like Math. Mutability and side effects are something very easy to understand because it feels natural. Stacking effects and the IO Monad is not something that talks to everyone. It's probably easier to reason about for people who likes Math and theories, but not for the rest. Most developers wants to get shit done and are happy with Python and the like. They don't care about theory if it looks like it works. They don't care about how it works. They don't care about what a semi-group is. They don't care about abstraction. They don't care about Monad composition. Anyway, i am sure that's an endless discussion that we might never agree on. 
I've been talking up const fn in other posts about this blog as an example of just what Rust needs to keep accumulating going forward. If you were writing Rust before (and now if your code cannot be const modeled yet, such as with generics or trait objects) and you wanted that behavior you had to turn to really ugly hacks like lazy_static using the macro engine to simulate the behavior in a few hundred lines of metaprogramming. And that was a lucky break - at least there was a workaround there. One of the things I like is how most implementations of expressiveness enhancement has been brought in via minimum implementations. Its min_const_fn, or min_impl_trait, or min_proc_macro. The RFC process distills out 90% of the missing expressiveness into implementations that are 10% as complex as the full version. And the minimum impls don't preclude expansion later, but just cutting off chunks of modern language theory or potential extensions of the language for the sake of "simplicity" reeks of the mindsets that have kept functional languages - for the sake of their purity - out of mainstream adoption for decades.
The `AtomicFoo` series of integer values are perhaps the simplest ones to get your head around without the programmer needing to manually bring in external rules and mechanics for shared mutability not going haywire.
&gt; I can't understand how you can truely believe that Haskell is not complex for everyone. Haskell has simpler operational semantics and does not have subtyping; it seems to me simpler from a purely technical POV. &gt; Yes it's like Math, a lot of people don't like Math. Not all mathematics are the same; I don't need to understand anything about statistics to understand basic set theory and functions which is what you should learn at any university or even high school for functions and variables. If you know basic functions and set theory then you have all the background you need to start learning Haskell. &gt; Mutability and side effects are something very easy to understand because it feels natural. Why does it feel natural? You should motivate your assertion. Mutability and side effects are opposite to the way variables and referential transparency work in basic mathematics; e.g. if you write `f(x) = g(x) + g(x)` then if you cannot rewrite this to `f(x) = 2 * g(x)` that is unnatural. &gt; Most developers wants to get shit done and are happy with Python and the like. As opposed to? I think Rust and Haskell are great tools for "getting shit done". The goal of PL and FP research is to facilitate getting more shit done faster and more reliably; I think it's easier to get more shit done in Haskell than in Python because I have types and value inference to act as my pair programmer. Idris-2 is even better in this respect: https://www.youtube.com/watch?v=mOtKD7ml0NU. &gt; They don't care about theory if it looks like it works. They don't care about how it works. They don't care about what a semi-group is. They don't care about abstraction. They don't care about Monad composition. Even if they don't, it's my job to make the ergonomic and idiomatic solution also the most robust and performant one. However, I believe in people, and I like to think that people do care about correct and maintainable software.
Generally, when you deal with I/O, you conceptually have a stream that you can arbitrarily read or write from. In practice, structures like file descriptors have to maintain an internal state (e.g. the current position within a file) that must be updated whenever they are accessed. This can also manifest in a few other "technically stateful" data structures as well, like random number generators. For the most part, interior mutability is useful when users of an API shouldn't be concerned about how something is being modified internally. If you're only using it to satisfy the borrow checker, you might want to try reorganizing your code first.
&gt; I've been talking up const fn in other posts about this blog as an example of just what Rust needs to keep accumulating going forward. :) &gt; One of the things I like is how most implementations of expressiveness enhancement has been brought in via minimum implementations. Its min_const_fn, or min_impl_trait, or min_proc_macro. Totally; but we need to also be mindful of the road ahead and stay forward compatible with the "apply rule pervasively" extension; with `min_*` I think we've managed to do that. By the way, we just stabilized `min_const_unsafe_fn`, https://github.com/rust-lang/rust/pull/57067 =P
&gt; notably, I've written 3 recent and accepted RFCs that purely remove user facing complexity Oh my god I have wanted these features for so long thank you!
Do you have plans to add more operations, like inserting lines after/before a match, or deleting them?
Seems like caching would be a good example. Like if I had a struct that took in a large text and then had functions to count the words, count the adjectives, count the characters, count the bytes, etc... Then to the user this should be immutable because the text doesn't change, but if after the first call to count adjectives I could save the value then all future calls could be essentially instant. Alternatively it could do all the counts up-front but that could be a huge waste if most instantiations of the struct only have a small portion of the functions called.
\&gt; which is what you should learn at any university Exactly, not everyone went to University or enjoyed it. Set theory is theory, some just like practice. \&gt; Why does it feel natural? You should motivate your assertion. Mutability and side effects are opposite to the way variables and referential transparency work in basic mathematics Because most people don't think mathematically. They think "if this do that then that". "if i set temperature to 80 then that burns... woops was too much, let set to 30, yay! program works, manager happy..." \&gt; As opposed to? As opposed to develop a software which is sound and maintainable but will take more time to develop. Static typing is seen as burden for some. \&gt; I think it's easier to get more shit done in Haskell than in Python because I have types and value inference to act as my pair programmer Or you can see the compiler as a burden which takes time to run and doesn't let you run things to see what happens. \&gt; I like to think that people do care about correct and maintainable software. It's all about compromise and where you place yourself your software in the project management triangle. Everyone would like to have a correct, maintainable, fast and quick to develop software. You can't have everything and a lot of developers are leaning toward the "quick to develop"... &amp;#x200B; I think it's irrelevant to blame the lack of documentation, libraries or stability. Most languages started like that and without huge investment. If the language doesn't grow and the ecosystem is almost dead, then it has to do with the language... Yes Haskell is a very different language but it was born in a time where things were changing and new concepts were adopted. If the concept itself was simple to grasp and let you get shit done, no doubt it would have been successful. &amp;#x200B; Haskell is really good in theory and that's where it's used the most. You can't be the best at everything and it's ok :)
`Rc` does not implement `DerefMut`, so `Rc&lt;RefCell&lt;T&gt;&gt;` is a common pattern.
This is sick! That instant feedback looks amazing. I have been seriously burned out by a large project I've been working on while waiting to see if the line I just typed is even valid.
`Regex` is on such example that you might have used. Internally, at match time, a regex uses mutable scratch space in order to determine the position of a match, and if necessary, the positions of matching capturing groups. From the API user's perspective, this mutation cannot be observed and folks can generally treat a `Regex` as if it were immutable. More precisely, from a correctness perspective, the execution of a regex could allocate space at search time and discard it after the search is complete, and then repeat the process in subsequent searches. This would avoid the need for interior mutability, but at the (fairly significant) cost of allocating new space at search time, which could potentially include re-computing costly things (such as DFA states). Exposing interior mutability like this does come with costs, especially if you really want to sell the illusion of immutability to the API user. In particular, it requires handling synchronization internally as well, and /u/amanieu has [helped with that](https://docs.rs/thread_local) to make it very fast. An alternative to the above is to push the mutable state required up to the caller, but this then makes the API of regexes quite a bit less ergonomic for not much gain. It's a prototypical example of making the implementation more complex in favor of a nicer API with a very small overhead cost. Another place where I use interior mutability is in cases where the borrow checker gets in the way of easy decomposition of code into smaller logical components. Sometimes a code reorganization is called for, but in other cases, it might not be worth it. It's a judgment call. A critical point here though is to make sure that your choice to use interior mutability doesn't leak out into the public API. It often can in a fairly subtle way, e.g., by causing your types to lack an impl for `Sync`. If your types otherwise expose an immutable API, then this can be quite surprising to your users!
See Xi for a pure WIP Rusty editor that could possibly be backed by this Rust-Analysis tech to make an IDE like experience in the future. 
I'm betting the problem is in creating the type itself, not resolving it. Rust generators are all on the stack, so by recursively calling yourself you're making an infinitely sized type. Just like when making recursive structs, the solution I would recommend is boxing the inner generator - breaking the infinite '
&gt; Exactly, not everyone went to University or enjoyed it. Set theory is theory, some just like practice. As I said, high school mathematics (functions and variables) should be sufficient; If you can understand that a set has some elements and that a function `f : A -&gt; B` takes elements from `A` and maps them to `B`, then you are good to and can start understanding types / FP. This is also essential knowledge for understanding Rust imo. &gt; Because most people don't think mathematically. They think "if this do that then that". "if i set temperature to 80 then that burns... woops was too much, let set to 30, yay! program works, manager happy..." Have you asked most people? From my time as a teaching assistant (Java course) it was my experience that the concept of mutability wasn't natural to many students. &gt; As opposed to develop a software which is sound and maintainable but will take more time to develop. Static typing is seen as burden for some. I don't think writing something in Haskell or Rust reduces productivity, if anything, the lack of types it much harder to refactor and understand a program. My overall point is that PLT research is about facilitating "getting shit done"; Go, python or other languages do not have monopoly on wanting to get shit done. Monads help getting shit done... and so do types. &gt; Or you can see the compiler as a burden which takes time to run and doesn't let you run things to see what happens. Haskell happens to have a great REPL letting you see "what happens"; it would be great if Rust had one too. &gt; It's all about compromise and where you place yourself your software in the project management triangle. Everyone would like to have a correct, maintainable, fast and quick to develop software. You can't have everything and a lot of developers are leaning toward the "quick to develop"... It may be so; but the gain in popularity that TypeScript has seems to suggest otherwise. At a certain point of complexity (200+ LOC imo) it becomes too hard to reason about a program without types; then the lack of types suddenly turn into "slow to develop". As Rust is about erasing dichotomies, given that we've checked boxes for correct, maintainable, and fast, I think we can tick "quick to develop" soon as well with enough effort. &gt; I think it's irrelevant to blame the lack of documentation, libraries or stability. Most languages started like that and without huge investment. If the language doesn't grow and the ecosystem is almost dead, then it has to do with the language... The main point was about inertia; when most mainstream languages are one way and everyone is used to that it is hard to swim against the tide. However, the Haskell ecosystem is by no means dead and is growing as far as I can see. I do think that the availability of good libraries plus a "killer app" such as UNIX or the web (JS) makes all the difference. There's no inherent reason for JavaScript's popularity besides being the standard web language. Hype also plays a role, "X company made Y language". &gt; Yes Haskell is a very different language but it was born in a time where things were changing and new concepts were adopted. If the concept itself was simple to grasp and let you get shit done, no doubt it would have been successful. Back in the days Haskell wasn't very useful as it couldn't even handle IO... Things have changed quite a bit since then. Haskell has also had a huge influence on various languages (e.g. Rust, Elm, C#, ..). Speaking of Elm, it seems to me that it is gaining traction and the basics of Elm are the same as in Haskell. All in all, I think FP is on the rise and that's a great thing.
I think you missed the key word "Reputation" at the beginning of the sentence. While I personally agree with you that I find Haskell less complex than Rust (especially when you start writing higher-order functions in Rust), Haskell certainly has the reputation for being a very complex language :(. Unlike C++, I feel that reputation isn't warranted but that doesn't mean it doesn't exist.
I'm using it to hot reload html templates when in development mode. In production it strip it out with cfg flags.
Thanks for asking! That was gonna be inevitable, due to the sed comparison :) &amp;#x200B; You can already do the first two by replacing a match with itself and some newlines before or after. Lines can also be deleted by replacing e.g. "$line\_regex\\n" with "". &amp;#x200B; I don't really intend to add some sort of a DSL, I think that'd be outside the scope of the project.
I do not agree that they would not prevent growth. Language features and additions are not in endless supply, at least not especially good ones the project would have to worry about. There are pretty [well-mapped](https://www.goodreads.com/book/show/89197.Programming_Language_Pragmatics) [expositions](https://www.goodreads.com/book/show/772585.Concepts_Techniques_and_Models_of_Computer_Programming) of the [feature space](https://www.goodreads.com/book/show/13449354-practical-foundations-for-programming-languages) of plausible language design. The only reason I suggested negative RFCs is that they are a way of collectively articulating a limit in advance, and "once and for all", rather than just implicitly assuming that the limit is "the union of everything that fits, always", and repeatedly revisiting it / re-spending everyone's time to revisit each feature to see if there's room now. Maybe "always pushing for more" is not a good limit. Maybe it's better to have things be easier than the hardest-tolerable, cheaper than the most-expensive-affordable, etc.
&gt; I don't see language features like HKT or overloading or default arguments or any of the wide range of wants on the RFC track being in any way comparable to how most languages are judged as "bloated" like how large the Java / C# standard libraries are or how complex the grammar parsers for C++ are. I do see them as being just that. &gt; it doesn't make the language easier for anyone for you to run into a situation where you want to do something but cannot because the language isn't expressive enough to support it. Yes, it does. It keeps the language easier because there is no need to burden everyone with understanding the mechanism of expression. &gt; Its little things like that, the eccentricities and "its like that because it is" of languages that make them hard to learn and bloated, not their comprehensiveness. I completely disagree. Learning minor syntax -- whatever its setting -- is a comparatively shallow cost and takes up little space. Introducing the _syntax_ of raw pointers takes two lines of text in a 60-page chapter on the semantics of unsafe code in of my copy of "Programming Rust" here. The semantics are the costly parts to expand.
Good job. Currently I use a similar tool in rust called fastmod https://github.com/facebookincubator/fastmod 
[Like this?Like this?](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fc4db2fc2addb23a3f95528e2e7f75e7)
&gt; As I said, high school mathematics (functions and variables) should be sufficient; If you can understand that a set has some elements and that a function `f : A -&gt; B` takes elements from `A` and maps them to `B`, then you are good to and can start understanding types / FP. Difficulty is not just in the number of rules, but also in how they are stacked. For example, `f: A -&gt; B` is not complex, and not difficult to understand. But then add `h: (f: A -&gt; B) -&gt; (g: A -&gt; B)` and it’s not a new rule, but now it is way more difficult to learn, and that is the kind of “complexity” that Haskell has. I don’t know the precise definition of complexity in this area, so I don’t know if this is technically complexity, but it sure is harder to learn, and harder to think about while using it. While nesting/stacking concepts is not adding rules, and mapping is mapping whether you're mapping a value or mapping another function/mapper, that is the kind of thing that looks elegant for maths/theory(/Haskell) but can make things more difficult.
&gt; No, they don't almost always increase You found examples where they do not, which is fine and good (I did say "almost"). Shall I go hunting for the examples where they do, that vastly outnumber them? Or shall we simply note that even in your own post here, you can't help yourself with pitching very costly proposals. &gt; take some concept that already exist and apply them uniformly This does not necessarily make things easier, or smaller. It makes them more uniform. Sometimes only the special case is easy to understand, or easy to implement, or easy to teach or document; the general case may not compose without herculean effort, or make sense in all combinations. It depends. Arguing for uniformity or compositionality above all else is an idealistic position but not a balanced one, it's a very particular design preference that discounts plenty of other costs. &gt; We'd need to start by unapproving RFC 2000, const generics since it amounts to const-value dependent types. I personally hope to break the runtime barrier one day; If Rust is to truly put its goal of empowering everyone to build reliable software a reality, dependent types help a lot. Higher kinded types may also be quite useful one day but their interactions with lifetimes might not pan out. I think we should experiment here I will just draw your attention to the fact that, as a reader, I find it very worrying the speed with which this paragraph slides down the slope from the very restricted special case of abstract equalities necessary to support RFC 2000 to the vastly more complex general case of full dependent types. Similarly, the casual HKT comments -- they "may also be quite useful" so "we should experiment" -- completely dismisses the costs of learning, understanding, implementing, maintaining, etc. etc. This is exactly the kind of implicit "let's just try everything" approach I'm writing against. I think the language is putting itself at risk of colliding with limits by taking that approach, and it would be best to limit that approach consciously. Especially given your invocation of "empowering everyone". It is absolutely not the case that "everyone" you might wish to empower to write dependable software is going to find dependent types comprehensible. You _will lose people_. A lot of them. That is a limit you cannot wish away just by saying "it's not too hard". It's not too hard for you. You are very much at the high end of people able to understand hard PL concepts. If they bleed into the libraries, docs, teaching material and reputation of the language, they will collide with many users hard.
Hm, interestingly, a lot of those mechanics proposed where at least glanced at. The mod team _does_ by the way have the right to close of discussions temporarily[1]. Here's a reminder that the mod team is understaffed and needs new people! A team dealing _only_ with those issues was in discussion, but it's also a bandwidth problem. [1] I'd be happy if they used it more, it's a good trade-off between cooling off a debate without immediately banning it. There's a serious issue where discussions pop up with no one competent to answer them and then going into a vicious circle or people just riling each other up in complaints and temporary closure helps a lot there. Often, even the discussing people have a more sober view after a nights sleep.
Oh my god learn to write git commits
I need look-around... It's the most useful part of regex for me a lot of the time. I think at least half of all the regexes I write absolutely require look-around support.
&gt; Haskell certainly has the reputation for being a very complex language :(. Well, it is a very complex _ecosystem_ and people generally don't differentiate. The big problem is that Haskell as used is often beginning with a huge set of PRAGMA's on the top of the file, which are all of different quality and their interactions are not clear. As simple as the language may be, its refusal to standardise extensions has become a huge problem.
This is neat! Nice work!
&gt;Well, it is a very complex _ecosystem_ and people generally don't differentiate. If you look at the core libraries shipping with Haskell platform, all of them can be used with few to no language extensions. Moreover, there is certainly a wide variety of libraries, some with simpler interfaces and others with more complex ones. Unfortunately, more sophisticated libraries get a lot more attention on Twitter etc because they are relatively unique to Haskell. &gt; The big problem is that Haskell as used is often beginning with a huge set of PRAGMA's on the top of the file, which are all of different quality and their interactions are not clear. I started using Haskell almost exactly 1 year back and that has not been my experience at all (coming from Python and OCaml). Commonly used pragmas can be put in a config file (like Cargo.toml). Interactions are almost always pretty clear (and the GHC user's guide is a well-maintained reference), apart from the Monomorphism Restriction. GHC will give you suggestions to enable extensions much like Rust's features. &gt; As simple as the language may be, its refusal to standardise extensions has become a huge problem. I agree that standardizing some common extensions would help. &gt;I feel like the reputation is warranted. Haskell is only a simple language at the very core. A multitude of typeclass extensions, deriving extensions and syntax extensions, if they were on by default, nobody would even have noticed (look at Purescript to see this in action). In terms of things that have been hard to learn over the past year, I'd say extensions are way down on the list given the excellent resources out there.
&gt; Edit: If you could answer what has shaped your perception of Haskell in terms of complexity/ecosystem/extensions that would be very useful to me going forward :) (not specifically this conversation). We need to get better at accurately potraying writing Haskell day-to-day. I have used and followed Haskell since university (2005) and am friends with GHC developers and some users. I have not used it in production in large capacities. I've also been trying to get into the Berlin community and found it very off-putting. 
I did something similar recently with the [`lis crate`](https://crates.io/crates/lis). The interface takes two iterators and returns an iterator (or a generator to be specific).
I think Graydon is completely right in the general sentiment of that Rust should not grow unlimited. The only thing that strikes after reading the post is that the number of limits must also be limited. (!) Sounds a bit funny perhaps, but we can't allow the controls and limits to grow uncontrollably either. Because that also has a cost in remembering and maintaining those limits, and extrapolating a bit, it can take your creativity away if you have to spend your time navigating the control and limit system, rather than spending your time making Rust better.
maybe add an ssh key to github, it looks like u are typing your pw for every push.. 
### 1. Make an enum with a variant for every kind of error, and return that One variant will correspond to Tera errors and contain a `tera::Error`, for example. Here's an example I used often when working on Advent of Code solutions, which very often require reading files, parsing them line-by-line, and parsing numbers in each line: pub enum Error { /// Error reading the input file IO(std::io::Error), /// Input in the file doesn't match the expected pattern LineParse, /// Invalid integer literal // This shouldn't happen since only valid integers would be parsed correctly, but it never hurts to return instead of panicking IntParse(std::num::ParseIntError), } I then had a `From&lt;E&gt;` impl for the contained lower-level errors that returned the correct variant, so I could use `?` on a `Result&lt;T, std::io::Error&gt;` and it would automatically get wrapped into an `IO` variant, as well as a `std::error::Error` impl. Eventually that turned into a declarative macro that took an enum definition and produced all the impls. ### 2. You won't be reinventing the wheel I haven't looked at failure or how other crates handle errors much (other than serenity, which also does it this way). From a quick look at failure, it looks like the same thing but better, as the `Error` struct lets you attach context, see the backtrace, and traverse the chain of nested causes easily. Using failure, you get all of that for free instead of having to reimplement it yourself. ### 3. If it's a small/medium project, I wouldn't, but YMMV I've found that which variant was returned and what line it was unwrapped at (from panic info provided by default) can locate where an error came from just as well as I could from a full backtrace, and errors' Debug impls give enough context. However, I've only worked on small Rust projects thus far, and I'd imagine those statements get less true the larger your codebase. I'd say start without it and refactor it in if you need it.
&gt; Generally, when you deal with I/O, you conceptually have a stream that you can arbitrarily read or write from. In practice, structures like file descriptors have to maintain an internal state (e.g. the current position within a file) that must be updated whenever they are accessed. This can also manifest in a few other "technically stateful" data structures as well, like random number generators. Hm, all those are examples where the common implementations of Rust _do_ expose the mutability. You need mutable access to a stream to read from it, as it modifies the stream state. Interior mutability is generally used when users cannot _observe_ the mutation, such as a Mutex changing it's state from locked to unlocked or an RC bumping its counter.
&gt; ... or how complex the grammar parsers for C++ are. What do you think is the reason for the complex grammar? I think it has a lot to do with adding new features and also to like a certain syntax representation for them, which might not be possible without making the grammar more complex.
I'm not knowledgeable enough to advise you on what's good about the different ways to do error handling here, but I'd just use the error handling from the standard library, and if you happen to be using features that are deprecated, fix that later.
Agreed, but I disagree with `DerefMut` being the main point. `Rc` doesn't implement `DerefMut`, but neither does `RefCell`. More precisely, `Rc` doesn't allow mutability, even with a `get_mut()` method like `RefCell` has.
I agree with basically all of this. Nice answer. &gt; Using `failure`, you get all of that for free instead of having to reimplement it yourself. TANSTAAFL. The price of using `failure` for the first time is figuring out how to use `failure`. So far I haven't been willing to pay. At a glance, it looks like the easy mode path to `failure` is through the `failure_derive` crate. The documentation linked from there is quite a bit clearer than the library documentation for the `failure` crate itself, and the deriving capability looks quite nice. As I said, though, I've only read about it: I haven't tried it. It would be great if somebody who has explored all this in detail in practice could weigh in.
I can personally _not_ reproduce this (from Switzerland). Which OS / Browser version are you using? What is the exact URL you are trying to visit?
There's no reason to use cat, that's what redirection `&lt;` is for. Although the makefile handles it all if you check the readme. As for why I didn't use cargo, every single file is a stand alone solution so i thought this was more straight forward.
Would there be a way to use `..arg_struct::default()` and a Default impl on the arg struct?
Actually, having checked from my phone, I also can’t reproduce this from mobile :( But on my mac it fails. It’s https://crates.io - I don’t think it’s the browser though because it also happens in command line when using cargo.
Can't reproduce failure on either crates.io or with `cargo search` on chrome 71.0.3578.98(the latest)
Yes. I am the squatter. I did it because I don't want anyone to create that account and misuse it. Will hand over the account or delete it, once we know what the next step is. Did it in a hurry, hence the repo is empty, will leave a note there regarding this. 
You can have a look at Tera error handling in the next version: https://github.com/Keats/tera/blob/v1/src/errors.rs The current released version uses `error-chain` but since 1.29 or 1.30, errors in Std support `source` so you can do https://github.com/Keats/tera/blob/v1/src/errors.rs#L74-L78 and have the same behaviour as error-chain Keep in mind the `ErrorKind` is not exhaustive (https://github.com/Keats/tera/blob/v1/src/errors.rs#L35-L39), otherwise adding an error type would be a breaking change. Overall, I would not use `error-chain`/`failure` and stick to std right now. Since this is a CLI tool, you can follow /u/notquiteaplant first point: this is what I do for my own CLI. See https://github.com/Keats/kickstart/blob/master/src/errors.rs#L35-L55 for an example where I wrap the Tera error.
we have had long discussions regarding namespacing. It wouldn't help in this case.
&gt; Wonder if it's fine to propagate that library tera::Error between my public functions, or if that's deemed dirty (as "leaking" a library type) and I should convert it into my own error type before returning it. To put this in more concrete terms: you publish library Foo on crates.io that depends on library Bar and items (types, traits, …) from Bar are part of the public API of Foo, then Bar is a **public dependency** of Foo. If however usage Bar is "invisible" from the point of view of users of Foo, then it’s a **private dependency**. You can add, update, or remove private dependencies at any time without any impact on users of a library. But updating a public dependency to a new version that has a semver-incompatible version number is a breaking change: you should only do it in a new version of your library that itself increments to a semver-incompatible version number, so that users will only get that update if they explicitly opt into it. In Semantic Versioning, for example version 2.4.1 is compatible with all earlier 2.x.y versions, but not 1.99.99 or 3.0.0. In Cargo’s extrapolation, 0.2.7 is also compatible with all earlier 0.2.x versions but not 0.1.99 or 0.3.0. (https://semver.org/ defines 0.x.y not to be compatible with anything.)