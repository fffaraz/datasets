:downvote:-:confused phenomena...
SWT is basically wxWidgets done right. (ie. Like wxWidgets, it's an abstraction around the Win32, GTK+, and Cocoa APIs that doesn't mind filling in the gaps where the platform is missing widgets. Unlike wxWidgets, it has an API that resembles Qt or a GTK+ binding for a language with native support for classes and objects, rather than being full of bare numeric IDs and other un-idiomatic junk.) 
The API is somehow similar in a way and also way simpler then \`jq\`. I would like to keep it as simple as possible and I think the latter is both super powerful and maybe also too complex. In the end, I'm opened to add any feature that can be useful if the tool stays intuitive.
I think that /u/CJKay93 is not saying that this project itself is bad, but rather that it is demonstrating how difficult making safe abstractions is and, hence, why they're useful.
Got it, thanks!
Which is my point - I'm not disparaging the author of this crate, just holding it up as an example of why you really do need to meticulously model your unsafe behaviour. Last I heard of RustBelt was that it was a bit stuck on modelling unsafe - are they planning on modelling unsafe behaviour? I was under the impression that they were going to treat unsafe blocks as black boxes.
How would C knowledge impart anything to me about move semantics? As a C++ programmer, I assure you that you are alienating a large percentage of your audience by not knowing the difference between C and C++.
FWIW the other option is a "tailored" enum, which can be built using a `struct` with `union` fields. 
Can you explain why you think Swift isn't for you? Swift and Rust are similar in many ways, so there's possibility that Rust won't be for you as well.
I am a noob in Rust, but have some experience as a hobbyist programmer. The usage of `mod/use` keywords thoroughly confuses me, and I just can't seem to get it right. Besides the Book, what are the recommended tutorials on the subject of code organization in Rust, i.e. `mod, use` and `crate`? Thanks!
Then I'm afraid that designer has rather strange taste and design vision.
Coroutines are a pretty big part of gameplay programming in the unity engine, for the same reasons I assume you brought up UI programming. Games are inherently stateful, and are full of logic that repeatedly pauses and resumes as it waits for the player to do things.
I've been working on adding support for BLAKE2b for [orion](https://github.com/brycx/orion). It needs another thorough review, then it should be ready to be included. I'll try to get that done and further polishing the API. If I can manage it, the plan is to replace HMAC and PBKDF2 with BLAKE2b and Argon2i, in the high-level API before the next release. I'm also thinking about entirely removing PBKDF2 and HMAC, to remove the sha2 dependency in an effort to decrease the amount of unsafe code in orions dependencies. Then maybe re-add those if orion gets a safe-Rust implementation of sha2. I haven't decided on what to do here yet, though I'm very open to suggestions.
I get what you're saying, but neither C nor C++ has destructive moves the way rust does, so your point might not necessarily apply either way.
For a data point, I work with C++ coroutines, and it's true that if you have long chain of coroutines, and you have a crash at the end, by default you get no information about the "call stack" of those coroutines. We got around it by manually adding in a lot of debug information, via some APIs to walk the chain of calls ourselves, and via enforcing some code standards about using making debug data available to those APIs. But it's not an ideal solution, and it would be nice to get the equivalent of a call stack for coroutines, somehow. My overall point being, this appears to be a problem in c++ as well. What does golang do? C#?
&gt; kill on a plane Find a # Object, and starting injecting people
C++ at least has such thing as a move; C knowledge does not involve the word 'move' at all. And it's not my point: &gt; The premise is that once you understand how move semantics are tightly integrated into the language, assuming past C/C++ knowledge
Fair enough.
I've been working on a website using Rocket, and using a lot of SQL for the first time ever. It's been an interesting experience!
Looks like the program is first reading the contents of the entire file into a buffer before processing it? I sometimes work with json files hundreds of MB large (or even in the GB range), so just reading it all in before processing it is out of question. The full complexity of `jq` revealed itself to me once I got into streaming processing. Any plans to support that?
The in-existence of move semantics in C is brought as reference - because C is still widely used in system programming even for new projects, we cannot ignore it. And I assure you that I do know the difference between C and C++.
Not exactly what you're asking for, but if you won't have wi-fi I like using http://devdocs.io to load the standard library docs offline for fast searching.
I'm part of these 10 contributors but my opinion for the website isn't really relevant (well, I don't like the new website but that's another debate). I'm just a bit sad that they didn't take all some feedbacks into account or at least write a blog post saying what they intend to do. Maybe later?
`rustup doc` will open the Rust documentation locally in your browser. 
I don't think that includes the standard library.
`rustup doc` includes the book(s), std library API docs, the reference, and more
Ah sorry I read cargo doc. Yeah, that'll work for him
I didn't know that. that's awesome. 
I'm not involved in RustBelt, but I imagine it's less about treating `unsafe` as black boxes and more about crystallizing exactly which invariants the programmer is responsible for upholding _within_ `unsafe`.
Yes, many of Rust's safe abstractions are built with `unsafe` internally. We have to experiment at some point. :-) But I do think we should be explicit about such things, lest someone use a library that hasn't been carefully vetted.
Ooh, good point! DevDocs is great for downloading lots of language docs in an easily searchable format, but if Rust is all you need then `rustup doc` all the way!
Man are you taking on a titan with this one. I'm a pretty prodigious user of jq in my work, but I'm always open to new tools. Where do you see this tool primary being used? Interactively on the command line or statically in scripts? for example, this feels like a syntax error `jql '"primes"[0]"' example.json` but it does work! The insistence on quotes is something that improves reliability for scripts, but makes things less easy to type for an interactive CLI tool, but the loosey goosey checking on the quotes harms the reliability you want for scripts.
Yup, that has been my impression too. By figuring out what invariants the type system expects, and mechanising it, we can make it clearer what contract the unsafe programmer needs to uphold. One potential future even would see programmers haing the option to use an external verification tool like Coq to ensure that their unsafe code upholds the right invariants.
Back to working on Criterion.rs - dusted off the CI builds (after six months of neglect they were in a pretty rough shape) and started working on updating the dependencies and fixing bugs and whatnot. I have some minor features that I want to do for 0.2.6 and then big plans for 0.3.0. Japaric also transferred control of the repository over to me, so that's kinda cool. Now, to go mad with the power of it! Muahahahahaha-*cough*. Ahem. Also trying to figure out a safe and ergonomic way to handle asynchronously copying memory to/from the GPU without introducing data races or segfaults for RustaCUDA. So far, haven't had much success - if you have any ideas, take a look at [this issue](https://github.com/bheisler/RustaCUDA/issues/8).
You could also sleep, that works well for me.
What are the advantages of \`jql\` over \`record-query\`? (also written in Rust) [https://github.com/dflemstr/rq](https://github.com/dflemstr/rq) (Obviously \`rq\` has not been updated in a fair while... but It's a tool I depend on quite often. I'd ask about a comparison to \`jq\`, but there are already other comments asking about that :D ) You might consider writing up a section on the readme discussing the differences between the various other tools out there and the relative advantages of jql. 
In rust 2018, `mod`, `use` and `extern crate` were all changed, so I'd recommend checking out that [chapter in the guide](https://rust-lang-nursery.github.io/edition-guide/rust-2018/module-system/index.html)
Yesterday I was writing some 2018 Rust, and wasn't able to figure this out: if I create a directory called `util` which contains only `time.rs`, how do I use this time-module in another file now that `mod.rs` is no longer required? Do I need to create a `util.rs`?
I'm playing around with a toy language, which will go unpublished. Also I'm making this game in Amethyst and streaming all of the programming on [twitch](https://twitch.tv/walterpi) if anyone here cares about streams
You could always code Advent of Code 2018 in rust. Thats what i did on my last flight. 
Worth pointing out that `rq` requires v8 while it looks like `jql` handles json entirely natively. This certainly makes `rq` a heavier tool in that respect. (Though also worth noting that the author primarily distributes `rq` as a binary rather than as source, which pretty much mitigates any annoyance of using v8 with the exception of the binaries they provide being less auditable. )
When using Rocket, it's worth pointing out that an error type can implement Responder. [https://api.rocket.rs/v0.4/rocket/response/trait.Responder.html](https://api.rocket.rs/v0.4/rocket/response/trait.Responder.html) [https://api.rocket.rs/v0.4/rocket\_codegen/derive.Responder.html](https://api.rocket.rs/v0.4/rocket_codegen/derive.Responder.html) So for example, One could do something such as: ``` #[derive(Serialize, Responder)] enum ServerError { #[response(status = 400, content_type = "json")] Validation(Vec&lt;ValidationError&gt;), #[response(status = 403, content_type = "json")] NotAuthorized, #[response(status = 404, content_type = "json")] NotFound, #[response(status = 500, content_type = "json")] InternalError, } ``` Or if you wanted the response json to look/feel in a very specific manner you can impl Responder directly, which is what I do.
thanks, I read the chapter you linked but it's way too terse for my brain, hence I need a good tutorial...
Thanks for that link, it's a very good talk. Time and time again I'm amazed at how accurate the concept of "bikeshedding" is. All the big discussions and arguments always happen about trivial things. The design of the website, the color of Rust on Github, syntactic sugar like impl trait in argument position, etc. I also notice though that a lot of the discussion follows after the fact. After the "change" was made. Perhaps if we could make upcoming changes more "visible" before they happen, it would be good, but the Rust team already puts a lot of effort into that with its FCP procedure and "this week in Rust" though.
Generally not being sync isn't going to effect the speed of requests. The problem is the number of requests per second. If your requests are fast, and given rocket spawns a large number of threads... you can sustain a fairly decent number of requests/s, scaling with multiple workers as needed. If every single request took 1 second, you would end up with a fairly low bound for requests/s (n threads * workers). You would require a very large number of workers. Though most likely in this scenario you can offload work into the background in some manner. For example, responding with a "job token" to the caller and then allowing them to poll to find out when the work has been completed. Having the ability to simply return a future would certainly make handling long running requests easier on the developer though. Rocket is intending to support this in 0.5 IIRC.
Not everybody can sleep in transports (or even outside their beds).
The API has been changing between the major releases. I expect that Rocket will continue to get a few breaking changes to the API after 0.5 but before 1.0. The futures refactor is likely going to be a breaking change in some manner for example. (Though that might also hit with 0.5)
You either need a `src/util.rs` or a `src/util/mod.rs`; in the 2015 edition only the latter would make the compiler recognize other files in the `util` folder as submodules of `util`, now you can instead have the module file in the parent directory instead and give it the same name as the folder. I think the old way is clearer (and having two ways is more confusing) but to each their own. So your directory should look something like this: src/lib.rs or src/main.rs (whichever is applicable): mod util; src/util.rs or src/util/mod.rs (pick one): // refers to `src/util/time.rs` mod time; 
Indeed. I just try to do my best to do my part and _not_ participate in discussions like that unless I feel like I have a high-value contribution or perspective to give. But leading by example doesn't seem to work with stuff like this, because nobody notices the things you _don't_ do, even when it's very intentional.
Remember cargo's -Z offline! :)
I'd like very visible warnings that a non-std library uses unsafe before using.
I've been using specs a lot too and while I disagree with calling it a framework, I think `specs::World` is the most annoying aspect of the API as well. The problem I have with it is that it wraps `shred::Resources` and adds new features that cannot easily be accessed without this type. So for example in `shred::System::setup` where you are given a plain `shred::Resources`, you have no direct access to specs-specific functionality. Essentially, `specs::World` feels like it has an inheritance relationship with `shred::Resources` which is inconvenient when interacting with the shred half of the API. I think `specs::World` should be removed entirely and all of its methods should be free functions or an “Ext” trait that operate on `shred::Resources`.
Thanks for your response. I would need it at compile time, though. I believe currently that's not possible.
Exercism.io was nice when I tried it. I don't know if it has changed or not.
`mod` tells the compiler you want to create a submodule. You can create it inline: ``` mod foo { ... } ``` or you can reference a file: ``` mod foo; ``` The file included is based on where it's included from; if you do `mod bar;` in `foo.rs`, the included file will be `foo/bar.rs`. `use` imports a name so you can use it. It's never necessary to `use` something - just convenient. Writing ``` use foo::bar::Baz; ``` means that you can just use `Baz` in your code and it will reference `foo::bar::Baz`. The form of a `use` path is one of some external crate, `crate`, `self`, or `super`. `crate` refers to the root of the current crate; `self` the current module; `super` the parent module. So if you're in `foo/bar.rs` and you want to import the `Baz` name from `lib.rs` (your root), you can do `use crate::Baz` or `use super::super::Baz`. In short: `mod` tells the compiler where to find your code; `use` lets you use shorthands instead of full paths.
I'm working on two projects: learning about Automata theory by (attempting) to implement an abbreviated RegEx engine, and then also writing a GUI project in Rust + Webview.
I would love to hear more about your toy language. I have been dabbling with PL development as well, although time is short...
I read *15 hours to kill a plane* and thought this would be another /r/playrust candidate :D
Funny because some people before the "official" beta release complained about it. No answers given.
Is `failure` still needed now that we have the `cause` in std?
Download a couple of [live-coding videos](https://www.youtube.com/playlist?list=PLqbS7AVVErFgY2faCIYjJZv_RluGkTlKt) to watch! Given your interests, [this one](https://www.youtube.com/watch?v=9_3krAQtD2k) where I go through how futures, the Tokio event loop, and async/await works might also be of interest!
For that you can use `std::thread::sleap`
Dumbass why did you ban me from your sub?
You can download and read the official [tutorial book](https://doc.rust-lang.org/book/index.html).
&gt; Advent of Code 2018 Oh this guy is golden. Wait, are you Jon Gjengset?
https://learning-rust.github.io might be helpful to gather basics quickly.
**Sleaps**
It's not any one or two big issues--I just get ground to a halt by a million small problems or decisions to make. Rust simply isn't a very intuitive language, and that's fine for a lot of applications where intuition is less important than the difference in performance or correctness as compared to antoher language. But for my projects in my hobby time (or even at work), I need things to Just Work even if it means my app runs half as fast and I have 5% more production issues. :(
I’m sorry it never got intuitive for you. I struggled too for about two weeks. Now the borrow checker is my friend and I really miss the rust compiler when I use python or go now. Rust has increased my dev time a touch in initial coding but almost entirely removed runtime testing. If it compiles it’s 99% there to production code. I encourage you to come back to rust in the future and give it a try. It’s worth the effort. 
I'm sure I will pick it up again. Last time I tried was before NLL and the editor story was pretty terrible (or at least I couldn't get vim/racer/etc working properly and that seemed to be the happy path at the time). How are the VSCode plugins for Rust these days? What can I do to give myself the best chance at a good experience?
To me, SWT *is* a modern version of TK (of sorts, modulo the language).
As mentioned in the tweets, I've blogged about Rust on my company's blog here: - [Haskell and Rust](https://www.fpcomplete.com/blog/2018/11/haskell-and-rust) - [Deploying Rust with Docker and Kubernetes](https://www.fpcomplete.com/blog/2018/07/deploying-rust-with-docker-and-kubernetes) Our VP of Engineering, Michael Snoyman, has also been writing about and teaching Rust. Here's his [Rust crash course](https://www.snoyman.com/blog/2018/10/introducing-rust-crash-course). It won't be identical, but the crash course is representative of what topics we'll cover and in what order. I plan to try to do some gap filling there. I will have more exercises prepared than we'll have time to cover in class, so you should walk away with plenty of take-home material too.
You'd probably have to save each page manually or use wget but my coworker Michael [has been writing a Rust crash course](https://www.snoyman.com/blog/2018/10/introducing-rust-crash-course).
Thanks for writing about this! I can't get over how weird it is (and cool!) when people write about the stuff you work on. Anyways, feel free to reach out of you have any problems or complaints.
&gt;The file included is based on where it's included from; if you do `mod bar;`in `foo.rs`, the included file will be `foo/bar.rs` This is an aspect I find confusing: what if I simply want to import `src/bar.rs` into `src/foo.rs`? &gt; `crate` refers to the root of the current crate What is my current crate? It's, like, the project I am working on? &amp;#x200B;
Maybe try adding a `#![warn(all)]`? Does that work?
I see, thanks. I think that's worth considering! Generally, I'm open for ideas so please create issues if you have any!
Man, this sets off my infosec tingly senses. I have noscript, but there is a real writeup there.
Hash is not injected, usually
Okay, that makes sense. I mean, you can just use the component storages without `World`, but that would mean you had to write your own execution logic (if you want parallelism). If you just want to run things sequentially, it'd just work.
Wouldn't it have to be in the source code? As far as I read in the README on github there is a way to configure a `clippy.toml` that is applied to the entire project, but it doesn't go deep into that
The new Rust website broke old links. Cool URLs don't change! When I search on Google for "install rust" the first result is "https://www.rust-lang.org/en-US/install.html". That link is now a 404 error. The new url is "https://www.rust-lang.org/tools/install". Google will eventually recrawl the page and get the correct urls but old links are broken.
Ah, great, thanks. It does make a lot of sense in hindsight, but I think the path clarity section in the edition guide needs to be, eh, clarified a bit to make it more obvious one of the two is required. 
If you want to include those, you do it in your top level module (main.rs or lib.rs, depending on whether you're making a binary or a library.) Your current crate is the package/project/whatever the code you're writing belongs to.
Yeah that would be, I haven't gotten my hands dirty with customizing Clippy so that'd just the one thing I can think of off the top of my head.
I've used Unity coroutines, which is actually what made me think of this; I just forgot to mention them. XD
Basically, the way I think about it is this: | Unique | Shared ----------+------------+--------- Immutable | Ok | Ok Mutable | Ok | Not ok Languages with immutability make things OK by controlling the horizontal axis. Rust's borrow checker makes things OK by controlling the vertical axis. So you end up with the same benefits of immutable-everywhere data, using a different model.
Will do. In this case, for such a big suggestion I wanted to work more with it to be sure it was worth considering. But it seemed relevant here.
&gt;...with the one caveat that SWT requires manual dispose calls in some situations, unlike other Java widget toolkits. Well, a Rust version wouldn't need to have that.
I'll be working on [tarpaulin](https://github.com/xd009642/tarpaulin), last week I made decent progress on OSX support, only issue now is my test binaries don't appear to have the `debug_info` section meaning I can't test if the update loop works. I've put something in the request for help but if anyone runs OSX and wants to help it would be appreciated. Also hope to merge a PR this week and just general bits and bobs. Also, kicking off my embedded rust efforts again adding in a bunch of clock support things to aid in serial and timer support. Once that's done filter it into my board specific crate and identify the next thing to tackle. 
1. Add this at beginning of a crate: #![warn( clippy::all, clippy::restriction, clippy::pedantic, clippy::nursery, clippy::cargo )] 2. Run clippy. 3. Remove this from beginning of a crate, because it's way too annoying. 4. Profit?
There's actually already a Rust idiom for this: fn main() { let data = { let mut data = Avg { count: 0, sum: 0 }; data.add(1); data.add(2); data.add(3); data } println!("{}", data.avg()); } The outer data binding is immutable.
SWT it is then. So someone just has to port this to Rust: [https://github.com/eclipse/eclipse.platform.swt/tree/master/bundles/org.eclipse.swt](https://github.com/eclipse/eclipse.platform.swt/tree/master/bundles/org.eclipse.swt)
You're right about the index plus one part, but I do need to pass the whole objects slice no matter what, because I need to check against the objects in the slice to see if it is a valid move. Even if I store the moves in another vector to apply later, it still doesn't work because I still need to pass the entire objects array for testing against.
The problem with `steal_borrow` is that it isn't panic safe. If your closure using the "stolen" borrow panics, it'd leave the borrow in an invalid state, which would be seen by destructors higher on the stack. It's safe to double panic, causing an abort, but then you're not as composable, since a bug means the entire process dies without a chance to clean up. And you do have a guarantee that a method doesn't mutate -- it takes `&amp;self`, the same as in your pipeline version where you say the guarantee exists. If you want further guarantees, you can do any mutable transforms with something like [tap](https://crates.io/crates/tap) on values you own and only use immutable bindings (though I guess functions taking mutable references still "suffer" from this limitation).
That's cool. Thanks for sharing.
Yep, and it's great for this example, but I don't think it will be so good for other cases
One of my favorite bits at 33m08s: &gt; There are a lot of options for Rust, _because_ of its interoperability as a core value. God bless that interoperability and performance as a core value, because it allows us to do with Rust what we did with C, which is to take an iterative approach. Start rewriting things in Rust. We don't have to rewrite the entire world in Rust. We can start rewriting parts in Rust.
FWIW, I asked Stefano about Rust support for Lambda a year ago, so besides having fun with this, I feel the need to give back :-) &amp;#x200B; I saw the App Mesh re:invent demo used managing the control plane over a Java &amp; Rust microservice as an example. With Lambda, Firecracker, etc., I'm getting the feeling that Rust is starting to be relevant for the AWS teams.
I am indeed! :)
_he's been found!_
For time, iirc chrono can do everything on wasm except get the current time.
&gt; How to configure clippy to be as annoying as possible? Oh, so it isn't by default? :D I thought it must be.
There some things that it allows as far as I know
Somehow I had completely missed this concept of rigid structure (`src/main.rs` or `src/lib.rs` as the *only* top level modules). I will re-read stuff again keeping this in mind thanks a bunch
Thank you! I appreciate the feedback :)
Not exactly a toturial but if you just have an Android phone or tablet, install Termux app then pkg upgrade, pkg install rust and code away for 15 hours. https://play.google.com/store/apps/details?id=com.termux
I believe so. I have traits working. Not sure what workspace symbols means, but I have a good experience with the setup so far as I said.
Well, to an extent, `0.1` is a warning by itself.
I'm already a fan. Can't wait for your next stream. Also, TIL about r/watchpeoplecode
I dont think we need named arguments. I think that we have enough sugar in Rust for 2019. I think I will write a 2019-roadmap blog-post to share my opinion further. Named arguments are nice obviously, but I'd rather use the builder-pattern, or other patterns that help with object configuration, instead of more sugar.
I wish it was a command line flag then. I don't want to modify my source code, but once in a while, when I feel particularly neat, I could run it and fix some pedantic stuff. 
Step π is to run `cargo clippy --all -- -D warnings` on CI, obviously. Give clippy the power to halt your merge!
You think builder-pattern is a good idea for workday-programming?? That's like competing in a racing car championship with a tricycle. You know, one of those: https://www.harborfreight.com/media/catalog/product/cache/1/image/9df78eab33525d08d6e5fb8d27136e95/i/m/image_21275.jpg?01AD=3FmDoBdV7FXwf_oRj3p0bHLh3c4WQRpUlAkryAqTcKcj2Lbz4P82nlw&amp;01RI=578FE5C7D7FB0A6&amp;01NA= I can't think of anything that would be a worse solution to the problem I want to solve.
Thanks for the link. I just tried to understand the examples and I mostly failed to do so. :-) What are delays? Is it the same as `thread::sleep` just for async? Also why do I still need tokio and the futures package? I thought this would be implemented into `std`? I read a blog post that some of the code of the futures crate is being included into `std` so that futures are available with "stock" Rust. Is that no longer the case? Why isn't this part of the nightly version of `std` ? Also why do I need tokio? And what exactly is the difference between tokio and futures? I might be dumber than most beginners, but Rust REALLY needs a chapter about async in the TRPL. Is there an estimate on when async will be finished?
Yes, I know what a tricycle is... But to talk about code, I just feel that Rust is such a syntax heavy language, we don't have the budget for it IMO. You could just have a single struct be the argument for a function: struct FooArgs { foo: i32, bar: f32, title: String } fn foo(args: FooArgs) { ... } This has the benefit that you get named arguments, in any position! Also, if you already have placeholders with the names you can just do this: let title = "baaa".into(); let foo = 12; let bar = 3.14158; foo(FooArgs {foo, bar, title});
Not sure about vscode. But I’ve had decent but not perfect code completion in vim and spacemacs. It’s not perfect yet and struggles looking inside generics and turbofish but it’s improving slowly and steadily. 
Please file a bug!
It's easier to do in the wrong way than the correct way. The proposal with ownership, makes explicit and easier the good way.
The book shipped with 1.31 has a completely revised chapter that covers all of this.
To be clear, those are the defaults; you can change them if you’d like. There’s generally not a reason to, though.
The implementation it's an awful trick. I wish it could be done in a more elegant way. Is it possible? What about the idea?
That's not the problem I need to solve. Structs are memory aligned. The problem I have is to pass many function arguments, some might have similar types, while making sure I did call the function correctly. What I mean about workday-programming is when you need to be effective and avoid mistakes for longer amounts of time. The builder-pattern is a design-abstraction. I don't think that you and I agree on what the problem is.
Do you have an example of another case where this solution is not so good and your solution is better? If this is not a great example it's not really a great way of showing of your feature. I fully understand that you picked a simple example to show of the feature, but for this feature I think you need to show where this will actually be valuable.
&gt; The tools thing that I'll take a moment to advocate for is an official way to do post-build scripting. It's had an open issue for it since before Rust 1.0 was released. These days you can kinda fake it with the cargo-make plugin, but that only works if your own crate is commanding the build cycle. Once you get used as a dependency, or if someone installs your program through cargo install cratename, then it won't happen and you're sunk. Could you help me better understand this. What are the use cases you are trying to resolve with post-build scripts? Why do we need transitive post-build scripts? &gt; Once you get used as a dependency, or if someone installs your program through cargo install cratename, then it won't happen and you're sunk. Personally, I view `cargo-install` as a convenient hack and not something that should we expanded to handle any software distribution need. There was some discussion on [cargo-install](https://github.com/rust-lang-nursery/cli-wg/issues/20) within the WG-CLI. We also want to look into [packaging](https://github.com/rust-lang-nursery/cli-wg/issues/8)
Don't write functions having more than 3 arguments. How bow dah?
I dont know how named arguments can verify that a function is being called correctly, they simply allow you to call them in any position, and make sure you know which is which. The alternative is something like: let value = function_caller() .foo(12) .bar(3.14157) .title("blarp".into()) .call(); this requires no new syntax, and can ensure that all arguments are properly handled, with names.
It's Rust's proposal and it's a very good improvement. Reducing mutability, even when not shared between "functions" makes the code more readable. A mutable variable in a multi-line scope is shared on those lines (it is still a kind of sharing).
I have a language recommendation for you: Untyped lambda calculus. It supports only one argument, with no function names. Simple to implement. It's Turing complete! Why don't everyone write programs in untyped lambda calculus? Just kidding, but I though you were kidding, so...
Good point. If we use "methods" receiving &amp;mut generally, people will declare variables as mut very often. We will lost control on mutable and inmutable methods (they look equal). And it will be easier to do in the wrong way. I'm a bad programmer and I would like to let the type-system and the compiler to help with these problems. 
`warn` not `deny`?!
I don't believe you have thought about this carefully yet. Here is the proof that named arguments can verify a function being called correctly: ``` fn foo(b, a); foo(a, b); // I know what `a` and `b` are, but I don't know what they map to. foo(b: a, a: b); // This looks wrong. ```
It will annoying whatever you use, but if you want to be extra annoying, use `forbid` instead which is like `deny`, but you cannot `allow` as an easy way out :).
Any idea when we're going to get async syntax support?
Warn by default and deny on CI. Keeps your project clean without running it for the users when new lints appear.
You can't pass the whole slice while iterating. The obvious choice would be to iterate with indices (`for i in 0..objects_slice.len()`). I hate that, since it's always error-prone and ugly. Maybe there is some other solution, but I don't see it right now.
&gt; they simply allow you to call them in any position, and make sure you know which is which I mean, thats a pretty light guarantee, and my example provides the _exact_ same guarantee, without extra syntax added to Rust. Why do we need named arguments when we have builder pattern, or struct-based arguments? Also, of course I have not carefully thought about this. I am just giving you my opinion, and you have probably cultivated arguments for this feature in your head long before you wrote this tweet. I am at a complete loss preparedness wise. That is why it is expected that you provide a good argument for your opinion. I find your argument wanting.
Oh wow, I didn't even think of that. I feel embarrassed now :P
[My Tetris Clone, got a start menu working](https://github.com/camccar/RustTetris)
I don't think my proposal is better than any other option. I'm thinking about it and I want opinions. Let me focus on the idea that I want make difficult to use in a wrong way an API. What you propose is great, but it's easier to do in the wrong way than in the good way (IMHO) With ownership, we can reduce the use of mutability (that's looks good to me) and we expose an API making explicit when and where things are modified. With ownership you cannot mix mutability by accident.
Can you just get rid of the iterator and loop through the indices? You're already indexing into objects in move_by so the iterator isn't really doing anything for you. That's how the tutorial you referenced does it. 
Yeah someone else commented the same thing earlier and I'm kicking myself for not trying it :) I'll try when I get home. 
We need named arguments because the builder patterns locks up the code in a different way. For every function with named arguments, you need to add a struct. This is just horribly slow. In theory it works, but in practice it only works for an edge case, where variables can be put together in a way that does not cause problems with the borrow checker. The whole reason I want named arguments is to make workday-programming better, not making it *worse*. I need a solution, not a regression. I've used the builder pattern in library design, I already know very well what it is. I don't have to be convinced that it's a solution to this problem, because I'm already using the builder pattern and struct-based arguments when I can, but it's not enough.
Playing around with some ideas for DSP audio in Rust. Long term I'm hoping to create something akin to the SuperCollider audio server, but written Rust. Short term I'd settle for a beep...
You are amazing. If you have ever heard about the 10x rockstar engineer, here is one.
What happened to the official faq? I can't find it on the new site and the link in the sidebar under "Learn" is broken...
Seems like a combination of permute/splat, maybe? Surely this is right up your alley wrt SIMD intrinsics?
Yeah this question is absolutely related to that! 
Support for `?` on `Option` has been available in stable for quite some time by way of the `Try` trait.
FAQ before you downvote: - Yes, I have used the builder-pattern and struct-arguments many times - No, named arguments is not the same - No, you don't have to convince me it's the same - Yes, I created Dyon (so?) - Yes, I don't care what you think is good language design from very general principles, my opinion of language is what I think works best in practice - No, an argument from the existence of a solution is not a solution to a language design problem - Yes, I believe you have to think about this carefully - Yes, there are trade-offs, but that's between variadic functions and default values, not between design patterns and named arguments - Yes, now you can downvote
I once did a [Java / Rust](https://llogiq.github.io/2016/02/28/java-rust.html) comparison that ended up being plagiarized.
Is this functionality that was missing from rayon? I'm not overly familiar with rayon but I thought this was what it was supposed to allow. Can you offer some insight into how this is different?
For example https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b826767a7dc3427fbf784de694c5a55e
What if we allowed for type elision when defining struct instances? Like this: struct Foo { a: i32, b: bool, } bar(_ { a: 42, b: true, }); &amp;#x200B;
Haha, thanks y'all! You're all too kind ^^
I'm playing around with trait objects using the following code. ``` struct FooStruct; trait T1 {} impl T1 for FooStruct {} fn foo(_f: Box&lt;dyn T1&gt;) {} fn main() { let fs = FooStruct; foo(Box::new(fs)); } ``` Running `cargo clippy` gives me ``` warning: this argument is passed by value, but not consumed in the function body --&gt; src/main.rs:8:12 | 8 | fn foo(_f: Box&lt;dyn T1&gt;) {} | ^^^^^^^^^^^ help: consider taking a reference instead: `&amp;Box&lt;dyn T1&gt;` | = note: #[warn(clippy::needless_pass_by_value)] on by default = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#needless_pass_by_value ``` So I tried replacing `Box&lt;dyn T1&gt;` in `foo` with `&amp;Box&lt;dyn T1&gt;` and replacing `foo(Box::new(fs));` with `foo(&amp;Box::new(fs));`. Now my code won't even compile and instead issues out this error. ``` error[E0308]: mismatched types --&gt; src/main.rs:9:9 | 9 | foo(&amp;Box::new(fs)); | ^^^^^^^^^^^^^ expected trait T1, found struct `FooStruct` | = note: expected type `&amp;std::boxed::Box&lt;(dyn T1 + 'static)&gt;` found type `&amp;std::boxed::Box&lt;FooStruct&gt;` ``` Could someone explain to me what's going on here? Are references to trait objects possible? 
This doesn't solve the problem, because you still have to add a struct and it's memory aligned. You would have to add one struct for each case, which is a regression, not a solution to anything.
IIRC `rayon` does not provide similar functionality, it can either provide ordered output via storing results in memory, or unordered "when ready" output. But I am not `rayon` expert, so I can be wrong here.
What's the issue with it being pointer aligned?
Note that in Rust `?` inserts returns from the function rather than propagating the null, so to get the same behavior as in Swift you'll need to wrap your accessor in a closure: `if let Some(foo) = (|| bar.baz?.quux?.get()?.value)() {...}` &amp;#x200B; [Playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ec8b02f64a35c2cf80b8de8c329c07b4)
To make it _really_ annoying, don't change your source at all but add a build to travis that does `cargo clippy --all -- -W clippy::all -W clippy::pedantic -W clippy::restriction -W clippy::nursery -D warnings`
No, not that kind of memory alignment. It chunks together the variables in memory on the stack. a b f(a, b) b a f(a, b) // A struct would have to push `a, b` to the stack here. 
Nothing exceptional though
Okay I see the difference now. Thanks for the explanation. 
[https://godbolt.org/z/7qZB6V](https://godbolt.org/z/7qZB6V) LLVM is able to move struct fields into registers.
The key thing that’s missing is being able to cross-use both in one function; you can only use it for option when your function returns option, and result when you return result. When Try stabilizes, so will NoneError.
Or with a try! block, or whatever it’s currently called. It’s gated too.
Possibly similar to [polyester](https://github.com/QuietMisdreavus/polyester)?
Where should I file it? The rust-lang/book repo?
Yes please!
So, you're saying that the good language design is what you think is best?
Futures are indeed going to be in the stdlib (they are in nightly versions of Rust). A Future is just a way of expressing the notion that some value will eventually be given back, but isn't necessarily ready to be just yet. Futures are pull-based, meaning that in order for something to get the value out from a Future, it needs to ask whether it has a value yet (by *polling* it). But the Future might not have a value yet. We don't just want to keep asking it in a loop though. Instead, when you ask the Future for a value, if it can't hand one back it'll arrange to let the asker know when it might have one ready. Until then, the asker can get on with trying other Futures and such. Tokio makes use of this notion of Futures (and Streams and Sinks) to represent things like reading and writing to network streams. Tokio provides a bunch of primitive things that can be read from or written to in a non blocking way. These things can be wrapped up behind Futures (or Sinks or Streams). Tokio also provides a runtime which knows what to do when these methods say that they don't have a value yet (which is why you can't call these methods outside of a Future that's been handed to Tokio to try and run to completion; without Tokio there, the Future wouldn't know who to tell to try again when a value might be ready). Async/await is essentially syntax sugar that works with stdlib Futures under the hood, and allows us to work with them as if they were normal synchronous blocking things that return a value right away. But! the Futures trait used in Tokio and much of the ecosystem is different (older) than the Futures trait that is in the stdlib. This is the trait defined in the futures package. Thus, we still need that package for the time being for these other libraries to lean on, until everything upgrades to stdlib Futures. This might not happen until they make it to stable Rust, which I gather might be a couple of releases away (potentially landing in Feb next yearish I recall reading!). Until then, things like Tokio provide a feature flag to enable async/await support, which just means it provides some functions which use stdlib Futures so that we can use async/await syntax with them. It turns out it's easy to wrap a thing implementing an "old" Future to look like a thing implementing a stdlib Future, and vice versa, so actually we can play with aysnc/await now, using the current ecosystem (this is the subject of the blog post I linked :)). So, to sum it up, a Future represents a way of getting a value that might not be ready yet. Tokio makes use of Futures to represent values from a network or file (for example) that may not be available yet. Tokio knows how to run these specific Futures, as they tell it when they might be ready and then it can try again. Async/await uses the new stdlib Futures, but much of the ecosystem uses the old futures crate. Bit of a ramble, sorry! I hope that helps! :)
Given that a huge proportion of the published crates is at 0.1, some of them quite mature, this isn’t much of a warning unfortunately.
do you have some recommendations for a good profiler? Valgrind doesn't seem to be maintained anymore and the latest from Github does not even build for me. OProfile doesn't seem to be good enough as when it runs on my program it quits with segmentation fault... so...do we have some actively maintained and stable enough profiler for rust programs? Thanks!
It's worth noting that some things you _might_ expect to be in the standard library, like regex and random, are instead in crates. You may want to download some of those in advance. Last time I had a long flight, I ran a local package server, and cloned in some of the most popular crates on crates.io.
&gt; FWIW, I asked Stefano about Rust support for Lambda a year ago, so besides having fun with this, I feel the need to give back :-) I was also referring to the Alexa bit! That's my full-time job. &gt; I saw the App Mesh re:invent demo used managing the control plane over a Java &amp; Rust microservice as an example. With Lambda, Firecracker, etc., I'm getting the feeling that Rust is starting to be relevant for the AWS teams. Fingers crossed! It'd make my job _way_ easier. Also, I didn't see that demo! Is it up anywhere? (I didn't attend Re:Invent this year...) 
I dont like anonymous naming like this. I feel like it goes against Rust's explicitness, and a programmer reading code like this would be confused, and would have a very hard time trying to find the struct in question.
I actually agree, was just suggesting things to u/long_void
I use perf and use this[0] to generate pretty flame graphs. [0] http://www.brendangregg.com/perf.html#FlameGraphs
Your callback takes `&amp;self`, which won't work, because Windows doesn't pass it in. You'll need to make it not take `self`, and if you really need the value, you'll have to store it in a global somewhere.
Ah. Is there literally no way to accomplish this using the self? &amp;#x200B; And I don't get the reddit formatting right.... :(
I just have not seen a convincing argument, for why we _need_ to add this syntax. We have gone years without it, and I feel that Rust API design is fairly robust.
There isn't. The caller needs to provide the value for `&amp;self`, and Windows won't do it for you.
Does "The Book" state this? It states "[The ?](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#the--operator-can-only-be-used-in-functions-that-return-result) [ Operator Can Only Be Used in Functions That Return Result](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#the--operator-can-only-be-used-in-functions-that-return-result) The ? operator can only be used in functions that have a return type of Result, because it is defined to work in the same way as the match expression we defined in Listing 9-6. " Is this a docu bug or did I miss the documentation somewhere?
Thanks!
Some embedded projects have things like custom elf sections with certain meta info that have to be added. The PS2 is a good example of this and although the ISA is an LLVM backend the elf sections need to be patched into the binary https://rust-console.github.io/ps2-bios-book/md/2_2_iop_boot.html 
I'm really fond of Android's approach to layout. They have an enum MeasureMode that is passed down from parent to children for each dimension. The whole system is also well documented and less hand-waively than other toolkits. IMO there are three noteworthy layouts: flexbox, ConstraintLayout (cassowary) and CSS Grid layout. With just those three you can very easily build UIs; constraints being most powerful while flexbox has good performance. I also suggest you check out the source of Facebook's Yoga, which is based on flexbox.
Reddit formatting is as simple as pre-pending 4 spaces before each line. If you are using Reddit Enhancement Suite there is a handy little button (looks like `&lt;&gt;`) that will take all of your unformatted code, and add the 4 spaces to each line.
I asked because I wasn't able to find such a repo among the Rust-lang repos, I eventually found it in the nursery. I'm not sure if I should open another issue requesting a link to the repository in the introduction of the guide or something similar, I think something like that would make it much easier to ask for these kinds of clarifications. 
It's not about API design, but about workday-programming. API design is not the most important things about workday-programming, but about being effective and not making mistakes. These things costs time and money. Think of it as a working tool: If the tool is not the right for the job, you swap it for something else. The tool needs to have the right scale and give the right force at the right moments. If you put a race car engine on a tricycle, it will put 70% of the forces on a single wheel in turns, which will make it unstable, and when you loose control it is harder to gain it back. There is simply no way to "upgrade" a tricycle into a racing car. You are arguing "but, this hammer is just fine!" when the problem is not about hammering in stuff, but screwing things.
&gt; Valgrind doesn't seem to be maintained anymore and the latest from Github does not even build for me. [Valgrind isn't hosted on github.](https://sourceware.org/git/?p=valgrind.git) But if you need it you should be using the [release binary](http://www.valgrind.org/downloads/current.html), no need to build it yourself. 
Yes, but structs is still not a good enough solution. You would still have to add one struct for each case.
Each case? Are you adding optional arguments as well?
No, I said my opinion of language design is what I think works best in practice. I think language design must make trade-offs, but these tradeoffs should be based on what works in practice. I did not make any claims about good or optimal language design in general relative to my own opinions. It might very well exist some magical algorithm that outputs the optimal solution that performs better than my opinion. However, I said that my opinion is based on what I think works best in practice, not by general language principles.
Youre using a lot of metaphors but not actually explaining what is wrong with my argument. When using metaphors you need to relate back to real life, not just use more metaphors. Please, use concrete examples. Your first sentence does not make a lot of sense, sorry. Are you saying that workday-programming is about being effective and not making mistakes? Well... that is also the whole point of API design. To ensure that users understand what they are writing, and don't use it incorrectly. I just do not see how my 2 examples from above are sufficiently different to warrant having both in the language. If you are concerned about boilerplate, I am sure that a macro could be made similar to that `rust-derive-builder` crate.
I think he is saying that for each function with named-parameter arguments, it requires its own argument-struct. I think that you could easily make a macro that creates that for you, there is no need to re-do boilerplate over and over for something like this.
There doesn't seem to be a huge benefit that I can see at a first glance. From the point of view of a library user it would still require looking up the argument names. I propose rather that we add support for describing parameters like with @ in Java and then hover over it to get a definition. However, I must agree if a function takes many function, the arguments might be as well a struct since most of the time arguments belong together.
Ah, that makes sense. Yeah, I don't really see an issue with that. Presumably, you should only do this in an user-facing api for your crate, so it likely won't be a huge number of argument structs.
The problem with your argument that you're not thinking about the problem. You are thinking about a *different* problem. It is not very hard to understand, once you try: 1. Named arguments makes it possible see whether variables map correctly to the arguments 2. It takes shorter time to use named arguments than builder-pattern or struct-arguments 3. (1) and (2) implies that you get more effective and make less mistakes within the same time span There is nothing wrong with your argument, except that it's completely irrelevant. It only holds for an edge case where there is some overlap in use cases.
Soon - [https://github.com/intellij-rust/intellij-rust/pull/3106](https://github.com/intellij-rust/intellij-rust/pull/3106)
oh sorry my bad, i actually meant cargo-profiler... i am reading the book, "rust high performance", which suggests using cargo-profiler to invoke valgrind, and cargo-profiler from https://github.com/kernelmachine/cargo-profiler cannot be installed correctly and it doesn't seem to be maintained actively. again my bad for the confusion! i will update my questions.
Structs are not a solution, because it requires adding a struct for every use case. 1. Named arguments makes programming easier when you need to be effective and avoid mistakes 2. You don't know upfront in this use case what's the best way to organize structs
color me moist.
I don't like named arguments and here's why: I've usually seen them mixed in with ordered, un-named arguments, and to me, this is mixing two things that should not be compatible: ordered tuples, and hashes/dictionaries/structs. The other thing that the builder-pattern supports that named arguments (potentially) do not is optional arguments (and it also supports default values). As an aside-opinion: I think a good middle-ground to this discussion would be anonymous/inferred types (kind of like TypeScript supports) for function arguments.
&gt;What are the use cases you are trying to resolve with post-build scripts? You need a post build step whenever you need to do something with/to the binary and before testing or installation/deployment. Use cases were covered in the [rejected RFC](https://github.com/rust-lang/rfcs/pull/1777) and in the issue linked by OP. The biggest issue with post-build scripts is whether you allow them to run on upstream dependencies, when the majority of their use cases are for the final target (bundling the binary, packaging it in a directory or with additional metadata, stripping symbols, verifying its size, etc). The resistance seems to be "cargo isn't a general purpose build system." But if that's true then I have no idea what Cargo is supposed to be. 
thank you for the reply! i will give perf a try.
I'm playing with actix for a project, and I was wondering how to distribute actix actors across many threads (although I probably could get away with only one thread). As I understand, an Arbiter = an event-loop in one thread, but is there a way to have like a work stealing mailbox spreading work equally across all actors in arbiters? I haven't found a way to automatically do that in the actix crate, or in an other crate, so I'm thinking of implementing a "gateway" actor that would spread messages. I would like to know if people have already solved this problem?
&gt;What are the use cases you are trying to resolve with post-build scripts? So, I'm not /u/Lokathor, but I have a ~~probably masochistic~~ project of reimplementing the boot system of the PlayStation 2. To be ran as a BIOS, the ELF must be packed with a bootloader (and the bootloader itself must be converted into a binary blob instead of an ELF) into a ROM file, and then this ROM must be indexed so that it can look up parts of itself. This is something that must be done after the file is built, for hopefully obvious reasons. Philipp Oppermann, author of the [Writing an OS in Rust](https://os.phil-opp.com/) blog, has a tool called [`bootimage`](https://github.com/rust-osdev/bootimage) to accomplish this post-build step, but this isn't portable for me, and it's not portable for /u/Lokathor, who needs to turn the Rust ELF files into `.gba` binary blobs. Of course, each of us could write our own tool for this, but it would quickly descend into [xkcd levels of duplication](https://xkcd.com/927/). &gt;Why do we need transitive post-build scripts? Here's another example from my BIOS. A small CPU in the PlayStation 2 is dedicated to servicing input/output requests (such as "play some music from the DVD") to maximise use of the main CPU. The PlayStation 2 has a lot of forms of I/O, but not every game will need all of them (a single player game doesn't care about networking support), so that kernel is modular in design, with these modules being loadable or unloadable as necessary. The format for these modules is called IRX (Input/output processor Relocatable eXecutable), and these modules do share common metadata. Common metadata sounds like a use for a library crate, doesn't it? And then while we're here, we could also add build scripts so that each module doesn't need to duplicate the process of being turned into an IRX. Except we can't, because the IRX crate is a transitive dependency, and thus has no way to influence the final build at present.
 &gt; Named arguments makes it possible see whether variables map correctly to the arguments Builder pattern does that too. &gt; It takes shorter time to use named arguments than builder-pattern or struct-arguments .a(a) vs a=a, its literally one more character to do it with builder-pattern style. Of course add a `.call()` which is a constant factor. Even then, Rust code is not meant to be a language that you write as fast as possible. It is a language where you should not be impeded, yes, but that does not mean we need to cut corners and add syntactic sugar until we get diabetes of the semi-colon. Also you keep saying that its a different problem, but have no explained at all how it is a different problem. Your argument for named parameters are that they are for parameter correctness and ease-of-use. My argument is the same, builder pattern is to ensure conditions of parameters, and do it concisely. Where do they differ? I argue that builder-pattern is a complete superset of named-arguments. With BP you can inject parameter-checking code in the functions, and enforce things like argument order, mutually-exclusive arguments, and much more.
What I wanted to say, is that Rust reduces the shared mutability, but not avoids it completely. My thought is on this way, to reduce sharing mutability as much as possible and make difficult to use an API using too much mutability
BTW, as an aside, I see that you wrote Dyon. It looks like an awesome project! I have been dabbling in Programming Language design, and I have to tip my hat to you.
Ahhhh that was beautiful. Thank you so much. I read all Rust/async posts/articles on the first 2-3 pages of the google search and it is really hard to get a clear answer on what exactly the situation with Rust, async/await, futures and tokio (and sometimes also mio) is. I don't need any actual code I just want to understand what library does what, and how it is going to work in the end. I'm now much closer to understanding this thanks to your exhaustive answer. So it is very much appreciated. I just have one final question: I'm looking into async/await because I want to use it for async-ing my GTK/gtk-rs GUI. Currently there are a few work-arounds, but they are pretty hacky and I was hoping that this is where async/await/futures might come in handy. However what I didn't understand is this: &gt;Yup; the delays are just the "async" version of thread::sleep. They don't block the thread, just that one Future (so other Futures can make progress in the meantime on the same thread). So even futures can still "stopped" if the thread is blocked by some other function? Meaning if I replaced the delay with a standard `thread::sleep` my function would still block even when using futures? That sounds very counter-intuitive. Or in other words: Will async/await allow me to async my GUI. For example: I press a button, which runs a function that checks for IMAP messages and it will take about 3 seconds to finish. The way I do it now: My GUI will be unresponsive for the entire 3 seconds. GTK unfortunately isn't thread-safe. Will async/await enable me to async my GTK GUI? Can you even answer that question? Thanks so much once again!
`cargo clippy -- -D clippy::correctness -D clippy::complexity -D clippy::pedantic -D clippy::nursery -D clippy::perf -D clippy::cargo -D clippy::restriction`
A macro does not solve the problem, because it introduces extra complexity and refactoring issues. I just want to call a function with named arguments. That's all. Other languages has it, so why not Rust? I got named-arguments in Dyon and I love it! You try to turn a very simple idea into an extremely complex one that doesn't even address the original problem. Then, you claim that there is no difference between that complex, irrelevant solution and a very obvious one: Named argument syntax. It does not convince me that there exists some solution in principle, when it doesn't address the core of the problem: Being efficient and avoiding mistakes for long amounts of time. Imagine a language where somebody removed "if" and replaced it with "goto" statements or something equally horrible. Then, defending "goto" statements because it would add complexity to the language by adding "if". This is how ridiculous it seems to me. It doesn't matter whether you think it's a good idea, it just *obvious* to me that "goto" is much harder and less efficient when *working* than "if".
&gt; cargo clippy -- -D clippy::correctness -D clippy::complexity -D clippy::pedantic -D clippy::nursery -D clippy::perf -D clippy::cargo -D clippy::restriction Thank you!
Doesn't pedantic already cover everything? Thats what it says it is
The other key thing that's missing is the documentation :-)
This is super cool! How hard would it be to implement warm support?
Yes, I don't like mixing named arguments with un-named ones either. One trade-off one could make, is to require named arguments for a function. You either have named arguments or you don't per function.
Pretty late on this but I just want to +1 the stable ABI point. It would make so many things so much easier/better.
I honestly have no idea having never worked with wasm. I'm guessing the ptrace api will have to be replaced with something else entirely. And if the bytecode is interpreted it just might not be possible. Once OSX support is in things will be tidied up in a way that should make cross platform support easier to add so if someone was interested they could take my [developer wiki](https://github.com/xd009642/tarpaulin/wiki/Developers) and try to figure it out. I always welcome new contributors :) I'll probably personally aim for windows next just to get the big 3. 
Now that I could get behind. I think in some cases it's nice to have unnamed arguments: `Math.max(1, 2)` is clear without the names. But the functions that take a gazillion parameters could benefit from named arguments. However, I still wouldn't take it unless default arguments were also supported, as an added convenience.
Go try Dyon for a week, if you got time. Experiment with named argument syntax and then it might become completely clear, everything I told you.
til of my new Christmas tradition
No. Restrictions lints are restricting things that aren't necessarily bad, but sometimes you may want to avoid those. For example, `float_arithmetic` warns about usage of floating point numbers - use of those is usually fine, but for example in kernel code it can be problematic when unexpected as it complicates context switches. Nursery lints are new experimental lints that aren't ready to be stable. Cargo lints aren't about Rust code, but rather about Cargo.toml file.
Good catch. If you end up opening an issue, please post it back here as I would like to follow the discussion.
I think it's possible even to use Dyon's trick of underscore with default values. Wait... Why not add default values to Dyon? You just gave me a new idea.
I think comparing Rust to a scripting language feature-wise is not wise, even when the scripting language bares a vague resemblance to Rust. I use named arguments all the time in Python (which is my #2 language at work), I love them too! I just dont see them fitting in with Rust. I see you conflating 2 different parts of an argument. You say that using macros introduces complexity and refactoring issues. That is a problem for the implementor. However, your statement of want: &gt; I just want to call a function with named arguments. That's all. That is the callers problem. And the BP is an _exceedingly_ simple thing to use. Of course its more work for the implementer! Injecting it directly in the language will obviously make it easier for everyone. Maybe I just am fine with making it a little harder for an implementer, for the sake of keeping the language a little bit simpler.
Enticing! Will definitely take a look! Thank you for your work so far!
I didn't downvote you for your ideas, but for your conduct. Please try to be kind.
Sorry, I am not a huge fan of Dyon. I dont like a hodgepodge of syntactic sugar features, with that much noise. I like named-arguments. I use features like named/default/variadic functions as much as I feel right to in Python (quite a bit for me!). I just dont like them in Rust.
I was introduced to Bryan Cantril earlier this year (probably by his first rust talk), and he has fast become one of my favourite speakers. I am looking forward to watching this.
Help with the [structural records RFC](https://github.com/rust-lang/rfcs/pull/2584), i think that is the closest thing you can get in the near term. 
I keep seeing an argument against structs because they are memory aligned. Can someone explain to me how named arguments would not be memory aligned? They still need to be pushed into the stack in a well defined order so the called function can generate addresses for them.
Wouldn't there be greater value added if you could trivially open the source code of the called function within the same window of an IDE and nest it near of code that's calling it? I feel like named arguments primarily serve as a code comprehension sugar and that something similar to the mentality of Pharo's IDE would better meet the needs of the Rust community. I'd highly recommend watching this video about Pharo's ecosystem: https://www.youtube.com/watch?v=baxtyeFVn3w
Then why does the `clippy` [readme](https://github.com/rust-lang/rust-clippy/) say `pedantic` covers everything? ..for that matter, where is restriction coming from? It's not listed anywhere?
I avoided understanding that myself. I think that he means that putting the args into a struct necessitates an extra allocation. However, that is not true, the allocation can be trivially inlined. I may be wrong though, idk what he means.
&gt; "Let the Wookie win" is my advice when dealing with Rust. I cannot agree with this more. From what I've observed, the people who struggle the most with Rust are those who have an idea of how to write something and refuse to adapt.
https://www.rust-lang.org I hear they have a book out
Looks like a bug with the book, I suggest [making an issue](https://github.com/rust-lang/book) or even a pull request to fix it.
Have you taken a look at https://exercism.io/tracks/rust ? I’m sure you gonna like it!
Sounds like a bug with the book to me, I suggest [making an issue](https://github.com/rust-lang/book/blob/master/CONTRIBUTING.md) or even a pull request to fix it.
I finished working on my programming language [tox](github.com/lapz/tox). So far it mostly works but certain things need some work, I might add generics and either a llvm backend or write my own backend. I've also started to learn some SQL so I can use it in a rocket project.
I don't agree with you that named args are a simple feature. If a function has named args, do you allow unnamed args in the function signature? If so, when calling the function do you need to specify all the named args before or after all the unnamed args? Does that mean two identical function signatures with the only difference being one has named arguments and the other does not should have different types? etc etc...
Will check it out thanks
If this is the only reason you have, why don't you simply use an IDE or editor that shows you the function declaration when you are typing it (even Vim will do this with RLS)? Or do you actually have any other reasons to want named arguments? Personally I don't miss them at all..
The lint is totally irrelevant in your scenario and led you into the completely wrong direction! You are just prototyping/playing around. Clippy merely warns that the function `foo` takes a parameter by move but does not make use of the ownership, but it actually does: It drops it. I actually cannot reproduce the warning, neither on stable nor on nightly (playground) nor by explictly adding the attribute. What's your setup? A type like `&amp;Box&lt;dyn T1&gt;` does not make sense because of deref coersion and thus is not used in practice unlike `&amp;dyn T1`. To make the error in your last snippet go away, you need to help the compiler a little bit using `as`: `foo(&amp;(Box::new() as _))`. By itself, it cannot figure out that the struct should be interpreted as a trait object.
That’s true, I thought we did that. Can you file a bug against the book please?
Add a `reject` option, where it just reverts the change in git. :D
No, I did not compare Rust to a scripting language. Sigh. I want to write functions with named arguments and call them. Happy? I don't care much about how hard it is to implement. I think there is a trade-off one has to make. However, I believe named argument syntax is at the top of the list that I would see implemented in Rust.
It might be possible to do it, but it'll need a lot of love - the problem space is huge. Here's my brief(-ish, ha ha) overview of the issuehttp://github.com/samsieber/rubber-duck/blob/master/REVIEW.md
If you do that, your brain will melt after several hours of attempting a successful compilation.
At the bottom of the Rust 2018 blog post there's an explanation of how you can rename crates now: https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html
You can use the `package` key to rename one of the two: [dependencies] md5 = "0.6" other-md5 = { version = "0.8", package = "md-5" } And then transparently import both at the same time: use md5::compute; use other_md5::Md5;
Yes, there are many choices in how to implement this. I think of it as a simple feature from a user point perspective: It not so important in terms of semantics, but it is important for productivity when you need to be efficient and make few mistakes, in my opinion.
I think a language should be easy to use with and without an IDE. Thanks for the link!
Wrapping up the CHIP8 emulator I'm writing as a learning project, and playing around a bit with the ggez game engine. 
If LLVM optimizes it away, then I don't consider this as an issue any longer. I'm still not convinced adding structs is better.
Do we have something for try already in the complier?
If LLVM optimizes it away, then that issue is not important. It doesn't change the issue with needing to adding structs.
Either with the `package` keyword [mentioned by gourlaysama](https://www.reddit.com/r/rust/comments/a50yp3/using_two_different_crates_with_the_same_module/ebj1bkd) or use `extern crate md5 as other_md5` if you are on an older compiler. The former is more idiomatic.
There are other use cases, but it depends on how named argument syntax is implemented. However, if I need to move the mouse and hover, instead of see at a glance what the argument does, then it's not the same, even it's less of an issue with good enough tools. Let's say that for some reason Rust picks a very bad implementation. I would then probably be against it, because details matter.
https://doc.rust-lang.org/book/
Thanks for the writeup!
`fe` is a program to facilitate tracking command line usage to more easily and accurately track your most used directories (and maybe files in the near future). Used in conjunction with `fzf`, it becomes a powerful tool for quickly navigating between directories. I wrote this to scratch an itch of mine, and thought I'd clean it up and share. Any feedback is appreciated. 
I don't think the semantic ambiguities would lead few mistakes. As a user of named args, I need to remember all the semantics mentioned above. I need to remember in what order the arguments are evaluated. I can only imagine the debugging hell of trying to track down a bug caused by named arguments being evaluated in a different order than I had reasoned while writing the code.
Really cool looking tool 
/u/QuietMisdreavus also wrote rayon's [`par_bridge`](https://docs.rs/rayon/1.0.3/rayon/iter/trait.ParallelBridge.html#tymethod.par_bridge), which mostly obsoletes polyester.
did you do it? I'd like to use it, if so
Thank you very much! It's better than what I was looking for!
Thank you very much!
Thank you very much!
You're right, `rayon` doesn't have anything like this sequential `report` callback -- pretty cool! I might have to think about how we could do something similar... :) We've had requests for a `ParallelIterator` to `Iterator` adaptor, and I could see ordering as an optional feature (not always needed). Part of the challenge for us is how to make it compose well with the rest of the API and threadpool. I don't think we'd want to spin up a dedicated receiver thread like you have, for instance.
Done! [https://github.com/rust-lang/book/issues/1679](https://github.com/rust-lang/book/issues/1679)
I like languages that are nice to use. Dyon is the nicest scripting language I know. It just happens that I made it myself. I am biased, but it doesn't matter to me whether you like it or not. :D I understand you want builder-patterns and struct-arguments. However, are you against any form of named-arguments in Rust, or just specific implementations?
I tried to explain the gap between how /u/Sinistersnare look at the problem and what I think as the problem as competing in a race car championship using a tricycle. Since I'm not a native english speaker, I thought there was a chance he could misunderstand and think of something else, so I posted a link to a picture where I confirmed that I really meant the slowest kind of tricycle. Did you think it was unkind? Yeah, I think was unkind too, now I think of it. I deserve those downvotes. What I meant was a solution to a problem that doesn't address the original problem at all, but is so much worse and slower that I think it is obvious that /u/Sinistersnare doesn't understand what I am talking about.
Wish list to Santa Claus : - unit tests - configurable prefix for thread's name - ideally a thread pool (I don't think this is possible with crossbeam) Nitpick possibly wrong. I'm not entirely sure what the borrow checker will tell you, but I think you can remove an unwrap, using binary heap's PeekMut.
Thanks to you and /u/Holy_City and /u/xd009642 for the use cases. I guess my next question is what is the value-add of having this built-in to `cargo build` rather than a generic or multiple specific "final artifact" subcommands? 
Named argument syntax is the reason why I consider my python code more safe than my rust code. rust: do_stuff(name, age, id, ls, inc, rev, hours) vs python: do_stuff( name=name, age=age, person_id=id, life_span=ls, income=inc, revision=rev, hours_in_prog=hours ) which one is easier to understand + try changing an argument (using the same type) and see which code breaks.
While I don't know what shape it takes, I have to say I'm very in favor of this. I find in Python that named arguments are preferable in all but the most trivial cases (such as `def max(a, b)`); so much so that virtually all of my functions use the required-kwargs syntax (`def function(*, arg1, arg2)`)
 fn main() { let x = 5.0; let y = 2.0; let result: Option&lt;f64&gt; = if y != 0.0 { Some(x / y) } else { None }; println!("{:?}", result); if let Some(asd) = result { println!("{}", asd); } } I understand what this code does, but what's with the let in \`if let Some(asd)\` ? What is the let referring to? result has already been let-ed and Some() cannot be let because its not a variable. Does it refer to the \`asd\` ? 
The reason I want named arguments is because of clarity. Restricting the order is just fine, actually, it's better to pick and implementation that reduces bugs than to have named arguments in a worse way. The kind of semantics I was thinking of was about the "depth" of this feature. Named argument syntax is not very deep, compared to e.g. lifetimes.
How (if at all) do you handle errors? I was working on something similar, and one of the features I wanted that I was struggling to implement is that if the compute returns an error, I want that communicated to my receiver *instantly* (rather than in input order), and I additionally want no additional tasks to start.
Thanks!
Any plans to move to stable? 
I have made an emacs client here: [https://github.com/TommyX12/company-tabnine](https://github.com/TommyX12/company-tabnine) It should also be on TabNine's website. :)
Thanks man, but I’m a fan already, that video was downloaded before your comment was submitted. Keep up the good work, these videos are a great way to learn! 
But we already want it to be generic. At the moment there's `build.rs`, which is compiled and run before the build. It can do _any arbitrary thing_ a normal rust program can do. I _think_ that all we need is a `postbuild.rs`, which can then also be any arbitrarily complex rust program that's run after the build. "all we need" makes it sound a lot simpler than it probably actually is once you get to all the edge cases of course.
Thanks for the response - I understand it now! ``` ⇒ rustc --version rustc 1.31.0 (abe02cefd 2018-12-04) ⇒ cargo clippy --version clippy 0.0.212 (2e26fdc 2018-11-22) ⇒ cat src/main.rs struct FooStruct; trait T1 {} impl T1 for FooStruct {} fn foo(_f: Box&lt;dyn T1&gt;) {} fn main() { let fs = FooStruct; foo(Box::new(fs)); } ⇒ cargo clippy Checking traitobj v0.1.0 (/home/afronut/projects/traitobj) warning: this argument is passed by value, but not consumed in the function body --&gt; src/main.rs:5:12 | 5 | fn foo(_f: Box&lt;dyn T1&gt;) {} | ^^^^^^^^^^^ help: consider taking a reference instead: `&amp;Box&lt;dyn T1&gt;` | = note: #[warn(clippy::needless_pass_by_value)] on by default = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#needless_pass_by_value Finished dev [unoptimized + debuginfo] target(s) in 0.09s ``` 
&gt;You can test with `rustup component add nightly-2018-12-01 rustfmt`. I think you meant `rustup component add --toolchain nightly-2018-12-01 rustfmt`?
Can't that just be easily fixed with newtypes if you require that added safety?
If person_id and area_id are the same type you've got bigger problems, friend.
What is frecency? Do you mean frequency?
When I started this, Rust 2018 was nightly only. I can't think of any reason at this point I couldn't move to stable. I'll go ahead and make an issue for it :)
Awesome 
"Frecency" is a combination of how frequent something is accessed and how recently something has been accessed. The term seems to have been coined by Mozilla for their URL completion algorithm, and I continued using it here because it's the most easily google-able term for the algorithm. 
To be clear, I'm trying to better understand requirements and goals and not focus on the implementation details. Yes, `postbuild.rs` is a solution but I'm looking for the "why" behind it and what all is within the solution space of that "why". So let's step back a bit. What requirements are we trying to solve by using the implementation detail of a `postbuild.rs` rather than having something else manage "final artifact" processing.
Philipp Oppermann has a series of blog posts where he builds an operating system: [https://os.phil-opp.com/](https://os.phil-opp.com/)
`let` takes a pattern on its left side, so the thing that is being letted is `asd`. Ordinary `let`s (like `let x = 5.0`) are no different, except the pattern is just a name that the entire expression is bound to - that's why you can do something like `let (a, b) = (1, 2);`. Only weird thing to remember is that `let`s outside of an `if let` can only use irrefutable patterns (like a name or a destructuring), and `let`s inside of an `if let` can only use refutable patterns (a pattern where binding that could fail, like `Some(x)` or `Err(e)`.)
Ah, gotcha. Interesting! Thanks
Hmmm still a weird looking/feeling syntax (for me) but thanks for clearing that up! Much appreciated!
 fn closures() { let one = 22; let clos = move |x| 2 + x; println!("{:?}", clos(2)); println!("{:?}", clos(one)); println!("{:?}", one); } Why can I still use the variable `one` after I executed the closure? I used the `move` statement, so the ownership for `one` should have been moved into the closure. Which in turn means that I shouldn't be able to print `one` in the last line. What did I misunderstand here?
Check out [rust-learning](https://github.com/ctjhoa/rust-learning) 
More of a theoretical question: I'm not sure I really understand the "safety" aspect of Rust. I don't know C++, but I understand what a dangling pointer is. My assumption/understanding: In C++ I can create a dangling pointer and I need to manually make sure that this is getting deleted/freed/whatever it is called. In Rust this isn't possible, because the borrowing concept won't even allow this, So I either pass this pointer on to another variable(?? or to another function??) or if that's not happening that it will be freed. Is that correct so far? What I don't understand: Let's say I had a dangling pointer. So the pointer points to some memory that is either still containing the actual value of the variable or it has been overwritten in which case it's just a few bytes of gibberish. So if that happens I guess the programm crashes, because it's expecting a String for example, but is getting some weird gibberisch. Is that correct so far? I get that it is not a good thing if your app crashes, but what I just don't understand: How is that a safety/security problem? I doubt that a few bytes of gibberish can cause any harm to the system? But apparently it seems to be. So what is going on exactly? Please keep it as ELI5 as possible as I do not have a CS education. I'm still very much interested in what's going on under the hood. Thanks so much!
Wow, take a step back from the ledge there buddy. I’m learning the language myself and it’s not something that can be picked up in an hour or so. As with anything, there’s a learning curve. However, your post comes off a bit rough towards the language. I’ve watched several talks and have been reading the docs and this is by far one of the best communities in terms of documentation and support. Take a breather, have a *refreshment or whatever, and get back to it when you’ve cleared your head a bit 
[HackerRank's environment](https://www.hackerrank.com/environment) specifically says you have access to [text_io](https://docs.rs/text_io/0.1.7/text_io/), which should make all of this trivial. If you want to just use the stdlib, you could do something like this (untested): use std::io::{stdin, BufRead}; let input = stdin.lock().lines(); // iterator that reads lines from stdin let two_ints: Vec&lt;i32&gt; = input.next().map(|line| line.split(" ").map(|word| word.parse()).collect()).unwrap(); assert_eq!(two_ints.len(), 2); or arbitrary groupings of ints like this: let input = stdin.lock().lines(); // iterator that reads lines from stdin let all_ints: Vec&lt;Vec&lt;i32&gt;&gt; = input.map(|line| line.split(" ").map(|word| word.parse()).collect()).collect(); where each element of `all_ints` is a `Vec` of the ints that were on a single line. We could also use `flat_map` instead of `map` to reduce it into a single `Vec&lt;i32&gt;`. `text_io` makes all of this way easier. let (i1, i2) = (read!(), read!()); done.
to be sure, I am referring mio based TCP stream in here. 
Sure. Note that this solution contains a LOT of unidiomatic rust code (in particular, the use of \`.expect()\` is generally frowned upon), but you were looking for short and sweet: use std::io::{self, Read}; fn main() { let mut input = String::new(); io::stdin().read_to_string(&amp;mut input).expect("I/O error reading input"); let mut parts = input.split_whitespace(); let first_int: usize = parts .next().expect("There wasn't a first int in the input!") .parse().expect("Error parsing first int from input"); let second_int: i64 = parts .next().expect("There wasn't a second int in the input!") .parse().expect("Error parsing second int from input"); let list_of_ints: Vec&lt;i64&gt; = parts .map(|part| part.parse().expect("Error parsing int")) .collect(); } &amp;#x200B;
I will point out that, while I love Rust more than any other programming language these days, one of its strengths is *not* that it's a language where you can bang out a quick string parser in a couple lines of code. That's more Python or Perl's strength. Rust is great because it forces you to deal with errors and think about data ownership, which forces you to write better code, but also means that even short and sweet code (like the example I wrote in [an earlier comment](https://www.reddit.com/r/rust/comments/a5294n/never_had_more_io_difficulty_when_learning_a/ebjc1j4/)) has to contend with dealing with errors and so on.
My favourite engineering speaker has discovered my favourite language!
Excellent, somehow I’d missed this tidbit :)
What happens if that gibberish is sensitive data - say, your password - and instead of crashing, it actually keeps working, and sends that data off somewhere by accident? Crashing is actually not the security problem - it's what happens when your program continues to run in an undefined state. That's why Rust often chooses to panic at runtime instead of just allowing you to invoke undefined behavior.
`one` has the type `i32`, which implements `Copy`. Anything that is `Copy` doesn't obey normal move semantics; trying to move it just makes a copy and leaves the original untouched. You can see the difference if you use a non-copy version: ``` #[derive(Debug)] // not Copy struct Foo(i32); fn closures() { let one = Foo(22); let clos = move |x: Foo| Foo(2 + x.0); println!("{:?}", clos(Foo(2))); println!("{:?}", clos(one)); println!("{:?}", one); // Doesn't work - "borrow of moved value" } ```
I really like that `run anything` UI. I wish vscode's cargo tasks worked the same way. 
Ahhh ok. I should have known this. Thanks so much for your help/explanation!!
&gt;If person\_id and area\_id are the same type you've got bigger problems, friend. Sorry, I can't catch your point. How do you change i32 id's type in [this code](http://siciarz.net/24-days-rust-diesel/)
You don't want all lints. Do you _really_ want clippy to lint if you use floats at all? What if you use [integer arithmetic](https://rust-lang.github.io/rust-clippy/master/index.html#integer_arithmetic) or you [implicitly return](https://rust-lang.github.io/rust-clippy/master/index.html#implicit_return) per idiomatic Rust, or you [don't document every private item in your crate](https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items)?
All lints, then selectively disable.
Yes you need to look up the argument names as a writer but as a _reader_ it is obvious and furhermore if two arguments are the same type it catches the error of accidentally switching them more easily. Finally it means you can switch the order which sometimes enhances readability.
Adds a lot of overhead + doesn't assist readability
I too once thought newtype wrapping was the solution, however the problems it introduces is often not worth the effort, buddy
Rust probbly also wants anonymous structs the same way it has anonymous tuple-structs right now. Then named-arguments can just be syntactic sugar over anonymous structs. Like let's say that `Colour::new(red=128, blue=100, green=255)` is just syntactic sugar for `Colour::new(@{red:128, blue:100, green:255})` where `@{ .... }` is some syntax for an anonymous tuple. You could even device some thing with optional arguments. Like let's say that it's actually sugar for `Colour::new(@{red:Some(128), blue:Some(100), green:Some(255)})` and that of course omitting it is the same as passing None. Just say that under the hood if the last argument a function expects is an anonymous struct then this translation can just happen.
&gt; Named arguments are nice obviously, but I'd rather use the builder-pattern, or other patterns that help with object configuration, instead of more sugar. Builder pattern itself should have been sugar in my opinion; now we have the annoying situation that some things are builder pattern and others aren't; I also don't think the optimizer can optimzie all cases of the builder pattern out as easily as it could with named arguments. But basically let's say `x-&gt;meth(arg)` was sugar for `{let mut _x = x; _x.meth(arg); _x}`; the you could just do `assert_eq!(Vec::new()-&gt;push(0)-&gt;push(1).len(), 2)` as an example and then everything can be used as a builder-pattern if you want it yourself.
Newtypes don't add any overhead.
Such as?
Same here
There's definitely tons of places where different fields are likely to be (and should logically be) the same type. Nobody is out there newtyping `str`, `u32`, e.t.c. individually for every struct.
In my experience it is being the easiest and that too with only std lib. I've submitted a couple of answers on hackerrank myself. When doing I/O stuff I actually make sure to enforce error checking. This way the program loops until the correct input is provided (of course not useful to the solution). Here's how I did I/O on the Tries: Contact problem: use std::io; fn main(){ let mut t = Trie::new(); let n: u32; let mut c = 0; loop { let mut inp = String::with_capacity(1); io::stdin().read_line(&amp;mut inp).expect("fail to read line"); match inp.trim().parse() { Ok(num) =&gt; n = num, Err(_) =&gt; continue, } break; } loop { let mut inp = String::with_capacity(2); match io::stdin().read_line(&amp;mut inp) { Ok(_result) =&gt; { let mut _m: Vec&lt;&amp;str&gt; = inp.trim().split_whitespace().collect(); match _m.get(0) { Some(&amp;"add") =&gt; { t.add(_m[1]); c += 1; }, Some(&amp;"find") =&gt; { println!("{}", t.find(&amp;_m[1])); c += 1; }, _=&gt; {}, } }, Err(_) =&gt; continue, } match c != n { true =&gt; continue, false =&gt; break, } } }
Not excution overhead, but verbosity overhead
&gt; I need to remember in what order the arguments are evaluated. I can only imagine the debugging hell of trying to track down a bug caused by named arguments being evaluated in a different order than I had reasoned while writing the code. If changing the evaluation order of arguments in function calls changes the semantics of your code (apart from `&amp;&amp;` and `||`), then your code is already brittle and you shouldn't be doing that...
I just wrote a proc-macro to newtype as many of my number types as efficiently as possible. I also wrote the less effective macro_rules version so that you can do it without two crates if you want.
In short, lack of a standard build system/workflow is as great a problem for usability as lack of a standard dependency management tool. Cargo solves the latter problem very well, it does nothing to address the former. So my thoughts on what post build scripts add: --- 1. Simplified, standard workflow for all projects (not just libraries or simple binaries) - Today's workflow: 1. `cargo check`: check syntax - `cargo build`: build (1/2) - `custom script/3rd party command`: build (2/2) __&lt;-__ - `cargo test`: run tests - `cargo run`: run your project and/or examples - `cargo install`: move final artifacts to destination and adjust target environment - Solution is to merge steps 2. and 3. with post-build scripts 2. Simplify IDE/Text Editor Integration through Cargo.toml - Would allow Cargo.toml to be a portable, fully capable IDE project file, like CMakeLists.txt but with a smaller surface area - Requires post build steps for non-trivial products 3. Cargo already supports pre-build scripts. It is not immediately obvious: - That cargo doesn't support post-build, pre-install steps - That to do so, you need a third-party Cargo plugin - Which third-party best suits your needs - How long those third party solutions will be maintained/how stable they are 5. Would allow for almost every possible target with vanilla cargo, such as MacOS/iOS apps, application extensions, embedded systems, etc. 6. `cargo test` could apply to the full product, not just the binary 7. Minimal additional surface area. --- ## On the Workarounds: - `cargo install` is an unacceptable workaround. Its semantics are for deploying the product after being tested, which typically involves copying artifacts to their final destination and occasionally manipulating the target environment. It should not be used as a part of the build process, as there are cases where you need to test something before you install it. - Third party subcommands are an unacceptable workaround. - Requiring them to target embedded is just as bad as in C, and it's an arrow in the knee to adoption. I get that's not the most convincing argument. - Dependencies are technical debt. You are committing to something being maintained or maintaining it yourself. - `cargo ___` would not be the most acceptable solution. Post-build steps are a part of the build process, and `cargo build` should reflect that. Adding more semantics to `cargo` just makes learning Rust more difficult. --- ## On the issues - Cargo is officially a build system. I don't really think this is a problem, since Cargo *is* a build system already. It's just lacking in features that make it usable. - What should the limitations be for post-build? Do you allow it in dependencies or only on the final downstream crate? - How will people abuse the feature? Using it to build multiple targets, messing with user's file system, mis-appropriating it for installation, etc - If you copy/move the binary, how do you alert cargo for `cargo run` or `cargo test`? --- ## Final thoughts Post build scripts would allow for `cargo build` to build non-trivial products. It would allow the user to test their final product without any additional semantics. It removes the necessity of build dependencies and debt associated with them, and makes building, maintaining, and distributing Rust projects easier. The minimum viable solution would be to limit post-build scripts to run in the final downstream crate, and not dependencies. Eventually limiting the script through sandboxing or an API would help curb bad behavior and edge cases in dependencies. This discussion is better suited for internals.rust-lang.org but I have a feeling I'd get crucified for this discussion at worst, or referred to the past failed attempts/discussion at best. At the end of the day, I'd be happy with acknowledgement from the Cargo team that these are real problems, and an explanation of why they don't want Cargo to become the build system de jure. So long as it remains the de facto build tool, users are left in limbo, and the ecosystem *will* suffer. We've seen that in C/C++ for decades. 
This seems like a really smart and intuitive way to go about it, although, I could imagine some really gnarly function declarations when considering a hypothetical anonymous struct syntax along with generic type/lifetime constraints, which can already get pretty messy.
Another alternative that uses shadowing instead of a block: fn main() { let mut data = Avg { count: 0, sum: 0 }; data.add(1); data.add(2); data.add(3); let data = data; println!("{}", data.avg()); }
I think what it comes down to is that building compiled products is a non trivial process that involves mixing configuration data and declarative syntax. The biggest problem with many build systems is that they opt for using declarative syntax to handle configuration data. Meanwhile Cargo is very much configuration first, and minimum declarative steps through pre-build. The only reason we have pre-build scripts is that FFI would be impossible. You need to instruct Cargo how to build and link against C libs somewhere, and build.rs is how you do it. Fortunately or unfortunately this has put Cargo on the slippery slope to becoming a build system, and I think the Cargo team doesn't want to go the route of supporting anything remotely declarative other than what is minimally necessary to build single binaries. But I'm speaking out my butt here, I'd love for the Cargo people to chime in. I've read through the old threads but wasn't around for the IRC/Discord discussion or present at any of their meetings, so if I'm totally off base, please someone correct me and tell me why Cargo shouldn't be a build system. 
I agree, my post above was for the sake of argument. Just trying to flesh out all the design considerations something like this needs. Personally whenever I'm calling functions that operate on a bunch of different data the data tends to be already organized it into a struct and I pass it by reference. It saves copying all the data over.
&gt; I feel like it goes against Rust's explicitness. The merits of `_ { a, b }` notwithstanding, some people keep repeating a point about Rust's supposed explicitness; but this is *not* a general design principle I (or to my knowledge the rest of the language team) generally adhere to. One language team member wrote a blog post about [not explicit](https://boats.gitlab.io/blog/post/2017-12-27-things-explicit-is-not/) another wrote about the [reasoning footprint](https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html). As you can see from these posts, our approach to implicit things are much more subtle.
You're missing the [try_clone](https://doc.servo.org/std/net/struct.UdpSocket.html#method.try_clone) method to allow both threads to use UdpSocket values that share the same underlying socket.
Okay, but I still believe that using an underscore to denote 'find the damn thing yourself' is a little too unreasonable. Its not hard to just write out a struct name, why not just do it? Even if Rust is allowed to have some implicit facets, I still believe that just throwing random syntactic sugar around isn't a good idea.
Youre describing the [cascade operator](https://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html) (shown here by dart). I like it, but, I am not sure how much syntactic sugar Rust should have. Rust has a lot of complex features (and gets more by the release), Id rather spend the syntax budget there, and not on more sugar-syntax.
You may be interested of this https://www.snoyman.com/blog/2018/10/introducing-rust-crash-course
Instead of pub fn steal_borrow&lt;T&gt;(target: &amp;mut T, f: &amp;Fn(T) -&gt; T) { let mut fake = unsafe { std::mem::zeroed() }; std::mem::swap(&amp;mut fake, target); let mut fake = f(fake); std::mem::swap(&amp;mut fake, target); std::mem::forget(fake); } why not just pub fn steal_borrow&lt;T&gt;(target: &amp;mut T, f: &amp;Fn(T) -&gt; T) { let res = f(unsafe { std::ptr::read(target) }); unsafe { std::ptr::write(target, res) }; } ?
I've just tried to access now and it works. If it's still broken for anyone, [here's an archive.org snapshot](https://web.archive.org/web/20181130155456/https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html).
You cant design a programming language thinking &gt; your code is already brittle and you shouldn't be doing that... You need to expect that the worst case will happen, and protect against that. There are tons of examples of libraries in various languages that just have bad APIs. It happens, it is no ones fault, but PL implementers should learn to look out for these things. Rust has a lot of things interweaving, and the [top post on this thread](http://github.com/samsieber/rubber-duck/blob/master/REVIEW.md) describes a lot of the complexity here. To make named arguments truly simple to use for everyone, it will be very locked down and basic. I'd rather just have a slightly clunkier (but not unsafe) method, that already exists in the language IMO.
You are a hero! And labels help a lot. Makes it even more evident that there is need of stop a little and clean. There are 1200+ open issues with the c_bug label. 
I have no opinions about this change in particular; As for a solution to "named arguments", mine is to introduce structural records into the language *and* the type system: https://github.com/rust-lang/rfcs/pull/2584. I'm sure that whoever suggested `_ { x, y }` didn't think of it as *random*; please give people the benefit of the doubt that they have good reasons for the specific sugar they are proposing. My general problem is with arguments of the form "I feel like X goes against Rust's explicitness" for random X.
It's `try { let a = foo()?; let b = bar?; a + b }`. The `try!` macro is deprecated on Rust 2015 and a hard error on 2018 edition.
This is great. Thanks for putting this together. 
I dont mean to call `_ {}` syntax random, I have seen it thrown around before actually. But I do see a lot of people _truly_ throwing around random syntax. I dont like the pseudo-anonymous structs proposal, and I hope it doesnt go through. It looks like it has a lot of drawbacks for a seemingly innocuous addition.
&gt;You need to expect that the worst case will happen, and protect against that. There are tons of examples of libraries in various languages that just have bad APIs. It happens, it is no ones fault, but PL implementers should learn to look out for these things. You'd think that the OCaml people from INRIA know one or two things about language design and 1. OCaml has named parameters and default parameters 2. OCaml doesn't specify the order of evaluation of arguments in the general case. Rust has sugar for indexing vectors, which is one step away from panicking. Arithmetic wraps around by default in release mode for performance. Unwrapping is extremely easy. Rust is hardly treating you like a baby. You are expected to not write bad code and that is okay. I'd argue relying on evaluation order of arguments is a way more subtle detail of the language compared to all of these examples, which very few people would know of/care about. &gt;Rust has a lot of things interweaving, and the [top post on this thread](http://github.com/samsieber/rubber-duck/blob/master/REVIEW.md) describes a lot of the complexity here. My comment was not addressed to that top-level comment, I was merely pointing out that the argument of evaluation order is not a good one. &gt;I'd rather just have a slightly clunkier (but not unsafe) method, that already exists in the language IMO. I did not make any point about preferences. You can have yours and I can have mine, that's okay. All I was pointing out was that giving examples of code that are already quite brittle as "this will become more brittle with your change" is a poor argument. We can disagree on that if you wish.
I kind of feel that these are the fundamental things that the syntax budget should have been spent on s well as true universal function call syntax that re just really fundamental instead of `x..y` syntax where `Range{start:x,end:y}`` would suffice. If they can replace the `try!` macro with `?` and feel `do catch { ... }` needs to exist and just `catch!{ ... }` is not enough I really feel that this is more fundamental. 
Maybe you didn't use it correctly? Newtypes is actually a thing that increases readability by the factor of infinity.
I've been staring at the docs for hours and looked right over that, thanks a ton
The majority of your functions shouldn't have so many arguments that you feel the need to call them with named syntax, so I don't get how this can be the backbone of any rationale for python being safer than rust.
Actually I think that we probably don't need explicit feature for named args. Probably postfix macros (https://github.com/rust-lang/rfcs/pull/2442) could solve the problem. Anyway, I would love to see named and optional args and possibility to overload functions. Most other langagues have this features, I miss them sooo much.
The idea of the stream is that it cannot be returned back. What you most probably want is to buffer the stream between the reads and emit event once the input record is finished. BTW, have you looked at Tokio [1]? It is build for solving exactly these kind of problems. [1] https://docs.rs/tokio
Well, with GCs like C4, ZGC, and Shenandoah, pause times in the Java space are much smaller than previous-generation GCs. I didn't state it, but there are other issues that may prevent GC languages from performing as well as their manually managed counterparts like not having value types and not having as mature of an optimizer. With respect to cost, I have worked with a manager who thought that cost would be negligible compared to the performance benefit of a complete rewrite in C++. I think there are enough people out there that are sympathetic to the idea that automatically managed memory will never be as good as manually managed memory.
Yes I did, I am basically learning low level communication, rust is perfect choice to learn so many new concepts. Thank you by d way for d response.
Looks like a known issue: https://github.com/rust-lang/blog.rust-lang.org/issues/312
I'm practicing in Rust on codewars.com
Step 1: Install Microsoft Office 97. :-)
&gt;I have no clue on how to pass down a Rust function to C These examples of [ffi](https://github.com/sn99/rust-ffi-examples) might help ([mainly](https://github.com/sn99/rust-ffi-examples/tree/master/c-to-rust)) &amp;#x200B;
[The Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator) does. 
Some thoughts on setting expectations for 2019. I did a bit of reading on the tracking issues. It looks like [GAT is blocked by Chalk](https://github.com/rust-lang/rust/issues/44265#issuecomment-396629866). I haven't heard anything about progress during the buildup to the Rust 2018 release, so I'm thinking that Chalk will be the blocking issue for future work, much like MIR was for NLL. At a glance, it looks like implementation is progressing on Chalk (see [https://paper.dropbox.com/doc/WG-Traits-Planning-Meeting-oDfr6ct8xx63HSAOOmIZX](https://paper.dropbox.com/doc/WG-Traits-Planning-Meeting-oDfr6ct8xx63HSAOOmIZX) ). That said, parts of it are still being implemented. I expect the rough process of getting Chalk to stable will be: finish building the parts of Chalk, first pass at optimizing, place on nightly, second pass at nightly / bug fixing, get on stable. ... it seems unlikely that Chalk would be done in time to use it to implement GAT and get that feature through a similar process in 2019--although I'd love to be wrong... unless GAT is implemented while the optimizing is done on Chalk, we may have a chance there. 
You can declare a reference to the socket: &amp;#x200B; let socket\_ref = \&amp;socket; &amp;#x200B; Since references are \`Copy\`, both threads can then use \`socket\_ref\` without problems.
Value types and immature optimizers are orthogonal to memory management scheme. But you’re right that GC has a marketing problem. The thing is, for most applications it’s not cost effective to fuss over memory details in the 95% of your code that isn’t the hot path. The GC languages with escape analysis and value types (I’m specifically thinking of Go) allow you to *opt into* memory management for the 5% of your code that is performance sensitive, which is a lot more economical than dealing with it in 100% of your code.
If someone were to write a Qt backend for it, I'd be up for writing Rust+swt-rs apps for my KDE desktop rather than rust-cpython+PyQt apps.
I ran into this limitation a bit over a year ago when writing native Node modules using Neon. I wanted to avoid needing any JavaScript shim code, which therefore necessitated renaming the .so/.dylib/.dll file created by cargo to a .node suffix and moving/copying it out of the target directory. It wasn't an impossible problem to overcome...it [just](https://github.com/casey/just) required an orchestration layer on top of cargo. But without a standard way of doing it, it became really hard to solve in such a way that didn't cause some amount of pain when dealing with the rest of the Rust or Node ecosystem. So as an interested-but-not-terribly-motivated party, I've been observing some of the discussions on this issue ever since. And I think that, regardless of how innocent your motivations are, your line of questioning is likely to strike a nerve. For more than a year now, people with a genuine need for this feature have been asking for it and been asked (and re-asked, and re-asked) questions like the ones you're asking. The rationale, despite continually demonstrating a need for the feature and a near universal agreement that it's a pretty trivial feature to implement, is that adding such a feature goes contrary to some aesthetic or philosophy of the tool and that even though people not wanting to use the feature could simply ignore it, omitting it entirely somehow simplifies things. I've since moved on from my project and don't really care all that much anymore, but I still find the opposition to the feature incredibly annoying. There's lots of things that have been added to Rust that I simply don't need. For example, I don't do embedded development, so I've got no need for `no_std` and little use for writing a custom allocator. But I'm happy those features exist because it makes Rust more useful to others and, apart from skipping a few bits of the documentation, I barely notice them. I wish those with an idealistic agenda for cargo could take a similar view on this issue.
Nice, thanks
Tensor Programming (youtube) if you're the visual type. JM Archer's rust videos (once you're done with Tensor's introduction to Rust) He's been doing the advent of code recently which is good as they increment in difficulty slowly. It'd be good to know what your goals are -- why Rust? what're you dreaming of building?
Rust more than ever is feeling like an excellent time investment for future career opportunities. If WebAssembly takes off, I could honestly see Rust being one of the top 3-4 dominant systems programming languages.
Seems like it's been fixed: https://intellij-rust.github.io/2018/12/10/changelog-88.html
&gt; However, we are far from being a diverse one. We need to do more. I keep seeing this sentiment around, especially with job listings and ironically it’s always struck me as very superficial in itself: diversity should never be the goal, it should just be an indicator that we are *not* being superficial, since true acceptance of diverse people is achieved when nobody has to talk about it. I even think the way of approaching the diversity topic that companies do is very dangerous, first of all since it gives them a competitive edge but also people now need to start wondering if their diverse teammate is even qualified for the job or are they the diversity hire which could lead to toxic work environments. Surely, we can be accepting of each other without having to mention race, religion or gender of one another.
Nice, but it's easy to do in the wrong way than the right way. [https://www.fpcomplete.com/blog/2018/10/is-rust-functional](https://www.fpcomplete.com/blog/2018/10/is-rust-functional?success=true)
I'm not seeing anything: https://www.virustotal.com/#/file/1ccb55ef4552aac85fe7dd3b1f81e55b53d19329eed384310e5811e327803912/detection
Wouldn't be necessary to call forget on res?
I will be happy to see such functionality as part of `rayon`, so if my crate will inspire such addition it will be great! :) But, yeah, integrating it into `rayon` architecture could be non-trivial, even more so if we will not cut corners on error and panic handling. (as unfortunately is currently done in my crate)
Unfortunately there is currently no error handling, even worse, if all worker threads will panic it will lead to deadlock. I have some ideas how crate can be improved, but nothing concrete yet. &gt;I want that communicated to my receiver instantly (rather than in input order), and I additionally want no additional tasks to start I would like to have such functionality in future as well.
These look great and have bookmarked, but I don't think I am at the level yet to understand these. I am still trying to wrap my head around ownership and scope by getting into long fights with the compiler. With that in mind do you have any of your videos you think would be more apt for a beginner?
Well said
Ah, the age-old debate about affirmative action vs level playing field.
I don't think so; `std::ptr::write` moves it out.
What are the advantages of named arguments as a build in features vs "named arguments" as a tooling feature? A sufficient good IDE can just print the argument names along the parameters - in a forward compatible way, because it can look the current name up. Having named arguments would make any parameter change a breaking change. As I see it the rust eco system has already an API commitment problem - that's why we're stuck at so many &lt; 1.0 releases. Something like this would &amp;#x200B; Also there seem to be some suggestions how to implement them for functions - i haven't seen any with explains how should they work with traits. * Don't allow named argument for traits functions? * Must an implementer have the same parameter names as the trait definition? This wouldn't be a backward compatible change. ( I can't remember giving two diffreent From trait miplementations the same argument name) * Always chose the trait definitions argument name? always chose the implementors argument name? * ... I honestly feel this could be solved best by enhancing the IDE tooling instead of baking it into the language. The only suggestions i've seen which would not work with tooling is the - but if the focus is just naming the arguments for clarities sake then the fixed order shouldn't matter. Only features like Pythons `foo(**dict)` or `foo(*args)` can't be solved by an IDE - but I haven't seen anyone calling for that. &amp;#x200B;
You can set [thread name](https://docs.rs/crossbeam/0.5.0/crossbeam/thread/struct.ScopedThreadBuilder.html#method.name) with crossbeam, so it's just matter of generating names in the pool creation code. &gt;you can remove an unwrap, using binary heap's PeekMut Great suggestion!
It's just "SmartScreen" warning you that they "haven't seen that executable". Doesn't help that `rustup-init.exe` isn't signed with a code signing certificate at all.
Also, `move` on the closure does not say anything about how it accepts arguments, but about how it captures its environment. Right now `clos` closure does not capture any variables, so it would work exactly the same if you defined it as a simple function: fn closures() { let one = 22; fn clos(x: i32) -&gt; i32 { 2 + x } println!("{:?}", clos(2)); println!("{:?}", clos(one)); println!("{:?}", one); } `move` basically changes how a closure is desugared with regards to outside variables it uses. When you don't have `move`: let x = 1; let f = |y| x + y; then closure stores `x` as a reference to the actual variable it captured (not real syntax, `Fn` traits currently don't work like that, this is just to illustrate the point): let x = 1; struct AnonymousFn&lt;'a&gt; { captured_x: &amp;'a i32, } impl&lt;'a&gt; Fn(i32) -&gt; i32 for AnonymousFn&lt;'a&gt; { fn call(&amp;self, y: i32) -&gt; i32 { *self.captured_x + y } } let f = AnonymousFn { captured_x: &amp;x }; But if you add `move` to the closure: let x = 1; let f = move |y| x + y; then value of `x` is instead `move`d into the closure (well, `i32` is `Copy`, so you could still use `x` after creating the closure, but you wouldn't be able to if `x` was for example a `String`): let x = 1; struct AnonymousFn { captured_x: i32, } impl Fn(i32) -&gt; i32 for AnonymousFn { fn call(&amp;self, y: i32) -&gt; i32 { self.captured_x + y } } let f = AnonymousFn { captured_x: x }; You would see a difference between `move` and not-move in cases like this: fn make_function() -&gt; impl Fn(i32) -&gt; i32 { let x = 1; move |y| x + y } It wouldn't compile without `move`, because then you would be basically returning a struct that contains a reference to a variable that went out of scope.
Thank you! I didn’t know there is an established term for this. Is there maybe an article that shows the other side of this "debate"? I’m interested in understanding their motivations.
You know, just once I’d like to see the negative reaction to a request for diversity be fear that we cannot serve the people we reach out adequately to rather than literally the same paean to merit.
&gt;diversity: Rust's community as a good reputation as a welcoming community. However, we are far from being a diverse one. We need to do more. Talk about virtue signaling
You will need to read the data in a buffer then decode that buffer. You could try to wrap it in a [BufReader](https://doc.rust-lang.org/1.24.0/std/io/struct.BufReader.html) but this does not handle reading data from it without consuming it. A while ago I wrote [AccReader](https://github.com/Geal/nom/blob/73cb4ec34a19f934911351377a25db5decfaf873/src/accumulator.rs) which was a kind of `BufReader` with access to the underlying data, with the `AccReader::current-slice()` method
Talks about diversity is always used as signal your virtue, not actually for the sake of "oppressed"
I'm using `fasd` and I think I'll stay with it but great idea anyway! You might want to note that, since we're talking about rust ports, there's a port of `fzf` in Rust: https://github.com/lotabout/skim I've nothing to do with the author but…
I'm not saying you should never use newtypes, what I'm saying is it's not a replacement for named arguments
Unfortunately, no, we can't just be accepting of each other and not allow people to talk about where we're falling short. I'm not sure what the best approach is, but that one is basically a recipe for making sure bias is everything but superficial. This is how you end up with insidious conventions that discriminate by proxy (e.g. instead of "no coconuts," you end up with "no food items that are brown and and hard and hairy with a white meat inside," which is not much better in effect but avoids talking about coconuts).
In a nutshell, the motivation is hidden in your own comment: &gt; since it gives them an unfair competitive edge The idea is that some over-represented groups _by default_ have a competitive edge - for example, people with a lower voice are (supposedly - I didn't dive into the research myself) often considered more trustworthy, even though that doesn't actually say anything about how trustworthy they are. So, what you might consider "giving women a competitive advantage", proponents of affirmative action consider "compensating for men's competitive advantage". In other words: by making an effort to explicitly prefer women, you make up for your subconscious inclination to reject perfectly capable women.
The rustc guide link in that doc leads to a 404
&gt; If you copy/move the binary, how do you alert cargo for cargo run or cargo test? On this one point it seems simple: same as build.rs you just print some specially formatted message to stdio and then cargo picks up on that and reacts accordingly.
I need to ask: Has anyone ever been rejected from participating in the Rust community because of their gender, sex, sexual preference or similar? If yes, then we need to do something about it. If no, I don't know why the topic needs to come up. I think we all agree that **everyone** is welcome to participate in the Rust community. And the term **everyone** is as inclusive as it gets. It literally means that no matter how different you are from the others, you are still welcome. And if you are just boring and like everyone else, you are still welcome. IMO, it is unnecessary and wrong to single out certain groups and tell them how welcome they are, since that would imply that they are not part of „everyone“.
https://crates.io/crates/take_mut https://crates.io/crates/replace_with
I moved from error-chain to std Error. If you use a recent Rust version, you have the `cause` which is similar to chain_err
[https://github.com/rust-lang/rust/pull/56384](https://github.com/rust-lang/rust/pull/56384)
How, when AoC gives out its instructions piecemeal?
I don't want to use names, but I have been witness to one particular case where one community member made a slightly off color joke, another community member was made to feel very uncomfortable, and then the uncomfortable member ended up leaving. And sure it was "just a joke", but _that's_ the kind of thing we're trying to be self-aware of. I would also agree that I don't think anyone is saying "no women" or "no blacks" whichever other group, but it's still easy to make a place less friendly for some than for others through simple carelessness.
I looked up the documentation: "cause: Deprecating in 1.33.0: replaced by Error::source, which can support downcasting" &amp;#x200B; This looks good but seems like a lot is going on there.
Great proposals and discusion on these urls Thanks
😮
This being not only upvoted, but the (as of this writing) top comment is a perfect example of what Nick is talking about. The ideal you're describing is meritocracy, which is a libertarian pipe dream that serves only to keep the current dominant demographic (white straight men) in the position it holds. Yes, ideally we would all be "color blind" (and the various equivalents of that for demographics besides race) but that's not how humans actually operate. It's a lot more complicated than that. Diversity initiatives may be ineffective or poorly implemented, but the goal is not shallow, and it's necessary to upset the balance of power that currently exists and that is most certainly unjust.
`cause` was there since 1.0 and will be deprecated in 1.33. And it is not the same method.
I really hope we live to see a day when that happens. It's so depressing.
I just finished to [implement a RealisticCamera](https://github.com/wahn/rs_pbrt/issues/70), but bits and pieces can be executed in parallel and I haven't done that yet. Antoine Büsch started to contribute parts from [his version](https://bitbucket.org/abusch/rustracer) of a Rust implementation of PBRT [last week](https://www.janwalter.org/assets/abusch_01.png): ![commits last week](https://www.janwalter.org/assets/abusch_02.png) So this must be the highest amount of commits for this repository since I started working on it. He actually started way earlier than me on his project and we were aware of each others efforts, but last week we decided to join forces and I think it was a nice start ... So, what's left to do this week is to clean up a bit, maybe add the parallel parts for `RealisticCamera`, write an announcement for the new version (to come) and publish it (and an updated version of the [Rust documentation](https://www.rs-pbrt.org/doc/crates/pbrt/index.html)) @ [rs-pbrt.org](https://www.rs-pbrt.org/about/) ... Thanks, Antoine Büsch, for your contributions !!! BTW they **rings** visible in the **C++ version** (see ticket mentioned in first sentence) are fixed now: [mmp/pbrt-v3#162](https://github.com/mmp/pbrt-v3/issues/162)
Isn't that what the named parameters is doing though?
This is an incredibly vile world view and IMO you should be banned from the subreddit for writing this here. Using "SJW" unironically and suggesting that people who care about the inclusion of people unlike themselves are just "virtue signaling" (again used unironically) is about the grossest violation of Rust's CoC there is outside of a direct threat or harassment of an individual. And since you likely think codes of conduct are evil plots concocted by SJWs to keep your merit from being recognized, you can substitute "Rust's CoC" with "basic decency."
&gt; diversity should never be the goal, it should just be an indicator that we are not being superficial, since true acceptance of diverse people is achieved when nobody has to talk about it. So why there's not more diversity in the first place? There're certainly multiple reasons and even if there might be already true acceptance, encouraging minorities might still be needed. Change doesn't just happen, but it has to be supported. If you never have been part of a minority you really have no clue what it means. I don't quite get what people are fearing, that they loose something? 
Surely, we can just *not* murder, rape and steal from each other, without having to talk about how these things are bad, or having instutionalized tools to prevent these things from happening. Oh, wait...
About the error handling, I tried `Failure` recently, and I found it great and much better that the `std::error::Error` API.
What are the current dominant systems programming languages, other than C and C++?
&gt;Builder pattern itself should have been sugar in my opinion; now we have the annoying situation that some things are builder pattern and others aren't My exact thought, as someone who's very new to Rust. Rust does mutability so well and yet we're being encouraged to use the builder pattern (which library authors have to opt-in for). I don't know, maybe the builder pattern will grow on me, but currently this is easily the thing I like least about Rust.
&gt; Last I heard of RustBelt was that it was a bit stuck on modelling unsafe - are they planning on doing so? I was under the impression that they were going to treat unsafe blocks as black boxes. RustBelt is all about modelling unsafe! One of the key things it lets you do is formally prove that your unsafe code is safely encapsulated behind a typed API, and we have done that to verify the correctness of `Rc`, `RefCell`, `Arc` and a few other types. That said, the model of unsafe that we used in RustBelt is definitely not final. The exact rules for what unsafe can and cannot do are still being discussed by the [UCG WG](https://github.com/rust-rfcs/unsafe-code-guidelines/). RustBelt just made some preliminary choices there (and not all of them realistic) to be able to make some progress towards verification of unsafe code. That was still realistic enough to [find](https://www.ralfj.de/blog/2017/06/09/mutexguard-sync.html) some [bugs](https://www.ralfj.de/blog/2018/07/13/arc-synchronization.html), though.
Take a look at codecs in Tokio. They do what you want. Perhaps have a look at [https://www.snoyman.com/blog/2018/12/rust-crash-course-07-async-futures-tokio](https://www.snoyman.com/blog/2018/12/rust-crash-course-07-async-futures-tokio).
I have, and continue to use, only the standard library for error handling. Unless you're building an application and really want backtraces (or some other need), then I would personally recommend you do the same. Once the changes to the Error trait in std land, then it will be time to re-evaluate.
Sorry made a mistake. Looks like I am using `source` but it's named `cause` on the struct. They should probably be named the same.
What version of windows are you using? There are two products labeled "Windows Defender", the one that came with Windows 7 and i believe earlier, which is considered bad, and the better one, Microsoft Security Essentials, which was renamed to Windows Defender and bundled with windows, starting in windows 8. I'm on Windows 10 and have never gotten any issues from windows defender about rust or rustup. Anyway, to be clear. yes, that is the correct and official source for rust and rustup, and it's perfectly safe.
I suppose using newtypes require from you to write some boilerplate, you need to define them.
Hi there, similar beginner here, but I believe I'm onto something ;) `line.replace(...)` is not in-place operation, but rather creates a new string (see [the docs](https://doc.rust-lang.org/std/string/struct.String.html#method.replace)). Try changing it to `line = line.replace(...)`.
Take a look at the [documentation for replace](https://doc.rust-lang.org/std/primitive.str.html#method.replace). It creates a new (modified) String. You are creating some modified strings, but none of the new/modified Strings get saved. &amp;#x200B; you could do something like: `let modified: Vec&lt;String&gt; = old_content.split('\n').map(|line| line.replace("pattern1", "pattern2")).collect();`
Because of the changes of website recently. All routing was changed. No redirection handler :(. RIP the old website.
&gt;I don't want to use names, but I have been witness to one particular case where one community member made an off color joke, another community member was made to feel very uncomfortable, and then the uncomfortable member ended up leaving. And sure it was "just a joke", but &gt; &gt;that's &gt; &gt; the kind of thing we're trying to be self-aware of. But this is actually covered in the CoC, isn't it? IMO, this is nothing that couldn't have been fixed with an apology. Leaving a community because a single member made a bad joke seems like an overreaction to me. There will always be individuals in a group that we don't like because they made a bad joke. If you want to to make people aware that this is a problem, you don't do that by leaving the community. You do it by talking to the individual in question and making them aware that their behaviour was inappropriate. In fact, I *expect* others to tell me when I behave appropriately so I can apologize and adjust my behaviour. This whole topic is not something we - as a technical comunity - can or should try to fix. All we can do is state that we want to be open to everyone (which we do), define some ground rules for behaviour (which we do) and settle disputes on a case-by-case basis (which, as far as I know, we also do). &gt; it's still easy to make a place less friendly for some than for others through simple carelessness. And it's easy for those who feel offended to make others aware of their carelessness. You don't change people using rules or campaigns. You change people one step and one person at a time.
Actually, crashing is the best case scenario in case of an unsafe behavior.
Really, no redirection of old URLs? I mean, the design is subjective, and even the needs of the target audience are. But this is a purely engineering fail.
I second this - I used failure for a while, but now with `source` being stable there's no need to use external libs. As i understand It, the plan is for failure to become a crate for generating error impls, and will just use the types in std.
Ahhh ok. That wasn't obvious to me. So the `move` isn't for the variable I'm actively passing in, but for the captured variables from the scope it is called from? Thanks for clearing that up!!
If you are lagging behind you have acess to part1 of the days 
Ah, I used markdown notation (three backticks) 
I like this plan, but in my opinion it should be shifted by 1 year. This plan assumes, that 2018 edition is done and year 2019 can be exploration and hacking. Unfortunately 2018 is FAR from being done, the next year is probably going to be mostly finishing this edition and maybe 2020 will be for new things. Otherwise Rust can sink under a burden of unfinished, unpolished features.
This is exactly what I was trying to say, thank you for putting it into words.
Previous thread: https://old.reddit.com/r/rust/comments/a4y73y/my_wish_for_rust_2019_named_argument_syntax/ I posted a link to a tweet yesterday and the discussion did not disappoint: I was down-voted to oblivion. There were some people with ideas of how to add named argument syntax through procedural macros. Today I woke up thinking maybe I should try one of those. However, I would like something that I can add to a working project and then remove later afterwards, when no longer needed. A one-liner macro is ideal, because you can just copy and paste it.
Thank you for this reply, I see your point and I think we agree on most matters. I'm merely criticizing the implementation as you put it. Your point with the current balance of power is also interesting, I guess this is more prevalent in the US because of its history? And these implementations of "affirmative action" are endeavours to revert the effects of that history? Thank you for making me understand it a bit more.
I applaud to your perfect talking points, I'm pretty sure your comrades will give 5 out of 5 for it. If you have nothing else to say aside from your whining, then go cry to moderators so that I'd be banned as you wish. It only proves my point that only followers of your ideology are welcome, not everyone. I'm pretty sure though what I said is not violation of Rust's CoC, and the actual violation is your hurt feelings for which I give no damn
Feels bad when you're on wrong side, right? Maybe you should look at what people think instead of what you want them to think?
&gt;then the uncomfortable member ended up leaving If he cannot tolerate simple joke, then I have no idea how exactly he could survive in this world this time
I didn't find the main pain for me in 2018 and in 2019 as the consequence: speed of compilation. When you work with Rust code for real project, not small one performance is matter, and now it is very slow. workspace caching doesn't always work and every miss is rebuild of several crates (which is slow or I already tell this), this is very very inconvenient.
If you're genuinely not educated on this topic then I apologize for my tone—almost always this point of view is brought up by racist or misogynistic men who just want to keep a hold on their domination of the industry and/or gaslight those who disagree. [Affirmative action](https://en.wikipedia.org/wiki/Affirmative_action) is not specific to the US. You can read as much as you like about it on that Wikipedia article and other sources, but generally it refers to any sort of public policy that attempts to rebalance power structures by providing extra privileges or advantages to demographics of people that are currently underrepresented. In many cultures, and certainly in the US, this almost always means that straight white men have the advantage and that affirmative action policies are put in place to help non-straight white males have better chances at things like getting a job. Unsurprisingly, many straight white males see this as an unfair attack on them, with the counterpoint being that reward should be given only on "merit" and not based on some innate property like skin color or gender that a person didn't choose. Obviously I have a strong bias in the debate, and you can make up your own mind, but I will say this: It's telling that when someone writes a lengthy article about many subjects such as Nick's post that we're all discussing here, which only briefly mentions diversity, without fail, one or more highly upvoted comments in the discussion will make the argument you made in your original comment. This itself reflects the imbalance of power diversity policies are trying to disrupt. Imagine how this feels to a woman, or a black person, or a transgender person. Every time someone even tangentially mentions improving the quality of their lives, a white guy shows up and loudly proclaims how unfair it is that people are giving special treatment to others and that all that should matter is his self-perceived merit.
It may be more prevalent in the US than wherever you are, but there are places where is much worse than the US also.
Thanks for your answer. However I'm not sure I really understand. My current app has loads of variables, but none of them is anything important (username, password, or something secret). So if Rust weren't safe my app would just crash, but it wouldn't be a security/safety problem. Is that correct? 
[Yes](https://github.com/rust-lang/rfcs/blob/master/text/2388-try-expr.md), but it's experimental, so you need to use `#![feature(try_blocks)]`.
`fasd` is great. I'm hoping to port this algorithm to `fasd` sometime soon. And I'll have to check `skim` out. Looks interesting
I think you're not fully appreciating how difficult what you're proposing is for people in demographics who are constantly having to deal with this stuff. You're putting the onus on the victim (so to speak) to correct the behavior of the "joke teller." But people get this day in and day out. It's inconsiderate and unrealistic to tell someone who constantly hears jokes at their expense that they are the ones who should stand up and be the ones to change things. For one, they already are. That's the whole purpose of things like a CoC. The community has identified the kind of stuff that makes people feel unwelcome, and there are now rules for how people should behave, so the hard work is not constantly on the shoulders of people who are already beaten down by this kind of stuff. tl;dr It's just not reasonable to tell minorities to "stop overreacting" and to always assert themselves with the aggressor. Many of them already do. The whole point is to protect them from having to do this so often. That's what makes for a welcoming community.
I find &gt; Talks about diversity is always used as signal your virtue, not actually for the sake of "oppressed" to be at odds with. &gt; Respect that people have differences of opinion. Nothing is likely to be done about it unless you get more explicit with your views on the dangers of diversity, but you explicitly stated that one of goals of the rust programming team is based on a believe that no one has. That is not respecting that people have differences of opinion.
Advent of Code! &amp;#x200B; [https://adventofcode.com](https://adventofcode.com)
I'm just learning about lifetimes and to me it looks like lifetimes undermine the safety aspect of Rust. Here's my code: fn lifetime() { struct Person { name: String, } struct Company&lt;'z&gt; { name: String, ceo: &amp;'z Person, } let boss = Person { name: "Elon Musk".into(), }; let tesla = Company { name: "Tesla".into(), ceo: &amp;boss, }; } So thinking out loud: **What's the problem here? Why do I need lifetimes?** The problem is that a Company could live longer than a Person which is the CEO of the company. So the ceo-reference would point to something that is not there anymore. *Is that correct?* **What do I need to do to fix it and why does it fix it?** I just append a lifetime annotations which tells the compiler: "This thing is gonna live forever, just trust me bro". *Is that correct?* **What is my problem?** Doesn't that make it unsafe? C/C++ is unsafe because of human errors. So what if I make a human error here to and just miss that some person DOESN'T live as long as the company, so that the reference to CEO is empty? How is it guaranteed that it lives long enough? **My explanation?** The only thing that could make it work is that lifetimes aren't the same thing as unsafe() blocks, but actual new rules. Meaning I'll tell the compiler: "Don't ever let me free a Person that is still needed as the CEO of a company. Give me a big fat error message if I do that!!". Which would make sense, but even then: Why doesn't the compiler just know it without me telling him? The error would be the same, no? **My rant!** I'm really confused about lifetimes. Why are they even there? Are they absolutely neccessary to make the whole ownership/borrowing system work? Is it just something that makes life easier for a programmer? Could Rust work without any lifetimes? If the Rust compiler is smart enough to figure out when ownership/borrowing becomes a problem, why isn't he smart enough to do his work without my giving him lifetime annotations? &amp;#x200B;
Throw in a derive Display macro (like with derive\_more) and building out errors with the std Error trait is fairly simple.
I agree with you; but please consider your use of the word "race"; it does not help to perpetuate "race" a category that actually exist as opposed to being a social construct. For example, the way the US. Census is conducted where they ask folks about their "race" strikes me as deeply offensive.
You are correct that the "everyone" welcomed by the Rust community does not, in fact, include those who treat others like you have in your comments here. You're not making a clever point by pointing that out other than reiterating the CoC's stated goals. I won't engage with you further, as anyone else reading this already gets the idea, and additional bickering won't provide much additional insight.
You can later refactor it into a struct. So far, most people do not write "correct" code at the first try because things change constantly. I see the readability benefit but not a huge productivity boost.
What word would you suggest instead? Ethnicity?
The problem is that I do not have respect for people who shows off their so-called "opinion" for the sake of being "morally" right There is no substance in belief that by oppressing majority you'll get diversity. Instead _we_ see white majority, which is consequence of developed world being cultivated by European culture, as something unnatural and evil. Society should develop naturally, not by the force of few vocal minorities
Imagine having a weird little bodily quirk (odd mole, etc) that you’re embarrassed by. Imagine if someone made fun of it every month or two. It might be a novel joke for each individual, but for you it would just be an endless stream of the same unfair criticism, over and over again, following you around everywhere you went. Imagine how tiring that would get. Even paper cuts become overwhelming if your job causes you to constantly get them day after day: that’s why people just move to other environments where paper cuts don’t happen. 
I'd love to work on Rust full time. (I don't know if I have the skills, but that's another story.) How can we get companies to sponsor this work? How can people willing to do the work get in touch with these companies?
I think the problem is ambiguity anyway, what if person_id is supposed to be an object but someone passes in a number or something. Nothing complains until some code tries to access a method.
Right now, short of talking to /u/aturon, I don't know. I can at most point people to other people, which doesn't get very far.
If you want to change something and see what breaks so you can update everything, you can just add an argument and watch the compiler complain about every caller location. If you're making a fundamental change to your function interface like that, you probably want to update every instance anyway in Rust due to the lack of function overloading. As far as type safety, naming a parameter does nothing to make sure it's the correct type. I could easily pass an integer to person_id not realizing it takes an object. Or if I decide to update the interface so it does take an object, but forget to fix a caller in some place, it won't complain until something tries to call a method at run time. It does make the code more clear, which means programmers are less likely to make mistakes, but I wouldn't go as far as saying that makes python code safer than rust code. That all being said, I'd definitely like named types to be a thing at some point. C++ should add them too while we're at it.
I'm continuing my Rust+C experiments, preparing to move some (initially) parts of a large C program to Rust. Since I'm proceeding bottom-up, last week I rewrote in Rust some of the low-level data structures; even if in the end they will be bindings to the C versions, this ensures that I have a Rust testsuite and a nice idiomatic veneer on top. It seems that, as long as I don't try to bluff linked lists, the borrow checker doesn't hate me too much.
AFAIK it is currently impossible to donate money to "Rust". The official answer of the past years has been "donate money to Mozilla" instead, sponsor particular people on their Patreon's, etc. Those are pretty bad answers. We should have a Rust foundation that pays for everything Rust related, and Mozilla could donate money to it, but it should be possible for individual and companies to donate money specifically for Rust, and the foundation should help that purpose by being fully transparent about how expensive the Rust project is and where does the money go.
You're right that doing proper Technics could probably prevent some of the errors, however your suggested path requires two different build. Often what happens is you change a parameter thinking you know exactly where it will break, and forget about the third place or you have function that takes func(person_id: usize, area_id: usize) in python I would just call func(person_id=.., area_id=..) thus ensuring it's correct and if someone decides to refactor the function no breaking happens. Overall this feature is just really great, and while I get more type errors in python I get way less logical bug due to this single feature.
This is something I would get behind, yes. I've heard some concerns that such a Foundation could run into issues with impartiality or something along those lines ("internal politics" comes to mind but I don't recall the details). But we should do *something*, and not go for another year without some kine of organization.
&gt;Ergo, we should either: &gt;- Require the same order whether using positional or named calling syntax OR - Not allow named arguments to be called with positional syntax I'd just like to point out that if the programmer decides to remove the names out of redundancy and causes the program to break, they're probably an intern and will learn quickly. I'm in favor of option three, allowing named arguments to be called with positional syntax and allowing them to be out of order. Also, it would be a bit confusing if optional arguments still had to be explicitly defined as default to maintain the order of the other arguments.
That seems better; I think it more clearly communicates that it's more about nationality than about some supposed biological category.
I'm messing around with structures, functions, and vectors. I currently have a student structure that has three attributes. String name, f32 grade, and i32 id. __________ struct Student { name: String, studentid: u32, grade: f32, } ___________ I also have a function, average() that is supposed to take in a vector of students, and return an average of all the student's grades. ___________ fn average (students:Vec&lt;Student&gt;)-&gt;f32 { let mut n=0.0; let mut t=0.0; for x in &amp;students { n=n+1.0; t=t+x.grade; } t/n } ___________ I *think* I wrote the average() function correctly - it compiles, at least - but I get an [error](https://media.discordapp.net/attachments/448238009733742612/522040596911882240/unknown.png) when I try to run it, saying the method isn't there. Could someone tell me why the method can't be detected, and how it can be fixed? (Here's the main function.) fn main() { let mut kids:Vec&lt;Student&gt;=Vec::new(); let mut s1= newStudent(String::from("Alice"), 101, 86.2); let mut s2 = newStudent(String::from("Bob"), 102, 1.0 ); let mut s3 = newStudent(String::from("Caleb"), 103, 2.0 ); //printstudent(&amp;s1); //printstudent(&amp;s2); //printstudent(&amp;s3); kids.push(s1); kids.push(s2); kids.push(s3); let mut s3:f32=kids.average(); //println("Average is {}", kids.average()); } 
One of the first questions is whether this introduces any parsing ambiguities, requires us to do a lot of look ahead in the parser, etc. 
&amp;#x200B; There is a lo of 404 since the new website. It will certainly be fixed in some days.
First, you are correct in thinking that lifetimes are not just a "trust me bro" thing - compiler will actually prevent you from using a reference in a struct that might outlive that reference. In your example `'z` is not saying "this is gonna live forever" either (that would be `'static`). Rather, `'z` establishes a relationship between `Company` and its `ceo` field - in this field you will only be able to store references that outlive the `Company` instance itself. I think [this SO question](https://stackoverflow.com/questions/31609137/why-are-explicit-lifetimes-needed-in-rust) sort of answers your questions on why you sometimes need to annotate the lifetimes explicitly. [The nomicon](https://doc.rust-lang.org/nomicon/lifetime-elision.html) gives some information about lifetime elision (i.e. situations where compilers allows you not to specify the lifetimes explicitly).
I'm not sure if my use of these words is correct, but I understood nationality to be a country of origin whereas ethnicity refers to a person's genetic background. So in most cases where "race" would be used, ethnicity would be more appropriate. I'll have to think about your criticism cause I generally think of race and ethnicity as synonymous, but perhaps they are not.
I'm not sure if Go qualifies as a systems programming language, but if so then it would certainly be up there.
https://github.com/rust-lang/www.rust-lang.org/issues/593: please add missing redirects to this.
&gt; What are the use cases you are trying to resolve with post-build scripts? I have a cargo subcommand, e.g., `cargo-foo`, that can be called as `cargo foo`, `cargo bar`, `cargo baz`. There are probably better ways of solving this problem, but a post build script would allow me to link `cargo-foo` to `cargo-bar` and `cargo-baz` easily to solve this. Currently, I just have `N` `[[bin]]` targets mapped to the same source file, so I just compile `N` identical binaries, which takes longer to compile, requires more disk space, etc.
&gt; Okay, but I still believe that using an underscore to denote 'find the damn thing yourself' is a little too unreasonable. The underscore is already used for type inference (e.g. `Vec&lt;_&gt;`).
This is the "future of rust" post I most agree with. 2019 for tech debt and architecture, 2020 for implementation and new features, 2021 for finishing and polishing the next edition.
I think he says you shouldn't use the name "id" when you have multiple kinds of IDs, because you could get confused.
I would love it if this line of reasoning where immediately abandoned. The reality - which I think should be obvious - is that its not necessary to explicitly reject people for them to be too uncomfortable to continue participating. When a group of people are largely similar to one another, it is very easy for them to develop norms of interaction which distance and alienate people who are not very similar to the group norm. Speaking frankly, I am a member of three Rust teams, I work for Mozilla Research assigned full time to Rust, and I often feel ill at ease at Rust meet ups, *even though no one intends harm*. I have almost entirely stopped participating in this subreddit, and there are other "Rust community spaces" that I find totally intolerable. And I'm not that different from the norm. It takes active and self-critical work to be empathetic and inclusive of people who are outliers, especially when that isn't necessary. It's not enough to not be an explicit, outright chauvinist. (I'm muting replies on this comment.)
[Read this](https://www.reddit.com/r/videos/comments/a1vk5i/z/eatv1dy)
I like swift syntax even better, arr.sort({$0&gt;$1})
Thread in one page: https://threadreaderapp.com/thread/1072444398284300289.html?refreshed=yes
I use failure, but only the `display` and `chain` generators on custom Error enums, and I do not expose generic `failure::Error` in library APIs. Example: #[derive(Debug, Fail)] pub enum Error { #[fail(display = "I/O error")] Io(#[cause] io::Error), #[fail(display = "Item not found")] NotFound, } Then I compose errors as per standard error handling. This makes it easy to go back to plain old Rust because all the failure does is generate Display impls :)
And it’ll be fixed in a few hours. I just woke up. (And couldn’t take care of it yesterday for Reasons.)
Come on... he is not asking about something really complex. In most languages (C++ and C included) doing exactly this task requires up to 20 minutes of research. My first program in Python didn't take even 5 minutes to write.
&gt; What are the use cases you are trying to resolve with post-build scripts? Summarising all use cases I have observed: - Post-process spat-out ELFs/PEs *(Custom sections, adding a digital signature, etc.)* - Make one compiled thing depend on the other *(e.g. `include_bytes!` a spat-out ELF to compile the next ELF)* - Package build artifacts *(wrap in a bootable ISO, PKGCONFIG stuff, etc.)*
Strong plus one. The primary reason why IntelliJ Rust can offer type-inference driven completion is not that it uses a different architecture than RLS, it is that it had a small (really small, 1.5 persons) team of people who were thinking about "how do we make code completion for Rust work", as opposed to "how do we pay the bills". Note that this is not really about making money: if you are lucky enough to be a programmer, you can always have a decent salary (at least, in my country). It is more about focus: to drive hard tasks to completion, you really need to be able to focus on them.
I think the `ResultExt` part of failure is incredibly useful. Instead of only being able to debug through stack traces when an error occurs, it allows looking at a list of causes that explain *why* an error occurred. Together with the `failure::Error` struct I think it paints a very compelling story that should work well for most uses. Note: In practice I rarely use custom `Error/ErrorKind` pairs. It's quite alright to hold off learning about this for a while, and using the `bail!()` and `ensure!()` macros instead.
&gt; Imagine if someone made fun of it every month or two If it is open mockery that I cannot tolerate I can either beat the living shit out of the guy or give up and accept being pathetic. Quite simple
Or perhaps, your colleagues could have a quiet word with the person in question and help them to act in a way that makes you happier without antagonising them in turn. This is what community and community-conduct is all about.
No, I phrased that badly. If Rust weren't safe, your app wouldn't crash. It'd continue running in some strange undefined state. It may not be a safety problem if your program doesn't handle sensitive data, but there are many people that want to use Rust for those kinds of things so the language needs to be able to accommodate that. In addition, even if your program doesn't directly handle that kind of data, it doesn't mean that you're OK doing unsafe things. Undefined behavior is, well, undefined; if you invoke it, the computer is technically allowed to do whatever it wants (the famous example being "making demons fly out of your nose.") In many cases this will simply be a crash, or maybe the computer will chug along with some slight glitches, but Rust's safety model is essentially designed to guard you from the computer doing these arbitrary things - your program being "safe" means it's well-defined.
This really highlights how rushed the changeover was. There is *never* any excuse for this sort of poor planning and implementation.
[Wiki says]: https://en.wikipedia.org/wiki/Ethnic_group &gt; An ethnic group or an ethnicity is a category of people who identify with each other based on similarities such as common ancestry, language, history, society, culture or nation. You may also want to read: https://en.wikipedia.org/wiki/Race_(human_categorization) In general, the word "race" has plenty of historical baggage that makes its use problematic; (see the sections on historical origin). [I found one section interesting:](https://en.wikipedia.org/wiki/Race_(human_categorization)#European_Union) &gt; The European Union uses the terms racial origin and ethnic origin synonymously in its documents and according to it "the use of the term 'racial origin' in this directive does not imply an acceptance of such racial theories". **Haney López warns that using "race" as a category within the law tends to legitimize its existence in the popular imagination. In the diverse geographic context of Europe, ethnicity and ethnic origin are arguably more resonant and are less encumbered by the ideological baggage associated with "race".** In European context, historical resonance of "race" underscores its problematic nature. In some states, it is strongly associated with laws promulgated by the Nazi and Fascist governments in Europe during the 1930s and 1940s. **Indeed, in 1996, the European Parliament adopted a resolution stating that "the term should therefore be avoided in all official texts".** &gt; &gt; The concept of racial origin relies on the notion that human beings can be separated into biologically distinct "races", an idea generally rejected by the scientific community. Since all human beings belong to the same species, the ECRI (European Commission against Racism and Intolerance) rejects theories based on the existence of different "races". However, in its Recommendation ECRI uses this term in order to ensure that those persons who are generally and erroneously perceived as belonging to "another race" are not excluded from the protection provided for by the legislation. The law claims to reject the existence of "race", yet penalize situations where someone is treated less favourably on this ground.
Also, funding official GUI toolkit should be ih there
Hey, I looked up the issue for you and pointed you to the right place to fix things. I'm not here as your punching bag, thanks.
Haha, glad to hear it! I'm not entirely sure what you mean -- Rust has no mechanism to do pre-emption, so your futures will always run until they can no longer make progress. That is, when `poll` is called on your `Future`, it will be allowed to run until it returns. No automatic switching will occur. Usually though, your future depends on some other future (like a `TcpStream`), and when you read from it, it might say `NotReady`, which makes your future also return `NotReady`. At that point, the event loop picks up another future to work on until progress can be made again on your future (i.e., when the `TcpStream` has data/capacity available). As for priority, this is something I know has been discussed in the past, but I don't know that we got much further. May be worth making an issue for it. The closest issues I found was a proposal to add futures that should be executed [when no other work is available](https://github.com/tokio-rs/tokio/issues/669), and one for adding support for [Hi/Lo classification](https://github.com/tokio-rs/tokio/issues/362).
Do you have an example how you compose errors?
I get this question [occasionally](https://twitter.com/lucarlig/status/1065471384237694979), and while I have one or two more beginner-friendly videos [like this one](https://www.youtube.com/watch?v=k6xR2kf9hlA), my content is generally aimed at intermediate/advanced Rust. This is intentional, as I believe there are already resources (both videos and otherwise) for learning more introductory material :) You may want to give https://hello-rust.show/ a visit!
I've worked on the compiler for a language that has this. A major advantage of this scheme is that it requires basically no changes to the grammar. Rust allows `_` in identifier position in lvalues, but not in identifier position in rvalues. To get this syntax, you just permit `_` in identifier position in rvalues (which usually just means removing the lint that forbids them) add a desugaring pass that transforms expressions containing `_`. 
Your previous post has 41 karma now. You were hardly downvoted into oblivion!
Who said I was upset with/yelling at you?
Is saving 5 bytes really worth it?
You used my comment to push your opinion on the planning and implementation. That's not the right place.
Was `try!(...)` vs `?` worth it? Saving exactly 5 bytes. &amp;#x200B;
&gt; Rust's community as a good reputation as a welcoming community. Maybe it has that reputation but personally I do not think it is very welcoming compared to other communities I have been involved in (e.g. Ruby or PostgreSQL). I feel it is often pretty hard to follow discussions in the Rust community because I get a strong feeling that the discussion has happened a long time ago in another medium. Commit messages are also often very sparse. (Not to single anyone out because this is far from the first time but a couple of days ago I was trying to figure out what [https://github.com/rust-lang/rust/pull/56312](Deduplicate literal -&gt; constant lowering) in This Week In Rust meant.) And if I who am used to open source development and other than not being an American is a pretty typical open source developer feel excluded I would guess the effect is even strong on minorities.
The reason to aim for diversity as a goal is that there is a significant amount of subtle to non subtle bias from homogeneous groups. Even when you feel your group is inclusive and progressive towards other demographics, there is so much you may not be understanding about another person's culture, gender or other aspects. This can range from * jokes that seem fairly light hearted that are offensive. As an Indian I've been asked dot or feather more times than I can bother or had jokes about curry etc . * You can have implicit hiring biases. Even if you don't try and hire, for example, white men aged 21-35, if that's your current groups makeup you're going to have people who will try and keep that setup. Read Amazon's AI based hiring failure storym * You can seen exclusionary even if you're not. Why would I join a group that has noone from my demographic when there are others that represent me better and I reduce the chance of feeling like an outsider? These are just some of the death by a thousand papercut scenarios of not having diversity that people miss. Of course it can be much worse. You could have someone in your group who is racist or bigoted but because it didn't relate to you, you may not pick it up or care because there's no harm. That quickly comes up if you have a wider range of people. And of course, diverse people give you more diverse opinions and predictives on everything. From product design to community outreach, there's a lot of wins and the presence of diversity leads to more diversity in turn. We all like to think we're more progressive than we are, but we fall short of that. Even if it's not you, it's someone else on the group that you may not realize. Therefore you need to make diversity a goal. That doesn't mean turn down better fitting candidates but use your best judgement and try and fight any implicit bias.
&gt;I'd love to work on Rust full time. (I don't know if I have the skills, but that's another story.) How can we get companies to sponsor this work? How can people willing to do the work get in touch with these companies? Seems to me the people most interested in rust (programmers with enough time to explore fringe languages) would have the skills to contribute \*directly\*, that's the nature of open source. An established organisation more likely has a source base and would fund tools around that (i.e 'write better static analysers for C++', 'pay for an IDE' etc) &amp;#x200B;
I've been using specs for quite a while now and I really enjoy it. I don't think it's a framework either. I am able to use it as my ECS *library* in a much bigger system of other libraries. My problems with specs have more to do with using specs storages outside of a System. There are all kinds of lifetime issues, for example: https://users.rust-lang.org/t/returning-iterator-of-specs-components/23012 I also find that the lack of any introspection abilities makes it difficult to build any debugging tools. In particular, it would be really cool to be able to somehow iterate through all the components on a given entity. Maybe even provide them as trait objects that can be downcasted. I know this is a hard problem, but it's definitely something to think about since currently specs can be very hard to debug. Thanks for such a cool crate!
What are you babbling about kiddo? This is a channel for rustaceans: "For everything related to the Rust programming language"
I started a web project and I choose rust as backend, a bit of learning curve but so far happy, for me is as good as doing backends in Java
I would say yes, especially when two of these five bytes are `|` which are annoying to type on some keyboards.
I've published v0.2.0 which now includes error handling in the same fashion as was described by you.
Thanks for sharing! To help me better understand the needs here, why do you want your bin to have multiple aliases rather than having a bin built per alias? I've seen this pattern in some binutil cases (can't remember the reason why) and also with some programs changing the default flags (`cc` vs `gcc`). I also assume you want this in a post-build script so it works with `cargo install` since you are living in the space where your users are more likely to install that way (assuming these cargo subcommands are for users and not CIs).
Weird, all of a sudden it went up. I wish Rust had something like this, but I don't know the right way to implement it. It is just this particular use case that's the 99% that I care about. I don't know about whether the extra complexity that follows from e.g. unnamed structs etc. is worth adding the language, and in that perspective I agree with most of the position held by /u/Sinistersnare. Most APIs would use structs, so it's mostly on the application side and within a development process that named arguments are useful. It is not an easy decision. Or, it might be that API design would evolve further with named arguments, I don't know. Could probably have a period of experimentation with Rust nightly. However, I think named arguments are so useful that's on the top of my list. If only those complex topics could be sorted out so we could e.g. decide either 1) add something like unnamed structs or 2) decide to *not* add unnamed structs, then we could add named arguments another way. This is just an example of a decision, I have not made up my mind about unnamed structs yet. In the meantime, I will use this macro and if not anything else, maybe we could stabilize `concat_ident` so that the macro works on stable.
&gt;First, you are correct in thinking that lifetimes are not just a "trust me bro" thing - compiler will actually prevent you from using a reference in a struct that might outlive that reference. Thanks for clearing this up. This way it already makes more sense. Even though I still don't quite understand why the compiler can't just do it automatically. Like it does everything else. But that's OK for now. Once I'm more into the subject I'm sure I'll figure it out myself! Just one last question regarding this: &gt;In your example 'z is not saying "this is gonna live forever" either (that would be 'static). When would I ever use `'static` over `'z`? If the element already lives long (meaning longer than some other element) enough, then why does it matter if it lives forever or not? As long as the Person "boss" outlasts the Company "tesla" everything is fine. Why would Person "boss" need to live for ever? Or in other words: Why would I need to make sure it lives forever? Isn't "equally long or longer" already enough? I hope this makes sense :-)
I'd recommend using[`str::lines`](https://doc.rust-lang.org/stable/std/primitive.str.html#method.lines) over splitting on `\n`.
Alright that makes sense. I'm not sure I understood this 100%, but for now I understand enough to appreciate what Rust is doing. That's what I really care about. Thanks for taking time and explaining it!!
In my opinion the current syntax is perfect and such simplifactions will produce ambiguity
Hm, yeah, I guess so - I didn't thought about it this way;
&gt; Fortunately or unfortunately this has put Cargo on the slippery slope to becoming a build system, and I think the Cargo team doesn't want to go the route of supporting anything remotely declarative other than what is minimally necessary to build single binaries. Also talking without authority, I wonder how much of it also related to being an open build system vs a closed build system (just made up these terms). At $DAYJOB, we have a closed build system. One build command will create final artifacts for all platforms. If you want anything different, you need to modify the package's configuration for the framework, the build steps, or modify the framework itself. In contrast, cargo is what I'm calling an open build system. A crate only specifies an artifact type (which might not be a final artifact as this thread has shown) and some slight customization of behavior per target triplet. Other than that, the caller decides - which target triplets are actually being built - what features are enabled - what post-processing is needed for the given target triplet The advantage of a closed build system is it is trivial for anyone to get the final artifact. The nice thing about a "low level" open build system is you are not as constrained to what the original author created. &gt; The only reason we have pre-build scripts is that FFI would be impossible. I'm curious if it was originally for a backdoor solution for FFI or for code-gen and then got reused for the other.
To piggy back off this, there are other approaches (via macros) to allow named args in rust: * [https://crates.io/crates/rubber\_duck](https://crates.io/crates/rubber_duck) (that's mine - proc macro that derives a macro with the same name as the function - allows for default args as well ) * [https://github.com/comex/namedarg](https://github.com/comex/namedarg) (a decl macro that allows things inside to use named arg syntax - I'm not super familiar with it). Mine (rubber\_duck) tries to take it as far as possible, so it requires nightly (generating macros from macros...), though there are other approaches I want to explore eventually.
&gt; And I think that, regardless of how innocent your motivations are, your line of questioning is likely to strike a nerve. For more than a year now, people with a genuine need for this feature have been asking for it and been asked (and re-asked, and re-asked) questions like the ones you're asking. Two interesting observations from this. 1. I've been involved in Rust and the community for 2 years and I've never seen this come up. I did not realize how tired people might be of questions. This goes to show that the community has gotten large enough that it is hard to track everything. This is good sign of growth but comes with downsides. 2. I'm looking forward to a new RFC process where it will hopefully be easier to summarize conversations rather than people either being overwhelmed with the backlog of conversation and not getting involved, taking the man hours to catch up on the backlog and integrating the information (since not all of it will still be relevant) so they can participate, or skimming to find relevant information and jumping in (what I did).
Thanks for posting these links. I also think it's easier to discuss this with some libraries to test with.
My wish for 2019 is to have these kinds of threads either stop, or be in one place.
I searched through my own projects and could not find a single instance of using a `&amp; 'static T` as a struct field. You will most likely encounter another pattern that looks like `T + 'static` [in the context of trait objects](https://stackoverflow.com/questions/48017290/what-does-boxfn-send-static-mean-in-rust).
Easier to read is subjective (or rather it may be made objective by doing a study on how fast beginners, vs. experienced users can read it and how many errors they make when interpreting it). `_ &gt; _` doesn't feel a lot easier to read to me than `|a, b| a &gt; b`
Very good. That means that I understood that concept. Thanks for your help. I'll come back to this post when I'm ready to experiment with trait objects. Doesn't look like a lot of fun though. traits + generics + lifetimes. Sounds like an enormous mess of complication. Haha.
But I didn't disagree or agree that it is replacement. I disagreed that it adds overhead and decreases readability. With From, Deref, AsRef, new types are almost transparent, that's why I disagreed. BTW. Personally I don't see the need of named arguments in any language. 
That's a valid concern. Supporting that can be a lot more work I guess, but definitely worth the effort 👍. Thanks for the feedback!
I just wish the language would take advantage of the fresh syntax space to offer real named arguments/defaults
Thanks for the feedback! I've never heard of \*record-query\* before. I'll try to update the readme in order to make it more clear.
Let's make 2019, the year of Rust. Some of you might not agree with me, but. We have a competitor, Golang! I don't know about future plans of them but according to current discussions we will not get much more things in Go2. Don't tell that there should not be any competition between languages. Mostly people spend their time on Rust because they love the language, features and community. But still business or PMs give more priority to Go than Rust, mainly because of maturity of Go ecosystem with products like Docker, Kubernates stabilize cloud native architecture and etc. If we get more time stabilize Rust ecosystem, we might betray our users who spends their time, effort to learn and contribute Rust My point is in 2019, we should give more priority to stabilize Rust ecosystem and make Rust everyone's language, not only for systems programmers. We should attract everyone, as soon as we can.
No. `?` was saving much more than 5 bytes. Compare: 
Yes, and assuming that a lot of web services are purely IO bound it would be the case for a lot of web services. If I need to handle say 1000 concurrent requests which might equate to 10000 req/sec given RTT of the request from the client to the server is quite slow. I would need to spawn 1000 threads in a rocket app to handle that. Versus a node app I imagine can easily handle 1000 concurrent connections. Not sure how resource usage scales in rust with number of threads?
You're right. I won't compare **jql** in any way to **rq.** The latter is definitely way more powerful and it's API is definitely super advanced. I'm trying to keep **jql** simple, efficient and to find a niche for it in this whole ecosystem.
I'm not sure this is a good way of thinking. Sometimes experienced programmers can mindlessly change `x: x` to `x` because they are used to doing this in structs already. Saying that "they're probably an intern" is very dismissive of real mistakes that even very experienced programmers make, which includes forgetting to free memory.
 fn main() { let mut name: String; name = String::from("Jeff"); println!("{}", name); name = "Jenny".into(); println!("{}", name); name = "Josh".to_owned(); println!("{}", name); name = "Jacky".to_string(); println!("{}", name); } Why are there so many ways to create Strings? The ones I listed are just the ones I came across so far. I'm not so concernced about the exact details of each line, but what I'd like to know is: Does it matter what I use? My current understanding is something like: "Hmmm OK it seems they all create Strings, I don't know the back story to each, but if they all create Strings it won't really matter to me right now anyway." FYI: I always just use `String::from("newstring")` &amp;#x200B; &amp;#x200B;
Is anything wrong with using `funcall(Color { red: 128, blue: 100, green: 255 })`? The only thing we don't get is processing inside `new` but are there legitimate use-cases for that?
Is language English or Chinese? If English, I would love to come, from Vietnam. Also please consider Singapore as well.
I can't remember the name of this macro style, but I wonder if `?` would have been stabilized if macros in the style `result.try!()` had come through the pipeline.
The major thing is that you need to define the struct; import the struct unqualified which then also can't share a new with the actual thing you get something like `ColourArgument` or something like that and that you still don't have anonymous structs which are in general useful.
`_ &gt; _` looks like a flipped face. More emoji-driving development features we need.
Can you implement it with language instead of adding new lang feature? Like `boost::phoenix`.
It's not the 5 characters that `try!` aims to save. Consider this: foo()?.bar()?.baz()?.qux()? vs this: try!(try!(try!(try!(foo()).bar()).baz()).qux()) &amp;#x200B;
Heh, I'll meet your bunker and raise you a `serde` -- that's some seriously OP stuff right thar. Just so you know, this is the [Rust programming language](https://www.rust-lang.org/) subreddit. Rust the game is over at /r/playrust -- but you're welcome to stick around! We love helping new people. :)
Thank you for taking the time to write this well thought out explanation. I'd love to see yours and others points captured in a living document so we can continue to iterate on it rather than it being lost to time or being yet another link in a long discussion people have to read to catch up on all of this. &gt; Simplify IDE/Text Editor Integration through Cargo.toml This is an interesting case I hadn't thought of. If you are writing Rust in a target-specific IDE (game console, Android, etc), what integration do we need so the IDEs "compile check", "build", and "deploy" commands will do the right thing, especially when steps are needed beyond what cargo currently supports. An IDE-specific solution would hurt you in supporting people outside the IDE / your CI while on the other hand an IDE would not support arbitrary third party CLI solutions. &gt; Third party subcommands are an unacceptable workaround. &gt; &gt; - Requiring them to target embedded is just as bad as in C, and it's an arrow in the knee to adoption. I get that's not the most convincing argument. &gt; cargo ___ would not be the most acceptable solution. Post-build steps are a part of the build process, and cargo build should reflect that. Adding more semantics to cargo just makes learning Rust more difficult. One benefit for external subcommands vs built-in (talking of specific use cases and not `just` or `cargo-make`) is the ability to evolve with ever changing ecosystems. Being baked in requires issues and/or RFCs, going through the release train to stable, everyone upgrading to the latest stable, and maintaining compatibility somehow even if the new stuff conflicts. Some challenges with generic solutions (`just` and `cargo-make`) are (1) cross-platform support and (2) giving people enough power which leads into implementing the logic in Rust. Speaking of the logic being in Rust, I would be curious to see what a prototype of post-build would look like, a `cargo-postbuild` that performs `cargo build` and fulfills the proposed contract with a `postbuild.rs` that it compiles. If anyone decides to go for it, [my cargo API](https://github.com/crate-ci/escargot/) might be helpful. Tying into my other reply about [open vs closed build systems](https://www.reddit.com/r/rust/comments/a4ygji/lokathors_rust_2019_wishpost/ebkh3r0/), there are some crates people create that can only be used for their one target. `postbuild.rs` would work fine for them. Others can be used for multiple. It seems like baking the logic into `postbuild.rs` might constrain your crate to the one use case, limiting its use. Sorry if this covered elsewhere, I've looked at the [RFC but only skimmed the threads](https://www.reddit.com/r/rust/comments/a4ygji/lokathors_rust_2019_wishpost/ebkhn7x/). &gt; Post-build steps are a part of the build process &gt; ... &gt; Cargo is officially a build system. I don't really think this is a problem, since Cargo is a build system already. It's just lacking in features that make it usable. &gt; ... an explanation of why they don't want Cargo to become the build system de jure. Just like there are multiple definitions of "package management" (which confuses people about why Rust needs a *build* package system when Linux distributions have an *installation* package system), I suspect there are multiple definitions or layers to the term "build system" and depending on what direction you come from, you expect something different. For me, I look at `cargo` as a tool specialized for Rust with minimal additional policy that you'd then tie together in a larger orchestration system. I'm mixed about all-in-one solutions. I've seen one try and fail at being all inclusive. It falls short in features but by being so powerful and pervasive it is hard to evolve. On the other hand, I fully admit I've not used some of the specialized tools people have with their fancy new systems to deploy to that make everything trivial. &gt; At the end of the day, I'd be happy with acknowledgement from the Cargo team that these are real problems, and an explanation of why they don't want Cargo to become the build system de jure. Similarly, I'd also love to get an official statement posted somewhere, so as not to get lost, on the goal of `cargo install` to help reduce the confusion on what all problems it is meant to solve or not (e.g. post-install steps, cached builds, etc). It gets discussed in threads and we, the community, talk of our interpretations but more could be done to reduce the re-hashing.
nrc mentioned in his [blog post](https://www.ncameron.org/blog/rust-in-2022/) that there were some ideas they could take from Swift.
Others already explained the problem, so I'm just going to suggest a more efficient solution: use std::{io, fs}; use std::io::{BufRead, BufWriter, Write}; let old_file = fs::File::open("filename.txt").expect("Could not read file"); let new_file = fs::File::create("output_file.txt").expect("Failed to create file"); let mut buffered_out = BufWriter::new(new_file); let buffered = io::BufReader::new(old_file); buffered.lines().map(|line_res| line_res.and_then(|line| buffered_out.write_all(line.replace("String_1", "String_2").as_bytes()))).collect::&lt;Result&lt;(), _&gt;&gt;().expect("IO failed"); This contains several optimizations: * It doesn't attempt to read whole file into memory, preventing exhausting of memory for files &gt; RAM size (A file containing a line that is bigger than size of RAM is still a problem though) * Doesn't allocate output vector * Buffers writes * Bypasses `write!()` machinery Unfortunately, there's a misoptimization that causes it to allocate for each line, possibly several times. This can't be solved at least until Rust gets associated generic types. :(
`String::from` is my go-to as well, due to clarity. These methods are all from different traits. `String` can be created "from" a variety of different things, including a `&amp;str` (`From` trait). A `&amp;str` can be made "into" many things, including a `String` (`Into` trait, opposite of From trait). The "owned" version of a `&amp;str` is a `String` (`ToOwned` trait). The way you convert a `&amp;str` to be shown as a `String` is just by making it a `String` (`Display` trait). Having all these different trait implementations allows you to do things generically, like how you can `println!("{}", "Jenny")` because `&amp;str` implements `Display`.
These are really good points. Github is great for small teams/communities, but a lot of its features don't scale up very well. The lack of threading in discussions in issues/PRs and such means it's very easy for conversations to get derailed by a specific subtopic. They did add the ability to add non-comment emojis, but the Rust team has insisted that those are meaningless and requires people to comment if they want to register an opinion. Rust internals is somewhat better, since it at least allows you to see a parent's child comments, but it still doesn't give you the ability to collapse a thread you're not interested in. The RFC process, too, is showing signs of stress. It, in effect, creates an unhealthy balance of product managers to developers, since it allows anyone interested in putting in the work to play what is essentially the a PM's role while not requiring them to put in the accompanying time building the feature. The result is as you'd expect, new feature ideas come in a mile a minute and a pretty major product backlog develops of features waiting to be implemented. Worse yet, if you're someone like me (and, I suspect, you), who tries to follow the project at a distance and doesn't have the time to pursue it as a full-time job, it can be quite maddening as so many different directions the language can go are being publicly discussed simultaneously. I know the core team is responsible for keeping the language coherent (no pun intended) and more or less ensures that what actually gets released doesn't reflect the chaos of what gets proposed, but that doesn't really help people who like to watch or be involved in the pre-implementation discussions. If I were writing one of these 2019 posts, my focus would be on this imbalance between the ease of suggesting new features and the difficulty of implementing them. It needs to be harder to volunteer as a PM and easier to volunteer as a developer. To their credit, the core team has put in a ton of outreach into encouraging people to contribute to the compiler/language. Much more is needed, but that's probably mostly due to the nature of a rapidly-changing piece of software as complex as the Rust compiler. But I haven't seen focus on the RFC process and its scalability issues. And I think that Rust in 2019 should focus on reforming that process to reflect the growing number of people that want to participate. I think if I were making changes, I'd make the pre-RFC stage mandatory and then require the core project team's approval to move on to the RFC stage. That would keep the openness of the RFC process, but limit the volume of discussions on candidate features. I'd also move those discussions to something more scalable (perhaps a new subreddit limited to just RFC discussions) and embrace voting as a way to offer an opinion. There's lots of smart people in the Rust community and, in many RFC discussions, they express my opinion better than I ever could. So why not let me say, "I agree" by upvoting their comment? But I just watch most of this from the sidelines and despite the perceived problems, I feel what actually gets released every 6 weeks is excellent, so maybe I'm not seeing the full picture. 
Aaron Turon has a good explanation of the problems that need to be solved with regard to giving Rust more money at [this point in his RustFest Rome 2018 talk](https://youtu.be/0sIgVnRAcn0?t=841).
Beautiful. That answered all my questions/thoughts about this. Thanks! I'm not that deep into traits yet, but once I am I'll come back to this topic and see if I understand where each "way" comes from.
I want to contribute more, I'd like 2019 to be the year it became even easier for new contributors.
There's little benefit to named arguments if you don't know how they're used in the called code. We're talking about investing in human resources to solve a code comprehension issue and the proposed solution arguably doesn't solve much. Haskell has an issue where the community is too deeply invested in language design and abstraction that they've failed to build proper tooling within a reasonable timeframe. A language should be easy use without tooling, but it should be even easier with tooling. Even if there's no sharing of human resources between language design and tooling there are plenty of other language improvements that are more valuable than named arguments. 
I experienced the same frustration when learning Rust. "Ugggghghgh, &lt;insert-seemingly-simple-task-here&gt; _should_ be easy. Why is it so hard?" I think when newcomers to the language have these frustrations, it would be more helpful to teach them how to think differently and solve the problem Rust's way, instead of just telling them what they already know (that they are frustrated). One of Rust's biggest strengths (in my mind) is that it actually borrows a **lot** from functional languages. Confusingly to newcomers, it is hiding this in a C-like syntax. Look at the top comment in this thread. It makes liberal use of `map`, and then to muddy the waters for the uninitiated, what are `collect`/`unwrap`? These are very powerful concepts, and one of the biggest reasons that I love Rust, but we need to do a better job of educating newcomers, in my humble opinion.
It is in Slovakia. The nicest gift I got. :)
Could the `?` operator be used to emulate encapsulation of side effects, a la monad? It seems to have a similar structure.
Last summer, there was talk of a new RFC process but I think it was put on hold so they could continue focusing on the RFCs in flight for 2018 edition. steveklabnik1 has said [his 2019 post will be about this](https://www.reddit.com/r/rust/comments/a4ez4y/llogiq_on_stuff_rust_2019_the_road_ahead/ebelmqz/?context=0&amp;st=jpk0lncj&amp;sh=d79064ce).
It's important to be able to write new zero-cost abstractions. I just worry that people don't really understand how complex upholding the invariants is. The last survey showed people think the borrow checker is way harder than unsafe. Maybe there needs to be more warnings in the book about how hard unsafe is.
You need to indent the code by 4 spaces so it is recognized as code.
Sure: https://nercury.github.io/rust/opengl/tutorial/2018/02/15/opengl-in-rust-from-scratch-08-failure.html
You want to make a 3d survival game. I think your language decision should revolve more around the tooling around gamedev for that language. If you choose Rust you'll have to write your own 3d engine, level editor, etc which is kind of a waste of time in the era of Unity and Unreal Engine. If you're set on making that type of game and you're just a solo developer, I don't recommend Rust. There's far too much engine-level work you'll need to do. If you're open to a simpler game or just really want the learning experience of doing lower-level engine work, go for it.
People who constantly complain about virtue signaling are just signaling to others that they are somehow above it all. They're doing the exact same thing they're complaining about. They just have a different idea of what is good, and they're unable to detect irony.
For combinators (especially for futures with many and\_then's) that could be potentially quite useful. Consider this example (a snippet to find dynamic library in the same folder as main exe): `env::current_exe().ok().and_then(|p| p.parent().map(|p| p.join(&amp;dll)).filter(|p| p.exists()))` vs `env::current_exe().ok().and_then(_.parent().map(_.join(&amp;dll)).filter(_.exists()))` &amp;#x200B;
Last chapter of the article: &gt; **Compiler** &gt; Nothing really new here, but we need to keep pushing on compiler performance - it comes up again and again as a Rust negative. We should also take the timing opportunity to do some refactoring, for example, landing Chalk and doing something similar for name resolution.
Maybe I'm understanding you wrong but you should probably just generate and host your documentation yourself.
As a moderator, I would kindly invite you to report said names, privately, to the moderating team. You can either PM me, or send an e-mail to rust-mods@rust-lang.org
First, well done Fastly with what you've done here. Love it. What do I like? And this is my issue with the Rust team and WebAssembly, btw. The fact that I can write Rust for WA and consume via Rust, not JS, Rust. The Rust/WA team continues to cater mainly to the Javascript community do to size, etc.. But we, the Rust developers are the ones making the function/app available via WA in the first place. Wouldn't it make sense for such a developer to test it and use it with the same language it was developed? Apparently not. So a company - Fastly in this case - has to do what should've happened by the rust crate in to begin with "Rust language programs are compiled to WebAssembly using the wasm32-unknown-unknown target as a library crate that exports a run function." And that's from the Fastly docs. That function is a rust function. Well done Fastly. @rustwasm team, watch and learn and don't make Rust a second class citizen for WA consumption. 
I don't think you can really have 1.0 until you have async/await.
&gt; but that's not how humans actually operate It's how interaction *through text over the internet* operates. Do you know my skin color or my sex, without going through my comments where I've explicitly mentioned those? No, you don't. Nobody is pushed to show their face. Meritocracy necessitates anonymity, but over the internet we're *anonymous by default*. 
Have you considered implementing [std::default::Default](https://doc.rust-lang.org/std/default/trait.Default.html) for your struct?
&gt; Imagine how this feels to a woman, or a black person, or a transgender person. Every time someone even tangentially mentions improving the quality of their lives, a white guy shows up and loudly proclaims how unfair it is that people are giving special treatment to others and that all that should matter is his self-perceived merit, and a horde of other white guys show up to cheer him on. 
Is &amp;[i32] a reference to an array or a Vec? Seems like it could work for both, but that would probably not be allowed. So which of the two is it?
It could be either.
&gt; Not sure if that's a bug or not. It's not; they have to compile your code, and since your binaries are up to date, they don't recompile them. 
I think forgetting to free memory is a much easier mistake to make, since you would have to deliberately remove something that was already there in order to cause this problem. I wasn't aware programmers change x: x to x in structs though, so that's a good point. Either way, I still think the ability to leave out parameters and get default values is nice in other languages
I want to generate and host my own documentation for the internal packages, but link to [docs.rs](https://docs.rs) for open-source packages.
https://github.com/rust-lang/www.rust-lang.org/issues/291
I think people choosing Go vs. Rust is blown way out of proportion. Go might have at one point marketed itself as a systems level language, but I don't think many people seriously think of it that way. It's also not particularly type-safe, uses a GC, and generally has a fundamentally different outlook on almost everything. You might as well pick Java or something. Why make this competitive? We're all "on the same team", or at least we're not on different teams. Let's just make the world better one Rust library at a time.
&gt; You can seen exclusionary even if you're not. Why would I join a group that has noone from my demographic when there are others that represent me better and I reduce the chance of feeling like an outsider? This. Even if you *are* perfectly free of bias when conducting interviews, do remember that interviews go both ways: the interviewee is getting an impression of the organization/company. As a woman, would you prefer (1) being the trail-blazer in an all-men team or (2) doing your job in a mixed-gender team? I imagine the first can be rewarding. It could also be frustrating, you could feel quite lonely, etc... all things being equal, is the risk really worth it? The simple fact of NOT being diverse is already repelling under-represented people. Just stating "we're open" is a good start, I fear it's not enough. 
To simplify things, it should be a completely separate 3rd party, The Random Foundation, that has nothing to do with Mozilla or the core people. A separate entity that people are supposed to trust and donate money to. They can decide to sponsor people to work on Rust full time but it is the internal decision of the foundation. I think we should not mix things.
If it was just one or two structs I would do this, but there will be many with similar logic.
Another practical example: &amp;#x200B; let table = self.config_file.as_ref().and_then(|config_file| { fs::read(config_file).ok().and_then(|data| { toml::from_slice::&lt;toml::Value&gt;(&amp;data) .ok() .and_then(|config| config.get("core").and_then(|v| v.as_table()).cloned()) }) }); vs let table = self.config_file.as_ref().and_then( fs::read(_).ok().and_then( toml::from_slice::&lt;toml::Value&gt;(&amp;_) .ok() .and_then(_.get("section").and_then(_.as_table()).cloned())) ); &amp;#x200B;
I'm a chinese developer in Beijing and I want to attend any Rust conference in China. Hoping this conference will come true.
Thanks for your reply. Isn’t that problematic? If the compiler doesn’t know what to expect? Strict typing is always listed as one of the „strengths“ of Rust. 
I mentioned it in another thread, but to summarize GAT is blocked on Chalk being finished. Chalk is the refactoring trait system project. I'm thinking getting Chalk done will un-block many improvements, but go through along stabilization process.
I really like Kotlin's syntax for handling closures with only one parameter. e.g. `(x) -&gt; x.method()` becomes `it.method()`. Not exactly the same as what you're saying, but this is at least one aspect of closure syntax that could be simplified a little.
This is borrowed from Groovy I believe.
`&amp;[i32]` is a [slice](https://doc.rust-lang.org/book/ch04-03-slices.html). Slice itself is neither an array, nor a `Vec`, but rather a "fat pointer" that points to the array or the underlying buffer of a `Vec` and additionally includes the length of that storage (amount of elements in it). If you have a function that takes `&amp;[T]`, you can pass it a `&amp;Vec&lt;T&gt;`. Why? It is magical, but it's not *that* magical. `Vec&lt;T&gt;` implements `Deref&lt;Target=[T]&gt;` and [deref coercions](https://doc.rust-lang.org/book/ch15-02-deref.html) make this deref process automatic when you pass a `&amp;Vec&lt;T&gt;` into a function that expects a `&amp;[T]`. This is not ambiguous as really, the slice does not care whether it's backing storage is an array, or a `Vec`. It has a limited API surface which works with whatever is underneath. If these few operations of a slice (`get()`, `len()`, indexing) are enough for you, you can just use a `&amp;[T]` and you will automagically be generic (using this word loosely) over both arrays and vectors. If you want to call `capacity()`, however, you will need a *real* `&amp;Vec&lt;T&gt;` and if you want to `push()` you will need `&amp;mut Vec&lt;T&gt;`.
https://blog.rust-lang.org/feed.xml should resolve now. Can you give this a try and file bugs if it doesn't work? Thank you!
&gt; I feel it is often pretty hard to follow discussions in the Rust community because I get a strong feeling that the discussion has happened a long time ago in another medium. Yes, this is a great way to describe it. There definitely have been events in the last year that made me feel that community feedback doesn't really matter as the decision was already made in private conversations somewhere. A few times I've seen those discussions shut down very quickly. This isn't a good look. Ultimately I'm trusting the core team to make decisions about the future of the language, and those decisions could either continue to improve it or force it down a path of obsolescence. It's a tough job because whether they are good or bad all of those decisions are likely to be questioned. There has to be space for that. Decision making has to be in the open, and criticism has to be allowed to happen. I am certain that the team is trying to do this already, and most of the time it's working. But a few times it feels a bit like things went off the rails, emotions run high, and key decision-makers start shutting down discussion. These are the times when the process really needs to work, and it's a different side of the "welcoming community" coin than we normally hear about.
&gt; Once the changes to the Error trait in std land Didn't they already? If not, which tracking issue do I subscribe to? Thank you!
[derive-new](https://crates.io/crates/derive-new) offers at least some of what you want. [smart-default](https://crates.io/crates/smart-default) allows similar control over `Default::default`.
None of that means anything is loosely typed. Arrays are arrays, vectors are vectors, slices are slices. That a slice can point to either isn't a problem, really, it's one of the points of slices in the first place.
&gt; I would love it if this line of reasoning were immediately abandoned. So, you want to be inclusive and open, or do you want to ban certain opinions from discourse? Because you can't have both. &gt; The reality - which I think should be obvious - is that its not necessary to explicitly reject people for them to be too uncomfortable to continue participating. The reality is that if people don't accept themselves and act insecure, they can't be helped, no matter how inclusive an environment is. Once you start ignoring the looks, words, jokes, laughs, ... and just be yourself, without holding back, your environment will react differently - more positive. You can't fix other people's insecurities, and you won't do them a favor if you try. They have to make the first step, which may be hard, but necessary. At least that's my personal experience and my opinion. I've been that insecure person, and sometimes still am.
That make sense. Thanks for clarifying! :-)
PureScript has this underscore syntax, too, and sometimes I also wish for it in Rust, but semantics should be more important, e.g. allowing generic closures like `for&lt;/*bounds*/&gt;|/*args*/| /*body*/`. 
That make sense. Thanks for clarifying! :-)
Any time!
Maybe check [this out](https://rust-lang-nursery.github.io/api-guidelines/documentation.html#crate-sets-html_root_url-attribute-c-html-root). May or may not be related to your question.
I use both heavily, also `getset` for generating getters/setters and `delegatemethod` for delegation to members. 
The README is empty here https://crates.io/crates/underscore_args, and I did not understand what is this crate about after looking at https://github.com/PistonDevelopers/underscore_args for 15 seconds. Not a big deal, but just feedback. Might be worth to improve this, if you hope to attract more users.
This crate looks good, but doesn't meet my needs exactly. With `derive-new` it looks like I'd have to do something like this: #[derive(new)] struct Foo { #[new(value = "bool_field_from_some_dynamic_criteria()")] x: bool, #[new(value = "i32_field_from_some_dynamic_criteria()")] y: i32, #[new(value = "string_vec_field_from_some_dynamic_criteria()")] z: Vec&lt;String&gt;, } Basically the idea is that almost every field on these structs will be 100% dynamic depending on some application state and not predictable by the caller. I also want to also add some custom attributes to optionally fulfill the `some_dynamic_criteria` portion of this code. This would act more as hints for the application to skew the data in some way.
I think this is actually a good example of ambiguity. Given only the latter code, how do you go back to the former? For example, does `from_slice(&amp;_)` become `from_slice(|x| &amp;x)`? Why not?
&gt; I think you're not fully appreciating how difficult what you're proposing is Actually, I do. It's insanely hard. But in my experience it's the only way to make others adjust their behaviour. &gt; It's inconsiderate and unrealistic to tell someone who constantly hears jokes at their expense that they are the ones who should stand up and be the ones to change things. I disagree. It's inconsiderate to assume you can speak on the behalf of others. How would anyone even know that they offended someone unless the „victim“ says so? What's unrealistic is to assume you can make any community work unless people speak up if they feel they're not being treated well. Everyone is different, and nobody can read minds.
You don't go back, if there is an ambiguity compiler throws an error. I mean, if from_slice also accepts closures you won't be allowed to use placeholders. 
I have personally witnessed at work a team choosing go instead of rust because "it's easier".
&gt;Better resource management: I'd like to co-sign / second this. Link rot has seriously been, and continues to be a massive problem when working in `rust`. So many documents tell me to read a different document, that end up not existing. For example googling, "_Rust Reference_" returns [this](https://doc.rust-lang.org/reference.html) which links [here](https://doc.rust-lang.org/reference/index.html) which immediately states in 2 different places in **BRIGHT RED TEXT** this document is likely out of date and possibly incorrect. I understand you want to make clear the reference is a WIP, but the experience is that I went from a doc that doesn't exist, to one that is out of date. 
Sounds like a cool self-contained project for hacking on rustc.
This is an interesting view on what 'welcoming' means, thank you! I think this is exactly the kind of thing we should be thinking more about next year.
Yes! I'm also a fan of Failure. It falls into both the 'revisiting std' and 'error handling' categories from my post.
&gt; why do you want your bin to have multiple aliases Because of the way cargo subcommands work. `cargo foo` searches `cargo/bin` for a `cargo-foo` binary, and then passes it `foo` as its first argument. That is, if you have a cargo subcommand that reuses 99% of the code with another, e.g., `cargo foo` and `cargo bar`, then you are often better off creating a single binary that has all the functionality, and just does one thing or the other depending on whether the first argument to the command is `foo` or `bar`. 
I notice that the \`reqwest\` package has this defined, and that seems to make it automatically work for this use case. Maybe cargo doc could accept an option to assume [docs.rs](https://docs.rs) as the base url if there is not one set?
I read "optional arguments" and I didn't release that was synonymous with function overloading/ad hoc polymorphism. I get that jargon isn't any better but still, it's so tough to keep up with what Rust people are even talking about. Maybe in Rust 2019 we can address the jargon problem. 
Looks like [this issue](https://github.com/rust-lang/rust/issues/42301) is what I really want to land.
It pains me that out of more than a hundred lines of blog post, this is the line that has the most comments on Reddit. &amp;#x200B; Perhaps I should rephrase. That everyone should be able to participate equally regardless of their identity seems like a really obvious goal to me, even if only from the perspective of maximising the number of Rust users. Assuming that there is no direct correlation between identity and ability at Rust programming (and as far as I know there is no such evidence, and pretty much every reputable study has shown the opposite), we should expect the Rust community to reflect the general population. Given that it does not, that shows that something in our project and community is sub-optimal and should be fixed. I.e., when I talk about improving diversity I am not talking about adding artificial incentives, but removing them.
And that's another problem too - stuff missing from later editions of the book and the reference. 
Oh! And the Unstable Book needs to be cleaned up, and more information provided when linked RFCs are less than clear. 
What about Open Collective? [https://opencollective.com/](https://opencollective.com/) It’s heavily used by Webpack or VueJS. I think it could be a good fit. 
&gt; Proc-Macro documentation needs to be significantly expanded. For example the nightly docs mention three types of proc-macros, but only talks about two with very shallow examples. I think this will only get better over time, now that it is in stable. A lot of nightly-only features get not-enough documentation because it has to be kept in sync with the feature, which many times evolves over time, sometimes significantly. Taking the time to document these features only for the feature to change can be demoralizing for the people doing the work. &gt; Better resource management: Not the technical definition of "resources" but the human version. On github, there's a lot of open issues, several of which when I investigated are no longer valid or necessary. Getting a response from the original reporter or from project management in regards to closing these issues is very difficult. Getting a response gets worse the longer time passes, which is why newer tickets are much better triaged than older tickets. Older tickets with not enough context are usually kept open until an infrequent triaging session determines they are unlikely to still be relevant. &gt; In addition, I've noticed a good number of issues where someone attempted a solution, but ran into a weird or obscure bug or message. When I was starting out these abandoned PRs were invaluable as they gave me breadcrumbs for my own research into the problem, but sometimes a feature requires much more work than a person without enough knowledge of the compiler can dedicate. &gt; They'd ask for help and get none. These issues need to be more actively monitored and the correct people pinged when you have people-new-to-the-project trying to help. This is certainly a failing. It's very easy to lose track of pings in github and requests for help, particularly when seeing a request for information that would require extended research in order to be able to answer. Having said that do not hesitate to ping again. The team is not actively ignoring you, it just has too much on their plate and for many it is not their day job. &gt;New contributors (like me) may not want to ping a higher-up rust dev, as it feels too imposing and intrusive. Do. Anyone that appears in the team page will not mind being asked questions and will do whatever they can to help. Just be mindful that when people are unresponsive is that other things might be happening that are unrelated to the project, but everyone will make an effort to help contributors. Worst case scenario, they will point you towards somebody else in the team. &gt; Finish ongoing projects, and if more bodies are needed, ask for help: How long has Chalkification been worked on? It's complicated yes, but devs retreating down a hole and not offering continual reports on their progress is both unhelpful and damaging. It doesn't need to be full-time work, but it does need to be done with transparency. [This](https://internals.rust-lang.org/t/crossbeam-request-for-help/4933) does happen from time to time, and [there are labels](https://github.com/rust-lang/rust/labels/E-help-wanted) for [people wanting to help](https://github.com/rust-lang/rust/labels/E-mentor). These might not be fully up to date, but there's an effort to split work out that newcomers can start working on. During impl period [a website was created that presented these tickets in a curated manner](https://www.rustaceans.org/findwork/), this should probably be resurrected.
&gt; Getting a response from the original reporter or from project management in regards to closing these issues is very difficult. If you leave a comment recommending a close, I will notice it. How were you trying to get in touch with people?
To be fair, it is easier. That said, if you could use either Rust or Go, here are some other languages you probably could have used: - C++ - Nim - Java - Kotlin (okay I'll stop using JVM languages now because it's basically cheating) - C# and that's just if you wanted Go or better performance. If you don't, that opens it up to pretty much every general purpose language. I'm not saying people don't choose between them; I'm just saying the comparison of Rust to Go is just as valid as almost any language-to-language comparison. Go is a weirdly specific target. If we're going to treat it like a competition, let's compete with everyone.
As always, please file bugs. We try to get everything, but we make mistakes.
To be fair, Go is easier to pick up than Rust if you have programmed in C, C++, C#, Java or any other OO language. It was designed that way. I still would prefer Rust to Go, though :)
|x| x.call_foo() can also be called call_foo ...
It's actually mostly the work of the poster above, thank you u/matklad!
While the style might be a bit melodramatic, I think there is a point to the argument: IO processing (especially text processing) is an area where there are few examples for beginners.
You may have done so already, but you should talk to the community team (specifically the events working group), they have thought a lot about what makes a good Rust event and have worked on Rustfest, Rustconf and more (u/skade, I think). &amp;#x200B; Some things I would like to see: &amp;#x200B; * a bilingual conference - I think one of the major benefits of such a conference is facilitating interaction between the local and global communities, and I think to satisfy both having real-time translation of talks is necessary. * good transport connections - if there is some choice in location, then picking one with great international connections makes travel easier for visitors * a wide mix of topics - for beginner, intermediate, and advanced programmers. General Rust topics and stuff specific to the local context * plenty of time to submit talks, buy tickets, and book travel * financial assistance for speakers and under-represented folk, paid for by more expensive general tickets * minimal swag - a little something is nice, but most conference swag is too much and very wasteful * workshops as well as the regular conference track (the Rustconf workshops are usually very popular)
Oh, and I think this is a really great idea! I would love to see more local Rust conferences happening in general, and especially in Asia, since there has not been much happening so far.
how do you author bugs about structural issues? because currently the reference has a lot of duplicate information that is scattered across multiple sections which don't link together. 
Just make the text broad. The reference has a few people actively working on it, I'm sure they'd love to clean up bigger stuff like this too. I don't know the details, but people don't notice stuff on reddit; things only get fixed if bugs about it get filed.
Ive never found a link to an RFC to be useful in the least. 9/10 it is dead link to the RFC that moved to a different location, due to acceptance/misfilling, or just being a link to the misfiled RFC. Then at best you have no documentation about how to use a feature (maybe a few code examples) or at worst you have discussion that leads to something completely different being implemented which has no examples. 
Thanks for the feedback!
After skimming though, this seems like deprecating the whole Rust language to me. Why write extension traits after this change?
Specifically, it's not even possible today to donate money to Mozilla and have it specifically earmarked for Rust. There are lots of large organizations that \*want\* to give money to Rust but \*can't\*.
&gt; whole Rust language That's a bit of an extreme take in my opinion. In all the instances of breakage I mentioned using fully qualified syntax was the solution, so Rust code was still being written and used. &gt; Why write extension traits after this change? The same reasons you did before. Functionally the code is still the same, it's just required to be a bit more explicit now.
&gt;How can we get companies to sponsor this work Rust foundation, Rust foundation, Rust foundation.
Memory safety without garbage collection is the single greatest feature of Rust. Garbage collection isn't free. It adds a run time, it adds computational overhead, and it removes entire classes of applications. A GC could be implemented in libraries, just like C++. But it begs the question, *why*? The language is already memory safe. You don't need to free anything manually. You would still need all the same `Type::new()` calls and builder patterns. 
Have you read the (ongoing) Shifgrethor series? https://boats.gitlab.io/blog/post/shifgrethor-i/ If you scroll to the bottom under Conclusions, you'll find links to even earlier work on GC in Rust that it builds on.
I think it’s feasible. Check out this blog series by withoutboats where they describe, “Garbage collection as a Rust library”: https://boats.gitlab.io/blog/post/shifgrethor-i/
1. [Rust has a static GC](https://words.steveklabnik.com/borrow-checking-escape-analysis-and-the-generational-hypothesis). 2. Rust aims for a minimal runtime (that's why it _used to_ have green threads like Go, but they were eventually removed), which contradicts using a GC. 3. Having two memory-management mechanisms (borrow checker *and* runtime garbage collector) would make everything (the compiler, standard library etc.) hella more complicated - which is rather not desired.
I've published a new version, hope you find it easier to understand: https://crates.io/crates/underscore_args
Fully qualified syntax is so much more verbose. This RFC is a non starter.
A small, incomplete list of the everyday (trait) methods this would deprecate/remove, just of those from the prelude: .clone() .eq() .cmp() .into() .into_iter() .to_owned() .to_string() Literally everything that you do with an Iterator, as well. TL;DR, method syntax is an important part of Rust code, and is used more widely than you'd realize at first glance because of how Iterator works. Also, it keeps Iterator chaining in order: iter .map(a) .filter(b) .collect() // All trait fn on Iterator, becomes Iterator::collect( Iterator::filter( Iterator::map( iter, a ), b ) )
Yeah that's fair. I hadn't considered that impact.
Why write extension traits instead of just free fn, though? Specifically, talking about something like `ResultExt` traits, which aren't used for generic anything, they're just implemented for `Result` to add methods.
I agree with others that this might have quite a big impact and is unlikely. But IIRC this has come up in the past discussions about a defensive programming clippy category, and I believe it would be well suited in that area of tooling.
Greetings from America! I’d really love to see some beginner/novice talks to help developers understand the basics of the language and ecosystem. Modern languages are more complex than running a compiler and executable. A talk on cargo, crates.io, package management, rust basics, community resources, etc. could be really useful to newcomers. Some hands-on workshops would be pretty great too. Having a class where developers pair on something like Conway’s Game of Life could be valuable. Multi-lingual conferences are great but also stay mindful of your local audience. Personally, I’d love the chance to visit China to give a talk at a conference but I would feel genuinely bad about not being able to speak the language.
I don't know, I'm not following it closely. I think `source` has landed, but I don't the backtrace support has? &gt; Also, is there and example/post/article which approach exactly are we supposed to use? Not that I know of.
Is there a reason that `slice::last_mut` doesn't use unchecked access? From what I can tell, [the double checking doesn't quite get optimized out](https://godbolt.org/z/Imb-s8). I could be missing a case where this could be wrong, or maybe it works better with generics?
&gt; If the compiler doesn’t know what to expect? To elaborate a little more on what Steve said, note that a slice type like `&amp;[i32]` is a borrow, which means it always comes from something. If I take an `&amp;[i32]` from a `Vec&lt;i32&gt;`, the compiler might treat that `&amp;[i32]` the same as if it had come from an array, but that doesn't mean it's forgotten about my `Vec`. It's still going to run the destructor when the time comes, etc. It's really no different from taking a single `&amp;i32` out of a `Vec&lt;i32&gt;`, vs doing the same with an array. Even though those collections are different, and some parts of your program keep track of that difference, other parts of your program don't care where the `&amp;i32` comes from at all.
I'm a bit late to the party, but IntelliJ-Rust already does this for you. https://i.imgur.com/Tx9btwT.png
I find that it's hard to follow up on the status of things between the RFC PR, Tracking issue and various PRs to the compiler. Most RFCs are implemented with multiple PRs too, it's a gigantic non-linear mess to follow. And some things get implemented by stay in nightly for way too long. We need a streamlined way of tracking RFCs from suggestion to acceptance to implementation and stabilization.
FWIW there's already a crate called "fe" -- a command-line tool, no less. (Guess there's a lot of demand for short command-line names.). It hasn't been updated in almost two years..
Some grammar mistakes / quirks are pretty recognizable and correlate strongly with certain groups. Even "text over the internet" allows one to discriminate.
Arguably, no software ecosystem can be improved by a small group of people working on a project for only a single day. Somebody has to maintain the created software, and that requires working on it for more than a single day.
What do "certain groups" have to do with race or sex? I'm reading a racist implication in your comment, but please elaborate.
I was thinking more about resolving some issues in existing crates / tools / rust itself. I've seen that many projects have markers like 'beginner friendly', 'good first issue' etc.
Making heavily cyclic data easier to work with?
Rust has a lot of history. Isn't this the same as walking into any situation with history? e.g. moving to a new country and not understanding all the jokes or political background or local customs or whatever. (I have done that, marrying into another culture.) Also "constant lowering" is a compiler term that isn't unique to Rust. Are you asking that they don't tell you things you might not understand? There are people here from all backgrounds, e.g. Haskell, ML, academics and so on. I don't understand half of what they're going on about. Well, I try to understand and sometimes partly succeed. I don't feel excluded, though. We just have different knowledge, and that is a good thing. This really is a varied community. Trying to be accommodating to everyone hits limits when people arrive in the community with their own baggage or problems. If someone has suffered in their life, and then feels vulnerable in some way, whilst we may all want the best for them and try to help, we are not all psychologists or shaman or priests or healers (or whatever that person really needs to sort themselves out). So we really can't expect to be able to sort out everyone's problems, because that is not our area of expertise. We do have to all meet in the middle to some extent, i.e. both parties have to do their part for it to succeed. Also a lot of this is framed in terms of issues which exist in the US (e.g. US history of white vs black), which is not the same in other cultures at all (e.g. people who grew up in a much more integrated multicultural region as I did). Imposing some frame of reference particular to the US can be just as insensitive, e.g. someone assuming that I must have some problem because it's like that in their home country. Assumptions can be just as bad as prejudices. The whole thing is a minefield. To me it's so hard to make generalizations, as so much depends on the individual and their background. Fortunately online we all go by handles, and whilst you can guess a little, e.g. from the handle name, or fluency in English, we really have no idea about the backgrounds of most people here. So this should be a neutral space, mostly, and we're only publicly exposing our technical ideas or levels of experience, and a little bit of our character in terms of aggression or impatience or whatever. Still, certainly I can see a point in helping particular groups who share certain group characteristics or disadvantages. But this needs to be on an individual basis so that it can't be gamed, and so that it is really helping and not just "trying to repay historical debt" or some such guilt trip specific to one country's history. And if it's individual then what you're really doing is healer's work, with some Rust on the side.
Welp, I know what I'm doing over my Christmas break... *cracks knuckles* (You're gonna hate me by the end.) 
C# has named arguments. I use the language on a daily basis and I think they're a misfeature. It is rather rude to assume that people disagreeing with you are simply ignorant.
This is how every software developer feels, at least in my experience. I agree fully (surprise).
I tried this: fn main() { let x: usize = 5; println!("{}", x % 3); } `warning: integer arithmetic detected` Thank you clippy, I almost did some very dangerous integer arithmetic.
[Here](http://aclweb.org/anthology/C18-1130) you go.
There's the official images of the logo at https://github.com/rust-lang/rust-artwork/tree/master/logo, including SVG versions which could be used to create a version like you want in any resolution. (It might be worth just glancing at the logo policy too: https://www.rust-lang.org/policies/media-guide )
You can use Servo's svg logo and remove the doge in the middle, which is easier than hacking the Rust logo.
I would say that the most help that can be done in a single day would be for documentation. Find some crates that you use, and work towards documenting it better for other people to use.
Thank you for the explanation. It does make some sense. However, this is akin to trying to cure the symptom, not the cause of a problem; or, even worse, fighting fire with fire. Discriminating the other way in an attempt to level the playing field feels like, even if it did work out somehow, would be a fragile type of balance that would collapse as soon as something changes.
You're missing something. String to typed conversions in Rust are extremely easy, IMO. let x: i32 = "534".parse().unwrap();
For those that can’t attend, are there best materials to learn about SIMD? Offline. 
Perhaps we could use a badge for repos that shows the number of \`unsafe\` lines of code in a project.
Shucks...I did a Google search for it, but since I haven't published it to crates.io yet, I didn't bother to look there. Thanks for the heads up
I worry about how this would increase Rust's complexity budget. Have you ever coded in CoffeeScript or written an outline list in reStructuredText? I already feel confident that I know how Rust's syntax works and this sort of "thing &gt; thing" is either an expression or a closure behaviour reminds me of the "nuanced parsing" of both of those. (I don't think I'd have to resort to trial-and-error to stumble on a form which parses into what I intended, as I've sometimes had to do in those cases, but I certainly wouldn't want a Rust newcomer to encounter it.)
There is already a `gc` crate. I'm using it in one of my rust projects where my Rust objects can have cycles (it's a term representation for prolog). It works as a library. When you make a new `Gc` value that acts as a root and when a collection happens it traces from all the roots. Here is the crate: https://github.com/Manishearth/rust-gc/
I second this. I feel like my Rust ability has reached a point where I'd like to work on the compiler or on core crates throughout the ecosystem, but I've no idea where to get started or who to talk to such that I might begin digging into the vast swathes of information needed to make myself familiar with these core technologies.
I'm new to Rust and I want to benchmark something using Criterion. I followed the example in the readme, so I created a project with `cargo new my_project`, I created a test file at `/benches/my_benchmark.rs` and updated the `Cargo.toml` file. If, say, I now move `fn fibonacci` (from the example) to [`main.rs`](https://main.rs), then how can I access it from the benchmark file? I've tried `use my_project::*;` and `use crate::my_project::*;` and `extern crate my_project;`, but none of them work. Should the benchmark file be stored elsewhere?
If you're German there's Prototype Fund that funds OSS development. https://prototypefund.de/en/ Other countries surely have such charities as well. 
You can implement cycles without a garbage collector. Whether or not that should be easy is up for debate. 
Did you make the function `pub` when you moved it?
Saving 5 bytes, no. Saving 5 tokens that are essentially boilerplate? That is quite possibly worth it. The rationale here seems similar to but stronger than the rationale for the ? operator, which I don't think a lot of people have a problem with.
If you find a dead rendered link on an RFC PR, please say so and I will try to fix it.
point 4 contridicts point 1 😉 but yeah i personally find the rust "gc" better then a normal gc for the application rust is developed for 
Hm, I wonder if Clippy should care about `%` and `/` operators. From what I understand, the intent of `integer_arithmetic` lint is to mark expressions which mean different things in debug and release modes. However, `%` and `/` operators are always checked for overflow, even in release mode. Not to mention, modulo by constant value 3 will never trigger overflow.
I did, though I meant that none of those lines I tried adding compiled, not just that calls to the fibonacci function didn't compile.
I actually started the same way you want to. I still haven't actually read the whole of the book all the way through. I do check if from time to time as a reference. The main resource I used when getting started was "Rust by Example". It was super useful when I was writing my first rust programs because I could just get in with trying to write something and when I wanted to know how rust did a specific thing I could just check the code snippets. The other thing for me was sometimes I would see title of one of the language constructs and wonder what the hell it was, so I'd read the code and then try to think of a use case in a program I'd written.
I think that you can use the `?` operator. I'm not 100% on the syntax but it would be: ``` let path = entry?.path()?; let file = path.file_stem()?.to_str(); let ext = path.extension()?; ```
Problem is I'm iterating over fs::read_dir with .filter_map(|entry| {})
https://rust-lang.github.io/rustc-guide/ and https://forge.rust-lang.org/ may help!
Offline as in books? I have no idea! I'll be doing the talk on twitch in the next day or two and then will copy that up to youtube. I'll post a link here when it is done. 
Strongly agree - It's remarkable how much work authors will put into crates that become effectively inaccessible due to the dearth of documentation. Examples and API docs are a complement - not a substitute for a natural-language description!
Awesome thank you. 
Maybe you could review some crates as a part of https://github.com/dpc/crev/tree/master/cargo-crev :)
That can be done inside of a closure. Here's an example you can run https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=30dead9c3c232ed5624e38b24bf84cea
great post
Agreed with all of this! BTW, get you some [HTTPS](https://letsencrypt.org/)! Browsing to your site made [HTTPS Everywhere](https://www.eff.org/https-everywhere) unhappy. ;_;
I made [this SVG](https://drive.google.com/open?id=1ixjSCfFOl9rcOcLWWSy0JKhO4tLNb2bn) for someone on IRC a few weeks ago.
We're going to need a bigger 'boats.
I think your example is too extreme and misrepresents what affirmative action/diversity initiatives are doing. To use a more relevant example, it's not trying to change "white men are superior" to "white men are inferior," it's just saying, "white men have a vast advantage if we don't intervene, let's throw other people a bone once in a while."
Ok, I managed to cross-reference `derive-new` and the heapsize example enough to get a proof-of-concept working. This is quite obviously absolutely disgusting in its current form and needs to be cleaned up, but this was enough for my proof-of-concept: #[proc_macro_derive(MyTrait, attributes())] pub fn my_trait_helper(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream { let input = parse_macro_input!(input as DeriveInput); let name = input.ident; let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl(); let dynamic_new_quoted = dynamic_new(&amp;name, &amp;input.data); let expanded = quote! { // The generated impl. impl #impl_generics ::mycore::MyObject for #name #ty_generics #where_clause { fn dynamic_new() -&gt; Self { #dynamic_new_quoted } } }; println!("{}", expanded); proc_macro::TokenStream::from(expanded) } fn dynamic_new(ident: &amp;Ident, data: &amp;Data) -&gt; TokenStream { match *data { Data::Struct(ref data) =&gt; { match data.fields { Fields::Named(ref fields) =&gt; { let fields = fields.named.iter().map(|f| { let name = &amp;f.ident; match f.ty { Type::Path(ref tp) =&gt; { return quote! { #name: dynamic_thing(#name) }; }, _ =&gt; panic!("not here"), } return quote! { #name: 1 }; }); quote! { #ident { #(#fields,)* } } }, _ =&gt; panic!("unsupported struct field type"), } } _ =&gt; panic!("unsupported struct type"), } } 
Good post! A note (rant?) on the compiler speed section: I consider a faster `rustc` to be an absolutely crucial "thinking big" goal- the compiler is not 5% or 10% slower than the compilers of comparable languages- it's multiple times slower. Incremental compilation, parallel compilation, distributed compilation, and caching are all worthwhile things to build... but they almost hide this very real problem. We shouldn't lose sight of how fast straightfoward, single-threaded compilers can really go.
ty!
Ah, looks like this isn't currently possible: https://github.com/bheisler/criterion.rs/issues/158 If you need to benchmark something, it'll need to be in a library crate. You can add one or more binaries to a binary crate, and that might end up being the simplest option for you. Personally I often find that I want my library to have a smaller set of dependencies than my binaries (no `clap` and the like), so I end up with separate crates.
This is the way to go. The official rust logo SVG is a single path, so it would be difficult to remove the "R". But with the servo logo you can just cleanly delete the doge.
How well is vscode debugging working for you on windows? For some reason on Windows i just get "variable is optimized away and not available" for everything. on Mac however it's much better. Did you do much set up? Could you share your launch.json? Did you install any symbols? Thanks
I'm not a developer but I am trying to learn rust and I'm in China. I would definitely attend a conference if it would help me learn more rust.
I have a function like this: fn blah(a: &amp;mut HashSet&lt;String&gt;, b: &amp;mut HashSet&lt;&amp;str&gt;) It simultaneously makes `a` and also `b` by making references to the `String`s in `a` to make the `&amp;str`s. This should be possible, because `String` doesn't reallocate its contents if they are moved, and they are moved whenever the `HashSet` "`a`" needs to reallocate. Is this actually permitted and what's should the lifetime be for these parameters?
People are downvoting this comment without explanation. To any passersby: I think it's pretty clear this is an honest suggestion and deserves an explanation for a downvote. I _suspect_ you're getting downvoted because official GUI toolkits have not been successful in the past. One-size-fits-all just doesn't seem to work for GUIs. It's likely that an official GUI toolkit will be too generic or underpowered to be useful, and will fall into the same unfortunate state as Python's standard library tcl/tk support: Mostly a noob trap.
Thank you so much!
Thanks for your reply! It definitely be worth reading the logo policy. Thanks for pointing it out here!
Thanks for the reply!
Hey honestly, simple isn't a bad thing. `rq` can be a beast with the deps it uses. I can certainly see a lot of desire for something that will pull down over a `cargo install` for some quick json perusing.
this ain't it chief. you're looking for /r/playrust
A few tens of 10% improvements and tada, we're as fast as other compilers! :P
&amp;#x200B; Hmm that's weird lol
Absolutely. I've given up on Proc-macros for now: I've found No tutorials on them, official or otherwise. 
&gt; EDIT: and it's being worked on. Oh me of little faith :) Breaking it and then "working on" fixing it isn't really a good thing, though. This is the kind of basic thing that should've been dealt with *before* the redesign was rushed on. Speaking of that, apparently comments saying the redesign was rushed are [removed](https://snew.notabug.io/r/rust/comments/a55o1o/error_404_when_coming_from_a_search_engine/ebk8f4x/), not a good look to me. Also, the issue linked in this thread was closed 9 hours ago, but the links are still broken. And it was opened 5 days ago, so it took 5 days to to fix?!
In addition to docs, HTTP Clients, C bindings or other labor intensive yet straightforward tasks would be *very helpful* too. They're generally not exciting tasks, but generally help bolster the ecosystem, and make writing higher level abstractions available to more people. For example something Id love to have is a client for [Dependabot's API](https://github.com/dependabot/api-docs/blob/master/README.md). This would allow writing all sorts of interesting automation tools on top.
Indeed! Work on the Cranelift backend is underway, aiming to achieve it! https://github.com/bjorn3/rustc_codegen_cranelift 
Formatting note, triple-ticks don't work on (some parts of) reddit.com. Only the 4-spaces syntax is consistent.
I've also heard folks mention it might even speed up heavily cyclic code. In particular have heard it be mentioned in relationship to Rustc*. I believe currently a lot of the data is just stuck in a hashmap, and using a GC some relationships could be more efficiently expressed instead. * It's been a few months. I hope I'm remembering this correctly.
Often, using a pool to allocate cyclic data is faster than both the regular allocator and a gc.
One very important point about language itself - use Chinese. .
100% agree! I hope the compiler team can really make speed a priority next year. The current wait times are a big drain on productivity. Even something like a fast mode that makes 100MB binaries would make debugging so much smoother!
I think it's also worth acknowledging the rust compiler simply does more too. Zero cost abstractions aren't actually zero cost, we just front load all the cost into compile time. Rust devs and the language itself try to do as much at compile time as possible to make the final executable blazing fast. The downside? Your compile times are really long. Now that being said all of my Rust projects compile way faster than my similarly sized C++ projects.
Breaking apart svg path in inkscape is just 2 clicks away. Not hard.
There are parts where the R overlaps with the circle. You would have to recreate the circle in those parts.
I suggest you use JSON to transfer data between JS and WASM. On the Rust side, you can work with it in a strongly typed way using serde, and in JS you can use it as an object. Can you do it in 3 days? Depends how "advanced" the validation is. As for JS wrapper, just re-export your functions but add "#[wasm_bindgen]" (I suggest you add ``` #[cfg(platform = "wasm")] #[inline = "always"] fn blah() {} #[cfg(not(platform = "wasm")] fn blah() {} ``` so that the wrapper is "zero-cost") Also add serde [de]serialization to your structs, so you can use them directly from the crate.
I'm super excited about that one! I do think we should be able to improve our LLVM-based compile times as well- there are LLVM-based compilers that far outperform rustc. I often see Clang outperform rustc on similarly-sized projects, for example.
I strongly disagree. I see Clang outperform rustc quite often, so I don't think we can really say Rust is universally faster there (though I don't doubt your claims either). I'm also primarily talking about debug builds. Assuming "zero-cost abstractions" refers to things like heavy use of inlining+constant propagation+DCE, that shouldn't really be an issue, other than perhaps a high volume of generated IR? But that's not even mentioning other LLVM-based compilers like LDC or Jai. Obviously these languages are farther apart than Rust and C++ are, but they still rely on the same optimizations so clearly the problem is avoidable at some level.
The one other thing to consider is borrow checking. Most other language choices you have simply don't do that.
I completely agree. To me, rushing the new website despite it's numerous and often serious technical and usability issues as well as the subsequent stonewalling of community concerns instead of temporarily rolling back is indicative of severe systematic issues with this project's current management. This issue is particularly worrisome because it sets a precedent as the first unilateral decision that actively and objectively harms rust for what amounts to a non-technical reason. I fear that this decision might be a precursor for whats to come. As for censorship on this sub, it's a known problem. A moderator here once stated that comments may get removed even if they don't violate the rules if they feel the removal is warranted. I would not use this sub to openly discuss my concerns about rust.
I believe you can run `rustfmt` on files and get diffs emitted, but I don't believe you can run it on diffs that already exist.
It's also not the bottleneck. The last time I looked, it was only around 3-5% of compilation time, while LLVM optimization and codegen was around 80-90%. The implementation has changed quite a bit since with NLL, etc. but no matter how fast the borrow checker gets we'll still have the same problem.
Interesting, well to be honest it sounds like you've spent more time looking at the issue than me.
yeah using serde was definitely the intention and I just forgot to mention it but I didn't know about its interop with JS. If I'm understand correctly then the layers would be like: 1. validation lib where structs that can be deserialized are defined as well as where actual validation is done 2. wrapper that mostly just re-exports functions from the validation lib, utilizing `#[wasm_bindgen]`, also uses the structs defined in the validations lib 3. actual javascript that passes plain old objects to the wrapper functions which get deserialized by serde magic Is that a correct assessment? A couple of questions I still have though - the bit you added about `[cfg(platform = "wasm")]`, I'm guessing that's meant to be added to the validation lib itself? Would that require the need to write 2 duplicate functions for each validation? - Also when you say re-export the functions in the wrapper, you mean just doing something like below, right? ``` #[wasm_bindgen] fn validateThing(p: my_lib::MyStruct) { // 'p' should be owned, right? my_lib::validateThing(p) } ``` 
Great to hear that it works, but I am still a little confused. How do the dynamic criteria work? Are these global variables? Do they obey the rust ownership rules? etc... Macros are fun, but it might be simpler to use the factory pattern or do something like this impl MyStruct { fn new_from_context(ctx: &amp;Context) -&gt; MyStruct { MyStruct { x: ctx.get_x(), y: ctx.get_y(), x: ctx.get_z(), } } } Here Context is a struct that holds your dynamic criteria.
Appreciate for your great advice. We will work on topics plan and webpage for submitting talks after the venue. Totally agree with minimal swag idea, should be as simple as possible, and a little bit fun. About the workshops we had too many ideas actually, also want to know what attendees expect the most from there. I think that's where the real communication happens.
Thank you for your support! Let's start with the first conference\~ Compare with Ruby community in China, for instance, there are much fewer developers at the moment.
Welcome to China! Talks will be in English or Chinese, with the real-time translation. &amp;#x200B;
sure will be true soon!
Cool, thanks!
Thank you for your great and specific advice, so helpful! I also think the hands-on workshops which let developers pair on something are really interesting. Considering better collaboration and communication, and maybe long-term connections, documentation or libraries or something else should be provided earlier.
Thanks! it will be in English or Chinese with real-time translation for talks. it would be better for workshop attendees to come with both language for better paring or collaboration
I'll be there at that time, so excited about this event, it is very early stage for the rust community in China, but I believe we will accelerate the progress of Rust language to be successful in China.
Wow, your [linked list video](https://www.youtube.com/watch?v=k6xR2kf9hlA&amp;index=8&amp;list=PLqbS7AVVErFgY2faCIYjJZv_RluGkTlKt) is really helpful! Whatever happened to your Patreon? Your videos are worth supporting!
that‘s would be nice to have real-time translation. And I hope organizer to have a guide book before the conference, thx
Sorry for my ignorance, but I'm wondering whether there are some well-known company using Rust in China? &amp;#x200B; If there indeed are a bunch of them, I guess you will not forget to email them about this right? &amp;#x200B; Seriously tho, could you please help me to list some companies that are great at utilizing Rust?
In short you have several options You can structure your code so that each shop contains a list of barbers, but the barbers don't have a reference to the shop.This approach is much simpler, but it forces you to iterate over shops whenever you want to access the barbers, and that is not always practical. You can store the barbers and shops in separate vectors (or hashmaps) and use indexes (or keys) instead of references. But then you have to be careful whenever you delete a shop. If you forget to update the barbers employed by the shop and subsequently add a new shop with the same vector index then the you will run into trouble. (Google for "generational indexes") Are you making a game? If yes, then have a look at the following video https://www.youtube.com/watch?v=aKLntZcp27M
Early release. A few bugs/optimization problems in the virtual DOM, and a number of features I'd like to add/document soon. Any critique or suggestions on the API, documentation, and overall approach would be appreciated.
that's why i mention drift luo before, I heard he's from a company called Cryptape in hangzhou. I've met Amiee in Rust Fest Rome and these guys are nice. Hope this conference be successful.
Woooow！！！Rust Conference，I'll be there at that time，and if there are any detail about the Conference，Please let me know
That really depends on your definition of comparability a lot. I don't think a compiler that does the same amount of work can be many times faster, but will be very happy if proven wrong.
&gt; However, this is akin to trying to cure the symptom, not the cause of a problem; or, even worse, fighting fire with fire. Well, that's a common criticism of affirmative action, but note that this post did not propose any solution. All it did was mention that more diversity would be better, which is because we might be missing out on perfectly capable people now. And additionally, though I didn't mention this yet, it provides additional viewpoints, e.g. about parts of the documentation that might not work that well in other cultures, or help from people being able to translate docs to other languages. &gt; No, it's everyone else who is superior to the Aryans; Aryans are the inferior race. Note that that's not what affirmative action says. Affirmative action says: "everyone else is equally valuable as Aryans, but we're currently treating them as if they're lesser, so let's make it explicit policy to treat them better so we hopefully end up treating them about the same.
It's annoying that I run under a different nick here, but you probably meant /u/fgilcher ;)
&gt; if from_slice also accepts closures Yes, this is what I was getting at. So, for new syntax that looks like it might be syntactic sugar at the AST level, you actually need to have processed name resolution, trait resolution, and partial/symbolic type resolution (remember `Fn(T)` is a trait, so generics are often involved) in order to find out which sub-expressions might be compatible with a a closure type? To me this looks like an absurd amount of complexity to specify, implement, and maintain in the compiler.
&gt; If you actually learn to write C++, it would be equal in speed to C Often greater, but it depends on what you're doing. Templates usually generate faster code than throwing around `void *`.
I think JAI has a custom emitter for debug builds because LLVM was too slow (IIUC it doesn't support as many platforms for debug builds). That said, it's creator is a bit... intense about performance. Regardless, "other than perhaps a high volume of generated IR" is a big part of the issue. In general, if you generate more IR, LLVM will take more time. My experience optimizing an LLVM code generator for a compiler I worked on in college is that this is the single biggest thing you can do to make LLVM perform better -- just give it less to work with. Easier said than done, of course.
Well I am not a compiler writer and can't estimate technical absurdity of certain features (like borrow checker or closure syntax sugar), this is mainly a high-level suggestion based on the implementation in other languages, somehow they manage to avoid absurd complexity. 
Great work! This looks well documented and easy to use. Really like the simple macro approach to building DOM elements. The Elm like architecture also seems very solid. Looking forward to building this with it. 
Full context: I'm writing a fuzzer. &gt; How do the dynamic criteria work? This is based off of thread-local RNGs. &gt; Do they obey the rust ownership rules? Yep, I'm only using this for setting primitive types and anything else more complex I've added a helper attribute to ignore its instantiation and just use `Default::default()`. I actually don't like resorting to macros as I think that it can be an overly complex way to do something that may be more readable and solvable a different way. Following macro logic isn't exactly the easiest from my own experience and I like to avoid it. In this situation I have dozens of structs where the logic for instantiation is going to be extremely similar, so it makes sense to use code generation imo.
I believe rls supports running rustfmt on only a section of the code. I imagine this functionality comes from rustfmt itself, so perhaps you could make use of that to implement diff only reformatting.
The content is obviously wrong, but I hope this explains some hostility to use of Rust, such as in librsvg. Rust use does make seemingly simple things like "native ARM build of Firefox" orders of magnitudes more complex.
Every now and then, somebody asks about GUI status of rust on reddit. AFAIK - no progress so far, just a few tries. Obviously people are interested in it, but results are lacking. Or maybe not, looking at the downvotes. Or maybe word 'official' triggered something like you mentioned... I'm very, very against fragmentation. Having it fragmented 'adds freedom to choose'. Unfortunately, we are free to choose among many many unfinished, half developed buggy things. Maybe this would be a way towards something that would unite Linux desktop since gnome started doing some back end stuff in rust (AFAIK). Anyhow, I'd like to see Qt as a template for GUI toolkit in the rust world. Documentation, company backing, industry use, IDE... It all makes sense. Starting development is easy, learning it is easy. The point is - there is one entity handling it and the toolkit is generic. Not perfect, but good enough for many things. Having several toolkits would help no one by again introducing fragmentation and this 'official' one would hopefully prevent it.
Re 2: Of course there will be syntax highlighting. The work is tracked at https://github.com/rust-lang/www.rust-lang.org/issues/349. If you can help, please do so!
Theoretically that works by \`peek\`ing into the stream, and when there is not enough data wait for more. Practically that as all kinds of issues. E.g. mio might not notify you again since there is still pending data (or it might notify you again directly, and before new data was received). And the buffering space is limited, and the exact amount depends on the OS. For portable behavior the advise of the others is right: The data should be read into an application level buffer, and further processed from there.
As far as I know no one can successfully compile firefox on these devices because they are just not powerful enough. Crosscompiling is the way to go here.
And it is definitely not ok to blame rust for this. Some sites say that even builds from 2013 fail. And that is an area where rust was nowhere near firefox.
I think the folks over at r/playrust would like this ^^
This blog is pathologically incorrect
Let's do the math... If we are at 5x and achieve 10 times 10% speedup (multiplying with 0.9) due to diminishing returns we'll be at...~1.7x (another 10 times 10% speedup arrives at ~0.6x, so 2 tens of 10% speedup should make us almost twice as fast as the reference!)
And it is definitely not ok to blame rust for this. Some sites say that even builds from 2013 fail. And that is an area where rust was nowhere near firefox.
And it is definitely not ok to blame rust for this. Some sites say that even builds from 2013 fail. And that is an area where rust was nowhere near firefox.
A simple thing you can do yourself to crudely measure the impact of different stages of the compiler it to compare the time of `cargo check` to that of `cargo build`. `cargo check` does all the syntactic and semantic analysis, including borrow checking, but stops before optimization and code generation.
Having actually done that work- do you have any specific ways to shrink generated LLVM IR? It would be great to compare notes not only for rustc's sake but because it's an interesting topic in general.
I think a bug squashing or documentation event is certainly good! Having organized hackathons myself, the key is to really organize and research before hand. Eg, in this case reach out to the crate author before hand, figure out good, bite sized issues, etc.
Well, clueless people will write clueless posts. This is the internet, move on.
My C++ projects only take longer than Rust if I make heavy use of template meta-programming. Already the fact that on C++ I can depend on binary libraries reduces the build time quite considerably. Then there is the incremental compilation and linking that compilers like Visual C++ offer, alongside their experimental modules support, to be finalized by C++20. I really look forward to Delphi like compilation times, or at very least .NET Native/D/Swift/Eiffel like ones.
I completely agree as well. I only regularly use Reddit, so there may be bias, and technically it's an unofficial platform, *but* lots of the Rust team hang out here, lots of discussion happens here, etc. The impression i've gotten of the project team is.. less than ideal, especially in regards to handling community concerns. There was a even a big thing about this last time, and talk of working more on listening to concerns and moderation and stuff, about some big issue or other i can't remember right now. And, a funny thing is, the redirects *still* aren't up, despite the pull request and everything being merged for 15 hours now.
My first thought is that you are in the wrong subredit. My second thought is that you may not know how to read. 
Cool thanks for your explanation and correcting my understanding! Sounds like it’s working pretty much the way I would like it to! I’m going to start playing around with mio and I’ll work my way up from there.
Nerver heard of this person before but I'm looking forward to it!
Awesome thanks! I’m very much interested in learning low-level systems programming. So that operating system blog looks like a goldmine. All of this is way out of my league for my limited understanding, but I got to start somewhere...
that dude has no idea what he is talking about.... it is even internally inconsistent from start to finish.... it seems like he did not read his own quotes!
This can't possibly work with two mutable references since `a` allows you not only to add/remove things in the hash map, but also mutate those things. You could, for example, extend one of the strings beyond its capacity, leading to a reallocation, leading to `&amp;str` pointers in `b` becoming invalid.
What? I never said I assumed people disagreeing with me are ignorant. What I said was the solution suggested by using builder-patterns and struct arguments is like competing in a race car championship with a tricycle, it doesn't address the problem that I want to solve at all.
Having `&amp;a` and `&amp;mut b` works, with manual association of a lifetime: fn blah&lt;'a&gt;(a: &amp;'a HashSet&lt;String&gt;, b: &amp;mut HashSet&lt;&amp;'a str&gt;) [On the playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=edace9e804953138fe65ea8bfaff3b6a)
Yes, the problem is RAM, 1 GB just doesn't work. On the other hand, it is definitely possible to compile Firefox natively on ARM32 with 4 GB RAM, because Debian does so. Debian does not allow crosscompiling for packaging.
Nice find! This could pass as some real quality satire.
Well, here is [requirements](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/linux_build_instructions.md#system-requirements) to build Chromium: A 64-bit Intel machine with at least 8GB of RAM. More than 16GB is highly recommended. At least 100GB of free disk space. You must have Git and Python v2 installed already. And building any big package (browser, office) with low-end ARM will take days, so why would you do that? If we are talking about Rust, well, yes, 1 GB isn't enough even to build Alacritty.
Thank you for the explanation BTW: I don't think that you should call 'thread_rng' each time you generate a random number. The problem is that 'thread_rng' spends time storing the number generator in an RC. [source](https://rust-num.github.io/num/src/rand/lib.rs.html#933). So it is probably better to instantiate it once and pass it by reference each time youuse it. let mut rng = rand::thread_rng(); loop { do_stuff(&amp;mut rng); }
&gt; [...] It is based on an odd shell (zsh) [...] uhm ... &gt; So Yet Another Object Oriented somewhat fat language. I love how in the quote above this line it states that Rust is *supporting both functional and imperative paradigms* and does not even mention OOP. 
Thanks!! Now I feel less stupid :)
Wait until you get to the bit that claims using Rust results in leaking memory all over the place because you have to do manual memory management. I could almost believe the author clicked on the wrong Wikipedia article. 😅
&gt; Re 2: Of course there will be syntax highlighting I mean, obviously not. The new design is ostensibly a finished product, released, on production, ready for new and old users alike to use. If it isnt finished and ready, why is it up? And if it is, then why are basic features like that, that "of course we'll have", not done before release? Not only did a lot of people give some pretty good criticism of this new design, but now there are new users coming to point out the problems. The new design is nowhere near ready.
Make sense now, thank you very much 
I haven't looked into building FF specifically, but in my experience building things on linux virtual hosts with low memory it is usually GNU ld (the linker!) that falls over with out of memory errors. GNU ld is written in C. So it's not like we can blame OOP or Rust or bootstraping or package managers or the day of the week or whatever our pet form of ignorance happens to be. Note: Some of my experinces here may be atypical because I was usually trying to build Haskell code using GHC and GHC tickles a particular suboptimality in the way GNU ld manages its internal memory representation of obj files. I think with recent versions of GHC/ld that it's much less of an issue. Even with the caveat about Haskell, my understanding is that large C++ codebases are also quite demanding of memory during the linking phase.
Agreed. I'm mostly fine with the design, even though I liked the old "motto" better, but whatever. But I think a website advertising a programming language absolutely needs to have a few small snippets that show off some language features, just as a neat introduction. Makes for a much better first impression. I really like the way [Kotlin](https://kotlinlang.org/) does it. Just a few lines of code that give you a basic idea of the syntax, so you kind of get a feel of what you're in for. In Rust I'd probably emphasize pattern matching, maybe even show off a simple Cargo config, why not? It's definitely something to be proud of :D
sure for it
The comments about zsh and not understanding compiler bootstrapping are kind of frustrating. And the author seems to have been using linux for a long time (mentions building on a 486), so you would hope they had a chance to become familiar with those things in that time.
This line of reasoning from the article was pretty frustrating to see: Rust has no garbage collection. Therefore memory is basically never reused or returned to the allocator. Therefore FF needs too much memory. 
Its absolutely awesome to see more and more rusty WASM framworks :) I just added seed to my list: https://github.com/flosse/rust-web-framework-comparison#frontend-frameworks-wasm Hopefully the community will soon pick one of them and combine the power of all the experiences to build one that is production-ready :)
The only thing I disagree about is the precompiled or cached packages. That's just begging to run into issues of hijacks like npm ran into.
&gt; I really like the way Kotlin does it. Just a few lines of code that give you a basic idea of the syntax, so you kind of get a feel of what you're in for. Looks pretty good imo. Good blend of marketing and actual programming stuff. Fancy animations, news, popular platform targets, why it should be used, and then some examples, and more. I especially like the features area, it has buttons to show examples of the features in the language! Great! Compare that(or any other programming language site, for that matter..) with the Rust site which.. besides the title, still doesn't even actually *say* it's a programming language.(Theres an [issue](https://github.com/rust-lang/www.rust-lang.org/issues/612) for it too)
Thanks!
&gt; I especially like the features area, it has buttons to show examples of the features in the language! Great! Yeah, those are cool. I'd love to see some on the Rust website showing memory safety etc., I think it'd work really well.
Just checked some other posts of the Blog … meh
Works now (see [issue](https://github.com/wahn/rs_pbrt/issues/70#issuecomment-445934766)). They even fixed a [problem](https://github.com/mmp/pbrt-v3/issues/162) on the C++ side of PBRT.
You're trying to cross-compile from your 64 bit toolchain to 32bit. You have a 32bit toolchain installed, but not the cross-compilation libraries to target i686 from within the x86_64 toolchain. If you want to compile using the full i686 toolchain, you can do `cargo +stable-i686-pc-windows-msvc` or `rustup default stable-i686-pc-windows-msvc` to change the default. I know you can also install the actual cross compilation libraries for compiling to i686 from an x86_64 toolchain using some command under `rustup component `, but I can't recall the exact one and I'm not at a computer.
isn't the stuff I put in ./cargo/config file supposed to take care of that?
Thanks! Would you mind creating an issue? I fully agree that would be useful, but I'll forget it otherwise ^^'
Forget that, I forgot to add the target… thanks!
Even if reallocating the `HashSet` is safe, that's not all you can do with an `&amp;mut HashSet&lt;String&gt;`. Consider this: *a = HashSet::new(); This will replace the set, and drop everything in it. All the `String`s will be deallocated and thus all the `&amp;str`s become invalid. Rust doesn't let you do this for good reason. --- As for alternatives, it probably depends on why you're trying to do this in the first case? There are options but no catch-all one that's best for what you've described.
Not really. It makes building an entire compiler toolchain and then building Firefox more complex. Rust has official binaries for ARM, so the only extra step in just building Firefox it adds is downloading the Rust binaries.
Thanks for maintaining this list. With all those frameworks popping everywhere it is a bit hard to keep up :)
Everyone who is contemplating whether or not to go to the Rust meetup in Berlin on December 26, see their meetup page: &gt; There won't be a Rust Hack and Learn on this date! Merry Christmas and enjoy the holidays!
So basically, make cargo as fast as go and rust will take over the world?
I actually don't care too much about speeding up builds from cargo. I get that it's a huge cost on fresh builds and dependency changes. But it's the day to day small changes where the performance of cargo really hurts. All I want for Christmas (2019) is decent tooling. That's a fast compiler and IDE tools that are on par with other mainstream languages.
&gt; &gt; &gt; If it isnt finished and ready, why is it up? And if it is, then why are basic features like that, that "of course we'll have", not done before release? Because it was timed with the release of Rust 2018. And at least for such details "roll out now, fix later" is not a bad strategy. Others like redirects hurt more, of course...
If you keep master always properly formatted with rustfmt on CI, then PRs shouldn't contain many "spurious" formatting changes. Because of rustfmt updates they do happen from time to time though. What I often do is commit the functional change, and at the end of the PR just have a "formatting" commit that contains all formatting changes.
/u/sunfishcode two questions: * How fast is the backend already for the cases that it can compile ? (I realize that optimization might not be a priority until things really work) * Do sun fishes really code?
NPM is hardly the only package manager out there :P. If you want to have precompiled packages, you're almost certainly better off stealing ideas from Nix rather than NPM (I didn't even know NPM offered precompiled stuff).
Really appreciate the extensive documentation! I’m going to give it a try.
I’d be interested in the precise rules for resolving this kind of ambiguity in languages that have this feature.
 - In some simple tests it is fast, though optimization hasn't been a priority until more things work. - There are many varieties of sunfishes :-).
This was already posted here 4 days ago :) https://www.reddit.com/r/rust/comments/a42gzd/the_swiss_army_knife_of_hashmaps_a_deep_dive_into/
I can understand no syntax highlighting, but no redirects is a major implementation issue and something I'm incredibly surprised no-one talked about, Rust essentially threw away tons of SEO when the 2018 edition was released and a bunch of important links suddenly returns 404 instead. It's such a rookie mistake. 
Great repo, thx!
Being interested in Rust, today I visited the website and to my great disappointment was greeted by one of the unattractive website designs I have ever seen. I really don't want to insult the designers involved, but as a Rust newbie the front-page definitely discouraged me from pursuing Rust as a language I could use for my projects. I know you're not supposed to judge a book by its cover, but the website left me confused and frustrated enough that I no longer want to pursue learning the language. Maybe since their mascot is a crab they were trying to make people sea-sick/nauseous? Was that the theme? I don't know what was even happening on the front-page... Maybe my resolve is just too weak? Maybe I'm just paying too much attention to superficial details? Regardless, I will give Rust another shot in 2019 when its appearance hopefully improves.
One thing I note with this post is that multiple modes of thinking are contrasted, as if they precluded each other. We can and should have both! Both a faster rustc *and* cargo, and caching improvements on top. Both a better wasm-pack *and* integration in cargo through custom workflows. A working group spawning working group. A meta-working group if you will, backed by a foundation that can actually cover costs that are currently borne by some employers and some private entities (such as yours truly).
Ugh, the recurring meeting again... Thanks :)
With you on the tooling, I can run `cargo build` in a loop in another window so compiling doesn't feel slow. The RLS really needs work, it's very often that it doesn't find symbols or references.
Wow you're not wrong. If you want to learn go to [the book](https://doc.rust-lang.org/book/ch00-00-introduction.html)
&gt;This is an interesting case I hadn't thought of If you decided to build the best IDE for Rust tomorrow, you could *almost* completely encapsulate your data model with just a Cargo.toml file. But so long as post-build steps are not at least described by the manifest, an IDE will have to come up with its own solution. Today we see that on a per-project basis, with custom build steps for every non-trivial product. Less than ideal. &gt;Being baked in requires issues and/or RFCs, going through the release train to stable, everyone upgrading to the latest stable, and maintaining compatibility somehow even if the new stuff conflicts. I see this as a feature, not a bug. I think Cargo should be the most stable of Rust projects, and the review process and commitment to the project make it ideal for future projects that depend on it. Basically for all the reasons that it can't adapt, it also can't break. &gt;Speaking of the logic being in Rust, I would be curious to see what a prototype of post-build would look like, a cargo-postbuild that performs cargo build and fulfills the proposed contract with a postbuild.rs that it compiles I took a brief look at what it will take and it's not immediately obvious, since you have to replicate the way Cargo handles pre-build scripts (disclaimer: it was my first time delving into the Cargo source). It would be easy to tack on a post-build step without dependencies. The more that I think about it, some of these issues could be resolved by adding a `[post-build]`value to `Cargo.toml` which is an array of executables (shell scripts, rust, python, whatever). &gt;tying into my other reply about open vs closed build systems, there are some crates people create that can only be used for their one target I mean this is the same problem as prebuild scripts, where you need `[cfg(target_os="whatever")]` for conditional compilation (hell, that's one of the major use cases for build scripts, linking against system libraries). The way I see it is that Cargo should be able to build the final artifact for a single target without a plugin. I can see some hackery where people would try and invoke `cargo build` in their post-build step to cross compile multiple targets, but just because something can be used for bad practice doesn't mean you shouldn't create it to support good practice. &gt; For me, I look at cargo as a tool specialized for Rust with minimal additional policy that you'd then tie together in a larger orchestration system That's fair, and I think that's the source of a lot of hesitance to add more features to Cargo. 
Melatonin. Noise Cancelling Headphones. Knocks you out. Keeps you down.
Learning Rust With Entirely Too Many Linked Lists is still my favorite Rust piece ever. http://cglab.ca/%7Eabeinges/blah/too-many-lists/book/README.html
If your future is getting complicated, you should probably write your own struct and impl Future on it. The best way I've found to do this is something like this example: struct MyFuture { state: State, } enum State { State1(...), State2(SomeFutureType), FailImmediately(ErrType), // this one sometimes comes in handy Done(), } impl Future for MyFuture { type Item = ...; type Error = ErrType; fn poll(&amp;mut self) -&gt; Poll&lt;..., ErrType&gt; { let mut state = mem::replace(&amp;mut self.state, State::Done()); loop { let (new_state, action) = state.poll(); state = new_state; match action { Action::Done(poll) =&gt; { self.state = state; return poll; } Action::Again() =&gt; {} } } } } enum Action { Done(Poll&lt;..., ErrType&gt;), Again(), } impl State { #[inline] fn poll(self) -&gt; (State, Action) { match self { State::State1(...) =&gt; { ... }, State::State2(mut fut) =&gt; match fut.poll() { Ok(Async::NotReady) =&gt; { // stay in same state and return NotReady (State::State2(fut), Action::Done(Ok(Async::NotReady))) } Ok(Async::Ready(result)) =&gt; { // go to the new state, but return Action::Again, so the loop that calls State::poll // will call it again on the new state (State::State1(...), Action::Again()) } Err(e) =&gt; (State::Done(), Action::Done(Err(e.into()))), }, State::FailImmediately(err) =&gt; (State::Done(), Action::Done(Err(err))), State::Done() =&gt; { panic!("poll on finished future"); } } } } The reason for having an inner enum that has method that consumes itself, is that it makes changing the state inside a match much easier. The loop that keeps updating the state until an inner future returns `NotReady` is very important, as it is invalid to return `NotReady` unless an inner future gave it to you (or if you somehow notify the scheduler yourself).
Thanks! Sadly I had to [shut it down](https://twitter.com/Jonhoo/status/1047259437319278592) as I'm living in the US on a student visa, and then you're not allowed to have any sources of income outside of your university :(
Agree, there should be some code examples. The kotlin page doesn't scale to mobile though, +1 new rust page.
The package managers I trust most they have people responsible and reviewing, sometimes in several layers (Debian), and it has its own overhead in work required and waiting time!
&gt; My C++ projects only take longer than Rust if I make heavy use of template meta-programming. That's the thing though. Rust encourages generic programming by default. That's where the "zero-cost" abstractions come from, and that's what takes time to compile. It's possible to reach similar results in C++, with similar compile times. If you don't use these features, then the comparison isn't fair anymore. &gt; I really look forward to Delphi like compilation times, or at very least .NET Native/D/Swift/Eiffel like ones. That's probably not a realistic expectation. Or at least, I'd be super-impressed if the rustc team managed to speed up compile times that much.
The comparison is fair, because with C++ modules template meta-programming compilation time will be drastically reduced. And even with C++17 it is possible to reduce the compilation times with some work, by storing expected template expansions in binary libraries. Some of the languages that I listed also make use of LLVM infrastructure, so there is necessarily some improvement possibilities for rustc as well. Currently the difference is like 5m C++ vs 18m Rust, on average, for my dummy projects, on a dual core with 8GB.
Per our on-topic rule, I would ask that someone leave a top-level comment explaining this submission's relevance to Rust.
Is it fine to use RUST for blockchain?? &amp;#x200B;
You're not wrong. I'm just glad that it's the website that's hurried and unfinished, not Rust 2018 itself.
We've had a few threads on this topic by now, and given that comments here are unlikely to be seen by the people working on the site, I would ask people to redirect comments to internals.rust-lang.org, and improvements to https://github.com/rust-lang/www.rust-lang.org
Rust's traits are conceptually similar to Haskell's type classes. They both include the concept of orphan instances. This post espouses a strategy for dealing with orphan instances in large projects.
This is actually really great. It helps to see a comprehensive list, rather than the single examples in the book.
. expect is ok in my book if your learning or making quick, messy code. It's there for a reason.
&gt; (I didn't even know NPM offered precompiled stuff) It's not so much that they do, but that you can put *anything* in npm packages. Some ship minified versions of your JS for you, and what happened was that the minified version wasn't the *actual* minified version... 
Funnily enough, this thread on users.rust-lang.org has been quietly locked. The mods here on reddit also appear to not want any more discussion of this (see [here](https://old.reddit.com/r/rust/comments/a5fw5u/two_things_about_new_website/)), redirecting to internals (where there is no discussion about this, it would probably be locked as off-topic, and rightly so) and to github (where issues get closed and locked with a friendly "please stop commenting"). I do get the idea that everything that had to be said has been said already, but you're left wondering why they even asked for comments if there's no place where you're allowed to make any.
Changing state inside match should be a whole lot easier now that NLL has been stabilized.
The problem is clueless people's clueless posts will cause other clueless people to make bad decisions. We really don't need more ignorant FUD about Firefox in a world where the internet is already too centralised around Blink and it's getting worse.
I forgot to add in all of this a (crazy) idea I had. Some of the use cases presented almost seem more like a custom`crate-type`. I wonder how feasible it would be to design a plugin system for `cargo` to support custom `crate-type`s. &gt; &gt; Being baked in requires issues and/or RFCs, going through the release train to stable, everyone upgrading to the latest stable, and maintaining compatibility somehow even if the new stuff conflicts. &gt; &gt; I see this as a feature, not a bug. I think Cargo should be the most stable of Rust projects, and the review process and commitment to the project make it ideal for future projects that depend on it. Basically for all the reasons that it can't adapt, it also can't break. The oft quoted thing in python "the stdlib is where packages go to die". One of the reasons for that is if the ecosystem moves quickly but the process for updating and deploying can't keep up. &gt; I took a brief look at what it will take and it's not immediately obvious, since you have to replicate the way Cargo handles pre-build scripts (disclaimer: it was my first time delving into the Cargo source). It would be easy to tack on a post-build step without dependencies. There has been talk of refactoring `cargo` into multiple crates. I look forward to it because I'm hoping it will make it easier to follow what cargo does. Personally, the approach I'd take is using `cargo-workspace` to extract dependencies and then mimic `cargo-script` for building. &gt; The more that I think about it, some of these issues could be resolved by adding a [post-build]value to Cargo.toml which is an array of executables (shell scripts, rust, python, whatever). This is starting to sound like the new prebuild feature where you can decoratively delegate some prebuild functionality to a crate The annoying thing for anything non-Rust is of course the system requirements for using it. &gt; I mean this is the same problem as prebuild scripts, where you need [cfg(target_os="whatever")] for conditional compilation (hell, that's one of the major use cases for build scripts, linking against system libraries). While this might get brushed off as "don't disallow good just because of abuse", I do wonder how many use cases people bring up would fall into the category where we are turning cargo into a closed build system i.e. where the `target` is insufficient to know the intent of the developer, locking in what kind of artifacts can be created. Yes, we could then possibly turn to using `feature`. That gets into its own debates. I'm not saying this is the case here but it is getting closer to it that I think of the analogy of the "pit of success". UX should be designed to take advantage of human psychology to encourage best practices while still allowing doing things off the beaten path when there is a need.
Sure, but what can you do about it? I don't think commenting on that blog will move anything in the right direction (hey, it's a Trump supporter, they are not known for changed opinions...)
One day is going to be tricky, 'cause any issue is going to need some context to investigate. If you say three days, then that's time to learn about a problem, figure out how it's currently being solved, and solve it better.
Yes! Anyone who wants a great example of fast single threaded compiling should search for Jonathon Blow on YouTube and watch his compiler demos for his programming language which he uses to write games. It can compile 50,000+ lines of code in 2 seconds or less, most of which is occupied by Microsoft's incredibly slow linker. Threads can help, but there are many other simpler optimisations that can be had first.
No problem :) Yup, there is a difference between a non-blocking call in the land of async that actually just lets the runtime (eg tokio) get on with other stuff, and an actual call that blocks the thread like thread::sleep. Futures in Rust are *cooperative*, which really just means that each running future needs to cooperate with each other and hand back control to the runtime at appropriate times in order that the runtime can work efficiently. If some code in a Future does not cooperate (it runs for a long time or does blocking IO or whatever), all the runtime sees is a future that's taking a long time. It has no real way of pausing it (and later resuming it) to get on with other things, and instead has to wait for it to finish before it can do some other work on the same OS thread. This does mean that you have to be careful to use nonblocking IO functions that hand back control, rather than blocking functions that don't, when working with Futures, if you want to make the most of using them and not slow things down unnecessarily. When you do have work that needs doing that blocks a thread, you can signal to tokio that this is the case (I can't remember the details here, sorry!). You can also kick off your own thread, perform work there, and send messages back to a thread that is running a Tokio runtime or somesuch to interleave the processing of those messages with other actions. I don't know anything really about GTK I'm afraid, but your basic options are to either use (or wrap into Futures) it's nonblocking interface (if it provides one), or spin up a separate OS thread to run it in and send messages back to a thread that's running eg Tokio, if you want to interface GTK things with other async stuff. Alternately, you might find that you don't need or benefit from Futures/async/etc at all in this case, but I don't know enough here to help :)
Within the last 2 months, someone posted a link here to a blog post about debugging embedded code via two black pills. I am not sure why I didn't save this link but I have spent a couple of hours looking for it to no end. Does anyone by chance have this link saved? The article started with an attempt to use a teensy which failed and then linked to robotdyn.com as a source for STM32F103 "Black Pill" boards. 
Done! The issue is here in full detail: https://github.com/slide-rs/specs/issues/519
Triple backticks don't work on reddit: #[cfg(platform = "wasm")] #[inline = "always"] fn blah() {} #[cfg(not(platform = "wasm")] fn blah() {}
Just found it! https://hk.saowen.com/a/84956dd037965844805bfbc5eacd42d7061e6a7320637bf47c6cabbfa9c23dc8
What is the status on safe immovable generators? Would really like to use them for a library!
Agreed! I tried to tip my hat to this in the intro by framing incremental progress and defining larger, more ambitious goals as not being at odds with one another.
Yeah, I know... I've only been putting it off for a decade...
FWIW, I agree that we should make `rustc` itself as fast as possible as well! But I think that this is an "obvious" goal that doesn't need me as yet another champion. In contrast, I think it is easy to miss the fairly unique opportunity we have of integrating something like sccache into cargo/crates.io because it isn't as obvious (or at least doesn't seem as obvious to me!) I wasn't trying to frame these things as mutually exclusive, and I fear that it kind of came off that way a little bit :-/
Awesome. Thanks so much for your detailed explanation. The entire topic of Rust &amp; async is starting to (slowly) make sense! :-) Your help is much appreciated!!
Don't Rust's orphan rules forbid the entire scenario that this blog post is dedicated to fixing? Withoutboats [gave a talk](https://youtu.be/AI7SLCubTnk?t=2598) on this a little while ago that was only recently uploaded. I disagree that this blog post is relevant to Rust.
Thanks for clarifying. I guess it makes sense from a "included-type" perspective. Meaning an `i32` will be coming either way. I'd like to know how the deconstruction of a Vec is different from an array. But I'm sure this is some super complicated traits situation and I'm not good enough with traits yet. It's safe to say I'm not at all a fan of traits. At all! :-) Thanks for your help!!
Thanks so much for your reply. All this traits, deref stuff is WAY over my head still. But I saved your reply so I can come back to it later. My current understanding is that traits are really really annoying, stupid and all they do is safe a bit of typing/few lines of code. But literally everybody seems to love them, so I'll have to try and understand them better. Maybe I'll be able to appreciate them more. All the non-trait things you said make/made sense though. Thanks again!
I think this can potentially be glued together quite simply. * A: Copy repo, apply rustfmt on it. * B: Copy repo, apply origin diff, run rustfmt on it. * Generate diff from A to B. That's your `rustfmt`ed diff. I don't have time to implement it ,but it would be a cool project.
Not everyone (I don't necessarily mean myself) agrees that Rust should disallow orphan impls completely. Posts that discuss mitigating strategies in other languages seems relevant to me.
I am confused about `unsafe()` blocks. I don't want to use them. I don't need any code examples. Why are there unsafe blocks? I can only think of two reasons: 1. Rust's ownership/borrowing system is not good enough and there are things that you cannot do while this system is in place. However I cannot imagine that being the case, because that would mean that Rust isn't as great as everybody makes it sound. Which sounds unlikely. 2. The "safety-inferiority" of other languages that you interop with is the cause. Random exampl: I call a C/C++/whatever function from Rust, but obviously Rust cannot guarantee safety-guarantees for other languages. So that's why one needs to use `unsafe()` blocks. If #2 is the correct answer, please let me know. If I am completely wrong and there's actually an entirely different reason, please correct me! :-)
While I would encourage formatting everything automatically, some projects might be able to do one big rustfmt on everything, and I think it's reasonable to have tooling that would clean-up formatting as the time goes by.
The short version is pretty simple: `Vec` owns some allocated memory on the heap, so after dropping each of its elements, `Vec::drop` will also free that memory. Arrays are fixed-size and stack-allocated (just like a struct or an int), so dropping each element is all they need to do. So for example, if you have a `Vec&lt;i32&gt;`, there's nothing to do for each element (ints have no destructor), so all `Vec::&lt;i32&gt;::drop` will do is free the vec's heap memory. Meanwhile, an array type like `[i32; 10]` will do literally nothing when you drop it. There is indeed some magic here when you peel back the covers. Here's the [`Drop` implementation for `Vec`](https://github.com/rust-lang/rust/blob/1.31.0/src/liballoc/vec.rs#L2109-L2118). It looks like it delegates to a drop implementation on slices, and I'm not sure where that's defined. This is also one of the rare cases where "slice" means "an array of variable size" rather than "a _fat pointer_ to such an array, which includes the size as part of the pointer." So yeah, the implementation details here include some extra layers of abstraction that make it a bit hard to follow.
Why this in the README? ``` &lt;script&gt; delete WebAssembly.instantiateStreaming; &lt;/script&gt; ``` Does this have a problem with a streaming creation function just being present? Is it fair to encourage user to delete that function from use for all other scripts that may appear?
We really wanted to use this for various tasks in [https://github.com/mozilla/application-services/](https://github.com/mozilla/application-services/), where we expose Rust libraries to a number of platforms (well, currently just iOS and Android, but eventually various Desktop platforms). Basically, after building a native library, there's other packaging we need to perform to produce a complete binary. This might include invoking a separate build tool for native bindings, and packaging things together, or it might include. We ended up using/abusing Gradle on Android (which we might need anyway for decent IDE integration with android code), and some shell scripts for other platforms. It's not a great situation, but these mostly run in CI so it's not a *huge* problem for us anymore. That said, there are some things we'd have liked to do that we didn't due to the lack of support here, mostly around (non-rust) code generation.
Thanks again for your clarifications. I guess it's not that suprising considering how similar Vecs and arrays are. I need to look at your thoughts in more details later tonight. And just play around with Vecs and arrays. But so far I think I understood why a reference/slice to both is the same thing. Just one very last question: Why will an array `[i32; 10]` not do anything when you drop it? is an array stored entirely on the stack?
Helpful tip, use the reddit "code" button to turn off reddit markup. Reddit doesn't take use "```" to delimit code. #[cfg(platform = "wasm")] #[inline = "always"] fn blah() {} #[cfg(not(platform = "wasm")] fn blah() {} 
&gt; Debian does not allow crosscompiling for packaging. I think that's the big question. I guess they were bitten by the brittleness of C/C++ toolchains too many times in the past. I've had so many incidents compiling on a recent Linux/BSD and trying to run on an older one, only to realize the program cannot load `glibc` because it was built against a newer version.
Reformatted: 
&gt;I don't think that you should call ´thread_rng´ each time you generate a random number. I think the language I used was misleading. Your suggestion is actually what I'm doing. My mistake. Thank you for the very helpful suggestions in this thread!
It was a number of years ago (6-8?), so I both suspect things have changed a great deal, and don't quite remember everything. The use case was also a bit odd since the language was not completely Turing complete (rather, the subset of it we were using LLVM for wasn't -- we used it as a JIT). That said, for some of this it basically looked like implementing versions of optimisations LLVM would eventually perform on it's IR on our higher level IR. I think we also did some annoying stuff to avoid allocas, but I'm having trouble remembering, sorry.
Rust's standard library and culture of both "generic programming by default" and also heavy use of macros (primarily for `#[derive]`) are one thing I'm afraid of here. But we should be in a better place than C++ in some major ways. C++ instantiates templates over and over in each TU and then combines them in the linker; Rust only has to do the instantiation once for each crate, and with some work we could extend that to once per final binary. (MIR-only .rlibs, plus some inter-crate knowledge?) Rust generics' extra semantic information means we can do pre-monomorphization MIR optimization to cut down on the generated IR we pass to LLVM. Macro expansion itself could probably be sped up quite a bit from where it is today, as we stabilize more of the interface and remove the corresponding shims, and find the resources to optimize the implementation. But some of the most common ones (e.g. Serde) *generate* a lot of code- maybe we can find faster approaches in "userspace" there (a la miniserde, to continue the example). Overall I don't think we've really hit the wall with "generic programming by default" *quite* yet.
Certainly- I didn't really take your framing as mutually exclusive, this was just an easy jumping-off point. :)
&gt; Why will an array [i32; 10] not do anything when you drop it? is an array stored entirely on the stack? Correct. Like tuples and structs and int primitives, arrays are stored directly on the stack. The main thing all of those types have in common, is that they have a known fixed size.
That's a shame! I wonder if you could get your university to collect the donations on your behalf...🤔
It's also notable **how much more** Clang compile. Remember that C++ `#include ""` is about *textual inclusion*. I remember doing some statistics in my previous company, and the average `.cpp` file, once pre-processed, was resolved into a multi-MB monstrosity. This means that if you have two equivalent codebases, where each `.rs` is mapped to a `.cpp`, and a few dependencies, then each preprocessed `.cpp` file will be *larger than the sum of all `.rs` files*. C++ compilers are beasts.
Or dig out a copy of MS-DOS and Turbo Pascal 7.0.
True, I completely left that out! The equivalent comparison for Rust would be... a first-time compile, including all the dependencies? *That's* generally a metric I've completely given up on, and just let it be slow while I do something else. :[
crates.io is great... ... however I'd like to remind that no self-respecting company wants their build systems/CI to have to connect to a random website over Internet, both because it means opening holes in the firewall and because it means being subject to downtime (even if historically the chances of the latter are minimal). So, before building sscache into crates.io, it would be worthwhile ensuring that the whole system can work in "cut-off" mode, with custom repositories.
Those are both valid reasons to use `unsafe`. `unsafe` is a means of indicating that you are about to do something involving invariants that the compiler can't prove, usually with the implication that _if those invariants are violated, bad things can happen_. The first reason you listed is one such scenario of this. `unsafe` needs to exist because, in general, proving all imaginable safety conditions is undecidable. The Rust compiler will undoubtedly improve over time (e.g., the borrow checker will get smarter, we may even get dependent types someday!) but there will _always_ be scenarios in which the Rust compiler cannot prove an invariant. For these situations, we will always have `unsafe` to provide an escape hatch.
I would expect a properly developed caching layer to allow for *custom* repositories, so that companies will just host their own crates.io, with their own pre-compiled/cached packages, rendering any hijack issue moot.
That looks more like an example for why this would be a bad idea to me. The second example is much harder to parse (for a human), this is especially bad for things that have side effects, if I were skimming through the code it would be really easy to miss a `_` and would then assume that `fs::read` is always called rather than conditionally which is the case. The `_.get("section")` is less bad as the `_` is at least the first thing in the expression, making it easier to see at a glance. Still, it is less clear than an explicit closure.
Oh I didn't mean to imply that they do, I'm not sure to be honest. Was just trying to voice a concern, especially when we're dealing with compiled artifacts.
Ahh yes of course. That makes sense! :-)
Sorry your in the wrong Reddit. This is the one for the programming language. I think this is what your looking for: https://www.reddit.com/r/playrust/
I'll add to the other reply that `unsafe` does not actually disable any functionality. It actually *adds* functionality. You might know this already, but it's a myth that pops up sometimes. The only thing `unsafe` does is allow you to dereference raw pointers, and call other `unsafe` functions. The borrow checker still checks borrows/references like it usually does, but it does not govern raw pointers.
The first thing that jumps out to me is the update function: fn update(msg: Msg, model: &amp;Model) -&gt; Model Why taking in a &amp;Model instead of &amp;mut Model? With a &amp;Model you would likely have to do .clone() and then modify Model, just like in your todo MVC example https://github.com/David-OConnor/seed/blob/35609eba0c7bfcef6e1a398197ff77fb33dd9063/examples/todomvc/src/lib.rs#L135
Working on it; now that the edition is out, the core team should have a bit more bandwidth, and I'm helping to coordinate some things with them.
Thank u 
So the inner future in this case would be my TCP stream? I'll give that a go.
Yes, I would imagine that both "can use with custom/private sccache cloud" and "can continue working in offline mode" would be hard design requirements.
I want to remove first N elements from `std::collections::BTreeSet` \- what is the easiest way to do it, apart from writing something like this: let btree = std::collections::BTreeSet::new(); ... for _ in 0..n { let item = *btree.iter.next().unwrap(); current.remove(&amp;letter); } or let elm = *btree.iter().take(total_workers + 1).last().unwrap(); btree = btree.split_off(&amp;elm);
Good on you. I tried something similar but for Go 2 years ago and have moved from C to Go. I guess I get just one life, so not going to mention Rust in near future but I wish I could. 
&gt; #[macro_use] &gt; extern crate http_guest; I may be mistaken, however I believe this is the pre-2018 edition syntax, and that with the 2018 edition: - the `#[macro_use]` is unnecessary, macros are imported like any other items. - using `extern crate ...` is unnecessary, all crates mentioned in the `Cargo.toml` file are automatically brought in. Granted, the 2018 edition is fairly new, however it is the new default, and more importantly, the new "nightly" default, when using `cargo new`.
 Without this line, it will not work with most web servers. Eg the only dev server I've been able to get working without this line is Rust's HTTP. For example, Python reports a MIME type error, as does opening the HTML file directly. See \[this wasm-bindgen example\]([https://github.com/rustwasm/wasm-bindgen/blob/master/examples/no\_modules/index.html#L16](https://github.com/rustwasm/wasm-bindgen/blob/master/examples/no_modules/index.html#L16)).
No prob, may want to drop that reasoning in the README. It's probably because a lot of dev servers don't auto-set the content type header for WASM properly.
You're correct. I wrote this post about a week ago. I didn't realize that it would change before publication! I'll work on getting it corrected :)
IMO analyzers like this one (Mathworks' Polyspace is similar IIRC) are not useful unless your mission is one like NASA's. No room for failure of any kind.
That's a good point. This detail (and related dets, like wheather the view func takes a Model or &amp;Model) is not stabilized. I'm trying to balance API decisions with speed (ie not cloning too much). I've attempted a functional-style (eg Elm or Redux) immutable-design pattern of not forcing the API-user to mutate the model... Although as you've noticed, the todomvc example inelegantly sidesteps this. I've attempted having the update function accept a Model (not mut or a ref) through an internal clone, but have not found a way to do this while satisfying borrow and lifetime requirements. (This might allow an immutable design pattern in the update func without cloning).
Solid idea; will do.
Not sure about the general trend, but when I was compiling LLVM it was the linker that OOM'd my desktop by using 2Gb per core.
+1. Thanks for maintaining this. I have it bookmarked.
Well, it's not like building Chromium is easy. Back in the day I took a freelance contract to do that (for Windows) and had to give up after 2 weeks of fighting with bespoke undocumented build tools throwing ungooglable errors at me... but no sooner than in 2 hours since launch.
To add to this, affirmative action originally was meant as an action of justice (e.g. reparations to descendants of slaves). Today it's become more of an ends unto itself, divorced from the idea that a wrong must be made right, and its meaning has been cheapened. I think this episode of one of my favorite podcasts discusses the issue with clarity: https://soundcloud.com/citationsneeded/episode-52-attacks-on-affirmative-action-and-the-commodification-of-diversity
"Not useful" is too strong. This tool is useful whenever you would like an assurance of writing safe code. It could be a great way to audit unsafe blocks.
And loose a lot of precious time understanding why your 150kloc code set has 250000 warnings
I agree on that part. However, if this really can be used to analyze LLVM IR, and by that Rust, like OP said then I think it would still serve as a tremendous tool for the part of the Rust ecosystem that includes safety-critical code, such as cryptography. Having more formal testing tools, the likes of [Frama-C](https://frama-c.com/), would be a great help in increasing the general trust towards replacing safety-critical C code with Rust for example.
The more tools available to help make things correct when it does matter, the better. As systems written with Rust increasingly involve human safety or are connected to products responsible for lots of money, the value of "NASA-level" correctness becomes increasingly apparent.
Sure, there are always trade offs
Thanks, that was great! :)
&gt;And loose a lot of precious time understanding why your 150kloc code set has 250000 warnings For essential crates that underlie a large number of major projects, I could see certain crate maintainers, or even corporations, finding it worthwhile to comb through that output.
It's released under the "NASA Open Source Agreement 1.3" which is probably not an open source license. The license bans adding other open source code to the software.
Wrong sub, buddy
Which sub is the right one?
This is the subreddit about the programming language not the game
Owww
/r/playrust
Thx
Yeah, even something like "lets verify every warning against rust stdlib tests" would be worthwhile. Seems like making sure rust and rust libraries are safe would be worth the time.
This is far less ambiguous to read than any Rust generics which can essentially take any value whatsoever. Practically impossible to find out what kind of parameter is expected unless the one is either familiar with the given api's or has opened documentation, and even in this case it's not trivial to find out that some generic parameter of type P can be closure, string, reference to Path or whatever. &amp;#x200B;
It is [OSI-approved](https://opensource.org/licenses/NASA-1.3) as an open source license, and tldr-legal's analysis of it doesn't seem overbearing: https://tldrlegal.com/license/nasa-open-source-agreement-1.3-(nasa-1.3) The "must register with the government when you get the software" is a little weird.
Alternatively Mozilla could sign the binary with its cert
Generic functions are something completely different in the context of readability. If a type parameter is defined without any trait bounds we may not know what the type is, but that is also part of the point. It doesn't matter what the type actually is at runtime. Because the function have no way of knowing what the concrete type is we now know that there is no way for the function to modify or otherwise use the value(*). On the other hand if there is a bound then we can just look at the documentation for the trait to see what is expect. * This isn't strictly true in Rust, but for the most part it is the case.
In this specific case, the Deref trait just make things a little shorter. You could just use `my_vec.as_slice()` instead, and you could just call slice methods like that, converting manually each time. For the Deref trait, it it meant to be used mostly for "smart pointer" types, so that things like \`Rc\` (reference counted pointer) and \`Box\` (owning pointer) are less painful to use and feel more like pointers since you can use \`\*my\_box\` to get and modify the contents. Imagine how the following would look without Deref/DerefMut and deref coercion. let mut x = Box::new(5); *x += 2; assert_eq!(*x, 7); Other than just making code shorter, the other key difference is that you could replace the box above with just a normal reference, and it works exactly the same. This consistency eases understanding. This also allows us to develop new pointer types in our libraries and not need them to be built into the language. &amp;#x200B; Traits in general are very important for generics. For example, the Ord trait lets you write a sorting function that works on *any* type that is orderable. The Iterator trait lets you write functions like `map` or `filter` that work with *anything* that you can iterate, and without it you couldn't keep chaining these. Another great example is the reason you can inspect a `HashMap&lt;String, T&gt;` using a `&amp;str`: the Borrow trait. I'd suggest trying to read and understand [the example here.](https://doc.rust-lang.org/std/borrow/trait.Borrow.html#examples) I would try not to stress too much about how some traits like AsRef, Deref, and Borrow work for a while, until you really need to implement them. Just enjoy using them :)
This is really cool! Is the current plan to go for parity with pbrt, and are there plans to implement other stuff?
Imagine you're writing an operating system, for x86. You want to print something to the screen. The API for this is to write some bytes to the memory starting at `0xb0000`. How would you encode this in Rust's system without `unsafe`? The only way that I can think of is, you'd have to include the entire VGA specification into the specification of Rust. And even then, you'd be trusting that the language authors properly implemented support for that whole spec. This is basically what unsafe does; it lets you build up abstractions where you know things are okay, but the language itself cannot know. This actually extends more broadly; see https://en.wikipedia.org/wiki/Rice%27s_theorem for the Real Computer Science Answer. (And, your second answer is basically a sub-set of number one; the hardware itself is outside of Rust, and therefore unsafe, and so any attempt at running Rust on real hardware must confront this question.)
Does it only guarantee memory safety, or can it make other sorts of guarantees as well? 
Python informs you of anything at all? Why doesn't it inform me?
can you describe possibly the advantages of this over something like nom or pest?
&gt; Dec 16. Sydney, AU - Rust Sydney Meetup 15. is actually on Dec 17 local time. (I guess it was copied out of the calendar in an American timezone.)
Accord to the comments on the r/C_Programming it only can do [these checks](https://github.com/NASA-SW-VnV/ikos/blob/master/analyzer/README.md#checks) https://www.reddit.com/r/C_Programming/comments/a5a5nc/ikos_21_an_open_source_static_analyzer_for_c_and_c/ebn79e0/ Which notable misses data races, so this isn't memory safe at least not with multiple threads. But since these checks should be sound (no false negatives), it should still be very useful for critical C. The amount of false positives will decide how practical it is for non critical systems. Since I think this works at a LLVM-IR level, It might be adapted to help verify unsafe Rust code.
If you're only targeting unsafe code it's not going to be 150kloc (I really, really hope) but probably a matter of 100loc per project.
This is an ugly hack. If you can't stream it because of wrong content types, then you should be able to use `WebAssembly.instantiate`, but that doesn't require deleting `WebAssembly.instantiateStreaming`.
I tried it with `rustc --emit=llvm-bc` and got this: ikos-pp: bc/bc.bc: error: Invalid record ikos: error while preprocessing llvm bitcode, abort. Might be missing something, but it doesn't seem to work on Rust.
This is my post in response to the [Call for Rust 2019 Roadmap blog posts](https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html). I hope it's useful, or at least interesting! :-)
You could argue the same thing for formal verification of software. But it happens and some cases it is essential. For example you don't want to use a FS that is not formally verified. 
How do you recommend apply this?
Well you might be waiting on different things in different states, so each state could have different futures they wait on. Of course which and how many states you have depend on the specific future you're implementing. To answer your question: yes, you will need to wait on the tcp stream in one of the states. 
That's true, although I haven't had time to play around with it.
It says in the readme it only works on C and C++.
Is there reason to think you might be able to target just unsafe blocks?
If you need something like a state machine, I would propose that you look into future state machines. It is a crate that abstracts the state handling for you. 
Very good summary of editions. I agree, what the compiler team did to make "Rust 2018" happen was nothing other than a miracle. But you have some good points on why that should not happen often. I finally "jumped" into adopting Rust literally one month before "Rust 2018" landed, and so I think it is the Bee's knees. I can't wait to see where this goes. I'm especially excited to see what they do with Cranelift.
&gt; The tower_service project does look promising but I’m trying to understand how it would work from the perspective of what’s already out there, such as wsgi for python or php-fpm for PHP. These projects are different from Rust, in that the web server is implemented in a different (non-python or non-php) language to the web framework. In Rust, the web server is simply part of the Rust program, implemented in Rust (quite possibly in the `hyper` crate). &gt; The middleware shouldn’t need to pull in an external crate to call the callable function in the web framework. Rust's approach is to put as much as possible in external crates to avoid issues that projects like python have had with not being able to remove old approaches from the standard library due to backwards compatibility guarantees (e.g. python has urllib, urlib2, and urllib3). Other important functionality such as regex's and random number generation are also in external crates. Pulling in an external crate should not be seen as a big deal.
It also works on llvm ir, see above comments.
Hmmm lots of interesting information. I saved your post as well. I'll look at the example when I am better at Rust. But one point I can already make: &gt;the Deref trait just make things a little shorter. You could just use my_vec.as_slice() instead, and you could just call slice methods like that, converting manually each time. I'm a strong proponent of "explicit is better than implicit" and verbosity in general. That's why I don't like traits. But as I said previously. I'm sure there must be a reason why everyone is so in love with traits. Thanks! 
Thanks for your answer. I don't have the necessar background/CS knowledge to understand it, but I saved it for later. Maybe/Hopefully I'll understand this in a year from now. It's not THAT important, I just like to think about stuff like this. :-)
&gt; (e.g. python has urllib, urlib2, and urllib3) ...and the urllib3 developers made keeping it out of the standard library an explicit goal for just this reason.
It's all good! It's mostly just to say "this kind of thing is really hard, and maybe literally impossible". There's a lot of interesting questions around this stuff, so keep thinking!
*Could be* used.
OK a few quick follow-up questions: 1. So there will ALWAYS be unsafe() blocks within Rust? Even if Rust would one day be completely finished? 2. So how sure are we that all the unsafe() blocks within Rust are safe? 3. Can we even be sure? 4. Have there ever been any Rust bugs due to using unsafe() blocks?
&gt; [Type-level Integers] It's a long-standing paper cut that feels like a missing feature I really agree with this and the whole paragraph is spot on.
Agree with the Editions opinion. They're a necessary evil and we should use them as little as possible
This is sort of a follow-up question to a previous question of mine: [https://old.reddit.com/r/rust/comments/a4tr69/hey\_rustaceans\_got\_an\_easy\_question\_ask\_here/ebn61ht/](https://old.reddit.com/r/rust/comments/a4tr69/hey_rustaceans_got_an_easy_question_ask_here/ebn61ht/) My understanding and just me thinking out loud: 1. C/C++ is only not safe because humans make errors 2. Rust has the ownership/borrowing system, but as I just learned it's not 100% safe either. So let's assume we had a perfect AGI (artificial general intelligence) and I'll tell that AGI to write an entire operating system in C or C++. Since the AGI is perfectly smart there'll be no memory/safety/whatever-it-is-called errors. Then I'll tell one of you (very smart, but nowhere near as perfect as the AGI) to write an operating system in Rust. If you did that and you would NOT use any unsafe() blocks. Would the Rust operating system written by humans be equally safe or less safe than the C/C++ OS written by a perfect AGI? I know this is pretty hypothetical, but that's what I/my brain think(s) about. :-)
I've asked on that thread whether this is significantly different from existing tools like KLEE or SMACK (the latter of which works with Rust), got a response that [it is](https://www.reddit.com/r/C_Programming/comments/a5a5nc/ikos_21_an_open_source_static_analyzer_for_c_and_c/ebnwxzm/). It would be very interesting to apply it to critical pieces of code such as Rust stdlib primitives.
I'm not saying that you can *today*. But if one wanted to take this project and apply it to rust that seems like the way to cut out a ton of noise. Perhaps an approach like Seer, something hooked up to miri. As far as I am aware, this (miri-backed) approach to analyzing unsafe blocks independent of other code has already been discussed.
Interesting! Thanks. I wonder if any of the checks that rust does to even unsafe code would help eliminate some of the false positives. This sort of thing combined with formal proofs of correctness make for an exciting future. 
The bit about `[cfg(platform = "wasm")]` was kinda wrong on my part. It should actually just be one declaration with `#[cfg_attr(platform = "wasm", inline = "always")]` in the validator lib. Additionally, reading the docs of wasm-bindgen, you have to do some stuff to use serde: (1) Add this to your Cargo.toml: ``` [dependencies.wasm-bindgen] version = "*" features = ["serde-serialize"] ``` (2) Deserialize the parameters, and serialize return value: ``` fn validate(p1: &amp;JsValue, p2: &amp;JsValue) -&gt; JsValue { let actual_p1: MyType1 = p1.into_serde().unwrap(); let actual_p2: MyType2 = p2.into_serde().unwrap(); let res: MyReturn = my_lib::validate(actual_p1, actual_p2); JsValue::from_serde(&amp;res).unwrap() } ``` (3) Pass parameters in JS as regular objects: ``` wasm_validate({ thing1: true, blah: "x", arr: [4,2,5], j: { u: true } }); ``` However, note that you can (probably) only use arrays with one type, due to the Rust conversion. You should write your library to accept borrowed structs (for the most part, unless there's barely any data in the struct), because it doesn't need ownership.
I saw the talk last night and thought it was really good.
It sounds like maybe you're not opposed to traits, just the Deref trait, since it corresponds to some builtin implicit stuff. I can understand liking things to be explicit. To me, Rust usually has a pretty good balance, but that's a totally valid thing to be up for debate on language design. For comparison, how do you feel about overloading operators, like addition (`a + b`) and indexing (`v[i]`)? I'm having trouble wording what I want to say next. Basically, the job of a reference is to give you a "view" into something. So, a slice is exactly that, a view. So, referencing a Vec (with `&amp;`) should be able to give you this view of it, because that's the job of the reference operator. A slice reference is just a fat pointer (pointer + usize for length). A slice is just a read-only version of a vector, since it's the same representation as a vector minus the capacity field. So why not just use `&amp;Vec&lt;T&gt;`? An objective reason is better performance. Having a reference to a vector means an extra pointer lookup whenever you index it or check its length, since the Vec itself has a pointer to its data. Another reason to have slices is code reuse and simplicity. All methods that just modify elements (not expanding/shrinking stuff which is Vec only) can be implemented on slices, and then don't have to be reimplemented for arrays, Vecs, and any other types which use contiguous data the same way. Instead they can just say "hey, my data is contiguous and here's how you get a slice of it". Since it sounds like you haven't looked into traits much, I'll try to explain more on what they are to hopefully help your mental model. Traits serve multiple purposes. The purpose you may not like is to make things like indexing, addition, dereference, and comparison operators overloadable. Another is to say what types can do, like "values of this type can be converted to a string if you call `to_string` on it" or "this type has a default value, here's how to make it". A third use is to signal information about a type, like Copy which says "you're allowed to bit-for-bit copy me, I don't own anything special", or Sized, Sync, or Send.
Is the hardware also created by this perfect AI? Is this hardware running in a perfect place, under perfect conditions? In a perfect world, both OSes would be just as safe, with or without `unsafe`, as you can have safe `unsafe` code, see the [vec.rs](https://doc.rust-lang.org/src/alloc/vec.rs.html#698) `truncate` function as an example of that. I would try to read `unsafe` as an idea (a marker of potential bugs), more than an issue of actual program unsafety.
Many (most/all?) of the O'Reilly books are available from [https://ebooks.com](https://ebooks.com) in the original (IMO, best) DRM-free PDF format (see a list of O'Reilly books at [https://www.ebooks.com/searchapp/searchresults.net?publisherId=36485](https://www.ebooks.com/searchapp/searchresults.net?publisherId=36485)).
No the rest would be the way it is now. What I'm trying to understand: Is C/C++ code that does not contain any human errors and Rust code equally safe?
&gt; As for the possible future Rust 2021 Edition... well, this may also be an uncommon opinion, but I hope we don't have one. Frankly, I hope we don't ever have another edition of Rust at all. I hope 2018 is the first and last one. Something to keep in mind is that Editions are more than just a way to evolve the language, they are a sync point for marketing and content. They serve as a standard point for books to be written around Rust. They serve as an opportunity to "catch up" on all the Rust happenings for those who don't follow everything going on in the 6 week release cycle. iirc new warnings cannot be enabled by default without a new Edition so Editions also serve to evolve best practices. Even if the language does't change significantly, we're going to learn better ways to use it (e.g. `unsafe`) and we'll need "breaking" Editions for these. Another level where breaking Editions are important is for introducing new keywords. I hope there isn't a flood of these but it is better than the weird hoops C++ has to go through to avoid breaking people.
Really good talk! I had been somewhat focused on the higher level SIMD crates, and it was super useful to understand the lower-level details. 
You would have to define what you mean by "safe" there. * The program never crashes? Can't be done. * You can't exploit it? The hardware is still exploitable (bios, microcode, ...). * No undefined behaviour? Then you must define behaviour for every operation. Your question is kinda of a rabbit hole, you can always go deeper and find "unsafety", but the shallow part doesn't have a proper answer either (at least in my opinion). Also, when `unsafe` makes sense, you should use it, it's a language feature, don't worry so much about it :D.
Move fast and break links is the philosophy I suppose.
On the old website one of the main features of Rust was: &gt; guaranteed memory safety That comes from having a ownership/borrowing model/concept and that's something C/C++ cannot guarantee. Are both those assumptions correct? 
&gt; Safe Rust is the true Rust programming language. If all you do is write Safe Rust, you will never have to worry about type-safety or memory-safety. You will never endure a dangling pointer, a use-after-free, or any other kind of Undefined Behavior. And also from the [rust nomicon](https://doc.rust-lang.org/nomicon/what-unsafe-does.html) &gt; The only things that are different in Unsafe Rust are that you can: &gt; * Dereference raw pointers * Call unsafe functions (including C functions, compiler intrinsics, and the raw allocator) * Implement unsafe traits * Mutate statics * Access fields of unions These are things that C++ let's you do by default, while Rust requires you to wrap them in an `unsafe` block. You can read more about [safe and unsafe](https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html). Safe Rust is mostly about preventing undefined behaviour. 
It's an interesting perspective I hadn't considered, but I think he's right.
Probably the best [documentation on the subject is in the rustonomicon](https://doc.rust-lang.org/nomicon/casts.html). Long story short `from` is a method that can do arbitrary conversions and is always safe (but it can be `panic`ky), `as` operates like casts in C.
I haven't used this crate, but one advantage might be better IDE support and error messages, since it doesn't use macros. 
&gt; Something to keep in mind is that Editions are more than just a way to evolve the language While that is true, IIRC the motivating reason for editions in the first place was the way they handle and allow for breaking changes. They are also _convenient_ as a sync point for documentation, marketing, etc., and it totally makes sense to me that 2018 Edition was used for that. But we shouldn't have to make a _technological_ edition (the kind that requires a new edition your Cargo.toml file) to have those kinds of sync points. In any case, to clarify my opinion from the blog post: I am totally down with having sync points for documentation, books, marketing, etc. And having a regular cadence for _that_ is fantastic. It's the actual breaking changes--the technological side of Editions--that I think we should generally try to avoid, or do as infrequently as possible. My motivating example in the post I think illustrates best what I'm getting at: sitting down as a new user, and reading a tutorial or Stack Overflow answer and having it not work because of the edition. That's a cost we're paying, and I am hoping that moving forward we don't treat (technological) editions as a given, but rather as things that need justification. So in the case of new warnings and keywords like you mentioned, those are likely to have less impact in the way I'm talking about, and I suspect I wouldn't be too concerned about an edition consisting only of those. However, those also aren't the kinds of things to excitedly look forward to or plan for or ask for people to write blog posts about 3 years prior. So my impression is that people are thinking about editions as being for language evolution via breaking changes. I could totally be wrong about that, but that's my impression, and that's what I was responding to.
Thanks for sharing. I like your thoughts on 80% solutions, but I wonder how long an 80% solution could stay an 80% solution if it becomes popular. One aside, the first two links in the `compile times` section result in a 404 for me. 
Hey, thanks for sharing my post here. I always keep an eye on r/rust ;)
Is there a phone number or someshit I should call?
Nowhere in the license does it say you must register it is merely a request.
Thanks telling me about the broken links, I've fixed them. Your point about how long an 80% solution stays an 80% solution is a good one; I think it mostly depends upon the author(s) recognizing when they've reached that "80% mark" and to then be very conservatives in the changes they approve, lest feature-creep transforms a simple 80% solution into a complex 9x% solution.
The book is a good start: https://doc.rust-lang.org/book/index.html Also, is always good to have rust-by-example: https://doc.rust-lang.org/rust-by-example/index.html
 i don't like communist party of china.they are fascist. this picture just game's friendship
...
Hi! This subreddit is for the programming language called Rust. For the game Rust, there is reddit.com/r/playrust
Hi thank you so much for replying! Would you suggest going through the rust book first before jumping into any projects or vice versa? 
I personally read the book while doing some exercises on codewars and exercism, after finishing the book, I did some projects
As a beginner myself, I got a suggestion in this subreddit that I liked: You can try to port one of your existing projects to Rust. So you have a familiar codebase that you know how it should work to compare against. As for whether you should read the book or jump into projects, I think that's a personal learning style thing. Although if you're not familiar with typical workflows in Rust yet, I found the Cargo docs helpful to get started quickly and learn about Cargo (which can set up a new blank project, act as a package manager e.g. for libraries you need to use, and even can call rustc to compile your project.) It's pretty much expected that you'll use Cargo if you get into Rust.
&gt; I wonder how long an 80% solution could stay an 80% solution if it becomes popular A classical 80% solution must not be the only way to do something, and as we have multiple Turing-complete languages to wield within Rust there's plenty of space to grow solutions that provide great ergonomics in some but not all situations. An 80% solution must express a very clear benefit for not covering some imagined use cases. I at least am quite willing to accept feature loss in `miniserde` since it compiles way faster than the alternative `serde`+`serde-json`+`serde-derive`. Users will choose solutions like `miniserde` because they _really want_ that compilation speed and the other trio doesn't offer it.
Wow, this blog and the replies serve as elegant proof that it's hard to find people that aren't constantly talking out of their ass. The blog post somehow barely fails to trip my Troll Detector. Barely. The comments somehow make it all much worse. The people that fell for it (regardless of if they knew otherwise, they failed to see through the complete lack of rhetoric in use), their own comments, the suggestions that make even less sense (Chromium and Chromium-based browsers tend to consume more memory than the Firefox build). Ouch. This is all around some amazing cringe.
I believe this is what is being called `const generics` in Rust circles. As far as I know it's currently blocked by the trait rework that is part of Chalk. GATs are another thing blocked by this. I'm not sure where the RFC designs stand, but I think it's hard to build sheds when you don't yet have Chalk to stand on. Personally const generics are the number one feature I feel Rust needs to solidify it's promise to be the best-in-class low level systems language.