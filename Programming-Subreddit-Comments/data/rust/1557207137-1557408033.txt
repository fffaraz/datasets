Happy to see that there is a deadline! I find the dot syntax unfortunate. Dot dot would have been my personal choice `future..await` but I don't see it as an issue in practice because I guess await speaks to most people anyway.
Hi Thanks for answering. I have got a solution by myself a couple of days ago as follows: let mut rows_iter = from_rows::&lt;CustomerAccountMovement&gt; . (stmt.query(NO_PARAMS).unwrap()); let mut v: Vec&lt;CustomerAccountMovement&gt; = Vec::new(); loop { match rows_iter.next() { None =&gt; break, Some(cam) =&gt; { debug!("CAM: {:?}", cam); v.push(cam); }, }; } However, your solution based on collect looks more elegant so I will give it a try. Also, regarding your question, the from_rows was failing at the first because a table column name different from the struct field name (snake case vs java style). Thanks a lot. J
Hi Thanks for your answer. I have already fixed it (check my solution in another message of this thraead). J
Exactly, thanks for clarifying! You explained it much better. Every beginner will run into the "there is something weird with field access" but very few will run into the "there is something weird with the await macro" problem.
Could it still be on the table to conservatively implement obvious precedence `(await expr)?` now, as it has broad but unenthusiastic support, and then look to enable postfix notation in a separately and consistent manner? Whether that is `expr.await expr.match` or `expr.try!() expr.await!()`. As much as I prefer the utility of postfix macros to postfix match/if, I think the most important thing is to avoid having one postfix scheme land and be stuck with await as a lone special case of the opposite. This delayed gratification path would seem to have the best of all worlds, eventually, and avoid magic special cases which may never be reconciled. Is there internally a feeling of wanting to finalize async/await in one go?
Working in my implementation of *cat* to practice Rust and programming in general. &amp;#x200B; I'm trying to generate the same results of the GNU version. &amp;#x200B; Actually I don't know very well how to program the --show-noprinting option. &amp;#x200B; But I think I've come a long way and it's usable. &amp;#x200B; [https://gitlab.com/Armiixteryx/ax-cat](https://gitlab.com/Armiixteryx/ax-cat)
Frequent lurker here. Can someone explain the difference between `Borrow` and `AsRef` to me? [The docs for AsRef](https://doc.rust-lang.org/std/convert/trait.AsRef.html) make a distinction between "turning it into a reference" and "agnostic to what is passed", but both situations seem equivalent to me?
It is mostly by sound, there are many screen readers that can read code out loud. I am not a fan of postfix await because it looks like a lot of magic, that is hard to understand and visualize. At least there is a chance to have prefix await and use it with temporary values.
&gt; We're half way through the year now with no sign of this, so what gives? "But we do hear the concerns, and we want to work through them!" sure *sounded* nice. Still accusing the team of bad faith certainly won't make them eager to work on that retrospective.
This is something I see more often in Python, where it is actually a point to gave slightly a sentence like syntactic structure, but rust is far from that, rust favours deeply nested expression and control flow. It is not that a sentence like grammar is inerently bad (e.g. Python) but it is not at all obviously why this should apply to rust or the other dozen languages I had seen this argument proposed. Anyway thanks for the nice answer, I don't think it is a bad argument, just that some pieces are missing, your answer provide a few of them, so I can rest at peace :-)
&gt;I find reliance on code viewer/editor features should not have its place in language discussions. If that is a guiding principle then all new languages should be designed with line editors in mind. Or maybe punchcards. I'm not saying every language designer should assume IDE-level refactoring power, but syntax highlighting has been a thing now for quite some time, and is supported in many tools (ex: Rust diffs in VSCode).
I agree, and it's good to bring this to attention since it needs international contributors' help. But I was about to ignore this topic, since the title sounded like yet another generic faux-discussion topic, used only to vent. Something like "Translations of the new website" would have been much better.
This is explicitly stated in the post: &gt; In this world, the dot await operation would be generalized so that await were a ‚Äúnormal‚Äù prefix keyword...
Starting with prefix (with postfix in mind) may lead to the conclusion that prefix with braces is enough and postix is not needed :P
&gt;Unfortunately the new design t[argets managers and CTOs](https://github.com/rust-lang/www.rust-lang.org/issues/431#issuecomment-442985053) "Unfortunately"? I think this is an important and good decision. Rust is already popular in the community of forward-thinking programmers, but it has yet to pick up any significant industry steam (try searching for "Rust jobs"). It's reached the point of its life-cycle where it needs to sell itself upwards in order to have a lasting impact. I partly agree that some code snippets on its front page would be good to appeal to those coders scoping it out, but really that's just selling it on its syntax. That's not Rust's main selling point.
The design in the linked issue looks way better! Why did they close it?
`mem::size_of::&lt;T&gt;()`, `Iterator::collect::&lt;Vec&lt;u32&gt;&gt;() ` to name a few
&gt;I find reliance on code viewer/editor features should not have its place in language discussions. Tangent: you should read up on Type Driven Development :) Building languages that appreciate how much smart editing environments accelerate productivity is a step into the future! Being obsessed with programming languages simply being a bit of plain text and nothing more at the core is just clinging to tradition.
This is the beginning of a Thomas Pynchon novel.
New account on here, new account on Github, Github account isn't even an organization, no actual code written, no real names (or any names) attached, Googling the org name just gives this post and the Github repo. I'm definitely leaning towards "troll" on this one.
Managers reading a programming language website? Shudder.
We are still almost 60 days away until half of 2019.
Sorry for the going off-topic, but what theme is that?
Those are not in argument position.
Oh right, it was early this morning :D
Simple question that's been hard to google and answer: What is the difference between these two function signatures? `fn my_function(input: &amp;mut Vec&lt;i32&gt;) { ... }` `fn my_function(&amp;mut input: Vec&lt;i32&gt;) { ... }` Are they both valid function signatures? From my experience it seems that in the first case the \`input\` type is a reference to a mutable \`Vector\` with \`i32\` elements. I think the second case is saying \`input\` is giving direct ownership of a \`Vector\` with \`i32\` elements. Then as a second step, since we have ownership of \`input\` we can choose to define it as mutable. And the &amp; means anywhere we use \`input\` in the rest of the code body it will be a reference to the initial argument.
To be clear, you are replying to a post that specifically calls out that I do use the feature and do not hate it. As for fixing things, that includes reddit and `git diff`.
\&gt;Thus the same should be possible for all expression based keywords (return, break, continue, while, if, etc.). &amp;#x200B; Out of curiousity, why would anyone want this to be possible? I'm not much of a fan of the postfix .await syntax either, and for these other things it seems to make even less sense. Actually using that syntax would in most cases just result in horribly unreadable code.
&gt; There is also the fact that a *user who knows anything about the semantics of the await operator* will quickly realize that its not possible that await is actually a field access. In contrast, you need to know a lot about the semantics of Rust to understand that await cannot be implemented as either a method or a macro. That is to say, a *user who is initially confused about the relationship between this construct and field accesses* will come more quickly to understand that this is a built-in construct different from field access than they would be if we used methods or macros. I feel like this is a switcheroo, first you're assuming a user that understands async/await, then you're switching to a user who is confused, but use the knowledge of that first user to escape confusion. &gt; First, by using a reserved keyword, it will be differentiated by any syntax highlighting system. Users are very likely to understand that this is different from a field access on first witnessing the syntax if it is highlighted. Alternatively users are very likely to assume that syntax highlighting is incorrectly highlighting a keyword in a context where it's not one. &gt; Even if not using highlighting, many users will be familiar with languages using an async/await syntax; while those languages will probably have a different syntax for the await operator, they will still recognize the await keyword as indicating something unusual is happening. This assumes that the user realizes that this is in fact an operator, not a field named await, in this case not even having the highlighting to help him or her realize that await is a keyword. I feel none of the explanations work in explaining how you will be able to learn Rust without having to learn about async/await nearly immediately.
I think he meant `variable` in the first sentence.
I love this *argument*: you can't frustratingly remind people in positions of responsibility of promises they have made. That amounts to accusing them of using delaying tactics. And in doing that, you just probably caused further delays in the fulfillment of said promises!
I admit, I am a bit jaded by talk of the future after being forced to read/write a decent amount of `G` (more commonly known by its editor, LabVIEW). That is the other end of the extreme and I've dealt with a let of the problems of not being able to treat code as source and don't feel like waiting for Sufficiently Advanced Tools (as the arguments I'm seeing remind me of the Sufficiently Advanced Compiler fallacy).
Have you looked at [vte](https://crates.io/crates/vte) ?
Agreed, it seems even in the excitement about opening up `.match{}`, the team missed the obvious conclusion that a lot of people who liked the prefix with delimiters option saw. The fact we have prefix match first and not postfix match is the same reason prefix await feels more natural.
I tried to avoid being accusatory and stuff in this post, just asking about the retrospective and linking to the previous discussion i could find for those OOTL. But you're right, i was being snarky with that comment, let my cynical bias slip through. I didnt want to bias the discussion with my post, as much as possible, though still a bit of a challenge due to my participation in so many of the linked threads, where i'm pretty critical. I edited the post though. Regarding bad faith, if the shoe fits, intentionally or not, well.. What else do you call it? Forgetfulness? Laziness? Are those better? We're a ways into the year now and not a peep about anything, despite assurances they took concerns about the website, the process behind the design, process, and moderation seriously. Not even anything to say "We're busy, it'll be delayed". I love Rust, and I want it to do well, so it makes me sad when stuff like this goes unanswered, especially when answers were promised.
I think one of the more damning things is the reaction of the _community team_. If my first contribution to Rust was to try and improve the new website, with the reaction that we've seen, I would have been dissuaded from contributing again. I believe that the community team should be held to higher standards than the other contributors, since they represent the face of the project.
It should have been done in [March](https://internals.rust-lang.org/t/website-retrospective/9556).
Why is Rust the only one doing it then? Why aren't any of the *other* programming language websites doing it? What actually makes it a good idea? Since when does management decide what languages developers use? Isnt it usually the other way around? &gt; (try searching for "Rust jobs") https://www.indeed.com/jobs?q=Rust+language seems to have a decent crop, and i see jobs posted on the subreddit every now and then, and there are plenty of companies using Rust.
As the closing comment says, because there ["should not be continued conversation on this."](https://github.com/rust-lang/www.rust-lang.org/issues/421#issuecomment-443460166), and other concerns like it.
`dot await` is a weird decision and is very unintuitive, let me show you why: `await` - block current execution until future is completed, and returns control to the caller. `break` - exit a loop immediately `continue` - continue to the next loop iteration `for` - loop over items from an iterator `if` - branch based on the result of a conditional expression `loop` - loop unconditionally `match` - match a value to patterns `return` - return from function `while` - loop conditionally based on the result of an expression All these keywords control the flow of execution. All these keywords, **except await**, are easily visible at a glance because it is more important to see what is happening in the code than to "hack" everything in a one-liner. Code composition is nice when control flow is *sequential, straightforward and without hidden complexity*! I hope that I will never see code like this: `foo().await.match { Some(x) =&gt; x, None =&gt; bar()}.run().await.if getResult().await.for it { break true.if it &gt; 10;false}` But it looks that Rust is heading in this direction. One last note, please do not introduce multiple ways to do the same thing! It is hard to learn, it differentiates code style, hence it is harder to read others code, and it will just bite us in the end (e.g. look at c++ of how to define a variable)
Rust hosts a [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d48a7c8ef0b19415d804418a37f21ba8) where you can easily run and test small code samples. To answer your question: The second line is not a valid function signature: error[E0308]: mismatched types --&gt; src/main.rs:1:16 | 1 | fn my_function(&amp;mut input: Vec&lt;i32&gt;) { } | ^^^^^^^^^^ expected struct `std::vec::Vec`, found &amp;mut _ | = note: expected type `std::vec::Vec&lt;i32&gt;` found type `&amp;mut _` = help: did you mean `mut input: &amp;std::vec::Vec&lt;i32&gt;`? The left hand side is a *pattern*, the right hand side is a *type*. The error message ways what's happening -- the pattern `&amp;mut _` does not match the type `Vec&lt;i32&gt;`. An example where the pattern matches the type, to show that more complex patterns in function arguments are possible: fn my_function((a, b): (i32, char)) { }
Good to know, that thread isnt tagged with anything so it slipped my radar, and i assume many others judging by the lack of activity/crossposts to the subreddit, thanks! Would have expected an important announcement like that to be tagged as such. Edited into the post.
What exactly is "fake" about the previous discussions?
If you check out the [nightly docs](https://doc.rust-lang.org/nightly/std/convert/trait.AsRef.html), there's been an improvement in them because this seems to be a common source of confusion: &gt; AsRef has the same signature as Borrow, but Borrow is different in few aspects: &gt; * Unlike AsRef, Borrow has a blanket impl for any T, and can be used to accept either a reference or a value. &gt; * Borrow also requires that Hash, Eq and Ord for borrowed value are equivalent to those of the owned value. For this reason, if you want to borrow only a single field of a struct you can implement AsRef, but not Borrow.
I believe reddits new design actually supports it. Which is a problem with reddit. As for git diff, set it to use a better diff tool. You can use VSCode with syntax highlighting, you can use vim with syntax highlighting, you can use notepad++ with syntax highlighting, etc etc. Again, "If your diff software doesn't have syntax highlighting, the solution is to fix the diff software, not redesign the language."
This was among the larger concerns at the time, too.
`Texture` cannot be made into a trait object because in order for `dyn Texture` to implement `Texture`, it would also have to implement `Clone`. `Clone` isn't *object-safe*, because `Clone` requires implementing a function fn clone(&amp;self) -&gt; Self ... that returns `Self` by value, but `dyn Texture` doesn't have a statically known size. There's an excellent four-part [blog series](http://huonw.github.io/blog/2015/01/peeking-inside-trait-objects/) on trait objects and object safety by Huon Wilson if you're interested in details.
Well, it still doesn't help, since March has come and gone.
pls await!? no braces, only await. https://i.imgur.com/q46L4QH.jpg
Looks like a quite a large regression in functionality. There are some issues open about it: https://github.com/rust-lang/www.rust-lang.org/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+translations+is%3Aopen+is%3Aclosed+ How bad is google translate for the website? I just tried with German, French, and Spanish, and it is "ok"-ish.
Nice! Always cool to hear about people contributing to Servo and having a pleasant experience with it. Keep up the good work!
Thats true, and the thread says updates would be posted but was dead until now, but still good information to have. Until now i thought nothing had been done at all since December.
That'd make me 100% in favour of `.await`. I'd love to write `await ugly.expression()`
Nearly half a year later and that comment still angers me.
&gt; control flow switches I prefer to not think of `await` as a control flow switch at all. It's a suspension point; the way I want to think about the code, it just flows linearly over it. Otherwise, what's the point in having the feature? The inability of debuggers to set breakpoints at the subexpression level is a shortcoming of debuggers, not something that should guide language design.
&gt; I have no idea what will happen if I have a struct with a field named `await` Same thing that will happen if you have a struct with a field name `if`: it won't compile.
And to no one's surprise, you were right. The author realized it though: https://github.com/vlang/v/issues/192
&gt; you can't frustratingly remind people in positions of responsibility of promises they have made Sure you can, but you need to take the appropriate tone. Especially when the people take over that responsibility as volunteers.
omg this worked \_awesome\_!!! I literally spent 2 hours last night trying (and failing) to create macros to approximate this. In about 15 minutes I integrated your crate and it does exactly what I want. And your way of using stderr output is way more clever than anything I would have come up with. &lt;3 &amp;#x200B; My use case is slightly different than yours. Rather than macros I'm making a compile-time checked units library. So this line: `let _ = Meters::&lt;f32&gt;::new(6.0) + Kilometers::&lt;f32&gt;::new(4.2);` Produces this error: error[E0308]: mismatched types --&gt; $DIR/si_units.rs:7:39 | 7 | let _ = Meters::&lt;f32&gt;::new(6.0) + Kilometers::&lt;f32&gt;::new(4.2); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `typenum::uint::UTerm`, found struct `typenum::uint::UInt` And now, thanks to you, I can easily make sure I didn't accidental enable undesirable behavior. =D &amp;#x200B; If I had one request, for some reason your stderr output seems to exclude a line. \&gt; error: aborting due to 20 previous errors In my case I've generated 20 test cases which should produce 20 errors. As I add new cases which produce new errors it would be useful for this line to be included. It's a nice sanity check.
Do you have a specific use case where you chain futures/promises (i.e. future returning a future)? I've never met such case.
&gt; correct me if I‚Äôm wrong, but if we already have a prefix await operator, it‚Äôs possible to implement a postfix await macro You are wrong. There's no such thing as a postfix macro in Rust currently, so you can't implement a postfix await macro. In order to do that, you'd first have to add a language feature for postfix macros. Those would then be different from all the (non-attribute) macros we have now, in that they would act on token streams not enclosed in their delimiters. &gt; But I reckon that‚Äôs a fairly small price to pay, especially we get the benefit of being less alien to programmer coming from another language. Disagree strongly. Having to learn the Rust way of doing things is a one-time price to pay. Having to write ugly code happens over and over. &gt; In summary, I think we need to consider how likely postfix generic keyword and postfix generic macro are going to happen. I don't have the impression that postfix generic macros are ever going to happen. Postfix `await!` was pretty much the only argument I've ever seen for them. Postfix generic keyword appears to have generated some excitement. To turn your argument around, prefix macro with delimiters is actually possible (and trivial) to implement now based on a postfix keyword.
I don't think it's doing a good job of that either. It looks pretty childish, and contains hardly any information.
&gt; Regarding bad faith, if the shoe fits, intentionally or not, well.. What else do you call it? Forgetfulness? Laziness? Are those better? I'd call it the reality of open source development. There are lots of things with different priorities, and some will take longer than planned. See also: almost any big new feature of the language. While not on the level of, let's say, implementing NLL, this particular thing is probably not too easy to write, given the backlash it is supposed to be a response to, and will take a lot of fine-tuning and diplomacy. Not something many of us are good at.
I suppose this would require variadics.
One of the point of the discussion here is that the process of peer-review is one of the keystones of research. One of the goals of peer-review is double-checking your work, and this includes double-checking a new syntax (which can be considered as a contribution if that makes things simpler to manipulate/understand) that may have flaws without you being aware of it. Peer-reviews will give you what your papers lack today: credibility. Most of us can't judge the validity of your papers because we don't know much about the underlying mathematics, but we can judge its credibility because the is no proof that anybody but you validated the claims on those articles. &amp;#x200B; The peer-review system is what makes the difference between a blog post an actual research paper. So many of us likely currently see your work as "AdvancedBlogPosts" instead of "AdvancedResearch". Your work looks great and interesting, so it would be a waste not taking this one last step of getting it reviewed by others knowledgeable in the field! &amp;#x200B; Also: \&gt; me not wanting publishing. I do, it's just that few other people understand the math well enough, have the expertise of publishing and are interested in it. It is true that in every difficult field of science, only few people understand the theory and are interested in it. But this only means that it is even more important for you to find those publishers, journals and persons to review your work because only them can give credibility to your work and ensuring the explanations are of high quality. Also this will help them (and help you) making more progress on this field by sharing contributions (through publication, conferences, etc.)
&gt; https://www.reddit.com/r/rust/comments/bfa44w/what_about_official_rust_syntax_for_vs_code/ Sure, somebody would need to implement it. Those who care enough can either implement it themselves, pay somebody to do it, or switch to another editor/IDE with better syntax-highlighting. Most people can live with bad highlighting and won't even fill an issue in their editor/IDE about it. Chances are the maintainers of syntax highlighting for an editor are not tracking the evolution of all hundreds of languages that the editor supports, so they might not even know about this.
&gt; But other than match, I can‚Äôt think of any other keywords that can be postfixed. If we use a simple desugaring rule of `expr.keyword tokentree` -&gt; `keyword expr tokentree`, then the following keywords yield syntactically valid constructs in postfix position: - `if`: `some_expr().if { true_case } else { false_case }` (basically the old `?:` operator) - `match` - `return` - `while` - `become` (if implemented as expected) - `box` (current unstable version) - `yield` (if implemented for arguments as expected) Some of those seem pretty iffy (especially `while`, since it would cause the expression to evaluated repeatedly, but also `return` and `become` since they interrupt control flow), so probably wouldn't be implemented.
Except emphasis doesn‚Äôt often change the meaning of a sentence. Comparing this to capitals, paragraphs and line breaks isn‚Äôt really valid either as that‚Äôs grammar not just presentation.
&gt; I think the first public discussion should have been whether we need to change the plan at all. Was there ever an established plan that was changed?
Then I disagree that syntax highlighting is a good solution for the readability issues.
What strikes me here is that postfix is pretty hard to see when scanning code, but (correct me if I'm wrong) it can only appear in async blocks anyway, which have a very visible prefix syntax. I still like prefix-with-braces quite a bit, as it's the same as other special-case expressions in Rust (loop, if, match), composes well enough as an expression, while maintaining high visibility. However postfix composes even better (something like matching on an await result will be much nicer in postfix) and I didn't have as many problems finding the await sites when I scanned for async first, and of course it'll be even easier once await gets syntax highlighted, so the extra visibility from await-with-braces might not actually be needed.
Wow, how many languages do you know?
Hm, but now it conflicts with range syntax.
Please consider creating a macro instead, such as `awaited!(expr)`.
You can't have `await` in a function that isn't `async`, because it works by means of the compiler rewriting the function. If you make the `await` function `async`, then its return type must be a `Future` in turn, bringing you back to square one. Finally, it would be weird to have an `await` keyword and either a very special rule that allows you to name a method `await`, but not a local variable (because that would be a parsing nightmare). Alternatively, it would be weird if the postfix method used a different name than the keyword in order to not conflict.
i18n (internationalization) tends to be neglected, sadly.
&gt; and will take a lot of fine-tuning and diplomacy. Thats the kind of thing that I have a problem with, though. Why isnt it enough to just be honest? Acknowledge specifically what concerns there were, that they're legitimate, and that they plan to fix them by doing X, and feedback on X is welcome? I feel like a lot of really good feedback was given, and what people thought could've been done better. Or failing that, say it's been delayed. It's come to my attention there actually *was* an [internals post](https://internals.rust-lang.org/t/website-retrospective/9556), in March, about it being delayed and planned for the end of March, but it wasnt tagged as an announcement and had no activity beyond the day it was posted despite promising updates, generally flew under the radar. &gt; I'd call it the reality of open source development. I don't accept that, or at least, that it *has* to be that. The rust project has all these teams and working groups specifically to solve stuff like that, people who are able to dedicate the time needed, including a community team. And the retrospect was supposed to help work through these exact issues! Sometimes things take priority, but surely theres always time to tell people when that happens, a quick "Hey, X Y and Z are taking a back seat to A B and C right now, sorry", a lot of people had a problem with how the community team handled it, and imho the ball was really dropped on handling the follow up. Have there really been that many so much more pressing community issues that they couldn't handle this?
Oh I know, I feel the same.
A couple, that's not that unusual in europe.
It's Frantic Contrast theme from extension Rainglow. It's also available on other editors and IDEs.
It's not a solution, is a tool that helps. Even with `await(await(await(await(...))))` my editor colors each of the parentheses in a different color, significantly improving readability.
[Here](https://gitlab.com/gareins/smallpodcasts): pretty much finished my podcast "transcriber?". Takes podcasts and converts the feeds and audio files to much more compressed versions and then hosts that on github.
&gt; Thats the kind of thing that I have a problem with, though. Why isnt it enough to just be honest? That used to be my view as well, but I had to come to the conclusion that I was naive back then. There's *always* ways to communicate things in a better or worse way. And especially in this situation, where a lot of sensibilities have to be reconciled. &gt; I don't accept that, or at least, that it has to be that. The rust project has all these teams and working groups specifically to solve stuff like that Well, I'm not a member of those teams, so I can't give you the "real" reason. But all these teams are still composed of volunteers, who typically juggle a lot of different activities not only related to Rust, and in the end individual people have to do the work, not "the team".
Well, some people try to not use Google at all
gtranslate quickly falls apart, and it is not a good look for prospective newcomers. People can already copy/paste it themselves to translate (or use chrome's page translation feature).
&gt; or use chrome's page translation feature FYI this is what I used (not google translate directly).
If somebody happens to know how to do something similar with xorg on Linux I'd very much appreciated being pointed in the right direction.
Paragraphs and linebreaks aren't presentation? ü§îü§îü§îü§î &gt; Except emphasis doesn‚Äôt often change the meaning of a sentence. "doesn't often", which means it does at times but you're ignoring them? ü§îü§îü§îü§î Obviously it varies on whether they're *really* required, but it also sure helps clarify things. I present to you [Exhibit A](https://english.stackexchange.com/questions/258653/8-in-1-sentence-depending-on-emphasis), which makes clear that sentences can change signficantly change meaning based on emphasis [Exhibit B](http://factinator.com/i-never-said-she-stole-my-money/), similar to Exhibit A [Exhibit C](https://english.stackexchange.com/questions/354681/what-form-of-emphasis-was-used-before-printing) which makes clear that emphasis existed long before computers Exhibit D, the existence of sarcasm, something based entirely on (verbal) emphasis. Exhibit E, the existence of emphasis at all, which suggests people felt a need for it.
Well, I think this is a one man's fault. I see your point, but I'm pretty sure not all one-man-projects target children as their main audience.
I am nearly certain that you and everyone else will get used to it. Moreover, unless you're one of the few people that frequently reads source code without syntax highlighting, `await` will stick out. *Additionally*, most awaits will be used with a `?` following it, which will also make it stick out.
wow, thanks a lot! This makes so much sense now.
This. A million times this. Want to parallelize your update function? It's trivial. Want to do it when the world state is not immutable? have fun! There are many ways to make it so that you only have to hold a duplicate of the current world state for a limited time, I would first handle it by holding the old state and then the new state and only correct this as you find yourself running into the edges of the system. It's just not worth complicating things until you need to.
&gt; where a lot of sensibilities have to be reconciled. Do they, though? And can they not do that with honesty? It's my belief that it's easier to reconcile when theres straightforward honesty. Whether we're entirely happy with it or not, i think people would be far more likely to accept it if theres honesty. You can't make everyone perfectly happy in any case, and trying to just guarantees no one is. The PR stuff like that is a lot of the problem I, and others, had. It feels like they aren't listening, dismissing and downplaying concerns, and often a disconnect from the community. I was particularly vocal about the follow-up post for those reasons, among others, too. &gt; But all these teams are still composed of volunteers, who typically juggle a lot of different activities not only related to Rust, and in the end individual people have to do the work, not "the team". The way I see it, volunteering means you're saying you have the time for it, relatively consistently. If they don't, they shouldn't volunteer, or should step down, or the team should be subdivided into active/inactive, or something.
I was just discussing if we implement prefix keyword, how the ? composition problem can be solved when we have postfix macro and/or postfix keyword features. Sorry if I wasn‚Äôt clear about my intention there. You don‚Äôt need to learn await operator twice with the prefix approach. In fact, you probably don‚Äôt even need to learn it once because you probably has already leaned that from another language. And when the postfix generic macro/keyword happens, you are not relearning the await syntax, but applying new language construct (which is generic) to the existing keyword. I agree that postfix macro probably isn‚Äôt that important other than in this case. But I think it does have some value. (Letting users chain macro calls with other macro/method calls). It‚Äôs not about which option makes await implementable as a macro, it‚Äôs about which options play more nicely with the future features. The worst case scenario for postfix keyword await is that if we never end up making generic postfix keyword a thing, we now have a special case just for await keyword. Which adds learning curve to the language. And it‚Äôs already quite a weird expression for new rust programmers. Now it wouldn‚Äôt be an issue if we are confident that generic postfix keyword will be implemented. However, if generic postfix keyword is going to be implemented, there‚Äôs no harm starting with a prefix keyword either. I agree that postfix if is quite an appealing syntax. However, I‚Äôm still not sure about postfix keyword in general. Because I don‚Äôt feel postfix return, while, for, yield make sense. And if they don‚Äôt, how do we define/teach which keywords are postfix-able?
Because twitter is a platform engineered to amplify the 'correct' opinion not foster discussion.
I've mostly stopped using the website for anything. I have a rust link folder with links for the stuff that is sometimes hard to find quickly via google, e.g., to the nightly and stable API docs, the rust reference, the cargo book, the nomicon, or some other resources like the compiler guide, embedded book, platform support crate (rustc_target) since the forge is kind of always outdated, unsafe code guidelines, libc docs, etc. For everything else I just use Google. The old website was mainly aimed at gathering new users and help them get started, but it still has most relevant information for Rust users in a single short page that was quick to discover. The new website feels even more aimed at marketing Rust to new users than as a quick stop for active Rust users. This is not necessarily a bad thing, it is just not useful for me. People working on the website should maybe do a survey for Rust team members only about how much do they work with Rust in hours/week, and how much do they actually use the Rust website, and how much did they use the old one. They might find up some interesting results from there.
So you‚Äôre arguing for an aspect of natural language which is easily misunderstood to be adopted by a programming language?
Thank you. It can be pretty challenging deciphering some of these error messages-- I think the pattern/type distinction is what I was looking for.
One silly option, there are [certain unicode characters](https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters) for letter variations. If someone *really* wanted to keep the await name, they could make an `ùñÜùñúùñÜùñéùñô!()` macro. Well, as the compiler pointed out when I went to test, maybe someday once [#55467](https://github.com/rust-lang/rust/issues/55467) is resolved.
A real internationalization would require to change the whole layout of the site for Japanese people. Their sites tend to be more "charged".
&gt; Do they, though? And can they not do that with honesty? You're making it all seem very easy, and I'm just pointing out why it isn't. As such, I have not much else to say since the arguments "but that's very easy" and "just do it" can be repeated ad infinitum. &gt; The way I see it, volunteering means you're saying you have the time for it, relatively consistently. If they don't, they shouldn't volunteer, or should step down, or the team should be subdivided into active/inactive, or something. I don't think the teams are limited to a certain number of people, so none of these options would help getting more done. Again, I can only repeat what I said before: this is all *volunteer* *work*. And in the end volunteers are best and most motivated working on what they like to work on, not on what they feel forced to do. Please tell me you understand that, at least.
Can't wait for this to be in stable ! Do you have a rough ETA for the necessary feature ?
Emphasis exists specifically to make understanding what was meant by a sentence easier???? Just like syntax highlighting exists to make understanding code easier???? Sure you could probably do without both, but it wouldn't be a pleasant or unambiguous experience.
I missed that feature from Kotlin, thank you.
What I really dislike about the new website is the huge text and spacing everywhere. The old one was compact and simple (perfect imo).
Upon re-reading that issue, it sounds like the context for that comment was that the mockups should go in a new PR instead. I think the "this" that was being referred to was the closed issue, not the topic. But I definitely didn't read it that way the first time.
Actually, compared to the kind of drama that happens in other technical communities, I find this kind of popcorn drama to be civilized, creative and somewhat funny. Not that it should be encouraged or anything - I don't believe OP(s?) to actually believe in the potential success of their "language" anyway - but you have to admit that the whole debate, as emotional as it is, managed to stay out of personal attacks and trash-talking (unless I didn't see them). In a sense, this also speaks highly of the Rust community! If this is as low as one can go to manifest its opposition, I think we're still okay...
The irony of rewriting the whole website to be full of enough bullshit about Empowerment to fill an intersectionality textbook and then not bother to translate it; i.e. de-empower a massive proportion of the audience; is pretty amusing.
&gt;Is it no longer considered a priority these days? well, it's voluntary work, so it's up to contributors. I did the initial translation into pt_BR and helped reviewing a couple PRs by other contributors, but I believe don't have time to re-do the translation and then maintain it actively. I'll look into it and may translate it in an upcoming holiday/weekend, but I don't know if it's worth the effort being left basically unmaintained. what I believe to be the biggest problem since the beginning is that we aren't notified of changes in the website (well, I can see that being a annoyance for every little change, but even for major changes like the new website I don't think any of us were notified)
It's easy to be honest. It's harder to speak candidly in a way that conveys the precise interpretation you intend to a large group of people with a wide range of perspectives. You should be honest, but you also need to communicate your points effectively, which is harder when emotions are high.
Thank you, Berlin.rs, for sharing the content from these events
I found this one to be updated [https://github.com/w3f/bls](https://github.com/w3f/bls) I'm trying to use it as a replacement to and existing java jpbc, which has a lot of magic numbers you supply such as: type=a q=98826429041171753291515535532523512299028170537954154869719707264887274916552228805607584116490046284509883309001532457986879277885241872021906840932513241346999389365188296460009947 h=32243626948934860887488490158437299489453513352745889246437755713701521031193083418924110592954582395114812811896992400310730276 r=3064991081731777546575510593831386635550174528483098623 exp2=181 exp1=127 sign1=-1 sign0=-1 I find this confusing, because the java implementation has this magic numbers while the rust libraries is very simple to use without supplying this magic numbers.
I ilve in Europe and the only languages I know are Czech, English and Ich spiele Computerspiele gern.
https://github.com/rust-lang/rust/issues/54727
So then what was the point of having it in the first place, if it was just going to be ignored anyway?
If it has to be postfix, why does it have to be a field access? I know it's kinda redundant to have brackets, but it feels more like a computation that happens, and so feels like it should be a method.
Yes, and we read more code than we write. &amp;#x200B; There should be more real examples so that we can compare on the whole, not only some small snippets of code that means nothing.
At last :-)
For anyone finding this here, got answers at [https://stackoverflow.com/questions/55997427/iron-persistent-state-with-struct-reference](https://stackoverflow.com/questions/55997427/iron-persistent-state-with-struct-reference)
Oh sweet, f strings. I missed those [from python](https://realpython.com/python-f-strings/#f-strings-a-new-and-improved-way-to-format-strings-in-python).
Because most diff tools do not support syntax highlighting.
You realize it wasn't the team who put it up, right? Everybody can make a strawpoll.
In the `msg.asc == 0` case you are ordering by `x.id` ascending and then, for draws, by `x.id` descending. Presumably those ids are unique and there will never be any draws. Make sure `x.id` only occurs once in the entire `msg.asc == 0` block.
Is this really a priority? async/await was never about making the yield points noticeable - it was about decreasing the huge overhead of threads and the need to use locks. Some languages/libraries even do it without extra syntax at all. It's an implementation detail - not really part of the algorithm... If anything, I'd say high visibility would be a much higher priority for error handling, because this early return actually changes the flow of the algorithm (not just the flow of some background mechanism), and even there it became a consensus that a postfix sigil is better because it offers chainability.
You‚Äôd have to ask the person who made it. It wasn‚Äôt the team who did. (And I‚Äôm not on the team, to be clear.)
I think what OP meant by "is it no longer considered a priority" is that they would have expected translations to be a blocker for rollout of the new site (or at least have the efforts planned), rather than being annoyed at volunteers not having translated it yet.
Couldn't this be done nearly identical with a macro by just using the macro with curly braces?
This is actually ridiculous. I'm struggling to understand how rolling out the new website could have even been considered without translations.
What you want is just ` v.sort_by_key(|x| Reverse(x.id));` A tuple (which is what you createwhen you write (x.id, Reverse(x.id))) are sorted lexicographically (first you compare the first field and if they are not equal that is the final ordering, if they are equal you do the same thing to the second field and so on), which is why you get the same result in both cases.
I took it as "they don't care about translations anymore" and I don't think that's completely true, but I get what you're trying to say
You should be able to get this to work on stable now using `proc-macro-hack`.
while I agree it's weird to base a grammar off of syntax highlighting. It's the only keyword where syntax highlighting will actually be relevant.
Yes, thank you.
What are you even trying to achieve with those lifetime constraints?
That's a very cut-down version of the real code, obviously! I just deleted as much as I could while still repro'ing.
I've been playing with a similar idea myself. You should publicise this on the issues for gloo - an attempt to provide the batteries for client side development. I personally believe something like this should be in there, with the support guarantees that come with being in an organization of more than 1 person.
Well, the thing that's making the whole thing recursive is `where for&lt;'c&gt; &amp;'c T: Sub&lt;Output=T&gt;`. Removing that constraint fixes everything, and I'm not really sure what you wanted to express with it anyway.
That's a very cut-down version of the real code! I deleted as much as I could while still causing the error.
I used it quite heavily in the utility functions [here](https://github.com/Nemo157/vdom-rsjs/blob/master/src/build.rs).
Why does this not compile? \`\`\` trait Trait { const CONS: usize; } struct Struct&lt;T: Trait&gt; { data: \[u8; T::CONS\], phantom: PhantomData&lt;T&gt;, } \`\`\`
This is insanely good, but I think it means no support for autocompletion in string.
Out of topic but can we talk again about its very bad design and the need to change it...?
In the Point2d type, I wanted to express that &amp;T - &amp;T is implemented for every possible lifetime (T might be BigInt, for example, so I need to avoid copying wherever possible).
In JS there is the relatively common `await (await fetch(url).json()` (which is horrible enough to write that you'll almost always stick it in a named function somewhere and just avoid using `fetch` directly).
If I am to express any particular aesthetic preference, I am a believer in the consistency of the language syntax. Current Rust keywords are in prefix form (match, if, fn, and others). I hoped that await would be similar. It reads far more naturally to me in prefix form, like match does. However, if both prefix and postfix forms of `await`, `match` and others are implemented like you say, even better. Everyone will get to use whatever they prefer. I know I will use both, depending on context, whichever I think looks prettier. That said, I think the choice of syntax for await is far too bikesheddy of an issue and doesn't actually matter as much as it was made to be. Honestly I am kinda disappointed that this syntax discussion delayed async/await by so much. I don't really care what the syntax will be. I just want to get things done. I know that I will get accustomed to whatever syntax ultimately gets chosen, after using it for a while. I think so will everyone else. Syntax shouldn't be a big deal, as long as it is practical (i.e not actively frustrating to use).
Link: [https://github.com/dtolnay/proc-macro-hack](https://github.com/dtolnay/proc-macro-hack)
I'm still miffed at how the Rust team handled the rollout and criticism of the new webpage, it didn't feel like the usual approach of how things work. Normally changes are announced, discussed, developed and released _in tandem_ with the community. With the new website they got a ton of feedback and then ignored it, released the new webpage and later closed most of the issues. I don't want to point fingers but how the new website was handled from beginning to start did not feel like the Rust community I know.
Yeah that's a general problem of having 3rd-party macros instead of language features or at least "core macros". IntelliJ IDEA has the excellent "injected languages" feature where you can say roughly "strings of these functions are language X", but in this case it's not the entire string but the contents of \`{\` and \`}\` inside those strings. But, Rust is moving fast, so maybe string interpolation will become part of the language someday.
Sweet! I'm not a fan of expressions inside strings like `"result: {x+y}"` (no rustfmt, no autocomplete, no refactorings - unless this get's into the language. But just being able to write `iprintln!("result: {res}")` instead of `println!("result: {}", res)` is totally worth it.
Well, that's how they're handling async/await feature as well (everybody likes magic and special cases in low-level languages, right?) So I guess, it's a trend.
But how does the lifetime `'c` relate to anything?
I agree, I think this is the best way by far. Or even a await!() prefix-macro together with an .await!() postfix-macro, which could also enable the prefix try!() together with postfix .try!() instead of ? for more consistency, but that'll never happen.
To me those automatic translations look totally unprofessional and I'd rather prefer having no translation at all from that perspective. After all, can you do any programming without English knowledge? I remember when I started out years ago I did use a German MSDN documentation for some time, but typically the experience was just worse - and that even though MS put in the resources to have reality good quality translations.
Isn't that correct method for specifying a constraint that has to apply for every possible lifetime? Specify "for&lt;'x&gt;", where 'x' is a new lifetime, and then the required constraint?
In which case we get back to the fact that the language should really be understandable on it's own.
A lot of these discussions tend to end up as "let's spell out how we feel the rust team is screwing up and not listening to us" instead of "hey there might be an issue here let's fix it" Specifically discussions related to changes on the website, async/await, impl Trait, etc. At least, in my personal opinion
Ouch, you were right. It is working now. Thanks a lot!
Hmm, after some fiddling around, it looks that's not right. [This](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=63ca34fcfcff19c71feafc0c5be30058) looks like the right way to do it. Thanks for the tip!
&amp;#x200B; Solution was provided in another message. Thanks anyway.
It's not really. [HRTB](https://doc.rust-lang.org/nomicon/hrtb.html) is a really rare use case.
&gt;. just seems to be the way to visibly "chain" something on the end of an expression It is, but .await isn't really chaining anything. Also, chaining multiple awaited function calls on a single line will generally look messy regardless of whether await is prefix or postfix. The vast majority of, if not all the time you'll want to put each function call on a separate line for the sake of readability anyway. The only cases I can think of where chaining function calls makes sense is when using a builder pattern (which I don't think you'd ever use async for regardless) or iterator pipelines - and in the case of iterator pipelines, I'm guessing you'd need to have some sort of special async iterator that wouldn't need to be awaited until the end.
I'd say use streams so you can replace logic with combinators (e.g. `stream.map(...)`). I usually just use sinks when there's an underlying `AsyncWrite`.
&gt;I would prefer some special indication for keywords (e.g a bang sign, like expression.!await). That would be a slight improvement to just making it look like a field access, but personally I'm not a fan of postfix keywords at all.
I can understand why the prefix await macro isn't happening - it cannot be implemented as a normal macro, and doesn't really fit the category of "magic macros" that can be implemented as compiler built-ins. That said, I really do think this offers a significant amount of consistency. In the future, the try macro could even be replaced by the try keyword (doing essentially the same job) for consistency with await, although that would leave us with 3-4 different ways to do the same thing, which is obviously less desirable.
I love the inclusivity of Rust, so I‚Äôm leery of your seeming dismissal of intersectionality. But I agree that it‚Äôs more important to walk the walk than talk the talk. It‚Äôs undeniable that the old website was more inclusive and accessible than the new one, despite the language highlighting Rust‚Äôs inclusivity. It‚Äôs frankly embarrassing. Lack of translations should have been considered a blocker, even more so than the lack of community input.
I hate having to import Duration, and it also doesn't fit with the general principle of minimality. But I will consider the `timeout_ms` option.
That does sound like a more sensible approach. Especially since then you actually solve a problem that can be well defined (the need to chain some operators to remove nested braces, such as await or match), and at no point do you introduce an exception to the usual syntax.
&gt; A lot of these discussions tend to end up as "let's spell out how we feel the rust team is screwing up and not listening to us" instead of "hey there might be an issue here let's fix it" You could take your own advice regarding "hey there might be an issue here let's fix it" Why do you think the discussions keep ending up as "we dont feel listened to"? Maybe theres an issue here about listening?! Consider that? And thats not all people did, there was plenty of reasonable critisism and suggestions on what could be done differently, it was just ignored, or appeared to have been ignored. Discussions keep going there because *thats how we keep feeling*. Theres a reason for that. Why do you think how the community feels isnt important, anyway? Thats a good way to lose the passionate community that Rust has created. And fixing these issues is a two way street anyway, and for the rust teams part we're [still waiting on the retrospective](https://www.reddit.com/r/rust/comments/blkh9i/halfway_into_2019_already_and_has_the_promised/)
Oh, ok that makes sense. Looks like I‚Äôve got some reading to do. Thanks!
What's new in the servo ecosystem? I haven't read any new communication in the last few month. What are the last big archievements? What is the roadmap? What's left for servo to be a full-feature web engine (event though it is not supposed to be its end goal).
Is it, though? Full disclosure: my favorite async/await syntax is not in contention, but this is a far cry from saying "they got a ton of feedback and then ignored it". I think a little more credit is deserved in this particular instance. Async/Await update: http://smallcultfollowing.com/babysteps/blog/2019/03/01/async-await-status-report/ Detailed summary of feedback received: https://paper.dropbox.com/doc/Await-Syntax-Write-Up-t9NlOSeI4RQ8AINsaSSyJ High-level summary with feedback invitation (note: 207 pieces of feedback as of this writing, in addition to feedback provided on main issue): https://internals.rust-lang.org/t/await-syntax-discussion-summary/9914 TL;DR - Perfect? Perhaps not, but none of us are. But the community has been (and continues to be) consulted, in depth, and our feedback reflected by the lang team. Even if we don't like the particular choice that is being made, let's not stretch that to suggest that the community's input is being ignored.
Looks great! Is it open source?
I think software projects should aspire to meritocracy, I infer from your comment that your stance is more in favor of post-meritocracy; that's fine, we can differ in opinion on that matter - fundamentally, we both agree that Rust should be inclusive and that to not have available translations for widely spoken languages is indefensibly exclusionary.
I've updated the paper about publishing path semantics: https://github.com/advancedresearch/path_semantics/blob/master/papers-wip/about-publishing-path-semantics.pdf I hope that you find this version clearer.
Whatever bias you are talking about there, I guess I don't have it
Of course, but the source code still need to be tidy up a bit first. Would be do it later.
Some people do not like when their editors look like a freakin Christmas tree, just saying. And you fix syntax highlighting before you build features that require it to use with any degree of comfort (that if you care about your users of course).
An update was posted on that thread.
There's also https://crates.io/crates/interpolate
Would it be possible to add a grid view of images? If I have a folder with 10 screenshots, I'd like to make out the one I'm looking for on first sight without having to go through 10 images sequentially.
Yes please.
&gt; Since when does management decide what languages developers use? Isn't it usually the other way around? Outside of trendy startups, I've never seen a company where someone in management didn't decide what language to use.
not related to your question but you should use `u32` instead of `i32`
Vern Buerg would like a chat with you..
I'd suggest continuing to use Rust, if you used it before. Leaving Rust for a syntax choice is kinda like getting out of a relationship because you had an argument. While I like this particular syntax choice, I'm 100% certain that there will be (and there have been) language design choices I don't like. That won't prevent me from using a very useful language.
Rust already has a quite steep learning curve along with, let's say, "sub-par" readability. So the notion of ruining that readability even more so by introducing more "magic" is very weird to me. Syntax highlighting argument is ridiculous in general, especially coming from the language team. It's (highlighting) nor uniform in availability nor in quality in places where you can find Rust code (to put it mildly, IDE and tooling support for Rust is whole another topic with its own problems). In general, the article gives away the impression "That is what we WANT to build" (or even more simply, CAN) and that's it. Proper arguments why mixing field accessor syntax and control flow is not bad are not existent or shaky at best. Instead, we got a whole new discussion about postfix control statements, as anybody asked for that. As somebody said, it's already hard to convince people to try Rust. I think I'll stop at this point, it's not worth it. Maybe, in 10 years, when this epic is finished, everything is postfix syntax (cause why not), `tokio` is dead or finally works, I can build a simple TCP networking app without pulling 2k deps and compiling it for 2 hours.
Ahoy!
You should be able to crib off of cnx https://github.com/mjkillough/cnx/blob/master/src/bar.rs , but where they set the window type to dock I think you would want override-redirect.
That's all nice and well, but that's the point of having feedback if you ignore it? From the last article: &gt; In resolving this question, there was a strong majority in the language team that preferred postfix syntax. I don't see any mention of any feedback here or how it affected the chosen option. Do you? Maybe I'm asking too much of course, but I'd assume if you creating a programming language and you want it to be used in production, you should listen to people who use your language in production (weird, right?) in questions of readability and syntax a bit more than people who don't write libraries and/or application code on a daily basis (the language team).
As an English verb, await would be used as in "this function will await the value of &lt;expression&gt; before continuing", so the way I see it, if await is being used as a verb, amongst a fluent chain of methods and fields trying to imitate English already, then it will tend to want to precede the thing being waited on. Since Rust is not English, this tendency will be very weak to begin with, so just about any asymmetric punctuation will overpower it. But space-await-space and dot-await-dot are symmetric, and so I feel that the conflict may emerge as a subtle "that syntax doesn't feel entirely right" without an obvious cause.
Already tried. The problem is that if you use `proc-macro-hack` expansions can't contain variables from the surrounding scope. At least, I think that was the problem. It was a few weeks ago and I didn't take good notes.
&gt; To me those automatic translations look totally unprofessional This might be a bit "duh", but the manual translations that we used to have were done by volunteers on their free time, so they were not professional either. Also, we don't provide the automatic translations, browsers do (e.g. Chrome in this case) so there is nothing we can do against them.
I do like that, thanks for sharing!
I suppose the order of chained calls is just too ingrained in my thought process for that to bother me, but I can see where you're coming from now.
&gt; We still don't have [syntax highlighting](https://github.com/rust-lang/www.rust-lang.org/issues/349) for the [getting started](https://www.rust-lang.org/learn/get-started) page &amp;#x200B; Looking at the website repo it doesn't seem like anyone's actively working on the site; it seems to mostly be in maintenance mode. I remember hearing big plans about the site back when it was first released. Perhaps it's just been hard finding people willing to work on it? I feel like pull requests to fix these things would be accepted. &amp;#x200B; ISTM it would be pretty hard to find people in a primarily non-webby community who want to maintain a website. Most folks want to contribute primarily in Rust, and the website isn't a great place to do that. Lots of people had \_opinions\_ on the website, but very few people seem to have made pull requests for anything other than their personal issues. &amp;#x200B; I hope eventually the website grows some steady contributors, there's a lot of work that could be done on it.
You can pass that mapping back to serde\_json to get it in JSON format. That is how I was testing some of my logic and also because I'm using JMESPath for queries. It works out pretty smoothly. Just use the parse from \`serde\_yaml\`, and then pass that into the \`sedre\_json\`. (Side note, you can also pass it into JMES. :))
&gt; as far as I can tell, the only way to serialize/deserialize is to have data that matches a predefined struct I'm not sure I understand you. The code you posted deserializes a file without a struct, which contradicts your assertion.
Could you show me an example of the code you are talking about? I'm still kinda new to the serde crate, and Rust in general. This is what I tried: let json_contents: serde_json::Value = serde_json::from_value(yaml_contents).unwrap(); And I got the following error: Compiling yq v0.1.0 (path/to/file) error[E0308]: mismatched types --&gt; src/main.rs:22:67 | 22 | let json_contents: serde_json::Value = serde_json::from_value(yaml_contents).unwrap(); | ^^^^^^^^^^^^^ expected enum `serde_json::Value`, found enum `serde_yaml::Value` | = note: expected type `serde_json::Value` found type `serde_yaml::Value` error: aborting due to previous error For more information about this error, try `rustc --explain E0308`. error: Could not compile `yq`. To learn more, run the command again with --verbose.
What, if any, is the difference between these two structs? struct Ref&lt;'a, T: 'a&gt;(&amp;'a T); struct Ref2&lt;'a, T&gt;(&amp;'a T); Thanks!
Woah buddy, that's wrongthink! Can't have that here! Better hit that down arrow, that'll work instead of a well-reasoned argument.
In your example, you **are** deserializing YAML to an unknown structure (`serde_yaml::Value`). If you just need to rewrite it as JSON, just deserialize YAML to `Value` and serialize JSON as /u/dmoonfire suggests, or use [serde-transcode](https://serde.rs/transcode.html) to do so with no intermediate step. If you need to work with the data: * If the YAML is truly arbitrary, use `serde_yaml::Value`'s [indexing method](https://docs.serde.rs/serde_yaml/enum.Value.html#method.get) to pull out the values you need. * If the YAML is expected to match one of several different structures, use [serde's untagged enum](https://serde.rs/enum-representations.html#untagged) (magical in a good way!) to get the right structure.
The `guard!` macro implements a control-flow sugar that occurs very often in common Rust code: ```rust fn foo(cond: bool) -&gt; Option&lt;i32&gt; { if !cond { return None; } // do something useful Some(42) } ``` With this crate: ```rust use try_guard::guard; fn foo(cond: bool) -&gt; Option&lt;i32&gt; { guard!(cond); Some(42) } ```
I guess I misunderstood what deserializing meant. What I mean is that I've only seen people work with json/yaml data by deserializing that data into a predefined rust struct that already matches the data they are passing into it, meaning they know what the data is going to look like. I guess what I'm asking is: how can I convert the `serde_yaml::Value` mapping into a data structure that's easier to work with and convert to other types (for example, and `serde_json::Value`), using just the serde crates? I haven't seen any code that shows how to do this.
You may not need to do this (`serde_yaml::Value` is almost as easy to use as `serde_json::Value`), but if you do, you should use `serde_json::to_value` here.
If changes to the website had to be translated into 14 languages before they went live, we simply would never have updates to the website. It's nice that the translations existed in the first place, but I don't think they should be a blocker on future progress.
The website is pretty positive and big on that it's goal is to empower any programmer to write quality code. I'm fine saying it's boring mush too. But actually framing it as "bullshit" like it's lying instead of just being an aesthetic you don't like or acting like it has anything to do with meritocracy is so misguided. Even in the joke, intersectionality doesn't make sense, you're just trying to inject your politics into something that doesn't need it. It's so clear you're just pattern matching buzzwords because the word empowerment offends you. The inclusivity of the rust community is good. Don't poison the well.
For anyone interested, I got a working response from the developer of the `postgres` crate. Simply change the declaration of the `values_arr` vec: let mut values_arr: Vec&lt;&amp;dyn ToSql&gt; = vec![];
But every time is await is used, context is chained on. So the comparison is `x.await.context(...)` vs `(await x).context(...)`. I like the former for obvious reasons
Can we not start with this crap here? The rust community is overall pretty good, don't get so upset by a comment being downvoted that you actually have to compare any dissenters to 1984. They're bringing up meritocracy and shitting empowerment for absolutely no reason but to push their politics. Yeah, downvote random political crap and move on, this is the rust subreddit, not a debate club.
Thanks. Btw link should be [https://rust-lang.zulipchat.com](https://rust-lang.zulipchat.com)
On what grounds are you suggesting the feedback wasn't listened to? It was discussed and commented on at great length by the language team. &gt;you should listen to people who use your language in production (weird, right?) in questions of readability and syntax a bit more than people who don't write libraries and/or application code on a daily basis (the language team). This is a baseless accusation of bad faith, and overly presumptuous of the experience of the language team (how do you know they don't write libraries and/or application code regularly?) You're misrepresenting the situation, not to mention being generally rude and unhelpful. Find somewhere else to vent if you don't want to participate in a constructive manner.
I think the easier to use structure is `serde_yaml::Value`. If it's too cumbersome, blame the YAML format :-). But if you know more about your data, you can also deserialize into a `HashMap` or something similar. See also /u/jacob-6avz's comment.
&gt; you're just trying to inject your politics into something that doesn't need it I wouldn't feel the need to do it if the Rust core team (who, to be clear, I have immense technical respect for) didn't feel the need to do it first.
Thanks for the recommendation! I'm going to clean it up a bit more and then I'll feel more confident recommending it to other projects üòÖ
[Yes.](https://www.reddit.com/r/rust/comments/bkobwf/one_billion_crates_downloaded_on_cratesio/)
&gt; Some people do not like when their editors look like a freakin Christmas tree, just saying Then they can change the colors to suit them and highlight, or not highlight, whatever parts they want. &gt; And you fix syntax highlighting before you build features that require it to use with any degree of comfort Thats partly a valid argument. Syntax highlighting does need to be improved. However, you already need modern editor features like syntax highlighting to code, in any language, with a degree of comfort. Syntax highlighting has been around for decades and it isnt going to disappear. Whether the code is "simple" or not, syntax highlighting improves understanding, [theres actually a study on it too](https://docs.google.com/viewer?embedded=true&amp;url=http%3A%2F%2Fwww.ppig.org%2Fsites%2Fppig.org%2Ffiles%2F2015-PPIG-26th-Sarkar.pdf). It uses Python as the language of choice, which is widely regarded as one of the "simpler" and "beginner friendly" and "easy to understand" languages. Looks like pseudocode. Concluding that syntax highlighting makes code easier to comprehend. It's ridiculous to act like syntax highlighting doesn't exist or that it's not being used.
The plan for the new website was to support proper internationalization using Fluent. Individual translation pages don't scale well and it's harder to make changes, and this was a big problem for the old site. With Fluent (or some other framework) you can plug the translations into a tool like Pontoon and it just becomes easier to do. There were some contributors [working on it](https://github.com/rust-lang/www.rust-lang.org/pull/732), however that never finished. If someone is interested in integrating fluent-rs into the website, I'm willing to mentor: I understand quite a bit of Fluent and the general concepts of internationalization. (I've been considering doing this myself at some point, but I don't really have the time)
Efforts were planned, [progress was even made](https://github.com/rust-lang/www.rust-lang.org/pull/732), but those folks are no longer working on it.
I actually wouldn't worry about the implementation, it's more the principals that matter.
Phf doesn't require nightly if you use the codegen version.
That looks much more bare-bones compared to what I have written. I hadn't seen that though, thanks for showing me!
We considered `w3f/bls` too - I just can't remember why we chose not to use it. The constants you have there are the curve parameters, which for our crate at least are implemented in the `Engine` (which is similar to the `w4f/bls I think). We specifically use BLS12-381, so we created type aliases to fix the Engine to that specific curve. So basically those should be hidden somewhere in the source code.
The way I view the whole thing is like this: the web page team wrote a page, and just before launch asked for more eyes to catch typos and errors and such stuff, but then many people suggested major redesigns and where disappointed when their redesigns were not used. I think the mistake from the web page team was that they were not clear enough that they wanted to catch typos, and were not asking for an open committee to design the page.
`u64::from_be_bytes()` is implemented since 1.32.0.
What a joke. They wrote the word empowerment and you got triggered. That's all that's happening here.
Try this: use serde_json::Value; use serde_yaml; fn main() { // Define the YAML. let yaml = r#" key: value list: - a - b"#; println!("YAML\n{}", yaml); // Parse the YAML into a generic structure. let value: Value = serde_yaml::from_str(yaml).unwrap(); println!("JSON Value {:?}", value); // Write out the JSON. println!("{}", value.to_string()); }
&gt; the web page team wrote a page, and just before launch asked for more eyes to catch typos and errors and such stuff, &gt; &gt; [...] and were not asking for an open committee to design the page. That exact sequence of events was also a major problem people had, since it's so different from how Rust usually works. /u/sondr3_ in the [other thread](https://www.reddit.com/r/rust/comments/blmk2d/concerning_the_newold_website/emqeia9/) put it best, "Normally changes are announced, discussed, developed and released *in tandem* with the community." &gt; they were not clear enough that they wanted to catch typos, If they weren't clear about it, then how do you know thats all they wanted? What makes you think that? The blog post announcing the beta sure doesnt say that, and IMHO it'd be worse if thats what they were expecting. In fact, [the blog post announcing it *explicitly* says](https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html#future-work) &gt; Please file an issue with any feedback you have! We‚Äôre also looking for people with abilities of all kinds to help maintain the site, and especially people with design, CSS, and marketing skills. If you‚Äôd like to get involved, please email us! they sure have heavy and unrelated requirements for typo hunters.. They actually did ask for an "open committee to design the page." &gt; but then many people suggested major redesigns Smaller scale changes were suggested, even as simple as using a consistent color layout, [mockups were even made](https://github.com/rust-lang/www.rust-lang.org/issues/421#issuecomment-443098003). A lot of people, myself included, thought those simple color changes ***vastly*** improved the site.
There's no difference. If I remember right, the explicit `T: 'a` bound used to be required in older versions of the compiler, but that was relaxed at some point.
I don't think it's productive to the general state of online discourse to trivialise the term 'triggered'. Remember that the term is meant to protect sufferers of mental illness and the victims of violent crime.
&gt; It's harder to speak candidly in a way that conveys the precise interpretation you intend to a large group of people with a wide range of perspectives. Yeah, i guess you're right. I guess i'm a bit of an idealist on this point. &gt; which is harder when emotions are high. Well, it has been quite a few months, i would hope we've all calmed down by now.
&gt; You're making it all seem very easy, and I'm just pointing out why it isn't You're right, i'm kind of an idealist with honesty i guess. I like to think if they were just honest, blunt, whatever, that we, the community, could accept that. But reality is often disappointing.
&gt; But reality is often disappointing. I'll gladly agree with you there :)
What a bad faith actor. You're being antagonistic literally for the sake of it now. Nobody will miss you if you leave.
Sure, management probably has the final say, but what i meant was, it's usually interested developers convincing management of the benefits of using it, rather than the other way around. I suspect trendy startups are the biggest user of new languages anyway, anything other than new software is already written in it's language of choice and unlikely to be rewritten in rust(or anything else), and i suspect startups write the most new software.
&gt;If they weren't clear about it, then how do you know thats all they wanted? What I wrote is just the feeling I get. Some things which gave me that feeling: * The call for feedback was very late, there just wasn't time for redesigns. * PRs for typos and for fixing typographic nits were accepted. * PRs that made text clearer were accepted. * The slogan was changed, but if I remember well, the call for feedback explicitly mentioned that the slogan was not yet finalized. It made no such claim about the web page structure. * I also had a PR accepted which changed the green colour to make the contrast with the white text more accessible, but the colour was only made darker for that fix, it wasn't changed because I liked some shade of green more than the shade that was used. &gt;A lot of people, myself included, thought those simple color changes ***vastly*** improved the site. Changing the colour scheme is something I consider a major redesign. It might not be difficult to implement (just tweak the CSS values), but it changes the look and feel in a major way. And while I like those mockups, I prefer the more colourful scheme used, to me it looks a little more cheerful, so I would not even agree that those changes improve the site, let alone ***vastly*** improve it.
None of my comments in this thread have been made in bad faith.
&gt; This crate also allows you to guard to any **time** that implements `Try&lt;Error = NoneError&gt;`. Did you mean **thing**? Otherwise neat; I really like guards and I've been missing the conversion from boolean to option for quite some time!
That clears up a bit. Thank you for the help.
`assert_cmd` maintainer here! First, I welcome engagement on what testing should look like. Please reach out to me on [the 1.0 issue](https://github.com/assert-rs/assert_cmd/issues/74), new issues, or [discord](https://discordapp.com/channels/442252698964721669/443151071041290241). Admittedly, `assert_cmd` / `assert_fs` are more low level. We do want to create something higher level, [taking over the `assert_cli` name](https://github.com/assert-rs/assert_cli/issues/41), but we've not been putting much time / thought to it. I'm still processing this idea for what all i think. In some respects it looks "fast" to write everything but in thinking about it, the code for doing this manually doesn't seem all that much bigger. For example `cwd: "/tmp",` just turns into `.current_dir("/tmp")` (made this up, haven't looked). This also makes me wonder about a macro for `assert_fs` for describing the layout of the filesystem fixture and possibly for describing what the resulting filesystem should be.
congrats
The page could keep its uncharged profile but still be translated :)
Thanks for the idea! I will write it down but for now there is a lot of polishing to be done. I will most probably not work on new features for the next few weeks. For now you might try using `viu * -n`
Published version 0.6 of my Banaloh Challenge crate: https://github.com/phayes/benaloh-challenge Thinking on if it I should push a 1.0 (since it's basically done) even if all it's dependancies are still 0.x.
Not sure I agree, but I see where you're coming from.
Seems like they should.
Is this the way to go with the Result type? Or is this stupid and there's a more sophisticated way? let res = foofunc(foo); let numb: i32; if res.is_ok() { numb = res.unpack(); }
For the last one, you now have dbg! (res) .
There are Rustc Dockerfiles with LLVM 8 and glibc 2.5 on CentOS 5. Is that good enough?
I'm trying to create a tracing shared library which can be called by C-programs, offering network-services to them. The lib basically has to monitor one thread, which accepts data by C-apps, and watches timers and sockets. As it looks this can be accomplished by using the mio crate and mio-extras for pollable-channels. Though I wonder why this has been excluded to a seperate crate
Really?! This is so cool, I love this! &gt; this crate requires you to use nightly rust... Noooooooooooooooooo...
Thanks for sharing, I was having the same problem the other day and will definitely save this for later :)
I don't think your codesnippet will work (even when correcting unpack to unwrap), but rejoice, there is indeed a much more ergonomic approach. Generally there are two options to handling a Result (or an error, generally): Either you handle the error (e.g. choose a default value) or you pass the error up the callstack for someone else to handle it (i.e. some function that called your function). The former is pretty easy with [Result::unwrap_or](https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or) and the latter is even easier with the question mark operator, your code simply becomes let numb = foofunc(foo)?; Note that for the ?-operator to work your function needs to return a compatible Result-Type or transform the Result of `foofunc` something that is compatible (e.g. via Result::map_err). You should probably read up on the ?-operator some more, it's not that complicated but makes your code very readable *and* concise.
Some good resources on advanced lifetimes stuff: * https://www.youtube.com/watch?v=fI4RG_uq-WU * https://medium.com/nearprotocol/understanding-rust-lifetimes-e813bcd405fa * https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance * https://doc.rust-lang.org/1.26.2/nomicon/subtyping.html
Regardless of the validity of your program the compiler shouldn't infinite-loop. Please post a compiler bug with this admirably short and clear example.
As mentioned by Lehona_, if your function also returns a `Result`, you can use the `?` operator to return the error case, and continue with the unwrapped Ok value. If you want to handle the error locally, though, rather than sending the error upstream, you can write something like match foofunc(foo) { Ok(numb) =&gt; { // do things with numb here } Err(e) =&gt; { // handle the error (e) here } } If you don't care about what the error value was, you can instead write if let Ok(numb) = foofunc(foo) { // Do things with numb here } else { // Handle the error case, assuming you don't care what the specific error was } `let numb = foofunc(foo)?` is roughly equivalent to let numb = match foofunc(foo) { Ok(value) =&gt; value Err(e) =&gt; { return Err(e.into()) } }
Oh nice catch, thanks! Yeah, I‚Äôve been missing that for a while too!
It may! Can you point it to me?
Ok, sounds handy So the methods is\_ok and is\_err are not supposed to be used directly?
Yes! I miss C# string interpolation so much.
Oh, wow, I literally just wrote this but now I don't have to maintain it :P. FWIW, I also ran into the issue with `proc-macro-hack` that you describe in the other comment. Maybe comment on [the issue](https://github.com/dtolnay/proc-macro-hack/issues/31) that you also ran into it? Or mention [here](https://github.com/rust-lang/rust/issues/54727) that you also need expression-position proc macros?
Fixed in [try-guard-0.1.1](https://docs.rs/try-guard/0.1.1/try_guard). Thanks again!
I edited the post. Also there are prebuilt Docker images cached on AWS of rust-lang.
You could change your \`push\`/\`pop\` implementations to make use of the updated \`head\` value when \`compare\_and\_set\` returns \`Err\`. That lets you get rid of an extra atomic load. Ultimately tho, when you have a bunch of threads all contending for access to the same memory, and all performing writes, you won't get scaling. Try different workloads like iterating 90%-99% of the time, and push/popping the rest of the time. You'll probably see some scaling better than what \`Mutex\` gives you. &amp;#x200B; Anthony Williams has put out a great book which goes over memory orderings, that might be interesting to you: [https://www.cplusplusconcurrencyinaction.com/](https://www.cplusplusconcurrencyinaction.com/)
Wow! That's a fast turn-around!
&gt; what I believe to be the biggest problem since the beginning is that we aren't notified of changes in the website (well, I can see that being a annoyance for every little change, but even for major changes like the new website I don't think any of us were notified) As someone who was involved in the translation of ruby-lang.org: yes, this is the biggest problem. A proper translation system with a lead language helps with that, but needs to be integrated.
Think of it like this. You‚Äôre making a struct that holds a reference to a string slice: ``` struct Test&lt;'a&gt; { test: &amp;'a str } ``` All this is doing is declaring a lifetime, which in this case we called `a`, and saying that the string slice that any instances of this struct may have MUST live as long as `a` does. Now, let‚Äôs make a function: ``` fn test&lt;'a&gt;(input: Test&lt;'a&gt;) { println!("{}", input.test); } ``` Now you are saying that this function `test` must take in an input, and pass it the lifetime `a`. This means that whatever instance of `Test` you pass to this function will be able to live long enough for the string slice to be valid. Let‚Äôs call it now: ``` let input = "hello world"; test(Test { test: input }); ``` When called, we are essentially saying that the lifetime of `input` here defines lifetime `a` for the function. Then, we are checking this to the lifetime of `input`. Here, input lives long enough so that when the struct instance is dropped, `input` no longer needs to be used. Hopefully that makes sense.
&gt;The inclusivity of the rust community is good. Don't poison the well. Inclusivity comes in two flavors: The kind you might expect given the definition of the word, and then the performative, self-serving flavor of double-speak that is used to wage silly culture wars. Now, considering the fact that nothing in the new website design makes it more inclusive or accessible in any practical sense (the opposite, in fact), what you're insisting is that you like the *idea* of inclusivity, even if actions taken are directly counter to that effort. Given the apparent disconnect between the stated goal of the redesign and what was actually achieved, in addition to the heavy handed response to any criticism, it's not unreasonable to wonder if the goal of inclusivity is merely performative.
There's a [great idea](https://internals.rust-lang.org/t/a-final-proposal-for-await-syntax/10021/38) from Manishearth on the internals thread that I really hope doesn't get overlooked. Essentially, it is to add prefix `await` and a postfix macro that expands to it, which really seems to be a best of both worlds solution that should satisfy the majority of both camps. At the very least, I hope to see the language team acknowledge this idea before proceeding with the `.await` proposal.
Imagine using the phrase "culture wars" unironically. Obviously I want the website to be translated. It's so dishonest to assume anyone doesn't want that. The original poster is complaining about some bullshit "post-meritocracy" and overall shitting on the fact that the new website used the word "empowerment". This has nothing to do with it not being translated. The fact the website isn't translated is being hijacked to complain about the words the webpage uses, since that discussion has upset a lot of people. And I think that's crap to do.
&gt;Imagine using the phrase "culture wars" unironically. No need to. &gt;The fact the website isn't translated is being hijacked to complain about the words the webpage uses, since that discussion has upset a lot of people. The person most upset by this discussion appears to be you. Surely you can understand how a website redesign meant to emphasize how empowering it is, while actually doing the opposite, might be a legitimate point of discussion.
Perhaps, but in addition to the vague last comment, straight-up locking the issue (which has less than 20 comments, so it wasn't out of control) is far too authoritarian for my tastes.
It's used by (and developed for) Alacritty: [https://github.com/jwilm/alacritty/blob/864cd9b8ef2c7d708d4160756e51dfa4bab94f16/alacritty\_terminal/Cargo.toml#L23](https://github.com/jwilm/alacritty/blob/864cd9b8ef2c7d708d4160756e51dfa4bab94f16/alacritty_terminal/Cargo.toml#L23)
Rust the language is meant to make it easier to program and shit. The website not being translated doesn't do this. Can you recognizing the fact without taking the opportunity to complain about there being some cultural agenda, using it to push your own politics, complain about "post-meritocracy" or intersectionalism, complaining about cultural wars, or accusing the rust team of not actually caring about empowerment and thinking that the lack of translation must reflect they're actually lying about their goals (double-speak) for personal gain, rather than just an issue? We genuinely don't disagree on the basic ideas (nobody does): They should fix it. They shouldn't have pushed it out with translating. I don't find the need to use this to push my own ideas.
I explain it in terms of dealing with a web request. When the request comes in you have a buffer of bytes. You then want to parse those bytes into the method / headers / body. You could copy each of those out into `String`s but it'd be a lot more efficient to just use `&amp;str` slices into the buffer. The problem with using slices is that they'd be invalid if the buffer ever went out of scope and got `Drop`ped. In our web request example, we'll probably keep the request around until we finish sending the response so the lifetime of the buffer needs to match up with the lifetime of the request. All the slices we derive from the buffer need to be annotated with this lifetime so the compiler can guarantee the Rust invariants while this happens.
&gt; All these keywords, except await, are easily visible at a glance because it is more important to see what is happening in the code than to "hack" everything in a one-liner. If you're writing `async` function you've already put a one big distinct "WARNING: this is async, so it has yielding points". `await` is different from other keywords because on the logical level, it does not affect the flow of the async functions. `async` is just like a blocking operation, and not like `break`. There's no jump in your function. There's just switching to "another thread". And we don't put a big red `blocking_io` before every IO operation. Also, as long as your code editor/IDE can make `await` bold, it will still be perfectly visible and distinct. It is still a keyword. Also, having used eg. postfix `match` in Scala, I know that it is *NOT* less readable than prefix version.
No. Every time the team does something bad don't make it into a circlejerk "let's all shit on the rust team for a few hours".
Could you make this backwards compatible with old macros? If you detect an empty {}, and extra arguments are given, you take on the old behavior, otherwise the new. That way you could integrate this in the std lib and replace the print/format macros currently in there.
Will it be published on YouTube or something after the stream?
&gt; Smaller scale changes were suggested, even as simple as using a consistent color layout, &gt; mockups were even made &gt; . A lot of people, myself included, thought those simple color changes &gt; vastly &gt; improved the site. I mean, it's nice that people think their color scheme is better, but I don't understand why people get so incredibly bent out of shape when it isn't used. It's not as if it makes sense to use half of one color scheme or just... average the colors or something. No. It's a damn color scheme. Fwiw I like it the way it is.
`await` is in itself sort of a busywork. It almost could be implicit and not exist at all as a keyword, but it would make stuff like combining `Future`s without resolving clumsy. Other than this, users will rarely be that interested in `await`, because the whole point of `async` is to write code that appears to execute linearly.
That would work. Though I would bet that after actually using postfix version, people will appreciate how much more convenient and ergonomic it is. The biggest downside of it is "oddity". But after using it a bit, that will go away.
You can, but generally aim to use the combinators, or pattern matching. The issue with is_ok and is_err, is you are then doing an unwrap. You could make a mistake, and unwrap an err'd value, if that makes sense. The combinator functions do this for us.
Rust uses reference counting garbage collection where the count can be at most 1. That 1 is the one mutable reference to an object, and when it goes to 0 the object will be destroyed. You can hand the object to somebody else and you can mutate/destroy it. Meanwhile any number of read-only references may be made to the object, but the compiler must make sure that none of these read-only references "out live" the one mutable reference. Lifetimes and ownership and borrowing are the extra notes we need to add to the program to *prove* to the compiler that no read only reference will last longer than the one mutable reference.
You keep missing the point in order to fervently insist that I have some sort of political agenda here. I don't. Given the way the rollout happened, given the heavy-handed response to perfectly valid criticism, and given the fact that the website regressed in nearly every way‚Äîit's possible, likely even, that this was a misguided attempt at rebranding the website for purposes of inclusion. Consequently, it became impervious to criticism so as to not appear to oppose inclusion.
I dig it! Blackletter macros should have special powers, and any error messages should be printed in latin or german.
&gt; All this is doing is declaring a lifetime, which in this case we called a, and saying that the string slice that any instances of this struct may have MUST live as long as a does. AH!!!! YES!!! Now I get it. Thank you!! It's saying the container (struct, function, etc) must live as long as any references it contains. That one sentence was easier for me to understand than any of those blog posts :-)
Glad to hear :)
No, I don't agree the website has regressed in nearly every way. No, I don't agree there was a heavy-handed response to perfectly valid criticism. No, I don't think this this is a misguided attempt. No, I don't agree that it's impervious to criticism because it would be against "inclusivity". Quite the opposite, it's receiving heavy criticism, especially because it's usage of the word empowerment. Weirdly, somehow again the conversation about the lack of localization is becoming about your own agenda of corporate double speak and attacking some kind of "fake inclusivity" you're trying to normalize. Can we get this crap out? Can you actually talk about the issue at hand for more than five seconds?
(edit as markdown...)
The difference between "Sufficiently Advanced Tools" and "Sufficiently Advanced Compiler" is that one of those has very exact specifications of interaction, technical and otherwise. Your argument here is not too different from "my computer did not work once, so we shall get rid of computers"
In the context of the readme's example, could I turn UsersListRoute { group_id: 4313145, query: { UserListQuery { limit: Some(20), offset: Some(10), keyword: Some("some_keyword".to_string()), friends_only: false, } } } into "/groups/4313145/users?offset=10&amp;limit=20&amp;friends_only=false&amp;keyword=some_keyword" or is it just a one-way thing? The reason I'm asking here instead of trying it myself is because [I couldn't compile the example at all](https://github.com/bschwind/app-route/issues/1).
Hello All, &amp;#x200B; recently I encountered a [bit of skepticism](https://discourse.julialang.org/t/julia-with-respect-to-reliability-sustainability-critical-application-dynamic-static-typing-big-data-hpc/23135/40) towards the statement ‚Äúif it compiles, it probably just works‚Äù from one of the creators of the Julia language. I haven't given much thought to this before as it aligned well with my experiences (with Rust, mostly), but this comment made me want to collect my thoughts on it should I ever need to defend it in the future. So I think this is true mostly because a strong static type system 'automates' the parts of programming that are hard for humans, eg tracking objects throughout thousands of lines of code to see if they are used consistently, and leaves only the parts (higher level abstractions) that we are well suited to work with. Also, it enables tricks likes session types and unit of measurement checking (I think F# has that), that reduces errors coming from oversight even further, and in Rust's case, it (the type system) can even rule out data races. It's late and I'm tired, so that's all I could put together, but if you have anything to add (like a blogpost that already has this put together), feel free!
Thought the editor on new reddit should make it easier to write the post. Guess that will teach to stick to old reddit :)
Nice, thanks.
True. I guess I'm more comfortable with that being the special-case syntax than single-dot, though I'm not really sure why.
That does not make sense to me, actually, because the documentation says about is\_ok: &gt;Returns true if the result is Ok
Do you really need Tokio here? Sounds like something that could just be handled over HTTP, to be honest.
&gt;No, I don't agree You don't have to agree. But you seem intent on insisting that anyone you disagree with has some ulterior motives or political agenda. It's starting to look a lot like projection.
Unfortunately I strongly disagree with the output format of `dbg!`. It's so verbose that I often end up writing my own print statement in the end, *especially* for vectors.
Polishing and documenting an almost pure Rust interface+debugger+flash loader for STM32 devices. Should be finished and published by next week . It allows to directly flash and debug STM32 devices without having to set up a debugger and `openocd` in different terminals.
Still can't talk about the actual issue.
What do you think of something like #[guard(condition)] fn foo() -&gt; i32 { /* ... */ } Desugars to fn foo () -&gt; Option&lt;i32&gt; { let closure = /* original function body */ if cond { Some (closure()) } else { None } } ? (Forgive formatting I'm on mobile)
You could forget to call `is_ok()`,while `if let Ok(variable)=expression` does the checking and unwrapping all at once,so there is no way you could forget to unwrap the correct variant with it.
Will the talks be saved somewhere? It starts at 6 am CEST, so it's a bit inconvenient for me.
&gt; I think the mistake from the web page team was that they were not clear enough that they wanted to catch typos, and were not asking for an open committee to design the page. I think the mistake was: 1. **Not anticipating that the Rust community is used to a higher standard of community participation.** The Rust project is (usually) great precisely because the community is involved in important decisions constantly, and from an early stage. 2. **Launching the website way too early.**. As mentioned by others, the new design is a promising direction, but the design could still do with a lot more tweaking, a lot of content is missing, etc. It was a bad call to release the new website until those things were fixed, and goes completely against the Rust projects usual strategy.
 [https://blog.servo.org/](https://blog.servo.org/) [https://github.com/servo/servo/wiki/Roadmap](https://github.com/servo/servo/wiki/Roadmap)
I‚Äôll definitely join on May 15th :-)
Yep, will post the recordings
If you change the C++ to have the same thing though, you get a much messier set of conditions. if (x % 2 == 0) { I suspect the `x % 2` verses `x % 2 == 0` produces different results because of the optimizer.
The correct test is (x % 2) != 0, and writing it in this form does not change the result for the C version: [https://godbolt.org/z/Cp9m0l](https://godbolt.org/z/Cp9m0l)
&gt; regex-0.2 has been removed in favor of only supporting regex-0.1 I think you mean only supporting regex 1.0, or technically regex 1.x.
As much as I love this aspect about the Rust language, I personally have to admit that the conjecture "if it compiles, it probably just _works_" is likely primarily due to confirmation bias. What I think is happening instead is when things _don't_ work, the language makes it very easy to reason about where something might be going wrong and so you're not always spending hours hunting down stupid little things like the null fields of an improperly initialized object getting coerced to strings or something like that.
&gt;While I use syntax highlighting where possible, I find reliance on code viewer/editor features should not have its place in language discussions. The features are not universal. Not all forums will do syntax highlighting, hiding important control flow in discussions. Its also less common to have it when viewing diffs of code which is where control flow should be the least subtle. It may help you to know that I share exactly that view (*including* the argument that you often won't have highlighting in `git diff` and similar), and I bring that point up regularly in language team discussions. I feel that `.await` benefits from syntax highlighting, but does not require it.
That looks great to me, but to each their own.
I got the rust version to be optimized better here, but still not perfect. https://rust.godbolt.org/z/N2IrDs It obviously knows the answer is 0 in this example, but loops for no reason...
Thanks that‚Äôs a good suggestion. Having my server be an http server would also allow for some otter useful stuff like presenting a browser interface for the data as well.
Yep, fixed.
In this case I can safely say: Post history checks out! :-)
Also it looks like when composed this way, it knows to fully optimize when you actually call the method... at least with a static value. https://rust.godbolt.org/z/GFoeyF Although your original rust example does not get optimized the same way.
The most interesting thing about it is that it implements Paul Williams' ANSI parser state machine. I've written a terminal emulator myself once (you might remember minicom) and that was mostly ad-hoc. I certainly could have used some examples :)
Not sure we have a cross-compiler for the PS4 architecture.
I tried the same. First with a while, then emulating a do-while with the infinite loop + break. I think I figured it out though. https://rust.godbolt.org/z/tcjPby https://rust.godbolt.org/z/6BDCZs It's the `.step_by(uzise)` that somehow isn't playing nicely. Notice how the modulus will now ail over the whole range. We get our drastic optimization. Add `.step_by(1)` and it all falls apart. Also... `.step_by(0)` gives a surprising result as well, hmm...
? I‚Äôm not very technologically knowledgeable
PS4 is (presumably) a BSD-like target, and LLVM is used in the official Sony toolchain, so there's a chance, but it's unlikely the work will be done publicly, as Sony's NDA is very restrictive. Seriously though, you probably want /r/playrust.
Interesting, thanks! I would be interesting to know also why your version generates a spurious loop.
Yeh I understand, I think it would come out quicker if PS4 had an early access scheme
I‚Äôm sorry, I was teasing a little. This is the subreddit for the rust programming language. You want r/playrust
This is what you must do. Otherwise type inference uses the first element of the `Vec` to determine the type for the entire `Vec`, by using the concrete type. You need to provide a counterforce to that inference by specifying the actual type of `Vec` that you want.
Thank you! Have a nice day
You too!
I'm honestly not even sure if you're missing the point or ignoring all the scary words or _actually_ talking about the Rust programming language.
God, I didn‚Äôt realize that programming languages evolve (and are worth to exist) iff Microsoft supports it!
Why not: ```rust fn foo () -&gt; Option&lt;i32&gt; { if cond { Some ({/* original function body*/}) } else { None } } ```
It looks like the `println!` at the end of the example does just that, using the impl of `Display`, so `.to_string()` should do what you asked.
Even something like this will not be optimized away. [https://rust.godbolt.org/z/AeHkxC](https://rust.godbolt.org/z/AeHkxC)
You can also get the Rust version to do better by using a `while` loop to emulate the C/C++ `for` loop instead of using `(0..num).step_by(2)`: pub fn bongo(num: i64) -&gt; i64 { let mut a = 0; let mut x = 0; while x &lt; num { if (x % 2) != 0 { a += x } x += 2 } a } For some reason [it still does the loop, but then always returns zero](https://rust.godbolt.org/z/6U2ha1). If you take a look at the generated code using `step_by`, you'll see that it's doing some overflow checks: movabs r8, 9223372036854775807 # 0x7FFFFFFFFFFFFFFF ... cmp rdx, r8 This doesn't go away if we disable overflow checking at the compiler level, so let's take a look at the [implementation of `step_by`](https://doc.rust-lang.org/src/core/iter/adapters/mod.rs.html#415): #[stable(feature = "iterator_step_by", since = "1.28.0")] impl&lt;I&gt; Iterator for StepBy&lt;I&gt; where I: Iterator { type Item = I::Item; #[inline] fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { if self.first_take { self.first_take = false; self.iter.next() } else { self.iter.nth(self.step) } } #[inline] fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { let inner_hint = self.iter.size_hint(); if self.first_take { let f = |n| if n == 0 { 0 } else { 1 + (n-1)/(self.step+1) }; (f(inner_hint.0), inner_hint.1.map(f)) } else { let f = |n| n / (self.step+1); (f(inner_hint.0), inner_hint.1.map(f)) } } #[inline] fn nth(&amp;mut self, mut n: usize) -&gt; Option&lt;Self::Item&gt; { if self.first_take { self.first_take = false; let first = self.iter.next(); if n == 0 { return first; } n -= 1; } // n and self.step are indices, we need to add 1 to get the amount of elements // When calling `.nth`, we need to subtract 1 again to convert back to an index // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1` let mut step = self.step + 1; // n + 1 could overflow // thus, if n is usize::MAX, instead of adding one, we call .nth(step) if n == usize::MAX { self.iter.nth(step - 1); } else { n += 1; } // overflow handling loop { let mul = n.checked_mul(step); if unsafe { intrinsics::likely(mul.is_some()) } { return self.iter.nth(mul.unwrap() - 1); } let div_n = usize::MAX / n; let div_step = usize::MAX / step; let nth_n = div_n * n; let nth_step = div_step * step; let nth = if nth_n &gt; nth_step { step -= div_n; nth_n } else { n -= div_step; nth_step }; self.iter.nth(nth - 1); } } } Yikes, that has some complicated overflow handling. And let's also look at `nth` in [`impl&lt;A: Step&gt; Iterator for ops::Range&lt;A&gt;`](https://doc.rust-lang.org/src/core/iter/range.rs.html#236): #[inline] fn nth(&amp;mut self, n: usize) -&gt; Option&lt;A&gt; { if let Some(plus_n) = self.start.add_usize(n) { if plus_n &lt; self.end { self.start = plus_n.add_one(); return Some(plus_n) } } self.start = self.end.clone(); None } That also has its own overflow checking. It looks like you can do a little better if you use unsigned integers, but it still doesn't optimize it all the way down. This does show that `for x in (0..n).step_by(2) { ... }` is not really a zero-cost abstraction for `let mut x = 0; while x &lt; n { ...; x += 2 }`.
Microsoft has been trying to meet all community demands. It has contributed into making an ecosystem that everyone can use. It is also embracing Linux ecosystem! What else do you want it to do? As far as programming languages: *Yes*, when Microsoft supports a language, the best and most experienced developers ensure that everything works efficiently. Remember that Microsoft hires the top quality staff in every area. Most experienced and efficient programmers.
I guess Rust is trying to get in it's 10000 steps per day.
Using `for_each` seems to optimize the code quite a bit over using a for loop https://rust.godbolt.org/z/T0-txX weirdly enough.
They're useful if you care about whether a value is `Ok` or `Err`, but don't care about the contained values, but I can't think of many cases where that would be useful. A contrived example would be something like let mixed_results: Vec&lt;Result&lt;_, _&gt;&gt; = vec![Ok(1), Err(2), Ok(3), Ok(4), Err(5)]; let oks_only: Vec&lt;Result&lt;_, _&gt;&gt; = mixed_results.iter().map(Result::as_ref).filter(Result::is_ok).collect(); but usually you'd want to unwrap in the process, and write something like let oks_only: Vec&lt;_&gt; = mixed_results.iter().filter_map(|v| v.ok()).collect(); Actually, I just found a place where I've used it: checking to see if a environment variable was set, without caring what value it was set to: if std::env::var(&amp;key).is_ok() { // Do things }
Hahaha, thanks for the laugh.
Your bango thing also works on OPs version.
&gt; the container (struct, function, etc) must live as long as any references it contains Other way around. The reference must live at least as long as this thing that's going to contain it. For example, the struct is allowed to contain a static string.
Yes, it's a common pattern in internal code at Google, but I'm not sure if it's open source so that I can talk about it.
Thanks, will sure to keep in mind that step\_by is more expensive than it looks. Still, when even an empty loop body gives something like this: [https://rust.godbolt.org/z/AeHkxC](https://rust.godbolt.org/z/AeHkxC), I can't help but feel that there's room for improvement here.
So thinking about this a bit more... in the version I posted, it is possible to get into an infinite loop by passing i64::MAX. In this case, I think it will loop forever because x will overflow back to zero before the break condition becomes true. That is probably why it doesn't optimize out the loop. But that has me wondering... wouldn't your C version *also* be susceptible to the infinite loop? If so, why does it optimize the loop out? On the other hand, your rust version would NOT be susceptible to an infinite loop. So that is a key difference in functionality, which might account for some of the difference in optimization. Still seems like it *should* be better optimized though.
Have there been language design choices you strongly disagreed with in the past?
And on a similar note... this produces an "Illegal Instruction"... that seems very wrong! https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=a1eabf41cd02ec7f7747c504409b4b2d
I see. So a lifetime is a way of telling the compiler "this reference must live as long as it's container", or "these references must live as long as the container". That makes more sense when I think about it.
Just checked with the rest of the organisers to be totally sure: no.
In particular, it's saying "this container must live at most as long as the thing being referenced"
Very cool packages; quick question: I only see a way to estimate ||A||\_1, but I can do that my l1 row sums. The hard part appears to be estimation of ||A\^-1||\_1; how do I use your package to get ||A\^-1||\_1 given only A?
I've run into situations where I've wanted to use *both* `impl Trait` in an argument position and a turbofish at the callsite. For example, it's a bit contrived, but have a look at [this playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=fa4915b2e8e35f00a28c2d979959753d). Sometimes you want to write a function where some of the type parameters will *always* be inferred, but allow the caller to turbofish some of the others.
Has anyone checked whether there's already an issue on the tracker for this? It seems like a good candidate for being on there and I'd like to subscribe to updates on it, but I don't consider myself knowledgeable enough about this sort of low-level stuff to identify different formulations of the same problem or to write a good report for it.
Is there a reason this terminate early with "Illegal Instruction"? https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=1ccc4fadb3b9659a0412e1df2a4928c2 Expected behavior is for it to loop infinitely, however on both play.rust-lang.org and my own computer (windows), it generates an Illegal Instruction error.
That's an infinite loop without side effects, which LLVM calls undefined behavior. Rust now tells LLVM to trap unreachable, which at least contains the UB, so your "illegal instruction" comes from the `ud2` instruction it generates there. See also: https://github.com/rust-lang/rust/issues/28728
And replacing `.step_by(2)` with `.filter(|x| x % 2 == 0)` takes us all the way home**!!!!!!!!!** https://rust.godbolt.org/z/nkruCe Funny though, using just the filter method without the `.for_each` doesn't optimize all the way... Very curious.
Add four spaces instead of three backticks to format code: fn foo(cond: bool) -&gt; Option&lt;i32&gt; { if !cond { return None; } // do something useful Some(42) } use try_guard::guard; fn foo(cond: bool) -&gt; Option&lt;i32&gt; { guard!(cond); Some(42) }
These would seem to be related: [https://github.com/rust-lang/rust/issues/59281](https://github.com/rust-lang/rust/issues/59281) [https://github.com/rust-lang/rust/issues/57517](https://github.com/rust-lang/rust/issues/57517)
Very interesting, considering that `StepBy` doesn't have a specific implementation of `try_fold`. `for_each` and a `for` loop should both compile to more or less the same code with repeated `next` calls, as far as I'm aware.
You can always file an issue at [https://github.com/rust-lang/rust/](https://github.com/rust-lang/rust/), they would really appreciate that :)
&gt; But that has me wondering... wouldn't your C version also be susceptible to the infinite loop? If so, why does it optimize the loop out? Signed overflow is undefined behaviour in C. This allows compiler to assume that it will never happen.
&gt;at least with a static value. Even when you give `bango` a parameter and use that, weirdly enough.
I would suggest looking at their examples repo: https://github.com/actix/examples Each of the subprojects can be built and run separately, play with them, read the rust docs of the methods that interest you, try to adopt them for your pet project.
To that end, everyone should watch this talk about Idris 2: [https://www.youtube.com/watch?v=mOtKD7ml0NU](https://www.youtube.com/watch?v=mOtKD7ml0NU)
I don't know if there is one yet. They are working on v1.0 right now and haven't rewritten the book yet afaik. The examples should be updated according to this issue: [https://github.com/actix/actix-web/issues/722](https://github.com/actix/actix-web/issues/722). &amp;#x200B; Until they have updated the documentation for 1.0 I don't think you'll find much info about Actix web 1.0.
Yeah, given the number of unexpected behaviors here, it might be worth filing some issues on this. For writing a good report, the best thing is to provide as minimal an example as possible. For instance, the unexpected lack of optimizing out of the `while` loop can [actually be reduced to](https://rust.godbolt.org/z/RC02GG): pub fn bongo(num: u32) -&gt; () { let mut x = 0; while x &lt; num { x += 2 } } While on the other hand, [this does optimize away](https://rust.godbolt.org/z/cf0kmn): pub fn bongo(num: u32) -&gt; () { let mut x = 0; while x &lt; num { x += 1 } } I'll file a ticket about this issue. The `for x in (0..n).step_by(2)` issue may take some more time to turn into minimal examples, since the range iterator and `step_by` iterators are reasonably complex. I'd consider trying to minimize that down, but probably shouldn't be spending the time on it right now, so if you're interested in learning about this kind of thing, you could try your hand. Basically what you want to do is first, copy in the relevant parts of the standard library to your program, so you can more easily modify them as well to be able to remove as much irrelevant code as possible. Then, keep cutting the example down (including the standard library code, taking out anything that looks like it would be irrelevant or already optimized away) while demonstrating the behavior that you don't want to see. If that behavior goes away, you now have a pair to compare it with. You can frequently continue to cut down both the original and the alternative even further, until they are quite small, which can help to isolate the specific issue. Sometimes, the issue may be in the library code rather than the optimizer; it may be doing something that really can't be optimized away. But finding this can be helpful as well. It looks like there are already some issues linked in a sibling comment about `step_by` being inefficient, but not one has taken the time to actually break it down into the most minimal example.
Okay, cool. So it would seem to me that the main issue is difficulty optimizing around iterators (in particular, using the step_by method). Using a straight `while` or `loop` lets it compile as well as it possibly can if we assume the compiler must leave the possibility of an infinite loop. Would be nice if adding an early return for `if num == i64::MAX` would let it optimize away the loop, but that is probably expecting too much.
I second going through their examples. Their documentation hasn't caught up, and in many cases is wildly different from the code you want to be writing.
So... if I'm following along... Rust recognizes that there is an infinite loop, and declares that any code after said loop is unreachable. Meanwhile, LLVM recognizes the infinite loop and does... well, whatever it wants since it's undefined. Then, since LLVM skipped the loop, we end up executing what Rust previously decided was unreachable code. Am I understanding that correctly?
[Done!](https://github.com/rust-lang/rust/issues/60603)
Wow. This totally makes sense now, and I feel like supports my theory that Rust will not optimize out a potential infinite loop. Since `bango` calls `bongo`, and by its own definition `bongo` must return (ie, not loop infinitely), `bango` is allowed to optimize fully. However, inside `bongo`, rust will not optimize away the possible infinite loop.
LLVM decides it's unreachable on its own, but Rust sets `TrapUnreachable` since [pr45920](https://github.com/rust-lang/rust/pull/45920), which gives us a well-defined trap. Before that, LLVM would often just emit *nothing* for the loop, nor anything following like a return, letting execution continue past the end of a function into whatever code happened to be next in memory.
Awesome, thank you for the explanation!
Here's why LLVM thinks infinite loops can be optimized out: https://blog.regehr.org/archives/161 Basically, because infinite loops without side effects are undefined in C/C++, with some technicalities.
That's still weird to me, though. Why would `bongo` return by definition? Does that mean that Rust also considers an infinite loop to be UB?
rust in general does not use reference counting garbage collection. The whole point of the lifetime stuff is to prove at compile time, not run time, that these references will live in all places they are used and will only go out of scope where they no longer are needed. &amp;#x200B; a/rc is used for reference counting where needed.
Rust also has some units of measurements checking crates, uom and dimensioned. I want to note that there is a slight confirmation bias on both sides of the argument. On one hand, there definitely are diminishing returns in proving absence of logic errors via types, on the other hand, absent of *any* proof, you may not find bugs that aren't executed ‚Äì and this leads to the philosophical question if a bug that doesn't get executed is a bug at all? I must note that in my experience, software has the curse of often being used far longer and in a far broader range of use cases than initially specified (law of unintended consequences). So as time approaches eternity, the probability of hitting any ever-so-obscure bug approaches 1. Given this, we face the danger, nay, certainty that any bug we leave will eventually get triggered. There are two ways to deal with it: The first is embracing the inevitable and creating safeguards at runtime. Erlang is a nice language for this sort of code, but it's not exactly fast. The other way is proving the absence of certain error classes. This can be done with types or program verification. The latter is very complex and thus expensive, so the former offer a good 80% solution. Finally, in Rust, we want to go fast, while still being able to abstract. So the type system (and borrowck) allows us to prove things at compile time we then no longer need to check at runtime. For example, in my [compact_arena](https://docs.rs/compact_arena) crate, I use lifetimes to ensure that each index is branded by the arena giving it out, so you can never mix them up. This allows me to omit bounds checks on lookups where I'd otherwise need them for safety ‚Äì or like C++, be vulnerable to out-of-bounds memory accesses by default.
I see `pub amount: f32,` in there, and if that is money, I can tell you it's wrong. (if it's not money but something else, then ignore me).
Hey, thanks for your interest. Can you maybe post the question on the github issue tracker? That will make it more visible. :-)
&gt; Why would bongo return by definition? By it's function signature, it returns i64. Rust actually has a type for a function that doesn't return. Such a function would look like fn endless() -&gt; ! { loop { // Some stuff that never breaks or returns } } So `endless` by definition does not return. In the same sense, `bongo` by definition returns `i64`.
Reference counting *where the count is at most 1*. Consider the code ``` let s = String::from("Hello!"); if fancy_condition() { drop(s); } // should the compiler insert a drop s here? ``` and you'll understand why the compiler adds an extra little boolean to keep track of whether or not `s` has been dropped. If you are already familiar with reference counting: Rust has a trivial version of reference counting.
Thank you!
Welcome! :)
Why not just make it a function that creates a `Result` from a conditional? The macro just seems to add functionality that's already there in the form of `?`, which is well understood. It would look like the [following](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f70764df45bf20e03e40117bb4e6949e). Note that this works on stable, but by switching to nightly and turning on the try trait you get a nicer handling of optional. The examples of converting to `Optional`, or another error type could be wrapped in helper functions `assume_optionally` and `assume_or`. The advantage is that using the `?` at the end of the guard statement makes it clear that this guard can cause the function to return early. A macro instead implies anything at all could happen. Also you can always implement `From&lt;PreconditionError&gt;`, but I think that it'd be more convenient to map each individual case where it makes sense.
Reference counting is run time. rust lifetime memory management is compile time. It's not just a semantic difference, one is not like the other in an important way. &amp;#x200B; Airplanes do not swim even if fluid flow dynamics is useful in assessing their wing designs.
So lifetimes are just a way to help compiler clearly understand the code?
Notice how you get identical code for C++ and Rust when you use `unsigned long` (equivalent of `u64`) in C++ rather than just `long` (equivalent of `i64\`): [C++ sample](https://godbolt.org/z/OF6eaU), [Rust sample, rewritten to actually be equivalent](https://rust.godbolt.org/z/ZLhYQj). This confirms that the difference is due to signed integer overflow being undefined behavior in C++ (unsigned overflow is not).
This is a great explanation, but I still haven't gotten WHY the compiler needs us to tell it lifetimes sometimes. If it can tell at me for lifetime errors at compile time then shouldn't it be able to take care of annotating them itself?
Exactly! Lifetimes just help the compiler understand your code. They don‚Äôt actually do anything different. You don‚Äôt need to get the lifetimes at all, they are just arbitrary names you give to them.
Done!
If the request isn't lexically scoped how would the compiler know the underlying buffer will continue to exist across multiple function calls?
Right, but this is also allowed: fn f() -&gt; i64 { loop {} } Calling `f` will result in an infinite loop, as you would expect, despite the return type being `i64`. So other functions can't just assume that `f` actually returns.
I
Ah honest mistake, makes sense now
I don't understand how to do it without Clone() actually, I've tried almost everything... The data are in a Vec inside a Struct (the whole thing is in a Btreemap). There is 10M keys, 10 entries about in each Vec (so about 100M entries in the global Vec). What I want is when I grab those entries from the Vec, while adding them to the global Vec, i want to also send them to a function and do some stuff with them.
Ah sorry - thought it was a person on the team who wanted a general gist of opinion
It‚Äôs cool; that‚Äôs exactly why I thought the poll was a bad idea.
Well at least these are not exactly common patterns, and look like they could be easily optimized in the future.
How about the "dot await exclamation-mark left-paren right-paren" syntax? (`.await!()`) It is not a postfix macro and therefore does not depend on the postfix macro feature.
Sure, but that's the interesting one as it's used in pretty much all custom proc-macro implementations.
As far as I can tell, the primary difference boils down to this: add nsw i64 %x, 2 versus add i64 %x, 2 As other people have figured out, with a few tweaks you can improve the rust version, but it has a seemingly-useless loop before returning zero. That's because `x += 2` might overflow. For C++, LLVM emits `add nsw` for signed integer arithmetic, the `nsw` just means that the optimiser is allowed to assume overflow doesn't happen, and therefore doesn't have to consider the case where `x += 2` overflows. As others have also observed, in that case, the loop is infinite. One interesting thing is that you can produce the same assembly for the C++ version by using `unsigned`. Since unsigned integers have defined overflow behaviour in C++, LLVM omits the `nuw` flag that indicates that overflow is undefined. That causes the loop to stay in the C++ version. More generally, while I appreciate that you're just experimenting and found an unexpected result, it's worth putting stuff like this into context. Cases like these are incredibly artificial, no real piece of software would contain something like this, so the differences in semantics have an outsized effect. This example doesn't really say anything about the relative performances of Rust and C++.
Because arrays stay in the stack and vectors stay in the heap
I haven't studied compilers. What's stopping them from analyzing code outside the current lexical scope?
I published another release of [compact_arena](https://docs.rs/compact_arena). Now trying to introduce it somewhere. Crates often rely on references, which makes this hard.
Yes, the macro will derive the Display trait for you so you can format it with {} in a format string or call .to_string() on it
&gt;Because arrays stay in the stack and vectors stay in the heap.What are in the stack is faster to access than what are in the heap. Is that true? They are both memory regions, in theory they should have the same access time as long as they are contiguous to for spatial locality in cache.
And if the "rust folks" you saw tweeting were members of the teams then of course they're going to be saying how great it is
In writing text, a paragraph indicates a new idea or grouping of ideas. This is a natural fit for humans and the way we think. In programming, nesting is the equivalent. Unfortunately, nesting can be nested. It behooves us to avoid as much nesting as possible when programming since it makes thinking about a problem harder. &amp;#x200B; `if condition,` `handle error error case and exit early.` `handle common case` &amp;#x200B; nicely breaks up the concerns and builds a common code structure.
It's fine on small collections, but I think he might be talking about thousands/millions/more
Literally all those ‚Äúrust jobs‚Äù are jobs removing rust and mechanical work, not programming
Show us the benchmark
Ok, so changing the examples to use unsigned long (C) and u64 (Rust), there is still a substantial difference between: [https://godbolt.org/z/6--Ccw](https://godbolt.org/z/6--Ccw) (C) [https://rust.godbolt.org/z/jbkVrv](https://rust.godbolt.org/z/jbkVrv) (Rust) For me, the take-away is that "zero-cost abstractions" is very far from the truth when it comes to step\_by, and that if I need this functionality in Rust, I am probably better of writing just a while loop. \&gt;Cases like these are incredibly artificial, no real piece of software would contain something like this I think a lot of software could conceivably want to use something like step\_by, and were such usage to occur in a hot loop, Rust performance would indeed compare unfavourably to C/C++.
Overflow of both signed and unsigned integers is undefined behavior in Rust. There are library types that provide wrapping semantics. In debug builds it crashes with an error, but in release builds the compiler can just assume overflow never happens.
False. It is well defined to panic or wrap based on your arithmetic overflow setting at compile time, it's never UB.
Two differences: - The stack is pretty much always in cache, because your code is constantly accessing stack variables. A vector on the heap might be in cache if you just used it, or it might not. - Allocating heap memory means going through the global allocator, which sometimes means taking a global mutex and modifying global data structures. Whether the overhead of doing that will show up in your benchmark, depends on all the details of your benchmark and also on a lot of internal implementation details of your allocator. I think /u/Lokathor said "show us the benchmark" because the details of all these things can be difficult to guess about. There are a lot of factors involved.
No, this is wrong. It's specified to wrap around in release modes _by default_, but overflow checking can be enabled (and there is even [discussion to turn it on by default](https://github.com/rust-lang/rust/issues/47739)). See https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md and http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/ for more details. The latter gives a more succinct overview.
Yep, I opened [ct-austin/ifmt#1](https://github.com/ct-austin/ifmt/pull/1) to add stable support.
You're right. Thanks. I'm now following them.
&gt; so if you're interested in learning about this kind of thing, you could try your hand. Unfortunately, I already have enough on my plate with just things that I'm already proficient in. (eg. Some of my own projects are in dire need of maintenance.)
Thank you for the update to proc-macro-hack! That's amazing :D I was sure this wasn't possible on stable, glad to be proven wrong.
Shouldn't that be if (x % 2 == 1) { in which case, you get the exact same assembly.
I have not tried every example but from what I tried the examples work with actix 1.0 beta.
I mostly use those inside asserts in tests. In production code, the vast majority of code touching a result will either want to get its hands on the successful value or to propagate any errors, and the idiom for doing that is the `?` operator.
While it's true that optimizing the loop away turns out not to be an issue with real code, the other issue run into is the internal vs. external iteration footgun when using some iterator adapters (https://github.com/rust-lang/rust/issues/59281 and https://github.com/rust-lang/rust/issues/57517); and that's something that could come up in real code, and not be obvious why it's happening. Of course, these "optimize the loop away" kinds of issues are the ones where it's most obvious that there's some difference (which is why I minimized that down to a trivial example so easily); real-world use cases can make it a lot more complicated to see the issue.
In this Rust code, there is actually no overflow while in the C code there is. In a sane world Rust would optimize better the code, but this world is is a weirdo. &amp;#x200B; iter.step\_by(x) just takes some iterator iter and discard a few iter.next(), it is not like the C += 2
Without seeing your benchmark, there's not much we can really do to answer your question.
 üëè love this. This is becoming a baseline from what programmers expect coming from other modern programming language. I'd love to see something like this eventually be folded into stdlib
The lexical scope comment isn't about compiler analysis, it's about the general Rust resource model. If you create something it'll get destroyed at the end of the lexical scope unless you do something special to it (most commonly, return it). All references have a lifetime but the compiler lets you skip writing the boring ones (e.g. `fn length(x: &amp;str) -&gt; uint` is really `fn length(x: &amp;'a str) -&gt; uint` where `'a` represents the lifetime of the underlying `String` buffer). The two correspond to how most code is written so the lifetime system winds up staying out of your way until you run into a situation where you don't want the buffer to be destroyed at the end of the lexical scope (e.g. you want it to last for the duration of the http request), you're working with multiple buffers, or some other non-basic situation Then you have to use the lifetime annotations to tell the compiler how long the buffer should live and the compiler tells you when that doesn't match how code is written.
They both are and aren't. i *did* read them before linking it. But later on i did notice the search results don't seem to be consistent. looks like an indeed thing. Refresh until it gets sensible/use a better search. [Adding "programming" seems to improve the results significantly.](https://i.imgur.com/zMPyQPA.png)
You *can* do that, but it appears to be UB. See here (got the example from a link someone else posted... don't remember which one now) https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=d9bf246c7f2e15040328760b8b68039e Also, just from a logical perspective, it seems reasonable to assume a function that has a return type other than `!` must eventually return. The only exception would be for panicking, and everything else is programmer error (unless you want your program to do nothing forever, which would be a useless program). For the purpose of optimization, I don't mind this assumption being made. I've recently learned optimization can (and does) assume some weird stuff. To me this particular assumption seems pretty okay.
This is the benchmark. Option 1 is always faster and I am not sure why.
My thread is not intended to say the design is bad and needs changing. There was a lot more to the situation that just the design of the site itself. The design and direction it went in general isn't necessarily bad, but IMHO it needs a lot of polish. Some of my primary concerns with the design for example are the lack of code on the front page and color scheme, but the rest is fine.
TIL. For some reason I always thought Rust copies Cs behavior in release builds for optimization reasons. Thanks for that article
Curious if the older Rust compilers with a classic gcc backend would emit better code
"and then"?
Yea, I was referencing something I posted earlier
`!` is a [bottom type](https://en.wikipedia.org/wiki/Bottom_type), which means it is a subtype of `i64`, and so it's acceptable in any expression expecting an `i64`. Because of this, it's type-safe for a function returning `T` to panic instead of explicitly returning an instance of `T`.
&gt; Currently, one can supply their own list for reproducible builds. But that isn't the default. Totally understand it's a WIP, and you do clearly document that behavior. That said, currently your [list of dependent crates](https://crates.io/crates/addr/reverse_dependencies) short, but if you had a lot of dependent crates, that magnifies the number of users using addr via another crate where the documentation is unlikely to be read. It's one of those problems waiting to happen but not yet likely. &gt; This is exactly what I plan to do at some point. This is one of the reasons why the library has not reached 1.0 yet. That's great! I'm glad to hear that. Definitely don't take my post as personal criticism, just thoughts on how your crate could improve. Please let me know if I can contribute any time to help. :)
&gt; When i recommend Rust i still link to https://prev.rust-lang.org/en-US/ Ha! didn't know it still exists! Thank you! I'll start directing curious colleagues to this page instead of wikipedia. Little rand (Sorry): The current default landing page doesn't even tell you what "rust" is. Don't believe me? **Show https://www.rust-lang.org/ to another person and ask them to tell you what that page is about.** I still can't believe other people in the core team haven't stepped in yet. The current landing page is an unmitigated disaster.
&gt; it would be pretty hard to find people in a primarily non-webby community who want to maintain a website. Most folks want to contribute primarily in Rust, and the website isn't a great place to do that. The old website didn't have this issue though. Perhaps there is more behind the lack of community contributions to the redesigned website.
Looks like this is not intentional. It's a known bug: https://github.com/rust-lang/rust/issues/28728
Fun fact: You can't even tell from the landing page what the site is about without knowing what rust is before hand. They never once state what Rust actually is. I'm serious, go to that page, and tell me what rust is. Is it a build system? a code analyzer? an efficient translation tool? In its current state (the landing page at least), I'd argue that it's actually dissuading managers from using Rust.
Your array is on the stack and its size is statically known. You should get same result as Vec if you used a Boxed dynamic array
&gt;Your array is on the stack and its size is statically known. You should get same result as Vec if you used a Boxed dynamic array Thanks for the response. Why would it change if I didn't used a boxed dynamic array?
Writing to eax clears the hi bits of rax implicitly iirc
In the first case, the compiler can compute the result ahead of time since it knows everything about how the loop will execute. However, in the second case, the operations are too complicated for the optimizer to entirely eliminate the calculations. You can see this by checkout out the assembly generated by the two versions [here](https://rust.godbolt.org/z/qkiGdT). Note that it's also possible that something else is going on, since it seems like you copied this code out of a benchmarking harness? Without the full code it's difficult to say. If you're not using a benchmarking harness like the one that ships as `cargo bench` or the 3rd party [`criterion`](https://docs.rs/criterion/0.2.11/criterion/), you probably should -- those frameworks provide infrastructure to avoid traps like this where different optimizations kick in and make it unclear whether you're actually testing the code you think you are.
Well, but isn't the whole point that the loop is optimized away because the compiler knows it's useless? Certainly agreed that the step_by fn appears to not be so zero-cost, in this situation, but the parent commenter is talking about the original example and I think it's fair to say that the original example is indeed very artificial since it contains a provably pointless loop.
I get that part, I just don't get why the compiler needs me to tell it that. Why couldn't it figure it out on its own so we can elide all lifetimes?
Done üôÇ. Renders from webcam to SVG [https://github.com/willdady/swirlr-wasm](https://github.com/willdady/swirlr-wasm)
I don't think I agree with the notion that unsafe is "supposed to be annoying". In my mind, it's really just the original example of this thing we're trying to do here. First there was unsafe. Next async. Then try. Then hopefully we'll get higher kinded types, and we can get do blocks for generic monads. At this point, hopefully unsafe, async, and try can be deprecated, as these are all just monads and could use the do notation. As far as I'm concerned, unsafe getting postfix dot notation is the only way this situation is salvageable. Similarly, try should get postfix dot. As for unsafe being this evil thing that should be avoided, I don't think this is a productive attitude. Realistically, at this level of programming, there's going to be unsafe code. Any program that's not just CRUD probably has some in there somewhere; programmers shouldn't be scared of it, they should be respectful of it like any dangerous power tool. A chainsaw is a dangerous tool that shouldn't be your first choice, but if you have to cut a tree down it's the correct choice.
Rust is ridiculously nice for CLI applications. It's easy to make them work across all popular platforms and to statically link them. And the resulting apps launch instantly and run very quickly. Tricky threading is also surprisingly nice in Rust, because Rust normally has no shared mutability and the compiler can prove many useful things. WebAssembly and synchronous servers can also be pretty nice. Rust async looks very promising, but it's not ready yet.
I sometimes think compiler writers are crazy and then i read something like this and I'm sure. Hope they at least warn about their 'optimization'.
Here is the generated code for different version... [https://godbolt.org/z/kVcZiD](https://godbolt.org/z/kVcZiD) &amp;#x200B; The Vec version does boundary check, and use scalar instructions. The static-sized array has an unrolled loop that uses SIMD instructions.
My first published crate! Let me know what you think. Is this useful to people? I definitely find it useful myself.
The function signature in Rust can be seen as a contract, such that any change to the contract (i.e. signature) is seen as a breaking change. If the compiler inferred lifetimes based on the body of a function, you could introduce a breaking change without noticing.
Some Rust vs C differences off the top of my head: - Integer overflow is defined. This includes addition like we were talking about, but also bitshifts, which are UB in C if the right side is large. - Division by zero is defined to panic. - Indexing is bounds checked. - `&amp;mut` aliasing is always UB in Rust. As I understand it, pointer aliasing in C only leads to UB if the pointers are of different types, or if the `restrict` keyword is used. - Infinite loops with no side effects are allowed in theory. In practice I think there's an [ongoing issue with how LLVM compiles them](https://github.com/rust-lang/rust/issues/28728).
I wish every single open source program that is made in C++ was made in rust instead as a user. I'm sick of (amateurish) coding leading to segfaults and codebases and devs *terrified* of refactoring because they're worried about tripping over some UB. Yes, i'm suggesting that rust very strict compiler and lifetime system is better to refactor without fear, and yes, most complex projects taken up as a hobby badly need this medicine, even if they loudly protest they don't.
Could you give me an example of that? I don't understand how writing a function could introduce a breaking change if the compiler could tell what lifetimes should be.
I like this much better from a cognitive concentration viewpoint. ? is for returning early - if nothing else, i like rust popularizing such a simple but useful idiom.
I sent you a godbolt link that shows the differences. If you use iter\_mut() you should get good result with the Vec
The compiler looks at lifetimes to figure out how long the underlying buffer has to live and where to insert the destructor. If there aren't lifetimes and the number and order of function calls can vary at runtime, how can the compiler guarantee it won't screw up the destructor placement? Garbage collected languages work around this by tracing references but the borrow checker works at compile time.
This feature is called Specialization. It has been in development for a long long time. Last I here there are some big problems with it, and so it is not high on the priority list.
&gt; where to insert the destructor I thought lifetimes didn't affect scope. Wouldn't the destructor always be the same?
It sounds like what you're running into is the lack of trait specialization. That is, you want to write a generic implementation and then more specific overrides for specific types? So to answer your questions with that understanding, the answers are: a. *Is this even possible?* Not yet. b. *Why is it not possible?* Because there's lots of tricky design and implementation work to be done to make this feature work. Most of the complexity is related to how exactly `rustc` should choose what implementation to use for a trait. The TL;DR though is that Rust would really like to be able to reliably choose a single implementation for a trait at a call site (or when allocating a trait object), and that implementation should be consistent regardless of what goes on outside of the crate currently being compiled. There are some tricky details to work out in both the design and implementation, which you can read all about [in the tracking issue, and the linked RFC](https://github.com/rust-lang/rust/issues/31844).
Thanks! That is good to know. &amp;#x200B; Such a concise answer for such a long post, but the results were not coming up on Google for me. &amp;#x200B; Much appreciated!
This is correct. And it's pretty easy to adapt this code to use it: just add the `default` keyword to the default `to_string` implementation ([playground](https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=9ca63bee50694fbe1edd628c40715cf7)).
Thanks! That is a great example.
I appreciate the context. This is useful information.
I'm also a Java developer. I think Rust is amazing for a couple reasons. 1. No GC Pauses, ever. In some applications, this isn't a big deal. In others, it's game changing. 2. Rust won't compile most concurrency bugs. I've spent a lot of time debugging frankly illiterate concurrent code in Java, and I'm kind of sick of it. The idea of a memory-safe language is very compelling. 3. It has a lot in common with Scala, while being a simpler language. Wrapping your head around lifetimes and borrowing is work, but like Scala, it borrows a lot from functional languages without being fundamentalist about it. Unlike Scala, there are no implicits, and the language syntax is generally unsurprising.
I started off as a fan of prefix await with mandatory delimiters (`await { fut }?`), but I've fallen in love with the "pipelining" idea that's presented here (`(await fut)?` or `fut.await?`). My only gripe is the fact that we're so against introducing a new symbol to represent this. It's much more surprising to see `fut.await` than `fut#await`, and if I was just starting to use Rust I'd spend my time trying to figure out what this magic field is rather than going "oh there is a symbol I don't know, I should read the book or something." Reusing the dot operator just seems confusing and it ends up feeling more like a special case than a language feature. The arguments in the blog post seem to be: - It produces too much "line noise" - We might want to use [insert symbol] for a later feature (a character budget) But how I see it: - `fut.await` and `fut#await` aren't very different in the amount of "noise," but that's 1) my opinion and 2) contingent on your exact definition of noise - Isn't a new feature one of the reasons why we reserve characters in the first place? If this isn't a good candidate, what is? All that said though, this is the final proposal, so I doubt any of this will change :( On a less complain-y note, big ups to the lang team for pushing this through-- we're finally moving passed the question of syntax! Looking forward to the **future** of stable async-await!
Here's a version that gives better performance for vectors (in most runs): [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b3face22f8c64b25803fa213be6a858f](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b3face22f8c64b25803fa213be6a858f)
Nice. I experimented with the same thing in [interpolate](https://crates.io/crates/interpolate) except for better and worse using `s` (iformat) and `p` (println). But honestly, I just think the std library macros should work this way.
Nice. I experimented with the same thing in [interpolate](https://crates.io/crates/interpolate) except for better and worse using `s` (iformat) and `p` (println). But honestly, I just think the std library macros should work this way.
Rust does need a runtime drop flag sometimes tho.
The compiler looks at all the lifetime annotations of the functions that use a buffer and puts the destructor immediately after the last point it's being used. That's the lifetime for the buffer. In general the lifetime annotations correspond to an allocation having a lifetime matching its lexical scope but that's not always the case. The borrow checker works one function at a time but even if it didn't you'd have to solve the halting problem to statically figure out where to put a destructor.
sure. but this isn't precisely the same thing as ref counting though. closer to it then the compile time behavior though.
? works on Optional. I think if you are using a macro like this you dont need additional explicitness in using ?. Its fairly clear, similar to writing assert() or check() in other languages like Kotlin
I think what the question is about precise use cases. Like Java for Webapps, python for data science, what‚Äôs the equivalent of that in Rust.
&gt; That makes more sense when I think about it. Yup! If things were dropped from the inside out, then in your drop method you wouldn't be able to use any of the data inside your structure to perform your drop cleanup. Therefore, things must be dropped from the outside in.
It doesn't work on stable, but it does on nightly. And why is it wrong to have the additional explicitness? Especially when it's only one character? It also work well within Rusty convention: anything that can cause an error return finishes with `?`. Nice library though.
Oh that is a really cool idea! Implement `Try` for booleans! The thing is that you need to find a way to map the error.
Thanks! Ah, so I think I tried looking at Godbolt to see the assembly, but they both looked very similar. I don't think I was compiling with optimizations on though. Is there somewhere I can read more about bounds checking? I was suspecting that it could be due to bounds checking, but I also read that bounds checking was on static arrays and vectors?
This is neat! I have a crappy version of a slightly different take on this for a web-app I built. Basically, instead of defining struct to represent a route, I define a struct to represent a full web-request. Basically you could define what do in your route (an interpolated path, query parameters), but also if it needed a json body, you could define it similar to the query. The last part was that you could define the return type. Then you could just hand the struct to an endpoint processor and it would execute it and get back the result deserialized into the right struct.
Check out [AtomicFloat](https://github.com/rust-dsp/rust-vst/blob/master/src/util/atomic_float.rs) in the vst crate, we're using it for the same purpose.
Problem is I have issues with Float, which is why I went on Rust Decimal
From the [docs](https://docs.rs/petgraph/0.4.13/petgraph/graph/struct.Graph.html): &gt;Graph is parameterized over: &gt; &gt;Associated data N for nodes and E for edges, called weights. The associated data can be of arbitrary type. Currently your playground example doesn't give enough information to let the compiler figure out what the edge type E is. &amp;#x200B; You could try `Graph::&lt;&amp;str, usize&gt;::new();` if your edge is an integer weight.
Looking at the docs N=NodeType and E=EdgeType data types. https://docs.rs/petgraph/0.4.13/petgraph/graph/struct.Graph.html
Replacing `step_by` with a multiplication in the loop compiles to the same as the C one.
For anyone who wants this sort of thing to be better supported in the language and has the skills to work on it, it's being tracked here: [https://github.com/rust-lang/rfcs/issues/1250](https://github.com/rust-lang/rfcs/issues/1250)
I mean you don't need to use it verbatim (although it would work for an `f64`), you can just look at how it's implemented.
Could you wrap it in a mutex or rwlock? I don't know exactly what you're doing or the properties or the decimal type this this might be a bad idea.
It's too simplistic to say there's one area for Rust, or for most languages (with the exception of highly domain specific ones). But if there has to be one, probably "systems programming". Things like Browser engines, game engines, operating systems, software for microcontollers. Or in other words, basically the things C and C++ are used for, that you wouldn't really want to switch to a language like Python. But that doesn't really mean it's exclusive to these things. While Java and Python may offer substantial advantages for Web apps and data science over Rust, such as a better ecosystem, Rust may solidly beat either in those areas for performance (depending on the exact task).
Yea.. Is this Graph&lt;N, E, Ty, Ix&gt; syntax means 4 parameters we need to pass? The Ty and Ix are optional ?
Is this Graph&lt;N, E, Ty, Ix&gt; means 4 parameters we need to pass?
Yes, so only two are needed, the third is implied by new() vs new_undirected() and the 4th is fine to leave as the default u32 unless you graph is huge.
It works on stable
Thanks! I feel like Rust's types and data structures are great for modeling data in a natural way, and I'm happy to use them anywhere they can replace raw strings.
In the settings you can check "always use markdown editor" (I've done this)
Have you checked these? \- [https://learning-rust.github.io/docs/c1.ownership.html](https://learning-rust.github.io/docs/c1.ownership.html) \- [https://learning-rust.github.io/docs/c2.borrowing.html](https://learning-rust.github.io/docs/c2.borrowing.html) \- [https://learning-rust.github.io/docs/c3.lifetimes.html](https://learning-rust.github.io/docs/c3.lifetimes.html) Unfortunately still they are not following rust-2018 edition changes. But can refer [https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/index.html](https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/index.html) about new additions.
A good read, hope they update it soon.
Unfortunately, amateurish programmers may still overestimate their ability to use `unsafe` safely.
You're right about the bottom type; the behavior of the empty loop is due to optimizations performed by LLVM that aren't intended in Rust, which has a stronger type system and safety guarantees than C and C++. In C or C++, they can just write this off as UB. In Rust, it really is supposed to be of the `!` type, but because Rust compiles to LLVM, and LLVM applies optimizations intended for C or C++, there are unresolved issues in that interaction, but which are actively being worked on. The big issue is that the easiest ways to fix it also preclude a number of valid optimizations, which means paying a potentially substantial performance cost.
Rust has never had a gcc backend?
At least according to [this article](https://www.infoq.com/news/2017/11/rust-1.22-released), it was stabilized back in 2017.
If I interpret your question correctly: [https://amethyst.rs/](https://amethyst.rs/) is working on a GUI editor for their engine.
This is a neat idea. It took me until the end of the documentation on [crates.io](https://crates.io) to understand that it‚Äôs only fetching the version number, not downloading the toolchain, though!
is there any showcase / demo / git repo / screenshot / timeline / log to see the progress or maybe contribute ?
Thanks all. So in my experiment, I actually didn't use the optimizer and it looks like both examples implementation use the optimization flag. Without optimizations, it seems like both the array and vector implement bounds checking.
- [Amethyst game engine showcase - 2019 Q1](https://www.reddit.com/r/rust/comments/bhlfuy/amethyst_game_engine_showcase_2019_q1/) - [This week in Amethyst 16 (2019-05-02)](https://amethyst.rs/blog/twia-16/) - [git repo](https://github.com/amethyst/amethyst) - [discord](https://discord.gg/amethyst)
Is there a way to display debug output for a collection with thousands or millions of elements that is actually human-consumable?
Thanks! Looks like the compilerfolk are as amused as I was.
The simplest thing to do would be `Mutex&lt;Decimal&gt;` or `RwLock&lt;Decimal&gt;`, which would work for a lot of applications. A software transactional memory library could work if you have a read-many write-few application, like https://github.com/k3d3/crossbeam-arccell or https://docs.rs/swym/0.1.0-preview/swym/tcell/struct.TCell.html Some targets do support AtomicU128: `aarch64` (besides windows), and [`x86_64-apple-darwin`](https://github.com/rust-lang/rust/blob/9ebf47851a357faa4cd97f4b1dc7835f6376e639/src/librustc_target/spec/x86_64_apple_darwin.rs#L6). Other x86_64 targets don't necessarily have cmpxchg16b, but you can do feature detection like any other `core::arch` intrinsic.
Ok after careful analysis, it seems like indexing into a vector requires much more assembly instruction. Each index does a call to "core::ops::index::IndexMut&lt;I&gt;&gt;::index\_mut", which executes several additional memory operations on the stack. It seems like that was the problem unless I'm missing something?
Thank you for `combine`! It has been a joy to use, and the tutorial and explanations in the [wiki](https://github.com/Marwes/combine/wiki) are excellent.
I would usually just write it like this: let response = await fetch(); let data = await response.json(); To make it more obvious what's happening. But if you have to chain await in a single expression often, it gets ugly, for sure.
Ok, thanks for your comment but I would like to remark that say "its wrong" without any explanation nor saying "how should be done right", will force me to ask you again...what its wrong too. &lt;lol&gt; Now: what should I use to hold money values instead of f32?
Really looking forward to this, i think it will be available in the next nightly: [https://github.com/rust-lang/rust/commit/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94](https://github.com/rust-lang/rust/commit/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94)
Nice, thanks. What about splitting into 2x U64? How would you go about that (to bypass the locks)
Thats unfortunate. I believe you have a great opportunity here. Nevertheless, if you guys change your mind, I'd be more than willing making it a thing and bring in some initial funding.
I can, but as it's millions of concurrent additions it sounds dumb VS 2x U64
Yeah, that's not optimal.
I sincerely hope they don't get go with `expression.await`, it's just as rediculous as `expression::&lt;await&gt;` their turbo await, `expression'await` await is love await is lifetime, `expression"await"` The random string on the end await, or are there any other syntaxes that we can overload? Sorry for my mini rant, but I feel very strongly about this. My personal preference is prefix await with parentheses to denote precidence, but the mandatory braces version is my second. I'd rather not have a weird inconsistent form. If the decision is really this hard, then we should just keep the macro.
I have not programmed async a lot, but, as a learner the postifix notation seems quite confusing, I'd better find a more conservative syntax, even at the price of some more braces / newlines.
&gt; I have searched Rust's good use cases. What I found is that Rust is mainly used for system programming or as an alternative of c and c++. [...] I didn't get any satisfactory answer. The beginning and the end of that quote seem contradictory to me. There is (at least part of) your answer: whenever the use case calls for C or C++, Rust can be considered as an alternative. Platform availability or toolchain constraints may preclude its use, but that has nothing to do with the qualities of the language itself. That's the lower bound, however. Rust's memory and data race safety make it a good fit where one would hesitate to use C or C++, such as publicly available Web services. I wouldn't presume to tell you why you should learn or switch to Rust -- unless it's a job requirement, it's for you to decide -- but I can try the other questions. &gt; What kind of applications should be built in Rust? Command-line utilities are a popular genre, as are all kinds of networked services. The latter category is well covered by all kinds of languages and frameworks, including Java, but (using Java for comparison) with Rust you can get a considerably lower memory footprint and more predictable performance (no GC). High-performance extensions for Ruby/Python/NodeJS are also a good fit. &gt; Are you building something in Rust? Are you converting your c/c++ application in Rust? System-oriented networked services of all descriptions: policy servers, various service proxies, Web API endpoints. This would seem to be the natural domain of Go, but I have to deal with some really old systems which Go doesn't support, but Rust can, with a bit of fiddling. I did rewrite a couple of old and creaky services, but I'm not doing it wholesale. All new development is in Rust. &gt; Why blockchain application needs Rust? It doesn't, but high performance, no runtime, and enhanced safety make it attractive in that domain. Also, don't discount fashion. &gt; Is there any popular application, built on Rust? Define "popular" and "built on" ;) You'll find Rust components in a number of widely used applications. The Firefox browser is a canonical example. The VSCode editoir ships with file search written in Rust. Etc.
Using [`for_each`](https://rust.godbolt.org/z/N7Gx4o) seems a bit better.
Awesome job!
Sorry, it's a well known issue with floats or doubles. They have a specific use and it should never be used for currency. depending on context (which I don't have) you want one of the signed or unsigned integer types or a big decimal library depending exactly on what you are doing. If you are trying to keep track of a something like the amount of money a student has on a lunch card at a middle school, then a u8 or u16 will probably work. If you want to track cash flows in a bank or at a government department, then a big decimal will be the right call. Combined with a currency type and conversion rates (ie, just a number is almost certainly wrong in that context). I lack the context to give better advice. As to why you shouldn't use a float or a double. [https://husobee.github.io/money/float/2016/09/23/never-use-floats-for-currency.html](https://husobee.github.io/money/float/2016/09/23/never-use-floats-for-currency.html) has a decent write up on it, but if you google it you will get a ton of hits on it, it comes up constantly. It's one of those perennial mistakes you will see constantly. Like people asking how to parse html with regex, it's a fundamental mistake.
Try this one, which uses the actix 1.0 beta and integrates with diesel: [https://github.com/valerauko/rucktar](https://github.com/valerauko/rucktar)
The big problem is not the size of the `Decimal` type. It's the semantics. Even if your hardware had support for 128 bit atomics or if `Decimal` was only 64 bits long, you could still not do atomic addition with it. You see, "hardware atomics" don't magically make every operation on them atomic. There are really only a handful of atomic operations on any given CPU. "Increment this 64-bit integer" is usually one of them. "Increment this binary-coded-decimal number with extra flags etc." is not. For types that are not your plain old binary, fixed-size integers that fit in a register, you only get some very minimal instructions, like "compare and exchange" or "compare and swap" (CAS). Using these, you can implement higher-level atomic operations, but it will usually involve running them many times (a "CAS loop") in the case of contention. This takes unbounded time and is often worse than a lock, because your operations may need to be recalculated many times. tl;dr no, it can not work, because your computer only really knows binary. Use locking or message passing instead. Even better, try to localize most of your additions to individual threads and only synchronize when needed.
Rust is not going to copy Cs behaviour in a way that lets you reach undefined behaviour in safe code.
Here's a great explanation: [https://security.stackexchange.com/a/151837](https://security.stackexchange.com/a/151837)
I'm mostly writing micro services as well as web apps, and to me it's awesome because in my approach, everything is compiled down and statically linked into a single binary that has the front end JavaScript compiled via webpack and embedded into the final binary as well. Deployment is simple as copy the binary to the server and run at command line, no docker, no complex devOps etc, it can be easily added into any CI pipeline. Most modern web apps are an bunch of APIs frontend to a database, where all the business logic happens, for that Rust fits perfectly, using enums and pattern matching and many other high level expressive language constructs means writing critical large codebases actually scales. I can refactor with very high confidence, the Haskell idiom of "if it compiles it most probably will just work" seems to apply. It's super easy to even call out other APIs or even have some backend service running on another thread. There are some areas such as say PDF generation which doesn't have many libraries, but that's understandable, it's a young eco-system, and the option to co-opt with another language is always possible.
Slightly off-topic but I always wonder how useful these kind of optimisations are - would a programmer really write a function that happens to always equal zero? Maybe this is a happy combination of other optimisations that are sensible though.
The comment about global ordering confused me, and I'm pretty sure that some of the claims in the Github issues are false &amp;#x200B; This is what I know: &amp;#x200B; 1) Every code that happens after (line order) atomic acquire/read can't go above (line wise) this acquire/read. This doesn't matter if it is a read to a regular variable or to an atomic variable. 2) Every code that happens before (line order) atomic release/write can't go under (line wise) this release/write. Again this doesn't matter if it is a read to a regular variable or to an atomic variable. 3) The extra guarantee SeqCst gives you is that atomic release/write that happens before another atomic acquire/read can't be reordered to be after that atomic acquire/read, even as it is not guaranteed by the first 2 rules above, this rule is not true for writes/reads to a regular variable. &amp;#x200B; Specifically, in the Github issue, it seems to be hinted that in order to ensure synchronization for a variable it must be atomic. This is, of course, wrong, and go against the concept of Mutex or even the Spinlock you have shown. &amp;#x200B; In the first part of Herb talk there are 2 slides which are really relevant for these claims: The first about SeqCst re-ordering around the 42 minutes mark. The second he specifically shows how the atomic variable affects a global non-atomic variable around the 54 minutes mark.
I don't think you can learn Rust without understanding English, since most of the learning material is in English, as well as the source code, the documentation, GitHub and most internet forums about Rust. So why bother translating the *website*? I live in Germany, and I have never met a programmer who doesn't speak English. I checked out several other websites for programming languages, too, and all of them were available only in English. There are several translations of the book *"The Rust Programming Language"* (most of them incomplete or outdated). If you want to help others to learn Rust, [you should start there](https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations).
No, even like 3-20 elements, all small integers. Often I have arrays like that that I end up printing in some loop.
I also have [this](https://github.com/Awpteamoose/amethyst-inspector) so you could say it's kind of a GUI editor.
I think the others replies give a good indication of what type of applications Rust is good for, so I'll mainly focus on why you should learn it and how it's different from Scala. I'm an experienced Scala developer myself and it's my main development language, but I'm also learning Rust because it provides some important advantages: * Predictable performance and low memory usage. This is something the Scala world has struggled with since the beginning, a lot of time has been spent on trying to implement optimizers, value classes and specialization in the Scala compiler and also to tune it to the Hotspot VM, but even today there is going to be a performance hit when using abstractions instead of low level constructs. In Rust you basically don't have to worry about this, everything is optimized as far as possible, iterators are just as fast or faster than a low level loop, data type are as lean as possible (no object headers) etc. * Concurrency. In Rust you can use low level concurrency constructs mixed with mutation with a very high level of confidence. This is just not possible in Scala. * No null pointer exceptions. Yes, Scala has Option etc. but there's still a possibility that a null can sneak into your program from a Java library or elsewhere. * Minimal type system, there are no classes, no inheritance, no singleton objects etc., just ADT's, traits and functions basically. * No GC which gives you full control over data lifetimes and predicatable memory usage Of course, there are some downsides as well: * Less powerful type system, no HKT's, no existentials etc. So more advanced functional programming constructs are hard to express Rust. * The borrow checker will dissallow some perfectly safe mutation/sharing patterns and there is extra ceremony for lifetimes etc., but these things are improving all the time and once you learn what patterns to use it has less impact on your coding experience. * Tooling is not as good, but it's improving * The library ecosystem is not as vast and mature, but that's also improving rapidly * The syntax is a bit clunky sometimes, but on the other hand it's simpler to read and understand than Scala's * No GC :) Well, that's the important differences what I can think of right now. I think Rust is definitely worth learning even just for understanding the ideas and concepts behind it.
If I run this benchmark in "release" mode, I get a runtime of "0" for both, presumably because LLVM removes the entire loop. In "debug" mode I would expect the array to be faster because it doesn't do any initialization and is less complex than the vector.
You can use Godot Engine. There is a plugin to use Rust code in it.
90% of all the API docs? Absolutely not. 90% of the book? Maybe, but probably not.
**"Rust by example"** is a starting point for people who understands concepts through examples. Definitely it will not cover all the API docs content. But Rust Book covers all the fundamentals of rust language with which you construct your base idea for the language and try to solve any code problem with it.
Lifetime parameters are... not about the container. I wish this misconception would die out but it's hard to fight back. What it lets you is "put in" any lifetime you want. Struct has 'a *as an input*. So you can gave `Struct&lt;'static&gt;` if you wanted to. You're wiring some external unknown thing, which you've named 'a, to the reference inside the struct. It's a bit more clear, perhaps, if you never use the same parameter name twice. e.g. `fn foo&lt;'b&gt;(s: Struct&lt;'b&gt;) -&gt; &amp;'b str` that's saying "whatever lifetime the reference inside Struct was, in the caller of `foo`, the resulting reference also gets" So if you called `foo` with a `Struct&lt;'static&gt;`, you get w `&amp;'static str` back. Without these signatures, borrowck would not be able to understand "what just happened" when you called another function (since it can only see the signature). This, btw, is why Rust can still do a more complete check than any of the proposals for C++, as those don't let you talk about `Struct&lt;something that ends up in the type of the reference&gt;`, only `Struct`.
I'm going to contradict the other answers and say that you are \_not\_ looking for specialisation. You're looking for a different, related feature. &amp;#x200B; With specialisation, all types that implement \`Debug\` will also implement \`ToString\`. What you want is that types must manually implement \`ToString\`, but they don't have to manually write out the body of \`to\_string\` unless they want to. If they want to use the default implementation they'd write \`impl ToString for Foo {}\`.
There is no turing machine that can ban concurrency, so you need thread-safety even in many cases where the concurrency/reentrance doesn't come from "threads". Maybe we should be talking about concurrency far more than threads, since "execution threads" may not mean much to anyone (e.g. interrupt handlers are included, not just "OS threads"). Anyway, you should really be just using an `AtomicUsize` `static` with the `Relaxed` ordering. That's, like, 100% safe. Why bother with `static mut`? Hmm, maybe we should lint against `static mut` of types that we know have atomic counterparts.
Yes, type inference would be 'problematic'. Maybe a from boolean to result o Option implementation depending on the actual function return value. That's the reason i'm rather doubtful this ever working.
See https://www.reddit.com/r/rust/comments/bkw00l/why_is_static_mut_bad_to_use/emthudq - unless you force the use of OS features for containment of global state to one OS thread (i.e. TLS), you are forced to deal with *concurrency*, even from non-thread sources. I wish I knew where to document this and stop people from writing UB because they think in terms of "oh I don't have multithreading" and miss the fact that none of this is about (OS-) managed threads!
The link you gave has this to say about "if it compiles, it probably just works" (which is itself a weaker version of "well typed programs don't go wrong" that I've heard a lot in the Haskell community, but they both express the same idea): &gt; Static language advocates seem to me to significantly overstate how much static type checking helps with catching serious bugs. Statements like ‚Äúif it compiles, it probably just works‚Äù seem very foreign. What kind of programming are people who say things like that doing? How often do I make a mistake where I‚Äôm passing the entirely wrong type of value to some function or returning the wrong type of value? Sure, it happens, but not that often and it‚Äôs usually trivial to find such a mistake given even cursory testing during development. (Again, especially in Julia where functions can and do declare argument types.) This is yet another instance of people on the Internet interpreting everything literally. Pithy phrases are never systematically true. At best, they contain a _kernel_ of truth. It's pretty easy to imagine the perspective of someone who's used to writing programs in dynamically typed language and is also simultaneously used to getting type error exceptions raised at runtime, coming to a language like Haskell or Rust, and being amazed at how much the compiler actually checks for you. It's easy to imagine that once you actually get your program running, the compiler has already eliminated a large class of errors. In contrast to a dynamically typed language, there is no compiler to catch anything, so in order to debug that class of errors, you actually need to run the program and test its *behavior*. There are none so zealous as the newly converted, so if the above process is new to someone, it's completely reasonable how they might blurt out, "if it compiles, it probably works." It's not an absolutist statement. It's almost certainly a statement made _relative to prior experiences_. The linked post also doesn't really touch on two other really important advantages to static types: compiler guided refactoring and readability. I personally find it _much_ easier to read code when I know the _type of the data being transformed_. When I read dynamically typed code, I find myself spending a lot of time trying to figure out the _structure of the data being manipulated_ in the program. The best dynamically typed programs I've read are programs that make this clear either via the code itself or through documentation.
Which, unlike c/c++ is infinitely easier to audit for. Besides that, rust rarely has one reaching for unsafe, and even amateurs might not feel the need to use it, which to users of libraries creates tons of useful guarantees
This doesn't explain it though, try adding -fwrapv to the C version and the assembly becomes barely longer
Sometimes you can end up with a lot of constant code after a function has been inlined because it has constant arguments or similar, which can result in functions becoming trivial. In C++ with templates as well you sometimes heavily rely on the optimiser figuring things out too
I'm not sure I like that the language reserves a word like "match" in `foo.match`, what if I'm programming some sort of football league bulletin board and such and I try to use a field named "match" in a struct? Would it fail to compile?
So there's a little bit of a story here: `range.step_by()` is indeed not as simple as it should be. There was an attempt to speed it up: https://github.com/rust-lang/rust/pull/51601 Which resulted in a bug: https://github.com/rust-lang/rust/issues/55985 This optimization got reverted: https://github.com/rust-lang/rust/pull/56049 Currently, `range.step_by()` goes through a lot of range-checked adds and tricky logic, because it has to be generic and safe. It would probably relatively easy to implement your own fast `step_by`, with range checks and candy: https://rust.godbolt.org/z/W0n9Rs
&gt;There is no turing machine that can ban concurrency, Turing machines are not a model of concurrent computing. &gt; so you need thread-safety even in many cases where the concurrency/reentrance doesn't come from "threads". This is both true and not necessarily relevant outside of embedded systems, kernels, and such exotic stuff... &gt; e.g. interrupt handlers ... because pretty much any sane operating system *does not modify userland* asynchronously. *Signal* handlers, not interrupt handlers, may do so in Unix. But signal handlers are opt-in and probably to first thing you'll hear is how they mess with variables and memory access. &gt;Anyway, you should really be just using an `AtomicUsize` `static` with the `Relaxed` ordering. That's actually terrible advice because: - coders who are ignorant of the consequences of data races aren't going to understand the intricacies of relaxing memory ordering. - it *lacks functionality*. In situations where unordered access is safe, atomics make that way harder than would be necessary. In fact, there's no public API for getting a raw pointer unlike other cell types. - and this *does* matter on certain architectures. Did you know Itanium was designed *without hardware support* for the Relaxed ordering? It's true. There are unordered instructions plus Acquire, Release, and SeqCst. But Relaxed and AcqRel can only be implemented using stronger instructions. In short `static mut` is a footgun, and we know it's a footgun, and the compiler at least warns users. `AtomicUsize` is a nerfed footgun that's just barely safe enough that the compiler allows it, but naive programmers *will* hurt themselves with it. For example, turning a struct into a struct of atomic cells will *not* make that struct behave much better as a concurrently shared global. Yes it prevents *undefined* behavior related directly to how the struct is accessed. But *unintended* behavior is still a good way to write a broken program.
Wait, is if !guard_condition { FooErr? } *not* already readable?
Thanks for the feedback, I'll try to make it more clear that it's still `rustup`'s job to download the actual toolchain.
Changing the body of an existing function such that the inferred lifetimes change would introduce a breaking change.
Not so far, I guess. Rust is much harder to write than to read (even more so compared to other languages). To write Rust, you need to understand the fundamental concepts and reason for a lot of Rust design decisions, which are lacking from the ‚ÄúExample‚Äù book.
What helped me most was this short free e-book: [https://www.oreilly.com/programming/free/files/why-rust.pdf](https://www.oreilly.com/programming/free/files/why-rust.pdf) I'll try to summarize from my memory how it clicked for me. Let's say you have a function that trims leading and trailing "x" characters from a string and returns a reference to the trimmed substring. This is how you would write the function: ``` fn trim_x(val: &amp;String) -&gt; &amp;str { val.trim_matches('x') } fn main() { let val: String = "xxhelloxx".to_string(); println!("val is '{}'", val); println!("trimmed is '{}'", trim_x(&amp;val)); } ``` Output: ``` val is 'xxhelloxx' trimmed is 'hello' ``` The function trim_x accepts a reference and returns a reference. If this is valid code, then there are only 2 possibilities where that returned reference could point to: Either it points to static memory (e.g. a constant) or it points to val's memory! If a function accepts a reference and returns a reference, then the two lifetimes must be the same. This is what's actually happening behind the scenes: ``` fn trim_x&lt;'a&gt;(val: &amp;'a String) -&gt; &amp;'a str { val.trim_matches('x') } ``` This defines a lifetime 'a, and then says that "val" and the returned reference must have the same lifetime. However, for ergonomic reasons, as long as Rust can automatically derive the lifetimes, you don't have to write them. This is called "lifetime elision". But what happens when you do this? ``` fn trim_x(val: &amp;String, msg: &amp;String) -&gt; &amp;str { println!("Calling trim_x with message {}", msg); val.trim_matches('x') } ``` Now the function accepts two references and returns a single reference. But does the returned reference point into memory of the first or of the second parameter? Rust can't know! ``` error[E0106]: missing lifetime specifier --&gt; src/main.rs:1:42 | 1 | fn trim_x(val: &amp;String, msg: &amp;String) -&gt; &amp;str { | ^ expected lifetime parameter | = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `val` or `msg` ``` We need to help the compiler a little. ``` fn trim_x&lt;'a&gt;(val: &amp;'a String, msg: &amp;String) -&gt; &amp;'a str { println!("Calling trim_x with message {}", msg); val.trim_matches('x') } ``` Now it works again. You might have noticed that the second parameter does not have a lifetime specifier. It can be elided. The full version would look like this: ``` fn trim_x&lt;'a, 'b&gt;(val: &amp;'a String, msg: &amp;'b String) -&gt; &amp;'a str { println!("Calling trim_x with message {}", msg); val.trim_matches('x') } ``` Hope that helps!
Serde apparently does not like lifetimes. [This discussion](https://users.rust-lang.org/t/serde-lifetimes-conflicts/16270) recommends using an owned type (Vec\&lt;u8\&gt;) or [serde(borrow)].
In C it is also UB to have an infinite loop that doesn't do any I/O. So the compiler is free to assume that any I/O-less loop terminates. I don't know if that plays a role here, but it might.
`#[serde(borrow)]` doesn't seem to help, but I'm surprised it works with the exception of that field considering https://github.com/serde-rs/serde/issues/359.
You could switch from `&amp;'a [Extension&lt;'a&gt;]` to `Vec&lt;Extension&lt;'a&gt;&gt;` to solve the compile error
Some impressive mental gymnastics there.
But when would it? I've only experienced it never breaking since Rust enforces it, so it's hard for me to see when something would break and why.
This doesn't mention Rust or even any server-side GraphQL technologies at all. It seems completely irrelevant to this sub.
It already does not compile because match, like nearly every keyword in Rust, is a non-contextual reserved word: you cannot name anything match, just as you cannot name them type or trait or struct or enum (etc).
I just wanted to thank all of you who responded. I really appreciate it. I guess, Ill just go through the examples. Thank you very much.
Thanks for the replies so far. Didn't know about [serde(borrow)] until know, but as you mentioned, unfortunately it doesn't really help. Switching to Vec is good solution for the short term and I will try it. But in the long run this code needs to work in no_std environments.
Derp, I should've tried it...
Does this do anything that sxiv and feh don't already?
So better read the book and write some code in parallel. Right?
People are using the function on data which lives for a certain scope. If you change the lifetime relationships for functions called in that scope, you potentially introduce dangling references into other peoples' code, or you introduce compile errors into their code. Neither are desirable.
Not really just yet, other than being nicer to use on mac. I do have some ideas for down the line to diverge from what I used to use feh for. Oh that and it's a rust project that beginner rust developers might want to contribute to.
just check the negative comments of JS fans there
iter.step\_by(x) by default calls iter.nth of the underlying iterator, and iter.nth of Range is defined as an O(1) operation, so the step\_by should not be the bottleneck of op's code.
I don't see a single "negative comment of JS fans" there.
I actually would love to see a blogpost or video covering in detail, how to actually use Rust documentation (API or otherwise) effectively. That would include things like discoverability, how to look for alternatives if you're trying to achieve something in addition to other stuff.
In the docs, look at the impl statements for each method. new and new_undirected all take two type params. The others are just the same functions but you pass size counts in the constructor.
My thoughts so far: I am not rewriting Emacs, so I don't think that it counts as "translation". I am writing parser algorithm by looking closely at orgmode parser. It is definitely not a "clean room" implementation too. Combining the two: not clean room impl + and not direct translation either? What it makes `org-rs` then? I am hoping that I can use LGPL since this is technically going to be a library
Since Rust code is always statically linked, I'd be worried that LGPL would still infect any binary I linked it to. It'd be hard in Rust to distribute things such that someone could combine a newer rlib of your code with their binary safely.
Isn't it possible to use a `Mutex&lt;Decimal&gt;`, and then on your threads locally accumulate into some variable (e.g. 1000 additions) and then lock, add to global, and release? It would be "as if" one thread ran for 1000 operations, then the other thread ran for 1000 operations, etc... unless you synchronize in other parts?
Azure Pipelines seems like a sensible option. It's the only CI system that has hosted build agents for Windows, Linux and Mac, as far as I know.
What the linked matrix shows is that if you include GPLv3 work in code that you want to release under the LGPLv3 license, that is "OK: Combination is under GPLv3 [8]". Which means that the combined work is under GPLv3, NOT LGPLv3. ONLY your contributions would be under LGPLv3, not the work as a whole. So that will not do what you want.
But work as a whole is complitely written by me. Using GPLv3 code as inspiration. Can I license it with LGPL to avoid further "infection"?
My attempt just decided it wanted to talk about PHP instead &gt; **Rust is the best language** in terms of speed. You never have to worry that the compiler will break and you never need to write a big parser or bytecode generation. &gt; &gt; Why is PHP? &gt; &gt; Well you don't need JavaScript on your site! But you don't need PHP either; it's very easy for your users to switch, and you can just run a server and have a nice website in no time!
Other than Azure, [Cirrus CI](https://cirrus-ci.org/) offers hosted agents for all three of those OSes. Travis CI technically supports all of them as well, but their Windows offering is not yet mature (for example [builds with secret environment variables just fail to boot](https://travis-ci.community/t/current-known-issues-please-read-this-before-posting-a-new-topic/264)).
hopefully they will add the sleeping bag thing on the map, that would be awesome
You can reach out to the 5 contributors and ask for their permission at the very least I believe
You're actually right. What I want is an **opt-in** implementation of the trait, with the option for a default implementation of the method **only if** the type that opted in also implements `Debug`. That is slightly different than `Specialization`. Do you know if something like this exists?
Any updates?
The only thing you can do is talk to a lawyer. They're the only ones who can give you the correct advice on this matter. If you want to be safe, don't relicense it.
Thank you, this makes more sense!
Sure it did, the old website wasn't really maintained at all either. Minor changes as per needs did get made (like adding new team members or changing some text) but it pretty much stayed in its basic form with no improvement.
To be honest, I did not dive deep into the discussion in that github issue, but there was an issue with the previous formulation of the SeqCst that I fixed.
Thanks for the `swym` shoutout! For types which don't implement `Drop`, like `Decimal`, `swym` will perform about like a seqlock for each individual memory location accessed. If there truly is only 1 global number then an actual `SeqLock` is a better choice.
Uh. Thousands of TCP connections on a single exit node. Ouch. Have you checked how well the exits cope with the load you generate? &amp;#x200B; If you're doing a legitimate pentest - you'll probably have a server to source both TCP and UDP stress tests from. The only benefit I see is to distribute the load against many relays; to reduce the load on each exit and to limit the requests per second per exit, to avoid automatic systems blocking the IP for too much traffic. &amp;#x200B; Distributing the load against many relays is as easy as connecting to the socks service with distinct user:pass tuples (like tor browser does for its first party isolation); but this costs more circuits and places load on more relays. You can reduce that with a single-hop client (tor source patch) as the anonymity doesn't matter here. &amp;#x200B; Theory aside I'd rather you didn't promote any attacks (even for pentesting purposes) over tor.
I've written chimper that hopefully one day will become a full image editor: https://github.com/pedrocr/chimper You may want to have a look at imagepipe: https://github.com/pedrocr/imagepipe/ It abstracts away all the image pipeline so it will allow apps like yours to have support for RAW files and all kinds of other formats without having to care about their specifics and also includes image manipulation operations. Even for a pure viewer having the image automatically rotated is nice.
I always recommend enums over booleans, even in C and C++, simply because a call site reading `foo(true, false)` is just undecipherable. Pattern-matching etc... is just the icing on the cake :)
Since the work is entirely written by you, you can re-license or dual-license it with any license you want. A license binds those who use it, not the copyright holder who issues it.
I'm a big fan of this. Working out what \`true\` or \`false\` means from context can be a recurring papercut.
Could you stick a screenshot in the readme?
The "If it compiles, it works":yness varies from language to language. In Python, you only get syntax checking - very little trust. In Typescript, the lastest build of VSCode does point out some problems, but it's still easy to get runtime errors. In Go, you can still dereference a null pointer real easy. In Rust, the compiler does help you a long way, but your crates can still use unsafe code and you have no guarantees that nothing will panic. Elm is the one language I find where I really do trust the compiler: the concept of a runtime error doesn't exist, and the compiler makes sure to check everything. You can't turn off warnings that would be errors.
Working it out is trivial if you have named parameters: foo(bar=true, baz=false) which does not require redefining true and false for every function
I'm using GitLab CI and building to windows+Linux, but I'm using my own mahcine as a GitLab runner so it was pretty easy to set up dependencies and just give it the right script.
Hi, you can make it work by replacing `&amp;dyn Any` by `Ref&lt;dyn Any&gt;` and `&amp;store_rc.borrow()` by `store_rc.borrow()`. From here it's just my opinion. First of all, you shouldn't need `Rc`, `HashMap&lt;TypeId, RefCell&lt;dyn Any&gt;&gt;` should be enough. With `Default` I don't know if it's really useful. 99% of the time you will do `new_com` and get it to initialize it, no? So why not skip a step and directly add values initialized? But regarding your question with copy/paste multiple trait bound you can use ```rust trait MyNewTrait: Default + 'static {} impl&lt;T: 'static + Default&gt; MyNewTrait for T {} ``` and then `create&lt;C: MyNewTrait&gt;` (just an example). To get a single component, you just have to return a `Ref&lt;ComponentType&gt;`. I'd suggest you to not handle errors like this. And of course I'd suggest you to use an [existing ECS](http://arewegameyet.com/categories/ecs/) (even if I'm making one myself haha).
Great updates for this great game!
In Haskell, this is enabled with [`-XDefaultSignatures`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DefaultSignatures), so it does exist elsewhere. But I don't think there's an equivalent feature flag in Rust.
I checked that with my default `/etc/tor/torrc` configuration, a next 5-10 socket will be connected to another exit node with a different IP address, so generally, the load will be distributed across different nodes. But a user's configurational files might differ from mines. I'll try to do something with connecting through Tor, thanks for the issue.
 - [The Genesis of Generic Germination](https://github.com/rust-lang/rust/pull/53645): The commit message is awesome, but I have no idea exactly how far along this pushes rustc on the road to non-type generic parameters; anyone? - [Suggest using an inclusive range instead of an exclusive range...](https://github.com/rust-lang/rust/pull/60330): Given that inclusive ranges can lead to performance degradation with external loops, the reverse warning when overflow is ruled impossible seems worthwhile; anyone knows if it is doable?
If it counts as a derived work, then see what the GPL says. Then it's either GPL or not. It can't suddenly become some other license (LGPL) unless the GPL says so. Asking the contributors for permission as tristan957 said seems your best option. With permission you can do MIT or LGPL or whatever you manage to agree with the contributors.
I think the crux of the issue would be weather or not your work is a [derived work](https://en.wikipedia.org/wiki/Derivative_work) of Emacs. If it's not (which I believe is the case), then you're free to relicense it however you like. If it is a derivative work, then it must be GPLv3. Other org-mode projects aren't GPL, so it seems like the idea of org-mode itself isn't copywrited. It would mostly depend of if you had copied code between them. A good question to ask yourself is: if a person looked at the two projects, and didn't know anything about org-rs's development, could they prove org-rs wasn't a clean room implementation? Note that because Rust tools are currently limited to static linking, using it as a library in non GPL/LGPL code is a little funky. What dsilverstone said isn't quite true, but anyone linking to org-rs has to provide their users with a way of altering org-rs. In practice, this means that anyone using org-rs needs to give their users the ability to recompile their code, which probably means the code needs to be under some semi-open license. This [stackoverflow post explains](https://stackoverflow.com/questions/10130143/gpl-lgpl-and-static-linking).
Awesome, I've actually already seen your projects, and chimper looks great. I haven't really hit a pain point with image formats or rotation yet, but it's good to know that you've got my back when I do, or if there is any demand for handling this stuff better :)
Up until now I've thought there wasn't any point, coz there's no GUI features, so it would literally just be an image inside a window. But I guess that's information in itself. Maybe I'll save it for once this is implemented. [https://github.com/Davejkane/riv/issues/5](https://github.com/Davejkane/riv/issues/5)
I'm trying to implement a function that will iterate a Vector while giving out all other elements as references. This is what I've written: fn iterate_with_all_others_mut&lt;'a, T&gt;(vec: &amp;'a mut Vec&lt;T&gt;) -&gt; Vec&lt;(&amp;'a mut T, Vec&lt;&amp;'a T&gt;)&gt; { let mut results = Vec::new(); for i in 0..vec.len() { let mut elem = None; let mut others: Vec&lt;&amp;'a T&gt; = Vec::new(); for (j, e) in vec.into_iter().enumerate() { if i == j { elem = Some(e) } else { others.push(e) } } results.push((elem.unwrap(), others)); } results } I get this error: error[E0499]: cannot borrow `*vec` as mutable more than once at a time --&gt; src/main.rs:257:23 | 252 | fn iterate_with_all_others_mut&lt;'a, T&gt;(vec: &amp;'a mut Vec&lt;T&gt;) -&gt; Vec&lt;(&amp;'a mut T, Vec&lt;&amp;'a T&gt;)&gt; { | -- lifetime `'a` defined here ... 256 | let mut others: Vec&lt;&amp;'a T&gt; = Vec::new(); | ---------- type annotation requires that `*vec` is borrowed for `'a` 257 | for (j, e) in vec.into_iter().enumerate() { | ^^^ mutable borrow starts here in previous iteration of loop I'm starting to think that it can't be implemented the way I want to without Rc. Can anyone guide me here?
That quote of the week took me a minute
&gt; Which, unlike c/c++ is infinitely easier to audit for. Definitely no argument there... but one must not assume that switching to Rust will magically fix everything. You still need someone to actually *do* said auditing and, if the amateurish programmer is writing a `--bin` crate, it may go directly into the hands of people who don't know that they *need* to audit for `unsafe`. &gt; Besides that, rust rarely has one reaching for unsafe, and even amateurs might not feel the need to use it, which to users of libraries creates tons of useful guarantees. You underestimate how often the Dunning-Kruger effect kicks in, resulting in "The borrow checker is being a b\*\*\ch. I *know* this is fine, so I'll use `unsafe`" when it's actually triggering undefined behaviour.
A lot of the issues they identify can be solved without language support. See eg [the Rust as a language for high-performance GC implementation](http://users.cecs.anu.edu.au/~steveb/downloads/pdf/rust-ismm-2016.pdf) paper, Y Lin et al 2016; they implement multiple pointer types to track if a raw pointer has had pointer arithmetic applied to it. Also, their error handling issues can be solved by just... using Result, or failure if they wanna be fancy. I'm also confused about why they say &amp;mut *mut usize is a confusing type. It doesn't seem any more confusing to me than size_t*&amp;, the c++ equivalent. It even reads in the right order; mutable reference to a mutable pointer to usize.
&gt; It is important to note that unsafe is not simply a way to compile bad code; most of the type system still functions within unsafe blocks, and invalid programs where types do not match or regular borrow rules are violated are rejected. A lot of Rust intros get this detail wrong, and I was a little surprised to see it covered so clearly. But then @jonhoo is a co-author, so that makes it less surprising :) &gt; However, as we transitioned to finalizing our code and implementing better error handling, we found that it took some effort to remove these unwraps and replace them with match statements or the equivalent. I wish there was some discussion of `?` here. Handling results with a match is definitely tedious, and I wonder if there was some barrier to using `?` in the cases they ran into. Note that `?` works with `Option` as well as `Result` as of 1.22. &gt; When writing our concurrent hashmap, we did not use any other `Ordering` except `Ordering::SeqCst`, in part because the meaning of the different orderings were not clear to us. It is difficult to understand the implications of any particular Ordering, even after reading the documentation. Strongly agree with this. I often refer people to [Herb Sutter's Atomic Weapons talk](https://youtu.be/A8eCGOqgvH4). It's _three hours long_. When I gave a talk about atomics at the Rust NYC meetup, I got a lot of questions about why `SeqCst` isn't the explicit default, and I didn't really know why it wasn't. My best guess was that anyone dipping into atomic orderings is probably doing such low level perf work that it doesn't make much sense to have defaults at all? (My actual best guess is that no one's really gotten around to debating this though.) It might make sense for the docs to take a more opinionated stance based on Sutter's advice: "`SeqCst` is strongly recommended as a default. Under sequential consistency, atomic operations will always happen in an order that's consistent with what you wrote in your code. Under any other ordering, you don't have that guarantee. The exact rules that the less strict orderings enforce are tricky, and different platforms vary widely in how much they'll reorder your code within those rules, which makes testing difficult."
So much C code still just uses int flags 0 vs !0, so at the very least doing: `typedef enum { false = 0, true = !false } bool;` cleans everything right up. Technically an enum, basically a bool. Going further to use domain distinguished names helps further. The namespacing of C++ enums though I think is where things really get killer, and Rust just expands on that with enums being fully tagged unions.
It's pretty feasible. You can provide access to the target directory used when building and the exact command used for the final application build. The build would be depending on using the exact compiler version you used for building. The LGPL doesn't "infect" binaries, it just has expectations on users rights on those binaries. That's independent on static and dynamic linking, just that the second makes the process of replacing the library easier.
Probably some pretty fundamental misunderstandings of iteration and references. While working my way through some exercism exercises I noticed fn main() { let fish = &amp;[1,2,3,4]; fish.iter().any(|f| f % 2 == 0); fish.iter().any(|f| *f % 2 == 0); // fish.iter().any(|f| f == 0); // errors E0277 fish.iter().any(|f| *f == 0); fish.iter().any(|&amp;f| f == 0); // is this dereferencing for me or doing something else? } Can I just clarify - do all of these compile to the same thing? Am I right in thinking that lines 1 and 2 are identical, and the compiler is just doing something convenient for me? Is this deref coercion or something else? I've got to admit this threw me a bit and I'm trying to understand why modulus is fine but an equals check requires explicit dereferencing. I'm guessing it's the std ops but I've gotten pretty lost in the syntax here. Following on from this, and probably highly related, is this right? for &amp;x in fish { let _test : u32 = x; // so x has been dereferenced? println!("{}", x); } for x in fish { let _test : &amp;u32 = x; // so x remains a reference println!("{}", x); } I've got a feeling I've missed some documentation that covers this, so if there is somewhere that covers this in a newbie friendly way would love to get some guidance. Also I've noticed the `iter()`calls for slice and vec say they return an Iter&lt;T&gt;. I'm trying to understand why it doesn't say `Iter&lt;&amp;T&gt;` as that seems more in line with my thinking.
Function parameters are not the only case where additional clarity is helpful, and "redefining true and false for every function" is not at all an accurate characterization of this design principle.
Interesting. I wonder if this would be easier or harder than \`Specialization\`. My guess is it would be easier given that you do not need to deal with conflicting trait implementations during monomorphization. Either the \*\*opt-in\*\* implementor took the default behavior, or it didn't/can't because it doesn't have the right trait bounds.
Oh man, `try-build` looks great! Maybe I can actually get it to work, unlike `compiletest_rs`. Regarding inclusive/exclusive ranges - couldn't we just make 0..256 work (for u8, as an example), instead of recommending 0..=255? Logically, every element of both of those ranges is representable by a u8, and the two ranges should be logically equivalent. I understand why it doesn't work today but it seems like much more of a concession to ease of implementation than a representation of what the final state should be.
So what will this means for `yield` once (if?) generators ever get stabilized. Will it become `yield expr` or `expr.yield`?
[crates.io](https://crates.io) is saying the project is MIT licensed, but the GitHub repository is lacking a license file‚Äîwould you consider adding one to make the project's licensing situation more clear?
https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=336da910d3e66166b189f174a383766f While it may not be quite as convenient of just being able to write `a &amp;&amp; b`, it functions basically the same.
Why? How? I don't understand how this keeps happening.
Oh sure that's better than nothing! I just wanted to underline how it is difficult to make a perfect i18n.
Oh, and `select-rustc` is super useful also! Between these two and that proc-macro-hack update, it's a dtolnay Christmas.
&gt; The Genesis of Generic Germination: The commit message is awesome, but I have no idea exactly how far along this pushes rustc on the road to non-type generic parameters; anyone? https://github.com/rust-lang/rust/issues/44580#issuecomment-488819344
&gt; but then @jonhoo is a co-author, so that makes it less surprising :) Why?
Wow, does `rust` allow you to use syntax like that for call sites?
You can use `SleepingBag` with `parking_lot` while enjoying a `hashbrown`.
It doesn't and is unlikely to allow it. [The closest you could do is](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=52beecfa74efd7cf928213470a9c81cf) foo(S { bar: true, baz: false });
Indeed, relicensing at least requires (unanimous?) agreement of copyright holders. The author's question however seems focused on whether relicensing a derivative work, when the original has a different license, is possible; and that's a different question.
By all means only do it when you feel it's relevant, but I think it really helps attract new developers/users, even if it's super simple. In this case, I was actually a little unsure if `a command line image viewer` didn't actually refer to an ascii image viewer *in* the terminal, and a screenshot would have clarified that quickly.
You may want to check https://opensource.stackexchange.com/. It's a stackexchange site which notably specializes in licensing questions; hopefully they could help you.
I'm working on a CLI that checks the passwords of a KeePass database against a source of breached password hashes, as well as for weak and duplicate passwords. I'm calling it [Medic](https://github.com/sts10/medic/). This week I used [structopt](https://github.com/TeXitoi/structopt) to improve parsing and make it more of functional CLI.
Enums are great and do make for generally more readable and safer code. Oddly, though, the use-case that I've found for bools in Rust is in making using enums more ergonomic. When you are dealing with a large, nested enum, creating helper methods that return bools for whether a specific nested variant is set is useful. For example: enum Organism { Animal(Animal), Bacteria, Plant, } impl Organism { fn is_dog(&amp;self) -&gt; bool { ... } } enum Animal { Dog, Cat, } While this isn't always appropriate, sometimes it's the right thing to do. And you can already see it in the standard library for cases like is_none(), is_some(), is_err(), is_ok().
The copyright holders don't have to relicense their own work. As copyright holders they just need to agree that whatever the OP is doing can be covered by whatever license he proposes (probably something Rust-friendly). Copyright ownership rules all else. The release license is at the whim of the copyright holder. It doesn't matter that they have already released it as GPL. That doesn't bind the OP if the copyright holders agree something else.
This is pretty well known in other lang communities, especially Haskell, as 'boolean blindness'.
Other languages might also hide a third state. Boolean b; b = true; b = false; b = null;
You could make the `bool` implement `Try`, which would require you to be able to map it to a `Result&lt;Ok, Err&gt;` where `Err` and `OK` are well defined types. Because the types are empty-types, the only cost would be the single bit to recognize which type it is, it would be no different than a boolean. struct BoolTrue; struct BoolFalse; impl Try for bool { type Ok = BoolTrue; type Error = BoolFalse; fn into_result(self) -&gt; Result&lt;Self::Ok, Self::Error&gt; { if (self) { ok(BoolTrue) } else { err(BoolFalse) } } fn from_error(v: BoolFalse) -&gt; bool { false } fn from_ok(v: BoolTrue) -&gt; bool { true } } At this point you could do anything like `(x&gt;0)?` and it should "just work". If you want to map the error you just do something like `(x&gt;0).into_result().or(err(new_error))`, if the error is cheap, otherwise you can use `map_err` to convert it to another with a closure, or even `or_else` if you want to attempt a recovery before giving up.
Cool term, I like it!
buildbot 2.x is great for custom CI/CD especially if you want to coordinate multiple machines and artifacts payloads. Monkey patching is great for up time and tweaking in production.
Thanks a bunch. You're changes worked. My next issue is that in the calling function that does get_store(), I have to dereference the Any into My ComponentStore&lt;T&gt;. I'd like get_store() to dereference Any and Return a Ref to the store. Wonder if would be easier to change my store: HashMap&lt; TypeId, Rc&lt; RefCell&lt; Any &gt; &gt; &gt;, to store: HashMap&lt; TypeID, Any &gt; Then in any just put RefCell&lt; ComponentStore&lt;T&gt; &gt; in Place of Any. I think from there I can downcast the Any into an RefCell, then it should be easy to just borrow/borrow_mut the store and using Ref that you mentioned to return the store all ready for use in the caller function. Thats if the borrow checker doesn't yell at me because the Any will be out of scope or something. About the simple component. Not sure how I would go about using Ref. So for example if I have a function like get_com_by_idx::&lt;T&gt;( i )-&gt; Ref&lt;T&gt;{ .. do whatever to get the store let t = store.get( i ) &amp;t } Something like this? how about doing a mutable version? Sorry for so many questions. I've been going through the existing ECS code for a few days now. I dont like most of the API and how to use them. Since I'm porting my WebGL Javascript stuff to rust and I already built an ECS for it, thought trying to recreate that system in rust would give me a good learning experience dealing with the borrow checker and whatnot. So far it feels like a real exercise in learning rust just to get how components are to be handled. Curious how you've implemented your version of ECS.
I was doing exercises on [Exercism](https://exercism.io) and ran into something that I found strange. u64::pow accepts a *self: u64* and a *exp: u32*. It's a little strange that exp is so wide when a u8 will do. If your exponent is greater than 63, the result will either overflow or be equal to self. Even u128 doesn't actually need the exponent to be wider than u8. My question is: "Why does pow expect a u32 when u8 would better describe the set of values of meaningful exponents?"
Thank you
Truncate [1, 2, 3, ...and 737890 more]
Why are you using libwebp instead of the image crate, out of curiosity?
Forgot about that, thanks!
I have no clue about the rust error handling situation. Maybe it's no big deal if the implicit return of `{bool}?` would give a specific error that didn't mesh with the normal function return signature (except if `Result&lt;_, Box&lt;Error&gt;&gt;` i guess), maybe it is. I only know that for this feature to be accepted and not to be called 'over-engineered', the simplest case `{bool}?` must look simple (achieved) and cause little churn. If that churn is impossible to avoid, then make it legible. So i'm iffy about `(x&gt;0).into_result().or(err(new_error))`, and would rather `(x&gt;0).or(ErrorStruc)?`.
I believe most (all?) of the performance issues with inclusive ranges have been solved, so that might not be an issue?
My mistake. I did not catch that. I was focused more on his first paragraph
Let me know if you need anything. I'm usually pretty responsive on GitHub issues and am using #chimper in irc.mozilla.org for chat. I'm not always online but will eventually respond.
Posted a question: https://opensource.stackexchange.com/questions/8285/org-rs-can-i-use-mit-apache2-license
Keeping it under GPL3 means death to the project, since this is a library. Nobody in rust ecosystem will be able to use it
For your convenience, `Rem` on i32 is defined for zero, one or both of the operands being references. So, less the compiler doing something convenient and more the standard library. (In general for operators, neither the left-hand side, the right-hand side nor the return value have to match.) Equality, however, always requires the same type on both sides, which is why you need to dereference `f` to make it compile. The last two lines are roughly equivalent. You're using pattern matching to peel off the reference. It's a bit like how `if let Some(x) = Some(3)` will bind `x` to 3, only here instead of `Option` it's a layer of indirection. Your example with `fish` is correct. Regarding `std::slice::Iter`, while the type parameter is `T`, if you look at [its implementation of the `Iterator`](https://doc.rust-lang.org/std/slice/struct.Iter.html#impl-Iterator) trait, the associated `Item` type is `&amp;'a T`, which is the type returned by `next()`.
I will most certainly ask all 5 contributors ( 4 excluding me), that is not the issue. The question I want to resolve is: can I publish my project under permissive license when orgmode source is GPLv3?
Interesting question! I dug around in the git history of the core library and eventually found [this issue](https://github.com/rust-lang/rust/issues/22240), titled *Audit integer types in the standard library*. It sets forth a bunch of guidelines for the standard library, in particular: &gt;For cases where the acceptable domain of a value perfectly fits a fixed number of bits, use the appropriate fixed-size type. For example, a method like write_u16 would take a u16 argument. &gt;Otherwise, use i32/u32 if the value has a narrow range and i64/u64 otherwise. It also gives an example that's quite similar: &gt;The radix of an integer would use u32. &gt;You might expect u8, since a radix higher than 256 is not useful, but the domain of useful radices is actually much smaller than u8, so using u8 isn't providing a meaningful guarantee, and will simply increase friction.
I am not a lawyer, but I can summarize what I know. Whether a computer program counts as a derivative work according to copyright law is governed by the [Abstraction-Filtration-Comparison test](https://en.wikipedia.org/wiki/Abstraction-Filtration-Comparison_test) (in US law; I can't speak for other jurisdictions). This test works in three steps, the first two of which are applied to each of the programs to do comparison in the third step. 1. First, work up from the lowest level code (the actual source code itself) and then describe higher levels of abstraction that are provided, for instance by organizing the code into blocks, and the functions, and modules, and work your way up ultimately to an abstract description of what the code does. This is the "abstraction" step; you're essentially starting from the lowest level code, and then providing higher and higher level descriptions of the code until you reach a very general specification. 2. Next, filter out elements of the above abstractions that are not copyrightable. Copyright only protects specific creative expressions, not abstract ideas. There are a couple of specific filters mentioned: 1. Any element that is necessary for efficiency; if there is just one optimal way to do something, then performing the task in the optimal way can be seen as a necessary functional requirement. 2. Anything dictated by external factors, such as need to conform with a particular interface or protocol, any elements necessary for operating in the same kind of computing environment, standard programming practices 3. Anything that is taken from the public domain 3. Finally, compare the remaining abstractions after performing the filtration step to see if there is anything left that has been copied, and how substantial and important that is to the work as a whole. After doing this, you can tell if there was anything copied from the original work; there then can be the possibility of checking whether that copying is covered under [fair use](https://en.wikipedia.org/wiki/Fair_use), but you probably don't want to get to that point. So, how would `org-rs` fare under the Abstraction-Filtration-Comparison test? Rather than doing each of the steps separately as specified, I think it will be more efficient to do a quick check at different layers of abstraction. At the lowest level, direct source code comparison, your code very clearly doesn't match that of `org-mode`, being written in entirely different languages. However, even at this level there is some direct copying; you've copied comments directly from `org-mode`, and you've copied lines of `org-mode` code as comments to annotate what you are doing. And at this level, you literally copy function names (modulo different languages namespacing and naming conventions), argument names, and argument order. For example, [`org-rs`](https://github.com/org-rs/org-rs/blob/master/rust/element/src/parser.rs#L123), vs. [`org-mode`](https://code.orgmode.org/bzg/org-mode/src/master/lisp/org-element.el#L4340). Then at the next higher level of abstraction, not comparing literal code but abstractly comparing the functionality of the control flow within the code, your basic code structure within the functions mirrors the original elisp code pretty much exactly; you even cross reference with the exact corresponding lines of elisp. You do make some things more idiomatic Rust, but for a lot of it there's a line-by-line, or block-by-block correspondence to the elisp code. Let's stop there on the abstraction ladder, because it looks like even at the lowest level of abstraction, there's a decent amount copied in the form of comments and naming of elements, and up one level there's a lot shared, and move on to filtration. Are these things that are shared necessary as the most efficient way to achieve a particular goal? That's clearly not true of the comments and names. At one level up, that could be a little harder to say, without coming up with an abstract description of what you are doing. But it's likely that there are other ways that are equally, if not more, efficient that don't mirror the exact structure of the original source in the same way. Then we can ask, is what you're doing necessary for any external reasons, such as interoperability? One of your motivations was to follow the exact same parsing algorithm in order to have better compatibility with the original org-mode parser. But while following the same algorithm could arguably be necessary, matching the names, matching the comments, and having matching code structure block by block almost certainly isn't necessary for compatibility. There are creative elements to those decisions about how exactly to organize the code and name certain variables and functions, which aren't at all necessary for compatibility. Likewise, most of the other external factors don't apply. While conventional coding standards might cause the occasional match between variable names or structure of code, just following conventions would't cause all of the matches that exist. So after applying these abstractions and filtrations, if we compare `org-rs` to the org-mode parser, I think there is still a lot that could be said to have been copied from the org-mode parser. If you want something that wouldn't stand the risk of that, rather than copying line by line, you'd need to do something to abstract all the way up to a pretty generic description of the functionality needed. It could even be a description of the same algorithm, but one that doesn't take any creative elements from the original code, and simply describes the overall algorithm; maybe something like the [HTML parsing algorithm](https://html.spec.whatwg.org/multipage/parsing.html), or may something even a little more vague but with a large number of test cases that you write yourself, and then implement the same thing in Rust from scratch. As it is, I think there's a pretty strong case to be made that you have created a derivative work of the org-mode parser, and it might take a start-over from scratch if you wanted to not have to worry about this. Now, that's not the end of the story. The org-mode code is copyright the Free Software Foundation. They own the copyright, so they get to decide how it's licensed. You could write to them for permission to release your parser under a more permissive license. They provide the LGPL for a reason, because they think that in some cases, a more permissive license is helpful to the Free Software cause by allowing some pieces of Free Software to become more ubiquitous. Since this is just an org-mode parser, and not a full implementation of org-mode, it could be argued that this would help the org-mode format be more widely adopted.
At the networking level it will be many small buffers. Whether you need a protocol depends on circumstances.
If I properly understand what you're trying to do, it's impossible to do in Rust since you're handing out both mutable and immutable references to elements at the same time. E.g. if you had \`let mut foo = vec!\[a, b, c\]\` and called \`iterator\_with\_all\_others\_mut(&amp;mut foo)\`, it would return (approximately) \`vec!\[(&amp;mut a, vec!\[&amp;b, &amp;c\]), (&amp;mut b, vec!\[&amp;a, &amp;c\]), (&amp;mut c, vec!\[&amp;a, &amp;b\])\]\`, when it's undefined behaviour to have both \`&amp;mut a\` and \`&amp;a\` at the same time. &amp;#x200B; (You also have a problem that you're consuming \`vec\` with \`into\_iter()\` inside of a \`for\` loop; using \`iter\_mut()\` would probably result in \*fewer\* errors.) &amp;#x200B; I don't know if there's any nice way to do what you're trying in Rust without resorting to bare pointers and \`unsafe\`, since you're running counter to Rust's goals. \`Rc\` alone won't cut it, since the contents of an \`Rc\` are immutable. You'd need another type to add interior mutability, like \`Refcell\`, and all the elements in the 'immutable' vec would have to be wrapped similarly. &amp;#x200B; My next thought was if you could instead make a type that implements \`Iterator\` which would give you the view that you're looking for, but there's no way that I'm aware of to force the lifetime of values yielded by the iterator to be strictly shorter than that of the iterator itself. &amp;#x200B; You might be able to make a pseudo-iterator type that has a \`next\` method but doesn't implement the \`Iterator\` trait which only allows mutable access to one element at a time by having the \`next\`.
Using Enums can also be missleading. You can feel confident all the cases have been handled and fail to see that they have been handled properly because of a '_' case.
I was pretty unhappy with the `impl` keyword being in both parameter and return type positions. That's the biggest thing. I also didn't like how the website was handled, but that's not a language design choice per-say (though evident of a slip-up in community processes).
I made a [playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=308ca372ab13fdb3ecec6f4a3702895d) with the changes to `Components` and `get_store` and I added `get_store_mut`, `get_com_by_idx` and `get_com_mut_by_idx`.
Then your only options are consult with a lawyer on if "inspiration" means you have to GPL it since you're not actually using any code?, or ask everyone who worked on the original for permission to relicense it.
We used to run buildbot; one issue is that you have to run it yourself. Monkey patching is great for custom tweaks, but custom tweaks are also a maintenance burden.
Using booleans anywhere is a real code smell - what if you [need the definition of a Boolean to change?](https://thedailywtf.com/articles/What_Is_Truth_0x3f_)
First of all - thanks for such a detailed reply! Let me comment on particular statements: - I decided copy program structure on block-by-block level in order to get the same correct implementation. Org's syntax is very complex - it is a context-dependent grammar. Without a formal grammar definition (which does not exist) implementing a correct algorithm without using the original source code is almost impossible. - I decided to use lookalike function and variable names for ease of navigation between the two codebases, while in active development. I can easily rename/obfuscate them if that will make a difference. Same goes for comments. &gt; Are these things that are shared necessary as the most efficient way to achieve a particular goal? I believe that given the complexity of the grammar this is the *only* way to implement a fully-functioning algorithm. &gt; The org-mode code is copyright the Free Software Foundation. They own the copyright, so they get to decide how it's licensed. You could write to them for permission to release your parser under a more permissive license. I did this today too. I'm waiting for their reply. &gt; Since this is just an org-mode parser, and not a full implementation of org-mode, it could be argued that this would help the org-mode format be more widely adopted. This is exactly the goal. I want Org to be more widely adopted. But releasing a rust library under GPLv3 will cripple the adoption right out of the gate, which defeats the whole purpose of this project. I don't want to waste my time on something that nobody will be able to use.
RE: having an enum but not then being able to make functions tied to one specific variant, I like \`syn\`'s solution to this where you make a struct for each enum variant. It is boilerplatey and can be annoying, but it does totally solve the problem you mentioned: e.g. [https://docs.rs/syn/0.15.34/syn/enum.Expr.html#variants](https://docs.rs/syn/0.15.34/syn/enum.Expr.html#variants)
And now you have an AUR package [https://aur.archlinux.org/packages/rust-latest-git/](https://aur.archlinux.org/packages/rust-latest-git/) \^\_\^
&gt; Equality, however, always requires the same type on both sides, which is why you need to dereference f to make it compile. It should be noted that dereferencing is not always viable, so you can just stick a reference in front of the other side: `f == &amp;0`
did you consider this? `impl&lt;T: Debug&gt; ToString for T {`
I wouldn't say it's a maintenance burden in that you can fix bugs and add features yourself without down time. Also when you work on projects that can't be fully public or in one location that's not an issue. If you just have a small project that only runs over a LAN for a couple of builds without deployment or CDN you might be better off with gitlab CI.
Who are the copyright holders? If you all transferred copyright to the FSF, then FSF is the copyright holder and the FSF decides. If you all retain copyright to your own contributed code, then it doesn't matter about the GPL at all if all contributors agree to give you a license to produce a derivative work of their copyright works (probably under certain specific conditions). This is a form of dual-licensing. How watertight and legally-sound you want it depends on you. I've given E-mail permission to people to use some of my work outside of the published licenses and they seem happy enough that that means that I won't sue them for doing what they're doing. It's not a formal license, but I'm the copyright holder so what I say goes regarding my work. So perhaps receiving E-mail permission would be enough to defend yourself should it come to that, or perhaps not -- I don't know. Anyway hopefully you'll get some more opinions on the stackexchange forum.
Here's the slides from the presentation I gave, for anyone interested. Thanks to everyone who showed up!
&gt; Who are the copyright holders? I think that's _the_ question. It sounds like the OP read the Emacs org parser code, and used that as inspiration to produce their own parser. AIUI, this is a legal grey area, but I think the conservative interpretation is to assume that this is a derivative work and thus subject to the terms of the Emacs org parser license. At least, this is why "clean room implementation" is even a thing in the first place. (The process I've heard described is for someone to read the "infected" code, and then create a specification. And then someone _else_ who hasn't read code creates an implementation from the specification. But that's a lot of work.)
&gt;Given that inclusive ranges can lead to performance degradation with external loops, the reverse warning when overflow is ruled impossible seems worthwhile; anyone knows if it is doable? If overflow is ruled impossible, I think it is a performance bug if there is performance degradation.
I think it's warning you about the `*self` part, not the last line.
Or [FileNotFound](http://thedailywtf.com/articles/What_Is_Truth_0x3f_).
Or a 4th state... looking at you JavaScript T_T ```ts let b: boolean; b = true; b = false; b = null; b = undefined; ```
Status Reports like these are really important. It gives community a channel of communication and infos about what is happening about Rust and where it's leading to, and why that. It involves the community in the process. Thanks for the update! It makes the community even more integrated and motivated to improve Rust as a whole.
Do you know how much of the performance difference vs. Pathfinder when rendering the tiger is having a special shader for strokes? It's not clear to me how much of the difference is using the hardware rasterizer/blending vs. just rendering strokes directly instead of converting them to fills. I believe, essentially, that after the tiling stage (which Pathfinder could eventually do on GPU as well, optionally) what you're doing is performing fragment scheduling manually using compute shader and taking advantage of the fact that you can schedule all fragments local to a tile together in the same workgroup. That way, you can use workgroup-local memory for blending and keep your ROP load down. It's interesting to note that what you're doing is very similar to what mobile GPUs using tiled rendering already do in hardware. To that end, I've thought about using [pixel local storage](https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_shader_pixel_local_storage.txt) to store the current area coverage value and color value side-by-side and updating the color value "just in time" as overlapping paths are rasterized. On mobile GPUs, this would potentially provide the same memory benefit as using local memory, but using the rasterization pipeline instead of compute. Of course, it's just a theory, and I've heard that pixel-local storage has performance issues on some hardware‚Ä¶
Yes, I have been meaning to swap out all of my tuple structs with regular structs for a while now. May be a good excuse to finally learn how macros work. That crate is pretty neat! I'm using LALRPOP right now as a parser but it's getting to be a little too heavyweight for what I need so I've been looking into alternatives.
Oh wow, yes, thanks! I *was* going a bit crazy---oops!
I'm trying to implement Dijkstra's shortest path algorithm. The code is a little too long to paste here easily so I'll try to explain my question, hopefully it's clear enough. I need a collection where I can quickly get the minimum of the collection each iteration of the algorithm's loop, because each iteration I need to know what node to visit next. However I also need to quickly get an arbitrary item in this collection, because I need to get all the adjacent nodes from the current node I'm visiting. The kicker is that I also need to be able to modify both of those items, because I need to update the current node once it's visited and the adjacent nodes in case I have a new path to those nodes. So I need a collection that acts as both a `HashMap` and a `BinaryHeap`, and I need to trick the borrow checker into letting me mutate elements from it at will. I'm having trouble coming up with a solution that doesn't make me use `RefCell`s and `Rc`s because right now I'm not So advanced with Rust that I am comfortable using those (I want the compiler to help me!).
Null and undefined are technically distinct types in javascript, not valid values for booleans. You can even avoid this issue with Typescript.
Are enums with 2 plain variants zero cost i.e. compile to bool ?
Wow, thank you! Just curious, does that get updated automatically when I publish a new version?
I actually wrote (as far as I know) a js tool in Rust which as no real js equivalent: atlas-coverage Github: https://github.com/samsieber/atlas-coverage I'm also very greater that stuff like swc exists - I have tool to be open-sourced soom for personal code coevrage tag relies on it for code analysis, and it means I don't have to dish out to node for that analysis. So all in all, I think it's sustainable.
I did a quick test of just the fills, no strokes, in the tiger image, and got 2.32ms GPU (as reported by the shader profiler in Xcode), with PF reporting 3.6ms CPU / 1.6ms GPU. I don't consider this at all scientific, as I'm not sure exactly what these are measuring. As I continue to say, it's an important project to measure all this stuff. But I think it's reasonable conclude that using a shader for strokes helps a lot but doesn't explain everything. If I was only compositing objects to the frame-buffer, I would agree, the difference between doing hardware blend and manually scheduling it in compute is not really compelling. But I think things are a bit different when you're doing various more sophisticated blends, including antialiased clip paths. If we end up using ideas from this to do GPU-side tile generation in PathFinder, I would be very happy!
Actually, type of null is object &gt;:D
Isn't that just a "bug" in the typeof operator that has been kept for compatibility? It's clearly not an object since you can't assign any fields to it, and it's treated distinctly by ===.
Yeah, GPU-side tile generation is probably going to need to happen at some point if Pathfinder grows in mobile/VR, as some of those handsets/headsets have pretty underpowered CPUs. (Actually, even just doing the clipping on GPU would help quite a bit‚Ä¶)
Just want to note that you will have extra padding for each struct then
imo, a mistake was made when the operators were even considered. Python style range(start,end) and range(start,end, step) and and irange variant. Oh well, still better than c++.
Is there some compiler flags to make Rust have more undefined behavior like C? e.g. signed integer overflow
Yes, but my point is they dont have a "type" belonging to them that can actually be detected as a type.
Yep, and this also allows you to do things like organisms.iter().any(Organism::is_dog)
Fucking finally!
Yep!
Apologies for resurrecting a 2 month old thread, but I'm curious how this is progressing. Is there anywhere I can follow progress?
I swear, that one stupid little article is the most cited, most influential thing to come out of daily wtf...
&gt;Why blockchain application needs Rust? As others have answered the other questions and since I am currently writing a [full fledged blockchain protocol](https://github.com/purpleprotocol/purple) in Rust I am going to answer this. Bitcoin was written in C++, because at that moment C++ was the most mature and performant programming language that was out there and blockchains **truly** need every ounce of performance available. So to answer your question, it is because if you deploy a blockchain system and you have **a single bug** in the software the consequences are quite catastrophic. For example, the Ethereum DAO hack in 2016, which was because of a bug, resulted in losses over **11 million dollars.** Rust doesn't prevent all bugs, but it prevents all of the common ones, while providing a performance that is comparable to that of C++. I can tell you that I am counting my blessings that I do not have to implement Purple in C++.
Well, that's where aptly named functions/variables helps. Poorly named enum values/names has the same problem.
Might be even cheaper? I think bool is guaranteed to be a byte and I don't think niche filling applies
Modern C has "true" bools, over which your fake bool enum has no advantage. I'm fan of "real" enums as described by the article though, and yes it is better with C++ scoped enums and Rust enums.
The inconsistency with field/method access irks me, partially because it puts a little bit of a burden on editing in an environment that supports syntax highlighting (probably a safe assumption, but still...), but the reasonings conveyed are thorough, and I agree that I can‚Äôt really think of a good alternative and this seems to be the least likely to result in illegible code. Probably an inconsistency that is worth the cost. I appreciate the write up explanation a lot!
Isn't it the job of tooling to display the function's parameter names/documentation as you type, though?
The image crate doesn't have an encoder for the webp format unfortunately. I'm trying to generate thumbnails for an app that has a lot of images, so the promise of smaller files than jpeg was attractive. Right now I fixed the qsort and bsearch issue but the problems persists (the error is now too much recursion or stack frame overflow) and lossless encoding or transparency freezes the website which is better than immediately failing. A pure Rust version would be nice.
[https://rust.godbolt.org/z/5CKfWg](https://rust.godbolt.org/z/5CKfWg) \`\`\`rust pub fn bongo(num: i64) -&gt; i64 { let mut a = 0; let mut i = 0; for x in 0..num { i += 2; if (i % 2) != 0 { a += x } } a } \`\`\` if you don't use step\_by(2). It gives the exact same result as C.
That makes a lot of assumptions as to what tools people are using. Having code that is easy to read at a glance with or without tools is still beneficial. Having fancy tools does make life a lot better though.
I think that prefix keyword with postfix macro was dismissed with pretty weak reasoning (await can't be a macro but somehow it can be a field???). It seems like they were tunnel-visioning on getting await out there as fast as possible but neglecting to consider the implications for the rest of the language. That's not to say that async/await should be delayed until a perfect solution is found (which probably doesn't exist anyway), or even that the current solution isn't the best one, but I'd rather focus on doing things correctly now and making it nice to use later in a way that is consistent with how the rest of the language works. For reference, postfix field: let simple = future.await; let more_complex = future().await?.another_future().await.do_something(); // If the syntax is extended to work with match: some_variable.match { // ... }; vs prefix keyword with postfix macros: let simple = await future; // x.await!() is the same as await!(x) which expands to `(await x)` let more_complex = future().await!()?.another_future().await!().do_something(); // If a postfix 'match' macro is created some_variable.match! { // ... }; // Examples with other macros: output.write!("{}", 5); 4.assert_eq!(2 + 2);
&gt; Having code that is easy to read at a glance with or without tools is still beneficial. It is, but defining custom enums all the time might get a bit cumbersome, I guess...
A bug that the creator refuses to fix becomes a 'feature'.
May solve the first issue (call site confusion), but still makes promoting a boolean to an enum non-trivial in many cases. &gt;"There are only two cases..." &gt; Thousands of lines of code later &gt;"There is now a third case..."
I guess worst case they simply remove .await in an edition again
It's not a field, it's a keyword
That's the problem. It looks like a field access but it's not. But .await() and .await!() were dismissed because they looked like a method call and a weird macro invocation (respectively), which they're not.
&gt; I find it amusing that the word for packing a data structure into a byte buffer is ‚Äúserialization‚Äù even when it‚Äôs designed to be accessed in parallel. Maybe we should come up with a better term, as ‚Äúparallel-friendly serialization‚Äù is an oxymoron. It's amusing, but I wouldn't call it ironic. You're converting structured data into a flat, ordered sequence of integers. (Usually bytes, but not always. For example, the Unicode variants of the Win32 API functions use sequences of 16-bit UTF-16 code units). The "serial" in "serialization" refers to how you're converting to a linear form where the ordering is significant and all entries in the sequence are of the same data type.
As I understood it, the argument was that with await being a keyword, field-access-like syntax would not be misunderstood or interpreted as a field access. Whereas if it used a macro-like syntax, someone could easily think "oh, this is a macro" when it really isn't, and macros can't do what await can do.
If `x.await` would've been parsed as a field yesterday (apart from its reserved status) but today it is a keyword, then there's zero reason that `x.await!()` couldn't be declared a keyword by the same reasoning. Postfix keywords were invented by fiat; they could've just as easily declared them to use macro syntax rather than field syntax.
No one thinks this about println! though. I don't think it has ever mattered.
There are plenty of built in macros that user defined code can't do. What makes `await` special besides wanting to move *away* from the system that does let it get defined in user code?
Oh i know, thats a particular problem of mine as well. Every other site prominetly has the words "programming language" on it, telling you what it is. But not Rust. It's hidden in the (long) title no one ever looks at.
&gt;await can't be a macro but somehow it can be a field??? You're missing one extra step to this argument. Await can't be a macro *or* a field, but it's more obvious that it's not a field than it is that it's not a macro. Even a beginner can see that "future.await" is separate from field access, but it's a lot harder to see that "future.await!()" is separate from a macro. That being said, I think it would be even better if there was more distinguishing it from field access.
Neat
Added a proof that null isn't an object type in an edit.
upon further inspection, it can't be a field access. That doesn't make sense, how would accessing a field on a future resolve the future instantly? plus it's highlighted differently. and it's a very well-known reserved word, "await". so it's a keyword.
That almost certainly depends upon _why_ you can't use cargo. Can you explain some details of your use case?
I get the impression like some language breaking syntax like this might have made sense in 2014, but making such a dramatic departure from established syntax is definitely irksome. I honestly would have rather written (await foo())? forever than have to reconcile future bug reports involving misunderstandings about this magic "method" on objects that doesn't use call syntax and consumes a future.
Finally! Now people just need to stop bikeshedding long enough for it to stabilize.
Wait, rust the game has await syntax and const generics? I remember it was a survival game last time I checked... (/s)
One issue I've run into repeatedly when trying to make 2d games is that I have no idea how modern graphics work. It feels like things have gotten more and more complicated over time, now that pipelines are totally programmable and immediate mode is deprecated. I understand there are many good reasons for the trend in this direction, but as someone who basically just wants to draw sprites on the screen, trying to make my own engine or even use a modern engine can be really frustrating. (but I might be the only one.) It seems like, from reading your original post, that you will build a game on top of piet? I really hope piet becomes a viable option in that space :) thanks for you work!
Given `await` in isolation, I strongly prefer a postfix macro. As the lang team pointed out, this sort of syntax may be expanded to other control flow operators as well, such as `match`. In order to be as general as possible, I think it's sensible that a postfix "field access" is the action that is taken.
That was actually the plan then, but I have different ideas now, it's going to be a font editor. I'll have more to say soon, but it's official. Either way, I'm excited about the opportunity to build out next-gen UI infrastructure in Rust. And I totally understand where you're coming from about GPU programming seeming arcane. A *very* explicit goal of this work is to make it not just easy to program, but where you can focus on how you want it to look rather than what renders efficiently. And figuring that out across the diversity of graphics APIs and devices is hard even for experienced graphics programmers.
That's definitely a fair point. I'm concerned about that as well. The idea of taking an action with side effects with no call syntax could definitely lead to some confusion. I think it's hard to know the right decision here. I hope that nightly will serve as a way to test how confusing it ends up being for people and may surface better alternatives or reasons to take another approach. I don't have any good ideas, though. Unless maybe triple dots or something like that could be used - `my_async_of_result_call()...?` for `Future&lt;Result&lt;T, E&gt;&gt;` and `my_result_of_async_call()?...` for `Result&lt;Future&lt;T&gt;, E&gt;` But, that has a lot of issues because then you end up with method chaining that has 4 dots, or potentially more if you for some reason had `Future&lt;Future&lt;T&gt;&gt;`: `my_async_call()....field_a`. Eh, that starts to get ugly and hard to read :/
`println!()` technically _could_ be implemented using procedural macros though, right? I get that in this case `println!()` is not, but I would put a varargs printing function which does argument checking is totally in the realm of macro possibilities.
Note that boolean blindness even applies to using enum 'flags'. Some would say a better approach is package together 'evidence' along with your data, for example inside an option type, because it constrains implementations even more. https://web.archive.org/web/20181211124726/https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
Recently published: [https://crates.io/crates/tokio-i3ipc](https://crates.io/crates/tokio-i3ipc), and wrote a blog post about my experience using tokio [https://leshow.github.io/post/impl\_proto\_tokio/](https://leshow.github.io/post/impl_proto_tokio/). I'll likely do an update when it comes time to move the code to async/await.
i doubt it. people are going to forget about this tempestuous discourse within a week of .await landing on stable, because they'll update their code to use the incredible new high-performance async primitives, use the new syntax for two hours, and forget that any other options were even possible. this is a process that happens with every UX change in every major piece of software. and, to be clear, i'm happy with this. the lang-team &amp; larger community have been working on the semantics of futures for years, and they've come to a pretty nice final design. .await is a little weird, but rust has plenty of weird syntactic features, and people cope with those fine. i'm irritated by the periodic breakdowns the Rust community has, where everyone freaks out about minor syntactic changes and accuses whatever team suggested them of being tyrannical dictators. it's the definition of bikeshedding, and i suspect it contributes to burnout on the governance team - having a big community that largely ignores you, only stopping to shout at you whenever the community rage roulette wheel lands on one of your syntactic changes.
Well, to me it seemed that people cared enough about the old site to contribute translations and code examples. The new site doesn't seem to be getting the same amount of love. At least, not from where I'm standing.
For the ones that like prefix better: https://crates.io/crates/await_macros
`panic!()` *is* defined in the language. It uses `#[allow_internal_unstable(..)]` to call the compiler internals where needed. A better example would be `asm!(...)`. This is a syntax-extension that lowers to its own [special node](https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/enum.ExprKind.html#variant.InlineAsm) `ast::ExprKind::InlineAsm`. However, the syntax itself is parsed as a macro invocation. Unlike `asm!(..)`, the syntax `f.await!()` *cannot* be implemented as a macro invocation in the parser because to do so would mean that `await` can no longer remain a keyword. We want to retain future design freedom and so we will not unreserve the keyword. The end result is that `f.await!()` might superficially look like a macro invocation but the only common code-path it would have with macros in the compiler would be in parsing the literal tokens `[".", "await", "!", "(", ")]` and nothing more.
It‚Äôs sets precedent for the language reserving property names too. Does anyone know if this would break existing code which used await as a property name?
https://github.com/rust-lang/www.rust-lang.org/issues/612 This seems like a deliberate choice by the developers in charge. They are not interested in fixing what they control nor are they willing to allow others to fix it.
I really am disappointed with the reasons given for this proposal. * The language spec being guided by the specifics of a compiler implementation is a very strange approach to language design. Whether or not `async` could be implemented via user macros isn't material, nor is its resemblance to other compiler built-ins. * Adding yet another quirk that is out of alignment with other language quirks should be avoided unless there are alternatives. In this case there are several viable alternatives. * Postfix keywords don't seem like a particularly reusable concept. `yield`, `return`, and `box` could probably also be used this way, but I can't imagine that would be very easy to read. Their `match` example is pretty hideous; you can see that there's a control block and then must scan around for what operation it might be performing. How far are we from `.if`? * Even if the postfix keyword of `await` is retained, it isn't easy to see why they wouldn't also include the prefix keyword. While there's been lots of discussion regarding the relative binding strengths of `await` and `?`, it is hard to imagine that the debate was so intractable that the prefix await keyword needed to be abandoned. * A lot of the arguments in the blog post are predicated on the idea that `await` is relevant for flow control. While this is true from the perspective of the implementer of `await`, a user of `await` actually doesn't see explicit changes to control flow. The whole point of the keyword is that it hides all of the control flow associated with the underlying callback state machine. I fear that their huge volume of knowledge about the implementation details of `await` is causing them to leak some abstractions. Language features like coroutines and macros are powerful, and in general I feel that powerful things should be obvious to the readers of code.
&gt; and macros can't do what await can do. Isn't this just a technicality? Why is it so important to not let people mistakenly believe that macros can do what await can do?
It is not a safe assumption for diffs. Many places have diffs without syntax highlighting.
&gt; it's the definition of bikeshedding, and i suspect it contributes to burnout on the governance team I suppose it's part of the job and what every team member signed on to, but the worst effect is in my view that it takes away an enormous amount of time that I, and my fellow colleagues, could have used to design and implement (in particular!) the features that people desire. Some people may think we don't read everything and don't listen, but we do. I personally have read every single comment about the await syntax on every reddit thread, GitHub issue, and internals thread. It's a lot of content to process.
This is very exciting. I, for one, am happy with this design - it seems balanced and the best alternative with the least downsides. Trying to think something to build to test this out.
I haven't checked, but I believe you are right. It might be that the macro might need to access some unstable paths but we have mechanisms for that for `macro_rules!` as well. The only reason no one has tried is because "meh". There are so many other issues that need fixing so it hasn't been high priority. Might be good to give it a try to shave of some technical debt.
@johnhoo is the guy who does instructional Rust live coding streams on YouTube.
In the end, I think a more straightforward reason that `await` shouln't be written as `f.await!()` is that `f.await` is simply more ergonomic. This is in particular seen when you write `f.await!()?` as compared to `f.await?`. Which one looks more like sigil soup to you? Which one reads quicker and easier?
You can't think of a good alternative? `await { foo() }` is too tough to imagine?
The `await` keyword is reserved in the 2018 edition and cannot be used as a field name in `struct` definition. So no code can break as a result of this.
&gt;bikeshedding imho consistency is not bikeshedding
What are you using to pack the JS into the binary? Just include!() ?
Yes, \*today\* you can implement println. But for years you could not. Suddenly, overnight, you could. Did anyone notice or care?
I really like your points about conflating await with control flow from the coder's perspective.
In other words, both await and panic can't be defined in user code because they lower (or *used* to lower to) unstable internals. If those internals were exposed (which in the case of await, *they still are*) then there would be nothing in the way of a user implementation.
Do you know if there is a language out there that has most of its operations implemented in a field access style? `let value = 42` `value.if(|x| x % 2 ==0).then(execute()).else(execute'())` After writing it down here it seems rather tedius to write but it reminds me a bit of expression based languages.
\&gt; but it's more obvious that it's not a field than it is that it's not a macro. Why does that matter? Why is that even desirable? "This is more obviously inconsistent" is an interesting argument but I don't buy it. &amp;#x200B; \&gt; Even a beginner can see that "future.await" is separate from field acces I guarantee beginners will not see this. I teach people rust a fair amount, there is \*no way\* this will be something people just 'get'. Especially newer programmers. &amp;#x200B; \&gt; but it's a lot harder to see that "future.await!()" is separate from a macro. Cool, that's fine. Rust introduces you to macros before you write your first line of code - it's literally the first line of a default project. And no one cares, most rust devs probably never implement a macro or anything more complex than basic symbol manipulation. They'll see "oh it's a macro, and it must do something to await". I remember, when first learning rust, I went to a meetup. Niko explained the borrowchecker. I asked about how prinltn! interacts with it and he sort of laughed and said "There's some magic there" and I was like "oh ok cool" and I moved on. Macros being magic is something you pick up early.
We (or at least I) am speaking up against things I find bad because even if I don't primarily use them, I might end up having to decipher other peoples code. My strategy for the weirdnesses of Rust is to not use them. But I still feel I should at least speak up to avoid that group of things becoming larger. So can we maybe stop it with the ever-more-aggressive responses to criticism? Rust is good because the design is criticised, not despite of it.
\&gt; could have used to design and implement (in particular!) the features that people desire. Rust is going to (hopefully) outlive all of us. I think a lot of the discussion is because people are invested in rust in the long term. I think that' s a good thing.
But if someone were new to Rust, they could confuse `.await()` or `.await!()` for a method/macro call. `.await` is much harder to confuse because the situations you use it in are different from the situations you use field access in, so anyone who has a cursory understanding of the code can tell the difference. From the post: &gt;There is also the fact that a user who knows anything about the semantics of the await operator will quickly realize that its not possible that await is *actually* a field access. In contrast, you need to know a lot about the semantics of Rust to understand that await cannot be implemented as either a method or a macro. That is to say, a user who is initially confused about the relationship between this construct and field accesses will come more quickly to understand that this is a built-in construct different from field access than they would be if we used methods or macros.
Not really. &gt; It's clearly not an object since it doesn't have a prototype You can have other prototype-less objects too, like created via `Object.create(null)`. &gt; you can't assign any fields to it Just like you can't to frozen objects.
`await!()` is a lot easier to spot in code, specifically when there's no highlighting, like in `git diff`. I feel reading ergonomics always trump writing ergonomics.
100% agree. You spend 10% writing code, 90% reading it. This "not a field, but *looks* like a field" implementation is jarring.
Why is `await` even necessary (most of the time)? Why not make it like `unsafe` in that if a function or block is marked as `async` then any function that could be called as `async` would be? That way your code looks a little more like how it would be with true coroutines.
&gt; I don't think niche filling applies It does. `bool` behaves pretty much in the same way as a corresponding enum.
[Previous discussion about the proposed syntax.](https://www.reddit.com/r/rust/comments/bld06g/a_final_proposal_for_await_syntax/)
Sure, several. Most of them just use a space instead of a `.` or other symbol though, for whatever operation it is they use to enable such ‚Äúchaining‚Äù. Smalltalk-alikes do it with message passing, which is written in postfix: `ifTrue:ifFalse:` is a message on Booleans, something like: (value mod 2 = 0) ifTrue: execute1 ifFalse: execute2 Forths and modern functional concatenative languages do it with function composition, also written in postfix by default, but sometimes with some syntactic sugar on top: value 2 % 0 = IF execute1 ELSE execute2 THEN value 2 % 0 = [ execute1 ] [ execute2 ] if (value % 2 = 0) if { execute1 } else { execute2 }
Reserved keywords are not unstable internals. You can access the unstable internals of `panic!()` on nightly. You cannot change how parsing is done unless you change the implementation of `libsyntax`. Also, tying us to the implementation details of the internals is a bad idea in terms of design freedom. In language design, most of the time, you want to promise as little as you can get away with. Allowing more of a user-based implementation here is not a virtue.
To tell `await` from a field, the reader first needs to know that it's a keyword (and not, say, a syntax highlighter glitch. Or a contextual keyword that somebody decided to also use as a field name).
If you read between the lines, I think u/brokenAmmonite's larger point here is the repetition. Critique is all good and *healthy*. However, when you don't bring anything new to the table but merely repeat things, it stops being valuable.
Oh, good! Thanks for confirming!
There's lots of people who keep asking if things that were already discussed have already come up. So this is clearly a discovery issue. So blame the discussion venues instead of attacking the people giving their ideas and criticisms. You also often don't know if stuff was missed, or how much it was considered. In the internals thread, I mentioned that a prefix alternative might have accessibility advantages. Has that made it on the language teams radar? How would I know if it did? Do you really prefer a soured atmosphere over repetition? Do you think using aggressiveness to avoid unwanted criticisms will make Rust better?
With respect, that is a hugely subjective assertion. It might be easier for you, but I don't agree that `await!(...)?` reads better. Spotting an `await!(..)` is also not everything. The point of `async`/`await` in the first place is to make asynchronous programming feel more synchronous code. Reducing the syntactic footprint and invasiveness of `await` is a key point here. So yes, making `await` blend in more is a feature, not a bug. &gt; like in `git diff` This is the only case in which I don't have highlighting and it is typically for changes I made and recently (which I understand fairly well). The issue is with `git diff`. &gt; I feel reading ergonomics always trump writing ergonomics. To my knowledge, almost everyone agrees with this. It's less clear what is more readable however and what counts as noise instead of signal.
&gt;It ain't what you don't know that gets you into trouble. It's what you know for sure that just ain't so. -Mark Twain
&gt; So this is clearly a discovery issue. So blame the discussion venues instead of attacking the people giving their ideas and criticisms. I used to believe this to some extent but don't buy this so much anymore. It often happens, and indeed it has frequently happened with `await`, that the same points have been reraised in *the same thread* (both on reddit, internals, and on GitHub, so the discussion format doesn't seem to matter). This suggests that some people don't bother reading the background material and simply jump to posting. I am familiar with this happening often from political discussions. In those cases it is seldom a matter of venues. Reading the background material has a cost. You need to invest time in doing it. &gt; Has that made it on the language teams radar? How would I know if it did? By virtue of team members reading the discussion, it has. We simply don't have the time to discuss every single comment as a group. &gt; Do you really prefer a soured atmosphere over repetition? In my experience reptition and soured atmophere tend to come together. &gt; Do you think using aggressiveness to avoid unwanted criticisms will make Rust better? Elaborate?
if this were custom syntax for a library function, sure. but async/await is a new feature that interacts with the landscape of other features (namely `?`) in unpredictable ways. you could argue that .await is more consistent because it composes easily with `?` -- in fact i do argue that. but again, this is bikeshedding -- arguing over minor syntactic details that will rapidly become muscle memory once the feature is released. i'd be perfectly happy with (await thing) as well. we've picked .await, fine, lets be done with this, everything's been said already.
I'm not talking about the keyword, I'm talking about generators and `yield`. Not to mention the fact that async/await, a *syntax* not a library module, doesn't work on `core`. How am I supposed to use it on core if I can't redefine it? This is a systems language that lets you redefine the memory manager, panic and oom handlers, and even the core operators on primitives like `+` if you use `no_core` and `lang_item`s. Why should async/await be any different? Why is `Generator` a lang item, but `Future` isn't? It's because async/await compiles to a generator and a single function call. Not even that function is a lang item; it's hard coded so that it's impossible to use any kind of async await on no_std. Unstable doesn't mean the internals are inaccessible, it means they're unstable and may change between releases and you're willing to accept that risk.
&gt; With respect, that is a hugely subjective assertion. I quote your earlier comment: &gt; In the end, I think a more straightforward reason that await shouln't be written as f.await!() is that f.await is simply more ergonomic. It's just as subjective as that one. &gt; Reducing the syntactic footprint and invasiveness of await is a key point here. So yes, making await blend in more is a feature, not a bug. To you it's a feature, to me a hindrance. And even then, I'd argue that masking it as field access is the wrong kind of blending in. &gt; The issue is with git diff. Do you expect every text-based tool possibly used during development to be made aware of Rust syntax? I must say I'm not fond of that baseline for language design. &gt; To my knowledge, almost everyone agrees with this. It's less clear what is more readable however and what counts as noise instead of signal. That I can agree with.
Was there a link to go with this message? üòÉ
LoL. Yes!
I'm someone who doesn't care for async/await, and likely won't be using it, as I find it much harder than explicitly managing async io (not just rust's async/await, the general pattern). So I've been approaching these announcements tentatively, even, I'll admit, suspiciously. But the process has actually given me a lot of faith in the core devs driving this, because they rejected several possible approaches that didn't meet the "zero cost" ethos, even when that was the harder path. It would have been easy to settle. I don't love dot await, but it's hardly what I was afraid of. Good on the rust team for forging the better, but more difficult path. As a mio bitter ender, I can live with this.
Updated.
&gt; It's just as subjective as that one. Sure. What is of import here is that the language team as a collective nudges in the *same* subjective direction. This is what is essential for language coherency. &gt; To you it's a feature, to me a hindrance. And even then, I'd argue that masking it as field access is the wrong kind of blending in. I understand your point and accept that you feel this way. I do disagree on what is important however. I also do think that "masking as a field", while a drawback, is not as serious as some think. There are major upsides to `.await` as well. It's a trade-off and we've evaluated them in a certain way coherent with our point of view. &gt; Do you expect every text-based tool possibly used during development to be made aware of Rust syntax? Language design must account for what *most people* use. It is not particularly interesting to me if there are many niche text based tools that cannot even do the trivial task of highlighting a list of keywords. The `git diff` tool is not niche, but then again I don't think we rely on syntax highlighting to make `.await` feasible. In my view, it works even without any highlighting. &gt; I must say I'm not fond of that baseline for language design. I expect language design to evolve based on advancements in tooling, yes. I think it is reasonable that we adjust our baselines every now and then based on what is commonplace. For example, recent advancements have brought us typed-holes and interactive editing. This changes things in my view.
&gt; I used to believe this to some extent but don't buy this so much anymore. It often happens, and indeed it has frequently happened with await, that the same points have been reraised in the same thread (both on reddit, internals, and on GitHub, so the discussion format doesn't seem to matter). This suggests that some people don't bother reading the background material and simply jump to posting. I am familiar with this happening often from political discussions. In those cases it is seldom a matter of venues. Reading the background material has a cost. You need to invest time in doing it. Even if that's true it's still no reason for aggressiveness. Though I don't believe it to be true. &gt; By virtue of team members reading the discussion, it has. We simply don't have the time to discuss every single comment as a group. Okay, but how do I know it has been considered? Will it be mentioned anywhere? I don't need a big discussion but an acknowledgement that it's on a list for thinking about or something would be helpful. This is one of the issues with floodgate discussions. &gt; Elaborate? I'm suggesting that using aggressiveness to stomp out repetition will create an atmosphere that's not good for language development. I also believe it will not work. If you assume (as I hope you do) that the comments are made in good faith, then there's no need for aggressiveness.
I think part of the problem is even if we added postfix macros the macro would have to be called something other than "await" since that is a keyword now.
Hmm. I'd consider it but being based in the States, the time spent on communication alone makes this not worth my while.
&gt; Sure. What is of import here is that the language team as a collective nudges in the same subjective direction. This is what is essential for language coherency. Language team agreement still doesn't make things fact. I'd suggest phrasing it as "The language team considers it more ergonomic" instead of just stating that it is. &gt; Language design must account for what most people use. It is not particularly interesting to me if there are many niche text based tools that cannot even do the trivial task of highlighting a list of keywords. The git diff tool is not niche, but then again I don't think we rely on syntax highlighting to make .await feasible. In my view, it works even without any highlighting. I disagree here, and I wouldn't consider many of these things "niche". &gt; I expect language design to evolve based on advancements in tooling, yes. I think it is reasonable that we adjust our baselines every now and then based on what is commonplace. For example, recent advancements have brought us typed-holes and interactive editing. This changes things in my view. Personally I hope against that. For many reasons, I think simple text-based tooling agnostic language design has the best long-term payoff.
I can get you a much cheaper Peking function, PM your best offer
&gt; Okay, but how do I know it has been considered? Will it be mentioned anywhere? I don't need a big discussion but an acknowledgement that it's on a list for thinking about or something would be helpful. If you see us commenting and on a thread on internals, chances are that at least some of us have read your comment. &gt; This is one of the issues with floodgate discussions. Certainly. It's harder to address new points that are made when you are busy educating people about facts for the nth time. So having too much repetition can hurt the ability to consider new information in depth. &gt; I'm suggesting that using aggressiveness to stomp out repetition will create an atmosphere that's not good for language development. I also believe it will not work. What do you mean by "aggressiveness"? &gt; Though I don't believe it to be true. &gt; If you assume (as I hope you do) that the comments are made in good faith, then there's no need for aggressiveness. If you allow me a smidgen of sharing my experience from political activism, it was regularly the case that people would repeat the same points *in good faith*. In particular, it was the case that men would take too much space and not write down what others have said. People rarely repeat arguments out of malice, but it can still be counterproductive to the health of a discussion.
&gt; your code will break Fwiw this isn't true-- I explicitly wrote the change in such a way that existing code that used the std await! macro will continue compiling, in order to give folks time to transition.
This is a great, in depth look at enums vs structs I got a lot out of: https://hoverbear.org/2016/10/12/rust-state-machine-pattern/
&gt; Language team agreement still doesn't make things fact. By "fact" I mean things other than mere subjective opinions. Facts are e.g. about fundamental constraints that compiler technology puts on us. &gt; Personally I hope against that. For many reasons, I think simple text-based tooling agnostic language design has the best long-term payoff. Well then; it seems we understand each other but are philosophically unaligned.
Try using the failure crate
&gt; If you see us commenting and on a thread on internals, chances are that at least some of us have read your comment. With all due respect, things have been missed before. How about some updates here and there about things which have been noted? &gt; What do you mean by "aggressiveness"? The comment I replied to that started this comment chain? &gt; If you allow me a smidgen of sharing my experience from political activism, it was regularly the case that people would repeat the same points in good faith. In particular, it was the case that men would take too much space and not write down what others have said. People rarely repeat arguments out of malice, but it can still be counterproductive to the health of a discussion. Okay, what does this have to do with the effect of aggressiveness? Was aggressiveness a solution to the problem in those cases?
&gt; How about some updates here and there about things which have been noted? These days we record language team meetings and put them up on youtube for anyone to see. I believe we also post agenda minutes from meetings as well. Beyond that and the comments we make as individuals, it's hard to do more. At the end of the day, most of us do this work on a volunteer basis. Given the limited time we have, I think you should adjust your expectations of us. &gt; The comment I replied to that started this comment chain? What about it was aggressive?
How much better than the enum solution is `#include &lt;studbool.h&gt;`? When inspecting `true` or `false` it gives the classic `typedef 1 true`, etc., so what else does it do?
It's no different to any other keyword. You can't use "let" or "return" as fields either.
&gt; Not to mention the fact that async/await, a syntax not a library module, doesn't work on core. How am I supposed to use it on core if I can't redefine it? See https://github.com/rust-lang/rust/issues/56974. &gt; Why is Generator a lang item, but Future isn't? It's because async/await compiles to a generator and a single function call. Not even that function is a lang item; it's hard coded so that it's impossible to use any kind of async await on no_std. This is a technical limitation in how `#[lang = ".."]` items are handled in the compiler today. The problem is that HIR lowering runs before the `TyCtxt&lt;..&gt;` is made and so before lang item collection happens. I don't like these hard coded paths either and I am working on a PR to hopefully fix it but it's not a trivial change.
&gt; These days we record language team meetings and put them up on youtube for anyone to see. I believe we also post agenda minutes from meetings as well. Beyond that and the comments we make as individuals, it's hard to do more. At the end of the day, most of us do this work on a volunteer basis. Given the limited time we have, I think you should adjust your expectations of us. Then you'll keep getting repetitions. Although personally I expected it to be missed. &gt; What about it was aggressive? I find the last paragraph particularly aggressive. "periodic breakdowns the Rust community has", "tyrannical dictators", "community that largely ignores you", "rage roulette wheel"...
&gt; I find the last paragraph particularly aggressive. "periodic breakdowns the Rust community has", "tyrannical dictators", "community that largely ignores you", "rage roulette wheel"... Perhaps an exaggeration, yes. But for what it's worth, it does happen that *some small* number of people do level accusations in that spirit.
The stdlib documentation for `std::collections::binary_heap` contains [an example implementation of Dijkstra's shortest path algorithm](https://doc.rust-lang.org/std/collections/binary_heap/). In that example they just use a two-dimensional vector of edges.
They're already on Travis, and they have other reasons to want to switch away.
Mozilla Public License v2 would work
You might not want to immediately resolve a future as soon as it's produced. That would prevent things like triggering then awaiting for several async operations to complete in parallel.
Regardless of if you have syntax highlighting or not, you will notice something strange is going on and you'll Google what the heck is this async thing. It's not as irksome as some syntax that leads you to believe that the code does something else from what it actually does. It only leads you to believe you don't understand what's going on.
A toy language I've been playing around with is like this. For example, (1,10).range.add.print prints 55 (1+2+3+...+10). The ergonomics of it are not great though. I did if/else with a variant on the normal syntax for the conditional operator. (5,15)?greaterthan:(|0):(|1) would print 15
Future is intended to be a lang item though, the fact that it‚Äôs implemented with generators today is the unstable implementation detail. That was a specific design choice so that generators and futures can compose to make streams and so that `yield` in `async` functions doesn‚Äôt interact with the `await!()` macro.
And it's awful that that happens. But framing it like in the original post is not helpful in my opinion, which is why I'm saying it would be great if we could all tone that down a bit. Do you agree with that?
~~Really wish we could have an alternate syntax for these pseudo-fields like CSS has classes and pseudo-classes...~~ I also really wish we supported this pseudo-field postfix form _and_ the prefix form. Even if less composable, the prefix form is far more familiar for people coming from other languages. Strangely enough while typing this response and trying out the syntax something clicked in my head and I now actually like the pseudo-fields with regular dot. I still feel like we could keep both.
Yes I agree we should *all* tone it down a bit*. :)*
Why not use a different separator other than a dot "."?
Sure thing. My use case is to run my test using Meson build system, I already wrote a python program that would handle downloading crates just need to run unit test.
I'm a Rust newbie so take this for the little it's worth but I find overloading the field access for a totally different concept to be pretty weird and confusing. If the concept of postfix keywords throughout Rust will be a thing, it would be much more obvious and intuitive with a different separator like myfunc@await or XXXX@match. Basically I disagree with the below statement from the proposal doc. Conflating two concepts seems worse to me than the problem that is being avoided. "Other choices (like ‚Äúexpression@await‚Äù or ‚Äúexpression#await‚Äù) suffer from too much from the ‚Äúline noise‚Äù problem and we strongly prefer to avoid introducing new meanings to punctuation characters for this purpose."
Then maybe it'd be handy instead to make it "procedural" by default (as I propose) and then you can explicitly ask for them to complete in the background as they would normally. 90% of the time, I want things to be entirely procedural, 10% of the time, I actually want to invoke the functions asynchronously and get their result later. It seems like we should make the 90% case the obvious one. If I see a function that's called "async", that should tell me that I *can* invoke it asynchronously. It shouldn't mean that I have to use this function in a completely different way (as in, that I need to `.await` it).
&gt; Do you know if there is a language out there that has most of its operations implemented in a field access style? Smalltalk has 100% of its operations like that. The only bits that aren't are sugar for other constructs that are. Instead of an if statement, you call the `ifTrue: ifFalse` method on a boolean and pass blocks of code for each branch. But in Smalltalk, absolutely everything is an object and respond to message passing.
Note: you are replying to the person same as the poster, so it is weird to use "they" here.
I really wish using a character other than `.` would be considered, because overloading that feels really strange for Rust. Using another character like `future@await` (mentioned in the proposal) is much more explicit and noticeable, which is a theme that's generally present in the langauge. I didn't find the syntactical noise argument to be all that convincing, it seems like the kind of thing that would look totally natural after using it for a bit &amp;#x200B; I've never seen `|&gt;` used anywhere besides F#, and Haskell has all sorts of funky operators (`&lt;*&gt; $ &gt;&gt;=`), but these things don't actually add noise to the language. If anything they make things easier to parse while scanning code
Gotcha. I've never actually tried this, but my understanding is that you can use \`rustc --test\` to build a test runner from the same source as your main app/crate, and it will automatically find all the functions annotated with \`#\[test\]\` ‚Äî in fact, I think this is what \`cargo test\` calls underneath. So if you've gotten your Meson setup working to the point where it's happily building your main app/crate, I \_think\_ doing basically the same thing but with the \`--test\` flag to \`rustc\` then it should Just Work‚Ñ¢. :)
They don't have postfix operators like ? Littering every block of code in those languages. All of our complaints have been posted a thousand times. Every stakeholder understands the various tradeoffs. They all read and write rust and care about the language. Don't lose sleep or make them lose sleep repeating an argument posted so many times on so many forums already.
so like a `delay` keyword perhaps
Important note: that's not how Rust futures work. They're dormant until you `await` them. If you want to await more than one future simultaneously, you'll need to do the equivalent of `let (a, b) = futures::all!(fut_a(), fut_b()).await`. It's still important that futures don't auto-await such that the `Future` type can represent an asynchronous deferred operation the same way in sync and async code.
&gt; Even a beginner can see that "future.await" is separate from field access, How in the world can you be so confident? Maybe in an editor environment that colorizes it specially they can see that it's *something*, but what will they see it to be?
&gt; plus it's highlighted differently. It *might* be. Have you never had to edit code in an environment where no installed text editor had highlighting for the language being edited (if it had provisions for that at all)?
Bikeshedding does not mean talking about a thing that doesn‚Äôt matter. It means talking about a thing that does matter, but talking about it waaay too much given how much it matters relative to other parts of the design. This is classic bikeshedding.
Rust is proving to be a great fit for cloud services! Microsoft is using Rust for part of their IoT offerings: https://github.com/Azure/iotedge/tree/master/edgelet . Amazon is using Rust to power various parts of their AWS offerings through [Firecracker](https://aws.amazon.com/blogs/aws/firecracker-lightweight-virtualization-for-serverless-computing/). Specifically, their serverless offerings, Lambda and ECS Fargate, use Firecracker. On the customer side, Rust has been used with great success on AWS, including [parsing logs](https://andre.arko.net/2018/10/25/parsing-logs-230x-faster-with-rust/) so fast the work is done on the free tier of AWS Lambda. With Rust's focus on speed and elimination of entire classes of bugs common in C or C++, it's finding a nice home on the cloud.
&gt; (await foo())? Or `await { foo? }?`, which pretty sensible to me.
&gt; "oh, this is a macro" when it really isn't, and macros can't do what await can do. I still don't buy that this matters. Plenty of "macros" do this. No one cares, it's never been a problem before, why is it now?
`await!` should not be removed in future
Let's use this opportunity to repeat over and over all the arguments against this version of the syntax. :D
&gt; I'm a little frustrated that the Rust compiler is marking my defined constants (to avoid magic numbers) as unused code, even though I invoke the constants in struct definitions, etc. Can you make a repro on https://play.rust-lang.org/?
But I am pretty sure that the desire for postfix await has not great support in the community. If you were to show code examples and poll users on it I‚Äôm quite sure postfix field access will lose against just prefix await with parentheses around the expression.
Very, very rarely? I seriously doubt more than 0.01% of Rust code is written without syntax highlighting by people that didn't explicitly turn off syntax highlighting.
Do you know of there is there a macro to derive all these `is` functions for an enum?
For what it's worth, I read the rationale for .await and I think it's the correct choice. Frankly I'm a bit surprised that so many people seem to be concerned about how it could be mistaken for field access by anyone except people seeing it in rust code for the first time. Most likely they will be confused for a moment, look it up and go "oh, ok". I don't think that's a practical concern at all.
I've never done this before, so let me know if I messed this up. Here is the [link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f94b814a53e6c55191b122dcbef89562). Initially, I thought maybe it was because I had not actually used the structs yet in my code (I'm still just defining types). However, I still seem a dead code warning. Perhaps I just fundamentally misunderstand constants in Rust? I'm coming from an amateur C background.
not really easy coz you still need to use the godot editor. another hand when we use Rust in godot we must use [unsafe] a lot so no point to do so. i want to use full power of Rust not just saying that im writing in Rust.
not a real editor though haha. but thanks for sharing
We run buildbot for servo, and rust used to run it many years ago. The problem is that now you have to manage your own infra. Including OSX infra. Which is basically physical Mac minis you rent (Rust used to have a literal stack of minis under brson's desk, servo uses macstadium). On Servo we've had plenty of problems with needing to upgrade things on the various builders, or just stuff being broken. We regularly have to reprovision a new mac mini. IIRC rust used to have such problems too, but times ten since they had a much larger set of buildbot builders and way more PR traffic. Servo's slowly migrating over to Taskcluster now. It's pretty good! Not having to manage your own machines is a major improvement, plus since it's run by Mozilla it's easier to deal with from a money POV. It's nice to be able to monkey patch infra, but you also have to keep shoring things up a lot more often.
In your example it's not complaining about `NUM_FRIENDS`, but about the two fields. They're never used in the sense that they're never read. I can disable the warnings during development if you want, but they're not so bad with proper IDE support.
I just noticed that the cargo build output of warnings is different from the run. There, it says that NUM_FRIENDS is unused. But I see what you are saying in the error output for running.
Oof, that version uses a heap which could contain something like `O(V^2)` vertices.
But it's not just that, there are semantic differences, and these are common across lots of other languages regardless of the specific implementations. Field accesses should not have side effects. You don't want actions to occur without seeing those (). And normal method calls should not affect control flow in the parent context, but macros may. !() is by far the closest currently existing construct.
Hi Thanks for your answer. I have been reading a lot since your first message and understood your point. However, I do not understand your recommendation to use usize for money, I mean: for money, even if I need to control the money I am giving to my son, I would need some decimals, what could not be handled by usize AFAIK. My context is just a simple test that my team is doing at work to compare performance between several languages as we are not happy with our Java platform. We are testing NodeJS (it was a surprise as it sucks and performed worst than Java), Go (awesome to write code and very fast), Rust (a bit faster than Go and rock solid but hard to learn) and Vert.x that surprised as because if faster than Go. So, the context is not really money related but as I am working for a bank (as my personal interest on learning) I would really love to learn how to handle money properly. Thanks in advance J
&gt; and I don't get why they can't actually, given that it would desugar to \`(await expr)\` but whatever That's because you're assuming that both keyword and macro syntaxes are available. If there is only macro syntax (prefix, postfix or both) then you can't.
How would the compiler know when you want to block execution of the function and `await` for some async operation to finish? What if I want to fire away two async operations and only after that await for them both? How would the compiler know that I want to await only after the second async is called?
I'm practicing using Rust with WebAssembly. I've got a working example: [lib.rs](https://lib.rs): [https://pastebin.com/aRM2Z3yD](https://pastebin.com/aRM2Z3yD) Cargo.toml: [https://pastebin.com/sU3K8icS](https://pastebin.com/sU3K8icS) index.html: [https://pastebin.com/bKQEL7nH](https://pastebin.com/bKQEL7nH) &amp;#x200B; However if I change [lib.rs](https://lib.rs) like this (I only add extern crate wasm\_bindgen; but I don't use it anywhere): [https://pastebin.com/n3w92NHA](https://pastebin.com/n3w92NHA) I get this error in browser's console: "Uncaught (in promise) TypeError: WebAssembly Instantiation: Imports argument must be present and must be an object" &amp;#x200B; I'm compiling with command: "cargo build --target wasm32-unknown-unknown --release" &amp;#x200B; I know there is wasm-pack, but it adds node.js, webpack and all kind of fancy magic into equation and I really would love to understand how to do things manually before I start using more advanced tooling.
I'm an intermediate Rust user, I've read the entire book. I don't know enough to understand why `expr.await!()` was considered to be inconsistent. It looks as consistently magical as any other macro. 100% of Rust users will see `expr.await` as a special case. New users will encounter the special case while still evaluating the language, and they may rightly conclude that even the simplest parts of the language, like field access syntax, have special cases.
&gt; A lot of the arguments in the blog post are predicated on the idea that `await` is relevant for flow control. While this is true from the perspective of the implementer of `await`, a user of `await` actually doesn't see explicit changes to control flow. Interestingly enough, I found that one of the most common arguments of the *detractors* of postfix `await` is that it is control flow and therefore needs to stand out more. Which I totally disagree with.
As I've said elsewhere, I like prefix await, with a postfix macro .await!() that rewrites to the prefix, but if we were going to do it like that, it'd be good if the symbol conveyed something about waiting, maybe the '+' sign? ``` foo+.another_future()+.do_something(); ``` Sorry, I obviously mean ``` foo+.await().another_future()+.await().do_something(); ```
Was adequate consideration given to making all of these valid? :)
Maybe that's OK? An 'await' prefix operator keyword and an '.resolve!()' or similar postfix macro. I doubt most people are really hung up on the name of the convenience macro.
not usize. u8, u16, u32, etc. \&gt;I am giving to my son, I would need some decimals, what could not be handled by usize AFAIK. 1000 in decimal form could be reinterpreted as 10.00 easily. a BigDecimal class would have the whole and fractional part held separately and handle the carry for example. \&gt; So, the context is not really money related but as I am working for a bank (as my personal interest on learning) I would really love to learn how to handle money properly. Does the bank have a software package for handling currency? Because currency is \*not\* just a unit-less number. it's multiple sets of money and a unit and conversion rates and how long those conversion rates are good for and on and on and on. Depending on exactly what you are doing 'money' is a \*very\* deep subject. Currency is just one small nearly microscopic part of that. But for a banking application, the bare minimum I would consider viable would be a currency type (which means it includes a unit type \*and\* a BigDecimal implementation). But again, the context is important. A stock system would need to be blazing fast and so it would significantly change the currency implementation vs just whatever BigDecimal implementation you have available.
It's not that a beginner "can see", but a beginner "will see". Many will see that even field access has special cases while still evaluating the language -- while they are still deciding on whether or not to learn more.
I misinterpreted the comment in the pull request, my bad. I've editted the post to remove this.
Just re-implement `cargo test` in python.
If you can't use `cargo`, then re-implement a tool that does what cargo does.
Isn't `Vec&lt;Box&lt;Mytype&gt;&gt;` kind of redundant? The vec is already allocated on the heap, is it not?
&gt; this can not be implemented as a Rust function To be fair, several rust functions cannot be implemented without significant compiler intervention. This is one of them: https://github.com/rust-lang/rust/issues/47809 That said, I‚Äôm in favor of prefix await? keyword. A function from your blog is my second choice.
&gt; I think u/brokenAmmonite's larger point here is the repetition I do get how this stuff can be corrosive to the motivations of the people doing the important work, and obviously that's bad. However, repetition does not necessarily indicate that people haven't done any background reading - people make points for all kinds of reasons, including believing that their objection is more important than is being given credit for (perhaps because it's not been articulated well enough).
The example would be *field access* syntax and not method call syntax, which is why the `.match` proposition is so weird, even moreso when applied to `if`: let value = 42; value.if x % 2 == 0 { execute(); }.else { something_else(); }
Unrelated, but I've noticed that /u/kyrenn has recently deleted her account. I hope she's fine, and it wasn't prompted by something on this subreddit like the `wlroots` post.
Hmm... I don't think the `extern "abi" fn` approach has been considered enough. It already has some funky magic like in the `Fn` traits like you mentioned. Granted, I would personally prefer practically anything to the field syntax, even the sigil, so it makes sense that I would support something like this. That said, I'm still not convinced that we're not trying to fix what's not broken. I've already grown fond of the current macro and see no problem with letting users know that async/await is built on generators. If someone tries to interact with the generator underneath, that would still require enabling `#![feature(generators)]` so changing it wouldn't be a breaking change for stable. If you're concerned with error messages mentioning `yield points`, why not just change it to `await/yield points`?
She was a specific person I was thinking about who might have a use for it. It does seem that her Twitter is suspended as well.
No, I think her Twitter account is still there.
Oh, my mistake, I assumed her username was the same.
Good point of anothern function with significant compiler intervention. I had originally considered mentioning this as well here but there is one difference why this does not need another ABI or magic. I see the abi/fn qualifiers as a way to restrict *where* a function can be called, whereas that feature tries to make sure it can be called *anywhere* even in places without internal llvm register support.
+1 to /u/thiez's suggestion. Even if you did use truly atomic arithmetic, it would still lock the memory from the other cores of your machine. In this case, a single threaded implementation might actually be *faster* than what you're doing, unless you're doing other actions between the arithmetic. The proper solution is to restructure your program so the different threads need to communicate as little as possible. One of the biggest reasons to use a global atomic for something like this is to count the number of operations done, but that wouldn't require decimals, and even if it was time you were counting, using nanoseconds instead of fractional seconds would be better.
I can't reproduce it with the Playground code in an empty project. You should consider opening an issue.
Try out different things and see what actually works for you. Most people here will confirm that most of us needed several attempts to actually understand how to use Rust properly. Rust tries to be a friendly language but the focus is still on writing safe and efficient code which is not something you usually put that much focus on in other languages (not to bash other languages. Use the right tool for each job).
One approach would be to provide the keyword version, then see what macros the community write to make usage better.
Good content, as always! :)
Well, it's absolutely possible to remove () or ! on ergonomic grounds. Haskell gets by without them in general. But then again, Haskell isn't so interested in broadcasting what a developers should expect behaviour to be from looking at the source code. I really liked the choice of marking macros with !. And that's not because they're specifically 'macros', it's because they can affect the code in the context they can appear. On the other hand a method call () cannot affect the code in the context they appear, but can take actions and affect the state of the world. These are great markers. Languages that allow code to manipulate the context in which it appears but that do nothing to mark that code as special in someway have chosen an inferior approach to rust.
\*Grabs the popcorn\*
If you wish to see what a large-scale change from the macro to the new syntax looks like without syntax highlighting: https://github.com/rust-lang-nursery/futures-rs/pull/1583.patch
I'm starting with rust this week, have some experience in C/C++, tried last week some golang but got quickly stuck as there is a garbage collector and I was looking for a langage that can almost do everything (web/api-calls/networking/games/AI/etc) Heard of Rust as a great tool, maybe a bit young but starting to have some really nice contributions. (I'm a low-level langages lover - C/Assembly &gt; All - Still I was missing OOP, here comes Rust). Wanna do something in SDL or a YamlParser to understand quite a bit some Rust specificities, seems pretty fun
I find this solution most helpful when reviewing others‚Äô code ‚Äî in PR diffs, for example ‚Äî where the tooling isn‚Äôt providing IDE niceties
@ is quite chunky visually. I don't know enough to know the problems with these, but if you want something that visually flows, maybe something like ``` future\await future&gt;await future-&gt;await future.&gt;await ```
I hear you, I‚Äôve been having the same nagging thoughts :) I think dot await would be a good innovation if it turns out that in practice, await chaining turns out to be useful and desirable. Interaction with ? doesn‚Äôt loom as big in my mind, I wouldn‚Äôt mind having to write await { ... }? or even (await ...)?. But await { await { ... } } (instead of chaining) does look unwieldy. However, until it‚Äôs clear that people want to do this, dot await feels like a premature syntactic optimization. And I don‚Äôt think this question can be settled other than by implementing the more obvious/conservative solution, i.e. some form of prefix await, first and letting people use it for a while. Kind of like try!() -&gt; ?. I tend to think that I‚Äôm the type of person who‚Äôd rather separate individual awaits to make them stand out, but maybe the best way to design async APIs will turn out to be one which will make me yearn for dot await as an ergonomic improvement. In which case I suspect I won‚Äôt be alone, and at that point, dot await will be a much easier sell. I understand the lang team may have genuine foresight about this, so they want to save themselves the extra step. But what is saved in terms of technical work seems to come at the cost of lengthy churn in the form of interactions with the larger community, who just cannot be expected to have this foresight.
I would consider a `_` match to be a code smell in a lot of cases
Now is the time to battle test this syntax. Time is running out.
Have you seen code with more than two chained awaits?
Finally, some fresh (and original) view on the issue. Even if your proposal would not be adopted, it still worth it. Thanks!
Rust newbie here as well, I find the ".await" kinda confusing, I would much like something different from the dot for a postfix keyword. Sometimes I do work without syntax highlight, but it is not really about that, it just looks not-consistent to me. And I really do not get the "line noise" problem. Different symbols DO break your reading, which is a good thing because await ALSO breaks code flow. Perhaps the '@' looks very odd, but a '#', a '-&gt;' or a '\~' could have worked very well IMO.
My opinion is probably worth only 1 cent, but I do like the idea of a different character other than `.` To me, a special operator to mean something special is a good feature, is not noise. Especially if we want to extend it to other keywords, like they have been proposing for `match`
It could have been implemented as the "await {}" syntax, which fits the most with the rest of the syntax, and unified postfix macro calls in order to be able to .await!() (and additionally .try!(), .format!() and other stuff)
I haven‚Äôt ‚Äî that‚Äô s kind of my point, since there‚Äôs no stable syntax, I haven‚Äôt seen much of this type of code at all, as a Rust ‚Äúnormie‚Äù :) Which is why I personally think it would make sense to start with the most obvious / least controversial solution first and see where it takes us before innovating. At the same time, as mentioned above, I fully acknowledge that the lang team may have foresight that I‚Äôm simply incapable of, and that within two months of writing stable async code, I‚Äôll be thanking them on my knees for pushing dot await through.
&gt; I know it seems a silly reason on which to hinge an argument, but to be taken significantly more seriously than a "Mozilla Research Language" lol
Thank you. Hearing that the work put into the blog is still appreciated even if it does not influence the final adoption feels nice.
There are some samples [here](https://github.com/inejge/await-syntax/blob/postfix-field/bin/wlan/wlantool/src/main.rs). I believe the code is written by /u/cramert, who's been a big proponent of the postfix field syntax, and it's been argued that it proves that solution to be better.
Thanks, I'm still trying to get the basic rules of references and lifetimes in my head. &gt; it would return (approximately) `vec![(&amp;mut a, vec![&amp;b, &amp;c]), (&amp;mut b, vec![&amp;a, &amp;c]), (&amp;mut c, vec![&amp;a, &amp;b])]` Yes, that's exactly what I'm trying to do. I considered the option of a fake iterator, but got stuck with a similar error with this code: struct WithOthersIter&lt;'a, T&gt; { idx: usize, vec: &amp;'a mut Vec&lt;T&gt;, } impl&lt;'a, T&gt; WithOthersIter&lt;'a, T&gt; { fn new(vec: &amp;'a mut Vec&lt;T&gt;) -&gt; WithOthersIter&lt;'a, T&gt; { WithOthersIter { idx: 0, vec, } } fn next(&amp;'a mut self) -&gt; Option&lt;(&amp;'a mut T, Vec&lt;&amp;'a T&gt;)&gt; { if self.idx &gt;= self.vec.len() { return None } let (before, item, after) = split_at_three(&amp;mut self.vec, self.idx)?; let mut others: Vec&lt;&amp;T&gt; = before.into_iter().map(|x| &amp;*x).collect_vec(); others.append(&amp;mut after.into_iter().map(|x| &amp;*x).collect_vec()); self.idx += 1; Some((item, others)) } } I'm using the struct in this part: let mut iter = WithOthersIter::new(&amp;mut self.players); while let Some((p, other_players)) = iter.next() { let played_card = p.select_best_card()?; Game::execute_card_action(&amp;played_card, &amp;p, &amp;other_players); } The error is again error[E0499]: cannot borrow `iter` as mutable more than once at a time --&gt; src/game.rs:43:46 | 43 | while let Some((p, other_players)) = iter.next() { | ^^^^ mutable borrow starts here in previous iteration of loop I don't understand the difference between my next method and normal mutable iterators. Is it the lifetime?
&gt;if it turns out that in practice, await chaining turns out to be useful I've kinda been wondering about that too. In what sort of situation is chaining multiple awaits ever useful at all? I can't really think of any reason to ever return a future wrapping another future. You'd just await it before returning instead. The only form of async chaining I can see being useful would be some sort of async pipeline/iterator, but that would almost certainly be a completely different type from normal futures and shouldn't need any kind of await except at the very end of the pipeline, as awaiting each step would pretty much undermine the point of having an async pipeline in the first place.
u/Kyrenite
Thanks, I‚Äôll take a look! &gt; it‚Äôs been argued that it proves that solution to be better. To be clear, I sincerely hope that this is the case, since it looks like we‚Äôre getting dot async anyway :) I‚Äôm just saying it might have been an easier process community-wise if it‚Äôd been done in two stages.
What's the easiest way of making a SOAP call with rust? &amp;#x200B; I don't need WSDL support, and I'm only using HTTP to call the SOAP service. &amp;#x200B; I couldn't find any functioning rust crates.
Yeah. Honestly, when reading your article I expected to see yet another bikeshed, but the contents surprised me in a positive way. SJLJ as well as async vs unsafe environments are definitely interesting parallels that, to my knowledge, weren't mentioned before. That alone was a win and would be useful for future research, IMO.
Yay :-).
Maybe I'm just missing it, but quickly searching for ".await" and looking through the occurrences, I can't find a single case of multiple awaits being chained at all.
Agree on all points
There are four instances in that file, e.g. https://github.com/inejge/await-syntax/blob/postfix-field/bin/wlan/wlantool/src/main.rs#L184.
In my day-to-day work, I do `git diff` code that has been written by other people, both on my own local machine and on a remote server with outdated-ish tools\*. I do agree that syntax highlighting is commonplace, but I would still love if this feature stood out a little more. I personally really like the idea of something other than a `.` in the `.await` expression. To me, that would not be "line noise" but "line insights", since it tells you more about what is going on. Disclaimer: I am a Rust newbie, and my little experience is the reason for which I am favoring a more explicit syntax. &amp;#x200B; \*(am I the only one here doing so?)
Ah, you are correct. Somehow I overlooked it.
As a C++ dev that's interested in rust but never gotten there, it literally doesn't matter what the syntax is as long as it makes sense, its consistent, and contains a minimum number of surprises Now **this** is a bridge too weird: template&lt;typename T&gt; struct class_extractor; template&lt;typename C, typename R, typename... Args&gt; struct class_extractor&lt;R(C::*)(Args...)&gt; { using class_t = C; }; Syntactic oddities are a very minor complaint on the list of why not to use a language, unless it becomes problematic like perl. The main reasons not to switch are still tooling and confidence that it won't go away in a few years
First, thanks for contributing to the discussion! However, I'm not sure I agree with having `await` as a method. The fact that it can be implemented as a special ABI function using `setjmp` and `longjmp` boils down to an implementation detail. I still see `await` as something that the compiler has to intervene pretty heavily in. Having used async/await in JS and C# which both (AFAIK) do compile-time splitting of the control flow at `await`-points to create a sequence of continuations, now thinking about it as a method hurts my brain a little. The composition argument I agree with. Composing these operations in JS/C# which I mentioned above can become weird because of the await operator precedence. This I disagree with: &gt;It points to a function call. This is correct insofar as some other code is running until it returns. Yes, some other code runs, but the code that runs is so arbitrary and disconnected from what's being await'ed that I think it has the potential to confuse people even more when they see as a method. The first question that pops to mind is probably "OK, what code runs here when I call this method?". And the answer is literally "code from whatever coroutine happens to be picked". In my mind this does not fit at all with how a method call should work. Signifying that something special is happening via an operator can be beneficial. Having said that, I also see the argument for a method from the language cleanness/orthogonality perspective, so as I said, I'm just not sure. But how the syntax will look is not that important to me - just want to get rid of the `.then(...)`s :)
&gt;Their match example is pretty hideous; you can see that there's a control block and then must scan around for what operation it might be performing. Scala had postfix matches since forever and I personally find them to be pretty ergonomic and composable: [https://docs.scala-lang.org/tour/pattern-matching.html](https://docs.scala-lang.org/tour/pattern-matching.html).
I would sympathize more with postfix solutions if I could see some code that uses three or more `await`s in the same expression, or that would be _improved_ by such chaining.
Note that there's already been a couple of polls on this: https://internals.rust-lang.org/t/async-await-syntax-straw-poll/9954, https://www.reddit.com/r/rust/comments/bju8di/asyncawait_syntax_survey_results/.
It's not about chaining awaits. It's about chaining await with `?` and methods. ``` lets() .do() .some() .operations() .then()? .await!()? .for() .the() .result(); // vs await (lets().do().some().operations().then()?) .for() .the() .result(); ```
Ah. We should really sticky a poll. Although, I do believe that there are too many options on some of those polls, which makes it cumbersome to really interpret the results.
I'm somewhat on the fence about whether postfix macros (or postfix anything, really) are a good idea at all, but I have to say I'm definitely more in favor of a generalized postfix-macro syntax that potentially could have other uses in the future than the completely out there field-access-like .await syntax (which frankly made me practically recoil in disgust when I first saw it) that's been proposed. Your #1 suggestion seems like a pretty good solution, as it would both allow the by now pretty standardized (outside of Rust) await prefix keyword, which you'd likely want to use most of the time, while still allowing a reasonably clean looking syntax on the rare occasions where you'd need to chain awaits.
I see this more and more often on the Internet, and I'm terribly sorry, but I must go grammar nazi on it: - "Copywriting" is about writing advertisements and similar texts - "Copyright" is your legal right to stuff you created.
Do you mind explaining what that snipppet does? I thought I was pretty well-versed i C++ but apparently not.
I'm a noob but I think the reason is vectors need to have all elements of the same size or something.
&gt;The idea of taking an action with side effects with no call syntax could definitely lead to some confusion. With .NET existing (properties cause arbitrary side effects), I think programmers already are on the lookout, so it's not so bad.
You mentioned briefly that the details of Intel's Iris Pro 640 are shrouded in mystery; they happen to be the only vendor for which this is not true. You can download a full hardware PRM from [the Intel Open Source site](https://01.org/linuxgraphics/documentation/hardware-specification-prms), and (with a lot of effort - I'd start with the GPGPU chapter of the specs, a big stack of notepaper, and an ample supply of your favourite concentration aids) deduce how the chip actually executes graphics commands. The challenging part when I did this was learning how the register file on a GPU is actually used, but I had past experience of VLIW DSPs. The other thing that's funky about GPUs generally is that, unlike CPUs, you have a very large number of hardware threads, and the GPU handles stalled threads by switching to another thread; on the devices I learnt about this stuff on, you had 16-wide SIMD ALUs (with clever mapping to/from registers), and you typically gave the hardware 16,000-odd threads to schedule across 24 SIMD cores. If I had spare time, I'd be tempted to write a crate that let you program the GPU at the EU ISA level directly, using the Linux DRM interfaces to schedule your computations - not for production use, but so that you can write a toy GPU driver in Rust to learn about how this all works.
https://github.com/pyros2097/rust-embed
The second class_extractor definition is a specialisation of the first that uses template argument deduction to work out the types involved with a member function. So R(C::\*)(Args...) corresponds to return_type(class_type::\*)(argtypes...), then it reexports the deduced class type as class_t The intended usage is to stick it in a struct like so struct some_struct { SOME_MACRO() } What the macro does is declare a dummy member function \_internal\_helper, and then it takes the type of that (decltype(&amp;\_internal\_helper)) and sticks it into class_extractor. self_t is declared as an alias to the class that _internal_helper belongs to (aka some_struct) for convenience The end result is that we get the type of the current class as self_t without having to actually type out the name of the class itself, which is useful for some generic programming stuff This is basically a dirty hack to work around the fact that you can't do this: void serialise(decltype(this) other); in C++
The language team seems to agree on this Foo. await general postfix syntax (but without parentheses) for some of the same reasons. But since it gives over flow control it is not according to https://boats.gitlab.io/blog/post/await-decision/ actually a function in the strict sense.
I just downloaded nightly. How can i use async? Do i need to use a reactor thatuses std future?
Yes, but in this case they are storing enums, and the size of an enum is the size of the largest variant.
&gt;That's definitely a fair point. I'm concerned about that as well. The idea of taking an action with side effects with no call syntax could definitely lead to some confusion. I think it's hard to know the right decision here. I hope that nightly will serve as a way to test how confusing it ends up being for people and may surface better alternatives or reasons to take another approach. I don't have any good ideas, though. Unless maybe triple dots or something like that could be used - my_async_of_result_call()...? for Future&lt;Result&lt;T, E&gt;&gt; and my_result_of_async_call()?... for Result&lt;Future&lt;T&gt;, E&gt; But, that has a lot of issues because then you end up with method chaining that has 4 dots, or potentially more if you for some reason had Future&lt;Future&lt;T&gt;&gt;: my_async_call()....field_a. Eh, that starts to get ugly and hard to read :/ Huh? It means that everywhere else.
A popular elasticsearch client for Scala has [.await](https://github.com/sksamuel/elastic4s#example-application), and it's pretty great. And in general, modern languages can - and do - hide complexity. With a strong type system I don't see the problem of accidentally not noticing an await. (Because if your function returns a Future, but that somehow along the lines gets awaited into a Result/Item, then you'll hear about it from the compiler.) &amp;#x200B; Powerful abstractions have serious consequences. It was always the case, other languages simply made it easy to forget this. (You can do the anything in C and you can make it as innocent looking as you wish, and the compiler won't say a thing.)
Yeah, I'll happily grant you that.
I'm not sold on solely using the \`@\` symbol, especially because there's a plan is to expand the postfix syntax to other constructs. But for the very reason that match will probably get the same treatment I think it would make sense to introduce a special symbol instead of the classic dot to delimit the keyword (maybe even the \`@\` symbol `let str_response = (http::get(url)@await)?.to_string();`)
Nice write-up. I also believe that a method is a clean solution to the composability problem, and am somewhat torn between method call or await prefix keyword (or await! psuedo-macro). However, it could also be a hybrid: \`fn await()\` could be implemented in rust as a simple wrapper around a less composable syntax, like \`await self\`.
I find the @ symbol just thrown out there, alone pretty weird of being read. I think the syntax would make Rust kinda harder of being understood. foo@await would be nicer indeed
Ah I thought you meant My type as in dyn Trait. Didn't have coffee yet.
IMHO the field variant is one of the worst. Method variant would be much better. Before reading boats writeup my favorite variant was the postfix macro but after reading I think the prefix keyword would be the best. I hope the field variant is not final.
If there was a prefix keyword, then a postfix macro could trivially transform into the prefix syntax.
I remain mostly unconvinced about this. That's a lot of methods being chained, which if you do that a lot means your code is likely going to be hard to understand. At least following my experiences with other languages. I know rust treats things a bit differently and can get away with it more, but I think this is going to lead to people trying to code golf way, way too much. You could even say that there is value in having syntax that encourages people to split up their long method chains. Besides, I have so rarely run into the need to do this that it's laughable. A decade of programming and its come up only a few times for me. Why should rust be special? Why should rust encourage long method chains? Why shouldn't rust encourage assigning names to more expressions?
There‚Äôs a very common case in the browser JavaScript API. AJAX requests (via `fetch`) are obviously returning a Promise (aka Future). If you want to parse the response as JSON, the `.json()` call on the response object also returns a Promise for some reason that resolves to the JSON object.
``` async fn fetch_things() -&gt; Result&lt;Value, Box&lt;dyn Error&gt;&gt; { let client = Client::new(); let mut resp = client.get("https://api.tonsser.com/bootstrap").send().await?; let json = resp.json().await?; Ok(json) } fn main() { tokio::run_async(async { let json = fetch_things().await.unwrap(); println!("{}", serde_json::to_string_pretty(&amp;json).unwrap()); }); } ``` üòçüòçüòç
Hi, I only wrote my first rust program yesterday so apologies if I missed the point, but you could do something like [this](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a282ef5f3ee79a2b86cbc60c4a761195)? You have to explicitly opt-in by implementing the default-based trait, and I guess this only works if your choices are all default or all non-default, you can't pick and mix for different defaultable aspects.
I agree. If consistency within the language is a priority (which it _should_ be, in my opinion), this is by far the best solution. This way, .match!(), .if!(), etc. could also be implemented as macros instead.
If there's one thing I learned about Rust and its core dev team in the years that I've used Rust, is that simplicity is lower in their values. Safety, performance, expressivity are at the top; good ergonomics is also quite high. I agree that `(away foo())?` would have been the right choice *if you value simplicity over ergonomics.* It's not wrong to value simplicity less than other values, but when that clashes with your own set of values, that's when there's tension.
If someone is so enormously close minded that some tiny syntax detail like this makes a difference, they shouldn't ever leave their home, the outdoors might present them with something too weird for them to handle! But don't worry, people coming from C++ should be battle hardened veterans of dealing with cl the most crazy syntax, so they should be fine. Nothing in any conceivable future version of rust will ever be remotely as weird as C++ lambda syntax.
One thing I find frustrating about this is that keywords are not treated as keywords, methods as methods and macros as macros. If it is keyword, make it consistent with other keywords... See how it goes and implement some syntactic sugar later on.
FWIW, [this](https://www.reddit.com/r/rust/comments/bmhmtw/what_postfix_macro_could_bring_to_rust_asyncawait/) seems like a *really* nice and clever way of going about it, one that I haven't seen suggested previously. In short: introduce a prefix await keyword + a general postfix macro feature. Each of these on its own is a pretty natural and straightforward extension of Rust's syntax, they don't feel like pre-emptive special-casing. And once both of these are available, implementing a postfix .await!() macro is simple, consistent and elegantly allows for ergonomic chaining-style code.
Just because immediate mode is deprecated, doesn't mean you can't learn or use it. Jon Blow, creator of Braid and The Witness, still always codes his prototypes with immediate mode graphics, and upgrades them to VBOs later on. So you don't really have to focus on performance right away - you can learn the current 3D graphics paradigm later.
I kinda prefer a prefix syntax over a postfix one. It makes a bit more sense when reading.
I agree that this makes a lot of sense in **function arguments**. However, it's completely fine to use bool as the **return type**. Some examples are `char::is_whitespace`, `str::contains` and `Iterator::all`. Boolean expressions can ‚Äì unlike enums ‚Äì be combined with `&amp;&amp;` and `||`, and are easier to use in `if` expressions. That `foo(3, false)` is suboptimal, is true for *every* programming language.
So what are the options of which tokens are passed to a postfix macro, and what are the up- and downsides of those?
You don't have to call people who value consistency close minded.
This is a wrong analogy. You don't need dedicated method call syntax to make `my_struct_.method()` work; all that is necessary is support for first-class functions. Your `method` can very well be a field whose apply the function call operator against.
Explicit flow control is important to systems programmers. Hiding flow control is almost always a bad thing, and this is why exceptions in C++ are still controversial to this day (many major C++ projects still avoid them). Consider also that things such as ternary conditions are frowned upon except for very low-complexity situations. To then go and let some of the most disruptive types of flow control be a syntactical special-case, hidden away at the end of lines, looking exactly like another extremely common language feature (field access)... That decision is incredibly baffling. If someone is writing complex one-liners containing async code, they are probably coming from a Node.js background, where that kind of stuff is probably just fine. But that's a different "market". Or I thought it was. I suspect that people who are attracted to Rust are exactly the people who want to reason precisely about flow control, both while writing, reviewing, and debugging code. I would personally reject any PR containing more than one ‚Äôawait‚Äô per line immediately. There is zero justification for ever doing that in my book. Anything beyond very minimal composition (such as dealing with a single ‚ÄôResult‚Äô or ‚ÄôOption‚Äô) also seems like a major code smell.
Chaining is also bad for debugging. Besides builders maybe, I tend to think it's an anti-pattern more often than not.
While I don‚Äôt think chaining is always better than splitting, I think chaining has its use case. By chaining, it‚Äôs very clear that you are transforming one (or several) item to another. None of the intermediate state can be used elsewhere. The chained code can be read from start to end. The logic is guaranteed to be a straight line. The same is not always true for split code. Because, unavoidably, you will have some intermediate variables. Those variables may or may not directly be used by the line below. And may or may not be used in other lines far down below. While the execution path is a straight line, the logic may not be. Now, to be honest with you. The reason I stated above is not my motivation of chaining code. It‚Äôs just me trying to analyse why I find chained code (sometimes) more readable than split code.
Maybe make $tt.m!($tt, $tt, ...) equivalent to m!($tt, $tt, $tt, ...).
Why not have actual monads with Idris's bang notation, which is a generalization of the async syntax?
There are some cases where chaining lends itself to better code. I think mainly for builders, streams, and similar. I've almost never come across chained async code.
I like this solution. Postfix macro greatly improves readability compared to field-like keyword.
\&gt; You'd just await it before returning instead. &amp;#x200B; Well, if Rust can pull it off, then you wouldn't have to .await "ever", because you will be able to write fully event-driven code. &amp;#x200B; For example, reactive Scala code is full of "[for comprehensions](http://buransky.com/scala/scala-for-comprehension-with-concurrently-running-futures/)", which are linearized .then .then .then things. (Which happens to be a special case of using the Future monad, which is great because you can use the for-comprehension to do whatever you want while keeping the abstraction container, which happens to be a Future, but it could be anything, such as Result, and [see also](https://varkor.github.io/blog/2019/03/28/idiomatic-monads-in-rust.html) for ... a bit too much detail.)
I agree. I honestly don‚Äôt feel very strongly about field vs method syntax. I just like postfix :)
While that could work. That‚Äôs basically saying: don‚Äôt be evil, macro developers. The token before the dot could be transformed, evaluated multiple times, which will be a surprising behaviour to the macro users. So I don‚Äôt think you should take the token before dot as simply tokens. They should be taken as an evaluated expression. That way, it can‚Äôt be evaluated multiple times or modified in the macro.
Splitting up long chains and assigning names to them can make your code more understandable, maintainable, refactorable, and debuggable. Usually, if I have lots of async calls I would want some way to log in between, or at least put a debugger on each of those async calls individually. The only case I can think of in real world code where chained asyncs is useful with javascript's fetch api, since performing the fetch and getting the json response are both async operations.
&gt; you wouldn't have to .await "ever", because you will be able to write fully event-driven code That doesn't really sound at all feasible (or a good idea) in a systems programming language that's aiming for zero-cost abstractions, since async isn't going to be zero-cost compared to synchronous code, nor necessarily desirable in every situation. &gt;reactive Scala code is full of "for comprehensions", which are linearized .then .then .then things Isn't that basically the same as what we've had in Rust until now, with the whole .and_then(...) chaining? What we're trying to get away from by having first-class async and await support built into the language?
Thank you, I appreciate your thoughts! I definitely do want to learn graphics at some point.
Thank you, I appreciate your thoughts! I definitely do want to learn graphics at some point.
Well, maybe, maybe not. Though coming from TypeScript I just wasted a hour yesterday by putting await in front of things and parentheses here and there. It was not a happy hour. &amp;#x200B; .await is simple. (That's actually one of its alleged downsides, because it's hard to notice. But I think this claim does not make much sense due to the strong typing of Rust. If there's an await then the function returns an Item/Result, not a Future (unless of course the Item itself was a Future, but each await decreases the number of Futures in the signature), and thus going into the function you know there must be an await somewhere.) There's an expression/struct/variable and then that is being awaited. Rust supports return-less functions, basically almost preferring a strict left to right code reading flow. &amp;#x200B; This minimizes the mental boxing needed. If you encounter an await you have to then parse what is being awaited. Which might be a big expression. But if await is at the end, it simply marks a point where whatever precedes it must be a Future-like thing that gets awaited there. &amp;#x200B; And ... so, await is nice, but you'll want to control timeouts anyhow. And eventually write fully event driven code, with as few explicit await points as possible. (At least that's what happened in Scala. Where the big Await construct has to be imported into scope, because it's use is discouraged, because there are better ways. Of course Rust is still building its async empire.)
I am in prefix camp, but I can imagine writing this over and over would be much better with postfix. And now that I think about it, we do all sorts of things in Haskell to avoid nesting.
I started implementing a macro for enabling postfix operations. It's a blanket and initial impl, but you can use "postfix match" already: https://github.com/swfsql/sonic-spin/blob/master/tests/match.rs
The weirdest thing in this whole story, is not that the postfix syntax was prefered. As you said, it makes easier to nest await calls. The weirdest, IMO, is to stick to the dot sigil while any other could be used (`@`, `&lt;-`, `-&gt;`, etc.)
And whose phd thesis is some kind of concurrent database whatever, that's the fastest in the world or something. :) ( [https://github.com/mit-pdos/noria](https://github.com/mit-pdos/noria) , of course the catch is that it's not like those other databases, it's a big materialized view engine basically)
I think postfix if would work like this: let value = 42; let a = (value % 2 != 0).if { on_odd() } else { on_even() }; which seems a bit silly for this conditional expression but for methods that return booleans I can see it being quite elegant.
&gt; The first question that pops to mind is probably "OK, what code runs here when I call this method?". And the answer is literally "code from whatever coroutine happens to be picked". In my mind this does not fit at all with how a method call should work. Signifying that something special is happening via an operator can be beneficial. But the same is true if you run `thread::sleep()` or `mutex.lock()` in a multi-threaded program. All this is doing is providing a different mechanism for suspending the current computation and yielding to let other computation run until some future point when we're ready to continue.
Hm. Because Emacs code is not in Rust, probably there is no issue with reading that code. However, the question is, are specifications copyrightable? If no, then org-rs is simply an implementation of that specification, if yes, well. Then the fair use question comes up. The Oracle v Google case might be eventually heard by the US Supreme Court (and they can still rule just in that particular case, that is effectively not-create new law, which will not help resolve the legal ambiguity), and that's of course just one jurisdiction...
`@` is noisy, the character is simply _ugly_, the code with `@` is very hard to read (I think this is because `@` is graphically heavy), and the most important, it has already some meaning which is totally different and not related with async/await. I agree that `.await` looks weird and is magical to the extreme and reminds me magic methods from php, but if I have to choose between only `.await` and any option with `@`, I blindly choose `.await`. And my favorite is postfix macro implemented as compiler built-in, which enables .match! and others to be implemented as real macros and not as compiler feature.
Ah, you‚Äôre using the old Reddit, aren‚Äôt you? :D I‚Äôll update.
\&gt; I believe that given the complexity of the grammar this is the *only* way to implement a fully-functioning algorithm. &amp;#x200B; It's always possible to reverse engineer the code, or simply do a very large scale fuzzing to construct a "specification" or org-mode. &amp;#x200B; Of course, at that point the endeavor would probably not worth it.
&gt; Because Emacs code is not in Rust, probably there is no issue with reading that code. I wouldn't necessarily make this assumption. &gt; However, the question is, are specifications copyrightable? In the "clean room" example I gave, you have two parties collaborating with each other to reach a common end. The presumption is that the party who created the specification grants it under a license that is favorable to said end.
Thank you, this clears up a lot. &gt; Rem on i32 is defined for zero, one or both of the operands being references Righto - where do I go to find this out? I've since visited [this page](https://doc.rust-lang.org/beta/std/ops/trait.Rem.html) and read the "impl Rem&lt;i32&gt; for i32" section but it seemed quite terse. My eyes just glazed over when I clicked to look at the source &gt; You're using pattern matching to peel off the reference Gotcha. I think the big issue for me was not understanding how widespread pattern matching was (the book covers it well, but if there's an area that discusses the reference peeling I missed it) &gt; Regarding std::slice::Iter, while the type parameter is T, if you look at its implementation of the Iterator trait, the associated Item type is &amp;'a T, which is the type returned by next(). Thanks. Bit lost with associated types (this is what it is right?) at the moment but hope to revisit this once I've done more reading.
&gt;That's a lot of methods being chained, which if you do that a lot means your code is likely going to be hard to understand. That's been my thought as well. Chaining has its uses in the case of builders and iterator pipelines, but outside of that I feel like it's usually a code smell to chain a large number of method calls, as it just makes code less readable and more impractical to debug. Storing each major transformation in an informatively named intermediate variable makes it more clear which components and/or types are involved.
I have to say, after seeing one example of changing multiple awaits I was kind of sold on the postfix syntax and I personally feel using another separator makes it look more cluttered. For example, I find it easier to parse foo.async_a().await?.async_b().await than foo.async_a()@await?.async_b()@await
&gt; `.await` looks so weird. I personally will be embarrassed to explain to people that are considering the language why the await syntax looks like accessing a field. This.
\&gt; I wouldn't necessarily make this assumption. I wasn't aware that OP basically translated the Lisp program to Rust, which makes it likely to [fail the test](https://www.reddit.com/r/rust/comments/bm5rwv/orgrs_legally_possible_relicense_to_lgpl/emuxw1k/) described by u/annodomini.
I like it much better than the "magic field" approach. But I still prefer the straightforward prefix keyword.
Yes, I tend to agree with you.
Agreed.
I also think some decisions were rejected for the wrong reasons. For instance, the prefix `await` keyword would be good, but there‚Äôs the `(await foo)?` problem (it happens a lot, I‚Äôve been told). On IRC, people suggested to add a special syntax for this case: `await? foo == (await foo)?`. I thought it would have been way better than the `.await` syntax. Yes, chaining isn‚Äôt as beautiful as with `?`. But one small step first. Before the `Try` trait and `?`, we had the `try!()` macro. It wasn‚Äôt as good as what we have now, but at least we took the right and enough time to explore how to use it. I think that `await` syntax bikeshedding madness is the wrong way to go. We should even, maybe, start with `await!()` and see how people react and get frustrated by it in the first place. Trying to ‚Äúsolve every problems in the first round‚Äù makes me concerned, not because I don‚Äôt trust the teams‚Äô works on this, but because I don‚Äôt trust we can clearly have the right idea in the first place without having lots of people testing and trying.
I agree, but here combinators also work, and to me it's not worth introducing a new kind of syntax just for these cases.
I think it should be straightforward: the macro must receive the 'self' token as an `$expr`. The tokens that contain that expression are consistent with whatever is necessary to evaluate to the expected behavior with method calls. eg `(2 + 3).method!()` have `(2 + 3)` as the (opaque to macros) expression variable because that is what would be received if method were a normal method. Once the tokens have been made sufficiently opaque, you can start thinking about what happens if the macro evaluates the `$expr` multiple times. Most flexible is to have macro developers explicitly write `match $expr { e =&gt; ... }` to force only a single evaluation. Will this work? I don't know, perhaps there are more complexities with capturing the _self_ expression. That case could fall back to having the compiler insert the above match statement and the `$expr` passed to the macro is the temporary (eg. `e` in the earlier example). How will the syntax look? Either hack it in the current macro system (this will probably entail weird scoping rules) or wait until the proper `macro` syntax can be fleshed out. In which case we should be hopeful for a full integration in the type system. Eg treating macro items in `impl` scope as scoped to those implementation, dare I even hope to have macros in traits and have it all work with type inference. That seems like an absolutely massive undertaking, I'd personally already be happy with the 'hacked in macro rules' approach.
If you agree with OP's post vote here (https://internals.rust-lang.org/t/async-await-syntax-straw-poll/9954/20) for method call style syntax!
I've been thinking of ".await!" as well (without the "()" that is), which would distinguish it from a normal field access. There are probably downsides to this, but at least it wouldn't be confused with a field access.
Rust is targeting the effective network services problem domain too (basically the same domain that is now being covered by Go programs), and there throughput might be more important than exact fine-grained determinism. &amp;#x200B; Yes, it's like the and\_then chaining. As far as I know first class async/await support is important to be able to provide better ergonomics for futures. (Currently they need to be 'static, right? And the compiler throws not so nice error messages.) So I think the "await" part of async is kind of a coincidental red herring in the big picture.
It's the lifetime. You didn't post all of your code, so I ended up re-implementing some of it, then modified lifetimes to make it work. You can find the working code [on the playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4cbb5c80bea32fad37583b70be451b0b). I believe the secret is the function signature `fn next&lt;'b, 'c: 'b&gt;(&amp;'c mut self) -&gt; Option&lt;(&amp;'b mut T, Vec&lt;&amp;'b T&gt;)&gt;`, which establishes two lifetimes: one for the iterator, and one for the value that we return from our pseudoiterator. We say `'c: 'b` to link the two lifetimes together, saying that lifetime `'c` (that of the iterator) must be valid for at least as long as `'b`, but `'b` can be shorter. (I believe this is the only place in Rust where we see subtyping. In a language like Java, we might write the relation between two types as `Cat: Animal` which would tell us that `Cat` subclasses `Animal`, and so a `Cat` can be used anywhere an `Animal` can: a `Cat` has a superset of `Animal`'s behaviours. In Rust, you can say `'longer: 'shorter`: anywhere that `'shorter` is safe, `'longer` will be too, and the amount of time that `'longer` will be valid is a superset of `'shorter`.)
As much as I dislike the .await syntax, I'm really not a fan of the idea of introducing yet another special symbol. While async/await is great and useful, it doesn't seem nearly fundamental enough to justify giving it a special symbol. If we're going with a postfix, I think the .await!() postfix macro syntax is the most intuitive and consistent alternative presented so far. At least it has the ! to indicate that it's introducing code generation.
As a beginner struggling my way through references and types and the api and... basically everything, when I do a `let x = ...` or `for x in ...` or.. basically anything, is there a way I can easily tell what type my x is? At the moment I'm going with the peasant way of just forcing doing a `let x : ()` and letting the compiler chastise me. I'm guessing this is more of a tooling thing - I'm using VSCode with the rust(rls) extension if that helps. But not necessarily married to that.
You can find it on the page for [i32](https://doc.rust-lang.org/stable/std/primitive.i32.html#impl-Rem%3Ci32%3E), specifically in the list of all its trait implementations. There are four entries, for `i32 % i32`, `i32 % &amp;i32`, `&amp;i32 % i32` and `&amp;i32 % &amp;i32`.
I know Haskell well; and I think it's one of the best engineered and designed programming languages ever made. It gets away with doing things in quite a light-weight fashion. It is already ergonomic and terse enough. Do notation is also orthogonal and doesn't require any special DSLs for specific monads. Even better, Haskell enforces the separation of church and state. That makes maintainability and readability of programs that much easier. However, Rust is not and cannot be Haskell. The detail oriented ("close to metal") nature of Rust's operational semantics has consequences that does not allow it the same ergonomic feeling as Haskell does. Region typing and memory layout control works against abstraction and modularity. &gt; Languages that allow code to manipulate the context in which it appears but that do nothing to mark that code as special in some way have chosen an inferior (but perhaps more 'ergonomic') approach to rust. I think `async fn` and `.await` (especially `.await?`) offers plenty of markers.
&gt; However, repetition does not necessarily indicate that people haven't done any background reading - people make points for all kinds of reasons, including believing that their objection is more important than is being given credit for (perhaps because it's not been articulated well enough). Or sometimes just to try to explain themselves in the hope of attracting a rebuttal specific enough to help them. Sure; I generally don't believe these, especially the first one, is a good reason to repeat yourself. I feel it is more or less the same as "shouting the loudest".
You've already made this point before. I believe you've also been made aware that Rust is not designed as a democracy.