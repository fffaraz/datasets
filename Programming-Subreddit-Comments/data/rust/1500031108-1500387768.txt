 Thanks so much!! I've copy pasted your gist and started modifying it. Now it validates some things from the Info and the Contact structs alongside the main properties. https://github.com/JordiPolo/oatool/blob/master/openapi_validation/src/lib.rs You'll see many changes. r.assert(...) is my way to avoid dealing with vectors as I need somehow merge information from the Info object into the main object. Also took assert_eq out as this is only relevant for options. I'm still not happy with the code, the display implementation for instance is kind of terrible and things seems too complicated for what it is but it's a huuuge step forward, thanks so much! Any further comments, of course welcomed. 
I am not convinced with the type-safety argument: you won't get *type errors*, but you'll still get errors. Take the `add` function: using `unreachable!()` means you're not using the languages' types to prove your invariants (even though in this case you could), and more importantly the *semantics* of the program are unhelpful: (Celsius(1) + Kelvin(274.15)).to_celsius() → Celsius(2) (Kelvin(274.15) + Celsius(1)).to_celsius() → Celsius(275.15999999999997) Frankly, even `Celsius(1) + Celsius(1)` is unhelpful. What does it mean to add two fixed points?
It was a reduced example, in my real code I need two vec's
TIL about unzip. Thanks! For some reason I think the ordering of the zip iterator is surprising me... but that's for after I sleep some lol
It seems like collecting on a pair like that would have an impl already. I guess this was the question I was ultimately asking. Thanks tho
Well for the http part take a look at reqwest. As you are blocking/waiting anyway you can just use the latest stable reqwest. I don't know If the tokio reactor is supposed to be recreated for every request you are sending. Also I think It's not good to recreate a the Https connector for every request as It uses a threadpool for dns resolving. Just using reqwest will fix this. Also I would drop all println and use a loggin library for a web app. In the function port() you can use unwrap_or which is by far less code. You actually don't need String::from(format!(...)) you can just write format!(...). It would be much nicer If Color would be an enum but that's just my opinion. Also here is something you should not do: let badge_url = Url::parse(&amp;badge).unwrap() Badge contains external text from the version you are downloading. This may fail and panic. You should never unwrap unless It's something like an assertion where you know If this unwrap fails your library has a bug.
Thanks, that's great feedback! unwrap is something I'm just getting my head round, and honestly the Tokio stuff was pure cargo-culting from the hyper docs. Reqwest sounds like the sort of simple interface that'll do everything I need.
LLVM used to have C as a compilation target, but I think it was removed at some point? Regardless, I think a more interesting approach might be to either add additional architectures to LLVM (as you already mention) or perhaps build a compiler that can translate MIR to GIMPLE.
Relevant: fsharp has static type checking for units of measure. https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure Although i haven't looked into how are they implemented. 
This is a relevant email from the LLVM mailing list: http://lists.llvm.org/pipermail/llvm-dev/2016-May/099663.html &gt; The other back end was the C back end. This was largely discontinued because of lack of interest, but it always had problems because LLVM IR is strictly more expressive than C. There are many LLVM intrinsics that can’t be represented by ISO C, though a lot have GNU builtins that can be used instead. C can’t represent exception-handling constructs at all. The problem lies in the assumption that C is a magic low level language which can express _everything_, while this is just not true.
The OpenAPI standard specifies keys and specific values for its json or yaml files. That can be deserialized by serde. But it also allows any key name which starts with "x-" , for instance "x-myextension" to be added to the document, their names and contents (inside you can have an object with more keys) are arbitrary. Is it possible to use Serde to deserialize this if I do not know the name or structure beforehand? If so, how? it seems I need a predefined struct with the name. 
There is a library called libgccjit which (despite its name) can be used for compilation using GCC. It might be possible to add it as an optional backend to rustc alongside LLVM. Relevant thread: https://users.rust-lang.org/t/rust-front-end-to-gcc/11601/12
You can also create a `bin/` folder in a lib crate. Then you can develop Ox as a library and test it as a binary using the library!
I'm not sure I follow. Why is `Celsius(1) + Celsius(1)` unhelpful? It is perfectly well-defined physically. `(Kelvin(274.15) + Celsius(1)).to_celsius()` giving the wrong result looks like a bug to me.
I made my review an issue :)
&gt; Why is `Celsius(1) + Celsius(1)` unhelpful? It is perfectly well-defined physically. It's not well-defined. Temperature units are especially weird because of the non-zero starting point. In other words, a "temperature difference" is a different thing than a "temperature". If you're talking about temperature differences, one Kelvin is the same as one degree Celsius. If you're talking about actual temperatures, they are different. This is not the case for other units. You can always add one meter to one foot and get the right result, because their starting points are all the same (zero). Another "unit" that is very common in programming with behavior similar to temperature is time. There you also have time points (such as "today at 2h") and time differences (durations, such as "2 hours"). In the same way you can't add two dates together, you also can't add two temperatures together. You can, however, add temperature+difference or difference+difference. All this, interestingly enough, causes problems when calculating by hand, but it can easily be solved using types. You just need separate types for values (temperature, time) and differences. That's why Rust has `Instant` and `Duration` (https://doc.rust-lang.org/std/time/), and Python has `datetime` and `timedelta` (https://docs.python.org/3/library/datetime.html). To work with temperature in anything other than Kelvins, you have to use the same semantics to your temperature type. 
In general I think this is a rather bad example to teach enums with. To me it seems temperature is something best suited to be stored in Kelvin, and converted from/to other units for input/display only.
&gt; It's not well-defined. Well, if you define it such that it should have the same result as when converting to Kelvin before adding, and then converting back to Celsius, it is well-defined, isn't it? &gt; There you also have time points (such as "today at 2h") and time differences (durations, such as "2 hours"). I think this distinction is arbitrary. You could do the same for distances. (Physically, you can even use the same units for time and distance.) &gt; In the same way you can't add two dates together Again, I would argue that you can, i.e. by converting to Unix time before adding them, and then converting back. &gt; You just need separate types for values (temperature, time) and differences. This is just using the type system to avoid confusing relative and absolute values. Mathematically, I don't think this distinction is required for soundness.
There's still a broken code block: ctrl-f ``` to find it near the end of the post.
It's hard to say without knowing when you tried to do this. Right now, you need the 2015 tools, the 2017 ones aren't supported by default yet. It totally works if you run vcvars, or if you wait until Thursday, for the next release. Generally speaking Windows stuff works really well for me.
You can define it, of course. Doesn't mean it's going to be useful, or that it's going to be what users expect. In real life you never add two actual temperatures together. Just like you can add two dates together, the result by your definition won't make sense (today+tomorrow=some day in 2064, what?). Or if today we had 30 degrees, and tomorrow will be 2 degrees hotter, we will have 300 degrees? You are right that you could do the same for distance, you can add two distances, but not two positions. However, the use of absolute position is rare: when you hear "one meter", you almost always think about the length or distance. But when you hear "two degrees Celsius", it can be either today's temperature, or how much hotter it was today than yesterday. The distinction between points and differences is definitely required if you want to prevent nonsense results. 
That's because these types are not enough to represent temperature, you need the distinction between values (where 0C = 275K) and differences (where 1C = 1K). And then you can implement Add as `value +/- difference =&gt; value`, `value - value =&gt; difference`, `difference +/- difference =&gt; difference`. See `Instant` and `Duration` for the same concept. 
You could also store it in everyone's favorite unit, Rankine.
That was forgotten in the guide during initial announcement. Sorry for that! If that was an issue for you, please have another look and submit a talk.
[So does Rust!](https://crates.io/crates/dimensioned) There are also others, but I like mine the best ;)
I've got another question here: are you free to talk about which systems those are? Also, is the processor architecture supported by Rust? It's perfectly feasible to build object files using Rust and then linking them into a harness built in C, using the target GCC toolchain for final assembly.
oops. thanks
There is https://github.com/thepowersgang/mrustc which converts Rust to C code. Its still very much in the development though.
Adding Celsius isn't well defined because "3 degrees Celsius" has two different meanings. Here are some examples; what should each of the following be in Kelvin? x = 3 °C y = 2 °C + x z = 1 °C + y w = 100 K + z What if you only had the line x = 3 °C Would that be any different? Edit: How about a = 1 °F + 2 °C b = 2 °C + 1 °F Should they be the same? Different? What should it be?
&gt; Are you looking for contributors for the actor library? Absolutely. The code is still very messy right now. And the produced actors are built on the 'fibers' crate, which I *really* want to move from but have no alternative. My future plan is to investigate rewriting a fibers-like solution. There's a lot of places to go, I'd be happy to discuss any of it/ help you contribute.
Related to the point about calculatuing the Ideal Gas Law right before the "Conclusion" section, I think using individual structs and the `Into`/`From` traits is probably the best of both worlds here. You'd define the three structs: pub struct Celsius(f64); pub struct Fahrenheit(f64); pub struct Kelvin(f64); Then implement `From` for all the combinations (only gonna put the impls for `Celsius` here but you get the idea): impl From&lt;Fahrenheit&gt; for Celsius { fn from(f: Fahrenheit) -&gt; Celsius { f.to_celsius() // defined in `impl Fahrenheit {}` } } impl From&lt;Kelvin&gt; for Celsius { fn from(k: Kelvin) -&gt; Celsius { k.to_celsius() // defined in `impl Kelvin {}` } } impl From&lt;Celsius&gt; for Celsius { fn from(c: Celsius) -&gt; Celsius { c } } Then instead of having your `ideal_gas_law` function take a `Temperature` or `Celsius` you would have it take `Into&lt;Celsius&gt;`. fn ideal_gas_law&lt;C: Into&lt;Celsius&gt;&gt;(temp: C) -&gt; Celsius { let temp = temp.into(); // do calculation here } Now you can just pass the function any of the 3 units types ideal_gas_law(Fahrenheit(1.0)) ideal_gas_law(Kelvin(1.0)) ideal_gas_law(Celsius(1.0)) You still have to remember to call `.into()` at the beginning of the function like you would have to remember to call `.to_celsius()` if you were using a`Temperature` enum, but trying to use the value as a `Celsius` later in the function would be a type error instead of a logic error.
IIRC, something very similar to the tree example is mentioned in the Nomicon, which is that you can implement a Hashset if you already have a hashmap by giving the latter a value type of `()`. However, your example of the minmax algorithm doesn't seem to of much benefit. Sure, you technically have one function, but since in the two-function case, one of them is a one-liner projection of the tuple values, IMO it's more readable than the generic function. I think it also makes your conceptually less understandable because your function winds up returning a `(Option&lt;Move&gt;, i8)`, whereas you're _actually_ returning a `(Move, i8)` and the `None` is just internal bookkeeping. (That said, I'm not entirely sure how to get around that, might come back to this if I have any ideas.)
Good to see you making progress! I've had a brief look at the code, and I really like the idea of using `ValidationResults' to carry the error state. Some nits: * `&amp;x[0..x.len()]` is just `&amp;x[..]`. * `add` under `ValidationResults` can be implemented using `assert` instead of manually appending to `errors`. * All these `unwrap`s under the `Display` implementation can be replaced with `?`. * Avoid `unwrap` in `is_match`, can be done with a combination of `and_then`, `map`, and `ok_or`. * Anytime you find yourself using `and_then(|_| Some(...`, you can use `map` instead. I understand that things may look complicated, but you've got yourself a nice API at least! 
agreed; since different units of temperature represent the same kind of value, they should be stored as the same type underneath. pub struct Temperature { value: f64 } impl Temperature { pub fn from_kelvin(k: f64) -&gt; Temperature { Temperature { value: k } } pub fn from_celsius(c: f64) -&gt; Temperature { Temperature { value: c + 273.15 } } pub fn from_fahrenheit(f: f64) -&gt; Temperature { Temperature { value: (f + 459.67) * (5.0 / 9.0) } } } and as others have said, you can't add raw Temperature values- the values in this article are nonsensical. introduce a TemperatureDelta struct that handles math. a delta of 1°C can be added to a temperature of 250K but you can't add the temperature 1°C to 250K. then deltas can also be retrieved from any two temperatures. this example illustrates type safety features in rust better because it can force you to only do temperature math with the correct types of values. don't want to be too hard on the author because the concept they set out to demonstrate is good, this particular example just doesn't map well to real life. maybe a better example might involve struct/enum wrappers around i32 as keys/identifiers for a database?
For me, I can imagine message passing between [green] threads as like some objects/people passing messages to each other and responding. Async/await on the other hand is like people doing some actions, being interrupted at certain points in the actions, and then resuming, which for me is more complex to reason about. Of course message passing involves this under the hood too, but because it's under the hood one doesn't need to think of it directly to understand the program's semantics (at the cost of less than optimal performance). Message passing also has a neat formalism: https://en.wikipedia.org/wiki/Communicating_sequential_processes.
I had never heard of GIMPLE before. Reading up on it I get a vague sense of what it is. Could you maybe give a quick summary of it? Seems like a sort of IR but it seems different as well.
The easy way to do it is: 1. Select all in your editor. 2. Press tab to indent (reddit comments treat tabs as four spaces). 3. Copy. 4. Undo. 5. Paste into reddit.
Macros are only hygienic regarding local variable bindings (like `_a` in your example). But names of items (functions, types, modules, etc) are not included.
There is also [`uom`](https://github.com/iliekturtles/uom) which I've been slowly working on. And relevant to this article I've been working on thermodynamic temperature and temperature interval right now. Rather than working with [measurement units](http://jcgm.bipm.org/vim/en/1.9.html) (meter, kilometer, foot, mile, ...) `uom` works with [quantities](http://jcgm.bipm.org/vim/en/1.1.html) (length, mass, time, ...). This simplifies usage because units are only involved at interface boundaries: the rest of your code only needs to be concerned about the quantities involved. This also makes operations on quantities (+, -, \*, /, ...) have zero runtime cost&lt;sup&gt;1&lt;/sup&gt; over using the raw storage type (e.g. `f32`). `uom` normalizes values to the [base unit](http://jcgm.bipm.org/vim/en/1.10.html) for the quantity. Alternative base units can be used by executing the macro defined for the system of quantities (`ISQ!` for the SI). `uom` supports both `f32` and `f64` as the underlying storage type. 1. Once codegen bug [#38269](https://github.com/rust-lang/rust/issues/38269) is resolved.
&gt; Travel coverage of at least 400 Euros out of Europe, 800 otherwise. Did you get those numbers backwards?
As I understand it... 1. `rustc` currently works like this: 1. Translate Rust code into HIR 2. Perform optimizations/checks that are easiest to do in HIR 3. Translate HIR to MIR 4. Perform optimizations/checks that are easiest to do in MIR 5. Translate MIR to LLVM IR. 6. Hand off to LLVM to do the rest. 2. GIMPLE is GCC's equivalent to LLVM IR. 3. thiez is suggesting replacing steps 5 and 6 with "Translate MIR to GIMPLE" and "Hand off to GCC to do the rest". Trivia: GIMPLE is actually a [family of 2.5 IR forms](https://gcc.gnu.org/wiki/GIMPLE) (high-level, low-level, and SSA-form low-level), which code passes through in a manner similar to how Rust uses HIR, MIR, and LLVM IR.
&gt; In real life you never add two actual temperatures together. I disagree, let me provide a counter example: If I mix equal amounts of water with temperatures of 20° Celsius and 30° Celsius, what will we be the final temperature? To calculate the answer you can add two actual temperatures, independent of the units. &gt; today+tomorrow=some day in 2064, what? That depends on your frame of reference, or which time you define as zero. That does not imply it makes no sense to add them, that depends on context. For example you might want to calculate the average between today and tomorrow (like for temperatures). &gt; Or if today we had 30 degrees, and tomorrow will be 2 degrees hotter, we will have 300 degrees? Not sure what you mean, why would you get 300 degrees? &gt; But when you hear "two degrees Celsius", it can be either today's temperature, or how much hotter it was today than yesterday. It could be many other things as well, depending on context. It's fine that you want to distinguish between the two cases, but I think it is an arbitrary choice.
I got the wording backwards. "for traveling from Europe" Fixed, thanks.
&gt; since different units of temperature represent the same kind of value Unit categories in general, they're also an interesting use case [for phantom types](https://oleb.net/blog/2016/08/measurements-and-units-with-phantom-types/).
You are right, there is some ambiguity. The definition I proposed would for example not work for calculating the average temperature, because you would pick up 273.15 °C for each summation.
Regarding the mixing problem according to [this](http://www.engineeringtoolbox.com/mixing-fluids-temperature-mass-d_1785.html) source the equation does not involve adding thermodynamic temperatures. Doing dimensional analysis the thermodynamic temperature dimension in the specific heat and thermodynamic temperature cancel each other. You're adding energy in the numerator and energy/thermodynamic temperature in the denominator and the energy components cancel out leaving thermodynamic temperature. thermodynamic temperature = (((mass) * (energy / (mass * thermodynamic temperature)) * thermodynamic temperature) + ...) / (((mass) * (energy / (mass * thermodynamic temperature))) + ...) thermodynamic temperature = (energy + ...) / ((energy / thermodynamic temperature) + ...) thermodynamic temperature = (energy + ...) * ((thermodynamic temperature / energy) + ...) thermodynamic temperature = thermodynamic temperature
Applying the formula you linked to my example makes the additional terms cancel out, leaving the ordinary average, where you add temperatures directly.
I have an enum like this: pub enum Color { Blue, Red, Green } Is there an easy way to pick a random element from it? I tried the rand crate, but the compiler asks me to implement the Rand trait, how do I do that?
The first link in the post is dead.
Probably something like concatenate number to string (that's what I wanted to do initially), later maybe u64 to string and then I just read through the documentation. And when I say google, I actually mostly use duckduckgo. But I think I actually googled this because when I'm really desperate I go back to google :D
No, it would work like a limited form of global inference iirc. Probably pick the first type that fit and error if there was a mismatch later.
That's fun. I was actually convinced I'm just stupid while doing this, turns out I'm not the only one who didn't know about to_string :)
&gt; The first thing that the frontend does is in frontend\app\routes\application.js. This route runs before anything else, and it makes a request to grab a data.json file, which is generated by the back end. This loads up all of the docs into ember-data, which drives the rest of the site. Does it make me Old that I feel like a Javadoc style approach would be better? Instead of having JavaScript client implemented in a web browser which reads JSON data files from the server*, why not just generate plain HTML/CSS flat files on disk with relative links? \* Does this even work for browsing the docs locally via file://? ISTR issues w/ loading files w/ AJAX via file://. 
... not to poo all over a new project. I do like the goals of the project, and re-using RLS seems cool. :) 
Yea, I gotta say, my face fell a little bit when I saw the word "ember" in there :-/
&gt; why not just generate plain HTML/CSS flat files on disk with relative links? That's what rustdoc currently does and it's harder to contribute because of that. &gt;Does this even work for browsing the docs locally via file://? ISTR issues w/ loading files w/ AJAX via file://. There aren't.
We already use ember for crates.io
&gt; * Does this even work for browsing the docs locally via file://? ISTR issues w/ loading files w/ AJAX via file://. Yes, it works just fine. &gt; Does it make me Old that I feel like a Javadoc style approach would be better? This is one of the reasons why there's pluggable frontends; you could output anything you want. It wouldn't even have to be a web page!
What is this "pluggable frontend" you're speaking of? https://github.com/steveklabnik/rustdoc just mentions "THE Frontend" so I assumed that was the only one. But to clarify -- I don't necessarily mean Javadoc's styling, I just mean the fact that it generates a directory full of static HTML files w/o lots of JavaScript nonsense. :p 
which doesn't run locally, and users aren't wanting to publish a copy of crates.io to their personal websites. Not the same thing. As long as users of Rust don't need to have node installed on their computer to generate and view Rust documentation, I'm okay with it, but I can easily see why someone would want static files they can publish to any static host.
The machinery to hook your own in isn't there yet, but fundamentally, the idea is that `rustdoc` will produce JSON. Therefore, you can write something that takes JSON and produces anything you want, HTML with no CSS or JS, a PDF, whatever.
This runs locally. You don't need node installed. All of these files are static and can be pushed to any static host.
Yes, for rustdoc you won't need any runtime components, just serving static pages is enough. Node will be a tool required for _contributing_ to the rustdoc _frontend_, and that's it. Otherwise the JS will be bundled.
&gt;&gt; why not just generate plain HTML/CSS flat files on disk with relative links? &gt; That's what rustdoc currently does and it's harder to contribute because of that. I've contributed to rustdoc in the past and I can't say that I found that to be an issue. What made contributing hard for me was that rustdoc basically just used the internal compiler data structures for everything. That meant that you had to understand some of the compiler internals just to mess with rustdoc. 
In theory, options are nice. In practice, it's really nice to just know what Javadocs or (presently) rustdocs look like w/o having to learn multiple different doc front-ends. It'll also become difficult to make changes to the JSON objects if you have to make sure you don't break any of multiple front-ends. 
Right, that's another part of the thing this is trying to eliminate. With this rustdoc will have strongly separated backend and frontend code, with the backend code basically reusing RLS analysis info and outputting a tailored json file. But yes, ultimately the way I see it ember isn't producing any concrete wins over writing the codegen in Rust, aside from generated code size. (Maybe /u/steveklabnik1 has better justification here?). Doing web stuff in JS is a bit easier in general IMO though. 
I have seen it, but it falls a bit short when it comes to complicated examples, eg: https://github.com/shepmaster/rust-ffi-omnibus/issues/49
I looked at these both, but they appeared as though to couple the Rust code way, way too tightly to the higher level language. I just want the Rust code to be Rust, and reusable in other bindings. Both Helix and Ruru appear to force me to add macros specific to Ruby bindings, which I'm not quite sure I am okay with.
&gt; Right, that's another part of the thing this is trying to eliminate. Yes, I'm very excited for that and also the associated productivity improvements from not having to rebuild the compiler just to tweak css. Ember on crates.io makes sense to me because I think long term, it would be nice to have additional "web-app" like features there for managing your published crates. Using ember just to render static documentation pages doesn't make a lot of sense to me. The content of the pages is generated from rustdoc, so you have to run rustdoc to get new content anyway. 
That looks nice, thank you!
&gt; If I mix equal amounts of water with temperatures of 20° Celsius and 30° Celsius, what will we be the final temperature? To calculate the answer you can add two actual temperatures, independent of the units. That's not a counterexample. You just used conservation of energy and took a shortcut and elided the temporaries that are in energy/mass units. You're actually adding energy units, which is perfectly reasonable, since unlike temperature energy is linear. The actual units are below, which would become noticeable as soon as you started missing unequal masses or unequal materials. a Joules = 20 K * `mass` kg * `specific_heat` Joules/K/kg b Joules = 30 K * `mass` kg * `specific_heat` Joules/K/kg c Joules = a Joules + b Joules // adding energy! not temperature c Joules / 2 * `mass` kg / (`specific_heat` Joules / K / kg) = 25 K edit: I just realized this is what /u/_iliekturtles_ already posted an hour ago. oops.
&gt;good package management This is the big reason I'd say to use Rust. `cargo` is a work of art and I love it, while Go's package management is pretty loosey-goosey. I've got my fingers crossed for [`dep` ](https://github.com/golang/dep) to help things out eventually, but it's not there yet. I'd be curious to hear about your other programming experience. If you've dug into languages with slick type systems like Rust's (like Scala), or functional languages (like Haskell), I think Rust is near enough that you could crack it without too much trouble. If you're not used to those concepts, Rust might be frontloading too many concepts for the learning experience to be any fun.
&gt; In theory, options are nice. Totally. In the end, it falls out of a natural separation of concerns though, so in some ways, there's nothing to stop it from happening. The JSON is already using a specification that's been authored by /u/wycats and myself, and has been stable for over two years. Used in production by tons of companies to make millions of dollars. So that helps with that a lot.
&gt; the way I see it ember isn't producing any concrete wins over writing the codegen in Rust, aside from generated code size Agreed. It seems like extra complexity for maybe not a lot of win. Unless HTML templating is just *a lot* simpler in Ember than it would be in Rust. 
&gt; Unless HTML templating is just a lot simpler in Ember than it would be in Rust. It is. This is literally what ember is designed for.
&gt; Using ember just to render static documentation pages doesn't make a lot of sense to me. In the end, I want working on the frontend to feel like working on a web app, so that it's familiar to web developers, follows best practices, etc. We already have, as a project, many ties to Ember, and so I chose it mostly because it feels like a solid, default choice. That's not the only reason, but it's one of them. &gt; The content of the pages is generated from rustdoc, so you have to run rustdoc to get new content anyway. One thing that this could enable is a mode wherein you run `rustdoc` in the background, and as you tweak your code and the docs, it automatically updates in your browser. It won't do that today, but the way it's built fundamentally makes this possible.
You *could* use the ruru/helix stuff to bind to your library like any other, but yeah, it makes less sense if you want it to be more generic, totally.
As a quite totally beginner in rust, I would say you should not be afraid by the steepness of rust learning curves, It is quite moderated.
If you have no problems with the complexity around templates, smart pointers or move-constructors, you shouldn't have much problem with the complexity in Rust. Rust compile times are pretty bad, just like C++. Go's main advantages are co-routines enabling easy asynchronous IO, the simplicity of duck-typed interfaces, and that garbage collection is simpler than the multitude of smart-pointers C++ and Rust have. But its lack of generics/templates prevents you from adding custom strongly typed collections or generic algorithms.
Planck units or GTFO.
Hokay. Associated types to the rescue! How's [this](https://play.rust-lang.org/?gist=c16d55ffb766841dfcbe858163593cff&amp;version=nightly)? Note that `SpecialVec&lt;i32&gt;` is `Vec&lt;i32&gt;`, while `SpecialVec&lt;Option&lt;i32&gt;&gt;` is `(Vec&lt;i32&gt;, Vec&lt;bool&gt;)`. Is that what you wanted?
Ah, cool, didn't realize that JSON format was already stable. Where can I read more about that?
http://jsonapi.org/ I'm using https://crates.io/crates/jsonapi to generate it right now.
Isn't JSONAPI just a high-level standard for developing "APIs" in? You'd still would need a specification for the data types you provide via that standard. This seems a bit like saying "Oh, yeah, I already have a standard for that data format: XML."
&gt; In the end, I want working on the frontend to feel like working on a web app, so that it's familiar to web developers, follows best practices, etc. We already have, as a project, many ties to Ember, and so I chose it mostly because it feels like a solid, default choice. I don't particularly enjoy working on web apps so that's probably part of my objection :) &gt;One thing that this could enable is a mode wherein you run rustdoc in the background, and as you tweak your code and the docs, it automatically updates in your browser. It won't do that today, but the way it's built fundamentally makes this possible. I don't see any reason that would be incompatible with static pages. [Hugo](https://gohugo.io/) has "hot blog reload" and it generates static pages. Please don't take my comment the wrong way. I'm very, very happy rustdoc is getting some much needed love and decoupling it from the compiler will make it *massively* better! I just don't think that rendering static documentation warrants the technical complexity of a web-app framework. It seems to me that using an existing Rust [templating library](http://www.arewewebyet.org/topics/templating/) would be sufficient for rustdoc.
It's true that there is some extra semantic information on top, but this handles the trickiest parts of the whole thing already, which is the relationships bit. In theory, sure, we could rename some of the data to another name or something, but I don't anticipate much change here at all. And the standard tooling to work with it should be resilient to changes, and there's toooons of standard tooling already available.
&gt; I don't particularly enjoy working on web apps so that's probably part of my objection :) This is likely it then, yes, as most of my professional career (though Rust is nearing the 50% point!) has been in web development :) &gt; I don't see any reason that would be incompatible with static pages. It's not that it's incompatible, it's that it's a lot easier and (IMO) nicer.
On another note, I would just like to focus attention on these bullet points from the original post: - rustdoc should be easy to contribute to, and maintain generally - rustdoc should be easier to customize - long-standing bugs should be fixed - Be good for more than API docs, like guides These are outstanding goals to have. Rust has some of the best documentation of any language I've ever used, and I can't wait to see it get better.
Awesome!
I'm coming from Python with a little C for low level drivers on custom Android devices. I'm new to both Go and Rust and gave them both a try. You will be faster getting going in Go. I was, for a while. But, I found that I would not like where I ended up. And doing things was very verbose, due to limited features. This has the advantage of being quick to learn and keep in your head. But nothing I did felt elegant or designed well. The biggest issue I had fundamentally is that some data types are blessed. i.e. They have functionality that isn't reproducible by the user. This makes it much harder to expand the language in a clean way. I'm still frustrated and learning Rust, but already I can see that the design is the language is just better. It feels a little like a force static typed Python in iteration and such. Although, I'm still wrapping my mind around some of the Monad styles, as this is new to me. I like that the language is build with the language. String is a custom Vector. That means, if I want to build a type in Rust on my own, I have the power to do so at no performance hit. I started doing solutions to r/dailyprogrammer in Python, Go and Rust. By solving the same problem in multiple languages, you can compare. I either dealt with compile errors with mostly helpful messages (once I started to understand Rust vernacular) or panics as I tried to run in Go. I found I prefer the former. One thing I found interesting is that defer in Go seemed to be required, for something that you often get for free due to lifetimes and scoping on Rust. It is still very easy to open a file and forget to defer the close. If you scope the open into a buffer, the scoping automatically closes the file in Rust. This felt a lot like Python's with context manager style. Go is not trying to break any new ground. It is trying to be a fairly simple and reasonably fast language. It succeeds at the intention. Rust is breaking new ground. And I believe that forcing myself through the learning process and producing in it will make be a better programmer in ANY language. I can force some other languages to behave a little like Rust and make my code safer. I'm already seeing this in my Python code and architecture I come up with. It seems like Rust will most likely be better for embedded targeting. I'm interested in that aspect. Go and Rust are really for different uses. But there is a wide overlap. And personally, I believe that with the right Rust libraries, speed of development for some of Go's bread and butter will be as fast in Rust when full lifecycle is measured (testing, debugging, etc). I also believe that Rust will be a more maintainable code base, because you get less free passes for bad design. One thing that I find attractive in Go is the targeted builds for various platforms. I haven't looked at where this is in Rust. With LLVM, it seems like it should be easy. I've seen this for ARMv7 on Raspberry Pi, etc. TLDR: Try to write some programs in both. Solve simple problems. Don't evaluate until you have a little experience under your belt. 
The "semantic information" *is* the trickiest bit. You're not just displaying that Foo relates to Bar, you have to know that Foo is a struct and Bar is a trait and here's some information we might want to display about that trait inline with Foo, but for the rest we want to go view it on the Bar trait page. Nailing down that "semantic information" is what will allow people to make good use of the data. Otherwise they're just developing a generic JSONAPI browser.
That's certainly fair. Thanks for working on rustdoc!
&lt;3
&lt;3
[removed]
`UnsafeCell&lt;T&gt;` owns a value, it's not a pointer. So, it's not `UnsafeCell&lt;T&gt;` vs `*const T`, it's `&amp;UnsafeCell&lt;T&gt;` vs `*const T`. Does that make sense?
don't remind me :-(
[This](https://play.rust-lang.org/?gist=f2747d4d719be63f91e5f7e085f49839&amp;version=stable) may not be the most clear example, but maybe it helps? The UnsafeCell provides interior mutability, and as Steve said, it also contains the value, it doesn't just point to a value somewhere, which you would then have to be concerned about not letting that pointer outlive the object it points to.
You can pick up enough Go to be productive really quick. So if your prepared for the learning curve of Rust, I'd suggest picking a very simple project that you could implement in an evening or two with Go, and then try the same with Rust. As an anecdote, I started a very minimal API client both [in Go](https://github.com/anowell/algorithmia_go/blob/067c530d6e20aa107cf1714503790fedce8d9447/client.go) and [in Rust (pre-1.0)](https://github.com/anowell/algorithmia-rust/blob/5d9986b6ead26fb06b853b668c966e21c8917c30/src/lib.rs) around the same time (Jan 2015) to compare. Admittedly, I already had a bias for Rust (from a colleague I respected), so I had a higher tolerance for the Rust learning curve. Rust intrigued me as something I wanted to continue to learn. I appreciated Go for it's simplicity, but for a language I didn't need, it didn't hook me. And for me personally now, I'd only choose Go over Rust if working with existing Go code, on a team where Go was preferred, or for a problem where the Go ecosystem is already substantially more capable. But best of luck with either Go or Rust.
This is a silly question, yet it bothers me much more than it should… Is there any reason you are using, in `README.md` of the repo, backslashes instead of slashes for directory delimiters in paths?
BTW it's `*mut T` because `UnsafeCell` disables immutability of shared references.
What is this package management of which you speak? Yours, a Go programmer.
At the moment, a `Vec` is indeed the most appropriate way of handling this. I do hope that with the advent of MIR, this silliness could be optimized out even in Debug. Otherwise, there's also maybe the placement RFC (with `&lt;-`).
I'm going to have a look at this, looks great! Also, Gautier Hayoun has an amazing mustache!
You might need to add an "RTS", but you can definitely do exception handling in C through setjmp/longjmp.
Yes, that's indeed an issue. I was interesting to see that Gor Nishanov proposal for stackless coroutines in C++ advocated the use of a memory allocation (which can be optimized away) specifically to avoid introducing a difference between the ABI of coroutines and functions returns a future.
How is this different from cobalt.rs? Those projects seem to have a lot in common.
Because I'm a Windows user now and it's starting to permeate my brain, heh. I'm not going to say it's *better*, that's just the *why*.
I have to say I am surprised that defining separate types as displayed in the first example works even when you pass a variable of type Celsius to a function that accepts Kelvin. For example, Go would treat these are completely distinct types and would not compile. Does anyone have any more information on why this is the case for Rust?
Oh, that answers it, thanks. :) I won’t argue that slashes are better either, just wondered about the *why*. ;-)
uh yeah right :) thanks.
&gt; In a vacuum, Go is a terrible language In a vacuum, a thing just "is", it can't be terrible or great, because there's nothing to compare it to. I have been using Go for the past 7 months in my full-time job. I'm not going to say it's a terrible language. It really is "C, but better", when it comes to application-level software. If you think Go is bad, C is even worse, but people seem more accepting of C. All of that said, I would not recommend Go to almost anyone. Use Kotlin, or OCaml, or any of a few other options if you want a garbage-collected language to start a project with. Those languages at least have the power to express your code in terms of the problem and the solution, not just in terms of the solution, which is the instructions that will be emitted by the compiler. As an example of the above statement, take my library [Metric](https://github.com/coder543/metric) for instance. This library allows you to check that any math you do with units will not involve conversion errors or typos that would result in the wrong units. This is done at compile time, so it does not affect the performance of the code, and it makes guarantees about what will happen at runtime. It is literally impossible to make that library in Go. It is possible in theory to write a Go library that provides runtime dimensional analysis, but that would have a large performance cost, and you would never truly know that your program isn't about to crash from a violation of units. It would also be so verbose to use, since you can't even overload operators in Go, let alone the other stuff that I do. At that point, it's almost useless, and not the same at all.
I can't figure out if it is possible to get an array or iter of a given enum. And the match to get the enum back for return is pretty funky. But it works. https://play.rust-lang.org/?gist=6e31f8ad428a19644e0833470353f950&amp;version=stable I'd love to see a better solution than this from someone more competent in Rust. If you add a color, you need to add to array and match.
Mine installed fine. I added Rust to my PyCharm IDE. I've been using http://cmder.net/ for command line for a while on Windows. Gives unix styles without Power Shells funkiness. No problems at all with Rust. I've pulled down and contributed to a few Rust projects with no build issues. But all were pure Rust.
Can you further clarify what's meant by "serving static pages"? Specifically, can this be loaded from file://? Or must it be over http/https, using a simple local server?
Goroutines are just threads. You can use 1:1 threads in Rust if that's what you want.
Yes, file://. XHR over file works provided you are on a file domain.
I really dislike that article, because (1) it treats Go as some sort of special thing, when it's really just threads with an idiosyncratic implementation; (2) you can easily convert an async function to a sync one by just blocking, and you can easily convert a sync function to an async one by proxying out to a thread pool. "Red" vs. "blue" functions is really not a problem.
You can do message passing in Rust, and that's the preferred method of concurrency. Rust is closer to pure CSP than Go is.
They aren't really comparable because the are used for different purposes. I don't know what the original motivation for rust's type aliases were, but I most often see them used to make types with generics easier to work with. For example, many functions/methods in the `std::io` module return a type `Result&lt;T, ::std::io::Error&gt;`. To make this slightly shorter to use in real code, it is aliased like this: // in the std::io module type Result&lt;T&gt; = ::std::result::Result&lt;T, ::std::io::Error&gt;; Now instead of having to write out the whole type, you will frequently see people importing the `std::io` module and doing this: fn my_own_fuction() -&gt; io::Result&lt;MyOwnType&gt; { ... } For rust, the comparable construct to golang's type aliases is the newtype struct, which is used at the bottom of the article: struct Fahrenheit(f64); This _does_ create a new type, without incurring any additional overhead above what just using an `f64` would be.
The types in the first example are just type aliases, not separate types at all. The way to define separate types a-la Haskell newtype is as the author did at the end of the article, pub struct Celsius(f64); pub struct Fahrenheit(f64); pub struct Kelvin(f64);
Your preferences seem to match what Rust does. The learning curve will greatly depend on what your first project is. Anything involving writing recursive data structures might be rather steep. I also hear Tokio (asynchronous services) is complicated at the moment. Start with something simpler to get a feel for the language.
As pointed out by /u/joesacher, there is no way to iterate through values of a regular enum, as they may not be static (e.g. how to iterate through Option&lt;T&gt;?). https://play.rust-lang.org/?gist=3a3cf05387caa5c42d9cd215318ce89b&amp;version=stable Another approach is to just implement the trait, this will allow additional functionalities, although it would still need editing when the members of the enum change. 
I would note that given the very oddities of floating points as presented in the caller, using a single underlying representation is actually NOT necessarily a good idea. For example, if I add 1 Celsius to 1 Celsius, I expect 2 Celsius, not 1.9999999997 Celsius.
I understand the use case, and I guess different languages have different implementations of type aliases.
Right, makes sense. The keywords mean different things here and doesn't necessarily mean it's wrong.
I agree with you, I'm just pointing out that's how people argue it.
Thank you, your code helped me a lot. But now I have another question regarding enums. In Java I could do Color n = Color.valueof("Red"); Is something like this possible in rust?
I think you may want the https://docs.rs/enum_derive/0.1.7/enum_derive/ crate - this will get you a lot of this functionality - the kind which really only makes sense for "plain data" enums.
Unsigned integers *are* just bits, it's the signed ones that interpret the bits in a non-uniform way - unless you want to disable integer arithmetic *completely*?
Great work to everyone who worked on 0.3!!!! I'm surprised the upgrade to serde 1.0 didn't make the announcement, that was one of the main reasons I was using rocket master instead of 0.2 for my app. Glad I'll be able to upgrade to 0.3 now!
Woop! Exciting stuff. I'm going to re-do rustls's test site using this (at the minute it's just a TLS-terminating proxy in front of nginx).
There were several soundness fixes that were added; they were trivial to update the code to fix, but since releases are immutable, the old versions are now broken. Stability is a huge priority, but soundness is too.
This is fantastic to see! I recently wasted a weekend diving into the rustdoc code in a vain attempt to add an option to produce output that could be compiled to info pages. (I would prefer to browse Rust API documentation in Emacs or a terminal, and my current solution of using w3m in Emacs is not very satisfying. The layout and styling of rustdoc's current output really assume that you are using a fully-featured Web browser.) The design goal of making it easy to develop new frontends is very welcome.
I wonder if it's possible to write a clippy lint to warn when a value of type `A` is assigned to type `B`, but both `A` and `B` are type aliases for `C`.
&gt; I have been using Go for the past 7 months in my full-time job. I'm not going to say it's a terrible language. It really is "C, but better", when it comes to application-level software. If you think Go is bad, C is even worse, but people seem more accepting of C. Because C is _fucking fast_; Go isn't. Yeah, C is terrible in every way but made those sacrifices back in the day to be as fast as possible. Now this was based on an outdated understanding and Rust in theory is as fast as C but without most of the terrible-ness so that's nice but there was never an excuse to be as terrible as C if you don't come with C-like performance. There were far less terrible languages before and after C, C threw away sanity for performance and that's reasonable. Go throws away sanity for nothing. &gt; All of that said, I would not recommend Go to almost anyone. Use Kotlin, or OCaml, or any of a few other options if you want a garbage-collected language to start a project with. Those languages at least have the power to express your code in terms of the problem and the solution, not just in terms of the solution, which is the instructions that will be emitted by the compiler. I very much concur. Go has Ocaml-level performance and compilation speed but with none of OCaml's elegance and strong typing that stops bugs and concise expression of problem solving. &gt; As an example of the above statement, take my library Metric for instance. This library allows you to check that any math you do with units will not involve conversion errors or typos that would result in the wrong units. This is done at compile time, so it does not affect the performance of the code, and it makes guarantees about what will happen at runtime. It is literally impossible to make that library in Go. It is possible in theory to write a Go library that provides runtime dimensional analysis, but that would have a large performance cost, and you would never truly know that your program isn't about to crash from a violation of units. It would also be so verbose to use, since you can't even overload operators in Go, let alone the other stuff that I do. At that point, it's almost useless, and not the same at all. Yeah, I remember selling a biophysicist on hindly-milner type systems with OCaml by pointing out how the type system can do dimensional analysis for you.
This looks like a very solid release! What i am very excited about is the fact that the new features are very well documented! Not only the awesome docs – fully packed with useful infos – but the guide has also got nice additions from the new features! This is very good software craftsmanship we're seeing here. 
Yeah but it hasn't succeeded at that either. It's replacing Python more than anything else.
Keep in mind that Python is actually quite old and has great C-interop.
https://docs.rs/serde_json/1.0.2/serde_json/#operating-on-untyped-json-values
I think you've hit the nail on the head there. Go has marketing and community fervor. It has corporate backing to get conferences and developer resources off the ground, etc. Language use really isn't about what's *best* and never really has been, just like everything else. It's about what's visible and what is predictable and stable.
I agree with everything here, but I'll just point out that Go isn't actually replacing Java or C++ as the default choice for new servers at Google, so that's somewhat of a failure. Google still uses C++ when performance is absolutely critical and Java for basically everything else, which is really hard to change due to network effects. The only thing Go *could* reasonably replace is Python, which it is starting to do. 
Would I be wrong in saying you can do this currently? I thought you could get rustdoc to output json at the moment
A flag existed, but it was broken for at least two years best we could tell so we removed it. Broken as in "any invocation of it caused rustdoc to unconditionally panic".
For two years?! Wow, time flies. I definitely remember trying to use it for something, I could have sworn it was more recent. I must be getting old :'(
Isn't ember for web applications? You could argue this of the template library but there's other stuff on top of that as far as I understand. Obviously this is very subjective but I feel like docs isn't really complicated enough to be called an application. That's probably a bit too subjective. I mean a docs page is (and not to diminish the work put into their design and implementation) largely linked static documents, with some nice dynamic things like hiding sections and search. Ember js seems a bit like overkill.
Inside Google or in general? ...because, if it's replacing Python, generally, and C++ inside Google, then I'd say that's a reasonable success.
He might mean this part in [`src/action/load.rs`](https://github.com/kieraneglin/diecast/blob/master/src/actions/load.rs)? let mut answer = String::new(); // TODO: Revisit. Reading input can't actually be this hard stdin().read_line(&amp;mut answer).expect( "Unable to parse input", ); let answer = answer.trim_right();
Yep makes sense; thanks!
No. It's replacing Python inside and probably also outside Google for people building things that don't depend on Python's vastly superior ecosystem, such as crud apps and tools like Docker (I guess). It doesn't seem to be replacing C++ anywhere because no one was using C++ for the reasons that made Go popular. I could see it replacing Java, except not really because it's not flexible at all and Java is so entrenched that we might as well be talking about replacing Von Neumann architectures in general.
Yep, that makes sense!
I find sphinx docs much more usable and python docs generally far more userfriendly (requests or aiohttp are very good examples).
Awesome, thanks for spelling it out for me :-)
The enum approach is really memory-inefficient; you'll end up with double your memory usage (or +50%, depending on the arch and alignment requirements).
Great news. Hope it will be async in near future.
Yeah so one day I was like "time to try this out" and it didn't work, looked at the code and didn't see how it could have ever worked, went back to the previous release and it didn't work, picked some old release like 1.0 and it didn't work. No bugs ever filed. Just removed it and nobody has ever filed a bug saying we broke them.
Great! Should probably try to fit this into the docs somehow...
...and crates.io suffers for it. People running NoScript are broken for no reason. Pages load in several phases instead of one, which is a jarring experience. The site is more resource-intensive.
A simple approach is to store last N values in B-Tree or binary search tree (keyed by value) and in circular buffer (in the same order as input). You can process each item in O(log N): 1) O(1) to find old value in circular buffer 2) O(log N) to remove old value from tree 3) O(1) to insert new value into circular buffer 4) O(log N) to insert new value into tree 5) O(log N) to find median of a tree (not sure whether std::btree will let you do that, but it's possible with e.g. custom AVL Tree implementation - store count of items in each subtree). I'm not sure that that's the optimal solution, though.
I'd really like to know what the benefits are meant to be for rustdoc and crates.io. I can see why you'd want to use ember or whatever if there's a lot of dynamic user interface but both of these are pretty static
As far as I can tell, the only benefits are 1) an existing template engine and 2) comfort for existing ember devs. Both are highly questionable, IMO.
&gt; No. It's replacing Python inside and probably also outside Google Ahh. Do you remember where you read that? ...because I'm always curious about where details about what's going on inside Google originate. &gt; for people building things that don't depend on Python's vastly superior ecosystem Makes sense. The ecosystem is the main determining factor when I'm deciding between Python and Rust. (Go never even factors into it for me, since my stuff has always been I/O-bound enough for Rust's appeal over familiar old Python to be in its type system.) &gt; such as crud apps For clarification, I assume by "such as crud apps", you mean CRUD (ie. frontends for data stores), not "low-quality"?
Rust is certainly more low-level than Go. So if low level capabilities are important for you, Rust is probably better choice. What you didn't mention is how much you value correctness of your program and abstractions. If they are important to you, Rust is better choice again. Finally, don't worry about learning curve too much. Especially if you know C++ well. Yes, it is difficult, but if I could make it, everyone can. :)
That seems like a much cleaner way of using Random. I'm still trying to learn enough to fully understand the docs. All these `&lt;` `&gt;` around are crazy. :) Just incrementing the upper limit and adding one more match isn't too bad.
Nice comment! &gt; The biggest issue I had fundamentally is that some data types are blessed. i.e. They have functionality that isn't reproducible by the user. Rust could improve in this area though. E.g. `Box` is blessed type. &gt; One thing that I find attractive in Go is the targeted builds for various platforms. I haven't looked at where this is in Rust. I found this super-simple with `xargo`. (Although I tried only microcontrollers - not RPi.)
Woo, awesome to see TLS support out of the box. I wonder if the rocket.rs folks would be interested in considering automatic-TLS with Let's Encrypt, ala Golang's autocert or Caddy? To hock my own wares, https://github.com/alex/ct-tools/blob/master/src/letsencrypt.rs is an implementation of this for rustls.
Yeah, but ember lets you have the webapp run mostly on the client side. I don't see why rustdoc _isn't_ be a webapp; to me it feels like a webapp which we hard baked into a static site. Many data-serving apps are not static. Ultimately, this is being designed so that the frontend will be pluggable, so you can also design a pure rust static doc generator if you wish. 
And thank you for taking the time to listen. I keep coming back to Rust because of its memory safety and performance. It has a steep learning curve, sure. It requires more typing, sure. But it is the kind of costs you want to pay so you don't pay the other ones it prevents. I learn so much good programming practices and how computer hardware and OS works through Rust that I can't simply ignore it. Heck, I can't even not like it with all of its great guarantees.
Yeah, I think drawing a clear categorical distinction between the unboxed wrappers (Cell, RefCell, UnsafeCell) and the boxed wrappers (Unique, Shared) could be useful since they all involve lying to the lifetime system in some manner or other, and so it's easy to mentally put them in the same bucket (which is, I think, how I got confused about it).
I'm playing with the ggez crate on Windows. When I build, the .exe spawns a terminal before it makes the game window. This seems like the difference between Python and PythonW for windows to not get the terminal. How is the terminal excluded in rust? 
&gt; Rust has some of the best documentation of any language I've ever used I couldn't agree more. Coming from Python, with little programming experience, learning Rust was _hard_, and the quality of documentation and of the first rust book are the main reason I persevered. Thank you /u/imperioland, /u/steveklabnik1 and all the others that contributed to the documentation.
Haha no worries, generics can make some documentation hard to discern, particularly if automatic impls are involved; but with enough experience, parsing these &lt;&gt; will slowly but surely become easier.
What is most important? Insertion performance, or median calculation performance? memory usage? Are you going to want the median after each insertion? It would really help to have some idea of how it's going to be used. There are some trade-offs to be chosen between, I believe.
I'm in the process of creating a Rust wrapper around [libsolv](https://github.com/openSUSE/libsolv) and thought everyone might be interested. Please feel free to ask questions!
&gt; you can implement a Hashset if you already have a hashmap by giving the latter a value type of (). In fact, that's exactly what the real [HashSet](https://github.com/rust-lang/rust/blob/ae4803a750cc415a3b8a69a68cec73400a5e27bf/src/libstd/collections/hash/set.rs#L121-L123) and [BTreeSet](https://github.com/rust-lang/rust/blob/ae4803a750cc415a3b8a69a68cec73400a5e27bf/src/liballoc/btree/set.rs#L73-L75) do.
Like I sort of said, what is and isn't a web app is very subjective and I only kept it in the comment to give a vague idea of where I'm coming from. My impression has always been that these frameworks are good when your page is changing a lot based on user input, ie. they're very responsive. To me it really doesn't seem like it's complicated enough for ember to improve anything, or be worth the performance. crates.io is very slow on my machine, far slower than PyPI or RubyGems or npm. That's not a good experience. It's nice that it's going to be pluggable, but it's not a reason to have a default that has poor performance (edit: or far more complexity)
I remembrer succesfully make it work with a few changes, but the generated JSON was awful anyway.
Crates.io is not really built for performance. I expect this to perform as good or better than the existing rustdoc output; there shouldn't be any major regressions there.
/u/staticassert, I don't know if this meets your needs, but [this](https://gist.github.com/anonymous/cbe575572cf33f6c32ef32b2d6e2f375) is something I just threw together. Testing on my machine with a buffer size of 10 values, it's able to `insert` about 300 million elements per second, and it's able to calculate the `current()` median about 10 million times per second. I'm not sure if that's good enough for you or not. When `unstable_sort` becomes stabilized in a few weeks, that would increase the performance of `current()` a fair amount. It would also be easy to add another value to the `StreamingMedian` struct, namely `cached: Option&lt;u32&gt;`, which would be set to `None` anytime `insert()` is called, and `Some(blah)` when `current()` is called, if it is currently `None`, otherwise `current()` would simply return the cached value. This would likely hurt performance if `insert()` is used much more than `current()`, and it would benefit if the opposite is true.
Cool, yeah that makes a lot of sense, I should have been clearer about this. Removals and insertions always happen at the same time, so they are used equally often. After every insertion there is always a recalculation of the median. So let's say you have 1 insertion, 1 deletion, and 1 calculation of median. There will be *1* additional calculation of median elsewhere in the code. So it ends up being that, for one full "processing" of data there is: 1 insertion 1 deletion 2 calculations
Is [`bitflags`](https://doc.rust-lang.org/bitflags/bitflags/index.html) what you want?
I can't let /u/steveklabnik1 makes all the "&lt;3" so here's mine: &lt;3 &lt;3 &lt;3
if you're always going to calculate it twice, obviously you're going to want to cache that. I'm not sure if you saw [my other comment](https://www.reddit.com/r/rust/comments/6nbk02/data_structure_to_track_median_processing_times/dk8bijx/) or not. It may not be the most efficient solution conceivable, but it might be fast enough, and it's dead simple.
I think if crates.io didn't use ember and instead used plain javascript the performance problem wouldn't be noticeable. Granted, I haven't looked at the crates.io source but the site itself isn't any more complicated than the ones I listed
RPi is a big enough computer that std lib and all that is fine. The only factor is unsafe when working with IO, I2C, SPI, etc. I'm interested in micros too. Currently I'm building 10 charging carts for our tablet production that has custom hardware hanging off of a RPi (which provides display and touch input.) It controls 125A of charging current and burn in tests the devices for 48 hours. This is all in Python and works well enough, but my pin toggling on GPIO is as slow as I could allow. I could see writing a low level hardware interface in Rust that is called with my Python workflow. Possibly replace all the workflow eventually. The webservice is in Flask (along with the local display) so it might be a way of testing Rust web experience as well.
I don't see any reason why `impl&lt;A, B&gt; FromIterator&lt;(A, B)&gt; for (Vec&lt;A&gt;, Vec&lt;B&gt;)` should be impossible. Admittedly, variadic generics would help here, but it'd still be good enough to simply impl for tuples up to 10 fields. FYI, generic value parameters are work in progress.
&gt; ow and it's starting to permeate my brain, heh. I'm not going to say it's better A bit off-topic, but I'm curious about made you switch to Windows if you are already familiar with unix?
*sigh* It's amazing that after all these years there's not even second-class support for latex in rustdoc, and when it pops up (even with code contributions), it gets swiftly axed by someone of the team ¯\\\_(ツ)\_/¯ That decision only makes the whole situation of the scientific crates ecosystem a whole lot more fragile, is frustrating. And as CS student, it really deters me from considering rust as a language for writing scientific software, even though I really love the language and used it to write production software =/ 
I've not quite gotten through to generics in the two books I'm working through. I'm like a nail sticking up. Just rusty enough to be dangerous. :) 
&gt; awesome to see TLS support out of the box I've been running things through an `nginx` proxy with `iron` because I didn't want to run two servers, http and https. This might actually get me to switch (though I'd prefer to stay on stable, but I might have to make an exception).
Happy Bastille Day everyone :-)
I think it'd be possible and useful. I've [opened an issue](https://github.com/rust-lang/rust/issues/43242).
That's not something I'm happy about either. That half second load when coming back to crates.io after glancing at a crate's docs is does not make for a good experience.
Just like any technology, you can build fast or slow things with it. bustle.com is one of the fastest websites I've ever used, and it's an ember app. crates.io was kinda tossed together years ago and until recently, basically had nobody working on it. I wouldn't take it as particularly an example of anything. Heck, it even uses its own custom web framework!
As I mentioned in the linked thread, stuff like this is something we'll be able to support, probably. The problem is not wanting it, the problem is it causing a big overhead for the vast majority of things that don't use it.
Microsoft has really been turning things around the past few years, I started playing video games again, the WSL made the transition easy, now I just use regular windows. 95% of my computer usage is * bash * vim * git * firefox * rustc Powershell works great as a bash replacement, the others work basically identically on Windows; I've been using VS: Code with a vim plugin and it's 90% compatible and better in some of its own ways too. Windows is important to Rust, and so having people using it actively is important too.
What specifically do you find more user-friendly about it? That's very helpful to me :)
Examples I mentioned: http://aiohttp.readthedocs.io/en/stable/ http://docs.python-requests.org/en/master/ In the first sentence you have clear statement what that thing is. Right below you have usable code example that explains how to use it On left side or below you have use-case focused list of topics. Then the docs is split in chapters explaining all you need to know, but allowing you to jump to specific topic. Those topics also contain relevant examples. This is not only usable, but also indexable by search engines, so googling usually leads to this page. In contrast, Rust crate documentation (something beyond this rarely exist): - don't explain what they are, expecting you to be familiar with the usecase and domain - contain no examples - expose module structure, which is rarely what I care about (and if I do, I look at the source) - do not document things users care about - do not have a way to figure out where some specific info might be
How can I get a stack trace? I tried this in Windows Powershell but it doesn't work: RUST_BACKTRACE=1 cargo run
&gt;Strings aren't just strings; they're strings in some particular context. Well, sure. But you could make the same argument for any trait, as they only allow for one implementation per type, even when there are multiple meaningful ways to implement them.
&gt; unless you want to disable integer arithmetic completely? maybe. if you have a value who's purpose is to be or'd and anded for testing, perhaps it would be useful to disable integer arithmetic such that it's a compile time error if the value was used incorrectly .. they *are* both just bits, however the intent is slightly different. of course there *are* times when you do both. One thing I mentioned was 'b128' : one scenario was a 128bit representation of the data in a 4x32bit SIMD register.. it could be a bool select mask; or it could be mid use r.e. some sort of permute operation (e.g. a transpose to get homogeneous data from multiple structs): at this point in time it's meaning is ill-defined .. it might be more correct to say 'it's just bits' , whilst it's neither a [f32;4] or [i32;4]
ok ```#![feature(specialization)]``` to the rescue, I haven't encountered that yet in rust. nightly I guess. Maybe that does achieve the desired result, it might still be interesting to be able to write such a clear, direct substitution (one of the problems with TMP / 'type traits' in C++ is that it's 'accidental'; the syntax and behaviour is quite obscure and indirect. just because it *works*, it doesn't mean it's *the best possible way to do it*) .. but if the language engine can already achieve this, great. this isn't as bad (yet). the traits themselves do give a better point of reference for this sort of thing, I guess. One of the things I'm still slightly uneasy about (generally) is the treatment of a 'special parameter', i.e. the "other parameters' (vs Self) are an afterthought".. the trait system is originally designed for *one* parameter. As such when you're writing 'expressions' reasoning about types you're sometimes flipping things back and forth in your head. The clearer expression of the phenomenon I'm talking about is : the signature of traits for binary operator overload, where the types in the 'impl..for' line appear backwards compared to the function definition trait (RHS,Output,LHS) / function (LHS,RHS,Output) ... very messy. In an ideal system, this flip/asymetry would not occur. with 'matrix*vector' it's not really ideal to call either 'matrix' or 'vector' 'self' Put another way: there's scenarios where you are basically expressing 'functions' that 'compute types' ('a function of types, producing a type), but the extraction of a 'result' looks different to any other time you write or use a function on values .. not sure if there are any viable paths for improvement from here though. I know, conversely, the trait system has been set up for dual purpose (bounds and vtables) and of course in a vtable scenario one type *is* special. 
certainly another option, I guess you could argue 'something wrapping u32s..' is perfectly valid , i.e. 'the low level capability is arithmetic etc.. and we're asking to disable' ; but there are scenarios 'like the whole 128bit register in SIMD' which doesn't have arithmetic on 'u128, i128', but which can be and/ored in it's entirety . the notion is that 'for precision it might be nice to have a very direct way of expressing that'.
Adding to that, the *Go* ecosystem is just reaching a critical point when it comes the availability of libraries and tools. 
(direct representation of a predicate register? I think some GPU asm might expose such a concept.. 'a register holding 1 bit per comparison result from each wide-SIMD lane')
Thanks!
&gt; Why is it so hard to parse CLI input? Would readline (via [rustyline](https://kkawakam.github.io/rustyline/rustyline/)) be overkill for your project? let mut rl = rustyline::Editor::&lt;()&gt;::new(); let readline = rl.readline("&gt;&gt; "); match readline { Ok(line) =&gt; println!("Line: {:?}",line), Err(_) =&gt; println!("No input"), } Maybe there's a better way of reading directly from `stdin`. Also, Rust aside, I'd suggest writing a function for reading "y" or "n" from `stdin` so you don't have to worry about changing the same code everywhere you wrote it.
Thanks, fixed.
Congratulations to all contributors. I've been reading most commits on the GitHub repository, awaiting the release of 0.3, and the thing which impresses me the most is the effort which goes into writing proper documentation. Documentation is one of the main things that make projects like Ruby on Rails so excellent, and it's great to see a similar focus on docs for Rocket as well.
"expects its managed-state has to be thread-safe" I cannot quite get how that's a problem for you, since tiberius is async and therefore has to be thread-safe to be able to run within a threadpool ('static + Send bound [Arcs all around]). Also providing a sync interface should merely be the work of building a wrapper around it that calls .wait(). (and some wrappers for some types/iterators to be ergonomic) For getting MSSQL support integrated into diesel, C-bindings (in this case that'd be FreeTDS) to mature/manufacturer drivers seem to be the favored approach. I also disagree that it fractures the ecosystem, there's always a way to use it synchronously if you want. Simply calling .wait() might suffice or a more complex approach like e.g. reqwest is using. So it's simply more flexible to expose an async API. And yes it isn't quite as mature as the sync APIs, but one cannot expect to get there if you don't want to "let it grow". 
I had another look at Cobalt right now but they look pretty different in terms of features. It seems to be a small subset of Gutenberg: the only features I listed as part of 0.1.0 in Cobalt are RSS feed generation and syntax highlighting (although Cobalt has a limited number of language syntaxes and themes). The template engine it's using is also more limited than Tera. So from what I can see, the only thing in common is being a static site engine and using markdown as input.
Why use such a broad, generic name for what seems like a fairly specific abstraction?
No worries! As a person who writes software for mainly himself with a few things here and there, I would love any constructive criticism. Trying to change jobs and all that jazz. Edit: there's a few things I definitely want to rework but haven't gotten to them yet. 
I tried to use two crates that internally used different versions of hyper. I think it was `egg-mode = "0.8"`, `serenity = "0.1"`. Ultimately it pulled in two different versions of openssl-sys, and apparently you can't have more than one crate linking to a library. I'd spent a while with either crate in isolation intending to use them together, which then felt like enough of a waste of time that I pretty much stopped using rust for recreational programming.
depending on multiple versions of a library is done a lot in rust, mainly through transitive dependencies, but i would consider it more of an antipattern usually.
I'm so pumped about using this library for my next project. It's by far the cleanest web api I've seen for rust. 
Just because you *can* doesn't meant you *should*. For what it's worth, I'd find that being a thing really weird, especially given the precedent set by virtue of `unzip` existing.
&gt; Rust has some of the best documentation of any language I've ever used, and I can't wait to see it get better. For the most part, I agree. The biggest issue I tend to have is with the trait implementation section. The list for [u32](https://doc.rust-lang.org/std/primitive.u32.html), for example, is all but unusable. Hopefully this rewrite will make it easier to fix that kind of thing. For me, I think I'd ideally like to see something like [this concept I put together](http://i.imgur.com/j57cDwL.png), but with not-terrible styling.
Temporary environment variables are set like this: PS folder&gt; $env:RUST_BACKTRACE=1 Then you just run your standard cargo commands.
As someone who's made a very small contribution to rustdoc, I did find the current approach of rendering HTML inline to be difficult. It seemed deciding what to render was all mixed up with deciding how to render it. I think this could be improved with a server-side rendering framework like handlebars-rs, where the back-end of rustdoc decides what to render (outputting JSON or some Rust structs) and then this gets rendered by the templates. Once it's possible to write pluggable front-ends, I'd be interested in trying to develop this if it doesn't already exist by then. I'd be interested to know if there's any planned functionality where this won't be sufficient and where client-side rendering would be advantageous. 
What if what's best it's the same as what's predictable and stable and popular? :)
Use Result in your API code instead of expect/panics, otherwise no one is going to use it and it can take down the whole application unless you have a panic handler
I've already asked you one nicely. I'll do it again. Please keep this flame bait style of discussion of other programming languages out of this subreddit. Thank you.
Go just recently got type aliases in the Rust sense. In Go, `type Foo = Bar` is the same as `type Foo = Bar;` in Rust. Similarly, Go's `type Foo Bar` it's the same as Rust's `struct Foo(pub Bar);`. It's not really about having different implementations of the same concept. It's really about two completely distinct concepts in the type system itself.
OP asked for input and I gave it. This kind of bullshit filter mentality isn't productive and stops people from discussing issues. If people think Go is without merit they should be allowed to say so, especially when someone opens a topic asking about it. It's certainly not an unorothodox opinion and there's much written about it. There's stuff in this world which is crap without redeeming factors and if you believe it has redeeming factors then you're welcome to engage in productive discourse and just _state them_; I made a very falsifiable claim in my post about Go you can easily debate on the merits if you think it's wrong so do so if you thing it's wrong; if you don't think it's wrong it's utterly asinine to advocate a culture where you can't say it because of I don't even know why.
You nailed it. I'm glad another go user could chime in. Thanks!
finally! great crate, have tls now and works with new serde! gonna need to update my websites now!
Congrats on the big release, Redoxers. The progress is really impressive. I have the hope and feeling that Redox is going to get over the hump and become a 'serious' OS faster than people might expect - it's built in Rust, so it has all the maintainability advantages that go with that; and we should probably expect it to run an increasingly large portion of the growing Rust ecosystem. The more systems software is written in Rust the more that software can be plugged into Redox for its own benefit. Super excited.
LOL I didn't know what Voat is before today. 
You literally called an entire user base ignorant. That's not acceptable. Plenty of other people in this thread provided plenty of criticism of Go without flame bait. I'm asking you to do the same. Please see the rules on the sidebar.
This is an awesome release! I'm curious about the Fairings. I've been able to think of a couple uses, like the example of logging, and maybe a request-limiter for load-balancing. But, I'm just curious if anyone is willing to share any other ideas for intended uses where this is better than request guards?
&gt; You literally called an entire user base ignorant. That's not acceptable. And what if it's true? Is it also not acceptable then? Like I said I see two reasons for using Go: 1. Your boss tells you to 2. You're blissfully ignorant of better stuff If you disagree you're welcome to argue why. &gt; Plenty of other people in this thread provided plenty of criticism of Go without flame bait. I'm asking you to do the same. Please see the rules on the sidebar. My criticism is constructive now and it was constructive the last time as well as in the follow up post; I provided arguments for my conviction why I cannot fathom why anyone would use Go out of free will except for an ignorance of languages with superior design. If you believe my conviction is wrong you're welcome to point out parts of Go that aren't covered better by other languages but what you're saying now comes down to "don't tell hurtful truths".
I wonder if this fuss about Ember is at least partially due to a cultural disconnect between the worlds of JS and Rust. In the world of JS, you run code to build an artifact that gets deployed to a server where it runs to build a webpage that gets downloaded to a browser where it runs to display the actual content. It sounds like the new Rustdoc fits neatly in that paradigm. In the world of Rust, the compiler does as much work as possible up-front, so the resulting artifact can be used with little or no runtime environment. That definitely describes the "static HTML and CSS" that I think a lot of commenters in this thread were expecting. It's a tough line to walk: you don't really want the official Rust documentation tool to feel weird and alien to Rust developers; on the other hand, you don't want a tool that works with HTML and CSS to feel weird and alien to web developers.
If you need some mentorship in Rust, the [Ion Shell](https://github.com/redox-os/ion) has a number of easy projects to work on that I can assist in their implementation. Namely, we have a lot of [builtins that aren't implemented yet](https://github.com/redox-os/ion/issues/409) that we'd like to have implemented. They don't require much effort, and are isolated from the rest of the shell, but it does take time to implement them all. I've been busy with addressing all the most difficult issues and features, so I haven't had time to implement them.
I would love to tentatively replace my usage of iron with this but I'll wait for it to be usable without nightly. 
I have prepared a virtualbox using the .iso The booting shows two edit controls without any labels. I guess they are for user name and password but I have no clue what to type there.
[rctree](https://github.com/SimonSapin/rust-forest) - reference counted nodes with iterators and borrowing for inner mutablility. It's used by the servo browser engine, so I think it's a good representation for a DOM. It has also three different versions, depending on what memory model constraints you have. I don't think polymorphism has anything to do with DOMs. Yes, you can create a DOM&lt;T&gt; where each Node is a different type, depending on what data you want to save with it. DOMs are highly dynamic, homogen, tree-like data structures. Traits are used for generating code of special types at compile time, for easier code reuse. They have nothing to do with each other. Maybe you mean nested structures / generic fields in structs?
It's impossible because statements 1 and 4 contradict each other. 1. An Allocation cannot outlive the Allocator [...] 4. An Allocation must be able to outlive the Allocator [...] Or clarify the statements. Are there seperate types. I don't understand what you want, because either you manage the memory in the Allocator (i.e. the Allocator stores a Vec&lt;Allocation&gt;) or in Allocations that hold references to memory stored in the allocator (this would be done with lifetimes, but harder to do). The last thing would be to have an Allocator that spits out Allocations to whatever calls it. Then the Allocations may outlive the Allocator. What is your definition of "Allocation" vs "Data"? And last, why do you need to do this, are you writing a memory manager of some sort? What's the context / use-case?
Depends on your use case, but https or not, I'd always run a web facing server behind nginx/haproxy. Too easy to catch a bad case of slowloris otherwise.
Haproxy seems like a good candidate for "rewrite it in Rust" :) My use case is prototyping a beta project. Load balancing comes in when it gets popular enough that I consider upgrading from the cheapest tier VPS.
&gt; If you think Go is bad, C is even worse, but people seem more accepting of C. I came across Go and Rust when looking for an alternative to my bad experience with C for my first micro-controller project. Go iirc turned out it couldn't really participate, but I'd still have gone with Rust regardless as I did.
Excited to see work being done to clarify the rules around unsafe Rust. In particular the issues about aliasing has always been one I feel uneasy about violating in my unsafe code (using raw pointers of course, I never alias references), so having a dynamic checker to have my back will help a lot. 
First box is for the username. You either type "user" or "root". The second one is for the password. For the user "user" you can leave this field empty or type anything you want. The password for the "root" user is "password" 
I built a CV generator app so I can customize/tailor what's best appropriate for the job, while having versioning/flexibility with how it's composed/looks. It just outputs static HTML/CSS from a JSON file and Marko templates(modular snippets that will compose based on the structure of the JSON). It works pretty well and I prefer it alot more than the more manual changes I did in the past, especially when I experiment with layout or style changes. All the text content is markdown filenames in the JSON, I'll probably move the files into a database at a later point. Allows for easy rich text(italic/bold/bullets/etc), the Marko template converts it into HTML, works great :) --- **TL;DR:** - Data via JSON and Markdown - Structure composed of Marko components(potentially influenced by JSON elements) - Layout and style via CSS - Outputs static HTML or PDF No idea what rustdoc contribution is like, but if anything like my setup, it's pretty simple. Someone mentioned it outputs JSON, so shouldn't be difficult?
&gt; Be good for more than API docs, like guides I wouldn't mind seeing something like Jupyter notebook support with a IRust kernel? Though I've seen rust books with embedded/runnable code snippets already.
That doesn't sound like Rustdoc, though. There's no server required, and there's very little that actually needs to *run* on the resulting web page- collapse/expand and search is all I'm aware of. Pulling in Ember when all you need is to toggle some CSS properties and do some string matching is absurd. If you want it for the template engine, well, it supports server-side rendering, and there are options that don't even leave the Rust ecosystem.
I'm curious why, it would have provided the ergonomics I as a user was confused were missing. I don't see the downside.
Hell yeah! Thanks
Google for "streaming median", there were very good solutions especially if you don't need exact answer and can afford to have an approximation with a controlled error.
Because *I* would expect collect on a tuple to dump the elements of the iterator into the tuple. The problem with "convenient magic" is that people rarely agree on *which* convenient magic should be used. It's only convenient if you just so happen to have exactly the same thought process as the person who implemented it. More generally, I really don't want Rust to turn into yet another highly magical language. We already have *plenty* of those. One of Rust's big selling points its its relative lack of magic, and strong consistency.
Sorry, but we don't do language bashing here. Go is a fine language for its purpose, which is to make reasonably-safe and speedy web services, fast, without much fuss.
It was mentioned in breaking change.
I've made my proposal. Hope it gets picked up. 😊
But threads use much more memory than goroutines, and the context switching is more expensive. A "goroutine pet client" model is feasible in Go with tens of thousands of clients, but it's not feasible using OS threads.
If message passing is the preferred method, why are async/await being integrated into the language?
Not sure what are these amazing languages you are talking about that make writing concurrent code such a joy and provide parallelism in the runtime and very easy to learn and become proficient at it.
Ocaml doesn't have any support for parallelism yet. So, it is not the same. Also go has faster compilation times. Also people who are not actually familiar with a powerful type system, it is not an immediate go-to language without some sort of mentoring. There is some effort in fixing the hurdle for new-comers. Also regarding dimensional analysis, sure phantom-types will do it, but inference will not work very well. 
My experience is that mostly slow things are built with it. Crates isn't the only example, discourse performance isn't great either, especially on mobile. I'm really not sure what pros there are to using ember for something so simple. Especially over just using a template library. I know you've said elsewhere that you want it to be like contributing to a Web app but there's plenty that use templates. In fact I'd hazard a guess that most use templates. 
How would this approach handle duplicate values?
Hi! I experienced similar issues when installing on Windows, maybe [my thread](https://www.reddit.com/r/rust/comments/6g00gm/help_with_rust_toolchain_on_windows/) will be helpful to you. 
You still can reproduce most of `Box`'s functionality with user code, at least. AFAIK, the two things that are currently magical, and can't be reproduced by user types are these: 1. You can dereference `Box` to move out of it. 2. You can have `self: Box&lt;Self&gt;` as the `self` parameter for a method.
I'm using [rctree](https://github.com/SimonSapin/rust-forest/tree/master/rctree) in [svgdom](https://github.com/RazrFalcon/libsvgdom). Fine by me.
Last I heard, there were no concrete plans. The [focus for this year](https://blog.rust-lang.org/2017/02/06/roadmap.html) is on ergonomics, so you would probably be waiting *at least* six months before any sort of major push. Possibly longer. Also, HKT is unlikely; the current most likely contender is ATC (associated type constructors), which I *believe* is akin to putting generic `type` aliases in traits.
Thanks for the breakdown. I suppose this is... unsurprising. Network effects are really hard on newcomers.
Yep, exactly!
An equivalent to Higher Kinded Types is explored under the name of Associated Type Constructors (colloquially known as ATCs). Or at least, it [seems it is equivalent](http://smallcultfollowing.com/babysteps/blog/2016/11/09/associated-type-constructors-part-4-unifying-atc-and-hkt/). There is no ETA that I know of. Variadics seem... further away. The need for them is somewhat lessened by the fact that: - macros allow variadic arguments, and therefore variadic constructors for example can be expressed as macros (see `vec![1, 2, 3, 4...]` for example), - tuples (which are variadic magically) can implement custom traits up to a certain size via said macros, emulating variadics via recursion, somewhat akin to what C++ used to require before C++11. There are other big features which seem more important than variadics in my eyes: - Pi Types: the ability to use values as generic parameters; which would greatly simplify working generically with arrays, matrices, typed quantities, ... The goal here is to start with support for integers. - Compile-Time Function Execution (CTFE): MIRI is a prototype interpreter which would allow such computations; the more complex functions can be executed at compilation, the more complex types can be used in `const` variables and stored in RAM... and of course it synergize with the above Pi Types. - As mentioned, Associated Type Constructors; at the very least, a version of ATCs working with *lifetimes* would be very useful. At the very least Pi Types and ATCs require significant work on the type system, and I am not sure whether they can really be worked out concurrently. I think that attempting to work on variadics at the same time would be really difficult, and I also have some doubt with regard to the availability of qualified designers/developers given the work already scheduled. So... it would be great to get a restricted form of ATCs (lifetimes) before the end of the year, and variadics may not even come before the end of next year. --- *On a side note, there have been proposals for restricted forms of variadics, only limited to manipulating tuples in a generic manner. I think such a restricted form could be sufficient to encode a lot of patterns, even if clumsily, and it might be much easier than the complete variadic story.*
&gt; I have a draft ready now, and I want to share it with the world to see what the world thinks about it. Did I miss the obvious? Is the draft accessible already? --- *Side note: a typo* &gt; which leads to miscompilations (in the eye of the programmer) and sometimes to security ~~vulerabilities~~ **vulnerabilities**.
Create a route to serve static files? That's what I've done, not sureif it's the best way though. 
&gt; Because I would expect collect on a tuple to dump the elements of the iterator into the tuple. I understand. I can't imagine what should happen if there are too few items in iterator. The tuple is fixed-size and `collect` can't fail. &gt; More generally, I really don't want Rust to turn into yet another highly magical language. I agree. The question is where is the line between too much magic and too much boilerplate? For now I strongly agree with someone who described it as reasoning footprint - how hard is to understand what it's doing. From that POW, I can see that `collect()` is practically an alias for `FromIterator::from_iter()` and I could quite easily look up `impl&lt;A, B&gt; FromIterator&lt;(A, B)&gt; for (Vec&lt;A&gt;, Vec&lt;B&gt;)`.
&gt; The only factor is unsafe when working with IO, I2C, SPI, etc. There's a crate called `i2cdev` and I've successfully used it to create [Heimdall](https://github.com/Progressbar/heimdall) - a system for entering [Progressbar hackerspace](https://progressbar.sk). It worked well for me. Good luck with your project!
The problem is not the mechanical "where do I look for the definition" issue, it's that `collect` means "collect this iterator into a collection". You want to redefine it to "collect this iterator into a collection, except sometimes it unzips it into two instead". It's that "except ..." bit that I object to, when you can almost as easily just use a different word for that operation, and keep the nice, clear, consistent definition. I don't *want* to have to look up the specific definition of every implementation of a trait to find out how the author has creatively interpreted its definition. When magic is some big, ubiquitous rule that has wide ergonomic benefits, sure, it could very well be worth the cost. Like deref coercion; that comes up *all the time*. When it's an exception to a well-established rule or definition that only benefits a very, *very* niche case, I think that's going too far. That's heading toward "i before e except after c, except for deceit... and fancier... oh, and seizure... *(insert hundreds of words here)*" territory.
I'm not sure I understand.
By using an implementation of B-Tree which allow duplicates.
I think the HKT/ATC plans are more concrete than you think: The ATC RFC is [about to enter its final comment period](https://github.com/rust-lang/rfcs/pull/1598#issuecomment-308187067). That post also mentions that * the official terminology is likely to be "generic associated types" * the features suggested by this RFC are apparently already implemented in [chalk](https://github.com/nikomatsakis/chalk), so it seems likely that they will arrive in rust soon after chalk does.
I'll check out your implementation. This is really useful, thanks for the reply!
1. Thanks for the link to rctree and the hint about each version addressing different memory models. That's really helpful to know. 2. &gt; I don't think polymorphism has anything to do with DOMs Agreed. That was a mistake on my part. I've edited the question to make it clearer.
To those wondering what Tock is, [from the homepage](https://www.tockos.org/): &gt; An embedded operating system designed for running multiple concurrent, mutually distrustful applications on low-memory and low-power microcontrollers.
No but if you use `--release` it'll go faster
 Thanks again! I've deleted add and for is_match I've used "match", it think looks readable. And used all you other suggestions. Looking better, thanks a lot!
It could be useful if we had an idea of what `n` is... an optimal solution for 1,000,000s will focus on algorithm complexity while a solution for 10s will focus on micro-architecture considerations. --- Assuming **big** `n` but less than 2^32 . I have seen heaps/B-Trees being recommend, they make sense in general, but for u32 I expect that you can get a lot more mileage from a slightly different data-structure. It's the equivalent of using a radix-sort rather than a plain sort; after all a u32 only has 32 bits! So, I propose to organize a tree as: struct Index(u32); struct Count(u32); struct Node { nodes: [(Count, Index); 16] } struct SeaOfNodes { nodes: Vec&lt;Node&gt;, free_list: Vec&lt;Index&gt;, } struct IndexedRadixTree { sea_of_nodes: SeaOfNodes, } The `SeaOfNodes` is essentially an optimized allocator, which allows using a `u32` as pointer, instead of a full 64-bits pointers, thus shaving off half the width. If you feel fancy, you can replace `free_list` by an `Option&lt;Index&gt;` and interlace it in the "empty" nodes. The `Node` itself is optimized to occupy exactly 128 bytes (`16 * (4 + 4)` bytes) which is exactly 2 CPU cache lines. Looking up an element in the `IndexedRadixTree` is done by using bits off the `u32` key 4 at a time (I suggest starting from highest, if your values are clustered), thus the tree is always exactly 8 levels deep, and it takes a fixed-count loop to get to the leaf containing the key. Each node contains a `Count`: - for a leaf it's the number of elements with that key, - for an intermediate node it's the number of elements in the sub-tree. You need to maintain the count when removing/inserting (at all 8 levels); when a count reaches 0 the node can be returned to the free list. The median element can be accessed by using the count of elements in each sub-tree to navigate to the correct element; the complexity is constant (8 levels, 16 elements to sum per level, maximum 8*16 comparisons). --- I would combine this approach with a circular buffer (to remember what is the oldest value to pop-off), and be on my way. --- *Note: if you like AVX512, there might be way to speed-up the median look-up by using two arrays (one for Count, one for Index) and AVX512 instructions to compute the cumulative sum, compare it to your goal, and get the index at which the comparison result changes. I'm not that well-versed in assembly though.*
You don't need to remove rust, as it makes your boat more secure. Just stay away from the c...
Probably check your cargo manual?
If you look at the [Techempower benchmarks](https://www.techempower.com/benchmarks/) and the [entries' sources-code](https://github.com/TechEmpower/FrameworkBenchmarks) you'll see that it's easy to create incredibly high-performance web-servers in not much code with Go. Rust does not compete (yet). For web-services in particular, Go gives you the best performance for developer time, and in fact beats most other languages: including Rust, C++, Java, PHP, Perl, and Scala. Go also is better than Rust for desktop software, thanks to the stable [libui bindings](https://github.com/andlabs/ui). In fact there's a huge variety of third-party packages. In terms of language design, Go -- like Rust and Swift -- allows you to implement traits/interfaces/protocols after the fact, and to essentially move from a hierarchical approach to describing functionality to a tagging approach. This is pretty neat. However the Go designer's focus on practicality over elegance does begin to grate sometimes. For example the built-in collections have generics support (I can say this is a list of `People` structs only), whereas user-defined collections cannot, and just have to take raw pointers and cast them, which has lots of problems. It can become pretty easy to create quite messy code in Go after a while. It's easier to design more stable code in Rust, thanks to it's more full-featured ML-style type-system, and support for sum-types ("enums") and newtypes (single-element structs) in particular. More bugs (e.g. null-pointer exceptions, data-races, forgetting to close file-handles) are caught at compile-time in Rust: in Go they happen at run-time. Consequently, to ensure the same level of software stability in Go requires many more unit-tests, or luck. However this may also be a second stumbling-block to you: Rust's type-system does not support inheritance, and getting out the mindset where things have is-a relationships, and instead replacing it with one where things have capable-of relationships, is something that has tripped people up. Rust this time next year will likely be a much stronger competitor to Go in the high-performance web-server stakes than it is this year. If you're only starting out, I would therefore say Rust is a better choice. Further, Rust and Apple's Swift are _very_ similar languages, so if you ever think of moving into iOS development, the most from Rust to Swift will be much easier than the move from Go to Swift.
could you give me more infos, such as sample code ? thx :)
&gt; Because C is fucking fast; Go isn't. While they have their problems, the [Techempower benchmarks](https://www.techempower.com/benchmarks/) give a reasonable picture of what performance the average developer can do with typical problems. Go is one of the fastest languages there: faster than half the C++ submissions, most of the Java submissions, and all the C#, Scala, Rust, PHP, Perl, Python, Erlang, Haskell and JavaScript entries. C may excel on micro-benchmarks created by committed developers. However the average dev-team, in the average company, will get great performance from Go. I personally don't like the Go language design much, and am hoping all the Tokio and async/await work pays off and Rust gets into the same application-level performance as Go. But Go is an excellent language for application development.
&gt; I found this super-simple with xargo. (Although I tried only microcontrollers - not RPi.) I set up cross-compilation for my [OpenPandora](http://openpandora.org/) (an ARM-based pocket laptop which is comparable to the Pi as far as porting goes) quite easily. 1. Install a suitable cross-compiling GCC. 2. Identify the LLVM equivalent to that GCC's target triple. (`arm-unknown-linux-gnueabi` in my case) 3. `rustup target add &lt;triple&gt;` 4. Add something like this to `~/.cargo/config`: [target.arm-unknown-linux-gnueabi] linker = "/home/ssokolow/opt/pandora-dev/arm-2011.09/bin/pandora-gcc" 
I'm using `error_chain` and cleaning things up for a 0.1.0 release of a simple program, and I've gotten to errors. I've tried formatting errors with `std::panic`'s tools, but it seems that errors thrown using `error_chain` aren't being passed a payload correctly. For example, an error being thrown is given by Err(ErrorKind::InvalidConfigError("index padding must be a non-negative integer".to_string()).into()) where `InvalidConfigError` is defined in my `errors.rs` as: errors { InvalidConfigError(t: String) { description("invalid configuration") display("invalid configuration: {}", t) } However, the `PanicInfo` passed to the panic hook is PanicInfo { payload: Any, location: Location { file: "/checkout/src/libcore/result.rs", line: 859 } } Trying to do the recommended practice to the payload (`panic_info.payload().downcast_ref::&lt;&amp;str&gt;().unwrap()`) results in a panic itself, since it's not a `&amp;str` (thus trying to downcast it results in a `None`, and panics on `unwrap()`). Tapping into nightly's `get_type_id()` on the payload doesn't really help: `TypeId { t: 14806796922000246706 }`. For completeness, the normal panic looks like thread 'main' panicked at 'Failed to verify database existence: Error(InvalidConfigError("index padding must be a non-negative integer"), State { next_error: None, backtrace: None })', /checkout/src/libcore/result.rs:859 note: Run with `RUST_BACKTRACE=1` for a backtrace. Am I formatting my errors wrong, or does the hook not get the information it needs?
Is chalk going to be integrated with rustc proper, replacing the current trait code? Or will it be just a reference?
[There's an example in the Rocket source](https://github.com/SergioBenitez/Rocket/tree/master/examples/static_files)
As far as I know, yes. The Project on Github also states "A PROLOG-ish interpreter written in Rust, intended eventually for use in the compiler".
Doesn't seem to solve my problem. I have many structured keys and one or several unknown keys. Also the format is Yaml
Awesome, thanks!
there is a conceptual '128bit binary value' type e.g. returned by some simd operations, usable as a bit mask, but invalid for arithmetic (and arithmetic wouldn't work anyway) various states in permutes might be describable this way, e.g. its possible to use a 4x4 x (32bit) transpose to get 'AOS' into 'SOA' data, (e.g.struct { x,y,z,flags} 0,1,2,3 becoming (x0,x1,x2,x3) .. (flags0,flags1,flags2,flags3) .. but the intermediate states spat out by the permute instructions would have weird types; might be better to just call them 'b128' (i suppose you might be able to express it all properly but the simd stuff might expect homogeneous data at every step, in which case pretending it's 'b32x4' is better than anything else)
Thank you for explaining! Now I understand it better. Thinking about it bit more, it seems like either `collect` uses badly named trait or `FromIterator` should clearly state in documentation that "This is intended only for collections to not confuse people." instead it says "By implementing `FromIterator` for a type, you define how it will be created from an iterator. This is common for types which describe a collection of some kind." My understanding is that `FromIterator` doesn't restrict types to collections. `collect` uses `FromIterator` and therefore it shouldn't restrict types to collections either. BTW, I think that with enough imagination `(Vec&lt;A&gt;, Vec&lt;B&gt;)` can be considered collection (but I'm not going to strongly debate this). What I'm saying here isn't that we have to implement this. I'm saying that maybe we want to update the docs.
Why is there no number/integer traits in the core/standard library (I am aware of the num-traits crate)? From what I can see there was at one point, but they were removed.
This is great, and may be very useful. I'll try it out with some other approaches, thanks.
I think the example is too simple, more details will be better :(
Well, that syntax is already valid, so it would definitely be a breaking change. Setting that aside, I definitely don't like case-sensitive syntax. If the use-case for this is parsing files that can *also* be directly parsed by a C compiler, you might get better mileage out of a compiler plugin that just parses an appropriate subset of C directly.
All the things you point out also depend on the programmer in Rust. Nothing stops a library in Rust from using panic, ignoring a failure, badly using unsafe, etc... So what are you on about?
&gt; handling the possibility of throws on moves without leaving "holes" in the vector was really hard. In Rust, this is trivial, because a move boils down to a memmove so it's guaranteed not to have exceptions. So why didn't you use memmove in C++ too? &gt; And yes, noexcept matters, because if you accidentally allocates in a noexcept function, the compiler will not complain. That's about the only reasonable thing you said.
The new login screen is still a bit WIP. If you make a mistake, tab switches fields. I want it to look more like lightdm when it is completed.
If I am not mistaken, specialization should allow this shouldn't it? Also Stdout does not *seem* to implement AsRawFd even though it claims it does, which is why I created this trait in the first place [Here is a minified version that displays the same issue](https://gist.github.com/anonymous/6261be303f7e6de02303be0e58289b40)
Yet the README.md of the project states "A Prolog-ish interpreter written in Rust, intended perhaps for use in the compiler, but also for experimentation".
is there an include!(), maybe we could wrap a rust macro around that (a rust macro that decodes some c macros)
`macro_rules!` doesn't work that way, and if you're doing a procedural macro, you don't *need* to use `include!`.
Funny, the only other link I found was a Github issue where people say that [static file serving should be simpler](https://github.com/SergioBenitez/Rocket/issues/239).
first of the series
Re. the `$` vs `#` in commands: I think you're meant to learn that in the terminal. Most shells end their prompt in `#` for root, `$` for other users. I guess the issue here is that people just use `sudo` instead of `su` / logging in as root.
i don’t agree with the tech empower benchmarks. They aren’t actually web servers, they’re just hard coded responses... as hard coded as they can get, so they don’t test anything you can actually draw conclusions from. The [Benchmarks Game](https://benchmarksgame.alioth.debian.org/u64q/which-programs-are-fastest.html) and every single other set of benchmarks i’ve ever seen show that Go is significantly slower than Rust... like half as fast, probably even slower. Go is extremely well optimized for web servers, so it is a best case scenario even without all the stuff that makes tech empower pointless.
Here Here! (I love inline, escape-proof text)
But in a real project, it is so common that you have a lot of static files :(
Haven't tried to install Redox yet but I love using Ion on Linux. Wish it had manual files or help for commands like calc, or docs/wiki of some sort. Also theming support would be nice, but I guess it is way too early for it. Prefer Ion over fish tbh.
yeah, I specifically said when it comes to application level development. Embedded software or kernel space software are nonstarters with Go. It’s not built to run without an operating system, although one guy has had some success forcing it to be a thing.
You're probably going to wait a long time, then. Rocket uses a huge number of unstable features.
I assume you are talking about the Tensilica LX6 used in the ESP8266 and ESP32, which only has a GCC backend. Depending on the level of effort one is willing to spend 1. Write a proper LLVM backend 2. Write a backend that targets a simple VM, write that VM in C 3. Given an [existing backend](https://github.com/llvm-dcpu16/llvm-dcpu16), modify it, or provider a translator. One could say binary translate from something easy like MIPS in to LX6 4. Do the opposite, write in C and translate to Rust for correctness checking via [Corrode](https://github.com/jameysharp/corrode) 5. re-re-resurrect the [CBE](https://github.com/JuliaComputing/llvm-cbe) For pragmatism, I'd would choose 4, everything else feels like a quagmire. 
It's easier to iterate on a design before locking it into the standard library where it can pretty much never be changed.
My guess is you need to downcast to `errors::Error`, then match on its `.kind()` to see that it's an `InvalidConfigError`.
I know it's faster, because the dom isn't the optimal way to do a dynamic ui in the first place. That's the idea of using a dom-like ui for "desktop" apps which scares me.
It is impressive. I still think it is a shame that they are copying the design of Unix so much when they have an ideal opportunity to improve it.
The problem is much rather that you are not joining back your threads, so your program is likely to stop before the second thread even properly spawned.
If you look at the very next sub section, you'll see that the problem is expected: &gt; Not only does the code in Listing 16-1 not allow the spawned thread to finish most of the time since the main thread ends before the spawned thread is done, there's actually no guarantee that the spawned thread will get to run at all! What you are seeing is that the main thread is finishing its prints, and terminating, before your second thread has had a chance to even start. 
Note for passers-by: "Pi types" are more traditionally called [dependent type](https://en.wikipedia.org/wiki/Dependent_type)s in the literature.
So in other words, there may be one in the future, but the details haven't been decided on?
Right.
The Fortune and DB read tests at Techempower both involve the app being asked to fetch a random row from a database, encode it (in HTML and JSON respectively) and then return them, using HTTP Now it's the same "random" row every time, but the apps aren't allowed exploit that knowledge. Admittedly the table-size and amount of info being transmitted across the wire is tiny, but it's still a decent reflection of real-world usage, certainly more so than computing spectral norms or applying regular expressions to DNA sequences. I don't doubt that in a world without IO, Go is much slower than Rust. But such a world only exists in the benchmarks game. For concurrent, parallel servers, Go gives excellent results for very little programmer input. 
&gt; So why didn't you use memmove in C++ too? Because it's not possible? In Rust, a move is a bitwise copy, and the source is *statically* known not to be in use any longer, thus there is no need to "zero" it. In C++, a move is a user-defined operation, which may execute any kind of logic, and may throw unless otherwise specific, and must leave its source in a destructible/assignable state. C++ is strictly more flexible, of course, and it's unclear whether anything else could have been specified given concerns for backward compatibility (notably, compatible behavior with Copy Constructors which may also execute arbitrary logic). However, at the same time, this flexibility has a cost for generic code, since there you cannot assume much about what a move can do. Unless you wish to restrict your container to types advertised as nothrow movable (which is reasonable, but not as generic as it could be), then you need to cater to their special needs, and it's complicated. And of course, even if you restrict to types that cannot throw on moves, you still won't be able to use `memmove` unless they are trivial; doing so would bypass the potential special logic embedded in the move constructor/move assignment operator. *Note: For an example of custom logic in moves, look no further than the observer pattern; the observee should have a pointer to the observer, and therefore when the observer moves it needs update this pointer.*
Simply pointing out that there are flaws with the C++ solution, and it's therefore not obvious that it's the best way to handle memory allocation failures.
&gt; But such a world only exists in the benchmarks game. Not really. I watch my processor cores get maxxed out all the time, and I'm not talking IOWAIT. I've written biz apps that are cpu bound, web browsers are often cpu bound (not network bound), and believe it or not, but there are people out there doing DNA sequencing and spectral norms and other stuff. And Go does give excellent results on that website, but it's worth noting that those excellent results come from using fasthttp, instead of the built-in net/http. At my workplace, we're just using net/http, since that was the system architect's decision. I wonder how many people out there just use net/http. It's not *bad*, but it's not that impressive, even by tech empower standards. But, whatever. I'm not going to argue about this, I don't have enough time to waste today on arguing with strangers.
put `#![windows_subsystem = "windows"];` in your `main.rs`. ([rfc](https://github.com/rust-lang/rfcs/blob/master/text/1665-windows-subsystem.md)) in a related question: is there a way to configure it so that the subsystem is `"windows"` for release mode but `"console"` for debug mode?
Just copy the route with static file serving and files in static folder will be available
&gt; on the other hand, you don't want a tool that works with HTML and CSS to feel weird and alien to web developers. Plenty of web development involves templates that are filled in server side.
This is super exciting! Great work.
Looks like that will be a good search term for a larger statement to make platform independent setups too. Thanks!
It's a pragmatic compromise.
Yeah, it currently is the ESP32 :-) 4 is actually a very novel idea. 
Would it be better to return a result from the API calls? 
Which designs are being copied, and what do you think could be improved? One reason to support some UNIXy stuff, like certain common UNIX syscalls, is to make it easier to port existing software to Redox.
Have you had much experience React? It seems odd and disagreeable at first glance but it's actually really nice once you give it a fair go. I've used some other UI libs that aren't web based in the past Feathers UI for Starling (Flash/AS3) was kind of nice, but I remember it becoming problematic to manage when UIs got more complex with alot of composition and component inheritance/extension. As long as performance is solid, I'd take all the benefits of React and Redux for building UIs any day :| That said I don't think it'd translate as well to Rust.
I'll try to work on that soon. If there's anything that you'd like to see improved / implemented, then I'd suggest opening an issue on GitHub so that I can remember to implement it and take the issue down.
&gt; Sorry, but we don't do language bashing here. What if it's _true_? This is stupid. Can I also not say that the original BASIC is a disaster that mutilates your brain or do I need to be Edgser for that and do you make an exception for hero worship? &gt; Go is a fine language for its purpose, which is to make reasonably-safe and speedy web services, fast, without much fuss. Oh yeah sure, as long as having to generate template files yourself with characters from the Canadian Aboriginal syllabic script qualifies as "fine" in your definition. What language isn't "fine" then in your opinion? Be careful you might be 'language bashing' if you utter criticism. If everything is "fine" then the word becomes meaningless.
I know you're probably not going to look back here, OP, but still - poor form for deleting a question which someone else might well be tearing their hair out over.
It looks great already!
If this is really what you want, then I would advise a connection pool. Using something like `lazy_static!` to create the pool itself, and then a `ConnectionGuard`: - building the guard acquires a connection from the pool, - a getter allows to retrieve a reference to the connection (or maybe a mutable reference, as needed), - at the end of the test, the guard is dropped, releasing the connection to the pool. There is one difficulty, though, if a test clobbers the connection for some reason, then all the subsequent tests using this connection will suffer from it. This might be potentially difficult to track down, and may cause unrelated tests to fail in the same run. Also, since the tests run in parallel, you'll want each of them executed on a separate schema (or "database" in MySQL), and each one will need be primed and readied for each test. While establishing a connection is pretty cheap, readying the schema is not. Ideally, you'd want to destroy it and recreate it from scratch; or at least truncate all tables. And each test will need to insert its own dataset, satisfying all foreign keys even if some tables are not actually used by the test. --- Thus, personally, I would advise either: - sticking with just creating the connection, and worry about the performance if it becomes an issue, - abstracting the connection away. And I advise the latter. The principle of unit tests is to avoid having such heavy dependencies as a database in the first place. Confronted with such a problem, I personally prefer to cut down the dependency. I've used two ways in the past: - the database typed interface: for each table/set of closely related table, a virtual method per query, - a real implementation for each interface: a single integration test is in charge of checking each interface, with a test for each combination of method and failure mode inherent to this method (Rust's explicit failure reasons makes it easier not to forget any), - a mock implementation for each interface: my recommendation is a basic log-based mock; each implementation defines one enum with a variant holding the inputs/outputs for each method, and holds onto a sequence of such enums. This allows testing both the order/quantity of times each method is called, checking that the expected input is provided, and returning the desired result. Not lightweight, but thorough. Then, in your tests, you obviously use the mocks. They should be much more lightweight to create than a full-blown connection, and allow you to test failure modes that may not be easy to setup (such as connection failure, timeout, ...). Also... I've never used this with an asynchronous event reactor before, so there may be some inherent issues that may make this totally impractical that I am not foreseeing. But hey, at least it's a solution that's been tested and used, even if not in the same condition ;)
&gt; Did I miss the obvious? Is the draft accessible already? Sorry, I may have been somewhat unclear: I do have a draft, but not yet in written-out form -- it's currently bullet points, not very comprehensible. I am currently writing it out, which should be done by Monday. &gt; Side note: a typo Thanks, fixed :)
The same or similar flaws exist in Rust.
The connection pool in mysql_async stores a reference to a Core, which isn't Send, so I can't make it static. I already abstract the connection away, but I still need a way to test my actual SQL queries - for example, if I change the database structure, I need to know my unit tests will pick up any errors caused by it.
I wrote this example: https://gist.github.com/anonymous/c746587285815e563415532c47a04773 It uses pattern matching instead of if-statements to detect "y", "n", and unknown input.
You can look at [what I've done](https://github.com/marcusball/buprestidae/blob/master/src/main.rs#L97) for [my blog](https://www.marcusball.me/), though it's pretty much the same as the sample code. Edit: Oh, are you asking for how to generate a URL to the static files, not just how to serve them? If that's what you're looking for, it's not available right now. Adding a `url!` macro is [planned for version 0.4](https://rocket.rs/news/2017-07-14-version-0.3/)(see: "what's next" at the bottom); [GitHub issue](https://github.com/SergioBenitez/Rocket/issues/263). Though, I don't see why you wouldn't just hardcode `/static/css/style.css` wherever applicable. Seems weird to try to dynamically generate a static url. 
Hmm, I have no experience with SIMD, so I don't know. Don't worry.
It's totally feasible to do that on x86-64 Linux. Threads don't use much more memory than goroutines, because stacks are paged in lazily. Async I/O started to become popular back when 32-bit was the norm to address the "C10K problem", which primarily resulted from running out of address space. Now that 64-bit is everywhere, that issue is effectively obsolete.
Async/await has nothing to do with message passing!
The 0.4 roadmap looks pretty awesome. Good job guys and congratulation on the 0.3 release!
I'd this through an integration test then (or several for parallelization), and pay the price for it. You can pass a flag to `cargo test` called `--lib` to only play the unit tests, which will pick up most errors, and only play the integration test before committing.
Ah great; looking forward to it!
Not really. For the simple reason that Rust aborts on memory allocation failures (at the moment), which is a completely different trade-off. However it seems I am clear not making my point here; so let me try to clarify. I am not interested about arguing over Rust's current solution to handling memory failure: it's ham-fisted, to say the least. My point is that C++'s solution is NOT ideal, for a variety of reasons I will not repeat, and therefore that I would rather avoid adapting C++'s solution without further thought. My hope is that better solutions will emerge for Rust. Will it bear fruit? I am no oracle. I do know it will never come to pass unless solutions are investigated and evaluated though, which is why I am willing to discuss them, and try to expose their benefits and faults, so as to be able to make an informed choice when the time comes.
It's not really specialization *because* Stdout doesn't implement AsRawFd. Specialization only works when one impl is a strict subset of the other, and your impls are disjoint. However, since Stdout could implement AsRawFd later, you get the regular, not specialization related error about conflicting implementations. In this particular case it seems reasonable to allow these impls since they'd be valid if Stdout did implement AsRawFd, so there's no possibility of breakage, but that's only true because the Stdout impl has no generic parameters. In the more general case it would be possible to implement AsRawFd for only specific types such that the impls would become only partially overlapping. It might be nice to allow this, but I don't think it's a bug.
What do you mean by implementing it later? Like if the Stdout type does not implement it in it's declaration and the AsRawFd trait doesn't have an impl for it either, then it shouldn't have AsRawFd should it? Also what do you suggest I do here because I want to write generic code for copying from one descriptor to the other
You mean, the actual SQL tests in an integration tests, and the mocked tests in unit tests? Shame we can't write our own test runners, are there any RFC's (or ETAs) on this kind of feature?
This is called an "self referential struct", and it's a limitation of the borrow checker; you can't do this without unsafe code. I'm on my phone so I can't say more right now but that's the key word you need to find more discussions and instructions for fixing it.
Thank you for pointing these out! I knew about these tricks, but still didn't see their obvious use in my own code until I saw your examples. Time to go restructure a large part of one of my projects for the rest of the afternoon...
No one knows what happens then. It's never been done :)
Take a look at `rustc-test`. It breaks out the test runner code of `rustc` and makes it stable-friendly. It's not the best solution, but it's the best we have right now. Now on the topic of RFCs and such, I know of none ATM. The test-runner code has a few issues that currently are holding it back from having external stable support (outside of `rustc-test` which is more than a little hacky). One of my numerous possible projects is to go through the test framework, clean it up, and submit RFCs to improve it and stabilize the support of external runners that doesn't require the entire test runner code-base to be copied out (as is done for `rustc-test`).
It feels like this *should* be allowed with specialization where it would have been forbidden before.
It has quite a broad (possible) usage. Using the context type you can add a deadline, cancelation signal and metadata to nearly every operation. For example a cancelation signal can come from a kill signal, but also from the closing of an incoming connection. Deadline can be applied to outgoing connection (reads/writes) but also to waiting time before a user types something into standard in (in a CLI application). I'm not really a fan of the `io` part of the name, but `context` alone was already taken.
How does this compare to the [ctx](https://crates.io/crates/ctx) crate?
You may be wondering why the TFS development has seemed to slow down a little lately, and it has to do with some very hard debugging in the `conc` crate. If you're interested in helping to solve it, just pull the repo, `cd` to `conc` and do `cargo test`, and you will see what fails. It is a very complex crate, even though it is relatively small, but I have documented it extensively, explaining what everything does in detail, so if you read the comments and documentation, it should be possible to get some understanding of what happens.
Associated type constructors (mentioned elsewhere on thread) are *possible* this year, depending on how things go with the trait system revamp. If not, I would expect them in nightly early 2018. Variadic generics is still undergoing design work, and has no definite timeline.
Awesome. So I think I was planning on supporting large numbers of values, but I'm realizing that for my use case I'll probably only ever want ~1000, so things like cache locality / instructions are going to matter a lot more than the algorithmic choice. I may give your solution a shot though, since it seems like a very fun project.
&gt;C, for example, has many implementations It has many implementations because it has many companies with independent goals, schedules and priorities. If Rust will get more popular, you'll also get multiple implementations.
Honestly this is a really important thing, I'm surpriised there has been no RFC for it. If Rust wants to be 'web scale' by the end of 2017 (I've definitely heard that said somewhere) then fully supporting TDD is surely a must. The current testing is okay, but really quite lacking. At least it's all standardised, so we can continue to write tests and not have to do a huge refactor once a better test runner comes along. Thank sfor the reference to rustc-test, will definitely be checking that out!
Haha, nice pun.
I agree that this is a lack right now. It's probably instructive to look at [what diesel does for their integration tests](https://github.com/diesel-rs/diesel/tree/master/diesel_tests). Which is, if I'm reading it right, have an external script guarantee that the database is running, then run the migrations in build.rs in a "tests" project, then just establish a connection aft the beginning of each test. I don't know exactly how much overhead that will be compared to a connection pool/persistent core, but until it's definitely a problem trying to optimize this might be a bit premature. Looking at it another way, the reason that no one has written an RFC to improve the situation is because the situation is not that bad.
From what I've seen until now, the team seems to regard Chalk as a kind of testbed for the type checking/reasoning part of the compiler and it doesn't look like they intend to integrate it as a whole, at least not right now. However, IIRC Chalk has been helpful w/rt the negative reasoning part of the impl trait proposal, for example. The whole deal reminds me of the Servo-Firefox relationship.
Oh, it probably should've been mentioned in the first post, but the panic itself comes from `expect`ing that error. On the other hand, I was playing around with types, and I can downcast it to a `String`, but not a `&amp;str`. Go figure.
Because Stdout and AsRawFd aren't defined in your crate, you aren't allowed to assume that Stdout doesn't implement AsRawFd (even though it doesn't). This gives std the flexibility to implement AsRawFd for Stdout in the future without breaking crates that depend on it. Do you need AsFd to be implemented for std::io::{Stdin,Stdout} specifically or could you provide your own Stdin/Stdout types?
We prefer to not have memes here (see rule 3): the signal to noise ratio is too low.
I think there's two things you should do: 1. To make this kind of thing easy in the future, suggest the addition of `impl AsRawFd` for stdin, stdout, stderr in the standard library. Not sure if https://internals.rust-lang.org/ or the rust Github repo would be the better place for this. 2. To work around the missing impl, you can employ the "newtype" pattern. You define a tuple-struct with a single member and create the `impl` you want for that. It probably makes sense for usability to also have auto-deref in this case. Here is an example for Stdout: use std::io; use std::os::unix::io::{AsRawFd, RawFd}; #[derive(Debug)] struct Stdout(io::Stdout); fn stdout() -&gt; Stdout { Stdout(io::stdout()) } impl Deref for Stdout { type Target = io::Stdout; fn deref(&amp;self) -&gt; &amp;io::Stdout { self.0 } } impl DerefMut for Stdout { fn deref_mut(&amp;mut self) -&gt; &amp;mut io::Stdout { self.0 } } impl AsRawFd for Stdout { fn as_raw_fd(&amp;self) -&gt; RawFd { 1 } } You can just put that into a module, named for example `unix_stdio` and then replace calls to `std::io::stdout` with `unix_stdio::stdout`. You will need impl's for all traits that `std::io::Stdout` implements and that you want to use in generic context though. In non-generic functions, auto-deref will let you call methods of the wrapped type on your newtype struct without that, but if you have e.g. a `T: AsRawFd + Write` bound, then of course you will need to `impl Write` for your newtype struct (so for every `fn x(&amp;self, ...)` you just call `self.0.x(...)`) which is a bit annoying but works.
It's the addition of the deadline and cancellation signal that make it more specific than a very general context abstraction. What do you name the thing that doesn't want to carry those features, which are completely useless for a wide range of use cases?
&gt;To make this kind of thing easy in the future, suggest the addition of impl AsRawFd for stdin, stdout, stderr in the standard library. Not sure if https://internals.rust-lang.org/ or the rust Github repo would be the better place for this. [It seems intentional](https://github.com/rust-lang/rust/issues/40007) Also thanks for the idea, even if this does get fixed it will still take a while before I can get the fix on my machine, and this workaround is very useful in the meantime and isn't something I thought of when I wondered "how do I do this in the meantime". Thanks for all the responses here and hope we can work out a solution soon
&gt; You can have self: Box&lt;Self&gt; as the self parameter for a method. Whaaaaaat!
If you aren't going to handle the error, you should let the caller handle it. Generally a library shouldn't cause a panic unless the error is a programming error.
The solution is to describe the highlighted word by its start index and it's end index (or length) with two usizes. Str is a pointer and it would have to be automatically adjusted if the String it is pointing to moves around in memory. 
I feel like the word "secure" is being misapplied here to some extent. Rust achieves *memory safety* at the language level, but *security* is a word with much wider connotations.
Async/await is a competitor to message passing. E.g. if I want to read asynchronously from a socket, in Go I might spin up a goroutine, have it make a blocking read from the socket and send the result on a channel, then have the main loop listen non-blockingly on that channel when I desired a result. In C# I'd make an async method and await it. The ecosystem in Go is built around the former, and in C# around the latter.
Are there any examples of anyone deploying a server in this manner, with 40-50k connections/threads? I thought that the Rust webservers previously suffered on the TechEmpower benchmarks for taking this approach instead of using (implicit like Go or explicit like C#) asynchrony.
It's also MIT!
Thanks your suggestion :). As for hardcode `/static/css/style.css` to wherever applicable, of course I can do it. I am just looking for a elegant solution to handle it. Programming is some kind of art, IMO :), don't you ?
By the way, is your blog powered by Rocket ?
Cool... I'll see if it is difficult to move my blog to this engine.
Good distinction and with that kind of logical thinking, I bet your libraries would be well-written. Are they public by any chance (no pressure!). You'll mostly get "web-framework" ideas here since that's what the framework term has subsumed into. My own understanding is to limited to think much of it but if the framework decides to call me back, it's probably because the things had a few possibilities themselves so rather than me doing the `match/case`, it did and went to the next step. I guess one could create a framework which can allow you a flag about whether it should go with it's opinion or let you handle things and return an Either but I guess the API would be horrible to use. I don't like Frameworks because it can get difficult to follow the flow but I do like that they have an opinion and cover the 90% case. I guess my suggestion would be- Think carefully about what all user may want You can try but don't be fixated on covering every single case. 
&gt; `str` is a pointer and it would have to be automatically adjusted if the `String` it is pointing to moves around in memory. That is how the borrow checker sees it, but since `String` is also implemented as a pointer it's not entirely true. Only a subset of mutations to a `String` invalidate pointers to its contents- moving the `String` itself does not. Some heap-allocating types don't even provide those operations (`Box`, `Rc`, etc.). The [immovable types RFC](https://github.com/rust-lang/rfcs/pull/1858) provides one way to specify this behavior to the borrow checker, so the situation should get better in the future. The OP's situation has the relatively straightforward workaround of using indices, but things like generators (which will be used to implement `async`/`await` for `Future`s) that keep references across suspension points are more complicated.
But you don't have one route per file, you have one route for the whole `static` directory.
I appreciate the Žižek references btw
The first thing I would do would be to expand your glob imports. They can be nice when you're messing around initially, but make refactoring later harder.
Does Alpine not have a rustup package yet?
That's basically my plan. I'm planning to create a piston window, set up some basic menus for common usages (debug logging, status logging, etc), create some standard charts / chart handling (ie, a chart channel that your routine gets where you can send a 'update' message back through the channel which then gets used to update the chart in the ui), a standard set of save/load routines for things like the standard ndarray types (behind a feature flag of course). I figure that should be enough 'around' the routine for working on most basic simulations.
No? I mean, if it did then it'll be a piece of cake!
Count and add one approach is bad because it won't scale. You should leave it to dB to create a id for you. I was thinking if we can have a derive or macro to automate all of this. Diesel is a relatively young library and it requires quite a bit of boilerplate. I think it is improving. 
Would a generic type parameter work? pub struct Game&lt;Id&gt; { pub id: Id, pub name: String, } pub type ExistingGame = Game&lt;i32&gt;; pub type NewGame = Game&lt;()&gt;; Or even this: pub struct NewGame { pub name: String; } pub struct WithId&lt;T&gt; { pub id: i32, pub inner: T, } pub type Game = WithId&lt;NewGame&gt;; Not sure how that would integrate with Diesel, though.
From Diesels own guide: use self::models::{Post, NewPost}; pub fn create_post&lt;'a&gt;(conn: &amp;PgConnection, title: &amp;'a str, body: &amp;'a str) -&gt; Post { use schema::posts; let new_post = NewPost { title: title, body: body, }; diesel::insert(&amp;new_post).into(posts::table) .get_result(conn) .expect("Error saving new post") } The reason they are using a `NewPost` is so that the type system encodes what is required to create a new post, rather than the user of the API having to guess which fields are correct, thus prevents a user of the API (usually also yourself) from being able to make a mistake when creating a post. you'll then notice this bit: diesel::insert(&amp;new_post).into(posts::table) .get_result(conn) .expect("Error saving new post") The call `get_result` mixed with the type inference and requirement that the call returns a `Post` makes sure it returns the post it just created in the database. Assuming your database is configured to generate the ids, it'll return the post with the newly generated id, along with default/generated values for the other columns. That way it's all done in one call to the database, where it can be done.
Please don't manually craft ids :) Actually Diesel could do some codegen to automatically _generate_ the NewFoo struct. It could have something like #[diesel_struct(table_name="games")] struct Game { #[id] id: u32, name: String, } which expands to the code you wrote.
Hmm... It might be too green to give it a try. thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Custom("invalid value: integer `4284898127`, expected variant index 0 &lt;= i &lt; 4")', src/libcore/result.rs:860 stack backtrace: 0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace 1: std::panicking::default_hook::{{closure}} 2: std::panicking::default_hook 3: std::panicking::rust_panic_with_hook 4: std::panicking::begin_panic 5: std::panicking::begin_panic_fmt 6: rust_begin_unwind 7: core::panicking::panic_fmt 8: core::result::unwrap_failed 9: std::sync::once::Once::call_once::{{closure}} 10: std::sync::once::Once::call_inner 11: gutenberg::rendering::markdown::markdown_to_html::{{closure}} 12: gutenberg::rendering::markdown::markdown_to_html 13: gutenberg::content::page::Page::render_markdown 14: gutenberg::site::Site::load 15: gutenberg::cmd::serve::serve 16: gutenberg::main 17: __rust_maybe_catch_panic 18: std::rt::lang_start 
There are other fields that you might want to omit from an insertable struct, for example `created_at`. A solution would have to be slightly more generic than just avoiding `id`'s. Nonetheless, a macro-based solution would be absolutely wonderful! So far, I've been doing what /u/sekhat said, which is to create multiple structs as necessary.
That meetup was awesome, thank you guys for organisation, pizza and that interesting presentation 😊
Why not?
I've just published the first public version of my mocking library, [mock_derive.](https://github.com/DavidDeSimone/mockitol). I'm excited because I was able to get the syntax that I wanted, despite running into some difficulties due to Rust's ownership model. 
Regarding [this question](https://youtu.be/7Mzl2HA3TuU?t=59m11s). This is just simply a forward declaration, and already works with non assembly Rust code: https://play.rust-lang.org/?gist=d1574cd156b6a8b2bb4055aa817543f4&amp;version=stable
&gt; It seems intentional Well, the issue isn't closed. There seems to be some interest in having this, it's just not as straight-forward as your implementation.
&gt;What if it's _true_? This is stupid. You seem to misunderstand the purpose of this sub, so let me reiterate: /r/rust is for discussing the Rust programming language. For general programming discussion, go to /r/programming or /r/coding (in your specific case /r/programmercirclejerk may also be apropos). &gt;Can I also not say that the original BASIC is a disaster that mutilates your brain or do I need to be Edgser for that and do you make an exception for hero worship? Again, the reason is not disagreement. So unless you quote to make a point pertaining to Rust, it doesn't belong here. &gt;Oh yeah sure, as long as having to generate template files yourself with characters from the Canadian Aboriginal syllabic script qualifies as "fine" in your definition. For many applications, you can get by without the compile-time type safety afforded by generics. Many gophers don't seem to miss them. &gt;What language isn't "fine" then in your opinion? Be careful you might be 'language bashing' if you utter criticism. If everything is "fine" then the word becomes meaningless. Languages are tools and serve a purpose. If you are misusing a language (that is, using it for anything besides its purpose, or trying to use the abstractions/patterns from another language), don't blame the language for your troubles. For example, I once had to maintain a python application written by Java programmers – they'd literally written Java code in python. I didn't enjoy that code at all, to say the least.
&gt; You seem to misunderstand the purpose of this sub, so let me reiterate: /r/rust is for discussing the Rust programming language. For general programming discussion, go to /r/programming or /r/coding (in your specific case /r/programmercirclejerk may also be apropos). This is a topic where someone asks if s/he should be using Go or Rust; I gave my opinion on that. Don't give me this "it's offtopic" bullshit; if I had praised Go then it would suddenly be fine. It's enforced niceness culture, nothing more. &gt; Again, the reason is not disagreement. So unless you quote to make a point pertaining to Rust, it doesn't belong here. Then complain about the topic itself as I can obviously not answer the question whether Go or Rust is better without being allowed to discuss Go; place your frustration with OP. But we both know that's not the issue; the real issue is enforced niceness culture. If I had praised BASIC or Go and it was just as off-topic you would've been fine with it. &gt; For many applications, you can get by without the compile-time type safety afforded by generics. Many gophers don't seem to miss them. Yeah and it's my contention that that is nigh on nought but ignorance about modern proper programming practices because the code is goddamn verbose as they have to constantly re-invent the wheel because the language does not facilitate re-using generic abstractions; they don't miss it because they don't know their 10 lines could be compressed into a 1 line combinatorical pattern. &gt; Languages are tools and serve a purpose. If you are misusing a language (that is, using it for anything besides its purpose, or trying to use the abstractions/patterns from another language), don't blame the language for your troubles. For example, I once had to maintain a python application written by Java programmers – they'd literally written Java code in python. I didn't enjoy that code at all, to say the least. I couldn't help but notice that in your enforced artificial niceness culture you didn't answer my question at all; it's almost like being nice stands in the way of speaking the point truthfully because guess what, truth sometimes hurts and isn't "nice". Again, can you name a programming language that is not "fine" and if you can't then calling go "fine" is the same thing as calling it "a programming language" which is surely a useless statement.
Thank you for providing me with the keywords ! Here the best answer seems to be saving the start and end of each of my elements.
Thank you for this option, though I did not manage to find how I can get the start index of the word from the slice given from split_whitespace(). The goal being to do the fewest computations as I can when I have to display.
The link doesn't work (certificate error).
- don't generate ids yourself, this could easily lead to a conflict when multiple threads do that at the same time - as mentioned in other comments, you may also want to omit other fields (`created_at`, `updated_at`, etc.) - the idea is to have one struct per "form" a user can send you - a derive macro `#[derive(InsertWithNewStruct)]` that gives you a new struct called `NewFoo` for a `struct Foo` and omits all fields with an `#[ignore_on_insert]` attribute (maybe even ignore the fields listed above by default) might be a nice coding exercise, and can live in its own crate :)
I think ~1000 is still relatively small, though it may start straddling the limit; storing 1024 u32s requires 64 cache lines. For such a small content, I think you could relatively easily keep a sorted vector and cook up a "replace" algorithm (which removes a value and adds another instead, keeping the vector sorted). It's important do to both in one step because it minimizes the moves: only the elements between the removed one and the added one need moving (one slot), all others need not. Also, if the focus on throughput rather than latency, you may consider batching updates. For example, only every 8 or 16 elements. By keeping a (small) sorted vector of elements to be removed, and elements to be inserted, you may avoid a lot of moves; it's especially true if the same values occur frequently, as finding the "element to be added" in the "elements to be removed" vector means they cancel each other: this further postpone the necessary batch update AND means that the median is unchanged this round.
You can do #![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
I tried the precompiled binary and that did not work on alpine, likely because of libc / musl stuff.
Additionally, unless your insert is modified by triggers (such as generating created/modified timestamps or changing inserted columns), and you're actually going to use the result, you shouldn't ask for it back from the database. If you just need the id back, then there are ways the database can supply that without pulling the entire row back.
What do you need it for? If you want to build a binary that's gonna work on alpine, you can use this image and then copy the statically linked binary into an alpine image: https://github.com/clux/muslrust/
I'm currently working on something like this, the [Sōzu HTTP reverse proxy](https://github.com/sozu-proxy/sozu). It has an additional feature over Haproxy: it can change its configuration at runtime wihout losing connections.
Working on my glTF 2.0 viewer and published a first version: https://github.com/bwasty/gltf-viewer
Are you going to do that with a simple `exec`/`fork`? Or will you reprocess the config file and managing computing a delta? I'll have to take a look at this and maybe throw some code your way :)
How are you installing it? Can you open an issue if it's from the Github releases? That looks like the error I'm mentioning in my article as one of the reason why I'm not uploading new version on crates.io
it works with config deltas sent over a unix socket. That way, it's easier to write tools to drive the configuration.
Actually, having a macro in the stdlib like `#[extends(OtherStruct)]` to copy the structure of an existing struct could probably be useful in many situations.
The NewGame type does not have to be public. When inserting it you can create a NewGame type from the Game type. Here is how I do it. This way I can have a Blog:::insert(Post) -&gt; Result&lt;Post&gt; that takes Post, converts it into a Poster and then inserts it into the db, while also ignoring the ID and creating its own, and returns the published post #[derive(Queryable,Debug)] pub struct Post { pub id: i64, pub title: String, pub filename: String, pub author: String, pub time: i64 } #[derive(Insertable)] #[table_name="posts"] struct Poster&lt;'a&gt; { title: &amp;'a str, filename: &amp;'a str, author: &amp;'a str, time: i64 } impl Post { fn inserter&lt;'a&gt;(&amp;'a self) -&gt; Poster&lt;'a&gt; { //generates a Poster type Poster { title: &amp;self.title, filename: &amp;self.filename, author: &amp;self.author, time: self.time } } } 
I used `cargo install gutenberg`. 
Rust macro definitions don't look anything like C macro definitions. They work differently too. Rust macros operate on the tokens being parsed whereas C macros operate on the text itself and are barely more than find and replace. I think the concept of being able to use the same macros in both languages is kind of cool, but what you're suggesting doesn't really accomplish that. :)
The pacing on this video is wonderful. Make this guy teach a Rust course!
Nope, rustup isn't packaged yet.
I also like the idea of defining traits and then using a macro to generate the structs. The generated structs would look like your second example. This is better for the case when you have other fields like `created_at` and `modified_at` which should be kept separate from your actual domain data.
sure they are different, but imagine being able to use a common subset in both.
I have a binary tree struct: struct BinTreeNode { left : Option&lt;Box&lt;BinTreeNode&gt;&gt;, value : String, right : Option&lt;Box&lt;BinTreeNode&gt;&gt; } Based on this I have a visitor or zipper that is supposed to reference a tree and change its values. As far as I understand the original tree needs a lifetime at least as long as the zipper; this makes sense. struct BinTreeZipper&lt;'a&gt; { current : &amp;'a mut BinTreeNode } impl&lt;'a&gt; BinTreeZipper&lt;'a&gt; { fn new(inp : &amp;'a mut BinTreeNode) -&gt; BinTreeZipper&lt;'a&gt; // code fn set (&amp;mut self, new_val : String) { self.current.value = new_val; } fn left_if_possible (&amp;mut self) { match self.current.left { Some(ref mut x) =&gt; { self.current = &amp;mut x.as_ref() } None =&gt; { } } } The left_if_possible function should move the current pointer from the current BinTreeNode to the BinTreeNode pointed to by left. I tried lots of variants (including unwrap functions that take a &amp;mut Box&lt;BinTreeNode&gt; and return &amp;mut BinTreeNode; let if instead of match; use of the unwrap function to panic if left is None etc..) but I always get the following error: cannot infer an appropriate lifetime for pattern due to conflicting requirements Can somebody explain to me what I did wrong.
yep that's broken and not the recommended way of installing it. https://github.com/rust-lang/cargo/issues/2263 is the issue causing that panic, with a previous version of gutenberg as an example explaining in details
Somehow, I feel like the problem should be solved the other way around. struct WithId&lt;T: ???&gt; { pub id: i64, pub inner: T, } Thus, you would insert a `T` and get a back a `WithId&lt;T&gt;`, a structure augmented with the generated ID. What I particularly like about this is that a single `WithId` struct is required for any table with an `ID`. I am not sure, however, how this would fit with Diesel. I have a feeling it would work well in Rust, mostly because any specific trait implemented for `T` (such as `Queryable`) can easily be implemented for `WithId` in a generic manner with `impl&lt;T: Queryable&gt; Queryable for WithId&lt;T&gt;`.
It usually makes sense to make that struct a field in such situations. It's Diesel that cares about the struct being flat.
This library allows for this in some cases: https://github.com/jpernst/rental
If you have a method like this, it will not come in two, but three variants. You're mistaken about your signature for `removing`. A method `method(self, ...)` will _eat_ the object is has been called on. This is useful for e.g. builders that are intended to be used with multiple chained methods that return `Self`. A method `method(&amp;self, ...)` will capture the object by immutable reference. Good for getters and inspectors. A method `method(&amp;mut self, ...)` will capture by mutable reference. Good for setters and mutators and other fun stuff. So your example would have _three_ methods: fn remove(&amp;self, index: usize) -&gt; Self; fn remove_mut(&amp;mut self, index: usize); fn into_remove(self, index: usize) -&gt; Self;
It is strictly less powerful than the first (given it can be implemented as `self.remove(index); self`) but might be slightly nicer syntax for some situations, e.g. `foo().removing(x).bar()` instead of having to save `foo()` to a `let mut`.
You should use `cargo bench` for Rust and [google/benchmark](https://github.com/google/benchmark) for C++. This will give a better measurements than `time`. Probably, you should also make a C-API for your Rust implementation and test in via `google/benchmark` too, to eliminate benchmarks differences. 
I'm not sure how often you're calling `println!`, but it's worth noting that it's relatively slow, since it has to exclusively lock a mutex, write the data, then unlock the mutex. I would suggest locking the mutex before a big loop of `print!`/`println!`, and then use stdout directly. [Example here.](https://doc.rust-lang.org/std/io/struct.Stdout.html) I'm primarily looking at the `display` function on line 46. &gt; I’m not going to discuss the benefits of the various languages but rather highlight similarities between Rust and C++. I mean, the benefits of each would be nice to hear about.
I'm well aware of the difference between `&amp;self` and `self`. I want to consume `self` in `removing`, not borrow it. The use case for `removing` is in builder patterns where you don't want to span the method calls across multiple statements. I shouldn't suffix the mutating method with `_mut` because `method_mut` usually refers to a variant of `method` that returns a mutable reference.
I'm not sure I understand your question. Could your formulate it differently?
/r/playrust 
After having a quick look at it. It seems that is more of a port of Go's context package, as it creates a new context for each value/deadline/cancel added. For example `with_value` (https://github.com/rkusa/ctx/blob/e9ae11d6dc786d6c74a4599ccef430b6cc546273/src/with_value.rs#L62-L69) creates a new context while keeping a reference to the parent context. It also seems you can only retrieve a single values from a context (https://github.com/rkusa/ctx/blob/e9ae11d6dc786d6c74a4599ccef430b6cc546273/src/lib.rs#L40-L48), but that might be incorrect. My crate uses only a single context with multiple values/cancel signals. But I'm not sure what the memory usage difference is between the two crates. Furthermore it defines multiple "context" like structs; `WithValue`, `WithCancel` and `WithDeadline`, so I'm kind of confused as to what struct to accept in a function. Which makes be guess you have to use the `InnerContext` trait, which is (slighty) harder to work with. Another difference is that it all depends on `Future` trait from the futures crates. Which is fine if your using it, but I image it being a hindrance when you're not using it.
Nevermind, I have done this: let a = sentence.split_whitespace().nth(start).unwrap().as_ptr() as usize; let b = sentence.split_whitespace().nth(end).unwrap().as_ptr() as usize; let s = sentence.as_ptr() as usize; let comment = Comment { start: a - s, end: b - s, comment: comment, };
&gt; … applying regular expressions to DNA sequences. … in a world without IO … But such a world only exists in the benchmarks game. Without IO? Those regex-redux programs read 50MB. The reverse-complement programs read 250MB and write 250MB. The k-nucleotide programs read 250MB. 
[removed]
Some people already mentioned ACT being what HKT is and they already mentioned it's implemented in Chalk, which is to be integrated with the compiler. I've read somewhere that the plan is to integrate Chalk in September. I don't know how long will it take to go from there to ATC support, but I guess (hope) not too long.
The aim was to use "idiomatic" approach in each language and also have an almost 1-to1 between the two implementations. Hence why I wanted to used for example Rayon and C++ parallel algorithms (which unfortunately isn't implemented yet). With regards to the benefits, IMHO both languages offer similar benefits if we exclude Rusts' borrow-checker. The later is the major upside of Rust. Unfortunately, some data structures, e.g. graphs, require unsafe code which annihilates this benefit for those kind of applications. On the C++ side, ISO standardization is a major one for large long term million dollar/euro projects.
I believe the go-to in C++ right now would be openmp, why not bench against that?
It was not the aim of running a scientific benchmark. And with the recursion level, each move results in 7^10 simulations (about 280 millions) and the run performed 26 moves, which at max could reach close to 8 billion "moves". I think this is quite enough to average out "noise". Now anyone, can take the sources and perform more measurements.
You forget about: sum-types, traits, unsafe block, pattern-matching, modules, cargo, etc. Borrow-checker is not the only difference between Rust and C++.
Cargo is another big benefit of Rust, IMHO
I don't know if it would be the proper way to do things in Rust, but what if there was an Option-like enum to separate cases? id = NewRow or id = ExistingRow(u32)? It could easily extend to other auto-filled fields, although then you have the data problem where a structure could improperly have a mix.
I don't agree. Cargo, the automatic fetching of external resources, will not be allowed in the financial industry where I'm working. I cannot speak for the web world. Another downside, I noticed that the same crate gets compiled every time it's used in a different project. IMHO, Cargo is nice for quick and easy toying code, like I've been doing so far with rust.
it's easily possible to vendor external dependencies in your repository using Cargo, and it is even possible to run your own behind the firewall Crates.io registry with some effort if you'd rather not take the classical method of dealing with third party deps that's used in C/C++... so, again, I disagree. It's a powerful and useful tool. However you would do it in C++, you can take a similar tact to dealing with external deps with Cargo.
I've written both C macros and Rust macros. Unless I'm missing somerthing, the common subset is so narrow as to be practically useless.
C++ has sum-types (https://github.com/CppCon/CppCon2016/blob/master/Tutorials/Using%20Types%20Effectively/Using%20Types%20Effectively%20-%20Ben%20Deane%20-%20CppCon%202016.pdf &amp; https://www.youtube.com/watch?v=ojZbFIQSdl8) , traits, similar things can be found too. I agree with pattern-matching. Modules is indeed cleaner than #includes but it's slated for c++20 (just announced). I strongly disagree with unsafe, for me it highlights borrow-checker is still unable to handle certain cases and graph data structure is an example.
I'll give it a whirl. Wanna run Rocket inside Docker, but don't want a 150MB Debian or CentOS image.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/cpp] [x-post for r\/rust](https://np.reddit.com/r/cpp/comments/6nnxfl/xpost_for_rrust/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
You can recreate sum-types in C++, yes. But it's much more work to do rather than a built in feature. `unsafe` is more than just a borrow-checker suppressor. BC can't do anything about FFI, for example.
A lot of work to avoid to "download" specific versions and build with these, test with these, document the test execution and have external audits. Ease of use at the program desk quickly becomes a nightmare in controlled change management environments. Have fun with PCI DSS (card business) and SOX 404 for example. And this is still simple compared to the requirements in the avionic world.
I'm not saying that software compliance is easy in those industries, I'm just saying that Cargo does not make compliance in those industries harder than it already is, but okay, if you're convinced I don't understand these things, that's fine too.
Disclaimer: I didn't make this, I found it on pcj and posted it here unironically.
I'm making a very basic ripgrep like program, and I'm getting the error `error: cannot document a package where a library and a binary have the same name. Consider renaming one or marking the target as 'doc = false'` when running `cargo doc --open`. I found [this](https://stackoverflow.com/questions/26946646/rust-package-with-both-a-library-and-a-binary#26953326) Stack Overflow page, but this doesn't seem to fix it. Cargo.toml: [package] name = "rgrep" version = "0.1.0" authors = ["Your Mother ;)"] [dependencies] clap = "2" ansi_term = "0.9.0" [[bin]] name = "rgrep" Structure (some files omitted): ├── Cargo.lock └── src ├── bin │ └── rgrep.rs └── lib.rs rgrep.rs: // snip... extern crate rgrep; // snip... fn main() { // snip... } I'm not really sure what the best way to fix this is, but I would like convention over configuration, if possible. Thanks!
Wow, that is one of the best README files I've ever read. I'm a diehard vim user but that README makes me want to give emacs a shot.
So I'm looking through the crate, I don't don't understand what the code in `hazard.rs` is supposed to do. * Is `writer.kill()` supposed to set the state to `Dead` or `Free`? The test `hazard_pair` expects it to be `Free`, but at the moment it sets the state to `Dead`. * I don't understand why the state in `destroy()` cannot be `Free`, rather than `Dead`. 
I believe you can take some of the advice in [here](https://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html) to make it work on Alpine. Namely switching to the system allocator and linking against musl, but if you want to reduce binary size, you'll probably appreciate some of the other tips.
&gt;Is writer.kill() supposed to set the state to Dead or Free? The test hazard_pair expects it to be Free, but at the moment it sets the state to Dead. The test is wrong, so I fixed it. You helped narrowing down the problem: ~~It is because of the panic it segfaults.~~ It SIGILLs due to panic-during-panic. &gt; I don't understand why the state in destroy() cannot be Free, rather than Dead. `Free` means that the hazard is temporarily unused and will eventually be replaced with something useful, whereas `Dead` means that the hazard has no `Writer`, and can thus be deallocated.
I wonder if diesel could define a special zero-sized type (named empty tuple) `New`. Then define a new trait for each struct, which is implemented for the `id` type and `New`?
It's not re-creation. Sum types are in the C++ standard library as of 17. It's exactly the same amount of work for users (i.e. 0).
The `doc = false` bit is meant to be added to this section of your `Cargo.toml`: [[bin]] name = "rgrep" doc = false
And if I want docs for both the bin and lib crate? Not sure if it's related, but I was looking at the source for rustfmt and they seem to have it pulled off.
Thank you for sharing your experience writing Tantivy. I find it interesting to hear about the challenges and the lessons learned when dealing with a particular problem, and compare Rust's solution to the one found in other type safe languages, e.g. Haskell. Have there been any points in particular that you greatly disliked when tackling this problem with Rust?
[This](https://chadaustin.me/2015/07/sum-types/) article goes into some depth about it. To say that it isn't a re-creation is a bit of a stretch. It's not actually a language-level feature in C++, by the looks of it, it's just a variadic template class called `variant`, and it requires a large amount of boilerplate to get anything done, and it has limitations with the matching. This quote from the article sums up my feelings on `variant`: &gt; Also, it’s so verbose! Most C++ programmers I know would give up some type safety in order to fit cleanly into C++ syntax It's also not pervasively used in the stdlib, thus many of the benefits are removed, since you don't have the `Option` and `Result` usage that Rust does, you still mainly deal with exceptions. I'm glad it's in there, and I'm glad it will be an option for people to use, but that doesn't make it equivalent, and it *is* more work.
If only the extension language weren't as arcane as Emacs Lisp, and the keybindings so numerous, modifier-laden and difficult-to-memorize.
I'm not sure, but that may be the [lib] doctest = false that they have in their Cargo.toml.
I already tried that, it just turns off testing documentation examples :(
Iterators generally return a single type. If you need to specify the type of the iterator variable, you can usually accomplish this by specifying the type of the iterator. [ex](https://play.rust-lang.org/?gist=38db559398eda356c149fa3094e09c6b&amp;version=stable). But I don't think there is a way to specify the iteration variable type in the exact way you describe.
Have you looked into [spacemacs](https://spacemacs.org)?
I wouldn't worry about this so much. In practice, unspecified types have rarely led to problems for me, because those values get passed to functions, and those functions definitely declare their parameter and return types. With the Rust Language Server, I can also easily see what type everything is in my editor. When RLS has a broader launch later this year, that will be great. I keep hoping it will be possible for RLS to magically annotate types on every variable in my editor, not as actual code, but as "comments" that only exist within the editor's textview. In this case, you *know* that `i` is an `i32` because `foo` is an `i32`. As you can [see here](https://play.rust-lang.org/?gist=1da4c5223cb39509dda09802f47f12da&amp;version=stable), you cannot have a `Range` with two different integer types, and Rust *will not* automatically coerce primitive types or any types into other types. Rust requires explicit conversions, with the sole exception of `Deref`, I believe. There might have been one other exception, but it's not related to integers.
There is an experimental feature called [type ascription](https://github.com/rust-lang/rfcs/pull/803) that is available on nightly with `#![feature(type_ascription)]`. It will allow you to do this: for i in iterable { i: i32; } The exact syntax you describe doesn't seem to be supported even with type ascription, perhaps someone can explain why that is.
Another comment suggests spacemacs. Better IMO is just using evil mode to get vi bindings without completely taking over the emacs experience.
Independently from the language, compile-time was the main pain, then came the language youth. I spent a fair bit of time over compiler and library bugs. The "it's never the library, it's never the compiler" rule is not applicable in rust yet, simply because the language is not popular enough yet. I assume a lot of people would answer fighting the borrow checker. In the one or two tricky places where it was indeed a pain, I didn't fight long and ended up just carrying a pointer in a struct (I recently learned about `owning_ref`). I am not a "virtuous" rustacean in that I sometimes introduced unsafe code probably more than is necessary. I'm fixing those gradually. A couple of people complain about the standard library. I find it fantastic compared to Java and C++. 
&gt; In practice, unspecified types have rarely led to problems for me, because those values get passed to functions, and those functions definitely declare their parameter and return types. That is the work-around I was figuring I would use, in any non-trivial cases, if there wasn't a syntax for this. Unfortunate that it requires explicitly splitting what might be a single idea across multiple functions just to get some solid type bindings but not catastrophic, by any means.
That sounds really useful, even beyond this situation. I might have to give it a shot and see how that plays out. Too bad that it is a different syntax but it makes the core idea available, which is great.
Yes, that's what I said, It's in the standard library. There some major pros and cons to having something as a language level feature versus in the standard library. I don't know what you mean by "just"; that C++ is that expressive is a pro, not a con. Writing something like variant at the library level in Rust is impossible. It is rather verbose in the use case examined in the article, which deals with nested variants. This is a specific case (one that I've almost never used) where the first class syntax is much nicer than what C++ can provide, sure. To say that it requires a large amount of boilerplate to get anything done, is just wrong (to be blunt). It requires a small amount of boilerplate to get most things done, and a large amount to get a few things done. I agree it is not equivalent.
&gt;Do you have any better idea? Currently, I think UUIDs make the most sense for primary keys. The UUID may be generated by the caller or the DB. Every UUID will be unique across all tables, all catalogs, and all databases. UUIDs never realistically run out.
Even if you don't use external crates, just having a standardised sane build system is a real advantage. As much as Rust features 'memory safety' and 'fearless concurrency' as it's primary selling points, for me those are several points down the list after things like 'cargo build', 'not fucking around with make files', 'no preprocessor', 'hygenic macros', 'traits not OOP', 'easy to modularize', 'no C++ gotchas'. You might need to use unsafe for things like graph structures, but that means the unsafe bits are quarantined in specific regions and can be a focus of testing. Having said that in quite a few projects I wish I could just use unsafe all the time. Dealing with the syntax overhead can be a pain.
If you start those lines of code with four blank spaces, you'll get monospaced font by default which'll make those tables line up more easily.
Yeah I do saw somebody using UUID, it might be a good solution
Yeah I think I'd go with defining new derive macro :D jesus it require a lot of coding
Wait, this is not what diesel having right now, right?
Thanks for your detailed reply. I have not dived into Rust yet, as I am bound otherwise. Last question, out of curiosity, since your project is of larger nature: Would you generally use Rust as all-round language, or do you see merit in using other languages with a GC if the use case does not mandate absolute performance? I am basically wondering if Rust feels really like a general go-to language for business type applications.
You are getting downvoted a bit unfairly. However, to rephrase your position: "I don't need it" or "I can't use it in my work" would be accurate, no? 
Cargo should make working with these constraints easier regardless of how strict they are. If you feel Cargo currently does not serve your use case well enough maybe you could consider submitting an issue to the project? I am sure it would be greatly appreciated as the Rust team is trying to make Rust and its toolchain a great fit in every industry.
Link is down to me, but [here it is on the wayback machine](https://web.archive.org/web/20170716140842/http://fulmicoton.com/posts/behold-tantivy-part2/).
No, this is a proposal.
Hey, thank you so much guys! I decided to go with a solution that required creating a new macro to create both structs at the same time: Some thing like this: macro_rules! build_model { ( $struct_name:ident; $new_struct_name:ident; $table:expr =&gt; { $( $attr_name:ident : $attr_type:ty ),* }) =&gt; { #[derive(Queryable, Serialize, Deserialize, Debug, Clone)] pub struct $struct_name { pub id: i32, $( pub $attr_name : $attr_type ),* } #[table_name=$table] #[derive(Serialize, Deserialize, Insertable, Debug, Clone)] pub struct $new_struct_name { $( pub $attr_name : $attr_type ),* } } } And the usage would be: build_model!(Node; NewNode; "nodes" =&gt; { key: String, value: String }); Now you have Model and NewModel struct ready to use.
I'm a bit confused by this. It's not like explicitly declaring the types of your bindings means that functions are then excused from declaring the types of their parameters. 
Hmm... I'm not sure about either of these replies. I work full time as a webdev, mostly on single-page app type projects, and I can't see the justification for using ember for rustdoc either. Maybe you're imagining rustdocs output being a lot more dynamic in future? But at the moment it seems like a lot of extra moving parts for what is essentially a collection of static webpages... Also, you should give Hugo a try. I recently redid my personal website in it, and it has one of the best dev workflows I've ever used. Largely due to incredible compilation speed (too fast to even notice a delay), and built in live reloading. Thank you for your work on rustdoc. It is much appreciated.
&gt; Cargo, the automatic fetching of external resources, will not be allowed in the financial industry where I'm working. Really? Cargo won't automatically upgrade any library versions without you asking, and mixing local (in-house) packages with public ones is really, really easy. I'm in the financial industry, and some of our Java code uses Maven to build, which pulls some stuff in from Maven Central. The only reason we don't do that with our C++ code is because there simply isn't a similar tool for C++, at least not one that's as stable.
It isn't about excusing type declarations, anywhere. This is about wanting the ability to declare types in more situations. Pulling logic out-of-line, into a function, in order to rely on the function's type bindings would work but it would add indirection in the logic which may just complicate what the loop is trying to do (since the logic is now spread between the parent function and the callee).
Working on my [awesome+wayland library](https://github.com/timidger/awesome-wayland) that will hopefully be usable in Way Cooler in a couple of months. The goal of the library is to make it easy for compositors to add support for the awesome lua libs.
This macro could be much simplier. macro_rules! for_type { ($name:ident: $type:ty = $iter:expr; $body:expr) =&gt; ( for item in $iter { let $name: $type = item; $body; } ) }
&gt;Unfortunately, some data structures, e.g. graphs, require unsafe code which annihilates this benefit for those kind of applications. That's not quite true. While, yes, certain data structures require unsafe code, to me the big advantage is in using Rust's type system to create safe abstractions over unsafe code. Your graph might require a ton of unsafe code to be usable, but you can probably provide a safe interface for at least the most common operations.
Personally, what I do, from their documentation, is to do a NewModel struct (someone pls comment how to do code blocks on phone? :)) It makes it a really easy task for how to set columns you don't want to be manually set by the user, in case of csrf and whatnot. What I'd personally like to see, similarly, is actually the ability to define the insert and update, or override them. In that case, you could create the Model and override the insert to not pass the id. Food for thought. 
Honestly the "builder pattern" could be syntactic sugar in the language as it's common enough. Let's say that `foo-&gt;bar()-&gt;baz()` desugars to `{ let mut _x = foo; _x.bar(); _x.baz(); _x }` Would be quite convenient. So you could also say do let conf_file = PathBuf::from("/etc")-&gt;push(PROGNAME)-&gt;set_extension("conf"); instead of: let mut conf_file = PathBuf::from("/etc"); conf_file.push(PROGNAME); conf_file.set_extenson("conf); let conf_file = conf_file; You can obviously get something close to this nice with a macro for now. Edit: macro_rules! build { ( $init:expr $(=&gt; $meth:ident ( $( $args:expr ), * ) )* ) =&gt; { { let mut _x = $init; $(_x.$meth( $($args),*);)* _x}}} fn main() { use std::path::PathBuf; let v = build!(PathBuf::from("/etc")=&gt;push("foo")=&gt;set_extension("conf")); println!("{:?}",v); } Works as expected.
&gt;&gt; the common subset is so narrow as to be practically useless. the ability to declare something in one file that both languages can read out of the box: I don't think that would be useless.
I wonder if they could generalise the mechanism behind enum tags to the level that a vtable could be used as a tag (giving rapid dispatch for a fixed set of functions and still being extendable) imagine some venn diagram of the capabilities of trait-objects, rust enums, C++ single-inheritance vtable classes (compare switching on a tag to 'if dynamic_cast..') 
Yes, the effect would be useful, but can it be achieved in any meaninful sense? Show me a valid Rust macro which would also be a valid C macro. (Since Rust is much pickier about what "valid" means.)
bear in mind the range of things that you can do with x-macros in C. you could do that more simply in rust, sure. but the real point here is the inter-operability *without needing code generators/hacking build systems etc* 
You could use an [ordered map](https://doc.rust-lang.org/collections/btree_map/struct.BTreeMap.html) over a Hashmap. Or does Hashmap do specialization?
And *my* point is that, having written both C and Rust macros, I'm skeptical that you can do much (if anything) useful that is valid and has the same meaning in both Rust and C macro syntax. For example, here's a comparison of the simplest possible macro that does something useful: **Rust:** macro_rules! MAX_THINGS { () =&gt; (1024); } **C:** #define MAX_THINGS 1024 Do you know something that I don't which would allow something to simultaneously be a valid expression of both of those two very different syntaxes? (Bearing in mind that the grammars only diverge more if you want to add things like variables)
I am in no position to make statements about rust, but I think rust does not have the vocation to become a language for everything. First for the obvious, Rust is not adapted to tasks that require a fast development loop, and for which not having batteries included is a pain. So scripting, datascience, pseudo-coding, answering an interview, prototyping an idea... I will personally keep doing those in python. A lot of user frustrations are coming from expectations that they got from python/ruby (e.g.: why don't we have tempfile as part of the standard library? why can't I auto-cast different kinds of integers? `String` and `&amp;str` are WTF etc.). I tend to appreciate a lot all of these choices and hope the language remains on this track. Will we one day be able to replace Java/C# in large service-side application? I'd love that but I am unsure. The editor tooling (although intellij-rust is getting pretty awesome these days) but is definitely not there yet. Some features of JVM sandboxing can be appealing in production. There is also an apparent consensus that Rust has a tough learning curve, so there might be an HR issue that could prevent business to bet on Rust. 
I didn't do any sort of specialization with the hashmap, but I don't think there's a lot of room regardless. The BTreeMap is a good idea! I opted not to use it though because every time I update a frequency (which is what the BTreeMap would sort by) I would have to remove and re-insert the entry. I figured looping through the vector wouldn't take up much more time than that. There's a specialized priority queue I have written to replace the HashMap (or what the BTreeMap would do), I just haven't added it in yet.
[Playground](https://play.rust-lang.org/?gist=6c11aa1d7e8d3857f8a68b27649412de&amp;version=nightly) pub fn take_range(&amp;mut self, r: Range&lt;usize&gt;) -&gt; Drain&lt;u32&gt; { self.v.drain(r) } you have to provide type parameters, that's the key.
What benefits does Spacemacs have over GNU Emacs? So far I've only found it unresponsive and difficult to configure, I've little complaints using GNU Emacs with evil mode.
Spacemacs is just a distribution of Emacs, it's still running GNU Emacs underneath. It is very different from normal Emacs though, but I really enjoy using it.
it's far from arcane. you should try it for yourself. It's light years ahead easier then vimscript, 100% guaranteed client satisfaction or your money back.
I think reusing result is the right way but may not work in certain situations. For example, mysql will not return generated id by default, you will have to call last_insert_id , also you won't get the default values if any added by db. 
you can use x-macros in C to declare structures with reflection, roll vtables, implement tagged unions etc etc. so, imagine being able to wrap and declare such things and they work perfectly in sync in both the C and Rust parts of a cross-language project even declaring plain function prototypes this way would be handy. 'here's a function, which should be callable from both Rust and C.'
Your last point about derive macro is a nice one
C/C++ ````#define DEF_CONST(TYPE,NAME,VALUE) const TYPE NAME=VALUE;```` rust ```macro_rules! DEF_CONST { ($t:ty, $name:ident, $value:expr)=&gt; {const $name:$t =$value;}}``` my_decls.rs DEF_CONST(int, Foo,0x0010) DEF_CONST(int, Bar,0x0020) my_decls_inc.h #define DEF_CONST.. #include "my_decls.rs" Viola! both Rust and C (would) get 'Foo=0x0010, Bar=0x0010', and anything else you put in there. no need to drop out to messing around with build scripts to keep things in sync. &gt;&gt; simultaneously be a valid expression of both of those two very different syntaxes? ... the point is to write macros to abstract away the syntax... DEF_FUNCTION_3ARGS(..).. DEF_STRUCT_4FIELDS(..) DEF_VTABLE_3(..) etc etc.
As of now get_result does not work with MySql as mysql does not support returning clause
I would argue its very easy to have a large config with spacemacs because layers nicely abstract the concept of a collection of packages. That being said the main reason I like spacemacs is it makes it unbelievably easy to try out a language. Before I used spacemacs I would have to fidle with my .emacs.d to try out a language and it was potentially a lot of work. Now I just add the layer that supports the language and boom I have a nice familiar vim ide for the language. 
Ahh. Point. I keep forgetting that you can do that. (Or, from a different perspective, I never really got into the mindset which, at infamous extremes, has resulted in people coding in approximations of other non-C languages using a macro set that reinvents most of the grammar.) That said, I think the same problem applies as with those other efforts... maintainability of programs which rely on your pet DSL by programmers other than you.
Is the motivation / use case for the library explained anywhere? It's not immediately obvious why this abstraction might be preferred to relying on the filesystem buffer cache.
Usually the point of IO buffering is to avoid excessive syscalls (and related context switches), while page cache is reducing disk writes.
I use spacemacs in my day job. I like it, I came from vim and spending hours configuring it to get it just right for me. But with spacemacs I have vim key bindings org mode and easy configuration with just adding layers and changing some hot keys here and there. Rust support is great too. It will give me quick compiler like feedback while I'm editing that makes it really seamless imo
&gt; maintainability of programs which rely on your pet DSL by programmers other than you. sure, but this idea is to improve the maintainability of cross-language inter-op .. something that will happen e.g. introducing rust into existing c/c++ projects, maybe trying to build new libraries that are intended for equally easy use in Rust &amp; C/C++ from the ground up. of course if the C language macros could be improved to be more rust-like, that would be even better; but rust is the more agile, malleable of the two (less existing work to break) - getting a new idea into C/C++ is extremely hard 
As I've more or less said before, it's an admirable goal, but I remain unconvinced that the upsides of this approach outweigh the downsides.
Its for a peraistant BTree ive been working on, it speeds things up by 10 or 20 times. The best use case for this is random access files, so lots of reading, writing, and seeking, with "hotspots." 
they just need to change it to a LISP-1 , then i'd rave about it.
For an application-specific database this is less often true. As the application API becomes the integration point, rather than the database, you're best to design the logic to reside where it's most visible and efficient. I'd argue that column defaults probably don't belong in the database in these cases as the application owns the data-structure and surely has opinions about the column values. If the database is your source of truth for timestamps then obviously the database should return that information - selectively. Obviously it's a case-by-case thing. Nearly all examples retrieve the full results of an insert, they imply that this is the normal case. It shouldn't be. And presented in this fashion there's a risk that developers poisoned by other ORMs might think that the ORM is using that for cached tracking of entities. Diesel isn't an entity-manager and ORM, it's just a translation layer for SQL (IMO a good thing). 
mit license :(
almost the same as freebsd? license
After reading most of the comments on Slashdot, I think these are the main points against Rust: - Rust is not a silver bullet, does not prevent logical flaws - Rust is too young, no mature libraries - Does not easily work on embedded, where people have size-constrainted stuff and assembly inline code - "Tyrannical" Rust community - "Good programmers write C, average programmers write Rust" - Ada did it already https://developers.slashdot.org/story/17/07/16/1715256/techcrunch-urges-developers-replace-c-code-with-rust#comments A lot of these points are valid. - No language is or will prevent logical flaws completely. - Working on it - Working on it - Yes, we should stop downvoting people who use C. It is a misbehaviour. - I am an average developer who wants to get shit done. Rust is not perfect, but it's a suitable tool and writes itself (imho) faster than C. If I write a function, I don't want to revisit it ever again. In C I have to, because memory bugs / valgrind, etc. If that makes me "average", so be it. - Ada still has a place in security / military systems. Not every application is a military system, but has to support a larger feature set. Overall what I like about Rust is not memory safety, not even security. It is the fact that I can write functions without having to revisit them. That I can test functions without frameworks. If my app crashes, it's not the memory safety that is a problem, it's the (down)time to find the bug and get it up and running again. With Rust I can have less of these "downtimes". Plus it's way easier to use libraries than in C or C++ because of a standardized way.
(/r/rust discussing slashdot discussing a techcrunch piece (kinda) discussing a [blog post](https://unhandledexpression.com/2017/07/10/why-you-should-actually-rewrite-it-in-rust/).) I'm curious if you wanted to highlight something in particular in the discussion? *edit:* I see you've written a comment.
Didn't know my mother could write Rust 
Why racer doesnt autocomplete stuff like println!(); ?
The [TechCrunch article on Rust](https://techcrunch.com/2017/07/16/death-to-c/) largely echos and excerpts the recent post by Geoffroy Couprie, "[Why you should, actually, rewrite it in Rust](https://unhandledexpression.com/2017/07/10/why-you-should-actually-rewrite-it-in-rust/)" which focuses on hardening and refactoring C/C++ applications by using Rust in the parsing (network and file) and concurrency layers. In reading the comments a couple things come to mind. 1. Rust really needs to sell itself over safety, maybe just put safety last. To me, pattern matching, Cargo and concurrency are enough of a win. 2. Many people view Rust as a direct attack on platform and life decisions. A couple referenced Linux, and that since Linux is awesome and written in C, C is obviously better than Rust. They are viewing Rust as an attack on Linux itself. 3. "First they ignore you. Then they ridicule you. And then they attack you and want to burn you. And then they build [monuments](https://www.thingiverse.com/thing:1592128) to you." -- [Nicolas Klein](https://en.wikisource.org/wiki/And_Then_They_Build_Monuments_to_You) The cool thing is that Rust is being talked about on _mainstream_ sites like Slashdot and TechCrunch, getting a piece into [USA Today](https://www.usatoday.com/) would be a dream.
The assistance that Rust gives makes a below average programmer above average in the quality of the output. Same thing that Java did in the late 90s and early 2000s. When it comes to Ada, I would mention [this previous thread](https://www.reddit.com/r/rust/comments/2og8xf/why_rust_started_rather_than_ada/) about Rust and Ada. It looks like Rust has better guarantees than stock Ada while being easier to use. Who knows, my Ada experience is limited to about a hundred lines of code.
I'm also curious about this. Sidenote: Kotlin can be used to write android apps. Google recently announced first class support for it.
You could try hunting down the person who made [A Snake's Tale](https://m12y.com/a-snakes-tale/), seeing that it was made in Rust and has an Android version. Pinging /r/m12y_
[removed]
There is a lot of cross pollination occurring between Rust and C++. Much of Rusts terminology for borrowing and ownership came from C++. I am stoked that questions like [these](https://stackoverflow.com/questions/30011603/how-to-enable-rust-ownership-paradigm-in-c) are getting asked by C++ programmers.
The "tyrannical" community complaint is just people whining about the fact that there's a Code of Conduct (in other words, complaining that the community will shun them if they treat other people unfairly). It's mostly just crocodile tears. The downvoting thing is unfortunate but it's pretty much the norm on reddit. The people who do it won't listen when you tell them to stop and the people who will listen don't do it in the first place.
There's a few tools around that do most of what you're wanting but they're a little bit incomplete at the moment. I've used [this](https://github.com/tomaka/android-rs-glue) with glutin &amp; glium to make a small demo "game" that runs on both desktop and android with very little platform specific code.
I loved it. Especially when the author referred to windows as a legacy platform.
i'm not asking about tools
how? it's closed source
&gt; If not, is there a way to use Rust only or almost only Rust, something like 90%, for building android applications?
You can have your Java main call your Rust main, and then do something like I'm doing https://github.com/rawrasaur/rust-jdbc for all your Java calling needs via JNI. This should allow you to write 99% of your application in Rust.
The * in the title is because it still relies on having an `sh` installed. But I think that most people are likely to be using git bash, cygwin, or the github command line tools installed, which all provide an `sh`. Let me know if it doesn't work! I'm not working on it right now, but I would eventually like to write a simple `sh` or `rc` shell in rust, and then get rid of the `sh` dependency altogether. I would really like to see `just` get more popular! In addition to just making it nicer to work on a project, I think that a project having a justfile also helps new people get started with it. It puts all the commands needed to work on the project in one place, and gives valuable hints as to what you need installed for it to work.
We're living in exciting times. Can't wait to use the i3-like version
Isn't he just calling DOS a legacy platform, or did I miss something?
It's closed source, but the author has been open to talking about their development methods in this subreddit before. I'm sure they would be willing to give some advise and/or knowledge based on research they've done about rust on android.
&gt; Unfortunately, some data structures, e.g. graphs, require unsafe code This is not true. You can implement a graph by using bound-checked indices into a `Vec`.
&gt; This is a specific case (one that I've almost never used) Composition is the whole point of sum types.
&gt; I did try to compare its performance with Lucene, but simply decoding utf-8 and reading lines from my file took over 60 seconds in Java. That did not seem like a fair match: remember it took 94 seconds to tantivy to read the file, decode JSON, and build a search index for the same amount of data. I was too lazy to work out a binary format to palliate Java’s suckiness and do a proper comparison with Lucene indexing performance. That's a bit sad to see, as Lucene is in general very fast at writing to disk (although much of the tuning must be done by hand, as far as I understand).
This book is written for less advanced programmers than the rust book but very properly written to ensure comprehension by the people who suffer from the steep learning curve of the language. Thank you for this work and please ensure this is linked in the rust community learning page.
I'm sorry... Have you tried just evil mode? Configuring it to work with all your other configurations and packages is a nightmare! I dumped six years and 500 commits of custom Emacs configuration because I wanted Evil with it... And Spacemacs just works.
[Zone of Control](https://github.com/ozkriff/zoc) project is [_officially_ _discontinued_](https://twitter.com/ozkriff/status/885502939204395008). Sorry, friends. Now I'm working on a new (much smaller and less ambitious) turn-based game [Zemeroth](https://github.com/ozkriff/zemeroth) (and yet-another-2d-rust-engine [Häte2d](https://docs.rs/hate))! Not much to look at right now: http://i.imgur.com/EEtIxGp.png Devlog-in-pictures: http://imgur.com/a/SMVqO Subscribe for instant updates: https://twitter.com/ozkriff ;-)
Is it possible to have module in `src/` and import it in binary that is in `src/bin/`? Or do I have to place all binaries into `src/bin/` and all modules into `src/bin/` when I want to share modules between all binaries?
&gt; Good programmers write C, average programmers write Rust That's a weird attitude towards problem solving. Good farmers use their bare hands, average farmers use a combine harvester. If you can write large, complex, flawless C programs, you are indeed a good programmer, but the other way around? &gt; Ada did it already Idk what language these people use, but it can't be more modern than Fortran.
The usual arrangement is that you make the crate a library, then each binary links to that library. So if you have a package called `gimbol`, you have `src/lib.rs`, and `src/bin/sputter.rs` does `extern crate gimbol;` to access the library. That is, you don't have every program include duplicates of the modules, you include them all in the library and access them through that. **Edit**: Although I've never tried it, you can probably also put common modules in a subdirectory of `src/bin`. That'll cause them to be compiled multiple times, though.
Ok, thanks.
You're probably looking for /r/playrust
There are valid critiques of the language, but most of them come from people who have obviously not taken the time to work through TRPL. There are clear advantages and disadvantages to using Rust. Those who take the time to understand the fundamentals of the language and tooling will be able to determine when it's the right tool for the job. Many others will continue to flail and blame Rust, instead of blaming their ability to write Rust or choose the appropriate tool for the job.
@fgilcher Oh yes, Lucene is extremely fast at indexing. I'll try to reproduce their nightly benchmark. (https://home.apache.org/~mikemccand/lucenebench/indexing.html) They clock at 700 GB / hour on it on a war machine (an overclocked 2 CPU x 6 cores x 2 hyperthreading) machine. Their setting does merge, but does not wait on the last merging threads. I think tantivy can beat that with a nice margin, but without a proper benchmark, that's just me talking.
IMHO Rust is more difficult than C.
see https://gist.github.com/michaelfairley/d86137085307d2e5c16ee0df2fb84cd9
See also https://github.com/tomaka/android-rs-glue
I dislike the common argument that "I don't need rust because as a competent C programmer I never make errors". As I see it, safety is an added bonus of Rust's, and there are many other good reasons to use it. Even a battle-hardened C developer must surely see elegant functional features, algebraic data types, unicode support, a cleanly designed toolchain and pleasant compiler messages and think that the proverbial grass is greener on the other side.
\o/ I'm following you project closely, as I hope for a better standalone library then Lucene. I'm doing a lot of Elasticsearch on my day job, but managing Lucene raw is just such a beast.
It's curious how this _programmer amplification_ is presented as a bad thing. If a technology makes it easier to write better code, then surely this is good? There's a bit of macho bullshit going on when people celebrate the difficulty of their craft and fetishize languages because they are _hard to use safely_
That's so cool, thank you!
I have seen at least one instance of a commercial iOS- and Android-app sharing their glue that someone at the Berlin Rust Hack &amp; Learn had. Sadly, I have a brain like swiss cheese, so I can't remember the name. The approach they took was defining proxy views, that would get all their data from a Rust library (this lib had a mirror of that view). All OS functionality, such as networking, was hidden behind a thin proxy again. Then, they coded a UI on top of it, using the native toolkits, mostly the view builders. From what they told me, the approach is similar to how you would C++ for that, and there's definitely a couple of people around doing that.
I'll need code!
&gt; Even a battle-hardened C developer must surely see elegant functional features, algebraic data types Not in my experience. Before rust this features were only available in high level languages and many C programmers are not interested in these.
I don't care about down voting. My point was that cargo is a nice build tool, like many others. But first of all it is not a language feature and a reason to chose a language and second, the advocated "benefit" of automatically gather dependencies and download them is not viable in strictly controlled change management environments like the one I mentioned. I'm not versed in ITIL but I'm wondering the same.
Syntax for this from other languages i've come across ... In Smalltalk, replace the usual '.' statement terminator with ';' to reuse the receiver in the next statement: confFile := PathBuf newFrom: '/etc'. confFile push: PROGNAME; setExtension: 'conf'. It doesn't, AFAIK, allow the chain to include the construction, though. In Visual Basic (YEAH!), you have with ... end: With confFile .Push(PROGNAME) .SetExtension("conf") End With In Ruby, this is a bit different, but there's tap: confFile = ConfFile.from("/etc").tap do |c| c.push(PROGNAME) c.setExtension('conf') end Tap is pretty handy in all sorts of situations, not just this.
You can write a native activity in Rust. It probably wouldn't be very fun though unless you're writing a game because getting the native UI components displaying basically means calling Java in one way or another.
have you seen this? its a löve2d clone in rust, it might allow you to save some work. https://www.reddit.com/r/rust/comments/6mg02o/ggez_a_rust_library_to_create_good_games_easily/
You really gotta name some example projects you would write. A server more complicated than a standard webserver? Go is probably better for that until Tokio gets sorted out. A database or some low level engine? You probably want Rust for the extra performance and control of memory. But it's really project specific. You *should* learn both eventually though, it's always good to have more tools to solve problems.
I shouldn't have written my thoughts when asked, as it started the "debate" below. For all, I advise to mind the quote of Mike Thomas "If you're arguing, you're losing". This was quoted in a interesting talk by Dan Saks on cppcon about persuading C programmers to move to C++ (https://www.youtube.com/watch?v=D7Sd8A6_fYU). I advise to listen to it and meditate when people starts arguing about rust vs (c || c++). What will convince c programmers to jump ship to rust, let it be c++ programmers? Certainly not by arguing! And there is a lot of arguing going on below.
Eh, I'd say that Rust just frontloads the difficulty. Rust wants to make sure you got it right before you compile, so fighting the borrow checker and learning the quirks of the compilier are important. C on the other hand will compile almost anything if the syntax is right, and it's rather unhelpful while you spend hours in the debugger when something goes wrong. In a large enough codebase you'll inevitably run into one or the other, and I'd say finding the bug manually is significantly harder.
Number literals support type suffixes: for i in 0i32 .. foo { println!("Number: {}", i); }
Video linked by /u/sergeken: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [CppCon 2016: Dan Saks “extern c: Talking to C Programmers about C++”](https://youtube.com/watch?v=D7Sd8A6_fYU)|CppCon|2016-09-24|1:36:27|566+ (92%)|46,440 &gt; http://CppCon.org — Presentation Slides, PDFs, Source Code... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/sergeken ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dkbr1gw\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Tap in Rust: trait Tappable { fn tap&lt;F&gt;(self, tapper: F) -&gt; Self where F: FnOnce(&amp;mut Self) -&gt; (); } impl&lt;T&gt; Tappable for T { fn tap&lt;F&gt;(mut self, tapper: F) -&gt; Self where F: FnOnce(&amp;mut Self) -&gt; (), { tapper(&amp;mut self); self } } use std::path::PathBuf; const PROGNAME: &amp;str = "myprog"; fn main() { let conf_file = PathBuf::from("/etc").tap(|c| { c.push(PROGNAME); c.set_extension("conf"); }); println!("{:?}", conf_file); } 
I've removed the tabs that "killed" the formatting.
Cool. tantivy is strongly inspired by Lucene though. :) I would not expect it to be "better" except on some very specific domain/task. Startup time, no GC, indexing speed, analytics. 
&gt; Cargo, the automatic fetching of external resources, will not be allowed in the financial industry where I'm working. I'm working in the financial industry, and using Cargo, with automatic fetching of external resources. It might be helpful for you to be more specific than "in the financial industry", and explain what regulatory regime you're working under that would forbid this. 
this is a great summary of the points that are raised all the time. The worst thing is really "Good programmers write C, average programmers write Rust", because it's a culture issue. I have a hard time convincing C developers that "just write correct code in C" or "just hire competent programmers" are not working.
As I stated PCI DSS. For software vendors, they need to pass audit for PA-DSS certification. Another one, are escrow agreements, where builds have to be done with auditors and the whole "package" handed over as a "snapshot". There are some stack overflow questions about the same for other languages. In the past I also participated in SOX 404 audits and there too it will be a challenge to use "that" feature as auditors will fall on it. Now, don't get over excited about it. For me it's cargo is not a requirement. I just want to create awareness about over excitement about cargo. IMHO, it's just a build system like many others. Maybe a "flag" do not check crates.io &amp; download will be more than enough. Another one, but irrelevant to this discussion, is how to re-use already "compiled" crates by another project on the same system without recompiling them.
[printpdf](https://github.com/sharazam/printpdf) is coming to an end, but I want to get a few features in before I do a 0.1 release (esp. layering and text outlining / character spacing + API cleanup). So far, you can do all features advertised. Pages, shapes (no clipping yet), images and fonts (Unicode, woo!). I also didn't test holes (in shapes), but they should work. I'll probably take a break to translate the [printpdf wiki](https://github.com/sharazam/printpdf/wiki) more.
I managed to finish off the project I have been working on, an experimental Neural Network in Rust called Juggernaut: http://juggernaut.rs What I'm planning to do this week is compiling it to asm.js and build a live demo, something like Tensorflow playground: https://twitter.com/afshinmeh/status/886162459555508226
Hey guys! I have been working on this project for a few weeks and I'm still learning Rust so if you read the source code, you would notice many errors! Excuse me for those errors, I will learn more and fix all of them soon. As I mentioned in the other thread, what I'm planning to do this week is compiling it to asm.js and build a live demo, something like Tensorflow playground: https://twitter.com/afshinmeh/status/886162459555508226 Any suggestions, please let me know!
I've been a web developer for a few years, have tinkered a little in Java and Go but never really made anything of any substance on the desktop. In an attempt to broaden my horizons and learn this language everybody is talking about - and as an aside learn a little bit about graphics programming (if that's what you'd call it) - I'm privately recreating my favourite game from scratch in Rust. The game: /r/TagPro I'm starting out really simple and have made a checklist of items to work through to gradually make it more complex. Thus far I've got a ball on screen and I've got it to move (without any coherent momentum) with WASD. I plan to eventually get to the point of a 3D ball in 3D space (i.e. an added height element), a moveable camera, and shading, strictly as a tech exercise. I'm on holiday over the next week and a half so whilst the missus is sunbathing I'll be working on this a bit. I'm using Piston for this at the moment. If I find it too limiting I may go down the rabbit hole further and commit to something a little closer to raw OpenGL / GLSL, but we'll see. I probably won't need to. Finding the docs for Piston are... less than impressive. But this language is still quite new and I'm much more interested in learning Rust than C++, so I'm pushing through regardless. Any tips for me? Specifically I'd love some advice on implementing physics - inertia, gravity, etc.
The Smalltalk one is markedly different though and indeed just re-uses the receiver so it's more a `pb.push(PROGNAME); .set_extension("conf")` kind of thing. I guess in this case `-&gt;` can be seen a some weird operator where `$foo-&gt;$meth($args *)` just becomes `{let _x = $foo; _x.$meth($args *); _x}` Unlike a weird special block construction it really is just a left-associative operator, the left side can be any expression while the right side has to be some kind of method call. It just says little more than "call this method on the left side and then return the left side as the value of the expression"
But to give emacs a shot, you'll have to exit vim first. Good luck. 
hey, i wrote nn from scratch too, you can check it out at https://github.com/jaroslaw-weber/rust-ml-from-scratch
Hi, I wanted precisely this, *a personal opinion* on the Rust formed on your experience writing a bigger project. It is just one measurement point of many. Thank you! :)
Sorry, didn't realize that was what you were asking for :p Your original question seemed more like "what's possible here?" than "how do I do this?" - I've got next to no experience with working with android though, so I'd see if anyone else can help with that.
nice one, sure thanks for the link! 
Unless you're specifically interested in learning how to implement rigid body physics from scratch (i.e. learning the maths) then I'd recommend checking out [nphysics](http://nphysics.org/). I haven't yet used it myself, but I've skimmed the API docs and I'm already using nalgebra (its underlying maths library) and finding it really nice to work with, including good documentation. More generally, I'm a recent convert to the Entity-Component-System pattern for structuring game logic, and have found [specs](https://slide-rs.github.io/specs/specs/index.html) to be a really good implementation of the idea. Happy to answer any follow-up questions as best I can. :)
I wouldn’t necessarily say Rust has better guarantees than Ada – there are some in Ada that Rust cannot enforce right now in compile time, eg. in Ada you can define a new ranged index type for indexing your array, and then it will enforce using only valid indices, whereas Rust will accept any `usize` and panic in runtime – they have different guarantees. But both languages’ type systems make it possible to encode huge part of your contract into types and make it safe for usage. Thanks to that we have such libraries in Rust like Vulkano. Or libraries for embedded which enforce proper handling of interrupts without runtime overhead, etc. Or [crates with special lifetime magic](https://docs.rs/indexing/0.3.0/indexing/) that encode checks for indices similar to Ada’s.
&gt; "Good programmers write C, average programmers write Rust" This attitude is condescending and seems to suggest that good programmers don't write software violating memory safety. The track record of undefined behavior in widely used C software does not support this.
Here is new link: http://www.tweag.io/posts/2017-03-13-linear-types.html
A benchmark suite would be nice to see actual results compared to the original implementation. I've implemented a very similar library some time ago, but not as BufferedFile but as more generic BufferedReader (no writing support though): https://github.com/gcarq/seek_bufread 
If we find a way to add Rust-like safety to existing C++ language, I think most people will be very excited with the result. Alas, as far as I can tell we haven't found any way to do so, and the prospect is not good. The fundamental problem is to understand how to control aliasing. On the other hand, Google's [Thread Safety Analysis](https://research.google.com/pubs/pub42958.html) successfully applied Rust-like system (linear type: although concept of linear type is not owned by Rust, Rust is by far the most prominent linear type language at the moment) to the problem of C++ thread safety, and I agree such endeavor is very valuable. I can't speak for others, but I am firmly in "I want safety features used, I couldn't care less about it being Rust" camp. Maybe we should try harder and get memory safety analog of Thread Safety Analysis for C++ working. I agree it would be much higher impact and better use of resource than working on brand new language like Rust, with one caveat: if it is possible. I am torn between whether it is impossible, or nearly impossible. I would have said "impossible", but I would have said the same for Rust, so I am reserving my judgement. But really, I have no idea how to get it working.
&gt; To me, pattern matching, Cargo and concurrency are enough of a win. To me it is not, and I think it is same for many (most?) people. There is a lot of (justified) inertia, and if Rust is (say) 10%, or even 2x better than C++, I think it is reasonable to conclude that it will fail. I think Rust should be 10x better to succeed, and that's why I think it is absolutely critical that we successfully sell Rust's safety features, and should never de-emphasize safety. I believe I made my opinion clear in the past's "fireflower" discussion, and I am aware many in the community disagree. For example, many want to focus on Rust's productivity features, de-emphasize safety, "just put safety last" as you said. I rather strongly think it would be a grave mistake, but so far I failed to convince others.
&gt; I have a hard time convincing C developers that "just write correct code in C" or "just hire competent programmers" are not working. This seems to be a pattern, and is simply a result of a lack of visibility of C problems. If on average C developers make 3 bugs a month, there 10 in the team, and a system integrates 200 such projects, the result is a mess, yet for each developer its just 3 bugs, what's the big deal. Conclusion is that it would be good to have such data (widely used projects have CVE lists or publically available issue trackers, others may not gather such data or not have it in one place), but also that one should choose arguments depending on the audience.
&gt; Rust really needs to sell itself over safety, maybe just put safety last. Rust needs to self itself on different things to different people. &gt; The cool thing is that Rust is being talked about on mainstream sites "It Doesn't Matter What The Media Says, As Long As They Spell Your Name Right" :-)
I dig the reference. But the implication is then that we need superheroes to do normal engineering ;) 
With over 50 new commit in the dev branch Native-Windows-GUI progress slowly ([link](https://github.com/gabdube/native-windows-gui/tree/dev)). I wish I had more time to work on it. Anyway, with the treeview done and the tabview mostly done, I will focus on integrating travis CI to the repo.
Granted, I'm well aware of ggez! :-) ~~I'm too lazy to read the docs! NIH syndrome!111~~ :-D Ahem... It's a cool engine and I recommend it whenever anybody asks me about 2d game engines, but I don't think that ggez's core values match my needs in Zemeroth project: - Ggez tries to mirror Löve as closely as possible but I don't believe that what's good for highly dynamic Lua is equally good for Rust. - It seems to me that ggez is targeted on beginners and fast prototype-like projects but I'm going to invest _a_ _lot_ of time into this project. - I want the engine to be much more opinionated about UI, scene, etc. - Right now ggez uses SDL2 (and it's not easy to replace it with glutin) but I really want to use cargo-apk. 
I second. Inertia, for what ever reason but usually cost, will keep existing code bases around and in any language, look COBOL and Fortran are still around. And another "debate" is ongoing on a post I made yesterday, when I was asked to give the pro's of both languages. As it stands today and if we exclude the borrow-checker, there is no strong point to move from c++ to Rust. And the c community will not move neither as they didn't move from c to c++, which has much more in common with Rust than C, yet being a "C" language. I also think the point raised about the Rust community is the "pushy" feeling others get and which is counterproductive. "If you're arguing, you're losing" is a quote that resonate in my head when I read these. What rust needs are real full rust end-to-end solutions and/or applications to showcase. The best candidate is Firefox (Servo?). Another important point is stability and maturity. Multi million dollar corporations will not bet on a young language vs a ISO standard one and the crates are yet not future proven neither. I still believe rust is a good language to learn (or to help to dis-learn older bad habits). Today, I'll stick to modern c++ and look forward at it's future features, sincerely regretting the borrow-checker as much as I regret Ada's strong basic types and clean/readable syntax. I do hate these large amount of curly braces (Ada was also mentioned in this discussion).
This is cool: I might use this library (in a far future) for my [`asciidoctor` crate](https://github.com/antoyo/asciidoctor-rs). Continue the great work!
True! This is how I would have written it in BASIC on my first computers in the 1980's. ;-)
I finally found the root of my issue in porting my web browser [titanium](https://github.com/antoyo/titanium) to a single UI process (with multiple web processes) architecture. That was caused by FD not removed from the glib event loop. I also made some improvements to my [`asciidoctor` crate](https://github.com/antoyo/asciidoctor-rs). This week, I plan to continue working on both of these projects.
the front loading is a tradeoff: I'm not convinced it's always a win; My thinking is that despite the memory safety, you still need to write some tests to verify actual behaviour: as such these give another chance to catch memory problems. The problem is that it's harder to prove safety 'line-by-line', so you need to over-estimate (e.g, needing 'split_at_mut' when you want to change 2 items in some situations) .. I think sometimes it's more efficient to be able to write tests quicker. (of course Rusts primary use-case requires the over-estimate). You're sometimes paying the cost *twice*, i.e. the tests you needed to write anyway are also more verbose. something else: bounds checks on arrays imply the remaining possibility of logic problems. If you're truly confident about the logic, *those should be unnecasery*. Rust makes what I call a "debug build". You still (to my mind) need to test it to the point where you know indices are in-bounds, by virtue of sound higher level logic (beyond the borrow-checker). If your aircraft engine control software has a bounds check that panics!(), you program was still 'unsafe' really.. e.g. "is it safe enough to run your aircraft engine... no", whereas the fully tested version (even minus bounds checks) is. (it seems safety has a spectrum of meanings)
Macho bullshit is exactly what it is. That and anti-intellectualism.
 I wonder if a compiler could be built with both rust &amp; c++ in it's core, accepting rust or c++ as a front end (much like how clang is a combined compiler engine for c,c++,objC) .. e.g. making the borrow-checker available as a static analyser for C++ (imagine coming up with some conventions to tag pointer lifetimes, like wrapping some references as ref&lt;T,ID&gt;) 
&gt;&gt;" As it stands today and if we exclude the borrow-checker, there is no strong point to move from c++ to Rust." I'm in the opposite camp.. I don't care about safety much (i need to write tests for other reasons, and I know C++ static analysers exist, we could wrap references as ```ref&lt;T,N&gt;``` smart pointers to name them whilst using a similar 'self assumption for T&amp;.) ... But I remain interested in Rust for it's conveniences/cleanup: *no header files*, better *immutability-by-default*, *better lambdas*, *better inference*, *easier serialisation*, *tagged-unions*, *tuples* (ease of using multiple return values), *expression-based syntax* (the 'enum..match' combo is very pleasing, but it shows up elsewhere too). *nicer macros* (handy for debug etc) Whilst i'm not 'safety obsessive' (and actually dislike many of rusts restrictions) I *do* definitely like the fact Rust calls globals 'unsafe'. This helps document side-effects (communication about what a function actually *does*), and helps writing parallelizable code. To me that's like completing the idea of 'const correctness'.. it bugs me that C++ has no way to say *'the globals are const'*. I like the fact it makes writing code where everything is initialised *syntactically easier* (e.g. writing an uninitialised variable is a form of repitition that is more elegant to eliminate, so there safety and elegance have synergy.)
Hey, check out [our repo](https://github.com/paritytech/native-signer). It's an app written in rust and react-native for iOS and Android. We will be releasing it soon. If anyone is interested, I can also write a blogpost a describe the development
These are all indeed nice to have.
&gt; Juggernaut is a powerful hero, when he has enough farm. That's applicable to all late-game carries ;)
I'm still circling thermodynamic temperature/temperature interval implementations in [`uom`](https://github.com/iliekturtles/uom) (type-safe zero-cost dimensional analysis) and ended up doing a bunch of macro cleanup last week. This week I'm going to try to get thermodynamic temperature done for real.
Some thoughts: - `address as u32` - what about on 64-bit? - Are you *sure* those function are `extern "C"` and not `extern "stdcall"`? - Have you tried writing the code in C to see if it works? If you have, and it does, someone might be able to tell you what you're doing wrong.
Spin to win!
Is this about downvotes on reddit? What is the policy? / Where can I find it? 
If you compile against musl, you'll get a statically linked binary that you can run `FROM scratch`. That way you don't even need alpine, and your container will be as small as a your binary. 
I often see people who really are just honestly expressing an opinion getting downvoted on this subreddit. It's unfortunate. If someone's being rude - fine, yeah, downvote. But sometimes they're just disagreeing, but they're going about it in a completely fine way. I saw this just yesterday. I see it often. If something hits /r/programming it happens a lot too. The community is downvote happy.
Last week I've started a project to port libopus (currently in C) to Rust (unrelated to the recent blog post about how to rewrite C stuff in Rust, but I've ended up with a very similar strategy). My strategy is that I take one source file at a time and convert it to Rust, keeping the same C API. I'm linking the testsuite with the C and Rust components of the library, and then make sure that each port of a file doesn't regress the testsuite. This way I always know which code I need to debug if it fails :). Rewriting libopus is not a small project. The C codebase right now has about 40k lines of raw C code (comments, blanks, and headers are on top of that, but tests are included). After one week of working on it, I have ported maybe 1.4k lines... A very small piece of the pie. That being said my main focus is on the decoder and no fixed point/sse/asm optimisations, so I'll need only a part of that, maybe around 15k lines or something. If I can release a decoder that's written in pure Rust until the end of the year I'm quite happy. This week I want to continue porting the celt decoder part of libopus.
There's definitely plenty of effort going into hardening C/C++ programs, as their should be. I'm a big fan of compiler mitigation techniques, and we've seen these significantly impact the cost of exploitation over the last 10-20 years. That said, the work involved to get C++ to the safety capabilities of rust is likely not possible without major breaking changes to the language, at which point... you're just writing a new language. If it were possible Mozilla would have invested there. Thankfully we have many, many developers with different skillsets. While some harden C/C++ others can invest in building new software in new languages that can make stronger guarantees. It isn't one or the other, it isn't rust vs C++. 
gg
I've been improving my binding for JavaScriptCore, which can be found https://github.com/endoli/javascriptcore.rs ... I've taken the approach of documenting the -sys crate from the header comments in the C API and then building the higher level crate on top of that and trying to keep up with the documentation. I need to do a new release once I get more working, but the docs for current master can be seen at https://endoli.github.io/javascriptcore.rs/ I've also been working with some other people on a crate that provides common implementations of things that you do with disassembled code: https://github.com/endoli/disassemble.rs/ ... Someone else is working on implementing support for using it with Capstone and I've been working on WebAssembly support. I'm open to help or suggestions on the above. It is difficult working alone all the time. :) 
Good old sloppy C is easier, yes. But writing production-level C is harder and more awkward.
&gt; "just write correct code in C" or "just hire competent programmers" are not working. I think people need more time. When I started writing C(++) I was over-confident and believed I can write correct code. Then reality hit me hard and I did bugs even when 100% focused. I spent too much time on debugging. I realized that most bugs are similar (memory bugs) and that I need a tool to help with that. Thats how my pride ended. Maybe other people just have to experience this too.
I think frontloading is a problem that should be solved. My preferred solution is to turn compile-time errors into runtime errors. For example, Haskell allows you to write programs with incorrect types. You can compile, and more importantly, run such programs. Type checks still happen, just in runtime. This is available by -fdefer-type-errors option, and I think we should have it in Rust too, especially for borrow checks.
I have a dream: "Good programmers write C, average programmers write Rust" A dream that this sentence is the truth and nothing but the truth - and that the consequences are enforced: Whenever a C-programmer makes a mistake that Rust would have prevented, it's proven by evidence that this programmer is not a good programmer and thus he or she may never again write any C-code.
That doesn't enforce the type of the iterator binding, though (it just makes sure there is no ambiguity in the constant literal). Consider a more general case where the loop is iterating the response from a function (which is the actual case I was looking at when wanting this type information - the i32 was just to simplify the explanation): there would be a lot of value in stating what the type is so I don't have to dig through a few other levels of indirection just to see what type I have.
I just got downvoted for mentioning Haskell's -fdefer-type-errors. This is indeed incomprehensible.
Awkward? Definitely! Harder? I don't fully agree. Rust does help with memory issues, data races etc... However that's just one component where rust is "simpler". Algorithmic errors can occur at the same frequency, that's independent from the language. Besides frontloading, and having a more complex (flexible, efficient!) syntax, there is also a higher cost due to tooling, libraries, interfacing with other libraries. And that too can be percieved as a higher difficulty when building projects.
Then you have once again code which may (depending on the input data) crash unpredictable during runtime. This is one of the main reasons Rust chose strong static typing, implemented the borrow checker and has no null pointers. It is an integral part of the language and as far as I know not even open for discussion.
I hope this won't happen. Dynamic type checks (or borrow checks) are awful, and they are encouraging bad initial design.
I have published my first crate called [easyfibers](https://github.com/SergejJurecko/easyfibers) easyfibers is a closure-less couroutine library for executing asynchronous tasks as painlessly as possible. It allows one to write code as if it used blocking sockets and does not require putting your code in awkward closures. It will seamlessly poll and schedule fibers on read, write and accept function calls.
&gt; something else: bounds checks on arrays imply the remaining possibility of logic problems. If you're truly confident about the logic, those should be unnecessary. Then write unchecked indexing in an `unsafe` block!
Oh yes, to get the total cost of switching it's necessary to look at the whole ecosystem. And a lot of areas where safety is important are also very risk-adverse, like embedded. I suppose you can say 'awkward' instead of 'hard', but it gets so ugly checking every possible error condition in C, and it becomes hard to do the right thing ;)
Rust already can crash unpredictable during runtime because of bound checks. What Rust promises is memory safety, which does not mean that Rust programs do not panic. I am simply proposing that like bound checks, allow type checks to happen at runtime, leading to panic. I think you are misunderstanding what is "an integral part of the language".
Well you would of course not use this flag during production. I think not even for a single commit, it would be strictly for developing.
This looks really cool: I'll try that. I was looking for a small abstraction over `mio` and easyfibers looks promising. Have you done some benchmarks?
unfortunately they can't currently re-use the [] operator as unsafe , so it's an example where you need a bit more syntactic bloat .. its unfortunate that beyond unsafe{} itself, they seem to syntactically discourage unsafe in other ways (e.g having to write both *mut and *const instead of one being a default). The best option IMO would be an whole-program 'unsafe build' option:- C++ | Rust | what does it do =============================================== high-debug | debug | (asserts, etc) low-debug | release | (just basic bounds checks) release | 'unsafe_release' | (all checks disabled)
Yes, I've definitely used evil mode. Never had a problem with it, so I can't relate to your experience. (On the other hand, I was mostly content to leave non-editing tasks with non-vi bindings, so maybe that's the difference in our experience.) On the other hand, I definitely *did* have lots of problems with Spacemacs (which I used before I tried evil mode). It felt like it tried to take over everything in Emacs, but a lot of the stuff it did only halfway worked. I found it very frustrating.
What’s that supposed to mean....
Ah, so it was. Thanks, somehow I completely skipped over that part!
Those obviously weren't good programmers.
I certainly agree that a really, really useful feature in any package manager which downloads from a central repository is the ability to change the base URL for downloads from outside the source-controlled project (so through an environment variable, ~/.cargorc, etc), with support for that being a file:/// URL. Then, you can somewhat trivially switch between internet, intranet, and offline modes of operation, as well as use an alternative repository should the canonical repository die or turn evil. A useful complement to that feature is a tool which can mirror some subset of a repository from a given URL to a local filesystem, to bootstrap an offline or intranet repository. For package managers which don't work by doing dumb HTTPS downloads from a single repository, this is a lot more complicated to achieve, but you can do similar things. 
You need an https:// after your (. 
One is not like the others: Rubys `tap` is not syntax.
I actually made the mistake of not using extern "stdcall", thanks
Continuing work on the [rustcod project](https://github.com/rustcod), a spiritual successor to [`libtcod`](http://roguecentral.org/doryen/libtcod/) (a roguelike toolkit). I have part of the first chapter written for the [roguelike tutorial](https://github.com/rustcod/roguelike-tutorial) and have been working on refactoring the tile renderer for ergonomics. Everything is still ultra-early and I fear this project will take a _long_ time, but at least there is progress being made. Feel free to follow [@rustcod_rs](https://twitter.com/rustcod_rs) if you're remotely interested in this kind of thing.
I'm not very knowledgable about nn's, do you know of any good resources where I could learn more about, say, the setup you have in the example on your front page? I see a dataset with 4 samples, of which each are 2 vectors, the first of length 3 and the second of length 1. I have no idea how you get from there to "this nn should have 2 layers, the first of which should have 2 neurons and 3 inputs and the second of which should have 1 neuron and 2 inputs." I've read some literature on nn's but it's this kind of design step that I rarely see reasoning for, and I'm assuming I must be missing something because this leap is so often glossed over in explanations that it feels like it is obvious to everyone but me.
I can't remember who it was, but I saw an excellent point on another thread recently: Safety is "avoiding a potential negative" and, due to human psychology, that's much harder to sell than "gaining a definite positive".
The current version is considered the "i3 version" in my mind. It's not 100% compatible, and I don't think I'll ever try to be a direct clone if it (sway does a good enough job already) but I find it more than sufficient already coming from i3. 
that's it. 
Maybe a better concrete question is this: why not use file backed memory maps?
The problem is that, in many cases, what makes Rust's features so special is that they're used throughout the standard library and ecosystem. Retrofitting them would be a breaking change. For example, Java has an `Option&lt;T&gt;` equivalent now... that doesn't prevent the older parts of the standard library from throwing nulls at you.
10% of rust -- that's not what I'm looking for. 
Sorry, joked about authors = ["Your mother ;)"]
checked the repo similar project right? it would be great to have someething like pytorch with dynamic graphs and cuda, but i guess it would be a big and difficult project...
Given how people treat compiler warnings in C and C++ and the fact that deadlines slip all the time, I think "people will put 'deferred checks' code into production and never bother fixing it" is a very valid concern.
Oh! I totally forgot I changed that! I’m so sorry! Have some updoots.
But once you have this "dev-only" flag, people will use it all the time even in production...
C and c++ are exploit writing languages and we can no longer continue to afford to use them for anything connected to the network that runs at elevated privilege. 
Not yet. The code is mostly accessing vec's, VecDeque's and jumping in and out of fibers. So if context-rs and mio are as fast as advertised it should work quite well. The only heavy part is allocation of fiber stacks. I will add a configuration option to preallocate some. 
You could go back in the git history and look at it directly.
Then they ship the program thinking it's ok and we are back to square one. Full dynamic borrow checking would require checking every memory access at runtime.
&gt; Maybe a "flag" do not check crates.io &amp; download will be more than enough. This flag already exists.
I really suggest reading this post: https://karpathy.github.io/neuralnets/
On the other hand, I bet we already have production Rust code that unwraps Option which can panic.
How are we back to square one? Dynamically checked Rust will still have entire security benefit of Rust. I am not talking about disabling checks. In a sense, making checks static is strictly an optimization.
I forgot to mention what I do like about cargo is that it offers me the same ease of compile as gnatmake for gnat Ada. But then the point is I do not consider this a language feature and not a reason to compare languages. And not all IDE like these "builders" or require specific support for them.
Agreed, except that I'm not sure which part of the Emacs system Remacs is porting? I thought Emacs was written entirely in elisp. Are they just rewriting the wrapper code for connecting to the OS?
I tend to agree, but many, many things are either not connected to external network, or do not run at elevated privilege.
I've looked at the source code. What I rather desire is some sort of commentary from the people who worked on the compiler using OCaml. It would be quite interesting to hear their perspective on the whole experience.
Thanks! Edited!
&gt; I thought Emacs was written entirely in elisp. That's not quite true - after all, your machine doesn't execute elisp natively. The Lisp interpreter, and actually quite a lot of basic builtin functions, are all written in C. All in all, 300k LOC - or in current Remacs, 290k :)
I'm working on a small terminal project which teaches people how to read 4 - 64bit binary and uses the rand::isaac::Isaac64Rng to randomize the minimum - maximum possibility of bytes depending on which binary set you're learning.
 A honest question: when does it make sense to reject useful tool for your toolbox? (I mean in this context, not in general like in case of languages with generics vs Go or C++ vs C)
In Rust, &amp;mut T is not Copy. I think the entire problem can be summarized as how to retrofit that to C++.
&gt; your machine doesn't execute elisp natively. Really? The Lisp interpreter isn't self-hosted? That's wild. Makes sense I guess, but I had no idea. (Behind every programming language is C, lurking forever in the shadows.) This is a very cool project! I'm excited to see where it goes. Makes me almost wish that Neovim had adopted Rust, haha.
I've filed all these as issues on the repo now, and I'll work through them. Thanks again :)
Actually this is how [petgraph](https://crates.io/crates/petgraph) implements it. (They are using `unsafe` in a few other places though.)
&gt; Good programmers write C, average programmers write Rust I'd describe it as "good programmers write average C, average programmers write good Rust". Compared to C/C++, programming in Rust basically gives you superpowers, thanks to the compiler as pair programmer.
Thanks so much!
Do you mean something like calculating the `Matrix.dot()` using cuda instead of using CPU?
I'm still playing around working on [weld](https://github.com/RoyJacobs/weld), which is my attempt at a GUI library. I currently have Webrender hooked up to Facebook's Yoga thanks to yoga-rs. Yoga provides a FlexBox-style layout system. I have a basic event loop up and running and you can click stuff, that's it. ([code](https://github.com/RoyJacobs/weld/blob/master/weld/examples/button.rs)) Detecting which item was clicked is now looking at the layout coordinates, this will break when layering items. I couldn't find an API in Webrender to hook into its own visual tree, unfortunately. Anyway, next steps are: - Figure out what the best way is to publish events and propagate state changes. Currently I just have a mpsc queue which works for events, but for state changes I want to have more flexibility so I need to look at futures-rs I guess. Stuff like "hover over a button and set something to visible after 300ms" should be expressible as some composed futures. - Do some basic rendering instead of just randomly coloured rectangles - Clean up the way a component tree is declared (get rid of the "vec!" everywhere, maybe use macros, ...)
lol
Primarily because i don't know what that is, and this seemed like a reasonable solution at the time.
&gt;&gt; Good programmers write C, average programmers write Rust &gt; &gt;That's a weird attitude towards problem solving. I'm not sure where it originated, but I see this attitude as an extension of the "blub" language mindset where languages exist on a spectrum of features / capabilities. Originally this argument was used by Paul Graham to argue the merits of Lisp, and it sparked a lot of debate because it implied you get less work done in "lower spectrum" languages. C, being a "lower spectrum" language must mean it takes considerable skill to make something great in it (eg, a kernel). This is false, of course (C was literally made to make Unix), but the idea still persists because it's easier to see languages as camps and levels of enlightenment rather than the tools they are. 
With your farmer example I think another point is In C alot of people write create their own harvesting method/tools(librarys). In Rust a few people work on one universial and good method/tool. Alot of people tend to introduce their own small collections or other stuff in C. I mainly worked with C++ and tbh It's super annoying to work with any dependency It just gets alot of work to make It compile. I rather use an external library than introducing my own library(which basicly struggles to be perfect) in Rust. If you think you can do everything perfectly on your own you are just stubborn. For example I created my own small http library working with http and c++ on top off boost asio. If I compare this one to hyper I think my library was by far worse. Also If I look @ rust librarys I see a very common coding style. In C every group has It's own. For me OpenSSL is almost unreadable code If you ask me. Another example I have is EA. They have their own C library for their games which also has a very bad SSL implemention. For the outside It's partwise flawless because It works and that's often enough but It has so many bugs and It can be very critical because in theory someone can log your login info.
Memory maps permit one to represent the contents of a file *as if* it were a contiguous chunk of memory. The file doesn't need to be completely in memory. Instead, the operating system manages which parts are in memory and which aren't. It's basically doing the work of your buffered reader for you. Rust has a good [`memmap` crate](https://docs.rs/memmap). Note though that there are trade offs involved. I suspect the biggest trade off is that memory maps are somewhat subservient to the operating system in terms of what is actually in memory or not, where as with your approach, you could specifically always keep certain sections in memory if you have a priori knowledge that they are "hot." Memory maps can be tweaked in this regard with `madvise` if you need that level of control.
True, but I'd argue that it's a balancing act centred around guiding the programmer's impulses. In fact, my personal opinion is that the current state of things is your "deferred checks" mode and, if Rust continues to work on ergonomics and optimization, we may some day be able to push the community's view of `unwrap()` and `expect()` in the direction of "`unsafe` in spirit, if not in what the compiler enforces".
yep. also implement more than just the basic neural network, adam adagrad lstm etc. pytorch and tensorflow are great but they r both in python and especially tf is hard to debug. i pray for solid rust nn library but its a distant dream...
This week I will be laying out the groundwork for Complex UI Components in [Lattice](https://github.com/andrew-lucker/Lattice). A Complex Component is a UI Element like a File Dialog that contains many primitive Child Components, data, and interactions. The first step towards this was adding [Modifier Stacking](https://github.com/andrew-lucker/Lattice/commit/4d28735d9f78b1cde9edb0519e9814404a637d24) which allows rendering using multiples of the same Modifier class. This is important because children nodes of Complex Elements need to inherit some modifiers from their parent (like x,y offsets). and there is a new example doing just that. This is great because it opens the door to project or library based reusable Components rather than one-off rendering instructions for every view. 
Are you aware of [corrode](https://github.com/jameysharp/corrode/)? If yes, mind explaining why you opted for a fully manual rewrite instead?
yeah I do understand what you mean. I don't have much experience with TF though. I really like to work on such a project but you know, if you want to start such a huge project you need to have a team. It is more than a side project. 
The neural network train : https://github.com/jramapuram/Hal (shameless plug)
But that's you asserting that you are sure the value of a type is a certain variant (and if it's not, something horrible has gone wrong). If you defer type checking, this makes it less likely I can rely on code because the type may not even be correct. Forget unwrap, that means when the option is returned it will panic, which is much harder to catch because it's implicit (which the static type system should have made explicit) 
Haskell has this flag, and I don't think anyone uses it in production...
No offense, but it is missing too much, like convolutional layers, pooling layers, dropout, LRN, Batch (Re)Normlazitation, different activation functions, different initialization functions, different cost functions, numerical stable algorithms, GPU support, multi-threading support, distributed support etc.
Rust bindings to TF?
I think you missed the point of "experimental."
I thought about this `-unsafe-build` too, but then, what do you gain from using Rust? If you disable all checks for a release build, the potential for shooting your feet greatly increases, as you will think that your program is bug-free when testing it in debug mode, only to be surprised when the release build crashes in some very specific (and rare) circumstances. It would also help the mentality of _I will fix this later, just let me compile right now..._ which, arguably, defeats one of the purposes of using Rust in the first place.
lol, 10% cause I reused libraries placed in different repo (our desktop app). you judge to quickly
You didn't mention, you recommend that Rust adopt the same functionality, which many of us disagree with.
Well in my case in all Java code we just use Maven pulling some stuff from Maven Central.
tensorflow offers rust bindings, if that's what you are looking for: https://github.com/tensorflow/rust/blob/master/README.md
You are right Stefano, thanks for your suggestions. I'm still working on this and I'm hoping to push the project a little bit more during my spare time but please note that: - it is still experimental. not production ready at all! - it is not a stable version Cheers! 
These days nearly everything is.
No offense, but everyone can reach this state with a simple tutorial about neural network. Doing this in Rust is nothing special.
Yeah, I guess I just saw what I wanted to see.
&amp;mut T shouldn't be a copy. Copying is explained in the TRPL, for instance T.clone(); The TRPL is available for free if you want to work through it.
The author isn't advertising this project as "production-ready and feature-complete machine learning library". Obviously, the room for improvement is huge. However, I really doubt a single person could come up with a decent implementation of the whole bunch of features you mentioned in a reasonable amount of time, so I'm not sure why you expect that from a person doing a good job while learning a new language.
No problem. In my opinion you announced this project too soon. You may have better chances to involve contributors if the project would be a little bit more mature. But this is just my opinion.
Right, I see your point. I will keep /r/rust updated after each version. thanks!
I don't downvote posts I disagree with. Do you?
The BufFile doesn't have the whole file in memory, just the hottest spots (though if its a small file it will be 100% in memory). Seems like I could have just used that memmap crate instead of creating this little project. Edit: After looking a bit more at the memmap crate, it doesn't look like it supports the type of behavior I wanted. The BufFile behaves exactly like a file - it's just faster than writing directly, where as memmap is something else entirely. I wrote BufFile to be something that could easily be swapped out with File, and be used exactly the same.
This is awesome! nice work. I see you wrote your own matrix module. Did you check out rulinalg or ndarray? I want to start writing a computation graph library as well (for learning purposes) but haven't figured out which crate would be best for n-dimensional stuff / tensors. Not to change the topic of discussion - but I'd be curious if anyone has any experience with either of those libraries?
I'm working on a 0.1 release of [Rudy](https://github.com/adevore/rudy/), a Judy array implementation written in Rust. This release will unblock a [specs PR](https://github.com/slide-rs/specs/pull/222) to add Rudy support, potentially speeding up storage in the future. Major features are an expanded API, improved performance, compilation on stable, and better test coverage.
I see your point. My criticism is, that timing to announce something matters. Sometimes someone can learn more from critics than from supporters, but I know: To MAY hurt someones feelings is a taboo in Rust's code of conduct. You can have of course a completely different view of this. No problem, I can handle this.
Thank you! I'm glad you liked it. Actually I've heard of those repos yes and I tried to use them but to be honest I don't remember why I gave up and wrote my own Matrix module!
And it is... ?
Ignoring the Rust conversation for a moment, this is a pretty fun little game if you're into puzzles.
http://doc.crates.io/faq.html#how-can-cargo-work-offline contains an overview, `--frozen` is what I'm thinking of here.
Or you can use rc-tree.
Could this also be used on iOS with the provided Framework version of JavaScriptCore?
Just imagine you as a dev new to Rust having the power to silence that pesky rustc spewing type errors at you when compiling by setting a single flag. Surely the mess you coded won't blow up in your face at runtime, right... right? The temptation would just be too great to use something that runs counter to some of Rust's strong points. And if this were to be implemented it would obviously be picked out as a flaw/self-sabotage by "critics".
That's fantastic. I truly love it. ♥ Though given the name of the engine, perhaps 💔 is more appropriate... For the peanut gallery, I offer some responses to the statements about ggez: * Practically, ggez tries to mirror Löve as closely as *feasible*. My experience is that the mismatch between what's good for Lua and what's good for Rust is a lot smaller than I expected. Most of what Löve uses highly dynamic types for is convenience in function signatures, which is easy to Rustify just by making the function signatures a bit more tedious. There were some bumps figuring out the right way to shape the `EventHandler` trait in 0.2, but it's much nicer now. (Whether there's a better way to do things than Löve's API is left as an exercise to the Amethyst and Piston projects.) * I'm writing what I intend to be a commercial game in ggez. Not many problems so far! * The intention of ggez is that things like UI and scene handling would be written on top of it. Things like physics and particles too, actually; in Lua these *have* to be written in C++ and integrated into the engine for performance, but in Rust there's very little that ggez can do that you can't do just as efficiently with an external library. * There's a semi-experimental [fork which uses glutin](https://github.com/sjaustirni/ggez), so it's possible with a bit of work. It just conflicts with portability goals -- mobile and wasm will be hard(er) if we leave SDL2 behind. Still. Häte2d. Glorious.
You are not forced to use `-fdefer-type-errors`. I think it would be nice to have.
Sweet! Well maybe think about extracting that code into a stand-alone library once you get a bit further along. Anyways, excited to see where this goes.
Nope, I don't upvote my own comments either. I do downvote misleading statements.
Yeah I was thinking about the same idea! I will do that for sure. thanks!
I sympathize with the "safety last" crowd. When coding games or scientific simulations, you don't care that much about memory safety. Having C++ with a stronger type system and better tooling is a more interesting proposition.
&gt; &amp;mut T shouldn't be a copy. That is what your parent said, so you're in agreement. &gt; The TRPL is available for free if you want to work through it. There is no reason to be condescending.
Uh, aren't your own comments upvoted automatically? Do you specifically go back and un-upvote them?
Hi /u/rodarmor. This is a very nice project ! Appart from the templating, what are the differences with GNU/Make ? How does the variables works ? Does it do file detection akin to Make ?
Why would you want to have a memory-leak, segfault, or out-of-bounds error in your program? And how much code would you write before you went back to try and fix that? It seems to me that by increasing the amount of code that might potentially be invalidated by the eventual bug-fix you have to implement, you're only creating trouble for yourself. 
Looks like the title doesn't really communicate anything, maybe make a new one with a better title?
I'm confused by your reply. I don't think /u/sanxiyn wanted to know how to clone `&amp;mut T`, he was just saying that the semantics of `T*` in C++ are `Copy`, while they are not for `&amp;mut T` in Rust. Because of backwards compatibility, it seems impossible to make it not `Copy` retroactively. (But couldn't you create a new type?)
Well, there is a reason why a lot of people favor dynamic languages like Python. Having a switch to make Rust dynamic could make prototyping easier. (That said, I don't enjoy writing moderately complex Python anymore, because of the lack of compile-time checks.)
&gt; memory issues, data races etc... However that's just one component It's the cause of the overwhelming majority of security vulnerabilities. It's a pretty big issue. And their frequency suggests these are mistakes C and C++ developers struggle with. &gt; Algorithmic errors can occur at the same frequency Actually the programming style that newtypes and sumtypes engender make it easier to spot logic errors (e.g. C will accept compare `add (int, int)` but Rust will balk at `add (Length, Speed)`). The `Wrapped` type also helps stops a whole host of algorithmic errors when used with QuickCheck. The String type is length-checked in every operation, and the length check is O(1). The I/O system won't let you forget to close a resource. Error checking is way better in Rust too. The macro system is much better too, and miles safer. It seems to me you're going to great lengths to minimise the the fact that Rust, in its compiler and language design, reduces or eliminates outright a huge number of bugs that developers commonly make in C. &gt; there is also a higher cost due to tooling, libraries, interfacing with other libraries. The library situation is the same for all new languages, and frankly isn't too bad. The tooling is much better C though: `autoconf` and `automake` are grim. &gt; percieved as a higher difficulty when building projects. I think Rust is a bit too harsh on itself. The borrow-checker does indeed cause a couple of weeks of pain to new developers: but move-semantics, lvalues, copy &amp; move constructors and multiple-inheritance all cause pain to C++ developers; and that's after they've got to grips with the complexities of how STL collections manage ownership. Compared to all that Rust is actually pretty easy. 
Coursera has some good courses on machine learning and even one just on the topic of neural nets.
I'm attempting to add more support for generics to my mocking library [mock_derive](https://github.com/DavidDeSimone/mockitol) Mocking with generics can get a little complicated in Rust, due to the power of it's type system. I am trying to be pragmatic about what I would like to support vs. what isn't worth the potentially massive complexity to mock. 
&gt; complaining that the community will shun them if they treat other people unfairly That largely depends on your definition of unfair. A lot of them probably consider what happened to Brendan Eich unfair. It's one of the few fair criticisms mentioned. The others are logical fallacies. &gt;Rust is not a silver bullet, does not prevent logical flaws Nirvana fallacy &gt;Rust is too young, no mature libraries Self-fulfilling prophecy &gt;Good programmers write C, average programmers write Rust No true Scotsman &gt;Ada did it already False equivalency
In patterns like this: (Celsius(a), b @ _) =&gt; { I think you can just write this: (Celsius(a), b) =&gt; { Nice post!
&gt; I have a hard time convincing C developers that "just write correct code in C" or "just hire competent programmers" are not working. It's Dunning-Kruger. (Ok, well, a combination of Dunning-Kruger and low standards for software quality.)
Thanks! I'll have to try that out but I think you might be right about that.
The Go ecosystem is not built around that. Nobody writes servers like that in Go. They just write goroutines that block.
I really pondered over it for a second time, but for me the thought of adding a flag to Rust, which converts many of the compile time checks to runtime errors would go too far against 'the spirit' of the language. I can somehow understand the wish to suppress the borrow-checker, as there are programs rejected because of borrowing errors which are perfectly valid, but I don't think a flag to flat out disable it is the right way. But for the type checks, I don't even really see the use case. Maybe in some cases where you have unfinished code which you know is not called, but prevents compilation. In my eyes that is a pretty niche scenario, which can be tackled in less dangerous ways. Anyway, Rust is not MY language, so this is just my personal opinion. I don't define what Rust is or what paradigms it promotes. So you are of course fully entitled to disagree ;)
&gt; Are there any examples of anyone deploying a server in this manner, with 40-50k connections/threads? Sure there are. Google for "scaling apache". &gt; I thought that the Rust webservers previously suffered on the TechEmpower benchmarks for taking this approach instead of using (implicit like Go or explicit like C#) asynchrony. Using OS threads can be slower, yes, because spawning a thread is slower. A lot of this is due to the fact that allocating a thread stack is more involved (and note that libgreen did *not* fix this issue). But if you're doing a real workload—not a techempower benchmark—the time spent to spawn up a thread is generally in the noise.
Thanks, I've looked at those but just never had the free time to be able to commit to the work (i have 2 small children at home so my free time is limited lol)
That's my hope / plan. If not, I welcome any patches needed to make it work. :) I use it on macOS with the OS-provided framework.
Congrats to Ashley and Sebastián! I really enjoyed Ashley's talk at RBR last year, and am glad to see she is taking on a bigger role in rust's development &amp; community!
I deal with ElasticSearch all day every day, and GC pauses are one of our biggest hurdles. Keep doing the good work, hopefully one day soon I'll be using a Tantivy based engine. 
How can you guarantee any library you use or write won't be fed untrusted content from outside sources? Thats the problem. "No one will ever use my frobber library for untrusted thirdparty data loaded from a network..." "Meet iFrobber! Now you can frobber online!" "Damnit!" "Well the OS and non-executable pages, and other stack smashing risk mitigation factors will protect it!" Not every iot device processor has a MMU or way to do this.
&gt; This is available by -fdefer-type-errors option, and I think we should have it in Rust too, especially for borrow checks. Leaving aside the problem of whether this would be a good idea, I don't know how this could even be implemented. I guess you'd have some kind of dynamic, atomic, global list of outstanding borrows that you're constantly updating? Seems really complicated and quite possibly unworkable; hammering down the details would probably take as much time as non-lexical lifetimes (which took *years* to design). I'd rather spend the time on implementing NLL.
"where all the women are strong, all the men are good looking, and all the children are above average." -- Lake Wobegon Or a pithy comment about rising tides and boats... When everyone is super, having superpowers is the new baseline. Rust can raise the quality of output across all skill levels and codebases.
I am not sure whether you misunderstood what /u/sanxiyn said or whether I misunderstood either of you, so please bear with. I think that what /u/sanxiyn is saying is to defer type checking/borrow checking issues to runtime. That is, the language would be exactly the same, except that: fn makeit() -&gt; String { 1 } would compile, but abort at runtime because `1` is not a `String`. Rust, **the language**, has strong typing. rustc, **the compiler**, type checks Rust at compile-time. I will not rehearse the advantages of static typing, you seem to be well acquainted with them. There are however a number of disadvantages that bear keeping in mind. My favorite example is attempting a large scale refactoring: it can be a nightmare. In a statically typed language: you start refactoring... and churn code... and churn code... until the compiler is happy and lets you execute the first test. **BOOM**. You investigate the cause of issue, oh crap, wrong assumption, that's why the API was so backward: it accommodated this edge case! Okay, revert... In a dynamically typed language: you start refactoring, run the first test, **BOOM**. Oh crap [...] Okay revert; no big loss. As a professional developer working on large systems, you'll probably learn tricks to make your refactoring more efficient: ways to plan them ahead, ways to apply them incrementally to avoid the big deception, etc... but what if your toolchain supported this without the need to tiptoe around it? Wouldn't that be better? *Note: I have purposefully ignored the fact that static typing can also help with refactoring by pointing all the points where refactoring would help; this can come AFTER you validated the approach.*
It would be awesome for development. I'm not afraid of people running such code in production: the performance degradation would likely make it impractical anyway (compared to the complexity of the language).
This would be awesome indeed; a couple times I've just wanted to quickly test a change, but had *first* to propagate the changes to the whole crate before being able to run the one test (only discover I had to change the API *again*). A quicker way of prototyping an idea, or inserting a change on a particular execution path without having to change the whole world, would really be appreciated. That being said, while I can see how to defer type checking, I'm not sure how to defer borrow checking without significant changes to the runtime; maybe I lack imagination?
&gt; Maybe we should try harder and get memory safety analog of Thread Safety Analysis for C++ working. I agree it would be much higher impact and better use of resource than working on brand new language like Rust, with one caveat: if it is possible. I'm not so sure. Looking at the usage share of C and C++, they've been [declining](https://blog.sourced.tech/post/language_migrations/eigenvect_stack_22lang.png) ([source article](https://blog.sourced.tech/post/language_migrations/)) for years and years, and modern C++ hasn't reversed the trend—at most it's slowed it. Now I'm not saying that Rust is necessarily going to win—it's a niche language at the moment—but I wouldn't feel that my work would have more impact if I jumped ship to C++. Pardon the cliché, but I'd rather skate to where the puck is going rather than where it was a decade ago. I think one huge problem that C++ has is that it's very hard to properly learn if you haven't been working with the language for years already. If I had to point to one reason for the slow decline of C++, it would be that. The committee keeps adding features, but they can never take them away, and every new feature makes the language that much harder to get into. Working on safety features for C++ would improve the safety situation for projects that opt in (how many would that be?) but would accelerate this basic problem. At worst it could be self-defeating: you want to work on C++ because it has high usage, but adding more features to C++ makes it harder to learn and erodes that very usage. And remember that adding features to C++ doesn't mean that those features will be *used*. The relevant comparison to make isn't between total C++ usage and total Rust usage: it's between usage of a *theoretical safe C++ dialect* and Rust usage. If this hypothetical safe C++ dialect had a high learning curve, confusing error messages, slow compile times, lack of industry support, and so forth, would it get more usage than Rust simply by dint of being C++? That's not at all clear, *especially* if that safe C++ dialect was incompatible with C++ as it exists today (for example, by requiring copious code annotations). It's worth remembering that the situation today is that you could make a memory-safe dialect of C++, but at the cost of compatibility with essentially all C++ code in existence today (because all industry C++ code depends on simultaneous aliasing and mutability). Nobody knows how to do better than what I described. I expect that an incompatible C++-in-name-only would be dead in the water in terms of adoption: it would be better to just improve Rust, which has a far larger library ecosystem than the library ecosystem of this new incompatible C++ dialect would start off with (zero).
&gt; It's the cause of the overwhelming majority of security vulnerabilities. Mozilla estimated it was 50% of the vulnerabilities of Firefox; that's a good chunk, but hardly an "overwhelming majority". I do wonder what other kind of issues compose the other 50% though.
Congrats! Very nice to hear.
One interesting thing with Java compiled with Eclipse is that syntax errors don't stop the overall compilation succeeding (since it is an incremental compiler). Instead you get an exception if you hit that line. (Edit: i.e. you can still run a JAR with syntax errors in the source code.)
There are very few such people - the OCaml compiler was retired in April 2011, when Rust was very small. You can see that the [meeting minutes](https://github.com/rust-lang/meeting-minutes/tree/master/weekly-meetings) from early development don't even begin until after the ocaml compiler was gone, but there are [rust-dev archives](https://mail.mozilla.org/pipermail/rust-dev/) from the time. Probably the only people who might have anything substantive to say about the ocaml compiler are graydon and pcwalton; and it was such a long time ago it's hard to remember details. Personally, I'm interested in writing more about what early Rust development was like, but that would mostly be from a personal, social, organizational perspective, and to remember the early contributors. Do you have particular types of information you are interested in? Maybe that would jog someone's memory if they happen to peek at this thread. Here are some tidbits: - The ocaml compiler did it's own machine code translation - it did not use LLVM - The original self-hosting bootstrap took at least an hour, which was much slower than the ocaml compiler - The original compiler, and subsequently rustc, used a completely different strategy for translating generics, interpreting type information at runtime, and it was super buggy (most everything about early Rust was super buggy for a long time...) [Here's the rust-dev thread announcing the bootstrap](https://mail.mozilla.org/pipermail/rust-dev/2011-April/000341.html), and more bootstrapping discussion in various threads [here](https://mail.mozilla.org/pipermail/rust-dev/2011-April/thread.html). For good measure, [here's the commit history](https://github.com/graydon/rust-prehistory) of Rust prior to it's public release.
This is great news! I'm really excited about these choices!
Maybe make it so that deferring type checking can only be done in debug builds?
Those linked threads look very interesting to start off with. It's interesting that you mention about the performance of the originally bootstrapped compiler. It would be nice to see how the current generation of the Rust compiler compares against that as well as the original compiler (but, like you mention, it's quite unlikely to get much discussion about the older compiler). One reason my curiosity was sparked is because despite Haskell and OCaml (especially the latter) being touted as good tools for compiler writing, it's very hard to get non-academic examples. When I learnt that the original Rust compiler had been written in OCaml, it intrigued me, and I had hoped to get some personal experiences from people who had worked on that version - the challenges, the availability (or not) of libraries, how it compares to the Rust compiler written in Rust, etc. Still, those links that you have shared appear to be quite promising for a few days worth of deep study. Thank you!
That's across the entire class of vulnerabilities. I doubt any one of the other vulnerabilities is over 30%. And anyway, if your language automatically cuts out half the bugs you normally encounter, that's already half the time spent debugging.
&gt; And anyway, if your language automatically cuts out half the bugs you normally encounter, that's already half the time spent debugging. Actually, given how vicious UB bugs are, you may be saving much more: attempting to reproduce rarely occurring memory corruptions or data races is a nightmare, just slightly better than hardware issues. So yes, removing UB is awesome. I still wonder what other big classes of vulnerabilities are there, and whether some languages help against them or not :)
&gt; Personally, I'm interested in writing more about what early Rust development was like, but that would mostly be from a personal, social, organizational perspective, and to remember the early contributors This would also make for some interesting reading. In case you decide to do some writeup on this, please do share it! That would be awesome. In fact, I remember watching a video by Marijn Haverbeke on the state of Rust when he had been working on it (not sure if he was ever full time on it?) - and it was very informative indeed. People just coming over to Rust seem to not realise that Rust has had quite a long way to go to reach its current shape! I'm sure things have moved on a whole lot since then, and a more modern perspective would be very instructional indeed, so please do share your experiences if you can! In particular, I personally would be tremendously interested in the details/history of how the whole affine type sytem (correct me if I am wrong) of Rust came about. Even Haskell seems to be considering experimenting with that, and it does appear to be quite rare, if not unique amongst known languages. How did that whole conclusion come about? And, by the way, thanks for the Rust Cookbook. It is most helpful! 
This reddit is about The Programming Language Rust, you are likely looking for /r/playrust.
&gt; If we find a way to add Rust-like safety to existing C++ language I think it is more practical to start with C. C++ is so complex with its various kinds of references and a lot of other stuff that adding a lifetime system would be extremely hard. C, on the other hand, is fairly simple, it is simpler than Rust.
/r/playrust/
It doesn't try to do any file detection or buildsystem-y stuff, it's basically just for saving and running commands. Even after I stopped using make, I found that I liked having a makefile around to store commonly run commands. Eventually I got tired of all of make's nonsense, which is why I wrote just. There are a lot of differences, but mostly it just tries to be simple and hard to mess up. For example, variables are all evaluated at once, so order doesn't matter. Also, the error messages are really helpful! (Mostly because I ripped of the format from rust.)
Oh sweet! I'll check it out.
resuming work on my cross platform UI library [limn](https://github.com/christolliday/limn). The focus in on high performance, a sane cassowary based layout system, custom drawing and a system for making composable and reusable widget behaviour from a relatively small low level API. I'm not focusing on having the most compact example code until things are stabilised, the idea is higher level APIs, DSLs or language bindings can be built on top, but everything should be possible with only the core. This week I'll be doing some refactoring to replace the petgraph based widget graph with ownership expressed through `Rc`s held by the nodes themselves. Everything can be done with a single graph object and widget ids, but it becomes convoluted when all graph changes need to coordinate with the central graph, and makes it impossible to restrict graph changes to a subset of the graph, or create subtrees before attaching them, which is really holding back the usability of the library. If I get that done this week the next goal is replacing piston gfx_graphics with webrender. I used gfx_graphics at first because it was easy to build a prototype and it has a nice high level interface for custom drawing, but the performance isn't there yet.
Would it be possible to somehow only compile one test case? Then we could at least write a test that uses the new API and iterate on that before propagating the change elsewhere?
A lot of C programmers are not CS grads. They are engineers, scientists, and other specialists that picked up C along the way to do their job. I'm one: EE with only training in BASIC, Fortran, Pascal, 68K assembly, and C (one course). Every other language I know I picked up myself. I know many excellent, experienced C programmers that can only program in C, shell, and a little bit of Perl (enough to be dangerous). Learning Python is a mindfuck for some of them. Learning Rust will be a huge challenge because some of the ideas behind Rust (closure? sum type?) will be completely alien to them. Which is a shame, because the industries I've worked in desperately need to move on from C. Federico Mena-Quintero's blog entries on porting librsvg to Rust are exactly the kind of content needed to help old dog C programmers transition to Rust.
Depends, I have been confronted at different occasions with structures with similarity where nesting did not make sense or would have been inconvenient. Not to mention that you may need to map to structures you do not control yourself.
UUIDs are awesome if you have a rich UI, because you can directly generate them in the UI code and insert them in the database.
Probably a much better solution would be to create a single type that handles the issue and also adds more things. Something then like: // in Temp module pub struct EarthLikeTemp { // Fields hidden, handle details of precision and such. } trait C { fn from_celcius(v: double) -&gt; Self fn c_degrees(&amp;self) -&gt; double } trait F { fn from_farenheit(v: double) -&gt; Self fn f_degrees(&amp;self) -&gt; double } ... impl C for EarthLikeTemp {...} impl F for EarthLikeTemp {...} The system is relatively easy to use: (EarthLikeTemp::from_c(-40) + EarthLikeTemp::from_f(-40)).c_degrees() // -&gt; -80 It seems a bit verbose, but I'm coming from a space where we are creating a temperature/unit library with no context whatsoever. I feel it makes sense that in Rust-world people do care about precision/space/speed tradeoffs, so this is handled by the type itself. Rust will give you a type error if you mix different precision types, but it should be easy for the module to expose various types that work as both good defaults and good translations. The precision of temperature should be independent of how its represented (but the conventions and limitations should be focused) and it's easier to talk about what range you're focusing your precision on than tie it down to specific units. Behind the scenes an offset may be added, units may be multiplied by a power of 10, or any other issue. I agree that having enums on a unit type seems like a very limited solution (at least in the current state of rust) but it might make sense on the right context. The thing is, again, that there isn't enough atm.
How many of those languages could compete with c/++ on speed and not be embarrassed to those who care at a deep level about having direct hardware access? Most people using C/++ are hardcore into optimization so going to even C#/Java doesn't seem viable to them. Rust is the first language I know of to offer those features and real speed/hardware access. I think someone else in the comments here said it (or maybe it was another thread) but it is very No True Scotsman. No matter what you offer up if it isn't exactly c/++ it isn't good enough, even if it could very reasonably be argued as a better alternative in at least some subset of cases.
&gt; A lot of them probably consider what happened to Brendan Eich unfair. It's one of the few fair criticisms mentioned. The others are logical fallacies. If Brendan Eich's event had been 50 years earlier, it would've been about miscegenation instead of homosexuality. In another 20 years, people will say he got what he deserved without any qualifications. Now, a joke: Also, he created Javascript and has never had to answer for that. So I think it's fair to say he got off easy.
Commencing the ceremonial ritual to summon forth /u/graydon2
But then what would be the point of it? If ultimately you need to have the types work, then there's no point to defer the error checking another optimization level. If you wanted dynamic type checking, it'd be better to add to all levels as a compiler flag or something. Again though, I'm against this being in Rust. There are better languages out there for this sort of thing. 
I think this should not be down-voted. It is constructive criticism of the presented work. I also agree with the content of this post. OPs post is a bit like announcing your new database after you can parse command-line flags (a slight overstatement to get the point across, but this is really basic functionality for ML). OP, nice job on getting started, add a few more features and present it here again, please.
I'm pushing to get the [0.9 release of nix](https://github.com/nix-rust/nix/issues/632) out the door before I go camping this weekend (and I have a short day Friday because of it). I'm also working on porting more winapi-rs code over for the next 0.3 release. There's a backlog of PRs right now that's stopping me from doing more work here, but the maintainer will likely clear through a lot of that this week.
The compiler is telling me a value doesn't live long enough, but the error doesn't make sense; the listed capture shouldn't matter. [playground link](https://play.rust-lang.org/?gist=7b9b0d61b0002ba1fa4c4bba2b9649f0&amp;version=stable) fn ranges_from_codepoints(mut codepoints: Vec&lt;u32&gt;) -&gt; Vec&lt;(u32, u32)&gt;; // impl in playground fn range_value_from_codepoints&lt;'a, I&gt;( groups: HashMap&lt;&amp;'a str, Vec&lt;u32&gt;&gt;, ) -&gt; Vec&lt;(u32, u32, &amp;'a str)&gt; { let mut list: Vec&lt;_&gt; = groups .into_iter() .flat_map(|(str, codepoints): (&amp;'a str, _)| { ranges_from_codepoints(codepoints) .into_iter() .map(|range| (range.0, range.1, str)) }) .collect(); list.sort_by_key(|triple| triple.0); list } the error in question: error: `str` does not live long enough --&gt; src/main.rs:11:49 | 11 | .map(|range| (range.0, range.1, str)) | ------- ^^^ does not live long enough | | | capture occurs here 12 | }) | - borrowed value only lives until here 13 | .collect(); | - borrowed value needs to live until here
Say Bitcoin 3 times and he appears.
I don't quite understand? I'm not advocating putting runtime type checking in production. I'm saying that many times when you're doing exploratory design and refactors, type checking often gets in the way. For example, if I'm refactoring a particular submodule *m* of my project, I want to explore its new design before committing to it. If *m* is used by another module (as a black box), then my project won't even compile (and thus I can't test my refactor via examples) until I update all uses of *m* within the second module to fit the new API. Now if when I'm done exploring the redesign I don't like the changes, I have to go back and undo all the changes I made to irrelevant modules. It adds unnecessary, tedious overhead to exploratory redesigns. I've felt this pain myself when refactoring my own projects. The idea is basically to make type checking a secondary kind of testing framework during the development process. Most people don't run all their tests in the middle of refactors, but when they're done with a refactor, the tests ensure that some invariants remain true. Similarly, during the dev process, I keep type checking off, and once I'm fairly certain of my design, I turn on type checking to catch additional problems and enforce certain invariants (like memory safety, for instance). 
This has been done in a few different contexts, the results have been interesting. The first was in Spring 2014 (a year before 1.0 and stability), for an operating systems class: http://www.rust-class.org/0/pages/course-wrapup.html There have been other ones as well, last year: http://cis198-2016s.github.io/ I feel like there was one in the midwest but can't remember...
https://www.youtube.com/watch?v=Vgfz37wLbnI
Oh I see. Maybe I've just gotten tired of that kind of development process after using Python for too many years, but I can see where that can be appealing to certain development workflows. If that was how it was added / marketed, I could support that. 
I needed to make it a move closure. Rubber Duck Debugging really works.
Bitcoin, Bitcoin, Bitcoin
Interesting to see, that only 26,9% wanted to have a pure Rust course like they experienced. http://rust-class.org/0/pages/final-survey.html
Rust is an advanced topic in my opinion. So it really depends how much experience they have. And should the course be combined with other topics like OS development or embedded programming? This would be a little bit too much without Rust experience, in my opinion.
University Osnabrück, too: https://studip.uni-osnabrueck.de/dispatch.php/course/details?sem_id=f4a7c0754b566ef1f43345adaecc98cf 2016 / 2017 winter semester: https://github.com/LukasKalbertodt/programmieren-in-rust It's in german, though
Generally, people pick the community team to be involved in, not the other way around :). It's a working group, not a honorary membership of some kind. Usually, it ends up that the community team asks people and there's a certain threshold, but this is more of a formality.
Do you have a citation for that, I'd be interested in reading it. [This paper](https://amiangshu.com/papers/Bosu-FSE-2014.pdf), looking at a variety of open-source projects, found that 32% of vulnerabilities were race conditions, 20% were buffer overflows and 2% were format-string vulnerabilities. Memory leaks accounted for an additional single-digit percentage. Thus over 54% of vulnerabilities would have been caught by Rust at compile-time. Additionally they found that 10% were caused by Integer wrapping, which Rust can guard against in a limited fashion using QuickCheck and Debug builds (which includes overflow checks in the compiled code). That brings the total to 64%. The paper also include SQL injection and XSS in its total: if you excluded these that 64% would rise to 70% Compare to 0% for C that's quite impressive. 
This is awesome! I use Just for all of my projects, and it will be great to replace the windows shell scripts with a cross-platform solution. Keep up the good work!
Ada is a great language.
it's worth noting that this was pre-1.0, so you have quotes like this: &gt; I can see the advantages of Rust, but the main problems were the lack of documentation and the ever-changing versions. It could be a very useful language to use in the future once these are fixed. 
Lukas Kalbertodt ( [youtube](https://www.youtube.com/channel/UCOCrHJxnQJP1ENl6qul_UQw) [github](https://github.com/LukasKalbertodt) ) has done a course at the University Osnabrück (in Germany). ~~Unfortunately in don't know his reddit handle~~ not a 100% sure but i guess its /u/DebuggingPanda – maybe he can say something about it :) ... but his course + evaluation is available on [github](https://github.com/LukasKalbertodt/programmieren-in-rust) and [youtube](https://www.youtube.com/playlist?list=PL0Ur-09iGhpwMbNiVTBeHmIjs0GuIXhNg) but its in german though. The Feedback from his students turned out pretty well – at least from what i can tell regarding the evaluation. 
I would recommend to use [`sha3`](https://github.com/RustCrypto/hashes) crate instead. It's part of the RustCrypto project, a modular rework (with `no_std` capablity) of `rust-crypto`, was not updated for almost an year. As for your code, you need to use `crypto::digest::Digest` trait, not `std::hash::Hash`. EDIT: On the second thought, your problem is different: all cryptographic hash functions return result in the form of plain bytes (`[u8; 32]` in your case), but your code written in a way that under `T` you can have any `Hash`able type, e.g. some arbitrary struct with derived `Hash` trait. And of course it does not make any sense to place result of the SHA-3 into it. What exactly do you want to express with this generic code, why not use just `Vec&lt;[u8; 32]&gt;` in your struct without any generics?
1. Any program that processes or opens a document that could possibly have been generated by another person should be hardened against exploits. 2. See https://xkcd.com/1200/
&gt; In a sense, making checks static is strictly an optimization. That's true for languages where everything is behind a pointer, but not Rust. For data structures (e.g. Vec), you must know the size to do allocations, copy the data over, etc. The only workaround I can think of is pervasive automatic boxing.
&gt;Yes, we should stop downvoting people who use C. It is a misbehaviour. I don't understand. I've never seen this ever mentioned before, and it sounds like a red herring. What's the historical basis for this?
Thanks so much, I really appreciate the kind words! One thing that may or may not be an issue is that I'm not exactly sure how the `sh` which gets installed on windows handles paths. Recipes that use paths might not be cross-platform, since the binaries that are invoked might expect windows paths on windows and unix paths elsewhere.
Also, I'm glad you like it! Thanks ^__^
Ah, that makes total sense. Still great work though!
I've been working on a Rust IRCd (IRC daemon/server) off-and-on for over a year. In the last few months, I've developed it to the point where it's mostly functional and I'm hoping to release it soon. Basic functionality is implemented, plus a number of [IRCv3](http://ircv3.net/irc/) specifications. I'm currently working on implementing the remaining specifications. Some changes to internal APIs will be necessary to implement e.g. `batch` tags in a sane way. It will need more automated tests before it's ready for release; for ensuring that client responses are correct and that the server-to-server protocol will not desync. A lot of real-world testing will then be necessary to ensure that it won't panic under any circumstances. Ultimately, my goal is to implement IRC services (ChanServ, NickServ, etc.) and a multi-platform IRC client to take full advantage of the latest IRCv3 features. Also, I still don't have a name for the project. That always seems to be the last thing I get done.
Assuming you've already decided to teach a low-level language, I think Rust is a good choice because it's clearer about ownership and lifetimes than C. Pointers might be slightly harder to teach just because they're a bit abstracted over, but you can still use rust for that as well. 
Not necessarily. Rust is capable of being fully self-hosting if someone were to rewrite LLVM in Rust. If my memory is correct, GHC is self-hosting and porting is accomplished by a "compile to C" mode meant only for GHC itself.
I'm writing my own library right now and it's rather basic and I won't publish anything before I pass the exam, but your library really looks like one of the most promising ones I've seen in Rust so far. Maybe I'll be able to send some PRs at a later point, ideally in like 5 weeks because otherwise it means I'm procrastinating. :) RemindMe! in 5 weeks
I will be messaging you on [**2017-08-21 23:14:35 UTC**](http://www.wolframalpha.com/input/?i=2017-08-21 23:14:35 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/rust/comments/6ns2wt/juggernaut_experimental_neural_network_in_rust/dkctp02) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/rust/comments/6ns2wt/juggernaut_experimental_neural_network_in_rust/dkctp02]%0A%0ARemindMe! in 5 weeks) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dkctpd5) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Such unsafe build would make safe Rust cause memory unsafety (instead of just panicking). That would be.. really really unfortunate. The nightmare scenario is, as such unsafe_release mode gain popularity, authors of crates containing only safe Rust could become burdened with memory safety stuff, at least if they want their crates to be usable by unsafe_release users. This is already the status quo of languages like C and C++ (where *all* libraries need to care about memory safety). I think that a better solution to verbosity is to write a macro `unsafe_index!` that translates `a[x]` to `*a.offset(y)`. Like unsafe_index! { x = y[z]; } Translating to: unsafe { x = *y.offset(z); }
Fairly off topic for this subreddit, but this phrasing really annoys me: &gt; using Python to automate Minecraft on a Raspberry Pi, which typically is very motivating to guys. Statistically, girls are much less interested in gaming, and are therefore much less impressed by that approach. It's true (I assume anyways) that statistically guys are more likely to be interested in automated minecraft than girls, but that's not the important part. The important part is that there is a large population not interesting in automated minecraft that you are *unnecessarily* missing out on, regardless of their gender or any gender imbalances that happen to exist in the division of people. The issue should be considered just as major even if the division was completely uncorrelated with every other statistic you could gather on them.
I could for see specifying in Cargo.toml the api interface and optionally, `nopanic` or `nostd`, to impose constraints and get a fork or variant of a lib. 
How I approached this topic when doing low-level programming course (for people who already know high-level programming): I showed them C and talked about basic concepts. I made sure to show them various ways of how they can screw up in C. Then I showed them Rust and how it protects them. When asked which language they'd want to learn, they wanted Rust. :)
Interesting approach :)
I am aware, yes, but I wanted to get a feeling of what a manual rewrite looks like before trying it. I don't think it will be useful if the Rust that it produces is way worse than the Rust I create manually.
Personally, I wouldn't have been motivated to learn Rust in the first place if it wasn't for my experience with manual memory management, segfaults, and languages with a weak type system. Rust is (in my opinion), a really well designed language. But I strongly suspect I would've been turned off of programming forever if I had been taught in Rust before C. Compilation errors are . . . frustrating, especially if you don't know why they exist in the first place.
I'll note that /u/tomaka17 [has a patreon](https://www.patreon.com/tomaka) for funding his work on open source Rust libraries, &gt; - Android-rs-glue allows you to easily turn your Rust code into an Android package. After installing the Android SDK and NDK, run the `cargo apk` command and you will get an .apk file which you can then install on your device. Works out of the box with vulkano, glium, winit and glutin. Also provides a docker image. Also, [here is the thread](https://users.rust-lang.org/t/announcing-cargo-apk/5501) in which he announced `cargo apk` (in 2016).
One advantage of teaching Rust vs. C is that it's less likely that students are going to come in knowing Rust, which makes for a more level playing field. OTOH, as [Learning Rust With Entirely Too Many Linked Lists](http://cglab.ca/~abeinges/blah/too-many-lists/book/) has shown, it's kind of a pain in the butt to implement some pretty basic data structures if you use Rust.
&gt; There are two main schools of thought on computer science education: top-down, and bottom-up. &gt; &gt; [B]ottom-up focuses on the core fundamentals and begins moving upwards, which means starting with C, then extending to full C++, and eventually teaching some Java, some awk, some bash, etc. &gt; &gt; Top-down is where you start in the other direction, with Python or a GUI block programming language, or whatever, and then work your way down to C and manual memory management. The two approaches can and should be taught concurrently, and this is where Rust can be especially helpful. Among other things, this enables the student to become familiar with how each of those "high-level" constructs is implemented in "low-level" terms, which is quite necessary if one is to understand their performance properties. (Personally though, I think it makes sense to teach Rust after a brief introduction to C. I don't think it makes for a good "toy language" on its own, for similar reasons to C++.)
I agree with this comment entirely, I didn't mean to come across as disagreeing with the content of your previous comment, just the phrasing. The gendered phrasing takes emphasis away from the actual problem (motivating people with diverse interests), and honestly I think does damage to the gender imbalance problem as well (along the lines of the issue discussed in [this very fine article](https://communequation.wordpress.com/2017/07/05/im-not-a-woman-in-tech/)).
&gt; OTOH, as Learning Rust With Entirely Too Many Linked Lists has shown, it's kind of a pain in the butt to implement some pretty basic data structures if you use Rust. Many/most "basic data structures" you actually need `unsafe` to implement. The fundamental issue is that the bookkeeping of how memory is used within each data structure relies on certain invariants being correctly preserved at all times (and these invariants can differ on a case-by-case basis), and this is not something that the compiler can certify right now. It would be nice if one could add explicit proofs of such and not need `unsafe` after all, but this is obviously a far-reaching goal at present - the first step towards this is a better model of "unsafe Rust", and this is obviously a work in progress at present.
Makes perfect sense to teach Rust instead of C in a CS degree. C might have been a good fit half a century ago, but a lot of language research has occurred since then, and Rust is right up there as one of the most forward languages that still gives you the low level control and concepts that you'd get in C. With C, you're basically setting the bar really low in the experience and perspectives department. C belongs in a museum.
The problem with Rust is that it's pretty hard to teach basics of, even though it's easier than C++ to do things in once you know how. It's a good second language, but I wouldn't teach it to complete newbies.
I'll just note that deferred type errors isn't like dynamic typing. [Here's a writeup on this Haskell feature](https://typesandkinds.wordpress.com/2016/01/22/haskell-as-a-gradually-typed-dynamic-language/). With deferred type errors, functions with type error would crash even for code paths that didn't trigger the type error. That's because Rust erases types at runtime, and can't distinguish between two values of different types that have the same bit pattern. So it's a feature useful mainly for running programs that aren't finished yet (and are expected to crash once they hit the bad parts), like `unimplemented!()`. Rust already has a solution for type-safe dynamic typing, [`Any` trait objects](https://doc.rust-lang.org/std/any/), which is like `Typeable` in the article I linked above. It tags the value with its type, so that you can distinguish values of different types [like this](https://doc.rust-lang.org/std/any/trait.Any.html#examples).
&gt; Statistically, girls are much less interested in gaming, and are therefore much less impressed by that approach. You mind citing your source for that?
There's so much baggage and so many problems with gender &amp; tech that examples using it are, at best, very distracting, and, more importantly, are very easy to be excluding/isolating. I'm sure there's a multitude of examples for people having different motivations for learning to code that don't touch such hot-button example. (Also, to reenforce the ease with which a casual example like this can exclude: in my experience, using ["female" as a noun instead of "woman"](http://jezebel.com/the-problem-with-calling-women-females-1683808274) makes many people uncomfortable.)
Even if you do all of this it would make for a rough time for beginning students, who are already trying to wrap their head around linked lists and trees and such. That's where garbage collected languages can shine. They handle all the ugly details for you and you can focus on the logic of a doing a sub-tree rotation rather than being forced to chase down memory errors.
propagating state is not that difficult, but what about animations? you shoul think bout it now cause it maybe harder to implement when u stabiloze your library
great that u r back at gui! 
I think F#, ML or OCaml would be a great stepping stone into Rust. We need to find better ways to teach Rust, for sure.
I view safety and correctness as separate things, maybe I shouldn't. I love Rust for the correctness and the incidental safety. I *also* love it for the safety. If safety sold itself, there are lots of other older languages that should be popular. We both understand this is a multi-faceted problem and it will require lots of different techniques to increase its adoption.
Learning rust! It's a lot of fun. (I'm coming from python mostly with a small bit of haskell.) I am absolutely *loving* the official rust book. It's probably the most well written intro to a programming language I've ever come across.
Hey, so just a heads up, I made a few modifications and got a big performance improvement. I also don't need accurate medians so I removed the branch to check if my deque is even length (also it's always even length in my implementation). The biggest improvement came from now creating a vector every time but instead using a stack array + not clearing it. A StackArray would work here too. I went from ~300ns to 95ns https://gist.github.com/anonymous/d26c6d048248c3e7a4fed9499c5e557e my particular use case allows me to always start with some set number of values, but the "don't create a new vec for every calculation" optimization should always be viable. The next step for me would be to take the last element and binary search for the position i can add it into to maintain sortedness, and then just do an insertion sort of that subslice.
I was fairly careful to not accuse you of doing anything bad, nor was I questioning the accuracy of the example. I'm sure it was accidental, but accidents still need to be called out. &gt; I used the term "males" to refer to "men", so I made everyone equally uncomfortable, if anything. Human language doesn't work like that. Like with examples for motivation for learning to code, some words have more history and baggage than others. However, I also wasn't trying to accuse you of doing something malicious, just pointing to how easy it is for things involving high-emotion topics to hit pain points (and maybe helping you and any readers not hit it next time). (Also, even supposing "males" makes people as nearly as uncomfortable, I'm not sure that "but at least it was inconsiderate towards two groups" is that good as a justification. ;) )
Thanks for the report. I went through the same trouble with GC, it is always nice to know that it is no only me.
You don't have to write in java for Android, but you will interact with java code unless you making a game or you willing to lose all of batteries included with SDK. Totally not worth it. Even writing a library in rust is bad idea generally. NDK in Android is an afterthought. 
&gt; Even if you do all of this What do you mean by "all of this"? If you mean "add proof-carrying code to Rust" (which again, I think is only feasible as a long-term goal) this will obviously require some changes to how the Data Structures course is taught. If you mean "just use `unsafe` as-is" this is basically equivalent to a C/C++ fallback and should pose no further hardship to students.
A big step forward! It'll make better docs and make writing code and short programs way more ergonomic! Can't wait to see it get implemented
&gt; I didn't mean to choose such a baggage-laden example, it's just one of the most natural examples to choose, as much as that may suck. I actually really like the example, it agrees with my experience too. Literally the extent of my complaint was the mentioning of gender, the example stands without mentioning it. I also want to be clear that I *really* don't mean to attack you, it's something a lot of people do unintentionally and I just happened to pick your comment to say something about it.
sol 90% of javascript 
Exactly. In some respects, all of the rules impede learning. 
This is a perfect example of what I was referring to with my reply. In terms of his comment anyways, it *doesn't matter* if that's true or not. Minecraft could have perfect gender balance, or an entirely female user base. His main point would still stand, a significant percentage of people aren't motivated by video games.
I think Rust is entirely suitable for an intro CS course. Although I probably would use a small subset of the language. 
yes/no
&gt; Such unsafe build would make safe Rust cause memory unsafety (instead of just panicking). .. sure, but my point is: *rust safety is an over-estimate*. There are safe programs that are not provably safe (on a line by line basis with current theory). Also sometimes, it is more useful to have something that 'sort of works' rather than something that doesn't even compile ('working code is more useful than any design document'). &gt; The nightmare scenario is, as such unsafe_release mode gain popularity, You've already got this, it's called C, C++ and it dominates.. and will continue to be used unless Rust can offer 100% improvement for *all* niches. An unsafe build would get more Rust out there. Unsafe users would still have safe subsets that push the community forward. I'm suggesting it would be clearly marked. You only get an unsafe build if you write --unsafe in your build script. Unsafe crates would be unusable for default safe users. &gt; think that a better solution to verbosity Wrapping everything in macros feels hacky. Software is malleable; I should be able to pick and choose the exact blend of features I want. I'm happy with many features in rust, but for the sake of a few dogmatic choices I have to stick with C++, or wait for this. https://www.youtube.com/watch?v=TH9VCN6UkyQ&amp;index=1&amp;list=PLmV5I2fxaiCKfxMBrNsU1kgKJXD3PkyxO he explains the conflict. we've got 3 dimensions.. performance, produtctivity, safety. C++ is performant but crippled in productivity for stupid reasons (header files and annoying suboptimal syntax choices). Rust gets safety, with a simple flag it could handle the 'productivity+performance' case that gamedev needs. He explains why he rejected rust. There's other problems based on Rust's focus on '8mloc' issues. There are sourcebases in the 100kloc range that don't have the exact same focus
During the final comment period, I left a comment about the weird/silly "exit 2 for failure" specified in the RFC, and a few comments agreed with me, but it looks like it was merged unchanged. :/
&gt; If my memory is correct, GHC is self-hosting and porting is accomplished by a "compile to C" mode meant only for GHC itself. Indeed. This sort of compilation is called unregisterised compilation (most commonly, however, it's called `-fvia-C`) and it's actually disabled in production compilers.
"Don't let programming interfere with your computer science education." (This is a slight variation on a quote from Mark Twain) I prefer introductory computer science courses to spend few weeks on assembly to help students understand how a program is executed at a very fundamental level. Then spend a month or more on C to understand how loops and other programming constructs translate into assembly, and how structures and other data types are laid out in memory. And finally, use C with dynamic memory allocation to illustrate how to manage memory, and the pitfalls that occur when it is done incorrectly. Only then can one appreciate the benefits of Rust. C is a better language for demonstrating how a computer works, how to manage memory, and what can go wrong when that's not done correctly. Using Rust would rob students of that education. Rust would be more suitable in intermediate to advance courses after students already understand the fundamentals.
yes
Okay, so I've taken your question as a chance to have a look and compare manually ported Rust code with the corrode equivalent. I'm picking an example function here. This is the original C function: http://codepad.org/BAZ1Cg5W This is the C function ported manually to Rust: https://gist.github.com/anonymous/680c80aa20a107a71f139a3b2a03055d This is the function ported to Rust with corrode: https://gist.github.com/anonymous/af6757cb35c21a7e67e634e1e2f552f7 I have picked an example where due to reliance on negative indices (which is legal in C) I haven't converted the pointer to a slice yet (usually its the first thing in a function that I do `slice::from_raw_parts` in the start so that later on I can just continue to use a slice). You need to know that celt uses macros as an abstraction layer to support fixed point math. For the floating point case, most of the macros are just the identity, or desugar to very simple things like multiplication or addition. While my initial focus is on floating point math, I want to provide support for fixed point math one day as well, so it makes sense for me to port the macros over to Rust and to use them instead of doing the expansion myself. Also, when porting manually, you'd have to remember what each of the macros mean each time, its easier to just copy them over. Looking at the corrode version, you can see that it has eliminated all macros. This is bad due to many reasons: First, I want to keep the fixed point math macros. Second, some macros generate unneccessary noise, like macros used for stack allocation. There is no dynamic stack support in Rust, and I have decided to go with heap allocation for now, and grep the source code for all occurences of heap allocation once Rust gets support, converting them over to stack allocations. No need for a macro. Further issues: * corrode seems to convert everything, including for loops, to `loop`. There is no need for iterators, it could at least have converted it to a for loop over an index. * corrode resolves all type aliases from the C codebase. I want most of the type aliases preserved as they are required for supporting fixed point math. (Bindgen does a better job here, it preserves them). * corrode has a different style than I do. Not even the official style. Of course you can't blame the author for it. * It translates `*Xptr++` to a very weird three line construct `*{let _old = Xptr; Xptr = Xptr.offset(1isize); _old}` which is obviously legal but very ugly to look at. * It preserves the forward declarations of C. This is very un-rusty. Yes, corrode openly admits of generating un-rusty code, and my initial stage of the rewrite does focus on a version of the source code close to C so I do accept un-rustiness in my code. But I accept it only to a certain extent, and I also want to support fixed point which the corrode version makes much harder to support. I'm familiar enough with C's semantics to understand all of the code, so corrode wouldn't even be useful to me to use as a base where I do a "clean" rewrite from, as it obviously makes more constructs less easy to understand (see the `*Xptr++` and `loop` issues above). Summarizing, I think I won't use Corrode. 
That does sound pretty weird - Rust already has an exit code for failure. I think this is the kind of feature that is going to see a lot of experimentation in tree before it ever lands on stable anyway, so I'm sure any weirdness will have a lot of time to shake out.
Thanks for the updates PingCAP &lt;3
RFCs usually get a bunch of finer details worked out during implementation, I would expect the exact exit code, the name of the trait, and whether or not it accepts `bool` in `OK` (my pet nit on the RFC) among other things to change in the several months before it's stabilized.
Small nit: Rust doesn't prevent race conditions, it prevents data races. So it's not actually clear how much Rust would help with race condition vulnerabilities in the abstract. With that said, i would probably bet that many of those race condition vulnerabilities also had data races, which means Rust might have been able to help prevent a lot of them. But we don't actually know without a deeper analysis.
Thanks for the writeup, Ralf. I like this approach a lot - the idea of every memory access being a lock is how I often think about it and explain it any way; and I've often wanted exactly this kind of instrumentation of Rust programs - for my purposes because I'm curious about the exact memory access patterns that Rust's reference scheme creates. I'm super excited for this strategy to be realized.
Thanks. :) I'm glad you like it! &gt; the idea of every memory access being a lock Do you mean "every memory location"?
the problem is: making abstractions requires *naming* , and in turn *searching for the right name by the user*, instead of writing the code. Sometimes writing a piece of code, and writing a test beside it is easier to do and even clearer. you can't do things easily in rust until the right 'names' for every possible pattern have been established. ( what would you call a combination of a dynamic array and the bounds of the contained elements? can you be sure it's the same name everyone else will use? will people even realise it already exists in your library and know to look for it?)
Cool stuff. Just be aware, in a practical sense, a modern ML library needs fundamental from-the-beginning-design-wise support for clustering and GPU compute to be worth using for training anything more than the most trivial application. Have a look at how the C++ backend for tensorflow is built; that kind of compute graph as a low level building block for distributing work is far more important than implementing particular types of layers. Honestly, I think the most exciting thing for rust would actually be being able to load a trained tensorflow graph and have it run in rust (ie. a trained model); that skips the need to solving the (very hard!) distributed GPU training problem, and lets you use real world models in rust. That would be super exciting~ ...but, this is cool too. :) Just saying... it's probably not terribly practical to try to implement the layers first and worry about how fast it is later. 
I'd expect it to default to exit code 1 with ways to override behavior
Yes.
Very excited for this, and the (eventual) end of sneaky doc examples. This issue trips up newcomers all the time.
So that version had a bug I think... either way, I have a second implementation that combines the insert + calculation phase (since in my use case they always go hand in hand). The new method insert_and_calculate is 12ns. https://gist.github.com/insanitybit/da3513f908c7193a459a7c60e5e492b6 anyways thats all ive got, I want to write a lot more tests since there's heavy use of unsafe, but 12ns is certainly fast enough.
This could, conceivably, be added to the stdlib, perhaps after iterating outside the stdlib in a crate with this and other things to improve ergonomics when dealing with unsafe code. edit: and perhaps `Index` and `IndexMut` should be amended to mark `a[x]` unsafe for some types, permitting raw pointers to implement indexing. But such macro would be a first step (like the `try!` -&gt; `?` saga) I think there's a case to be made for improved unsafe ergonomics in general: less cluttered code is easier to read and reason about. And I think this can be done gradually, with RFCs and/or helper crates.
When we're talking opinions, I'd like to represent the other one. The amount of ceremony C needs ("you need to do these three things correctly in order, because otherwise, it's UB and not _correct_") is really taxing to me. Rust has a lot of the implicit semantics of C programs (Who owns what? Who deallocates?) as explicit features. There is definitely more to Rust then to (simple) C, but Rust has a much higher ceiling and it is an ergonomic language. I find it much easier.
Take care: I train Rust professionally and I am boggled by the number of C programmers that - three days into a course that regularly says "this is done purely by static analysis" - are still claiming that all Rust has a garbage collector and all these features are not possible without runtime overhead. They literally believe that added safety can _only_ happen through runtime cost. Interestingly, I never had that problem with people coming from high-level languages, who have a much easier time groking a lot of concepts, also Ownership and Borrowing.
Agreed; it's really important.
I want this changed to 1 or something sensible based on the OS, such as 69.
&gt; ...because despite Haskell and OCaml (especially the latter) being touted as good tools for compiler writing... They are, I've written several (toy, admittedly) compilers in OCaml. A long time ago now, though. Part of the advantage is due to tooling, you have cool toys like `menhir` and such to help. Good non-academic examples would be, naturally, the OCaml and Haskell compilers. Though the accounts you get from the people working on them might be a little biased. ;-)
One reasonable objection is that, if you make something too easy, then laziness prevails, and you wind up with a lot of developers who are superficially productive, but because they lack the deep understanding necessary to write solid C, they end up reinventing square wheels. I don't mean to say that rust is actually prone to this kind of intellectual laziness creep (in fact I think things like borrowck hell are generally good for forcing developers to understand the ownership semantics of their code), but it is a reason why "it (appears to) make my life easier" isn't necessarily a good thing.
how to convert bin crate to library type?
The magic of a WM is registering for `SUBSTRUCTURE_NOTIFY` and `SUBSTRUCTURE_REDIRECT` events on the root window. This means that it'll get events/requests for any changes to the direct children of the root window (creation, resize, changed attributes, etc.), which allows the WM to manage them. Only one X connection can register for these events on the root window, so there can only be one WM at a time. (You can see hootwm [register in `setup()`](https://github.com/steinuil/hootwm/blob/56d721e4df6b7534ac0ce12af86e95545502ae9b/hootwm.c#L170)). I recently wrote a simple tiling WM in Rust using XCB, if it's helpful you can [view the code on GitHub](https://github.com/mjkillough/lanta). It's only 1,500 lines of code, but it's also missing useful features like full-screen mode for applications. I found [this C++ tutorial](https://seasonofcode.com/posts/how-x-window-managers-work-and-how-to-write-one-part-i.html) very useful, as it explains why you need to do things. I found [this Rust tutorial](http://kintaro.github.io/rust/window-manager-in-rust-01/) a little less useful, as it is using Xlib rather than XCB and didn't go into a huge amount of detail. However, the Rust tutorial might help if you're not familiar with C++. There's a few popular tiling WMs written in Rust which you can learn from. I read through the code for [wtftm](https://github.com/Kintaro/wtftw) when writing mine, but you can find more by searching this subreddit or Github. 
I gave a guest lecture in Konstanz for a course introducing basic operating systems and concurrency with Rust instead of C and it went very smoothly. They are continuing down that road and will also start teaching a pure Rust lecture. I can highly recommend getting hold of some the slides or speaking to some of the professors.
&gt; On the other hand, Google's Thread Safety Analysis successfully applied Rust-like system (linear type: although concept of linear type is not owned by Rust, Rust is by far the most prominent linear type language at the moment) to the problem of C++ thread safety, and I agree such endeavor is very valuable. And yet... skimming through the paper shows multiple things: a) it requires additional annotations outside of the language core - which is okay for a codebase such as googles, but hard if you program with a diverse set of dependencies. b) it doesn't fix everything, most notably, they mention that they fail to detect aliasing situations. It's an impressive achievement, I don't want to downplay that, but the difference is: Rust is far more rigorous in that department. In Rust, the concurrency features are core, so you don't need to root for adoption - people will have to interact with them immediately. I'm pretty sure that if Rust gets huge adoption, we will land in the same place at some point, and people will do other analysis passes over Rust finding gaps that were missed, but that will happen at a much higher level. 
Wouldn't it make sense to require `T: Display` and print it in case of success? It would simplify writing command line tools that just print one line.
Great post! I think the unsafecell stuff is incomplete -- accessing an unsafecell in an aliased mutable way does not cease to be UB just because of the unsafecell. Rather we guarantee that we won't do weird reorderings with it, and it is up to the programmer to ensure that it isn't accessed in an aliased mutable way. Except of course, we haven't yet defined exactly when this is UB or what the exact guarantees are. Given that the eventual goal is to define UB by means of a checker, delineating the boundaries of safe unsafecell use is important IMO. Of course, no need to do that immediately; I'm already super excited with the progress so far on this project :) Just saying that UnsafeCell isn't a done deal.
&gt; The library situation is the same for all new languages, and frankly isn't too bad. The tooling is much better C though: autoconf and automake are grim. I was trying to refer to the IDE situation with rust. It's definitely getting better, but it still feels clumsy compared to C (C++). &gt; The library situation is the same for all new languages, and frankly isn't too bad. I'm mostly doing graphics development (non real-time), and it's really bad there. None of the big libraries have nice bindings.
https://crates.io/crates/tiny-keccak could also work, you should audit both and pick the most satisfactory one.
Your Github avatar when rendered small looked like a Canadian flag to me, so I clicked it and sure enough you are in Canada, but the avatar was just an auto-generated icon that coincidentally looked like the flag :P
&gt; For example, Haskell allows you to write programs with incorrect types. You can compile, and more importantly, run such programs. Type checks still happen, just in runtime. This is available by -fdefer-type-errors option, and I think we should have it in Rust too, especially for borrow checks. That's not how that option works. It's not runtime type checks; the program gets fully type checked at compilation time, and terms that fail to type check are compiled to code that, when executed, throws a runtime error. The difference is a bit subtle, but perhaps this contrast helps: * In a true dynamically typed language you can write a function that will succeed for when called with some argument types but fail with others. * With `-fdefer-type-errors` you cannot do that. Whether a term will succeed or fail is predetermined at compilation time.
I certainly agree that the discussion is far from over; in fact this is meant to spark it. ;) However, I don't follow your concrete point here. We certainly guarantee that `Cell` is safe, and that is accessing the content in an aliased mutable way. So, from a memory model perspective, alias mutable state must be permitted on UnsafeCell. Of course, that doesn't mean that you can do anything you want, but that's not what I am proposing either. For example, if we imagine that `RefCell` would have a bug and hand out both a `Ref` and a `RefMut` -- that is still UB under my model, because safe code will validate the return values of `Ref::deref` and `RefMut::deref_mut` at their respective types, and thus assert that they are disjoint (assuming that the `T` in `RefCell&lt;T&gt;` does not itself contain an UnsafeCell again; that part would then be exempt from disjointness as usual). In other words, when you wrap a safe interface around UnsafeCell, you are still bound by the contract defined by this interface's type. Only those contract of UnsafeCell itself has a special exception, not the contract of other non-UnsafeCell-containing types that also appear in the interface. Does that resolve your concern, or were you talking about something else?
Do you mean there's no instant gratification, watching your program run, because you can't compile it? I agree, it is impeding learning. A mode, which moves all borrowck checks into runtime, could be interesting in this respect.
the issue is that you are mounting a directory into container and the container process doesn't have permissions to write into it; here is the upstream issue: https://github.com/TomasTomecek/rust-container/issues/9 I still haven't figured out what the best solution to this problem is
Oh! Yes, I see now. This didn't occur to me, thanks.
We want the effort in solving a problem to be commensurate with the difficulty of the problem, so I see no downside to easy problems being easy. We want to reduce the 'accidental complexity' as Fred Brooks calls it. Rust adds necessary complexity, assuming that you want the most efficient possible solution and also would prefer working with the compiler rather than wrestling with the debugger ;) E.g. Swift dodges the lifetime thing by ref-counting everything, and there's a performance cost to that simplification. 
Why this is not off-topic: "For those who want to take a closer look, the source code for [Exonum](https://github.com/exonum/exonum), written in Rust, is now available on GitHub."
That's a really thorough, well-written RFC!
If you use it on windows, let me know if you run into any problems. Some of them might not be fixable, but some of them might be. For example, if the paths thing is an issue, we could introduce an actual path type, along with functions that operate on paths, so that you can deal with them in recipes in a cross platform way.
I've got a little tool hanging around that does exactly this, and even formats the code properly with comments for inclusion. I'll try to publish it this week 
Oh boy that link brings back memories. Yeah, I never got around to finish that tutorial series.
It would also result in some things being printed out unexpectedly sometimes, which might be surprising.
It sounds to me like you're expecting corrode to do more than it was designed for. My idea of how it would be used was always that you'd use it to kickstart a port. So you could use cargo to build the whole project at once and didn't need to set up some Makefile that compiles both the C and the Rust code and links them together. And maybe it could also make it easier to rustify mid-sized things that span multiple files / modules more easily. But I do agree that if it actually makes the code less readable (by expanding macros everywhere, and using the complicated general conversion even for simple loops) it's probably not worth it.
Yes, excellent point. Webrender has this as an explicit concept ("dynamic properties") so it's definitely on the agenda.
&gt; Gender &gt; * 2% Non-Binary Gender Nice to see they're getting some recognition. :) &gt; Other Popular Games &gt; * Space Engineers &gt; * Kerbal Space Program &gt; * The Sims &gt; * **Dwarf Fortress** &gt; * Terraria I like this list.
&gt; So you could use cargo to build the whole project at once and didn't need to set up some Makefile that compiles both the C and the Rust code and links them together I don't actually use a Makefile, but only Cargo and the awesome gcc-rs crate. It all works like a charm, see [this commit](https://github.com/est31/werk/commit/713e22a68654d0a4581d2e52a16a6a00b4142185) for a description on how I did it. Yes, its maybe not really what cargo was designed for (for example "cargo test" is broken on the werk_test crate...), but it works for my purposes. I'm not saying that corrode is useless, in fact I'm quite glad it exists and that people work on it. Its a great idea.
&gt; I don't actually use a Makefile, but only Cargo and the awesome gcc-rs crate. Huh, that's pretty cool. Didn't know that was a thing. &gt; I'm not saying that corrode is useless I didn't get that impression before, all good \^\^
/u/ralfj could you maybe make a small post on validating `split_at_mut` and how the UB checker would prevent a bug in its implementation? Say it would be implemented like this: fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) { let len = self.len(); let ptr = self.as_mut_ptr(); unsafe { assert!(mid &lt;= len); (from_raw_parts_mut(ptr, len - mid), // BUG: should be "mid" instead of "len - mid" from_raw_parts_mut(ptr.offset(mid as isize), len - mid)) } } How would the checker catch the bug here?
We are planning on helping the Libz Blitz initiative and polish some Crates. One bonus for working on these issues: You can win RustFest Zürich tickets (incl. travel and accommodations)! So please join us in Cologne on 2nd August at 7pm!
Really? When would one unexpectedly return anything else than `()` or `Result&lt;(), E&gt;`?
The terrible, terrible history of computer security suggests that yes, we *do* need superheroes to do normal engineering (at least in C and similar systems which provide as few guard-rails)
two fast questions: 1) is gtk crossplatform 2) how to make window to be always displayed on top with gtk bindings
Heh, I follow both /r/Bitcoin and /r/Rust, so I was highly confused seeing this. :D
How do I single-step a test with mingw64 gdb on windows? It hits breakpoints but when I step the execution goes into another thread. I tried the &gt; set scheduler-locking step command but get the result &gt; Target 'native' cannot support this command. Can gdb be fixed or can threads be disabled in tests?
Runtime crashes in C aren't much better either though. If I were teaching novices to program I'd start off with a high level garbage collected language, get the basic concepts drummed in and at that point something like Rust would be fine I think.
You can (and many do) reexport (pub use xyz;) types from modules that are basically implementation details (and sometimes not even expose the modules to the user). So the idea is having the user of the library import the types, not the modules. That's why the constructors (::new) are methods, not free-standing functions.
Ah, I hadn't made the connection between the blog post and wtftw! :) Thanks a lot - you were certainly a great help for me.
Or at least superhero languages ;) 
yeah i use re-export all the time, but what I found myself wanting was to actually embrace the modules more: if those names exist anyway*, it seems nice to be able to leverage them. e.g. vecmath/matrix.rs ... "fn identity()-&gt;Matrix" .. elsewhere ```use .. matrix``` ; ```matrix::identity()``` rather than ```use... matrix::Matrix```; ```Matrix::identity()``` &gt;&gt; "That's why the constructors (::new) are methods" ... this might sound irrational.. but when it's truly a free function, I despise it less. See also the fact that we can actually make a named function equal to the type name (rusts syntax handles it fine). It might be because of the implied namespaceing along the way (e.g. vmath::matrix::Matrix::new() ... you still needed to use/export to get there even if you don't type that all out; we've said 'matrix' twice. but what i've done is made the name of the file more significant: it is no longer 'a generic file that i happened to stuff matrix in'... it really is *matrix*. the visibility rules seem to further imply something worth exploiting I guess I also like the implicit navigational hint: 'where is matrix::identity()?' .. 'in matrix.rs'. vs. where is the reported 'Matrix' ... is it in some local prelude along with all the other fundamental types of that library (or what)
I was speaking to a lecturer from my my old university once and she said they used Scheme because they wanted to teach computer science, not programming. The boy coders who come in speaking BASIC from an early age are equally disadvantaged ;) Rust fits this niche well I think. But not as first language - or we haven't found a way yet. An important point is that you can't understand memory safety on a gut level until you've _experienced_ unsafety. But for that, we have `unsafe`.
Yep, that's a good way to do it. You can have a look at the generated files by Djinni (https://github.com/dropbox/djinni) to see how the proxies can be implemented. Djinni uses C++ for the common code but it should give a good idea how the bridging works.
When one is a beginner, which is what this RFC is mostly aimed at. The more I think about it though, the more I do see where you're coming from. Does it actually result in less code though? A println! vs an implementation of Display is probably fewer lines.
Have you taken a look at Hack and Flow projects from FB? Also Reflex is currently written in OCaml
No, I haven't yet. Thanks for the references - I'll take a look at those projects as well! :-)
Well, for most types `Display` is implemented already. I'd expect that `T == String` most of the time.
I'm not sure it is always 1:1. Think of functions that trim whitespace for example. In C++, a trim would probably return a new string from an existing one whereas in Rust you could just return a slice. Anything that manipulates a buffer or string can experience a huge performance boost in Rust compared to C++ unless you forced equivalent behaviour by invoking to_string(), to_vec() on stuff. 
Very interesting. I'm having some trouble with the `Validating taking a reference` paragraph, maybe someone could help me out: * The first call to validate does not seem to acquire a write lock to `*z`. That's just a typo, right? * The suspension of the lock of `*z` seems to reference a lifetime `'z`. Should that be `'inner`? * After acquiring the lock to `*z_for_fun`, there's a release for `*x, *z_for_fun`. What's it doing there? As far as I understand it's not mentioned in the text either (the text mentions some release &amp; acquire that's not redundant, but I assume that refers to the suspense &amp; acquire, right?). Thanks for any pointers (pun disregarded) :) 
Yeah, I think Rust mainly appeals to the developers that actually have to deal with these low-level memory issues every day, and wish they could have free safety and abstractions on top of performance. Rust provides solutions to problems you won't realize you have if you aren't already proficient in another language with flaws in safety, performance and/or abstractions.
Rename `src/main.rs` to `src/lib.rs`. There's more detail on how to configure a package in [the manifest documentation](http://doc.crates.io/manifest.html#configuring-a-target).
1) mostly – it has Windows, MacOS, X and Wayland backends. 2) dunno, that's probably the window manager's choice?
GTK is *kind of* cross-platform, in that it does work on multiple platforms. The problem is that GTK 3 makes your application look like it's on GNOME on every platform. I can't give any better suggestions, though; the landscape of good cross-platform UI libraries for Rust at the moment is barren.
Test binaries now support a --test-threads argument to specify the number of threads used to run tests, and which acts the same as the RUST_TEST_THREADS environment variable You can control the number of threads the test runner will use by setting the `RUST_TEST_THREADS` environment variable. You can also use the `--test-threads` argument on the test binary itself. `cargo test -h` has some more information.
One benefit with Rust is that the compiler is doing part of the teaching, and you can amplify this with [clippy](https://github.com/Manishearth/rust-clippy).
Another rust newbie here. Very very impressed by the language, tooling and speed so far. I need to move a commercial project on an embedded system from scripts to a compiled language for various reasons. I played with Go and enjoyed it but I really like how easy is to wrap legacy code and rewrite as you go in Rust. 
[@afshinmeh's latest tweet](http://i.imgur.com/bD9vHlp.jpg) [@afshinmeh on Twitter](https://twitter.com/afshinmeh) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
My opinion on this is, basically, don't ever *ever* try to teach Rust as someone's first programming language. Because Rust will insist on that newbie doing everything correctly. That's great for production software, but not for the motivation of the already frustrated newbie. So, the first language should be something that allows you to write slightly broken code. Who cares, it *does* something. Sure, it can return a wrong answer, or crash in 30% of cases… but for a newbie, that's a great thing. If it doesn't even compile… However, I wouldn't try to teach C as the first language either. You can't really explain what a string is or C's IO without explaining pointers. So, for a person that can be reasonably expected to cope with C course, I think Rust course would be fine. They may miss the experience of broken C code, though ‒ and I think knowing what can go wrong is a large part of being a good programmer (compared with just an average one) and good motivating factor to learn Rust.
What if the same memory location is accessed via different types? For example, with `repr(C)` types, or types with known layout (such as references, pointers, primitives, etc.) may be (safely AFAIK) accessed through a byte slice. Does the unsafe code checker always keep track of accesses at byte granularity?
*(sees name)* ... \**sigh*\* Take your upvote and get out.
Does it only affect the display, or also the actual content of the buffer?
I think that you are looking for /r/playrust. This is the subreddit for a programming language named rust.
This is only fold method so this is only display.
Sweet, great! EDIT: I should have noticed the line count in the screenshot.
What happens if you try to edit the folded line?
If you're trying to write a normal Android application: forget about it, there's just no point. You need good system integration to write an app, primarily for building the UI and managing various components (Activities/Services/Data storage/etc). You'd be writing tons of Java/Kotlin glue code just to implement things in rust. You'd still have to have a java version of the Activity (and callbacks etc), which happens to map to the rust version - which would be very painful, and somewhat pointless. If you're writing a cross-platform app or a game, then rust might be a good choice, i.e. as long as you do all your rendering in rust and you don't care about normal Android UI components (in other words: just set up the app window in Java, hand over to rust to draw everything) - but you'd still need to write a lot of wrapper code to deal with app lifecycle management (and getting that right is hard). And it won't look and feel native - which is fine for a game, but not for any kind of productivity app. If you happen to have a complex data storage component (e.g. your own database or similar), then rust might be a good choice for implementing that part, along with JNI to access it from the main app code. Perhaps similar for networking components. But it's not a good default choice because of the complexity of juggling languages, and also a complex build system (compared to gradle just working for building Java and Kotlin). TL;DR: bad choice for a normal well-integrated Android app. Good choice for games and 3d things, potentially a good choice for complex components. Just use Kotlin or Java instead.
It should expand like any other fold. You can open it manually with`zR`.
I see your are well trained in the dark arts of Mac O'SeX.
I agree. In college, we learned Ada as first language. It was a really unpleasant experience, because the language seemed too strict and I was not understanding why all that boilerplate was actually useful.
Can confirm. Our Haskell stint in our programming languages was the absolute worst. None of the teaching assistants had a clue what was going on. The lecturer intentionally left an air of mysticism. We had no idea why everything was so crazy and why a `do .. print` type construct just wouldn't compile. Urgh. Computer shouts at you that you're doing something wrong but you just don't know what or why.
I was nodding along until I came upon this bit: &gt; Emacs provides functionality without applications. Rather than separate applications, functionality is all integrated into your Emacs instance. Amazingly, this works. Ever wanted to use the same snippet tool for writing C++ classes as well as emails? Eww! No! Never! Have you heard about that Unix motto some times, about doing one thing well so you're composable and can do more complicated things more easily?
This comment should not be downvoted. It's a straightforward comment on the state of the library, without any judgement of the author. Not to mention, accurate.
Not sure where to report this, but HTTPS is broken for that site on my browser. It complains about the domain being wrong ("github.com", not "spacemacs.org"), so I'm guessing it's a redirect to a "gh-pages" or something.
I'm pretty sure Go is as well. In the past it used a C-based compiler/linker, but those have been ported to Go, and I don't know what else (if anything) is left in C. To compile modern Go, you need to compile Go 1.4 with C then compile 1.5+ with Go.
Emacs is kind of like that as well. Instead of separate applications, they're separate scripts that compose. It makes a lot more sense to think of Emacs as an operating system (ViM users do this jokingly, but it makes sense here) and the individual scripts as applications. So Emacs is a relatively small runtime for an editor with a ton of elisp functions to give it default functionality, nearly (or literally?) all of which can be disabled/replaced/etc at runtime, even more-so than ViM. Emacs is a highly extensible text editor, and as such there exist extensions to do pretty much anything you can think of doing, from writing C++ to checking email.
&gt; pcj I always have to look this up since I don't follow that sub. For anyone else as /r/outoftheloop as me, it's /r/programmingcirclejerk.
thx why not Scala instead of Kotlin?
Preventing people from 'being lazy' (and specifically, borrowck or lifetime function signature hell) is also the real reason rust is unpopular. When you raise deliberate complexity to enable cool features or getting stuff done safely, you're alienating more and more of the 'average' population that has the perception they don't want to deal with this (misnomer) 'accidental' complexity. Same thing happened with generics and java actually with the 'explosion' of complexity if you wanted to build a truly 'professional' library (although, that language had the escape clause of casts, reflection and backwards compatibility for the 'old way' so the computer science superstars could do their libraries, and the peons could do theirs and none were too unhappy... except the absolutists). Pity the same strategy can't work for memory safety. One important property that (flawed) comparasion had is that generics library complexity was *mostly* on the library maintainer/creator side. As a user, almost all of the complexity could be avoided, and indeed, it made code look cleaner by removing casts.
Awesome! I'll try to update some of the issues listing things needed!