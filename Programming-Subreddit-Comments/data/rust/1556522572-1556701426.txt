I've just been getting into Rust recently, so I decided to start by making a linux info fetch tool. Just things like user, shell, terminal, packages, etc. I really like what I've made so far. [fetch](https://github.com/Phate6660/fetch) - Github Link Any criticism is very gladly accepted. I'd love to learn as much as possible from this little project, or any other I can join.
There are two problems with your idea: 1. Tracking *whether* something has been shared across threads must also be threadsafe, which means that implementing it at runtime can't outperform the algorithmically simpler option of just using `Arc`everywhere. 2. Tracking and inferring that purely at compile time is comparable to allowing type inference across function boundaries or allowing implicit conversions between numeric types. It's possible, but the language designers decided against it because it complicates the compiler (especially when you think about how crates may share `Rc`/`Arc` between each other, and is one more papercut when it comes to getting a new team member up to speed on how a codebase written in Rust functions.)
This looks amazing! Thanks =)
Since this is Xi related, would [https://github.com/xi-editor/druid](https://github.com/xi-editor/druid) make sense/be helpful?
Note: Indent multi-line code 4 spaces to render as a formatted block of code, instead of using single ticks around the whole thing.
I think it is thread local storage, not thread level storage.
Thank you. Fixed.
I don't know very much about Rust, sorry.
I know this is nitpicking, but match b { InputEvent::Keyboard(event) =&gt; match event { KeyEvent::Char('q') =&gt; break, _ =&gt; {} }, _ =&gt; {} } Why not simply match b { InputEvent::Keyboard(KeyEvent::Char('q')) =&gt; break, _ =&gt; {} } or even if let InputEvent::Keyboard(KeyEvent::Char('q')) = b { break; }
&gt; So the problem is Relying on us imagining what your code looks like is quite brittle. Please show a more meaningful example of what you are doing, ideally one that compiles on the playground.
&gt; But I get a seg fault when indexing into it. The behavior of creating a reference to uninitialized memory is undefined. So... if you are just indexing into it, note that `Index` returns references, so at that point all bets are off.
&gt; it makes it hard to know what is unreachable, and what is accidentally left in `map.get("my key").expect("we just inserted this entry")` is clearly not accidentally left in. I would say the distinction is a useful expect message. Even "unreachable" is fine, though more detail is better. I wouldn't use `unwrap()` unless the reason is completely obvious in the immediate context.
And put your deps in Cargo and wait for them to build....
Thank you good sir! Please share it as soon as you can!
How does that compare to your experience with the previous C++ code? Has Rust reduced your bug rate?
Here is an interesting article about this feature in cpp: http://snf.github.io/2019/02/13/shared-ptr-optimization/ Further if, and when, Rust gets higher kinded types, this problem could rather be solved by being generic over the reference counting pointer. The author of the binary application will always know whether or not a resource is shared across threads, hence they could specify the reference counter that fits their needs. That way single threaded applications wouldn't need to get the same overhead as multithread applications because the library *has* to use `Arc` to give the possibility of concurrency. See this article for a closer explanation: https://joshlf.com/post/2018/10/18/rust-higher-kinded-types-already/
Thanks for this, looking over atomics in the docs I didn't notice they also needed to be wrapped in an `Arc` in order to be shared. Thinking more about your questions... 1. If it's simpler to just use `Arc` everywhere in the event threading is needed, besides benchmarking, is there any way to make it clear to a new user how severe a trade off they are making? I've seen a few examples of people implementing a known solution to a problem but not knowing if its "right" because of associated costs involved. I was wondering how to communicate it is without saying it also "depends". 2. I'm not so sure I understand this part but it might be because of my `Rc/Arc` example. If I go back to the `Drop` trait, where users can choose to overload the `drop` function. My hope was anyone with access to the codebase could see that someone has manually overloaded `unsafe impl Sync for MyType { fn default....}` for some desired behaviour in threads. This is where they could chose to convert an `Rc` into an `Arc` but thats was just one use case that came to mind. Since `Sync` is normally automatically implemented, any custom behaviour would be obvious going over the code. 3. Another example of why I believed this could be possible was looking at the use of `Cow`. You have some dynamic behaviour which I thought would be interesting with threading. The key was understanding if we can even know when something has been moved into a thread but I agree it might be simpler just to make the choice and fully understand the costs associated with each type.
On my computer, the UI text is [completely broken and barely readable](https://screenshots.firefox.com/Sb9IaFE3vSveUpSo/null).
Thanks for the links, I had a feeling it wasn't a completely insane idea but its clear I may be out of my depth! I'll see what I can pick up from the articles.
There’s [this](https://www.youtube.com/watch?v=OemyLQbDTSk). I’m a bit ashame of it, but well, at least it exists. :D
&gt; What makes multi-threaded processing models unreliable?(??????) What I mean is that if a "processing model" is simply a list of sequential steps, executed in the same thread, it's in my opinion "more reliable" than a list of steps executed concurrently in several threads. And so the way to build reliable "multi-threaded processing models", if you will, is in my opinion by combining several "single threaded processing models", executing concurrently and communicating in async ways, as opposed to going for actual "multi-threaded processing models". &gt; My experience using Mutex for concurrency is that it causes bugs (eg:re-entrancy deadlocks) frequently enough that I naturally get pushed towards channels (or other push-pull style concurrency) in medium-sized projects anyway,leaving Mutex only for the things I know can be done atomically. I'm glad to hear that is your approach. I still see shared-state concurrency being used "quite often", although I can't say I have done any serious polling across projects.
Yeah. It seems easiest to just clone the `Option&lt;Rc&lt;_&gt;&gt;` given the definition they are using.
When it comes to intervals, most OS provides timers with both one-shot and interval modes. So these concerns could be delegated to underlying platforms. But as for this library, if I had to make interval it would be most likely represented by `Stream` since `timerfd` and `kqueue` requires polling approach. And personally I feel like approach that I took with `Timed` would suit better to Interval too. Start timer on initial poll, and then resume it on each expiration of previous one (if I'd implement it using `Oneshot`) Otherwise I'd go for platform dependent interval timers.
I'd *strongly* recommend starting with much smaller projects to get a feel for the language. One thing I love to do to get a feel for a language is to reimplement simple versions of some common command-line tools such as `cp` or `cat`. That really gives me an idea of CLI handling (I'd recommend `clap` or `structopt` for that) and for basic file IO, along with programming patterns in the language etc. Tackling a few of those will improve your confidence to tackle something larger, while helping you to really internalise some of the core aspects of programming day-to-day in Rust.
Working on a game boy synthisizer tutorial. It's slow going, lots of mathy stuff.
&gt; This felt more like a stream of consciousness and less like a tech article. Do you mean that there is a certain way to write a "tech article"?Should I ask my robot assistant to write a proper "tech article" next time, as opposed to a "stream of consciousness"? &gt; It talked more about JavaScript than it did Rust. The article mentions the processing model of the web event-loop, which is used to run Javascript, however it's often implemented in C++, and lately a few hopefuls have been trying to implement it in Rust too. Even outside of implementations of the web, it's a relevant model for concurrency to consider for any Rust project.
Merci bien!
very new to rust, looking to make a simple discord user script to automatically delete messages in a given server and channel. i haven't even gotten to the multithreading part of the rust book but regardless i'll go ahead and ask: what's everyone using for doing HTML requests?
What dogma? I simply highlight a problem, provide a potential solution, and finally mention that one shouldn't take it all too strictly...
What's the time for Xi to become an usable editor?
How can I print in color to the terminal? I naively tried using the ANSI escape codes I've been using in python (such as `\033[32m` for green) but it just printed out the escape code as text. It's only for making a help menu a little more readable, so it'd be preferable if I didn't need to rely on any external libraries.
TUIs are the best. If you could get to visualize github project board in terminal that'd be awesome!
Implementing [networking library](https://github.com/libredrop/libredrop-net/) for easy file exchange on LAN. The library is meant to be used for building Apple AirDrop like applications on all major platforms.
even then. It is only slower if you have more than 8 u64s if they have no excess padding and are aligned on a 64 byte boundary.
on some systems i8 is as fast as i32 because of alignment. Those are usually embedded systems and they literally can't load less than 32 bits at once &amp;#x200B; Then there is systems where there are no 8 or 16 bit instructions at all and they have to emulate 8/16 bit arithmetic with 32 bit instructions (example for that is arm, it only has 32 and 64 bit arithmetic, but not 8 and 16 bit)
I cannot get my unix domain sockets to work with tokio. Minimal example that reproduces my issue: use std::path::PathBuf; use std::io::Write; use futures::prelude::*; use tokio::io::read; use tokio::net::{UnixListener}; use tokio::prelude::*; fn main() { // Server let addr: PathBuf = "/tmp/test.sock".into(); if addr.exists() { std::fs::remove_file(&amp;addr).unwrap(); } let socket = UnixListener::bind(&amp;addr).unwrap(); println!("Listening on: {:?}", addr); let done = socket.incoming().for_each(move | socket | { let addr = addr.clone(); println!("got a new connection"); let mut buf = [0u8; 10]; // this block forever :( let result = read(socket, &amp;mut buf).wait(); match result { Ok((_, buf , count)) =&gt; println!("read {} bytes from {:?}: {:?}", count, addr, *buf), Err(e) =&gt; println!("error on {:?}: {}", addr, e), } Ok(()) }); // Client - we dont care about async here, so use std UnixStream let client = future::lazy(move || { use std::os::unix::net::UnixStream as StdUnixStream; let mut stream = StdUnixStream::connect("/tmp/test.sock").unwrap(); stream.write_all(b"hello").unwrap(); stream.flush().unwrap(); Ok(()) }); tokio::run(future::lazy(|| { // Spawn server tokio::spawn(done.map_err(|e| { println!("error: {:?}", e); })); // Spawn client tokio::spawn(client); Ok(()) })); } The call to read().wait() blocks forever. Does anyone have an idea what's going on?
I +1 this not because I agree with this statement as-is, but I agree that smileys / emoticons can be understood in many different (sometimes unintended) ways.
From what I've seen the [reqwest](https://docs.rs/reqwest/0.9.15/reqwest/) crate seems to be popular.
Oh, it's certainly is a very specific issue, but it is also a security one (considering how many chat systems tout themselves as "secure"). But it looks like that at least some Matrix(?) clients have thought hard about it and offer a solution (see parallel message).
While working on large project upfront is tempting, you need to recognise you need some level of foundation before you can move onto building anything concrete, which unfortunately means you need to do the boring part first - understanding and exercising. And obviously you can aim to exercise by doing projects, but aim low to begin with to allow yourself to grasp everything, similar to /u/dsilverstone's suggestion. So don't be afraid of going through the Rust book or other resources (very) slowly, it is much better to learn things in-depth and actually develop an understanding than to seem impressive and rush through things. Don't be afraid of exercising on simple stuff, asking things like "what if this happens, will borrow checker complain?" is very good practice, and is facilitated by things like the Rust playground. Just to give you a time frame, I normally spend a few months doing nothing but exercising via very small code files and reasoning with the theory behind when I learn a new programming language. This is typically 3-4 months of small and gradual progress. So unless you've been really struggling with Rust for more than 6 months or so, I wouldn't try to rush anything.
Is that a screenshot of a Matrix client ? Yes, it does - looks like that they have thought hard about this issue ! Thanks !
Have you clippy on it yet? It can provide a lot of suggestions that help you learn idiomayic style.
Making a better kubernetes client so it becomes easier to write operators with reflectors. [Current status](https://github.com/clux/operator-rs)
I used the same algorithm as yours, but I think this way of writing is better: [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=10c031b2fc3ead5ac47c6a3a40c2f491](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=10c031b2fc3ead5ac47c6a3a40c2f491)
Doing problems from [Project Euler](https://projecteuler.net) to practice clean code.
Try "\x1B[32m"
I ran into a situation where I have a `data: Option&lt;T&gt;`, and I want to get the value of a field of T, or use a default if the option is None. I thought `data.map_or(default, |data| data.field)` would do that elegantly, but it turns out `map_or` takes self, not &amp;self, so data gets moved (T is not Copy, but T.field is Copy). The solution I found is `data.as_ref().map_or(...)`. Is this idiomatic? Is there a better way? Could there be? [Running code on play](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f918ab2c8680608743dfc0715c6e1d8e)
There are some nice ideas there: thanks for sharing. You are definitely right that the cloning should be done in the match head, not the body: cleans things up a lot. I'm not sure about the switch to functional style: it makes it either easier or harder to read :-) . Anyway, fun to compare solutions!
That worked! How come it's \033 in python but \x1B in rust? Is this two ways of writing the same thing and if so what's different about them?
This is completely idiomatic and I am not aware of a better way
Thanks!
Just finished my Ludum Dare compo entry in Rust with Amethyst last night. Gameplay wise it didn't end up being very good, but I got it complete and I was a bit worried in the middle of day 2 I wouldn't get it done. Have a decent idea of nalgebra now too
Ah cool, I want to use something like this to send browser-to-browser [Open Sound Control](https://en.wikipedia.org/wiki/Open_Sound_Control) for music applications.
&gt;Also, don't use linked lists. Well, at least the Too many linked lists tutorial should be ok. The important thing is that you don't use linked lists in real projects.
There are tools that can be used to catch panics ([https://github.com/Technolution/rustig](https://github.com/Technolution/rustig) this, for example, but I remember seeing another one, with slightly different approach).
I'm working on a personal static site generator to learn and explore Rust. Right now its very simple (literally 2 commands), single threaded and uses a markdown to HTML generator crate to make the conversions. But I'm planning to work on it further and implement; Multi-threading, custom template support and a built in server to serve the files. Feel free to check it out and comment, I'm always looking to improve [Coilover](https://github.com/Ryhazerus/coilover).
I'm working on `v9`, a rewrite of `v11`. It's simpler &amp; more flexible. `v9::table!` is 200 lines of an almost-easy `macro_rules!`, compared to the *2000 line monster* of a procedural masquerade hack in `v11`. Mutations approximate a pure functional style. Locks are acquired in bulk, so there'll be less problems with `lock(A), lock(B)` deadlocking against `lock(B), lock(A)`. This week I'm working on indexing and data consistency. I suspect it won't be long until that's finished. Then it should be ready to refactor, test, document, &amp; publish. This is what usage looks like. Works on stable Rust: use v9::*; table! { pub struct ships { pub name: &amp;'static str, } } table! { pub struct sailors { pub name: &amp;'static str, pub ship: ships::Id, } } let universe = &amp;mut Universe::new(); ships::Marker::register(universe); sailors::Marker::register(universe); universe.kmap(|mut ships: ships::Write, mut sailors: sailors::Write| { let boaty_mcboatface = ships.push(ships::Row { name: "Boaty McBoatface", }); sailors.push(sailors::Row { name: "Leo", ship: boaty_mcboatface, }); }); universe.kmap(|ships: ships::List, names: ships::read::name| { for f in ships.removing(&amp;names) { f.remove(); } }); // At this point, Leo and the Boaty McBoatface should be RIP. // This is one thing I need to finish.
Depends what you're doing. If you're just moving an array of i8s around, then it will be faster. If you're doing math and possibly other operations on i8 variables, they will be slower than doing math on i32 variables.
33 OCT = 1B HEX = 27 DEC Personally I think interpreting numbers as octal when they start with a 0 is a huge misfeature. I'm glad that Rust doesn't.
Yeah, like in linux kernel
Using [https://docs.rs/crossbeam/0.7.1/crossbeam/utils/struct.CachePadded.html](https://docs.rs/crossbeam/0.7.1/crossbeam/utils/struct.CachePadded.html) could fix the potential false sharing issues.
on it, chief.
I've been dealing with a lot of \`ffi\` code recently and having to use types such as \`CString\`, \`raw::c\_char\` and \`CStr\`. I have an \`\_sys\` package and a typed package which is meant to be more rusty and safe and I'm struggling to work out what to expose these particular types as? Is it better etiquette to simply ignore the c types and have users pass in \`char\`, \`String\` and simply have \`Result\` all over the place which feels clunky or should I just expose them as is?
r/playrust is probably where you want to be
Same here. Except that when I tried to take a screenshot using the FF screenshot thing like you did, the "screenshot" turned out much more legible than what I see on my screen?
This could be HUGE for webapps and browser games. Bookmarked for when I have time to play with it...
`#[repr(C)]` makes the struct follow a specific layout. Casting an address to a struct pointer reinterprets the data at that location in memory as an instance of this struct.
That's pretty neat. Makes sense when you think of it, you basically move the start of the struct in memory to existing memory. Is that oversimplified explanation correct?
\&gt; Currently it is not possible to send raw UDP packets from a web app, ... this WebRTC based workarounds may provide a useful workaround for some applications and fast p2p game communication in particular, but it isn't a solution for the more general issue. it's a really limiting restriction, that we can not use UDP based network protocols from within WASM and are therefore unable to realize communication tasks, which are very common in usual desktop software and often make it impossible to communicate with existing legacy hardware (e.g. video camera remote control) without questionable/harmful browser extensions. i really see the security concerns related to this restrictions, but i don't think its a very satisfaying situation, that we still have no useful solutions to this issue, although many compromises (e.g. UDP receive only) and rejected standard requests have been developed over the last years to solve this lack of capabilities.
Its biggest problem is the lack of GATs.
You don't "move" the struct in memory, you _reinterpret_ the location in memory _as if_ it already contains an instance of your struct. Nothing is actually allocated, except what's already here.
I’m looking at connecting to various audio interfaces on different platforms (windows/OS X) - is there some stuff I should definitely know before looking at writing something basic and cross platform? I’m yet to start my first rust project, but I believe I’ve finally picked something that can be helpful.
ok, I understand, Thanks. Have a great day
Future::wait isn't meant to be used inside an eventloop as it will block the whole eventloop (there's a note about this in the docs for that method). You need to use future combinators, or async/await (though I think that requires a newer version of futures than tokio properly supports).
Finished splitting the shaderc-rs crate and approaching more sensible options. Switching E-Nguyen over to Ash from Vulkano to have more fine-grained control and rolling my convenience code into an Ashade workspace to publish as a standalone crate.
Implemented a tiny toy (or art?) program that converts images into 3D-printable objects that reflect the image in grayscale when viewed from the front with light coming mostly from behind and above your head. It's called [sloper](https://github.com/bzar/sloper).
Great progress Andy! Very encouraging results.
No, not yet. I took a look at [https://github.com/PyO3/pyo3](https://github.com/PyO3/pyo3) and it seems like it should be pretty easy to support.
I filed [https://issues.apache.org/jira/browse/ARROW-5234](https://issues.apache.org/jira/browse/ARROW-5234) for this feature request. Hopefully someone will pick it up.
[`uom`](https://github.com/iliekturtles/uom) (Units of measurement -- type-safe zero-cost dimensional analysis) [v0.22.2](https://github.com/iliekturtles/uom/releases/tag/v0.22.2) was released over the week (credit to [dunmatt](https://github.com/dunmatt/) and [nicodemus26](https://github.com/nicodemus26/)). Continued work on various pieces of `uom` this week. Looking for feedback if the following set of minus sign and number character and super script characters display properly in your browser and console. Win 10 and Mac work. Looking for feedback from Linux or Win 7 users. -⁻2²3³4⁴5⁵6⁶7⁷8⁸9⁹
Apparently playing around with next-gen graphics API's, with an eye towards someday using them for game dev tools. I'm not doing anything terribly sophisticated, but `gfx-hal` is quite solid so far (at least using the Vulkan backend), and `rendy` is a very nice set of tools atop it. `wgpu` was tempting because it's simpler is a prototype for the WebGPU standard, but if WebGPU ever becomes a thing then `gfx-hal` will end up having a backend for it anyway, so simply using `gfx-hal` seems better right now. `wgpu` is less stable/featureful, and while it would theoretically have fewer layers between it and the underlying API on web (someday), it would have more on the desktop, so it's a tradeoff either way. The experience has actually been very interesting. With Vulkan-era API's you have to think a lot harder about how things are organized, but by doing this you get much clearer designs. It's like the difference between using a dynamic language where everything's public and you can add new variables wherever you want, vs. using something like Rust or OCaml that forces you to be very specific about what depends on what. It takes a lot of thinking, but then I step back and look at my prototype and say "wow, this is going to be *so fast* by default..."
Awesome! Can you link us to it? :D
Rust itself can be very fast, but one big feature I'm missing for writing fast code would be emplacement new. Do you have some custom allocation patterns you could share with us?
We simply don't allocate on the critical path.
Ah, that makes sense. Thank you.
Try [practise questions](https://github.com/sn99/rust-practise-questions) or drive in directly to [issues](https://github.com/search?l=&amp;q=label%3Aeasy+language%3ARust+state%3Aopen&amp;type=Issues) with easy label
That's the objective, and GitLab's board too.
I started in rust less than a month ago, and am only just feeling comfortable in it in the past week. I started in ASM, then C, about 20y ago, then went Java, and have been RB/PHP/JS for the last 8y. In spite of there being no GC, and very demanding strict types, I generally find it a much easier language to read. It can feel like struggling a lot to get things to build, but rust is one of the few languages where I feel like managing to compile actually means something. So many of the compile errors I had to figure out early in my project were things I would've needed to fix in runtime if I built this on node. I'd have features that I'd struggle with for a while to compile, but then they actually ran perfectly the very first time they ran. Almost unheard of in most languages. So I'd say that learning how to debug compile errors is one of the most important parts of learning rust. Figuring out trait errors was the big step in going from tutorial-level problems to real things. Don't shy from embracing Result and Option. When I started, since these things were new to me, I'd often throw in unwraps everywhere and assume I'd fix it later. Understanding how to return errors or Nones is not something you can skip. Now that I'm used to it, I find it much easier to reason about than exceptions or nulls. What I struggled with the most was the lack of maturity of the language and ecosystem. There were a lot of places where I took time doing something that would likely be an SO answer or have whole articles written about it, if the language were out a bit longer. Rust may technically be 8y old, but a lot of what's really made it take off recently has only been out a year or two (or in the case of async/await, not even out yet). Definitely save yourself the trouble and avoid Futures right now if you can. They're easy to understand once you're comfortable with the language as a whole, but you need to learn all the fundamentals before they'll really make sense. It's hard to figure out one step at a time. Understanding how IntoFuture is implemented on Result, so the Result err can `into` to the error defined above in the chain of `.and_then`s if it implements a `From` for the earlier error , is not easy when you're still trying to learn the syntax. The discord channel's helped make up for the lack of maturity. Without it I probably would've dropped rust a couple weeks ago.
Yeah I've been using it and I definitely feel its better than the current RLS implementation. I still find myself waiting for cargo watch to finish so I can figure out if there are any compile time errors. I still eagerly update the rust-analyzer every time I start a rust development session. I'm hoping we can tighten that loop and get it to near instant feedback.
see also: https://doc.rust-lang.org/nomicon/other-reprs.html
LD Page: https://ldjam.com/events/ludum-dare/44/lifelong-quest
Ironically, this is what most Rust programmers seem to be using as nobody gave a fuck to fix rust-doc installation times on windows till this very day.
Linux, Firefox, OpenOffice (in the past, but even today 99% of the LibreOffice code base) have huge developer budgets (in paid man hours for the project). They are all developed for decades. From the 3, Linux is the only one with serious amount of volunteer contributions, around 10% at the moment.
thanks for the suggestions, I looked at creating my own Enum from [https://doc.rust-lang.org/rust-by-example/error/multiple\_error\_types/define\_error\_type.html](https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/define_error_type.html) but at the time didn't fully understand it, might need to go back to it.
first time I am hearing of it, will give it a try!
I'm not about to install discord just to keep up to date on Rust...
Implementing a command line tool with cargo like interface which will generate cmake files and build C/C++ projects for me
did a literal (yes actually literal) spit take when I opened the image. your setup + that image is :chefkiss:
I often see these OSS posts promote Zulip.. is that not proprietary? I like Zulip, but is there a meaningful difference in Zulip and Slack with respect to OSS?
From Wikipedia: &gt; Zulip was originally developed as proprietary software by a startup called Zulip, Inc., based in Cambridge, Massachusetts. [...] In September 2015, Dropbox open-sourced it under the Apache License.
This is something I'm quite bent out of shape over. I just had a good discussion about it _on_ said server. My end conclusion is, yeah, whatever, the WGs wanted to use Discord so that's what they're doing. It sucks, but as long as we can (at least try) to keep _community_ spaces in free and open platforms, we will probably be OK. Speaking of: we have #rust:matrix.org for all you Matrix people!
Bravo! I was trying to do this myself a few months ago but hit a wall with implementing SCTP over DTLS in Rust. I have a few projects that can make use of this :) getting UDP in the browser is huge.
Why not take some time and work through the [Advent of Code 2018](https://adventofcode.com/2018)? Once you've written code that works, you can contrast it with work made by seasoned Rust veterans, such as [BurntSushi](https://github.com/BurntSushi/advent-of-code).
I use it in the browser. If you need code help it's been great for me. The people monitoring it are super friendly and helpful.
Working on a web api using Actix, Diesel, and Juniper(GraphQL). Coming along surprisingly well!
It's not a property of the language but of the hardware. If you read a bit further, you'll find out you can't even write to the `calib`-field because the data it contains is read-only; it's set by the hardware itself.
Discord requires a 'real email' registration. I won't ever use it except in spectator mode for this reason, fuck 5-eyes.
When I first tried Rust, the first benchmark I made to compare performance with other languages was a naive prime number calculation like this one : fn main(){ let limit = 100_000; let mut primes = Vec::new(); 'main_loop: for dividend in 2..limit { for divisor in &amp;primes { if dividend % *divisor == 0 { continue 'main_loop; } } primes.push(dividend); } println!("{} primes number between 2 and {}", primes.len(), limit); } I was surprised that I was experiencing bad performance, far beyond C, envent worse than JavaScript. The problem was at this time, the default fallback for inference was not `i32` but `int` (that was fortunately renamed to `isize`). So on my 64 bit OS I was using 64 bit integers, while JavaScript use 32 bits for handling integers in internal and the `int` type on modern C++ compilers is always 32 bits, even on 64 bit systems. And when you make a lot of modulo, it makes a huge difference, even on x64. It convinced me that : - having a variable length `int` type was a huge mistake. - having a variable length type for default was not a good idea. - u32 was better for default All this was fortunately fixed.
Thanks.
Just use a free temporary email service. [https://temp-mail.org/en/](temp-mail should work) there are dozens more.
No it doesn't. These companies exist to make advertisers pay and they'll blacklist any temp email. Just try it.
Zulip is pretty awesome, we use it for a [FOSS community we have](https://www.codeshelter.co/) and I love its threaded model.
The problem is that we shouldn't have to do that. I guess it makes it easier to keep up with abuse and things like that, so we should get with the times. Semi-unrelatedly, I logged in to IRC last night for some help and the topic pointed me to Discord, and it really underscored how much more modern the experience is. I can see scrollback, edit my messages, paste code without spamming everyone, etc etc. IRC really has not aged very well.
Oh wow your right. What a bunch of dicks
Working on a basic SQL database (based on SQLite), but it's still in very early stages ([https://github.com/drgomesp/oxidb](https://github.com/drgomesp/oxidb)).
The experience is far better because the tools fit our needs better. Communication is about accessibility.
Sure, but the point is that they're not equivalent in performance as you might expect. The argument crops up frequently when talking about making signed integer overflow defined in c++ (which has performance implications for eg loop counters), but the correct solution is to use 64bit loop counters
That's awesome! `cdg` and `cdg_renderer` were the first crates I ever published (and, in fact, the first rust code I ever wrote). Your goal was the same as mine: have a karaoke machine on a raspberry pi that I could carry around to different events. I ended up getting stuck on making audio output work efficiently, but if you're interested in my specs for embedding karaoke data into OGG files, the rest of my code is [on github](https://github.com/thequux/qaraoke) I'm curious how the APIs for cdg and cdg_renderer worked out for you. They were designed to be convenient to use with OpenGL, so if there are pain points that I can improve, I'd definitely like to know.
You can click a button and have great voice chat. show images. Spoiler tags.
It actually is kind of upsetting, both from an ideological standpoint and even worse from an accessibility and privacy one. I think a main issue is that free software ideology is not really very popular anymore, *even among* the figurehead leaders of these open-source projects. Names such as "Richard Stallman", the GNU project, and the GNU public license are spoken about in a crusty, old-farty, and almost crackpot kind of way and not given respect. Overall I just don't get this move at all when so many open-source alternatives are available
This is not a matter of which is prettier or which has the cutesy emoji support for me. If it's not IRC (or something like IRC) I can't use it. Hearing that Rust and other projects are migrating to proprietary platforms that I am unable to use makes me incredibly frustrated, and I'm trying not to rage about it, but it is incredibly marginalising to tell me that the only supported means for synchronous real-time communications are going to use proprietary protocols with clients that are unsuitable for me, and because they're proprietary nothing can be done about it. Also, do we really need a quad core i7 and hundreds of megabytes of RAM to send strings of text to one another? Really? Do we?
It is pointless to worry about open source project relying on proprietary systems. There are tons of proprietary systems that are in use aside from Discord/Slack, and open source hasn't died from it still
The stable versions of Fedora have outdated crates because the normal update process is too cumbersome -- build the package, file an update, requested a buildroot override if it's needed in other builds, and finally after a few days push the update if no one found issues while it was in updates-testing. Repeat for each stable release (F28, F29, soon F30) and for every crate update. In Fedora Rawhide we only have to build the package to have it tagged for further builds, but even this is a lot of work to keep up with over 600 crates we have packaged. FTBFS (failed to build from source) on those outdated crates is most often cause by `#![deny(warnings)]` -- please don't do that! I do keep the Rust compiler package updated on stable Fedora, but this can introduce new warnings. It's not much of a problem as a crate dependency because of cap-lints, but these FTBFS come from (re)building crates directly.
From personal experience, my advice is to not worry about making the most efficient Rust code. Treating Rust more like Go - that is avoiding heavy/complicated use of Generics, using Rc/Arc frequently, Mutexes if you're dealing with shared models, and finally Cloning to get out of trouble. If you're having to define lifetimes you're probably over complicating life. This is by no means advice on writing proper Rust code, but I found it really helped my proficiency at writing many LOC in Rust. That, I believe, helps smooth the pointy bits and make Rust more approachable. You'll still want to avoid some classic patterns that Rust dislikes, but those will largely be edge cases in your LOC. You won't fight the borrow checker nearly as much, if at all. The above helped me go from starting out and trying to write large programs _(which I always tend to)_, focusing on patterns that I did not fully understand, to simply writing code in Rust. It also lets you approach concepts at your own pace. Once you get tired of cloning you'll want to see how you can simply share that struct instead. Then you'll get familiar with scenarios that are stupid easy with sharing, and scenarios where it becomes more complex. The more complex ones you can again avoid by cloning as needed. Super not production friendly advice, but I feel it's good learning steps. From personal experience _(as a Go programmer)_, Rust is _not_ an unfriendly or even difficult language if I simply thought of it as Go code. Rust is only as complex as you need it to be.
Sure but this is directly about community
Could you explain a little bit about why you choose to use exclusively libre software/protocols? When you say that you are unable to use proprietary software, is that from an ethical perspective, one of personal privacy/security, or something else? I'm not trying to be inflammatory, I'm genuinely curious.
That's because the GPL is extremely anti-business, and most large open source projects are spearheaded by businesses. One of the biggest reasons I like the rust community is that most projects are licensed under the MIT or Apache-2 licenses, and not the GPL.
Except for: 1) discord is really buggy and poorly made 2) full of stupid memes 3) constantly trying to up sell you 4) probably using all your data It’s not a great way to build/support a community that ostensibly wants to be professional one day.
I have a bit of a beef with the assertion that rewriting something 1:1 in Rust is not good engineering. If it's done to gain confidence in the code, it may well be the cheapest way.
I mean fair enough, and I agree and I always use permissive licenses. But this is just one small part of the ideology. The point is do the rust devs care about free software, privacy, and ideological purity? My point is that I feel like they have almost become dirty words now, along with RMS and GNU and GPL...crufty old words from an age gone by. And in that age they would have never switched to *Discord* as the main place for the community to converse!
Business is anti freedom, that's why it's not compatible. The solution is not to abandon freedom because it's not profitable... It's to rethink society to thrive on freedom, not on profit.
I've never signed up and have used a bunch of times
It's accessibility, /u/modulus is blind
Got it. Thanks!
&gt;It's to rethink society to thrive on freedom, not on profit. and I mean, it's not like we have much power in our physical society to make this change, but in this case we actually do hold the keys! and we can easily and should definitely choose a free alternative, rather than the proprietary profit making solution.
Not to mention Discord doesn't let you have multiple accounts. So if you don't want your gamer/personal profile to interact with your work, you don't have a choice. :( That part sucks because I don't want work to know what I'm doing on the games side of things... none of their business.
And it changes what? Community is not going to be affected by majority of it using proprietary tools. As with any tools, when a need arise, people will find alternative
Should a CachePadding be used to wrap the mutex? Or a linked list?
Because it directly excludes people who can't use Discord, e.g. people with accessibility issues. People who used to use the IRC completely fine will now be completely excluded from the community. Are you really okay with that? Even when we have the choice to not exclude them? There are obviously other reasons to not use proprietary tools for an open source project too
They don't? Well shit I guess I'm breaking the rules, I have 3 alts.
I agree with you but I see alternatives to the GPL license. BSD licence is a better license for many potential contributors since it does not force you to share your changes publicly but encourages you to do so. I also think the main reason for this development might be that many users are just used to use discord so they just keep using it for their open source activities as well. To the list if open source chat alternatives I would like to add wire https://github.com/wireapp
If people cannot use Discord then most likely they cannot use IRC too. AFAIK I don't remember #rust dying in IRC also? Though I no longer use it (and neither I use Discord for communication with community) &gt;accessibility issues. Is there any communication tool that aims to solve this problem? I don't even know IRC client that would solve these issue. So I don't think discord is alone with accessibility issues &gt;Are you really okay with that? Even when we have the choice to not exclude them? I'm one of these people who prefer IRC over Discord. And I don't feel excluded. I avoid big communities because they are source of spam rather than useful discussion in first place ;)
Hey folks, OP here. I'm really excited to announce the release of Smithy v0.0.3. This is a huge improvement in terms of usability. I'd encourage you to try it out, and let me know what you think!
The point of the Rust project is to further the Rust programming language, not to improve the user statistics for IRC or LibreOffice or whatever else. Ruling out superior tools because they are connected to a company only undermines the core purpose of the project and in the long run helps no one. Of course if or when a free/open source tool is the best option we should absolutely use it. To address your point of how projects can get off the ground, it comes down to attracting hobbyists and tinkerers and developer talent until they can built something that is competitive with commercial offerings. You can't just guilt others into using your software until you get critical mass. Also as a side note, Linux and Firefox aren't run on a shoestring budget: they both have operating revenues on the order of $100 million/year.
&gt; If people cannot use Discord then most likely they cannot use IRC too. Well /u/modulus in this thread is totally blind and says that they can only use IRC or similar solutions and would not be able to switch to Discord. I wouldn't have expected IRC to be much better either but it sounds like it would be. &gt;I'm one of these people who prefer IRC over Discord. And I don't feel excluded. I avoid big communities because they are source of spam rather than useful discussion in first place ;) Well fair enough, if you aren't going to engage the community in that way then of course you won't feel excluded. I won't really go on it either and yeah it'll probably be really spammy. Personally I think that's beside the point
Not gonna put words in anyone's mouth but I have always had the feeling that the Rust community cares more about building software than the politics of it. They've always seemed more pragmatic than anything to me.
But then it's not free anymore.
For every blind person that uses irc but can't use discord, there's easily a hundred people that wouldn't learn how to use irc but does know how to use discord. Your argument is rather terrible.
I hate to say "wait" but it sounds like you need const generics to land.
&gt;For every blind person that uses irc but can't use discord, there's easily a hundred people that wouldn't learn how to use irc but does know how to use discord. Your argument is rather terrible. I don't agree. Able people *can* learn to use IRC. Blind people *can't* use Discord. &gt;But proprietary chat solutions are arguably better than open source chat solutions in almost everything but freedom. Freedom is what really counts here
I agree, and that's a massive shame, because then things like this happen.
&gt; It's to rethink society to thrive on freedom, not on profit. Freedom doesn't put food on the table. I don't want to get into an ideological war, but my point is that businesses are ALWAYS going to be anti-gpl because it makes preserving IP rights very difficult, and IP rights drive profits.
I disagree, I have no problem with them choosing proprietary tools for their jobs. I don't care where you buy a hammer from if you're building a house. I did not realize discord had accessibility issues though and that is a major problem, and one I'm surprised that Mozilla didn't recognize it when they made their decision. Especially considered the focus on inclusion in the development process.
Druid is an experiment in cross-platform UI; this project is fairly closely tied to the original xi goal of providing fully native platform UI. :)
Yeah discord in basically every way is worse than other chat apps/protocols. I hate that it seems to have become the de-facto chat app.
&gt;I disagree, I have no problem with them choosing proprietary tools for their jobs. I don't care where you buy a hammer from if you're building a house. It depends for me. In most cases I don't care because often it is only for some small part of the development, e.g. some part of the build system or documentation, or whatever. In this case I care more because the quality of the open-source chat software is not as good as the proprietary ones, so I think it's important for rust to set the precedent. Additionally I think community engagement is very important and I do not think it's okay to exclude people who have privacy and freedom concerns. Recall from OP that the Discord terms of service has this in it: &gt;By uploading, distributing, transmitting or otherwise using Your Content with the Service, you grant to us a perpetual, nonexclusive, transferable, royalty-free, sublicensable, and worldwide license to use, host, reproduce, modify, adapt, publish, translate, create derivative works from, distribute, perform, and display Your Content in connection with operating and providing the Service. I think that's pretty strong, and you are giving over a lot of rights to Discord. I can't blame anyone for not wanting to hand that kind of control over. &gt;Especially considered the focus on inclusion in the development process. Yes actually this is directly against the code of conduct https://www.rust-lang.org/policies/code-of-conduct &gt;We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, **disability**, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.
I'm unable to type directly because of an RSI injury. I type using speech recognition and a lot of custom emacs code to go with it. One of the reasons I ended up using emacs was because the accessibility is in effect great -- since everything is treated as text, even "graphical" user interface elements -- if I use the emacs version of an "app" -- e.g. IRC, email, etc. all of my existing commands for manipulating text work seamlessly. My workplace adopted slack, which initially had XMPP support, but then they abruptly dropped it. Embrace extend extinguish. They provide a slack API now, but because it's particular to them fewer clients exist. To slack's credit the accessibility of their web client is not terrible because their interface elements are real links, which means plug-ins like the one I use for chrome that hover a letter over each link which I can then say to click the link work. However there is no guarantee they won't arbitrarily change their client in the future and this will stop working. Open source provide a little bit of a safety for the disabled, because there is a better chance of the community being responsive to them and they can possibly even provide patches to address their needs. The problems I see with IRC for new people is that getting set up is overly obfuscated, the login method is dated, and you have to know about server splits so you can ghost your nick. I think if the community put a little effort into making setup easy, e.g. having a web client people can access without installing anything, having a normal username password login screen, etc. IRC or maybe one of the new open source contenders could be fine. Sometimes it is even convenient to have the discussions you have automatically saved and logged and in the cloud so that you can see them from other devices. I end up regularly having to search my slack history for things my coworkers have said. But it would be nice if each user had their own encrypted copy on the server and the option of keeping their key client side. But I am less worried about this than I am Discord, Slack, etc. one day on a whim releasing an update that completely ruins my ability to use them.
You have to log out and log back in to each alt. So my phone has my personal one and my work machine has my work one, but when I get crap about not monitoring my Discord, I just have to give some BS about "network problems" instead of explaining (again) that they have a terrible chat system for our product. :)
So how do you get this right in C? If the problem is pointers to resources that have runtime-defined lifetime, doesn't all the same boilerplate to check if a thing is live before using it still apply?
In C, you have a `destroy` event handler, which typically unregisters all event listeners and releases resources.
The article quotes Discord's Terms of Service, to illustrate how, "These contracts... allow the companies behind these systems to use your data, including your chat logs, for whatever purposes they want." The excerpt sounds scary, but is completely standard and necessary. &gt; All of Your Content is your sole responsibility and the Company is not responsible for any material that you upload, post, or otherwise make available. By uploading, distributing, transmitting or otherwise using Your Content with the Service, you grant to us a perpetual, nonexclusive, transferable, royalty-free, sublicensable, and worldwide license to use, host, reproduce, modify, adapt, publish, translate, create derivative works from, distribute, perform, and display Your Content in connection with operating and providing the Service. Discord **must** have a clause like this, to allow them to host your content and deliver it to your intended recipients. They even specify they are only allowed to use your content "in connection with operating and providing the Service." For comparison, check out [Imgur's TOS](https://imgur.com/tos): &gt; With regard to any file or content you upload to the public portions of our site, you grant Imgur a non-exclusive, royalty-free, perpetual, irrevocable worldwide license (with sublicense and assignment rights) to use, to display online and in any present or future media, to create derivative works of, to allow downloads of, and/or distribute any such file or content. Or [Reddit's TOS](https://www.redditinc.com/policies/user-agreement), &gt; When Your Content is created with or submitted to the Services, you grant us a worldwide, royalty-free, perpetual, irrevocable, non-exclusive, transferable, and sublicensable license to use, copy, modify, adapt, prepare derivative works from, distribute, perform, and display Your Content and any name, username, voice, or likeness provided in connection with Your Content in all media formats and channels now known or later developed.
There is existing terminal-clients for discord. I don't know how good they are from the accessibility standpoint, but they're likely better than Discord's site.
&gt; Communication is about accessibility So why should we prefer Discord, a platform that has known accessibility issues, when compared to libre alternatives without those issues?
Do you write data structures for live? No? Then don't do that. &amp;#x200B; Instead take a subset of a practical project close to your skillsets. &amp;#x200B; For example, I implement ORMs in each language I learn. This is because my main job is work with databases. A ORM, even the most simple of all, cover a lot of ground, including take a taste of the ecosystem, work with transformations of data, etc. &amp;#x200B; Learning a language is one thing. Not add "learn how do X" too. That is 2 things and you will not know if your implementation is good. Instead if you already know how make ORMs, and have reference implementations, you problem is reduce to just learn a lang.
It's not necessarily and advertisement thing. I work in security, a good security practice is to block temp mails because they're overwhelmingly used by spammers/trolls/etc. Of course you're also blocking legit users, but you have no way of distinguishing the two at registration.
Author here. To echo `emersion_fr`'s response: in the destroy callback it's expected the compositor writer will clean up all their resource pointers manually, since after that callback they will be dangling. This manual memory management should be handled automatically in safe Rust as when you write unsafe code you have to uphold the basic contract that Rust's memory model enforces. If it's possible to dereference a dangling pointer in safe Rust code then it's not safe Rust code. So you either mark it unsafe (then why are you using Rust?) or you write a lot of memory management code to make that impossible (either statically, using lifetimes, or dynamically using checks. wlroots-rs did a combination of these).
Out of the suggested alternatives they are all offering either limited free usage, with a paid upgrade, or a worse featureset/UX than something like Discord. Discord is used since it's convenient. You have all servers in one place, no need to set up different accounts for each server either. You can search for servers and invite people to them easily. It's free, has apps for most devices, and is easy to use for the var majority of people. And since so many people use it, it has become one of the best place to chat with friends, causing kind of a Facebook effect where everyone uses it because everyone uses it. Until something comes up that is more **convenient** to use, then people will continue using Discord.
Author here. I'm not sure what you mean by "confidence" here, so I'm not sure how to respond to this. If you mean "this won't have any memory management bugs" then you're ignoring two things that I alluded to but didn't fully explore in this post (since I wanted to focus on wlroots-rs): the other bugs and the opportunity cost. Rewriting anything will introduce new bugs, basically guaranteed. As time goes on these bugs will be fixed and, given infinite time you would definitely have more confidence in a library written in Rust than a library written in C. If we had infinite time, and resources, then I would agree with you. However, when you rewrite a library there's a certain amount of opportunity cost that doesn't seem to often be factored in for some reason. In wlroots-rs case I [literally couldn't](http://way-cooler.org/blog/2019/01/09/year-of-wlroots.html) work on both Way Cooler and wlroots-rs because so much of time was forced to be dedicated to making the library good. If I instead opted to RiiR wlroots (or work on smithay) then the same problem happens: I'm shaving massive yaks for no reason other than I want to use Rust. This is also ignoring that now ecosystems can be split in two (not always, but sometimes). Should I contribute to `$c_library` or `$rust_rewrite`? What if I'm writing bindings in another language to this library, which one do I target? Both? Ultimately people can do what they want, this is just my opinion. It's no skin off my back if people RiiR. I'm just pointing this out because I perceive this as an inefficient way to work given the goal of wanting to make something. If your goals are different ("I want Rust to spread everywhere", for example), then you and I just have different goals (which is fine).
Zulip appears to be very limited for free use, and extremely expensive if you need more from it. &gt; Free: 10,000 messages of search history File storage up to 5 GB total
So what you are saying is that business is anti-freedom and we need to rethink society to not be like that? You said the same thing as me but in a disagreeing tone lol i dont get it...
FreeBSD is a free and open source Operating System under the BSD license. Big companies like Sony and Apple contribute to the public source although they are not forced to. They contribute just because it is easier to put your code in the official source code than to patch it into the code base each minor or major release. Their proprietary parts remain closed but the community and the project benefits from the work shared. Of couse this is not applicable to all kinds of software projects but it is an alternative to GPL.
Is there a better hosted version? I think for an OSS community I wouldn't trust _any_ "unlimited free tier" of a paid product. Not that you suggested we _should_ trust unlimited free, I'm not building a straw man. I just meant, when talking about Zulip, I put it in a similar vein as Mattermost and etc. Self hosted varieties. We are talking about a replacement for IRC after all. Wasn't Mozilla self hosting that as well?
You might find [`rodio`](https://github.com/tomaka/rodio) useful. It's my goto audio output crate.
&gt; Communication is about accessibility. You're absolutely right, and while Discord is more accessible to a certain subset of people, it's far less accessible to other groups. For instance, support for standard assistive technology is _terrible_ and, futhermore, they're not interested in making it better: https://www.reddit.com/r/discordapp/comments/69dsbt/a_community_closed_off_from_discord/ for instance, and https://support.discordapp.com/hc/en-us/community/posts/360032435152-Discord-Accessibility-for-blind-users , make it clear that they simply don't care. Furthermore, the client is buggy, battery-hungry, and attention-hogging. It's not more accessible to me than Matrix (via Fractal or Riot or Nheko or ...) or other systems. Just because something is easier for the subset of able-bodied users with fast computers doesn't mean it's "more accessible" in general.
The blog author specifically lists self-hosting as a requirement. I guess different priorities.
Try the excellent [`colored`](https://github.com/mackwic/colored) crate.
Interestingly, Spectrum chat is often overlooked when considering IRC alternatives. It's also open source, and I just created a room to give it a try: https://spectrum.chat/gfx
[If they wanted to do that they'd block the far right terrorists](https://slate.com/technology/2018/10/discord-safe-space-white-supremacists.html). I have nothing but scorn for a platform that puts me on a database for targeted ads while putting up a false front of 'being for my own good' and at the same time not shutting down nazi crap.
&gt; Discord is used since it's convenient. Is it convenient when it cuts my battery life in half? Is it convenient to people who use screen readers that can't read the text in the desktop version? Is it convenient when it doesn't load fonts correctly, or when there's a security vulnerability in Electron and they don't upgrade for months? There are usability issues in every communications product, but when that product is closed source, those issues are unsolvable except at the whim of the developer. What's so inconvenient about Riot, or Fractal, or any other high-quality Matrix client? Especially for an org like Mozilla, if they made a homeserver and offered people signups there it would be a _very_ slick experience, and people who already have a Matrix account somewhere could seamlessly interact.
It actually doesn't necessarily, it's just that 99% of discord servers enable email verification, probably to avoid spam. Just to clear that up.
Hey u/_Timidger_ , I wish you good luck and courage with this migration. Even though you'll be replacing a lot of your code, I completely understand your choice. From the years I've struggled with the C libwayland api to make wayland-rs as it now, I'm pretty well placed to understand how difficult the C&lt;-&gt;Rust mapping can be, especially in an environment like Wayland compositors, where a large part of the logic is handled via callbacks. And libwayland is definitely quite a small thing compared to wlroots! Still happy to see that you've kept wayland-rs for your userspace utilities, I hope we'll be able to continue collaborating to improve the Wayland+Rust story. :)
Presumably Mozilla would self-host, as they did with their IRC network.
But they're against the terms of service to use. Rust and Mozilla can't expect people to violate the ToS of the product they're asking us to use; that's ridiculous.
... Except for layman ease of use and feature factors. I wonder why it's become de-facto standard.
&gt; For every blind person that uses irc but can't use discord, there's easily a hundred people that wouldn't learn how to use irc but does know how to use discord. Your argument is rather terrible. Are you being serious? Do you not understand the difference between *can’t* and *wouldn’t*?
Doesn't cut my battery in half. Most people don't use screen readers (but of course it should be supported). What fonts are you talking about? Vulnerabilities in electron is the same for other electron based apps as well. People don't want to sign up to a bunch of different services. They want one that hosts all of their communities.
&gt; If people cannot use Discord then most likely they cannot use IRC too. You could, you know, listen to what disabled people have repeatedly said about the difference in accessibility between IRC and Discord, including in this very thread, instead of conjecturing about what they “likely” can and cannot do.
&gt; Doesn't cut my battery in half. Congratulations. I don't find Riot inconvenient. This is exactly my point: what is good for some people is not good for everyone, but with proprietary software, the bad stuff can't be changed. &gt; Vulnerabilities in electron is the same for other electron based apps as well. The problem is not _that_ Electron had a vuln, it's that any time there's an Electron issue the devs go "oh well, that's not a Discord issue it's an Electron issue" and then don't upgrade for months, up to one year. It's irresponsible, and as it's not free software, the community can't step in and solve the problem.
No shit, Sherlock.
I wish people would be a bit more understanding of the need for newer protocols. It's not about "pretty" or "cutsey" at all, it's about functionality like offline pings, multi-device sessions, and scrollback. Discord has problems but IRC is simply insufficient, and most free alternatives have their own major flaws. Various Rust teams have tried them and moved on because of unreliability, inability to scale, etc. It would be great if we could solve every problem... but stonewalling isn't the way to get there.
&gt; If it's simpler to just use Arc everywhere in the event threading is needed, besides benchmarking, is there any way to make it clear to a new user how severe a trade off they are making? I've seen a few examples of people implementing a known solution to a problem but not knowing if its "right" because of associated costs involved. I was wondering how to communicate it is without saying it also "depends". I'm not sure what you're asking. When I'm implementing things, I generally go with "pick/write an implementation of a suitable algorithm, taking any available benchmarks into account. Then optimize later if it proves to be necessary." What more do you think is necessary? ...or if it's a question of documentation, what conventions do you think should be adopted? &gt; I'm not so sure I understand this part but it might be because of my Rc/Arc example. I'm saying that choosing between a thread-safe and a non-threadsafe implementation isn't free. Either the programmer has to make the decision or the computer has to make the decision, and the computer either has to do it at runtime (which is simpler, but inherently imposes overhead that would eat away at the performance gained by having a version without thread-safety) or at compile time (which compilcates compilation when you've got the compiler automatically reconciling two different types across multiple compilation units). I also realize that I didn't clearly state something important. I compare `Rc` vs. `Arc` to requiring explicit conversions between integer sizes because, just like explicit conversion, it's partly there to prevent minor programmer mistakes in large codebases from causing performance regressions. (eg. It serves as an "are you sure you meant to add that one line which rendered all this carefully tuned code ineligible for `Rc`?")
/u/thequux, your crates were a life saver! I doubt I'd have been able to see this project through without building on top of your work. I haven't read through the entire repository yet, but I'd definitely be curious to get a high level of how everything is coming together and why you decided on multiplexing everything into OGG. The APIs were great! Any issues I had were purely on my end with just getting up to speed on Rust. It took me a while to figure out how to use the GenericImage trait on CdgInterpreter with the Image crate to get the RGBA u8 data out of it, but once I figured that out, it was super easy to feed that data into SDL2 (which I first used) and then finally SFML. BTW, it appears in newer versions of Image, copy_from takes an object of the new GenericImageView trait instead of GenericImage. I like that I can cycle through multiple sectors before copying the pixels out of CdgRenderer, which is useful when &gt;1 sector worth of time may have elapsed before rendering the next frame. Thanks again!
Matrix IRC bridging is horrifyingly unreliable. Up until recently Riot's UI was unusably slow. Rocket.Chat doesn't scale to the size of Mozilla or Rust without becoming really slow itself. These alternatives have been tried by various Rust teams and they've been abandoned for good reason. The upside to this is that *if* someone can actually provide a chat service that meets their needs, they can consider switching- it's not some decision passed down from on high, it's purely driven by the user's needs. The fact that we've ended up with something sub-optimal thus means that *the optimal thing doesn't exist.*
Yes, but the post mentions a lot of other projects as well, and to assume that everyone would self host is not realistic imo.
Because those libre alternatives have their own, worse, issues. Rust teams *tried* them and they failed. They were variously unreliable, too hard to moderate, slow, etc. There isn't an ideal option right now so we're stuck with the downsides of the ones that *actually work*.
&gt; The fact that we've ended up with something sub-optimal thus means that the optimal thing doesn't exist. I absolutely agree. But by choosing Discord, they are choosing a product that _does not care about its users_, and especially not open source projects who are unlikely to sell Nitro subscriptions or games. It's closed source, and thereby it _cannot improve_ without a business value to those improvements.
There's plenty of business reason to improve accessibility, power usage, whatever other complaints people have. And it's not like anybody has mandated a permanent move to Discord. It's what works today, but that doesn't stop anyone from improving the alternatives to the point that they also work. It's a choice between a) continuing to suffer with IRC or whatever else, preventing people from doing their *actual work*, or b) using something non-ideal to get work done *in the present*.
I'm not familiar with the project, but I wonder if using some kind of entity system (like in [Catherine West's keynote](https://www.youtube.com/watch?v=aKLntZcp27M)) could've helped. The idea there would be that all of these ephemeral C objects live in some sort of arena owned by the main loop, which hands out simple handles/tokens that refer to the objects it contains, like `u64` indexes or something like that. Every function that deals with these handles/tokens then takes some kind of argument like `a: &amp;mut GiantArenaThing`, which gets passed from above by the callback infrastructure. Functions use that arena argument to translate whatever tokens they've stashed into actual references to the C objects, potentially dealing with failure at that point if the objects have disappeared. Superficially this is similar to the closure approach described in the article. But the difference is that the `a` argument it allows Rust to reason about the lifetimes of references without using nested scopes. For example, I think the closure/scopes version makes it painful or impossible to do something like "take a `Vec` of tokens, dereference each one, and collect a `Vec` of references". But with entity tokens you can just do it the normal way, and Rust will understand that the `Vec` of references can't outlive `a`. Some possible pain points of this approach: - Any function that deals with tokens has to take that `a: &amp;mut GiantArenaThing` argument. Though if you already have some kind of global context that gets passed around everywhere, the two could be combined. - If you need `&amp;mut` references to the C objects, the arena would probably have to do some kind of `RefCell` style bookkeeping for each object, to check at runtime that you don't dereference the same token twice. That would add some more overhead.
This is really difficult, because cargo wants to control so much, aiui. It would break a lot of what's nice about meson.
These are memory-mapped registers from the target. It's nice to not have to use arch-specific assembly instructions for features like these.
Wow. This pretty much sums up my experience trying to make a wrapper around libdrm a while ago. In fact I think I ran into the same lifetime issue described with hotplugging outputs. Ended up starting a new library that wraps around the raw DRM API, but I understand why you wouldn't want to RIIR.
One way or another the connection string will have to be encoded at some point - nothing will prevent "malicious" user from running your program inside a debugger, setting a breakpoint just before your program acquires connection to the database and dumping the memory; this way one does not event have to try to decode your encrypted string - everything's in plain sight! Seems like we might have an X/Y problem here - what's your goal?
&gt; There's plenty of business reason to improve accessibility, power usage, whatever other complaints people have. And yet, they choose not to do so. This is not a hypothetical. I have been a reluctant Discord user for over 2 years now, and almost without fail, any time I have an issue it's brushed off, even when I _submit a patch_ that would fix it.
&gt; Tracking _whether_ something has been shared across threads must also be threadsafe, which means that implementing it purely at runtime can't outperform the algorithmically simpler option of just using `Arc` everywhere. I'm imagining this as a pair of new `Rc`/`Arc` pointer types wrapping a common inner allocation, where you would explicitly call a method to upgrade to the threadsafe `Arc` with `Send + Sync`. Extant `Rc` pointers would have to notice the upgrade and internally start using atomic count updates too. I think you can track this with a non-atomic `UnsafeCell&lt;bool&gt;`. When you're upgrading to threaded, you know you're currently *not* threaded, so a plain write is fine. Downgrading to non-threaded should probably require singular ownership (like `Arc::get_mut`), and then a plain write is also fine here. Then non-atomic reads are fine everywhere. So you add an extra bool condition -- hopefully branch-predicted well -- to avoid memory bus locks for atomic updates when not needed. This could be a real win on larger systems.
They have priorities and limited resources, of course, but *so do open source projects.* People have exactly the same complaints about free software, up to and including "I submitted a patch and they didn't accept it." I'm not trying to say it wouldn't be better to be open source, just that it won't magically solve everyone's problems.
Primarily, I want users to be able to input their UID and password directly and have these values stored in such a way that they can be retrieved and re-inserted into the connection string at a later date. So that they don't have to enter their UID and password every time they connect. &amp;#x200B; This program is going to be run on the user's computer, could I just save their credentials on their system somewhere and then read them in if the file already exist?
Author here. At first glance this looks like it would be sound (the exact value retrieved from the arena would have to be a reference). I'd have to think about it more to be sure, I probably won't. While it's very possible my design sucked, the point was it was such a drain to design it's no longer worth working on.
&gt;To avoid this callback hell, I defined two macros to help: one normal macro and a very complicated procedural macro. Here’s what the procedural macro looks like: You do realize that what you posted is actually do-notation? It even has the same expansion as Haskell's with nested bind calls rather than try our await's early returns.
Apparently there's a fix for the setting not working: https://github.com/rust-lang/rust/pull/58873
Yeah, saving credentials to a file seems like a good choice - you can additionally encrypt them with e.g. AES with a random passphrase (generated just once during the first program's run and also saved to a file). Doing more is IMO futile, since - like I said - after all everything's going to be decrypted anyway in the memory.
&gt; we should not, as libre software maintainers, force our users or contributors to use a proprietary system A lot of these discussions start from a place of "we _should not_ do XYZ," but I think that makes it hard to make progress. Both sides have specific concrete problems in mind, and I think it's important to start from a place that acknowledges that all the problems interact with each other and have tradeoffs. The article describes several reasonable benefits of free software, which are all true, but it doesn't discuss any benefits of non-free software: - Features. Sometimes proprietary software has more features, or adds new features faster. - Popularity. Sometimes proprietary tools are the most popular, and using popular tools in a project makes it easier to onboard new members or to integrate with other projects. No one is saying that those things have no value, so we have to be honest about how we're going to weigh them. If using proprietary chat means 10% more new user growth in the project, does that make it worth it? What if it means 100% more growth? How can we evaluate the growth or time savings impact of a tool after the fact, to see if we were right? Obviously there's no objective answer to these questions, but putting our opinions in those terms makes it much clearer that 1) both sides of this question have value and 2) neither side is going to be obviously right or wrong.
That makes sense. I'm going to give it a shot and see if it works.
I have a crate that provides both a library and a binary. Is there a way I can export a module such that it is only exposed to `main.rs` but isn't exported publicly with the rest of the library?
If you're hashing a string, that's a one-way function. You can't then reverse it when you want to use it to perform the connection. The plaintext would need to be kept somewhere. You might be interested in crates like [secstr](https://crates.io/crates/secstr), which provides a wrapper around key material to address certain types of disclosure. Depending on the architecture, I might be more concerned about the security of the connection between the app server and the database (e.g. TLS, firewall restrictions etc), and separation of roles and privilege grants within the database.
&gt; it won't magically solve everyone's problems. And I'm not saying it would "magically" do anything. What I _am_ saying is that using proprietary software dramatically limits the possibilities for solving any problems that do arise in exchange for fewer problems right now, and while that's a good short-term choice, it has the very real potential to turn into an extremely bad long-term one. For example, there are great Discord clients that solve most of the accessiblity and battery life issues I have. But it's against the ToS - in fact, a bannable offense - to use them.
So fix the problems with the open source alternatives and we'll be able to use them. Using Discord in the meantime is, as you say, a good short-term choice.
A Good Chat UX and OSS are **not mutually exclusive**. No one wants to do the engineering or on-going maintenance work. If Mozilla can't or won't do it, who will? &amp;#x200B; This is endemic of our industry and the state of open source right now. There are fifty dozen shitty Slack clones that have millions of dollars in VC funding, and we can't get a single god damn decently-polished federated chat client off the ground. Oh well, the poor, free laborers of open source are coming through anyway. Fractal and Nheko are decent native clients. This situation just makes me so sad. I don't fault Mozilla for leaving IRC but I don't know what I'll do if they pick Discord...
Well not from an accessibility standpoint. It’s UI is tiny and unscalable (and IMO extremely confusing), it uses a *fuckload* of bandwidth (which is a huge issue on mobile), and doesn’t work with screen readers (which is an issue for disabled members of the community). Overall, as a chat app, it’s a huge downgrade from others. (Including other proprietary apps)
Padding seems to me the right way to go.
&gt; While it's very possible my design sucked No matter what the final verdict is about the design, I want to be super duper clear that nothing here should be "your fault". When Rust makes it hard to find a good design, that's _Rust's fault_, and hopefully it's something we can improve on over time with new libraries or maybe new books.
https://github.com/xynxynxyn/terminal-discord refers to it as 'Note that the official Discord statement is only mentioning automated user-accounts, so this client and similar programs are in a grey zone since they do not actually automate usage or abuse the API.' but I am not against using something other than discord, I was just mentioning options if they are needed.
I don't know Meson particularly well, so I don't know what's nice about it compared to Cargo. But yes, Meson would have to share control with Cargo for the Rust code to get some of the nice Cargo things. It could build a Cargo.toml out of Meson config. The alternative of teaching Meson to do everything Cargo does seems hard. The alternative of getting Rust developers to write Meson config seems impossible. :-)
I have the same thoughts about the Qt bindings. Qt tries really hard to make C++ safe, so they have not only one solution, but two: smart pointers (mainly COW) and objects tree. There are a lot of magic in both of them (like `QObject::deleteLater()`). I have no idea how this can be translated into Rust.
I think it's to do with dependency management -- if I depend on r1 and r2, which each depend on r3, meson has no way of controlling that r3 is the same in both cases
&gt; Extant Rc pointers would have to notice the upgrade ... atomically, meaning that they would have to do all the work `Arc` has to do *plus* the `Rc`. So *a priori* we know that `Arc` alone is faster.
I explained why I thought the `bool` could be read non-atomically -- is there a hole in that?
Perhaps. It'd definitely need some prototyping and benchmarking. I'm still skeptical that it could be accomplished without adding a prohibitive amount of overhead.
&gt; tiny and unscalable I don't know about mobile but the desktop client can totally be scaled in the appearance options. You're right about screen readers but I can't personally attest about bandwidth. &gt; it’s a huge downgrade from others. Except for all the features and ease of use.
https://zulipchat.com/plans/ &gt; Yes! Zulip Cloud Standard is free for open source projects and affiliated institutions. We also offer steep discounts to non-profits, educational institutions, groups of friends, and in scenarios where most of the users are not paid employees (e.g. company support forums). Just contact sales@zulipchat.com and we’d be happy to discuss your situation!
&gt;I'm not sure what you're asking. When I'm implementing things, I generally go with "pick/write an implementation of a suitable algorithm, taking any available benchmarks into account. Then optimize later if it proves to be necessary." I guess what I'm trying to say is how to do you optimize an `Arc` when you don't have an alternative? It feels like you are forced to pay 100% of the cost using the type, when you may have a 10% need for it in your code base. That branch of code could in fact be behind a flag and not necessarily trigger at all. The `Arc` docs at the moment say "If you are not sharing reference-counted values between threads, consider using `Rc&lt;T&gt;` for lower overhead." Which feels problematic for the scenario I've described. &gt;I'm saying that choosing between a thread-safe and a non-threadsafe implementation isn't free. Either the programmer has to make the decision or the computer has to make the decision, and the computer either has to do it at runtime... Taking the decision out of the programmer's hands and letting the computer take care of it is pretty much what I'm suggesting. If you only have a choice between an `Rc` and `Arc`, which are both so widely used in the language, it feels like an implementation that could switch at runtime could take away some of the associated cost (with the right implementation).
&gt; completely standard and necessary. Not for IRC it isn't
I think a hammer is a poor analogy here. A hammer manufacturer can't terminate your hammer account and repossess your hammer at their sole discretion, or decide that they no longer support hammering rocks because there's a lot of overhead for that feature and geologists are a very small part of the userbase. Services (especially free ones hosted on someone else's infrastructure) are a very different beast than traditional physical tooling, and they do involve some politicking whenever the service provider has any kind of agenda (e.g. Discord needing to be profitable eventually). In the end I don't think these issues typically turn out to have very much practical import, but I do think it's important to consider the possibility that the service you depend on *might* pull the rug out from under you, especially since (in FOSS), you're probably not paying them anything.
Afiak mobile can’t. And it doesn’t seem to respect the UI scaling options on iOS/Android at a glance. I still don’t see what “features and ease of use” it offeres. It’s UX is incomprehensible, and every time I bring a new person into a discord channel there’s like 20 minutes of “wait how do I...?” That’s the opposite of ease of use. Discord took off because it’s Vent without needing to be self hosted. Not because it’s good in any way. (As previously discussed, it’s generally a huge regression over other apps)
Yeah, because your content is never stored on a server with IRC. Discord needs to store content, to display to users who were offline when it was originally sent.
&gt; So fix the problems with the open source alternatives and we'll be able to use them This would be fine, except that nobody from either Rust or Mozilla has committed to a plan like "if only project A had x, y, and z, then we could use A". We don't know what to do, because none of this has been done in the open.
 There is a good reason most browsers simply allow you to look at your passwords. I think generating a random passphrase is already dangerous by offering the illusion security.
https://www.reddit.com/r/discordapp/comments/8tq1ae/why_are_alternate_clients_banned_under_the_tos/
Happy to answer questions here regarding the project I'm working on (what I can share), hopefully when it comes to my modest Rust experience I can share something useful.
Hey, just in case you haven't run into it, wee-slack is a weechat plugin that provides most of slack. Could work for your case; I use it every day.
Also look at [serenity](https://github.com/serenity-rs/serenity) for a good Discord API wrapper. It's somewhat complicated since it manages the sharding etc. that Discord wants which then makes you deal with concurrency, etc. but it's better than having to do it yourself.
Cargo doesn't require that r1 and r2 depend on the same version of r3, so it's unlikely that Meson can make that requirement work in general in practice.
Or new tools, as the problems described in OP looks really similar to async/await to me. I.e. Solving callback hell with a bunch of futures self-referencing.
pub(crate) is probably what you want
If it's about multiple accounts [Ripcord](https://cancel.fm/ripcord/) (in beta and closed source) lets you have multiple accounts and is less resource intensive than the electron client.
Given all the talk about inclusivity from the Rust team I am very surprised that they seem to be ok with moving to a communication platform which makes it virtually impossible for people who use screen readers to participate. &gt; We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, **disability**, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.
I'm just saying what I remember from complaining to jussi about this in the past :P
First to get it out of the way, I don't really think everything should be written in Rust. That's for dogmatists &amp; I'm too old and have seen too much for that. I disagree with your assertion that rewriting must by definition introduce bugs, and you don't present a very strong case for that either. But even if that were the case, it might still be a good idea to rewrite a C program in Rust. Because, as you undoubtedly know, writing C is a defender's game, where one mistake can invoke UB, rendering your program exploitable. Sure, there's sanitizers and fuzzers, and if you write C, you should use them, but they can only search taken code paths, so you never know if there is any other UB perhaps lurking in an obscure, hard to reach code path. And funny enough, some people I spoke with who did this exercise of porting their code to Rust found that it improved their understanding of ownership &amp; lifetimes to the point where they could find bugs in the previous C solution, because borrowck explained their mistakes to them. So, I don't want to tell you what to do. Writing in C is probably a good choice given your constraints. However, to extrapolate that a rewrite will always be a bad idea is overgeneralizing your experience.
Popularity and features shouldn't play a big factor in this decision. The rust community is still growing a lot but there are already "old" community members which means that if we migrated to something popular but unaccessible for those, we actually lose more. We would lose expertise and mentors for the newer generation and show that someone could be excluded very soon. Now, if features meant more accessibility for everyone, extensibility, privacy and ease of use that would be a good point. However, popularity does not indicate feature completeness.
the point is that the generation of utility is fundamentally more important to society than freedom. needs for food, shelter, physical security, etc. outweigh the FOSS ideal of freedom by many orders of magnitude, and for most people, the vast majority of their material wants also outweigh that ideal. businesses fill the utility-generating role in most of the world, hence it's not reasonable to prioritize freedom over business. you can reframe the problem by saying it should be taken as a given that society should provide all utility anyone could ever need (such that there aren't business interests imposing on FOSS-freedom), but then you're looking at some form of communism. i don't say that as a value judgment about communism, but if the response to "rust is using a proprietary chat app" is "we'd better overthrow the government", i think we've jumped the shark. and maybe there's some middle ground for altering society to "thrive on freedom rather than profit" that doesn't involve revolution, but if so, it'd be great to hear a specific, reasonable suggestion about how to do that.
&gt;I disagree with your assertion that rewriting must by definition introduce bugs Writing code in general creates bugs. Rust is not immune to bugs: https://github.com/jwilm/alacritty/issues?q=is%3Aopen+is%3Aissue+label%3A%22B+-+bug%22 https://github.com/gfx-rs/gfx/issues?q=is%3Aopen+is%3Aissue+label%3A%22type%3A+bug%22 https://github.com/BurntSushi/ripgrep/issues?q=is%3Aopen+is%3Aissue+label%3Abug I could go on. Maintaining existing code does not create new bugs.
It's been written about extensively. For example: https://yakshav.es/from-the-rider-down/
Of course, but rust isn't a business is it?
That works within the library, but seems to break down when I try to access it from `main.rs` for the binary.
I don't think that's jumping the shark. It's understanding why things are the way they are, the FOSS problem is just another symptom. And you said yourself there is no middle ground. This society will always be based in profit and representative democracy. There are a bunch of things incompatible or that just can't survive in that setup.
Not an IP router, but a "hash router" for a browser in WASM.
Do you have any specific examples?
&gt; That being said, I do still believe that Matrix show the most potential for the next cool chat system if they can solve the problem of not only potentially providing many high-quality clients, but also practically. But that’s not their mission. I fear we’ll end up with a lot of nice crypto, but not many good clients. But their current overemphasis of technical subjects over social interactions feels like a bike build for spec, not for riders. I currently run four different Matrix clients (just to try them out) and they're _all_ good, in many ways better than Discord. Whatever, they've obviously thought it through and I hope they have a better experience with the platform than I did. This is the death of any hope I had of contributing to the project anymore, though, because I cannot stand Discord.
Well, not to be too on the nose, but unsafe rust is better than C in every other way. There are plenty of reasons to use rust even if every function you write is marked unsafe.
Hi, author here ! Keeping the [promise I made](https://www.reddit.com/r/rust/comments/bhu2qq/is_there_a_good_rust_file_indexer_similar_to/elwhag5/) to /u/free_are_we a few days ago, I'm publishing my code today. The code reflects my current Rust level of literacy. I'd be very glad to take advice about it. Here's an excerpt of the "Contributing" section of the README: There are a number of areas you might want to consider contributing to: - The most needed feature is the colored printout of pattern matches. - Lolcate is not yet useable as a library. - I'm not satisfied with the ignores rules being kept in a separate configuration file. - Testing. I'd be very interested in advice on existing code I could reuse / take advantage of in order to provide Lolcate with a complete testing bench. - Backend strategy. Lolcate currently stores its data as a lz4-compressed list of path names, and recreates it each time `lolcate --update` is run. It's as simple as you can get. Alghough it works well enough to my taste, I'd be glad to consider alternatives. Here's an excerpt
On topic 2, when you describe your lifecycle with the borrow checker, I think you want step 2 to be almost **lose** it, not almost **loose** it. Unless I'm just not reading it correctly.
I get what you're saying but I hate mincing words over an analogy. The point was that arguing over what tools people use is almost literally bikeshedding. When it comes to chat apps, it's just a public forum with quicker response times than a GitHub issue thread. So long as chat logs are preserved and backed up outside the app I don't see any issues with it being proprietary. Making money off IP isn't a sin, it's how all of us make a living.
For what it's worth there are still plenty of contributors that don't use any form of chat, sticking to the forums and GitHub (...notably also non-free...).
I think the documentation and the full set of features are great! Can't wait to test it out for myself.
The license looks fairly standard for any service that exchanges IP. IANAL tho and it may be unenforceable.It just means if you share something on a public forum you give a right to Discord to use it in their service. The only reason that you don't see licenses like that in community/OSS projects is because they haven't hired lawyers who told them what happens when you don't. Any chat client should have something similar.
&gt; For what it's worth there are still plenty of contributors that don't use any form of chat, sticking to the forums Absolutely. The Rust user's forum is great, and indeed the use of a centralized tracker for issues, RFCs, etc that is async in nature is great. &gt; GitHub (...notably also non-free...). And if I thought for one second that the project would be able to move to a free version control, issue tracking, etc platform I would be making a huge ruckus about it. I use my own Gitea server as much as possible. In fact, the lock-in with GitHub is so severe that I suspect few even considered using anything else. **This is the situation I wish to avoid with Discord.**
I think the OP's analysis and cherry-picking of that clause is almost entirely pointless fearmongering. 'perpetual', 'nonexclusive', 'royalty-free', 'sublicensable' and 'worldwide' license to 'use', 'host', 'reproduce', 'distribute', 'publish' 'perform' and 'display' are all quite innocuous. That leaves: - 'transferable': Covers their bases if they get bought out, for example. - 'translate': Gives them the freedom to add e.g. automatic translation in future. - 'create derivative works from': cover's their bases. Even converting from markdown into html in my eyes probably counts as creating a derivative work. Also, note the `in connection with operating and providing the Service`, i.e. this only allows them to do those things to operate the service, not outside of that. IA (very much) NAL, this is just my interpretation. I'm not saying that discord doesn't have its problems, especially if it isn't accessible.
&gt; I guess what I'm trying to say is how to do you optimize an Arc when you don't have an alternative? It feels like you are forced to pay 100% of the cost using the type, when you may have a 10% need for it in your code base. That branch of code could in fact be behind a flag and not necessarily trigger at all. I haven't needed to get much experience with conditional compilation, but this seems to work: **Cargo.toml:** [package] name = "rust_test" version = "0.1.0" authors = ["..."] edition = "2018" [features] arc = [] **main.rs:** #[cfg(not(arc))] use std::rc::Rc; #[cfg(not(arc))] type MyRc = Rc&lt;i32&gt;; #[cfg(arc)] use std::sync::Arc; #[cfg(arc)] type MyRc = Arc&lt;i32&gt;; fn main() { let i = MyRc::new(50); println!("Hello, {}", i); } &gt; Taking the decision out of the programmer's hands and letting the computer take care of it is pretty much what I'm suggesting. If you only have a choice between an Rc and Arc, which are both so widely used in the language, it feels like an implementation that could switch at runtime could take away some of the associated cost (with the right implementation). Except that `Arc` is already optimized to be quite lightweight and the bookkeeping involved in tracking and switching at runtime isn't free. That's what I'm trying to say. There are many situations in programming where ideas haven't panned out because they overestimated the cost of the existing approach and underestimated the cost of their replacement.
Matrix is much better
For one, it doesn’t work with screen readers. That’s *huge*. The others all pale in comparison to that. Some examples are: it’s very data heavy / slow. Notifications often don’t work on mobile, or if they do they take you to the wrong chat, it *destroys* battery life compared to its competitors, did I mention it’s slow?
FOSS/Tech stack I agree. But does Matrix support threading? Threading is _really_ great imo, and unfortunately Zulip is the only one I've seen even try it. Even Slack has "threading", but half measures don't seem to work properly with threading, because Slack's implementation is just terrible in my experience.
I made it ! See https://www.reddit.com/r/rust/comments/bitdm6/lolcate_a_comically_fast_way_of_indexing_and/
&gt; you can reframe the problem by saying it should be taken as a given that society should provide all utility anyone could ever need (such that there aren't business interests imposing on FOSS-freedom), but then you're looking at some form of communism. This is why I said I didn't want to get into an ideological war - thanks for putting into words what I couldn't find a way to say reasonably :)
I don’t care if discord needs those rights to function. We are comparing to IRC which *doesn’t* need them. I already think that’s enough of a reason not to switch to Discord specifically!
I think it would be up to the client to add that feature, so I would bet anything it will exist very soon or does exist on a less popular client
You can't just do that. Rust strings are not null-terminated, for one. Use `CString::new` to create a C-compatible string pointer.
After going through the entire readme I'm still not sure how it compares to mlocate, so I cannot make an educated decision to migrate to it.
I need some serious help lads. Been really struggling just getting started with this game. I've watched multiple different tutorial videos, that do cover basic aspects, but it seems like most guides are strictly aimed at covering a ton of beginner and intermediate aspects of the game and doesn't fine tune the game for EXTREME BEGINNERS. I want to see more in depth look into map selection, because I've landed in multiple spots that have ZERO resources and even a very little amount of trees around me. I've spent 15 minutes walking around areas to find no stone, and a bare minimum amount of trees. I try and get a spear but don't know how to get a sleeping bag which seems important and with a limited amount of trees around me, I can't get wood quick enough without someone killing me. &amp;#x200B; I've even started joining low-pop games and am still getting killed by someone with a bow or by someone hiding around with guns. It's frustrating because I just want to get a small base going and start getting some decent shit but I don't play with anybody. Can someone direct me to some videos where guys are posting FULL VIDEO gameplay, not just clips of things here and there of how to progress in the very beginning? Because I can't seem to find any, or at least find anything of relevance from within a 6-month period. I really love the aspects of this game and want to get going but just seem to be at a loss.
Personally I find Discord's UI extremely straightforward *and* extremely similar to all the other chat apps. I took a look at a bunch of Matrix/IRC clients recently due to this debate and they're *all* the same give or take. Heck Riot might as well be a counterfeit ripoff now. As for features, comparing to others: 1. Quite flexible but easy role permission system. 1. Discord search is top of its class 1. Code blocks with syntax highlighting, and extremely comfortable *typing* of those code blocks with syntax highlighting. 1. Message editing 1. Handles giant servers without breaking a sweat. 1. Excellent voice chat. Video calls are sweet too. 1. File upload 1. Outside of "electron is bloat" it's extremely responsive and snappy. 1. Reactions are cool 1. Probably a lot more I've missed Nothing quite ticks all the *chat* features of Discord. Sure having client competition and being open source but your average end user couldn't give a crap about that.
Maintaining existing code involves writing more code; if it doesn’t, that’s not maintenance, that’s abandonment.
You clearly haven’t been reading the rebuttles all throughout this thread. I don’t care if it’s open source or not. It’s slow, bloated/buggy, and inaccessible to disabled users. It’s a regression.
Good question. I'm sure it's faster, but I never did any precise benchmarks. Thing is, I stopped using mlocate years ago after writing a prototype in bash using lzop and ripgrep. The prototype ended up working so well, I've used it since. So, would a benchmark be useful for you ? Could you please elaborate a bit on which additional criteria you'd like to see Lolcate compared with mlocate ?
This is a nice article. Matches pretty much my experience. Thanks for sharing.
You are looking for /r/playrust &amp;#x200B; This is a subreddit about the Rust programming language.
This is an example of an annoyance I have frequently with Rust: it makes inefficiency in memory management obvious and unergonomic. Window managers aren't count-every-clock-cycle performance critical. Reference counted handles would probably have been fine, but Rust goes it of its way to make developers feel like runtime memory management is slow and bad (e.g. you frequently have to .clone() to pass an Rc or Arc). I'm almost tempted to build Rust++ that silently clones and an alternate stdlib for it that uses refcounts for everything. I'll get on that right after I build Go++ with exactly C++ style templates.
They mostly relate to missing documentation. I will try to send a patch next time something comes up.
&gt; (This naming desperately needs improvement.) what does `smd` stand for? (I couldn't find it in the article, but it's possible I missed it). generally "inner" is a naming convention for things that are in some interior context, "owned" is a convention for something that owns its objects, and "ref" is a convention for something that borrows (owned vs. ref are generally used in cases where there is a need to distinguish two otherwise identical structs/functions/etc.) I don't think "move" is informative here, if for no other reason than it's not typically used in names.
from my experience, rms has spent the last 30 years being a gross creep to women and complaining when people say "linux" and not "gnu/linux". why should i respect him?
Is that all he’s done? 🤔
Hey u/_Timidger_, I hope your migration goes okay, and I'm sorry that you've had so much difficulty wrapping wlroots, I completely understand :( I know you know this already, but I have some experience binding extremely unsafe C libraries to Rust and I know how much of an utter slog it can be. Thank you for your effort trying to wrap wlroots, even if it didn't end up working out! I'm going to share some thoughts that I've been meaning to write down about the situation with rlua and Lua, which I think are parallel to the issues you've been having. Now, please don't take this to mean that I think your situation mirrors mine completely, I'm sure that wlroots provides its own unique challenges and reasoning behind its design, and I can't really speak about wlroots in any detail and I don't know the details of what you had to go through. What I CAN speak in detail about is Lua, and I have a lot to say about it, but I think I might have taken a different lesson away than you did. This is all a bit of a spicy take, but it's been a long time coming: Lua's C API is absolutely awful and basically nobody uses it safely. Every project I've ever seen (every!) that has used Lua has given their project an avenue to memory unsafety via Lua scripts. Every (every!) Lua bindings system I have ever seen has been memory unsafe. I have spent at this point *years* thinking about how to protect people from the face of Cthulhu that is the Lua C API, and I've come to the conclusion that it is was... I guess useful but possibly misguided effort. So, let me back up what I'm saying a bit for the benefit of other people reading (I know _Timidger_ knows this already). Very *very* briefly, Lua's C API is a hot mess of unsafety and requires deep thought for almost every possible action, and the consequences of misuse are almost always memory unsafety. Let's make a short list: * Lua has a pretty clever stack API which protects users of it from needing to uphold GC invariants. By default, there is a (defined in a C configuration header, so it can be *different* per library build) constant amount of stack space available. It is usually large enough (20) that most casual uses of Lua don't hit it, so can pretend the stack is automatically handled and it mostly works. If you use Lua for a long time, you will eventually hit it and realize that everywhere you ever pushed things onto the Lua stack, you *should* have been calling lua_checkstack, *and* handling the case where it fails. You have to keep track of the stack usage by hand, and if you get the number to pass to lua_checkstack wrong, it will 99.99% of the time work anyway * Lua's API mostly uses C longjmp for external error handling because it also uses longjmp for internal error handling. A huge percentage of the library's API surface will longjmp on error, and usually people who use Lua only protect the obvious entry points (lua_pcall instead of lua_call). Lua can and will call into Lua scripts all the time and most of the time people forget even the easy ones (lua_settable, lua_gettable can both longjmp because of metatables). If you call one of these API functions at the top level of your code, you will be saved because Lua will simply abort, but if you do so *within another Lua callback* generally it will hop over all of your intermediate code and silently cause memory unsafety. * For the C API that does not directly call Lua code, a huge, *huge* percentage of what's left will call Lua code inside garbage collector metamethods. In fact, *everything in Lua that allocates* can call Lua garbage collector metamethods, *and these can all longjmp*. Hardly anybody ever runs into this, because hardly anybody ever even uses __gc metamethods, but they're there for scripts to exploit. Making a bindings system that handles this correctly is *hard*, I mean *really hard*, and doing it wrong means that, again 99.99% of the time everything works anyway. Go take a look at [util.rs](https://github.com/kyren/rlua/blob/master/src/util.rs) in rlua and just scan until you see something gnarly (it's all gnarly). Also notice all of the comments that say "uses X stack space and does not call checkstack". * If you solve all of this, and this takes an amount of effort that is hard to justify, you will still be left with the memory unsafety inside of Lua itself. You have: * The entire 'debug' library * load, dofile, and loadfile will all load bytecode and that is memory unsafe * os.setlocale sets the C locale globally (and is thread unsafe?) * package.loadlib will allow you to load C dlls * os.date (also thread unsafe?) * After all of that, and effort sandboxing Lua scripts away from the unsafe parts, there are plain bugs in PUC-Lua's VM which lead to memory unsafety, and a large percentage of bugs filed lead to memory unsafety. Look [here](https://www.lua.org/bugs.html) and start counting. So, right now, rlua is the only bindings system I know of to even *attempt* to solve some of these problems, and it still fails at it. Admittedly, the only current failure I *know* of is stuff inside Lua itself that rlua doesn't prevent yet (load / dofile / loadfile, etc, [see here](https://github.com/kyren/rlua/issues/116)), but I'm almost 100% positive there are others though. I know of one "potentially" safe use in production of untrusted Lua scripts, in a commercial entity, and it's my understanding that as part of their solution they had to *remove __gc metamethods from the language entirely*. After spending SO much effort on rlua, I became just.. very very tired. This is why I completely get where _Timidger_ is coming from. However, in my case, I think the lesson I took away is different. I have to say that I 100% blame the Lua C API here, even though I understand the reasoning (I think) that led them to the current API design. The thing that was SO tiring about writing this for me wasn't Rust, it was *reasoning about the C library that I was binding*. I'm just... *tired* of using C APIs! I'm tired of not having the compiler reason for me, I'm tired of having to second guess at what invariants the API expects and guess at what of a myriad of interesting non-local behavior a function call will do. I know that the Lua C API is a really, especially bad example, but I just don't know what the general solution is here. As a user of libraries and a Rust programmer, I'm going to be honest, I'm so tired of dealing with C crap that I just don't reach for C libraries anymore :( That's the *really* depressing thing, that if I wanted to use Lua and rlua didn't exist, I just... wouldn't? I'm not writing a wayland compositor, but I'm just NOT going to use wlroots directly... all that effort that was spent trying to wrap it safely is instead effort that I have to keep in my head. I'm *going* to get it wrong. I'm just tired of writing programs with memory unsafety bugs, I know there is still software worth writing that needs to deal with memory unsafety and C libraries, but I guess somebody else can write it because I'm exhausted. If there are patterns that Rust can't express, then I guess we should work at making Rust better, or finding new patterns? If there are fundamental limitations to Rust.. then I guess let's make a new language? I know there are some problems that require advanced knowledge of memory layout and lifetimes and will be unsafe, but Rust's purpose is not to pretend such problems don't exist, Rust's purpose is to provide a firewall against them, to make sure that unsafe code is reasoned about *locally*, not throughout the entirety of your project, the projects that use your project, their users, and so on. People talk about Rust being restrictive and kind of influencing the design of your whole project, but you could turn this around the other way: C is so *unrestrictive* that you can express crazy lifetime rules in it, and this sort of sucks everything that uses them into being as memory unsafe as C. This is not limited to Rust, C++, safer non-systems languages also suffer from this effect, as is evident from Lua. I refuse to believe that the solution is that C will live forever, that just *can't* be the solution. I think Rust's biggest strength is being able to take things that are unsafe *globally* and turn them into things that are unsafe *locally*. I know that this is not 100% possible with all tasks yet, but I'm trying to [do my part](https://github.com/kyren/luster) at figuring out answers to the remaining questions. I know this has been a bit of a rant, and I definitely don't mean this as a criticism of wlroots or _Timidger_ or C programmers in general, this has just been on the forefront of my mind a lot lately. Sorry for the rant, and I hope your port goes well :D
Surely IRC should need most of them, it's just not laid out in such an explicit, watertight way.
&gt; So you either mark it unsafe (then why are you using Rust?) Because of a million (ok, I exaggerate here) ergonomics improvements: * Much richer type system * Traits * Iterators * Cargo * Great std lib * crates.io * The list could go on and on, those are just the top ones
is the index is just of file names? not content? so, like find (or fd) with an index? also - this will probably come off as annoyingly critical, but hopefully not so much with that caveat haha - I think the name is very clever, and I laughed at it, but I imagine I would find it to be too long for everyday usage, although I think I'm somewhere close to the kdb+ people on the spectrum of demanding brevity in naming.
&gt;However, most of the evidence on the internet I found claims that it doesn't really matter that much or that 64 bit is slightly faster. Can anyone please elaborate on this? It is a bold face lie. Why? 1. Rust manages field layout as a MIR optimization so for optimal cache layout the programmer is unlikely to improve on Rust's layout. 2. Loads from memory always terminate an icache line (you can fit N micro-ops per line) regardless of size (in the case of `i16`, or `i64` immediate value they consume the _entire_ line without any additional micro-ops). (Intel/AMD specific, but this is 98% of the processor market) 3. L1-Data Cache has 64byte cache lines (modern Arm, Intel, or AMD). This means main memory is loaded/read in 64byte aligned chunks (sometimes 32byte on older &lt;2000 processors with L1-Data caches) so an extra 4 bytes is largely irrelevant. 4. 64bit and 32bit integer operations are equal speed on modern processors. Citation: https://www.agner.org/optimize/microarchitecture.pdf --- In short myths about 32bit integers being faster are mostly supported by people doing extremely quick userland tests without checking how repeatiable those results are in most cases. Also a fair number of compression benchmarks run faster under Linux's x32 mode (64bit mode with 2 level page tables), which uses a lot less hardware TLB resources provided secondary acceleration. --- In short, it isn't.
Refactoring the terminal util, \`Crate help in terminal\` to be more idiomatic rust. ([https://github.com/peterheesterman/chit/](https://github.com/peterheesterman/chit/graphs/traffic))
&gt; is the index just of file names? Exactly. &gt; I think the name is very clever, and I laughed at it, but I imagine I would find it to be too long for everyday usage I actually considered using a shorter program name ; but in actual use I found it most appropriate to write shell aliases, e.g. ``` alias d='lolcate --db documents' alias zik='lolcate --db music --type audio' ``` and functions, e.g. ``` z(){ mpv --playlist &lt;(zik $1); } zs(){ mpv --playlist &lt;(zik $1|shuf); } ``` So the length of the program name isn't really relevant, imho.
Well you clearly haven't been reading mine either. Yes it's pretty slow and bloated, closed source, and disabled users definitely are not well off. But guess what, 99% of users *don't give a crap*. And for anything else, Discord is just flat superior to the alternatives. It's that simple, it's not an absolute regression like you're making it out to be, and it makes sense why it took off.
Matches my learnings pretty closely. Taking care of the borrow checker is the price I happily pay for trivial multithreading, no copy by default, no gc and a lovely modern language.
A generic answer was exactly what I was asking for—I certainly wasn't expecting you to give away trade secrets. Thank you for your insight :-)
Quick test with 6 million files (417,726,232 bytes in a raw `find` dump): bsdgrep: 0.47s ripgrep: 0.25s FreeBSD locate: 65,561,990 bytes, 0.5s Lolcate: 53,778,002 bytes, 2.4s
Well as Steve said, if you're not risking new bugs, you'll effectively abandon the project. In either case entropy always wins in the end. But my argument for there being possible cases where rewriting in Rust may be a good idea doesn't even hinge on that ("But even if that were the case..."). So you agree that you overgeneralized?
I'm sure there are great communities there, but that's not my concern. I'm part of other great communities that aren't owned by a corporation.
Hopefully the amount of code you write to maintain a library is less than the amount of code you'd write to rewrite it from scratch.
Well, in the context of this conversation: why it’s bad for rust to use it as a platform I think being inaccessible to disabled users is a *huge turn off*.
&gt; I have always had the feeling that the Rust community cares more about building software than the politics of it. That in itself itself a political position, and one many disagree with.
If you need to talk browser to browser, you can just use WebRTC directly. This is really just for browser &lt;-&gt; server communication.
Is there a crate similar to termion for Windows? I've tried using crossterm, but I just hit frustration after frustration, and the minimal/outright missing documentation is a big pain point (e.g what is "alternate screen" or "raw mode"?)
I'm coming from a Python background and I just learned how to write Python modules in Rust. It works surprisingly well and I love it. I use Django a lot and I was wondering if this was possible: Could I write a Python module in Rust so that I don't need a nginx for my Django projects anymore? I just setup Django and use my Rust module as an http server. Would this even work? I don't have a CS degree so I am lacking the needed knowledge. And let's say this was possible: I suppose the biggest problem would be that there's no wsgi implementation in Rust. I would still need this for my Django app so it could communicate with the application server. Would you agree to this? Are there any experts that can tell me if this is even possible and maybe push me in the right direction. I can google stuff myself, but I need at least a few keywords so i know what I need to be looking into. Thanks in advance!!
Fixed! Thanks!
&gt; If Mozilla can't or won't do it, who will? There are already plenty, there just hasn't been the "big one" that people have united on and invested in. Or maybe it's still IRC and it just needs some updates and ergonomics?
I disagree with the other commenters that cloning is necessary or helpful. An important rule for writing recursive algorithms - or proofs by induction; same thing - is that if you don't like the arguments then change them (internally). To wit: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=836e1f5ed71d532860f3a7fc0a57900f
Except I was simply pointing out why it's become de-facto because of the layman.
Business is anti-bankruptcy, and like it or not it is much easier to make money when you (and only you) can charge actual money for software you have written.
Thank you for the feedback! It appears to be an issue on Firefox on Linux only (Firefox on other platforms appear to render this text correctly, and chrome on Linux appears to work correctly too). I'll try to debug this (even though I don't have a Linux instance to debug on right now).
You didn't miss it - it wasn't in there! `smd` stands for smithy DOM. (I didn't want to use `rsx`, `htmlx`, `html`, etc. because there are existing projects that use that naming scheme. But it's a decision I'll revisit, now that I've gotten the internals of Smithy to a fairly good point.) owned vs ref: Ah, that's actually a really good idea for naming, thank you! I'll consider renaming it to that in the next release.
I believe I tested this and printed out the result and it actually didn't do it in order. Am I missing something?
Thanks for sharing this!
But a tiny change during maintenance can easily break a lot of other code.
This, it’s mind boggling to me how they’re doing that. Plus all the comments in this thread like “it’s popular get over it”. Wtf. I expect better from the rust community.
&gt; this build may install, and may not format your hard-drive. How worried should I be?
Is that before the index has been created? I'm just very surprised that locate is slower than the greps.
“Limited resources” They are funded by tencent, one of the biggest corporations in the world. They have the money to add whatever they want. They just don’t care about things like accessibility, because at the end of the day their target demo is gamers, and most gamers aren’t blind/immobile.
Windows bad lol
So you are literally stating the same point as I?
I don't think so, since there's nothing special about your binary target at `main.rs` as far as the library target is concerned.
&gt; most of that 9 seconds now is linking a binary Are you using LLD? As far as I'm aware you'll also need to use the `x86_64-unknown-linux-musl` target, so `RUSTFLAGS="-Clinker=lld" cargo build --target=x86_64-unknown-linux-musl` should get you going. The GNU linker is both pretty slow and serial, for my modestly-sized projects LLD takes me from 3.0 to 0.36 seconds of link time.
Here's a proof of concept: https://crates.io/crates/darc I added benchmarks for `clone` (and implicitly `drop`). I find that `std::rc::Rc` takes 3.15ns, while mine takes 3.78ns. So it is a little slower for single-threaded, but then `std::sync::Arc` and mine both take about 11.5ns. Feedback welcome here or as issues/prs on the repo -- especially where safety is concerned.
yeah, i agree with the basic idea. discord is fine (modulo accessibility) and i don't have much patience for FOSS purism for its own sake. the way i read the analogy just struck a weird note for me, so i thought i'd mention it.
Yes, thank you! I hate tiny cryptic program names with a burning passion, that's what autocomplete and aliases are for!
That thread only addresses BetterDiscord, not alternate clients.
It's not, you can be apolitical in the libre software debate. Let people build and share things how they want and call it a today. It's incredibly misguided to make _not having a position_ something to debate, you need give people the freedom to not engage. I really hate that attitude in the FOSS community, nothing is so black and white.
I was expecting the same.
Well, that would also be useful for a variety of things (eg session recording). But I thought you at least need a server to initiate browser-to-browser communication. Maybe that doesn't require much, I've never seriously looked into it.
Hey /u/sanxiyn, thanks for doing this AMA. I have a few questions, hopefully they're easy to answer. 1) I'm not sure I understood correctly, do you deploy your services in Docker on Windows? 2) What do you use for metrics and alerting? 3) In a comment below, you mentioned that you don't use gRPC for any critical path logic. Do you use any other sort of MQ systems or Rust's built-in mpsc channels? 4) Is it faster to use one application (one process, many threads) and having the application logic running in a separate thread, or has it been easier/less troublesome to have each component be a separate application? (This one is a bit of a rookie question and I may just lack the lower-level knowledge to have the answer already)
the normal amount of worried you personally feel is appropriate when downloading and running code you found on a subreddit? 😬
God, mlocate sucks so much. I puposefully deactivated all the desktop 'indexing services' because my computer sucks at dispersing heat and will shutdown on persistent writing, and what do i find? mlocate was already doing it on a schedule. Godamnit.
It's literally titled "alternative clients", and mentions BetterDiscord AND Pidgin. Two clients. It's against the TOS to use the discord api for anything other than a bot account. The discord client uses and requires the discord api. The only way for an alternative client to exist is to violate the TOS.
I've been writing a bunch of unsafe Rust, and I think it's not so bad. As others have mentioned, there are many quality-of-life improvements over C. But I'll go a bit further and state: unsafe Rust is also easier to write without running into UB than C. &amp;#x200B; Here are the main reasons I believe this: \- Even in Unsafe Rust, the compiler still prohibits many sources of UB. Regular references keep their normal borrowing/aliasing semantics. You can't just go and use an uninitialized or moved-out-of variable. You can't read the \`Ok\` value of a \`Result\` that's really an \`Err\` as if it were a C \`union\`. \- Dynamic checks catch many things that are UB in C. For example: integer overflows, array out of bounds accesses, panicking while holding mutex guards etc. \- You can run your unsafe code through miri and it will tell you if you are invoking any UB and, if so, exactly when and how it happens. In my opinion, it handily kicks AddressSanitizer's ass for the purpose of detecting UB, because it finds way more things, including code that only "incidentally" works on your hardware but has UB at the language-level.
Maybe check out [`fst`](https://github.com/BurntSushi/fst) for the DB? It should result with fast queries and small result files (at expense of memory usage when building indices).
[immeta](https://crates.io/crates/immeta) has read-only support for several image formats. [imagemeta](https://crates.io/crates/imagemeta) has read-write support for JPEG/EXIF but appears to be unused/unmaintained. [mp4parse](https://crates.io/crates/mp4parse) has read-only support for mp4 metadata. [ogg_metadata](https://crates.io/crates/ogg_metadata) has read-only support for various Ogg formats. [id3](https://crates.io/crates/id3) has read-write support for MP3 tags.
Can we use lld on Windows too?
Thanks ! Yes, I was aware of `fst` and it indeed seems appropriate to consider using it. Admittedly the backend is one of the areas I'm hoping people will contribute to, because it already suits my needs as it is.
Yeah, that's the _Room Settings_ panel of Riot.im, the first-party Matrix client.
Interestingly, copyright has been used as a reason why logging public IRC channels is probably on slightly shaky legal grounds.
Yes, I had the same problem too (it was more legible, but the text was white instead of black). To work around it, I took a screenshot using the \`import\` command of imagemagick, then opened the png in Firefox and eventually took a screenshot of it so I can have a link pointing to the broken screenshot …
I made something like that when I was trying out webassembly. In JS: // Allocates a wasm-accessible copy of the given string function write_wasm_string(module, str) { let encoder = new TextEncoder("UTF-8"); let string_buffer = encoder.encode(str); let ptr = module.exports.string_create(string_buffer.length); let str_data = module.exports.string_data(ptr); let str_len = module.exports.string_len(ptr); let mem = new Uint8Array(module.exports.memory.buffer, str_data, str_len); for (let i = 0; i &lt; str_len; ++i) { mem[i] = string_buffer[i]; } return ptr; } // Converts the given wasm-accessible string into a javascript string and deallocates it function read_wasm_string(module, ptr) { let str_len = module.exports.string_len(ptr); let str_data = module.exports.string_data(ptr); let mem = new Uint8Array(module.exports.memory.buffer, str_data, str_len); let decoder = new TextDecoder("UTF-8"); let str = decoder.decode(mem); module.exports.string_dealloc(ptr); return str; } And in Rust: /// Allocates a new String on the heap, with space for `len` bytes. /// /// # Safety /// /// The string's data must be completely filled by valid utf-8 bytes before /// being used in safe code. #[no_mangle] pub unsafe extern "C" fn string_create(len: i32) -&gt; *mut String { let mut s = Box::new(String::with_capacity(len as usize)); s.as_mut_vec().set_len(len as usize); Box::into_raw(s) } /// Deallocates the provided String. /// /// # Safety /// /// Requires that the `ptr` was allocated in Rust. #[no_mangle] pub unsafe extern "C" fn string_dealloc(ptr: *mut String) { let _ = Box::from_raw(ptr); } /// Retrieves a pointer to the string's data. /// /// # Safety /// /// `ptr` must be a valid String. All modifications through this pointer must /// preserve String's invariant, that it is totally filled with valid utf-8. #[no_mangle] pub unsafe extern "C" fn string_data(ptr: *mut String) -&gt; *mut u8 { (*ptr).as_bytes_mut().as_mut_ptr() } /// Retrieves the string's length, in bytes. /// /// # Safety /// /// `ptr` must be a valid String. #[no_mangle] pub unsafe extern "C" fn string_len(ptr: *mut String) -&gt; i32 { (*ptr).len() as i32 }
Speaking from years of dreadful XMPP experience, I've begun to understand "it's up to the clients to implement" as "it will never work reliably, if at all". You have no idea if the people you're communicating will receive the same things you're sending, which makes communicating very hard. If you wanted to use any but the most basic XEPs, you'd better hoped your peers were using the same client as you are, and connected to a server running the same software as your server. It was terrible.
I work with some blind colleagues on slack. Works fine, they say as well as IRC. There are many awful things about slack, but accessibility seems ok.
I was wondering about this myself. Using indexes into arrays seems to be a good, but non-obvious "escape hatch" for when lifetimes don't seem to match up to scopes on the stack. I'm really curious if this design would work out, or if there are other, even non-optimal designs that don't end up being horrible to maintain.
Instruction reordering can do really confusing things with unsynchronized multithreaded code.
&gt; I'm unable to type directly because of an RSI injury. Do you avoid all typing? Or just type minimally? Are there any specialized keyboards for this kind of situation? I can imagine speech recognition working in a lot of cases, but when you need precision + greater speed, there's no foot based keyboard or something?
As an aside, a CS degree probably wouldn't provide you with this knowledge. CS degrees are heavily focused on theory and providing a wide gamut of introductory courses, but very few focused on particular software engineering disciplines. (This also varies widely from school to school; my only college experience is from when I briefly attended the state university in my home town, but it was focused on liberal arts and its CS program was more or less stuck in the 90s.) Some trade/technical schools offer web development courses but IIRC those are more focused on web design than web application architecture or administration. Also most of those kinds of schools in the US are overpriced and not actually accredited so your degree is only worth something to other people who attended the same school. I don't have any real experience with Django myself, but just from some searching I can tell you definitively that nginx isn't the only way to deploy a Django application, and it isn't even the officially recommended one that I can find. [The official Django deployment guide](https://docs.djangoproject.com/en/2.2/howto/deployment/) actually recommends [deploying with Apache server and `mod_wsgi`](https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/modwsgi/). Apache is very mature and battle-tested, but it is rather heavyweight and any advanced usage requires a lot of knowledge of its configuration files. It's potentially worth learning, though, depending on your career goals. There's two other alternatives provided in Django's documentation: * [GUnicorn](https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/gunicorn/), a pure Python WSGI server which looks pretty simple to configure. * [uWSGI](https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/uwsgi/) is a lightweight WSGI server written in C which also has a very simple configuration file. It sounds like what you've actually learned to setup is an nginx reverse proxy with uWSGI as the actual HTTP server talking to Django; that's what's being instructed in [this guide in uWSGI's documentation](https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html) In a single instance setup, nginx is somewhat superfluous as AFAICT you can just have uWSGI handle the requests directly. nginx is mostly used for load-balancing against multiple running server processes, usually on different machines in the same internal network. However, it can also statically serve files (images/CSS/Javascript assets) which is definitely necessary for any serious web application, but uWSGI (or GUnicorn probably) won't do that itself so that's why you need both of them. If you wanted to replace nginx and uWSGI with a Rust program you would have to cover both talking to the Django application over WSGI as well as static asset serving. It's not for the faint of heart but it's definitely possible and probably worth doing. The actual specification for WSGI is [PEP 3333](https://www.python.org/dev/peps/pep-3333/#specification-overview) which is definitely a required read if you're considering this. WSGI is explicitly designed to be easy to implement, however, to encourage wider adoption, so this would be a good place to start. The RedHat Dev Blog has [an article on creating a Python module in Rust](https://developers.redhat.com/blog/2017/11/16/speed-python-using-rust/) and you can use an existing HTTP server implementation like [Hyper](https://github.com/hyperium/hyper) to handle the low-level web stuff for you. As a final note, I've found that it's not helpful to ask whether something is possible or not, because in software it almost always is; it's just a matter of how much work it's going to take. But the hardest part is usually just getting started in the first place.
What exactly do you mean by anti-business?
You have made my week, honestly I can't thank you enough for this POC! I was struggling to piece together how this could be done, so appreciate the input. Sanity restored!
Who mentioned slack? Discord is supposedly much worse for accessibility
Ok then we shouldn’t use Discord (or even consider it as an option!)
One of the few things that I miss from Windows is an alternative to [Everything](https://voidtools.com/): an application to find any file instantly by its filename. This looks like a potential alternative, so here is my wishlist, what would it take to make me use your app on a daily basis: * Instant results. I want matching files to appear while I am typing. Integration with a launcher like dmenu would be nice. * Sort files by creation time. Useful for finding recently downloaded files and recently created logs. * Also, sort by name, path, and size. Changing the sorting type should be instant. * Filter by media type: music, videos, pictures, documents. Basically a builtin regex for each. * GUI. A terminal interface would give me zero benefits over running `find`. I want to click buttons. I do not want to learn more commands or keybinds. I want to double click to open the files. I want to be able to drag files to folders. * User experience. I want this app to work out of the box. Manually creating a database is too much for me, just use sane defaults and I'll be happy. An install script is a must. * Responsiveness. I want zero startup delay. Have you ever tried to run alacritty? It's a GPU-accelerated terminal emulator, but it takes maybe one second to start up. In that time I could have opened a normal terminal and typed the command there. Opening this app should always be faster than typing `find / -name `. Now, I suppose that some of this points are out of scope for this project, but writing an alternative to Everything has been on my TODO list for a while, so if this project keeps evolving I will probably use it as a backend for my app, unless someone else writes it first.
I don't think you understand. _Every service_ which hosts user content has essentially the same clause in their terms of service. For example, Rust is hosted on GitHub.com, which demands: &gt; [You grant us and our legal successors the right to store, parse, and display Your Content, and make incidental copies as necessary to render the Website and provide the Service. This includes the right to do things like copy it to our database and make backups; show it to you and other users; parse it into a search index or otherwise analyze it on our servers; share it with other users; and perform it, in case Your Content is something like music or video.](https://help.github.com/en/articles/github-terms-of-service#d-user-generated-content)
I do a little bit of swiping on my phone, and I keep the keyboard nearby for the rare instance where there is no choice, but I do pretty much everything by voice. There is no foot keyboard that I am aware of although I do use USB foot pedals for some things (it's convenient for up and down which would be a real chore to do by voice). Feet generally lack the same level of dexterity and precision as your fingers so I'm not sure a foot base keyboard would work very well, although I have a big memory of seeing a special on disabled people once where there was someone who typed with their feet, but I think they were only able to develop that ability because they were born without the use of their hands.
One question that I have been pretty stumpted about in the past few months is why have we stopped trying to improve open standards? IRC is a protocol defined, quite accessibly, by the [IETF](https://tools.ietf.org/html/rfc2812). If IRC is broken for your organization, why aren't we submitting updates to this specification to accommodate these problems?
Knowing that Discord excludes part of the community changes this conversation for me, and I hope for others. Accessibility is way, way more important that open-source vs closed and electron vs native.
Before the index has been created? What sort of weird test would that be? :) locate's a 1980's design, it doesn't surprise me it's less than ideal for modern hardware.
Thanks for your comment. &gt; Instant results. I want matching files to appear while I am typing. This is actually possible by piping a `lolcate` query to e.g. `fzf`: lolcate --db music --type audio jazz | fzf &gt; Filter by media type: music, videos, pictures, documents. Basically a builtin regex for each. Such a feature is already implemented as "path name types", and example definitions for music, videos, pictures and documents are provided, but commented by default. I contemplated enabling these definitions by default, but -- as always -- the right balance between ease of use and versatility is hard to find. Take for instance images. Some people may have their disk filled with jpeg pictures and a bunch of png files, and be happy with `img = ".*\\.(jp.?g|png|JP.?G)$"` ; while other may need a much longer set of image file types (whose list seem [endless](https://en.wikipedia.org/wiki/Image_file_formats)). And I have this feeling, that everybody has his own idea on what a "document" can be, and especially what it cannot be. Any thoughts from other people ?
Maybe not everyone, but large-ish open source projects like Fedora, Gentoo or Rust? Sure.
If that is an argument: There is a Matrix Rust room with 2925 people.
&gt; we have #rust:matrix.org for all you Matrix people That's awesome!
I read \_Timidger\_'s post again, and I guess it was lost on me the first time that this: &gt; I want to make one (mildly controversial) thing clear: rewriting a library for the sake of only using Rust is not good engineering. A literal rewrite of a project to Rust is not interesting, it’s not useful, it just causes churn and splits ecosystems. Time would be better spent either working with existing solutions that already have the effort put in to make them correct or to come up with new green-field projects. Was maybe directed at me with luster. I don't know if that's the case or not, but even if it is you're allowed to feel that way I guess. I think for luster I really very strongly disagree, since its purpose is mainly to try and find a solution to one of the areas where currently Rust *does* have a lot of problems maintaining speed, ergonomics, and safety: garbage collection and boundaries with garbage collected languages. The recent Chrome zero day with a misbehaving garbage collector invariant should be a pretty good indicator that something like this would be a welcome tool to have, but you can also just use the rest of my post as justification as well. Language implementations are interesting also, since often times a new green-field language is a complete non-starter for people but a re-implementation of an existing language can be fine. I hope that comment wasn't directed at me, but if it *is* I really couldn't disagree more I'm afraid :(
You are correct, the most used config for Django is Apache/nginx for serving static files and gunicorn/uwsgi as the application server. I worked through chapter 20 of the TRPL (creating a multi-threaded web server) and I really like how easy it is to deploy. It's just one binary and you don't need a webserver like Apache/nginx. I think that it would be awesome to have something like this for Python via Rust. But if I need to implement an entire WSGI server, I'm afraid this is way over my head. Thank you so much for you clarifying input!!
Uh, the complaining about linux thing is a meme, he hasn't spent much time doing that at all.
Sony contributed to FreeBSD? Hah, I'd love to see a source for that. Everything I've read says they took FreeBSD for their PS4 OS and gave nothing back, not even a penny.
I did this recently, so I guess I'm guilty of bad engineering *twice* here, once with luster and once with [webrtc-unreliable](https://github.com/kyren/webrtc-unreliable). &gt; If it's done to gain confidence in the code, it may well be the cheapest way. I gave some other justifications for rewriting it, but that was actually the main one for me in webrtc-unreliable. I mean what else do you do when you encounter code [like this](https://github.com/seemk/WebUDP/blob/master/WuSctp.cpp#L10) . Maybe if I was a better open source citizen I could have just reviewed WebUDP and fixed all of the bugs, but it would have taken me longer. But it's also possible that this is just more excuses and if I wasn't as bad of an engineer I could have fixed the memory safety issues. I just don't think I'm able to write memory safe C / C++ I'm afraid :(
Yet here we are on a proprietary platform.
"Great minds discuss ideas; average minds discuss events; small minds discuss people." -Eleanor Roosevelt
There's a big difference between sharing stupid gifs and managing a project like "Rust" or "Firefox"
&gt; _Every service_ which hosts user content has essentially the same clause in their terms of service. That's not really true for federated protocols. You don't give these rights to, e.g., GMail. (I assume, haven't read their TOS). Additionally, if the content is E2E encrypted, it's a non-issue. They can't read it. Though there's still big UX issues with E2E encrypted community communication.
Gmail uses the generic Google ToS: &gt; When you upload, submit, store, send or receive content to or through our Services, you give Google (and those we work with) a worldwide license to use, host, store, reproduce, modify, create derivative works (such as those resulting from translations, adaptations or other changes we make so that your content works better with our Services), communicate, publish, publicly perform, publicly display and distribute such content. The rights you grant in this license are for the limited purpose of operating, promoting, and improving our Services, and to develop new ones.
It actually is, but folks who are hosting irc logs typically haven't spoken to a lawyer about whether that's legal or not. You're conflating terms being not explicitly laid out with them not existing
Wrong subreddit. This is for Rust the programming language.
Whoops
You may want to bind a mature C library for this task. I had good experience with GNU libextractor in the past.
You might find WebTransport interesting: https://discourse.wicg.io/t/webtransport-proposal/3508 It's a proposal to add a Web API for unreliable, unordered, WebSocket-like-but-better messaging. The only protocol you need to speak on the server is QUIC. It grew out of WebRTC (see https://w3c.github.io/webrtc-quic/) to give people the power of the data channel but with fewer roadblocks and more flexibility. We (the WebRTC team at Google) heard from people like game developers many times that they wanted something like this, so we've (slowly) been working on it. A p2p version (https://w3c.github.io/webrtc-quic/) is in original trial in Chrome 73 (https://developers.google.com/web/updates/2019/01/rtcquictransport-api). It can be used client-server, although you need to speak ICE and QUIC (although ICE lite is quite easy). We'd love to get feedback from developers on both of those, either by using the origin trial or by commenting on the discourse. So please go try it out or join the discussion. I think the only thing blocking us from implementing more of it, or more quickly, is demand from developers. So if you want, please go express your desire for it :). (BTW, if it matters, I'm an author of the WebTransport proposal and author of the WebRTC/ORTC QuicTransport proposal. I work at Google on Chrome, and my previous team implemented the original trial for RTCQuicTransport as well as the original SCTP DataChannel)
I am confused over the error message from the compiler regarding this code type ParseResult&lt;'a, Output&gt; = Result&lt;(&amp;'a str, Output), &amp;'a str&gt;; trait Parser&lt;'a, Output&gt; { fn parse(&amp;self, input: &amp;'a str) -&gt; ParseResult&lt;'a, Output&gt;; fn map&lt;F, NewOutput&gt;(&amp;self, map_fn: F) -&gt; ParseResult&lt;'a, NewOutput&gt; where F: Fn(Output) -&gt; NewOutput, { map(self, map_fn) } } fn map&lt;'a, P, F, A, B&gt;(parser: P, map_fn: F) -&gt; impl Parser&lt;'a, B&gt; where P: Parser&lt;'a, A&gt;, F: Fn(A) -&gt; B, { move |input| parser.parse(input) .map(|(next_input, value)| { (next_input, map_fn(value)) }) } The errors are error[E0277]: expected a `std::ops::Fn&lt;(&amp;str,)&gt;` closure, found `Self` --&gt; src/parse.rs:21:9 | 21 | map(self, map_fn) | ^^^ expected an `Fn&lt;(&amp;str,)&gt;` closure, found `Self` | = help: the trait `std::ops::Fn&lt;(&amp;str,)&gt;` is not implemented for `Self` = help: consider adding a `where Self: std::ops::Fn&lt;(&amp;str,)&gt;` bound = note: required because of the requirements on the impl of `std::ops::FnOnce&lt;(&amp;str,)&gt;` for `&amp;Self` = note: required because of the requirements on the impl of `parse::Parser&lt;'_, _&gt;` for `&amp;Self` note: required by `parse::map` --&gt; src/parse.rs:147:1 | 147| / fn map&lt;'a, P, F, A, B&gt;(parser: P, map_fn: F) -&gt; impl Parser&lt;'a, B&gt; 148| | where 149| | P: Parser&lt;'a, A&gt;, 150| | F: Fn(A) -&gt; B, ... | 155| | }) 156| | } | |_^ error[E0308]: mismatched types --&gt; src/parse.rs:21:9 | 17 | fn map&lt;F, NewOutput&gt;(&amp;self, map_fn: F) -&gt; ParseResult&lt;'a, NewOutput&gt; | -------------------------- expected `std::result::Result&lt;(&amp;'a str, NewOutput), &amp;'a str&gt;` because of return type ... 21 | map(self, map_fn) | ^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found opaque type | = note: expected type `std::result::Result&lt;(&amp;'a str, NewOutput), &amp;'a str&gt;` found type `impl parse::Parser&lt;'_, NewOutput&gt;` error: aborting due to 2 previous errors Some errors occurred: E0277, E0308. For more information about an error, try `rustc --explain E0277`. error: Could not compile `parser`. Please explain like I am 1 month old....
Note that in the design pattern of Rust, code must only mutate if it is declared mutable. If some Rust code does mutate an immutable variant, it is usually NOT a good design. If that was me to make this design, I'd prefer changing the variable type into mutable owned or mutable borrowed. After considering this, if you still want this kind of immutable variants, you need interior mutability. Use Cell or RefCell structs in core::cell may help you with that, or even sometimes with unsafety if properly handled and wrapped.
How will const genetics help?
Core spec threading support is planned for Matrix. It might be a while, though, they've got their hands full.
there are 2 ideas I like personally with the await syntax 1) any of the post fixes except for the space syntax because when I see a space between expressions and one of them is a keyword I expect it to read vaguely grammatically correct and I have preference against the field access syntax(though I still like the idea) given that field accesses feel like they should be accessing a value that is currently stored in the struct when they are accessed but instead it's waiting a bit I like the post fixes because they are clear on what's being awaited and they're as the write up says orthogonal and when you have to figure out what order they're in just read left to right and 2) the mandatory delimiters I support this for similar reasons to the postfix syntax the reason I support this over optional delimiters is because if you're allowed to not have delimiters you have to think about how await and ? interact with each other as far as order of operations go I mean yeah it's left to right but the expression between the await and the ? makes this unclear at least I imagine it would for me so mandatory delimiters make it clear that what ever is in the brackets will get awaited and if there is stuff outside the brackets that it will get applied to the value that await returns(as if await was a normal function)
I am glad that attention is paid to Korean linebreaking. I learned that Korean is pretty unusual (but it looks normal to me!) in that Korean uses spaces to break words, but do not use spaces to break lines. This is unlike Thai, which does not use spaces to break words either. Because of this peculiarity, everybody seems to get this wrong.
Good to know! So my argument doesn't stand. An email provider can be just as scummy as a chat provider.
To be completely clear, line breaking is out of scope for the skribo library. I'm hoping that there will soon be a paragraph-level layout library that uses skribo for the low-level text formatting, and when that happens your input to make sure Korean is correct is well appreciated. Of course, one thing the library *does* try to do is convert between NFC (syllables) and NFD (individual jamo) when the string is in one form and the font is in the other, though I haven't tested it extensively with Korean. I did write my own Unicode functions for that :)
If the service is going to store sent messages and forward them on to other users, it *has* to get a license to those messages, otherwise the entire thing doesn’t work.
Super exciting to see the continued development here! With the way the Rust ecosystem is going lately, I'm actually looking forward to building UIs for my personal projects in a year or two. Plugging together libraries like druid, skribo, and pathfinder is going to open up some really cool capabilities.
You should test Hangul normalization with obsolete Hangul letters because they can't be encoded in syllable form. Google Noto supports combining obsolete Hangul letters and is recommended by Korean Wikisource project.
Explicit copying isn't for performance, it's for predictability. Copy and move constructors in C++ cause \_tons\_ of problems, so Rust forcing you to acknowledge that doing something could have a side-effect is really comforting. Naturally, we still have this problem in Rust via \`Drop\`, but I'm not sure how we'd possibly get around that.
Any chance of seeing Pathfinder ported to GFX or webgpu in the future or unlinking it from OpenGL directly? I'd love to use it for some future projects. Of course I can always port it myself too but just curious what plans would be. Fantastic release btw
I’m surprised there is more support for postfix field access than postfix method syntax. It feels more natural, with await being a verb.
Is there any way to vendor a patched 3rd party crate into your own crate repository such that you can still publish your own crate to crates.io. I’ve made some changes to a 3rd party crate that are critical for my crate but really don’t make sense as an upstream patch. I vendored the modified 3rd party crate into my own repository, and can use it locally with a {path = ‘vendor/foo’ } directive inside my Cargo.toml. But noting I do seems to allow me to publish my crate to crates.io. Is there a solution here?
I suppose the lure of lesser typing in the middle to the end on lines is in play here.
Keep in mind that Mozilla has not decided on an IRC replacement yet, they've simply announced that there will be one. You may be confusing Mozilla with various Rust teams that independently decided to migrate to Discord.
He mentioned that he can't use LLD on Mac
Having an implicit magical field on futures really does seem like the worst possible solution. It’s genuinely frustrating to see it being taken seriously at all.
&gt; Let people build and share things how they want and call it a today. This is absolutely a political position; you are advocating a laissez faire attitude to this specific area. I can trivially translate it to some other area: "Let people build apartments and rent them out how they like". &gt; It's incredibly misguided to make not having a position something to debate, you need give people the freedom to not engage. This is like saying that not voting is not a political act. *It is*.
&gt; Business is anti freedom, that's why it's not compatible. Business seems to be making a whole lot of money of of Linux which is a GPL2+ed kernel, so what gives?
Not very surprising. https://github.com/rust-lang/crates.io/issues/173
A protocol is not a service. Federated protocols like Email or IRC depend on the recipient (or their mailserver) being online at the time. GMail doesn't host your content for anyone else, so they shouldn't* require a license to reproduce it in perpetuity. Yeah, I'm looking forward to the future of E2EE, as long as politicians don't get in the way. For an open source community with public discussions, I don't see a problem in granting non-exclusive reproduction rights to any company. All Rust code contributions are freely copyable under Apache/MIT, so discussions should be freely copyable too. *I haven't read GMail's ToS either, but Google overreaching would not surprise me. Chrome's original ToS had a similar clause giving Google perpetual license for _all content you upload using their browser._ It has since been removed.
Depends on the project. I use `vault` by HashiCorp a lot. Doesn't look it's possible in your case. You can: 1) Relay on OS built int mechanisms (i.e. Keychain in macOS) 2) Encrypt data at rest with a master password and as the user for that password every time or adopt sudo technic and ask password only after a certain time. As many said hashing is a one-way operation, so it's pointless here.
I'm personally radically in favor of free software (e.g. GPL2+) including for political purposes. However, I am always practical and *strategic* in my political considerations. Is a chat platform where I want to expend my energy when working on a language that is going to improve the state of software in general? If there was a good chat platform that was FOSS that fit our needs I'd be happy for us to switch.
I'm not convinced. Having the language prevent abstractions just forces developers to spend all their time in the weeds messing with whatever detail the language is forcing them to pay attention to. It's just like the lack of generics or operator overloading in Go or the lack of reader macros in Clojure. It's basic functionality being excluded because "someone might abuse it", and the result is that there's no way to abstract away worrying about ownership and heap copying for every single expression in an entire program.
My understanding is that QUIC is still a stream transport, and doesn't allow you to control how unreliable some packets can be. I.e, sometimes you don't care if packets are out of order, or have dropped, whereas QUIC will always provide an in-order reliable stream of bytes. Unless I am mistaken! There was a great article by gaffer that explained this and other methods: https://gafferongames.com/post/why_cant_i_send_udp_packets_from_a_browser/ I'd just like to be able to send raw packets from a browser in a non-opinionated way :)
My only real complaint about the future method is that it's not a method, and using method syntax might cause people to expect it to act like a method. I'm a pretty big fan of the method macro. It's not special, and the feature you need to add to get it to work can be useful elsewhere.
I'm warming up to the idea, just because it looks cleaner. With syntax highlighting, maybe it'll indicate that it's a special reserved word. But I see your point too. Honestly I'll just be happy when any decision is made.
This was my first reaction, including a slight bit of trust lost in the lang team that this was so prominently featured. I then decided to be a bit more optimistic and instead treat it as a strawman to get brainstorming / discussion going for how to make postfix work and posted some suggested iterations. I sure hope they are being open minded to the negative feeling some of us have around implicit field access and don't just brush it off or say it is too late.
On the contrary, I would say implementing WSGI is the _easier_ part of this endeavor. The spec is actually pretty easy to follow and I'm not even a Python developer. Implementing it as a Python module in Rust would be the more difficult part, I can understand if you'd like to avoid that. However there are projects like [rust-cpython](https://github.com/dgrunwald/rust-cpython) and [PyO3](https://github.com/PyO3/pyo3) which try to make it safe and easy; the latter requires nightly for specialization. Barring that, the Rust HTTP server you're talking about implementing would basically perform the same function as nginx, so if that's what you want to do then knock yourself out I guess. There may be other functions that nginx provides in this context that I'm forgetting though.
I have run into similar problems trying to wrap existing C apis, and am sympathetic. It sems if your C library maps well to rust idioms, yes, it is pretty painless, _however_ as soon as you have a more complex problems that don't map well to rust objects your only resources are an endless list of tutorials showing you how to call a C function similar to `int add(int a, int b);`. What makes this particularly frustrating is when you ask for guidance on how to deal with non-safe limitations imposed on you via FFI, the answers you initially get assume there is some kind of XY problem going on, then end in "try not to have that problem", which like, doesn't really help you much. To try to be constructive, it might be useful to create a list of code patterns that _don't_ map well to rust idioms and show some examples of the best ways to deal with them (or just advise to abandon all hope on some things). I'm fine with rust not doing everything, it can just be difficult to tell what a good solution to certain problems looks like.
You can also look for beginner projects started by other rustaceans (they occasionally pop up in this subreddit, like karaoke-rs). Trying to understand code written by other people is a good exercise in my opinion, and even trying to contribute to those projects can help you becoming more fluent in Rust. Remember that being fluent in a language takes a lot of work and time, so you need a bit of patience. However, as you go, your skills will gradually increase and the quality of your code will become more and more high.
I wonder what is the main takeaway we should take from this experience. Is this more about design choices for wl-roots (perhaps a less ambitions design might have worked?) or is it something about Rust that is making it particularly painful to interface with the C code?
After reading the whole thing, I'm hoping for postfix await macro. At least with a macro it will be clear that there's some sort of codegen going on. I agree that making it look like a field access is the worst of both worlds.
I’m of the opinion that the best thing to do would be to stabilize the await-macro and defer the actual syntax for now. That was what happened with the try macro, and it worked out well. The most important thing is to stabilize the functionality, it could be smart to wait stabilizing the final syntax.
People ARE updating IRC specification, at https://ircv3.net/. It's just that progress is slow.
Implementing [Handel](https://github.com/ConsenSys/handel) in Rust. Today I got the traits for the network interface and a network simulator finished. It uses futures and hopefully will just plugin with Tokio (with some routing layer). Yesterday I implemented the [BLS](https://github.com/nimiq/bls/) signature aggregation and aggregation traits, while my colleague actually extended the Rust implementation of BLS signatures for our needs. Maybe still today or tomorrow I will work on the [San Fermìn](https://ssl.engineering.nyu.edu/papers/cappos_sanfermin_nsdi_08.pdf) aggregation protocol and later extend it to Handel (i.e. add byzantine fault tolerance). Altogether I will be programming Rust 3 weeks straight with no distractions. We flew in last Thursday and we've been programming from 9 am til midnight every day - just minor breaks to eat and cool down in the pool :) We're working on the new version of our web-native blockchain, which will use Proof of Stake - and that's where we need the signature aggregation for. Most of it will be written in Rust and compiled to Web-Assembly (and native for nodes that need high performance, such as validators). We actually already have an experimental Rust version (and a stable JS version) for our current blockchain version. We got it that far last time we hacked Rust for 3 weeks straight - very fun, can recommend! BTW: my code can be found [here](https://github.com/nimiq/handel-rs/tree/janosch/prototype) - but it's work in progress ;)
I like the postfix macro syntax a lot, especially if done in a generic way. The real discussion is if we can replace `?` with a postfix macro too. `.ret\_err!()` perhaps?
Yeah, burntsushi was once asked if it was possible to write ripgrep in C++ and said yes, but he wasn't up to maintaining that. That said, I can fully understand OPs problem, because of network effects Wayland has a lot of inertia and we're not going to replace it with a more Rust-friendly protocol anytime soon.
I hope people don't seriously consider postfix operator as a way? We don't need any more magical operators aside from `?` because it would make it a nightmare to read code so having `my_task().await()` would make it look retarded unless `await` will become a method of `Future` that is implemented as trait extension. I'd prefer having `await!()` macro rather than postfix operator that would weird the shit out of me.
I, personally, disagree with the concerns I've heard about Matrix; specifically, I think the moderation story is pretty good and getting better. However, it's clear that the Matrix platform doesn't fit the needs of the project at the moment.
I haven't tried it so I cannot comment on Matrix.
You could publish your fork onto crates.io, or fold it into your main crate as a module rather than external dependency.
I really think sticking to macro style is a good idea. The macro can solve all the prefix/postfix problems well enough and the meaning is immediately apparent. If somebody is butthurt about making the additional effort to type an extra exclamation mark and a left paren, they're just being juvenile.
Neat, thanks for the info!
Putting aside syntax question I believe people miss that `await` should be applied to expression when favoring postfix operator
Dang, somehow I totally missed that. Thanks for pointing it out.
As a related aside, I went to one of the largest universities in my state that supposedly had some of the “best” IT courses in the southeastern United States. Most of what they taught in CS was Java, C++, and .net So, it’s not your community college—it’s just college in general. Degrees in this field rarely make sense. As the lead front-end dev and hiring manager for programmers at the company I work for, I can confidently say that the people I interview with degrees have been all but completely useless compared to the self-taught freelancers with no formal experience.
I believe people do not consider that `await` operator should be applied to expression rather than value, and therefore favor postfix
&gt; At least with a macro it will be clear that there's some sort of codegen going on. So why don't we scrap `async fn` while we're at it and adopt the `#[async]` attribute macro instead? That would signify that the other prominent part of the async/await pattern is just glorified codegen that turns the function's logic into a future machine. I understand your reasoning, but there's no need for users to understand that it expands to more code. For example, `?` is also just syntactic sugar for a pattern that can be expressed with a `match`, but people only need to know how it behaves and most won't care about how we used to write it.
Actually, the concerns were that folks couldn't _find out_ what the moderation story was when we were evaluating it a year ago. They actually sent some of us a draft of thorough docs on mod functionality yesterday, so this is improving. (Though you'd have to convince individual teams to switch to Matrix, which at this point may be harder since they're used to things. The accessibility argument is a strong one)
I mean, we use Zulip too, and some teams are still on IRC (and may stay, on Freenode). I don't see any kind of lock-in here, this is very much a per team thing.
Surely it'd be `.try!()`? In any case, I doubt `?` is ever being replaced, but I agree that `.await!()` seems like the best postfix option, since there's zero confusion with regular method calls and field access. More so if someone can confirm a future implementation of `await` using a future postfix macro feature would actually be feasible.
Working scrollback and user persistence are some pretty hard requirements for us. You need stuff being stored on _some_ server for that. Could be our server, but that also involves running our own stuff, and we barely have the bandwidth to run the infra that we need to support development.
wlroots' design is considered very good by the Wayland community in general. It's not really ambitious. The issue is how to build a safe Rust library to build a compositor (see the output hotplugging example).
Re-using the syntax for methods/attributes, especially if we introduce macros in method position, is definitely going to contribute to the language's weirdness. Maybe keyword highlighting will help when picking out `await` from normal accesses, but I personally find it unreadable in situations where that highlighting isn't available. *Please* seriously consider postfix `@`! I personally think it is the most readable (easy to pick out of a line of code) and easiest to understand how it interacts with `?` and `.`. It also is the most concise option, and its behavior is very similar to that of `?`. let w = foo().await?.bar; let x = foo().await()?.bar; let y = foo().await!().bar; let z = foo()@?.bar;
https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/
Probably think about renaming it catalog? (cat-a-log) Would be easier for me to type, you keep the cat and it actually tells you what its about :P
I think it's generally accepted that a BS/CS is considered the "troll toll" of the software industry which is why experience is also required for most job openings. I guess most larger organizations will expect to train CS undergrads applying for junior positions in their specific stack technologies. People chalk it up to lazy HR departments but I'm wondering if it's actually CS undergrads perpetuating this; if you started your career with a BS/CS then you're going to expect anyone you hire to have one too, aren't you? I'm sure the schools are complicit in this. It's funny, though--I think software development is the only "engineering" discipline where you're expected to obtain a Bachelor's of _Science_.
&gt; Reference counted handles would probably have been fine, but Rust goes it of its way to make developers feel like runtime memory management is slow and bad If Rust pushed more APIs towards reference-counted handles by default, it might split the ecosystem a bit between crates that works with `no_std` and crates that are ergonomic with regular allocating code. Right now most code that doesn't obviously depend on `std` tends to work with `no_std`, which is pretty cool.
Some Rust teams already use Zulip. The discord is only some of the teams.
One of the biggest things that seems to have been ignored so far in this thread is cost. FOSS systems cost in: - hosting resources (servers, backups, bandwidth) - staff resources (moderation, software updates, security etc) - community engagement (IRC, Slack and Discord are already installed and well known) Until someone offers a truly free system, how are projects like Rust supposed to fund such infrastructure?
And pretty much the only argument against keeping prefix macro that I've seen is that `await` is a keyword, but that seems like a really trivial argument.
Catalol perhaps?
Unfortunately, I'm one of the last people to ask about safety, so someone else will have to give feedback there. (I only trust myself to use `unsafe` for the absolute simplest of calling into functions already wrapped by crates like `libc`.) The main thing I'd suggest is including the output of a benchmark run in the README.
I agree. I though a big part of the argument that macros should always end with an exclamation mark was that macro invocations should be unambiguous. So await! and await are different things.
Still working on the [Rho](https://gitlab.com/tsukurou/rho-lang/rho) language, as a way of procrastinating as final exams are approaching ... This week I'm going to be implementing the compiler part that parses the syntax and converts it into an expression tree (which I discovered is [not a new thing](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/), even though I did come up with the concept on my own). This is an incredibly new area for me; though I understand the basic concepts of language parsing, I'm not aware of the most efficient ways to implement FSMs. I originally thought about writing it as a non-deterministic version which would make adding changes in the future simpler, but that does come at a performance cost of linear complexity with respect to number of states for every character consumed. On the other hand, a deterministic FSM only needs to update its current state based on the given input, which gets partially optimized to a lookup table based on the enum discriminant. Maybe I could use procedural macros to declare it non-deterministically and generate an equivalent deterministic machine at compile-time - that's an interesting idea for a crate, now that I think about it. I also don't know how to fully leverage the features available in Rust to optimize it and minimize number of allocations, copies, etc. I guess I'll just have to put something together, see how it performs, and work from there. Not going to try JIT just yet, but I'm definitely interested in writing that in the future and seeing how it compares.
&gt; If it's not IRC (or something like IRC) I can't use it. Does Zulip work? It's open, but the primary client is web based. We have a server on http://rust-lang.zulipchat.com/ used by some teams. I've been eyeing Matrix as well, they're improving on their moderation documentation but there are some other concerns about capacity (maybe? I've seen various concerns crop up over time, I haven't myself encountered this one) The primary driver behind the decisions to switch to Discord and Zulip was not "prettier and cutesy emoji". IRC has proven very hard to moderate, and it's become an inclusion problem to keep running official things there. Plus, the lack of persistence (both scrollback-wise and the fact that there is no easy standard way to log out and still be pingable) becomes a problem for being able to get anything done in a distributed org. Last year individual teams experimented with a bunch of platforms and ended up mostly on Discord and Zulip, which are both easier to use and easier to moderate. That said, I recognize that in this process we have made it harder for folks who use screen readers. I'm hoping to eventually get us onto something that works for everyone (This might still be Discord, if they make their app work better on screen readers or start allowing third party clients). If you know of any specific non-IRC systems that are good with screen readers (and have persistence), let me know!
Sorry, I meant wlroots-rs instead of plain wlroots (＃＞＜) I wonder is the difficulties the rust wrapper encountered were more due to trying to make things safe (in which case giving up and embracing unsafe rust would be the natural solution). Or if the difficulties were more due to trying to be idiomatic and/or efficient, in which case runtimd tests and dynamic memory allocation might result in a simpler API
Honestly I feel like threading works great for deep technical discussions, and kinda becomes confusing -- at least the way Zulip does it with "streams" -- for everything else. (This reflects why the compiler team uses Zulip but many other teams use Discord)
&gt; It's just like the lack of generics or operator overloading in Go [...] It's basic functionality being excluded because "someone might abuse it", Can't speak for Clojure, but isnt it because Go is intended to be a very simple, very quick to compile language? Generics take up compile time. IIRC the go compiler does minimal, if any, optimizations at all for the same reason, which is even *more* basic than generics.
&gt; Window managers aren't count-every-clock-cycle performance critical. They should be IMO. At the very least they should get memory right. Something that low in the abstraction stack and so fundamental to the system should not be wasting resources, as much as feasible. &gt; but Rust goes it of its way to make developers feel like runtime memory management is slow and bad (e.g. you frequently have to .clone() to pass an Rc or Arc). That sounds more like a personal misconception than a problem with rust. If a developer thinks `clone` == slow and bad, thats their problem?
I can help you, even though this isn't r/playrust I do know a bit lol. Look for servers with the keywords "just wiped", "fresh wipe", or a very recent date in the title. The older a server gets, the more scarce resources become because they don't regen (AFAIK), and you'll be closer to equal footing with everyone else because they'll all be starting from scratch too.
This is bitchin! Thank you.
Void linux, Firefox, with the most common font packages installed (dejavu, liberation, etc). Negatives and superscripts look just fine for me: https://imgur.com/eKcZt46
I'm working on an RFC to normalize pique, peak and peek to just peek. That's how everyone uses it anyway.
I haven't really taken a look at your code, but I'm going to take a guess based on past experience with OpenGL, anyway. OpenGL is a stateful API, which tends to be problematic because small differences in what operations are performed frame-to-frame can produce unexpected results (obviously a major problem and one of the motivating factors for adoption of the modern low-level interfaces; Vulkan, et al.) Graphics API calls tend to be expensive, so applications and frameworks will often try to avoid doing redundant state changes. The problem occurs when you start sharing your context with external libraries (i.e. SteamVR). The external library has to modify state to operate, but doesn't have the information necessary to restore the state expected by your application. Specifically, if I had to guess, it's something like the following: 1. glium sets up the texture bindings required by your application 2. The application does roughly the same operations between frames, so the bindings are expected to persist (meaning glium doesn't try to re-bind textures unnecessarily) 3. SteamVR binds a different texture to do composition, breaking the above assumption In general, I'd highly recommend using a graphics debugger like RenderDoc when you encounter these sorts of issues. Ultimately, we can guess all day what the problem is, but it'll only take you a few minutes to load up the application in a debugger and actually inspect the state.
The Linux kernel being GPLv2 isn't *really* that big of an issue. Very little code actually *links* against the kernel outside of 3rd party kernel modules, which have option of having GPLv2 compliant licenses or not. Most of the kernel exports are GPLv2, meaning that 3rd party kernel modules that wish to use those exports must be GPL2 compliant. However, there are a subset of kernel exports that are available under more permissive licenses - that's a large part of why old proprietary nvidia drivers were garbage; they weren't able to have full access to the kernel exports. This was actually an issue for zfs a while back because the linux kernel removed some non-gpl2 exports that zfs relied on because they weren't being used by any of the builtin modules any more. There's a lot of other legal issues around zfs and linux, but this was a recent relevant issue. GPL2 is specifically an issue for linking against other libraries. GNU has tried to argue that executing a GPL2 program from another one falls under "linking" but as far as I know there's no precedent there in either regard. Where things *really* start to become an issue is when things are AGPL2, which forces you to relinquish patent rights to the software you right, and has the same copyleft design. This is horrible for companies that want to use open source software, as it reduces their ability to control their IP. If you're wondering about syscalls and whether those are considered linking, there is an exception in the linux license that makes syscalls not turn your application into a GPL2 application. There's another exception for gcc. You can see those here; https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/LICENSES/exceptions
There‘s still value in distinguishing it from fields and methods syntactically though, and macro syntax is the best we have unless we are introducing new symbols.
Geez. I think I'll just keep doing systems programming and stuff — this looks way too hard. Maybe I'll go back to X where things are easy. Beautiful chart!
For the problem of threading a global through tens of functions, I suggest you: 1. take a look at `config` crate, which maintains a global config variable for you 2. learn about functional dependency and normal forms from database, and see if you can break the global dependency up into local dependencies
`await` could be spelled `...`: `await!(fut)?` -&gt; `fut...?` `await!(fut?)` -&gt; `fut?...` bikeshedding is fun
Technically, `@` isn't a new "symbol" in terms of it being a punctuation token, we're already using it in match expressions. Besides that, even if it were new, would that argument have stopped us from adding `?` when it was a new symbol?
After all this it is clear to me that nobody has any idea as to what will be best for the language. And with the 1.37 release as a deadline I am afraid the decision might get rushed. I can't say much about which is better except that postfix is too much magic and somehow weirder that other languages, so from my perspective this is the choice that goes over the weirdness budget. At this point I am also in the camp of just stabilizing the macro and naturally evolve from there. There's nothing wrong with await as a macro and not using it just for the sake of not using it when there's no clear decision on what to replace it with seems unreasonable.
Indeed, can't use on Mac. I have planned to see if it's worth it to set up a docker build just for linking -- the question would be -- is spinning up docker on my macOS dev environment and building in docker faster than the local macOS build.
Hey guys, so I've got a vecor full of u8's, and i want to convert this vector into a string while keeping the byte values as integers. So i go from [101 34 97] to "101 34 97" if that makes sense. Im having trouble figuring out how to do this without immedietly converting the bytes back into chars. Thank you!
You can use `.join(" ")`: assert_eq!(vec![101u8, 34, 97].join(" "), "101 34 97");
rust-doc is trash, not windows, retard.
You are definitely missing something, but we'd have to see your test code to know what.
Afaik they contribute patches to freebsd.
Rust and the tooling around it are open source, if they are so trash on your favorite platform feel free to improve it. In general Windows support for programming languages is trash, except for languages integrated with Visual Studio. Installations in Windows are usually pretty bad too because of the platform. Most Rust developers don't work on Windows so I wouldn't be surprised.
I am surprised there is support for either of them. The only real requirement I have is that it _doesn't look like existing syntax for something normal_.
Poor Windows support for programming languages has nothing with the fact that rustup is complete garbage and you're a fucking retard.
Do you mean postfix _only_ for `await!()`, or a kind of ["uniform function call syntax"](https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax) for all macros? I'd be pretty happy personally (ignoring all the other arguments for different options) if I could choose between either `let res = await!(future);` and `let res = future.await!();`.
I suspected the OpenVR might be confusing glium, so I ended up deciding to switch to gl-rs, just to ensure problems of this nature can't occur.
I actually really like `.await!()` - it's distinct from everything else, and opens up a design space for postfix macros (`.try!()`? `.trace!()`? Yes please!). What really worries me is the 1.37 deadline - postfix macros seem like a big, potentially scary feature in their own right, and with a deadline this tight, I'm worried it'll get discounted based on the amount of work required.
I don't understand the error handling problem; in particular I don't really get what's so egregiously terrible about `(await http.request(...))?` that it considered a major launch blocker.
Reading the The Await Syntax Write Up document made me happy. There are a lot of trade-offs to be made in settling on a specific syntax and balancing these naturally leads to some disagreement, but I can't think of any group of people better suited to find the right solution.
Nice, where can I follow your project? :)
You seem like a nice human being.
Zola is such a nice tool - not only is it in Rust, but I find it's markedly better for most of my use cases than anything else.
And what's point of your retarded macro? We already has `Try` operator, there is no need for another one. Instead of adding more complexity, for no reason, we should consider a syntax for `await` within existing practices.
Trying to make a site that generates fake companies/logos/text/etc. for UI design practice. I took the opportunity to delve way further into use of types and generics, and (somehow) running across a use case for GATs, which was cool because I didn't even realize what they were until I had a problem that required it as a solution. Also it's been two days (yeah I'm a slow 0.1xer) and I haven't yet traditionally run the program since I can guarantee what I have so far with just tests - which is awesome.
Did you get a chance to share in the Amethyst discord? I bet the folks there would love to see it
Well shoot! Didn't know that. The visual design puts me off a bit but I haven't seen in a while so it may have improved. UX concepts were very neat
I wish `?` was a postfix `.try!()` macro. So much easier to discover what it means/does (? Is not googlable), your ide could ever give docs about what it is.
&gt; The rest is battery included as the standard library is extremely rich. I haven't heard this before =P but I sort of agree.
Huh, anti-business is one of the reasons I like the GPL ;) Moreso with me is that it's cancerous and I don't like restricting the end user would my decisions.
&gt; So why don't we scrap async fn while we're at it and adopt the `#[async]` attribute macro instead? I... actually think that's a good idea...
:) Well I guess it's a personal experience for me, at least. For example, when I'm doing Node.js, I tend not to use functionality out of what I shipped with Node.js, I rather turn to the community. For example, I usually take \`fs-extra\` and not just \`fs\`.
We could get rid of the retarded operator, that's the point!
Will it not be really rare to await on any expression except a function call? Those rare cases can be handled with parenthesis around them.
`file.async_read().await!().try!()` and `maybe_promise(a).try!().await!()` Perfect.
To add on that, if it was also directed at me with wayland-rs, one can pretty well see from the docs that the API of the `wayland-client` crate is pretty different from the API of the C `libwayland-client`. This is what motivated my [rewrite](https://smithay.github.io/wayland-rs-v-0-21.html) as pointed in the blog post: my initial goal was to provide bindings to the Wayland *protocol*, and being limited by the constraints of the C library was just highly frustrating and limiting when designing a Rust API. So from this version I shifted my design principles: rather than bind to the C library as well as I can, the Rust implementation is now the main driver of API design, and I retrofit the C implementation into this API even if it means runtime cost. (wayland-rs is a double-backend crate, and a cargo feature selects either the rust implementation of the protocol or the C bindinds). I apply the same reasonning with Smithay (and I think u/Drakulix will agree with me): Yes we are kind of re-inventing the world where other mature projects (wlroots, libweston) already exist a do a very good job, but starting with rust designs principles from the start means we are exploring the design space in a very different way, and Smithay's API as a result ends up being very different from wlroots or libweston. Ergonomic design in C and ergonomic design in Rust are quite different, and they often don't mix well. wlroots is a very ergonomic and powerful library from the point of view of a C project, but as u/\_Timidger\_ illustrates in his blog post, it is nightmarish to bind to Rust in an efficient and ergonomic way. The notions of ergonomy of both languages are too different. If there is one lesson I've learnt from these years working on wayland-rs, it'd be that one: If you want to bind a C library to Rust in an ergonomic, don't build your Rust API as just a safe version of the C one. Rather try to design a Rust API that matches the *functionality* of the C library, but in a way that feels natural in Rust, and then figure out the way to do the plumbing in between. Low-overhead wrappers does not necessarily mean that the final API will be similar to the original C one. And introducing some runtime costs in non-performance-critical code to improve the ergonomics of the API is a trade-off that I think is generally worth doing.
The summary on dropbox was archived and no longer visible. Was that intentional? I have it opened in a different tab if needed.
Hmm.. UFCS for all macros by default... `"Answer: {}".format!(42)` has a nice Python ring to it. I like it! That way you can always use the 'prefix' version `await!(&lt;expr&gt;)` or the postfix `&lt;expr&gt;.await!()`.
I don't have a strong opinion either way, but I find it a bit strange to rule out sigils if one is considering postfix field-like syntax. People's expectation about await is that it is a prefix keyword, so anything but that is already confusing, making the point moot IMO. If I come from another language and can't use prefix async, I would have to read the documentation anyway to be able to write async code in rust. If I read rust code I would know that I don't understand what the code means with a sigil and can look it up. If I see ".await", I'd assume it is a field access when reading the code. With a method call I would guess that some code is called that awaits something.
Why do I have to login to Dropbox to see the design summary? Can someone export it and rehost?
&gt; GMail doesn't host your content for anyone else, so they shouldn't* require a license to reproduce it in perpetuity. Gmail needs a license to make derivative works so they can index, a license to reproduce so they can make backups, and a whole bunch of other stuff.
Lack of consistent API guidelines.
https://pastebin.com/VrdH0UDN
Wrong subreddit.
There is broad consensus that Rust should do _the right thing_. The problem is in defining what the right thing is, in this case. The options are irreconcilable: nobody argues that the language should have two fundamental ways to perform a single operation. I'm happy that they're imposing this deadline. This has been in debate for months. Everyone has their opinion, and few people are changing their minds. I have my own preference, but at this point, I'd rather get _anything_ stabilized than get _my thing_ chosen.
Pretty sure you can google "question mark" and provide documentation for arbitrary line/column indices in LSP and IDEs.
If I had to guess, when moving `std::ascii::AsciiExt` methods to be inherent methods, the `&amp;self` parameter was copied, and nobody noticed.
Add a k and now your Kool Katalog
Yes an Joel talked 19 years ago about a very specific case where you both: 1. rewrite from scratch 2. are in an industry where maintinaing/growing market share is extremely important Rust can be used in incremental rewrites and are you in the second industry?
I read the `#design` discord channel, and trying to follow 6 people talking in groups of 2 about new feature suggestions while another person was asking a "how do I solve this question" was a true mess.
Have you looked into Albert (https://github.com/albertlauncher/albert) Afaik it can index files, apps, Mozilla bookmarks whatever (it is extensible). I'm not sure if it would live up to your performance expectations, but it works fairly well. Doesn't look anything like 'everything' though.
Seems logical - do you think it'd be worth creating a merge request changing all to `&amp;char`? Predicates in Rust (e.g. `Iterator::filter`) all seem to accept `&amp;T`, thus doing so would enable us to perform easy filtering on character streams (e.g. `chars().filter(char::is_ascii_whitespace);`), but that seems too easy and so maybe there's a catch here I don't see now :-)
I think that it’ll be best to ask this question (about a PR) on the internals forum
Thanks 🙏
Isn't that a breaking change?
Your statement is still wrapped in a Result and you will need to handle that by either unwrapping it (the dirty way) or handling the error.
No, it doesn't matter how rare it is, What matters is that `await` operator should operate on expressions rather than values and therefore only available formats should be: - `await &lt;expression&gt;` - `&lt;expression&gt; await` Async function invocation is just expression too after all
IIRC we did notice, and kept it identical in order to stay compatible with the existing stable `AsciiExt` methods.
it is breaking change
I think it’s really jarring to have an otherwise pipeliny syntax have some prefix bits. You read from left to right, but then need to jump to the left again. This might not be a big problem when you use combinators (is that the right word for `map` and friends?) and limit yourself to one `await` per line, but I’m still not a fan of wrapping long stretches of code in parentheses.
You're just not doing enough work in your threads to offset the overhead.
Isn't the same thing true of every control flow statement / expression? Wouldn't `5 + 4 return;` make more sense, in that case?
&gt; This is easy enough to imagine: all it takes is a yank of the display’s power cord and the monitor goes away. This is basically the exact opposite of the Rust memory model. Doesn't this just mean that you have to check whether the monitor is alive before performing every single operation? struct Monitor; impl Monitor { fn foo(&amp;self) { assert!(alive(self)); ... } fn bar(&amp;self) { assert!(alive(self)); ... } } or if you want you could just have those return `Result`.
Have you tried using `--release`?
I'm sad as well for the disparition of the `@` option, but the team has made a choice, and that's it... &amp;#x200B; I aggree with you, tho : the method and field postfix notations are misleading and weird as hell.
&gt; nobody argues that the language should have two fundamental ways to perform a single operation. `await!()` and postfix `.await!()` would work pretty well together...
Most likely a historic reasons. Performance wise it would make a little difference
You could write an async function (i.e. one that returns a `Future`) and block on polling it when you want to call it from synchronous code since it's a 0 cost abstraction
The best pattern for IO functions is probably to make them all `async`. Then call `.wait()` on them in sync contexts, which will simply block until the future resolves.
The `.await` syntax is by no means a strawman.
&gt;`await` is first and foremost a *control flow* construct, like `return` and `break` I don't see how `await` is related to the control flow of the code. Both `break` and `return` are used to interrupt the current loop/function, so the instructions after them are not executed. The idea of `await` is that the code continues after it with no changes. It is true that `await` changes the generated code, so it is built as a state machine. But that is just an implementation detail. A lot of users, specially newcomers, will not be interested in the assembly code of their asynchronous functions. Teaching `await` as a control flow structure may be confusing for them.
Consistency with `return` and `break` is in my view rather misleading. In particular, they return `!` whereas `?` and `await` are both "run effect and extract value" operations. *It is consistency with `?` that is paramount.*
`excessively_nested_future... ... ... ... ... ... ...?`
Indeed, the first results are: - https://m4rw3r.github.io/rust-questionmark-operator - https://stackoverflow.com/questions/42917566/what-is-this-question-mark-operator-about - https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html
Thanks for the pointers :-)
Interesting. I hadn't thought of that. Do you know if binding a C library like this prevents me from compiling to Javascript? One of my end-goals for this project is to be able to make a Linux CLI that can be repurposed into a web extension. &amp;#x200B; I'm afraid I'm still new to Rust, so please forgive me if I'm not using the correct terminology.
I'm personally also in favor of taking things slowly, start with existing methods of #[async] attribute and await!() macro. Let people get used to the concepts and only then figure out a syntax to bake it in the language proper. I forgot where, but I remember reading that this was explicitly rejected by some of the core developers of async await. The reason, IIRC, is that it would cause additional churn from macros to baked syntax. I personally don't agree with that, but I don't have a big stake in the whole async story so I will defer to others. I have faith that the Rust developers act in good faith and are actually quite competent. Whatever they end up going with will be of high quality.
In most cases, it shouldn't matter because `char` implements `Copy` trait. So, even if you pass a `char` by reference there is no guarantee that it won't be copied in memory. Compiler can choose to copy that `char` for optimising performance.
I haven't compiled Rust to JavaScript in anger, but if you mean things like Emscripten, there shouldn't be any theoretical problem since Emscripten supported C and C++ earlier than Rust. Practical problem from two languages and two build systems is a different matter that would require actual experience to answer though.
Isn't lld the default linker on mac ?
It matters when you try to use it as a predicate for instance (e.g. when you have another function accepting `dyn Fn(&amp;char) -&gt; bool`, it will allow only one of those two functions to be passed) - and that's the problem I've encountered. It's not a big issue of course (it can be overcome using an anonymous function), but it made me wonder about that difference :-)
Listary
I'll have to check that particular one, but I can already tell you no web client is going to be fast enough for chat from an a11y standpoint, so it would depend on what desktop clients are available. Regarding which alternatives to IRC there are... Jabber would be doable. Things that have IRC bridges, or can be used through Bitlbee, would work. Matrix doesn't have a lot of clients, and they're not too straightforward to make... So far the client can be used, but again, it's not really fast enough. The problem is, a chat application is very highly demanding on the a11y system, because things are happening in real time at a high throughput. If you can read the output, but it requires too much user action, or it is too slow to navigate, it becomes impossible to follow in time. This is a hard problem, that no-one I'm aware of is actually trying to solve, and IRC solved it purely by chance by having so many clients that one of them is bound to fit the needs of a particular access pattern.
This is not quite correct. Yes, all current QUIC frames are supposed to get reliable delivery, but data frames from different streams are not ordered; so if you don't care about ordering you can use a different stream for each packet you're sending and ignore incoming messages on older streams. Plus, some people are working on an unreliability extension: [https://datatracker.ietf.org/doc/draft-pauly-quic-datagram/](https://datatracker.ietf.org/doc/draft-pauly-quic-datagram/) It seems likely that in the future WebRTC will also to some extent be rebased on QUIC anyway, so investing in WebTransport (modulo timelines) would be useful, I t hink.
Is going via WASM really the right way, though? Is there a comparison between doing it this way and using CFFI somewhere? I'm looking for both usability and performance. I'm not sure my rust is good enough to make this comparison myself.
I'm not sure I understand this, the "member access operator" (aka as `.` also operates on expressions.
To me it matters how rare it is. If something is rare, the syntax can be verbose, if it is common you want a shorter syntax. Your p.s. contains an example of just that. "if" isn't needed with "match" being available, but it is so common that a shorter syntax is needed.
This is very sad. I was hoping to use this library. Looks like I have to write it myself. Luckily, the SVG text layout it way simpler (no paragraphs, no caching, only lines).
Maybe it is not true any more (I have not worked with such things in a while), but latency was lower with sync I/O, sometimes making it preferable.
It really isn't a zero cost abstraction when you compare async code to sync code. For a single async read you have at least two system calls on unix, no? Also some more CPU usage when the future is move to the reactor etc.
How many lines of code is the large project that takes 30 seconds to compile?
it's right there in the title
I gave a hasty response earlier because I assumed `.join(" ")` would work but it only works with vectors of strings, unfortunately. I retracted it and waited a few hours for someone else to take the opportunity to respond, but none have so I'm giving it another shot. If you don't care about the actual formatting of the string and you just want to see the numbers, you can use debug formatting on the vector: let s = format!("{:?}", vector); println!("{}", s); And that would give you `[101, 34, 97]` from your example. If you want to format the numbers exactly like you have it, there's not really an optimal one-liner solution without reaching for an external crate. To avoid intermediate allocations, you can use the `write!()` macro with a string target, e.g.: // allocate the maximum size that `vector` will take to display let mut string = String::with_capacity(vector.len() * 4); for byte in &amp;vector { // trailing space is the separator between bytes write!(string, "{} ", byte); } // remove the trailing space for the last element string.pop(); // optionally, free the excess capacity string.shrink_to_fit(); You also _could_ use `.join(" ")` by converting each byte to its own string first, but this will incur an intermediate allocation for every element as well as an intermediate vector each byte-as-a-string (in practice this will be negligible for small vectors unless you're calling it in a hot loop): let string = vector.iter().map(|b| b.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(" "); Alternatively, [itertools has a function that does exactly this](https://docs.rs/itertools/0.8.0/itertools/fn.join.html), however it's a somewhat large dependency to bring in for just one function: Cargo.toml: [dependencies] itertools = "0.8" In your code: let string = itertools::join(vector, " "); Itertools has many other utility functions and extension traits you might find useful, however, so it may be worth checking out anyway.
The summary link to dropbox requires me to login... Anyone have a mirror?
https://youtu.be/mrpIch0Qrpg Cause somebody are interested in this project, so I decide to post a video series about how to write a simple one totally from scratch, so If you have interest, give it a check, hope it can help u, and feadbacks are really welcome ;)
1) What? No. The result of build is two everything-statically-linked Win32 .exe, with icons and all: server.exe and client.exe. They are deployed with PowerShell Remoting, but it boils down to copying a few files. Docker is for Linux CI because it's convenient. 2) We do extensive logging for postmortem analysis. For monitoring, flesh and blood people sit in front of GUI. We also play sound when something worthy of attention happens. 3) We use C++ [readerwriterqueue](https://github.com/cameron314/readerwriterqueue) as packaged in vcpkg. It's SPSC. It's amazing! It is used to defer all non-critical processing. I am not sure about Rust's built-in channels: they don't seem convenient to use from C++, which is necessary. 4) I am not sure what you are asking, but it's a single process (okay two, for server and client).
The Rust community has had the luxury of working without time constraints. This has been a long, drawn out process intent to make the best long term decision possible. Whatever decisions are made at this point about syntax are based on careful, well-informed considerations by the best people to make the decision.
True, but how many functions do you have that sometimes need ultra-low latency, but sometimes don't?
Why we ever need to mess with async/await special syntax at all? Is it possible to implement something like Kotlin does? From my point of view, being able to just use the same code in sync and async contexts is a huge win.
This seems useful for cross-platform distribution. For performance, Rust WASM still may be fast enough.
*Not* viewing `await` as a control flow construct is more likely to result in bugs. It's not an implementation detail: `await` yields control to somewhere else in the program. This is super important to be aware of if you use mutexes of RefCells or any other kind of internally mutable state, because if you hold a mutex across a yield point, you're guaranteeing deadlocks in the futures model. In every respect it is a control flow construct, just like `return`, you don't need to look into the assembly for that to be relevant.
As someone who's new to rust and was planning to play with some networking this weekend, should I defer from reading [this book](https://rust-lang.github.io/async-book/getting_started/why_async.html)? My general understanding is that Futures are what's akin to Promises in node and `async/await` just builds on top of it?
And you seem like intelligent person ad homs just because you didn't like the truth.
I think `return`, `continue`, and so on are well suited as prefix, as they have special, flow breaking behavior. `?` does that too, but only in exceptional cases, so the normal flow is to stay in the pipe. `if`/`else` and `match` accept blocks which are often Multiline, so it makes sense for them to be prefixes too. I think postfix macros could be a thing. We didn't do them when `try!(thing)` became `thing?`, but adding more punctuation is confusing, so I'm in the `.await!` camp.
Yes
&gt;It's not an implementation detail: `await` yields control to somewhere else in the program. The same is true for system calls. For example, in a multi threads program, if you try to read from a socket, the kernel will block the current thread until data is available, and another one will run. Just like futures, you have to be aware about mutexes, RefCells, etc. So, using that definition, most syscalls are also control flow constructs. Someone may argue that it is much easier to deadlock with futures, but in real world programs the difference will be very small, since executors could spawn threads as necessary.
Maybe not on it's own but rather as a fallback for platforms currently not supported by rustc
This would be backwards incompatible so it would never be accepted.
That’s a very dangerous view of how multithreading works. Context switching can happen at any time a thread is running if its timeslice expires, at the resolution of individual machine instructions. In a multicore computer multiple threads from the same program can run concurrently even without context switching. I don’t think it’s useful to call every machine instruction a control flow construct.
One of my initial ideas was to go somewhat more networked than you did: I envisioned the system being useful for a karaoke club with up to a few dozen rooms with all of the files streamed from a central server. Shoving everything into an OGG container would mean that a song would be completely self-contained: no worries about losing the cdg file, and if I later add support for [Kate](https://wiki.xiph.org/OggKate), or Vorbis audio, the decoder wouldn't need to try fetching multiple streams. Regarding the new version of Image, I don't have time to do it now, but if you send me a PR to update the dependencies, I'd happily merge it.
I dunno, I don't think including a roadmap can hurt and it'll probably increase the likelihood of contributions by offering some ideas/guidance for the future of the crate/repo/project. Also nice tool, just cargo installed :)
Persoanlly, I like roadmaps/to-do-lists in my projects - mostly so that I can keep track of it myself wihtout needing to use a separate management tool for a short feature list.
I'm slowly drifting away from Rust and into the language that I'm bootstrapping from Rust. That language is a strictly imperative, procedural, non-OO Rust/C/C++/Go/D alternative. I haven't decided about the functional paradigma yet, but there is room for closures if I decide to add them. &amp;#x200B; This isn't strictly Rust related, although the compiler is written in Rust, but I wrote a Minecraft clone in that language.
I think that the document is very well written. Kudos! Personally, I hope they go for one of the "sane" postfix syntaxes. Once you accept that it is a special field, method, macro, you just know how it works. My second favorite is to just keep the macro syntax. But most important: Make a decision and move forward. Really looking forward to it.
The problem is that you need to distinguish between expression and value in general. `await` should applied in general to any expression as any other operator. Expression is first class citizen in Rust and you shouldn't sacrifice it for few strokes. Not to mention, proposed magical postfix operators will introduce more complexity to language which is far worse than _you_ typing few extra strokes
The first problem with postfix notation for await is that you cannot use `await` effectively as operator in this case. Imagine arbitary expression: ``` { &lt;calculate future&gt; }.await ``` So when I look at this code what should I think? I'm starting reading block of code trying to understand what's going on and then at the very end I see `await` which explains a lot of stuff immediately. Now imagine if `await` would be as prefix? When reading code you'll get context immediately. Now you can say that it is my fault to use such long expressions, but to that I can say in Rust expressions are first class citizens and there is nothing unusual about expressions. Even if I put this expression behind `async fn` it would still be more helpful to see `await` at the begging because I'll get context of the code line immediately instead of the end Even in C++ world they settled on `co_await` as prefixed operator precisely for read-ability sake. `await` comparing to `?` performs quite a lot of changes to the expression and it should be seen immediately. Making awkward operator, and as consequence increasing complexity of Rust, for the sake of no-issue (by that I mean error handling) is really bad idea
Almost three years. Wow. :/
Personally really appreciate roadmaps, from the perspective of someone looking to use either tools or libraries. They’re a nice way to summarise the implemented features, show roughly how production ready the software is, and give me an idea of where the maintainers want to take the project in future.
You're not alone: https://medium.com/simply/web-developers-fatigue-90e0e6d40dd5
&gt; I think return, continue, and so on are well suited as prefix, as they have special, flow breaking behavior. So does `await`.
Saw from the link in [this thread](https://www.reddit.com/r/rust/comments/biyl4k/roadmap_to_becoming_a_rust_web_developer_in_2019/) (which I don't want to litter with my beginner questions) that there's both [The Rust Book](https://doc.rust-lang.org/stable/book/ch00-00-introduction.html), which I've been using thus far, and [Rust by Example](https://doc.rust-lang.org/stable/rust-by-example/). What's the difference between the two? I'm only at part four-ish of the book, should I switch to Rust by Example? For context my previous experience is mostly with Python, which I've used quite a lot, and a bit of Java, which I'm just starting out with. I'm building a batch renamer in rust for practice and the stuff that's giving me the most issues has been types/typing, especially converting between types, and that I'm lacking a lot of terminology to properly understand the documentation.
&gt; I apply the same reasoning with Smithay (and I think [u/Drakulix](https://www.reddit.com/u/Drakulix) will agree with me): Yes we are kind of re-inventing the world where other mature projects (wlroots, libweston) already exist a do a very good job, but starting with rust designs principles from the start means we are exploring the design space in a very different way, and Smithay's API as a result ends up being very different from wlroots or libweston. I do agree and isn't that exactly the green-field approach that u/_Timidger_ was asking for in his blog post? &gt; Time would be better spent either working with existing solutions that already have the effort put in to make them correct or to come up with new green-field projects. I expect smithay to be able to provide some very powerful abstractions in the future, that I think will be way easier to do in rust, because of it's safety guarantees. I do not think it is impossible to achieve the same in C, but I think there is a technical reason (rather then only an idiomatic one), that many C-libraries tend to describe themselves as "simple", "easy-to-use", "basic", "straight-forward" or in terms of wlroots "about 50,000 lines of code you were going to write anyway". In my opinion the design space for rust libraries is much broader, then just providing a safer interface. Smithay's story partly feels very similar to u/kyreen 's Lua story, because both are striving for not much less then perfectionism. Instead of going for a best effort implementation with rlua and calling it a day, being sick of memory unsafety bugs had lead to rewriting the next lower layer of the stack in rust as well. The result is something rather unique and interesting from my perspective, no matter if it will succeed or not. I cannot say to which degree smithay will be "done" at any point in time, but I know, that if I will ever build the compositor I am imagining, I am either going to do it with this library or I simply won't. That said, I totally get OP's decision. If my goal would be to get a working compositor in a reasonable amount of time, I would also bet on wlroots. As he pointed out there is more to it, then just wlroots. I have build (currently somewhat outdated) bindings to [libinput](https://github.com/Smithay/input.rs) and worked with u/Slabity on [drm-rs](https://github.com/Smithay/drm-rs), who also reported similar experiences with libdrm. It is a rather deep rabbit hole. Kudos for trying and getting this far!
I really like this! I would go so far and say \`()\` is optional for macros only having one argument (the think before the \`.\` dot). So we could have \`body.try!\` and for an argument list &gt; 1 we use \`()\` like in your great suggestion \`"Answer: {}".format!(42)\` &amp;#x200B; \`macro!(the\_thing)\` -&gt; \`the\_thing.macro!\` and \`macro!(the\_thing, 42\` -&gt; \`the\_thing.macro!(42)\`
What I mean is that they never evaluate (return type of `!`). `await` just pauses execution and returns something when execution is continued that.
That project is long gone because it’s broken but I can say around 20k
This is just the discussion about the final syntax, the model is decided and will stay the same. The author of the book is one of the main people behind this proposal, so the information is all valid. Your understanding is correct.
It's in progress by a GSoC student for Xi project, see https://xi-editor.io/gsoc.html#high-performance-piet-backend
Is there any mechanism in Rust for making breaking changes to `std` at some point? Editions? It seems like an eventual necessity.
When writing a crate you often don't know. I expect async to be used for all I/O, not just network I/O. Even with network I/O, latency is sometimes important when dealing with IPC on the same machine.
But they do not ask for the right to make derivate works or to sublicense.
crates.io has about one full-time developer, spread across three or four people.
&gt; What I mean is that they never evaluate (return type of !). `if` is prefix, and there's also plans for an `yield`, which may return a value. `await` pauses the execution, and returns, possibly on a different thread. That's closer to control flow than to field access.
Wow, wasted 20 seconds of my life searching for an `inbuilt` testing library/crate for rust 🤦 Nice chart though!
WeeChat has some support for Matrix, how is WeeChat from an accessibility point of view?
Nope. Editions purposely don't do it. The only way to make a breaking change to std (according to our API guidelines) is with a Rust 2 release. AFAIK, there are no plans for that to ever happen. Our standard way to deal with this stuff is deprecated and replace with a new API. Something this minor is certainly not even remotely close to a motivation for a breaking change release, and likely not enough to even consider deprecating IMO.
The Rust Book is pretty much the go-to for everyone new to Rust, I would recommend spending some time going over at least Chapters 1 - 6. Rust by Example goes a little easier on the text and tries to display the concepts of Rust through code snippets. They are both great resources for learning but If you are running into specific issues with converting types don't be afraid to drop the question in here. &amp;#x200B; If you visit [the playground](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018) you can write some code and press share to get a link you can post here. That way others can run the code you have written and help you through your issues. It might help if you feel you are hitting a wall.
I really should try Zulip since Slack's implementation of threads is too half assed.
&gt; Someone may argue that it is much easier to deadlock with futures, but in real world programs the difference will be very small, since executors could spawn threads as necessary. That's not how executors work - futures are a form of cooperative multitasking, that means that the executor cannot just pause and reschedule a task onto a different thread if it cannot make progress: instead the entire thread is deadlocked, and the executor has one fewer threads on which to schedule tasks. It can easily happen that all of the threads in the executor's thread pool become blocked, and will never make progress because the executor has nowhere left to run tasks which might unblock them. With real multi-threading, you don't get the same problem with deadlocks because when a thread blocks trying to take a lock, another thread (hopefully the one currently holding the lock) is given time to run. You can't "run out" of places to run threads because blocked threads are taken out of circulation entirely. Let me put it this way: if you guarantee a total order in which locks are taken (ie. if you have locks A, B, C, and a task takes some subset of those locks, it always takes them in alphabetical order) then in the multi-threaded model you will never have a deadlock. With co-operative multi-threading you can still get deadlocks if locks are held across yield points, even if you ensure that within a task, the locks are taken in the right order.
I'm about to deploy our first rust functionality, so this is a great chart to share with the rest of my team. I had to fumble around with learning a lot of these things on my own, which is trickier than with other languages because so many of the devs are not web developers. The one crate on that list that I'd love to use, but just couldn't find a place for, was diesel. Super well documented (for a rust lib), and really does a good job taking advantage of the strict types in rust. My sticking point was its extremely strict typing for the QueryableByName derive. It is way too limiting and "safe" for any custom SQL queries, since MySQL tends to encode anything touched by an aggregate function as a bigint. That forces me to type as 64 bit everywhere, which means I can't use the same struct for juniper as well, which is half of what I've loved so much about rust. I've used mysql_async instead, where the FromRow trait and from_value are much more flexible (plus it has Futures), but I dislike how many of the functions straight up panic! when they should be returning Results. I guess my question is, given you have your ear to the ground, if I want to contribute to a project, am I better off improving the Queryable from diesel, or the return types from mysql_async?
Hi Thank you. I have fixed it like this: pub fn customer_accounts_handler(parameters: web::Data&lt;Parameters&gt;) -&gt; Result&lt;String&gt; { let conn = parameters.con.get().unwrap(); let mut stmt = conn.prepare("select * from customer_account"); let mut s = match stmt { Ok(stmt) =&gt; stmt, Err(error) =&gt; { panic!("There was a problem opening the file: {:?}", error) }, }; let ca_iter = s.query_map(NO_PARAMS, |row| { Ok(CustomerAccount { id: row.get(0)?, name: row.get(1)?, user_name: row.get(2)?, }) }).unwrap(); for customer_account in ca_iter { let ca: CustomerAccount = customer_account.unwrap(); println!("Found accounts {:?}", ca); } Ok("Algo".to_string()) } and it worked! However, I am wondering if this part could be done better: let ca_iter = s.query_map(NO_PARAMS, |row| { Ok(CustomerAccount { id: row.get(0)?, name: row.get(1)?, user_name: row.get(2)?, }) }).unwrap(); I mean: - how should I really check and handle errors for each row.get to avoid use the "?" ? - how to properly check errors to avoid the last unwrap? Thanks in advance J
Excellent. Thank you!
Many teams of the Rust project use Dropbox Paper to collaborate on design documents and notes. Normally something like this would be posted to some blog before being made public, but Niko suggested we experiment with allowing other people to make and suggest edits instead of posting it as a finished document. Sorry that this has not worked well for you.
Someone claimed "Maintaining existing code does not create new bugs", which is clearly nonsense. You claimed that you'd need less code for maintenance than a rewrite. I pointed out that the breakage caused by those maintenance changes can easily multiply. It's worse if the code is old and no-one remembers all the assumptions made, worse still if there are poor tests, worse still if it has been patched up so much by poor maintenance that it's bloated way beyond the code size it really should have. Incremental refactoring could be one solution to this problem, or gradual replacement of sub-components one by one.
I italicized Inbuilt to differentiate it from the others. Did not think it would cause confusion, but it did. Sorry. :)
Crazy idea: If immediately waiting on an async function is guaranteed to have the same program behavior as a sync function... could there be a high level optimization that creates and calls a sync function instead?
Well, `yield`, `return`, `continue`, and `break` all do something orthogonal to the normal control flow. (giving control back to a higher scope) Technically, `await` does the same, but you don’t control that scope. It gives control to some function that happens to be next in the queue and then waits until it’s its turn again. I’d argue that this is something completely different conceptually. It’s for performance, not for building abstractions.
How do I compare if an `Option&lt;(String, String)&gt;` is equal to 2 other `String`s ? So far my only solution is: if opt.is_some() &amp;&amp; string1 == opt.unwrap().0 &amp;&amp; string2 == opt.unwrap().1 ... but I don't like to `unwrap`. Does anyone have a better idea ?
I see `await` and `yield` as being the same, and you can more or less emulate one with the other.
`"Answer: {}".format!(42)` looks *really* nice.
&gt; Again, please leave comments on this internals thread Hard to do that when the thread is locked....
For my own education, when you say "vectorized" are you referring to memory locality or does the release compiler automatically optimise SIMD where appropriate?
That's exactly what I said: they're the same from a technical standpoint, but completely different conceptually.
I am glad that it helped. &amp;#x200B; Contribution to either of the project should be fine as it would be helping rust community as a whole. I would suggest you raise their respective issues with both the projects and see what comes out of it.
Translation is considered a derivative work. I'm not sure if Discord has translation built in like Skype, but they may be planning it someday. They also need license to create derivative work if they provide any image filters/effects, or overlay something on your image. They need the ability to sublicense if they ever want to integrate with 3rd party apps, and display content through them. GitHub doesn't adapt your content to fit their mobile app, or anything, so they don't require the same licenses a chat app does. I'm not sure what features Discord has. I've barely used it and am not advocating for it; I'm just a nerd who reads ToS for fun. This excerpt is pretty much boilerplate legalese, including a bunch of synonyms to cover all their bases in case they get sued, "modify, adapt, create derivative works from." Most chat apps need the same license Discord does. Even Zulip, which is open-source, mentioned in this article, and well received elsewhere in this thread, has the same language: &gt; [When you upload or otherwise submit content to our Services, you give Kandra Labs (and those we work with) a worldwide license to use, host, store, reproduce, modify, create derivative works (such as those resulting from translations, adaptations or other changes we make so that your content works better with our Services), communicate, publish, perform, display and distribute such content. The rights you grant in this license are for the limited purpose of operating and improving our Services, and to develop new ones. This license continues even if you stop using our Services (for example, so that we can deliver a message that you sent to another Account before you stopped using our Services).](https://zulipchat.com/terms/)
Good point. I think the language could be restricted so they don't have permission to host the content to anyone else though.
Until recently, Rust used IRC, which was hosted by Mozilla. Why couldn't Mozilla host a Matrix server or whatever?
Considering that we have free repos in gitlab/github, I'm not even sure why anyone would need to host papers somewhere else.
Yes I was thinking this. I don't want to login to my dropbox to view a document about an open source project.
I don't disagree. The salient point was that whatever syntax we choose for `await` should be used for `yield` too, e.g. for i in 0..100 { i.yield; } As for the distinction you make, I think `await` (and also `yield` and say `call/cc`) are _more powerful_ than `if`, `for`, and so on. So if the latter deserve a prefix keyword that's easy to notice, so should the former.
The lock-in of Discord is that transitioning away from it is intentionally made difficult. Whereas e.g. Pidgin can work with XMPP and IRC, or Fractal will eventually work with both Matrix and IRC, it's against the terms of service to use a modified or alternative client, meaning transitioning away is harder; it's has to be a hard cut-over.
Please attach another format next time so that people can view the content without having to sign up to Dropbox. This is not a good look considering the recent controversy about the IRC community being moved to Discord.
Not to sound like a salesman, but the Dropbox Paper interface is really nice for collaborating on documents. Like Google Docs but designed from the ground up for purely electronic viewing instead of intending to be printed out.
While I like collaborative editing on drop box, I wish this would use an alternative that at least allows reading the document without having to sign in. Also, I signed in, and couldn’t leave a note on a typo.
That works for me!
What's "not a good look" is how incredibly entitled the reddit rust community is.
&gt; I hope people don't seriously consider... Before I say that about something someone else is interested in, I try to remember that someone else has said that about every single thing I'm interested in.
I like how not all members of the Lang team new about the document (see Centril in the internals post), and how the document wants to land this in beta in June
Why do you say that you have to sign in to view the document? The document is completely view-able without signing in, at least for me on both my phone and desktop
Are you being requested to sign in? As I mentioned [here](https://www.reddit.com/r/rust/comments/bj2u6h/hosting_the_asyncawait_syntax_doc_on_dropbox_isnt/em51dxv) I was able to view it fine without logging in. I didn't try editing though
There's a controversy because one group likes doing things one way, and another group likes doing things a different way. The fact that the controversy exists isn't an argument in favor of either group's way of doing things.
Github documents with pull requests, or Github wikis seems like a much more accessible alternative to this.
Haha--you were kind, leaving in the spaces. :)
Now that I’m on a desktop I can see it. It wasn’t obviously available on my phone w/o downloading an app and signing in.
That's really not obvious for me. It should be viewable in a browser on mobile.
Benchmarks: https://github.com/djc/template-benchmarks-rs markup.rs is the fastest in the Big table benchmark and should be about the fastest in the Teams one once the benchmarks are run again -- some optimizations were made to the rendering after the last benchmark run.
Hypothetically, if Rust 2 ever comes, it would still be nice to be able to clean up these kind of minor things. But I don't think there's a list of "things that shouldn't be considered unless Rust 2 happens", probably because people are confident enough that it won't ever happen.
I don’t think this will be a common answer, but I make creativity software tools. I am using Rust in a Video Synthesis app for Mac, and am planning to use it for audio plugin programming as well.
It made me sign in on safari on my Mac
That's strange, I don't have a Mac to test. On Windows and Android with Firefox it didn't request me to sign on. On my phone there was a notice along the lines of "this was created with Dropbox paper, sign in or open the app to collaborate on the document" but i was able to close it to move forward (side note: I dislike those popups)
What is video synthesis ?
Since the internals thread got suspended before I even saw it, I'll make my comment here: There's a mention that "Rust doesn't have prefix operators", but what about `*`? Feels also relevant since you have to sometimes write `(*foo).bar()` to clarify precedence, and a postfix variant would be quite hidden.
(Due to limitations in Reddit I'm only responding to one person, but this is also directed to /u/levansfg and /u/Drakulix). So, to get this out of the way at the beginning: I was directly referring to both projects in the last paragraph of my blog post. I'm not happy with how that paragraph came out, as it came off aggressive and antagonistic when I wasn't trying to be. I kept it in the blog because of the main message: I think "RiiR" is a major problem in the Rust ecosystem (as a more salient example, I think this [attempt to rewrite Emacs](https://github.com/remacs/remacs) is incredibly misguided). However, after reading Kyren's [very, very good response to my article](https://www.reddit.com/r/rust/comments/biq864/giving_up_on_wlrootsrs/em31xe0/) I realised that I made an important assumption, based on my personal beliefs, with this sentence just before that last paragraph: &gt; They are doing this because it's difficult to write good bindings to C &gt; libraries, and so the natural conclusion to making it work well in Rust is to &gt; rewrite it Or, to put this distinction another way: It's Rust's fault that it can't work with C, rather than C's fault it can't work with Rust. This directionality is important because it motivates different outcomes: /u/kyrenn has directly stated &gt; I'm so tired of dealing with C crap that I just don't reach for C libraries &gt; anymore It's C's fault that lua's API sucks. It's C's crap that Rust binding authors have to work around in order to make a safe API. If this was written in Rust it wouldn't have these problems because it would have a different design from the get-go. This line of thought leads me to a direct source for my beliefs: the idea of [worse is better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html). Way back when I had a Lisp phase (don't we all :P) that essentially ended the moment I read this essay. So much of the world, in my opinion, can be framed in this simple "MIT vs Jersey" dichotomy. It's always a trade off, it's always a balance. There's an "MIT budget" in my head that I keep track of that must always be managed. Rust has always felt more balanced towards the MIT side of things, both in terms of how the project itself is managed and what the language itself actually encourages in its users. I've always been wary of it tipping too far over. With my admission of defeat in being able to sufficiently wrap wlroots-rs I now have to wonder if isn't Jersey enough. The major thing that attracted Rust to me, and still attracts me to it, was the ability for it to construct safe abstractions over unsafe operations. After reading blog posts like [the tootsie pop model](http://smallcultfollowing.com/babysteps/blog/2016/05/27/the-tootsie-pop-model-for-unsafe-code/) and reading through the standard library the major selling point of Rust to me was its ability to define abstractions whose main purpose was to make the unsafe safe. This is important to me because I see it as critical that any new systems language _must_ be able to interoperate well with C. I don't mean by having a switch to use the C ABI, but that it's (reasonably) easy to take a C library and abstract over it with a fairly small layer that would make it indistinguishable from a native library. C++ did this, namely by being originally an extension to C, but that's a big reason (IMHO) that it succeeded whereas others have failed. It is no surprise then that C++ is the poster child of Jersey design. This isn't necessary what most people care about with Rust, especially based on (the now quite old) [fireflower series of blog posts](https://brson.github.io/fireflowers/). A year ago, for the call of blog posts asking for input on the roadmap I wrote [this blog post](http://way-cooler.org/blog/2018/01/09/way-cooler-turns-two.html). While `async`, ergonomic improvements, and better IDE support are nice to have in the language the `unsafe` portions of Rust has felt unexplored. The biggest change that unsafe Rust has received in the new `Pin` API - which only came about because it made `async` state machines possible with today's Rust. This development was more incidental than purposeful - it feels like unsafe Rust is a second class citizen. Ultimately my beliefs are not yours and you can work on whatever you want. I simply am expressing my ideals because I think they are at least somewhat rooted in pragmatism and feeling forced to rewrite libraries doesn't feel pragmatic. Despite my potentially extreme sounding beliefs, I wish everyone the best of luck. We may disagree on the reasons but at the end of the day we all just want to make cool shit.
Was readable without sign in (firefox, linux) a couple of hours ago so probably not due to a flag toggle
Many sites like LinkedIn, MSDN, Medium use annoying dark patterns to decide whether force you to sign in based on how many times you visited the domain previously, whether you ever logged in before, and what your referrer is. Probably other factors as well. Sometimes you can circumvent this by using incognito mode. Not sure about Dropbox, but I think they've done similar stuff in the past.
Centril did know about the doc and has known about it for a few weeks.
gamedev and simulations
This is really cool. Have you had to do a lot of the coding yourself for the video synthesis, or have you been able to utilize any crates in your work?
Perhaps a better example, which we've discussed in the lang team, is `expr.match { ... }`, which I actually like quite a bit, since it prevents having to reorganize the order and indentation of an expression you want to match on. This is also what Scala does.
Auth isn't the problem on IRC. Default user experience and moderation tooling is. Mozilla IRC has decent auth support, we often used it at times it didn't help that much. Things that rely on extending IRC won't be supported in most clients. IRC is very much a non starter for a host of reasons.
Ship it! :)
It is viewable now for me, but a few hours ago it was not
Yeah I think the author changed something
I work in agriculture. Rust is a good fit because we usually have decent hardware (think Raspberry Pi class stuff), and we need performance and reliability. And I no longer have the patience to write C code.
I recently saw a simulation of a single lane closure and how it caused chaos in traffic. I was surprised by how far back people breaking rippled through traffic! Is the simulation work closely related to the gamedev you're doing or is that another interest of yours?
&gt; Niko suggested we experiment with allowing other people to make and suggest edits instead of posting it as a finished document Just FYI, for the first few hours it was available edits/comments were disabled due to the number of people viewing the document.
That's true-- we do have `*` and `&amp;`. For me, the distinguishing factor is that using these operations doesn't usually require disambiguation. I see your example as an exception to this. `await`, on the other hand, is usually paired with `?`, making disambiguation a constant requirement.
 if opt == Some((string1, string2)) { // Do things }
Is there any performance/CS/memory difference between `for element in list.iter()` and `for &amp;element in list.iter()` ?
I liked the way it was hosted ¯\\\_(ツ)\_/¯
It wouldn't be sad if people stepped up to help with skribo :)
This moves the `String`s into the `Option` so they are unusable afterwards ...
I must admit this one is a surprise for me. Are you building sensor networks by any chance?
It’s a way of creating visuals in real-time (for festivals, shows, or video art for example), that uses similar principles to audio synthesis! [Here’s a link to the app’s site](http://lumen-app.com) that should help clear it up :D
Sure, but my point is that sorting-out-precedence-via-() isn't something unfamiliar in Rust in general. Plus I'm just a bit surprised an official syntax discussion contains the notion that Rust doesn't have any prefix operators. Makes me think the whole pictures is still not in view.
Yeah, it's a fairly niche industry in a lot of ways. I'm doing some experimentation with sensor networks, but for the most part I'll just be asking them for data.
I have been able to use many helpful crates along the way, mostly OpenGL bindings and cbindgen 🙏! I’m in the middle of porting the core of the app to Rust from Objective-C to make it cross-platform, so I’ll be using many more soon.
Is this... metabikeshedding?
simulation project is separated from our gamedev projects, we are doing both the same time :)
Yep!
I think we will delay it until next year just to make you unhappy.
Couldn't this be solved with a piping operator? I mean it seems to me this is about making \`await!()\` nicely chainable, right? Some languages have an binary operator that takes a callable thing on the right side and calls it with the stuff on the left side as a parameter. \`[foo.bar](https://foo.bar)().baz? |&gt; await!?\` would desugar to \`await!([foo.bar](https://foo.bar)().baz?)?\`. I brought this up in the internals thread, but it was promptly shut down to cool off. Are there any obvious reasons I'm missing some simple sugaring operator like this wouldn't work? Couldn't find a clear block in the doc either, save for slight unfamiliarity. OTOH, many are familiar with shell piping, after which these things are modeled. Additionally, since it would be a universal operator and not async/await specific, it would make chaining other things like functions, macros and methods even easier.
It made me download the app and sign in from Chrome on Android.
man, you've a nasty syntax error in line 42 in your lib.rs file!
&gt; Doesn't this just mean that you have to check whether the monitor is alive before performing every single operation? Elsewhere in the post the author points out that the output is guaranteed to be available over specific spans of time. I think your approach is also described and discarded because it doesn't need to be checked before *every* operation as a result so checking every time would be overkill. I might have misread it but I definitely had your reaction at first and saw comments that helped me understand why its not the nicest approach.
We already have a kind of piping operator: `.` More specifically to your proposal, `await` is extremely common in asynchronous codebases, so having the default be something ergonomic and easy-to-use is very important. Personally, I think that `&lt;expr&gt; |&gt; await!()` is too noisy and hard to write. I also think it's unclear what this would mean from the perspective of `await` being a macro: is it passed the tokens of the preceding expression? How does that work?
Don't be sorry. It was just me being distracted :P
It's not pretty, but you could turn your `Option&lt;(String, String)&gt;` into an `Option&lt;(&amp;String, &amp;String)&gt;`, then compare: if opt.as_ref().map(|s| (&amp;s.0, &amp;s.1)) == Some((&amp;string1, &amp;string2)) { // Do things }
Well, \`.\` only works for a subset of cases. In languages like Nim writing \`foo(bar)\` is equivalent to writing \`[bar.foo](https://bar.foo)()\` and vice versa in all cases, not just methods. I think this goes a bit too far since it pollutes the member namespace with everything in the global namespace. Hence suggesting a separate operator, be it \`|&gt;\` or something else. The character itself used to do this feels like a small detail. The pipe operator would bind \*exactly\* like \`.await\` does. It's just making that special case into a more general one and using a different operator character to differentiate it from member access.
I realize I'm probably going to be downvoted for this, but that just looks ugly as hell IMO. I really don't see why moving the cursor a few characters is such a big deal that we have to contort the language so severely. Frankly, this feels to me like the kind of change that looks good on paper but in the real world, just makes code ugly and harder to read because codebases will be a mix of both styles.
It's also a good way to help prevent getting issues that say "is X feature going to be implemented?".
If you believe a port is achievable thats great news. It sounds like you've got a challenge a head of you so good luck!
I don't know of any collaborative option that is in widespread use in the community. Some specific people use HackMD but that's quite rare, and that's usually for drafting markdown docs (which you can do in Paper it's just less good) Dropbox Paper has been the de facto collaborative environment amongst the rust teams for at least three years now. It doesn't require sign in to view, only to comment, though documents can be made private. AFAICT the async doc wasn't private. You need to sign in to view it on the app on your phone (but you can still view it in a browser on your phone without sign in) I don't see why a document linked to off an official forum is "somewhere unexpected". It'll still be found the way it needs to be found.
I tried Weechat before and I didn't manage to set it up in a way that I could use it efficiently, though it may be possible to do so with more extensive customisation.
Most of these functions just get inlined so it doesn't matter perf wise. For the ones that don't you can define an inner function that passes by value and dereference in the outer function and mark the outer function as inline. Should be benchmarked first.
Ideally they'd use narrower language. But it increases legal liability because they might have forgotten of something that might be considered outside the terms they've listed. And they may have to change the license and get users to agree to the new one every time they add a feature. Not that it might not be feasible and desirable to restrict the language somewhat, but it's probably not so straightforward.
Hm, I've not really thought of that, but I suppose that makes sense. Personally, I would say if the channel is publicly logged and it says so in the topic, sending messages on the channel should probably be seen as implicitly agreeing to a license allowing that. But I have no idea if the law would agree with me, and when possible it's probably desirable to include such terms just to make sure. Laws can be ambiguous, and multiple legal jurisdictions can apply.
The point of this example was to demonstrate how well things compose, not to advocate writing in this "match match match..." style. :)
&gt; I simply am expressing my ideals because I think they are at least somewhat rooted in pragmatism and feeling forced to rewrite libraries doesn't feel pragmatic. I agree with you on that, on that if at some point I'd feel like I had to RiiR half of the world make my project work, I'd probably take the hint that Rust was a poor choice of language. There's a reason why I use python for my machine learning reseach. :) This is however not at all what drove me to working on Smithay and wayland-rs. What interests me the most here is exploring the design space. I really don't have "one big project of &gt;ayland compositor" of which Smithay is a dependency that I have to do. If you ask me what I'd do with Smithay once it reaches a realistically usable state, I'd probably just tell you "use it to experiment more". From this goal of exploring the design space and figuring out what kind of ergonomic APIs I can make given the constraints of Wayland and Rust, the easiest and most natural route is clearly to just develop everything in Rust, as this is what gives me the most freedom and ease of development. So call me an MIT perfectionist if you want, I can't tell you'd be wrong. :P For the anecdote, with wayland-rs I initially wanted to make it a full-rust implementation from the start, and only fell-back to using the C library because it was an hard dependency of OpenGL/Vulkan support. And actually, had the C lib been very easy to wrap in Rust, I'd probably had found it boring and never pushed polishing wayland-rs.
I found [this](https://andre.arko.net/2018/10/25/parsing-logs-230x-faster-with-rust/) article on here today am absolutely fascinated. I do heavy amounts of SIEM integrations/log parsing and want to try porting some of my (python 3) parsers into Rust programs to see the performance increase with my own eyes. My question: I see a bunch of different options for JSON parsers/serializers on [crates.io](https://crates.io) (json, serde\_json, etc.). They seem somewhat similar according to their documentation - are there any caveats to either one? Which one is considered the "go-to" crate?
Good suggestion with the parent modules. I might change that in the future ... Thanks.
Earlier today I could not see it in my browser in my phone, it was telling me to download the app and sign in. Now it is available. I don’t know what changed but *something* did, maybe a flag got thrown or someone elsewhere in the thread mentioned it might be an engagement hack on Dropbox’s part. I don’t really have a reason to misrepresent this experience, not sure why people feel the need to challenge it. As for how widespread Dropbox use is: I’m certainly not deeply involved in the project but I’ve been following it since very early days. I do not recall a big public request for feedback pointing to a Dropbox link before this one, most of the time we get blog posts, RFC links, or a discussion on internals.
I am working in commodity trading as an analyst. Our main language is R but for data interfaces and small tools we use Rust.
Then they couldn’t use a CDN.
There is not much benefit to putting content which can only be retrieved by a single user on a CDN anyway.
The size of the struct in memory? Are they not the same in this case as they both contain a single u32?
I suspect you saw the app modal and got misled by it. Folks are challenging it because we've not had this issue for ages :) Not saying you're deliberately misrepresenting it, but it's easy to be misled by UI. &gt; I do not recall a big public request for feedback pointing to a Dropbox link before this one, most of the time we get blog posts, RFC links, or a discussion on internals. That's fair, usually such documents are team-internal. But it isn't the first time such a document has been shared publicly, just perhaps the first time such a document _that people care about a lot_ has been shared. The devtools meetings have been using Paper for their meeting notes, and those have been linked to publicly at times. This is true for some other teams too, I'm just not as familiar. Dropbox paper docs get linked to in the lang team channels a _lot_. Every Rust all hands almost all the written output of the meetings is in the form of paper documents (meeting minutes and workshopped policy papers), and this was all linked to publicly (people even jumped in and commented on some of my docs!).
Just want to thank the lang team for their hard work on this! These kinds of design changes are always difficult.
Yeah in memory. Sorry this is probably a poor example as they have the same size. Assume the enums represent a bunch of different structs, each of different size. I'll edit the question for clarity
There seems to be some confusions regarding the issue raised by this post. When I first tried to access the Dropbox paper, it was gated behind a login form. I was expecting this to just be Dropbox misleading me to think an account was needed and looked for a way to access the file without creating an account: I couldn't find any way to access the file without registering first. I tried to reload the page and open it in incognito mode, it still prevented me from accessing the file. I am using Firefox on a Linux desktop. I can now access the link. I don't know if it is because the settings of the files were changed or if Dropbox blocks with a login form randomly. Even if many users could access the file just fine, there definitely were other people in the same situation as me. I just wanted to read the file but couldn't even access it.
As far as I understand, Rust will represent an enum variant in memory as the largest of the variants so that they take up a constant amount of space. So the size should be the same in memory for for each variant. Someone please correct me if I’m wrong!
Same on Firefox for Android (it worked fine on desktop (FF linux) though).
I think using `await` as anything else than “I give the system a chance to execute another green thread for a while” is a hack.
You suspect wrong, and the condescension isn’t appreciated. The modal was there when I returned to the doc and was able to access it, and I dismissed it. The screen I initially encountered was a full wall telling me I had to download the app and sign in.
What version of actix-web do you use?
An enum is generally the size of its largest variant plus the size of the discriminant. Sometimes this can be optimized down, but even if the data in two variants are of different sizes, the enum itself will always be the same size. As an example, let's say that the data in \`Increment\` has size 8, inside \`Decrement\` has size 4, the \`discriminant\` is 1. In this case the enum will be size 9 (notwithstanding potential optimizations or padding for alignment). So, \`Command::Decrement\` has size 9, even though the data inside only consumes 4 (+1 for the discriminant).
I work on embedded vision devices, usually for automotive applications. I don't use Rust as part of my day to day work, but I would love to as all the usual Rust talking points would help greatly in this field.
Agreed: I shared my experience in [another comment](https://old.reddit.com/r/rust/comments/bj2u6h/hosting_the_asyncawait_syntax_doc_on_dropbox_isnt/em5c3ss/). Earlier today, there was a full page form preventing access to the file to some people. It was not a modal and none of the links on the page allowed to bypass the form.
I personally use serde based (serde-json in this case) stuff because I prefer parsing directly to structs. If I wasnt doing that I would probably use the json crate.
So matching to find out which variant is represented and getting the size of the struct explicitly is the only way?
So matching to find out which variant is represented and getting the size of the struct explicitly is the only way? Anyway to expose the type from the discriminant? e.g. the enum knows which type it is currently representing so find that type and then query the size of that type?
This looks like one of the 1.0 alpha/betas (noticing `web::Data`)
What version of beta?
&gt; if i'm passed a Command representing the Increment variant I wish to get the size of the Increment struct There's no such thing, but you can make one: struct Increment { pub quantity: u32, pub length: u32, } struct Decrement { pub quantity: u32 } enum Command { Increment(Increment), Decrement(Decrement), } But.. why?
Was it a company decision to start using Rust or something you / your team suggested?
To be clearer again, I have already done the part you suggested in the edit. Was just trying to give a minimal example for the question
Aerospace... I wish we could use it here, still dabbling and hoping that someday I get to use it here (or move into another industry where I can).
I guess I'm not really talking about the nested match style, you can do that right now. I find putting `match` after thing to be awkward to read in the same way I'd find this awkward args.contains("help") if { println!("syntax: cat foo bar") } else { println!("try --help") } There's only one (to my knowledge) mainstream language which has done this and nobody else seems to be clamoring for it either.
What about attachments sent to multiple users?
Huh. I haven't tried it in a year or so, but I got OpenOCD to work with: openocd -f interface/stlink-v2.cfg -c "transport select hla_swd" -f target/stm32f1x.cfg -c init -c "reset halt" -c "program target/thumbv7m-none-eabi/release/i2c-test" -c reset
It depends. It totally makes sense to `await` a timer, a semaphore (for rate-limiting, maybe), or some kind of an asynchronous mutex.
Video compression research. If that’s an industry.
Why do you need the size in the first place?
&gt; the concerns were that folks couldn't find out what the moderation story was when we were evaluating it a year ago. Absolutely fair - that's a problematic situation. I'm glad it's on the way to being resolved. &gt; you'd have to convince individual teams to switch to Matrix, which at this point may be harder since they're used to things. The accessibility argument is a strong one Could you elaborate on this? For me, other than having a Matrix homeserver to sign up on (which I'm currently talking to Mozilla about hosting), the signup flow is pretty much the same: - Make an account on the server - Download the client and sign in or log into the webapp - Done
When you compare that cost to the cost of the I/O access, it's likely an order of magnitude smaller.
&gt; Most of these functions just get inlined so it doesn't matter perf wise. These are not `#[inline]`, so how can they be inlined without LTO ?
Experimenting, writing web services with no framework. A fun exercise but I'm not convinced I can make a nice router without a DSL. [https://github.com/CrowdHailer/raxx.rs](https://github.com/CrowdHailer/raxx.rs)
&gt; Could you elaborate on this? For me, other than having a Matrix homeserver to sign up on (which I'm currently talking to Mozilla about hosting), the signup flow is pretty much the same: No, this isn't a matter of how Matrix works, this is that venue choice is and has pretty much always been a per-team thing. There's no top-down request to use a particular venue, we have teams on Discord, Zulip, Telegram, and IRC (the IRC ones will be figuring out where to go next, it may be one of the others, Freenode IRC, or could be Matrix). So you have to convince the team members that they should be moving, and it's harder when they have something that already works really well.
oh, hm. Yeah, in that case we should mark some of them inline, and the others could use an inner function and have the outer one marked inline. But you'd need to prove it's a perf benefit.
I'm working on the design for an entirely command-line client for Matrix; I'd love to hear ways such a client could be more friendly to assistive technologies.
The current nested match style doesn't really read well and requires contortions when you chain things. Meanwhile, the postfix style reads naturally top to bottom in a way that follows data flow order. As for your example, fwiw, I'd write that as: ```rust args.contains("help").if { println!("syntax: cat foo bar") } else { println!("try --help") } ``` which makes it much less weird in my book ;) Why is it with `.if` that makes you feel it is weird and method call syntax somehow not weird? Similarly, some people, including me, find postfix macros to be elegant, useful, and not weird.
The full data of the attachment is included in the email transmission, then stored on recipients' mailservers. The sender's email service doesn't host them.
For the record, it sounds like you have a cool job. Do you know if Rust supports the processors you are currently using at work?
Oh, I see what you mean. Yes, that totally makes sense.
Using synchronous `Mutex`es or `RwLock`s in a cooperatively multithreaded context is a bad idea. Any contention will actively block the executor from making progress as it cannot reschedule other work in its place. There are other constructs available, such as `Atomic`s or the locks in `tokio-sync` which are better suited for async work.
Security engineer, building fuzzers/other vulnerability research tooling.
Is you concern more about adoption in the industry or have you found the language difficult to use in your space? I think if Rust made it into Aerospace it's worthy of a celebration.
Your app looks amazing! I assume the GUI work was done in C++? &amp;#x200B; If you're ever so inclined, I help with the \`vst\` crate (and upcoming \`lv2\` crate) and we have \[forums on developing audio with Rust here\]([https://rust-audio.discourse.group](https://rust-audio.discourse.group/)).
There is no size of each variant, there is the size of the enum. This should print the same value three times: println!( "{} {} {}", mem::size_of::&lt;Command&gt;(), mem::size_of_val(&amp;Command::Increment { quantity: 1, length: 1 }), mem::size_of_val(&amp;Command::Decrement { quantity: 1 }) );
Have you leaned much on the available libraries in your research or are you implementing stuff yourself?
I personally find ".if" and ".match" (and ".await") much weirder than method calls because it completely breaks expectations. If I position my cursor over them and use my editor's "go-to-definition" functionality, what happens? As far as I can tell, the answer is "nothing", because they aren't actually fields or methods, they're secret implicit names. It makes me wonder what other secrets the language is hiding from me. It would make me question what field or method names are safe from being "stolen" by the lang-team. As far as I can tell, most of the current support for postfix syntax is so that some people on the lang-team can code-golf their webservers. Upending the fundamentals of the language for that feels like a really rotten trade.
This is a new one for me, if you have any good reads on Rust fuzzing please share!
1 beta 2
I would definitely go into the source and add comments on the implementation mentioning all that we have learned. it's a comment only pull so it should get added in, and it also makes it clear what and why which is always nice.
I work in data engineering. I create web-based UIs for data visualisation and controlling data processing, plus backend batches and services for [ETL](https://en.wikipedia.org/wiki/Extract,_transform,_load) and the actual processing. Most of my Rust programming happens outside of work hours, although I'm wishful of seeing more adoption around me somewhere around next year.
Yes, I couldn’t see it without signing it. I had to sign in and then I could see it.
&gt; As for your example, fwiw, I'd write that as: rust args.contains("help").if { println!("syntax: cat foo bar") } else { println!("try --help") } which makes it much less weird in my book ;) I don't agree at all to be honest but we're talking about personal preference there. If we're going to talk about aesthetic preferences, then I'd vote to retain the existing "C with ML" aesthetics of language rather than changing the language to look some kind of nasty assembler directives ;) I think sometimes the lang team has really good ideas for features but hides them behind syntax that doesn't feel very Rusty. Some of the community, myself included, really likes the way Rust code looks now and most of the rest of the community has just come to accept it. Introducing syntax that diverges wildly from the current language on the one hand alienates the people that like the way things are now but also opens a huge can of worms in that everyone who isn't 100% satisfied with the way things currently are feels like it's their time to share their personal preferences. The end result is 3.123 x 10^34 long comment threads on RFCs and irlo posts. &gt; What is it with .if that makes you feel it is weird and method call syntax somehow not weird? Similarly, some people, including me, find postfix macros to be elegant, useful, and not weird. For me personally, it just breaks my brain. I have trouble even understanding how this would be parsed. I get that it can be, however, I've never seen a programing language that does this and it feels extremely unintuitive and strange to me. I can certainly learn to parse it but this is just one more hurdle developers will have to get over when learning Rust.
Yes this is essentially what i'm doing now. I simplified for the question. I am writing some code to interact with C and I need to construct and serialize buffers of the correct size
Okay, serious question, why does every single Rust job opening I see posted here have to do with blockchain cryptocurrency? It's really disappointing...
Yet being in the Lang team they felt they had to publish a doc stating that when the Dropbox document says “our opinion” that does not mean Centril.
Bitcoin
In this case, I think it would be best to make a macro that declares both sync and async variant of the function.
It's not that bad unless you are holding it across a yield point - there are plenty of cases where you need to interoperate with existing code or libraries, and using a mutex is the only option. Also, mutexes do not really work as a concept in futures code, so you can't just say "use the locks from tokio-sync": if you give the mutex to the next thread that "polls" it once unlocked, then it's unfair, and if you try to make it fair by queuing tasks that try to lock it, you get a catch 22 situation (just because a future tried and failed to take the lock last time it was polled, doesn't mean it will try again the next time) and whatever you do, you end up with the thundering herd problem (you have to wake up all tasks which *might* want to take the mutex, rather than just one).
&gt; please leave comments on this internals thread I know this is wildly off-topic but I just want to say how much I dislike Discourse or whatever it's called. I used to think Reddit had a bad design. Discourse really takes it to a new level of trash. I'm tired of the second scroll bar, the bizarre cryptic little bits of text I have to decipher each time I visit like '19h' (instead of, you know... '19 hours ago', like a normal design), tired of all the other bits and pieces scattered all over the place that were designed to be clever instead of clear. I think if you want people to leave comments there instead of reddit or read there, you might not want to use such a dumpster fire garbage trash design for a forum.
&gt; It’s also incredibly ugly to use in practice: fn some_wlroots_callback(output_handle: OutputHandle, surface_handle: SurfaceHandle) { output_handle.run(|output| { surface_handle.run(|surface| { // maybe some more nested layers... }).unwrap() }).unwrap() } I'm not really seeing what's so bad about this code. Many of the code I write looks like this, and I usually don't have any major issues with it. Yes, "callback hell" can get annoying to debug if the callbacks are asynchronous, possibly concurrent or intertwined, etc. But asynchronous code tends to be hard to debug in general. Essential complexity. These callbacks don't have any of that complexity. They're glorified scope blocks. And (from my experience at least), Rust doesn't usually cause many issues handling these kinds of `FnOnce` closures as if they were scope blocks (occasionally you have to add `move` and then even more rarely you have to create references for things that you then *don't* want to move), but it's generally not a big deal. I find that quite often when people - in particular in the JavaScript world - are complaining about something being "callback hell", the essence of their complaint often boils down to the fact that they don't like code with many indentations because it looks bad. Like, looking at OP's article, I really don't get the point of the `#[dehandle]` macro. It doesn't help with any essential complexity, the code after the macro expansion is the exact same "callback hell" as before, it just doesn't *look* like it because there are fewer tabs. What's so bad about a few extra tabs?
So just to recap. If I'm understanding correctly, the "order of operations" is too surprising, and the postfix sigil `@` is out of favor. To a lesser extent, `await?` isn't orthogonal. We seem to be down to, prefix with enforced parentheses or brackets: (await future) await(future) await{future} Or postfix, which seems to be popular: future.await // magic field future.await() // magical method future.await!() // postfix macro Am I missing anything else?
You should also look into `#[repr(C)]` for the inner structs, and maybe into unions, depending on whether you're marshalling the whole enum or just the fields.
I'm not a native English speaker, but in programming jargon, isn't \`built-in\` a more broadly used term?
Ha ! TIL, thanks !
I would hope with your work there would be less resistance. Rust seems like a great fit. Either way keep at it, if anything build something anyway and show them how it can help!
&gt; You suspect wrong, and the condescension isn’t appreciated. The modal was there when I returned to the doc and was able to access it, and I dismissed it. The screen I initially encountered was a full wall telling me I had to download the app and sign in. I'm sorry, I didn't mean to be condescending. I'm trying to make your experience with the doc match up with mine, because something was different. It's possible that the document was just marked as private by accident. That doesn't match my experience when I opened it, however I may have opened it after they fixed that. It's certainly not in a folder that I have access to (there's no one single Rust dropbox folder that everyone on the teams can access, and there's very little reason for the lang team to add me, specifically, to their doc). Either way, Dropbox Paper doesn't require logins to view documents, but yeah we should be more careful when putting out documents like this to ensure that the permissions are set up that way. That's the default so usually folks never check.
Exactly! That's why i used 🤦 ... feeling like an idiot :P
See https://www.reddit.com/r/rust/comments/bj2u6h/hosting_the_asyncawait_syntax_doc_on_dropbox_isnt/em5jwd5/ From what I can tell, it was accidentally marked as private when it was shared. It's not always obvious that it's private from the UI so I suspect when making the post the team just didn't notice this. The default is publicly-viewable (and publicly-editable if you have a log in) so in general folks just don't check for this.
&gt; in particular I don't really get what's so egregiously terrible about `(await http.request(...))?` Yes, I completely agree, and when I read that part of the doc, not having followed the discussion very closely, I was really puzzled about the evident unanimity behind it. I realize that people didn't like `try!(try!(try!(x.foo()).bar()).baz())` and that something like `(await f((await op1()?))?` might be considered objectionable on similar grounds, but honestly it doesn't seem as bad to me (I think the space helps a lot), and I like the ease with which one can thereby express `(await x?)?`, where `x` is a `Result` possibly holding a `Future` that resolves to a `Result` in its `Ok`.
&gt; Generics take up compile time. That's simply false. A complicated type system can take up compile time, but simple generics (e.g. C++ and Java have different simple approaches) doesn't need to take any significant amount of time. This is especially true for Go, where built-in types are already generic.
The enum will always be the size of the longest element (in this case u32) plus some undefined overhead (1-4 bytes) in memory.
I see above that you’re planning on adding *even more* magic fields (if and match) My reaction is still frustrated. It feels like a lot of churn, especially for a year that is supposed to be about “maturity”
&gt; They should be IMO. At the very least they should get memory right. Something that low in the abstraction stack and so fundamental to the system should not be wasting resources, as much as feasible. Gtk uses reference counting. It's one of the most lightweight commonly used UI library out there. Complaining about reference counting is like complaining about dynamic memory allocation - those concerns have their place, and that place is exactly control systems for fighter jets and maybe nuclear submarine reactors.
Debugger Si
I'm 100% OK with that. no_std is a niche use case, and for many scenarios giving up even a little bit of ergonomics for no_std compatibility is silly. That being said, I agree that the language and standard library shouldn't be pushing people *towards* refcounting as the default. I just wish it wouldn't push away from that very effective optiojn quite as hard.
Most of the stuff ends up having to be implemented ourselves because our needs are too specific, but there are some really good general purpose compression crates that have been used. Some of the bigger ones are stuff like actix web and serde. I published the arcode crate to have a rust arithmetic coder so that was fun.
\&gt; I would definitely ... Meaning, I suppose, that you will not be doing that?
Luster's whole *point* is to figure out solutions to safe GC interaction. The fact that it's a Lua interpreter is kind of secondary. It's also not the first project to fork / reimplement Lua, and other Lua forks have been really successful. The goal is not *necessarily* to replace PUC-Lua, it was to make a memory safe Lua? To make it possible to make language runtimes in Rust that aren't slow and have real garbage collection? To make a Lua where you can run untrusted Lua code and it not be equivalent to loading untrusted object code? (I'm aware spectre maybe means that this is always a risk anyway :(, but memory safety is still an important layer here). In fact, I would say it's NOT being written as a sign of failure to wrap Lua correctly, I figured out how to do that. The rest of the problems are PUC-Lua *itself*. I'm not *forced* to rewrite Lua, I figured out the bindings system, it's safe. I even figured out a good pattern for passing non-'static data to scripts where you can't be sure of the dynamic lifetime (the scope system) that I think other language bindings should adopt. (SPEED is another problem here which is also kind of Lua's fault but I'm skipping that for now) Where does RIIR become bad engineering vs good, is ripgrep bad because burntsushi could have just made grep better (very slowly)? I understand what you're saying but I'm having trouble taking actionable advice from it. If you're rewriting something to make something better, at *some point* you have to rewrite something and have a worse version of it to get to the better version of it. If your goal is not to make something better, then probably you're not seriously trying to make something that people will use? I understand PUC-Lua is well respected (and I even understand why!), but it has problems and they're not Rust specific. I mean maybe I'll fail to make anything better, but maybe I won't? Maybe the world is complicated and my thing will be better in some ways and worse in others? Anyway I'm not mad or anything, I just don't exactly know what to do based on your advice. I'm not *qualified* to work on PUC-Lua, it's a language runtime so basically if you open the source code and look for anything touching garbage collection and transpose two lines of code it will: 1) work, 2) nearly all the time, and 3) be a memory safety vulnerability. I get what you're saying though about Rust unsafe, I'd like to see some ergonomic improvements as well, but there has been a bit of progress. For me, it's actually kind of funny, the biggest "unsafe ergonomic improvement" would have been GATs! I needed GATs to express some lifetimes in rlua, and most of the Rust-side problems with rlua came from that, so I'm just patiently waiting for GATs to show up. That happens a lot actually, I've found I get a lot of expressive power to make previously unsafe things safe out of the oddest corners of the language (the same thing applies to generative lifetimes). Anyway best of luck, and I agree in general with a push to make unsafe rust more ergonomic and especially more verifiable.
Dropbox is cancer lately. The rust team should consider divorcing from it. A wiki page would be better for collaborative editing; a self hosted dokuwiki or mediawiki would be great, or a github / gitlab wiki page would be great. No need for dropbox cancer.
Oh dear god
`serde` is so fundamental that it should be learned much earlier.
So the core issue is two-fold. `c1` and `c2` come from `self` and `other`, so you're moving them out of a borrowed struct. Then match ergonomics kicks in, and assumes you meant to borrow `c1` and `c2`. If you do that you won't be able to hold on to them after the end of the functions, hence the error you're getting. Fastest way to fix that is to take `self` and `other` by value: `union(self, other: Set&lt;T&gt;) -&gt; Set&lt;T&gt;` The other issue is that if you want to move `c1` and `c2` into your closure, you need to prefix it with `move`: `move |u| c1(u) || c2(u)` I'd try that
Thanks for the kind words! I'm sure Rust has much to give! It's still the early days :)
I didn't mean to imply that another Lua interpreter written in Rust would spilt the ecosystem (how could it, if you're conforming to the spec?). Rereading what I wrote it does sound like I'm saying that when I don't mean to. With wayland-rs it's a little messier I feel, since while there is a standard protocol they are reimplementing there are e.g. those problems with interacting with the existing C libraries that makes it seem like it will spilt the ecosystem if taken to its extreme (e.g. RiiR all those libraries too. Not saying that is what's going to happen). I probably should have just dropped that comment though, as that's not the important thing I was trying to say. The _most_ important thing I wanted to get at was that I assumed that you (and this applies to /u/levansfg too) were making these projects as a yak-shaving process. I know that rlua was probably done so you could make games with it and I assumed there was a compositor that /u/levansfg wanted to make. Since that's not the case, and the project itself is itself the end goal then my mindset doesn't really make sense. You're not being forced to work on this, you want to work on this. In contrast, I felt forced to work on wlroots-rs (because of the sunken cost I had with Rust up to that point, and because I knew it _could_ be nice to work with once all the safety bits are dealt with) as a secondary concern to my main goal (e.g. making Way Cooler). I assumed that was the case with the both of you, but I was incorrect. &gt; I just don't exactly know what to do based on your advice It wasn't really advice, I'm not trying to speak from a position of authority by any means. It was more a description of my values and what I perceived to be a problem in the wider community that wasn't actually happening (e.g. only I felt forced to work on wlroots-rs, for the both of you your respective projects are goals unto themselves).
It's either GO or Rust as the main Ethereum clients are written in these languages, and everyone is following suit.
I can confirm that I had to log in... couldn't read the document otherwise.
I got to implement diffuse and specular image-based lighting using the split-sum approximation popularized by Unreal Engine 4, as [described in this paper on moving UE4 to PBR](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf), for a term project for one of my classes. This means `rendy-pbr` is now able to load equirectangular HDR environment maps, filter them into an into a pre-convoluted irradiance map and specular radiance maps by importance sampling the GGX specular lobe distribution at several levels of roughness, then storing the results in different mip levels of a cube map. In the main PBR shader, these maps are then sampled and combined as the 'ambient' term of lighting. In addition, I implemented emissive materials, which is essential in getting the look of the new elemental sword test model right, which was relatively trivial in comparison to the IBL stuff. This was a big project but super fun and I'm very happy with the results!
&gt; I see above that you’re planning Not really.
I work in email security. Rust is used for email and SMTP parsing. Rust is also used in some of our machine learning tools.
`cargo build -j 1`
I'm in the industry of the unemployed! However, I am currently exploring the use of Rust to replace some slow python code in a friend's machine learning project. I have also used Rust in the past to replace nasty C++ code in a game-related project.
One thing to note that’s changed since that article: lambda now supports Rust directly, so the setup should be even easier!
Thank you for the clarification. As mentioned above, I can now access it. Many people seemed to be able to access it so I suspected some dark patterns from Dropbox. In the end I am simply happy that it got solved. As long as I can see the files, I am not against the Rust devs using it to share their files.
To me it's sounds like you've found your first client :D Good luck!
That industry follows a lot of fads and hype. Rust is a lot more than a fad, but it is en-vogue right so I'm not surprised they are using it.
Ooo, neat idea - hadn't thought of that.
The problem is that LLVM can optimize better when passing things by value, because if you pass them by reference, then you are passing a raw pointer, and then you need to start doing alias analysis to prove that you can first eliminate all pointers (after inlining, if inlining happened), and then continue optimizing as usual. For chars, it just really don't make sense to pass them by reference. They are copy, and the copies are small, and often can be elided.
Work in rail transport systems but also with software where lifes potentially depend on. Biggest problem would probably be compiler certification. Even for a simple language like a subset of C this is hard: see for example http://compcert.inria.fr
If you can, would it be possible to share a little more the Rust ML use? I'm familiar with the typical Python stack but haven't spent any time looking into Rusts equivalent. That's assuming you haven't written the algorithms by hand.
Looks pretty cool! Does rustfmt change the format inside the `define` macro?
Thanks! I've used `cargo help build` without seeing it… but it was right under my nose x)
This is really interesting, but I gotta nitpick a bit. I think the kubernetes community largely agrees that an operator is a CRD + a controller. You'd expect something like `Controller &lt;- FIFO queue &lt;- Reflector`. The go-client would call the queue a store, but I think you called it `state` here. Lot of great work though, would be lovely to write kubernetes stuff in Rust.
In .NET disaster unfolds when you mix async and sync functions... like if you have an async function that calls a sync function that calls an async function for example. This and similar code can lead to dead locks. How does rust handle that?
&gt; I didn't mean to imply that another Lua interpreter written in Rust would spilt the ecosystem (how could it, if you're conforming to the spec?). Off topic, but the spec is just what PUC-Lua does, and also kind of what LuaJIT does, and now they're forever different, it's kind of a mess :/ I wish there WAS a spec! FWIW I'm just trying to do exactly what PUC-Lua does up until but not including the insane parts (C locales, locale dependent number lexing, loading C shared objects). &gt; The most important thing I wanted to get at was that I assumed that you (and this applies to /u/levansfg too) were making these projects as a yak-shaving process. I know that rlua was probably done so you could make games with it and I assumed there was a compositor that /u/levansfg wanted to make. Since that's not the case, and the project itself is itself the end goal then my mindset doesn't really make sense. You're not being forced to work on this, you want to work on this. I mean, to be fair that was *rlua*'s purpose, I just got to the point of being able to make games with it... pretty fast. Trying to make it *bullet proof* was not so much for games as it was for.. the desire to be able to make a secure (modulo spectre) scripting environment by default. I kind of at the time had like lofty ideas about making a neat server-side-scripting game environment, but that may just have been an excuse, it was a problem to solve and I felt like I was making the world better by making it easier to not write security vulnerabilities. NOW I think that maybe was trying to build a castle on sand... but I'm really *dissatisfied* with scripting &lt;-&gt; non-scripting language bindings in general actually! Javascript and python both also have these problems, and they seem to be general problems. That's kind of what lead me to work on luster, to try to make the situation better. &gt; In contrast, I felt forced to work on wlroots-rs (because of the sunken cost I had with Rust up to that point, and because I knew it could be nice to work with once all the safety bits are dealt with) as a secondary concern to my main goal (e.g. making Way Cooler). I assumed that was the case with the both of you, but I was incorrect. I mean, for rlua that's not wrong. I guess I'm a bit confused now, were you considering luster to be yak-shaving or rlua or both? I mean definitely rlua was in reality the more yak-shavey of the two, I had to do it to write something else and it took on a life of its own. But rlua is also something that we both consider to be a strength of rust: being a firewall against unsafety? Do you consider bindings projects to C libraries, if they're required to be very intricate like rlua / wlroots-rs to be the bad sort of RIIR? I don't think rlua was a bad idea *as such*, I just became really disillusioned with the PUC-Lua runtime itself (I have actually just made the interpreter itself crash from Lua + __gc metamethods on multiple occasions). *Discounting* the underlying C projects themselves, making safe wrappers to C libraries is a force multiplier. I know it can feel pointless and like yak shaving *to you*, but you're saving somebody else from having to go through the same pain. I mean, writing a wrapper like that is always going to be a waste of time if you're the only user of it, it's always going to take longer to make sure that *anything* that somebody might do is safe vs only what you particularly want to do. But you're giving up your time to be a force multiplier to other people, surely if you decide to do that that's not a bad thing? It's also not a bad thing if you decide *not* to do that ofc. I'm trying to make sure I understand your thought process: did you think that I wrote luster because I just couldn't manage to make a safe Lua wrapper? I mean that's *half* right, but like I said it's not the Rust part. It's funny, I actually do have a new game project and I'm not using scripting in it at all, partially because it's a bad fit and it will be very performance sensitive, but also because I don't want to yak shave with luster right now :P
I'm a web developer. We've written a few tools in Rust (file and dB manipulation type things), mostly using Clap and Serde. We just put our first API live last week (although we've had it working for months the business need to have it was pushed back). The API uses Actix Web, Serde and Diesel. I'm also working on a side project that uses Rocket. Although I really like the macros, I would stick with Actix for "real" work for now for stability and because endpoints can't be generic.
I suspect it doesn't contain std and there should be separate tarball with compile std. On other hand afaik rustup doesn't require special privileges for installation and you can just tell it to get unpacked anywhere
Soon after the post was made I read the document without signing in. After someone mentioned they had to sign in I checked again, and at that point it was definitely requiring a login to view (I didn’t actually login to see whether I could view it at all). I just tested again now and it is accessible without login again. So it seems like there was some transient issue blocking access, maybe an unintentional permission change, maybe some kind of rate-limiting by Dropbox. Doesn’t really matter at this point.
I understand, but this can't be fixed backwards compatibility the direct way, I'm trying to see if there are ways to make it not matter indirectly (but I'm skeptical those methods will work)
Ah thanks. I encountered so many conflicting definitions on controllers vs operators and have just been using operator as "any app that operates on a CRD" :( Is there a canonical source for what?
The latter is dereferencing `element` using a pattern-match, and so is copying each element to the stack before it is used in the block whereas the latter will leave it behind a pointer. It's hard to say how LLVM's optimizer might treat these forms differently with respect to the code in the loop but in general unless the type of `element` is larger than a pointer (32 or 64 bits depending on target) then the differences are going to be more or less negligible.
`yield` returning a value _really_ doesn’t work with how generator resume arguments are likely to work, so it will likely remain syntactically the same as `return` and not like `await` (number one issue being that you want a resume value in between entering the generator and reaching the first yield).
Any chance to get a summary of what branch 3 brings in... ?
There's definitely a lot of abstract definitions, the CoreOS project are the first (I think) to use the term 'operator' and you can take a look at their operator SDK github to see how they explain it https://github.com/operator-framework/operator-sdk If you look at their 'workflow' section they basically describe it as 1. define the CRD 2. define the controller 3. write the controller logic The accepted answer on this SO post https://stackoverflow.com/questions/47848258/kubernetes-controller-vs-kubernetes-operator goes on step further and suggests that an operator should have a 'single app focus'. That's kind of a nebulous term but helps narrow down the focus. If you think about it, you need _something_ to reconcile cluster state and that's exactly what the controller does.
Thanks for the kind words and the link, I look forward to hanging out there! :) The GUI is almost all Cocoa still, since I’ve been moving the core of the app to Rust first.
That would be correct. I should, it's the right thing to do. But I've got my own things. If I had ran into this problem, I would do it, but seeing it from the outside, nah, that's going a bit far out of the way even for me. I've routinely added pull requests for typo's in readme files when people have posted their projects here. It's a small way to give back, but, again, a step too far for me to fix something someone else noticed and I've only tangentially commented on.
The standard library for each target is distributed as a separate component. You will likely find it easiest to try and install `rustup` - it's not an installer in the traditional sense, it just downloads more files to put in your rustup directory. If you *really* can't do that then you'll want the main toolchain, the rust-std for the same target, and possibly some other bits.
I could sign in and view from the web (in fact the Reddit app) this morning on iOS
&gt; Off topic, but the spec is just what PUC-Lua does, and also kind of what LuaJIT does, and now they're forever different, it's kind of a mess :/ I wish there WAS a spec! Oh I thought there was a spec :( &gt; were you considering luster to be yak-shaving or rlua or both? I thought both were, but I admit I only glanced at luster and didn't realise it was more of a "research project" than yak-shaving attempt. &gt; But rlua is also something that we both consider to be a strength of rust: being a firewall against unsafety? I really like rlua, it's a great testament to what I see as the main strength of Rust. &gt; Do you consider bindings projects to C libraries, if they're required to be very intricate like rlua / wlroots-rs to be the bad sort of RIIR? That's not RiiR, that's what I _want_ to happen more: relying on battle tested libraries (that are probably in C, because history and it's what the open source community has historically preferred) but wrapping it up to be safely used. There is no rewriting going on and all the work done to make safe is added _on top_ of the existing library as a separate project. &gt; I know it can feel pointless and like yak shaving to you, but you're saving somebody else from having to go through the same pain. Oh absolutely! I think we are on the same page I want to highlight this comment specifically because I do think it's a shame that it's a pain to write these. I wish Rust made it easier (can it be easier? I think unsafe ergonomics can be improved and a standard should be made which would make this significantly easier), but it's very important (if very boring and soul crushing) work. &gt; I mean, writing a wrapper like that is always going to be a waste of time if you're the only user of it I designed wlroots-rs hoping others would use it. I had two groups attempt this: buffet tried it and didn't like it and [purism](https://puri.sm/) looked at it as an alternative for writing their phone compositor. Neither found it usable enough to continue. If they found it usable I probably would have soldiered on. Since neither took a liking to it I'm going to write wlroots-rs off as a failure. At least I learned things :). Thank you very much for putting in the effort to rlua, you have made Way Cooler better for sure since I will still be using it for the client side (we just updated to 0.16, so now we are as safe as can be :D). &gt; did you think that I wrote luster because I just couldn't manage to make a safe Lua wrapper? I was only slightly active on your issue list, but it seemed like your situation was similar to mine: every once in a while you would get a bug report and you realise everything is broken because there's a safety hole and the whole thing falls down and you have rethink everything and oh god everything is terrible. I went through that a lot with wlroots-rs, and it is exhausting, so I assumed luster was a reaction to that happening. I just assumed you wanted to make something with it, not explore the design space. Maybe I'm just tired of academia after so many years in university, but I just assumed it was yak shaving for some concrete project rather than an exploratory thing that will hopefully bear fruit (but it's ok if it doesn't). &gt; It's funny, I actually do have a new game project and I'm not using scripting in it at all, partially because it's a bad fit and it will be very performance sensitive, but also because I don't want to yak shave with luster right now :P Good luck in your project!
Unfortunately no. AFAIK rustfmt only formats code inside certain macro invocations and this library uses a format that's not valid Rust code so rustfmt has no way of knowing how to format the tokens.
Glad to hear you've gone live. Web development seems to have the least resistance in Rust which is great. I've definitely seen a number of posts relating to the stack you've mentioned. Thanks for the tip!
We are a small part of a big company and have a lot of freedom to choose. When we hit some problems with reliability of our R scripts we started looking for a better alternative. I liked functional programming so I suggested Rust and started building things.
How does modules *really* work? I just can't wrap my head around them, despite reading the official docs and many other explanations. Let's say that I have three files in the same folder, like this: ``` main.rs types.rs routes.rs ``` `main.rs` uses `routes.rs` and `types.rs`. `routes.rs` uses `types.rs`. `types.rs` is completely stand-alone. *how* do I describe this relationship? What do I add to the respective files? What should I *not* do?
I'm slowly starting to realise safety is rarely binary but more a matter of degrees. I never imagined compiler certification would be a thing. Very interesting.
Thanks a lot. That's helpful. Sounds like If my `operator-rs` was entirely focused on maintaining the lifecycle of whatever the [Foo CRD](https://github.com/clux/operator-rs/blob/master/yaml/examplecrd.yaml) is managing under the hood, it would be more appropriate to call it an operator? Might be a bit of a stretch to even call it a controller since it's not doing anything with with the Store except return through a json http api.
Wow! Looks amazing!!
If you don’t mind how big is your dev team and how did rust start to make its way in? I’m a web dev also but not a lot of other people on my team have any interest it rust. We use a lot of PHP and JavaScript but I’ve slowly been bringing in rust when those can’t perform well enough.
I really hope more people can follow this route. Thanks for the info.
FYI, in a postfix syntax, your example would end up looking like `f(op1()?.await).await?`. Did you mean to unwrap op1() before awaiting it?
&gt; I thought both were, but I admit I only glanced at luster and didn't realise it was more of a "research project" than yak-shaving attempt. Yeah, I mean I guess I interpreted yak-shaving as negative at first, but really it's not necessarily a negative so it's fair to call rlua yak-shaving. &gt; Oh absolutely! I think we are on the same page I want to highlight this comment specifically because I do think it's a shame that it's a pain to write these. I wish Rust made it easier (can it be easier? I think unsafe ergonomics can be improved and a standard should be made which would make this significantly easier), but it's very important (if very boring and soul crushing) work. Okay that's good, we're definitely on the same page then! &gt; Thank you very much for putting in the effort to rlua, you have made Way Cooler better for sure since I will still be using it for the client side (we just updated to 0.16, so now we are as safe as can be :D). You're welcome! You know I'm not very good actually at open source development, and rlua was my first even somewhat serious open source project, so I'm glad even if it's a bit of a castle on sand that it's useful to people. It definitely makes Lua safe*er* to use. &gt; I was only slightly active on your issue list, but it seemed like your situation was similar to mine: every once in a while you would get a bug report and you realise everything is broken because there's a safety hole and the whole thing falls down and you have rethink everything and oh god everything is terrible. I went through that a lot with wlroots-rs, and it is exhausting, so I assumed luster was a reaction to that happening. In rlua's case, the BIG problem was lack of GATs, which I think is an interesting point and an example of where the pain points of unsafe code *aren't* in parts of rust specific to unsafe code, just in not being able to express everything you want to express with lifetimes. The [specific issue](https://github.com/kyren/rlua/issues/97) that I'm assuming you're talking about that lead to me using generative lifetimes basically all came about because at the very very beginning of the project, I was using the "wrong" lifetime signature for callbacks. I'm *still* actually using the wrong lifetime signature for callbacks, due to lack of GATs, and though it's safe it was a pain to get there. I'm not going to lie, there was definitely some cost paid here in getting to a deeper understanding of rust's lifetime system, but that at least bears fruit across anything I do with rust in the future. That issue and the issues around it were the big "rust-side" issue that I had making rlua, so I'm really happy that GATs are finally on track to be in Rust. That issue did happen roughly around the same time as I started seriously working on luster, but the really soul crushing part wasn't that issue actually. Really, what happened was that shortly after that issue, as my familiarity with puc-lua increased and I kind of realized that it wasn't ever going to be safe to run scripts through puc-lua, and the only people I had met that had apparently done so had to do surgery to the interpreter itself. It felt terrible to apply so much effort, basically succeed, and *then* realize that it was still kind of a lost cause. &gt; I just assumed you wanted to make something with it, not explore the design space. Maybe I'm just tired of academia after so many years in university, but I just assumed it was yak shaving for some concrete project rather than an exploratory thing that will hopefully bear fruit (but it's ok if it doesn't). So this is probably like TMI, but actually I kind of started working on luster seriously after I left Chucklefish. I think I needed a break from game development and like, needed an outlet for some pent up desire to do lofty researchey sorts of things. Plus, /u/manishearth got the whole GC problem in my head and I couldn't get it out :P &gt; &gt; It's funny, I actually do have a new game project and I'm not using scripting in it at all, partially because it's a bad fit and it will be very performance sensitive, but also because I don't want to yak shave with luster right now :P &gt; Good luck in your project! Thanks, good luck with way-cooler!
I'm most in favor of prefix as it draw attention to expressions. I find the argument of having to move your cursor back to the beginning of the line if you forgot to annotate await to be uncompelling. I also find await with braces (or parens) to be a non-issue, and like to think of them as await-blocks `await{expr}`. Postfix macros would be my second choice (only since sigil based operators are off the table [`@` being my favorite]). Magic fields and magic methods both sound like the worst of all worlds. Magic fields scares me the most as it's the least like any other Rust syntax, and the most implicit. A final note, I dislike the comparisons of `await` to `?` on the grounds of similarity; as one is a keyword and the other is a sigil based operator.
Thanks! :)
Yeah we've switched over to use LLD on Windows as well for our project with quite a lot of dependencies and got a massive speed up (5x) so can't live without it
Cargo features should be additive; if a crate compiles using desse with the dynamic feature disabled, it should also compile with the dynamic feature enabled. Suppose there's some library A that depends on desse without the dynamic feature, and some library B that depends on desse with the dynamic feature. If my crate depends on both A and B, Cargo will build desse once, with the dynamic feature enabled, and use it to build both A and B. If the return type of a function changes when the dynamic feature is enabled, A probably won't compile and my build will fail. This is a bit of a complicated issue, because it's not just changing a return type that can cause issues. Changing a parameter type will also cause problems, for similar reasons. Adding a method without a default implementation to a trait will break impls that were written with the dynamic feature disabled, because they'll be missing the implementation for that method. What I would recommend is instead of having methods that work on vecs/slice references, have the dynamic deserialization take any type that implements `std::io::Read`, and the serialization method take any `std::io::Write`. Slice references (which you can get from both arrays and vecs) implement both traits, and this way also gives you the option to read/write desse types directly to/from a file/socket/etc. You could then make a method that creates a Vec and serializes into it as a convenience, and gate that behind the dynamic feature (as long as it has a default implementation).
I work in games, though I haven't been using rust at work, there is a contingent of people interested in it at the office, and I've used it in hobby projects (like this one: [piston shooty](https://github.com/GamesFromRust/piston_shooty)) and others. My experience so far makes me confident it will (someday) be something I'd use in production, and there are 2-3 companies doing it for their next projects now.
thanks! that's a great solution ! But then if I want to make my library a bit usable, I would need to implement the Copy trait to the Set struct. Do you know if there is a way to implement the copy trait for a closure ?
Essentially, a controller runs a loop that pops the deltas from the queue and then does something with them. I think your state is a btree map under the hood, so you'd need something with queuing semantics. The go implementation is here https://github.com/kubernetes/kubernetes/blob/82cb4c17581752ae9f00bd746a63e529149c04b4/pkg/client/cache/delta_fifo.go
This has already been debated at length: https://internals.rust-lang.org/t/explicit-future-construction-implicit-await/7344
We should have a discussion about whether reddit is an appropriate place to have a discussion about where documents discussing language design changes should be posted for discussion.
This forum isn't sufficiently Free for FOSS, we should really be using IRC or Electronic-Mail or DNS TXT records to discuss such a vital issue of freedom
Put them all at the top level (next to main) and declare them via 'mod' in main.rs. The 'mod' statement simply names a file that is a submodule of the current module, it shouldn't be in the files that want to use said submodule. In `routes.rs` you can then `use crate::types::foo;`.
I don't mind. Works well even outside of coding. Passive aggressive code will now be a thing! I don't find `excessively_nested_future.await().await().await().await().await().await().await()?` easier to interpret.
Agree. I'd be okay with some kind of postfix operator, if it looks and feels natural, but \`get\_response().await\` is AWFUL in that it completely interrupts my expectations for what comes after a \`.\`
I know some of those words...
I used to work on a WebRTC server and I can definitely say that SCTP is a sore point in that whole stack. I don't know of another complete implementation of the protocol than usrsctp, and that library has some serious issues when you try to scale up traffic through it. For instance, I've seen it take down jitsi videobridge due to memory-related errors (what looks like use-after-free). From what I can tell those issues are still unsolved. &amp;#x200B; ICE and STUN are important as well - many corporate networks will block UDP and therefore those clients will need to fall back to TCP/HTTPS for connectivity. From my experience, about 10-15% of participants in calls ended up on TCP-based transports. However, that is also influenced by how you set up ICE candidate selection - in at least some cases, UDP is available but TCP wins the ICE race and is selected for the transport.
I also work in same industry as you as Computer Vision and Embedded System Engineer. People don't even know about Rust in my company, let alone use it.
`... ... ...` looks amusingly similar to the "progress is happening" output of some long-running console programs, too. Not necessarily a bad thing, just mildly entertaining enough to draw attention to, so that others might enjoy it.
I did a tic-tac-toe game in rust that allowed for boards of arbitrary size, and I used a HashMap&lt;(usize, usize), Cell&gt; pub struct Board { cells: HashMap&lt;(usize, usize), Cell&gt;, size: usize, } enum Cell { X, O, } So my board's cells only contain entries for occupied cells, which would have the useful property of allowing to to iterate over all occupied cells while skipped over unoccupied ones practically for free. &amp;#x200B; So the follow board state: +-+-+-+ |X| |O| +-+-+-+ |X| | | +-+-+-+ |O| | | +-+-+-+ Would be stored as: (0,0) -&gt; X (0,1) -&gt; X (0,2) -&gt; O (2,0) -&gt; O
I work in the construction industry, and I am currently using Rust to write CAD software.
As I understand it, when deriving `Ord` and its necessary trait bounds on an enum whose variants hold no values like this: #[derive(Eq, PartialEq, Ord, PartialOrd)] enum CardSuit { Hearts, Spades, Clubs, Diamonds, } The behaviour when comparing variants of `CardSuit` is that `Hearts` is less than `Spades`, which is less than `Clubs` and so on. Is it acceptable to simply order the declaration of variants in an enum to set up the desired ordering? It seems a little obscure, but looks better implementing `Ord` with a long match or with `std::mem::discriminant`.
We're not planning to introduce proposals for those things, especially since as you pointed out they're far away from the roadmap goals for the year.
You can explicitly set the discriminant if you want the derived `Ord` to use a different ordering than the declaration of the variants: #[derive(PartialOrd, PartialEq, Ord, Eq)] enum Suits { Hearts = 3, Diamonds = 2, Spades = 1, Clubs = 0, } fn main() { assert!(Suits::Hearts &gt; Suits::Clubs); }
You can define member methods on a struct directly, althought you won't be able to use inheritance for them (as it is not a thing in Rust). You could go about like this: struct Board{ current_board : Vec&lt;i32&gt;, next_board : Vec&lt;i32&gt;, } impl Board{ fn new(current_board : Vec&lt;i32&gt;, next_board : Vec&lt;i32&gt;) -&gt; Board{ Board{ current_board, next_board, } } fn calc_next_for_field(&amp;mut self, x : i32, y : i32){ // Code here } fn swap_boards(&amp;mut self){ // Code here } } Now, this wouldn't necessarely be the best way to go for a Rust-ish style of such a thing, as the OOP mindset in Rust exists, but not in the same way as Java (You'll want less encapsulation and more dealing with data). You can recognize the static methods by the absence of a `self` parameter, so `new`, which is akin to a factory constructor in Java, will be what your users will usually use to create an instance of the object. Meanwhile, the `calc_next_for_field` and `swap_boards` take a `&amp;mut self`, since I suppose you want to modify the own object state, as not doing so in Rust with functions that don't return anything wouldn't really accomplish much here. Keep in mind this might not be the way you'd see this done in Rust, but it's more or less the exact translation of what you asked, except maybe for the fact that `Vec` is a resizable array, but it's quite simple to deal with in your code and as an introduction going for `Box&lt;[i32]&gt;` instead wouldn't really bring you a lot of benefits. Use Traits when you have to describe common patterns for the objects you are describing, they are more similar to a mix of abstract classes and interfaces, as in you can define required functions and functions with bodies using the functions you required in the trait, aswell as default overridable implementations, but you can't define additional data fields like you would with abstract classes. The advantages are having a more powerful set of what would be interfaces in Java, and you use traits to define what generic bounds should accept in generic Rust code!
The GUI part sounds great - I could have used that a while ago (and still can if I find the time). I wish there was a 2d crate with similar design goals as kiss3d, but current frameworks want to be a fully fledged UI framework instead of a kiss solution (understandably so). I actually ended up "misusing" kiss3d for my 2d-scene which worked out fine. Thank you for your work on kiss3d!
On Discourse's second scrollbar: Personally, I feel like that scrollbar gives it the only sane implementation of infinite scrolling I have ever seen. I also feel that infinite scrolling is the wrong solution for a forum, though, so either both ought to go, or neither (or, even better, a user-visible display mode toggle! The reddit redesign has shown me that a lot of such preferences will depend on what sort of media you expect to find in a given community, so some threads are probably very well suited to infinite scrolling, so even an account-wide toggle might be to coarse).
Data analytics for TV industry. Full time Rust (basically every dev in company except frontend and devops is primarily working with Rust).
not **every** one: some time ago I posted this one: [https://www.reddit.com/r/rust/comments/ahahqj/job\_rust\_engineer\_position\_in\_stuttgart\_de/](https://www.reddit.com/r/rust/comments/ahahqj/job_rust_engineer_position_in_stuttgart_de/) &amp;#x200B; BTW: We are still looking for some more people (this time only part time).
maybe the wording "guards" could be interesting instead of "protectors" ?
I did a POC of an operator using the operator-sdk, and I really felt like the APIs were cumbersome. I ended up writing our operator using [metacontroller](https://github.com/GoogleCloudPlatform/metacontroller), and implemented the webhook with Rust. I think it worked out pretty well, but I also think that a "batteries included" operator framework would ideally be something I can use just as a library instead of having a whole separate deployment, and I'd love to see a Rust library for that. This seems like a good start, so I'm excited to see where it goes. What I'd really love to see is an operator framework that provided an API similar to what you get with metacontroller.
For me, it worked the *second* time I opened the link, so either someone changed the permissions in that narrow time gap, or dropbox is doing some sort of shady fuckery to try to make people sign in or create accounts. Or maybe they have some idiotic "guest viewer (rate) limit".
Yeah I guess that'd also work. I am not a native speaker, so I am not aware of all the connotations. I'll consider it next time I rename everything. ;)
Heh, yeah, it's a complex topic so trying to compress it down is hard. If you want to understand it more fully, I'd definitely recommend checking out the learnopengl.com articles on PBR, which starts [with theory](https://learnopengl.com/PBR/Theory) and ends with [implementing specular IBL much like I have](https://learnopengl.com/PBR/IBL/Specular-IBL) :)
Time synchronization sector (yes it's a niche). Rust is perfect for crash-proof long-running processes with controlled RAM consumption, be it on embedded systems or big iron cloud machines.
If we could incorporate a blockchain somewhere, they would be best.
&gt;Keep in mind this might not be the way you'd see this done in Rust, but it's more or less the exact translation of what you asked How would it normally be done in Rust? &amp;#x200B; &gt;`Vec` is a resizable array, but it's quite simple to deal with in your code and as an introduction going for `Box&lt;[i32]&gt;` instead wouldn't really bring you a lot of benefits. Wouldn't I need a Box if I wanted to simply swap "Pointers" (when switching content of `current_board` and `next_board`) ?
Given their [history of sexism](http://valleywag.gawker.com/dropbox-has-a-conference-room-called-the-bromance-cham-1522825779) I have avoided Dropbox altogether. If you believe the [current self-evaluation](https://blog.dropbox.com/topics/company/an-update-on-diversity-for-2018) they look much better now, so maybe I should rethink that. I also am uncomfortable to the degree with which Dropbox has tried to monetize me: I really am not interested in being pushed toward their paid service. This raises an issue that is important to me: do we really want to tie Rust to the whims of somebody's corporate culture, and if so how do we choose which one? I would be much more comfortable with a Google Doc than a Dropbox Doc, for example, but I'm sure there are people who feel the exact opposite… The Github Wiki might be the right place to handle document editing and review: it certainly is more in the spirit of open source. That said, I understand that there are problems with that solution as well. This apparent push toward for-profit Rust development tools exemplified by Discord and Dropbox concerns me: it looks like it concerns others, too. I'd really prefer that we use open or at least explicitly open-source supportive infrastructure as much as we feasibly can as we develop Rust together. To be clear, I am 100% certain that the Rust leadership is just trying to make things work as well as possible. As always I thank them for their tireless and invaluable service.
&gt;How would it normally be done in Rust? It really depends on the problem, but for example you would have your functions returning something instead of acting on a mutable state and considering to use free functions if your class is not really describing an object but just a few steps of a process (Keep in mind this is not always applicable: for example a sorting method would mutate state and not returning something and smaller classes may exist to expose specific details of what you want to show to the user instead of allowing them to access the inner object entirely). This said, you should experiment with the design as you like, you'll learn with experience and by asking for code reviews to community members, a lot of people, including me, will help you for sure! &gt; Wouldn't I need a Box if I wanted to simply swap "Pointers" Not really, you can swap the two `Vec`s without extra allocations or anything just by using `std::mem::swap`, which as specific as it sounds, it's extremely practical, safe and efficient, and will work with pretty much any type you have a reference to mutably. Also this is something Rust does well, since by default move semantics are applied, which mean that you'll pretty much never copy huge chunks of data inefficiently without requiring some explicit code to do so (for example `.clone` calls on container types or big structs you have a reference to).
&gt; I don't know of any collaborative option that is in widespread use in the community. Wikis are sometimes used. Not quite the same thing, but has some advantages in addition to the disadvantages: for example Github provides them automagically; document edit history is well-supported.
I work on web search, and write mostly C++ for a living these days. I'd certainly prefer to work with rust. Ideally, a search engine, a DB, or something low level like an OS.
You can't implement Copy in your case because you have `Vec` and `Box` and those aren't `Copy`-able (they are `Clone`-able though). The difference is `Clone` implementations are allowed to do things, while `Copy` is only good for bit-level copying (you can copy a u64 by just copying its bytes, but you can't copy a `Box` because now you have two `Box`es pointing to the same data, thinking they own it).
If you want to set this globally, you can set jobs to the number you want in the build section of ~/.cargo/config See: https://doc.rust-lang.org/cargo/reference/config.html
Question about reference/deference, context: I am going through the book, chapter 12 with minigrep. I couldnt understand the order of operations when doing: &amp;args\[0\] when args was of type &amp;\[String\]. I looked it up and array indexing has higher precendence. Then it was a bit weird to me how we index into a reference. What would seem "natural" to me is to do deference and then index. It seemed to work and they both seem to have same type. I wonder if we there is simply no difference, and that it is not necessary by the language/compiler, but it happens behind the scenes? &amp;#x200B; To make it more clearer, I've created a playground link (disregard bad naming). [https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9a9475312d13e66454fef662f922d855](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9a9475312d13e66454fef662f922d855) Printing the addresses, it seems to me like it is exactly the same. If there is a difference then my next question is (Q2 in playground): why is args\[index\] type of String, when args is of type &amp;\[String\]. Basically I am looking for how to think/reason about it to have a better mental model of it. Thank you PS: assume I am ultra noob, this is my first day of rust. Previous experience(not work) with java and python.
I made this little survey because I'd like to know how do people *feel* about the different propositions being discussed for the `await` syntax. I've seen people arguing about it here and on the internal forum, but I think the majority don't want to spend too much time arguing about features, even though they have their own preferences. So, if you've been silent on this topic so far, I'd love to hear your thoughts! Also, English is not my native language, so please correct any mistake I made in the process!
If the ordering has significance (like suits ranking in certain order for poker hands or something) then you should make a unit test that asserts the order. This will protect against an unwitting change.
Wikis are quite far from the kind of realtime collaborative editing environment that Paper provides.
Old post - but in that scenario do you have any way of filtering inputs? Eg, I drool at the idea you laid out but in my case i'm not sure how we would use it (or this tool). I'd be most curious to see the I/O of a small subset of data, even from individual functions. Think of a number crunching app that crunches thousands of IDs. To debug, you may only want to see one ID travel through a program. Same thought might be applied to sessions, where you want to see the program flow of user X. Does your macro stuff handle this? Not that it's applicable to me, just curious about design and how it could be used in something like `log-derive`
I picked up Rust on my own as a student looking to learn a language for experience sake and quickly applied it for some work for automotive management, today I am looking into applying it for some embedded development in telecommunications.
money laundering
That’s a great suggestion. The only problem I can see is that I also have to support no_std environments. Read and Write traits are only available when you compile with standard library. Are their any alternatives to Read and Write which I can use in no_std?
&gt; If I ignore the fact that Rust is still new, I’d be happy to see a learnyou variant in Rust. Why not (also) a [Learn Code the Hard Way](https://learncodethehardway.org) variant?
You seem to be missing the postfix keyword separated by white space case.
Extremely cool! Thanks for the post, Ralf. I am particularly excited for the potential in tracking raw pointers with the new model.
I annotated your example and hope that clears things up: [Playground Link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=58aff5cac918510b359b02efba41dd8a) Basically, you can just mentally search and replace types in your code. A `&amp;[String]` yields `String`s when indexing. `*` dereferences the reference indicated by `&amp;` (think `+1-1`), so that'd leave you with `args`. Since `String` is not implementing `Copy`, getting one by indexing into the slice would constitute moving it out of that slice. Which is immutable, so an additional `&amp;` is necessary. This leaves us with a `&amp;String`.
Might be a necessary evil, regardless of the sharing platform. People with something important to say will hopefully come back later to comment, and people that just want to react or troll during the initial traffic will be more likely to just forget about it. The struggle of public discussion.
Wrong subreddit.
`await?` does seem like a weird special case.
System76 is using Rust in a wide range of areas. From open source firmware development to desktop applications for Linux. The infrastructure for Pop!_OS is written in Rust, as are our system services, tools, and desktop applications. On the hardware and business side, we do have a receiving / inventory / assembly GTK UI written in Rust. If you're a Linux developer of any kind, Rust is already perfect. The only thing I'd really like to see is more focus on async File I/O, rather than focusing exclusively on networking.
You're right, I couldn't easily figure out how it would work. Would it be like this ? ``` let str_response = http::get(url) await?.to_string(); ```
First of all, I assume that you forgot to mention that you actually implement Parser for every Fn. Here is the impl I used, just so you know: impl&lt;'a, F, O&gt; Parser&lt;'a, O&gt; for F where F: Fn(&amp;'a str) -&gt; ParseResult&lt;'a, O&gt;, { fn parse(&amp;self, input: &amp;'a str) -&gt; ParseResult&lt;'a, O&gt; { self(input) } } Let's fix and explain the second error first. Your free-standing top-level `map` takes a Parser and a mapper function and returns a Parser. `Parser::parse` returns a `ParseResult` if applied (to self and) to an input string. On the other hand, the method `Parser::map` takes `self` which is a Parser (`Self: Parser`) and a mapper function but returns a concrete element(!), a ParseResult. Such value can only exist if there is an input string (`input: &amp;str`), right? You cannot create such a value from thin air. There are two ideas to fix it, one of which does not work though: * `Parser::map` returns a Parser like `map` (point-free style). This does not work, neither `-&gt; impl Parser&lt;…&gt;` (the language does not support this yet in this context) nor `-&gt; Box&lt;dyn Parser&lt;…&gt;&gt;` (the trait is not object-safe). Sorry if you planned on doing that. * `Parser::map` takes an additional argument, namely `input: &amp;str`, using it inside the body: `map(self, map_fn).parse(input)` Onto the first error message. Unfortunately, is incredibly misleading: It states that `Self` (`Self: Parser`) does not implement Fn/is not a closure. Really, the compiler wants to say that `&amp;Self` does not implement `Parser` (`&amp;Self: Parser`). The bad error message shadows the real one everytime you implement a trait for all Fns. Just for debugging, if you replace any code that ties Fn and Parser together, you'd get the desired error message. Fns seems to be handled specially when reporting errors. I might have to do with issues of overlapping implementations of Fn. Whyever, it checks `&amp;Self: Parser` -&gt; `&amp;Self: &amp;Fn` -(there is an impl, so that `&lt;F:Fn&gt; &amp;F:Fn`)-&gt; `Self: Fn`, hence the error message. To recapitulate, `map` wants a `P` (`P: Parser`) as an first argument but you pass it `self` in `Parser::map` which is of course of type `&amp;Self` (method taking the `&amp;self` parameter), so it's of type `&amp;P` (`P: Parser`). I solved this by changing the signature in `map` from `P` to `&amp;'a P` but note that I was forced to add a bunch of lifetime annotations. You might also be able to `impl&lt;P: Parser&gt; Parser for &amp;P`, no idea how this plays out. I could've sworn I found a solution which consumed `P`, although I cannot remember it anymore. So there might be other ones. Anyways, [here's a playground link](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0ea5f87cec2bdffb0aa9e0fb49c2a62a) to a version which compiles.
Just to ask the "dumb" question: Are you sure it might not be worthwhile for the upstream crate to add a new feature? Maybe your special case is not that special or could be generalised to some extent?
Think of it as &lt;signature&gt; { &lt;signature&gt; { val=10 } &lt;signature: exit status&gt; } &lt;signature: exit status&gt; The only filtering is levels and which debug binaries are installed. I'd then use my log browser to filter further. I've wanted to make a dynamic version of this with Intel's pin library but never got around to it.
I like the form that’s equivalent to the C# syntax. I don’t know much about how it’ll work in Rust, but I immediately understood what the line in TFA was doing.
Seriously likely the true answer. For anyone taking these jobs they should know most of these projects are scams. The technologies they claim don't exist and the projects don't deliver
Will you publish the results?
So, first of all, unless memory safety is on the line, just make the fields public. Life will be so much easier, trust me. Second, you can perhaps place the tests inside the module that declared the struct? Though perhaps that's what you meant by "unit tests" and "integration tests"? If so, yes, make more unit tests until they sort out whatever the problem turns out to be.
I just created a stub project having a `main.rs`, `lib.rs` and `shared.rs`. In *both* lib and main I simply write `mod shared;` and can access the public constant I put in for testing. So only one file, one place to define stuff, reusable in both and still controlled visibility to outside crates.
`fut.await!` postfix "macro" without parentheses.
How does it compare to Quip? I’ve been using that for personal use and I like the collaborative part of it.
I notice this is missing my personal favourite alternative of mandatory delimiters like await!() and await{}
I added this to a personal project on Monday. Whilst rustfmt doesn’t seem to touch it, vim happily indented it properly, which was most of what I wanted.
Agreed. For me it makes sense if they *are* method calls (or trait implementations) and I can find it pretty interesting and nice when languages actually manage to implement this in some kind of method calls (e.g. if you say that "match" is just a trait that is implemented on some types and you can implement on others, ok why not have foo.match but if it's a keyword it's a bit weird imho)
I'm happy with postfix sigil. `foo()#?.bar` is another good option.
I don't have a strong opinion on await syntax, but I love this idea of UFCS for macros.
Here is project repo: [https://github.com/PsichiX/your-time-is-currency](https://github.com/PsichiX/your-time-is-currency) Also you may want to check engine: [https://github.com/PsichiX/oxygengine](https://github.com/PsichiX/oxygengine) I'll make updates about progress in production and a full tutorial about making web games with Rust! :D
Simulation networking. What led me to rust is that I love learning new PLs and Rust is very relevant to what I do (mainly C++ design and development). Rust is rather lacking in my domain, and Rust is most likely not something that will be adopted into the products we work on.
That’s my understanding. It’s also my favorite as I think it’s readable, Googleable, has clear precedence, and clearly not something it isn’t: a field, a method, a macro, a method-location-macro (which would look like a feature but isn’t). It definitely spends from the weirdness budget, but to me no more than any but the vanilla prefix or looks-like-a-normal-macro options. I find it a bit strange that it’s not more discussed or refuted. I’d be interested to hear the problems other than that we expect keywords to be prefix operators.
I just got done figuring out how to get a AWS lambda function written in rust running locally. Next up: get it talking to a local instance of Amazon's dynamo DB. &amp;#x200B; With that, I think I'll be able to use my laptop as a dev environment for a lambda based system written in Rust.
This is the answer! Thank you!
I think the reason for preferring "guard" has more to do with programming jargon than English per se; indeed, "protector" may well be the word an English major with no programming background would choose if the desired concept were explained. But in CS stacks have guards and that's that. =)
Wow nice! This might be of interest to you. I *just* release this tool for side-channel fuzzing: https://github.com/phayes/sidefuzz
You can also set it as an environment variable for less-permanent-than-a-config-file but more-than-one-command: https://doc.rust-lang.org/cargo/reference/config.html#environment-variables export CARGO_BUILD_JOBS = 1
Oh interesting. I was thinking about doing a rust implementation of RFC 3161, any interest in that?
I try to combine **sustainability** with **Rust** :) For that purpose I founded slowtec (aka **S**mart**LowTec)**. I think we really need smart technologies but IMO to solve global challenges we don't need a chip in every thing. Don't get me wrong, I really like the IoT but for me the purpose is more important than the technology itself. That's why I love to combine **smart** things (like Rust &amp; CS) with robust **low tech** (natural materials like wood) to get the best of both worlds :) To be more concrete: At the moment we're developing an **irrigation system** for green city systems (like external facades &amp; urban farming systems). The software is written in a **pure Rust stack** (WASM based WebApp + Rust in the Cloud + Rust on an embeddes Linux + Bare Metal Rust on a ARM µC). Beside that we're also doing traditional industrial automation ...of course with Rust ;-)
Thanks so much for your input. I understood everything you said, but this: &gt; Also of course the latter requires element to implement Copy. Why would/does/will it require the Copy trait?
What are you latency requirements and is your solution fault tolerant?
There are many ways you can handle this, but the most direct analog is a `struct` with methods; no traits required.
This is is dope. I will give it a try. How is this different from [`maud`](https://maud.lambda.xyz/)?
&gt;x2a\_org We are using clustering algorithms, the similarity function is coded in rust and the rust code build a distance matrix on all cores using rayon. The rest is mostly regular numpy stuff.
Woot! I visited during your open house a few months ago. It was great talking to everyone. Keep up the good work :)
As most of what we work with is ARM based, yes. Now, the hard part are the DSP cores and other specialized processing cores, but those are generally supported only by a custom compiler (one sometimes based on GCC, but still custom) and so Rust does not support those right now.
https://www.google.com/search?q=rust+"%3F"+operator I agree that it's difficult, it took me a few iterations to get a query that worked, but it's there.
Fair enough, I'd personally say `#[async]` and `await!()` would look fine, The latter is similar to existing syntax in other languages, and its explicit delimiters would put this issue about operator precedence to rest, while the former would match the "metaprogramming" style of the latter.
Time to fork it! :P
A dereference operation inherently implies a copy from one location to another; you're reading the value from behind the pointer to a new location on the stack, or sometimes writing it to another pointer. Rust forbids implicitly copying types that do not implement `Copy`, as those may own resources that are assumed to be unique (such as heap allocations, file handles, etc.). For example, `String` cannot be `Copy` because it is responsible for a heap allocation that is freed when it falls out of scope and its destructor is called (it is "dropped"); if that exact `String` instance is duplicated, then you now have two instances which think they're responsible for the same allocation, and you end up with use-after-free if one is dropped while the other remains live, or a double-free if both are dropped together. The same occurs with `Vec` but it is also responsible for running the destructors of its elements on top of the allocation it owns; running destructors twice can produce all kinds of problems including use-after-free or double-free. On top of that, if you duplicated a `Vec` then you can have non-exclusive mutable access to its elements (because they both point to the same allocation), which introduces data races as well. Both `String` and `Vec` (as well as many others following this pattern) implement the `Clone` trait which is an *explicit* copy; in `String`'s case it gets another allocation and copies the data into it, where in `Vec`'s case it gets another allocation and then `Clone`s each element into it. These produce duplicate instances that are still responsible for *unique* allocations, which is important in Rust's safety rules for the reasons described above. In `Vec`'s case however it requires the element type to implement `Clone` as well. Types that implement `Copy` indicate that they may be implicitly copied via dereferencing or other means, so multiple instances of the same identical value are free to exist. This is actually mutually exclusive with having a destructor (implementing `Drop`); you can only have one or the other, or neither; in which case it's treated as if you had a `Drop` implementation anyway, as the value may still assume that it's unique for its purposes. `Copy` also implies `Clone` which is useful in generic contexts (in which case it's just a trivial wrapper around a dereference).
unless I'm mistaken, the postfix macro syntax could be special cased in the compiler and then eventually stabilized as an orthogonal feature and backwards compatibly converted to a normal macro. So long as that holds true, it feels like the ideal postfix syntax.
[`clang -fstack-protector ...`](https://clang.llvm.org/docs/ClangCommandLineReference.html)
But the post never explains what it is actually doing, so how could you know? Because part of the debate is between which one should have precedence. I think that's the root of the issue: multiple people see that same line and think "I know exactly what that's doing," but they're thinking two different things!
What is the other thing that it can be doing? A successfully compiling code that awaits on `get()` which returns a `Future&lt;Result&lt;T&gt;&gt;`, uses the `?` operator, and calls `to_string()` can only really do one thing given the shape of the functions being called. The question is more "which of these should compile?" rather than "what is this code going to do?"
I wonder about using trailing dots instead: `http::get(url)...?.to_string();` It's closer to what you would write in an essay…
One day, someone will finally post a mod or a bot or some other tool for Rust the game, written in Rust the language, and we won't know what to do.
Amazing! I spent so many hours as a kid playing falling sand games on dan-ball and other sites. This brings me way back.
What is that second `match` matching on? My naive expectation is that the result of the first match would flow into the second, but I'm not seeing how `1` or `x+1` would match to `Quux1` or `Quux2`.
thanks for clarifying!
Rust is already basically perl.
That's correct. QUIC allows you to either send out of order via streams (each stream out of order with another) or datagrams (which are also unreliable). The WebTransport explainer and spec have examples of both, because it supports both. It is theoretically possible to do RTC media on top of QUIC by either using datagrams or streams. What's missing from the Web API currently to make that possible is either a low-level codec object (think WebCodecs) or a way to use an RTCQuicTransport within an RTCPeerConnection to replace a DtlsTransport. We've been exploring both options.
Yes, I'm familiar with that post. I had a long conversation with him about it, and that's one of the reasons we decided to add QUIC datagram support to WebTransport (it's coming to the RTCQuicTransport origin trial soon as well). QUIC datagrams are as non-opiniated as you are going to get in a Web API. The only things it adds on top of UDP are security and congestion control, both of which no Web API will allow you to bypass.
I think it also expresses the meaning of await, "..." in some sense indicates some wait time.
Is this based on / inspired by [SlowFuzz](https://arxiv.org/abs/1708.08437)?
I haven't been following the thread on this, but has the language team just considered using `{}`? await { http::get(url) }? There is already precedence for this with how rust (doesn't) handle ternary expressions: if (test) { 1 } else { 0 } With the `{}` syntax the `?` operator can go inside or outside and it will be immediately obvious what is desired by the programmer. Similarly, it handles compound situations should they arise in the future: await { future? }? No ambiguity, clear, simple. My 2c.
r/playrust
Lol thx
It's something you can do manually, but the compiler will also automatically vectorize instructions in places where it's obvious. It's hard to tell where it'll happen though so you kind of have to rely on baiting the compiler magic into working.
I think it should be postfix and strange, so you can see easily that you are dealing with something very different to anything else in the language. So postfix with an strange symbol, something like let str_response = http::get(url)#await?.to_string();
As Taylor says; I did know about the document but had not had time to read it due to lack of time and because it takes a certain amount of focus to read and write detailed thoughts down.
Your naive expectation is correct. I was just being a bit too lazy to write down a well-typed example. =P
It's not actually, but from a quick read it looks like they are based on very similar ideas. SideFuzz's genetic algorithm *loves* to find inputs that explode algorithmic complexity (so it could be used as a replacement for SlowFuzz) but is actually built to detect very subtle timing differences. The genesis of the idea behind SideFuzz is humorous. I had the idea of using genetic algorithms to find timing-vulnerabilities as a "Eureka" moment in the middle of the night, and got up and googled the idea only to find that someone else had published a paper on the idea only a few months ago. So SideFuzz mostly inspired by these two papers: 1. "DifFuzz: Differential Fuzzing for Side-Channel Analysis", Nilizadeh et al. https://arxiv.org/abs/1811.07005 2. "Dude, is my code constant time?", Reparaz et al. https://eprint.iacr.org/2016/1123.pdf
I love it. Also thanks for writing it all up so it makes a very enjoyable read!
How did you make that chart?
I also remember a DARPA project, [STAC](https://www.darpa.mil/program/space-time-analysis-for-cybersecurity), covering similar problems although I'm not sure if anything public was ever released.
Got a puzzling Piston question for you guys ... I'm trying to use an Image object (cleared out all white) as a canvas, but I'm struggling to figure out how to use `draw_2d` to draw onto that Image. My ideal draw loop would look something like this: - On startup, create a blank image ... then ... - Loop: - Check for items that are invalidated - Draw invalidated objects to Image - Display image on screen for each draw cycle - Re-render the image ONLY IF an object has invalidated - Invalidated objects are redrawn on the same canvas image - Each render cycle displays the image, skipping refresh if not invalidated If the objects are not invalidated, the canvas is undisturbed, and simply drawn on the screen for each refresh. This way, less CPU is used during the draw/refresh cycle, saving lots of time between blits. Hoping someone can assist - I've been struggling with this one for a long while now.
"The STAC program will kick-off in April, 2015 and will be 48 months in duration." That means they're just finishing up!
How much does C# use method chaining? Method chaining is really nice in Rust, and while I'm not entirely sure how much it will be used with await, it becomes almost a non-option with any prefix syntax.
Using draw.io
Great job! You should post to /r/fuzzing as well.
You’re also missing the postfix sigil option e.g. `foo@?` for awaiting a Future named `foo` and unwrapping the Result.
Oh boy, my brain definitely thought 48 months was 2 years.... But anyway, that repo looks just like the evaluation criteria on which the actual entrants would be judged: &gt; The programs in this repository were **used to test** the capability of different research approaches to achieving the program goals.
It's also missing my personal favorite alternative of postfix sigil, which would solve everything - excepted using the await keyword.
Most of the fuzzing I do is testing our targets for memory corruption/object lifetime issues, but this looks really cool. I'll have to see if I can apply it to any of our targets. Hopefully I'll be able to share some of what I've been building up soon :)
I should apologise: I blindly assumed that QUIC was reliable only, and didn't read into the proposal. QUICK Datagrams look like an appropriate solution here. It would be nice to be able to send raw packets via WASM, so you could backport some good network games, but I would assume that there'd still need to be a number of changes, and as long as there is a *UDP analogue* this would work.
Thanks. It is a work in progress, been really learning a lot about rust as i go too which is fun. :)
This is a good point, not that my projects are close to that level of attention.
A lot. See any 'fluent' API, e.g. LINQ.
Nice! Look forward to seeing what you're working on.
That's interesting, my last few roles have been data centric and I'm sure it's no surprise but I've worked with Python primarily. Having a REPL helped a lot with manipulating data. Judging by the fact it's heavily in use where you are, did you have any issues using Rust at first?
Yes they have, it's in the summary post.
Excited for when you guys are looking for someone a bit less senior :)
I like this a lot! I've been pleasantly surprised by the responses I've seen to this thread. I'm hopeful we will see more broad adoption across spaces like this. Keep up the good fight! :)
Which were presumably so named to be different from “guard pages” that are designed to give intelligible stack overflows. Guards in Rust are usually like `MutexGuard` — types that only exist to implement `Drop` and cause something to happen when they go out of scope. If it does that, call it a guard, otherwise call it whatever you like.
Also since you aren't invested in this particular issue you won't do as good a job as OP in this case.
As I understand it, the await syntax will never be a "true" macro, it will always be special-cased in the compiler. This is for a few reasons, not least that they want to be able to improve the error messages, which they apparently can't do with a macro. This is why I'm not a fan of any of the "macro-like" options, prefix or postfix, because eventually we'll be in a situation where some macros are just special cased. If I had to choose, I think I'm personally have a preference for the operator option, but that does have major discoverability issues.
This is really neat. The smoke and wind effects are definitely an eye-catcher, you should be proud of getting them to work in a dynamic context like this. My favorite thing to do in falling-sand games, though, is make saltwater stills: * Salt + water = saltwater * Saltwater + fire = steam * steam condenses to water sometime later I especially prefer when a sand game has non-colliding floors so I can have creations running for a long time without filling up the canvas. One of my recent favorite falling-sand games simulated heat transfer through wall/stone/steel elements so I could build a cooking pan into my still instead of having the water drop directly on the fire. I think it also allowed ice to condense steam faster. But it didn't run nearly as smoothly as this. Playing around with this a bit more, I expected Stone to be able to form at least small unsupported overhangs. Cloner is also not really useful with Acid since it eats itself. And maybe Plant could turn into Wood if there's enough of it?
IMHO, i rather have alternative syntax for \`?\` using \`try\` so: &amp;#x200B; let response = try await http::get(url); &amp;#x200B; But, maybe its too late to propose this solutions....
Compared to the other keywords in Rust, `async` being postfixed is a bit out of the line tho.
&gt; If I had to choose, I think I'm personally have a preference for the operator option, but that does have major discoverability issues. Discoverability and readability IMO.
&gt; but I ran into a lot of interaction scenarios while testing the game, and tried to *sand down* the rough edges eyy 👉😎👉
This is a great read. Thanks for taking the time to document your work and findings so thoroughly.
I actually just posted something to that effect on the internals thread. Really, it makes the most sens with the other syntax in rust: `?` is clearly the outlier, and while it's for good reasons it doe mix rather badly with constructs other than pure method chaining. (For instance: `let thing = match ... { ... }?` should work but it hides that `?` in such a far off place, `let thing = try match ... { ... }` is much easier to parse.)
Also true. I feel bad for just saying 'no, I don't care to do this and it's a low priority over my current goals', but it's the truth and lying about it would be worse.
The libs team just need to develop more guidelines for the standard library, so that new APIs aren't added that have these types of issues. I know you know this, but clippy does actually have a lint, that will tell you to use `self` instead of `&amp;self` here. So just using clippy on the standard library would be an improvement.
So how can the document have Lang team consensus and agreement if members of the team haven’t read it, and disagree with parts of it?
Well some of it *does* have consensus but anyways... shit happens. My disagreements with the document, where they exist, are included in the gist above.
That should be possible like this: WASM &lt;-&gt; JS &lt;-&gt; WebTransport/QUIC &lt;...&gt; ProxyServer &lt;...&gt; GameServer. That's assuming you don't want to change the GameServer and it's easier to put a ProxyServer in front that does QUIC on one end and QUIC datagrams on the other. If you can change the GameServer, then you don't need the ProxyServer.
I just noticed this in futures 0.3: https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.15/futures/lock/struct.Mutex.html
Now we just need an OE-Cake clone written in Rust
It is possible that function returns `Result&lt;impl Future, Error&gt;`, then `await func()?` becomes more tricky.
So what you want is essentially python? :D ;) - jk, cool project
I was thinking of that, but I don't see how it would work. If our function A is calling function B which is available in a sync and an async version, how will the macro know? Wrap every method call in a macro? Update the macro for each function that is available in two versions?
Thank you for the thoughtful response. Admittedly I was just poking fun at how inaccessible your comment was for those who are unfamiliar with the subject matter (or rather just how complex sounding the terminology of the topic is). I actually have a strong background in CGI (both design and mathematics/engineering), so I did in fact understand; regardless, I appreciate the links you shared and I'm sure others will as well.
Your argument is not very strong. Postfix macro would also solve everything(event the await keyword) – and even more if it gets universally usable. So by this definition you have to chose postfix macro – it solves more than postfix sigil. if we have universally applicable postfix macros users would already be familiar with the concept at the time they hit async/await. `"I am {} years old".format!(42);` would be one of the first things a newcomer have learned. `future.await!()` (or optionally discard parentheses for macros with only one parameter) would be instantly recognizable. Nothing new to learn here when arriving at async/await such as new sigils etc.
Ah, I had no idea about `crate` referring to the current crate. Thanks!
It makes the `await` look grouped with what comes after it (`?` and subsequent method calls) but separated from the future it applies to.
Thank you for posting this! It's so exciting to hear that people all over the world are as hyped about Rust as I am ^_^
Personally I would have liked to see more people considering using a postfix tilde syntax. I find it more elegant (than either the verbose `await` or a postfix `@`) and intuitive, because it looks a bit like a windy path, or a squiggly time axis. `let response = http::get(...)~?;`
There are other job posts. For example, a startup working on deterministic execution technology made a post last month: https://www.reddit.com/r/rust/comments/baohwd/job_rust_software_engineer_remote_startup/
&gt; As I understand it, the await syntax will never be a "true" macro, it will always be special-cased in the compiler. I strongly disagree and think better error messages for macros would be better than making something that is at its core, and AST substitution would be better than making special cases things like this.
If `get()` instead returns `Result&lt;impl Future&lt;Result&lt;T&gt;&gt;&gt;`, then should `await get()?` compile, or does `await` (longer and further away) bind stronger than `?` (shorter and closer)?
At i wrote in a comment directly on this post, wouldn't you prefer using `~` instead of `@` for this?
Have you read [this](https://paper.dropbox.com/doc/Await-Syntax-Write-Up-t9NlOSeI4RQ8AINsaSSyJ)? The language team has already decided that a sigil is not going to be used.
the make keywords a macro feature, a macro with no following parenthesis and exactly one parameter will consume the first following expression as its parameter // Future returns value let value = await! future; let value = await! { get_future()? }; // Future returns Result let value = (await! future)?; let value = (await! { get_future()? })?; // Alternative unwrap macro let value = try! await! future; let value = try! await! { get_future()? };
There are also match guards in rust, so it's not a word reserved for resource manager types.
Does it really matter if its a "true" postfix macro or not? I know the problems with the macro (you could also fake generators with it etc. that's the reason the lang team don't wont to commit to stabilize the current marcro) but from the user perspective there is nothing new to learn. If you are familiar with `"I am {} years old".format!(42);` – which is one of the first things a newcomer would learn – you are ready to go with postfix await macro. It's not very important for the user if that macros is spacial cased in the compiler or just an ordinary macro.
It's possible that it runs out of memory simply due to running too many linkers at once. You may find it better to pass `-j2` to your `cargo test` or even `-j1` where your CI appears to have 4 CPUs so cargo is defaulting to running 4 tests in parallel, which, unfortunately for doctests, means 4 links in parallel.
Yes, that's what I'm really missing. I need this for recomendation systems, simple classificators, natural language processing, etc.
Amazing work
That actually does sound better than than “internal thread 2 beta” in two months.
Am I right in assuming that this will only ever work for libraries that are meant to be used only when compiled to WebAssembly? LLVM backends can turn branches into conditional moves and `select`s into conditional moves, table lookups or branch trees, which have vastly different timing behavior. This can be done not just based on the architecture, but even depending on the specific processor family you're building for (eg. Skylake might be better/worse at certain branch predictions than other µarchs, so building with `-Ctarget-cpu=skylake` might make different choices there). If so, this should be noted in the readme, since it might give people a false sense of security otherwise.
I think this is a way to avoid this problems? [https://github.com/rust-lang/rust/issues/51751](https://github.com/rust-lang/rust/issues/51751) [https://github.com/rust-lang/rust/issues/51719](https://github.com/rust-lang/rust/issues/51719)
Update: The link doesn't seem to be visible from [new Reddit](https://www.reddit.com/r/rust/comments/bj7eoq/stacked_borrows_2/), only from [old.reddit.com](https://old.reddit.com/r/rust/comments/bj7eoq/stacked_borrows_2/) ([img](https://i.imgur.com/FMNl2Bs.png)) Link in question: https://www.youtube.com/watch?v=t557dPspLxo