This is a community about programming. But some people are attempting to turn it into a political battle, where all that matters is a subjective measure of “privilege”, which will only trivialize and ostracize people and destroy the community.
does elsewhere really include this same reddit forum, in a post currently visible on very the same page? that's pretty interesting, if so. my interpretation would've been that they're talking about a location not under their authority.
The CoC tries to make it an inclusive community. Calling the CoC and diversity initiatives "racist" and "sexist" because they give a platform and a safe space to less represented groups is the only case of "identity politics" I see here. I have never seen anyone trivialize *anyone's work* because they were a white man. There have been plenty of cases (historically) of women being written out of history, however.
As I stated in the post you would have to have an incredibly draconian reading of the CoC to state that the tweets in question, from her personal twitter account no less, have any grounds for a CoC violation. Making jokes on twitter is not grounds for a CoC violation. You have to intentionally misread the posts in question to claim that. I would prefer if you referenced a particular tweet/comment that you felt violated the CoC. As I said, many of them would have been _had they been posted on a rust medium_, but should not be considered a problem on someone's personal twitter. Even then, they would have probably just been deleted by a moderator -- not caused for someone to be disqualified from a team position.
I never said that.
I don't get this: &gt; [() now implements FromIterator&lt;()&gt;;](https://github.com/rust-lang/rust/pull/45379) check the PR for a neat use-case. Could you someone break this down carefully?
https://www.reddit.com/r/rust/comments/7o5ztn/where_we_discuss_drama_surrounding_ashley_williams/ds7iu0y/ &gt; The majority of people believe that fighting racism with racism and sexism with sexism is sheer hypocrisy, and those who do that come off as juvenile bozos with an axe to grind. It's possible I misread you and you were referring to her _tweets_, not to the rust policies. In which case... maybe? It's hard to say what the most "effective" method is for any kind of activism. However, again I state that being an activist in your personal life is not a reason to bar someone from a community team. Edit: and again... they weren't really "racism" or "sexism", they were _jokes_.
Full disclosure: I'm a man. (wow, what a surprise) I dunno though. Men aren't a small, ostracized culture. Killing all men is pretty tongue in cheek because...yeah, I don't know how to say it well, but there's an issue here in conflating "jews" with "men". Also, I'll be sad about Ashley's comments in a world where people fight as hard against "kill all muslims", or "kill all jews" as they do against "kill all men". 
If a healthy discussion is not an effective way to reach someone then I assert that there are few methods available to us on the internet anyway. From my personal experience: upon reading the thread and seeing "people silenced" and "posts deleted" I _personally_ felt a level of outrage. Instead of staying angry I decided to do some research and start a thread in as considerate a way as possible, but not everyone will do that.
How are you so good at writing thoughts? (no sarcasm) (this is just another "well said!" post)
Fair point! I actually really like Ashley, her talks and I think she’s an absolutely brilliant developer. I’ve been all over the map with replies and threads so it’s likely I’ve not made sense or out of context. Mainly I just have concerns that putting activism above all else can be toxic to the community, that’s all.
Same here, and I'm a man. Way to go, Ashley! Good on your for making them squirm.
What's HN?
I think it would be good if you took a look in a mirror and made sure one of those people weren't you. You are making generalized statements here. If you want to be offended by someone's personal twitter, seriously check out [Steve Klabnik](https://twitter.com/steveklabnik)'s, one of the best community outreach members we have. He's got LOTS of opinions (and I love him for them, even if I don't agree with them all). A toxic community would be one in which we ostracized individuals for their personal beliefs and opinions.
Just tested it, no colors in cmder
First I'd note that the (majority-male) community and core teams have made this decision themselves (see [post](https://www.reddit.com/r/rust/comments/7nx3cm/announcement_ashley_williams_joins_the_core_team/ds681lz/?context=5) from member of the community team on being sovereign in decisions) and so collectively aren't seeing an issue here, be that because they've raised concerns and they're resolved, they don't see the issue in the first place or whatever. Part of this whole 'making their own decisions' means they don't actually have to justify said decisions to the outside world, and I personally feel I trust them to make decisions like adding new members. Second, your comparison is obviously absurd. If you really struggle to see why, let's talk about actual actions (of Ashley, I'm sure you can fill in the blanks for the other half) - thus far she has been coordinating the community team, and doing a pretty good job of it from what I can see, both keeping existing things ticking over and introducing new initiatives that other people like. The channel is public so you can observe meetings, the logs are public so you look at what was discussed, the community team even have a repo where they track what they're up to! Again, I point these out not to handwave away the tweets (which I don't currently have an opinion on), but instead to point out that you lower any attempt at reasonable discussion (and cast doubts whether you even want one) with such a ridiculous comment.
I appreciate the thorough and thoughtful reply, and I believe you have assuaged many of my concerns. It’s possible I didn’t understand the context of that original tweet.
Thank you for the clarification!
Perhaps you could try sift through Rust's codebase for some inspiration. On that note, there are quite a few naming references from the anime series Puella Magi Madoka Magica. As to why there are, [it's been asked before](https://www.reddit.com/r/rust/comments/6hirku/why_are_there_so_many_madoka_references_in_rusts/).
What's the downside of using a `for` loop or `for_each`? 
foo/bar, unimplemented!(), _blah
For those of you interested in following along: http://bzm3r.github.io/ (click on ash-tutorial.pdf) Please do leave constructive feedback. My writing especially, is never good the first time...
&gt; They also tend to frame the criticisms of the status quo as attacks on white men, rather than as criticisms of a system that has institutionalized the promotion of white men for essentially all of history. Okay. Help me understand this: I am white male. I am also Slavic from former Yugoslavia. My parents were fired from their jobs because my father's nationality is that of other country from former Yugoslavia. Am I oppressor or oppressed? Or are you talking about western Europe when discussing white males?
Jewish men are richer than average. Asian men are better off than average. And neither were loved historically. I don't think you are factoring in those things seriously. And as both groups are over represented in Silicon Valley (regular white males are actually somewhat under represented, proportionally to population), I suspect you people are maybe using "white male" as a way to camouflage criticism of other groups. A "code word," maybe?
Are you sure? They seem pretty out there. [Here's](https://www.reddit.com/r/node/comments/6whs2e/multiple_coc_violations_by_nodejs_board_member/) a megathread from the Node drama she caused, it has dozens of tweets. They're not all that bad, but there are a few "kill all men" tweets (and no, that doesn't seem like much of a joke). She's never, to my knowledge, admitted any wrongdoing or apologized in any way at all. I'd rather not have someone on the Rust team who frequently tweets racist and sexist nonsense.
If it was a man being appointed who tweeted shit like "kill all women", would you also be totally fine with it? Personally I wouldn't want someone tweeting sexist nonsense either way, but it sounds like you don't think her tweets are sexist. And, to head this off at the pass, women also aren't a small, ostracized culture.
It wasn't even satirical. [Tweet in question](https://web.archive.org/web/20160807212533/https:/twitter.com/ag_dubs/status/761962956431187968) (or one of them at least, I'm pretty sure she tweeted "kill all men" multiple times). Imagine if someone linked a news article about a shooting, and someone else responded "kill all black people". Followed months later by "Oh, I was just joking." It's really not a valid excuse here.
This post is extremely juvenile for the Rust community. Please stop.
**École Polytechnique massacre** The École Polytechnique massacre, also known as the Montreal massacre, was a mass shooting at the École Polytechnique in Montreal, Quebec, Canada that occurred on December 6, 1989. Twenty-five-year-old Marc Lépine, armed with a rifle and a hunting knife, shot 28 people, killing 14 women, before committing suicide. He began his attack by entering a classroom at the university, where he separated the male and female students. After claiming that he was "fighting feminism" and calling the women "a bunch of feminists," he shot all nine women in the room, killing six. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
This is what `CStr`/`CString`, `OsStr`/`OsString`, and `Path`/`PathBuf` are for.
You can disagree with responding to tech's sexism problem (where a majority-male community undeniably throws up roadblocks to women) with sexism (the linked comments), but it's clear one group has dramatically more power in that situation.
People say "women are manipulative bitches" all the damn time on Twitter, on accounts that can be traced back to their real name. I also don't think any of those people should be given a position on the Rust team. Realistically, neither a man tweeting "kill all women" nor a woman tweeting "kill all men" is going to actually carry that out in the real world. *Far* more people talk the talk but don't walk the walk (which I'm obviously thankful for).
We can suggest more features to get a better support for Rust
Indeed. I encourage everyone to read https://www.reddit.com/r/node/comments/6whs2e/multiple_coc_violations_by_nodejs_board_member/ and decide for yourself.
Oh yeah, now I remember back in university where they wouldn't let women join the CS program. /s The rather large gender gap in the tech industry mostly comes down to lack of interest, not some fictional "roadblocks". Now maybe you can make the argument that the lack of interest is actually internalized sexism or whatever, but that's a different (and much more tenuous) argument. I'm pretty sure the Rust team would never appoint a man who was known around the internet for tweeting shit like "kill all women". So, at least in this instance, the "roadblock" seems to go the other way round.
All of those also don't have the functions for conveniently string manipulating.
Your link needs a `https://` prefix.
Very nice, I can see use for this in my own projects.
I've spoken to plenty of female engineers who had entirely non-fictional roadblocks in their careers in CS, from having their technical skills underestimated or ignored or having been subject to sexual harassment. I've talked to not a single man who has had that issue. I honestly expect every member of the Rust community to know sexism causes real, harmful impact in the tech community, from school into the workplace. That's the context all of these comments were made. You trivialize the magnitude of the problem when you equate this to men threatening women in a predominantly male community.
I enjoyed [this](https://www.youtube.com/playlist?list=PLJbE2Yu2zumDF6BX6_RdPisRVHgzV02NW) playlist.
graydon, hoare
Oh sweet, useless anecdotal evidence. Cool. &gt; sexism causes real, harmful impact in the tech community, from school into the workplace. I fully agree, which is why I don't think an overt sexist should be on the Rust team. It honestly sounds like you're trying to make a "sexism = prejudice + power" argument here. It's dumb when people try applying it to race and it's dumb when you try applying it to gender.
The plural of anecdote is not data. I know of many males who have been discriminated against by females in higher positions in the workplace. Just because _you_ have not seen it doesn't mean it never happens. Sexism is bad regardless of the sex of the perpetrator.
Rake is a ruby-version of make - which is basically just a tool not restricted to web tasks. Take a look at "just" listed below, though it may not be what you think. What is the application you are thinking of?
Cool. I think there is a small mistake in your project description: The alphabet of a UUID is smaller. Upper and lower letter characters are treated the same when parsing UUIDs. EDIT: Sorry. Misread it. What you meant is that the alphabet is bigger than the one of a UUID.
Do you define sexism as just saying bad things about a gender? Not speech that actively contributes to material harm to a minority group by a larger group? If you only define it as the former: why is discriminating based on inherent traits socially unacceptable? The reason is because it creates immensely hostile environments for outsiders. No wonder people affected by it (and linking to it; did you even read the tweets) would lash out.
Translation: In late December 2017, we have conducted a poll at the Rust China Community Group (QQ Group number: 303838735). Here are the results: "In 2018, which areas do you hope to apply Rust in (or invest time upon)?" Multiple-choice, maximum of 3 votes 593 votes are cast 98 votes - Distributed systems/Parallel programming/Async IO（e.g. tokio） 63 votes - Backend web services 48 votes - Machine learning/Artificial Intelligence/Big Data analysis 46 votes - Embedded/RTOS/Internet of Things 42 votes - Frontend web development（wasm） 40 votes - Game development 37 votes - Desktop application UI development（GUI，TUI） 36 votes - Improve existing C/C++ projects 32 votes - Blockchain/cryptocurrency 31 votes - OS development 28 votes - Others: microservices/service discovery/containerization 28 votes - Databases 26 votes - Optimize existing Python/Ruby/Nodejs applications 20 votes - System security development 18 votes - Mobile App development Headcount of people voting: 237
Definitely not. Sometimes you want to search arbitrary data where utf8 might be embedded in it. Sometimes you want to do string operations on a memory mapped file without doing a utf8 check first. Sometimes you want your search to coupled utf8 decoding to avoid an initial first pass to do utf8 validation. This is why the regex crate exposes both str and [u8] APIs. 
Nothing I guess. It's just simpler that way. 
The second book and rustbyexample.com
[learning-rust.github.io](https://learning-rust.github.io/docs/a1.why_rust.html) might be helpful as well. 
Oh btw, if anyone's wondering what "悄悄的看了一下我的投票，中了俩。。。" in the comments section is all about, it basically translates to "I meekly came here and took a look at my own votes, and saw that 2 of them are selected..."
wonderful!!
rust will become better and better
rust will become better and better
The [Rust Gentle Intro](http://stevedonovan.github.io/rust-gentle-intro/) was designed to be as gentle as possible, but no gentler. I'd be interested in any feedback to push the gentleness to the max. (It's a classic case of a tutorial that grew into a small book, which is an awkward size)
This is probably just going to show how clueless I am but I hadn't actually realized that cargo had its own docs. I just thought whatever was mentioned in the rust book was the cargo docs.
Based on my experience the vast majority of web apps and services use some JVM language (usually java) for backend. I have no idea why anyone would want to use a dynamic language, do people like runtime errors that much?
run project-specific commands with access to the environment of my project
Removed some unsafes from pq (replace libc with nix). Also removed error-chain (in a larger goal to reduce dependencies).
Is the performance slowdown not mostly with pre-haswell processors? 
Sounds like a great project, I highly reccommend toggl btw.
Thanks for translating, this is really cool!
I don't know what I expected...
`for_each` don't allow you to examine the resulting error if one occured, if I understand the reasoning correctly.
Yeah. Regardless of language, I use `foo`, `bar`, `baz`, `quux`, and `glorp` in that order, with the sequence then breaking down into an unpredictable mish-mash of things like `quuz`, `spam`, `eggs`, `foobar`, `qux`, and the like (again, regardless of language).
 不知道rust 有个qq群，现在很少用qq了，建个微信群是不是更好点？
In english, I don't know there is rust qq group,but I rarely use qq now,why not setup one rust group in weixin?
There is indeed a WeChat group in Rust, but that one has an explicit English language policy and is invite-only.
Not too familiar with rust but in general, if your lookup table is small or if your lookup table is immutable or has far more lookups than insertion, a sorted array of tuples has better performance than a hashmap (despite o log N lookup and o N insertion). You can find some papers/tutorials about this topic if you want exact numbers.
I use foo, bar, buzz or lorem, ipsum, dolor, … but we should probably invent something new! May I suggest &lt;https://en.wikipedia.org/wiki/List_of_alloys&gt;? :D
In that case you could have one feature in *Cargo.toml*: [features] custom-name = [] And then in your code: #[cfg(feature = "custom-name")] // item to use only when feature enabled #[cfg(not(feature = "custom-name"))] // item to use only when feature is not enabled Note that the `cfg` attribute does not have an `else`. If you want to use the `cfg!` macro instead, you can use `else`: if cfg!(feature = "custom-name") { // stuff to do only when feature enabled } else { println!("not custom-name"); // stuff to do only when feature is not enabled } 
Did you do `cargo clean` before each build?
Nightly now uses 16 codegen units by default: https://github.com/rust-lang/rust/pull/46910
有一个微信群, 他们大多说英文和一点中文.
You can do this: https://play.rust-lang.org/?gist=8341330fd95d498bbf67058a8e808aef&amp;version=stable This is *PROBABLY* safe, as I do not think padding and stuff is relevant for slices. Still, use this at your own risk.
我很不喜欢微信，因为它没办法方便地在 Linux 电脑上使用。谁整天在手机上写代码呢？ I hate wechat very much, because I can't use it conveniently in Linux desktops. Who writes regularly on a phone? 
From what I can tell, they ask language-specific questions for the top 3 languages you use. At least from my single data point :)
Given that description, we don't have anything *exactly* like that, though Rust is pretty good and consuming and producing JSON, so web frameworks tend to do a good job at that, even if they do templating.
I'm curious, what was the rational for that AsciiExt change? Do we not like the previous pattern of having it in a trait, or was it just commonly used enough to warrant being included on the types?
`alias checkall="cargo check --tests"`
I am getting this after pulling down the latest update. This is all from version `rustup 1.9.0 (57fc3c087 2018-01-04)`
It doesn't prevent you from doing it, but you have limited means of propagating the error upstream. A regular `for` loop, in contrast, permits that though the `?` operator. This new impl is equivalent to the latter, except that you don't need a function to achieve the same effect, you can just `collect`.
Probably the most important legitimate use is making types that allow for injecting mocked dependencies for testing.
In Rust, this is actually almost indispensable, because it's the only way of making types that allow for injecting mocked dependencies for testing.
Usually, the `Ext` traits happen thanks to incoherence between `libcore` and `libstd`. However, [it's actually not clear why this trait existed](https://github.com/rust-lang/rust/pull/39659#issuecomment-278489834). Let's dig into some history! In 2013, [the trait was created](https://github.com/rust-lang/rust/commit/a00becd0eb8c04dc7416a5f8a633b73c9080c65d). Originally, this stuff was free functions, and when it was made into methods, it was put into a trait. Why? It's never actually made clear!
It's because you are calling panic! with pair. You can just change "_ =&gt; panic!(pair)" to "_ =&gt; panic!(format!("{:?}", pair))". That will change the pair into a String and should run fine.
I'm guessing it will be a different story once the compiler is compiled with an LLVM version with this patch applied -https://reviews.llvm.org/D41723
You're right, Rust doesn't have any production-ready/mature pure Rust GUI libraries. If you want to write GUIs, you'll have to use bindings for a library written in C/C++, like QT or GTK. 
I would argue you read my comment correctly. :P
Aah, so that would make the reference exist outside of the scope of main(), where input has been destroyed? That makes sense, thanks a lot! :)
It's a hack, but it works: thread_local!(static STORE: std::cell::RefCell&lt;Vec&lt;String&gt;&gt; = std::cell::RefCell::new(Vec::new())); pub fn get(pos: usize) -&gt; Option&lt;String&gt; { let mut res = None; STORE.with(|cell| { res = cell.borrow().get(pos).map(|s| s.clone()); }); res } pub fn set(s: String) { STORE.with(|cell| cell.borrow_mut().push(s)); } // to set a value set("hiho".to_owned()); // to receive a value assert_eq!(get(0), Some("hiho".to_owned()));
this is what i do, personally
Be more specific with your language. When you say "that seem like much of a joke" do you mean: - it is clearly a joke but: - you don't find it funny - you think it is in poor taste - etc - it is NOT a joke and you believe it is her actual beliefs.
You have to use https://crates.io/crates/lazy-static to do what you want.
Well, I would say you seem to be a person who handles humor very literally. Context and humor are important, if you don't see that that's okay -- but your concerns are not widely shared, especially on the rust core team. The fundamental issue here is whether someone's personal activism should preclude them from being on the rust core team. You seem to think it should, those who chose Ashley for the job disagree. 
&gt; far-left lol
This isn't really the place to get in a long form discussion of modern racial politics. The core issue is whether someone's expressed personal beliefs _in their personal life_ should affect their candidancy for being on the rust team.
The argument is that: - they are not sexist tweets, they are jokes. - someone's personal activism should not affect whether they should be on the rust community team. Let's not get in a long form discussion over whether sexism _exists_ -- that is beside the point (although I see you already have)
i want that via a built-in functionality
Someday, it will be possible in limited situations. Until then, you need this. In the general case, you'll need this.
Okay, so you believe she actually believes "kill all men"? You have a very literal reading of jokes that few people share, and I seriously wonder if you are reading them this way just to create drama.
gibberish. how does that crate work itself? by magic?
Quite a jump from JS to Rust. It's interesting how many webdevs have found Rust (I come from RoR myself).
It creates and manipulates `static mut` that is initialized with your code first time the value is accessed. Subsequent calls get to use it as if it was a regular `static`. This is done through the deref trait. The crate's documentation goes into greater detail and the implementation is only a few dozen lines if you want to see for yourself. https://docs.rs/lazy_static/1.0.0/lazy_static/index.html https://docs.rs/lazy_static/1.0.0/src/lazy_static/lib.rs.html#174-186
Okay, you could write the exact same code that the crate does, and then use it. But there's zero advantage to doing that when you can just use the crate.
&gt; Okay, you could write the exact same code that the crate does, and then use it you've just said that it wasn't possible. only via the crate
It is not possible to write the code you've written and have it work. It is possible to write different code. But it's significantly different. Good luck.
&gt; It is not possible to write the code you've written and have it work. &gt; &gt; I pointed out that it didn't compile 
Lazy static initiates the contents of the variable on first use.
I feel like you are reading too much into it. What I got from Steve's answer is that you need this specific code, not the crate itself.
Proggit 7 years ago. 
&gt; built-in Built-in is less special than you'd think. Rust is so low-level that even the `std` library isn't terribly special. There's a lower library called `core` which the language more-or-less assumes exists and more-or-less does what you'd expect, but it's tiny. `core` *only* knows how to do fundamental CPU stuff (arithmetic and logic; atomic memory manipulation; it defines Rust's pointer arithmetic and iterators) and *cannot* talk to the OS (any kind of IO, creating and parking and resuming threads, exiting, heap memory). `core` is the most built-in part of Rust. `std` talks to the OS and can do a bare minimum of Things Applications Should Do - if your program *is* an OS or doesn't need an OS it can't and won't use `std`. `lazy_static` doesn't need `std`. It's also fairly straightforward - provided you understand the guts of atomic memory manipulation. Even if you don't it's worth a read. In most languages that feature would *have* to be built in. But in Rust it's just normal unsafe code with atomic memory manipulation. You could do it yourself if you want. Would you like to?
The crate is very small. You can read the source code if you want. https://github.com/rust-lang-nursery/lazy-static.rs/tree/master/src
If you don't need to share the data between threads, you can also use thread local. https://doc.rust-lang.org/std/macro.thread_local.html
I wrote Rust-related comments in the free-form section. My top-3 langs aren’t Rust (sadness :() but I thought I’d put feedback *somewhere*.
Thanks a lot for your answer (and of course /u/sjustinas too)! I'll do some benchmarks to decide whether I need it to be fast or not. I really like to avoid `unsafe` in general ;-)
I think they have no detailed question section for Rust. 
&gt; I don't want to use third-party dependencies Then you probably don't want to use Rust.
&gt; probably 
are you an idiot? what are trying to sell me? I said - I don't want to use third-party dependencies 
Obligatory disclaimer that it's your code and all; you can establish any standards for it. But I gotta point out that incorrect code is still incorrect, even if it's safe. Safety guarantees just mean that the optimizing compiler turns "wrong" into "faster but still wrong", instead of "faster with new and unpredictable kinds of wrongness, but usually it just crashes." I can't encourage a blanket distrust to `unsafe`. It just means that you need a little deeper knowledge and more caution. In this situation, you *know* you're reinterpreting words as bytes and that endianness is a thing. Only thing you might not be aware of is alignment. The best argument against `unsafe` is the risk of programmers having unknown unknowns. 
Do you feel a tweet stating "kill all women" would have been a violation? How about "kill all whites"? How about "kill all blacks"? 
it was quite spontaneous tbh, and now I'll have The Jackson 5 stuck in my head for the next few days.
&gt; But there's zero advantage to doing that when you can just use the crate. Taking a dependency increases the set of people you have to trust. Its maintainer, (or the maintainer of any of its dependencies) could get hacked and push a malicious version.
&gt; `yorp`, `garg`, `vorticon` Woah, nostalgia. I have a sudden urge to install Commander Keen now.
Why are distributed systems and Async IO grouped together? To me, the former means MPI which to my mind is entirely different from Tokio.
Offhand it seems that static linking easily could fix the clippy and rustfmt-nightly issue, but this probably requires support further up the toolchain.
Sure. But I'm not talking in general, I'm talking about this specific crate, which is maintained by the Rust team, and has no dependencies. (unless you use it with no_std but that's not what's being discussed here).
Paging /u/dmwp37
To be clear, you said it "wasn't even satirical." If it was a joke it WAS satirical though, right? Were you saying "wasn't even satirical" for effect -- as in meaning it was satire in very, very, VERY poor taste? If so, I can get how you would _feel_ that way. However, do you honestly feel that jokes in (very) poor taste are grounds for barring someone from being on the rust community team?
My experience has been relatively good up until recently. Like everyone else on the platform I was hit with the `rustup` bug. It seems to work ok after the update but I still get the warnings about `rustfmt` and `cargo-fmt` already being installed, which shouldn't be managed by `rustup` until 1.24. I would like to echo the statements on the Windows testing regimen seems to be lacking.
You're welcome to feel that way, but the issue you linked to was just that: a temporary issue. I've been using Rust on Windows for about a year, and it has been a fantastic experience. Some of the central people in the Rust community are using Windows for their dev environment too, like Steve Klabnik. Windows is not a second class citizen. The issues you mention with clippy are not specific to Windows. On Linux too, they break when you update Rust, since they depend on the exact version they were compiled against. The DLLs not being on the path is a confusing statement to me. If you the executables you're talking about are on the path, I'm pretty sure the DLLs are too, and I've never had any issues with that. In life, there is always a chance that someone will do everything exactly right and it will be just their luck that everything keeps going wrong. I highly recommend just uninstalling everything related to Rust, and then starting from scratch. It should all work very well, no problem, with the exception of nightly RLS, which is still under heavy development. If you want RLS to work reliably, the advice I've heard centers around using the stable release of Rust with the rls-preview component. I'm nobody, but that's my 2¢. Compared to any language that isn't .NET based or Java based, Rust has been the best windows development experience I've ever had, so I'm a bit passionate here.
Yeah things go in cycles. I ran into the same issue with rustfmt and cargo-fmt which lead me down the road of trying to install rustfmt-nightly which was a bit of a mistake.
&gt; Regardless of language, I use foo, bar, baz, quux, and glorp No `qux` or `corge`? You monster. 
For what it's worth, my experience developing rust on Windows natively has been almost identical to developing on Mac and Linux, with the rare exception of 3rd party crates that have issues compiling non-rust code (the SSL crate comes to mind, but I believe this has since been fixed).
I had one big issue with rust on windows, but that was fixed quite quickly. I'm just using WSL now because it's so much easier to just be inside linux all the time for developing, but I prefer windows for other things.
Hi, I'm on the core team, and I use Windows as my primary OS. I don't know what the testing for rustup is, but I do know that we test rustc and the stdlib against Windows on every commit. I don't use clippy or rustfmt-nightly, so I haven't seen the issues you've seen.
well, that seems to be your opinion and it is not [shared by the community team](https://internals.rust-lang.org/t/announcement-ashley-williams-joins-the-core-team-and-taking-lead-of-the-community-team/6453/13?u=vitirall). If you feel strongly enough you should take your concerns up with them.
Do you use an old version of Windows? Do you use non-standard installation methods? Similar to rust on Windows, I very rarely (if ever) encounter Windows specific issues when using NPM.
With the new rustup, you should be using the component to manage rustfmt, not using `cargo install`.
The libraries required are in "%USERPROFILE%\\.multirust\toolchains\nightly-x86_64-pc-windows-msvc\bin", but binaries go in "%USERPROFILE%\\.cargo\bin". The former is not added to the path by any tool (as far as I can tell) but the latter is. All I can guess is that you manually added this to path at some point in the past. I suggested to the rustup people to auto-add the binaries folder of that specific toolchain to the local environment path when using "rustup run" but they refused so who knows.
I did a bit of Rust development on Windows and as soon as I realized that Rust works under WSL I uninstalled all the tooling on the Windows side and used it from WSL. That's not even a comment about the quality of Rust support -- even just having a useful command line was enough to get me to switch. (And the Rust support generally works better because I am sure the majority of devs are not on Windows...)
The community team (and its leader most of all) can suck a chode. The simple fact of the matter is that men, or whites, or especially white men are deemed *acceptable targets*.
Sorry, I can't resist: "Activism. that's laughable" =&gt; a pun for activism using funny jokes. Context is important, see my response here: https://www.reddit.com/r/rust/comments/7o5ztn/where_we_discuss_drama_surrounding_ashley_williams/ds8d4je/ There might be no way to resolve this for you. You might continue to be offended about it. I want to posit to you that that is okay -- it is okay for some people (even yourself!) to be offended about a decision made by a community you love.
It changed extremely recently and the README is still wrong, so no worries! What's nice about it is that it fixes one of /u/mansplanar's issues, which is that it correctly handles pairing things so that you don't run into those version mis-matches. Also, it's in nightly and beta. Six weeks till stable!
Windows 7 at home, Windows 10 at work. NPM's issue is that it creates path trees so deep that the system cannot delete them.
Since it's not in the README yet, do you know the correct component name? None of "rustfmt", "rustfmt-nightly", or "rustfmt-preview" were found and I don't see anything under "rustup component list --target nightly"
&gt; And I do mean we: the vast majority of that work was done by newcomers to the community, many of whom had never worked on a compiler before. I loved the overall enthusiasm that was in the air. To me, it felt like what open source is supposed to be like. I've seen that as well and I think this was the most awesome aspect of the impl period: people I've never seen or heard opening PRs with really helpful feature additions or badly needed refactorings. I hope that some of them will continue to contribute. Even if it is only one in ten, it would mean a win. Wouldn't like if there would be a continued (official) use of gitter/slack/etc. I'm a great fan of chat protocols where there can't be any removal/editing of messages. Just look at some conversations in this subreddit. Some conversations you can't form your own opinion about because one of the moderators got mad and deleted everything. You don't even know which moderator it was so you can't even ask them. This isn't even an issue specific to this subreddit, it is an issue of reddit itself giving this tool to moderators. I'm not against the idea of moderation, but it can be solved well enough with kicking/muting. Github at least is transparent about this and shows the author of the comment, as well as the moderator who deleted it. And in issues where I am subscribed to I am getting an e-mail so I can still have a look. Also I dislike if chat protocols lose focus on their actual textual nature. Why does it have to render images/videos? Or show previews of links? IRC may not be perfect (not easy to get into, needs bouncer, etc), but it is the best option right now IMO.
&gt; The DLLs not being on the path is a confusing statement to me. If you the executables you're talking about are on the path, I'm pretty sure the DLLs are too, and I've never had any issues with that. You explicitly need to put /c/Users/UserName/.rustup/toolchains/nightly-x86_64-pc-windows-gnu/lib/rustlib/x86_64-pc-windows-gnu/lib into your path, otherwise clippy and co. just straight up don't work. This used to work when rustup used .multirust as its folder, but whenever they renamed it, they broke it and never fixed it again.
I don't remember having had to do that, so I disagree that it must be done.
AFAIK sometimes nightlies end up missing 'side' components like `rustfmt-preview` and `rls-preview` due to build failures in them which don't actually fail the release of the nightly.
Since you don't want to use third party dependencies, then you can just make it a `static mut.`I really think you should use `lazy_static` as has been mentioned but I don't know your reasoning here as to why not like if you have a work restriction. It's a highly trusted crate. Anyways I wrote about this technique [here](https://mgattozzi.com/global-uninitialized) a while back. That being said this is dangerous if you access this from another thread before it's initialized so it should be the first thing you do really if that's how you want to do it.
It's `rustfmt-preview`. I have it. Just checking, you're using the MSVC target? and rustup 1.9.0?
That's true, but they're there today.
why would the _compiler_ care about this? Isn't this a vulnerability at the OS level? Even if the LLVM compiler "fixed" this, that wouldn't prevent someone from exploiting it with a different version of LLVM. Or is the point so that people *don't* fix it in their kernel, but just make sure all of their software uses a compiler with the vulnerability fixed? That makes some sense... maybe. Just _never_ download a precompiled binary...
Yeah that's the issue. Maybe something is odd because I still have .multirust as a junction to .rustup in my %USERPROFILE%. Did not know about it previously working, interesting.
All help is very welcome! As I am new to rust, I'm sure some code is also sub-optimal in many ways :-)
I definitely agree with the goal of documenting more of the internals of rust and cargo. Here are some things I found hard to figure out: 1) How stability attributes should be used, creating stabilisation tracking issues, etc. 2) How exactly tests are built and run, including how the test runner gets linked in, how the entry point is switched to the test runner entry point, various other configuration questions. 3) Common techniques for debugging the compiler, including logging, additional `x.py` command line documentation. 4) Exactly what is expected to work vs not expected to work: for example, some stuff is not expected to work on stage 0, some stuff won't work with panic=abort, etc. 5) Just generally, what is defined where.
You don't need to set the path of you use`cargo +nightly clippy`.
Alright, then. The basic rule with `static` is that the type must be sync-safe (trait `Sync`). Sync-safe means that multiple threads are allowed to access a location, and `static` locations can be accessed from any thread at any time. Fortunately sync-safe is default. Most types are sync-safe, and you can put almost any type in a `static`. The problem is modification. Normally you can't modify a location unless you own it. Any instructions in Rust exist inside functions. Functions "own" any local with the `mut` property plus anything they can reach through a chain of unique pointers. This means you can "loan" a location to a function by giving it a temporary unique pointer: `&amp;'lifetime mut T`. `static` isn't owned by anything, so you normally can't write to it. At some point early in the program you'll need to write to the configuration static, later on you'll only read from it. But that read-only access can be shared everywhere. The shared-reading part is easy. It'll go something like this: pub fn get_config() -&gt; &amp;'static Config { loop { match CONFIG_GUARD.check() { CState::Configured -&gt; return unsafe { &amp;CONFIG }, CState::Unconfigured -&gt; panic!(), CState::Configuring -&gt; { relax_loop(); continue } } } } There are two `static` locations. `CONFIG_GUARD` is a regular `static` - no `mut` because it's going to use an *atomic-cell type* to allow special mutation. `CONFIG` itself is a `static mut` location. This means that the programmer takes responsibility for preventing a memory race. That's why the `unsafe` is grammatically necessary. A memory race happens when: - a location may be accessed by multiple threads - while it is being changed - the exact order of what happens isn't properly defined To prevent a memory race, we *must* ensure that `get_config` doesn't return a reference to `CONFIG` until any and all writes are complete. So, we check the `CONFIG_GUARD` and make sure that it tells us `CGuard::Configured` before returning the reference. If this fails, it might be because it configuration hasn't happened yet. Simplest answer is to panic. It might fail because configuration is currently happening, in that case we can chill out and try again soon. Could also panic. `relax_loop()` is more magic I'll get to in a bit. You might want a function that explicitly does configuration. Here's a very simple one. pub fn set_config(cfg: Config) { if CONFIG_GUARD.start() { unsafe { CONFIG = cfg }; CONFIG_GUARD.end() } else { panic!(); } } Again, writing to `CONFIG` is `unsafe`. The `CONFIG = cfg` operation must occur *cleanly*, without any other threads reading from `CONFIG` at the same time, so two `CONFIG_GUARD` calls are needed. This is enough to outline `CONFIG_GUARD`: struct CGuard(AtomicUSize); static CONFIG_GUARD: CGuard = CGuard(ATOMIC_USIZE_INIT); impl CGuard { fn start(&amp;self) -&gt; bool { .... } fn end(&amp;self) { .... } fn check(&amp;self) -&gt; CState { .... } } #[repr(u32)] enum CState { Unconfigured = 0, Configuring, Configured, } impl From&lt;usize&gt; for CState { .... } impl Into&lt;usize&gt; for CState { .... } CGuard only contains an `AtomicUSize`. Notice that the methods have `&amp;self`, not `&amp;mut self` - they don't require ownership. The `AtomicUSize` starts out equal to 0, same as `CState::Unconfigured`. - `start` switches the state from `Unconfigured` to `Configuring` and returns `true`. Any other attempted state transition will fail and return `false`. - `end` sets the state to `Configured` - `check` checks the current state These are all one-line wrappers around `AtomicUSize` methods. For example, fn check(&amp;self) -&gt; CState { self.0.load(SeqCst).into() } I think this is probably a good point to let you try to implement it. You'll need to read the docs to figure out how to implement `start`. Use the `SeqCst` ordering because it's never wrong (but often slower than optimal). I haven't touched on `relax_loop()` yet; it's basically `hint_core_should_pause` (nightly only) or `thread::yield_now` or possibly nothing but that's suboptimal. 
This patch makes sure that branch prediction always fails when calling out to kernel space - at least in my limited understanding. Thus, if you compile everything with the patched compiler, this new class of bugs is slightly mitigated, as speculative execution will not occur, thus data won't get pulled in the caches for the process to observe after the indirect call. This will make a lot of indirect calls a lot slower. Unlike the kernel patches, this will apply to all code that is running, not just syscalls.
Ah neat! Part of the reason I made the [external docs](https://github.com/rust-lang/rfcs/pull/1990) RFC that got accepted was for being able to store documentation in one spot easily and making it easy to find and read it all rather than digging through source code and cluttering code up with documentation comments.
My browser, for whatever reason, was unable to do the drag drop language order. Why would a survey that really wants feedback make required questions that you can't get past?
This is a bit old, but might still answer part of your question: https://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html.
You can also use `objdump` to see the size of each compiled function.
Yes, I know about this article. But I'm interested in something like `llvm-lines`.
&gt; Because they depend on dlls specific to the nightly they were built against, the tools will not run unless those dlls are added to PATH on Windows. No tool does this for users and no projects have made an attempt to fix the issue either in documentation or in code. I need to do the same thing on Linux with `rustfmt` built from sources. It's mentioned (here)[https://github.com/rust-lang-nursery/rustfmt#tips]. ``` LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/ rustfmt ``` The `rustup` issue was probably harder to catch during testing, but other than that the issues you mention also apply to the other OSes.
Doesn't it work only in the debug build?
I actually did something more complicated. I ported a gtk app of mine to Windows, and setting everything up on Windows + fixing platform dependant stuff only took me like 2 hours. It was almost only installing rustup, Cloning the repo and then building it with cargo.
In a build with `debug-info`, I believe. I used it with `gcc -O2 -g`, but it should also work here.
the nice thing about artifact (one of it's main value adds) is that you can store it alongside the source code and host it anywhere. You then link an artifact to source code by just having `#ART-name` anywhere in your source.
I will try it, but I think that a build with -O3 and LTO will change a picture completely.
If you have access to WSL, I have no idea why you'd program using Windows directly. 
Was that issue fixed in npm 3? I found a StackOverflow post indicating yes: https://stackoverflow.com/questions/26155135/node-npm-windows-file-paths-are-too-long-to-install-packages
Neat!
Yes, you'll lose some fidelity there to inlining. You should also try `opt-level = "s"`. `3` will probably produce larger binaries.
The WSL isn't real windows. If you want to be doing stuff for actual, real Windows, then the WSL isn't it.
Oh yeah if you're targeting windows that might make sense. I've never tried to do that. 
Well, when I jump back to C# for something, it makes sense to use VS on windows directly, since the support is undeniably first-class. You are, however, correct that for rust, python, or other languages (actually, I don't use that many other languages), WSL is just better.
I'm a power user of the command line, and the last time I used windows I was not, so I'm probably biased. 
I'm not sure that it's Rust's fault...
If you're using linux, I don't think it'd be too far fetched for most distros to add a default flag for all of their packages. On iOS, some platforms (the watch) require you to submit LLVM bytecode to teh app store instead of binaries, thus Apple could compile the bytecode with the patch, I believe it's only a matter of time until they start accepting only bytecode on all platforms. I think one of us has a misconception about this situation - I thought that these patches would mitigate Spectre whilst the kernel patches will mitigate Meltdown - two different exploits. So, as far as I understand, to half-mitigate these CPU deficiencies, one has to both use the KAISER/KPTI patches and also compile the world with a compiler that is aware of these issues. What a brave new world we live in, heh.
[removed]
I didn't realize there are two exploits. God I hate computers.
This is a bug in the documentation, but I have corrected.Thanks for the help
I haven't tried this with Rust executables yet, but it should work: https://github.com/google/bloaty It gives you a breakdown of what contributes to the size of an ELF or Mach-O binary.
If someone frequently tweeted "kill all women" and "blacks are violent" would you feel the same way?
With May, you can write your code as if it were synchronous. As if I/O system calls were blocking, except that in reality, they won't block. When they would block, something else will be scheduled. So, you don't need to explicitly keep a state machine for each connection. The code becomes easier to write, easier to maintain, and less bug prone. May also includes queues, the ability to seamlessly wait for multiple events, timers... 
This code will not generate UUIDs with 'z' or 'Z' in them, because of the way `safe_alphabet` is defined. Try using something like let crange = |start, end| { (start as u8)..(end as u8 + 1) }; let lower = crange('a', 'z'); let upper = crange('A', 'Z'); let num = crange('0', '9'); let cs: Vec&lt;char&gt; = lower.chain(upper).chain(num).map(|c| { c as char }).collect(); 
You have the explanation why it doesn't work in the last error message you posted. The closure has the wrong type. It is FnOnce because it can be called only once, while the function you are calling expects a Fn instance, which can be called infinitely many times. You can fix it by following the example more closely, returning the type of the service struct instead of a reference to one and making sure your closure is a Fn and not a FnOnce. 
It's still theoretically possible, but much less likely
I can't speak for anyone but myself, but for me it's because the second edition is the one where all the effort and work is being poured into, it's also the most up to date idiomatically. Rust is a "stable moving target" so there is benefits to staying current, conversely it is also perfectly feasible to stay static. I say using either version is perfectly fine.
The only issues I've ever encountered on Windows because "the majority of devs are not on Windows" are in building C dependencies that already have that problem themselves- OpenSSL, etc. Rust itself has top-notch Windows support.
[removed]
FWIW, [`mioco`](https://docs.rs/mioco) exists and predates MAY.
May uses generators.
possibly relevant to your concerns: https://forge.rust-lang.org/
Honestly, I've encountered a fair amount of anti-Windows snobbery from the Rust IRC channels, as well. Like, asking a basic question about Windows + Rust dev, and people shit all over you for asking "why are you developing on a toy operating system, herp-de-derp ..." Mods could do a better job of policing that kind of bullshit behavior.
Ugh, agreed. (I'm not on Rust IRC much, so I mostly see this elsewhere.) Windows isn't free/open source, but way more end users run it than macOS or Linux, and it's better in a lot of ways technically as well. I also appreciate that it's different enough to force Rust to avoid baking POSIX into everything.
The other commenters are suggesting some fancy `unsafe` approaches, and that's certainly going to be the fastest option. (As long as you're ok with the result depending on machine endianness.) But there's also a way to make your original approach cleaner, using the `byteorder` crate: https://play.rust-lang.org/?gist=9c6f58b6e67be7d0695547c9191504e2&amp;version=stable fn convert_to_u8(input: &amp;[u16]) -&gt; Vec&lt;u8&gt; { let mut ret = vec![0; 2*input.len()]; LittleEndian::write_u16_into(input, &amp;mut ret); ret }
It occurs because currently your closure takes 'MyServer' by value. You need to closure to be callable _multiple times_, once for each connection if I recall correctly. To fix, make `MyServer` implement clone, and then use .clone() within the closure: #[derive(Clone)] pub struct MyServer { var1: i32, } let srv = MyServer { var1: 333 }; let server = Http::new().bind(&amp;addr, || Ok(svr.clone())).unwrap();
`cargo +nightly doc --open` in `rust/src/libtest/` seems to work, if it's easier to look at the rendered docs.
&gt; Mods could do a better job of policing that kind of bullshit behavior. Have you gotten in touch with the mods about this? See the [Code of Conduct](https://www.rust-lang.org/en-US/conduct.html) for contact details.
So does [coio](https://github.com/zonyitoo/coio-rs), but the question was about May.
This is super cool! I've been casually watching artifact for a while, but hadn't done a deep dive in quite some time. It looks like it's come a reallu long way! I'd love to try it out now that I'm coming back from the holidays! Something I've had trouble with is tracking progress and properly documenting how all things fit together but it looks like artifact could help solve this.
I think the problem is with the "if not loaded, insert into hashmap" part that requires mutability. Insertion is a separate concern from retrieving an existing item and is probably better off left to a separate function. So I would change the `cache.get()` method to just do the same thing as `get()` on the underlying HashMap, i.e. take an immutable reference and give `Some(val)` if present or `None` otherwise. If you really do need to get-or-insert-and-get, then maybe you can make something work via the `entry()` method on HashMap, but you might run into the same mutable borrow issues again.
It feels a little hackish, but you can try something like this https://play.rust-lang.org/?gist=11c449fc4484ea3b6b069a6400228a91&amp;version=nightly
Can't you cross-compile for Windows out of the WSL?
In theory. It's not nearly as simple as just compiling on the host.
If it happens again, I'll certainly do that. Unfortunately, I haven't had a chance to do much Rust work lately.
There are worse things.
It does have a couple, but they're not ready yet.
One solution to the issue of focused communication in a busy channel is instead of making it a private conversation, create a new channel for the issue at hand. Have the one-on-one discussion there, then after the fact, provide a link to the discussion in the primary channel. It won't get a lot of traffic, but the paper trail (pixel trail?) will be there if anyone needs to see what decisions were made or how.
Yep. Try compiling with `-C prefer-dynamic` and it'll dynamically link it.
Thanks, you indicated a design flaw in my code (which Rust helped avoid :D). I fixed that, but now I still have lifetime problems. Wherever I try to store a Consumer, I need to define a lifetime. This goes eventually all the way up to my main function where I define a container of a Consumer. This container also has a lifetime. struct Container&lt;'a&gt; { cache: Cache, cons: Consumer&lt;'a&gt; } Now, the problem is that I cannot call `self.cons = Consumer::new(&amp;mut self.cache)` because `'a` cannot outlive the function where I do the assignment, but it must outlive it for the consumer to be assignable. I'm guessing the problem is that I'm tying the lifetime of the `Container` to the resources. Am I interpreting the following correctly? `Container&lt;'a&gt;` means that any child (no matter how deep) marked with `&amp;'a` must live at least as long as the container. If that is correct, then any resource that can be loaded after the creation of the container (which is the case here with the `load` functions) lives too short, making this whole thing impossible? I know this comment may be a rambling incoherently. If it's unclear, just wait and I'll get back to you in the morning. I've had a long work day and I'm a bit too tired for lifetimes right now :). Thanks for the help!
Slightly off topic but if there was a Tokio clone based on May it should obviously be called Mayland.
Not yet, but i intend to give it a shot next time I use a *nix machine for a significant amount of time.
Yep, the same issue also exists on OSX as well. Would be nice to see it fixed.
Is there a way to make a `&amp;'static str` out of a `char`? I feel like there should be (because a `char` is basically a `&amp;'static str` of length 1, for the correct meaning of length). I know I can use `to_string` on it, but it feels like I should be able to do it without allocation (though my utf8-foo is neglegible, so I'm not sure). If not... can I do it anyways if the `char` is ascii?
You just need to separate the insertions and the references. https://play.rust-lang.org/?gist=cace2c0dd1c81257fc84d7897105ea94&amp;version=stable
If you could elaborate further: 1. Which abi did you use to build your project? gnu or msvc? 2. How did you satisfy gtk deps? msys2 or built-from-scratch? 
No, I'm pretty sure he's trying to insert something on #get if the thing he wants isn't in the cache.
Heya, I've stumbled here after playing with diesel for sqlite. I'm at least looking for a more simplistic library after struggling with a few things. The table I'm querying against is basically an id, a timestamp, and a bunch of foreign keys for lookup tables. I can build associations and filter based on the values in the lookup tables easily enough, but the structs I've built for diesel don't contain any of the information I'm actually interested in. Running multiple queries in diesel and joining together in the application feels like a lot of work, and the latency of doing this in serial will throw any performance benefit that i get out of the window surely? I can easily write a sql statement with subqueries joining everything together, and only returning the columns that I'm interested in with a more lightweight library. This means I can map it to a struct that actually matches the data model I want for my application. The same goes for insert and update statements as well. ... unless I'm completely misunderstanding how this should be used?
I looked into your repo and I find it extremely easy to follow along the Future use (and I'm an absolutely beginner with Rust) - I'm going to be implementing it for my own project but would *love* to see this as a part of stdweb
Oh wow a reply to a comment in a deleted post :) What stops you from using diesel's association API? You should be able to use them to join and select most things. If you have very complex queries that just work better in SQL, however, I'm a fan of [writings views](https://deterministic.space/diesel-view-table-trick.html).
Wow, you use Windows to make sure others have a good experience with rust. You are a very self-sacrificing person, especially to help rust!
Well, if your `char` is `'static`, you can just use a `&amp;'static str`. Otherwise, you'll introduce a borrow to your character, so its lifetime must be shorter than that of your char. No matter if it's UTF8 or not, you can find the length of the corresponding byte slice using `.len_utf8`. Then you can create that slice using `std::slice::from_raw_parts`. Be careful, it's unsafe (also I'm glossing over endianness). Also note that this method takes a *reference* and the length, so you must ensure the char stays alive. Then you can call `std::str::from_utf8` on your slice to get a borrowed &amp;str. Perhaps someone should contribute an `impl From&lt;&amp;char&gt; for &amp;str`. Cc /u/Manishearth – does `char`'s repr allow it?
I want to avoid using `&amp;'static str`, it's part of a struct where really a char should be. It's `Cond(usize, char)` which should be a condition I want to test on a `&amp;'static str`, namely that the char at position `usize` is `char`. I'm using `string.get(usize..usize+1) == Some(char.to_string())` right now...
I appreciate you using Windows to help out. As someone that's been primarily a Windows user all their life, I've found the rust on Windows experience to have greatly improved since I first found rust in 2012. While there's some issues, I don't typically encounter them myself and I really do personally feel like rust is a first class citizen on Windows.
It's not drag-drop (for me); select the languages in order
Ah alright, makes sense! My apologies for not seeing your current code for the situation.
I'm not sure if it's possible to do this, since `char` is a "unicode scalar value" which doesn't necessarily have the same byte-for-byte representation as the (possibly multiple) bytes it would take up in a string. https://doc.rust-lang.org/std/primitive.char.html#method.encode_utf8 looks like it could be used to do this much more efficiently than allocating a string though. It won't be an `&amp;'static str`, but it will be an `&amp;str`: fn char_equals(c: char, s: &amp;str) -&gt; bool { c.encode_utf8(&amp;mut [0u8; 4]) == s } 
But that's for project names, we're looking for metasyntactic variables here, for which I think nonsense words might be better than recognizable names. So maybe taking some of the technobabble from the [turboencabulator](https://www.youtube.com/watch?v=rLDgQg6bq7o) ([more info](https://en.wikipedia.org/wiki/Turboencabulator)) would work better, and fit in with the "big metallic things" as well as "I keep making up different explanations" [origin story](https://www.reddit.com/r/rust/comments/27jvdt/internet_archaeology_the_definitive_endall_source/). * `grammeter` * `encabulator` * `turbo_encabulator` * `spurving` * `magneto_reluctance` * `amulite` * `nofer_trunion` * `dingle_arm` * `soinasoidal_repleneration` Etc.
**Turboencabulator** The turboencabulator or turbo-encabulator (and its later incarnations, the retroencabulator or retro-encabulator and Micro Encabulator) is a fictional machine whose alleged existence became an in-joke and subject of professional humor among engineers. The explanation of the supposed product makes extensive use of technobabble. The gag was popular for many years. The following quote is from the original Students’ Quarterly Journal article written by J. H. Quick. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Built with gnu abi inside of msys2 for gtk dependencies. Then I just packaged my installer with all dlls. I have a script for that.
You can use the system allocator instead of jemalloc, if you use nightly. See https://doc.rust-lang.org/nightly/unstable-book/language-features/global-allocator.html
Though I never tried to run Rust on Windows (mostly because I only use Linux nowadays), I can feel the pain. But, to be honest, practically every CLI tool on Windows will require you to mess around with the PATH or at least with .bat files. My best advice is that you should use a tool to "unix"ize your Windows box, like Cygwin on MSYS. Of even try using WSL, which may cause less problems. [I've also built this small demo](https://github.com/luksamuk/wasm-demo-rs), inspired on Koute's wasm32-unknown-unknown port of his NES emulator Pinky, which can probably help you get started; it has a Makefile included for you to start straight away.
In that case, why don't you get the char from the string at the given position and compare with another char?
I've found developing on windows to be such a shitshow for anything. VS didn't help me.
&gt;even just having a useful command line was enough to get me to switch Powershell isn't that bad. Just different. Also there are enough unix-like command shells available, like Cmder.
Isn't the hashmap implemented using robin hood probing? this means an insertion can move existing items and thus invalidate references. Of course if the map used linked buckets there would still not be a way to represent this in rust, but at least you can be sure that a real problem is caught by the compiler here =)
I use Linux full-time, both because I like it and I can't stand the other two major OSes. Thanks to Steve using Windows, I was able to write a program for Windows users using pure-Rust crates on my Linux machine and have it work perfectly on my users' Windows machines. 
Absolutely concur - PowerShell has a logical consistency I've never seen on any other shell.
Thanks for your hard work - I suspect you've made life a lot more pleasant for me. 
I was looking at ripgrep's sources. In the [args module](https://github.com/BurntSushi/ripgrep/blob/7ae1f373c2b899c7db5f8106dec4d7423b1d8364/src/args.rs) for example, there's a public Arg struct with a bunch of fields. All these fields are private. In the impl block for this struct, there's a bunch of public functions that act as accessors (for example, there's a `pub fn threads` that simply returns `self.threads`. What's the benefit of this approach ? Intuitively, I'd just have marked the thread field as public, but I guess I'm missing something.1
&lt;3
It's an accessor method, a common pattern used in many programming languages. It's a minor example of [defensive programming](https://en.wikipedia.org/wiki/Defensive_programming). What it affords you is a compatibility layer for anything accessing the fields in case the underlying struct goes through changes. For example, `threads()` could no longer be represented as an immediate state (`self.threads`), but a composition of other states (`self.total_threads - self.passive_threads`). Without an accessor method, this would require rewriting all call sites as the struct is changed.
https://github.com/dtolnay/cargo-llvm-lines [previous discussion](https://www.reddit.com/r/rust/comments/7hicbv/improve_compile_time_and_executable_size_by/)
The only IDE I use is Visual Studio, which I use for C# and related languages only. The windows command line is fine I guess, but I still prefer something linux, even if the only commands I use are `Ctrl-Z`, `cargo build`, and `fg`.
I think that the second edition is better written, while the first edition is more complete (that will probably change in the future as a lot of effort is being put into the second edition). This is why, as of right now, I recommend that people go with the second edition at first, for learning Rust, and then check out / skim through the first edition as well, to learn more things they would otherwise be missing out on.
I've used a number of ORMs and crafted others in other languages, ad I like the approach. Notably, when I've had to craft them it was when my (pre-existing) DB didn't match the way a particular ORM worked (too many seem to target new DB's and work with existing DBs as an afterthought). Looks like Diesel may be good for that. When I have more familiarity with Rust, I will be certain to return and experiment.
Just out of curiosity, was there any particular reason you picked `~` for your alphabet, rather than `-` as the [URL- and filename-safe base64 alphabet](https://tools.ietf.org/html/rfc3548#section-4) does? Aside from that and padding, they're identical.
did you see this? http://reddit.com/r/rust/comments/7ocam1/it_can_be_quite_frustrating_to_use_rust_on_windows/ds8gjbf
&gt; that improves the experience for tiny platforms that are also non-POSIX (embedded stuff, etc.) And, arguably even more importantly, helps future-proof it for any new non-POSIX mainstream-platform OS that might appear.
Ah, I didn't see WSL. I've been using Cmder since cmd itself is pretty atrocious, and I'm used to *nix coreutils. It's also nice to use sublime without running an X server, and run Rust bins on my host system and test windows. Yeah, devving for win on VS is pretty horrible IMO. I really dislike how "magic" the configs feel. I recently had to open a C++ project and hated how complicated it felt compared to a nice and simple Cargo.toml file.
NPM has an option to use a flat directory structure and Windows 10 has the option to disable the path limit. No problem there whatsoever.
The limit can be disabled on Windows 10.
I haven't had issues with Rust fortunately, but web tools (npm and the like) really aren't built with Win in mind unfortunately since they're going to run in production on Linux most likely. WSL is pretty nice for that stuff.
I agree! I haven't actually used Rust on linux yet, with most of my projects being non-server based. It's a blast compared to stuff like Ruby or Crystal.
I agree. Hell, I've had an even better experience with Rust on Win than I have with C#. 
Powershell is interesting, but it's difficult for a lot of people (including myself) who are so used to *nix utils. Cmder is very, very nice (despite being quirky with mouse mode in vim). 
I might just have a difficult time wrapping my head around Windows tooling in general, then. NuGet to me is magnitudes more complicated compared to cargo, and IDE/project settings still feel like magic.
&gt; To fix, make MyServer implement clone, and then use .clone() within the closure: &gt; &gt; that works, but there's also must be "move" in move || Ok(svr.clone())).unwrap(); 
VS is *very magic*, and understanding the specifics is something I haven't been brave enough to attempt. But you don't really need to if you just want to write some code and include some libraries. If you use NuGet with the GUI tooling built-in to VS, then in my experience if Just Works^tm.
&gt; It is FnOnce because it can be called only once, while the function you are calling expects a Fn instance, which can be called infinitely many times. why can my original structure with no field can be called only once, whereas the struct with a single field can already be called not once, but multiple times?
As somebody who uses linux most of the time, I have found pretty much any development on windows to be fairly broken in comparison. I won't say that the rust windows support is fantastic, but I will say that I've had a much better time with it than both python and C. This doesn't mean that there isn't room for improvement, but I definitely wouldn't say it feels like a second-class platform. To be honest, if you are going to use windows, you should probably accept that programming is going to be difficult.
For 2: In your original example that worked, you never actually created the struct - it was 0-sized. So, the closure was always callable multiple times because it didn't have any data. Once you added a field to `MyServer` and constructed it before the closure, the closure changed to "capture" that data. Since the closure captured it, and moved it, it could no longer be called multiple times. After the first call, your closure's data would already be used, and it wouldn't be able to use it again. The `.clone()` solution fixes that because with it, the closure no longer "uses up" the server. Instead, it just makes a copy and uses that. I'm glad it works with `move ||`, I didn't realize hyper would need that but I guess that makes sense. For 1: There are definitely other ways of solving it, but these two are the two simplest and most efficient ones for each of the two general cases (not modifying data, and modifying data). If you have some other requirement, I could try to find a way to make it work.
while I do not defend NPM for being dumb with package trees etc, that's entirely Windows' fault. Limitting paths ...
Thanks!
Well I had the issue that I can't even move files to the waste bin ... even through the "console". Which seems to me as if it was not fixed yet tbh ... then again Windows is so bad, I would not even be surprised if the cmd actually uses the explorer to move stuff.
Wow... how people developed the majority of desktop software is beyond me
Well duh, bash is outdated 80s language and is used for things it was never designed for. 
It's not, it will only work for ascii. A char is encoded in utf32, and a string in utf8. For multibyte characters this means the bytes themselves will differ, even if the codepoints match.
Box has a special deref implementation that permits moving its value, this is separate from `Deref::deref` and is one of the strange parts of rust you have to live with: pub fn dereference&lt;T: Sized&gt;(arg: Box&lt;T&gt;) -&gt; T { *arg } See playground link: https://play.rust-lang.org/?gist=88a16fea099fa5a65c6160ac3153a843&amp;version=stable For much more details, see: https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/
This is how [Zulip](https://zulipchat.com) is structured. Kind of like a slack clone but centered around "topics" instead of channels.
The `cfg(not(...))` syntax might be the key thing op was missing there.
I think the main idea is to prevent mutating things. Mutability is a property of a value or reference, not ever of a type, so the main way to prevent mutation of specific fields is is to make the field private, and provide an accessor, as ripgrep does. The other advantage is a guard against breaking changes: this way, you can freely change the field name, make a new getter, and deprecate &amp; #[doc(hidden)] the old getter without it being a breaking change. If it was a struct field, changing the name at all would be breaking.
/r/playrust please. This sub is for the **PROGRAMMING LANGUAGE** Rust.
Why wouldn't it?
Obscure distros are best distros, because they approach problem solving from a fresh angle. Debian is old and it belongs to the past, kinda like C. But old folks don't like learning new tricks. Debian stable is fine but packages are ancient. Unstable channels are mocked Frankendebian for a reason. Currently running nixOS and it is completely different experience from other distros. Many novel ideas solving old problems but a lot of new stuff to learn. You declare your system in nixOS you don't fiddle with million different config files each having its own structure. Shame it uses Linux kernel, it deserves better kernel, maybe something like redox kernel but not another attempt to recreate Unix but completely new approach, new filesystem hierarchy.
Also, humans are way too greedy to ever work in teams. It's not just Rust, you see this behaviour in DayZ, Arma, whatever. IRL this would be different because people usually have a certain morale. But in a game, where the whole point is to kill other people? Teams with anonymous players rarely work out.
Writing up the blog post for the call for community blogposts (and it will double as my "Happy Birthday Way Cooler" post). Is there a "deadline" for when they should be posted? I planned to post it on the 9th to coincide with the birthday, and don't want to miss the boat :P.
I saw it and tried it, it worked. Then I noticed that rustup run also worked which did not before. So I need to investigate further what's going on. It could be that a bug was fixed at some point.
Same. Spent hours trying to install Cabal so I could work on a Haskell project. Eventually gave up. 
Like, developing for windows in general, or developing for windows on rust?
How?
The thanks for that goes to everybody who worked on the standard library design, which is a whole lot of people, but I don't think Steve was a part of that?
The reason the first one works is simply because the `MyServer` struct is _inside_ of the closure's code. Meaning it gets recreated whenever the closure is called so it can be called multiple times. So each time the function is called it returns a _different_ MyServer. The second one doesn't work because it closes over an outer variable so it attempts to return the same one every time but it can only return it once because it's not a `Copy` piece of data. You can just derive `Copy` on it if you want to make it do that; it has nothing to do with the single field and just that you store it in a variable first and then close over the variable.
Nope. char is utf32; codepoints are represented as different bit sequences in utf32 and utf8.
&gt; No tool does this for users and no projects have made an attempt to fix the issue either in documentation or in code. This is incorrect; both tools are moving to a model where they're distributed with rustup. This takes time, but has already happened with rustup on nightly I think.
Wow, this is a pretty intense programming language. 
Gives me plenty of time to catch up on what I missed :)
It's as if school themselves could learn something. How strange...
I just started in my dev career and made a couple contributions to Diesel during the impl period. Over the past year I’ve noticed that one of the best ways I learn is pairing, or at least watching devs work while they just “think out loud”. I don’t suspect I’m the only one but I do suspect this isn’t something that’s really possible with open source. All that being said, id love to pair on Rust things with more experienced devs. I think if it was even once every two weeks if a dev just opened up a google hangout and shared their screen, or broadcasted on YouTube for us to be able to hear them think and work on whatever feature. This not only would give contributors insights into the codebase with whatever’s being worked on, but also help them grow a bit as a programmer. Like I said it’s a hard thing to try to implement and finding the right iteration may prove impossible. But I just thought I’d throw it out there. Maybe open source contributors/maintainers are willing to pair a lot more than I’m giving them credit for. Just a thought!
Totally agree with you. Also the reference was so much better than the first edition around a year ago. I have no idea why we create a second edition which is more lengthy while we need to speed up learning experience. 
Properly utilized slack is the same. There are generic channels and per-topic ad-hoc channels that get archived after work is done, preferably private. 
Shows the advantage of having core team members using it though. 
Not sure if u agree but I just want it to be like erlang/Elixir.
Ideally - yes, but with typed messages. I think there is no better framework than OTP for network systems (design wise).
The paragraph about "clear mentoring instructions" made me think that a tutorial for newcomers on how to fix a E-Easy bug could be useful. It will need a bug with clear mentoring instructions and then step by step instructions on how to resolve it beginning with a checkout of a revision where the bug is still present. This could be valuable because when you think about fixing easy bugs in a huge project like a compiler, one of my first thought is "during the time it will take to set my environment and be able to compile the project, someone will have already done this really interesting bug" and then my motivation drops. Learning how to basically swim before jumping into the pool is quite comforting. wild mode: this could even be a mooc with more than one bug!
Ya.. that is the part that stops me from being all Rust almost* all of the time.. at least for distributed network stuff
I ve been hitting the rustfmt and clippy being installed issue on MacOS and Linux too for a couple of weeks, it looks like everybody is hitting it.
`let _ =` has different behavior than `let _foo =`. See https://github.com/rust-lang/rfcs/issues/537 . It immediately drops what is assigned to it. If you just want to declare a variable that you're not going to use, but still want to hold onto until the end of scope, use `_whatever`.
`let _ = ...` does not assign it to a variable named `_`, it ignores it. The thing after `let` is a pattern, normally when you say `let x = foo` you're actually saying "pattern match `foo` to the given pattern, `x`", and when you match `foo` to the pattern `x` it means "assign the matched value to the variable `x`". This is why `let (a, b) = ...` works. `let _ = foo` says "pattern match `foo` to the wildcard, and then ignore it". No variables are set, so the destructor runs immediately. Assigning to `_` is no different from just making a statement out of it, i.e. `foo();` is equivalent to `let _ = foo();`. Except for the unused_must_use lint, which detects `let _ = foo();` (or anything other than `foo();`) as an explicit acknowledgement of you throwing in the result.
To answer with the nuance of the `_` pattern see [answer here: *The _ pattern, no-op pattern*](https://github.com/bluss/rustfaq#the-_-pattern-no-op-pattern). Note that the effect this pattern has: it does not bind any values. That things are immediately dropped only happens *if* there are no *other* bindings to the value. See examples in the link.
Oh, I thought for some reason this was a Windows-specific issue. Only saw reports from Windows users. My mistake. If that's the case, I apologize for what I said in my parent comment.
I'm trying to find what occupies place in my own code.
Haha, sorry. Yeah, it had the most google juice when I was trying to figure out how to do what I need. So the associations let me join tables in queries, and I can select the information that I'm after... it's that the query functions all must return structs that map directly to a single table, and then it's up to me to piece everything back together. I guess I could create a view and select on that, but it won't help with the insert or update queries which still need lots of back and forth (if I already know the lookup tables have the values I need I can use subqueries in the values / set parts). It seems like an ORM should map my applications data model to the database, but I end up having to manually map my data model to the orms data model, which maps to the database. It feels like that's open to more bugs than just a row mapper for a sql query, but now I have way more complexity in my application.
Diesel's query functions *don't* need to return something that maps to a single table! You can totally write a strict that just maps to the columns in your select. See [the examples here](http://docs.diesel.rs/diesel/query_dsl/trait.QueryDsl.html#method.inner_join) for instance. You can use insert, update, delete on simple view in Postgres btw. Sorry, don't have time for a longer reply, check out the Diesel Gitter rooms or people who can answer this in more detail :)
Developing **on** windows. Last time I tried C++ + VS it was so overly complicated that I re-wrote whole code in Rust and compiled it on Windows.
Aha, that looks like exactly what I'm after! I must've gone straight past that section so many times. Amazing, thank you :) Yeah, Postgres is fantastic but this an attempt to rewrite an existing Python tool that's using sqlite. I'll give this another go, if I can get diesel to return the types my application uses directly without having to modify the db then I'm all in.
The *representation* of the TOML value contains the quotation marks to show you it's a string -- it could also contain brackets to show you it's an array. You need to match on the value or call a method like `as_str` to get the inner data (which can fail if it's not a string!).
Furthermore you should consider writing your structure as types and using serde's Deserialize instead.
The compiler can give you some suggestions like "foo not found. Help: import it with `use super::foo`". Are you using this or is this a completely custom implementation?
That's a really good idea! Currently there isn't any actual auto-importing (it's planned, but not fully executed), but rather you supply the path as an argument. So perhaps I should just remove it all together?
AFAIK the compiler doesn't suggest `extern crate`s, but you should check. (Rustfix is able to work with the suggestions, but it's not as smooth as I want it to be right now.)
About the preserving of the formatting, the approach I took in [hsimport](https://github.com/dan-t/hsimport) is to use a library for the parsing, but to only add or replace imports in the source file. The library I'm using has source spans for every element in the source, so it's quite straight forward to add or replace imports. [vim-hsimport](https://github.com/dan-t/vim-hsimport) does only support semi-automatic import addition, the user has to ask for the import of a concrete symbol. It uses [hdevtools](https://github.com/hdevtools/hdevtools) to get the info in which modules the symbol is defined. `hdevtools` is a server that caches infos about the dependencies. On the Rust side [RLS](https://github.com/rust-lang-nursery/rls) might be the equivalent or the right place for the addition for such infos. The normal workflow of `vim-hsimport` is to call the compiler, automatically jump to the missing symbol and then use a shortcut to add an import. Even if you're trying to go for the complete automatic approach using the compiler to tell you about missing symbols seems the easier way than to analyze the source by yourself. 
[It does!](https://play.rust-lang.org/?gist=7adf2c7f1b3e7df1a218037542c8a03a&amp;version=stable) That's pretty epic! TIL about Rustfix. I'll read up on it and see if I can `.clone()` some ideas :\^)
`.clone()`? I thought this was all about `extern crate`ing stuff! :D
&gt; About the preserving of the formatting, the approach I took in hsimport is to use a library for the parsing, but to only add or replace imports in the source file. The problem is those insane people who put everything on one line so you can't simply inject stuff. I want to make it as reliable as possible... if possible. &gt; On the Rust side RLS might be the equivalent or the right place for the addition for such infos. Kind of what /u/killercup suggested as well. I guess I should leave that to editor plugins and simply be a way for those plugins to reliably insert the imports.
I would say "point taken", but I can't seem to move out of borrowed content.
I think the main issue with Windows testing is that most Windows users are 'Corporate' Windows users. Behind firewalls that rewrite SSL and use NTLM and super weird antivirus software. At work, I can't use rustup, for some reason rustdoc (invoked by rustc through cargo check) hangs the _system_ ) Fun times... So I build rust from scratch and it works...
&gt; I'm using the parsed import information for the inspection and addition. So no complex wrangling with strings of any kind. Afterwards you just have to pretty print the import. Oh, sorry! I think I misunderstood you completely! &gt; One thing is finding the missing symbols, the other is finding the modules where the symbols are defined, to be able to create the `use` statements. Or are you just after the `extern` statements? Yeah but the compiler suggests what to import too (apparently), magically enough. I don't have to lift a finger! [Example](https://play.rust-lang.org/?gist=7adf2c7f1b3e7df1a218037542c8a03a&amp;version=stable)
&gt; Yeah but the compiler suggests what to import too (apparently), magically enough. I don't have to lift a finger! Example Oh, that's really nice! The question is how deep in the module hierarchy the search goes and what happens if the same symbol is available in two different modules?
Please give a code that compiles next time. There are tons of errors to begin wtih (`config` misspelled as `content`, indexing by `&amp;&amp;str`, etc.) This is what I came up with: https://play.rust-lang.org/?gist=8d2089bbb3951f69138de15c39d91705&amp;version=stable Your main mistake: you need mutability like, *everywhere* in this case. You are not using a single `let mut` in your code, you can not expect to be able to change stuff. [Variables and Mutability](https://doc.rust-lang.org/book/second-edition/ch03-01-variables-and-mutability.html) from the Rust book should be a good read.
thx, but your codes inserts "section2" into "section1", whereas I want them both to be on the top level, next to each other.
Well, I did not change the logic of your merge, only mutability problems. If you want to merge items of both dictionaries, you have to iterate over section2 and insert all of the entries to section1.
That's due to the Win32 API having a more path restrictions than the NT kernel or NTFS. Both CMD and Explorer, along with most Windows software, use the Win32 API. With CMD you can bypass the Win32 path processing by prefixing the full path with `\\?\` (e.g. `\\?\c:\folder\file.ext`). Powershell uses the .Net API, which does its own path processing, that, as far as I can tell, can't be bypassed. WSL communicates directly with the kernel, and it isn't effected, so you can do [fun stuff](https://i.imgur.com/Q0avBGl.png).
I'll re-phrase: I want to take an existing "config", select only 2 top level nodes - section1 and section2 - and return a new "config2" which contains only these 2 nodes - section1 and section2
This would probably be the easiest: create an entirely new map (table), insert these two `Value`s - bam, done. https://play.rust-lang.org/?gist=590d31dbbea2c52c80a491bbe8d817f4&amp;version=stable
thx
Where is your link to API documentation?
I think it lists both, but I can't try it currently.
yes, one good thing to use `may` is the mild leaning curve. you can freely do whatever in coroutine context just like in the normal thread.
There is no documentation yet (this is pretty high on my mental TODO list). The crate has not been published to crates.io yet so does not exist on docs.rs for me to link to in the manifest.
I've had similar thoughts regarding Vulkan, using [vulkano](http://vulkano.rs/) and [specs-rs](https://github.com/slide-rs/specs). In particular, I thought it would be really cool if you could abstract away where a system was run (CPU or GPU), depending on platform availability.
Aye. My suggestion is to write docs, include a link to them in the README, and then ask for feedback again. Here was my progression: 1. Open README. Read it. Sounds interesting. 2. Look at `Cargo.toml`. Finds dependency on `walkdir` surprising. Realized that I must have misunderstood what this library was doing. 3. Searched for API docs to get a more in depth understanding. 4. None existed. OK, this is too hard to review. Comment on reddit because maybe I missed the docs.
I didn't mean to sound like "obscure == bad"! I use Arch myself and am actually planning on switching to nixOS as well!
`rustc` can emit json I think, so if you're looking to parse errors and warnings, that might be what you should go for.
 I tried to be fair in my criticism but in retrospect it was unfair to say no one was doing anything about it and I apologize. There must be some good reason for not allowing static linking because it would solve all of these problems easily and cleanly. I wish it could be investigated rather than projects having to be locked into specific distribution methods if they want to link against the compiler.
&gt; for some reason rustdoc (invoked by rustc through cargo check) hangs the system dang! i wish we could sort that out...
not on the libs team, but I think it's because doing it that way isn't the way that we wanted to do it, ie, that magic interface isn't very good. Note that today's `alloc_system` usage uses said allocator machinery.
Ah, sorry, taking a look at the `alloc_system` feature I see that it is using the allocator machinery. What I was wondering about is why there isn't just a very simple opt-out that can be stabilized, to solve the papercut of people who build a small Rust binary and then are surprised by how large the result is, without having to go through the whole process of stabilizing the allocator interface. I suppose if I want such an interface I should propose it formally.
Wrong subreddit. You're probably looking for /r/playrust
I am doing a refactor of artifact and one of the pain points is testing a commandline application with color (honestly a pain point was writing a command line application with color in the first place!). A crate that does *basic* html -&gt; ansi would be a *huge* boon for cli's that want to use color and tables. Please please please implement (if you don't.... I will!) I think this would be a great first create for a newbie as it has a pretty simpler set of requirements but can make a big impact.
Just some ideas: - first, I don't think there's any need for your `linen` crate to recreate an OpenCL wrapper, the [`ocl`](https://github.com/cogciprocate/ocl) crate already does that (it contains the `cl-sys` wrapper, the `ocl-core` crate for low-level OpenCL, and `ocl` itself, which is high level`). - the same repository I linked has an [`async_menagerie.rs`](https://github.com/cogciprocate/ocl/blob/master/ocl/examples/async_menagerie.rs) example which creates a CPU pool and uses futures to handle OpenCL events.
I was being sarcastic, suggesting that occidental schools may one day start teaching rust too, following in the steps of Chinese schools.
Please look at https://caddyserver.com/ (written in Go) for features and UX.
Last time I looked at it SAFE_ALPHABET didn't appear to have any 'Z' or 'z' in it. Now it does. Don't know why. Maybe it was a Github view thing.
that looks *amazing*! I can't believe I've never seen it! When testing for the color output on windows... how do you do that?
I'm thinkin about starting to learn Rust in 2018, would you recommend the second edition of the Rust book or Programming Rust? Or both? I have decent experience with Java and a fair bit with Python, but nothing too advanced.
Also, I will do mentoring help and code reviews for anyone who wants to take this on (beginners extremely welcome!)
haha, "you don't" is a fine answer. I figured as much! I'm glad I can at least test it on unix and then rely on your excellent library to do the right thing otherwise ;)
Note that from a cursory look, `console` looks great too, although I haven't used it. Keep in mind that I built `termcolor` with a focus on efficient emission of colors in a multi-threaded program. I didn't focus too much on API niceties (although I'm not opposed to them) or functionality other than coloring.
Chris, this podcast is so amazing. Please keep putting out New Rustacean! I love having a podcast medium to learn about the big developments in the community and get to know the *people* using and developing Rust better. :)
Author of [ocl](https://github.com/cogciprocate/ocl/) here. Futures have been integrated into the library for nearly a year now. They are safe and work extremely well for coordinating transfers of data between host and device, etc. I had no idea anyone else at all was interested in this so what is sorely lacking is documentation. I'd be happy to put together some better examples and documentation to explain how to use everything (the `async_` [examples](https://github.com/cogciprocate/ocl/tree/master/ocl/examples) are probably overly complicated for learning). I'd also really appreciate any feedback on how any aspect of the library, features-related or otherwise, could be changed for the better. I've been waiting for the list of needed improvements that you mentioned you were putting together several weeks ago, /u/Kerollmops. Did I miss it somewhere? I'm still curious to see what you feel is in need of tweaking so we can fix it! The library is not 1.0 and as I'm sure you know, I'm happy to break things in the interest of improvement. :)
There's a general sentiment among the core team that being forced to use Rust on a variety of platforms and with a variety of editors is a good way to ensure a high baseline of quality; I believe brson started the trend of using Windows for his personal workstation to such an end.
Apart from that thing where it sometimes gets confused between a foo and a list of foos with one element. :-)
It's true, you can't move out through a reference. Since indexing and the methods `.get/.get_mut` only give references or mutable references, those can't be used to move Strings out of the map. Like a common Rust collection, the map owns its elements. If you want to take ownership (move) of one of its elements, you will have to call a remove method. If you don't want to remove it from the original map, you'll have to clone it -- so that you own your own copy of the value.
Side topic: Can non-lexical lifetimes affect when `window` gets dropped?
It'd be better to stick with `foo` and friends, rather than confusing people with terms that sound like they _might_ mean something so you waste time looking them up etc.
Actually, speaking of gaps... Is there a curated list somewhere of the gaps that still exist in the ecosystem?
I think for your config types you should implement [Default](https://doc.rust-lang.org/std/default/trait.Default.html) instead of using unwrap_or and option fields. Then your default values are all in one place and you don't have to check the options on every access.
I'm not sure! Would probably be a great idea for end-of-the-year planning.
I think `rustup` already has some support for "telemetry": https://github.com/rust-lang-nursery/rustup.rs/blob/master/src/rustup/telemetry.rs#L9. With everyone moving to opt-out (Firefox, VS Code, .NET Core come to mind) or forced telemetry (Windows), I expect that to also come to Rust more sooner than later. In my opinion, it's terrible, but that didn't stop the others. There is a large enough corpus of open-source Rust code that can be used to measure any metrics a developer might want to. I disagree that it's necessary to introduce another feature with negative privacy implications.
Sometimes, you don't have the luxury of this choice. You could have an iterator of tuples: ``` let a = vec![(1, "One".to_string()), (2, "Two".to_string())]; for &amp;(n, ref s) in a.iter() { println!("{:?} {:?}", n, s); } ```
In this case, I'd suggest using [scrapy](https://scrapy.org/) instead, really.
No, NLL only affects how long a borrow is considered to be alive. For other values (or at least those with a `Drop` impl) the behavior must stay compatible, and predictable (dropping things at end-of-scope).
The `system` readme doesn't give me much information. How does it collect the info (wmi? etw?), and what does 'interact' mean? An example in the readme would help. The example in examples is *huge*, with tons of boilerplate like a help message etc. It would be nice to just have a minimal example.
Okay, good.
What’s the point of the last line? You’re just denying that theyvexperienced a problem? Hostile of you, and that annoys me a lot.
Lifetime question! See https://play.rust-lang.org/?gist=74d9d05bda8a6ca433af53bf40124362&amp;version=stable. I don't understand why this is happening. `li` and `nextline` go out of scope at line 32, so the borrow to `it` has ended, which should allow me to use `it`, shouldn't it? If it can't be made to work, I'm fresh out of ideas. I've worked myself into a corner and now I'm trying to structure my code better. For that, I've made `LinesIter` to hold an enumerated iterator over `&amp;str`, and the whole idea would be to repeatedly call functions like `skip_comments` on it to advance the iterator to a line satisfying some criterion (I know about `find`, I'll use it in this case, others are more complicated), and then use the returned `&amp;str` to either stop over all or call more methods that advance the iterator even further.
Uh no. Not for this. Scrapy is good if you want to datamine an entire site down through every index it has. For quick and dirty scraping like this? Beautiful Soup + requests is all you need. Using Scrapy for simple data extraction like this is sending a private detective to look for the sock you lost in the laundry machine.
Rustup does have telemetry, but it's not turned on. That's definitely the direction I was thinking - just turn it on. I definitely agree we could look at the corpus of Rust code (and we do, that's what 'crater runs' do) for some things. For others, though, we don't have any way of seeing into issues that we can't see by just reading open source. Note too that I said opt-in a few times. I don't agree with opt-out, with tricking the user into giving telemetry, etc. Trust is important, as is privacy. The data is valuable, but we want to make sure we gather it in a way that protects the person volunteering it.
Why's that? :)
Kuchiki is good and fast but I personally find the API a little confusing. Once I got the hang of it, it worked marvelously, but I can't say I didn't spend 3 days in the API docs figuring out how to make it all work.
Be sure to check out Jason Orendorff’s talk. I found it to be a slow burn; it snuck up on me. But it’s great. I dig the dry humor.
In your example, these two are not equivalent - they just seem to be because `println!()` doesn't care as much what you give it. In the first example, `thing` is of type `&amp;&amp;Thing` - this is because you're adding an additional reference to a value which is already a reference. In the second example, `thing` is of type `&amp;Thing`. You can see this here: https://play.rust-lang.org/?gist=5afd6ed93e19b88e0022c21210a38c34. For your code, the first is always redundant. I would never see a reason to use `for ref x in (...).iter()`, because you'll always end up with `&amp;&amp;X`, and double references really just aren't that useful. It's redundant. As for why `ref` exists: see /u/despawnerer's answer. It is needed for certain more complex patterns - if you're pattern matching on something which is not already a reference, using `ref` will only capture a reference and not take the thing by value.
[systemstat](https://github.com/myfreeweb/systemstat) also supports some things on Windows :)
Speaking of Vulkan, [there's a nice compute-oriented C++ wrapper](https://github.com/alexhultman/libvc). We need this in Rust. Can everyone just switch all compute things to Vulkan instead of OpenCL ^because^i^don't^have^opencl^working
&gt; Note too that I said opt-in a few times. Yes, of course. I was making a "slippery slope" argument (make it opt-in, make parts of it opt-out, decide that the data is still biased and so on), which is rather unfair to you, I suppose. _Off-topic rant:_ On the other hand, I've seen this in the other projects I've mentioned. E.g. there was a recent push to collect anonymized Firefox browsing history for common websites in an opt-out manner. When people pointed out that Alexa provides such information, the response is that Firefox users might have a different browsing behaviour, making this necessary.
I was thinking of exactly this, actually. There are a few ways I think we could gather that info: - A list for comparing available libraries from other languages, like you're saying here -- it will help people familiar with other languages reason about libraries in Rust better at the start, and help us spot missing libraries. Probably the easiest and most valuable. :) - The other list would be a list of domains and libraries that apply to them, where gaps will become obvious as people contribute what they work with and use cases they would expect libraries to handle. I know that this would be helpful for people managing projects and those really wanting to know if they can rewrite something in Rust for their company -- I work at a forensics company, for instance, and it's really important to know what different file formats I can parse out just by using the library and rest.
Heh, I'm assuming I'm one of the inspirations for this. Its good to get the concrete numbers. Maybe I've just dealt with too many flaky benchmarks but I'm used to and assume the results would have to be manually inspected. I understand that small speed ups will be lost in the noise of the CI's jitter but it'll probably be (mostly) useful for changes in orders of magnitude.
I'll give a shameless plug for [voodoo](https://github.com/cogciprocate/voodoo), my Vulkan API wrapper. I occasionally use it for compute but there are serious limitations compared to OpenCL, hardware support being a big one. OpenCL capabilities will probably be merged into Vulkan at some point. Since it will likely be half a decade or more before these yet-to-exist API changes reach ubiquitous hardware support and since it will be easy to use existing OpenCL host code on top of Vulkan anyway (kernels can already be compiled to SPIR-V and Khronos has mentioned creating an abstraction layer for host code, which would be easy), OpenCL will remain the #1 API for high performance computing on a huge variety of hardware for many many years. Any idea why you can't get OpenCL working? Maybe I can help.
Awesome project! Feel free to take inspiration from [imag-timetrack](https://github.com/matthiasbeyer/imag/tree/master/bin/domain/imag-timetrack) or even [time warrior](https://taskwarrior.org/docs/timewarrior/) (which I use for almost a year now).
Uuuh I'd love to play stratego in the terminal! Awesome idea!
Slippery slope is a fallacy. That doesnt mean the position is wrong. But there are actual arguments to defend it...
&gt; Slippery slope is a fallacy. I know, I tried to point that out, but it might have been less obvious.
&gt; I'd appreciate any sort of feedback at all, from perf tips to high-level design choices. Why the downvotes? The OP's request was "I'd appreciate any sort of feedback at all, from perf tips to high-level design choices.". CaddyServer does have a ton of features in a easy to use package. 
I know there are a bunch of sites like https://arewefastyet.com/ (I think there was one for Rust too but I forgot the name of it.) Anyway, shouldn't their be blogposts about how to increase reliability for these?
 pub struct LinesIter&lt;'a, T: 'a&gt; { it: &amp;'a mut iter::Enumerate&lt;slice::Iter&lt;'a, T&gt;&gt;, start_idx: usize, } By using `'a` in both `&amp;'a mut` and `slice::Iter&lt;'a, T&gt;` you have said that the lifetime of the borrow is the same lifetime as that of the `slice::Iter`. So in the function the borrow is set to match `it` in the outer scope, effectively extending it longer than necessary. You can separate the two lifetimes and say that the `slice::Iter` outlives its borrow pub struct LinesIter&lt;'a, 'b: 'a, T: 'b&gt; { it: &amp;'a mut iter::Enumerate&lt;slice::Iter&lt;'b, T&gt;&gt;, start_idx: usize, } and adjust the impl accordingly impl&lt;'a, 'b: 'a, T: AsRef&lt;str&gt;&gt; LinesIter&lt;'a, 'b, T&gt; then it'll run.
Holy Hell, feels like I was so close to understanding that... yet so far *G* Thanks a lot!
This is sort of a follow up to my previous question, just not quite, so I figured I'd make it a new one. Please consider https://play.rust-lang.org/?gist=09d075bf03feb564b8b43497d62885b6&amp;version=stable. The error is a type mismatch for the iterators. And I don't get why that is. I mean, the slice iterator returns `&amp;str` items, so the enumerate iterator returns `(usize, &amp;str)` as per the docs, right? And so putting a mutable reference to such an iterator into `LinesIter` should just work, right? The error message is somewhat strange in that it claims it found `str`, which sort-of-fits by the number of ampersands... could someone entangle that for me? Thanks in advance :)
Literally started learning last night. Big C#/PHP background, originally learned to program with C++ and not going to lie... I loving Rust so far
Ah right, I thought it's `&amp;[str]`, but it's `[&amp;str]`. Thank you!
Be ready to forget everything you know about Arch. nixOS is declarative system, you declare everything in /etc/nixos/configuration.nix (systemd wide) while in Arch you issue commands and edit each config file separately. You do need to get familiar with nix in order to use nixOS. Issues I have so far are: &gt;query is slow but you can query multiple different packages at the same time. If you need to know package names in order to add them to your config.nix it is best to query them all together and write results in a text file. Nox is separate tool which employs cached queries. &gt;I'm not sure how you can dual boot with nixOS but that isn't the issues for me because I use docker and systemd-nspawn. If only Xserver was more flexible and allowed multiple parallel instances that don't add too much overhead and are active on the each of predetermined tty then in theory with containers you could have eight different Linux distros running in full graphic mode at the same time on one machine. Maybe this is possible but I'm not aware of it yet?
Vulkano supports compute: https://github.com/vulkano-rs/vulkano/blob/master/examples/src/bin/basic-compute-shader.rs Is there something about vulkano that makes it less suitable for compute tasks?
Oh true. Didn't know this one! I'll check how they do temperature (it's the only thing I don't support on windows).
For things like use of language features, would a job run over GitHub repositories be a useful approach?
If I am currently holding a mutable reference to `Foo` is it possible to use a function which takes an immutable reference to `Foo` and returns an immutable reference into `Foo` *within the scope of my mutable reference* and turn the return reference back into a mutable reference? I am implementing `Index` and `IndexMut` on a type which contains an interior `Vec`. My type must be able to index by `&amp;str`, which it does by iterating over the inner `Vec` and looking for a contained element which matches the index str. I already have this logic in place in `Index::index(&amp;'a self, idx: &amp;'b str) -&gt; &amp;'a Self::Output;` I think it would be convenient to have `IndexMut::index_mut(&amp;'a mut self, idx: &amp;'b str) -&gt; &amp;'a mut Self::Output;` merely call `Index::index` on itself (which downcasts `&amp;mut self` to `&amp;self` for the duration of the call) and return a **mutable** version of the reference returned by `Index::index`. Like this: impl&lt;'i&gt; Index&lt;&amp;'i str&gt; for Group { type Output = Element; fn index(&amp;self, idx: &amp;'i str) -&gt; &amp;Self::Output { for elt in &amp;self.elements { if elt.name == idx { return elt }; } panic!("Element {} not present", idx); } } impl&lt;'i&gt; IndexMut&lt;&amp;'i str&gt; for Group { fn index_mut(&amp;mut self, idx: &amp;'i str) -&gt; &amp;mut Self::Output { &amp;mut *Index::index(self, idx) } } Assuming I know how to read, which is always in doubt, `Index::index` always returns an immutable reference to an `Element`. While inside `IndexMut::index_mut`, it is **known** that casting an immutable reference to mutable is safe (because `index_mut` cannot even be entered without having sole mutable access), and so I feel like I should be able to reborrow the `Index::index`-returned reference from immutable to mutable because I'm in a scope where the compiler has already proven that I have sole mutable access to the entire `Group`. ---- I just copied the loop body from `index` to `index_mut` and turned `&amp;self.elements` into `&amp;mut self.elements`, and it works, but I am not hugely fond of having the same crawl logic in place twice when all I want to do is alter a compile-time annotation.
Not to shamelessly plug my own crate here, but let me shamelessly plug my own crate. You can also use [`endian_trait`](https://github.com/myrrlyn/endian_trait/blob/master/src/arrays.rs) to flip a slice's endianness in place, and then reconstruct the slice pointer as described by claire_resurgent. This is technically zero-allocating, if /u/rusted-flosse is okay with flipping the source slice. Otherwise, cloning it, flipping it, and transmuting the result will also work.
The other week I read an RFC or issue about getting the compiler to represent tuples using Peano logic specifically to support the exact use case you're describing. Unfortunately I don't remember which one it was, so I can't link at this time. This and const-generic arrays are things at which the team is actively looking, but are not yet on the map, as I understand it. Sorry:/
Thanks for the kind words! I really appreciate them!
Big fan of your work! I'm looking forward the the ECS compatibility updates. I'm using kiss3d, nalgebra and an ECS-compatible fork of ncollide in my work-in-progress [sorta-clone](https://github.com/jswrenn/laserstorm) of [AirMash](http://airma.sh). I look forward to tracking the master branch of ncollide again. Anyways, some challenges I've run into and other notes: * The [collision group API](http://ncollide.org/collision_detection_pipeline/#collision-groups)'s use of usize group IDs doesn't _feel_ rusty. * Similarly, having to track object's `usize` uids for [deferred_add](http://ncollide.org/rustdoc/ncollide/world/struct.CollisionWorld.html?search=#method.deferred_add) doesn't feel rusty (and, in fact, unintended uid collsions have bitten me in the ass). * Kiss3D is, by far, the best way to get a quick visualization of the physics state, but what I _really_ want is a library that just 'speaks' the same language as the [shapes of ncollide](http://ncollide.org/rustdoc/ncollide/shape/index.html). Gluing these libraries together [isn't pretty](https://github.com/jswrenn/laserstorm/blob/master/src/systems/render.rs#L46-L64). * For people who aren't yet linear-algebra magicians (like myself), a definitive guide for projecting nalgebra's suite of 2D types ([Point2](http://nalgebra.org/rustdoc/nalgebra/geometry/type.Point2.html), [Isometry2](http://nalgebra.org/rustdoc/nalgebra/geometry/type.Isometry2.html), [Translation2](http://nalgebra.org/rustdoc/nalgebra/geometry/type.Translation2.html), [Rotation2](http://nalgebra.org/rustdoc/nalgebra/geometry/type.Rotation2.html), etc.) to their 3D analogs would be a godsend. * I don't need _all_ of the power of nphysics, so I tried to look to the source for elegant tidbits I could pull-out. The code can be a little hard to follow. For instance, the position integration code has [lots of](https://github.com/sebcrozet/nphysics/tree/master/src/integration/euler.rs) tersely named and under-documented functions with _very_ terse parameter names. * Rather than [feature-flag between two-dimensional and three-dimensional types](https://github.com/sebcrozet/nphysics/blob/eff89cb2c84e674ab67465bf58225b3e79432fe7/src/lib.rs#L121-L172), could you just parameterize the types by a type-level `Dimension`? I had success doing this a bit in [my adaptation of nphysic's type-aliases](https://github.com/jswrenn/laserstorm/blob/master/src/types.rs#L7-L12). * I wish I could add `Ray`s to a [`CollisionWorld`](http://ncollide.org/rustdoc/ncollide/world/struct.CollisionWorld.html). 
Interesting. FWIW, I tried writing something equivalent in F# and got this: open FSharp.Data let html = FSharp.Data.HtmlDocument.Load "https://news.ycombinator.com/" [ for a in html.TryGetBody().Value.CssSelect ".athing" do match a.CssSelect(".rank"), a.CssSelect(".storylink") with | [rank], [storylink] -&gt; yield rank.InnerText(), storylink.InnerText(), (storylink.Attribute "href").Value() | _ -&gt; () ] 
People are linking to r/rust from less savory places on the Internet. While we wait for the subreddit mods to see this, let's exercise some self control and ignore this post. Thanks.
I'm not aware of any such library. Sounds like a great project though. You could start by porting BoilerPipe: https://code.google.com/archive/p/boilerpipe/
There are already libraries for perusing HTML (see [this Reddit thread](), for example), but I haven't heard of one that will do the sifting for you yet. Maybe you could peek at `newspaper` for some implementation hints, write something yourself, and then show it off? :)
FWIW, I was bitten by Thurs fairly recently trying to add Windows support to [`termion`](https://GitHub.com/erichdongubler/termion)...I was confused when I had no idea why my terminal initialization logic with a custom `Drop` didn't seem to do anything!
Thanks for the advice, I have implemented the system generator
Not strictly Rust related, but I'm trying to make some lifestyle improvements in honor of the new year, including trying to work up to a half marathon, and become more consistent with when and how much I'm working a week!
I am also working on a nom-powered parser, which I have never done before. It took me a couple days to figure out what the hell nom's provided components do and how to put them together, but once I grokked that it hasn't been too bad to assemble them into pieces matching the spec of the language I'm trying to parse. I'm happy to chat about my learning experience making parse functions that actually return a data structure, but I have not yet gotten to the part where I make those structures do work :/
Did you mean to post to /r/playrust?
I'm pretty sure these vulnerabilities are issues with the hardware, not software bugs, so it doesn't really make a difference. As I understand it, software changes can only ameliorate the issues insofar as they specifically compensate for the hardware issues, which is not something that a preexisting lack of bugs helps with.
lol.. uh... NO... uh... shutup.
Is it possible to add motion blur to env?
I wrote the http-entity crate you mentioned. I'd like for stuff like this to be able to directly use it rather than just borrow some of its code/ideas. Feel free to file issues for anything that prevents you from doing so. And I'd be thrilled if the issue discussion ends with you sending me a pull request. I think your gzip encoding stuff has a couple details wrong: the etag should be different for the gzipped version than the non-gzipped version, and the response should contain a `Vary: Accept-Encoding` header. The gzip encoding stuff should be possible to with the http-entity crate's abstraction. You could create a `Gzipped::wrap(entity)` that returns a struct implementing `Entity` that does the on-the-fly gzipping, and a `serve_maybe_gzipped`
Just thought it should all be one place.
This is the subreddit for the Rust programming language. Please delete this post.
It should! Unfortunately, you've encountered a very common name collision. The one place for this is probably /r/playrust
If I recall correctly, Firefox went with opt-out because they felt they (i) needed lots of data to compete with e.g. Chrome, and (ii) didn't think that self-selection would give them good results. I don't think these specific worries are as bad here, and opt-in with data in the clear could still have great value. I would love to contribute information about all cargo runs I ever do, but I'm not clear how I *should* do this currently. I very much want to in part because I'm not convinced that the metrics you all have are representative (not a ding, just reality), and I have an incentive to do so in that life might get better for me if I do. You all do have lots of public information in the form of crates.io, which would be a solid source of "build times to reduce" if you weight crate build time by number of downloads. Please don't rathole on "we would need an unbiased estimator of build time / errors / etc before doing anything". There seems to be lots to improve in the meantime. :)
Web servers. But we all already know and it is just a matter of time until the experience there is top notch.
Hey guys, this is my contribution to the #Rust2018 call for blog posts. I'm not on Twitter, so posting here.
Soo sorry as I'm a Perl, etc. programmer myself. Deleted.
in the context of web scrapping- this is very true. Rust don't have the right tools and I don't think it will have the right libraries in the short term. JS or Python will still be the right option. One option to build a good library around chrome/firefox something like Puppeteer
Thanks. This is excellent.
Then we're in the same boat. If you make a breakthrough, make sure to make a post here. I don't think there's anything useful out right now (at least specific to Rust's tools).
I _could_ also check for the char, since for a valid `String` in my case there's only ASCII, but I want to avoid the utf8 overhead, so I check for the byte. Thanks though :)
You can use `cargo` itself as a library for inspecting a crate. For example, in my `mdbook-epub` experimental backend I want to include the version of `mdbook` it's been compiled against as a constant in my crate. I added a quick [build.rs] script which uses cargo to load the crate graph and find the exact version of "mdbook" being used. That build script may be a nice starting point. You're probably looking for the `PackageSet` returned by [`cargo::ops::resolve_ws()`][ops]. [build.rs]: https://github.com/Michael-F-Bryan/mdbook-epub/blob/master/build.rs [ops]: https://docs.rs/cargo/0.24.0/cargo/ops/fn.resolve_ws.html
It seems like bidirectional iterator would often break invariants. Specifically consuming iteration over `Vec` can't be bidirectional. Also bidirectional `iter_mut()` would allow to create two mutable references to same memory, which is UB. Sure, you can safely implement it on immutable iterator. ATC+streaming iterators should help with that...
I’d expect BeautifulSoup to be the go-to library for delving into the document. But then, cssselect is connected with scrapy, which for a more thorough thing is the go-to library. I haven’t actually done anything like this for about three years now. (How time flies when you’re writing Rust!)
I don't think a REPL is what you want. But i have been thinking about a Jupyter notebook like experience. I don't have to much time to actually work on it , but i would imagine you would need to build something that can * Read a file with rust code ( but without main) * Split it up into sections * Glue the sections together so it is a valid rust program, and run cargo check on it. * Determine what variables move between sections * Make each section a valid rust program that can read and write the variables with serde. * run each sections &amp; dump stdout / stderr to the GUI. * User edits a section -&gt; recheck , and rerun this and all following sections You would need to build a GUI which is pretty hard, and you would also need to figure out a strategy for imports and struct ( You would probably import all structs in all sections ) 
&gt; Rust just makes it noob friendly. I'm not sure. There are many experienced programmers that make same mistakes over and over again. (Use-after free, buffer overflow, ...)
"they" is me :D no temperature on windows yet, only memory, uptime and battery
My assumption is that BidirectionalIterator would only be implemented for iterators that it's safe/makes sense for. By no means do I expect it to work for all iterators.
&gt; OpenCL is almost certainly available on your phone Some Android vendors provide OpenCL drivers, but [Google does not like OpenCL](https://issuetracker.google.com/issues/36953125). The drivers exist, sure, but you often have to manually put the library onto the device. Just ran OpenCL-Z on my Nexus 5X (LineageOS + vendor partition), it did not detect a driver. &gt; What's the Vulkan situation on FreeBSD? RADV works great :)
Sure. I just imagine newbies being confused why it doesn't work as they expect. :)
In tokio a UDPSocket is a `Sink` and a `Stream`, so you can call [`split`](https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html#method.split) to separate the halves. Then you can create a sending future, and a receiving future and combine them using [`select`](https://docs.rs/futures/0.1.17/futures/future/trait.Future.html#method.select) or [`select2`](https://docs.rs/futures/0.1.17/futures/future/trait.Future.html#method.select2) then execute that future on your tokio core. You might also want to consider using [tokio-timer](https://crates.io/crates/tokio-timer) for a futures based timer. For using stdio a thread is indeed probably the best way to go.
I've definitely felt that pain around `Index`. Having it work with other types would be great
It seems to me that the post is about "web scraping in Rust" using a trivial example. You don't need much to do something simple, but you're not going to be able to climb the complexity ladder at the same speed as you would if you had started with a more advanced tool (which doesn't require a lot of setup for simple tasks) in the first place.
It's the first time I laughed so hard watching a technical talk. I was only mildly disappointed that it tapered out after half-time, too busy brushing off the tears from the first half :D
Opt out with clear messaging is often best if it's not sensitive data. Most people will not stray from defaults unless it has an immediately tangible effect.
By the way Josh, in your talk you mentioned the lack of cross-language inlining. I know that D performs cross-language inlining, and since rustc is built on top of LLVM, it seems it should be easy enough to allow the addition of arbitrary LLVM IR modules. It should even be possible to make those additional modules "information-only" (ie, discard the code generated for them after the fact) by pushing their symbols into a special section. This would let you compile the C/C++ libraries with GCC if it results in faster binaries, but still present the content of *some* of them to rustc in the form of LLVM IR for sweet inlining. If this is important for Firefox, you may want to suggest this for the yearly plan that's coming up.
"bidirectional iterator" doesn't correspond to iterators in Rust but rather "cursors" (safe "pointers" to an element of a collection, that can be used to traverse it).
`dotnet` includes in its telemetry every command-line invocation. Would you call that sensitive data? It's a honest question.
[https://learning-rust.github.io](https://learning-rust.github.io/docs/a1.why_rust.html) might be helpful.
I am not sure that telemetry is as easy as you make it soon. I understand the appeal, of course, I'm just not sure how to make it work. --- It simply cannot be opt-out, from the point of view of corporations. *Just knowing* that a particular company is using Rust is already more information than some would like to share. If you start having data on the number of users, the size of the projects, etc... this could get Rust booted out of the company pronto. And if the company's firewall is properly managed, it'll be picked up real soon. --- On the other hand, opt-in implies self selection, and therefore bias. As mentioned above, many companies would probably forbid their developers to opt-in, for privacy reasons. For a company, the *default* stance is hiding internal information. There must be a clear business advantage for revealing it. Which means, I am afraid, that you wouldn't get much more information from telemetry than you would from analyzing open-source projects and getting private reports from the few companies interested in shaping Rust's future. --- Now, I may be pessimistic, of course. But if telemetry provides biased data, it may actually be worse than having no data.
Thanks, I was able to get a full package list, but not library names. Any ideas how can they be resolved?
File names, project names maybe, and command-line arguments, I think. It's anonymized, but it includes the MAC hash (which also happens to be reported by VS Code), so it still identifies a person.
Oh, and it also includes 3/4 of the IP address.
This should be possible with ATC (Associated Type Constructors), but I do not see how `Index` could be migrated to ATC without a breaking change.
I think it would need to report command line arguments unless they resolve to a file path or allow users to configure which flags to not report. Otherwise you lose a lot of value in reporting. Afaik the Mac hash can represent a person but the hash is such that you couldn't trivially reverse engineer the actual Mac address. 
😅 ``` The origin "http://evanandrewrose.com" has sent too many requests. The number of requests is limited to 600 per 60 minutes. Please self-host CORS Anywhere if you need more quota. See https://github.com/Rob--W/cors-anywhere#demo-server ```
&gt; I think it would need to report command line arguments unless they resolve to a file path or allow users to configure which flags to not report. There's of course the case of `dotnet run -- --api-token 12345678`. My point is that you can't tell what that will catch. &gt; Afaik the Mac hash can represent a person but the hash is such that you couldn't trivially reverse engineer the actual Mac address. I think you can trivially brute-force it, but that's less. A hash of the MAC is just as good as the MAC, in the end, especially if the whole ecosystem reports that back.
Hmm I would consider API token something that would be configured to not report. But if it allows for passing of arbitrary arguments , then maybe it only reports those that are registered. So a whitelist rather than a blacklist. At least in the implementation I would think of... Not sure about the exact details of dotnets implementation Re the Mac address afaik it's not just a straight hash. I could be wrong but it should be hashed against some machine specific key which should make it still unique without being easy to reverse engineer to the address itself. 
Thanks, doing our best for our users. We can still learn a lot from the awesome Rust community ! Also personally looking forward to have some time to learn rust more and contribute. 
more challenging, iterators are used most often in for loops, and I don't think it would be possible to signal to the loop iterator that you want it to sometimes go back one, limiting the usefulness of the bidirectional iterator.
I wish you the best of luck, then!
Thanks, that was one of the points I was trying to make.
Very cool. Thanks. Maybe I should learn Python. :-)
Once you have the `PackageSet`, you can call [.package_ids](https://docs.rs/cargo/0.24.0/cargo/core/package/struct.PackageSet.html#method.package_ids) to get an iterator over the `PackageID`s in the set. Then you can call [.name](https://docs.rs/cargo/0.24.0/cargo/core/package_id/struct.PackageId.html#method.name) on each `PackageID` to get the name string for that package.
Why don't you think a REPL is what they want?
Agree with the post and you that it should be opt-in. This gives me an idea about how we could implement it. What if the report apis were to cargo, and when the custom cargo instances land it would report to that instead. For companies that would/could be in-like. And whereas the company might not want to participate real-time publicly they might still be really interested in the data for their staff *themselves* ... and also might be willing to share the results privately with the core team if they differed from the public aggregate in any interesting ways.
I, too, would like to see `RangeArgument` stabilized. https://github.com/diffeo/kodama/blob/bbd0ede6d3ed71a38e8cd8f9f8bb717b93bf1427/src/active.rs#L173-L201 :-)
arewefastyet.com is also not on a CI system. These are real machines under some desk.
I started learning Rust a couple of days ago, finished my first basic project in it last night. Coming from a Node.js / Javascript background, I too am loving Rust so far :-)
Another option is Guix, improved nixOS concept but GNU/FSF project which means only free true software allowed, they don't even have Firefox. Guix uses Guile, variant of Scheme.
Appears to be broken currently, using latest firefox.
That's... a great idea. The last company I worked for indeed had internal telemetry tools which helped identify slow-to-build projects, etc... If the way to opt-in is to provide a URL to report to, or it simply reports to whatever server it downloads the crates from, then I can imagine much more interest in the feature indeed.
There's the Win32_TemperatureProbe API which is based on WMI classes: https://msdn.microsoft.com/en-us/library/Aa394493 It looks like you can access WMI classes via COM: https://msdn.microsoft.com/en-us/library/aa389276(v=vs.85).aspx, and IIRC winapi has some tools for accessing COM interfaces from rust.
I'll take a look. Thanks!
"It simply cannot be opt-out" Right, I mention this in another comment thread, but I was sure to call out being opt-in a few times in the article. I don't feel that opt-out is a good default as it's basically meant catch people. I want people to not divulge any information by default, so if they're busy when they're installing rustup or whatever they don't accidentally click yes. "On the other hand, opt-in implies self selection, and therefore bias." We already have lots of bias in the data we collect now. You have to have enough time to take a long survey. If you're too busy, we won't hear from you. For seeing your code you will need to be comfortable posting your projects on crates.io. How github works, you will also need to predominantly write your project in Rust. If it's just a little Rust in a bigger project, we won't see it. As programming languages grow, less and less of the total lines of code tend to be open source, so if we only look at github, we'll see a smaller percentage of the whole over time. Each of those give us some form of bias, which is why we would want multiple forms of input into the system. I mention a few of them, like doing usability testing, and doing smaller surveys, etc. The hope is that combined together we'll have less bias that we currently have. "Which means, I am afraid, that you wouldn't get much more information from telemetry than you would from analyzing open-source projects and getting private reports from the few companies interested in shaping Rust's future." You use 'companies' as a group here, though companies can vary widely in how they participate with open source projects. If we're clear the data is anonymous and used to improve the tools, it will play a similar role to other telemetry-gathering that they would be familiar with (like Visual Studio or the many cloud applications). "if telemetry provides biased data, it may actually be worse than having no data." I mention this a bit earlier, but we already have biased data. Any non-OSS or non-'I have time for a long survey' data will help de-bias us.
Works for me, though IMHO: - the edges are too long, - the "gravity" toward the center too strong - the repulsion between nodes too weak. Thus the "leafs" dependencies come back toward the center, which make the graph hard to read.
Yes and no. As programming languages grow, they tend towards a smaller percentage of code being open source. It's just a natural effect of people being paid to work on projects churning out more code than volunteering in the off-hours. This means we'll get more biased data over time. The other issue with things like github is that repositories only report they're Rust if the dominant language is Rust. Basically, we already have bias in the form of 1) you have to write a project and put it on crates.io 2) you have to have time to fill out a survey or 3) you have to make the project's dominant language Rust (meaning probably you wrote it from scratch) The hope with adding new ways to gather data is that we can work around these limitations a bit and give a clearer view into how Rust is being used.
😦whoops... I set up my own server and it's back up. Thanks for letting me know.
I feel you for the last bit. Fundamentally we trust the developers of https://crates.io not to deliver malicious content to our browsers in whatever form that may take. We also trust the browser to enforce that trust. This makes it tolerable for me to whitelist it.
For the first variation, I'd generally perform some kind of structural sharing between the two implementations. This could take the shape of a generic method or a macro. Methods are generally preferred since they have less capabilities and better errors. Note that your case is rather straight forward to implement with `iter`,`iter_mut`, and [`find`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find), but I'm providing this as a solution to the more general problem. fn find_by_name&lt;I, E&gt;(iter: I, name: &amp;str) -&gt; Option&lt;E&gt; where I: IntoIterator&lt;Item = E&gt;, E: ops::Deref&lt;Target = Element&gt; { for elt in iter { if elt.name == name { return Some(elt); } } None } impl&lt;'i&gt; ops::Index&lt;&amp;'i str&gt; for Group { type Output = Element; fn index(&amp;self, idx: &amp;'i str) -&gt; &amp;Self::Output { find_by_name(&amp;self.elements, idx).expect("no element found") } } impl&lt;'i&gt; ops::IndexMut&lt;&amp;'i str&gt; for Group { fn index_mut(&amp;mut self, idx: &amp;'i str) -&gt; &amp;mut Self::Output { find_by_name(&amp;mut self.elements, idx).expect("no element found") } } Playground Link: https://play.rust-lang.org/?gist=9251c68bdf7cda925c0bfd4c6c46e9c5&amp;version=stable &gt; Followup, same project, different question: &gt; &gt; How do I print a String such that characters within it are rendered as their escape sequences? &gt; &gt; I need to print a String that, if it contains quotes in the in-memory buffer, literally displays backslash quote \" instead of just quote ". This part sounds like you want to `fmt::Debug` the string: let v = "foo\nbar\""; println!("v = {:?}", v); Would print: `"foo\nbar\""` Maybe there's something I'm missing?
I'm not sure I fully understand what the problem is with Index. What prevents you from doing impl Index&lt;Range&gt; for Ropey{ type Output = RopeSlice; ... } ?
Awesome :) Having good documentation/tutorials on Vulkan with Rust would be really cool. One question tho: any particular reason you don't use vulkano instead of ash? 
The `index` method can only return a `&amp;Self::Output` which means for `RopeSlice` that you need to create a new `RopeSlice` and return a reference to that. Unfortunately you can't do this because `RopeSlice` doesn't live long enough. `Index` should really use a generic associated type to enforce that the return type is referencish rather than enforce an actual `&amp;` reference, e.g. trait Index&lt;T&gt; { type Output&lt;'a&gt;; fn index(&amp;self, index: T) -&gt; Self::Output&lt;'a&gt; } 
Hi Folks, I'm having a bit of trouble with multiple error type returns, here is what I have: https://play.rust-lang.org/?gist=7693050376a46a954d5be6a07725fe8c&amp;version=stable By reading the docs (https://doc.rust-lang.org/book/first-edition/error-handling.html#the-from-trait) I thought I should get automatic Box&lt;error::Error&gt; conversion as long as I implement `std::error::Error` trait however the code above does return the following "expected struct `std::boxed::Box`, found struct `MyError`". The approach I've taken also seems a bit convoluted, any tips on how to improve the error handling? PS: A lot of my inspiration comes from the io crate here https://github.com/rust-lang/rust/blob/master/src/libstd/io/error.rs 
I think that a REPL is something from the sixties (I am thinking about Lisp). A more modern approach to interactive programming comes from the eighties, and is an integrated development environment. I am thinking about Smalltalk, that is a fast-prototype-oriented language. Though, to have a Smalltalk-like development environment, I think an interpreter or a very fast incremental compiler is required, like it is for a REPL. So, the first step to have both is to have a program that can load some libraries (and compile them into a library cache), and then is capable of evaluating in less than half a second any (reasonable) expression that uses such libraries.
If you add a `?` to make it `Err(MyError::new(ErrorKind::MyErrorA, "X is not A"))?` then it invokes the conversion and executes fine.
What a great article, showing clearly the power of Rust &amp; wasm. Btw some games are running now (@ 18:22 UK time) click on view on the right of this page. The speed at which this game is running in 3D is awesome. http://russianaicup.ru
&gt; crates.io flat out refuses to display any information if you don't have javascript enabled. Remember back when we used to try and make the web actually function gracefully? Especially sites that have mostly-static content.
This is awesome!
Ah! Wow, I had a big misconception of the role of `?` I thought it simply unwrapped the results; thanks a bunch for the clarification!
I'm boring. Just single letter variables for me. Maybe x1, x2, ... if I'm feeling verbose.
You have one big choice when doing this: emscripten vs not. Emscripten is designed for "I'd like to get a desktop thing (especially games) running on the web asap". It includes a lot of shims for a lot of APIs to make things Just Work. It also means installing and setting up emscripten, as well as a larger binary size. There's also the new `wasm32-unknown-unknown` target, which basically is super bare bones. It gives you no help, but you also get exactly what you need, and nothing more. I would make this choice first and then let it go from there. Most projects say which target they support, or sometimes both.
Code Reuse in Rust https://gist.github.com/qinwf/55f651daece54a6fdfa2 
Good point, I reworked it a bit for readability. You probably need to open it in an incognito window to see a non-cached version.
View finals here: http://russianaicup.ru/contest/4/games So amazing.
Much better!
Ah, interesting. Yeah, I'd be happy to have a Cursor trait instead, that doesn't try to work with iterators per se. There's already the std::io::Cursor struct, but it's different enough that a minor name overload is probably fine.
That doesn't work on the PaaS setup, where you're given exactly one port to listen on and everything has to be done inside your application on that one port. Yes, I could run two different applications - with a different external hostname for each - and that would technically work, but it's a lot more complicated to set up (plus you'd be paying for twice as much server time)
Yeah, just using `RangeArgument` honestly gets me most of what I actually care about. And `text.slice(2..8)` is really not that bad at all. Regarding `&amp;[..]` syntax, I definitely see where you're coming from. My intuition is maybe just a bit different: I assume that if slice something, the slice will have the same performance characteristics as the thing being sliced. So if I slice an array, I expect the slice to be a fast O(1). If I slice a `VecDeque`, I also expect a fast O(1), even though it won't necessarily be contiguous in memory. And if I slice a rope (as in Ropey) I expect the same O(log n) as the rope. I think that's fairly reasonable? Of course, none of these things are enforceable by a trait, so at best this expectation would be well documented and then it's up to library authors to adhere to it (or not). But that's true of all operator overloading.
Source is here: https://github.com/evanandrewrose/cargo-vis I have some cleanup to do, but it's not too gross.
a) let me do you one better: pub fn seek&lt;I, E, F&gt;(iter: I, lookup: F) -&gt; Option&lt;E&gt; where I: IntoIterator&lt;Item = E&gt;, F: Fn(&amp;E) -&gt; bool, { for elt in iter { if lookup(&amp;elt) { return Some(elt); } } None } b) I have a weird habit of naming lifetimes to match the parameter they govern, if applicable; personal quirk c) yeah, you're missing the fact that I'm a dummy when I try to program at 4 a m The string that wasn't printing properly was ... uh ... was not the one whose format parameter I had set to be the Debug version. An ordinary, escape-less, string was getting debug-printed and not displaying any change.
For sending from the stido thread to a future I would definitely use a futures channel so that you can compose other futures with it, however for sending from a future to the thread it may be simpler to use a regular channel (otherwise I think you may need to have another executor).
Hello dear competitor. I've found a few mistakes in the vorbis spec. You can have a look here, maybe it is helpful: https://gist.github.com/est31/bf09db5288978591822a968cd0626b34
Oh I didn't realize; I haven't been able to find much information on this. Do you know where I might find more info?
This is really cool and useful! Does it differentiate between two separate versions of the same crate? It would also be cool without the spinning physics. I tried typing "cargo", and the physics make the graph spin around its center forever, which is annoying.
Any good example queries? Everything I’ve tried in the search field results in a single dot.
Do'h! I forgot the most important part...
That said, it's still starting at a disadvantage when it comes to SEO and page load times... both of which have been a hassle for me.
If you're not trying to build a binary you can use the cargo check command.
Thanks for trying it out. Right now it grabs the latest version of the crate, but I have a todo in there to let users select the version. I just updated it to prevent the spinning nonsense. I agree, that was annoying. :)
Or it could do the cutesy `IntoIterator` trick of (stable Rust): trait Index&lt;'a, T&gt; { type Output; fn index(&amp;'a self, index: T) -&gt; Self::Output; } I'm not sure this actually solves any problems, but I think it is a cute pattern and like to share.
I'm not sure what is causing your rebuilds, especially if you aren't tweaking the things that get rebuilt, but one thing that has shown up for me before was with the `skeptic` project, where it would add/remove files especially around `build.rs`, which essentially taints the whole build process. It resulted in full rebuilds for each edit, and .. well it got commented out for now.
My favorite modern take on the idea of a REPL is the Swift “playground” document in Xcode, and the associated directory layout that allows ont to package assets and support code. They’re great for REPL experiments, but they scale to shareable interactive tutorials and documentation — the current far end of that spectrum includes the Playgrounds app on the iPad. The basic interactive document in Xcode, however, is what I’d like to see in the Rust world, with a traditional REPL as a nice consolation prize.
I wonder what makes servo so fat and why the linux build (244 MB) is so much fatter than the windows build (59 MB).
This isn't directly related to Rust, but crates.io and the npm registry share the same purpose, so it's still relevant to see how it was handled. An interesting snippet is: &gt; Unfortunately, the process was complicated by well-meaning members of the npm community who believed that a malicious actor or security breach was to blame and independently attempted to publish their own replacements for these packages. Ensuring the integrity of the affected packages required additional steps and time. This is somewhat similar to the `left-pad` incident, where a user removed his packages and broke the entire ecosystem.
I see, `Err(err) =&gt; return Err(::std::convert::From::from(err))` so in theory even if I don't implement `std::error::Error` but if I provide a implementation of `From` for `Error` then it should suffice, correct? (although I doubt that would fit best practices...) I think I will also read the first edition of the book in full! (only finished the second edition). Now it all makes a lot more sense! Thanks! PS: I really like Rust so far!
Not sure how relevant this is to Rust, but I will point out this statement: &gt; We don’t discuss all of our security processes and technologies in specific detail for what should be obvious reasons Umm. Unequivocally, this practice is wrong. If your system is any less secure when malicious actors know your processes, it isn't secure. When it comes to security through obscurity, I do not tread lightly. So, please, explain what these "obvious" reasons are... and I hope that they do not rhyme with obscurity.
&gt; why the linux build (244 MB) is so much fatter than the windows build (59 MB). This might be due to https://github.com/rust-lang/rust/issues/46034
Maybe symbols? The debugging symbols are on Windows symbols are usually stored in separate `.pdb` files, while on Unix platforms they tend to be stored in the executable. But I don't know if Servo gets built with `debug-info` enabled.
&gt; Not sure how relevant this submission is to Rust, but I have to call out this statement: I believe the `left-pad` incident was discussed here previously. It's still relevant, I think, for the reason I mentioned in my other comment. &gt; Umm. Unequivocally, this practice is wrong. It depends. Google doesn't discuss their spam detection algorithms, for example, and many other companies take a similar approach. "Security by obscurity" is still a valid technique, at least when it's supplementing others. It's a form of "defense in depth".
I can't really find [any PRs](https://github.com/rust-lang/rust/pulls?utf8=%E2%9C%93&amp;q=is%3Apr+clippy) that match this, though that might as well be me not quite knowing what to look for. I can see that clippy's [toolstate is tested](https://github.com/rust-lang/rust/pull/46554) along with RLS, etc., but I'm not sure that says anything about it being included in a release.
I wasn't able to build it because I don't have `pulse` on my gentoo.
Very cool, but I would like to see this the other way around actually. I would like to have an easy overview of what packages use a specific package (especially my own ones). 
Spam detection is less about security and more about convenience. https://en.wikipedia.org/wiki/Security_through_obscurity &gt; Security experts have rejected this view as far back as 1851, and advise that obscurity should never be the only security mechanism. This is not just my opinion, it is a widely held belief among people who know security, as seen in this quote. In my opinion, it is actively negative towards the security of a system. No outside experts can point out the flaws in your design, so unless you feel absolute confidence (as a company like google who employees hundreds of thousands of security engineers might feel) in your design, this is a broken approach.
&gt; google has talked about their algorithms for fighting spam That doesn't really go into detail, unfortunately. &gt; obscurity should never be the only security mechanism I think we're saying the same thing: " is still a valid technique, at least when it's supplementing others" :).
Sounds like something else (your IDE/editor?) is building the project in the background (thus the lock), in a way that makes the build artifacts incompatible. One obvious way would be that it uses a different toolchain version...
nope, I still disagree, because the layers underneath are actively reduced in quality by obscurity. If you create a great system in the open, let people make comments, and then hide it, I have few qualms with that, since the attacker would have to assume you made changes, even if you didn't, but without having hundreds of people study your system in detail, hiding the spec is premature, as it will be broken, almost certainly. But, I've stated my piece, and I'm going to leave it at this. You can search around, if you want, and you will see clearly that security through obscurity is not security. Any system can be properly secured in full public view.
That's a cool solution :) Thank! Do you also have a way to do it the other way around (u8 -&gt; u16)?
That would be awesome. I'll look into it for sure, thanks for checking it out!
Not sure about this but there could exist `ATCIndex` trait implemented for everything that implements `Index` trait and then indexing could simply use `ATCIndex` trait.
1. Spam detection is still not related to security. 2. Having the process being used does not mean that you have their datasets. Spam detection often relies on a secret corpus of samples that are known to be spam. Even with a detailed whitepaper, you wouldn't know what their system classifies as spam, since that classification is a purely human decision. The whitepaper would just explain the transformation from human-selected samples to a general algorithm that can be applied to find similarly spammy items and discard them. 3. I don't know why I'm continuing to respond when I decided to stop. 4. Lists are fun. 5. I could give you the exact set of algorithms used to sign and publish a Debian package. It doesn't mean your published package will suddenly be accepted either by the package mirrors or by client Debian machines, who will reject the signature on the package. Notice, the system is still secure from malicious update servers, even though the process is not a secret.
Thanks. My project is only a parser for OGG. The part about playing vorbis is just as a proof that the parser works. If I would do a vorbis decoder I would use fixed_point, so like a port of Tremor to Rust. 
`impl From&lt;MyError&gt; for Box&lt;Error&gt;` ought to work. You'll just need to be aware that trying to do this kind of conversion generically might run afoul of the orphan rules and you won't be able to write such a `From`.
I used lex+yacc for some projects before. For using nom (and parser combinators in general) you need to think different. To get a feeling on how to use nom look at the example parsers [here](https://github.com/Geal/nom/issues/14). I found the parser for [gzip](https://github.com/nharward/nom-gzip) and [gif](https://github.com/Geal/gif.rs) useful.
Whoa, I haven't used taskwarrior in ages. Maybe I should go back and start using it again. Thanks for the links.
I do not trust the crates.io devs to have the site be immune to hacking and I do not trust my browser's sandbox to be flawless. I have to accept that I'm being forced to use javascript. At best I recognize that the likelihood of such an attack is low but low chance * many occurences can still result in a moderate to high risk.
Cool! Reverse dependency information is available on crates.io btw, in case you didn't know: https://crates.io/crates/libc/reverse_dependencies, just not in such a nice visualization. 
I experience something similar, but, in my case, it's that building on `stable` invalidates the `nightly` build artifacts clippy uses and vice-versa.
This is my tiny contribution to the #Rust2018 hashtag. I sure hope some of you agree with me on this :) ^Thanks^shepmaster^for^proof-reading^♥
This happened to me with Vim + a plugin that runs `cargo check` and the RLS in the background. I was trying to build rust-clippy with rust nightly and the vim plugin ran `cargo check` with rust stable, creating incompatible crates, etc.
Juniper is not actually a server, but has companion crates for integration with two web frameworks: https://rocket.rs/ and https://github.com/iron/iron. So hosting regular http endpoints along with Juniper is really easy. Websockets / subscriptions are more complicated. I have a rough idea for subscription support, but don't hold your breath. I don't know much about the existing websocket libraries out there, but your best bet would probably checking out https://github.com/cyderize/rust-websocket/blob/master/examples/hyper.rs. So your setup would be: Hyper for regular requests, rust-websocket for WS + Juniper. There is no ready-made integration for Hypter + Juniper yet, but it would not be hard to write. We already have an issue here: https://github.com/graphql-rust/juniper/issues/119
&gt; These two terms clearly mean substantially different things, one is a concrete attribute of a piece of data, the other is a compile-time constraint used to verify safety. Funny you put it this way, because lifetimes don't actually live in the final compiled program. They're _both_ compile-time constraints.
This does seem pretty good! I would do a few things differently, but that would mostly be more general/generic statements. It should be possible to: impl&lt;T&gt; RPackIO for T where T: Read + Write + Seek {} and: impl&lt;T&gt; From&lt;T&gt; for RPackFile where T: RPackIO { fn from(x: CustomIOType) -&gt; Self { RPackFile { inner: Box::new(x) } } }
Ah yes, this makes it actually a bit more clearer. Thanks a lot!
Really cool, thanks for doing this!
but there is actually one problem with the generic trait implementation for the From trait. It conflicts because RPackFile itself implements RPackIO
I suppose the sentence is unclear in that respect. The distinction is that one is a property of data, and the other is a constraint on functions, types, and traits. I'll edit the sentence.
I have to say I agree with this a lot. A lot of progress was made in 2017, but quite a few of the goals aren't quite there yet. I think some time to polish and really get things bob on could be great. In particular, the IDE experience still feels a bit hit and miss. Granted, the last time I checked RLS was at the start of December but code completion wasn't great for me. On compiler performance obviously incremental compilation has been a big help (it improved my compile times a lot). I do remember at the start of 2017 there were some posts about the compiler getting slower as new things were added in nightly. I'm sure this has been thought about but it's important that there isn't a massive step forward and then a gradual regression back. 
probably wrong subreddit - go to [/r/playrust](https://www.reddit.com/r/playrust/)
Having all that stuff land in 2018 would be anything but boring.👌
You should put it up on crates.io! Easier to `cargo install` that way.
I thought this was going to be about unsafe code guidelines because of the blog title.
When you iterate over the `PackagId`'s in a `PackageSet` you should also be able to access its `name()`.
Great post! I agree with almost everything on this list! I had two questions though: &gt; [..] Clippy should see a 1.0 release [..] I thought the idea was Clippy would *never* hit a 1.0 release? Unlike some more user facing tools, I don't see what issues would be solved by clippy reaching 1.0 (short of perception, which is important too!) unless I'm totally misunderstanding...which is also possible :) &gt; rustup/cargo integration I very, very much agree with the reasoning behind this but it sounds like a *massive* undertaking! I would worry the juice may not be worth the squeeze. And if it was, I'd see equal benefit and probably an easier time) to incorporating rustfmt too.
That seems pretty reasonable. Personally I'd prefer to panic on an odd length input, since it saves some complexity and it's probably a bug in the caller anyway.
Sorry, Suspect Semantics is the title of the blog, which I forgot to remove before submitting.
All of them are being worked on but just thought I would share my views .
did you compile it with `--release`?
Great to see [Xargo](https://github.com/japaric/xargo) mentioned! Rust is potentially a revolution for those of use seeking an escape from C/C++ in the embedded space (ARM cortex M bare metal programs etc) but there doesn't seem to be a lot of discussion about it. The work done by u/japaric and others has been amazing to follow but it hard to tell what priority that particular application is for the core Rust team.
I very much agree with this. I think we don't need more features but we need currently accepted/worked bits to stabilize. Compilation speed, IDEs are going to be very important. The other important thing to not do is add too many features into the lang, Rust is already awesome.
Still extremely useful! Thanks for your post, it's great :)
&gt; some better syntax for functions which return Results First I've heard of such a thing, is there anywhere else I can read about this?
Thanks for the responses. Basically, if I assign to `_window` then it is guaranteed that _window is dropped at the end of the scope, and no earlier, right?
There was an RFC with some discussion that got closed/postponed. I can't seem to find it right now though, sorry.
I'm generally terrible at offering broad suggestions for my tools, so instead i'm just listing out what i want to work on myself: slick docs, and slick libraries. The hope is, i/we can use these to entice more people into using rust. `:D`
Agreed. Also, I like that debugging is it's own complete bullet. If Rust is built with LLVM, does LLDB "just work?"
* https://github.com/rust-lang/rfcs/pull/2107 * https://github.com/rust-lang/rfcs/pull/2120
This is the blog post I wanted to write, but didn't have the words for. You get my "vote". ([and this is why](https://github.com/rust-lang/rust/issues?page=1&amp;q=is%3Aopen+is%3Aissue+label%3AB-RFC-approved+-label%3AB-RFC-implemented&amp;utf8=%E2%9C%93))
I don't know why everything *has* to suck at *something*. Rust is an amazingly well-balanced language. You say you've *heard* of Rocket, but have you [seen it?](https://rocket.rs/) 13 lines of code to get to a minimal, working web app. Rust can be used to write [operating systems](https://www.redox-os.org/), it can be used with Rocket, it can be used to develop [client-side web apps](https://users.rust-lang.org/t/yew-a-framework-for-client-side-web-apps/14597) in an Elm/React-like Rust framework. Rust is the only language that is competitive with C and C++ in performance on [the Benchmarks Game](https://benchmarksgame.alioth.debian.org/u64q/which-programs-are-fastest.html), but it doesn't let you shoot yourself in the foot with segfaults, dangling pointers, etc. and it has high-level concepts like Algebraic Sum Types, hygienic macros, and so much more. Rust doesn't have explicit SIMD support yet (coming soon™), and the stable releases of Rust do not properly support microcontrollers yet, but that's likely going to be a focus of 2018. Beyond that, no, I really don't know what Rust should NOT be used for. It's an *incredible* language, but it does have a steep learning curve because of the ownership and the borrow checker.
For FLAC, the claxon crate can extract metadata. And for Ogg/vorbis, my lewton is able to. Both libraries are mainly decoders, but at least my lewton crate can read metadata without doing any decoding at all. For opus, it shouldn't be really hard either. Funnily all these three formats basically use the same standard.
Another project to look into on the Rust side is the Xi editor by /u/raphlinus
I don't understand why some of those tests don't produce a bar on the bar chart. On my machine, neither Elm nor Mithril produce a bar on the chart, and the results are not sorted by duration. Plus... &gt; Best time in milliseconds over 1 run (lower is better) 1 run isn't that great. Is there a way to do it over 10 runs or a 100 runs?
&gt; cargo/rustup integration - there is no reason for these to be separate programs and it increases friction for new programmers. Although it is a relatively minor thing, I think it has a big impact. So much this. As beginner I was astonished to find out that there are two tools I have to interact with. From a later p.o.v. it's not a big deal, but when learning language, the purpose of those two utils was not that clear.
&gt; There are a lot of benefits I don't go into in the blog post, so I think it's more than just the initial friction. Aren't these 2 tools too conceptually different to be combined into one, or: What are the benefits?
&gt; We just need criterion-rs to become WASM compatible! :) Well, there's an idea. I don't actually know much about WASM - what's currently preventing Criterion.rs from being WASM-compatible?
I'm not actually sure. It might already be! I just assumed that since WASM has almost no API surface at all, it wouldn't have any high-precision timers available, which would complicate things.
Unlike the other #Rust2018 posts, I like that this one emphasizes that 2017 Roadmap items aren't done yet, that we should Finish stuff.
I very like the idea of integrating xargo into cargo
both gdb and lldb sort of work (but they didn't just work, it took quite a lot of doing), but getting from 'sort of work' to 'work really well' so that debugging is a good experience is really hard
&gt; EDIT: and down voting someone who responds to **you**. Classy. Do you just assume that's the OP? Because it wasn't. Anyways, yeah, I remember seeing some snippets like that in the past. For a language to be good at the vast majority of things sounded like it could be too good to be true. C and C++ have the reputation of being verbose, error prone, and dangerous. Even highly knowledgeable people will have conflicting views but I thought it was possible that Rust's lower level-ness could make it not a great idea for web development. I was kind of just hoping people wouldn't use something like Rocket just to be hip. 
Awesome! Two quick questions though: 1.) Are the percentages of deps only and not the entire binary? i.e. on some test binaries, the binaries themselves are ~30mb, but `cargo-bloat` says 100% is ~2mb. 2.) I'm not seeing all deps either, even with LTO turned off. I guess it's possible some deps aren't used at all, but some of the ones I'm seeing missing are critical to operation of the binary so I'm curious how they're being accounted for.
not really, one installs and updates rust programs and libraries and the other does the same thing. They both do a lot of other stuff too (especially Cargo). benefits are just having a single command line tool, better tool discoverabilty and user flow, easier workflows, easier to maintain
I have now removed that comment. I made that assumption because the downvote occured within a minute of posting the comment, and rarely does anyone but OP act that fast. Rocket isn't production grade yet, so I personally avoid it, but I eagerly await the day that it's ready. Getting the performance boost from Rust would theoretically mean a single server can handle more load, but the expressiveness of the type system means having more robust web apps with fewer tests that test boring things. In Ruby and Python, it's common to write tests that check how a function handles inputs of a wrong or unexpected type, but those tests come for "free" with static types. I know a lot of Ruby developers, and that's fine. I just really enjoy how Rust allows me to define my solution so precisely, performs well, and maintains safety. Rust isn't for everyone. But, this doesn't make Rust bad for these tasks, it just means different people are looking for different things.
Rust should not be used for an intro programming course. I think it could work as a second language in an Operating Systems or Algorithms course just fine though :)
&gt; Rust should have a lifetime visualizer. I think this could be cool. RLS could provide Spans for lifetimes which could be highlighted by the editor. Might be hard to do across function boundaries? 
&gt; Funny Things That specific issue looks to be fixed by this pr: [#47167](https://github.com/rust-lang/rust/pull/47167). More broadly, though, I would like a concerted effort to clear out these smaller issues.
Wow! I was not expecting that speed given all I had heard about JS interop in WASM being slow. I suppose most of the time in this benchmark is just parsing the big JS frameworks that are used. Yew wins here due to its simple feature set, AOT dead code elimination, and (perhaps) fast WASM parsing.
Yeah, here are the reasons why I am choosing to use ash instead of vulkano: * ash is very very lightweight, so it's easy to see the one-to-one correspondence between it and Vulkan, especially when following tutorials made with C-ish in mind * ash is used underneath by gfx-rs to interface with Vulkan, and eventually I want to move on to making gfx-hal/gfx-rs tutorials, which I think is a win for "convergence"/"cooperation" * vulkano has the cool idea of building a safe Rust wrapper around Vulkan, but in the process it's much harder to actually understand what's going on under the hood for a newcomer: I found the guide to not be illuminating, and I found some of the design docs on github to be way above my level---I hope to come back to it one day, when I understand Vulkan design and safety issues better 
This is wonderful! I'd love to be able to paste in my toml and see my dependency tree. 
The only reason Clippy hasn't 1.0 yet is that it's not distributed with rustfmt. Once it is, well do a quick audit and a 1.0 release. Rustfmt is already in rustup on nightly.
Trying to use Rust as an embedded scripting language would be a disaster.
Also you may just need to manually install the latest drivers. I had the same problem and that fixed it for me
[My entry](https://i.imgur.com/9WgKrMO.png)
I'm working on a C/C++ debugger using the LLDB API and Qt. I wonder what it will take to get it working nicely with Rust as well.
In addition to crates.io, please also tag releases :)
Yeah, I don’t call out the issue in the post, but I did see it. This is just something I found recently that I thought was interesting and kinda funny in its longevity.
As the comments point out, removing those timers does nothing to stop those attacks, considering those attacks were designed to handle such countermeasures from the get go. At best, it just slows the attack down, which is better than nothing, but not by much.
&gt;rust-crypto is an abandoned project, that leaves ring and openssl. Shameless plug: take a look at [RustCrypto](https://github.com/RustCrypto), it aims to be a modular successor of `rust-crypto` and inherits significant amounts of code from it. It's still pretty much work in progress and haven't yet achieved feature-parity with the `rust-crypto` (although it has a fair bit of algorithms not represented in the `rust-crypto`), but we'll try to make a good progress on it in 2018. And I really hope to see const-generics sometime in 2018, which will allow us to drop `generic-array` and `typenum` from dependencies.
Please keep Linux distributions in mind. Archlinux currently ships a rust package that contains stable rust and cargo, and a rustup package that ships just rustup and uses sideloading to fetch rustc and cargo. This is important as sideloading is generally discouraged (other rust packages are built with the regular rust package) and Debian would probably have to do some heavy patching since it violates policy. This change might also cause problems on platforms that ship rust on their own, but are not supported by rustup, like OpenBSD or alpine. There are even more problems down that road, like reproducible builds failing because buildinfo only records the rust package version, which, due to sideloading, might resolve to a different rustc version in the future.
I don't know of any realistic examples of a domain where Rust would be excluded merely because it's Rust. It was created to be a safe language that's also low overhead. One thing I miss from Python is the ability to experiment very quickly. I have become very accustomed to the Jupyter Notebook workflow. Some trivial examples do come to mind though: - a deployment platform without an LLVM backend - inside an org that doesn't permit it 
I think you're looking for /r/playrust
Also, I should point out that thanks to cargo-bloat I ffinally look at some quick wins to de-bloat clap without losing any functionality (i.e. just logic refactoring and removing duplicates). I'm in the process of putting together a PR that shows nearly a 60% decrease! This should come out shortly in 2.29.1 for those interested. So big thanks to /u/razrfalcon for this tool!
Situations where a repl excels. Like exploring a dataset. I use python/pandas then. 
How do I post my server on there?
Where was I addressing design patterns? I dislike communities that treat their new language as profound when in fact it does most of the same things statically typed languages have done for decades. Static typing and static analysis are nothing new. Even C and C++ can be analyzed for lifetime safety. While it's not as robust as Rust's is, it exists and isn't _new_. Compilers have stopped you from making mistakes for a long time. Next time you use clang, add the flags `-Wextra -Wall -Werror -pedantic -Rpass=loop-vectorize -Rpass-missed=loop-vectorize -Rpass-analysis=loop-vectorize` and you'll see just a _very small_ slice of diagnostic information you can get out of a compiler.
Who's fault is that. Not the arch user's fault, not me.
Implicit Ok(()) would be very very nice
I pushed for WASM in my 2018 perspective that was linked in the call for blog posts but I also mentioned continuing on with current goals. A lot of stuff was unfinished or designed but never started. No reason to throw all that work away since it's a new year.
You need it to be a String. Call serde_json's serialize method on the value to turn it into a json formatted string that gets sent out and that should solve your problem. :) Hyper doesn't know what a Value is, but it does know what do with strings.
Using vscode with visual studio "sort of works". I'd much rather have what's there than nothing, but there's some hiccups like it not really understanding match patterns and if let patterns, and so whenever you step through code with either, you get it jumping around like it's stepping through optimized code.
a sandbox which run code from outside.
Hyper does not include a router. You may want to look at one of the web frameworks (rocket, iron, nickel, gotham, etc) for examples of this. Hyper will parse the actual URL though. You can do request.uri() or response.uri() to get the URI and then use that to get whatever part of the URI that you want. Example: response.uri().query()
I don't know - I just know that this subreddit is for rust the programming language. I've never played Rust the video game.
Gotta say I still disagree there, even though I spent my weekend writing a whole lot of functions that have a final `Ok(())` or similar I'm willing to accept that Result and Option are semantically more than mere enums at this point but I'm still very leery of increasing their levels of magic MAYBE I could see an argument for implicit returns of the default value when the return type is`Default`, but Result is not.
I'm not asking about web frameworks, I'm asking about hyper
`rustup` is higher up though: it installs _rust versions_ and associated build tools like `cargo`. I don't see `cargo` doing this at all, it just manages dependencies for projects. Sure, there's `cargo install`, but even that is geared at a quick way to build a project without cloning it in git. I guess both "install stuff", but that's all they seem to have in common. I'm _glad_ rustup is separated from rustc and cargo the way it is because this way it can manage multiple versions of things and keep working if all rustc and cargo are uninstalled. If by combine, you mean move `cargo install` to rustup, that's something I could get behind. But, in any case, I don't want my rustc-version-dependent package manager to also be my rustc version manager.
That's a common problem. If something is missing you'll have to build it or wait for someone that does. And learning takes some time. You'll have to decide for yourself.
Taking the fastest (minimum) rather than the median or mean is actually fairly common practice when running benchmarks - for example, it's the default for Python's `timeit` module. Here's a [good analysis of the reasons why this approach is often better](http://blog.kevmod.com/2016/06/benchmarking-minimum-vs-average/).
As a beginner, did you have to do much with `rustup`? Maybe it's changed, but when I started rustup was really just a tool to do the 'install everything' step, then I just used cargo.
Wow, I haven't yet got to doing any performance tuning in [stdweb](https://github.com/koute/stdweb) (which Yew uses to interop with the DOM) at all, and yet we're already this fast?!
Right, confusion like this will tend to happen in a language when there are monad-like things, and where these things can have `bind` in both sugared (`let y = f(x?); ...`) and non-sugared (`x.and_then(f).and_then(|y| { ... })`) forms but without any explicit connection between the forms. And where there are `for`-loops mixed in with the sugared binds, making it more convenient to write for x in xs { do_something(x)?; } Ok(()) than, (uhh...?) // xs.flat_map(do_something).map(drop) // nope, this eats Errs for breakfast and keeps going ... xs.fold(Ok(()), |_, x| do_something(x)) ... that? (Wow, is that *really* how to implement `mapM_ do_something xs`?)
I didn’t see any full page reloads when I was testing it, although it’s conceivable that the implementations were being loaded into fresh iframes.
At the least, having a proper statistical distribution with box and whiskers is better than minimum. Having the minimum is better than nothing, but I specifically called out the median because averages often influenced by outliers significantly. The median better represents what performance should be expected, in my opinion, although I have heard [arguments for the geometric mean](http://ece.uprm.edu/~nayda/Courses/Icom5047F06/Papers/paper4.pdf). The minimum could be a massive outlier, and I don’t remotely trust it, but with a box and whiskers plot you’d still see it. I’m just a flawed human, of course, but those are my thoughts.
Please fix RLSs autocomplete. It’s really bad right now. 
I've used rust in the past, it's just been a few years. Frankly, the borrow checker is fine. I don't particularly like the rigidity and it prevents me from making a bunch of performance shortcuts that would otherwise be fine in C. I'm not underestimating anything, and the "contrarian" text at the top level is a great example of gatekeeping and zeal.
The nice thing about Cargo managing rustc installs is that it could potentially use forked/pinned/pink or nightly compilers for parts of projects.
Yeah Linux distros are a big issue. While their model has advantages, it does not really fit with the more modern rapid release model of software development. I suspect we'll end up with a situation where if you want to use regular Rust you have to use Rustup, and if you want to use distro packages, you have to use some kind of LTS release (as a long-time Linux user, I am both saddened and amused by the irony of Linux users ending up in the same boat as enterprise developers) 
It probably has something to do with this issue. https://github.com/SergioBenitez/Rocket/issues/209
I guess he meant that hyper (a low level web framework) don't have this function.
Rust is getting there but not there yet. If you like some of the features of Rust which you cannot find in a language like Go, you can take look at Scala and Akka library. Since Scala runs on JVM and interoperable with Java (Kind of), even if you cannot find a Scala library for that, definitely there is one for Java which you can use.
[removed]
I wouldn't want to use Rust as a replacement for Perl. Or sed, awk, or for that matter 99% of shell scripting. I mean I see no reason not to write the interpreters in Rust, but I wouldn't want to even consider using the syntax of Rust in any of those contexts. I wouldn't want to use Rust anywhere Erlang does its business... safe doesn't mean resilient. I wouldn't want to use Rust in live interaction with large datasets, ie Jupyter Notebooks and REPL in general. Again, writing Jupyter in it? Maybe. But not using it as the language syntax that does the manipulation. Additionally, I think Rust would do a piss poor job of replacing HTML.
I think this is mostly hampered by compilation time, not by the lack of a REPL.
1. The percentages are relative to .text section size (in ELF at least). 2. You can pass `-n 0` to see all. But it's not obvious.
Every contribution is worth it! I do like the idea of new avatars, contributed by the community.
I found the problem. I had set CARGO_HOME to ~/.cargo which was interpreted by rustup as /home/myusername/~/.cargo which is obviously wrong. That prevented rustup from updating itself. After setting the variable to /home/myusername/.cargo everything was fine. I guess it was something to do with a mismatch between rustup and rustc or something.
Just started learning rust and I was wondering if someone could explain the difference between the println and format macros to me?
`format!` essentially prints into a `String`, then returns it. `println!` prints to standard output instead and also appends a newline.
Ahh that makes sense, thanks!
There are tools for the benchmarks (I think it's called dnsperf). As for the pre-rendered, I was just describing the whole-message cache. Assuming you don't do fancy things like views/split-horizon DNS, the only thing you have to really worry about is invalidation if the zone changes. The idea is to save both on rendering and expensive tree lookups by hashing the query params.
&gt; Should I stop projecting so much human behavior into computer programs? https://media.ccc.de/v/34c3-9296-why_do_we_anthropomorphize_computers 
From the first discussion, this is the main reason why I think the implicit return would be problematic: fn foo() -&gt; Result&lt;(), u32&gt; { if everything_is_awesome() { Ok(()) } else { Err(911); // the semicolon means this returns Ok } } 
I find Rust great here. I can prototype a quick naive solution in it, integrated testing and benchmarking makes it trivial to make sure it works and establish a performance baseline. Afterwards I start exploring different algorithms making use of the previously set tests and benchmarks to verify that they are correct and gain insight into how they are performing. Parallelization using e.g. rayon is also trivial to add. In C++ I would spend 90% of my time setting up testing, benchmarking, and debugging segfaults. In Rust those things take zero time, which is great for exploration.
Nice! Many people think size does not matter,. But if rust is ever going to have a chance in the semi embedded Linux IOT world size, people need to make the size come down a lot.
FYI: People use nginx for more than just routing, managing network connections is a non-trivial task that many people choose to have done by a dedicated servers. Thus its popularity.
I know. I get that. That's not the problem. The problem is that, if my application is going to run on a PaaS setup like Heroku, I don't get any control over that. Literally what I get is an environment variable called `PORT` that I am required to listen on, and *all* HTTP Networking must be done on that one port. The PaaS host then managed all of the networking - potentially using Nginx or something like that, but I suspect using something a bit more heavyweight. This means that, if I want to develop a Rust application that does both traditional HTTP *and* Websockets, **and** I want to run it on something like Heroku, I've got to be able to do both of those things on the same port from within my application. I've got to be able to start up a server listening on exactly one port, and then have Rust understand that some connections are HTTP 1.1 and other connections will be upgraded to Websockets.
Hopefully this isn't too community-y. Here is the jist: &gt; I believe that the Rust programmers should demonstrate that Rust is a better language to write your hot loop code. &gt; ... &gt; How would this work? Well, Python provides a useful case study. Its package manager supports a binary distribution format. That format allows pre-compiled binaries to be downloaded by 3rd parties. The `rust-fst` package can be downloaded by any Python developer, without needing a Rust installation. It's only one example that will hopefully spurs more ideas. 
That sounds like a pretty ideal solution if it can be made to work. I'll have a poke around and see what I can work out :)
&gt; There's no reason that crates.io should require JavaScript for basic usage. Mozilla love them some unnecessary Javascript. :-)
I actually came across Rust back in early 2016 because I was looking for something better (DX wise) than C/C++ for doing embedded dev(which wasn't the main part of my job but something I'd have to touch on once in a while for clients). Later on Xargo became a thing. Pretty exciting stuff and I think Rust can position itself really well in this area. Last I heard there were some good boards available, but parity still wasn't quite there, especially with wireless and bluetooth where japaric could use some help iirc. 
I did use rustup to install, then forgot about it. Later I read something about rustup and was confused, since I already used cargo to do "Rust language stuff".
I disagree. Without a REPL, every time you do some minor change you'll need to run the program from the beginning again, which involves reinitializing the dataset that can be slow at run-time. The advantage of REPL here is maintaining the state, besides skipping the compilation step.
Your application can bind to a single port yeah? Sometimes you have an application split into services and each need their own port to listen to and communicate with, they're not able to bind to the same port because problems right. So what you tend to see is a proxy like nginx will listen to port 80(HTTP) and 443(HTTPS), and all web traffic to your server can go there. Now you can host several web services on different localhost ports like 1337, 3000, 53110, the proxy will redirect to the correct service. These days, you'll often find your service(be it app, database, or thirdparty vendor) utilize containers like Docker offers. Interesting thing here is you can find a really nice Docker container for nginx proxy that makes it so simple to route your incoming traffic for a hostname to a specific container and it'll map the ports for you. So you can have mysite.com, db.mysite.com, blog.mysite.com, api.mysite.com, mysite.com/api, etc. Heroku might not allow that, and this probably isn't the correct sub-reddit for your question as it's more networking specific(and platform/provider specific) than it is to Rust. Your problem is more so that you want to use a platform that imposes restrictions that are problematic for your application. Vultr is quite affordable and a nice cloud host, &lt;$5 a month, sign up and wait a while, you'll get an e-mail offering you a bonus $10 credit when you make your first deposit($10). If that's too much, Amazon offers 1 year free as a new customer on their platform, won't cost you anything. I believe Microsoft Azure has a similar offering(more of a fixed amount of money in a smaller time frame). &gt; The PaaS host then managed all of the networking - potentially using Nginx or something like that, but I suspect using something a bit more heavyweight. nginx is a heavy weight. But yes, they likely have a much more complicated infrastructure to provide their PaaS and keep customers happy at the scale they run at. nginx or HAProxy are very common for what they do best though.
&gt; ... that? No, it is easier. xs.map(do_something).collect::&lt;Result&lt;_, _&gt;&gt;() (depending on context you might not need the turbofish, or you might have to fill in one or both of the `_`s)
So, in any other language this wouldn't be a problem. I've managed to quite successfully write applications that have a single HTTP server on a single port that will service both HTTP/1.1 and Websocket connections - since the Websocket spec is deliberately designed to be able to co-operate on the same HTTP port as other services - in Node, Java and Go. And I know you can do it in many other languages as well. That's why I see this as being a Rust issue - because it's down to the Rust language and library support as to why I can't achieve this. It looks - from /u/the___duke's answer - that it probably would be possible to get Juniper to work with Hyper, and Rust-Websockets can already do so, so that means that the problem certainly isn't insurmountable. As such, I wasn't looking for answers to alternative places to host the application, but ways to make the application do what I want, and what I can easily do in a number of other languages. After all, the original intention of this was a learning exercise for picking up Rust.
Is rustls stable as in it should generally work for websites? Using it through [tls-api](https://crates.io/crates/tls-api) on nonblocking sockets usually fails (connection gets closed out of the blue) in my [mio_httpc](https://github.com/SergejJurecko/mio_httpc) while native-tls and openssl work fine.
I don't think so. If the `Result` is explicit in the return type, why should there be an implicit `Ok`? And IMHO even more questionable, why should there be a special case for `()`? 
&gt; That's why I see this as being a Rust issue - because it's down to the Rust language and library support as to why I can't achieve this. Fair enough. I've not tried to do any web stuff with Rust myself. I've used NodeJS plenty in the past but not done anything with Heroku, I've not had a port constraint problem. Is it possible that you for example had a Node process/server/service run that binds to a port, then all HTTP/websockets/graphql goes through that? So the problem might be that you're trying to bind to the port more than once? IIRC Node could skip nginx and perform it's own proxy/routing, although it was generally advisable to go through nginx for best perf. All I know from experience is that you can't have two webservers start that bind to the same port last I recall. Which is why the nginx proxy docker container was so popular(your other containers could bind to port 80 and expose that from the container, then the nginx-proxy container would dynamically manage/route traffic to the correct containers based on hostname. I personally don't feel Rust is at a point that I'd want to use it for web dev atm. It is absolutely fantastic elsewhere I've used it for getting performance that's amazing. Goodluck :)
This is a great idea, thanks for making this. Sorry for going off on a little bit of a side-tangent, but have you thought about the potential security issue where an author of a completely legitimate crate suddenly publishes a patch-level release that builds in a keylogger or takes control of the machine or something similar? I know that's not really what your site tries to prevent, as code reviews could stop this kind of attack obviously. I fear that this might happen some day, probably not on crates.io but on npm. But if it happens to a really high-profile package, such as a dependency that nearly everyone uses, then it's going to be disastrous.
The link seems 404 on mobile.
Most of what you describe primarily becomes significant once you know *what* abstract algorithm you're trying to implement. I'm talking about string-processing heuristics where I have no idea what I'm trying to do beyond a set of inputs and desired outputs. Parallelization, atomics, benchmarking, etc. are all things that only become significant once I actually know what transformations will maximize the code's accuracy at generating the expected outputs from the given inputs.
&gt; I wouldn't want to use Rust as a replacement for Perl. Or sed, awk, or for that matter 99% of shell scripting. Replacing Python (which in turn replaced Perl and shell scripting) is my #1 use for Rust because it's such a hassle to write a comprehensive test suite for something which interacts with the filesystem. 1. Rust makes it easier to minimize the chance that there's some bug lurking in my "shell scripting", just waiting to blow up at the worst possible time. 2. Rust binaries start much more quickly than things written against a heavy runtime (eg. Python), which makes helper commands much more comfortable.
Which is nice. Real nice. Now, on a random machine, without internet access, change the contents of one line in /etc/sudoers with a one-line rust command and no text editor installed. We're a *long* way from Rust being a viable replacement for everything.
So, in Java I would run a single Tomcat (or Jetty, or whatever) inside of which is running my Webapp. This Tomcat is then responsible for all of the HTTP-ness of the connections - including Websockets and everything - and passes control on to my code for individual requests. (Where a request is either a single incoming HTTP request, or the start of a Websocket connection) In Node, I've done similar using Express - where there are multiple HTTP routes and a single route registration for the Weboscket connection. In both cases, it's inside the application that a single web server is started, and that web server routes individual requests to either HTTP handlers or to start a Websocket connection. &gt; I personally don't feel Rust is at a point that I'd want to use it for web dev atm. It is absolutely fantastic elsewhere I've used it for getting performance that's amazing. That's pretty much the feeling I was getting. Which is a shame, since it's so common these days to write services as webapps and interact with them that way. I'm sure it will improve quickly enough though.
Using the example from readme with rustls will crash with connection closed error. cargo run --example get --features "rustls -- "https://edition.cnn.com" Due to using tls-api and general read/write traits the actual cause is buried. It may be that there is something wrong in tls-api and not rustls.
Instead of having distinct characters, how about having their avatars depict Ferris in appropriate postures? Highfive, for example, could show Ferris highfiving with his pincer.
I agree with this. Maybe a year is too short for our roadmap. How about we align the roadmaps with the Epochs?
Nice blog, and thanks for providing links to the RFCs. Btw you spelled "Summary" wrong towards the end. 
Most of my programming experience has been in C#, though I do have some small experience with assembly and C++ (Arduino-related, not much, and not using most of the modern features). In my opinion, despite Rust aiming at the same low level as C/C++, writing Rust feels more like writing C#. When writing Rust, like when writing C#, I don't have that nagging feeling that I might be writing a foot-gun without realising it, to the extent that I was comfortable poking at a part of Rustdoc without feeling like I needed complete understanding of the program.
I did not mean you any discourtesy. Also downvoting is not supposed to be used for disagreement. There are known stumbling blocks for programmers switching to Rust, which even very experienced programmers often face. So it seems only fair to warn people who seem likely not to already have passed those obstacles, or who seem to have unrealistic expectations of how long it would take them to adjust from some other low-level language. If you already have Rust experience, then obviously that does not apply to you.
Uh, uh! Rfcbot could be Ferris with a pen, maybe ready to sign some document :D
My point in that retort was more would you rather sit there and rewrite sed in Rust, with a full test suite, or use the sed you've got, when the job at hand is updating a single file? My actual point in the post you were responding to is that Rust's syntax is not well designed for, say, describing terse regular expression substitutions, nor does it provide a good REPL interface for data interrogation... aka it's not a DSL, it's not a good scripting language generally, and it's not going to replace DSLs or scripting languages in their domain. It's a *great* systems programming language, and if the ecosystem gets large enough it'll be a great general programming language, but it doesn't need to try to take territory in areas it's not well suited to, and a heck of a lot of real world *and also necessary and valuable* interactions with computers do not need or particularly benefit from its core strengths. The OP asked where Rust won't be used, and that's all I attempted to answer. The fact that you do use it for some larger systems that you've got time and need to test heavily is great... but that's not the main use case for a shell scripting language, is it?
[removed]
Hey dude I see you're posting a lot on the Reddit. You may get faster and better answers if you ask the relevant irc channels, or post less frequently.
Completely agree on the lifetimes/lifetime variables point. This area already causes a lot of confusion, imprecision of language doesn't help.
I'll post more frequently
Ah, were you reading [this article](https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5) lately too? :-)
&gt; `rust-crypto` versus `RustCrypto` Hm, are we really at that stage of the name collision problem already? (obviously it was going to happen eventually)
I think you've got that backwards, it only works on nightly. But I'm sure that will get fixed soon and then it can be used for normal development.
I love the idea! I tried to login with Github but now it telse me `Couldn't create user: Username contains invalid characters`. Feature request a Audit `Consider alternative ...` response, for packages that are fine but abandoned, superseded, deprecated, renamed, or generally replaced. For example, Top wanted crate is `advapi32-sys:0.2.0` The correct answer is `Safe, but outdated switch to winapi for ongoing support.` Alsowe, does the site use crates.io download statistics in calculating the `wanted` ness of a package, or only data from the cli? 
If this programming gig fails, inventing cute mascots is definitely my plan B. I still need a polished version of [Rebecca the Reference](https://twitter.com/whoisaldeka/status/916337294553968640)!
Continuing work on tests for [`uom`](https://github.com/iliekturtles/uom) (type-safe zero-cost dimensional analysis). I didn't get a lot of time but got a number of tests for non-float types passing. More to go this week.
&gt; Ah right, but if there was a semicolon in the first clause too then I could see this being confusing You'll also get an error about not being able to infer the Ok type. And even if you didn't, you'd get a warning about having an unused result. We already have the facilities for dealing with this problem, and they are not requiring `Ok(())` at the end of functions. &gt; I think in error handling being explicit is better. (This is mostly an artificial example anyway.) If you can demonstrate a problem that `Ok(())` is solving, I'm interested in hearing about it, but sloppy arguments that are factually wrong waste other peoples' time in correcting them.
Here's an example that can be sometimes annoying: * You use `cargo doc` to view the documentation for your crate and its dependencies * You use `rustup doc` to view the standard lib documentation From a UX point of view, it seems like these two things ought to be more unified.
[hyper-rustls](https://github.com/ctz/hyper-rustls) repo has a similar async client example based on tokio+hyper+rustls, your may want to try your failing cases with it. I just tried that locally and this seems to work fine: cargo run --example client https://edition.cnn.com
2018 is going to be the year of clippy on stable. 😎💯👍
No, I hadn't read that. Thanks for sharing, it's a very good, but pretty unsettling, article. And that article was only talking about malicious client-side packages. If you can get your malicious npm package to run on a node.js server, the whole server is compromised.
It's certainly possible to call `sed` from Rust. The question is: 1. How complex are the parts **I'm** writing. (eg. Even if I'm calling `sed`, I generally at *least* use Python so I that bits like the more intuitive string quoting, `try`/`except`/`finally`, the `subprocess` module, etc. result in more intuitive and readily composable building blocks.) 2. What are the risks if I get it wrong? (eg. Locking myself out of `sudo`, destruction of data not yet committed to incremental backup, etc.) 3. How long is this code likely to stick around (eg. Is it something I'll run once or is it process automation that's likely to stick around through months or years of slowly shifting inputs?) In the context of "shell scripting", the part of Rust I value most is the monadic error handling, which helps to ensure I meet a minimum level of reasonable response for unexpected error conditions without it being uncomfortable to do so.
Well Rust isn't perfect at everything. It's really fast at runtime, but that comes at the cost of slower compilation times. Debugging isn't as easy or user-friendly out of the box as some other languages, like JavaScript. So to answer OP's question, if you just want to run a tiny bit of client side code on your personal homepage, Rust+WASM is not the right tool for the job. Just use JavaScript.
I'd be interested to see if you have more success in using [tql](https://github.com/antoyo/tql), my alternative to ORM. Even though the API will change very soon (so it's not stable yet), it might be easier to use than diesel. Be warned though, it's not released yet and it's in alpha-stage. Thank you in advance.
Yes, so in both cases, you had a single process bind to the port. I'm not familiar with how you are setting it up in Rust, but if you're having conflict issue, it's probably because more than one process/program is trying to bind to the port? I would assume hyper or rocket or whatever the equivalent is in Rust atm would take this role, then plugin/extension crates of some kind like a require in nodejs would provide the extra bridging/functionality to use the different protocols on the same port if possible. It might just be that web dev with Rust just isn't quite there yet, async is still being worked on / explored with things like Tokio crate afaik. Rust might be lacking some feature or high level functionality provided by crates to do this for now? I think the situation will improve quite a bit this year. In the meantime, you could still learn Rust. Look into FFI, you can write business logic for a service that would benefit from the lower memory or much better computation speed and safety that Rust can provide while doing more higher level / general parts of your app/service in Node/Java.
I wish SOAP would just die. If Rust can get a good SOAP binding, I might be able to introduce it at work. :)
The beauty of WSDL is that it should be fairly easy to get all the bindings and types automatically, so i definitely wouldn’t consider my SOAP library complete without some kind of binding generator. The main hard part is that WSDLs generated by WCF services also include a lot of “extra” types that mainly refer to .NET’s managed types, or are just redefinitions of types that look built-in. It will be fun to try to “peer through” this extra layer to get clean bindings out of it.
Hey, I was just talking about this recently! :) I think that I'm going to start this today -- if you're interested, I can let you know when the list is started!
As mentioned, no experience with how it's handled in Rust or if it is or isn't possible right now. I'd imagine supporting HTTP and Websockets would be not too uncommon so surely there is a tutorial or docs somewhere about getting that setup if possible. I do remember from when I worked with Node that Websockets used to be it's own package you'd require in, express itself didn't just provide it(maybe it does now?). I know there are some websocket crates, presumably there is one that intergrates with a Rust http server/framework. Had a quick google, there is an example of using hyper with rust-websocket [here](https://github.com/cyderize/rust-websocket/blob/1fab3a438a5f11e97760acddfcfd8c9504094987/examples/hyper.rs), it will upgrade http connection to websocket, but as you can see requires two different ports. Your question was asked about 2 years ago, the example link is from [this reddit discussion](https://www.reddit.com/r/rust/comments/3db6tp/handling_http_and_websockets_on_the_same_server/), you can see that it is suggested to use nginx there too and that the problem(run on a single port) might be (at least at the time) non blocking async support was not available in Rust. I take it you've seen [this issue on Iron](https://github.com/iron/iron/issues/359) which has fairly recent feedback about it being difficult to support currently in Iron. I haven't looked over the code or compared with the other example but there was [a StackOverflow question a few months back](https://stackoverflow.com/questions/45806359/running-websocket-and-http-server-on-the-same-port-rust-hyper) asking how to do the same, rust-websocket apparently has some buried example in their docs. Scratch that last paragraph, [this issue on hyper](https://github.com/hyperium/hyper/issues/1323) links to it and states it was possible to upgrade from HTTP to WS with prior version of hyper that was on sync design, but hyper has since become async and that exampe no longer works? You may want to watch that issue and watch it progress in the meantime? I am guessing that web dev in Rust is still not quite there yet vs competition for the type of projects you want to do.
Here is a macro I use in my projects: macro_rules! json { (body: $body:expr) =&gt; { hyper::Response::new() .with_header(hyper::header::ContentType::json()) .with_body($body) }; (status: $status:tt, body: $body:expr) =&gt; { hyper::Response::new() .with_header(hyper::header::ContentType::json()) .with_status(hyper::StatusCode::$status) .with_body($body) }; } Example usage: _ =&gt; return json!(status: BadRequest, body: r#"{"error":"Request body was not valid UTF-8 data."}"#),
I agree with this pretty strongly. Internationalization in particular is something I'm dealing with right now. I'm writing a program like wc, is unicode-aware, and the options available right now are lacking. `unicode-segmentation` has been great from a "it just works" perspective, but it's very limiting to only be able to use its functionality via iterators. I was thinking about writing a blog post just for this. (I wanted to wait until I had an initial release for my program ready, but I may not by the end of January, and writing the blog post will also take time, so I might just do that first.)
There's also the problem of "any" types, which are just placeholders in WSDL for an un-typed block of XML. I guess these could just be deserialized as `String` / `&amp;str` and have the caller deal with it
I know. It is a cumbersome protocol but I can kinda see why some use it. It can completely describe an interface in a machine-verifiable, type safe manner, something that JSON interfaces struggle to express.
all what that macro does is inserts the content type. 
This is fantastic! I there a way to use this with May?
Rustface is a very straight-forward port of a C++ face detection library, SeetaFace. I'm pleasantly surprised to see that the Rust version *slightly but stably outperforms* the original (by 4-5%).
It builds the `Response` object which you can either return directly or modify as you see fit. Part of this is setting the content type but that is not all the macro does. Compare your code in the OP and my example usage.
Wasn't me, just found it. Give the github project a star if you want to give credit where it's due. 
Personally I'm worried about Rust moving towards a too newcomer-friendly spirit. If things get easier for newcomers, but harder (to read or write) for long-term users (or even just a niche segment of long-term users) I'd love if other avenues were tried first, like more in-depth documentation around a topic, or more detailed error messages. I'm worried in a similar way to /u/est31, because some of the ergonomics proposals didn't just start out as "allow new users to do X" but also "and lets prohibit everyone from doing Y in the future". Best examples to me are the proposals to remove `extern`/`mod` and losing `ref` patterns. I also want to mirror the post's sentiment that I, as someone who's less of a newcomer (jumped in around 0.11 I think), sometimes don't feel listened to, like in the above mentioned discussions. My Rust language discussion energy has basically been used up by those discussions for a while, The experience also diminished my excitement about Rust in the future, which makes me a bit sad.
Here's a talk I gave in October in [Lambda Montreal](https://www.meetup.com/fr-FR/lambda-montreal/events/243365588/). Hope you enjoy!
I mean, if it's supposed to be just plain XML, it could also be deserialized as a generic XML Element type instead of a string, so there's at least *some* kind of structure to it.
But this isn't really responding to my point. My only point is that you can't tell someone that learning something isn't hard, and then just magically expect the problem to go away. Focus on the data the users give you. Start there. Now what?
This is really cool! I'm definitely going to steal the idea and implement the same thing for WebAssembly in my [cargo-web](https://github.com/koute/cargo-web)... (:
Not sure if it's been published before, the youtube publish date is 2018-01-06.
&gt;"understanding code inside large codebases" use case. This is something that I value a lot as well. Even more detailed scenario would be "I need to understand and fix code that I'm unfamiliar with and the person who wrote it is not around anymore, and my ill-informed fixes should not silently introduce other bugs" that happens surprisingly often if you work in a company and not on your own hobby (or non-hobby) project. In this situation any "written explicitly here" is better that "written somewhere else and inferred here", regardless of noise and duplication, that's one of the reasons why I was skeptical about many ergonomic initiatives as well.
Great work! I'd love to look into it &amp; see if we can improve perf further, but my time is lamentbly limited.
You should be able to change the username in the register dialog. I'll respond to rest of your comment later. Thanks! 
The site tracks stats on every version level. So it can warn you of a patchy version that no one reviewed yet. Right now cli is not configurable enough, but generally any policies can be implemented client side depending on paranoia level desired. 
It was published earlier [here](https://www.reddit.com/r/rust/comments/7okp1j/videos_from_rust_belt_rust_2017_now_available/).
Ideally, that's why `Cargo.lock` exists and `cargo update ` isn't automatic. But, realistically, you're right- no one, or at least not everyone, is going to check every dependency's every patch release.
I got the idea from [bloaty](https://github.com/google/bloaty) too =)
Hyper is not a web framework :) It's just an HTTP server/client.
&gt; post less frequently ... &gt; Got it, I'll post more frequently If you disagree with /u/Sinistersnare, you should simply indicate it...instead of responding with sarcasm. Remember the first rule of this community: &gt; We strive to treat others with respect, patience, kindness, and empathy. To the original point: Do you feel like you're getting the answers you need here in the community already? We definitely want to make sure you're getting them -- I'll provide another reply here to see if I can help out. :)
YEW was recently released and has been getting discussion on this subreddit.
It won't, the Rust team made sure it will be full of silly drama unrelated to programming.
This release features a redesigned AST that is more consistent and easier to understand than the previous one, and supports more comfortable idioms for traversing and building the syntax tree. In addition, unlike all past Syn releases which focused on parsing strings of source code as input, this release is built around parsing the Rust compiler's token representation used by 2.0 procedural macros. We provide a polyfill so that code written against the token-based API of tomorrow can work just as well on Rust compilers all the way back to the first stable support for procedural macros in Rust 1.15.0. Whether you have used Syn extensively already or are looking at it for the first time, I encourage you to browse through our brand new examples directory featuring runnable working procedural macros of all sorts. Check out [`heapsize2`] for a 2.0-style custom derive with high quality error messages, [`lazy-static`] for a function-like procedural macro that demonstrates the custom diagnostic API, and [`trace-var`] for a procedural macro attribute that mutates a function body. [`heapsize2`]: https://github.com/dtolnay/syn/tree/master/examples/heapsize2 [`lazy-static`]: https://github.com/dtolnay/syn/tree/master/examples/lazy-static [`trace-var`]: https://github.com/dtolnay/syn/tree/master/examples/trace-var The 0.12 release represents many person-months of design iteration and documentation. Thanks in particular to /u/Mystor for being a force multiplier and shouldering a lot of both the tricky and the tedious implementation work, /u/acrichto for the key idea of polyfilling Macros 2.0 support atop a Macros 1.1 shim and for outstanding rapid prototyping work in the futures-await library, and jseyfried and /u/DroidLogician both for driving all of this procedural macro stuff forward on the compiler side with implementation, insightful discussion, and responsiveness. - [Syn 0.12 documentation on docs.rs](https://docs.rs/syn/0.12/syn/) 
Ah look at that, my bad. Weird that it didn't stick a while longer to the first reddit page.
Yes, WASM really looks promising. I am currently at the process of rewriting an Scala(.js) application - which already shared code between client and server - with the kind help of Rust.
Some assumptions I'm making: * You're asking about how to use [`hyper::Request`](https://docs.rs/hyper/0.11.11/hyper/struct.Request.html) structs? What context are you trying to write code in? * Build on the last assumption, once you extract the URI with [`request.uri()`](https://docs.rs/hyper/0.11.11/hyper/struct.Request.html#method.uri), it seems the method in the `Uri` struct you care about would be [`path()`](https://docs.rs/hyper/0.11.11/hyper/struct.Uri.html#method.path)...which SEEMS to be where you're at. Is that right? Whatever the case, once you have the `Request` in hand, I can see a few options: * Do as you suggest and parse the URI yourself with something like `regex`, splitting on `'/'` and doing whatever other decoding may or may not be necessary for your application. * You could also copy the URL from Hyper and parse it using [Servo's `url` library](https://docs.rs/url/1.6.0/url/struct.Url.html), which has a nice [`path_segments()`](https://docs.rs/url/1.6.0/url/struct.Url.html#method.path_segments) method -- that way, you don't have to reinvent the wheel with parsing...at the cost of copying your URL string. I'd probably do this first and then roll my own code if there was a legitimate bottleneck.
I'm almost done with my [WireGuard plugin for NetworkManager](https://github.com/manuels/wg-p2p-nm-plugin)!
nice!
There are some algorithm known to be unsafe or inefficient but they are still needed for various reasons. If you work with a vendor who only supports a legacy/deprecated algorithm you don't have much choice, it could take months or years before the vendor does the upgrade. Brian definitely is doing great work with ring. I am not removing it from the list but all I think we need better alternates. A static linkable library with all the algorithms supported by openssl would be nice. Thanks Murali
&gt; You should be able to change the username on the /register page. Ok, but what username is allowed, I am known as Eh2406 in a lot of places, and it doesn't tell me what the problem is with using that.
Rocket has one of the best APIs out there. But I think Tokio/async support may not be in the near term goal. I don't have big hopes that it will be done in 2018. I would love to see Rocket to become the defacto solution for rust web backend with other providing specialised cases. But we aren't nowhere near that.
True, but that could be solved by things like JSON Schema. However, I find that creating a schema to match the documentation is less annoying than automating it, but that's mostly because JSON based APIs typically use URIs and headers to convey information, whereas SOAP relies more on the body of requests, so it's not exactly an apples to apples comparison. Dealing with SOAP is a pain partially because of this design choice, so it's imperative to have good tooling to make it manageable.
Thank you for your feedback! &gt; The collision group API's use of usize group IDs doesn't feel rusty. &gt; Similarly, having to track object's usize uids for deferred_add doesn't feel rusty (and, in fact, unintended uid collsions have bitten me in the ass). &gt; Kiss3D is, by far, the best way to get a quick visualization of the physics state, but what I really want is a library that just 'speaks' the same language as the shapes of ncollide. Gluing these libraries together isn't pretty. I agree. In a next version, I intend to use opaque identifiers automatically allocated by the `CollisionWorld` when a collision object is added. &gt; For people who aren't yet linear-algebra magicians (like myself), a definitive guide for projecting nalgebra's suite of 2D types (Point2, Isometry2, Translation2, Rotation2, etc.) to their 3D analogs would be a godsend. That could be done. I've created an [issue](https://github.com/sebcrozet/nalgebra/issues/304) to remind me of that. &gt; I don't need all of the power of nphysics, so I tried to look to the source for elegant tidbits I could pull-out. The code can be a little hard to follow. For instance, the position integration code has lots of tersely named and under-documented functions with very terse parameter names. I totally agree. Hopefully the upcoming version of nphysics will be much cleaner and I will focus more on documentation. &gt; Rather than feature-flag between two-dimensional and three-dimensional types, could you just parameterize the types by a type-level Dimension? I had success doing this a bit in my adaptation of nphysic's type-aliases. I do not parametrize by the dimension because the current implementation only handles 2D and 3D dynamics. Higher-dimensional rigid body dynamics would include additional terms that are not currently computed. So I prefer to keep the API a bit simpler by not adding another type parameter. &gt; I wish I could add Rays to a CollisionWorld. Could you provide some details regarding possible use-cases here? I am not sure when this would be preferable compared to just performing a ray cast every time it is necessary. 
Thank you, fixed
The place where the Linux distro style matters more is for *users*, not developers. The stock compiler for a language is what is generally used to build libraries and programs in that language for the distro. If Debian ships with rustc 1.14, and someone packages ripgrep for Debian, it gets built with rustc 1.14.
You can look at what we do in getsentry/symbolic. We use tls for it. 
Yeah, it's a little frustrating. I use iron for anything that needs stability, though on considering switching that to Gotham. However, Rocket significantly improves my code, so I really hope that it can get updated to use tokio. If I have time, I'll try working on that, but no promises.
I am going to continue building [a tutorial for using Vulkan through Rust+ash](https://github.com/bzm3r/ash-sample-progression) (a lightweight Rust wrapper around Vulkan). It is intended for those who don't know anything about Vulkan, and would like to get a grip on its fundamentals. Currently, there are 4 working "steps" that take you all the way towards implementing logical devices. Writing the tutorial up to this point took a fair amount of time (approximately 28 hours these last 7 days), so progress might slow down somewhat over the next week (school's in session again), but I hope to continue steadily adding to it, with the help of your encouragement!
**Hitscan** A Hitscan in computer games, most commonly in first person shooters, is a calculation performed by a game to find the point at which a given line intersects a game object, and is commonly used to determine whether a bullet or projectile hits a target after being fired from a weapon. A projectile weapon which uses unmodified hitscan information to dictate whether or not it has hit its target is often called a hitscan weapon. Deploying the weapon calls the hitscan function, and if an object is detected in the path of the projectile, a hit is registered. Since the effect is immediate, the projectiles effectively travel at infinite speed and have a linear or otherwise simple trajectory — a practical approximation of a bullet's speed and accuracy over short distances. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/rust/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Linkified: https://github.com/DenisKolodin/yew
Aren't these types of tasks usually more well suited for DSPs than CPUs? 
Any ideas on where the performance gain was realized?
Thanks! This looks interesting so I've created an [issue](https://github.com/sebcrozet/ncollide/issues/177).
It's not a good idea when JIT and DOM caching can be involved. For example, nobody would ever do that in JMH. The justifications a Python module uses are not necessarily applicable for the web.
Thanks, fixed!. Something wrong with `buster generate`
Correct. But I'll need to use regexp still to match against and extract the segments. Instead I'd want something like //pseudo code add_route(GET, "/articles/&lt;year&gt;/&lt;month&gt;/&lt;slug&gt;") || { //now I have the variables year, month and slug } 
I tend to use a lot of nightly features, and having `rustup` manage different compiler installations so nicely is so much better than other languages. Just having to run `rustup override set nightly` is honestly amazing
&gt; The other important thing to not do is add too many features into the lang, Rust is already awesome. I agree with the feeling, however there are still areas where Rust is lacking. Const generics and SIMD are, depending on the domain, pretty much mandatory for performance for example.
Maybe one should create a `ring-depecrated` crate with all algorithms which should not be used but unfortunately are :D
The Jupyter notebooks would be interesting in getting a Rust kernel, which seems a doable project. Would that help?
Did you also test performance by building against the CPU in your computer? RUSTFLAGS="-C target-cpu=native" cargo build --release Of course, for fairness you should also build against march=native for the C++ code. You can also turn on Link-Time Optimization in `Cargo.toml` with: [profile.release] lto = true 
Lots of posts due to the call for blog posts :D
Oh. It might be only lowercase letters. :D Sorry for that. I should be able to relax that today evening PST.
Yeah, I mean, I don't really participate much if at all in those discussions either. They are extremely tiring, and my utmost respect goes to the folks that do the work to have those discussions.
Read that as "Rusty McRustface" initially. Excellent work porting this library!
Sure, but with this in a low-level language you can run the library from any application/browser, and in Rust's case, in a safe manner.
I finally made the new releases for [bytecount](https://github.com/llogiq/bytecount) and [flamer](https://github.com/llogiq/flamer). Need to look into [overflower](https://github.com/llogiq/overflower) next. Also TWiR and possibly a 2018 blog post.
Will you post the list to reddit? Just cause I think it could be quite a good discussion topic to see what gaps other people see. Could also lead to a sort of lib-blitz 2 just bringing up new libraries rather than refining existing ones
They tackle the same problem in pretty different ways. In Juniper you have to write the types yourself and annotate them with various attributes/use macros. In my framework, you use a single `schema` macro which generates all the code for you. I believe this approach means less boilerplate and more flexibility (it's easier to have custom data type implementations).
Wow. Enabling LTO reduces the mean to 815ms (C++ mean is 889ms), increasing the difference to 9%. I wonder what the results will look like in a multi-threaded scenario. Setting RAYON_NUM_THREADS to 2 instead of 1 yields another ~30ms. I need to setup OpenMP to test the original. Also, using "target-cpu=native" did not change the numbers at all.
Thanks for clearing things
You probably want /r/playrust. This is the subreddit for the Rust programming language.
As mentioned in the GH issue https://github.com/DenisKolodin/yew/issues/5 note that those benchmarks compare to older versions of those js frameworks, from around 3+ years ago. 
I have no idea, but would love to learn more as well :)
This is such a wonderful attitude. In a similar vein, reading ~~your~~ Geoff Greer's and /u/burntsushi's comments settling on a standard for ignore files made my heart go all warm and fuzzy &lt;3
Unfortunately `mingw-w64-gcc` on Arch is broken and unmaintained right now. Is there a way to do this still?
Thanks for the offer and that sounds like a swell plan. But if we are going to oxidize OpenBSD is there something easier, or impactful yet less risky, what we would start with? 
Hyper sells itself as: &gt; A low-level HTTP implementation for Rust. ...which is NOT anything like a nice server framework like Ruby on Rails and the like, and I definitely wouldn't expect it to implement something like path segmentation for you. So, if you want that sort of high-level interface for routing, you're either going to need to roll it yourself or add some more high-level components in your project: * If you're attached to Hyper, [Iron](http://ironframework.io/) is a good choice and have a fairly robust [router](https://github.com/iron/router) middleware. * [Rocket](https://rocket.rs/) is an amazing framework and my personal favorite. Look, it even has auto-generated code using the syntax you've used as a high-level parser description(!): #[get("/hello/&lt;name&gt;/&lt;age&gt;")] fn hello(name: String, age: u8) -&gt; String { format!("Hello, {} year old named {}!", age, name) } fn main() { rocket::ignite().mount("/", routes![hello]).launch(); } * More information about the current state of Rust's current web ecosystem can be found here: http://www.arewewebyet.org/.
I definitely will! :)
Roger!
Design question...why not just have users write `Option&lt;whatever&gt;` instead of `whatever!`? Is that use case just that common? Was it just to be more compact? As a Rust user who's not very familiar with GraphQL, I was confused when I first saw it...and I hope that the feedback is helpful. :)
I LOVE THIS! Sometimes, you just have to realize that your design goals aren't the design goals somebody else has...that applies to (sometimes only personal) workflows, and that's okay! :)
Hey, I remember this too! :) Collaboration on something all participants care abuot is what open-source was supposed to be all about in the first place, right?
Actually, that was with the author of the Silver Searcher (Geoff Greer). The OP of this post is Andy Lester, the author of ack. :-)
Uhh... I knew that :-) Thanks for the correction.
Were you using an LLVM backend for the C++ version as well? I've noticed massive differences between VS/GCC/Clang for the same C++ code.
The schema IDL syntax is a (de facto) standard part of GraphQL, not something I invented. I've tried to stick as closely to it as possible.
I'll have to look in to it. Haven't been working on anything lately, so haven't tried.
I'm polishing up my [http-entity](https://github.com/scottlamb/http-entity) crate to publish. Feedback welcome: * name advise? I was a bit nervous about claiming authoritative-sounding names (http-entity and http-file, or maybe http-entity-file to keep the same prefix for this and future companion crates) for my little project but that seems to be common practice, so maybe I should just go for it. * do the README and docstrings explain what it does well enough? * code review / quality advise? I just did a pass through clippy and rustfmt, set up travis-ci, and improved the README and comments a bit. Still need to simplify the example, make a benchmark, add a couple tests to the http-file crate. Eventually I'd like to add in something for selecting between uncompressed or gzipped versions of entities and a nice thing for baking in 
C++ version is compiled with AppleClang 7
Ooooh, okay. :) TIL, thanks!
OK. I was trying to build a Docker image for non-Arch users but apparently just yesterday they stopped offering a `mingw-w64-gcc` binary package...
What are your thoughts on deriving a scheme from e.g. diesel.rs type definitions, like graphene does for django? Would it be feasible / worth pursuing?
Hey guys! Erich here -- I'm hoping to gather a list of the use cases and ecosystem chunks that you feel like Rust is still lacking, and just needs manpower for. I hope that this list can become helpful for those who are looking to build something with Rust, so they can make the ecosystem even stronger! This is actually a selfish motivation of mine -- I want to build *stuff* with Rust, and I want to know what will be used! :) A few members of the community have encouraged me to actually implement this idea. It's not necessarily an original one, but I couldn't find anything like it -- so let the collaboration begin! I'm also open to anyone who has ideas for how to add value to this list -- I've made it the way I think it might be most useful, but I'm definitely not representative of most Rust users, so I bet there's still improvements to make besides adding more to the list.
That's exactly what I was referring to. Can't get this to work without fetching the dependency I want to change, which sucks. I don't want to manually have to think about that kind of stuff and remember that I did that.
DONE! See [here](https://www.reddit.com/r/rust/comments/7p1s2l/notyetawesome_rust_tell_us_the_use_cases_you/). :)
I'd not use `.iter()` for iterating over character in a string, use `.chars()` instead, it even works with Unicode. The last example where you went back and forth between ASCII and bytes was pretty horrible because of that and I would not teach that to beginners. fn main() { use std::iter::FromIterator; let string = "RustConf, August 18 - 19 | Portland"; let new_string = String::from_iter( string.chars() .take_while(|c| *c != '|') .filter(|c| c.is_alphanumeric()) ); }
At least i established "Rust-HQ" – which is now a thing :D
Good idea! I hope this projects gains traction, it seems very worthwhile.
Performance analysis on that level is pretty complicated. I don't know the specifics of this library, but usually the compiler can't do a lot of performance optimization once there's a possibility of pointer arithmetics. Rust doesn't allow that unless you're in an `unsafe` block, so all other things equal it should be naturally faster. At least that's the reason I've heard why Fortran is faster than C. However, one advantage C/C++ have over Rust is that there's a lot of undefined behavior, which allows the optimizer a lot of leeway. This is less of an issue with properly programmed code, since it shouldn't exhibit undefined behavior.
If you've done a function-by-function port, you could run both through a profiler to see where the numbers differ.
Kind of. `openssl` crate can support the older and unsafe versions of SSL and TLS. It also has DTLS support. I really don't know what you'd need those for, but maybe.
I think that's a huge issue at the moment: the language is still evolving, so I believe any AST parser will by definition be unstable, although modifying and republishing the rustc parser as a separate crate can certainly be a more stable solution.
I have been wanting to do this and do the signalling side. I haven't started yet, but I wanted to first replicate https://github.com/coturn/coturn functionality using tokio (I know, there are some Rust impls already). Then I would move to the actual WebRTC side (I was wanting media channels as well). Oh well, one day, I am too busy atm. I think it could do more than browser p2p, I think it could be a decent standardization for NAT busting and desktop p2p in general.
For what it's worth, I built this project in an effort to learn some Rust without the intention of making something production-worthy. I consulting your project because I had trouble getting `Box&lt;Stream&lt;Item=Chunk, ...&gt;&gt;` to work for myself. So I've been trying to depart from it not because your work is insufficient but because I'm a beginner trying to figure out my own code. Thanks for the ETag/Gzip tip. I wonder if it's enough for the ETag to be strong when uncompressed but changed to weak when compressed. I certainly have some RFCs to read. If you have some spare charity time, I have a question regarding http-entity. What is the purpose of this code? https://github.com/scottlamb/http-entity/blob/4e18480e69bc7f9413c316d6825649012b73d739/http-file/lib.rs#L109-L116 It creates a new channel, pipes the chunk stream to it in a new task on the same pool, and uses forget() on it for a reason I can't figure out. For example, since `entity.get_range()` is already happening in a task on the thread pool, I'm wondering what the benefit is of doing the chunk stream in a different task on the same pool. At any rate, thanks for publishing your work.
I don't know if this is something that really belongs on this list, but I will say that as a novice rust user I often run into the problem that stackoverflow Q&amp;As/blog posts/etc are from 3 or 4 years ago and the solutions presented there are no longer valid with how much Rust has been updated. I'm not sure what the solution would be, but maybe it could involve putting together a task force to go through and provide updated answers to the most popular questions on SO, finding popular blogs and seeing about getting them updated/deprecated/rewritten, that sort of thing. This would be a lot of effort that wouldn't be terribly visible to people already in the community, but it would be a boon to newcomers. Rust's documentation is great, but it doesn't always have direct answers to a lot of questions asked by noobs like myself. There isn't as much community content, and unfortunately a lot of it is outdated to the point of not even being syntactically correct. This can definitely cause headaches for people trying to get started with Rust.
That is what syntex is/was: the parser used by the compiler, compiled into a crate, and with a version
If I'm reading the post right then a third party library should be able to do this by deriving the `ResolveObject` and `AbstractX` traits.
There are the [uutils/coretuls](https://github.com/uutils/coreutils) and [redox/coreutils](https://github.com/redox-os/coreutils) projects which are both implementing a set of the "core" POSIX utilities in Rust. uutils is aiming for GNU coreutils compatibility, which is what's used on most Linux systems, while I believe that redox coreutils are closer to the BSD variants, so would likely be more appropriate for OpenBSD. I'd recommend getting involved with one of those projects, and implementing a missing utility or adding a missing feature to one of the utilities, if you're interested. Of course, to get them accepted into OpenBSD core would take a lot of work to get past some other technical hurdles, but actually having a set of utilities that could replace many system utilities as a drop-in would likely help.
&gt; Sure, but with this in a low-level language you can run the library from any application/browser, and in Rust's case, in a safe manner. um... wasm port in the works? Real time face detection in the browser in pure rust?
I did like this in Haskell, although it often felt more like a novelty than anything else. I don't know whether this would take more work than just getting RLS up to scratch tbh
Unrelated to Rust but it would be nice to know it's speed and accuracy compared to other libraries, e.g. dlib.
Improving Warden - the data-driven test framework for gfx-hal: - implementing missing features of GL backend - running on Travis CI - adding support for shaders
This seems like quite a stretch to expect a function to return an error when you never write the `Err()` at all. That's not a subtle bug at all: fn insert_value() -&gt; Result&lt;(), DbError&gt; { if insert_impl() { return Ok(()); } } And why would you write this when you know you don't need to have `Ok(())`? It would be much more natural to write `if !insert_impl() { return Err() }`. This is an unrealistic reach in my opinion. &gt; I really don't see the benefit of saving the few keystrokes of `Ok(())` This is not the reason people want this feature. I would really love it if some day we could bury these trite arguments about explicitness and keystrokes and have a more elevated conversation.
It's in the archive, but it won't install because of the dependency issues.
Working on a crate that can open doom .WAD data files 
I'd love to see something like this implemented. I've been working on a service for my friends to provide low-latency webstreaming (think Twitch, but with &lt;2s delay) for interactive single-player gaming. The proof-of-concept is super easily achieved using an nginx plugin to accept RTMP streams and video.js to play them, but it leaves me with this nasty dependency on Flash. I tried using some WebRTC libraries by had no success.
2:24 GMT +3, Server is down again 
Not just 'in the works', it's [natively supported by the Rust compiler](https://www.hellorust.com/news/native-wasm-target.html) (albeit still in beta).
I think Rust could be used alongside another language for this purpose. It of course heavily dependents on what you actually want to teach in the introduction, but I think it would be a better fit than C for example if you want to teach lower level things.
Yes, combining diesel's db schema inference with this schema macro is a [great](https://twitter.com/killercup/status/950487847861145600) idea!
I know this is probably a niche use case but I really need cargo to work in an isolated, non-internet connected environment. Ideally I would like to be able to create a local mirror of crates.io that is periodically synced much like I do now for Linux packages.
Which ones have you tried, how recent were they? I already made [an issue](https://github.com/ErichDonGubler/not-yet-awesome-rust/issues/3) for you. :)
Trying again since no answers last week. Is there a basic guide to using a C dynamic library within a Cargo project that works across Windows/Mac/Linux? I've looked at https://github.com/rust-lang/cargo/issues/4421 which doesn't have a resolution yet.
Would it be okay if you sync'd packages first, and then just reused the cached packages? Or do need to actually imitate crate infrastructure?
/u/Noughmad, does /u/killercup's reply here help you? 
Made [an issue](https://github.com/ErichDonGubler/not-yet-awesome-rust/issues/4) here. :)
i'm sure/u/shepmaster would love this!
This could work, via parity-wasm....
rustfmt ties directly into the compiler, and the compiler's interface isn't stable. However, we're looking to distribute it with Rust, which means that `rustup` can manage the versions such that it all works out. This process has already happened, and so there's a `rustfmt-preview` component on beta and nightly. Next stable release will have it.
Also consider, https://github.com/alexcrichton/cargo-vendor
Then my first reply is probably the kind of answer you want, and you'll almost certainly have to roll that routing API yourself. 
yeah. Good Intl crate(s) that would provide at least basic functionality to match what ICU/CLDR do (date/time formatting, number formatting, plural rules) would be very helpful for localization as well (I'm one of the authors of the fluent-rs crate).
Why even require a username for people logging in via github?
Since you're in that market, would you mind having a look a [my metrics library](https://crates.io/crates/dipstick) and telling me what you think of it? It provides "sane defaults" metrics aggregation like codahale. Since Rust does not have anything like JMX built-in the platform like the JVM, the current outputs are "push"-styled (log, console, statsd, graphite...) but the next version will add plain HTTP-served metrics. 
Oh, now that I think of it, you can't do `Content-Encoding: gzip` for a portion of the stream on the fly at all. You need to provide the length of the body post-compression and, on getting a request for a given byte range, serve that range of the compressed encoding. (I just tried it with Apache's mod_deflate, and it indeed changed the `Content-Length`.) I think the behavior you're looking for—where the headers and sizes and ranges everything represent the pre-compressed entity—is possible with `Transfer-Encoding: gzip`, which is a different thing. I don't really know the details of how it works. I haven't messed with either way of gzipping stuff yet because I originally wrote this for `.mp4` files which are basically incompressible anyway. As for the http-file code you mention, a couple things: (1) The contract doesn't require that the `Entity::get_range()` call happens on the thread pool, or that the `http_entity::serve()` call happens on the thread pool. `http_file::ChunkedReadFile::new()` advises the caller to use a thread pool (to avoid stalling the reactor thread), and so it'd typically make sense for the caller to do the `http_entity::serve()` right there rather than handing back off to the reactor thread, but that's not guaranteed. Maybe the caller wants to cache `ChunkedReadFile`s between requests for efficiency; then there's no reason the caller would be running anything on the `CpuPool` in the cache hit case. (2) Which thread calls `Entity::get_range()` doesn't matter anyway. The code in `get_range()`'s `unfold` lambda gets run where the stream is consumed, not where `unfold` was called. This is how futures work, as I understand it, and hyper consumes it from the reactor thread that we don't want to stall. You can confirm this with my `serve_file` example: I was actually about to simplify this code, but it works out well for this demonstration. Assuming you're on Linux, run `strace -f target/debug/examples/serve_file /usr/share/dict/words` in a terminal and then hit `http://127.0.0.1:1337/pool-inline`. This tells it to serve that file, constructing the `ChunkedReadFile` in the `CpuPool` but pass `None` as the `CpuPool` to the constructor, skipping the code you're asking about. You can see that the same pid does the `epoll_wait` call and the `pread64` calls. That means blocking file I/O is happening on the tokio reactor thread, not the `CpuPool` thread. You can also see that `/pool-pool` has the better behavior of never doing the blocking filesystem calls on the reactor thread. Running `futures::sync::mpsc::Sender::send_all`on the `CpuPool` thread ensures all the stuff to fill the channel happens there, even if the consumer is on another thread.
I looked at the post title and wondered to myself 'where can I get a good summary of the changes?', and here it is! Thanks for taking to time to write this up. It's very helpful.
\#[no_std] desperately needs error_chain or something similar.
Have you considered also porting SeetaFace Identification?
Could it be simplified with something like Docker? Install Docker, pull the image, add a config file to be mounted/read by the container when run and some persistant storage volume to mount to store/cache crates? I haven't read the link as it's not something I particularly need, just curious if most of the work could be nicely packaged in a container(perhaps with a CLI/GUI app to connect over some port/protocol and do any management in a user friendly way), and then just point cargo to that local port/ip?
Can someone explain what these parameters mean in english? I understand generics and type constraints but I'm struggling to understand this massive on from futures-rs impl&lt;S&gt; Future for Concat2&lt;S&gt; where S: Stream, S::Item: Extend&lt;&lt;&lt;S as Stream&gt;::Item as IntoIterator&gt;::Item&gt; + IntoIterator + Default, source: http://alexcrichton.com/futures-rs/futures/stream/struct.Concat2.html
Regex? Write a parser with nom? There **is no solution to this using hyper**. That's what people are saying. You have to make your own solution.
How to do it in hyper: use regex. That's literally it. Hyper provides no exported functionality to do what you want, and it does not intend to. You need to use it to give you a raw URL string, and you need to use **some other library** to parse it. If you want: add_route(GET, "/articles/&lt;year&gt;/&lt;month&gt;/&lt;slug&gt;") || { you can use something else (not hyper) to do this. Heck, you can write your own `add_route` method, and your own struct to store the routes - that's totally doable! There is no structure in hyper to do this though, it's for you to write.
yeah how about other routing libraries? I haven't found any decent one.
&gt; The reason I suggested something higher level is because generally that sort of functionality is in framework land. Just trying to help! :) or harm Iron - a) non async b) outdated Rocket - 1) heavy 2) non async 3) rust nightly 4) 2 weeks ago when I was trying it, it didn't compile -- library "ring" had a bug in it. That's it
[`failure`](https://github.com/withoutboats/failure#requirements) is supposed to replace `error-chain`, and can be used with `no-std`! :)
Well the issue is all development from start to finish needs to happen offline. So I can't just sync the packages before hand and then bring them offline - what happens when I need a new dependency? That's the issue I ran into - and truth be told I haven't tried that hard to remedy the situation yet. But looking around it seems theres no 'obvious' solution to this problem. My current C workflow currently consists of syncing Linux packages using shell scripts and manually taking data to the offline network periodically via external hard drives. Right now I'm working on my rust projects while internet connected but eventually I will not be able to do this and I'm looking toward the future. I watched a video of a rust conference talk once where an audience member had a scenario very similar to mine and the rust dev indicated that this was something they wanted to handle but I haven't seen a ton happening on the front so far but maybe I'm just blind.
Bitcode support for Apple products (watchOS and tvOS - maybe iOS one day) is definitely something I am missing from rust right now
Truth be told I haven't tried very hard so far because I've had other priorities lately. I have tried building a cached project offline but was not successful as cargo still tried to connect to the internet for some reason. I did not persue it further after that though. The real issue though is not that I need to work offline temporarily but rather permanently. Theoretically I should be able to work on a project with crate dependencies entirely offline. See my response to another redditor above for a few more details on what I mean by this.
The best routing library I've found so far is rocket, but I know that's not what you want. I don't know of any routing libraries which don't also wrap the HTTP stack - everything uses hyper internally of course, but none of the libraries providing routing like rocket, iron, etc. allow direct access to hyper. Just using regex is doable, if you want simple URLs. This is a copy of the hello world example w/ simple routing added like your post: extern crate futures; extern crate hyper; #[macro_use] extern crate lazy_static; extern crate regex; use futures::future::FutureResult; use regex::Regex; use hyper::{Get, StatusCode}; use hyper::header::ContentLength; use hyper::server::{Http, Request, Response, Service}; struct Echo; impl Service for Echo { type Request = Request; type Response = Response; type Error = hyper::Error; type Future = FutureResult&lt;Response, hyper::Error&gt;; fn call(&amp;self, req: Request) -&gt; Self::Future { lazy_static! { static ref ARTICLE_SLUG: Regex = Regex::new("^[0-9/]+:([a-z_-]+)$").unwrap(); } futures::future::ok(match req.method() { &amp;Get =&gt; match ARTICLE_SLUG .captures(req.path()) .and_then(|v| v.get(1).map(|x| x.as_str())) { Some(article_slug) =&gt; { let body = format!("Hello, this is {}", article_slug); Response::new() .with_header(ContentLength(body.len() as u64)) .with_body(body) } _ =&gt; Response::new().with_status(StatusCode::NotFound), }, _ =&gt; Response::new().with_status(StatusCode::NotFound), }) } } fn main() { let addr = "127.0.0.1:1337".parse().unwrap(); let server = Http::new().bind(&amp;addr, || Ok(Echo)).unwrap(); println!( "Listening on http://{} with 1 thread.", server.local_addr().unwrap() ); server.run().unwrap(); }
Makes sense. For some reason I didn't read the gaming part of your post, I thought it was for data streaming..
Hmm. Have you tried gotham? https://github.com/gotham-rs/gotham It's definitely heavy in terms of setup, but it: - compiles on stable - is very committed to stability - is async (uses hyper-0.11)
Will this code work for that purpose? https://github.com/schultyy/sphinx And after I hook it up will it run its functions after it compiles?
it sounds to me like cargo-local-vendor may be for you.
Added two issues for you that have been of interest to me personally. Can't say that they would garner much interest to others to be worth the time, but with Rust progress this year on Async support and other language features to stablize/implement, they might be better catered for. One big gripe I've had is examples. Some documentation is pretty good, I often find though some example snippets aren't available in the docs(sometimes provided on the github readme, or they might have some example source in the repo). It's one of the things I miss from JS dev which was quite common to see with npm packages. Perhaps a site/service where users can associate example snippets to docs.rs or crate urls/id, users can look up their crate/docs and find user contributed examples(from users who figured it out or it took them a while and they wanted to share back to the community to get others started faster). If it took off, perhaps docs.rs could query by some API call to the service and provide examples inline(or a subset of examples sorted by user votes).
I think he does that, at least I recall seeing old questions with updates from him year or two later :) Quite helpful!
Which dependencies are you objecting to fetching? Sorry, I'm not entirely sure what you're looking for. If you want to try another dependency, won't you have to download it in every single scenario? If you are objecting to downloading `ring=0.12.1`, why? I mean, I assume you already have it in your local cache? if you specify a patch, it won't ever be compiled/used.
Doesn't tie you to it does it? Anyone could apply the setup to a host system without the use of Docker or use another container technology(or VM guest if they prefer). Docker just provides a simple recipe of something that works well and easy to get everything sorted for you once someone else has set it up. Less variability(especially on linux) with various differences such as package versions and conflicts if you prefer to avoid the benefits of a container/VM. You could though provision with Ansible or Salt(or puppet/chef) too. Chances are, if there is some official guide/list and enough interest, someone in the community will make a Docker setup or automation recipe with Ansible for others to benefit from and save on time/troubleshooting. Regardless of which way you go, the CLI/GUI app to interact/configure, and a settings/config file is separate from all that and can work with any of them. As mentioned, I didn't read the link, just assumed from your comment on it being fiddly that the setup might be a bit complicated and have gotchas or other weird problems that can happen setting up certain infrastructure. Docker and others mentioned really help alleviate that, I don't see it as overkill if that is the case. It's light weight and simple to use, far less hassle than following instructions for how some projects want to be built/deployed.
Yeah I've had a look at what it would take to implement this and it is not feasible with the current crate ecosystem. Last time I looked into it, the following bits stood out: * STUN/TURN server would be required to use ICE protocol properly. * You would need to support SCTP, which is a different protocol to UDP/TCP, which means that you would need to rewrite tokio to support it. * SRTP and DTLS are basically mandatory, and I don't think you can turn this part off if you want to interface with firefox/chrome. There are probably more bits and pieces I have forgotten, but you are looking at implementing lots of massive standards in order to get this stuff to work. Just load up a DataChannel example and use wireshark to see the various protocol level negotiations that take place. You might be better off starting with bindgen and using those existing libraries, then slowly porting over things. 
rocket - isn't a routing library.
I'm guessing the part you're getting confused at is `Extend&lt;&lt;&lt;S as Stream&gt;::Item as IntoIterator&gt;::Item&gt;`. My eyes roll back into my head just looking at that, too, but it's actually straightforward if you start stripping pairs of brackets: * `S::Item: Extend&lt;_1&gt;` * `_1:` `&lt;_2&gt;::Item` * `_2:` `&lt;S as Stream&gt;::Item as IntoIterator` So working from inside-out: * `S::Item` implements `IntoIterator` (which is in the outermost bounds as well) * that `IntoIterator::Item` type is the argument type to `Extend` Thus: the impl requires that `S::Item` implements `Extend` for its own `IntoIterator::Item` type. Which makes sense because the purpose of the `Concat2` combinator is thus: &gt; A stream combinator to concatenate the results of a stream into the first yielded item. So if your stream is yielding `Vec&lt;T&gt;`, for every item after the first it'll instead call `firstItem.extend(nextItem)` and then it's just a `Future` that yields `firstItem` once the stream is coimplete. ("concatenate" isn't the verb I'd choose here because I'd assume that means concatenating one stream's output onto the end of another, like the `.chain()` combinator for plain iterators; this is more of a fold-type operation)
Just to make it clear, I really like Haskell, I just hope Rust won't make the same mistakes and end up being ignored by the big companies and failing to have a proper eco-system.
So why can't you do `target-cpu=native` inside of the `Cargo.toml`?
Eh, I'm interested in why you would say that. Why isn't it? From what I know, rocket's whole purpose is literally to wrap hyper and provide routing to functions using a simple attribute syntax. How is that _not_ a routing library?
In particular the pointer case of Fortran and Rust has to do with the compiler being able to make greater assumptions about which pointers cannot possibly alias each other. In Rust because the type system stops it and in Fortran because the programmer just isn't allowed to alias under a lot of conditions which is undefined behaviour. Rust in theory once the type checking is completed has more "undefined behaviour" that the compiler can use; the type checker just ensures that it won't pass if it occurs; the pointer aliasing is one of it but for instance another thing is that a boolean in Rust is always 0 or 1 whereas in C++ it's 0 vs nonzero and that can be used to optimize pretty aggressively by just translating conditionals to addresses themselves and loading code into those addresses and jumping to them that way. Modern C and C++ have a `strict` keyword though that allows the programmer to vouch that a pointer doesn't alias and if it does it's UB but it's not often used.
you can do it inside of `$PROJECTDIR/.cargo/config` as: [build] rustflags = ["-C", "target-cpu=native"] but, I agree it would be nice to have the option to set the target CPU inside the `Cargo.toml` file. However, I would bet that very few people outside of Gentoo users actually use "native" for the target of binaries they're building. If you use "native", then you can't just copy the binaries to a friend's computer, or to one of your remote servers. It's only useful for running code on your own machine, and it would be *very* unpleasantly surprising behavior to many newcomers if they couldn't copy binaries to a friend's computer. If a company is building binaries for a specific hardware platform, like Skylake servers, it would be better to say `target-cpu=skylake`, that way you know for sure that the binaries will not exceed the feature set of Skylake. ----- As the nobody that I am, I would guess that it will eventually be an option in Cargo.toml, but no one has owned it and made it happen.
Because fn get_data(&amp;mut self) -&gt; &amp;'a mut FieldData You've told the compiler that the lifetime of the returned `&amp;mut FieldData` is tied to the lifetime `'a`, which is tied to `FieldData&lt;'a&gt;`, which is tied to the lifetime of the `&amp;mut [u8]` inside the `BorrowedValue` variant, which in this example is tied to the lifetime of the `referent` variable... which is the entire lifetime of the body of the function. You shouldn't be using `'a` there at all; remove it. If you want to be explicit, not putting a lifetime there is equivalent to: fn get_data&lt;'b&gt;(&amp;'b mut self) -&gt; &amp;'b mut FieldData Which ties the result's lifetime to the temporary borrow used for the method call.
As a novice, lack of tooling is pretty big issue for me. I wish intellij plug-in would work good with all dependences and hints, but code completion stops working after simple map function on vec...
Well I don't know, I write a lot of stuff in Rust which I essentially never intend to redistribute to anyone and it's pretty much hacked together to only work on my system to fill a quick need like a shell script when I need the performance so I tend to compile it with native but it's kind of annoying to indeed have to do it with a RUSTFLAGS environment variable.
Yes, I think I see where the issue is. Solution here: https://play.rust-lang.org/?gist=791b08e087101559cd13dad19397ceac&amp;version=stable The problem is the `Field` trait - your version: trait Field&lt;'a&gt; { fn get_data(&amp;mut self) -&gt; &amp;'a mut FieldData; } My version: trait Field&lt;'a&gt; { fn get_data&lt;'b&gt;(&amp;'b mut self) -&gt; &amp;'b mut FieldData&lt;'a&gt;; } You can also write this as: trait Field&lt;'a&gt; { fn get_data(&amp;mut self) -&gt; &amp;mut FieldData&lt;'a&gt;; } ... since `self` is the only lifetime in the arguments and therefore the lifetime of the return type is implicit. What you are doing is handing out a reference and saying that this reference will be alive as long as the `Field` struct is alive. You basically say: once you have called this function, the `Field` will indefinitely mutably borrowed until it is destroyed. So the compiler is technically correct to say "hey, you won't My version says: The mutable returned reference will be alive as long as the value that the return type is assigned to. Interestingly, your code will compile using the non-lexical-lifetimes feature: https://play.rust-lang.org/?gist=27d281d88e7b6c30bd94f20eb62d8d4d&amp;version=nightly ... because this feature detects that the mutable reference is not actually used at the same time as the normal reference. However, what you wanted to express is technically incorrect. Although I like non-lexical lifetimes I have to wonder how many errors like this will pop up (because technically, the posted code does not match what you wanted to express, so it is an error).
Have you tried specifying the version yourself? cargo update -p ring --precise 0.12.0 This only works if the version you specify is compatible with what your dependency specifies.
An issue with some more details would be great! :)
does this detect faces at any angle?
So I took a look at it and tried it out. It looks like a great lib, but I think I need something a little lighter weight. Some issues I found: - it ignores whitespace, which is valid for HTTP! But for a cmdline application whitespace is REALLY important - whitespace has some... weird impacts on tables. I couldn't quite put my finger on it so I didn't open an issue, but it seems that adding whitespace, while it doesn't get rendered, DOES impact how big the width is for that column. - tables are a little too heavy-weight for my needs. They look good though! Basically, its a great lib but I realized I just need (basically) a token stream which is probably better specified in yaml. Here's a basic example of what I will be writing (in yaml) - This is a regular string with a newline\n - This does not have a newline, but - {t: "this is red", c: red} - , but this is NOT red!\n - "Bold is easy like this: " - {t: "see I'm bold", b: y} - and so is multiple settings - t: bold AND green! b: true c: green # Table - - ["header col1", "header col2"] - ["row col1", {t: "row col2", c: green}] - [ "you can do lots of things all in ", {t: "a few lines", b: true}, "fairly ", {t: "easily!", c: green}, ] 
Most recently: https://github.com/rust-lang/rust/issues/46819 This is the path forward for LLVM 5, so I'd say the odds are good :)
&gt; I believe the solution “let’s introduce epochs! Modules using different epochs can’t work together!” is not good enough. This isn't the plan- instead, crates using different epochs *can* work together. Epochs are mostly a marketing thing to mark shifts in idiomatic Rust, and the occasional supporting opt-in breaking change.
The `syn` crate with the "full" feature is capable of parsing all of a rust crate or module from a string. If I understand you correctly, this in what you're looking for?
There is [a crate](https://docs.rs/debug_stub_derive/0.3.0/debug_stub_derive/) which implements this.
Invite link doesn't work.
Good write up. I agree almost every point on your list except wasm. I think being WASM is going to help Rust bring attention. I pretty much shared similar opinion on my [blog](http://www.mmrath.com/post/rust-my-wish-list-for-2018/) BTW: Are you the gentlemen who used to organize JVM meetups in Sydney? 
To take the example of the RFC, the new "catch" keywords, It means a new Rust project using the most recent epoch will not be able to use a library which use catch as an identifier. Epoch is not introducing this problem, to me it just makes it the official way of dealing with breaking changes. I am wondering if instead the compiler/cargo can be reworked to not need to recompile everything with a single compiler. Basically precompiling every module with a different compiler version and then combining them with the latest compiler. That would mean introducing an intermediate language which is completely backward compatible (LLVM IR? HIR? MIR?). That would greatly reduce the potential breaking changes between modules / crates.
That's right, I am! I have retired from that a while ago though :)
Hmm, looks like I may have submitted it wrong. Whoops! Here's a fixed one: https://discordapp.com/invite/qVejEk7 Paging /u/llogiq, is there a mod that can edit the link?
Cool, so let's make it a capability of the compiler itself then.
It suggests lots of stuff, and seems to be good at being relevant based on what you've typed before the dot, including new functions from cargo libs added, but it doesn't seem to know that "let" exists.
Good to see you in rust Reddit. Even I have not gone to that Meetup for sometime now, after you one of my ex colleague took over. Nowadays I don't see the JVM Meetup happening frequently.
Okay, thanks for your time. 
Matching the name of the similar Go function? Hmm, that's a thought. I picked "entity" because that's the term the HTTP RFC uses to describe the thing being transferred. It seemed like a logical name for the trait, and thus the whole crate. Would you do `http_servecontent::Entity`? and `http_servecontent::serve`?
The only way you can refer to anything in a separately-compiled dependency is via its identifier...
I think the problem with Haskell is not in the language itself, but that it tends to be regarded as needing a knowledge of category theory to be mastered. If you read posts from the Haskell community, it is full of terms that scare people away. I don't think Rust has the same "marketing" problem.
&gt; I'm using RLS + neovim Editors other than VSCode are supporting the language server protocol? Do you know of a list of editors that support it?
I second your wishpost! Not the most critical initiative, but a real paper-cut for sure. I have used the [debugit](https://crates.io/crates/debugit) crate to be able to log any value passed into my mocking library, but the necessary use of compiler intrinsic makes that functionality nightly-only. UX-wise, there’s no reason to have this be the case. It would make so much more sense to have the debug text for a given type default to its type name if Debug is not implemented for it. Printing the debug value of a variable should always do _something_.
But is that a problem if the identifier is called "catch" at this point of the compilation? That's a genuine question. I'm no compiler expert, I just don't understand how that could be an issue. 
But it is, via macros. I view this as a success of the macro system. Does it need to be merged?
Rust requires you to understand the whole ownership mechanism. the learning curve to me is as steep as the Haskell one. I don't think either that the problem with Haskell is the language. It is what they do with the eco-system. As you said the lingo is one thing but there's also no official tooling and easy convention you can rely on. I feel like it's not even getting better and now it has this bad reputation of an overly complicated language that it will never get rid off. 
I feel like that when I read the Scala documentation too. It feels like I'm reading a math paper that's waaaaay beyond my depth... but then I get a more straightforward explanation and it's just like "oh. Well, you could have just said that...". And these explanations tend to be of equal length, so it's not that they're just being concise. Rust, on the other hand, tends to have lovely straightforward explanations of everything. It's great!
`eh2406` should work now. :) . Thank you for reporting it.
Last time I looked at it (like 2 months ago), it could only parse modules. Has this changed?
Right, I'm suggesting that the crate's ability, or something close to it, should be merged into the compiler itself and made automatic. Having such core things be left out in their own crate is not good. With debug_stub_derive being a separate crate you have to 1) know it exists 2) add it to your Cargo.toml file 3) put `#[macro_use] extern crate debug_stub_derive;` in your lib.rs 4) derive `DebugStub` instead of the normal `Debug`, meaning that everyone else reading the code later now has to go double check that `DebugStub` doesn't do anything weird. 5) Mark a replacement value on every field that would be missing, meaning that you have to care about what's missing or what's not ahead of time, instead of it just working automatically for you. 
As far as I know, it's always had that ability, just under a feature flag. The one thing it can't do get is follow `mod x;` definitions to other files, but that probably belongs in a wrapper of some sort? Given that syn just parses strings.
&gt;&gt; I don't know whether this would take more work than just getting RLS up to scratch tbt - it could be done in parallel, - theres's fewer moving parts eg integration RLS with IDEs - it could feed backing what the RLS and IDEs could do, eg imagine an IDE that gives you dropdown menus on the placeholders which dynamically adapt as you fill them in my imagined use is actually slightly different to haskel (typed) holes, i.e. extending the dot-autocomplete idea to expressions allowing the return type to contribute, not just the first parameter
You need a plugin. There is a list of supported editors here: https://langserver.org/
and how is better that using pure hyper then?
You can't make them anonymous names if you want them to be accessible from other crates! // crate a, in an older epoch: pub fn catch() { /* do something catchy... */ } Now, in a newer epoch, how do you call that function from crate `b`? // crate b, in a newer epoch: extern crate a; fn main() { a::catch(); // oops - need something more than just separate compilation }
https://github.com/glimmerjs/glimmer-vm/pull/752
Regarding the NPM-security model: I'm working on outsourcing the package trust to the community with https://hackeraudit.com/ , that I've just announced a couple of hours ago.
One of the things that strikes me as odd is "industry adoption" vs. "do not care about WASM". WASM is a good driver for industry adoption, as it has a huge value proposition in spaces where you need to share implementations, e.g. between macOS and a web frontend. (Indeed, I know more then one company that does exactly that) It's one of the only places where Rust is ahead of competition.
The same is true for some parts of the Boost documentation, such as boost::asio.
&gt; but maybe it could involve putting together a task force to go through and provide updated answers to the most popular questions on SO Who needs a task force when you have /u/shepmaster ?
I want to se the results after profile guided optimization (PGO). It's quite a bit trickier to make work though: https://github.com/Geal/pgo-rust There seem to be a project to make it easier: https://github.com/vadimcn/cargo-pgo
A good XML library … There are several competing ones currently, but none of them is full featured or especially good. I don't blame the authors, XML is not as easy as it looks, but we might need a concerted community effort to get a proper XML library.
&gt; In particular the pointer case of Fortran and Rust has to do with the compiler being able to make greater assumptions about which pointers cannot possibly alias each other. I heard aliasing informations were not given to LLVM due to a bug in it. Is that bug solved by now ? Or is it something else ?
I agree on most things, especially SQL bindings. But can't figured what the benefit of rustup merged in cargo. Those tools does not aims the same things. I am not sure to have ./cargow will help me. Downloading a compiler for every project is only ok if you have a solid bandwidth...
Well, we'll see about it. I'm afraid that not that many users actually care... . But I hope I'm wrong. :D
Exciting news! :) I am more interested in incremental build times in the debug configuration rather than the release configuration, so let me report on that. I have [a project](https://github.com/maghoff/sausagewiki) that I measure to the following: * Complete debug build (`CARGO_INCREMENTAL=1 cargo +beta build`): 160s-185s * Inconsequential change of whitespace inside main.rs, then incremental rebuild (`CARGO_INCREMENTAL=1 cargo +beta build`): 4.3-4.5s * Minor change of [an arbitrary string literal](https://github.com/maghoff/sausagewiki/blob/master/src/web/resource.rs#L8), then incremental rebuild: 10.1-10.5s * Inconsequential change of whitespace inside main.rs, then non-incremental rebuild (`CARGO_INCREMENTAL=0 cargo +beta build`): 4.1-4.8s * Minor change of the same string literal, then non-incremental rebuild: 19.7-20.8s It seems that incremental compilation manages to slash compile times in half for many of my recompiles (ie, for small changes). Awesome! :) --- But I am not really happy about 10s compile times, it'd be qualitatively different with around 1s compile times – I'd be able to work in a different way then. What are the plans for compile times and incremental compiles going forward? Is this as incremental as it is going to get? I'm asking so that I can adjust my expectations accordingly :)
&gt; Better libraries for basic things. Rust is meant to be good for concurrency and yet doesn’t have an official stable library for it. We need tokio and future-rs to be stable! Same thing for error management (failure crate?) logging (log crate?) I suspect once OP got a couple of projects under his belt he will agree not all these points are points. We have rayon for concurrency maintained by one of the lead devs. Tokio is async io. Different things. Error handling in rust is something of the most beautiful thing I've worked with. Result&lt;T,E&gt; with? operator and auto From trait is amazing. And logging is de facto standard using a log facade (log crate) leaving the actual implementation up to me, which is miles ahead of some other "mature" languages (looking at you java and nodejs) I agree futures ought to be more central to the language. The confusion of tokio vs futures and the way to learn those libraries are currently a hurdle for rust. As a beginner there really isn't an easy way to start writing async code just yet. 
Oh and concurrency we have built in muted, arc, rwlock, atomicXX, most channels etc. It's great!
From the RFC &gt; To be crystal clear: Rust compilers must support all extant epochs, and a crate dependency graph may involve several different epochs simultaneously I indeed misunderstood the RFC in the first place! Thanks for pointing out! I'll edit my article. I still feel like having both epoch and rust version is unnecessary :)
Thanks, will try it out
I want my giant shoulders too. I'm so tiny on my own.
WASM certainly looks like it could do a lot for rust adoption in the comming years.
&gt; Languages features. The language is good enough. What about [Parameterize types over numerics / type level integers](https://github.com/rust-lang/rfcs/issues/1038)?
It does interest me, thanks. As far as I know `syn` was for implementing macros, not full parsing, but now I see it can parse entire files. I will definitely take a good look at it. 
Yeah, resolving modules and crates should not be the parser's job. But that's part is well-defined and easier than parsing the code. 
Thanks, I did not know about this. I agree with your points there, and really hope it gets accepted. 
FORTH and Red (esp. Red/System) are also languages that attempt to create a single language for all layers of the stack.
I saw you were missing a database abstraction layer...why doesn't diesel fit?
Well for me it's way more meaningful. Entity is too vague a term.
&gt; I saw you were missing a database abstraction layer...why doesn't diesel fit? As mentionned in my post, it supports only postgres, mysql and SQLite. Which is fine for most project but my company requires to work on Oracle. The previous company I was working for was requiring SQL Server...
Definitely nice to have but I don't think it's a blocker in the adoption of Rust.
How hard is it to put the compiler binary together with my crate's source code, to be able to build it on a computer that doesn't have network and don't have rust installed?
It seems to me that rustc still spend a lot of time doing llvm stuff even in incremental mode. Maybe someone else can explain that.
Yeah, it's annoying right now. A workaround for you would be to alias the cargo command for now, so that you don't have to edit your .bashrc.
Huh, but you do have control over `overflow-checks` in Cargo.toml. I've used it a few months ago to look for Servo bugs. [Here's](https://github.com/rust-lang/cargo/blob/e10c651ea142f0a8c077bc717462b2ea233e7e1c/src/cargo/util/toml/mod.rs#L339) the relevant cargo source code. Inside the `[profile.release]`, `[profile.test]` and so on, you can use `overflow-checks = true` to enable them for that profile.
&gt; Papercut: writing internal links in the documentation should not be a pain. I agree with this, bit this it definitely being worked on right now, so it should be good soon(tm)
I believe creating a little browser extension for marking outdated content as a community effort would be worthwhile. Or, simply making a list of solutions that are no longer valid is also good.
This is my effect to replace [python-crfsuite](https://github.com/scrapinghub/python-crfsuite) to enable multi-threaded tagging in my company. Hope it will be useful for others too.
Rust is not yet mainstream and absolutely not a research language. Rust has been designed to be a composition of practical and proven to be effective research results. 
&gt; I need to display something What's wrong with fetching that something from github? &gt; users can change their username on github , I plan to support gitlab sign-in, etc So? Those are distinct namespaces. &gt; It seems easier to just let the user pick a string for themselves It seems easier for the users not to have to worry about it at all.
Definitely an instrumental tool like Intel Pin or DynamoRIO. My big dream...
&gt; You would need to support SCTP, which is a different protocol to UDP/TCP, which means that you would need to rewrite tokio to support it. SCTP congestion control in WebRTC works on top of UDP, AFAIK. Perhaps we don't need to *rewrite* the Tokio for it. And we don't *have* to use Tokio, IMHO.
You know what would make me jump headfirst into rust? Good desktop GUI. There’s no viable option for native GUI at the moment. 
I remember reading somewhere about how to ask rustc what it is spending its time on. Do you know the relevant flag?
&gt; Improve project tooling I definitely agree on this, but personally would avoid anything as powerful as a Gradle system and instead model it after rbenv or nvm and build it into Rustup. That way you could have a `.rustrc` in the project root or a field in `Cargo.toml` that would specify what version of the Rust toolchain this project requires and additionally it would be trivial to work on many projects with different Rust versions on a single machine. A simple `rustup auto` could select the correct version for the project at hand. &gt; Official Crates Isn't Docker the only package repository that does this and isn't it aided by the simplicity of `Dockerfile`s in term of reviewing them. I don't quite know what you mean by "controversial NPM security model." since to me their model is very similar to that of Rubygems, PyPi, Maven, CocoaPods, Composer etc. Generally though your points about core Crates being in a good place is good IMO the key point there is stabalizing them on 1.0 which is already a goal. &gt; There’s not yet a big de-facto web framework I haven't done any Rust web service development, but if I was to liken the language with any other language it would be Go and from my experience building Go web services most projects seem to just use the standard lib HTTP support and a few other bits and piece. This simplicity is IMO one of the core points that make Go so suited for microservices which is a position I think Rust would also occupy as a web services language. 
be_u32 matches a binary word and returns the integer. It is meant for binary data. The delimited macro was correct, I suggest you read this page to simplify the map_opt!: https://stevedonovan.github.io/rust-gentle-intro/nom-intro.html#parsing-numbers 
*cargo-pgo* didn't work for me, so I decided to go with the manual process, described in *pgo-rust*. The docs are a bit outdated, but with some tinkering I've been able to generate the bitcode. Unfortunately, I'm getting an error when using *llc* to compile the *.bc* file: LLVM ERROR: Cannot select: 0x7fcd6a225020: v4i32 = X86ISD::ABS 0x7fcd6a2252f8 0x7fcd6a2252f8: v4i32 = bitcast 0x7fcd6a20c170 0x7fcd6a20c170: v2i64,ch = load&lt;LD16[%sunkaddr1034](align=1)&gt; 0x7fcd69a00700, 0x7fcd6a224a08, undef:i64 0x7fcd6a224a08: i64 = add 0x7fcd6a084810, Constant:i64&lt;-16&gt; 0x7fcd6a084810: i64 = add 0x7fcd6a20b9b8, 0x7fcd6a20b540 0x7fcd6a20b9b8: i64,ch = CopyFromReg 0x7fcd69a00700, Register:i64 %vreg380 0x7fcd6a872d48: i64 = Register %vreg380 0x7fcd6a20b540: i64 = shl 0x7fcd6a20bdc8, Constant:i8&lt;2&gt; 0x7fcd6a20bdc8: i64,ch = CopyFromReg 0x7fcd69a00700, Register:i64 %vreg472 0x7fcd6a20b200: i64 = Register %vreg472 0x7fcd6a224fb8: i8 = Constant&lt;2&gt; 0x7fcd6a084878: i64 = Constant&lt;-16&gt; 0x7fcd6a872ba8: i64 = undef In function: _ZN98_$LT$rustface..feat..surf_mlp_featmap..SurfMlpFeatureMap$u20$as$u20$rustface..feat..FeatureMap$GT$7compute17h7dcff95899878fceE
&gt;But can't figured what the benefit of rustup merged in cargo. I really can't see the benefit of that either. Combining those two sounds like bad tool "separation of concerns". They have completely different purposes that IMO shouldn't be mixed. &gt;Downloading a compiler for every project is only ok if you have a solid bandwidth... I doubt bandwidth would be an issue, as you could just cache them, but I still think it's a bad idea to have the compiler version be determined by the project. It would just result in an endless churn of "use new compiler" updates to the project files, and if on top of that you're going to have output from different version compilers being linked into a single executable it sounds like a veritable rat's nest of hard to debug problems.
If you only use rust versions then that means breaking changes are unconditional in new rust versions, so old code won't work with new compilers. Breaking old code is bad; that'll certainly negatively affect rust adoption. Epochs allow opt-in to the breaking changes, while still allowing old code to benefit from all the backwards compatible changes in new rust versions.
Yeah, if you look at python they're trying to push people away from logic in setup.py (and eventually setup.py entirely) while the JS community moved from gulp to webpack to get away from logic in build scripts as much as possible.
&gt; And logging is de facto standard using a log facade (log crate) leaving the actual implementation up to me, which is miles ahead of some other "mature" languages (looking at you java and nodejs) Java has this. It's called slf4j. It's not ubitiquous so it needs shims for libraries that use java.util.logging or older logging frameworks directly. 
There don't seem to be any fully-featured concurrent maps. They all seem to have some missing parts, like lookup given a borrowed key.
Because [it's not supported by the `goblin`](https://github.com/gimli-rs/object/issues/44#issuecomment-355858376).
Perhaps [this](https://www.reddit.com/r/rust/comments/7ovgzx/how_to_parse_complex_urls_in_hyper_server/) recent question may be of help to you?
no
&gt; Did you try RegexSet? &gt; how will it help me?
I just signed up and will do a review sometime this week. 
yes, but it's abandoned
I can't understand the tests in there. if I have a url "/articles/:my_article_name123", how can I a) recognize it b)retrieve the ":my_article_name123" part? 
You can tunnel SCTP over UDP yes, but it's a different protocol number (132 instead of UDP's 17). You could definitely not use tokio of course! I think that it'd probably be easier as a prototype to do so off the bat, then worry about async after.
And what language has a good GUI? The answer is simple - none. That's why electron exists. The best option for now is Qt, but it's C++ or strange QML.
The ASF is more than a couple of individuals. It's a whole foundation with a strict governance who gives a framework for new projects. It started off with people developing a replacement NCSA HTTPd (I believe as part of their company-work). ASF is though a very good community on how to build a really good community. That being said most open source projects start with a couple of individuals. I believe that having companies adopting Rust will lead to more individuals contributing. It's then a virtuous cycle. The hardest is to kickoff this cycle. 
I18n is certainly something I forgot to mention! I have to look closer at Project Fluent. What did you mean by discoverability and packaging?
A few poorly put together rumblings: ------ &gt; Languages features. The language is good enough. Is Rust a complete-package at this point? I wonder what paradigm of language Rust is, because at this point it looks "a bit of everything but nothing full". It's linear-procedural, (like C but without its unlimited freedom of raw pointer manipulation), tries to be functional (but missing many features like dependent types, higher kinded types etc) plus I don't think Rust is a "functional language" in traditional sense, structural (not really, because it has no inheritance, but has traits [but many people still can't get used it](https://hackernoon.com/why-im-dropping-rust-fd1c32986c88)) etc. Does Rust put emphasis on template meta programming? I don't think so, it doesn't have constant functions yet. I think there are *many* people waiting for Rust to have some features so they can dive in and dive deep. If you look at successful languages (C, C++, Java, C#), they put emphasis on a specific language paradigm. It enables users to delve into the language. Supporting a paradigm fully means that a language is "full" in a sense. In short, since Rust is not sold on a particular paradigm, it's far from a complete package. &gt; Desktop GUI. That will come from the community too. Nowadays 90% of GUI are web or mobile. Translation: Yeah, we lost to C++/C# in this. And how is desktop GUI a niche while web frameworks aren't?
&gt; It means a new Rust project using the most recent epoch will not be able to use a library which use catch as an identifier The RFC explicitly says that a way to solve this is by importing the keyword as a different identifier: use old_rust_library::catch as catch_; 
Discoverability: It's not always easy to find the 'right' crate for a task. Packaging: Getting applications/libraries written in Rust deployed on an arbitrary system in a trusted, reproducible way; we need to make it easier to distribute releases, and to work with distributions. I believe making it easier to create dynamically linked binaries is an important step here (but that would require some ABI stability).
Yep my bad, turns out I was wrong :) Let me edit and thanks for this precision
I am a little confused #[proc_macro] pub fn proc_test(input: TokenStream) -&gt; TokenStream { println!("{:#?}", input); let expanded = quote!{ pub struct Hello; impl Hello { pub fn hello(){} } }; expanded.into() } . #![feature(use_extern_macros)] extern crate proctest; proctest::proc_test!(); fn main() { Hello::hello(); } Err: error[E0433]: failed to resolve. Use of undeclared type or module `Hello` --&gt; example/src/main.rs:6:5 | 6 | Hello::hello(); | ^^^^^ Use of undeclared type or module `Hello` cargo expand: #![feature(prelude_import)] #![no_std] #![feature(use_extern_macros)] #[prelude_import] use std::prelude::v1::*; extern crate proctest; #[macro_use] extern crate std as std; pub struct Hello; impl Hello { pub fn hello() {} } fn main() { Hello::hello(); } I feel like that I am missing something because the expanded code looks correct. Maybe `cargo expand` is not correct anymore?
There will be mechanism to deal with this. For instance : - You can extend use to allow `use a::catch as a_catch` - You can, like backquotes in Scala, add a syntax to force to recognize an ident
If you compile with panic=abort, yes it is solved now
I agree that we need better official resources for intermediate level devs. The Rust Book is great for learning the language, but I've found that if I want to get proficient in Rust and learn about more advanced techniques, I have to scour through random blog posts, reddit threads, forum threads, ask on irc, read other people's code to figure out idioms, etc. I would love if there was more official documentation on how to go from being someone who knows how to use Rust to becoming someone who is really good at Rust. Documentation on more advanced topics feels quite hit-and-miss right now.
Instant segfault and worse compile times, sorry, this isn't usable for me yet. stable = rustc 1.23.0 (766bd11c8 2018-01-01) beta = rustc 1.24.0-beta.1 (5b496b726 2018-01-02) nightly = rustc 1.25.0-nightly (b5392f545 2018-01-08) rustc | incremental? | LTO? | ThinLTO? | compile time | runtime ---------|-----|------|------|--------------|-----------|--------- stable | no | no | n.a. | 328.62 s | 15.416 s stable | yes | no | n.a. | 308.20 s | 15.784 s stable | no | yes | n.a. | 444.48 s | 15.152 s | | | | | beta | no | no | n.a. | 371.63 secs | Invalid opcode beta | yes | no | n.a. | 375.25 s | Invalid opcode | | | | | nightly | no | no | no | 366.66 s | Invalid opcode nightly | yes | no | no | 386.14 s | Invalid opcode nightly | no | yes | no | 487.30 s | Invalid opcode nightly | yes | **no** | **yes** | 402.21 s | Invalid opcode nightly | **no** | no | **yes** | 372.38 s | Invalid opcode I did not test the other beta builds, because they'd probably have invalid opcodes, too. So yeah, this is why I stick to stable, sorry. Seems like incremental building makes everything slower. In fact, ThinLTO with incremental build is slower than the default, stable rust compiler. 
You did not understood what I mean. I'm just telling you can make a Rust 2.x that still support 1.x code by default like it is planned to do for epoch. Cargo would set the by default compatibility flag to the maximum major version for new projects.
that's what I want. but again -- it seems abandoned. it's risky to use it.
Good points :) I'm especially in agreement with that last point about moderation. I'm thrilled to see Rust's community growing, but I really don't want that to come at the expense of the positive/friendly atmosphere that we currently have.
Yep you're right. I probably should read the discussion about that in the RFC comments.
Would you be able to provide a link to the repository so the compiler team can try to reproduce the issue? I've been using Rust for over a year at work and never had an issue where the stable or nightly compiler will generate an invalid opcode...
This crate is the reason why ripgrep doesn't suffer nearly as much of a performance loss when counting lines (super common use case) as GNU grep does. :-) Thanks /u/llogiq and /u/veedrac!
&gt; One of my big concern when writing a real world app is to be able to plug any database to it, not only because I want to be portable, but because my in-memory database for my tests will be different from my prod database and I want to avoid nasty surprises. You run your tests against a different database to production because you want to *avoid* nasty surprises? How do you optimize your queries without the ability to hand write SQL or run against the actual database? This sounds crazy to me.
Maybe it'd help to introduce bounties, so people are motivated to review the code.
I have a piece of code which takes an `&amp;[T]` (with a type bound specified in a type clause). If I want to pass an immutable empty slice, I have to add some type annotations. Thinking this through, it sure seems a waste... why does the compiler need a concrete type in this case?
&gt; I personally believe people will most likely use Typescript... On top of that Typescript is much more useful when you also want to target browsers that not yet support wasm. Typescript is not usable in many contexts where a Rust library that can be compiled to native and WASM can be used. &gt; I also believe that the wasm is far away from being usable. I consider it pretty far ahead. The danger here is if we don't properly build on what the LLVM gives us, we'll lose against our competitor on the only ground where we can compete without them having the advantage of age.
It's not a public repo, and even if it were, that wouldn't help you because in order to run the application, you need a large amount (13 gigabytes) of input files to run the application and those files are not openly accessible (anymore). The application takes SRTM tiles and stitches, shades and reprojects them into an image. SRTM files were available at https://e4ftl01.cr.usgs.gov/SRTM/ - but that server is misconfigured and there doesn't seem to be a mirror. I am currently rather tired, sorry. I am sure someone else has already notified the compiler team. segfaults and opcode issues happen rather frequently (for me, at least). It hasn't happened to me on stable yet, but I've had segfaults / crashes on nightly before (which compiled fine on stable). I can try to grab the files needed to run the application (you don't need the whole 13GB, just a subset) and make them available via dropbox or something. What worries me is that the beta compiler shows issues, I did not expect that. I am not sure if I should make a github issue or just mail someone from the rust team or ask them on IRC. You can argue that it's stupid to run tests on private projects (because then nobody could reproduce it), but I didn't have any other binaries that I could test, my public projects are all libraries.
[This project](https://github.com/alexcrichton/cargo-vendor) right? This looks like it might just work, I'll have to investigate further. Thanks for letting me know! 
What's the point of exposing `naive_count_32`?
What's the point of exposing `naive_count_32`?
Thank you for the kind words.
Paraphrasing from https://github.com/nikomatsakis/rust-memory-model : &gt; A "memory model" tries to define what kind of aliasing and accesses unsafe code can perform (this in turn implies limitations on the transformations and optimizations the compiler can do).
Amazing :) I did not know that. Then I would say the project tooling point is covered other than outstanding chats on whether rustup should be merged with cargo. The docs are here https://github.com/rust-lang-nursery/rustup.rs#the-toolchain-file
Nor are `impl Trait`, trait specialization, ATCs, the `!` type, etc.?
An illegal opcode exception is probably due to a call to `std::intrinsics::abort`. You can run the program under a debugger (preferably using a debug build) and obtain a stack trace, which should indicate where the call is coming from.
I'll try to narrow it down (where the wrong opcode is generated) and make a test case available later. Please also note the dates - the bug must've been introduced between 01.01. and 02.01.2018. Beta and stable are just one day apart here. 
I'll try to narrow it down (where the wrong opcode is generated) and make a test case available later. Please also note the dates - the bug must've been introduced between 01.01. and 02.01.2018. Beta and stable are just one day apart here. 
that but what i really meant was https://github.com/alexcrichton/cargo-local-registry
Run `cargo vendor`, copy the whole thing over. done.
Thank you very much !
Web Development in Rust seems like a total red herring. Most web development gets done in high level languages because writing code faster is better than writing code that is super efficient in 99% of cases. Rust needs to focus on being the language of choice for settings where performance is key.
It doesn't. It only looks at `\n`.
please file a bug (against cargo)
It's still "good enough" for many people. I've never used any of these features, nor particularly wanted to. Well, if I wrote more complex futures stuff, I might like `impl Trait`, and I certainly want to use libraries using procedural macros, but I could live with the language today, as is. I still think adding these features is good, but not nearly as high priority as macros 1.1 was.
On the paradigm point, it seems like emphasizing a certain language value set trumps picking a paradigm. The success of JS isn't tied to a classic paradigm- they made useful features, made sure they worked together, and made sure the language stayed out of the way of programmers.Rust has a capable feature set that upholds our values of security and performance- let's focus on preserving that
Exactly. That, and the fact that Rust has a really solid foundation with WebRender, makes GUI a fantastic opportunity for Rust adoption. Something along the lines of Flutter (but supporting desktop OS's) would probably see a big take up.
&gt; For me the whole selling point of Rust vs C and C++ is memory safety. The whole ecosystem is based on safe abstractions around unsafe code but our best answer to "are those unsafe abstractions correct" is "there is no way to know but they work for me". I'm on a bit of a crusade against "it seems to work" at the minute so I agree with this wholeheartedly. I like all of your goals, although I feel that the 2018/2019 timings are maybe a bit optimistic.
I'm in the same boat!
&gt; undefined behavior detection: 100% reliable detection of undefined behavior at run-time What would this look like, roughly? Would one partition the universe of `unsafe` blocks into trusted and untrusted subsets, and then have the compiler emit a call to panic every time it enters an untrusted `unsafe` block? 
&gt; 1) know it exists Generalised point: this is a way bigger hurdle than people give it credit for
Right now this works on top of miri (MIR interpreter) which has been recently merged into rustc. It is like a virtual machine that you can run rust MIR code on and traps when this code invokes undefined behavior. So in 2018 we could improve this to be able to easily run your tests via `cargo test --miri` on it to check if they invoke undefined behavior. Ideally in the future beyond that one should be able to compile all code with instrumentation so that if the code invokes undefined behavior at run-time it just panics instead.
It does routing for you in a manner much more similar to your original post than is possible in hyper alone.
A QR library, then...? I'm afraid I didn't quite understand what you meant, aside from noting how hard building reusable software is. :)
Beta is a separate branch, so the Nightly of the same date can have many changes from a given Beta version. To find a compiler bug, bisecting Nightly versions can be a good start. Then `rustc -V` shows the respective commit hashes, and you can build a URL like https://github.com/rust-lang/rust/compare/827cb0d61...560a5da9f
Oh you meant beta vs stable, not vs nightly. But it’s still two separate git branches that can have more differences than the date suggests.