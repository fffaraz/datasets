You might find [capnproto-rust](https://github.com/dwrensha/capnproto-rust) to be useful for serialization. It's designed to let you read and write your data extremely quickly and in a type-safe manner.
&gt; Is there a good intorduction to these 'a lifetime specifiers? Maybe [this part of lifetimes guide](http://static.rust-lang.org/doc/master/guide-lifetimes.html#returning-references). It doesn't mention lifetime parametrized structs but covers all the basics. &gt; Is it possible to take another type parameter and parametrize the u8 out, so I could use it also as a helper for u8 to u64? Of course, why not? Just throw in another type parameter and adjust `len` calculation. And if you plan to return mutable slice, better mark the function as unsafe.
Lifetimes in the type system don't affect the runtime behavior, they're just part of the static checking at compile time. Consequently, `copy_lifetime` doesn't actually *do* anything, it's just a way to force the compiler to accept your code when you know more about lifetimes than it does. Values living in local variables get dropped and disposed of and whatever at the end of their scope, but that's just the compiler inserting a bunch of destructor calls or whatever at the right places, there's no reified lifetime data structure that manages that.
Really? Do lifetimes really not affect where the destructor calls are made? So is it then categorically impossible to do something like: { let y:&amp;int; { let x = 0; y = &amp;x; // do some magic here with lifetimes to extend the lifetime of x } println!("{}", y); } To extend a local variable outside its own scope? (or have a local function variable exist after the function returns?)
Yes. The lifetime system is a compiletime check to ensure code like that doesn't compile, not a mechanism to somehow enable it.
Objects returned from functions like those `T::new()` functions are moved by value, not via a pointer with a lifetime on it. Variables that are moved out of won't have destructors called on them, but that's not something to do with &amp;'a pointers. `~T` variables work just like `T` variables with regards to when the destructor is called, there's nothing fancy going on. `*` pointers don't cause destructors to run or not run, just like `&amp;` pointers don't. A struct `X` with a `&amp;Z` in it is never responsible for cleaning up that `Z`, rather the lifetime system ensures at compile time that the `Z` that is pointed to will outlive the `X` by refusing to let code compile where that isn't obviously true.
&gt; I guess my real question is; if lifetimes don't actually govern when garbage collection is done, what does do that, and how does it work? Rust does not have a garbage collector. When a variable goes out of scope, the destructor is called on the value it owns. If ownership is moved from a source to some destination, there is no destructor call on the source. Lifetimes are entirely stripped out after type-checking and have no runtime effect.
Reddit does vote fuzzing for whatever reason, there wasn't necessarily a down vote.
This is obvious. It's much less obvious when the structure contains pointers, eg. &amp; and ~ values. For example, you might easily (I was...) be fooled into thinking a &amp;'a pointer would be destroyed when z when out of scope, if Foo had a &amp;Bar in it and the lifetime on that was 'a where 'a was the lifetime on z (ie. Foo&lt;'a&gt;)
Pointers are not special: some of them (partially) own their contents, others do not own their contents, and this dictates whether destructors are run when the pointer value itself goes out of scope.
so *some* pointers *are* special. That's the point... :)
If you mean "some pointers don't own their contents" then yes, some are special.
Ah yes, that is correct. Personally I'm quite glad for the drift towards C++ in some aspects of the semantics and philosophy.
Sadly, this will uglify most of my code ._.
Is there going to be a nice way to sugar this into a decent shorthand? This is going to be quite infernal for string-heavy code, and while the explicitness is appreciated, neither t the syntax nor template alternatives look appealing to the eye.
http://www.reddit.com/r/rust/comments/2340zb/rustdev_removing_foo/cgt7yoo
Rust seems to be getting rid of more and more syntactic sugar. Part of me likes the elegance, part of me hates how each week rust gets more verbose in the name of simplicity.
I see it as a cycle. 1. Special cases 2. Simplify 3. New sugar We've been going from 1 -&gt; 2 a lot lately, but that's what _enables_ going from 2 -&gt; 3.
Well, as long as there is hope of going towards 3 in due time that makes me happy :). It seems people have different feelings on code aesthetics. Some absolutely love the ruby style approach, where clarity and api-level elegance is above all else. Others have been burned by magic/hidden behavior by language-level abstractions in the past and thus try to avoid it. Or they just don't care either way. I lean more toward the ruby side, but I absolutely would not want to see Rust give up any of its predictability or pragmatism. I just think there is a lot of room to optimize for terseness, reduce duplication, and simplify common cases in the syntax sometime in the future.
By including 'let' you can quickly tell a declaration from an assigment. Also your proposel would make it hard to do this: let x = 5; { let x = 4; // shadow original x doSomethingWithX(&amp;x); } I believe similar proposals have been suggested and rejected in the past.
I don't know the exact rationale behind the 'let' keyword, but consider this: In C, there is no 'function' keyword so you just write `void foo(void)`. This is a problem because you can't search for functions easily. In Rust, we have `fn foo()`. This makes it possible to search for all functions. The same could be said about 'let' statements.
True. I feel like I'd be leaning on `fmt!` for a side effect, though. It works, but it's not obvious what I'm doing when I write `let s = fmt!("foo");`. A newcomer would see that pattern everywhere and wonder what formatting was being done to `"foo"`.
 mut x := 5; // declare x x = 10; // Change x's value { mut x := 4; // shadow original x doSomethingWithX(&amp;x); } I'm probably missing something.. Do you mean parsing is more difficult?
I don't disagree, but it seems to me like everything that goes the way of sugar seems to be getting shoved into macros. I think Rust macros are great and strike a fantastic compromise, but it would seems that in order to have greater API-level clarity for some pieces of code you need to rely on macros just as much as regular methods and language functionality, and seeing '!'s everywhere does not really clarify things much at times. Without wishing for LISP-like special forms, it would seem to me that some facilities could be made to facilitate user-level memory management, or perhaps new literals for frequent use cases might appear. At least as far as I think, it wouldn't be too bad if strings had nicer-looking constructs. From the current look of the language it would appear to me that pretty soon people might end up targeting Rust as a language with other higher-level languages, much in the way or Nimrod-&gt;C, Xtend-&gt;Java, Coffesscript-&gt;JS. I'm not sure that's the ideal path however.
Where did the distinction between 'mut' and immutable go?
I see what you're saying, `let` is easier to search for. But is `foo := val` and `foo: T = val` much harder? With my brief and naive look at the [rustc tokens list](https://github.com/mozilla/rust/blob/0.10/src/libsyntax/parse/token.rs#L44-L105), it seems like you just search for an IDENT followed by a COLON, optionally followed by an IDENT that corresponds to a type, followed by an EQ. Is that already too much computation? EDIT: I'm a dummy, I see what you're saying. Grepping for `let` is easy. That sounds like a counter argument that kills it. I'd much rather type `cat main.rs | grep let` than something like this `cat main.rs | grep "[a-zA-Z0-9_]\{1,\} *\: *[a-zA-Z0-9_]* *="`
Woops, you are right. I edited. Still a rust noob :P
&gt; From the current look of the language it would appear to me that pretty soon people might end up targeting Rust as a language with other higher-level languages, much in the way or Nimrod-&gt;C, Xtend-&gt;Java, Coffesscript-&gt;JS. I'm not sure that's the ideal path however. That would be very bad. I think that the `!` syntax for macros is important for understandability of code. When reviewing systems code, you want to know whether something is a special user-defined form or whether it's something natively understood by the compiler. This is why people use `ALL_CAPS_MACROS` in C. Anyway, if we really felt that string buffer literals were important enough to bake into the language, then we could do that. But such syntax is not needed in Java or C#, so I don't think it's likely to be true for Rust either. In any case, I think the syntax for string buffer literals should *not* sacrifice compositionality: having `~"foo"` mean something different from `~("foo")` is undeniably a wart.
I don't think it'll be that bad for string-heavy code. Java and C# also have a string and string builder separation, and nobody has asked for separate syntax for string builder literals.
I really think that this also has to do with the over-usage of `~str`, historically. People use features that exist. Once it's gone, they won't use it as much, and so new code won't feel the same pain as existing, ported code.
A lot of string heavy code will wish to be using `StrBuf` anyway.
Assignment in `let` is actually pattern-based, i.e. `let (foo, ref bar, Struct { baz, .. }) = ...;` is perfectly ok, and keeping an LL(1) grammar without `let` while retaining the patterns is a little tricky.
I think this is a fundamental problem with our `~` syntax: it's just too easy to use. `Uniq&lt;T&gt;` would be much "nicer" for this reason.
I think this is accurate. When I was starting out, I got used to seeing compiler warnings about the `'static` lifetime when I'd pass `"foo"` to a function instead of `~"foo"`. Naturally, I got in the habit of writing `~` everywhere. It wasn't until `~` was going to get cumbersome that I realized there was a reason to avoid it in favor of `'static`.
Which warnings?
Er, "warnings" was a poor choice of words. I meant I'd call a function that asked for an owned pointer and I'd see an error about passing a static string. I formed the habit out of poor understanding, not due to issues with the compiler's output.
Hopefully there should be a rust 1.0 within a year. I'd say the majority of the language is within a first approximation of what it will look like at 1.0. You will need to make changes each time you update your compiler though. If you're writing on the order of a few thousand lines of code, it should be alright to start now. If you're going to have fifty engineers writing a million lines of code, I'd be more hesitant. A large portion is also your tranquility upon encountering API changes, compiler bugs, and features coming and going.
Should I stick to one of the versioned releases like 0.10 or should I stick to nightlies? Are the nightlies particularly stable? Also will there be a 0.11 before 1.0? 0.12?
AFAIK, Rust master is very much stable. I don't think anything gets pushed without passing the test suite. I personally enjoy riding the wave of nightlies. But every week or so, there's usually some change that breaks my code. I don't think it's ever taken me more than 10 minutes to diagnose and fix. It really just depends on your use case and your willingness to update your code when you install a new nightly. But nightlies are definitely **not** unstable in the sense that they're buggy or untested.
The `let` key word is important because it is more powerful than just a variable declaration: it is a pattern binding. As /u/dbaupp [says](http://www.reddit.com/r/rust/comments/23489q/variable_declaration_syntax/cgtem1v), `let (foo, ref bar, Struct { mut baz, .. }) = ...;` is much harder to parse without the `let`. That said, I do prefer `:=` for assignment.
Certainly I wouldn't want Rust to be just another ML -- I use a combination of OCaml and C for a reason, but C is comparatively unpleasant. Phantom types and Monads... great. GoF patterns out of sight, also great. That's encouraging to me. What has worried me is when I see the occasional code snippet which looks like C++ with iterators and mutation, using a slightly different syntax. Even if that's from people new to Rust, I'm concerned about a mass of C++ programmers creating a natural inertia toward "a better C++" because that's familiar. Rust can do better than just that, and I hold out hope for it!
This is a situation where you want to use the `std::mem` methods. In your case, you can safely swap the pointer with: *self = Node(new_value, ~mem::replace(self, Nil) We used to have a singly linked list in our collections library, but we ended up removing it in [#13183](https://github.com/mozilla/rust/pull/13183). We removed it because the old `list` used the deprecated reference counted pointers and no one was really using it. I did explore porting it over to using owned pointers, but we decided that `Vec&lt;T&gt;` provides nearly all the same benefits with a lower cost, so it was rejected. If you're interested in checking it out though, you can find it in [#13011](https://github.com/mozilla/rust/pull/13011). It has a pretty extensive API that could help you out.
I think /u/mcpherrinm summarized the major points well, so I'll give some more information. I've managed a mid-sized project (some 10K lines of code) myself starting with Rust 0.5. There were many breakages so far, which can be further classified as follows: 1. Language syntax changes: For example, `#[asdf];` moved to `#![asdf]`. This is the easiest thing to handle, and will continuously occur til 1.0. Fortunately for us, Rust compiler is developed in Rust, meaning that there would and should be a clear migration path (i.e. the old code *should* fail to compile, so that the change is easier to verify). 2. Language semantics gets removed: For example, the removal of the built-in managed pointers (`@`). This can be subtle to handle, and the migration path depends on the changes. Personally the removal of managed pointers was the biggest deal and would remain as the biggest deal in the future (hence the example), and I (finally) have to learn about `Rc` and `RefCell` over the course. I expect big changes can still occur, but much less frequently (say, once a month). The next biggest change would be the removal of growable `~T` (use `Vec&lt;T&gt;` instead) and `~str` (use `StrBuf` instead). 3. Language bug is fixed: This is very subtle. You might have relied on the unsafe feature which gets accepted due to the bug. This kind of breakages was very common til 0.8, but it became virtually absent nowadays for me. Your mileage may vary since my coverage is not complete, but I think it is the least concern now. When in doubt, ask around. 4. Standard library naming changes: Yes! We are still bikeshedding for names and they are not yet set in stone. For example, `std::vec` moved to `std::slice` (and `std::vec` is reused for newer `Vec&lt;T&gt;`). This is akin to the language syntax changes, but will continue to occur *after 1.0*. (Remember 1.0 is for the language stability, not the library stability.) 5. Standard library design changes: Sometimes the standard library gets redesigned for the better cause. For example, once upon a time `Vec&lt;f64&gt;` can be sorted with `sort` method, but since `f64` has `NaN` which cannot be compared, now you have to use a custom compare function with `sort_by` method. In many cases you can keep them up easily; in some cases you may have to copy the older definitions somewhere (yes, I've done so several times) and fix them later. 6. External library doesn't keep up with the master: Well, this is inevitable. I personally try to handle breakages on my libraries (e.g. rust-encoding) as fast as possible, but not always. You are recommended to fix the bug yourself and send a PR; it is also a good way to contribute! 7. Compiler internal changes: This occurs when you are trying advanced features like [externally loadable syntax extensions](https://github.com/mozilla/rust/pull/11151). If you are trying them, keep eyes on the compiler changes as well; I think the strategy here is mostly same as that of external libraries. 8. Also, you'll want to periodically check your code to remove any redundant workarounds introduced by the series of migrations. This actually makes me happy ;) To the end, I think 0.10 is a good starting point since the main language design is very solid and most features wouldn't go away (they can still move to the standard library, however). You still have to deal with weekly, or possibly daily breakages no matter they are small or big, but it became reasonable for mid-sized projects now. [1] You are strongly recommended to use the official nightly version [2] and [rust-ci](http://rust-ci.org/) to track the recent changes to Rust. [1] Larger projects like Servo depend on the particular development version of Rust and update to the newer version much less frequently. Remember that Servo consists of some 100K lines of code, which is the largest of this kind. (I think my project is still in the top 10, however.) [2] There are three different versions available: The "master" version is the most recent development version updated several times a day and yet still very stable (since it should pass all the available tests at least), but you need to compile them yourself. The ["nightly" version](http://www.rust-lang.org/install.html) is a pre-built snapshot of recent master versions, it can lag behind the master but is generally good enough to track the master. The point release is just a rebranded version of a particular nightly that gets released every 3 months, and no different from nightlies except for the extra verification to avoid the bad PR, but you shouldn't install it.
Wow! Thank you for that highly informative wall of text! This makes me super excited to get started on a new language :D
Wrong Rust, man.
What comes after the `let` keyword is not necessarily just an identifier; it is actually syntactically a pattern (it must be an irrefutable pattern---that is, one that in a match would be on its own an exhaustive pattern). Given a `struct S { foo: int, bar: bool }`, you can write `let S { foo, bar } = an_s_value;` and lo! `foo` and `bar` are bound locally; or given `enum E { V(int, bool) }`, `let V(foo, bar) = an_e_value;` and lo! ditto. The reason all this is important is that the Rust grammar is consciously `LL(1)`---that is, by looking one token ahead, you will be able to know for certain what you are parsing. If the `let` keyword were removed, there would be ambiguities that would require you to look ahead to the `:` or `:=` before you would know whether a `V(foo, bar)` was an expression or a pattern. This is something we don't want. We value the simple and predictable nature of the grammar. An `LL(1)` grammar will tend to be easier for humans to read also, for much the same reason: you can very quickly parse what you're dealing with. `let` is obvious. `let` is good.
I'm a Rust beginner but I wouldn't wait. The language should be pretty stable right now (even if it's not v1.0.0 yet) and the changes are not so big that you have to wait and relearn everything when it's final.
That's awesome, exactly what I was looking for. Very elegant! Even if there's no need for the linked list in the standard library, it could be worth adding some of it to the tutorial. I found it quite instructive :)
Generally I do a lot of moving of `~str` in `enum`s, so for test I need to compare an option wrapped around result like this: assert_eq!(Some(Ok(Baz(~"foo")), pull_stuff); assert_eq!(Some(Ok(Baz("foo".to_owned())), pull_stuff); I already asked on StackOverflow if there was a an alternate way to move string in enums between two structs without using `~` pointer. Will this change allow to move strings in enum like we can do with char values?
([We actually have a Rust-specific description of our stability indices](http://static.rust-lang.org/doc/master/rust.html#stability).)
Under DST, won't just `~*"foo"` work for converting `&amp;Str` to `~Str`? I am wondering why string literals are planned to have type `&amp;'static Str`, not just `Str`. I think it would be more consistent with how we treat literal slices, and simpler for newcommers (reference in type won't appear from nowhere, like now). And `~"foo"` would work without parser magic. Only downside is writing `&amp;` in many situations, but there is autoboxing for methods and maybe will be for arguments too.
I hope you dont lose the ~T notation. ~ meaning unique ownership and being easily composed with other syntax forms is/was really neat. Its not just the characters, its the lack of nesting. If you do start losing ~... I really hope ~ and even @ could be re-introduced as user defined shortcuts (per crate?per file? per module?) more like macros, shorthands for whatever you want.. ) The convinient syntax counts for a lot, its probably why I've never enjoyed the standard libraries in C++, but I'd enjoyed them more in Rust. You can add static analysis to C++. Platform vendors add 'restrict' as a practical way of acheiving full optimization where its needed. You have powerful IDE's helping to manage its 'corner cases'. clang has made leaps and bounds in tooling. What you *can't* do with C++ is make the modern style look &amp; feel elegant, because all the decisions for symbols and syntax were taken back in the 1970s for low level code with raw pointers and for loops/imperative incrementors .. and the high level language has been shoe-horned back into that. didn't do sugar get removed because some uses had to be removed,over details about owned closures or something .. now there's talk '~ isn't being used' ...but you had to add a 'proc' keyword for 'owned closures' - i'm sure between do/for/~/proc could you could get the right closure in the right place. 
seems logical to me, people can wrap the standard libraries to insulate themselves from changes, if they really need to . what they can't do is modify the semantics and syntax. I see a big dividing line between standard libraries and language 'engine'.
Rust noob here. So how should the following be written afterwards?: fn foo() -&gt; Option&lt;~str&gt; { if bar() { return Some(~"Error, bar invalid"); } let baz = qux(); if baz != 0 { return Some(format!("Error, baz expected to be 0, but was {}", baz)); } return None; } Just also use `format!` for the first string? Or `"...".to_owned()`? Or is there an altogether better way to do something like this?
&gt; meaning unique ownership `~` doesn't mean unique ownership. It means "*pointer* with unique ownership of its contents", as compared to pointers like `&amp;` which don't own the data, and `Rc` which have shared ownership. That is, `x: ~T` and `x: T` are nearly identical semantically (the `T` is owned by `x` in both cases), except the former is guaranteed to be pointer sized. In most cases, `T` should be preferred to `~T`; the brevity of the `~` syntax leads to it being overused.
"In most cases, T should be preferred to ~T;" I know its a pointer, I dont always write every detail in a post.. I'm speaking from the perspective of having done low level programming for many years. The times when you do need pointers and allocations, ~ makes it easier, and makes it easier to write code in rust compared to C and C++. Option&lt;~T&gt; where you want to return a raw pointer in C++ and rely on the caller checking if it was valid.. and so on. Pointers get composed in many ways. The more I can compose easily on the fly, the less convenience functions I have to write(reinventing the language, makign my source incompatable with others), the less I have to argue with other coders.. if T was enough vs ~T they wouldn't have invented smart pointers and people wouldn't have moved from C to C++ " the brevity of the ~ syntax leads to it being overused." .. isn't that a lack of understanding rather than the fact its short. '&amp;' is short aswell :) and of course no sigil is even shorter. I dont think merely having to read and type more is going to educate people coming managed languages about pointers vs stack. error messages are a better place to educate people IMO, and the language does seem to help you a bit already ('warning unnecasery allocation' etc)
I said "in **most** cases". Not all. There are certainly many places where `~T` is good and in fact the correct choice; however, having helped many people with their Rust code, most uses of `~` I see are not necessary. &gt; I dont always write every detail in a post Many people assume that `~T` is the way to get "unique ownership", not realising that `T` has the same "unique ownership" properties, so I wanted to make sure it is clear to everyone involved (you, and anyone reading) that `~` is not some magical "ownership" type. &gt; Option&lt;~T&gt; where you want to return a raw pointer in C++ and rely on the caller checking if it was valid.. and so on. And how many of those are just using the pointer to represent an optional return value? i.e. where `Option&lt;T&gt;` is the appropriate Rust translation? (Maybe not many, but I'm sure there's a few.) &gt; I dont think merely having to read and type more is going to educate people No, of course it's not going to educate them, but it is going to stop people just saying "throw sigils at the compiler until it's satisfied"... at least it will leave them throwing the mostly-harmless `&amp;` sigil (no surprise heap allocation). (And people do say that. Even those with experience in languages like C etc.) --- And anyway, "removing" `~` would just be removing the syntax, there will always be an equivalent type (e.g. the move from `~[T]` to `Vec&lt;T&gt;`, a possible replacement of `~T` with a 100% equivalent `Uniq&lt;T&gt;`).
"&gt; And how many of those are just using the pointer to represent an optional return value?" i.e. where Option&lt;T&gt; is the appropriate Rust " I'm hoping eventually there will be a version of enums which can allocate just the size for the required variant. ... and at the minute, isn't embedding a ~T a possible workaround for the enum padding eg enum Something { Foo(a,b,c), Bar(d,e,~(f,g,h,i,j,k)) // now Bar doesn't pad sizeof(Something) out } having a load of optional pointers is a very convinient reasonably efficient pattern, and of course if you can avoid it great, its usually the job of 'preprocessor tools' (asset conditioning) to simplify everything out to reduce the amount of pointer chasing/allocs the runtime has to do, but preprocessor tools want to share datastructures with the runtime - and you might move code back and forth - so it's great when you can use the same language for both. you dont always know before you write something if its going to end up being perfomance critical. 80 20 rule. I wonder if HKT will make it into the language eventually, that might have interesting possibilities for refactoring code.. making it generic over pointer types..
You do realise that Rust will always have a type equivalent to `~` (i.e. pointer-sized with ownership of its contents), right? No-one is proposing removing the functionality. &gt; I'm hoping eventually there will be a version of enums which can allocate just the size for the required variant. This gets weird, e.g. changing which variant was stored in a `~MultisizeEnum` (i.e. to do `*ptr = NewVariant(foo, bar)`) would require a realloc in general. ... Anyway you didn't explain how this relates to the `~` *syntax* in particular, so mentioning those enums was a complete non sequitur?? (As with the rest of your comment: I don't see how it relates to the `~` syntax.)
&gt; '&amp;' is short aswell :) and of course no sigil is even shorter I missed this the first time around: it is *good* that `&amp;` and stack-alloc are short, since they're cheap and should be the default, i.e. the functionality a Rust user reaches for first, only falling back to `~` when necessary.
That would be ultra nice, I always get confused by ``FromIterator::from_iter`` and always try to call it on the "destination" type (e.g. ``Vec::from_iter(some_iterator)``, which blows up and annoys me until I remember that it lives on ``FromIterator``) I think the weird part is that these live on objects/traits, so you get the impression that you should call them on the trait implementor, it might be easier if they were freestanding function delegating to a trait method although I don't know if that's *possible*.
First off I wouldn't recommend 0.10. It breaks when linking with debugging enabled on programs using static variables. Personally I would recommend just sticking to master. Stuff *will* break. In some cases it might break every other day. But you will have to change that stuff anyway. It's better to do it a little bit at a time. Most of it's a fairly simple fix. There might be a few other annoyances, like when the debugging was broken for a few days or when the ~[] -&gt; Vec change occurred but they didn't update the libraries so warnings where everywhere. Worst case you can keep an older version around until the issue is resolved. Also most of the community are using master, so if what your working on it opensource others might come in and fix it for you.
&gt; Many languages use `:=` syntax, which makes it familiar. Besides Go, how many languages use `:=` for variable declaration? I don't know any. On the other hand, lots of languages use `let` (Lisp variants, ECMAScript 6, Haskell...) (Notice that I'm specifically talking about declaration, not assignment).
Another point: Most code is not performance-critical, because it executes comparatively rarely. It feels odd to make the easier-to-use constructs more verbose when more lines of code are free to use them without affecting performance much, and only a few hot loops in a program need to use the low-cost constructs to keep performance up.
Good post :) You can add a static analyzer to C++, c++14 has poly lambdas which are a nice step forward , you have powerful mature tools to deal with the language's complexity (jump to def handles all the overloading, you can hover on variables and see what the infered types are..), and a superior template system, and *huge* existing libraries.. .. so why am I here? A big part of why i'm looking into rust - as trivial as it sounds - is it just "feels fresh" compared to looking at C++ which I've been with for *so* long. Making compact syntax for what is basically the 'modern C++ style' is a big part of that.. in C++ the syntax choices are constrained around a foundation optimized for incrementing raw pointers in for loops, casting all over the place etc. The way I would word it is, these syntactic forms are very easy to compose. Between tuples, &amp; [] and ~ (and @..) you could save the need to create temporary symbols alot. .. throw the right characters around one or two identifiers and you're done. ~[~T] is one common type (I used to make 'PtrArray' in C++, long before i heard of boost ) . Option&lt;~T&gt; is another massively common case for me - useful for tree structures. Learning &amp; using new syntax is fun! ..wheras learning *vocabulary* is a pain , and gets 'bikeshedding' .. long arguments over what to call things. Whats too long, whats too short, whats going to be more common.. Forget anyone complaining about "multiple pointer types", if you dont *want* multiple pointer types, rust is not for you! And its not just saving characters, its' the amount of nesting involved.. ~ works so well prefixed. If I start making my own wrappers (OptPtr&lt;T&gt; .. PtrVec&lt;T&gt; etc), and instantly my code is split from the rest of the world. Usually i like to do this but i'm finding *so far* that i like the rust standard libs more than C++ standards -its possible the handy syntax is a big contributor. There are a lot of people saying "this isn't used much" which seems premature given the language currently has a small userbase. I build tree structures with potentially null pointers all the time.. I think "do" notation was removed prematurely. 'proc' was added for ~|...| if i've understood correctly (again, people saying 'you dont use ~', when you did something to remove a use case.. ) I think its easier to learn:- knowing that ~ is unique ownership modifier then you finding where you can apply it... than it is to learn the "proc" keyword, and I'm sure between for/do/~/&amp; you could have got the right behaviour). Seriously.. whats' the word "proc" got to do with ownership :) What I would say is, if the language gets HKT I'll care about this less, as we'd be able to write code that substitutes pointer and collection types and still interacts. Something else that would interest me more is if they added local type inference between private functions, which would help with refactoring code alot.. often you want to break things up just to reduce nesting, not because the function size itself is a problem. I also wonder if they would consider reserving ~ and @ as symbols which we can assign, almost like macros or typedefs.. although i'm not sure if thats sufficient for everything ~ did.. it was more of a 'modifer' for the next thing rather than an actual 'operator' or whatever. (Maybe i'm getting carried away but imagine if you had ? as a shortcut for Option&lt;T&gt; (its so common..), and [A=&gt;B] as a shortcut for hashmaps.. I suspect I risk trivializing the rest of my post with this, but you've got quick syntax for this in some other languages. The hashmap , certainly, has more scope for customizing, and I personally want parameters for vector namely selecting an input type, i would have u32 indices, and you can express more safety by specifying 'these indices are to be used in those vectors') Is that another route that could be taken.. generalize the use of a ~ modifer on a type..
&gt; ecause it executes comparatively rarely. It feels odd to make the easier-to-use constructs more verbose when more lines of code are free to use them without affecting performance much, and only a few hot loops Right. you dont know when you set out which parts are performance critical - you explore a problem, needing to just get things written quickly. But its still so useful to have the same language and interface as the heavy lifting libraries. This is probably why C++ is ubiquitous, not because everyone is *writing* performance critical code, but because they're *using* existing optimized libraries. I've heard that a lot from C++ people discouraging me from many of the C-like tricks &amp; habits i have.. Making code long winded just wastes time and effort that can go into exploring your problem to find better strategies where they *are* needed.
&gt; A big part of why i'm looking into rust - as trivial as it sounds - is it just "feels fresh" compared to looking at C++ which I've been with for so long. &gt; Learning &amp; using new syntax is fun! ..wheras learning vocabulary is a pain Totally agree, these are reasons which made me interested in Rust. &gt; And its not just saving characters, its' the amount of nesting involved.. ~ works so well prefixed. Good point! Forgot to mention it. I really hate nesting parentheses and `&lt;&gt;`s in C++, more than two levels of them make code almost unreadable. That's why i find Haskell syntax far more readable.
If people don't understand what ~ does and its costs in the first place then it doesn't make any difference how verbose the syntax is. Right now it is very simple and that's an advantage rust has over c++ and other languages. Let's keep it that way.
There's no serious discussion to remove `~`, I think you're slightly confused about the removal of `~str`, which _is_ happening. EDIT: When I say "serious" I mean "bors isn't currently working on a PR to remove `~`, not "nobody wants to see `~` gone.
There are _lots_ of random things that get talked about on IRC, but I wouldn't stress it until you see an RFC for the change. It's totally true that it's possible for `~` to be in a library only, and I'd actually prefer that, but it'd be a pretty huge change. `box` is a more generic way of putting something into a box. So let foo: ~int = ~5 and let foo: ~int = box 5 are the same thing. But you could also do let foo: Gc&lt;int&gt; = box 5 Does that make sense? This style will probably be _preferred_, but that doesn't mean the first one is going to be going away. That comment is a bit above my pay grade, sorry :/
I concur, like design patterns for more advanced programmers, linked lists are the basis on which students learn. That being said, maybe Rosetta Code is the ideal place to show-off Rust snippets ?
Sorry, I misspoke. I meant the @ syntax.
The tutorial in fact contains a linked list, as part of the introduction to pointers and ownership :)
&gt; There are lots of random things that get talked about on IRC, but I wouldn't stress it until you see an RFC for the change. It's totally true that it's possible for ~ to be in a library only, and I'd actually prefer that, but it'd be a pretty huge change. That's a huge relief, that the fate of `~` is not determined yet. But since there are plans to move unique pointers to library, I just wanted to say why I think it's not a good idea. &gt; But you could also do `let foo: Gc&lt;int&gt; = box 5` That works already? If yes, then wow! It's good to have generic way to box values, but I don't think that removing `~` operator is a good idea, and "`box` defaulting to unique pointer" seems to be unelegant.
Here is the [nicely rendered form](https://github.com/nikomatsakis/rfcs/blob/traits/active/0000-traits.md). Awesome job /u/nmatsakis â€“ this is super exciting.
&gt;&gt;@ was removed because it could be implemented as a library type, ok Agreed, it's definitely a step forward if the operator overloading is there to be able to implement custom type. But we've seen all that in C++ already, and there are static analyzers. Learning new names for 'unique_ptr' isnt' worth giving up an IDE for. What the language had done was learnt from ubiquitous patterns established in C++, and built them into the compiler in a more solid, elegant way (compile times benefit?) &gt;&gt;It also means that a new user will have less magic syntax to learn But I assert that the magic syntax was *easier* to learn. you learnt one symbol/idea and then applied &amp; composed in many situations. The problem with vocabulary is discovery - its hard to find the right name for something if you dont know it already. Yes, you can search for it once you've seen it but thats not the point. Syntax also leverages placement to clarify meaning, in ways that templates/functions can't &gt;&gt; is beginning to look very lonely alongside: dont forget 'proc', a keyword was added there too :) ~|....| -&gt; proc Much better IMO that you learnt '~' and '| ...|' then combine them as ~|...|. So all you've acheived is added the burden of learning new names, 'StrBuf', 'Vec', 'Uniq', 'proc', and soon 'box'. I can go "#define box new" "template&lt;typename T&gt;using Vec= std::vector&lt;T&gt;" etc and stick with C++ :) I wonder if there is any way this 'sigil' idea could be generalized and made part of the overloading system? Perhaps with HKT or associated types in future, "how is this type modified with this prefix", and at present, a trait 'MakeUnique' perhaps. Perhaps that would be the best of both worlds. 
Note the [section on coherence](https://github.com/nikomatsakis/rfcs/blob/traits/active/0000-traits.md#coherence): Orphan check: Every implementation must meet one of the following conditions: 1. The trait being implemented (if any) must be defined in the current crate. 2. At least one of the input type parameters (including but not necessarily Self) must meet the following grammar, where C is a struct or enum defined within the current crate: T ::= C | [T] | [T, ..n] | &amp;T | &amp;mut T | ~T | (..., T, ...) | X&lt;..., T, ...&gt; where X is not bivariant with respect to T So as far as I understand it, you would be able to define a linear algebra style of multiplication for pairs if either `Self` or `RHS` contained a type `C` that existed in the current crate.
&gt; Rust being powerful is of course awesome, but just because something is possible does not mean it should be done this way, just to demonstrate the power. Yes I agree with that. I re-worded my statement to emphasise simplicity and consistency. Demonstrating the power of Rust is a by product, it shouldn't be the main driver of a change like this.
Nice work!
It's not possible to have an unboxed `str` type in a local variable. Fixed-size arrays have a length as part of their type, but the size in bytes is not a very semantically sensible value for a string. I'm not sure what the syntax would be for it either.
&gt; I was a fan of sigils when I was first learning Rust, and thought it was a shame it got so much external hate ("ugh, line noise! my eyes!"). But I do think that library defined pointer types are far more powerful, and that we should be consistent. I agree with you that simplicity and consistency are good things to pursue, but I think that sometimes it's good too look from beginner's point of view. As you said, sigils are appealing to newcommers, and are easy to learn. I think that it's important not to make Rust look like another C++. Advanced programmers will see through sugar and understand simplicity behind it, while beginners could look at simple and easy to learn part of language. Pursuing simplicity can lead to something like Lisp, which doesn't have so many users, because users love sugar. I personally won't stop using Rust if every feature moved to library, but the lack of sugar may scare newcommers. And I think sometimes it's worth to compromise in favor of users.
Rust needs a generic syntax for making a memory allocation and storing the result of an expression there. The `box` syntax is *necessary* because there are many smart pointer types. Replacing the current unique pointer syntax with it would then be natural. The hard-wired unique pointer type in the language is not going to work with allocators, so we will have `Uniq&lt;T&gt;` (sugar for `Uniq&lt;T, A = DefaultAllocator`) regardless. I don't think it will make sense to keep around two ways to do the same thing, especially when `~T` is used so little in Rust code. It will only be commonly used in the type definitions of recursive data structures and trait objects, since type inference takes cares of the rest and `box` will be the way of doing memory allocation.
The recent discussion on IRC didn't mention it being "too lightweight" as the primary reason for wanting to remove this special case from the language. As far as I can tell, you disagree with what was discussed and are trying to define the position as something it's not with a straw man.
It's hard to understand where it came from when the real points that were raised are left out and replaced with a straw man about it being "too lightweight". Language design shouldn't be able playing politics and misrepresenting other people's views on Reddit.
&gt; but it'd be a pretty huge change To support allocators, it will need to take an allocator type parameter. That implies defining a new type in the library. The fate of the syntax hard-wired into the language would need to be determined via an RFC, but a library equivalent is inevitable. I personally don't think that it makes sense to keep around two ways of doing the same thing, especially if `~T` is not simply sugar for `Uniq&lt;T&gt;` which itself is sugar for `Uniq&lt;T, DefaultAllocator&gt;` via default type parameters. 
Fair enough. I'll wait for an RFC -- if it ever comes -- instead of reading too far into speculation.
Indeed. `Uniq&lt;T&gt;` being sugar for `Uniq&lt;T, DefaultAllocator&gt;` is useful. `~T` being sugar for `Uniq&lt;T&gt;` is less so.
I agree, when I say "huge change" here I mean "will break a _lot_ of code, and so won't be a decision made lightly"
Agreed, I think this post is becoming toxic. This should be an RFC, refereed by the language designers.
Entirely unrelated.
Indeed that exact syntax is not working (and I'm not sure it ever will). What does already work however is `let foo = box(GC) 5i`.
This isn't really one of the arguments for removing it. It was mentioned a few types as a reason why losing the syntactic sugar for `~str` isn't a big deal, along with the fact that `StrBuf` will be more common than `~str`. It's hard for people to understand what `~` does because unlike a type name like `Uniq`, it is not at all easy to search for and does not appear in the documentation *at all*. That's not one of the reasons I brought up for removing this the other day though.
I think they're distinct issues. "foo" is a `&amp;str` so the special-cased `~"foo"` syntax will no be sensible when the dynamically sized type changes remove `~str` and `~[T]` as distinct types. In most cases, people are going to be using `StrBuf` (hopefully renamed to `Str`) rather than `~str` anyway, so it would be sugar for the uncommon case rather than the common one.
No worries. We are trying hard to keep Rust a friendly community, but we have to balance being open and welcoming to the views of new comers, whilst at the same time working hard to combat [design by committee](http://en.wikipedia.org/wiki/Design_by_committee). Design discussions seem to turn ugly when conducted on reddit. Keeping it to formal RFCs or discussing it on #rust-internals might be the best way - I dunno. I hope you aren't discouraged though, we are generally pretty friendly. :)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Design by committee**](https://en.wikipedia.org/wiki/Design%20by%20committee): [](#sfw) --- &gt; &gt;__Design by committee__ is a disparaging term when a project has many designers involved, but no unifying plan or vision. &gt; --- ^Interesting: [^Design ^Automation ^Standards ^Committee](https://en.wikipedia.org/wiki/Design_Automation_Standards_Committee) ^| [^Committees ^of ^the ^European ^Parliament](https://en.wikipedia.org/wiki/Committees_of_the_European_Parliament) ^| [^Computer-Aided ^Design ^Technical ^Committee](https://en.wikipedia.org/wiki/Computer-Aided_Design_Technical_Committee) ^| [^Drama ^Desk ^Award ^for ^Outstanding ^Costume ^Design](https://en.wikipedia.org/wiki/Drama_Desk_Award_for_Outstanding_Costume_Design) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgua5yl) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgua5yl)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I am not opposing removal of `~"foo"`, I am happy it is going to be removed! But [dbaupp](http://www.reddit.com/user/dbaupp) seemed to dislike that lightweightness of `~` in general encourages people to use pointers too much. Maybe I misinterpreted him, but I am still happy that discussion moved to talking about `~` in general, no matter how it started.
well maybe i'll see it as a step forward if combined with HKT &amp; associated types, and the icing on the cake would be full HM inference between private functions. .. or if there's features in the system of overloading *beyond* what C++ can do - like the idea of Deref carrying information down an object graph... eg if Ptr has information about an arena encoded, or making the implementation of internal/external vtable objects also more user controllable. perhaps there's an opportunity to make HKT look a bit prettier than it does in C++. http://stackoverflow.com/questions/2565097/higher-kinded-types-with-c Perhaps you'll add these to the standard library aswell to save us all the trouble of fighting over what to call them in our code. OptUniq&lt;T&gt; = Option&lt;Uniq&lt;T&gt;&gt; VecUniq&lt;T&gt; = Vec&lt;Uniq&lt;T&gt;&gt; // its about the nesting levels, not saving characters, // that'll also make it easier to swap Vec / VecUniq when tweaking and certainly Vec is already something I want more options for, namely parameterized index. (target being 2,4,8,16 mb machines, 64bits of index is wasteful - 32bit indices suffice for my purposes - plus you can annotate via the type system which indices are used with which functions.. type Mesh=(Vec&lt;Vertex,VertexIndex&gt;,Vec&lt;[VertexIndex,..3], TriangleIndex&gt;, Vec&lt;MaterialIndex,TriangleIndex&gt;), that sort of thing...). There's relative pointers aswell, which would become especially useful in arenas. make a 4gig arena, or go further with shift values .. 32bits x 4byte alignment can adress 16mb and so on
nice! Is the 'multiparameter typeclass' just going to apply to operator overloading, or would it be considered for function overloading too, "collide(spaceship,asteroid)".. that sort of thing, (some sort of sugar for double dispatch when its vtables, or just dont go as far as doing it for trait-objects?)
Do you often put a loop like `for _ in range(0, 1000) {}` in non-performance-critical sections of your programs? It only executes rarely so it won't be a problem. (Many uses of `~` I see are just as pointless as that empty loop: just using cycles for no semantic benefit or difference.)
(I did leave out things: supporting allocators is definitely the most important reason to move away from `~`.)
They might be easy to learn, but they're also very difficult to search for.
&gt; full HM inference between private functions Can you elaborate on what this means?
Imagine if within one module, the type inference worked like haskell, where you can just omit types. The desire comes up when refactoring for me ( eg just pulling bits of code out to reduce the nesting level, with all those match blocks..). I know the drawbacks of doing this at the whole program level, which is why i'dsuggest only allowing it within a module, and not between modules.. i.e. Only for non public functions.
I personally wanted to remove `~` for a while, but I was persuaded by the rest of the core team to leave it in. At this point I think nobody really wants to take it out. It's just like C++'s unadorned `operator new`, a nice convenience (but more modern than `operator new`). Not many people are complaining about "all the different kinds of pointers" in Rust anymore, so I don't see a whole lot of demand to remove it. I feel that the remaining memory-related usability issues in Rust will be addressed by iterative improvement of the borrow check over time (for example [#6393]), not by world-breaking changes. [#6393]: https://github.com/mozilla/rust/issues/6393
~ is an expensive thing? I thought it was basically a malloc (yes expensive but not a deal breaker?) idk
I'm confused. Rust already does Hindley-Milner type inference, on your whole program. Though maybe not in function parameters?
I'd assume trait objects would still just be for the single Self type, sadly.
I could see the STM monad being useful in some cases, however it loses many of its benefits in a language that allows side-effects. http://hackage.haskell.org/package/stm-2.1.1.2/docs/Control-Monad-STM.html
Right, for a systems programmer, a malloc is expensive. ;) More importantly, Rust tries to make costs explicit. While `~` is explicitly costly, it's not _syntactically_ costly. So it got used more than it should, especially `~str`. So it's not that `~` is expensive per se, it's that expensive things should be expensive, and typing it is just too cheap. ------------------------------------------------------ But other than that, there are still good reasons to remove `~`. I was solely commenting on the 'expense' angle: after a few more changes land, it's arguable that `~` won't even be all that _useful_.
Why would that be bad? Writing Rust is fairly confusing because it requires wrestling with the borrow checker that is sometimes not as smart as it should be. It's also a very big language with lots of black magic and white magic because the black magic is only required 90% of the time and you need to something else 10% of the time. It's like trying to mess with C++ or Haskell. You get these weird error messages that you don't understand because if you could understand them you wouldn't be making the error in the first place. Compare that to the elegance of Lisp (everything is a list) or Smalltalk (everything is an object). You can learn Lisp or Smalltalk in a few hours after which you just need to learn the libraries. They have very little syntax and have the pervasive "everything is a _" that allows you to treat code as data. In Haskell it's more like data is code because it's actually not data but a thunk that will be evaluated at some point when it feels like it. Rust seems to miss that elegance of a minimal language like Lisp or Smalltalk.
It should be ok using higher inductive types if your langauage supports it (note that not even Agda has these currently). In such a language one could write data FinSet : Type -&gt; Type where {- ... normal set constructors go here -} FinSetExt : (s t : FinSet a) -&gt; (x : a) -&gt; (Elem x s &lt;=&gt; Elem x t) -&gt; s = t and data Elem : a -&gt; Set a -&gt; Type where {- ... some encoding of membership in a finite set -} but I'm sure programming with this would be not be fun.
i understand it does that through generic type parameters, but I mean without even specifying types at all - like when you write lambdas within a function, or when you write local variables. (under my suggestion, think of the module contents being 'local')
Mmmm it works but I don't understand why, where goes `GC` comes from? and how can one box into an `Rc`? (also, why doesn't `std::gc::Gc` implement the Deref trait?)
Everything you brought up there has to do with the memory model of Rust. Xtend and CoffeeScript don't fundamentally change the memory model of their languages. If you were to write a syntactic layer on top of Rust, you'd still have the smart pointers, and you'd still have the borrow checker. It seems like what you want is not Rust at all but a garbage-collected language with less control over the machine. (Nimrod is different because it changes the memory model of C by going to garbage collection for everything. It's basically only using C as a compiler backend. A "Nimrod on top of Rust" would be the same as a Nimrod on top of C, and might as well not use Rust at all. Actually, it probably shouldn't even use Câ€”LLVM is a much better choice for more precise control than C gives you, especially when GC is involved. Also, compilation times will be better.)
We could in principle write a rustfix. We haven't put a lot of effort into it because most of the language changes have been changes to the memory management story and type system that would be impossible to automate. That's not true as much for the changes here on out though.
&gt; GC is a unit struct constant with an implementation of the necessary trait which simply calls the static allocation/deallocation functions directly. Interesting, it's even documented and I still missed it. Thanks. Shame it's not possible to just pass the box type. 
&gt; if you are getting a variably sized enum as a return value, you'd want a pointer rather than allocating it on the stack (unless you've got alloca). Eh? That's not related to the syntax of a pointer.
But the .pdf have numberings as well, so it's consistent. 
they seem to want to get rid of special syntax and move toward everything in library features, as their generics/overloading get better. personally I would like it if they kept ~ and even @ as user definable syntax shortcuts,like typedefs, with defaults. (maybe even add Option to that scheme.. ?T=Option&lt;T&gt; .. might sound silly but Option is even more ubiquitous. ?~T and ?&amp;T would replace many of the troublesome uses of raw pointers, but which us C programmers are so used to having as one character, let alone 2) when they're so easy to compose, you are spared from needing to create lots of typedefs. well, emacs has 'pretty mode' that can substitute unicode for arbitrary strings, and one can set up keyboard macros so maybe this desire can be satisfied within a text editor. (visualize 'Uniq&lt;' as some symbol and hide its closing '&gt;'... , and so on.
its related to the situations in which you want to use the pointer.(countering claims that it isnt going to be used), and hence the demand for nice syntax for it. I'm saying a pointer is useful for variable sized data (an option being a common example where one size is zero). and many things are variable size. before c++ came along and 'blessed' one particular way of allocating, i was used to concatenating things into a single allocation. (header,arrays..) (yes, allocations are expensive, so concatenate into variable sized objects?) C programmers are used to both 'Option&lt;Uniq&lt;T&gt;&gt;' and 'Option&lt;&amp;T&gt;' as well as various iterators, being just one character .. 
wow :) great to see progress on this. I'd given up long ago
Example using it: https://github.com/vhbit/ObjCrust
Yes, It is about bullet vs numbers. e.g `1 Introduction` --&gt; `Introduction`
Would nice to have something like: `type @T = Rc&lt;T&gt;;` `type ?T = Option&lt;T&gt;;` `type ~T = Uniq&lt;T&gt;;` `type *T = RawPtr&lt;T&gt;;` `type &amp;T = Borrowed&lt;T&gt;;` `type $T = MyDynamicVariableWrapper&lt;T&gt;;` `type Â§T = MyGameRule&lt;T&gt;;` `type Â±T = PlusMinus&lt;T&gt;;` `type Â°T = Degrees&lt;T&gt;;` etc.
I **never** said `~` should never be used (and I did made this clear in other replies in this chain), just that's it is currently used inappropriately a lot. C is a silly comparison: all possible pointer semantics get overloaded into a single character, forcing programmers to keep track of ownership (and validity) themselves, not letting the compiler handle anything.
They're not failure safe because they're making the memory in the `&amp;mut T` uninitialised and this `&amp;mut T` presumably is pointing to some value owned on the stack/heap. When something `fail!()`s, the stack unwinds, calling destructors of values in reverse order to creation. The following program has creates a `Foo` and then attempts to `transform` it, in a failing way. Theoretically there's only one `Foo` in that whole program (the one created in `main`, `transform` should just be modifying not duplicating it), so destructors *should* only run once. As you might guess, this isn't true. Both `x` and `y` have their destructor (the `Drop` impl) executed: use std::mem; fn transform&lt;T&gt;(t: &amp;mut T, f: |T| -&gt; T) { unsafe { let tmp = f(mem::replace(t, mem::uninit())); mem::move_val_init(t, tmp); } } struct Foo { x: uint } impl Drop for Foo { fn drop(&amp;mut self) { println!("Dropping {}", self.x) } } fn main() { let mut x = Foo { x: 1 }; transform(&amp;mut x, |mut v| { v.x = 2; fail!() }) } This prints: task '&lt;main&gt;' failed at 'explicit failure', tranform.rs:21 Dropping 2 Dropping 1 (I had to compile with optimisations (`-O`) to see this error, without optimisations the `replace` call is actually zeroing `x`s memory, including its implicit "drop flag", and a zero drop flag stops the destructor from running (this may change in future, as there are plans to use flow-analysis rather than zeroing+the drop flag).) --- Yes, partially a bug, the following works: unsafe { let tmp = f(mem::replace(x, mem::uninit())); mem::move_val_init(x, tmp); } 
We could have post-fix type sigils too, e.g. `type T! = Factorial&lt;T&gt;;`.
Thank you so much So, i understand this is an example where optimizations does not preserve correction of unsafe code. This is a bug, right ? And a quick fix would be not to optimize unsafe blocks &gt; partially a bug You mean a bug which is not yet completely fixed ?
repurpose @ for prefixing something? (and ~ for postfix or use haskells backticks..?) Gc@T compiles as Gc&lt;T&gt; emacs shows as â’¼T Option@T Option@Uniq@T compiles as Option&lt;Uniq&lt;T&gt;&gt; emacs shows as ?â“ŠT X.HashMap@Vec@Y compiles as HashMap&lt;X,Vec&lt;Y&gt;&gt; emacs shows as Xâ‡’â“‹Y show it as whatever makes sense to you, and leave the text in a form which is search friendly the world would probably benefit more from making emacs handle the &lt; .. &gt; as one could prettify C++ at the same time. 
Maybe hard to parse... `type &lt;-T = Receiver&lt;T&gt;;`
Then, i can't see any way to achieve this with 100% safety even in this very basic situation. what a shame &gt; without optimisations the replace call is actually zeroing xs memory, including its implicit "drop flag", and a zero drop flag stops the destructor from running This is why i thought that optimizations didn't preserve correction. Zeroing the drop flag *mustn't be optimized out* &gt; (this may change in future, as there are plans to use flow-analysis rather than zeroing+the drop flag) `nawfel_bgh.search("flow analysis")` :) This is why i enjoy following the development of Rust
On this line, `let o = (i, ~make_int(i));` `i` is moved into the tuple, then the code attempts to use `i` again. That's where you get the "use of moved value" error. `~` pointers are always moved unless passed by reference. If they weren't moved but implicitly copied, you would easily end up with multiple pointers to the same object which is a source of errors. If you explicitly copy a `~` pointer by calling the `.clone()` method, the underlying data is copied as well. Move-by-default isn't unique to `~` pointers. Everything is moved by default, unless the type implements the Copy trait, which indicates that it can be copied by simply copying bits. In practice the primitive types all implement Copy.
To follow up, this means that `let o = (~make_int(i), i);` works.
`type &lt;-=T = Receiver&lt;T&gt;;` Edit: On second thought, restricting it to one characters make it easier to compose.
Ah, I think move mechanics make sense now. Thanks for the quick turn around!
Yes, however it's certainly the most striking example I have ever seen. In GCed languages specifically, you never get a dangling pointer, so reference invalidation is generally less regarded as an issue compared to C or C++; however iteration is still at risk.
Right, in Java, you almost always put things on the heap, not the stack, so a malloc is relatively cheap. &gt; Ignoring of course times you borrow a pointer on the stack. That's ignoring the majority case!
One tool I've found useful for playing with messy graphs if http://gephi.org/, but it doesn't support subgraphs.
How does a browser written in Rust prevent the Heartbleed bug? Wasn't that a serverside bug? What does it have to do with browser security?
I think Jack means that Rust would prevent the categories of bug that led to Heartbleed in the first place (assuming that you weren't tempted to drop into an `unsafe` block in that part of the code, of course). Note as well that the only reason that Heartbleed was a server-side bug is because typically no client-side web browser uses OpenSSL for TLS (Firefox uses NSS, as does Chrome on most platforms).
There's always tension between brevity and verbosity. I'm pretty sure the answer is "because the code was committed that way."
Indeed. As far as I've been able to tell, all of the recent TLS vulnerabilities, not just Heartbleed, would have been prevented by writing TLS in Rust.
This is a nice concise guide. Thanks.
The problem is that you can't move the interior of the variants out, since if the program fails while it is moved out, the runtime cannot tell that the destructor should not run while it reaches whatever the borrowed pointer was pointing to. The best solution is to store an Option&lt;E&gt; instead of an E, and then you can take() the value, deconstruct it, and then store a new Some() in it. This is equivalent to adding a flag to tell the runtime to not run the destructor (the flag being the Option Some vs None). Alternatively, you can use unsafe code, swap in uninit() and make sure your program does not fail in between. Or you can temporarily swap in a "dummy" instance of E, assuming you can construct one (in this case, you can't, because there is no way to safely construct a dummy &amp;'a mut where 'a is a lifetime parameter). You can also see the idea of using Option&lt;E&gt; instead of E as a way to ensure that a dummy instance can always be constructed (using None). 
Many factors: 1. Arbitrary decisions by the designer, if any 2. The specific tastes of the implementer 3. The length of the unabbreviated name of the type (longer names are more likely to be abbreviated) 4. The commonness of the type in practice (more common types have greater license to be abbreviated) 5. Whether that type has precedents in other languages (such as Option, which was lifted wholesale (along with Some and None) from the ML family)
It does seem like MutableFoo -&gt; MutFoo would be a good candidate for a change, since 'mut' is a keyword so it's guaranteed to be obvious. Otherwise it's pretty much case-by-case.
Perhaps some design decisions should be taken, outlining some sort of naming conventions where coherence is advocated - one way or the other. This would ease adoption and make it easier to use external libraries from different developers.
That seems excellent! Rust is shaping up to be one of the most interesting languages out there.
Why not: type ðŸŽ¤T = Sender&lt;T&gt;; type ðŸŽ§T = Receiver&lt;T&gt;;
Unfortunately that is the case. But the rationale is that in Rust unsafe blocks are a tiny portion of the code you normally write. In C and C++ you are basically working in one giant unsafe block, which is a nightmare to audit.
Not the browser. He is suggesting that a TLS lib written in Rust would be more safe.
6\. The amount of time the author fought with [long class names](http://docs.spring.io/spring/docs/2.0.x/api/org/springframework/test/AbstractTransactionalDataSourceSpringContextTests.html) [in Java](http://www.pushing-pixels.org/2007/11/07/and-the-longest-jre-class-name-is.html).
I didn't know we had Haskell's @ syntax! Neat!
[Heartbleed affects clients too](http://jakeaustwick.me/heartbleed-affects-clients-too/).
Rust does not have properties. I'm not sure what you mean by 'implied parameters', but yes, `self` is explicit so that you can specify whether it is passed by-value or by-reference and whether it is mutable or not. You can also leave off `self` entirely and you will get something like a static method in C#.
It can definitely be useful, but notice that your `getUserConfig` example completely throws away all error information. So if there's a problem reading the config, it's going to be pretty difficult to know whether it's because the file can't be found or if there was a syntax error somewhere. Using `Result` in your example seems like a much better fit.
Do you mean tension between brevity and readability? Verbosity is not a desirable trait for a programming language.
So the problem is people use ~ on the heap when they could/should have used stack allocation?
Yes.
Ordinary fonts cannot into these symbols. But arrows are avalible in any font. So: type â†T = Sender&lt;T&gt;; type â†’T = Receiver&lt;T&gt;; type âˆ… = (); Also, we can use right-associative `âŸ` instead of `log(num, base)`: `base âŸ num` 
In your example, you're actively discarding errors by using the `ok()` method. So in your example, this isn't really applicable. More generally, if a function returns an `Option`, then that means there's probably no useful error to report. At least, one would hope, anyway. As a general rule, if a function can return an error, then you should be returning a `Result` or some equivalent.
I only discard the errors because I can't do much with them anyway. What should I return when os::homedir () returns None? I have no IoError value to wrap in Err, so I'm not sure what would be appropriate. For my app I don't really care about the error anyway--if the user configuration can't be found for any reason, I just use a default. 
Vrbsty nd rdndncy hlps th ndrstndng f xstng cd t lst. Hw bt th nturl lnggs? Sm scrpts lcks chrctrs fr vwls, bt y wldn't sy tht ths vwls r rdndnt snc w cn nfr thm! Y'll fnd [ths](http://www.i18nguy.com/twain.html) ntrtnng.
dbaupp also wrote unsafe_ls, which allows you to filter unsafe blocks by the kind of unsafety used. A better "grep unsafe". https://github.com/huonw/unsafe_ls
&gt; The Rust programming language
/r/playrust
I am the exact audience for this kind of post, so thanks. My five cents would be to not spend so much time explaining things that will probably be pretty obvious to a C++ developer, like what -o and -g are, and explain things that really aren't obvious at all, like what &amp;' is. 
Indeed. I was waiting for him to explain what `&amp;'static` meant...but... I guess not.
Why isn't verbosity desirable? IDE's can autocomplete shit, readability is far more important IMO. Honestly, the abbreviations are my biggest peeve about Rust.
+1 on the module system - I dont just think it was me being stupid, this is surprisingly confusing, because it goes against any preconceptions you have not just from C++ but everything a C++ programmer assumes is different in *other* language module systems. (it only makes sense to ML programmers?)
I'll keep a note of all of these for later - thanks! Only the second was on my radar, so I'll probably cover some more fundamentals before getting to these, but I will try to cover them
I'm kind of regretting dropping `&amp;'static` in there so early now. I will explain it in a few episodes time. (For now, it is a borrowed reference which has the lifetime of the program. In the specific case of strings, `&amp;'static` str is a string literal in the data segment of your program).
[**@ChicagoPL**](https://twitter.com/ChicagoPL): &gt;[2014-04-17 21:13:17 UTC](https://twitter.com/ChicagoPL/status/456903245340753920) &gt;And here is \(debug\) \[\#servo\]\(https://twitter\.com/search?q=%23servo\) on Android on an \[@pandaboard\]\(https://twitter\.com/pandaboard\)\. Next\, ARM Linuxâ€¦ \[\*pic\.twitter\.com\*\]\(http://pbs\.twimg\.com/media/Blc\_FJdCQAAYNP6\.jpg\) \[^\[Imgur\]\]\(http://i\.imgur\.com/qzSlyvT\.jpg\) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/23cb7v%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
This looks awesome. Is this theme now default in rustdoc?
Yes. It landed in master recently.
Sadomasochism?
Its certainly not sarcasm: There is a percentage of rust devs for which Rust the first system programming language, and which now know enough about the important details of memory management, ownership and low level details to write good Cpp, without knowing about the basic syntax, common pitfalls and do's and dont's. I'm one of those btw ;)
Still early. Mostly did a lot of cleanup and refactoring, added Travis and Rust CI.
I am looking forward to what you do with emoji :-) 
Personally, I don't like the new doc design. :/ It seems to me that the new design is another "Bootstrap-style" website and lose the "Rust"-style that he had before (I mean, something like the "grey-block"-style with small font size).
Interesting situation, who knows in 5-10 years, but I think replaceing C++ is still unlikely; - people who want a C++ replacement generally dont agree what the replacement is, or what aspects need replacing. - huge C++ projects will remain in common use and continue to be extended/maintained. - a big portion of the C++ community has 'stockholm syndrome' and is convinced C++ is perfect. (I encounter people who reject rust over trivialities like 'fn') I'm hoping the crossover between the languages increases - a lot is simply slightly different syntax for the same things, then some restrictions. C++14 getting polymorphic lambdas is a big step forward. You could have a project where you basically treat C++ modules as giant unsafe blocks. I've not touched the JVM but i'm told interoperability between Java,Scala,Clojure works 'surprisingly well', is it possible that C++ &amp; Rust could seemlessly coexist in the same sourcebase.. I wonder if eventually a source-to-source translator would be possible ,or if you could build a rust-and-c++ compiler that feeds the same AST. (make one AST that is a superset of the concepts, and take it from there.) No standard c++ abi, but you might have a platform where you can rely on the mangling being the same.. Since the smartpointers are moving into library functionality (and if it gets associated types, and there's all the talk of internal-vtables) Rust seems to be converging on something closer to C++ "with a new grammar, and inbuilt static analyzer, and dangerous behaviour controlled". 
oh another BIG one for cultural reasons :- *MACROS* The C++ programmer comes from a culture where "macro" is a dirty word, macros are to be avoided at all costs. Whereas in Rust, the macro system is actually amazingly good, and a viable,clean way of handling all those 'x-macros hacks for not having reflection' cases elegantly. And it can do all the debug info stuff better too. I was surprised - its quite possible the macro system will actually be one of rusts most useful changes for me over C++. A C++ programmer needs to know somekey facts, (i) rust macros actually understand AST elements like types,expressions,idents; (ii) rusts' macros can have nested repeats. (iii) they're NOT just text substitutions, you can't do things like #define private public and so on :) As i go back to C, not C++ as my starting point, I was open to macros because I still see C++ as incomplete without them.. templates have not succeeded in making macros obselete. Another one would be *match*, dive straight in and show cases where match can go beyond the template hacks people have in boost and so on ( when you start matching on more elaborate patterns..)
we dont have an IDE for rust. until we get an IDE for rust, i prefer, for example, raw openGL bindings, because emacs can handle the gl prefix better with primitive autocomplete and primitive ETAGS IDE's could also extend/disambiguate abreviations once there is one :) (hover over it and it tells you more).
If we get 'Uniq' replacing ~, i will make myself an OptUniq&lt;T&gt; for the common case, Option&lt;~T&gt;, and VecUniq&lt;T&gt; instead of having 2 levels of nesting for Vec&lt;~T&gt;. I really hope they add those to the std lib, even though they're trivial anyone sane will make their own versions.. I think they've got the level of abreviations about right. There's no way I'd be content writing out unique_ptr&lt;T&gt; in C++, and I always want 'using namespace std' because I dont want to write std::vector either. option on its own is ok.
See http://www.reddit.com/r/rust/comments/23941p/syntax_for_owned_boxes/cgv7l88
Ah yes, macros - I'll add that to the list. match definitely needs coverage - I have an introduction ready for part 2, but more stuff to come later.
To its credit, it's really self-documenting.
Yeah, the font is way too big. And the grey boxes are way too light.
Am I correct in understanding that this was tested not in a code context, but in an individual variable / phrase context? If so, that lowers its value to actual work substantially. Of course an underscore more closely mirrors a normal english phrase. angry monkey angry_monkey but IMHO, in actual code, you don't want conflation between word separators and underscores, as they have very different meanings. if this then if_this_then versus if this then ifThisThen in longer lines of code, having a muddle mix of underscores and spaces lowers readability. You have an additional cost of separate between words (space) and variable parts (underscores). 
Yeah, it's pretty bad. While the HTML output of rustdoc is a bit quirky in places, you can get pretty far by changing the CSS. I've never been very happy with the default rustdoc style, so I've neen using a different CSS almost from the beginning (here's an [example](http://siegelord.github.io/RustGnuplot/doc/gnuplot/struct.Axes2D.html)). Nothing you can do about the official web-page though... On that note, it'd be awesome if Firefox allowed me to white-list specific fonts (so I can keep using github with its icon fonts), so I don't need to enjoy the often unreadable fonts web-designers try to use. Arial is the only font that should be used for non-code text.
I've read one [earlier study](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.158.9499&amp;rep=rep1&amp;type=pdf) but except from those two, there hasn't been done much research on the topic. They probably start with simple experiments before they conduct the more complex ones.
In the end, it is probably a rounding error. Follow your language / platforms standard and you will get used to it, warts and all. It is surprisingly easy once you adapt -- I swap from C++ MS style, and C++ Google style on a regularly basis (sometimes in the same day). 
&gt; But Windows, Java and Javascript folks typically use camelcase, and there are a lot of such folks Well, the researchers claim that &gt; the trend has been to use camel-case style identifiers. but according to your argument itâ€™s just a local â€œtrendâ€. Are there any known statistics on the most common style conventions?
This is a bit OT but since I see it here the first time: I find it very irritating that attributes are also allowed to be placed directly after an opening brace an not only in front of an item.
&gt; Java and Javascript covers like half of all developers Possibly; the article doesnâ€™t mention JS in the context I cited, though.
Thank you for the response. I think implicit parameter is the correct term.
If I wanted to discuss/suggest adding properties to Rust and the benefits this could bring to the language, where would I go about starting that discussion?
Why not simply fn unpack_int() -&gt; Option&lt;int&gt; { /* something */ } or even enum Thing { IntThing(int), FloatThing(float), StrThing(~str) } fn unpack() -&gt; Option&lt;Thing&gt; { /* whatever */ } 
I also wish for interoperability between C++ and Rust, however given the floating ABI of C++ I am afraid it would require to create Rust bindings in C++.
Personally I like the idea of properties, but I don't think there is much will out there, or whether the added complexity is worth it for 1.0. You can submit a detailed RFC as a PR here: https://github.com/rust-lang/rfcs/ Also, you can chat with folks on #rust-internals on irc.mozilla.org, they are pretty friendly! I would suggest drawing up and RFC first though.
Yeah, but the IDEs will come. We can't rewrite Rust once they come out. Mousing over every variable and keyword is not a solution. I dunno how emacs works, but I think sublime will complete words once you type it at least once; that at least might tie us over until full fledged IDEs come.
emacs has a lot of completion options and can be flaky with various plugins fighting eachother because you have bits of leftover scripts going on :) it is my prefered option though short of a true IDE, as its the most maleable editor i've found. I've got emacs firing up a rustdoc search on a symbol from a hotkey
heh yeah the classic "collide(spaceship, asteroid)" example .. although heavy duty game engines actually avoid vtables for performance reasons.. they'd still probably be very convinient in many situations as you mention.
Yes, you can achieve the similar effect with traits, with a return type of `Self`: trait A { fn f() -&gt; Self; } impl A for int { fn f() -&gt; int { 42 } } impl A for f64 { fn f() -&gt; f64 { 3.14 } } impl A for ~str { fn f() -&gt; ~str { "blah".to_owned() } } fn main() { let x: int = A::f(); let y: f64 = A::f(); let z: ~str = A::f(); println!("{} {} {}", x, y, z); } ...will print `42 3.14 blah`. You are required to annotate types for `x`, `y` and `z`; otherwise it will end up with an ambiguity error. There is some inflexibility in this syntax however, and you may have to make a wrapper function to avoid several issues (just like the `FromStr` trait and `from_str` function).
Perhaps what I really mean is "eliminate the difference between methods and functions by generalizing methods".. rather than 'eliminate methods', if you use the term "method" to mean *function chosen at runtime*. But a lot of what I'm on about is simpler than multi-methods, its merely generalizing UFCS. Perhaps somethign could be done that would just open a roadmap toward multi-methods it in a natural way. I'd seen some of their suggestions about generalizing the 'self' parameter so that its' not self, that causes a problem for finding which functions go in the vtable, but if you were to say "its only the first parameter that goes in the vtable(for the timebeing)"... and "we have UFCS, a.foo(b) is always just sugar for foo(a,b)", .. maybe that would work.
do you have to *annotate* the type, or can it be infered backwards (lets say x/y/z were parameterized, or clear from function arguments/struct fields..). I suppose the real utility of this would be avoiding needing to pass references to mutable fields. In C++, create an uninitialized structure, and read elements ... struct Foo f; file &gt;&gt; f.x&gt;&gt;f.y &gt;&gt; f.z; but in rust... let f=Foo{ x:file.read(), y:file.read(), z:file.read() } ? 
In many case they indeed get infered. Unfortunately, the Rust's type inference has some quirks that the full bidirectional inference is impossible yet (I'm not sure this can be made possible either). In those cases you'll have to annotate types explicitly, and having a function form helps a lot since it would be equivalent to the proposed `A::&lt;for ~str&gt;::f()` syntax or so.
Generalizing methods is part of what would be fantastic, I just really like multi-param traits as well (especially if we make Self explicit there just like it is with args).
Rust is probably a good systems language for students. 
You don't really need a compiler flag, you would just need to use the `extern` marker with a special destination (`extern "g++11"`). But the problem goes much beyond mangling, if you do not wish to be restricted to a small subset of types you need a way to create a Rust `struct` that is layout compatible for each `C++` struct, with all the methods, to deal with exceptions, etc... It truly is a daunting task.
Sorry, my example was a bit misleading. The context is that I have code that is very generic but the return value has to be of a given type. I wanted to avoid writing a whole bunch of `to_type` methods to achieve that effect.
I wonder if clang makes it a problem the community can tackle at both ends - in cases where you can choose the compiler. I realise some people are tied into MSVC or whatever.. platform specific compilers. but is Rust by definition going to be used on platforms where LLVM and hence Clang are available. i've never used exceptions, I can see they're a whole extra kettle of fish. 
"Malloc" is cheap in Java, because the cost is defered to Garbage Collection :) (bump-pointer allocation, but then having to trace and shuffle data around) it isn't cheap really, its just a case of pretending it costs nothing and paying later, but some claim there is an advantage to batching up the memory management cost. I would think with pooling and arenas there are cases where you can consider allocation cheap in a systems-language, but in one of those (arenas) the ownership is really somewhere else (the arena) 
Thanks to TheHydroImpulse and Adrien Tetar for their continuing efforts to clean up our HTML.
Wow. This is a huge step forward!
Awesome. Thank you.
I think this would be confusing. For example, with ~T and *T, and &amp;T you can call methods that are defined on T. However, with ?T, it is actually an Option type, so ?T .foo() wouldn't work and would be confusing. 
I've used CLOS and never thought it's flavor of multiple dispatch to be something desirable. It's a lot of complexity, hard to reason about when reading code and has modularity issues. The (perceived) need for multi dispatch can be an indicator that the system hasn't been decomposed correctly. The cases where it is the right thing can be simulated with a little expression language and writing an "explicit" dispatch function that fits the domain. That can be made composeable as well. Not convinced at all that it is a good idea to enshrine a "blessed" multi dispatch feature in a language.
LOL
rust seems to be a bit overzealous with regards to abbreviation. 
Depends on where you come from.
I noticed that with the old version of rustdoc, it generated hyperlinks to other crates' documentation. I can't seem to replicate this behavior with the newer version. Any tips?
The sidebar now has a list of crates with links to them. You can also visit http://static.rust-lang.org/doc/master/index.html for a complete list.
How to run this? Trying to run the tool on itself: ``` thiez@phenex:~/sources/rustfind$ ./rustfind rustfind.rs rustfind.rs:1:1: 1:1 error: can't find crate for `std` rustfind.rs:1 #![feature(managed_boxes)] ^ error: aborting due to previous error task '&lt;main&gt;' failed at '~Any', /home/thiez/sources/rust/src/libsyntax/diagnostic.rs:120 ``` I had to make several changes to get your code to compile under master (I don't have an older version lying around) but I don't think this is an error that I introduced. I tried running after setting`RUST_PATH=&lt;location of my copy of the rust repo&gt;` but I get the same error.
On the subject, does Rust plan to have GADT at some point ? (Or is it easily encodable in Traits ?) It would solve the issue quite trivially.
Really awesome! I'm excited to see what this project has in store for the future.
I'll take a look,i'm updating my compiler now. that IS the correct invocation, it is indeed supposed to do something usefull with no extra paramters, just an input file. The error reminds me of what I saw when i tried to run it on Servo - but its' possible more has changed. (part of the issue on servo is they use an old compiler) I'll update my compiler and take a look... someone else has submitted an update aswell. Servo didn't compile 
hi- it seems I have an additional environment variable which it doesn't tell you about, RUST_LIBS=/home/me/rust/x86_64-unknown-linux-gnu/stage2/lib , and there's a -L option to rustfind to override that if you dont have it. If you dont specify -L &lt;library path&gt; it uses RUST_LIBS, if that isn't set it uses nothing (i will change it to make it tell you, i'll check if there's an official/better way to do that) (the makefile is also using RUST_PATH to generate a -L option.. $(info Set $$RUST_PATH=&lt;rust tree&gt; to be able to link to rust std libs) $(info $$RUST_PATH is also required to generate HTML for the rust libs) RF_LIBS = else RF_LIBS = -L $(RUST_PATH)/x86_64-unknown-linux-gnu/stage2/lib/rustlib/x86_64-unknown- linux-gnu/lib endif let opts = optgroups(); let matches = getopts(args, opts).unwrap(); let libs1 = matches.opt_strs("L").iter().map(|s| Path::new(s.as_slice())).co llect::&lt;Vec&lt;Path&gt;&gt;(); let libs= if libs1.len() &gt; 0 { libs1 } else { match os::getenv(&amp;"RUST_LIBS") { Some(x) =&gt; vec!(Path::new(x)), None =&gt; vec!() } }; 
This is really to vary different proposals in one, a) removing semantic significance of method invocation syntax, and b) multi-parameter traits. Certainly .method(...) syntax doesn't make much sense for traits, but it can be done and thus the two proposals are orthogonal. I have no opinion on multi-parameter trait at the moment. I know and love the feature from Haskell, but I don't know about it's implementation strategies, and it seems rather complex. And they might be slippery slope: e.g. truer existential types than the trait-objects Rust has at the moment would be very useful. Getting rid of method syntax, or making it apply to all functions/methods on the other hand makes the language simpler and more regular. While we are at it, get rid of trait-less impl-blocks. I've never understood why the exist and are used, as is.
Looks like a huge improvement. 
Based on your new plan and my own experience, I'd make a macro where the first argument is the `Option&lt;T&gt;` and the second argument is a string for the `desc` field. Then you are still concise, but also nicely explain errors.
Also, https://codeo.me - very minimal one.
I am a C++ developer and although I have not tried Rust myself yet I follow the developments a bit. I think it might turn out quite nice in the future. But... when people complain that C++ is garbage I think that many people seem quite ignorant to what C++ is and about its development. I think there are too many people who use C++ as C with classes. They use the old unsafe raw pointer handling used normally in C. And many seem to have learned the language in some beginner class and got a really bad start using the wrong techniques. The language have also developed quite a bit in the last years and it's a bit unfair to compare how the old versions work I think. Regardless of this, Rust seems quite cool! :)
&gt; And many seem to have learned the language in some beginner class and got a really bad start using the wrong techniques. Which is why I believe Rust makes a good language for students. It teaches and enforces good techniques which then presumably come naturally in other systems languages as well.
In C++ functions have polymorphic return types, since... you can... throw... anything... (please don't do this, is a joke).
I know a fair bit of C++ and I still dislike it, because it's so damn complicated (and still hard to be safe with, despite smart pointers and STL datastructures, and boost magic and so on).
PG?
The argument about println! macro is invalid because that can be done in C++ too with variadic templates.
Type-checked 'holes' in strings? 
Out of curiosity, why is this in /r/rust? I'm not saying its not relevant at all, but it's relevance seems tangential enough that a text post with some framing for the discussion would be useful.
i guess there are details r.e. generalizing a.foo(b)/foo(a,b) since in the first case its more 'obvious' that foo is chosen from 'a's namespace (i think thats the purpose of the trait-less impl blocks), so its possible such a change would meet with ideological resistance and refactoring issues i would imagine you can still define a consistent rule about where the function is selected from - i would suggest foo(a,b) resolves the same as a.foo(b) &gt;&gt;I've never understood why the exist and are used, as is. i think its' needed for functions that are statically selected on the first parameter and its' also a shortcut for declaring a load of functions where a type is repeated. (well, on the latter front would a typedef be just as good)
Well, Clang chose to respect the Itanium ABI for compatibility with other compilers (gcc, icc, ...); however due to its modular nature and its permissive license it could be exploited to parse headers and generate Rust bindings. The other solution being to have the Rust compiler generate C++ bindings for Rust classes.
&gt;&gt;"I think there are too many people who use C++ as C with classes. " until it got auto (and now polymorphic lambdas), the safe style goes against what its natural syntax encourages. C++ is shoe-horned into C , who's syntactic choices are optimized for raw pointer manipulation. so thats why people write C with classes. Thats the language origins. until you had auto and range based for.. the iterators in C++ just looked ridiculous, you can't blame people for resisting that .. and other things like deciding bitshift makes a good file stream operator.. 
I agree, too many developers I work with have just no idea what the lifetime of their data is; and more often than not they pay little to no attention to the flow of their data, just making everything reachable everywhere. By imposing lifetimes' safety and non-aliasing (for mutable data), Rust **educates**.
&gt;&gt; it could be exploited to parse headers and generate Rust bindings. https://github.com/dobkeratops/cpp2rust here's my fairly primitive attempt, of course no templates are translated yet, and I get details of const -&gt; mut translation wrong; and theres' no attempt to do anything about overloads; but you can pass references to datastructures across, if you can manually supply a few analogues of the common collection classes like vector / Vec , that seems perfectly doable. I haven't tried to rely on name-mangling though - i'm only doing extern "C" stuff. Actually relying on name-mangling might simplify things out, i was currently emitting an extern "C" shim
Interesting, apart from Rust, there is no language I would swap C++ for right now. And I am not even talking about performance. Despite its many flows, C++ has generics, non-nullability and RAII. Too many languages either don't have the option (Java is `null`) or only have a watered down version (generics in Java ? RAII in GC'ed languages is restricted). Haskell is of course an outlier here, but honestly I've got a hard time getting into it. Laziness and boxing by default is not the choice I would have made (I don't know if it covers RAII... I suppose there is a weird extension making it possible). Now, looking at Rust: everything that I like in C++, without the *safety holes*.
Yes, with C++14 `constexpr` (it would be possible with C++11 but a recursive hell...), you can easily parse a string literal at compile-time. What macros have over `constexpr` is their ability to *generate* code.
Ideally, the C++ to Rust translator should also be used to translate the `std` classes: there are various Standard Libraries out there, and they themselves have various designs depending on their versions, so maintaining manually the classes in Rust would be a nightmare.
Please, please, make function names a different colour from generic type parameters. It's incredibly hard (for me at least) to notice the function name when it follows a list of generic parameters. This is especially bad for traits, where the function name is neither first nor last thing.
You want /r/playrust
You are wrong! The best rust server is http://www.rust-lang.org/
emddudley's (pedantic) point was that you could be verbose without being readable. :)
can pages query resolution. conversely , having documentation open on your ipad whilst you code on your laptop seems like a nice idea. I want a tablet browser which can be commanded by a search command from a laptop on the network (with restrictions obviously to not make it a security hazard)
i like that stuff, its good, but i've always found 'cheating' on the nesting always bites me when i try to change code later, I always end up having to nest it properly. 
I'm soo sooo sooo tempted right now.. [bites all 10 nails]
The way I see it, the proposed Metal stack could be written in Rust (for safety), JITing PNaCl instead of asm.js (for performance) and even running safe Rust application code without any form of isolation. Now, there are a few problems with that, but I hope we can sort them out by 2030 instead of sticking with a "bytecode" weirder than Java's. **EDIT**: /u/garybernhardt [did mention Rust on his twitter](https://twitter.com/garybernhardt/status/456875300580651009), but there's no follow-up on it.
This is only in the type space, for example: let x : @T = ...; let x = Default::default::&lt;$T&gt;(); etc.
Oh..well. Yes, that's certainly true. I think the biggest factor is ambiguity. If a name can be reduced in length without it being misinterpreted to mean something different, then do that. Otherwise, avoid uncommon abbreviations; they may not be understood, or might be misinterpreted to stand for something different, and they're harder to search for. `list` and `str` and a handful of others are atrocious type names in Python. I've overwritten them dozens of times by accident (even worse that I'm *allowed* to do that).
I agree, for me it has terrible readability and is a definite step backwards. - No contrast or differentiation between different parts of the page. The main document and the side bar just flows together. - Distracting random assortment of different font-styles. - Fonts are way too big, I think everyone agrees with this one. - Probably a bug in the server configuration, the webfonts aren't cached and the browser re-downloads them on every page.
I think this is similar to python, which has: for x in list: if something(x): x.noted() break else: nothing_noted() and prevents you from carrying a "did i break this loop or iterate over every element"-variable around with you. I like it, and in my amateurish opinion this would be nice to have in rust. 
Was he being serious though? The idea of a bastard JavaScript running computers scares the crap out of me, I agree that we should maybe have a technology stack like his proposed Metal in the future, but please God not JavaScript.
is PNaCl ever going to be supported by anything other than chrome
so if it was to return a value , which way would you suggest it works:- 'break &lt;return value&gt;' ... and 'else' is the return value otherwise; I think that follows cases i've had in C where i do indeed check ' if (the last iteration reached the end) ... else .. Makes it a little messier for my original suggested use.. for x in something_optional { break ..value to use} else { ...} - but I like the generality you suggest more. On the other hand, having such good lambdas as rust does generally makes writing HOF's to handle these sorts of cases easier.. python is slightly anti-FP as far as i've heard. 
the argument is about `println!` vs `printf`, not about what can or could be done in either language. C++ has streaming IO which is much safer than printf. I was making a point about the design philosophy of Rust, rather than comparing specific mechanisms. (It's not the best part of Rust to use to make that point, I admit, but all I've introduced is 'hello world' so I don't have many options :-p )
I don't like abusing `for` with Option, as it's extremely confusing to read. But I do like Python's for/else in general.
asm.js is just as fast as PNaCl. I know it feels like more of a hack, but PNaCl is _awful_ - it's a terrible choice of bytecode format for a VM and it requires a total re-implementation of the DOM for Pepper. Also the implementation from Google has been really bad - the API is mostly undocumented and changes frequently and there is tonnes of hidden stuff - Google's flash uses some kind of PNaCl++. I dislike the JS monopoly as much as the next man, but PNaCl is really not the solution.
1 - it is decided it will, it has not been decided how. 2 - not sure what you mean by this, sorry 3 - not sure if this has been brought up before. It seems a bit confusing to me, but then so did Java OO when I first learnt that, so perhaps that's not so bad. I fear it doesn't satisfy all the requirements for inheritance, but I'm not sure from this. I think the requirements are in the first inheritance/virtual fields RFC, plus somewhere on the mailing list.
I'll stop posting every blog post in the series after this one. Stay tuned to the blog or Planet Mozilla for more...
Came looking for a good flame war. . . was not disappointed. I especially enjoyed the C/C++ vs. LISP (and friends) thread. . . reminds me of classic reddit.
(Or wait for someone else to post them here... :) )
`.map` on an iterator actually just returns a lazy iterator where the iterated values are transformed with the closure as they are requested (that is the `v.iter().map(...)` won't actually print anything, because it's never actually iterated). A `for` loop is the idiomatic way to do these side-effect-only applications.
It works fine outside of Chromium, just not in other browsers.
asm.js *is* significantly slower than PNaCl and lacks features like 64-bit integers and threads among other things. It will *always* lose far more information than the SSA form bitcode. PNaCl also relies on lower-level sandboxing mechanisms Backwards compatibility with JavaScript is nearly worthless since any application like a high-end video game requiring the performance simply won't work in anything but a modern browser anyway. &gt; Google's flash uses some kind of PNaCl++ Pepper isn't part of PNaCl, as PNaCl has a use case outside browsers. The Flash plugin uses a superset of Pepper although it is still sandboxed, while the Google Talk plugin is not sandboxed.
The author seems to have posted this to one subreddit.
Nice!
Thanks for posting! Keep paying your entries! 
Posting your entries!*
I quite like that you post them here, as this subreddit doesn't get much traffic, I like that there is something rusty to talk about (I go on reddit a lot...)
Whoops! I should fix that, thanks!
&gt; For now, know that a `Vec` is a sequence of `T`s and `iter()` returns an iterator from anything you might reasonably want to iterate over). It seems that the HTML parser shallowed the `&lt;T&gt;` part both in the prose and in the code.
Thanks, I'll try and fix it (stupid HTML...)
Which foo() is called though?
For resource management, Haskell uses [exception masking](http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Exception.html#g:11), which is like try/finally without the race conditions.
The following seems to work, but there may be a better way. fn main() { let my_list = [1u, 2u, 3u, 34u, 5u, 6u]; match my_list.iter().filter(|&amp;x| *x &gt; 10u ).next(){ Some(x) =&gt; println!("Found {}", x), None =&gt; println!("Found none") } } 
Crossposting from HN as I'm quite curious: why is the symbol '|' used for or in pattern matching, not '||'? If '|' is used for bitwise or elsewhere in the language then this might lead to confusion, or at least seems slightly inelegant/inconsistent.
This post has been on hackernews, /r/go, /r/python, /r/programming, /r/hackernews, /r/javascript ...it really doesnt need yet another cross post with the same discussion.
I think you should move to github's gist to embed your code. You'll also get to refer line number in your explanations. My experience is once you change your template or layout, everything gets messed up
I find the iterator and `iter()` method names confusing, are they iterators in the C++ sense? They look more like C++ ranges (see ISO SG9 which is very active as well as eric niebler's Boost.Range-v3 library). I also find the: `for i in v` syntax more succinct than `for i in v.iter()`. In C++ they use non-member non-friend `std::begin` and `std::end` to obtain the iterators generically, but in the SG9 discussions an `as_range(v)` non-member non-friend function comes often up. The problem I see is: how do you implement `array.iter().map(...)` without providing built-in arrays with a member function?
I enjoyed reading these its just nice to link people to in work. I suck at explaining myself sometimes this is very well thought about good job!
I had a fairly thorough design involving using `Result`-based iteration and `for`..`else` some weeks back. I considered all the corner cases of it quite thoroughly; it bears some resemblance to what you have posted here, but is more polished. I didn't finish the write-up surrounding the proposal at the time and then did other things; it being a holiday tomorrow, I'll finish it off and post it.
The code style question came up in #rust a few days ago, and I found and posted this paper there, just as a curio on the topic (I believe snake_case more readable than camelCase). Turns out someone found it a few days later and posted it, or else happened to be thinking along the same lines independently.
Its plain old struct field inheritence &amp; compile time dispatch that i'm personally, missing ... there's a lot of situations where I've liked being able to just throw simple daatastructures together and extend them; with composition you end up getting longer paths for common values (i suppose you could get around that by rolling accessors, might not be so bad and might be macro-able, 'typeof' would help) i think those RFC's i've seen focus on the issues required for internal vtables - I wonder if the two problems can be adressed in an orthogonal way, or split into 2 seperate features, one building on the other
Hello, I understand your concerns so let me phrase out a few things. The new design is content-centric, using the typical typography guidelines &amp;ndash; a process similar to the one fleshed out by [the 1910 studio](http://blog.weare1910.com/post/75576312730/a-readable-wikipedia). This ties into the guidelines shown by [Matthew Butterick](http://practicaltypography.com/websites.html): a content-centric internet and it has nothing to do with Bootstrap specifically, it's just about doing away with default browser-styles and raising the font-size to have a proper view and better readability of content. Scrolling a bit more often is not an issue when you have a significantly more comfortable readability and less bloat. It is a minimalist and content-centric design, not a Bootstrap design. What's like Bootstrap: underline under the headings, the search bar highlights in blue when you click it. Having a higher point-size is crucial now that we the minimum common denominator in terms of screen is "decent". Please read [this article by SmashingMagazine](http://www.smashingmagazine.com/2011/10/07/16-pixels-body-copy-anything-less-costly-mistake/) that goes more into technical details with this matter, also most importantly [this article about responsive typography](http://ia.net/blog/responsive-typography-the-basics/) which is very comprehensive about point size, margins and how it should be set. No typographer, no designer will tell you otherwise and you'll see yourself having less trouble to concentrate and less squint when reading a text that has appropriate point size (16px and higher) and proper, aerated but not exaggerated line-height (120-145% &amp;ndash; of prime importance for readibility and when jumping to the next line of text). Nonetheless, I hope these four articles along with my explanations helped clearing some of your concerns&amp;mdash;hope you will enjoy this new design also. I already have a pull request ongoing that fixes some issues that have been reported.
&gt; but honestly I've got a hard time getting into it I followed your link and I'll be honest: it flew far above my head. I did not know Haskell allowed to throw exceptions to begin with :x
Uh oh -- time to update again soon? ~"" [is being replaced](https://mail.mozilla.org/pipermail/rust-dev/2014-April/009519.html) with "".to_owned(). There were a few big commits that changed this just about everywhere in Rust itself, and from what I've understood (I'm still very much a beginner, started last week), to_owned() is preferred now.
It is missing the possibility to *get back*, that is, you cannot know whether a `&amp;A` is part of a `(A, B)` tuple or of something else or even is stand-alone. This, in turns, makes safe downcasting impossible.
I would advise *against* looking at the core libraries of *any* language for learning purposes. I have dived into libstdc++ enough time to know it's easy to get lost, and Boost is even worse: trying to squeeze the last ounce of performance whilst being generic and cross-platforms takes its toll on the code readability. The goal of Rust is that *you* as a *user* should not have to use `unsafe` (or at least, only rarely). Note how despite using `unsafe` internally, the core library API is safe ?
Actually, C++ has weird iterators because you always need a pair of them to form a range (made so to match C's pointers). Most other languages have a single iterator that knows when to stop.
I guess it would seem a bit strange if &amp;(A,B) could just coerce to &amp;A. the thought arose as i was bouncing between composing a struct and composing a tuple to deal with the situations in question; what seemed nice about the tuple is avoiding needing to name intermediates. 
Side note: I've been using quiterss for a feed reader on Linux. There are several good options, both application and web-based, depending on what features you want.
 fn main() { let my_list = [1u, 2u, 3u, 34u, 5u, 6u]; let success = my_list.iter().all(|e| *e &lt; 10u); println!("Processed all elements: {}",success); }
tuple elements have a well defined order, so it could be a consistent rule, whatever it is; 
I have every sympathy for people writing C with classes, because the C++ iterator design is such a mess, it only became compelling for me to use them once there was 'auto' and range based for
Well, if you have any better resources to learn how to implement basic data structures such as a linked list in Rust, feel free to share. :-)
The unsafe code is in the libraries so that you won't have to write it yourself (in most cases, ymmv). Perhaps when we get to Rust 1.0 and semantics will no longer change, we can write a formal specification of the language and include correctness proofs for all (or most) uses of unsafe. I imagine separation logic will be sufficient for most cases that do not involve shared mutable state.
It's actually I am afraid a crucial weakness of Rust, that so few "basic" samples exist. I would wish for a repository of basic data structures, algorithms and design patterns as well; just to help newcomers getting situated. The problem at the moment is that given that the language still changes at quite a fast pace, keeping those snippets up-to-date would require some maintenance and make it difficult (I guess) to have them sitting on an external site (such as Rosetta code).
I am well aware of the tutorial, but it is only an introduction to Rust. However, it is not enough to implement some destructive operations (i.e. modifying the list "in place"/copy free without recursion), or to implement a double linked list, etc...
there's [std::any::Any](http://static.rust-lang.org/doc/master/std/any/trait.Any.html), but I don't think that'll help much.
As a suggestion, your error message would be a bit easier to read if you indent each line with 4 spaces. It looks like you might have been running into a bug in the error message. In older rust, we used to support declaring attributes as either module wide: #[feature(default_type_params)]; Or attached to a single value: #[deriving(Eq)] struct Foo { x: int } We've since changed the module wide declaration to this instead: #![feature(default_type_params)] Unfortunately I don't recall the argument for the change, it was before we started the RFC process. You ran into two bugs. First, it should be telling you to use the new syntax. Second, I don't believe we can feature gate a single value, so we should probably error out if you ever try to do that. I'll file bugs about it. Finally, I wrote up a quick example on how to use a custom hasher with a HashMap: #![feature(default_type_params)] extern crate collections; use std::hash::{Hash, Hasher}; use std::io::IoResult; use collections::HashMap; struct MyWriterHasher; impl Hasher&lt;MyWriter&gt; for MyWriterHasher { fn hash&lt;T: Hash&lt;MyWriter&gt;&gt;(&amp;self, value: &amp;T) -&gt; u64 { let mut state = MyWriter { hash: 0 }; value.hash(&amp;mut state); state.hash } } struct MyWriter { hash: u64, } impl Writer for MyWriter { fn write(&amp;mut self, buf: &amp;[u8]) -&gt; IoResult&lt;()&gt; { for byte in buf.iter() { self.hash += *byte as u64; } Ok(()) } } fn main() { let mut map = HashMap::with_hasher(MyWriterHasher); map.insert(1, 1); println!("{}", map.find(&amp;1)); }
An `enum` with variants for each type and implement the trait [FromSql](https://github.com/sfackler/rust-postgres/blob/master/src/types/mod.rs#L229)?
I poked around in `rust-postgres`, and I believe you need to use `stmt.result_descriptions()` to get the types of each column. I don't have postgres installed on my machine, but I suppose something like this would work: for row in stmt.query([]).unwrap() { for (i, ref col) in stmt.result_descriptions().iter().enumerate() { match *col { PgBool =&gt; { let v: bool = row.get(1 + i); println!("{}: {}", col.name, v); } PgInt8 | PgInt4 | PgInt2 =&gt; { let v: int = row.get(1 + i); println!("{}: {}", col.name, v); } ... } } } It's kind of nasty though because you need to list every type postgres supports, and there are a bunch of them.
The syntax for alternatives in Backus-Naur Form grammars, data constructors in ML-family languages, and the choice operator in regexes use `|` as well. I'm guessing it comes from one of those.
 #[deriving(Show)] enum List { Node (i32, ~List), End, } impl List { fn append(&amp;mut self, data:i32) { match *self { Node(_,ref mut next) =&gt; next.append(data), End =&gt; *self = Node(data,~End), } } } fn main() { let mut list = End; list.append(1); list.append(2); println!("{}",list) } Or something along those lines.
I think the following example from the documentation is close to what /u/haletonin asked for. This feature looks nice. fn inc_conditionally(x: uint) -&gt; Result&lt;uint, &amp;'static str&gt; { if x == uint::MAX { return Err("overflow"); } else { return Ok(x+1u); } } let v = [1u, 2, 3]; let res = collect(v.iter().map(|&amp;x| inc_conditionally(x))); assert!(res == Ok(~[2u, 3, 4])); http://static.rust-lang.org/doc/master/std/result/fn.collect.html
You can append and then use swap() to swap the location of the original pointer, effectively replacing the 'first' node. Have a look at http://static.rust-lang.org/doc/0.10/std/mem/fn.swap.html Actually walking over a list is more complex; look at each() in https://github.com/shadowmint/rust-blah/blob/master/list.rs
Thanks! For the record, I got the following to work, although it required altering the ResultDescription struct to make the ty and name members public (or creating getters or whatever). I wasn't able to get the PgInt8 | PgInt4 approach to work in the end, and it still needs fixing to allow null values and so on. for row in stmt.query([]).unwrap() { for (i, ref col) in stmt.result_descriptions().iter().enumerate() { match col.ty { PgBool =&gt; { let v: bool = row.get(1 + i).unwrap(); println!("{}", v); } PgInt8 =&gt; { let v: i64 = row.get(1 + i).unwrap(); println!("{}", v); } ... _ =&gt; { println!("Not yet implemented {}", col.ty) } } } } ---- I imagine that in general this isn't considered an ideal way of doing things, given the number of types we're talking about. In Java (or $TRADITIONAL_OO_LANGUAGE) I would be able to do something like the following after getting a value of an unknown type through JDBC: if (val instanceof Long) { //do some special processing for longs... } else { print(val.toString()); } This works because Java has a toString() on the base Object - but even if that weren't the case and it was on a different interface, I could still do an instanceof check to see if the toString was already implemented on the object for me, followed by a cast. Is there any Rust equivalent to instanceof to check at runtime if a type implements a trait (presumably Show or ToStr in this case)? Or am I best off doing something with macros?
The standard library serves as a common, efficient base to build real code off of. It builds safe abstractions out of fundamentally unsafe operations. Consider a refcounted pointer. If the refcounting logic is wrong, you can use-after-free, something rust is supposed to protect you from! But this logic has to exist somewhere. So it goes in the standard library, with an abstraction that is impossible to get wrong. Even though it's implemented with unsafe code, it exposes a safe interface so the rest of the codebase doesn't have to deal with it. This philosophy permeates idiomatic rust code. To write efficient code, you frequently DO need to do unsafe things. We just try to do it at as low a level as possible, and keep the majority of the logic safe.
I write a lot of modern C++11 code but haven't played around with Rust yet. It would be very helpful if you could explain a bit more about what is happening under the hood for your various examples. In your loop examples, you don't provide a comparison to a C++ range based for loop which I think mirrors the syntax in Rust the most closely. What does calling `.iter()` rely on? Does being iterable require a certain interface of the underlying class? I saw some discussion over at HN about using `enumerate()` for the for loops - some discussion on this would be great as well. If I had a vector of something heavier than an int, say some user defined type, am I getting a copy of the data in the loop or a modifiable reference to it? I feel like this series of posts is great for appealing to a novice C++ programmer, but doesn't do much other than show off some syntax to a more seasoned one. I would imagine that most C++ programmers in the back of their head are reading each line of code and thinking about what is actually happening to the data, what the overhead is, etc.
Here's your `print` function: fn Print(&amp;self) { let mut curr : &amp;List = self; let mut i = 0; loop { match curr { &amp;End =&gt; return, &amp;Node(x, ref xs) =&gt; { if i != 0 { print!(", ") } print!("{}", x); curr = &amp;**xs; i += 1; } } } } Append is a little tricky. I'll see what I can do.
Well, you can run Rust code *on* the device sure. Just use the android target and copy the binary over with adb and it should mostly work. Problem is it's pretty much limited to that. You can't use Rust to build an app for example.
I don't see an easy way to do this, but if it's any consolation, rustc manages to tail-call optimize this with -O. This is unfortunately quite difficult.
Hmm.. The docs said rust depends on llvm for tail call optimization
Yeah it's not something you can count on. The only way to check is to look at the assembly of whatever you're compiling. It's very hard to get right, because tail-call doesn't play nicely with destructors and lifetimes.
Yes, emscripten is the only viable option, unless you end up writing an interpreter in JS instead. Firefox OS supports standard web technologies; providing a new vendor-specific language defeats the purpose.
Cool thanks :) Btw.. is there a way to get a native / raw * pointer to ~?
You generally don't want one, but I think `as *T` might be what you want. You might need an unsafe block for it, though.
For sure. I understand a fundamental goal of FFOS is to be able to easily write apps using web standards. I do think, though, that as low end phones commonly have multiple processors - and relatively powerful ones to boot - the ability to write components in Rust wolud be greatly beneficial. The uniqueness typing scheme would also be extremely useful on devices with limited memory. Maybe this is my cue to go do something about it instead of bloviating ...
Here is the printing bit: enum List&lt;T&gt; { Node(T, ~List&lt;T&gt;), End, } impl&lt;T&gt; List&lt;T&gt; { fn nodes&lt;'a&gt;(&amp;'a self) -&gt; Nodes&lt;'a, T&gt; { Nodes { curr: self } } } struct Nodes&lt;'a, T&gt; { curr: &amp;'a List&lt;T&gt;, } impl&lt;'a, T&gt; Iterator&lt;&amp;'a T&gt; for Nodes&lt;'a, T&gt; { fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt; { match *self.curr { Node(ref x, ref next) =&gt; { self.curr = &amp;**next; Some(x) }, End =&gt; None, } } } fn main(){ let list = Node(1, ~Node(2, ~Node(3, ~End))); for x in list.nodes() { println!("{}", *x); } }
Thanks for the comments - I'll try and fill in a few more details about what is happening under the hood. I have another post planned (in a few posts time) which will cover iterators (including enumerate) in a lot more depth, and I'll try get into the implementation details a bit then. I'm finding it tricky in these early posts to introduce some concepts without getting into tangents on references etc. To answer your question about data in a for loop - iterators return an immutable reference to the data you are iterating over, so no copy. It will be a long series (time and motivation permitting). I'm starting with the easy stuff. I hope later posts will be much more interesting for experienced programmers.
Okay, this isn't pretty but you asked for it: use std::mem::swap; #[deriving(Show)] enum List&lt;T&gt; { Node(T, ~List&lt;T&gt;), End } impl&lt;T&gt; List&lt;T&gt; { fn append(&amp;mut self, data: T) { fn next&lt;'a,T&gt;(elem: &amp;'a mut List&lt;T&gt;) -&gt; &amp;'a mut List&lt;T&gt; { match *elem { Node(_,ref mut nxt) =&gt; &amp;mut **nxt, _ =&gt; {fail!("No next element")} } } let mut cur = self; loop { match *cur{ End =&gt; {break;} _ =&gt; () } let c = cur; cur = next(c); } swap(cur,&amp;mut Node(data,~End)) } } So it *can* be done, but the recursive version is much prettier.
They'd disappear because of the memory bloat you mean?
To expand on this, Rust has `Arc&lt;T&gt;` paying the necessary atomic reference counting cost to be `Send`.
I used an iterative version in the original version of that tutorial section. It was only a few lines longer than what's there, but not as easy to follow so it was changed. It doesn't have to be this this complex.
I'd be interested in that version, do you still have it lying around? It couldn't find it in the git history and I'd like to see how to do it properly.
Oops, the fields of `ResultDescription` should be public, but never got updated for the visibility changes. I'll fix that now. As to the root question, there are a couple of options. I could implement `FromSql` for `~Any` and have the huge switch statement internally. It wouldn't be able to handle third party types and implementations of `FromSql`, but I don't think that's a huge deal. Unfortunately, that wouldn't help with the "I just want to print this" use case. Returning a `~AnyShow` trait (`trait AnyShow: Any+Show {}`) would be closer, but there are some issues with trait objects that would make it impossible to actually use any of the methods you'd want to. The `Any` infrastructure really needs to be improved a bit. Another option is to add a `query_text` method onto `PostgresStatement.` The driver can tell the Postgres backend to return all of the results in their default textual representations which could then be returned in a `Vec&lt;Vec&lt;~str&gt;&gt;` or whatever. This will be a bit more flexible with respect to user-defined types, but you wouldn't be able to special case certain types anymore.
Nick has a PR to add DXR support to Rust, this would allow IDE support.
You can actually just implement `Deref`/`MutDeref` yielding the most commonly used contents (`.node` for `Spanned`) to get `spanned_t.some_t_method()` to work via autoderef.
Just take a look at the musl [libc](http://www.libc.org/) as another example of a readable standard library. It's quite beautiful code.
The problem is, once a company becomes large enough or has remote offices, you cannot enforce standards on the other groups due to the communication overhead and political bs. The only way you can really do it is through code. 
Sadly it was lost to the `rebase` gods... I never included the mutation examples I was working on in the final pull request.
You can't implement the `Iterator` trait that way, as it has an incompatible type signature. Either restructure your code to use iterators differently or don't use iterators there.
Me too interested.. Ladies n gentlemen.. Presenting uniq&lt;strncat&gt;
You can implement it for `&amp;'v ABC` and remove the lifetime declaration on `next` and the lifetime on `self` itself. (I have a feeling it might not work perfectly though; I second pcwalton's suggestion that not using iterators might be better.)
Could do with covering named loops. 'outerloop: loop { 'innerloop: loop { break 'outerloop; } } 
You can use `Cell` and `RefCell` on individual fields to get a mutable reference counted object.
Thanks, that works great!
Note that this means this `ABC` is much more restricted: it is chained to the stack frame which owns the `Vec`, and cannot be returned from it, or even sent to another task. And it also means the `Vec` cannot be modified (which is really the only reason to store a `Vec` rather than a `&amp;[]` if storing a reference is OK). Of course this can be rectified by storing a `&amp;mut Vec`.
Moving the switch statement internally would definitely provide some help, regardless of trait implementations: at the moment it's not possible to use PgInt8 | PgInt4 | PgInt2 in the match because I think the rust-postgres code relies on the type of the variable that's receiving the value to decide what code to run. If I try I (iirc) get an error about an unexpected PgInt4. If there was an option to decide that at runtime instead it would make this sort of situation easier. The query_text method would definitely help. For my use case I could take the (admittedly a touch shonky :-) ) route of printing out the string most of the time, and if I want to do formatting parsing the string back into its real type and using formatting methods. From your answer I take it there's no real rust equivalent to instanceof that allows me to determine if something implements a trait at runtime? Thanks a lot for your help and work on rust-postgres!
It's worth noting that although Cell and RefCell are 'safe' they are only 'safe' because internally they use unsafe * pointers to manage their memory contents. In many case you will find that manually managing unsafe pointers will be faster than relying on the Cell and RefCell implementations and will use (somewhat) less memory; you just need to be careful as to how you do it. The difference may practically be negligible in many cases, but Cell and RefCell are not magic band aids to the can-only-borrow-once problem in rust. I'd argue that in many cases (doubly linked lists is another example) unsafe pointers are a better implementation than relying on Cell and RefCell.
Designing a code documentation listing using the conventions of news websites and blogs seems unwise. One huge difference between the two use-cases, for example, is that code documentation is usually *searched* or *skimmed*, whereas prose is usually *read thoroughly and slowly* from start to finish. Being able to fit less text on the screen will make the documentation listings more difficult for anybody to search or skim. I've personally found myself scrolling frantically when using the new documentation style, and found myself exhausted by the rapid scroll-scan-scroll-scan which it requires. Furthermore, I've found that it's very easy to "get lost" on the document, or accidentally miss parts of it, when I'm forced to rapidly scroll away an entire page of content at once. Please also note that most programmers are younger men, and essentially all programmers spend huge amounts of time looking at ugly text documents, laid out using monospace fonts, in the smallest point-size they can tolerate. I suspect that, compared to the general population, programmers are much less likely to have untreated vision problems.
&gt; I'd argue that in many cases (doubly linked lists is another example) unsafe pointers are a better implementation than relying on Cell and RefCell. This wildly depends on the use cases. I agree that the data structures may indeed need inevitable uses of unsafe pointers, but in more general cases, `Cell` and `RefCell` encapsulate the unsafety out of other code and thus should be preferred over unsafe pointers.
Does the type system enforce that Arc is atomic? 
That link was supposed to be a source, not a tutorial. I'm not sure what you're trying to say here.
Nice work!
Hmm, but why is that? fn next(&amp;mut self) -&gt; Option&lt;A&gt;; Can't you set A = &amp;vec&lt;T&gt;? I mean, apparently having A = ~[T] works, so I figured &amp; would also work. Either way; what do you think is the best ("most rusty") way? My first thought was to simply mutate it in place, but then, in order to loop through all permutations, you would have to do while next_permutation(&amp;v) { // Use v } I thought that for p in v.as_slice.permutations() { // use p } was more elegant, though I would assume that cloning the array each iteration is costly. This is especially nice as the iterator approach returns the original vector in the first iteration, so that it actually does return *all* permutations. The while loop starts on the second, unless you code some state into it.
I tried compiling it (according to the directions in .travis.yml) and got the following error: $ rustc -L. rust-2048/src/main.rs rust-2048/src/game.rs:209:17: 209:28 error: type `~[int]` does not implement any method in scope named `push` rust-2048/src/game.rs:209 ret.push(i); ^~~~~~~~~~~ rust-2048/src/game.rs:227:21: 227:37 error: type `~[(int,int)]` does not implement any method in scope named `push` rust-2048/src/game.rs:227 ret.push((i, j)); ^~~~~~~~~~~~~~~~ error: aborting due to 2 previous errors I'm brand new to rust, so I might just be doing something dumb.
It's because the code was written for an older Rust version, where `~[T]` was a growable vector that had a `push` method. `Vec&lt;T&gt;` took its job.
I liked the one on [Heartbleed](http://thecodelesscode.com/case/140). Edit: and also [this one](http://thecodelesscode.com/case/8). edit 2: and [Void](http://thecodelesscode.com/case/50). I may be addicted.
I think the question you might mean to have asked is: Does the type system force one to use Arc when atomic access is required? The answer to that is yes. If you need to use a reference counter over multiple threads, the type system will not let you use Rc.More specifically, Rc is not `Send`, so it cannot be passed to another thread. Arc, on the other hand, is `Send`, so it can be sent to other threads.
Of course this talk is wild speculation for fun rather than real proposals, but itâ€™s not that ridiculous. Also: [SIMD](https://01.org/blogs/tlcounts/2014/bringing-simd-javascript), [value objects](http://wiki.ecmascript.org/doku.php?id=strawman:value_objects) (including 64 bit integers).
It hasn't finished yet. I'll fix the game logic soon. Thanks for posting it here. Currently I'm working on rewriting the game logic which is copied from [paraze/2048-rs](https://github.com/paraze/2048-rs).
There is an equivalent of `instanceof` in Rust, but in a more limited fashion. `Any` is a trait implemented by all types, and `~Any` can be used as a rough equivalent of `Object`: let foo: ~Any = ~10 as ~Any; match foo.as_ref::&lt;int&gt;() { Some(r) =&gt; println!("foo + 1 = {}", r + 1), None =&gt; println!("foo isn't an int"), } http://static.rust-lang.org/doc/master/std/any/index.html This doesn't really solve your problem, but something like this is closer to what you'd want: trait AnyShow: Any+Show {} impl&lt;T: Any+Show&gt; AnyShow for T {} let foo: ~AnyShow = ~10 as ~AnyShow; match foo.as_ref::&lt;int&gt;() { Some(r) =&gt; println!("foo + 1 = {}", r + 1), None =&gt; println!("foo isn't an int: {}", *foo), } We're explicitly stating that we need our types to implement `Show`, which means we *can* call it if we run into a type we don't want to handle specially. This doesn't work currently, unfortunately, due to this bug: https://github.com/mozilla/rust/issues/5665. `as_ref` is defined in a trait implemented for `&amp;Any`, but we can't currently get from an `&amp;AnyShow` to an `&amp;Any`. Note that unlike `instanceof` in Java, runtime type inference in Rust is opt-in. If you don't have an `Any` trait object, you can't do it.
Did you want to provide a link? Anyway, now I understand. Almost forgot about pattern matching. Thanks
Which version of IntelliJ does this work with?
ok - "safe downcast/upcast" - c++ dynamic_cast - is related to dynamic type information - this is simpler, just plain composing structs for static access - most of what i have done in the past has avoided vtables. this is literally just more about throwing a bunch of fields together and having similar looking code accessing the same fields. this is orthogonal to anything to do with vtables, although maybe it would make faking c++ multiple inheritance with embedded vtables / embedded objects easier, by throwing trait-objects together
I have another question about this same example. what does the '~ref' mean? The tutorial talks about ref but not the combination of '~ref': &gt; In a pattern, such as match expression branches, the ref keyword can be used to bind to a variable name by-reference rather than by-value. 
Those are not part of the JavaScript of today. The backwards compatibility argument of asm.js is gone if you include new features being added in the future. With that argument gone, PNaCl is a much better bytecode.
I think it binds the data behind the ~ by reference.
I asked on [rust general questions IRC](http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust) and someone said this: &gt; if you have a ~int for example, doing a "let ~ref y = ~10;" makes y have type &amp;int and be a reference to the 10 inside of the ~int &gt; it's a case of the more general pattern matching syntax
From glancing over the rules: latency is important (it's a real-time system, slow response will get you disqualified), the task itself is simple and there's unlikely to be a need for existing libraries, and crashing will guarantee you lose. So rust looks attractive for its high performance and safety, and the small ecosystem is not a problem because there's likely to be little need for external libraries. There's also no requirement to maintain the code after the competition so they can just pick a rust version and stick to it.
I would assume Rust is being chosen for fun as much as anything, as high level languages like Python seem adequate. The contestants program has to control a virtual racing car, and communicate with a server using JSON over TCP. The server sends details of the track and car positions.
Prior uses of Rust in the programming contest: in the qualification rounds of [Google Code Jam 2014](https://code.google.com/codejam) there were [7 contestants](http://www.go-hero.net/jam/14/languages/Rust) who used Rust.
`print!` has gotten some optimizations. It should be pretty good, but it'll always be bigger than `printf()` because it's totally static. C++ exceptions are an important part of Rust, so that task failure can be contained and isolated. This is important for Servo, as well as many other applications. But it's a design goal to be able to strip it out with LTO. I don't recall offhand the exact invocation necessary to do this, but I know Alex Crichton had success with it.
That's really interesting, thank you! I appreciate you taking the time to explain it to me.
Yup, `~ref y = ~10` would be the rough equivalent to `y = &amp;*(~10)`
I don't think that it's ridiculous to suggest that people avoid `unsafe` blocks in their own projects unless profiling has indicated that they might be warranted. Few projects will have their `unsafe` blocks as scrutinized for correctness as the stdlib. And since the stdlib is intended to provide datastructures that are performant enough for 80% of use cases, it absolutely has an obligation to drop into `unsafe` if it prevents people from needing to do it themselves. It's not a double standard, it's just pragmatism. That said, if you think your use case is exceptional, nobody's stopping you. If wouldn't be a language feature if we didn't intend people to use it! Just don't expect us to encourage its use. If we could get away without `unsafe` anywhere, we would.
In `let ref y = ~10`, y would be a reference to the owned box (that is, a &amp;~int). In `let ~ref y = ~10`, y would be a reference to the value the owned box owns (that is, a &amp;int).
Ok I think that's the same as what I said but worded better lol.
Oh my goodness, I will use the hell out of this. My first question after deciding to learn a language is always *"Is there an IntelliJ plugin?"* Awesome work! Will try this out tonight.
What ever it is, be consistent! C++ allows [i], but not [i, j], so for multi dimensional subscripting libraries use (i, j). However, since that is what they use for multiple dimensions, some libraries don't see the point in providing [i] and provide (i) instead for 1D data. As a result, you need to use a `get` function that overloads on the type for indexing 1D sequences in generic code, since you don't know if your sequence implements [i] or (i), so you end up with 3 conventions! Whatever you choose ([] vs ()), stick to it and be consistent! If it is called _subscript operator_, allow it to subscript all kinds of sequences, in a consistent way! Learn from C++! Another thing that is worth noticing is, that some libraries implement multidimensional subscripting like this: [i][j] where [i] returns a proxy type that provides a second subscript operator. So yes you can emulate C by writing a lot of boilerplate. This is nuts, since what you are trying to do is conceptually very simple... and these implementations are unnecessarily complicated...
&gt; What ever it is, C++ allows [i], but not [i, j] at least with tuples [(i,j)] would instantly be a step forward over other ways of doing 2d indexing, [i,j] would be the icing on the cake, if they can do that. There's plenty of cases where rust could improve on syntax cruft in C++. I hadn't minded proxy types so much, eg getting a scanline from an image made sense
I'd love to see something like this evolve to include static analysis on borrow lifetimes and such to indicate errors you will get if you compile and then even support refactoring of lifetimes to make them work in their given usage scenario. This has a lot of potential.
too bad they chose 0.9 (0.10 was released or really close to release at that time)
As of 3 days ago, it looks like 12.1 or better and JDK 1.6. or better - according to a comment in this issue: https://github.com/Vektah/idea-rust/issues/1
The best documentation I could find is in META-INF/plugin.xml in the description element. It says: "PLEASE NOTE: This does not yet do any auto completion. It is JUST the lexer and highlighting for .rs files. The rest is coming soon!" 
That contest seems quite cool, but I am wildly annoyed by the fact that I can't seem to find out what it actually is about anywhere on the web page. I code a racing AI and I communicate with a server using JSON over TCP. I got that. But what are the actual rules of this game I have to provide an AI for (I assume it is a game. Maybe we are racing actual RC cars? I dunno). Are we talking realistic 3D environments and simulated laser scanners or is it a simple 2D simulation with direct access to all information? An example of what kind of challenge this is could be nice. 
https://helloworldopen.com/techspec
I wouldn't get too excited , the rust AST isn't up to complex IDE support yet , and the AST is changing (@ pointers being refactored) . The community needs to figure out how to hack something on top to compile incomplete code, compile incrementally etc, and its' a moving target.
If you could post that exception message on the issue tracker I will see if I can get it fixed. The hard part is knowing what conflicted.
It should be available in the built in pluging manager in intellij
Ah - /Atomic/ Rc. 
I participated in a [similar contest](http://ants.aichallenge.org/) and while I started off with Python, I ended up learning C++ (C++11!) because the limited turn times made the choice of language *incredibly* important. There were few libraries available on the server and your upload had to be small, so the Rust of *today* would have been a better choice. I did [pretty well](http://ants.aichallenge.org/profile.php?user=2255) and I think a lot of that had to do with choosing a language where I could do a lot more work in a turn. You can always find *something* to spend time brute-forcing.
Fabrice Desre, one of the Firefox OS hackers, has done some experimentation with porting Rust to FFOS, though not publicly. As an end-user language of course Rust doesn't have a place there since FFOS is a JS-only device, but there is lots of systems code that could be replaced with Rust.
It would be awesome if you could x-post this over at /r/IntelliJIDEA !
Nice, I show up on there. Now if I can only not miss the next round, that would be great :D.
--emit asm
note to others: it's not available in phpstorm, but is available in intellij idea community edition. now to get `rustc` working. **Edit:** needed mingw. got everything working now. You can create a run configuration if you install the Batch Scripts Support plugin and then configure it: http://i.imgur.com/kEHOmao.png
http://www.mpi-sws.org/~turon/
Phpstorm (and the other language specific variants) remove project specific config as well as the ability to have multiple modules in the one project. While these features are not currently used I am hoping to leverage them for crate boundaries. Regarding rustc I'll be hard at work completing the grammar for the next few weeks but its definitly on the list of things to do. Pull requests are always welcome ;)
I just wrote my first hello world program in rust (thanks to you), so... yeah, not going to be submitting any PRs any time soon, but I do appreciate your effort :-)
Unique ownership vs. shared ownership. I.e. it's just making sure it's super clear that we're *not* talking about `Rc` etc. (which do have some form of ownership of its data, just with several different handles pointing to it).
Sure thing. I'll try to reproduce it tomorrow. Edit: I thought I'd be able to reproduce this on my other machine, which is running Mountain Lion, but there was no conflict there. Later tonight I'll go home and look through ~/Library/Logs/IntelliJIdea13/idea.log to see if there's a stack trace. Edit: it's a bust. Couldn't find anything in idea.log, and I couldn't reproduce the problem by uninstalling the plugins and trying to re-create the original configuration. Sorry.
That's kind of what I was thinking.
How about a readme and a license for your repo?
&gt; at least with tuples [(i,j)] would instantly be a step forward over other ways of doing 2d indexing, [i,j] would be the icing on the cake, God I want this so bad. If we can type something like: let v = A*B[:,2] where `A` and `B` are matrices, and `v` is a vector, I will be ever thankful to the devs. I want a static language for numerical programming that can go from prototype -&gt; production in an iterative fashion, instead of the common Matlb -&gt; Fortran/C++ that is my current method.
Thank you. I wasn't able to find that.
I just read the LVish paper (or the beginning of it) and I was very impressed. I wonder exactly what Aaron is going to be working on in the Standard Libraries, but I guess it will involve some concurrency/threading stuff.
For such a particular use case, it would be cleaner to create a dedicated macro with its own matrix-oriented syntax. In my opinion, the indexing operator should be kept the simplest possible (or even removed entirely, actually).
I like having a debug macro a bit like that, i call it 'dump', which prints file:line foo=... bar=... ... ; i think i saw an feature request from someone trying to add this but they figured it didn't belong in the stdlib
ah I didn't realise task failiure used the same mechanism as exceptions under the hood - for games we'd always worked with exception handling disabled - the option to strip it out sounds nice, Is there anything in the semantics of task failiure vs exceptions that might make it less expensive than exceptions are (the fact the whole task fails seems simpler than having to unwind state and recover program flow..) might it be possible to control on a per task basis - (spawn a task that might fail, vs spawn a task that you assume isn't going to fail and it's just plain old crash if it does )
Thought this might be of interest, since it seems to do a similar thing to Rust's macros.
AFAICS the pull request was closed due to inactivity, but the issue is still open. * https://github.com/mozilla/rust/pull/12426 * https://github.com/mozilla/rust/issues/12015
This is an excellent idea. I didnt post this in the ticket because I didnt feel it was within scope, but I feel as though I can speak for a lot of people in saying that Rust is our first low level language. With that comes a lot of frustration with things like builds, compiler options, debugging flows and finding documentation (especially for those that have always had a REPL at their disposal), etc. A cookbook style format would be extremely helpful for someone like me for a lot of the project creation and workflow type of issues.
seems like a low priority to me, but then again, syntactic convinience with the clean break from C++ is a way to draw people in , if they otherwise think it's just "C++ with a static analyzer"
There's one being developed for Mozilla by Tilde. It's still very young: https://github.com/carlhuda/cargo
If only I had infinite time :cries:
&gt;&gt;"and maybe the variable name as well if rust macros allow for getting that" I've been very impressed with rusts macros, yes you can make it print "expression= &lt;what the expression evaluates to&gt;" just fine. 'stringify!()' And the $(..)* repeat stuff works great. Convenient and informative.
I am under the same impression. Is Cargo going to do boilerplating as well? 
Thanks for your quick fix. :) I've refactored the game logic. Make it consistent with the original JavaScript version.
Thanks. :)
How would that work with a macro?
I'm really confused by your shorthand notation. &gt; some libraries don't see the point in providing [i] and provide (i) instead for 1D data. Does that mean they provide `object(i)` but not `object[i]`? &gt; â€¦so you end up with 3 conventions! Wait, what are the three conventions? `object[i]`, `object(i)`, and `object.get(i)`?
 macro_rules! dump{ ($($a:expr),*)=&gt; ( { let mut txt=StrBuf::new(); txt.push_str(file!()+":"+line!().to_str()+":"); $( { txt=txt.append( format!("\t{:s}={:?}",stringify!($a),$a)+";") } );*; ::std::io::println(txt.as_slice()); } ) } .. but might want to be log! instead of println.. personally i like it having file:line. Can just say dump!() to show file,line, or throw in any number of expressions to show their value.
Use `push_str` not `append`. (Even better would be using `write!` to avoid allocating for each `format!`.)
I think it would be possible for a macro to interpret your example as is. Assuming a library that provides the Matrix type and the "matrix!" macro that evaluate to a Matrix, then you could write : let v = matrix!(A*B[:,2]);
Would a write for each chunk be better than using a strbuf with some sensible initial capacity; do you think there is enough demand to include a standard implementation.. Or is there too much user taste involved 
Further to this, imagine if casting a tuple extracted the element of the requested type , only if unambiguous of course (A,B) as A == lhs.val0() (A,B) as B == lhs.val1() (A,A) as A == compile error because its ambiguous Perhaps even... (A,B,C) as (A,C) == (lhs.val0(), lhs.val2()) Would this save examples where you create an intermediate struct just to name access to a composed type.... Leverage the names you've already created and extend the convienience of tuples... Could trait objects be generalized as ( vtable, pointer ) and 'internal vtables' be represented as ( vtable, data) - as if internal vs external data was a bit like autoderef on data ... Not sure how typesafety on that would work though, it would be like the data and pointer were exposed to abuse. but if you had an intrinsic type for the vtable, it could be constructed and coerced appropriately? 
I think the main problem is if your using them you have too many nested loops. Actually if you have a loop inside a loop you probably have too many nestings and should refactor.
It is indeed a fine use of the [`ItemModifier`](http://static.rust-lang.org/doc/master/syntax/ext/base/enum.SyntaxExtension.html#variant.ItemModifier) syntax extension. Some suggestion: I think every internal identifier starting with `__` should be generated with [`gensym`](http://static.rust-lang.org/doc/master/syntax/parse/token/fn.gensym.html) instead. It is currently possible to refer to `__trace` (for example) inside the instrumented function, though it can also be regarded as a feature...
I think you will find that the only way to access a mutable vector from multiple threads like this is using a `Cell`. I ran across the same problem when I implemented a parallel merge-sort - you can see the code I used for sharing the vector here: https://github.com/am0d/rust-projects/blob/master/sorting/merge-sort-par.rs#L28-37 
Thanks, this seems really close to what I'm trying to accomplish. The blog post I linked to mentioned `Cell` as well, but it doesn't seem very 'elegant.' Oh well. 
It is not possible in general. Well, it is a good example of how the rich type system of Rust prevents the unsafe practices, and how it gives another headaches (ugh!). The [owned closure](http://static.rust-lang.org/doc/master/tutorial.html#owned-closures) (which `spawn` receives) can't share anything mutable by default, as it *can* run on the other tasks. You may choose them to run on the current task, but in general you can't guarantee that (if you can guarnatee that, use the [normal closure](http://static.rust-lang.org/doc/master/tutorial.html#closures) instead). Moreover, the owned closure can't share anything borrowed (`&amp;[int]` etc.) because it cannot check if the borrowed reference won't change by other tasks. `Send` is a [built-in trait](http://static.rust-lang.org/doc/master/tutorial.html#traits) used to denote the latter [1], and `&amp;mut [int]` obviously does not implement `Send`. [1] The former is prevented by more general type system guarantees: there are no safe global variables, and any immutable `Send`-able values can be *copied* into the owned closure. For normal types, there are several abstractions for safely sharing immutable or mutable values among multiple tasks ([libsync](http://static.rust-lang.org/doc/master/sync/index.html) has a lot of them). Unfortunately, we don't have a safe abstraction over partial slices of the vector yet, and you have to rely on the unsafe mechanism (casting `&amp;mut [int]` to the pointer and length, send to other task, casting back to `&amp;mut [int]` and process).
`arr.slice(0, middle).to_owned()` and others will copy, so it is not what the OP would want.
Alright. A bit disappointing, but very informative - thanks. Related to what you said in the last paragraph, I found [this thread](http://www.reddit.com/r/rust/comments/1wi3p5/does_or_will_rust_support_shared_memory/). It seems like what I'm looking for is planned, but not available any time in the near future. Bummer. 
I spent a while confusedly staring at this until I clicked through and realised it's an *ARM* stack. More specifically, zinc is: "an experimental attempt to write an ARM stack, that would be similar to CMSIS in capabilities but would show rust's best safety features applied to embedded development".
I completely agree with assert+enforce, I don't really understand why not enforce; do people think it would be ambiguous? Also a very interesting idea about anonymous modules, I'd love to hear more discussion about it.
I would be very *very* interested in seeing a write up of the pros of returning `~[]` from library functions from the perspective of some who supports it: I can really only think of the binary compatibility with `&amp;[]` as a solid positive; everything else positive that I can think of has downsides too (e.g. the nice `~[]` syntax doesn't support allocators nicely).
çŒ«çŒ«å¾ˆéœ¸æ°”= = å“ˆå“ˆ
FYI: standard Rust style has `snake_case` for functions and methods.
Yes, a nongrowable vector. The problem is the risk of overusing `~[]` despite the cost of conversion and loss of information compared to `Vec`, as well as the cognitive overhead of even more types when just using `Vec` is perfectly appropriate.
This episode is a bit dull, but next time, the fun stuff - pointers!
It's not clear from your comment if you're working with this in mind: `enforce!` is the nondisablable assertion, `debug_assert!` is disablable.
Whoops, thanks. Old (sloppy) habits die hard.
The problem is that in tests (or helper functions called by tests) people might write `assert!()`, which is the wrong thing. I prefer `assert`+`enforce` myself for similar reasons that you gave, but I can see the argument in favor of `debug_assert!`+`assert!`.
Yes, a bit of bad naming out there. I'm ok if anyone wants to contribute code for some other platform, but apart from ARM I have experience only with AVRs, and llvm-avr is a PITA, so no rust out there for now.
Great to see some windows community contributions!
In Python, one of the very few things `-O` does is disable asserts.
Teepee looks like a cool project! Be warned that `TcpStream` still has some problems. In particular, you can't shut down a stream that's blocking on `read()`. This can be problematic if you don't know exactly what you're expecting to receive on the stream. See the comments near the bottom of: https://github.com/mozilla/rust/issues/11165
Would also love to hear thoughts on library design, specifically good practices and pitfalls that are Rust-centric.
Ahh, yes. I really should get around to that. As the plugin page says licence should be your standard BSD 2 clause.
I haven't touched a line of Rust, but I've been designing various libraries for a while, including one that's used as a user-facing component of a major commercial project. Library design is very similar to internal abstraction design on a large project, with the added difficulty that the user can't walk over to your desk and ask what you were thinking. The goal is to make it so that intuitive things work and non-working things fail to work in a really obvious manner. * *Simplicity* - Try to avoid megafunctions that do half a dozen semi-related things. If you can't write a one-sentence summary of a function's use, your interface needs to be simplified. Yes, it's real tempting to say "hey, I keep doing X and Y and Z and they're all kind of the same so I'll put them in one function with some flags" - don't do that unless you can come up with a way to define them in terms of a single common behavior, and remember that the user is capable of writing functions themselves, and they can always write helpers. * *Orthogonality* - However, if you don't provide the tools needed to do X and Y and Z separately, the user may not be capable of getting the control over the library that they want. I've found it helps to think of a library as two parts - the "core functionality" and the "utility functionality". The utility functionality is looser on the "simplicity" front, in that it can do big composite things if those things are common, but it must be written solely in terms of public core interfaces. This ensures that if they don't like a detail of your big composite behavior, they can always rewrite it without that behavior. * *Terminology* - No term should refer to two concepts. No concept should have two terms. Try to keep your terminology simple and intuitive. It can help to write down a list of all terms you'll need before you start writing the library, so you don't end up in a mess like I'm in right now where I have two completely unrelated things called "textures". (One of them is getting renamed to Sprite - thankfully this particular library isn't even alpha yet, so I can break compatibility without concern.) * *Abstraction* - The user cares about the interface. The user doesn't care about the internals. If you have to jump through horrifying hoops in order to provide a clean interface, do it! * *Testing* - Test extensively. Use a continuous integration package. I've heard rumors that SQLite's test suite is actually 2/3 of the entire SQLite codebase. This is a good thing. You *will* break your library accidentally when working on it. * *Dogfood* - Use your own library. If you don't use it, you'll never know what's annoying about it. * *Documentation* - Write documentation. Send it to a friend. Rewrite a lot of it if it's unclear. Documentation is a constant effort and it will never be "done". * *Error handling* - To the best of your ability, make sure that every error condition is checked for and reported in detail. Your library should never fail with a generic error. Your library should *absolutely* never fail silently. * *Really advanced stuff* - Mature libraries should generally provide hooks for error handling and memory allocation, because you never know when someone's going to want to run your library on a toaster that can communicate with the outside world only through a proprietary twelve-pin serial interface. You don't have to worry about this for quite a while, however.
&gt; It's weird; C is very vague. It says that you should pick something that is at least big enough to store the integers that are in there. Actually C (and C++) regarding `enum` are precise. Weird, but precise. In short, you need to pick the smallest `k` so that you can represent all combinations of `|` enum values in `2**k` bits, and it's only signed if at least one value is negative (in which case you assume 2-complement for the bit representation). The important point is that `k` is not constrained to 8, 16, 32, 64 even though the ultimate types are and therefore the compiler can assume, for example, that if `k` is 21 then only the 21 least bits are used (and happily truncate the rest). As usual with C, thus, storing a value that does not fit in `2**k` bits is undefined behavior. In C++11, `enum` can now "inherit" from an integral part, which: - makes it possible to forward declare them: `enum: uint16_t;` - plays more nicely with ABI stability: whereas before adding a new constant could switch the representation under your feet, now since *you* specify the representation the compiler can warn/error that the new constant does not fit and you can choose whether to switch the underlying type (ABI breakage) or forego the new constant
I am also perfectly happy with the choice of `assert!` and `debug_assert!`, and I am mainly a Java and C++ programmer (two languages where assertions can be disabled). Assertions are a tool for detecting logical errors at runtime. If a logical error happens in your code, you don't want to execute the code further, because you will end up with either a crash further in the code, incorrect results, or corrupted data. I don't see the point of removing these guards in the release version of softwares, where such incorrect results and data corruptions will potentially have disastrous effect when they happen to the users. That's why I'm happy that the shorter version, `assert!`, is the one that can't be disabled. There is one reason to remove those guards: when performance really matters. For these cases, it's great to have `debug_assert!` around. And I think it's a good name, I'm pretty sure I won't get the two names mixed up. That would be different with a name that is a synonym of `assert!`, like `enforce!`.
I'm 100% sure I will forget which one can be disabled, if the names are `assert!` and `enforce!`. Maybe it's because I'm not a native english speaker, but these two words are too close in their meanings to give a clue of which one to choose.
Somewhat similar, but not doing the `push_str` stuff manually: macro_rules! dump( ($a:expr) =&gt; ( println!(concat!(file!(), ":", line!(), " ", stringify!($a), " = {:?}"), $a); ); ($a:expr, $($b:expr),+) =&gt; ( println!( concat!( file!(), ":", line!(), " ", stringify!($a), " = {:?}", $(", ", stringify!($b), " = {:?}"),+ ), $a, $($b),+ ); ); ) 
These articles are great, thanks for doing them!
[previous discussion](http://www.reddit.com/r/rust/comments/22wksv/rfc_add_regexp_crate_to_rust_includes_compile/)
&gt;&gt;"ban fail!() and things like unwrap" ... that doesn't seem so suitable, its more like you want to unwrap to become something that crashes - and you've verified through testing that it doesn't. (plenty of cases where assumptions can be logically made, and empirically verified, its just at a micro level no language is yet up to verifying that logic automatically) perhpas it will require llvm hackery to produce performance-oriented code where you basically used fail!(), unwrap!() etc as glorified asserts (shiping a game, your main program cannot fail, it would seem like going too far to just mark the whole thing 'unsafe{}', but one does want to be able to exploit assumptions sometimes... I realise this might not be rusts' primary environment. There was also the idea of doign something ilke PGO, empirically recording what can 'fail' 
It'd be nice to be able to tell the compiler that they are separate with dependent types or something...
Yes, it's plannedâ€”we've talked about it for a while. It would be implemented as unsafe code that uses the `Share` trait. Pull requests welcome if you end up making your own abstraction :)
there are `app_blink.rs` and `hello_blink.rs`, and they are slightly different. could you tell something about the differences?
Yes, Rust ditched octal. I believe we changed the precedence of `&amp;`.
&gt; e.g. the nice ~[] syntax doesn't support allocators nicely Is there something that prevents doing that via implementing a `trait`?
Actually, that could probably be something that `cfg` is good for, I could imagine a `#![cfg(no_fail)]` for example. `unwrap`, in particular, can be avoided as long as one is willing to pattern-match by oneself.
The implementation of exception-handling in LLVM, if I remember correctly, follows the Zero-Cost Exception strategy: - it has zero-cost on non-exceptional paths - but has a high cost (10x/20x that of an `if`) on the exceptional path The cost is spread between: - memory: the side tables require to map each program point to their appropriate handler take space and of course the handlers themselves take some space as well; they are however bundled together in a specific section of the libraries so they need not be loaded unless you use them (thus they only take memory if you actually throw an exception, and even then the tables are lazily loaded) - cycles: because the first access to a side-table implies loading said table from cache, it is frequently a cache miss and may even be a memory miss; furthermore the machinery involved for unwinding is slightly heavyweight So, should you fear it ? - from a memory point of view: no, it seems silly. Any decent library loader will avoid loading unused pages in memory. - from a CPU point of view: you might find that unwinding a single task is much faster than crashing (between the crash itself and the restart) Should you just crash ? - from a debugging point of view: a crash might indeed be better (more context) - from a resiliency point of view: uh... the downtime is daunting, and the absence of cleanup even more! All those pending requests that will now timeout, all those database connections left hanging (until their own timeout), ... &gt; i've never bothered learning how to write exceptionsafe code in C++ I've never seen resilient code that did not have the Basic Exception Guarantee. An exception is nothing more than an n-th path for the flow, among so many others (`return`, `break`, `continue`, `goto`, ...), that code that is resilient to the addition of any other keyword is naturally resilient to exceptions as well. Hint: if you are using `try`/`catch` for this you are doing it wrong.
Amazing!
&gt;&gt;from a resiliency point of view: uh... the downtime is daunting, and the absence of cleanup even more! All those pending requests that will now timeout, all those database connections left hanging (until their own timeout), ... Oh no question , graceful task failiure seems great for rusts' primary target, and certainly the right default. Its console games (i hear of similar considerations in "embedded") where I've never used exceptions. Usually a game should be designed such that anything 'exceptional' is handled by design, for example, you dont load a texture then catch an exception if you run out of memory - you premptively prioritize what is in your texture memory, based on camera movement -and evict the least-needed, and fill that space with new textures, based on context. etc.
By 'ban fail!()' I meant 'ban your coders from commiting anything containing fail!() or a call to a function that can fail' e.g. making them pattern match properly (which is often overkil and hard work (and rather silly)). Making failure a call to abort() or a disabled by a compile-time option (as matthieum says) would be nicer, but at this moment in time I don't think there is a better way to avoid task failure.
&gt; it has zero-cost on non-exceptional paths This is true in the sense that it never adds extra instructions to the non-exceptional paths, but it certainly causes a performance loss due to missed optimizations. For just one simple example, a function that's not `nounwind` can not be treated as pure and hoisted out of a loop.
The hard-wired unique pointers don't take an allocator type parameter. To add allocator support, we would need an allocator lang item to hard-wire the trait into the language. I think it makes far more sense to just use a library-based unique pointer type, and it also removes one more confusing sigil from the language. I've had to explain to countless people that unique pointers are not special and work just like library types with destructors... the language is overcomplicating something simple.
&gt; Actually C (and C++) regarding `enum` are precise The issue is that they only define the minimum size. Most platforms start off with `enum` having the same size as `int` for legacy reasons, but have a switch like `-fshort-enums` to use the minimum size. This varies across different platforms, as some newer ones use "short enums" by default.
Maybe I don't get the point, but wouldn't something like libdispatch be much easier?
Fantastic work! I've been using the library to do some basic HTTP request routing and it's worked out swimmingly. (I also happen to be a fan of RE2 in general, I'm very happy to see it in the distribution.)
&gt; I've had to explain to countless people that unique pointers are not special and work just like library types with destructors... That totally makes sense now that you mention it. I guess I really see the appeal now :) What about taking that a step further and having post-DST `~[T]` become another library type (e.g `Array&lt;T&gt;`)?
There will be no distinct `~[T]` type at all after the DST changes. There's no need to make it a special library type, and there's very little use case for `~[T]` (`Uniq&lt;[T]&gt;`) anyway since we have `Vec&lt;T&gt;`. If there was, we would also have a use case for stuff like a hash table without a capacity... I don't think we do.
Afaik, that could become `Uniq&lt;[T]&gt;`.
i'd be curious to see more syntax extension examples, wwith a lot of commenting to explain how they work and whats posssible.. sounds like it has interesting possibilities. 
The situation isn't as bad as you make out; solid HTTP/2.0 support won't be possible without the ability to close a stream, and for HTTP/1.1 it won't have the ability to time out connections, but for the moment it'll be OK to depend on clients or a reverse proxy doing that. It's not a long-term solution, but it's not going to be too serious a problem (except for the fact that it allows a fairly easy DoS attack of the resource exhaustion variety---open many sockets and leave them open). As I've said before, until it is audited in some way I wouldn't recommend exposing a rust-http or Teepee server to the world other than behind a reverse proxy of some form.
Wrong subreddit. There's no guns here though... 
Are these as powerful as .net's?
Exciting news. I can't wait to see what comes of it.
No. .NET regexps support backreferences, which are impossible to implement efficiently. This implementation is a near port of RE2, which gives up backreferences (and generalized zero width assertions), but in exchange has `O(mn)` worst case time complexity. (`m` is proportional to the size of the regexp and `n` is proportional to the length of the search text.) Also, this crate can compile regexps to native Rust code. I don't think .NET has that.
I was against shadowing when we added it, but I can't imagine living without it now. In Rust, the situation is not like in weakly-typed languages where it's easy to make mistakes with shadowing; in Rust you are going to get a type error. Shadowing is very common in Rust for building up values without introducing a bunch of throwaway unique identifiers: let name = get_raw_name(); let name = name.to_str(); // Change types let name = name.trim(); let name = name[0]; // Change types again Awful example, but that's the idea.
/r/playrust
Hahahahahaha woops
Variables are immutable by default, so in pretty much all cases, removal of a shadowing declaration would just lead to compiler errors instead, and any direct assignment to them is immediately suspicious.
To add to this: most misuses (e.g. `let`ting a new variable, when you meant to modify an old one) will trigger lints like unnecessary use of `mut`, dead assignment or unused variable.
klutzy and vadimcn have been consistently working on our windows support for months and months, fwiw. (E.g. tracking down the causes of &amp; fixing some very weird bugs, support for mingw-w64 and then using that to support true 64-bit windows builds.)
Rust has supported 32-bit windows for a long time. (That said, proper 64-bit support is awesome.)
You might consider [julia](http://julialang.org/). I suspect it does what you want. Still, I agree that it would be great if rust's [] index trait supported slicing like python's.
This subreddit is for Rust the programming language, not Rust the game.
You mention Spray which has a heavy enphasis on being asynchronous. Are you planning on supporting asynchronous operations with native threads? Rust seems to have no support for this currently, but I assume it will get support eventually.
Yeah, but these days 32-bit is almost useless. 
lol thanks 
Yeh, I saw he was friend of the tree this week, I just meant it was nice to _see_ the windows stuff, there seems to be a widely held impression out there that windows support is lacking.
It's not, 32-bit apps run on 64-bit platforms (mostly) fine.
As someone who gets a majority say what technologies my company uses, I would never vouch for anything 32-bit only. It's far too limiting. 
But...if those features aren't used, you wouldn't incur the extra performance cost, would you? Or would you essentially have to implement two different algorithms to achieve that? I find backreferences *very* useful. And what do you mean by "generalized" zero-width assertions? It still supports `\b`, `^` and `$`, right? What about `(?=a)`? &gt; Also, this crate can compile regexps to native Rust code. I don't think .NET has that. Without some measurements, I'm not entirely sure what the implications of that is. Or what that evens means. It unrolls the FSM and gives you source code??
I want rather to cross-compile *rustc* to ARM.
&gt; Or would you essentially have to implement two different algorithms to achieve that? Yes. And if backreferences are used, then the regexp can take exponential time to execute. [Russ Cox goes into more detail](http://swtch.com/~rsc/regexp/regexp1.html). The rest of the articles in that series are also worth the read. &gt; I find backreferences very useful. Indeed they are! &gt; And do you mean by "generalized" zero-width assertions? It still supports \b, ^ and $, right? What about (?=a)? Yes, it supports `\b`, `^` and `$` because they require at most one-character lookahead. `(?=exp)` requires arbitrary lookahead and is difficult to implement efficiently. &gt; Without some measurements, I'm not entirely sure what the implications of that is. Or what that evens means. It unrolls the FSM and gives you source code?? Pretty much, yes. It's done seamlessly with the `regex!` macro. You can see examples here: http://burntsushi.net/rustdoc/regex/ The cool thing is that a regexp compiled at compile time and one compiled at runtime are indistinguishable from well behaving clients. The advantage of this approach is that you can optimize the VM that executes the regexp. For example, removing all heap allocation or converting binary searches to simple `match` expressions. Here are some comparisons. "dynamic" regexps are compiled at runtime. "native" regexps are compiled to native Rust code at compile time. name dynamic regexes native regexes ----------------------------------------------------------------------------------------- anchored_literal_long_match 487 ns/iter (+/- 11) 154 ns/iter (+/- 2) anchored_literal_long_non_match 8155 ns/iter (+/- 634) 5410 ns/iter (+/- 64) anchored_literal_short_match 472 ns/iter (+/- 16) 149 ns/iter (+/- 1) anchored_literal_short_non_match 900 ns/iter (+/- 6) 454 ns/iter (+/- 2) easy0_1K 7533 ns/iter (+/- 87) = 135 MB/s 1281 ns/iter (+/- 159) = 799 MB/s easy0_32 5199 ns/iter (+/- 111) = 6 MB/s 262 ns/iter (+/- 1) = 122 MB/s easy0_32K 86868 ns/iter (+/- 783) = 377 MB/s 33968 ns/iter (+/- 2241) = 964 MB/s easy1_1K 9125 ns/iter (+/- 988) = 112 MB/s 1890 ns/iter (+/- 622) = 541 MB/s easy1_32 5714 ns/iter (+/- 174) = 5 MB/s 372 ns/iter (+/- 79) = 86 MB/s easy1_32K 126966 ns/iter (+/- 4464) = 258 MB/s 51002 ns/iter (+/- 3982) = 642 MB/s hard_1K 60998 ns/iter (+/- 423) = 16 MB/s 33377 ns/iter (+/- 240) = 30 MB/s hard_32 7283 ns/iter (+/- 43) = 4 MB/s 1342 ns/iter (+/- 16) = 23 MB/s hard_32K 1779833 ns/iter (+/- 5978) = 18 MB/s 1061047 ns/iter (+/- 9319) = 30 MB/s literal 434 ns/iter (+/- 3) 134 ns/iter (+/- 2) match_class 2457 ns/iter (+/- 12) 1391 ns/iter (+/- 7) match_class_in_range 2707 ns/iter (+/- 12) 1433 ns/iter (+/- 3) medium_1K 37968 ns/iter (+/- 637) = 26 MB/s 17165 ns/iter (+/- 210) = 59 MB/s medium_32 6196 ns/iter (+/- 124) = 5 MB/s 809 ns/iter (+/- 38) = 39 MB/s medium_32K 1053551 ns/iter (+/- 5442) = 31 MB/s 541218 ns/iter (+/- 4247) = 60 MB/s not_literal 1930 ns/iter (+/- 9) 1051 ns/iter (+/- 6) one_pass_long_prefix 1133 ns/iter (+/- 7) 395 ns/iter (+/- 8) one_pass_long_prefix_not 1145 ns/iter (+/- 4) 402 ns/iter (+/- 3) one_pass_short_a 2108 ns/iter (+/- 11) 1329 ns/iter (+/- 16) one_pass_short_a_not 2577 ns/iter (+/- 81) 1635 ns/iter (+/- 52) one_pass_short_b 1509 ns/iter (+/- 6) 913 ns/iter (+/- 2) one_pass_short_b_not 1997 ns/iter (+/- 27) 1141 ns/iter (+/- 2) replace_all 3735 ns/iter (+/- 34) 1271 ns/iter (+/- 14) TL;DR - Dramatic and universal improvement. It's particularly groovy for getting the constant factors to be really small.
Yes! In fact, the benchmarks I'm using are the same as the ones used in Go's `regexp` package, so they are directly comparable: https://github.com/BurntSushi/regexp/tree/master/benchmark That's comparing native regexps with Go's though, so it's really not so fair. (Although Go can sometimes win, primarily because they have Russ Cox and a one-pass NFA optimization. :P) You can compare the dynamic times in [this comment (first column)](http://www.reddit.com/r/rust/comments/23ro5n/add_regexp_crate_to_rust_distribution_implements/ch0mzjp) directly with the times for Go in my first link. They were run on the same machine. Finally, there's also the [regex-dna](https://github.com/BurntSushi/regexp/tree/master/benchmark/regex-dna) benchmark, which I hope will be included in the shootout proper at some point. Again, that's demonstrating native regexps. I think dynamic regexps were in the 12s to 14s range.
&gt; That's comparing native regexps with Go's though, so it's really not so fair So Go's `regexp` is not native?
Me too! I think I want to send some pull requests making it better first, and then documenting how to do it.
Are there any particular lessons or ideas that you would like to draw out from this? Are you picturing it as applying to such a toolkit as Qt as it might be written in Rust, or to Rust as a whole, or to some new layer in between the two?
I was discussing this with Alex Crichton earlier today; weâ€™ve agreed that the main functionality necessary for `TcpStream` is the ability to forcibly close all clones of the stream and the ability to set a timeout on a stream after which it will be closed (like the just-landed `TcpAcceptor.set_timeout`). These will fix up this problem.
I've been keeping my eye on julia. I like it pretty well, but I learned Haskell this year, and it kind of ruined me for a good type system. My work consists of building prototypes for testing, and then re-implementing the prototype in Fortran for the "real" code. Fortran has some nice bits, but overall it drives me pretty crazy. I'm looking for something that gives me some static typing guarantees, so that when my prototype gets more than 1000 lines, I can refactor without driving myself crazy. Also it needs to be fast. I want to be able to prototype, and then profile and iterate to a fast production-worthy code. 
I think what i have in mind is semantically unsafe code, but so pervasive that unsafe seems overkill; perhaps there are ways of restructuring solutions to avoid these conditions in the first place . ( again, we had an environment where branching was expensive... Unnecassery checks were a severe performance penalty and a lot of time in tuning went into eliminating them.) its really a cfg that turns rust back into an unsafe language that i am after i think, but the default safe build is like the ultimate debug asserted version.
I haven't had a chance to read burntsushi's code (and this isn't a meant to be a slight against his programming ability), but I would assume the more mature Go implementation has had much more effort put into micro-optimisations.
&gt; 1 - it is decided it will, it has not been decided how. Is this an official statement that Rust will have inheritance one one way or another? That would be good, because Go is disappointing in that way. The example above presented by the thread creator does not work as a way to implement inheritance, because it only displays the use of delegation. This is explained in this [article](http://objectscape.blogspot.de/2013/09/mimicking-method-overloading-in-go.html) in the section "Motivation". One work-around to get this done in a language without late binding as in Go is explained in the section "Inner Pattern". I *really* hope we get something better than that in Rust :-)
IIRC [CL-PPCRE](http://weitz.de/cl-ppcre/), a Common Lisp implementation of Perl regexp can compile regexp at compile-time.
&gt; . One work-around to get this done in a language without late binding What i'm talking about is orthogonal to anything dynamic, vtable-based or late-binding based. I'm simply talking about the ability to conviniently acess similar data, grouped/extended - with compile time resolution of types. As soon as you can accept late binding, vtables, .. there are many other more versatile ways of doing things. Even then, I think my suggestion might add something helpful, because you could compose different 'trait objects' pointing into into the same set of data and have the same rule select which element of the tuple is called.., a bit like c++ multiple inheritance with virtual bases, but composed in an ad-hoc way. 
All right, I might have missed that from the initial post. You mean something like [intersection types and union types](http://ceylon-lang.org/documentation/1.0/tour/types/) as in Ceylon?
reading your link, yes definitely, the concept of intersection and union types seems very similar to what i'm suggesting here; thew thought crossed my miund when writing something where i had a node type who data could be split and accessed and grouped in many ways. (multiple maps taking the same id's ? or those id's are resolved and references or even copies embedded and throw together.. etc) I should have worded my original post better since most discussion about inheritance means something to do with runtime interfaces.. the simple extending of structs is just one aspect My later suggestion "(A,B) as A" is probably a bit misleading, perhaps there would be a better way to express it.. .val::&lt;A&gt;() /* extract the component value who's type is A, error if its ' ambiguous */ i wonder if any of what i'm after could be rolled with a syntax extention #[tuple_accessors] type Foo=(A,B) // the extention creates a load of accessors that delegate components..
I think `Error` has some erasure cost - just like Rust tasks can fail with `~Any`.
I have an ARM tablet which I work on when away from my main machine (e.g. on a train, in a car). It's convenient to be able to compile Rust code there.
could you build a purely rustic GUI/widget library around it perhaps :) (as opposed to getting wrappers of libarries written in existing languages). eg - design around rust's concurrency concepts - rust macros to declare layouts (instead of any existing layout language) - trait-object based? (gui systems seem to be based around a specific languages' OOP system.) - Design 1st for modern touch devices - maybe tuples or rust fixed vectors for coordinates? what works best.. - design for the availability of gl hardware for animated transitions from the outset 
That's an interesting idea.
I had no idea you could do this in Rust! What an elegant pattern.
&gt; Does that mean they provide object(i) but not object[i]? Yes, since they have to provide object(i,j) for multidimensional indexing but cannot provide object[i,j] or object[i][j], they just use () as subscript operator instead of []. &gt;Wait, what are the three conventions? object[i], object(i), and object.get(i)? No: object[i], object(i), get(object, i).
It's my understanding that the vast majority of compilation time is on the LLVM side. Does LLVM offer any kind of partial compilation? Like only recompiling a specific function?
I really hope that one day, the rust compiler will support an API of sorts, where we can give it a context and span and it will give things like type information and other useful things. When I asked about trying to make an IDE on irc once, people said that the compiler isn't at a state where it would be easy. Sorry that got a bit off topic, I have also read that incremental builds are a want, but not a need for the rust compiler. I would love to see some discussion on this
I can't imagine coding without a real keyboard.
IDE does not require full build, only typechecking, that should be incremental.
dbaupp is right. Those benchmarks were done on Go tip from a few weeks ago, which includes a "one pass NFA" optimization. Russ [describes it here](http://swtch.com/~rsc/regexp/regexp3.html) (do a ctrl+f for `one-pass`). But I don't think that accounts for all of it. Go's dynamic impl seems to have lower constant factors than mine, but I haven't figured out exactly what they are yet. (Note that Russ's C++ RE library also has a DFA, which is very very quick. Go's `regexp` library doesn't.)
Hmm, are you sure? I just took a look at that link and I'm not sure I see native regexps. I see that you can specify a regexp as an S-expression, which is cool, but not native compilation. Am I missing anything? I see that there is a `create-scanner`, but I don't see anything in the docs that indicates it's any different than just compiling the regexp at runtime. Dunno.
Asus Eee Pad Transformer. I wouldnâ€™t quite call it a *real* keyboard (most notably, it has ghosting issues! Yes, genuine ghosting issues of the type that I thought had been completely overcome twenty years ago, but which they apparently managed to introduce again), but it is a physical keyboard.
Yeah. I have some optimizations in too---the biggest one is identifying a literal prefix in the regex and skipping the VM through the input just by looking for substrings. Basically, there's a crapton more work to be done on the performance front. :-)
I have a blog post in the pipeline that describes how I implemented native regexps, but I take a rather large detour and explain how to build a syntax extension and use the quasiquoter. (I include examples not using regexps, since the code gen for that is complex.) I hope to have it out by tomorrow.
You might be interested by [merlin](https://github.com/the-lambda-church/merlin), which does exactly what you describe for OCaml. It's done by using a slightly modified top-level to 1) only typecheck 2) make it split out as much type information as possible.
In the last section (Hints, comments, performance considerations): &gt; CL-PPCRE uses compiler macros to pre-compile scanners at load time if possible. This happens if the compiler can determine that the regular expression (no matter if it's a string or an S-expression) is constant at compile time and is intended to save the time for creating scanners at execution time (probably creating the same scanner over and over in a loop). To my knowledge, compiler-macro are a special kind of macros used to implement optimizations at the dev level (i.e. without having to implement it in the compiler).
Makes sense :) You mentioned that D was the only other language that had "native" regexes. Do you reckon that this would also be possible in C++, since its template system could potentially be (ab)used to provide something like this?
I had a similar idea. I was wondering if you could have a `Status` struct containing a reason string and a `Code` enum (an enum so you avoid typos for common codes, and a `Custom(u16)` enum item for new ones). If you forbid the full comparison of the `Status` enum except with `status.eq_full(&amp;code, &amp;reason)`, you'd force the user of to either explicitly compare it fully, or make decisions on the code and reason separately. Edit: On second thought, the `Custom(u16)` variant would have the problem of allowing things like `Custom(200)` as well. It wouldn't work when comparing against an `OK` at runtime, but it would unfortunately compile. Not sure if something can be done against that. Note: Only ever wrote 160 lines in rust, so I might be missing a lot of relevant details.
&gt; For example, the status code 451 has been used by Microsoft Yes, and it should be interpreted as the 451 code from the standard (currently unspecified, likely to become Unavailable for legal reasons). They knowingly took a risk, so now they are the one who will have to deal with it, instead of user agents. The meaning of unspecified codes was clearly unspecified. There are loads of 9xx codes as well, not to mention other obscure and/or misused error codes. You cannot track all of them down; the standard is what should be final. Aside from that, I support the API separation between codes and reason phrases. I'd even be fine with removal of the latter as long as there's a way to look up the canonical name for the code (which would always be "Not Found" for 404 in HTTP/1.1). **Edit** I should add, allowing user agents to behave differently based on the reason phrase is actually **in violation** of the spec: &gt; The reason phrases listed here are only recommendations -- they MAY be replaced by local equivalents without affecting the protocol. As a result, I'd argue in favor of complete removal of allowing software to see the original reason phrase, instead returning only the reason code. If one need to distinguish between different cases, this would need to be done through the number, or via a different mechanism entirely.
Surely there are other strongly-typed HTTP libraries out there. What approach do they take in this situation?
&gt; Pattern matching doesnâ€™t work on struct statics (or for that matter, nonâ€Câ€style enums). (Actually, it complains â€œunsupported constant exprâ€ at the static site, rather than at the match! If youâ€™re careful, you can probably find an ICE nearbyâ€”pnkfelix did. Bad.) Surely that's a Good Thing, given you should not match on the reason, only on the status code?
&gt; I also donâ€™t see much use for the Status enum, compared to just an integer. I imagine that's so that you can "match" against error codes. Having it as an enum gives you 2 things: 1. you can match based on name: match status { Ok =&gt; continue, Unauthorized =&gt; try_auth_again(), ... } 2. The Teepee library is then the only one that needs to have a fully comprehensive list of error code -&gt; reasons, and then others who really want to be certain can make sure they don't miss any possibilities through the type system: if your match doesn't have any blanket "_" matches in it, you've matched them all. Then when the standard is updated and Teepee updates its Status enum, you get a compilation failure because you missed something. And it all looks fairly pretty... _ 
how do you think an IDE would work? think about it for a bit. although it doesn't have headers, rust does have large translation units.
incremental build up to a certain point - typechecking/'resolving'. In C++ you can translate individual files in isolation, but they bring in context through headers. In rust , there's no headers, but, you have to have all the sources in a crate to understand the crate.. its a bit like a C++ unity build. however, in C++ you can only even build the AST for one source with information from the other sources headers; at least in Rust, you can actually get as far as an AST for a source without the other sources. 
So, the obvious proper way to do things is this: 1. Separate status code and reason phrase, and always check only the status code, except in client code for specific services where you really need to check the reason phrase to figure out what happened 2. Use an integer for status since the number may be anything, and you want to be able to pass it through if developing a proxy (also, converting ints to an enum is expensive and unnecessary) 3. Provide a bunch of statics with the default status codes (AND NOT THE REASONS, see 4) 4. Provide a function to map a status code to a default reason phrase expressed as Option&lt;&amp;'static str&gt; (for use in servers) 5. If you want to pretty print a status code, print the number plus the reason phrase, if available, or otherwise the number, plus the return value of (4) It's quite worrying that the author apparently can't figure this out by himself: is the rest of the library fine, or does it have even bigger issues? For example, is header handling fast and usable for writing a proxy, or does the library try to enforce the author's surely mistaken understanding of what values are allowed in HTTP headers? 
Well, I know that we often need to leverage the technologies we create in many different cases. Having no 64-bit windows option means that it would be a limiting choice. In general, I try to avoid limiting choices. Also consider we often work with very large data sets. Far beyond what a 32-bit program can handle. 
Actually, in the specific case of HTTP, there is the alternative of using, instead of statics, an enum with a variant for each of the 1000 possible 3-digit codes, and using an unsafe transmute to parse the number into it (of course, public function with safe interface needs to provided encapsulating it). Variants not defined by the standard would just have names like Code003, Code987, etc. This is only feasible because HTTP status code are less than 1000 though, and not a general solution. 
Somehow, I have avoided ever writing a line of C++. So I'm not the one to answer that. :-) I hear their templates are Turing complete though...
Ah I see! I missed that, thanks. Although I'm not sure if that's just zeroing the cost of compilation or *also* compiling to the state machine specialized for the regexp. I'll have to dig into the source as it doesn't seem to clarify in the docs.
I love what you are doing with this toolset, and that you are promoting using Rust in game jams.
I believe solving this problem cleanly requires a rather invasive change to the way the staged bootstrap works: https://github.com/mozilla/rust/issues/5258
You could use a lookup table for the reason; the reason is NOT intended as a discriminatory factor for software to act differently upon. It's *purely for humans*. This would: 1) Solve the comparison problem that was mentioned; 2) Prevent programmers from mistakenly using the reason phrase for anything discriminatory at all, instead of a code In typical Rust fashion, this would be an elegant and simple solution, and since the implementation that is described would shield programmers from the numbers by themselves by default, instead using more descriptive `Status` terms and functional comparisons, I argue it should be preferred. I'm open to suggestions, though. I see we do agree on the (imho) most important part: &gt; I agree, if you're having to match the reason phrase, something else is wrong. The status code should be the source of truth to the application. But how would you solve the comparison problem? Just follow the author's idea? &gt; One solution to the primary symptoms is to change equality checking on a Status (the Eq implementation) to just compare the Status-Code and not the Reason-Phrase. Maybe that's sufficient as well, I'm just a bit wary of programmers deciding to act upon the phrase rather than the code.
They haven't: they even mention the `Result` type Ocaml has already.
For returning status, I'd say a struct because how often would you match against all possibilities. You could have a method on the struct that optionally returns an enum though.
&gt; the reason is NOT intended as a discriminatory factor for software to act differently upon. It's purely for humans. In an ideal world, sure. But people have to deal with legacy crap which doesn't strictly follow the protocol. Someone may not have a choice in the matter and *simply must* discriminate based on the Reason, because legacy code XYZ is terrible. If I was in that situation, I would be very upset that the HTTP library actively hides it from me, and in fact just throws it away before I can see it. I understand your point, but on the other hand, libraries like this should be as un-opinionated as possible. Throwing away data is an opinion that higher-level clients can make, but in my opinion (heh) not something a low-level HTTP library can do.
(BTW, `#[deriving(FromPrimitive)]` and then using the methods from that trait, is the preferred way to support going from number to enum, *not* transmute.)
Iâ€™m meaning rustcâ€™s behaviour. It is doing bad things.
There are actually only 500 possible values, 100â€“599.
I covered `is_redirect` et al. with the `class()` function and the `StatusClass` enum. In [take two](http://chrismorgan.info/blog/teepee-design-status-line-take-two.html) ([discussion](http://www.reddit.com/r/rust/comments/23xcaa/teepee_design_statusline_take_two/)) I offer the struct approach as one of the solutions (though I used a normal struct rather than a tuple structâ€”but theyâ€™re equivalent).
I'd be pretty surprised if you're getting the same error when using this: let random_key = { let mut iter = self.entries.keys(); sample(&amp;mut iter).clone() }; as with the other two, particularly with your `clone()`. Could you double check? Could you post that error message? I suspect the reason why you're getting that error message with the other code is because `sample` is returning a borrowed reference to an element in the iterator, which is likely tied to your immutable borrow of `self.entries`. But I can't be sure without more types shown to us...
Have you filed a bug regarding the issue with `#[deriving]` codegen? I'm wary of leaving such a ubiquitous feature unoptimized.
Please keep your tone constructive and polite in /r/rust. This kind of condescension is not appreciated.
How very strange.
Thanks for the discussion, guys. Based on this feedback, Iâ€™ve changed tack. This document has been largely superseded by [Teepee design: Status-Line, take two](http://chrismorgan.info/blog/teepee-design-status-line-take-two.html) ([discussion](http://www.reddit.com/r/rust/comments/23xcaa/teepee_design_statusline_take_two/)).
It's merged!
&gt; you can match based on name: You can use statics in patterns to give a name to an integer value: static OK: u16 = 200; match code { OK =&gt; {}, _ =&gt; {} } &gt; others who really want to be certain can make sure they don't miss any possibilities through the type system: if your match doesn't have any blanket "_" matches in it, you've matched them all. I donâ€™t think youâ€™d want to do that: there is a lot of them: https://en.wikipedia.org/wiki/List_of_HTTP_status_codes It also doesnâ€™t work as this list is not closed: people regularly come up with new status codes such as Twitterâ€™s 420 Enhance Your Calm. This is why the enum at the beginning of the post has a `UnregisteredStatus(u16, ~str)` variant.
For what itâ€™s worth, I like just a number with statics for registered values. * Adding statics for new status codes just works as expected. Library users could even declare their own statics if they rely on "unofficial" status codes. * All validation does not have to be enforced by the type system. It can be handled in a library function or method call.
Here's the error with the scope and `clone()`: buffer.rs:93:17: 93:29 error: cannot borrow `self.entries` as mutable because it is also borrowed as immutable buffer.rs:93 Some(key) =&gt; self.entries.remove(key), ^~~~~~~~~~~~ buffer.rs:88:36: 88:48 note: previous borrow of `self.entries` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `self.entries` until the borrow ends buffer.rs:88 let random_key = {let mut iter = self.entries.keys(); sample(&amp;mut iter).clone()}; ^~~~~~~~~~~~ buffer.rs:95:3: 95:3 note: previous borrow ends here buffer.rs:84 fn evictPage(&amp;mut self) { ... buffer.rs:95 } `sample` looks like this: fn sample&lt;'a, T, I:Iterator&lt;T&gt;&gt;(from: &amp;'a mut I) -&gt; Option&lt;T&gt; { let from: ~[T] = from.collect(); let l = from.len(); if l == 0 { return None; } let index = randrange(l); Some(from[index]) } `randrange` is just returning a number: `randrange&lt;X: SampleRange + Ord + Zero&gt;(high: X) -&gt; X`.
&gt; my current order of preferences is #2, #3, #1, #4. Is that increasing or decreasing preference?
Stackoverflow: [how does jemalloc work? what are the benefits?](http://stackoverflow.com/questions/1624726/how-does-jemalloc-work-what-are-the-benefits)
Congratz! This is great work :)
I guess even if it aproximated the potential completions based on the traits it can see in the function signature , it would still be a lot better than nothing. I also like the idea of making the compiler error messages more helpful, eg "see definition of... " when you tried to acess something that isnt there, or telling you the correct path to it if you tried to use an embedded subfield . Those types of enhancements are lower hanging fruit that would complement what you're already doing in racer
FYI, compile-time can be invoked at run-time in Common Lisp. It's *not* a simple compile-run sytem. There's load, compile, and run-time[1], and you can move around in that system fairly dynamically. Typically a CL implementation will compile to native code at any rate. So if CL-PPCRE can compile a re at load-time, it'll be a native function. [1] Maybe more... I'm up early and no coffee yet.
If you (or someone else) can get rust for AVRs (arduino), please shout it far and loud. 
C++ has native regexes: http://www.boost.org/doc/libs/1_41_0/doc/html/xpressive/user_s_guide.html#boost_xpressive.user_s_guide.introduction The catch is that they use expression template syntax, because AFAIU C++ can't templatize on a string literal, because it doesn't have built-in arrays (unlike D).
I haven't tested this, but what if you do it like this? let random_key = { let mut iter = self.entries.keys(); sample(&amp;mut iter).map(|v| v.clone()) }; This will directly clone the content of the `Option` and return a new `Option`.
It does not work because your sample function returns a reference to a key, and then you clone that and that does not get rid of the reference.
How can I dereference and clone it? In `sample` neither `*` nor `clone()` work on objects of type `T`.
is your function sample generic? then you have to bound that type to implement Clone like: fn sample&lt;T: Clone&gt;(...)
I replied to you other comment: &gt; is your function sample generic? then you have to bound that type to implement Clone like: fn sample&lt;T: Clone&gt;(...)
Yes, I suspected that both `Options` would contain the same data or be connected somehow, so I thought that making sure that the data was really cloned and repacked would solve it. Both `map` and `and_then`, with friends, are really useful for using optional values without having to match all over the place (and create a pyramid of death). And, no, I don't take dogecoin tips, but I appreciate your appreciation :) That's valuable enough for me
A: Have you really *seen* people using statuses outside the range 100â€“599? Thatâ€™s bad. Really, *really* bad. If I were writing a highâ€level HTTP library, I would simply thumb my nose at such a thing, but as one who is writing a lowâ€level interface first of all, I cannot ignore such a thing so easily. The fact that #2 is exhaustive would indeed cause a problem if someone is violating the HTTP spec in that way. Still, before compromising the API for such invalid behaviourâ€”are you able to demonstrate a case where this has actually happened? B: I covered the status codeâ€™s class in the first part with the `class()` function and `StatusClass` enum.
Yes, but as SirOgeon says, I'd rather avoid it being cloneable. But maybe I'll add that trait, since otherwise you can get bitten pretty easily.
didn't really try to understand what the code does (didn't even see you pasted your sample function above). I agree, returning a reference is the right choice. It even server documentation purposes (you know from the type signature that it is a value from input iterator).
&gt; You can use statics in patterns to give a name to an integer value: Sure you can, but why add that intermediate? Its a bit of complexity with little gain, AFAICT. &gt; I donâ€™t think youâ€™d want to do that That depends on application, right? If you're just writing a little web-scraper just for yourself, then sure, you wouldn't... but if you're writing a serious browser or a webcrawler for the next search engine, then you might. &gt; people regularly come up with new status codes Yes, but not official ones. The unofficial ones can easily be encapsulated as you said.
My first preference at present is #2, and my last #4.
Of the first part, various parts are entirely compatible with any status representation scheme; the status class part is the main part that certainly applies.
Is there anything actually *wrong* with having a 500â€variant enum? Itâ€™s unusual, sure, but I donâ€™t know of anything genuinely *wrong* with it.
The only thing i really want from this would be auto imports, anything else only extra.
I'm for #1 as it seems to be the cleanest solution and supports stupid status code values. As for the issue with new status values being registered this shouldn't be a problem provided you force all comparisons to be done by value, unless I'm missing something obvious. For example: pub enum StatusCode { ExtensionCode(OpaqueExtensionCode), Continue, SwitchingProtocols, Ok, ... } pub struct OpaqueExtensionCode { priv value: u16 } impl StatusCode { pub fn new(value: u16) -&gt; StatusCode { match value { 100 =&gt; Continue, ... _ =&gt; ExtensionCode(OpaqueExtensionCode { value: value }) } } pub fn value(&amp;self) -&gt; u16 { match *self { Continue =&gt; 100, ... ExtensionCode(opaque) =&gt; opaque.value } } } impl Eq for StatusCode { fn eq(&amp;self, other: &amp;StatusCode) -&gt; bool { self.value() == other.value() } } 
Just a quick tldr from the README: A super-fast, parallel backtracking algorithm for n-queens implemented in rust. The 30,000 foot overview: Our inner helper function that does all of the work only takes a few arguments: three integers which represent the spots on the current row that are blocked by previous queens. The "secret sauce" here is that we can avoid passing around the board or even the locations of the previous queens and instead we use this information to infer the conflicts for the next row. Once we know the conflicts in our current row we can simply recurse over all of the open spots and profit. We can then use bit magic to significantly speed up the process over arrays - almost a 50x speedup. Time for n=12: 500k ns. Highest calculated result: n=17 Please see nqueens.rs for a significantly more detailed explanation of the algorithm including a thorough explanation of all bit magic. For the same algorithm implemented in js (about 200x slower) see my n-queens.js repo.
That's quite the speed boost over the js implementation. I'd expect js to be ~5x slower, maybe 10x. Is that running on node, and including time for the jit to optimize?
jemalloc is pretty much the fastest memory allocator around, especially when multiple threads are involved. It should provide consistent, fast general-purpose memory allocation performance on all platforms.
Would anyone care to make any argument for why this was posted here, or why any of you have upvoted it? The other discussions, on reddit at least, are old and lacking. 3 comments in /r/scala, five months ago. Nothing a month ago in /r/programming. Also, was posted five months ago on HN with no discussion. I don't really get it, as aside from "Options over nulls", I don't see the left hand side options as being manifestly (heh) better than the right hand side. A lot of them are two sides of the same coin, or at least of very similar denominations.
I took it as a delightful sendup of the agile manifesto, in the ha-ha-only-serious vein. (You might have your right/left switched in your post. The NOOO manifesto is promoting the items on the left over the items on the right).
I certainly saw the similarities to the agile manifesto, and I was mulling over whether or not this was poking some fun at it or not. &gt; You might have your right/left switched in your post. The NOOO manifesto is promoting the items on the left over the items on the right You're right. The bitch of it is, I wrote it correctly and then changed it half way through thinking I made a mistake. I am a bit drained at the moment, which is why I am heading out right now for some exercise. I edit my original post just to be clear about it. I could do the fancy this-is-a-lab-notebook strikeout edit, but I'm not sure how that is done with reddit's markdown syntax. Edit: Something I just noticed before actually checking out: the submitter has a one year old account, but his only visible contribution on reddit is this submission. Slightly odd.
Please feel free to add your own!
Yeah, I wondered if I might have been imagining the humor. It's pretty dry, if it's really there. The two things that tickled my funny bone were the acronym (Nooo!) and the parenthetical dig at null references. 
I don't understand why closures are "mutable references to their environment". I can see them as references, but why straight jumping into mutability? What does it happen on the process of creating a closure that makes them mutables references?
So why not make closures capture values ("by move-value" by default, or "by copy-value" if the type of the captured value implements `Copy`) instead of references? If one really needs to capture references, it is always possible to capture borrowed pointers. As an added bonus, this lets us distinguish much more easily between closures that can be called multiple times (when they only capture values whose types implement `Copy`) from closures that can be called at most once (when they capture at least one value whose type does not implement `Copy`, e.g., a `&amp;mut T` for any `T`). Making closures only usable from mutable references has the unfortunate consequence of making writing functional-style higher-order combinators significantly less convenient: https://github.com/mozilla/rust/issues/13765
does it simply need additional syntax for declaring a closure with immutable references? I'd definitely want to keep pass-by-reference the default. I'm not coming from a haskell background; i'm definitely finding myself wanting to passing closures to mutate some locals passed in an environment, a lot; for the mainpart its' working without global state that makes code easy to reason about IMO. mutation is ok when its controlled by who gets a mutable pointer, where, and you know they can't be cached, dangling or whatever
Would capture-by value cause people to mistakenly pass huge copies around - but if they add some syntax to control *what* the form of capture is, its just an issue of deciding which is the safest or most useful default. 
They would only pass huge copies around if these huge objects implement ~~Clone~~ `Copy`. But then, the same kind of "problem" already happens when you pass variables as arguments.
In general, captures would *move* the object to the closure's context, not copy it. Only stuff that can be cheaply copied (i.e., implements the `Copy` trait) would be copied.
Sorry, I confused the two.
Perf depends on your workloads. For Google's workloads, tcmalloc remains unbeaten.
I'm really curious, what do you use them for? I can't imagine what other categories there are than the five, but I don't know everything...
Closures can mutate their environment, so therefore they need a mutable reference to mutable variables they close over. I guess it would be nice if we had a separate `mut |A| -&gt; R` type but that probably also gets unwieldy really quickly.
Specifying different methods of capture for each individual variable is not necessary. Instead of capturing a variable by reference as in C++, you just capture a borrowed pointer to that variable. Then, the lifetime of a closure is simply the intersection of lifetimes of all the borrowed pointers it captures. If it captures no borrowed pointers, the lifetime of the closure is `'static`. (Basically, lifetimes form a monoid with intersection as the binary operation and `'static` as the identity.)
It was possible to do use-after-free in safe code before. 
When all is said and done, modulo optimization tricks, the following data structure is the only possible general representation of a closure. struct closure { void *env; result (*func)(void *env, argument arg); }; (Sorry for using C. Add more arguments to the closure type if necessary.) What Rust presently does is force the the environment pointer to point to a stack frame. This is useful sometimes, but not always. Actually, most of the time, I actually need to *transfer* ownership of the captured variables to the closure, so that the latter can live independently of the stack frame in which it was created. The closure data structure remains the same, but now the environment pointer must point to a *separate* memory block that is *owned* by the closure itself. (For efficiency reasons, this memory block could actually be adjacent to the closure data structure.) This ownership transfer could be called "capture by move-value", because it is similar to "passing arguments by move-value". When the type of the transferred object implements the `Copy` trait, this becomes a "capture by copy-value", which again has a function call analogue. So, enough looking at the implementation, now let's look at the types. Like any data type in Rust, the lifetime of a closure must be bounded by the lifetimes of its constituent components. This means that: 1. A "trivial closure" that captures nothing has an unbounded lifetime. Equivalently, we can say it is bounded by the `'static` lifetime. 2. A closure that does not capture borrowed pointers also has an unbounded (again, `'static`-bounded) lifetime. This is because, after the transfer, it is the closure and not the original stack frame that owns the captured contents. 3. A closure that captures borrowed pointers is bounded by the *intersection* of the lifetimes of the borrowed pointers. 4. As a special case of the above, a closure that captures a borrowed pointer to a stack frame is bounded by the lifetime of the stack frame. This is what Rust presently does, and it fits nicely within the more general framework I am proposing. Looking at algebraic structures really helps identify clean generalizations like this one. Lifetimes form a monoid, with intersection as the binary operation, and `'static` as the identity.
I'll take your word for it; I'm just going by what I've generally seen. For example: http://www.quora.com/Is-tcmalloc-stable-enough-for-production-use or https://github.com/mozilla/rust/issues/6897
Nice. Could you post a link to it?
So it appears that it was once merged, but was it removed? Why was it removed? 
https://github.com/mozilla/rust/issues/8622 has some details.
There were some heisenbugs, iirc.
Compilation speed isn't a consideration at all, because I can just bypass #[deriving] with my own implementation.
The `||` closures are specifically by-reference closures, and there's heap-allocating only-callable-once `proc()` closures, and we used to have some other flavors too. I think right now we're happy with these two limited variants built into the language (leaving other environment schemes to be explicitly written out like you're doing in C), and generalizing the notion is on the far-future post-1.0 wishlist. :/
Awesome, thanks.
I haven't created a reference implementation in C, but a friend of mine here at Hack Reactor wrote the same algorithm in a threaded C implementation and the rust version is still faster! It's also significantly shorter: about the same number of lines as the js implementation -- even the parallel version! The C is, of course, much longer and more verbose.
https://github.com/wallstop/NQueensSample Unless I screwed something up awfully, that should be a one-for-one implementation of your algorithm in modern C++. *EDIT: Turns out I did screw something up - bitwise v bool negation. D'oh, I was blinded by rust. Everything is fixed in git* Note that the parallel function totally sucks and is incredibly sub-optimal. Each call to the parallel method has to construct the "threadpool", so there's a lot of spinup time there. In order to get timing information, I relied on a short and sweet timing class I wrote a while ago that, for the moment, is windows only. And, if windows is to be trusted, timing are: Debug x86: * Sequential: 70k us * Parallel: 72k us Debug x64: * Sequential: 20k us * Parallel: 22k us Release w/ 02 x86: * Sequential: 8.4k us * Parallel: 9.49k us Release w/ 02 x64: * Sequential: 7k us * Parallel: 8.5k us Please note that I'm of the opinion that comparing anything to a javascript implementation for timing / performance reasons is incredibly silly... Things of note: 64bit compilation decreased the debug runtime considerable. Turning on 0x did not noticeably impact runtime. 
I agree that capturing "by copy" is just a special case of capturing by move. However, when all captures are "by copy", then the closure itself can be copied, which is not the case for closures that capture at least one non-copyable object. I think it would be useful to make "closures that can be copied" a subtype of "arbitrary closures". In particular, using a closure would consume it (because it would consume the captured objects), so a "closure that can be copied" can be called multiple times, while a "closure that cannot be copied" can be called at most once. This is not very different from what Clean does with uniqueness types.
? `println!` has always been able to print string literals. Itâ€™s string *nonâ€*literals that it canâ€™t print.
A format string can have any number of formatting directives, including zero (a string literal).
D'oh, that's what I get for being on /r/rust at 3am.
This is easily the best introduction to Rust. Nice work.
For the most part, I agree. However, `MutClosure` is not really necessary as a primitive: It can be encoded as a special case of `OnceClosure`, using F-bounded polymorphism: pub trait OnceClosure&lt;Arg, Res&gt; { fn once(self, x: Arg) -&gt; Res; } pub trait MutClosure&lt;Arg, Res&gt; : OnceClosure&lt;Arg, (Self, Res)&gt; {} Besides `Mutex` and `RWLock`, I have yet to see any uses of mutability that cannot be encoded in terms of destroying old objects and returning new ones. I do not mind `mut` variables, but `&amp;mut` causes an action at a distance (even if it cannot be copied, it can be moved around, sometimes really far away from where it was borrowed), so I try to keep my use of it to a minimum.
While true theoretically, Rust is a low-level language, so modelling memory locations (via "actual" pointers) is important for performance (and somewhat semantics), especially since things are not uniformly boxed/pointer-sized, so passing around by-value can be expensive. Another thing that may be a little tricky to model as just consuming/returning is something like `sort` that takes a `&amp;mut [T]` since `[T] -&gt; [T]` is impossible (even with DST): encoding that as `Vec&lt;T&gt; -&gt; Vec&lt;T&gt;` is not as general (e.g. one could have array `[T, .. 10]` on the stack, or a `SmallVec&lt;T&gt;`). (Someone appears to be downvoting you... don't know why. :( )
Actually, one of my concerns is performance for low-level programming! If the compiler sees a function of the form `fn foo(T, ...) -&gt; (T, ...)`, and `T` is a big type, it should be able to internally optimize it into `fn foo(&amp;mut T, ...) -&gt; (...)` without me having to tell it. But, also, if the compiler sees a function of the form `fn foo(T, ...) -&gt; (U, ...)`, where `size_of::&lt;T&gt;() == size_of::&lt;U&gt;()` and `min_align_of::&lt;T&gt;() &gt;= min_align_of::&lt;U&gt;()`, it should be capable of performing this very same optimization, by deciding to store the `U` where the `T` used to be, and internally only taking a mutable untyped pointer to the common memory location. As things currently stand, this optimization has to be manually performed by the programmer *and* it is not as general as it could possibly be. I have not been closely following the discussion regarding DSTs (although I am certainly very interested), but, if `uint`s are added at the type-level, then `sort` could be `fn sort&lt;N: uint&gt;([T, .. N]) -&gt; [T, .. N]`. And, in addition to that, if [repeat whole `size_of` and `min_align_of` thing], then we could have `fn in_place_map&lt;T, U, N: uint, ...&gt;([T, .. N]) -&gt; [U, .. N]`, where the ellipsis stands for whatever new syntax is used to express that [repeat whole `size_of` and `min_align_of` thing]. So, in the long run, maximizing the expressiveness of the type system allows the compiler to optimize much more effectively than we humans could ever manually optimize. (I was accidentally downvoting myself!)
"Rc and RefCell aren't evil" is my favorite mantra. :) Don't worry if you need to use them; they're there for a reason. Of course, things will be faster at runtime if you can avoid them, but that's just kind of a law of the universe: unique ownership is just easier to reason about. Incidentally, I would like to see if there is a way we can make Cell easier to use.
[Docs](http://static.rust-lang.org/doc/master/std/mem/fn.replace.html): &gt; Replace the value at a mutable location with a new one, returning the old &gt; value, without deinitialising or copying either one. Can you explain in more detail what you donâ€™t understand?
&gt; without deinitialising or copying either one What does this mean? How can something be replaced without copying?
RefCell isn't too bad, but I like to avoid implementing the Clone trait for my structs, if possible. Maybe I just don't grok rust yet.
OK. What it means is that the object is not being logically copied. To be sure, in memory it is done as a copy (the two objects are swapped), but that is all. Logically, each is still exactly what it was, with no destructors being called or cloning or explicit copying or anything like that.
O1 is pointer to M1 (Object pointed to Memory Address 1). O2 is pointer to M2 (Object pointed to Memory Address 2). replace(o1, o2) implies o1 now points to M1 or that contents of M1 have been replaced by m2?
 I found a Solution for my Problem: Works as expected. struct ProgramData { cb: Option&lt;~Callback&gt; // keep Callback alive } struct SyncDone&lt;'a&gt; { dsp: &amp;'a Display, data: &amp;'a mut ProgramData } impl&lt;'a&gt; CallbackListener for SyncDone&lt;'a&gt; { fn done(&amp;mut self, cb: &amp;mut Callback, data: u32) { println!("Synced with display -&gt; data: {}", data); // move the old listener out of the Callback // and add it to the new one // ProgramData is only here to keep the Callback alive until we // replace it let listener = cb.listener.take().unwrap(); self.data.cb = Some(~self.dsp.sync().unwrap()); self.data.cb.as_mut().unwrap().add_listener(listener); } }
Why isn't there a type that's like a Rc with built-in RefCell? It could be called Mrc for mutable reference counted. Having to type Rc&lt;RefCell&lt;T&gt;&gt; is quite frankly annoying, which is probably intentional, and I think it's overkill when it comes to discourage unnecessary use of expensive things. Although I have to admit the automatic dereferencing helped. Before that it using Rc&lt;RefCell&lt;T&gt;&gt; was a massive turn off and made raw pointers look good and easy to work with. 
Hm, this is nice so far, but there are also a lot of detail errors in the descriptions which might confuse beginners...
Well, making it a extra type just leads to combinatorial explosion, as you might also special case `Gc&lt;RefCell&lt;T&gt;&gt;`, `Arc&lt;RWlock&lt;T&gt;&gt;`, etc. Overloadable deref's main reason for implementation was to make composing smart pointers like this more bearable.
is the return type `-&gt; &amp;str` (no lifetime specified) regularized now? That writing used to be almost the same as `&amp;'static str` apart from some oddities [(used here)](http://rustbyexample.github.io/examples/tuples/README.html)
Sort defined like that would require knowing the length at compile-time, which is impossible in general. (Or would require dropping our monomorphisation strategy for generics.)
Yeah, I was surprised about this too. It works on 0.10...
Nice work. I especially like the in-place mutation examples in '17 RAII and borrow'.
Thanks :)
It works because a string literal has lifetime `'static` and the return values have an anonymous lifetime, inserted by the compiler. The key that makes it work is `'static` is the super-lifetime of everything, even those anon lifetimes, so AFA(the compiler)CT it's perfectly ok. ([#2478](https://github.com/mozilla/rust/issues/2478).)
Unfortunately this is a downside to tutorials outside the main repo: they don't get code-reviewed by the largest group of Rust experts in existence (the people working the compiler/standard lib), so often the details/descriptions can have subtle/easy-to-make mistakes.
Ahhhhhhh. Neat.
I quite agree. I answered this way because it was not clear to me what precisely was in question.
**This comment is a poll.** Suggestion: upvote this comment if you would prefer to go back to the old, downvote it if you would prefer to stay with the new (possibly with further tweaks, but approving of its general direction). (Is that a reasonable measure of the opinion on the matter? Dunno, but hopefully it gives us at least a very rough figure.)
It's pretty hard to argue against: * Purity over mutability * Composition over inheritance Edit: Thought I was in /r/programming
Perhaps someone could host a copy of the docs built with the old style, so we can compare side by side with the new?
Excellent, this is exactly what I've been looking for.
That would indeed be valuable. I canâ€™t do it now or probably for the next 30 hours. Hopefully someone else will do it. (A 0.10 build should do it, I think.)
This made me grok quite a few Rust concepts better, but lifetimes still confuse the hell out of me. Is there a thorough tutorial that focuses more on them?
I think the names of 'Cell' and 'RefCell' accompanied by the very short documentation they have make it really hard to grok. I've been trying to both understand what it is they exactly do, why they are necessary, if the need for them can be designed around, or maybe a better name for them. The last required the first though. I was going to write an RFC about renaming them but understanding what they do and why they are necessary it's not trivial. I can't figure out why the name Cell was chosen yet.
I prefer to implement `RefCell` directly on each field of a struct, not on the struct as a whole. That way, you don't get dynamic borrow failures when accessing field A while iterating over field B. It's a bit of an experiment; `RcMut` *did* used to exist. If it ends up being a losing battle we can bring back `RcMut`, I guess.
Have you read [The Rust References and Lifetimes Guide](http://static.rust-lang.org/doc/master/guide-lifetimes.html)?
I've read that and I still don't really understand how lifetimes work. My experience using lifetimes mostly consists of me haphazardly adding lifetime annotations in an attempt to get the compiler to stop yelling at me.
Just going to point out that with [reddit vote fuzzing](http://www.reddit.com/wiki/faq#wiki_how_is_a_submission.27s_score_determined.3F), it might be simpler to just make a [straw poll](http://strawpoll.me/) for it since the actual number of upvotes and downvotes are hidden on reddit.
Author says dereferencing a pointer causes the object to be copied to stack. what type of copy is this? Full copy or shallow copy?
I don't know if this helps, but once I took this perspective, things started clicking for me: * The Rust compiler will do its very best to prove that there are no use-after-free bugs. * To do this, it must reason about the *lifetime of data*. * In most cases, it can infer the lifetime of data on its own and make sure everything lines up. * But sometimes, there are things it doesn't infer, and in those cases, we as programmers must tell the compiler some information about the lifetime of data. * This is done by naming lifetimes and then claiming that "these two pieces of data have the same lifetime" (or something similar). I think the meat of this is really covered in [sections 8 and 9](http://static.rust-lang.org/doc/master/guide-lifetimes.html#returning-references) of the references and lifetime guide. I think if you really work through the example in section 9.1, that might help.
Usually people do two comments, one for yes, one for no.
I think you can just compare eg. http://static.rust-lang.org/doc/0.10/std/str/index.html and http://static.rust-lang.org/doc/master/std/str/index.html
Perhaps Rust needs an endless stream of lifetime tutorials and analogues like Haskell has for monads :)
With Reddit Enhancement Suite you see both upvotes and downvotes. Right now it reads `7 points (22|15)` for example.
How are you getting your timings?
The only copy the compiler inserts anywhere is a shallow copy: `let x = *(&amp;(&amp;huge_val));` just copies the one word `&amp;huge_val` pointer. Any sheep (shallow/deep) or deep copies are explicit via function calls, and are defined entirely in libraries, not the language. (E.g. `Clone` is a library defined trait for a sheep copy: it's the minimum amount of work required to go from `&amp;T` to `T`.)
Did you mean to post to /r/playrust? This is /r/rust, a sub-reddit for the Rust programming language by Mozilla.
Yeah, I have a feeling that, at least for a while, lifetimes in Rust will be like monads in Haskell. However, Rust is a much more practical language than Haskell, so we should be able to come up with a decent set of explanations eventually. 
Baaaa
If I understand correctly, types are monomorphized, but lifetimes are not (because it would not even make sense). Just add type-level `uint`s to the list of things that are not monomorphized. :-)
&gt; I'm much less worried about the concrete style (which I assume is going to change again and again over time) than the organization and relative semantic poverty of markdown. Hear, hear. &gt; if I'm looking at std::str docs to find out what operations are available, the structure of the docs is determined by the list of traits that are incidentally used to provide these operations, and I have to basically open all the trait-specific pages in new tabs and check all of them for what I need. This is basically my only real gripe with the docs too. When I first started with the language, the number of traits defined in the `slice` crate (or the old `vec` crate) was daunting precisely because I had no *instinctual* feel for what the heck any of them meant. It took me forever to get a feel for *the set of methods available*. As I've become more familiar with the docs and language, I can usually guess the right trait I want. But it's definitely less than ideal. (The search feature is great and definitely helps, but by its nature, it's not good for getting a feel of what's available in a crate.) This becomes worse with crates that might not have as obvious semantics as slices. The only real way to resolve this---I think---is to reduce the number of clicks it takes to get somewhere. This means much bigger pages like the haddock docs (as you pointed out) or the output produced by `godoc` for Go. Giving types (and traits, functions, etc) their own separate pages definitely feels more aesthetically pleasing, but I think flattening the crate docs a bit would yield greater utility. **One** possible solution is to treat the current page for crates as an index, and then just dump the rest of the documentation below it. Everything for a crate would be on a single page and it'd still be easy to jump around. &gt; Haskell docs still aren't perfect (and fairly confusing with, like, re-exported items) Agreed. The re-exported stuff is extremely unfortunate. (Perhaps more unfortunate is that it could be entirely avoided by library developers listing symbols explicitly instead of just re-exporting entire modules.) For example, the `parsec` module has its public interface spread out over a bunch of modules, and it's not exactly obvious to me where I might find a particular function. FWIW, `rustdoc` as a tool, with its markdown structure and doc tests, is phenomenal. Love it.
True, `str` is probably the module most exaggerating the problem, so it wasn't really that fair of a comparison. I still think we have room to improve rustdoc, though. :)
Definitely (and I agree with the original point too: the current state of built-in types is not acceptable).
You'd need to have some guarantees that the indices were unique if it was yielding `&amp;mut`s.
Please note that webfonts are not working yet. We are working on resolving this issue. In the meantime, please look at these samples: - [enum.FileType](http://adrientetar.legtux.org/cached/rust-docs/enum.FileType.htm) - [struct.CChars](http://adrientetar.legtux.org/cached/rust-docs/struct.CChars.htm) - [std](http://adrientetar.legtux.org/cached/rust-docs/std.htm) - [std::io](http://adrientetar.legtux.org/cached/rust-docs/io.htm).
The variants of an enum are defined in the same namespace as the enum itself. You'll want to do `use std::io::EndOfFile;` instead of `use std::io::IoErrorKind::EndOfFile`.
the new ones are much better than the old ones. i'd add a different background color for preformatted text and example code - that's the only thing that is subjectively worse than the old stuff.
I've never really been convinced by the Sphinx people. I've always hated using that tool, and I've tried several times over the years. The divorce between documentation and code is just way too much for me to handle. I think there's some reasonable justification lurking somewhere for such a system for really huge software projects that require a bit of explanation on how to connect different pieces together, but I'm not sure a tool like Sphinx is required for that. (I also have a lot of gripes about Sphinx and Python because, dammit, it won't let me document my representation when required. Python itself shares some of the blame here though Sphinx should have found some decent workarounds by now. IIRC, there are various hacks.) A great example of good auto-generated docs is the Go ecosystem. All API docs are auto generated, and their web site includes a smattering of articles that head in the tutorial direction. I've never been in a situation where I've felt the Go docs were grossly insufficient. &gt; but I definitely still favour reStructuredText Blech. It's too heavyweight for me. Too much syntax. We have a hard enough time writing documentation as it is. Just let us write it in Markdown---it's already used everywhere so almost everyone has already internalized its basic syntax.
I much prefer the new style. 
These look even better. Nice work! 
That can also lead to skewing if people apply downvotes at all.
The biggest issue I see across the 2 is that the new style relies largely on font size to distinguish between header levels. It should be obvious if something is a level 1,2, or 3 header without having to compare. That way it's easier for the reader to know the layout of the document and skip to the section they want.
Any by-value use of a value (e.g. using `x` like `y = x` or `~x`) memcpys the raw bytes from the source (e.g. `x`) into the destination (`y`). For some types (those that implement [the built-in `Copy` kind](http://static.rust-lang.org/doc/master/std/kinds/trait.Copy.html)), the source is still usable* afterwards ("a copy"); for others, the source is not usable* ("a move"). That is, the runtime behaviour of a by-value use of a type like `y = x` is always identical (it's always just (in C notation) `memcpy(&amp;y, &amp;x, sizeof x)`, like in C) whether or not the value is `Copy` or not, the difference between a move and a copy is just a compile time thing. &gt; "~" (moving) `~` is not a "move operator", it's just syntactic sugar for allocating memory and putting a value inside it. Writing `y = ~x` is basically the same as y = malloc(sizeof x); // allocate memory *y = x; // by-value use of `x` to move/copy it into the pointer with a destructor that calls `free(y)` as soon as `y` goes out of scope. *usable/not-usable is determined at compile-time: you get a compile error if you use a moved-from value.
I absolutely agree about comparing to js, I just did this at Hack Reactor, so the only implementations I had to compare against were JS. Unless I'm mistaken, this means that rust is still faster?
`#[bench]` and `--bench`.
I know you're not a real NZ'er, despite your disguise. ;P
I see (about the move/copy for by-value). So it is in fact copying and moving is just a special case of copying, where the source is not available anymore? `fn take_this(something : ~Somestruct) { ... }` is what I meant by `~ (moving)`. I guess it is just passing ownership, not moving.
To be clear, it's something like `let x = *y;` that does the whole copy. Writing `let x = (*y).field;` does only copy the one field (as /u/suddenbowelmovement [points out below](http://www.reddit.com/r/rust/comments/240hxa/introduction_rust_by_example/ch34hfy), dereferencing doesn't really "dereference", it just says "let's work with the value instead of the pointer").
`~` is just a heap allocation with a destructor, and so passing around a `~T` by-value will *always* leave the source unusable. That, the fact that it's always pointer-sized and the fact that you can cast a `~T` to a trait object are essentially the only differences between `~T` and `T`, and one shouldn't be worrying about the always-invalidates-source difference: if `T` *should* move, then that should be encoded in the type `T` (e.g. by having a destructor) rather than by always using `T` behind a `~`. Basically the 3 ways to touch ownership in the language itself are: fn takes_ownership(something: SomeType) { ... } fn borrows(something: &amp;SomeType) { ... } fn borrows_mutably(something: &amp;mut SomeType) { ... } `~T` falls under the first category. &gt; So it is in fact copying and moving is just a special case of copying, where the source is not available anymore? I think it's better to think of "copying" is a special of moving, where the compiler happens to notice that it is safe to continue using the source.
That's one of the nits I've noticed, but I don't know how to fix it. Explaining lvalues and rvalues in Rust isn't the easiest thing ever, not even when the reader knows the C++ value model.
&gt; The "if Copy trait implemented" idea is a little too implicit for me. You never know if stuff gets copied or not without looking up if the type implements Copy. It doesn't matter: there is no difference in runtime behaviour between a `Copy`-based "copy" and a move (which is the only other thing that makes sense). Capture-by-`Copy` is actually just capture-by-move restricted to a subset of types. Basically, I would recommend ignoring all mentions of "copy" and the `Copy` trait in this thread and replace them with "move" (except for /u/inf-groupoid's mention of single-callable closures way below, where the `Copy` behaviour is actually semantically relevant).
Amazing work, great to read both your blog about it and the code! I wanted to submit a niggle here so that you see it and can fix it -- the docs refer to "UTF8 codepoint" a couple of times, and the result is that the unicode section is a bit fuzzy. Maybe this is better: [(1)](http://static.rust-lang.org/doc/master/regex/index.html#unicode) "This implementation executes regular expressions only on sequences of ~~UTF8 codepoints~~ *Unicode code points* while exposing match locations as byte indices *into the search string*." "Regular expressions themselves are also only interpreted as ~~a sequence of UTF8 codepoints~~ *a sequence of Unicode code points*. This means you can ~~embed~~ *use* Unicode characters directly ~~into~~ *in* your expression:"
I'm still pretty new to Rust, so a lot of this was over my head. But it was a very enjoyable read, and I'm bookmarking it to return to later when I know more about Rust. Thanks for the excellent and highly detailed explanation...resources like this make the Rust community really awesome for learning!
I'd like to point out that `cargo-lite` was released months before the Cargo announcement. Oh and there's [a repository for cargo](https://github.com/carlhuda/cargo).
Excuse me for asking, but I am wondering if the smart folks behind Cargo are dedicated full time to it? 
Since this post appears to be written in the same flavor of markdown that Reddit uses, I've copied it here for readability, hope you don't mind. ---- Hey all. I accidentally broke everything with a recent Ruby upgrade (I didn't have rbenv setup right), so going back to the good ole mailing list for publishing. Hello and welcome to another issue of *This Week in Rust*! [Rust](http://rust-lang.org) is a systems language pursuing the trifecta: safe, concurrent, and fast. This is a weekly summary of its progress and community. Want something mentioned? [Send me an email!](mailto:corey at octayn.net?subject=This%20Week%20in%20Rust%20Suggestion) Want to get involved? [We love contributions](https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors). This issue combines this week and last, since I was very busy with school last week, and did not have time to write. &lt;!-- more --&gt; # What's cooking on master? 153 pull requests were merged in the last two weeks. ## Breaking Changes - Auto-rooting of `@` [has been removed](https://github.com/mozilla/rust/pull/13559). The exact fallout of this isn't obvious to me, but presumably this makes some uses of `@` not work. - `std::task::task` [has been renamed](https://github.com/mozilla/rust/pull/13675) to `TaskBuilder::new`. - Closures can [no longer be applied](https://github.com/mozilla/rust/pull/13686) through a `&amp;`-pointer. This fixes some memory unsafety. - The `Round` trait [has been removed](https://github.com/mozilla/rust/pull/13597), and is now part of `Float`, and `Float` now takes things by-value. - `Unsafe&lt;T&gt;` [is now always `Share`](https://github.com/mozilla/rust/pull/13583), regardless of whether or not the contained type is `Share`. - Modulo (`%` operator) on float types [has been removed](https://github.com/mozilla/rust/pull/13410), use the `rem` method instead. - `~[T]` [is no longer growable](https://github.com/mozilla/rust/pull/13588). - Some `Bitv` method names [have changed](https://github.com/mozilla/rust/pull/13572). - The `priv` keyword [is no longer used](https://github.com/mozilla/rust/pull/13547), but is still reserved. - Some cases where destructors were not run [have been fixed](https://github.com/mozilla/rust/pull/13390). - `unwrap` and `unwrap_err` on `Result` [now require the wrapper type to implement `Show`](https://github.com/mozilla/rust/pull/13479). - Some return types in `std::comm` [have been made consistent](https://github.com/mozilla/rust/pull/13448). ## Other Changes - There is now a [pure-Rust regular expression library](https://github.com/mozilla/rust/pull/13700) in the standard library. As I've come to expect from burntsushi, the docs are fantastic. - [Unix sockets](https://github.com/mozilla/rust/pull/13723) and [TCP sockets](https://github.com/mozilla/rust/pull/13688) now support accept with a timeout. [TcpStream::connect](https://github.com/mozilla/rust/pull/13604) can also take a timeout. - [64-bit Windows is now partially supported](https://github.com/mozilla/rust/pull/13692). Unwinding still doesn't work. - `&amp;&amp;` [is now parsed as `&amp; &amp;`](https://github.com/mozilla/rust/pull/13576) when appropriate. - Errors about use of moved values [are much nicer now](https://github.com/mozilla/rust/pull/13418). - Cloning vectors [is now much much faster](https://github.com/mozilla/rust/pull/13539). - SipHash [has also been optimized](https://github.com/mozilla/rust/pull/13522). - Steve Klabnik's 30 minute introduction to Rust [has been added as official documentation](https://github.com/mozilla/rust/pull/13416). ## New Contributors - Aaron Turon - Adolfo OchagavÃ­a - Andrew Gallant - Brandon Waskiewicz - Brendan McLoughlin - Chris Shea - Jacob Hegna - James Sanders - John Fresco - John Simon - Manish Goregaokar - Meyer S. Jacobs - Michael Fairley - Richo Healey - Ryan Mulligan - RÃ¼diger Sonderfeld - Thomas Backman - iancormac84 - mdinger # Weekly Meeting - [Two weeks ago](https://github.com/mozilla/rust/wiki/Meeting-weekly-2014-04-15), a bunch of RFCs were discussed, as well as a breaking change log. - [Last week], some more RFCs were discussed, notably the regex crate, numeric type inference, and disableable asserts. # RFCs - [Linker placement attribute](https://github.com/rust-lang/rfcs/pull/44) - [Avoiding integer overflow](https://github.com/rust-lang/rfcs/pull/45) - [Writer size hints](https://github.com/rust-lang/rfcs/pull/46) - [Revised trait matching](https://github.com/rust-lang/rfcs/pull/48) - [Disableable assertions](https://github.com/rust-lang/rfcs/pull/50) - [Macro name resolution](https://github.com/rust-lang/rfcs/pull/51) - [Private trait items](https://github.com/rust-lang/rfcs/pull/52) - [Coroutines](https://github.com/rust-lang/rfcs/pull/53) # Community Updates - For all Mac users, there is now [dash-rust](https://github.com/indirect/dash-rust/), for Rust API docs in Dash. - Another [Rust By Example](http://rustbyexample.github.io/) has been created. This one is much more complete and also looks pretty nice. - [Teepee](http://chrismorgan.info/blog/introducing-teepee.html) has been announced, the successor to `rust-http`. - [zinc](https://mail.mozilla.org/pipermail/rust-dev/2014-April/009618.html), a bare-metal Rust stack. - [An IntelliJ Rust plugin](https://github.com/Vektah/idea-rust). - [Rust for C++ Programmers](http://featherweightmusings.blogspot.co.nz/search/label/rust-for-c). - [A very fast n-queens solver](https://github.com/reem/rust-n-queens). # This Week in Servo Servo is a web browser engine written in Rust and is one of the primary test cases for the Rust language. In the last week, we landed 29 PRs. There are several very large PRs waiting to land behind an impending Rust upgrade, which will bring us April 10th. ## Notable additions - Matt Brubeck worked around a long-standing issue causing Servo to look crunched on HIDPI displays in [#2224](https://github.com/mozilla/servo/pull/2224) - Harry Maclean made `Node.Normalize()` work on all its descendants in [#2221](https://github.com/mozilla/servo/pull/2221) - jgraham cleaned up the Web Platform Tests integration in [#2216](https://github.com/mozilla/servo/pull/2216) - ms2ger, among many other things, added support for the `Any` type in dictionaries in [#2225](https://github.com/mozilla/servo/pull/2225) - Tetsuharu Ohzeki added helpers that significantly cleaned up script's layout queries in [#2210](https://github.com/mozilla/servo/pull/2210) - jdm brought back the "I tried" star for failed pages in [#2200](https://github.com/mozilla/servo/pull/2200) - Peiyong Lin implemented `Element.localName` in [#2209](https://github.com/mozilla/servo/pull/2209) - Tom Schuster implemented `ParentNode.children` in [#2192](https://github.com/mozilla/servo/pull/2192) - jdm also added a basic browser context in [#2111](https://github.com/mozilla/servo/pull/2111) - Manish Goregaokar added support for tracking the WPT manifest in [#2187](https://github.com/mozilla/servo/pull/2187) - Sankha Guria implemented `Element.prefix` in [#2199](https://github.com/mozilla/servo/pull/2199) - Bruno Abinader implemented `createDocument` in [#2072](https://github.com/mozilla/servo/pull/2072) ## New Contributors - Harry Maclean (hazz) ## Meetings and Notes In this week's [meeting](https://github.com/mozilla/servo/wiki/Meeting-2014-04-21) we went over the Rust upgrade status, some medium-sized project brainstorming we've been doing, the Web Platform Tests support in Servo, and fixing iframes. # This Week in Servo Servo is a web browser engine written in Rust and is one of the primary test cases for the Rust language. In the last week, we landed 39 PRs. ## Notable additions - Manish Goregaokar landed support of the Web Platform Tests in [#2089](https://github.com/mozilla/servo/pull/2089) - ms2ger improved the integration of WPT with our build system in [#2162](https://github.com/mozilla/servo/pull/2162) and [#2180](https://github.com/mozilla/servo/pull/2180) - Philip Horger handled treating HTTPS request as a network error in [#2166](https://github.com/mozilla/servo/pull/2166) - Peiyong Lin cleaned up some parser code in [#2157](https://github.com/mozilla/servo/pull/2157) - James Sanders associated ResourceTask with URLProvenance in [#2152](https://github.com/mozilla/servo/pull/2152) - Josh Matthews added `Traceable` and `Untraceable` types to clean up rooting in [#2147](https://github.com/mozilla/servo/pull/2147) - Lars Bergstrom changed the default rendering mode to CPU on Android [#2148](https://github.com/mozilla/servo/pull/2148) - Simon Sapin removed some unnecessary `unsafe` code in [#2145](https://github.com/mozilla/servo/pull/2145) - Matthew Brubeck fixed some terrible bugs in [#2135](https://github.com/mozilla/servo/pull/2135) and [#2134](https://github.com/mozilla/servo/pull/2134) and [#2130](https://github.com/mozilla/servo/pull/2130) - Sanhka Guria added attribute setters and getters for `HTMLImageElement` in [#2054](https://github.com/mozilla/servo/pull/2054) ## Meetings and Notes In this week's [meeting](https://github.com/mozilla/servo/wiki/Meeting-2014-04-14) we went over our Rust upgrade strategy, linking, embedding, rooting, Android support, and the commit we missed landing in one submodule for Acid2. -- http://octayn.net/ 
Yeah, I did something like your example, but I've used `std::raw::Closure` as an intermediate representation, so I didn't have to take a closure by reference. Now when I see what you have written I'm not sure if I did it right, but it does work and it does produce correct results.
Whoops, thanks for the correction! I'm new to Rust, so I just assumed the timeline was the other way around :)
Good idea, it's [#13797](https://github.com/mozilla/rust/pull/13797) now.
In general you can't implicitly move the value out of the immutable reference, except when the value is known to be implicitly copyable. The general solution is to return the value as a reference: pub fn deref_vec&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a T { self.b.get(1) } If you intend the struct to be used for primitive types only, then you should add `Copy` bound to `T` instead.
Well, "yes", where "yes" is used loosely. On my machine, with optimizations on, the sequential version runs in ~200k ns (parallel at ~3 ms). This is in the realm of "everything is probably getting optimized out", at least for the sequential. So, I compiled without optimizations, which yielded: Parallel: 16k us Sequential: 6k us And, using built-in timing functions (precise_time_ns()), so as to get a more fair baseline against the C++ version (compiled with -O): Parallel: 8.8k us Sequential: 4k us I am incredibly dubious of 500k ns runtime. But, regardless, for the sequential version, rust is faster, but by a very small factor. Depending on whether or not the results from the benchmark for the parallel code is valid, rust may or may not be faster than the parallel C++ version too. Cool. 
No, last I heard they were each doing ~3 days a week.
Supplement to lifthrasiir's response: Remember that the Vec owns its elements, and can't give them away like you wanted. Either you need to copy/clone or you need to extract the element from the vector first.
Awesome! And for regular expressions only available at runtime, wouldn't it be relatively easy to emit machine code at least for x86 and ARM? (using ad-hoc code, not LLVM) 
Do you know when this is planned to roll out? The new docs are much more difficult to read in their current form.
You still don't need to handle `raw` at all to avoid taking the closure by reference; just do the same `&amp;` thing you've done to a `raw::Closure` directly to the original `|f64| -&gt; f64`.
These are the kind of things I really enjoy about this community. This is an excellent article in general that shows off quite a few aspects of rust itself all the while showcasing the new regex macros (which I find really cool). It's great seeing that the macros provide such a universal speed up and in some cases huge performance gains all around. I'm really excited to see what other sort of things can be made with syntax extension macros.
Every Rust value has an owner: Rust-level copying would create a new value with a new owner. This is not possible for all types etc, so no such thing as a Rust-level copy is occurring. Of course it is copying bytes on the implementation level; the value is memcpy'd out and then overwritten shortly thereafter.
&lt;3 Now, if we can all just get in that habit...
&gt; I'm unsure on the timeline for this project, I'm not 100% sure, but I think the idea was to get it roughly around the same time as Rust 1.0. So, "in the future, no exact date yet."
https://gist.github.com/dobkeratops/11357252 begins to seem a silly amount of boilerplate to setup , it could just be map(|x|src.get(x)), but its nice sometimes to have one mental step to do something. i guess simply getting the array index operators in the language is far more preferable
It sounds like you'd need some sort of JIT facility for that, right? I'm not terribly familiar with the state of JIT and Rust though.
Native regexes are such an amazing idea to me, I have not run into a language (that I knew) had them until now. Rust is quickly turning into my favorite compiled language :)
&gt; I'd still rather grep the sources I see others advocating this, not only in the Rust community, and I can imagine the benefits, but it seems like it would be slower and more noisy than good documentation. What's the workflow like when doing this? I ask because, as I said, I see "going directly to the source" preferred by some to good documentation, to the point that some disregard documentation as being unimportant. I can see elements of the argument, but I have never agreed. I admit this is likely due to never having a preference for it. That is, rarely going directly to the source for details. I'm not suggesting this is the point you're trying to make - that documentation is unimportant - just trying to understand the preference. 
I'm using a black-box that rust provides for tests so that they don't get optimized out to ensure that things aren't being optimized to nothing. Without it the timings go to near 0 ns because no work is actually being done. I don't really have very much experience with doing really accurate timings, I'm basically just relying on rust's built-in benchmarking capabilities.
`iter.filter(f)` takes `iter` by value and wraps it (it's an adaptor). You would only need a mutable `fibs` there if you called fold directly or used the `by_ref` adaptor.
[#13776](https://github.com/mozilla/rust/pull/13776).
For the record, JavaScript engines tend to include regular expression JITs. It would be interesting to benchmark against those.
Sorry, but I don't understand your point. I look at next and it changes some internal fields. The fields of a struct have the same mutability as the struct itself. So from my point of view next should not be able to modify i.e. the value of 'last' since 'last' is immutable.
The most important one for beginners is to prefer "&amp;'static str" over "~str". More generally, learn about lifetimes and take advantage of them to get rid of heap allocations as much as possible.
I think the concept of explicit ownership is one of the largest in Rust (aka linear (affine?) types in type-theory jargon). Understanding how ownership works (how moving things around transfers ownership, etc.) makes borrowing and lifetimes seem more natural.
Rust doesn't really enforce any paradigm, and whenever you may feel otherwise, you are free to use unsafe block and do the usual thing (and standard library does it often). Having said that however, I'd recommend get some understanding of functional programming, since this is where many of rust concepts are coming from, many functional patterns are easy to express here, and doing this will simply teach you more then just using rust as slightly saner c or vm-less c#.
If you 'copy' it i.e. take it by value you can modify it.
The method `.filter(..)` doesn't mutate the value you call it on: It ***moves it*** by value, so it completely takes over ownership of `fibs` and returns a new filtering iterator that wraps and owns the original iterator value. This simple thing could illustrate: let fibs = &lt;.... &gt; let mut foo = Some(fibs); `foo` can be mutated because it moved `fibs` into an `Option&lt;...&gt;` value and took ownership.
Thanks for the information! will look into this.
Thanks for the info. It looks like Rust is going to be a good challenge.
Rust-Graphics is about a week old, but the results so far is ok. So far we got: * Filled ellipses * Filled rectangles * Filled round rectangles * Filled convex polygons * Filled linear interpolation of polygon frames * Alpha blending * Clear background * Margin * Transformations (global + local) Lines of code: - Rust-Snake: 1892 - Piston: 400 - Rust-Graphics: 2735 Notes: The snakes in the game renders 512 ellipses every frame (per snake). Each ellipse render 128 points which are streamed into triangles in chunks and sent to the GPU. All the interesting stuff is [here](https://github.com/bvssvni/rust-graphics/blob/master/src/triangulation.rs), the rest of the API is inlined 'sugar' to make the library nice and practical.
There is a bit vector library in the standard library: http://static.rust-lang.org/doc/master/collections/bitv/struct.Bitv.html, or are you looking for something different?
Something different. We need named fields, not indexes and we need each field to be a given number of bits in size, not necessarily one. Example in C: struct usb_register { unsigned int packet_size : 2; unsigned int speed: 2; unsigned int end_point: 4; unsigned int device: 8; unsigned int transfer_type: 2; unsigned int direction: 1; } 
It's still effectively immutable. After the `fibs.filter` statement you cannot use `fibs` anymore so you'll never observe any mutation.
Much better now. Are you sure though that it's a good idea to only consider 100-500 as valid status codes? The spec is contradictory, since it says both "extension-code = 3DIGIT" in the grammar and "There are 5 values for the first digit". One would however reasonably expect a pass-through proxy or WireShark-like tool to work properly when the HTTP code is 600, so maybe it's best to accept those. 
Ahhhh gotcha... now I see the problem. Good luck!
&gt; It looks like Rust is going to be a good challenge. It will be. I had never programmed with linear types before Rust, and it took me a few solid days of fighting the Rust compiler before things started to smooth a little. Don't be discouraged when your first few programs are basically *what you could get the compiler to accept*---things will start clicking with enough practice. :-)
Perhaps this would clarify: fn compute(limit: uint) -&gt; uint { let fibs = LimitedFibonacci::new(limit); println!("{:?}", fibs); // `print` macro inserted. let res = fibs.filter(|n| n % 2 == 0) .fold(0, |a, b| a + b); println!("{:?}", fibs); // another `print` macro. res } This prints: LimitedFibonacci{limit: 4000000u, last: 1u, next: 1u} LimitedFibonacci{limit: 4000000u, last: 1u, next: 1u} 4613732 Note how the `fib` object did not change, since it was copied to the `filter()` method. Now, consider this: fn compute(limit: uint) -&gt; uint { let mut fibs = LimitedFibonacci::new(limit); // Note: has to be `mut`; won't compile otherwise. println!("{:?}", fibs); let res = fibs.fold(0, |a, b| if b % 2 == 0 { a } else { a + b }); // Removed the `filter()` call and moved the filter into the `fold()` call. println!("{:?}", fibs); res } This results in: LimitedFibonacci{limit: 4000000u, last: 1u, next: 1u} LimitedFibonacci{limit: 4000000u, last: 9227465u, next: 14930352u} 4613732 Note how now, `fib` was mutated. It had to be declared as such as well, otherwise you would get a compile time error. 
I agree, I'm just saying that language doesn't try hard to enforce any rules here (as for example some purely functional languages would do), maybe just points direction sometimes. By usual I mean usual for another language, whatever it is for whoever reads this. In other words developers coming from another languages may decide not to change their habits to much and stick to paradigms they are familiar with. For example when I needed to store counters accessible from multiple tasks, I could: - store them in lock-protected globally accessible data structure, as I would do in most imperative languages - encapsulate state in a task and communicate via messages, as I would be forced to do in erlang - whatever other way of doing it there is, rust will allow to use it too Language and standard library allowed me to achieve it any way I wanted, without favouring one more then another. Which one you may call usual depends on your background.
bitfields are very non-portable. That's probably why they're generally avoided in modern languages.
Is it feasible to generate the getters/setters using syntax extensions? That could make for an interesting little project.
But the use case here is intrinsically non-portable (an OS kernel) and bitfields (or an alternative) are necessary for setting control registers, etc. We want Rust to be a systems language, so we need something. I don't know if other languages like D or Nimrod have bitfields or an alternative. I think they are avoided in modern languages because generally there aren't any modern systems languages.
Unfortunately not because that would mean using `concat_idents!`to create the names of the getters/setters and macros cannot be used in that position in source code. We should fix that.
A procedural syntax extension (I.e. not just a `macro_rules!` ones) can do that. (And I imagine that will be the sanest way to have a general bit-field macro anyway.)
They're only non-portable because C avoids defining any specifics. C thinks of bitfields as a way to conserve memory, rather than as a way to access hardware. Having some language defined way of cleanly accessing specific bits would be a hardware programmer's dream.
Setting control registers using bitfields is generally a bad idea. Some discussion here: http://jcardente.blogspot.com.au/2009/10/c-bitfields-and-hw-registers.html The problems depend on the architecture and the specific hardware being accessed, but as a rule of thumb bitfields can be a massive gotcha.
Thanks for the link - interesting read. Seems to me to be a fair point about using bitfields. So, I guess the preferred solution in C would be to use macros, but (non-procedural) macros in Rust can't do this. Since I don't think we should expect users to write procedural macros for this kind of basic task, and it doesn't sound like there is another solution, should we have some kind of library for doing this sort of thing?
&gt; A procedural syntax extension (I.e. not just a `macro_rules!` ones) can do that. Yep, that's what I meant. Sorry if I wasn't clear the first time. Syntax idea: since we already have the primitive `u8`, `u16` etc, the extension can simply add more types in between: bitstruct! Thing: u16 { daisy: u2, lily: u4, rose: u10 } Thoughts?
I wonder if combining arbitrarily sized integers (which LLVM supports, somewhat) and `#[packed]` could solve this issue elegantly.
It's a bit more complicated than this though. When you set a bit what exactly do you do? read / bitmask / modify / write a full word? On a lot of hardware that'll cause unwanted side effects or possibly a segfault. Should the compiler instead use the processor's built-in "set bit" operation if it has it? But what about setting a two-bit field? On most architectures there isn't any special instruction for that so you can't. It all gets very ugly very quickly and there is no definitive "right" way of doing it.
The problems discussed there are mostly due to C's nasty details regarding bit-fields, but a similar concept could be workable for memory-mapped registers etc given a suitable specification.
Thanks, these are some very interesting points. Another point, from the post pointed out elsewhere, it sounds like in some circumstances reads can be destructive, to other fields as well as the one read. It would be great if this could be specified and checked somehow. Possibly we need some sort of abstraction to differentiate reading a register into a struct and reading the values from the struct. No idea if or how that would work... 
It's worth noting for design inspiration that [Erlang's bit syntax](http://www.erlang.org/doc/programming_examples/bit_syntax.html) supports all of that. Edit: Err, except for the access width of course, since Erlang doesn't have a concept of memory. :)
I knew about cargo then, though. It was designed to be fundamentally compatible with cargo.
Right. Write-only registers would be useful, too. For the really crazy hardware you'd want something like: union { write_only struct { â€¦ } write; read_only struct { â€¦ } read; }; Where the bits are totally different for writing and reading (I've seen hardware guys do this). I would say in the case of write only registers you wouldn't support setting a single bit. Instead you'd want to do something like (C99 syntax here): *the_register = (struct my_register) { .x=3, .y=4 }; â€¦and have that compile down to a full word write to that register. &gt; Should the compiler instead use the processor's built-in "set bit" operation if it has it? No. I'm not sure I've even seen a bus design that can set individual bits in a single bus cycle. That processor is going to do a read/modify/write internally and it would have the same effect as doing it in the software would. &gt; It all gets very ugly very quickly and there is no definitive "right" way of doing it. I disagree. I believe with the proper language features you can have something that is high level, flexible, correct, and still sane.
Yeah erlang's bit syntax is really great for both generating and taking apart binaries. Although I guess in Rust instead of doing it inline, you'd have a macro defining the structure and (if possible &amp; necessary) the various dependencies and generating the function taking apart the binary stream (not just bitfield).
I don't think "make a generic way to create bitfields" is a basic task.
Seems very reasonable; although I think the syntax would have to be (something like) bitstruct! Thing { u16; daisy: u2, ... } or bitstruct!{Thing: u16; ... }
I meant that setting groups of bits in an integer is a basic task. I totally agree that the generic solution is not basic. And non-basic solution to a basic problem sounds like motivation for a library (or language feature) to me.
Can you explain why?
I don't think this is the *most* important thing. One should focus on understanding lifetimes etc. rather than putting a lot of effort into writing `"..."` rather than `~"..."`.
It would be useful if you participate in discussion of this bit fields RFC in rust: https://github.com/rust-lang/rfcs/pull/29
Wow, that C version using the Tcl library is really fast compared to the others. I wonder what it's doing differently...
If I remember correctly, tcmalloc was designed to never return memory to the OS? If that's still the case, I don't think it is appropriate for general-purpose use in a language...
Probably a lot of optimizations. Burntsushi is planning on adding a bunch of them as well.
Is this the only use case considered ? Another big use case is picking apart and assembling binary data, e.g. file formats or communication protocols.
Yes, it's a by-design restriction of the language. Macros/syntax extensions are reasonably restricted in the ways in which they can be invoked, limited to the following forms: macro! { &lt;arbitrary&gt; } macro! &lt;ident&gt; { &lt;arbitrary&gt; } #[macro(...)] &lt;item&gt; This makes Rust possible to parse without having to keep track of macros &amp; their definitions, as the arbitrary syntax that a macro can provide is restricted to just the `&lt;arbitrary&gt;` contents of the `macro!` invocations. (The `{}`s can be `[]` or `()` too.)
I think I missing something here: a macro for setting bits of an integer? Or a macro that creates a function (with some `concat_idents!`'d name) for setting bits of an integer? (The latter sounds a lot like a generic macro for creating bitfields...) (I do think a bitfields macro library like `fourcc` and `hexfloat` would be cool.)
BTW, [#8680](https://github.com/mozilla/rust/issues/8680) is the relevant issue.
i'd always been happy with C++ on this front, minus the actual bitfield syntax, using raw shifts and just wrapping those with abstractions. I think there's many other things the language would benefit more from than dedicated bitfield support. I thnk macros could help alot. my own wishlist is decltype/infered return types, int in generic typeparams, more on inheritance/coercions, HKT, UFCS. Perhaps improved array overload syntax could be repurposed for bitfields (maybe if you had N-D arays [i,j] etc and/or a slice operator [start:end] .. and you could overload that, you could use it to implement bitfields. but for the moment, just we'd just helper methods to abstract the shift/mask. 
(Being on your blog feels more "professional" for referring people to, and, more importantly, makes it significantly easier to get a list of all TWIRs.)
I wrote a very simple `bitfield!` macro for Servo. https://github.com/mozilla/servo/blob/master/src/components/macros/macros.rs Very minimal and could use more features, but it's worked OK so far. Feel free to grab it.
Currently produces around 30 `conflicting implementation in crate std error: conflicting implementations for trait std::fmt::Show` before then saying `note: conflicting implementation in crate std error: conflicting implementations for trait std::fmt::Show`. Could it be a module setup problem?
Do any of the instances of `Instances` (confusing name...) already implement `Show`, either by implementing it explicitly or by having `#[deriving(Show)]`?
Sure, but I mean in addition to, instead of just a link.
Are you sure? `.filter(...)` copies the value, not moves it. See my answer above.
[Looks very similar to issue #3429](https://github.com/mozilla/rust/issues/3429), including the infinite loop, so it looks like that the std:: trait can't be overridden locally because the generic type conflicts with the one defined...
LLVM's type system has no notion of bitfields. They are lowered into the equivalent bit manipulation of standard integer types by Clang.
As an embedded systems programmer, I've been disappointed that there's little one can do to bring register-level programming out of the realm of #define constants combined with manual masking and shifting operations. It's a very error-prone way of doing things, but C provides no tools to build anything significantly better out of, and unfortunately Rust doesn't bring much to the table right now either. The approach that I've been most interested in lately is one that's been explored by the Portland State University's High Assurance Systems Programming group, specifically in their Hobbit and Habit research languages, which are based on Haskell. They've developed a concept called "Bitdata" that integrates the hardware-level issues that people have brought up here (endianness, read/write only bits, etc.) into the Algebraic Data Type framework so that you can pattern match on fields. There's a presentation from 2010 here: http://vimeo.com/14069325 The slides from the presentation are here: http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/27/slides/mark.pdf A preliminary version of their language specification (which includes the bitdata stuff): http://hasp.cs.pdx.edu/habit-report-Nov2010.pdf Iavor Diatchki's Ph.D. thesis on the concepts: [High-Level Abstractions for Low-Level Programming](http://yav.github.io/publications/diatchki-dissertation.pdf) Iavor Diatchki's Hobbit compiler, which was an earlier implementation of the ideas: https://github.com/yav/hobbit Unfortunately, I don't have the time or sufficient understanding of the details of Rust's implementation to write up a coherent RFC to show how this "Bitdata" concept could be integrated with Rust, but I think it would be worth looking into if someone has the time for it, and it would certainly make the life of anyone doing OS or embedded systems work much more pleasant.
Why not like this?: player.drill_direction = if mine_left { DrillLeft } else if mine_right { DrillRight } else if mine_up { DrillUp } else if mine_down { DrillDown } else { DrillNone }; Looks cleaner to me.
Essentially, the reason I wouldn't write it like that is that is that it'd go against my brace style. Either way is better than one'd write if one didn't have ominpresent expressions.
&gt; *This line is here because plain markdown sucks* I love this.
You might be interested in the links I put in my [comment](http://www.reddit.com/r/rust/comments/244yz6/bitfields_in_rust/ch4aryw) regarding an implementation of typed bitdata in a research Haskell-like systems language. I think it could potentially fit nicely into Rust, though it would take a bit of work.
Generically, .filter moves the value (and can be used with iterators that can't be copied). In this case, fibs is copied *if you use it a second time* because fibs is implicitly copyable.
It does, but still: * Some of the neater code was created using match statements: player.drill_direction = match (mine_left, mine_right, mine_up, mine_down) { (true, _, _, _) =&gt; DrillLeft, (_, true, _, _) =&gt; DrillRight, (_, _, true, _) =&gt; DrillUp, (_, _, _, true) =&gt; DrillDown, _ =&gt; DrillNone }; 
As a small aside (or two): iterators have a `take_while` function, which is very neat. There's also the AdditiveIterator trait (`use std::iter::AdditiveIterator`), which adds a sum() function (equivalent to your fold). With that in mind, you can solve this as let fib = Fibonacci::new(); println!("Answer: {}", fib.take_while(|&amp;n| n &lt; 4000000).filter(|&amp;n| n % 2 == 0).sum()); ... without having to create a limit in the Fibonacci code itself.
A generic implementation conflicts with everything, including things that don't satisfy the trait bounds, so that code will not work. (This may change in future, but currently... no chance.)
Ah, interesting. Is that the case with all types that are implicitly copyable which get passed by const ref?
Is there any reason for the current behaviour or is it a bug?
It's being... proactive about avoiding a situations like the following where there are overlapping implementations impl Base for SomeType { ... } impl&lt;T: Base&gt; Trait for T { ... } impl Trait for SomeType { ... } and impl A for SomeType { ... } impl B for SomeType { ... } impl&lt;T: A&gt; Trait for T { ... } impl&lt;T: B&gt; Trait for T { ... } I guess, theoretically, it could probably detect these situations as they appear, rather than casting such a wide net, although there may be some subtleties getting this to work correctly (I don't know).
&gt; By far the most annoying bit was the lack of implicit number casting (which I begrudgingly approve of). on this subject, (manual casting having to be done for indexing was something i noticed a lot..) I would like Vec and Slice len()/Capacity types to be parameterized.. I need u32 indices most of the time, and its the cast for indexing that seems to crop up.. eg `struct Vec&lt;T,IDX=uint&gt; { data:*T, len:IDX,cap:IDX}...` I'm certainly only coding for machines with 2-16gb of ram basically, even with more you're hardly ever going to fill the entirity of memory with one collection. (for 16byte objects filling 32gb, a u32 index is still sufficient). You could also express more information in the type system, eg seperate types for vertex arrays, material indices, whatever; you'd see a vertex array is supposed to take vertex indices and so on. They should also allow for using a signed value there, of course the value wont be negative but you might want signed arithmetic throughout the calculation of indices, and you always have bounds checking anyway. (sometimes signed indices are given special meaning) 
Why not relate rust's unique ptrs to std::unique_ptr?
I'd like to. RFC soon.
I was holding my breath for 2/3 for this comparison. :)
I'm not able to explain the problem, but there are [several](https://github.com/mozilla/rust/issues/3902) [discussions](https://github.com/mozilla/rust/issues/8888) about it on github. edit: playing with this example further, I might be wrong about the applicability of those issues.
Why is a `Self` type necessary? `Succ` is a static function.
Yes. It's called Self. A trait is an abstract module that can be overloaded with respect to the Self type. If you don't need to do this, then just use a regular module (this includes the top level module you defined Zero and ChurchNumeral in).
I think that this issue is related as well. https://github.com/mozilla/rust/issues/13046
http://static.rust-lang.org/doc/0.10/rust.html#traits
And if anyone can give me a good guide to cross compiling it I will be happy.
Your first link seems the most directly applicable. It would be far more helpful for the compiler to emit an error like â€œCannot infer type of trait implementationâ€. Is that something I should file an issue about?
Because plain structs have the same semantics (except they are moved by copying the bytes directly), and copying them is usually cheaper than heap allocation.
It denotes a dynamic memory allocation, not ownership. Like any other type with a destructor, it has ownership-based move semantics. The confusion about this is a fantastic argument for ripping out the syntax and just calling it `Box&lt;T&gt;` or `Uniq&lt;T&gt;` like the other smart pointers...
It should have been done from the start though: Using naked pointers in C++ isn't really different from using unsafe pointers in rust: It should only ever be done inside a library to implement higher-level data-structures, not in normal code. If you do it nonetheless it looks like you have to attack a straw-man in order to make rust look better than C++.
The compiler cannot magically tell you don't want an implementation of the trait so it can't work out that `Self` is completely irrelevant. How about something like struct Zero; struct Succ&lt;T&gt;; then one is the type `Succ&lt;Zero&gt;`.
+1
Loved this article. Rust has got so much right!
Well I guess you're stuck using a macro for now :(
Is this likely to happen, or the subject of a RFC?
I find the term 'asshole' offensive to use in that manner, as is 'dick'. Those are sexual terms that you are using in a derogatory manner.
I've created a macro that does basically this, though uses a byte-array instead of a u16 to save the values in. [My code](https://gist.github.com/IdolfHatler/11396878) I have not created the setter, since I looked at the generated code for the getter and was disappointed by the lack of LLVM-optimizations. It should be fairly similar and I might update the gist later. It will turn this code: bitstruct! Foo { pub x: i33, y: i53, } Into this: pub struct Foo { pub bytes: [u8, ..11] } impl Foo { pub fn get_x(&amp;self) -&gt; i64 { let first: i64; let first_size: uint; let mut res: i64 = 0; if 0 % 8 == 0 { first = 0; first_size = 0; } else { first = (self.bytes[0 / 8] as i64) &gt;&gt; (0 % 8); first_size = 8 - (0 % 8); } let start_offset: uint = (0 + 7) / 8; let rest_bits: uint = 33 - first_size; let rest_bytes: uint = (rest_bits + 7) / 8; for n in range(0, rest_bytes) { res |= (self.bytes[start_offset + n] as i64) &lt;&lt; (8 * n); } res &lt;&lt;= 64u - rest_bits; res &gt;&gt;= 64u - 33; res | first } pub fn set_x(&amp;self, _val: i64) { } } impl Foo { fn get_y(&amp;self) -&gt; i64 { let first: i64; let first_size: uint; let mut res: i64 = 0; if 33 % 8 == 0 { first = 0; first_size = 0; } else { first = (self.bytes[33 / 8] as i64) &gt;&gt; (33 % 8); first_size = 8 - (33 % 8); } let start_offset: uint = (33 + 7) / 8; let rest_bits: uint = 53 - first_size; let rest_bytes: uint = (rest_bits + 7) / 8; for n in range(0, rest_bytes) { res |= (self.bytes[start_offset + n] as i64) &lt;&lt; (8 * n); } res &lt;&lt;= 64u - rest_bits; res &gt;&gt;= 64u - 53; res | first } fn set_y(&amp;self, _val: i64) { } } impl std::default::Default for Foo { fn default() -&gt; Foo { Foo { bytes: [0,..11] } } } 
Here's the discussion on /r/programming: http://www.reddit.com/r/programming/comments/2494zo/rust_for_c_programmers_part_4_unique_pointers/ (Two different blogspot domains means Reddit didn't link the two)
True, although to be fair it takes a lot more to be pure, such as not touching any global variable (constants are okay) and not using input/output arguments.
There is a difference between our levels of consideration: - from a Standard point of view, the size of `enum` is precise at the bit level, which determines the exact set of value that the `enum` can take - from an ABI point of view, a platform may choose whatever integer in which those bits fit for the underlying storage type, much like a platform is free to insert padding between struct fields ABI is a complicated topic of its own, but is now covered by the `enum: integral_type` part which let the developer pick the underlying storage type.
It's because it's more general, and looks way better when you start using different kinds of pointers. They're all the same instead of special cased.
I'm hopeful, and have been thinking about writing up an RFC (although I can't do it in the immediate future). In any case, pcwalton is hinting below that he will be possibly be writing an RFC.
I don't see anything wrong; we have over 30,000 error messages where I work, each with its own code, and I don't see why we should not be using an `enum` for it (although enumerating it manually is not exactly a solution).
i suppose owned trait objects would just be Uniq&lt;TraitName&gt; ? ... are you going to change the way it insantiates trait objects, does Rc&lt;TraitName&gt; work already is 'box' going to rely on inference to decide what actual pointer to create (its' going to be general purpose? let x:Rc&lt;T&gt; = box T, etc..). I guess when an allocation is needed , its' usually going to be specified in a return value or field declaration. Would you rely on 'unbounded type' errors to get people to think more about what type they actually wanted.
yeah and sometimes they're used to keep enums the same size enum FooBar{ // foobar is 2 words in size.. Foo(a,b); // either (a,b) or.. Bar(c,~(d,e,f,g)) // c and a ptr to (d,e,f,g) } i think Option&lt;~T&gt; is a common concept , if something large has a high chance of absence, you want its' null value to not take much space,the allocation does valid work making the space for T optional
+1 to the comments: bring in unique_ptr&lt;T&gt; right at the start and explain whats new, the compile-time safety. hehe. Even the fact it was just syntax sugar over C++ unique_ptr&lt;T&gt; and make_unique() (long names with nesting in the template, vs "~") was a draw for me... making something thats supposed to be used inplace of raw pointers look more like part of the language than a bolted on afterthought .. but it seems this is going to be lost :( 
I think the goal itself (avoiding integer underflow/overflow in Rust) is extremely worthwhile. It's a gaping hole in the trifecta *safe, concurrent and fast*. I am surprised there does not seem to have been any discussion of the proposal yet; personally the emphasis on attempting to avoid runtime overhead is very appreciated, as it would probably be a non-starter for most people. The checks could however be relaxed in `unsafe` sections, where the developer would be expected to supply the types explicitly.
&gt; but it seems this is going to be lost :( Yeah, it's a pity.
And I clearly remember Chandler Carruth struggling to generate correct lowering code in Clang to try and get minimal reading/writing width for the bitfields.
This looks amazing!
How does this affect linker speed? Are there pathological cases where the toolchain isnâ€™t expecting to handle thousands of sections for a single object file? What about at runtime? Does this impact the loaderâ€™s ability to keep code contiguous in virtual memory? Will some loaders wind up putting each function on their own page? **edit**: Bah, I'm on mobile. Didn't notice the comments below the PR.
I don't suppose there's any chance we could take a peek at the helper libs you've written, is there?
Though it pains me to say so, I too think it might be time to say farewell to the `~` notation.
There's no rules against "necroing". I'm not going to get banned for replying this late.
&gt; Does this impact the loaderâ€™s ability to keep code contiguous in virtual memory? No, the static linker merges them (unless intentionally configured to not do that). 
I think there has been past discussion on this, probably on GitHub issues or the mailing list. 
I've always felt languages like Scala and Rust take a more friendly approach to functional paradigms than other ML inspired languages like F# or OCaml, but it's almost entirely syntactic in that regard. The braces and structure probably feel more comfortable to programmers coming from languages like C++ or C#. I also feel like rust takes a more friendly naming convention that will feel more natural to people transitioning over from languages in the C-style family. For instance in rust the Algebraic Data Type is called an enum. It looks a lot like a C enum, but you can pack data in it and make recursive structures with it, but in F# they're called discriminated unions and have some strange syntax. The rust syntax makes it clear what's going on and doesn't really require some knowledge of type theory to decode. For example a simple shape ADT would look like: enum Shape { Circle(f64), //Radius Rectangle(f64, f64) // Width * Height } Where as in F#: type Shape = | Circle of float | Rectangle of float * float I find the way Rust defines the syntax to be much easier to follow. Do note that rust allows you to define enum variants as struct like Circle { radius: f64 } and so does F# like Circle of radius: float. Also C# in respect to all versions 3.0 and on have some very heavy use of functional concepts. So you're probably already more familiar with functional programming than you realize, but may have never noticed.
Sure, that's only one of the examples where this hurts though.
std::intrinsics::type_id ?
Thanks. I found one here: https://mail.mozilla.org/pipermail/rust-dev/2014-January/007655.html
That's one problem you'll likely run into. Rust doesn't currently have higher kinded types. There's no way to apply a type constructor N times, because there's no way to generically represent a type constructor, so the computations that are possible in the type system are limited.
Unless I'm missing something, having to specify `mut` would also catch the case where a library (or an API in your own code, but edited by someone else) suddenly decides to mutate the value after all.
I uploaded them before the compo but there were a few serious bugs that I had to fix during the competition. I'm also jus about to go away for a few days so I'll have it up this weekend.
We can have a flag to mark TWIR here so that we can find them all by easy search. It may be useful for discussions, since the blog doesn't support comments.
That'd be awesome, man. I'm really interested to see what you've got there, especially the text stuff. Text seems to be such a pain in OpenGL!
That's a start, but I don't think I can actually do anything useful with it, like use it to type another variable declaration: use std::intrinsics::type_id; fn main() { let intTy = type_id::&lt;int&gt;(); let a : intTy = 42; // error: use of undeclared type name `intTy` } What I really want is something like this: fn crazy&lt;fn ArgTy -&gt; ResultTy&gt; (a: ArgTy) -&gt; ResultTy; // kinda-sorta like 'apply'
I'm all for having some great tutorials and documentation around Rust's macros. They're a powerful feature, and I believe people have already quipped about macros being the Rust version of monads. They might be something that we have to tirelessly write about. Or was that something else? Syntax extensions maybe? An interesting perspective on this matter: Joe Armstrong's [Three Laws of Programming Language Design](https://joearms.github.io/2013/05/31/a-week-with-elixir.html) * What you get right, nobody mentions it. * What you get wrong, people bitch about. * What is difficult to understand you have to explain to people over and over again. Monads (esp. in Haskell) were brought up in relation to point three. There was plenty of discussion on the [Lambda the Ultimate post](http://lambda-the-ultimate.org/node/4754). &gt; From my very limited perspective, I worry that when Rust is released in the wild, macros will start popping up in regular code as much as they do in the included libraries This is a fairly standard criticism concerning use, and abuse, of macros. Over use of macros means that we can be as comfortable with the base language as you would like, but we'll be constantly battling novel macros. Even the very basic macros supplied by the C and C++ preprocessor are criticized for this. The post about [Syntax extensions and regular expressions for Rust](http://blog.burntsushi.net/rust-regex-syntax-extensions) had a note about syntax extensions having little documentation. Given that they are quite new, at least outside of the language internals, that is not a surprise. These things will improve as Rust stabilizes.
First of all, these values are impressive. However, the remaining binary seems still a bit, well, corpulent. Asking as an outsider: If I were to inspect that 597KiB binary, what would I find? For comparison, these are the sizes for native binaries of hello-world examples in Ocaml, C, and Rust (without the optimization discussend in the linked post, ``0.11-pre-nightly (30e3733 2014-04-29 00:26:48 -0700)``): -rwxr-xr-x 1 me me 1802128 Apr 29 21:48 ./hello_world-rust -rwxr-xr-x 1 me me 176905 Apr 29 21:48 ./hello_world-ocaml -rwxr-xr-x 1 me me 6732 Apr 29 21:50 ./hello_world-c Where do those extra bytes come from? Not a criticism, just asking out of mere curiosity and a deep interest in Rust. 
To be frank, I wish macro syntax was revamped to be more easily understandable. Even a simple macro such as format! is incomprehensible to me. If I hadn't seen what it's used for, I wouldn't be able to figure out what it actually does. macro_rules! format( ($($arg:tt)*) =&gt; ( format_args!(::std::fmt::format, $($arg)*) ) ) Macros in practice are also a quick and dirty solution for some things the rest of the language doesn't handle well, if at all. I don't know if the plan is to eventually expand the language and make macros less necessary for some things, but it seems like a good idea.
I'd rather just not autoborrow `~` to `&amp;` if we're going to do that.
The `type` keyword is the Rust equivalent of `typedef`: type IoResult&lt;T&gt; = Result&lt;T, IoError&gt;;
It seems like this is doable with the normal generics syntax: fn crazy&lt;ArgTy, ResultTy&gt;(f: fn(ArgTy) -&gt; ResultTy, a: ArgTy) -&gt; ResultTy { f(a) }
Did you statically link the C and Ocaml binaries?
Nope. (Statically linked hello-world in c is around 800 KB.) EDIT: Howâ€™d I go about creating a statically linked binary with rustc? The manpage offers an option to make it â€œprefer dynamic linking to static linkingâ€ but not the opposite. It links dynamically by default.
i really enjoy the series, but that blog software is godawful. i pasted the posts to a gist for smoother reading, i hope thatâ€™s OK: https://gist.github.com/flying-sheep/9cd5a6b1dc0b01c03f7d
I'm new to this, but that would be dereferencing, and then immutably borrowing it? I hadn't thought about that. Being able to say per-use that you expect it to not mutate is definitely a plus. One idea I had was an off-by-default warning, but I have no idea if that fits within the philosophy or if there's precedent.
I want `typeof`, not `typedef`. :)
Macros is the extreme end of the Rust language. Like most extreme features, I like to experiment with it, but not use it. The problem with a system language is the use cases are wide and varies between different domains. I learned to not worry too much about things I don't use, but I try to give clear feedback on what stops me from making progress. I wrote a [chain macro](https://gist.github.com/bvssvni/9674632) that flattens match pyramids. In practice, I have not found very much use of it yet. It is nice to be able to do that, but I rather refactoring the code than adding this as unnecessary complexity. At least you will not see much abuse of macros in my code ;)
I personally find the macro system in rust to be excellent. They're far above and beyond what C and C++ have in terms of macros. They provide excellent meta-programming facilities and can even take things like regular expressions and give you compile time errors if the regex isn't formatted correctly. That's useful and helps programmers more than it hurts them, in my opinion. The thing is that most every language has short comings that require weird workarounds. One of the most common is code generation and meta-programming. There's code that can shares common structure, but perhaps you can't express appropriately through the generics system of the language or perhaps you're generating types from some data source (i.e. an ORM for databases) so you can't really express that through the type system. This is an area where rust macros help. Macros allow you to do this sort of stuff inside the language without having to resort to other applications to do the code generation for you as part of the build of your application. Your macros are written in rust itself either as part of the normal code or as a crate that gets loaded by the compiler during compilation of other crates. This to me is a win because I don't have to learn some other code generation language to do these things. I also get the ability to do compile time checks and emit errors and warnings. This is a huge win IMO. Should macros always be used everywhere? Probably not, but they provide ways for users to extend the language and save themselves from having to either write a lot of repetitive code or use external code generation systems.
I find macros to be quite simple (speaking as somebody who used Rust macros before being exposed to Scheme's syntax-rules): the only features they have over C macros are that they're "strongly typed" (eg, they distinguish identifiers from expressions), they can pattern-match on more than just their number of parameters, they can't be invoked in arbitrary places, and they can't refer to "external" name bindings. Taken together, these should be easy-enough concepts for any C++ programmer to pick up, although the rationale for why Rust macros are "so much weaker than C macros" may be a bit over their head. I think the problems with Rust's macros are social issues: the tutorial is a bit weak and intimidating, they interact weirdly with the module system, the syntax looks out-of-place and ugly (the macro_rules! macro is cute, but a "macro" keyword would be more welcome), and the builtin macros and syntax extensions rely on arcane secrets like macro_escape which aren't documented anywhere. I expect all of these things to improve with time.
Oops, I misread.
&gt; I think the problems with Rust's macros are social issues [...] I expect all of these things to improve with time. You're probably right... from what I've seen, the rust devs do an excellent job in creating this language and thinking through everything, they just haven't finished it yet. (-: 
The macro system is actually split in two. There's syntax extension macros which are loaded from external crates during compilation and thus have far more power in what they can do (the new regex macro is an example of this) and then there's macro_rules! macros which are more restricted, but should be the go-to for when you're initially attempting to write a macro.
Storing a value representing an actual type in a runtime variable is usually called reflection (and depending on how crazy you get, dependent types). Rust doesn't do that (beyond the already mentioned std::intrinsics::type_id). Try to think how it would be implemented.
OH, ok... I did not appreciate that difference! Thanks!
A lot of it is because they aren't finished yet. Especially they way they are imported needs to be cleaned up a lot. The interface for syntax extensions will probably change a bit. The syntax for macro_rules is probably harder to improve on, because fundamentally it's expressing a grammar. For simple uses it's fairly straightforward but the macros tutorial goes into the really advanced uses very quickly. Personally, I like the macros in rust a lot, especially syntax extensions (the potential for designing DSLs is pretty cool, I've written too much automatic code generation for C and C++). I do think there could be some difficulty with opacity if many macros wind up being used. I think ideally libraries should try to keep the macros for very common repeated patterns and as easy to understand as possible. In terms of the documentation, searching is not intuitive but the documentation does exist, for example http://static.rust-lang.org/doc/master/std/macros/macro.try.html In that case the macro is fairly simple to understand.
No, static linking against Rust libraries is the default (which is part of the reason binary sizes are so large), however if rustc can't find `.rlib`s for all the dependencies then it cannot statically link, and so will try dynamic linking in that case.
The extra size is a library issue (not a language one) mostly due to the design of our runtimes which are basically a huge trait with a lot of different methods calling a pile of different functions (many of which are quite complicated). These get stored as a trait object, with a vtable containing function pointers to each and every one of them. The indirect storage means LLVM struggles to work out that a lot of the functions are actually unused (e.g. you don't need anything network related for just hello world), and so the optimiser is forced to leave all that dead code hanging around. This is a known issue and people are working on it (e.g. this PR itself, although it's not addressing this underlying issue).
&gt; Try to think how it would be implemented. I don't want to store a reference to a reified type. I want actual type variablesâ€”higher-kinded variables whose values are types. They are variables in the sense that they stand in for values. But they are a different kind of thing than "a name given to a specific memory allocation". Rather, type variables are substituted by the type checker at compile time.
its confusing coming from C, but once you've seen 'match ... =&gt; ' ... and been told $ is the arguments, its not so crazy. I like the fact they can make multiple patterns, the definitions are all in one place, you can mix meaning within the invocation with names and custom syntax annotating the parameters
I've always liked Julia's approach to this, where idiomatic code would append a `!` to the names of functions that mutate their arguments. For example: `fn change!(x: &amp;mut int) {...}` Obviously, the `func!` format is already used for macros, but I think the general concept has merit. It helps quite a bit in reading code.
I did some macros myself, and it was manageable, but on the other hand I love how easy it is to use macros in D Language and I don't fully understand why Rust macros couldn't be like that.
I prefer Rust's macros to any other flavour I've encountered. I also found the syntax overwhelming at first blush. But once you get used to it, its not so bad. I'm kind of happy about that. The scary syntax is a barrier to entry to using them too often. But if you do put the effort in, they are nice enough. I'd be much, much happier without them though. I'm just not a big fan of macros in general.
The thing is - "&amp;" doesn't mean immutable and" &amp;mut" doesn't mean mutable. My understanding is that "&amp;" really means "aliasable" and "&amp;mut" really means "non-aliasable". Rust requires that in order to mutate memory, that you must use a non-aliased pointer to do so. Since "&amp;mut" is guaranteed to be non-aliased, you can directly mutable memory addressed by such a pointer. However, a "&amp;mut" is not the only way to get a non-aliased reference to a chunk of memory. If you look at the Cell type (http://static.rust-lang.org/doc/master/std/cell/struct.Cell.html#method.set) you'll find that it has a method set(&amp;self) which lets you mutate the content of the Cell via a "&amp;" pointer. This is ok because the data its wraps is not directly accesible - its only accesible via the get() method and that method returns a copy. So, its impossible to have a pointer directly to the data inside a Cell, so, its impossible to alias, so, as a result, its safe to mutate it via an "&amp;" pointer to the Cell. The name "&amp;mut" I think it suggests some things that really aren't true. Rust's real rules for mutating memory revolve around aliasability and, as I see it, "&amp;mut" being allowed to directly mutate memory is just a consequence of those rules as opposed to being a rule itself. "&amp;non_aliased" might be a better name, but, I would imagine that the boat on that discussion sailed many years ago. If you think of "&amp;" as "aliasable" and "&amp;mut" as "non-aliasable" I think it makes more sense as to why Rust doesn't require "mut" at the callsite - the variable is already non-aliased so there is no need to redeclare that fact. Even if "mut" were required, it wouldn't mean much, due to types like Cell that allow mutation via "&amp;" pointers. Adding a construct that directly addresses mutability instead of aliasability, although it is very appealing for a number of reasons, would require a significant ammount of completely new syntax and infrastructure I suspect. 
i thought [...] was going to be a [T,..N] literal (can you confirm or deny that?)... which could in turn be coerced to a slice or Vec - wheras originally [...] was a vector (or slice?) literal? If [1,2,3,4] made a [int,..4] ... would "~[1,2,3,4]" currently make an owned pointer to a [int,..4] on the stack - and would it be possible to transfer ownership of that allocation to a Vec&lt;int&gt;, and figure out that its also possible for that block of memory to do the job of a vec's data by setting len=4. Possibly where vec!(...) comes across as a hack is: specifying type information in a macro name, from a naming convention, I think. .. wheras if you were to write `"let v:Vec&lt;_&gt; = ~[1,2,3,4];"` or `let v:Vec&lt;int&gt; = box [1,2,3,4]` or whatever.. that looks more 'solid', like language features interacting in a constructive way rather than a workaround for something that it doesn't do yet. ( in some cases, might the information of 'Vec' come back from inference) [...] being a [T,..N] literal would be really nice for vector maths code. 
Great work! :)
I'm flattered to be compared to Alex.
No.
However, in the example above, I did have to write "let mut x", which seems to deal with mutability and not aliasability. Is it so? 
You shouldn't be using `~[~[T]]` since each `~[T]` contains its own, separately allocated dynamic array. What you'd do instead is pass a `&amp;mut [T]` to each "task", where you're taking subslices of the original `&amp;mut [T]`. Of course creating multiple subslices of a `&amp;mut [T]` is an unsafe operation, but it's not hazardous if you're careful to make sure they don't overlap.
Of course, Rust isn't intended for people new to programming, and people new to programming really shouldn't be using Rust. Too many hard concepts baked right into the language, near impossible to appreciate them without a thorough understanding of manual memory management techniques.
That's what I originally tried, I used mut_slice to slice things out, but it only wants me to take one slice at a time, even if they don't overlap. Is there a way to do it that the language agrees is safe? 
I brought up a similar point earlier. I think we also need to consider the use case of less-than-word-width enums. For instance, a tri-state enum that only takes 2 bits.
The stdlib has the unsafety pre-written: the `.mut_split_at(n)` method.
The *language itself* won't agree to it being safe, but since we know it is, there's a standard library function that has an unsafe block doing the lifting that is itself safe. http://static.rust-lang.org/doc/master/std/slice/trait.MutableVector.html#tymethod.mut_split_at
Good point. I don't have a good explanation for that. What I'm thinking is that "mut" on a value type behaves differently than a "&amp;mut" pointer. I'm thinking that on a value, "mut" means that the value can either be mutated directly or borrowed to a "mut". If thats the case, I'm not quite sure why a non-mut value can't be borrowed to a "&amp;mut", though.
Here's what I've come up with so far: fn split&lt;'r, T&gt; (xs : &amp;'r mut[T], nseg : uint) -&gt; ~[&amp;'r mut[T]] { let segdim = xs.len()/nseg; let mut segments = ~[]; let head : &amp;mut[T]; let mut rest = xs; for ii in range(0,nseg) { let (a,b) = rest.mut_split_at(segdim); segments.push(a); rest = b; } segments } But it doesn't like me trying to do that loop over rest. (and I couldn't figure out how to rebind head and rest as I went...)
Haven't gotten great responses on there yet, and I kind of hate SO in general anyhow, figured I'd have a better chance at an in-depth response here.
Oh, if you're getting equal size segments then there's an even better way to do it: [the `.mut_chunks` iterator](http://static.rust-lang.org/doc/master/std/slice/trait.MutableVector.html#tymethod.mut_chunks). You can just write `for chunk in xs.mut_chunks(segdim) { ... }` (preferably you just write this at the point-of-use, or have the `split` function return the `MutChunks&lt;'r, T&gt;` iterator, rather than collecting into a temporary vector).
Ah OK, good stuff. But, if I try to do something like: fn increment (chunk : &amp;mut[int]) { chunk[0] += 1; } fn main () { let mut xs = ~[1,2,3,4,5,6,7]; for chunk in xs.mut_chunks(2) { spawn(proc() { increment(chunk); }); } } I get " cannot capture variable of type `&amp;mut [int]`, which does not fulfill `Send`, in a bounded closure" which I can't find any info on... Edit: Seems that spawn only takes owned closures which can only captured owned data, so references are right out =(
In the long run (around 1.0, perhaps) I'm going to start insisting that specific questions like this be posted to SO rather than here. But for the moment our traffic is low enough that I'm not really that bothered.
Thanks for the explanation! 
Those are very good points. What I was thinking of when I said easier to reason about was from a more theoretical perspective: If I have a few baked in features that I have proven to be correct, then all I need to prove that some extension is correct is that its reduction into primitive components is correct -- this may be much easier and less error prone then duplicating the common functionality. In terms of performance, you are absolutely correct that the lack of extra information or context can lead to less performant code: if, for whatever reason, I implement numbers as constant functions, then I'm going to have a hard time optimizing my language as I have to treat numbers as general functions. What I had in mind with this aspect was again related to simplicity in the sense that we can afford to spend more time optimizing one specific piece of the core language, as there are so few primitives, which can then have a positive affect on several other constructs just due to the fact that they are implemented in terms of this one core component. This is really where the balancing act comes into play: we want the smallest possible core language because it is the easiest to theoretically work with and prove properties of, but we need to still carry enough context through to the actual compiler to allow for reasonable optimizations. There are other nice properties of small languages, I've just listed what came to mind first. Of course macros can make it more difficult for the user of the language to debug, just for the fact that there is an extra layer of indirection, but if they can help eliminate the need for extraneous boilerplate, external code generators, needless/convoluted abstractions, and repeated code, then I would say they provide a much needed service. In the end, when rust stabilizes more, the user shouldn't have to care whether format! is a macro or built in magic -- at least that's the goal.
&gt; static linking against Rust libraries is the default Let me se whether I understand this correctly: The static/symbolic linking issue concerns *Rust* libraries, but itâ€™s not just Rust libraries that are part of the binary. Thatâ€™s why I get a dynamically linked binary; e.g. for my hello-world ``ldd`` claims: linux-vdso.so.1 (0x00007fffd37fe000) libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007f882dff5000) libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007f882ddd8000) libgcc_s.so.1 =&gt; /usr/lib/libgcc_s.so.1 (0x00007f882dbc2000) libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f882d81a000) /lib64/ld-linux-x86-64.so.2 (0x00007f882e1f9000) libm.so.6 =&gt; /usr/lib/libm.so.6 (0x00007f882d519000) So itâ€™s linked both statically (on the Rust side) and dynamically (for the rest) -- correct? If so, will those linkages always be part of Rust binaries or is the goal to have it deliver true static binaries at some point? 
Yeah, statically linked to Rust libraries, dynamic to system libc and libm etc.. I think you can coerce the Rust compiler to statically link to the system libs using some `-C link-args` hacks, but it's not particularly well explored at this point. I'm sure that people will be slowly chipping away at this sort of stuff, and eventually we'll have true static linking support. There's nothing in the language (and nothing I can think of in the libraries) that requires being dynamically linked to the system libs. In fact, there's nothing in the language itself that requires those system libraries even existing, Rust-the-language can run on bare metal.
Yeah, they're rare enough. We'll probably want the same policy for the issue tracker at some point (although I haven't seen much in the way of questions there yet).
Thanks to dagenix's explanation I had an idea that I posted to the mailing list: https://mail.mozilla.org/pipermail/rust-dev/2014-April/009706.html
That's a lot uglier than just using `vec![1, 2, 3, 4]` anyway...
As far as I know, D does not have macros. Templates are something else entirely, and are closer to Rust's generics.
Java has finalisers and try with, the latter being new, and the prior being slow.
Oh awesome. I wasn't aware Java had 'try with'. I'm using Java for Android developement and I haven't seen any tutorial/manual mention this yet tutorials. Thanks for enlightening me! Is it really slower? I would imagine it's just syntactic sugar for `try { ... } finally { resource.close(); }`?
Does the rust community have problems with &gt;hateful, hurtful, oppressive, or exclusionary remarks ? I've been visiting this subreddit and hanged out on all rust-related irc-channels on irc.mozilla.org for over a month now and never seen anything other than discussions about or related to the programming language in nothing but a friendly manner. What have I missed?
No, there is not an endemic problem. Unfortunately, there have been a few significant isolated incidents on IRC (the stickied post on /r/rust is a product of the first, and these new definite guidelines were prompted by the second one which occurred just recently). In any case, one doesn't need to have a problem before taking steps to make it clear that that sort of behaviour is entirely unacceptable. (And it is entirely unacceptable, speaking as a mod of /r/rust and #rust.)
I don't believe you've missed anything. This is part of allowing the community to grow in a safer way. There have been events that involved such behaviours in the past, but regardless such events have existed or not, it is important to establish the rules of our community and make sure it remains what it is today. A safe, nice and friendly environment full of very capable and amazing people.
Finaliser are like destructors from what I've heard, and have issues with garbage collection, which is why they're not used, I believe. Those are what i meant by being slow, I'm pretty sure try with is fine.
Are you on [#rust-gamedev](http://client01.chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust-gamedev) ? Also, I saw you haven't implemented graphics yet. Currently I am working on a project to simplify 2d graphics across back-ends: [Rust-Graphics](https://github.com/bvssvni/rust-graphics). It is very limited yet but might be useful for something like Go. At top of this there is another project called [Piston](https://github.com/bvssvni/piston), which goal is to develop a user friendly game engine. Previous weekend I wrote a small game which uses Piston, in case you need example code: [link](https://github.com/bvssvni/rust-snake) All these project uses [Rust-Empty](https://github.com/bvssvni/rust-empty) which automates the setup of your project. Currently I'm busy with working on Rust-Graphics, but would love to see how Piston works in the hands of other people. Feel free to open issues and send pull requests!
Thanks for the comment. Very kind of you to say that I haven't implemented any graphics, yet when I haven't written a single line of code to date ;) I also don't plan to write any graphics frontend for the engine. For Go there's a text protocol called [GTP](http://www.lysator.liu.se/~gunnar/gtp/) that let's you communicate with external frontends as well als Go online servers (like KGS).
But think of ***all*** the delicious link karma
I did a fairly straight forward translation of the Python: I'm sure there's large gains possible by using the various modifications the current [top answer](http://codegolf.stackexchange.com/a/26337/4832) made. 
And thanks for mentioning rust-empty. I had seen that before, but I wanted to dust off my Makefile skills which is why I wrote my own.
typeof/declype is definitely one of my highest wish list features at the minute, its possible some other ways of solving some cases exist but id' guess they're more complex (HKT and return-type-inference) ..still, HKT would kill many birds with one stone
Yay meaningless, magical internet points!
It's not trying to "sort out" a single IRC incident, it's answering "what happens for hateful behaviour in future?". Interpret the email as if it says: &gt; if you behave rudely/hatefully, then you will first be warned, then kicked, then banned (if you continue). rather than just addressing moderators. A reason for having a more formal process is the Rust community is growing, meaning there may be more people taking moderator roles, whether in the "official" communication channels like the mailing list, #rust &amp; /r/rust, or otherwise. (e.g. only recently have the first few non-Mozilla moderators been added to #rust.) Having more people means it's harder for an informal procedure to work. Another reason is having these sort of guidelines in the main community early is it will "set the scene" for satellite communities that develop.
`loop` has different semantics than `while true`. It's something to do with lifetimes (I think). Although `while true` could be special-cased and have the same semantics as `loop` does now.
It's really nice to see rust competing with the faster times shown by C and C++ solutions.
Yea, and it's not even 1.0 yet!
That saved me the trouble of doing it myself. I am disappointed, though, that itâ€™s another thing being scuttled by using randomness. Meaningful comparisons MUST NOT use different types of randomness.
Then you also have to start special-casing things like: let mut cond = true; while cond { // some things that // are guaranteed to // run at least once // ... cond = some_calculation() } Because people will expect it to work. As I recall this is what it's really about: `loop` allows the compiler to assume that anything before the first `break` is guaranteed to be executed at least once. `while (condition)` has no such guarantee. This may make a difference when, for example, you declare a variable outside the loop but don't assign it a value yet, and assign it in the loop. Example: Prog1: let mut c = true; let mut x; while c { x = 5; c = false; } println!("{}",x); Prog2: let mut c = true; let mut x; loop { x = 5; c = false; if !c { break } } println!("{}",x); Prog1 will not compile, while Prog2 will :)
Indeed. Hence why `loop` still exists. I'm pretty sure this was discussed about a month ago here on /r/rust.
Totally. We should come up with an app or sdk made purely of RUST that people can jump on. I really wish there was something like Node (node.js). If anyone's gonna make it.. Corrode would be a nice name :P
No.
I miss those too, but according to a post on the mailing list reaching a stable 1.0 version has priority for now: https://mail.mozilla.org/pipermail/rust-dev/2012-August/002241.html &gt; There is room in the syntax and semantics for this in the future, but I agree with Patrick that running experiments on combining such features is past scope for the "stabilize for 1.0" roadmap; we already have a _very_ full plate and have been trying to get the language to stop moving for two years now.
Neat. You think that this'll be more of a first-class feature in the future though? I understand that the ~[T] -&gt; ~[~[T]] mapping has to allocate new vectors, but it seems like under the hood it could alias the memory for you and ensure that it was non-overlapping, then you could just bind them up in the spawn closure normally and go about your business. I don't know what the definition of Vector looks like in the implementation, but in C++ if I had something like: template &lt;typename T&gt; class Vector { public: size_t len; T* data; }; Then, sure I'd still have to allocate new instances of Vector, but then I could just twiddle pointers under the hood to make them encapsulate different parts of the array. This would be very important for the stuff I do, where I routinely memory map multi-hundred gigabyte files. It's just not feasible to do any copying in that case. 
Works pretty well for both, surprisingly enough.
Yes, [the Share kind](http://static.rust-lang.org/doc/master/std/kinds/trait.Share.html) was added to make it possible to expose safe interfaces for working with references and other shared data between tasks. I think the last missing steps are a few compiler tweaks and then the libraries themselves. (That C++ definition is exactly what a slice `&amp;[T]`/`&amp;mut [T]` is, btw.)
Very cool, sounds like it's all in the works then and I just need to be patient.
Overloading can be added in a backwardsâ€compatible way, so itâ€™s not such a high priority. Of course, it also depends on what you *mean* by â€œoverloadingâ€. The term is overloaded.
Slightly off-topic question: If any, what knowledge about static types is rust using for optimisation that C/C++ would not provide? Is there more to come?
Funny, I also [used Rust for a code golf](http://codegolf.stackexchange.com/questions/21571/generate-an-understandable-sentence/21918#21918), once. Thank you, `#[deriving(Rand)]` !
We're using some aliasing information that the borrow checker provides, and we can provide more over time. Specifically, we know that `&amp;mut`s never alias each other or other `&amp;` pointers temporally, and that `~` never alias each other.
One of the reasons there hasn't been any problems yet is because there's been an explicit policy since the beginning. We're not perfect, but it's been pretty reasonable so far.
Years upon years ago I was in a book store when my eye was caught by the familiar sight of some Go books by Ishi Press. I went over to look through them and nearby there was a book (perhaps from another publisher) on the topic of how the end-game can be played perfectly (provably so) after the game has reached a certain stage. I grabbed it, of course, thinking that it might come in handy in writing a Go AI, even though all of the real interesting work in a Go AI would involve playing much earlier stages of the game, long before quibbling about single points in small battles for life along the edge became relevant. I never got to spend much time with the book. There always seemed to be a higher priority. "Mathematical Go", I think it was: http://math.berkeley.edu/~berlek/cgt/gobook.html
mixin + templates is what I consider D's "macro system"
Ah, I see. I never played it.
on another note i would be interested in the idea of giving for/while the ability to have a return value (break expression?.. and copy python's ..else{}?) maybe that be an elegant way of getting a value out - and it completes the idea that rust blocks are expressions with a value. More elegant and more composable tools than having a seperate infinite loop construct 
I thought they weren't guaranteed, but generally did and were quite slow.
The implementation still has a lot of low-hanging fruit to pick when it comes to performance. For example, even though we automatically generate aliasing information (e.g. `restrict` in C) as a side effect of tracking ownership, we still aren't in any way conveying that information to LLVM to enable further optimizations. I'm sure there's lots more too, but Rust moves so fast that I'm not sure what's left to be done there. Zeroing? Drop glue? /u/strncat and /u/eddyb are probably the experts here.
As dbaupp has alluded, the moznet operators are planning on adding a slew of new ops to the IRC channels. Thus the additional clauses regarding op behavior.
I had never heard of Toki Pona. Awesome!
I'm new to rust, and program language design, so perhaps this is obvious to others, but does the proposed syntax make `box x` valid or is it going to only be `box(x)`? I see some people in github's comments using `box x` syntax, but I don't see it in the actual RFC.
`box x` is currently valid syntax and (I think) would remain so. `box` is a keyword, not just a plain function. You would need `Box&lt;T&gt;` for the type.
It's the same as almost all patterns: the destructuring syntax is the same as the constructing syntax (e.g. enums, structs, references, slices).
It also allows specifying an allocator
It also allows one to construct directly into a location: currently something like `Rc::new(make_huge_struct())` will write the struct to the stack, allocate memory for the `Rc` and then copy the struct into the allocation. `box (Rc) make_huge_struct()` will allow one to allocate then construct the struct, writing it directly into the allocation. (BTW, I'm not sure the pointer type will infer, `box 1` may just be sugar for `box (Box) 1`... But maybe it will, I'm not sure of the latest plan for this part of the exact syntax/behaviour `box` operator itself.)
How often are you encountering type signatures containing `~`?
The destructuring syntax should look like the constructing syntax since it should be the same syntax, just in a destructuring slot instead of an expression slot.
http://i.imgur.com/bsKMZ1i.png
Just a thought. Would it be useful (and possible) to add some extra sugar to rusts macros, so that the following two lines become equivalent? let x = default!(Foo, x:10, y:20); let x = Foo.default!(x:10, y:20);
I like the proposed Box-syntax because it is googleable. This will help newbies trying to understand error messages and code on github. But if tilde is kept as optional sugar, then the language could become less googleable, because newbies don't understand that tilde and Box are the same. 
Ha! There's a Majora's Mask reference in there too.
Bad poetry... oh noetry [^^^^src](http://www.toothpastefordinner.com/index.php?date=022005)
This has made my day
It could be Vogon poetry.
Although I find ~ to be nice because it's short and reduces nesting, I must admit that there are some good reasons to go with box and Box&lt;T&gt;. My usual keyboard layout doesn't have a ~ symbol. I didn't feel comfortable using Rust until I edited the layout which required installing a special program. At first I didn't even think about this possibility. That said I mainly used ~ for ~str and ~[T].
Statically linked rust runtime.
https://twitter.com/pcwalton/status/461195039180193792
Would be good to have `~` be a shorthand for `box(heap)` still.
That's only the third worst.
yep, see https://github.com/mozilla/rust/pull/13833
Only when using libstd, statically linked. You can use `-C prefer-dynamic` to get a much smaller binary. A large part of the size is just bugs though.
You won't need to pass anything to `box`, the default will be unique pointers. Keeping both around makes the language more complex and Rust puts a lot of effort into avoiding duplicate features.
Kinda saddened to see the sigils go away (both `~` and `@`). Some time ago one key motivation was to take the smart pointers that we should have been using in C++ and make them less noisy/verbose and more strongly integrated in the core language. Now it feels like we are stepping back from that. 