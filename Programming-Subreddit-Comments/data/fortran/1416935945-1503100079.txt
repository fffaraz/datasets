The * basically means default. It can be used in place of a unit number or format statement. Note; reddit doesn't like you putting: *,* as it just tries to make an italic comma, unless you have it in a code block, so if something doesn't make sense it's probably because I didn't put it in a code block. Read(*,*) This will read the default read device (normally the keyboard) and wont format what it reads. Be careful with this! It's not a good idea to do unformatted reads. Write(*,*) This will write to the default write location (the screen) and not put any formatting into it. Write(*,*)var1, var2 where var1 = 'Wednesday' and var2 = 'November' would give you: WednesdayNovember as an output on the screen. That being said, if you want to read and write to a different location; like a file, you have to use OPEN statements, as you have done. The first number you have is the unit, you have used 5 and 6, which is not life threatening, but may cause confusion. What I will do is write you a safe open subroutine. I'll throw it up on pastebin when I'm done. Basically it will look to see if the filename is in use. If it is then it will increment the file name so that each run produces you a new output file. and you wont have to mess around any more. It's a bit of a bodge, but it is easier than trying to understand your code, no offence. It might take me 90 minutes or so as I have to pick someone up from town in a minute. It's not a bother as I have the code already written. (Actually, it's some our research group's common code library that my supervisor has written. I'll modify it to work for you, so hat tip to Prof. N. Kirkby, really)
Also, what compiler/version are you using? If you happen to know.
I believe 77. I'm back on campus and the code i've shown you wont even run at all on these computers. I really dont understand fortran and how it can be so inconsistent across different machines.
No, you are right. I guess my text wan't very clear. You can probably set them, like OP did, using an open statement.
What command do you use to run your program? From that there is probably a --version tag where we can get the actual compiler / version etc. 
I was getting lost in comments, so made a fresh rather than replying. I've tried to stick with FORTRAN77, but then I realised that everything I wrote is valid for FORTRAN90, but almost certainly not for 77. Apologies, I may have just wasted both of our time! There are two pastebins. The first just has the code I wrote and the second I have integrated it into your code, so hopefully you can just copy/paste and run. First, a little of of programming ettiquette which should be valid for F77. When you write END, tell people what you are ending! Normally at the start of a program, the very first line is: PROGRAM MyProgram Then at the end of **the whole file** use: END MyProgram I tend to use caps for this, but that's habit rather than doctrine, I think. When you have finished your 'main program' and you are just about to start your subroutines put: contains This tells fortran that you are done with the main program and then the rest are subroutines. As another point, when you are finished with a subroutine (for instance; my_sub), it's better to put: END SUBROUTINE mysub Don't put the interface in that line (the bit in brackets that shows what's being sent in and out) Quick recap: PROGRAM MY_PROG !main program here contains SUBROUTINE mysub(my_var1, my_var2) !Subroutine activity END SUBROUTINE mysub SUBROUTINE mysub2(my_var1, my_var3) !More subroutine stuff END SUBROUTINE mysub2 END PROGRAM MY_PROG Links: [Just my code](http://pastebin.com/AYCy7F7c) [Integrated your program in](http://pastebin.com/y3LgDtNS) There are a few hairy things in there, but it should work OK. If you have any problems then drop me a line. 
hey man. I really appreciate this. Unfortunately it's still not resolved my issue. I truly have no idea what's happening. A friend sent me his code for this problem and i've rearranged it so that it would read my input file and have my formatting statements and it runs. Like it looks identical to what i've been showing you now that ive changed so much but it runs now. It blows my mind.
Just preference, but it depends. For modules with just a few variables or functions then the second option makes more sense. If you just need a few things from a module that has lots of definitions, then using the 'only' clause is good practice and avoids contaminating the namespace. In that case, using a getter to be more explicit may also be more clear. Also, instead of private, module variables can have the protected attribute which allows them to be read outside the module but not written to and can be useful in certain situations. 
The key advantage of method 1 is that the value of `var` is protected from being accidentally modified. Of course, in [modern Fortran](https://software.intel.com/en-us/node/526549) this can be done by declaring `var` as a `protected` variable. module example1 implicit none integer, protected :: var end module example1 My preference is to use the simplest method (method 2 typically) until I find myself in a position where adding in those extra layers of complication/control would actually be of use.
You can do something like this: character(len=20) :: fmt real :: num integer width width = 5 write(fmt, '(A, I0, A)') '(f0.', width, ')' num = 1.2345 write(*,fmt) num Which writes an integer to a string to create the format. The problem you were having is that 'b' was treated a string literal, not an integer, and it was expecting a number there.
What vintage of Fortran (e.g. 77, 90, 2003)?
Is this your first programming course?
yes
In addition to the resources tomedunn listed: I recommend *Modern Fortran Explained* by Metcalf. It's a good book for learning and as a reference as well.
For Fortran 90 (what I mostly use), I really like [this book](http://www.amazon.com/Fortran-Programming-International-Computer-Science/dp/0201544466). It takes a no-nonsense approach to Fortran 90. Also, a good resource on the web is [this website](http://www.personal.psu.edu/hdk/fortran.html); however, it's large size and plethora of links can make it somewhat difficult to navigate.
FORTRAN was my first language too, so I know it can big hump to get over to start to feel comfortable. What is it that youre having trouble understanding and perhaps a better question is, what kinda of course is this. If its a low level course, you should be able to be set straight rather quickly. The first step is figuring out where youre getting hung up.Try going through a small bit of code and when you hit a snag, google the keyword followed by "fortran 90"
Fortran is great, but there is a lack of good courses and textbooks, and because it's a minority language, you're less likely to find good answers on stackexchange etc. If you've never touched any programming language before, it may be best to find a "C for dummies" tutorial online first (or some other tutorial for absolute beginners, preferably for C), just to teach you the general concepts of programming that are fairly common amongst many languages - stuff like arrays (fixed length &amp; dynamic), variable types, loops, pointers, if statements, etc. Many Fortran tutorials assume you already have some idea of how to program, so picking up some of the basic concepts from a tutorial for another language may be useful.
The xkcd fora helped me. I'll write the solution we came up with here in case someone else needs it in future: Write(1,"(a,F10.6)") "Text", distance
Anytime you use a "list-directed" formatted `write`, i.e., with the output format set to `*`, as you have in your first example write(1,*) "Text", distance the output line will have a leading space added to it. You can get around this problem by supplying the write statement with an appropriate format instead. In your second example you provide such a format in the form of a format string write(1,"(a)") "Text", distance However the format you've supplied, `"(a)"`, is only sufficient for writing a character array such as `"Text"`. In order to have your write statement also write the value of `distance` you need to revise your format string. For instance if `distance` was a `real` variable then the format string `"(a,f16.8)"` would write "Test" followed by the value of `distance` with 8 digits after the decimal place and up to 16 characters in total. So for example real :: distance =3.14159 write(1,"(a,f16.8)") "Text", distance would output Text 3.14159000 If you substitute the blank spaces in the previous output statement with `^` you can easily verify the total number of characters is 20, 4 for "Text" and 16 for `distance`. Text^^^^^^3.14159000 To learn more about formatting write statements check out the following links: * [cs.mtu.edu](http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html) * [web.stanford.edu](http://web.stanford.edu/class/me200c/tutorial_77/17_format.html) * [Intel Fortran compiler](https://software.intel.com/en-us/node/525638) --- **edit**: As /u/doymand correctly points out, write statements with the format `*` are not unformatted. The `*` format indicates a "list-directed" format which can be thought of as a default format. Unformatted write statements are something else entirely and typically refer to writing output to binary. I have edited my original post to reflect this. 
Yeah, it means "default format". But it looks like tomedunn knows what it does, s/he just used the wrong term for it.
&gt; line numbers, smart indents, and syntax highlighting I've got that in TextWrangler. I think what I really want is just some of the features of [BBEdit](http://www.barebones.com/products/bbedit/comparison.html), which is basically the full (paid) version of TextWrangler. Little things like multiple clipboards and highlighting every instance of a keyword would be handy.
I don't think that's available for Mac? I've used Notepad++ in Windows, but I don't like Cygwin etc, so I tend to prefer MacOS or Ubuntu.
Ah sorry. I didn't even think of OS when I wrote that. When I was a Mac user I think I used TextMate for the same reasons I used Notepad++. In fact, I think I found TextMate when searching for a Mac equivalent to N++ originally. 
Method (1) is generally considered to be a better practice, because you know explicitly what you are inheriting from the module. Method (2) involves less work, but it's not immediately clear when looking at that code what you have picked up with the "use" statement. This makes it harder to avoid reusing variable names etc. As a general rule in any programming language, you should want to only have access to the stuff you actually use. Having everything as a global variable or using a big "use" statement all the time means you're carrying around a big baggage of variables everywhere, which can cause conflicts and confusion. That said, it's not really a problem if you're only writing a small program.
I don't deal with direct access I/O often so hopefully someone else can confirm/correct this, but I believe you can read/write multi-dimensional arrays just fine so long as you have only one array element per record. So as an example, if I have a 2x2 array of integers integer :: array(2,2) I can write the 3rd element `array(1,2)` to the third record in my file using open(unit=1, access='direct', recl=10, form='formatted') write(1,'(I10)', rec=3) array(1,2) and then read it back using read(1,'(I10)', rec=3) array(1,2) 
How long do you have to do those 4 assignments?
If you have questions about a certain feature or a particular problem then people are usually glad to help if you've made a genuine attempt. But just throwing 4 problems out there and saying you need to solve them isn't helpful. Looking through a few of them, they don't seem terribly difficult. What are you having problems with specifically? 
Theyre not difficult to someone with experience. I have never programmed in my life and this is supposed to be an Intro to Fortran. The professor has never taugh anything that relates to the homework and our text book is complete garbage. My main issues I am having is "Where do I start"?? I need a Fortran Intervention, I am not simply looking for handouts. I have done well in the class in terms of quizzes/midterm (82% on midterm) but the material taugh in the classroom, there is absolutely no way for me to figure out how to start. When you go to the professor to ask questions he snaps on you like you are a moron. I am still working on assignments 5 &amp;6 as well but I have them done, with minor errors. Assignment #5 I get it to print the output but my loop is not working so it just prints the same thing over and over. Program Prog5 Implicit None CHARACTER:: FILENAME Integer::J,IERR,COUNT,YEARS,MONTHS,IVALUE Real::R,P,B,TOTAL FILENAME= 'DATA5.TXT' Open(unit=10, file= FILENAME, action= 'read', status= 'old', Iostat= IERR) 200 FORMAT (20X,A12,20X,A6) !PAGE HEADING Print 200, "Payoff Times", "Page 1" 210 FORMAT (4X,A13,4X,A11,4X,A5,4X,A6,4X,A9) !COLUMN HEADING Print 210, "Interest Rate","Payment ($)","Years","Months","Total ($)" Do Read(unit=10, fmt=100, Iostat=Ierr) R,P 100 FORMAT (F5.3,4X,F6.2) !READ DATA VALUES B=20000.00 Count= 0 If (B .LT. P) Then TOTAL=0 B=0 Count=Count+1 Else B=B-P B=B+B*R/12 B=B+0.005 J=B*100 B=J/100.0 COUNT= COUNT+1 TOTAL=TOTAL+P END IF !CALCULATE YEARS AND MONTHS YEARS= COUNT/12 MONTHS = MOD(COUNT,12) 220 FORMAT (14X,F4.3,4X,F5.2,4X,I2,4X,I2,4X,F8.2) ! DATA ENTRIES PRINT 220, R, P, YEARS, MONTHS, TOTAL END DO Close(10) End Program Prog5 
This is my first time as a Reddit user, I replied to your comment but not directly. I am not looking for complete handouts. I am looking for a reference to help me learn this.
I have a week. I have been in constant communication with the chair of this department regarding the professor. He has over a decade of bad remarks from students. http://www.ratemyprofessors.com/ShowRatings.jsp?tid=62519 As you can see, this is a reoccuring problem for many students. I was told by the chair of the department that some course of action would be taken, well now its 1 week before finals and nothing has been done and I am stuck between a rock and a hard place. He is the only professor that teaches this class, there are 0 tutors that know this at my university and I do not know anyone who knows Fortran well enough and has the time to devote to be able to help me. ( Stepdad has been a programmer for 35 years but he works from 4am-730pm everyday, and I live over an hour away so I can barely use him as a resource)&gt;
Have you completed the previous assignments? The assignments seem to flow pretty well. I've you've done the other assignments then you should at least know the basics of programming that will get you through 7-10. You need to find some online resources on how to program fortran and spend some serious hours going through them. You will eventually find one that hits you home in the way that will help you. But this could take a while. http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/F90-Basics.pdf http://www.owlnet.rice.edu/~ceng303/manuals/fortran/ http://micro.ustc.edu.cn/Fortran/Fortran%2090%20Handbook.pdf http://www.uv.es/dogarcar/man/IntrFortran90.pdf http://www.am.qub.ac.uk/users/d.dundas/msci_workshop/fortran/notes/fortran90.pdf There are many people on here that if you give them a direct question will be happy to help. Reading his ratemyprofessor makes me think he is more of a pseudo code person, who lets you work out the small details. So start there. Think about writing the pseudo code for your problems, then from there fill in each little bit with real code. That is where people here can help you. 
The assignments would flow well together if I had any clue what is going on. Most of my problem is formatting based, but after asking for help several times before the midterm, I was messing up DO loops, IF statements and on. Like I said, I have absolutely 0 programming background and after asking for assistance earlier in the class, it was not reciprocated leaving me not understanding what is going on. Which is why I was in constant communication with the chair of the department to say "Hey, this guys is not helping and Im going to him for more help and that does nothing". The chair of the department did nothing for me, didnt offer me guidance, assistance, nothing.
Thank you very much for this reference. I see where I was wrong, but this is where I am saying lies the issue. The teacher never correlates the assignments and the classroom lecture, so I understand the concepts but there is no guidance/assistance from the professor. He is a real stickler about the formatting about all of these assignments, which is why this is not "Intro to Fortran", he expects perfect assignments. This is supposed to be a gened. I truly appreciate you taking the time to explain everything thoroughly sneddo, otherwise I could never make the inference of what I was doing wrong when the programs wouldnt work.
I agree that these assignments seem hard for a very first course on programming.
I can not begin to describe my appreciation for your reference. So much more makes sense just from the comparions I can make between your very well designed program and my not so well designed one. I was on the right track with this assignment and the next and the comments you provide really help me understand what is going on. I think half of my problem is that I am trying to clump everything together, but we never were really taught well how to structure anything in class. 
I am using it as a reference and understanding what parts I was on the right track and what I did wrong. I agree that a week is not ideal to complete them. Saturday I am taking the 1+ hour trip to my parents house to get help from my stepdad, so between that and the tutor I found at a local community college (go figure), and you all as a resource I can do enough to pass, and at this juncture, that Is all I am looking to do. I have been doing well on quizzes/midterm. Quiz/midterm/final make up 60%. Assignments make up 40% so I just need to accumulate points in general. I am very upset I was not referenced to Reddit earlier by my friend otherwise this semester may have went smoothly for this class.
I think that Intel decided not to offer its compilers for non-commercial Linux development for free. 
there are quite some syntax errors when i try to compile it. It complains about a do loop/if statements which needs a attention, duplicate statement labels for format statements, an '=' in your wci calculation and a real funky print statement. These shouldn't be to hard to fix first. Hint: try parenthesis. After fixing these and providing some input the program goes into an infinite loop (the 2nd where you only print things). e: btw, i'd loose some of these format statements for real numbers, fortran is smart enough to recognize them without (unless stated ofcourse but is seems it is not) e2: the second do loop doesn't do what you think it does, it's good to see why not. Sometimes [these things](http://en.wikipedia.org/wiki/Nassi%E2%80%93Shneiderman_diagram) come in handy to do beforehand. e3: i can't imagine this is the first thing to do in that class. if so your teacher is a prick.
It is the 6th assignment of 10. He never teaches anything that relates to this "extremely proper formatting" and he has never used a computer in class to show us trial/error. The professor is like 75 years old and yes can be a prick. I thank you for your insight but since I lack the overall knowledge, I dont really know how to apply it.
ok so keep the formatting then. You might want to take a look at the syntax errors first, most of them can be solved by using parenthesis around the check. Also the double use of 10 in format should be different. The = should be a + in the wci assignment. If it compiles you'll see the infinite loop, seeing what you've done now this should be fixable since you read in values in the first loop, maybe you want to check it in the first loop instead. Old professors are keen on hand written diagrams of program flow and it might be why he doesn't like trial and error. Having the general program flow written out on paper might please him. e: you can 'label' do loops so you can exit them. Also you should have a (if) check to see when you'll need to print a new heading. See [this](http://en.wikibooks.org/wiki/Fortran/Fortran_examples#Calculating_cylinder_area) wikipedia example of how to do so. 'exit' instead of 'cycle' exits.
Depends on how you learn, but I find the best thing for learning a new langauge is to find some simple (and then increasingly complex) programs using that language, and try to pull them apart and see how they work. If you go down this route, you need to be quite conscientious. If you don't understand what a line of the code is doing, find out, don't skip it. It's coming to understand these confusing lines of code which really improves your understanding of the language.
I just glanced at your code and the first thing that jumped out to me is that you have two `format` statements attached to the label unit `10`. Once on line 18 at DO READ (*,10) DATE, T, V !Read the data then calculate WCI &amp; RISK 10 FORMAT (A10, F4.1, F4.1) ... and again on line 42 at DO ... PRINT 50, "Frostbite Risk:", RISK 10 FORMAT (A, A10) ... Also what compiler are you using? And have you learned how to read compiler output yet? Generally speaking the compiler will tell you what lines and what variables are causing the problems. 
Thank you very much for the example! I am aware that it is a good practice to use the 'implicit none' statement and explicitly declare all variables. However the legacy code we have in hand don't have these nice things and it has been verified to produce correct data so we don't want to fiddle with it.
I've never used pFUnit but from quickly browsing the documentation on it what you described sounds generally correct. I would be a little cautious though if your code uses any kind of parallelization since this can cause the results to differ slightly.
&gt;First of all, am I even thinking about this correctly? What are your binary output files representing, arrays of floating point numbers? If this is the case, it's extremely unlikely that comparing the binaries to be exactly equal will do what you want -- you'll need to read in the binaries and do floating point equality tests in pfunit *with some error tolerance*. Not sure if it has an "assertNear" function (it really should), but if not you can do "assertTrue(abs(a-b)&lt;1e-5)" where 1e-5 is some tolerance. Reason being is that if you're modifying the code, simple things like 1/8\*5 will in general give you a slightly difference answer than 5/8, for example. &gt;Secondly, I can't actually find anywhere online that states how I would go about doing that. Does anyone have any ideas? Sounds like you already figured out how to do it. Write a test that reads in your binary files into whatever kind of appropriate data structure, issue the tests.
have you tried adjusting shell path and running make? It's too much of a mess to make sense of it but the makefile looks like (cygwin/msys) gnu make. 
Why has this not yet been submitted to /r/fortran ?
It's on the sidebar already under "Suggested Links." Or was that just added? I thought it had been there for a while.
I managed to make it only a little bit faster (on my laptop, so your mileage may vary) by changing it to: type :: route type(node), pointer :: dest integer :: cost end type route type :: node type(route), dimension(:), allocatable :: neighbors logical :: visited end type node contains recursive function get_longest_path(current_node) result(distance) type (node), pointer :: current_node integer :: distance type(node), pointer:: j integer :: i,temp_distance,curmax temp_distance=0 curmax=0 current_node%visited = .true. do i=1, size(current_node%neighbors) j =&gt; current_node%neighbors(i)%dest if (j%visited) cycle temp_distance = current_node%neighbors(i)%cost + &amp; get_longest_path(j) if (temp_distance &gt; curmax) then curmax=temp_distance end if end do current_node%visited = .false. distance = curmax end function get_longest_path Also I noticed that with my gfortran (4.9) the -O2 version was significantly faster than the -O2 version. All that being said, this sort of graph based traversing is not the sort of algorithm I expect fortran to shine on (wrt to C or C++). Also, I expect that a lot can be gained, independent of the language, by clever reordering to optimize cache locality. 
I think you are right, I got this: $ g95 -v Using built-in specs. Target: Configured with: ../configure --prefix=/mingw --enable-languages=c --with-ld=/mingw/bin/ld --with-as=/mingw/bin/as --host=i386-pc-mingw32 --enable-threads --disable-nls --disable-win32-registry --enable-sjlj-exceptions --enable-libgcj --without-x Thread model: win32 gcc version 4.1.2 (g95 0.93!) Jun 16 2010 
If somebody is interested - the cheat sheet is now finished :) The guy obviously need to add some things but still this is a great source for beginners! 
Stuff that's already written in Fortran, mostly. In some industries (eg. nuclear power), that's almost everything. It still gets used a lot in engineering and physical sciences, where there's a huge amount of existing code and people who know the language. It's also a very good choice for things that require fast numerical calculations - Fortran generally makes it harder to shoot yourself in the foot than C or C++, and is as fast as it gets. Bits of Fortran can be used with other languages too where speed is needed, eg. via F2PY with Python.
Look up! Space is cool! :)
I haven't been through the whole program (and probably won't be able to), but there are problems in the knuth_shuffle subroutine. Most importantly, you don't seem to be initializing the random number system properly, so you'll get the same sequence of pseudo-random numbers every time the program runs. In most (maybe all) compilers, calling random_seed with no arguments resets the random number generator to its default seed value. If you want a different shuffle each time, you can use the system date/time to seed the PRNG. A bit of googling about random_seed will find example code for this. Line 61 is incorrect as written, as it is possible for card to have a value of 0; it should be changed to card=int(rn*lo)+1 . In addition, by multiplying the 1 by rn you biased the shuffle to favor swapping with cards earlier in the deck, slightly reducing the randomness. In addition the loop should iterate over values of lo from 52 to 2, not 52 to 1 (nothing will happen during the last pass through the loop as currently written.) Finally, you don't need the bounds checking on lines 62 and 63, and should be cautious about things like that when you're trying to do something requiring randomness as you can end up skewing the distribution of values away from what it's supposed to be. 
Ok, thank you very much!
As everybody else as said, it's used in engineering and computational science. But as you're just learning Fortran, I want to give some really important advice: *please please please* learn proper modern Fortran - that it's Fortran95, Fortran2003, Fortran2008 etc. You should be familiar with FORTRAN-77 for backwards compatibility, but when you write something yourself you should use modules and not common blocks.
Your variable names are bad. Certain characters are not allowed. You are reading and writing to the same file. You are only reading the header line. You aren't reading the variables you think you are, you're reading just the first 6 columns. Fortran isn't smart enough to recognize that the variable names match the column labels in the file. Start here: http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/fortran.html learn program structure, basic I-O and loops. It's all there. 
What's wrong with it?
Mail, thank you for the link. This is much more clear and concise than the previous guides I have found. Here are the first few lines of the file: Dist Mv CL Typ LTef logg Age Mass B-V U-B V-I V-K V mul mub Vr UU VV WW [Fe/H] l b Av Mbol 0.052 12.30 5 7.50 3.518 4.98 5 0.26 1.608 1.254 2.538 4.728 15.880 -0.264 -12.060 -36.68 -43.14 -1.17 -19.28 -0.21 0.00000 -15.00000 0.028 10.644 0.071 12.60 5 7.50 3.513 5.01 7 0.24 1.627 1.285 2.644 4.862 16.835 -0.633 0.299 -7.66 -6.71 -1.13 4.54 -0.17 0.00000 -15.00000 0.042 10.944 0.091 7.80 5 6.70 3.623 4.66 6 0.69 1.280 1.146 1.450 3.155 12.567 -9.218 -3.766 -12.98 -16.55 -40.03 -11.61 -0.28 0.00000 -15.00000 0.056 6.493 0.111 12.10 5 7.40 3.522 4.97 2 0.28 1.454 1.251 2.580 4.929 17.459 -3.223 -3.602 -48.76 -52.24 -16.88 -6.55 0.14 0.00000 -15.00000 0.070 10.475 0.111 11.70 5 7.40 3.529 4.95 4 0.32 1.442 1.207 2.465 4.739 16.964 -8.310 -5.103 -3.74 -10.87 -42.64 -26.09 0.16 0.00000 -15.00000 0.070 10.075
You're more likely to get useful help if you provide more details, like what coefficients you're using and what problem you're having. Is it not compiling, crashing at runtime, giving wrong answers? In this case, the program runs fine as far as I can tell (I used the same online compiler you did), but for certain coefficients d will be negative and sqrt(d) will be NaN (not a number). This isn't an error, it just means that there are no inflexion points for real values of x. If it makes sense in the context of this problem for x to be complex, you can use complex variables for e, f, and g, and change line 12 to e = SQRT(cmplx(d,0)) (if the argument to SQRT is complex it will handle negative numbers correctly.) Also, the user is asked to supply five coefficients, but you never use the last two.
Thank you very much :) It didn't seem to do anything when I ran the program, and I was wondering if it was a problem with the code. I tried the compiler on other computers and it worked as planned. Sorry about all of this, I am inexperienced and thought it was a problem with the code. BTW, thanks for the tip with the complex numbers ;)
What does it print after the first two values? The third through sixth values from line 96? There are three ways to get a subset of the values on a line. The first is to read all the values on the line, or at least those up to the last value you need to put in the new file. The second is to use formatted input, specifically the T (for tabbing) operator, to skip over the values you don't need. The third (since you never use the numbers as numbers) is to use formatted input to read and then write them as text. The course notes mailmanofsyrinx linked to has a good section on formatted input/output. Were you aware that you never explicitly declared one of the variables in your program? The first line after PROGRAM whatever in any Fortran program should be IMPLICIT NONE. This disables the implicit variable declaration system, a relic which once reduced the number of punch cards needed for a program while adding whole new ways to introduce bugs. Additionally the DO/CONTINUE form of DO loops is outdated. DO/END DO is the modern equivalent.
Update #2: I've gotten the code to successfully write the first line of the six variables I want directly to the terminal window. The current program is updated in the main post. The next step is to make it write to a new file that I name, with a proper header row. Not sure how to do this yet. I'm reading up on it, but if someone can share some advice, please do! I should also note that there are 28 different files I need to read in (I don't mind manually editing the open and write statements for each one) but each of them will have a different line count, and I need to know how to make it read all of the lines until the columns stop. To be specific, there are 6 lines at the end (after some 5000-11000 per file) that do not need to be read.
Not a book, but reading through [this site](http://www.fortran90.org/src/best-practices.html) on Fortran 90 best practices really improved my Fortran.
Thanks for the great starting points! Are there any Fortran for programmers books out there? I'm proficient in C and Python but I need to learn Fortran for some scientific computing at University
I'm encountering an error running pw.x about xml parsing that the documentation page says could be caused by the compiler.
error message: $ gipaw.x &lt; quartz-efg.in &gt; quartz-efg.out STOP 1 $ cat quartz-efg.out Program QE v.5.1.1 starts on 14Jan2015 at 18:36:33 This program is part of the open-source Quantum ESPRESSO suite for quantum simulation of materials; please cite "P. Giannozzi et al., J. Phys.:Condens. Matter 21 395502 (2009); URL http://www.quantum-espresso.org", ... Parallelizing q-star over 1 images Message from routine gipaw_readin: *** iverbosity is obsolete, use verbosity instead *** %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Error in routine pw_readfile (1): error opening xml data file %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% stopping ... gfortran version: $ gfortran -v Using built-in specs. COLLECT_GCC=gfortran COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapper Target: x86_64-linux-gnu Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.2-19ubuntu1' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu Thread model: posix gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) 
Can you give the input file? I suspect the problem is that your input is malformed.
That's right - if he's looking for something like skipping every line that starts with a #, then that would look different.
Do me a favor and try running this through pw.x: https://dl.dropboxusercontent.com/u/45069517/qetest.tar.gz It took me about 30 seconds on 16 processors (which is probably overkill). Paste any error messages you receive. Edit: For reference, this is my output: https://dl.dropboxusercontent.com/u/45069517/mos2_relax.log
you know what i just figured out I need some flags I guess and needs to run pw.x first... this is working pw.x -nk 1 -nd 1 -nb 1 -nt 1 &lt;file.in&gt;file.out Ill run yours when mine is done I just started a long one. 
Now that I got it working im gonna try and get it working my the cluster.
Ok Ill try this right now
Those control the parallelization from the command line. I don't know why you need to use them in order for it to run correctly.
If you got it to work I don't think it's super important you try my example. I just wanted to see a test that I know works on my system, to help narrow down the possible issues.
Your example isnt working for some reason, same old shit. majewski@hydra12:~/espresso-5.1.1/qetest$ mpirun -np 16 pw.x &lt; mos2_relax.inp &gt; mos2_relax.out -------------------------------------------------------------------------- MPI_ABORT was invoked on rank 1 in communicator MPI_COMM_WORLD with errorcode 0. NOTE: invoking MPI_ABORT causes Open MPI to kill all MPI processes. You may or may not see output from other processes, depending on exactly when Open MPI kills them. -------------------------------------------------------------------------- -------------------------------------------------------------------------- mpirun has exited due to process rank 1 with PID 7153 on node hydra12.phys.ufl.edu exiting without calling "finalize". This may have caused other processes in the application to be terminated by signals sent by mpirun (as reported here). -------------------------------------------------------------------------- majewski@hydra12:~/espresso-5.1.1/qetest$ cat CRASH mos2_relax.out %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% task # 1 from read_namelists : error # 5010 reading namelist control %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% task # 12 from read_namelists : error # 5010 reading namelist control %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Program PWSCF v.4.3.2 starts on 16Jan2015 at 21: 6:56 This program is part of the open-source Quantum ESPRESSO suite for quantum simulation of materials; please cite "P. Giannozzi et al., J. Phys.:Condens. Matter 21 395502 (2009); URL http://www.quantum-espresso.org", in publications or presentations arising from this work. More details at http://www.quantum-espresso.org/wiki/index.php/Citing_Quantum-ESPRESSO Parallel version (MPI), running on 16 processors R &amp; G space division: proc/pool = 16 Current dimensions of program PWSCF are: Max number of different atomic species (ntypx) = 10 Max number of k-points (npk) = 40000 Max angular momentum in pseudopotentials (lmaxx) = 3 Waiting for input... Reading input from stdin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% from read_namelists : error # 5010 reading namelist control %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% stopping ... 
Ah I see. good call. Theres likely more than one installed here
I don't really understand, you want to move the statistics to the front? I think there are two ways; use two output files and use the os to concatenate them in order (would be best regarding memory and overhead) or switch logic and loop twice or use an array to store results. I don't think it's possible to write to the beginning of an existing file while moving the contents otherwise. e: well it seems possible if you leave room for the statistics header to write it. This would mean adding enough space for the whole header to fit before writing the first data to the file. http://stackoverflow.com/questions/19584097/write-in-an-existing-file-without-overwriting-in-fortran it is however more trouble then worth it imho since it requires unformatted files per defenition. e2: to concatenate the files under dos/windows you can use 'copy /b header + data plotfile' i think, under *nix/apple it is 'cat header data &gt; plotfile' or you could write 'cat' in fortran also after writing both files also of course :D 
This page is more general for scientific programming, but it has some useful things for fortran. http://stellar.cleanscape.net/products/fortranlint/fortran-programming_tips.html 
Okay, first to answer your question: you might find that if you just put "#" in front of each line of the stats output, then the plotting program will just ignore those lines and run fine. That will work for gnuplot, but I don't know what you're using. But more importantly: you wrote this code? Here's an important piece of advice: you really really should not be using GOTOs and CONTINUEs at all. They can get you into trouble really quickly, and they make your code quite hard to understand. You can do everything with DO WHILE loops instead. Remember, just because it's Fortran doesn't mean you have to write like it's the 1960s. And, this is not so important, but you don't need to use .EQ. or .GT. etc. You can use == and &gt; and so on instead - I find it makes the code easier to read because I can process a symbol much faster than I can process block text, and it makes it look a lot more like how you'd actually write the mathematical formula. Fortran also has all sorts of nice array operations these days too, which can cut out some parts of your code. For instance: pmlav=0.0 ! Calculate Avg pmbav=0.0 DO i = 1,count pmlav=pmlav+pml(i) pmbav=pmbav+pmb(i) END DO pmlav=pmlav/count pmbav=pmbav/count (which should really be indented properly) can be written as just: pmlav = sum(pml(1:count))/count pmbav = sum(pmb(1:count))/count And similarly: pmlstd = sqrt(sum((pml(1:count)-pmlav)**2))/(count-1) pmbstd = sqrt(sum((pmb(1:count)-pmbav)**2))/(count-1) although that second one might actually run a bit slow, because it's storing a couple of extra temporary arrays that it didn't before. As a rule of thumb, don't learn Fortran by looking at your supervisor's code. As a fellow astronomer, I know that there are a lot of professors who write in absolutely horrible old-fashioned incomprehensible Fortran. Google around and learn about the features of Fortran90 and beyond, and take advantage of everything you can to improve the sorry state of astronomical codes :) Having said that, for something as simple as this, you might be better off using Python than Fortran, which could make the code even simpler. It's something that's probably worth learning anyway.
Generally speaking, Fortran is not all that great when it comes to using an IDE. Is this for classwork or for research? If you are beginning Fortran for research purposes, an IDE will go stale on you shockingly fast. Considering Fortran for research usually means high performance computing is involved, you will run into a ton of issues with debugging, linking, and parallelization. Regardless of those more advanced techniques, I would still recommend learning to compile your code in the terminal always. Edit it freely in whatever editor you want, but when it comes time to build, stick with terminal. Just for kicks though ill download that IDE you mentioned and give it a try myself. Ill let you know if I get it working
&gt;Is this for classwork or for research? Classwork (intro level). We never used terminal there, they've set up scite to do everything (and I can't check their properties file, disk is protected). But we also never compiled a module (just learned how to write one and what they offer), so I wasn't sure how it worked and wanted to try it home. But thanks for going out of your way and checking the IDE.
Though I'd also say that if you're building up to doing more advanced stuff in Fortran, this type of thing is a good way to learn. 
I cannot disagree with you there!
I suspect it's a matter of symbol mangling.. nm the object code that has hint0_1D and see what the symbol is called (eg, is it lower case?)
Already tried that, gfortran appends '_' to the end of Fortran functions when using it with C. I tried accessing another function from the same file and I got an undefined reference error for that function too, so I'm assuming it's a linker problem because I made sure they were both spelled right
Isn't that only in C++? I've seen examples of C++ code linked with Fortran that used 'external "C"' but I've never seen that with straight C. I'm not sure if I have to declare function prototypes or something?
Using gcc 4.8 and gfortran 4.8. How did you get it to work with GCC? 
Wow...I feel so silly. I just remembered I copied the function name from the Fortran source instead of the nm output! Thank you so much! I know about the no-underscore switch but is there one for no name modifications at all?
I don't think so. The standard requires Fortran to be case insensitive, so all functions will be converted to lower case. I think g77 had an option like that, but as far as I know gfortran does not.
The program is the answer to the fizz buzz test which is a common question asked to interview candidates. It combines the use of loops, logic and module arithmetic. 
thanks for your reply, i guess it was the MOD function that i was unsure about, as i understand the CASE functions. So for a value of 27 say, it would do (27-(INT(27/15)*15) which would = -3, I take it the MOD command returns the modulus of this value? and therefore gives 3 and returns fizz?
The `int` function works a [little different](https://software.intel.com/en-us/node/526352) than that. `int(27/15) = int(1.8) = 1`, i.e., it always rounds towards zero. Therefore `27 - int(27/15)*15 = 27 - 1*15 = 12` which would return "Fizz".
If you think back to division with remainders, then mod(27,15) = 15*1 + 12 therefore it should be 12. For you example INT(27/15) would return one as it returns the integer of 1.8 which is 1. (opposed to NINT or nearest integer which would return 2) So (27 - (INT(27/15) * 15) = 27 - 1*15 = 12
makes sense now, thanks!
Attempting to calculate the radial distribution function of a hydrogen, and store the values calculated at each 0.05 atomic units in an array. The program compiles without issue, however as the title says, I receive a segmentation fault when I attempt to perform the calculation. Any ideas what might be causing this? 
That shouldn't be the problem, I'm not a very good programmer by any means, but I think I only set it to one dimension, and I used the "allocatable" function so it would automatically keep my array at the necessary size. EDIT: I changed the allocatable function to a flat 50 values, and the program compiles without any segmentation faults, so you're evidently right. I just don't know why it doesn't work.
Yes the allocatable keyword means that you can choose the size of the array at runtime rather than at compile time. You still have to declare how big you want it somewhere.
There are a number of potential problems in this code and in the future you can use compiler options to help you detect these issues. For gfortran: -g -fbounds-check -Wall -fbacktrace For ifort: -g -traceback -check all -warn Running it with these options ifort gives you: forrtl: severe (408): fort: (8): Attempt to fetch from allocatable variable RDFA when it is not allocated And the line number the error was on, in my case when I entered '10', line 27. It also finds an error in R21. You're using z when you probably meant 'iz' in the exponent. R21= (iz/2.)**(3./2.)*(iz*r)*exp(-1*z*r/2) Which also highlights another danger: using implicit variables. If you're using an allocatable statement then that means you're using at least Fortran 90 and if you're using modern Fortran, you should not use implicit variables by putting implicit none at the top of your file and explicitly declaring all variabes. And in that case you might as well pack everything into a module to give an explicit interface. Another potential problem is your array bounds. Fortran array bounds start at 1 by default, so looping from 0 to 50 could cause some issues unless you allocate your array like so: allocate(RDFA(0:50)) Which makes 0 the starting index of the array. 
Have you tried printing your file name to make sure it's correct? From the code snippet you listed it looks like your full file name would be 'path/to/whereversegment_001test.txt' rather than 'path/to/wherever/segment_001/test.txt' Otherwise, the default directory is the current working directory from which the program was called. So if your current working directory is 'path/to/wherever', as your explanation suggests, then you should be able to set your file to filename='./'//segment//'/test.txt' The './' at the beginning may be unnecessary as well but I included it as it is more likely going to be correct.
Haha, yes, thank you. Can't believe I missed that. Thanks for helping.
The Fortran way to do this is with modules, and or polymorphic types depending on what you're trying to do.
Thanks for the pointers.
[This](http://www.mathsisfun.com/combinatorics/combinations-permutations.html) page contains all the different combination/permutation formulae repetition(yes/no) &amp; order important (yes/no) so you can omit the iteration counter if I'm understanding you correctly.
I work with some of the same type of really old, really annoying Fortran code on a regular basis. When you say that the code runs differently when you run it "separately" ... I assume that you're talking about a cleanly compiled executable using the old code, right? Have you checked that you're using the same compiler configuration and options for both versions? Sometimes these old codes assume things about the memory layout and variable sizing/initialization which may not be true after you've rolled them into your code.
I can't really debug this without dealing with the actual code, sorry. A module should not be modifying anything you don't explicitly tell it to. It's clearly not doing what you think it's doing, and the error probably isn't where you think it is. You might have some kind of flow problem.
If the old code is run from a shell script each call is a new instance of the program, with new initializations. ... So why do you have "save" statements? Even if such behavior was implied by the original code, it would never have been used and you don't need it now.
Yeah it's quite hard to just blindly try and fix something without seeing the code, but thanks for your help though. Like you say something is clearly not where I imagine which just means more print statements for me!
Something to keep in mind when you are trying to debug this sort of thing is that Fortran variables are saved between calls by default. So if you have a subroutine subroutine temp integer :: i = 0 i = i + 1 write(*,*) i end subroutine temp On the first call it will print "1" while on the second call it will print "2" because `i` is only assigned the value 0 when the program start and it's value is saved in between calls unless the subroutine is declared either `pure` or `recursive` which don't carry with them the save default. You can also control whether variables are saved by default using compiler flags. 
Does the program have to interact with the physical world, deploying a real shield, or just do the math to determine how to deploy a shield?
Awesome, thanks!
Sounds like lf95 isnt in your PATH. Try navigating in cmd to where the lf95.exe is and do: lf95 &lt;full path to the project .f90&gt; and my guess is that should work.
In the first section of code you have ! Calculating initial window functions (W_delta_ik). do k = 1, n/2 call random_number(rnd) bni(k) = kdelta(statei,k) sni(k) = bni(k) + gamma*(2.0*rnd(1)-1.0) q(k) = 2.0*pi*rnd(2) arg = gamma-abs(sni(k)-bni(k)) wi(k) = heaviside(arg)/dsn end do what is the purpose of `q(k)`? It doesn't appear to do anything. As it stands, your value for `arg` simplifies to arg = gamma - abs(sni(k) - bni(k)) = gamma - abs(bni(k) + gamma*(2.0*rnd(1)-1.0) - bni(k)) = gamma - abs(gamma*(2.0*rnd(1)-1.0)) since you are summing over random configurations this is equivalent to = gamma - rnd(1)*abs(gamma) This is problematic because if `gamma` is positive then `arg` &gt; 0 and `heavyside(arg)/dsn` &gt; 0 while if `gamma` is negative then `arg` &lt; 0 and `heavyside(arg)/dsn` == 0. 
Oh sorry `q(k)` is an action variable. It's used to calculate some other value later on (setting the initial conditions). The construct arg = gamma-abs(sni(k)-bni(k)) is left like that because it is also used in the calculation of the final window function value. Leaving it like this makes it clear that the initial and final arguments are calculated in the same manner. But the simplification doesn't work for the final value. &gt; This is problematic because if `gamma` is positive then `arg` &amp;gt; 0 and `heavyside(arg)/dsn` &amp;gt; 0 while if `gamma` is negative then `arg` &amp;lt; 0 and `heavyside(arg)/dsn` == 0. That is intended. The initial window functions will always be non-zero, the heaviside function is there to give them the desired value. Oh, i forgot. The window function can also be adjusted, in some cases it can `arg &lt; 0`, but never in this implementation.
Oh that simplification is nifty, thank you. I also talked with my adviser, and he suspects the published results might actually be wrong. It's strange, i really thoroughly tested all component parts individually. My RK4g integrator was tested with all sorts of dynamical systems problems, double pendula, projectiles with air resistance and spin. The kronecker's delta and heaviside functions are really simple, default value is 0.0 unless an if condition is met. The MC repetition routine is standard. The equations of motion i've manually and computationally derived. I've tested my potential energy surfaces (and derivatives) by printing their values with fortran and plotting them in mathematica and python alongside their mathematica and python analogues, and they're all an exact match. The only part i wasn't sure about is the one i posted. But now that two people on here haven't seen an issue, my adviser hasn't seen an issue, and i haven't seen an issue; it seems that the published work may be wrong. &gt; Also is there a reason you have your array bounds as n/2 and not just n? Yes, n/2 is the number of electronic states. But now that you mention it, i'll have to make it sqrt(n) and turn it into an integer, because n is the number of potential energy functions in an nxn matrix. Luckily i'm working with n=4 at the moment, so it doesn't matter.
For another nifty trick, if you make your `heaviside` function an elemental function, such as elemental function heavyside( x ) result( val ) real, intent(in) :: x real :: val if (x &lt;= 0) then val = 0.0 else val = 1.0 end if end function heavyside then you can replace do k = 1, n/2 bnf(k) = kdelta(statef,k) arg = gamma - abs(snf(k)-bnf(k)) wf(k) = heaviside(arg)/dsn end do with bnf(1:n/2) = kdelta(statef,1:n/2) wf(1:n/2) = heaviside(gamma - abs(sni(1:n/2) - bnf(1:n/2))/dsn assuming `kdelta` is an array and not a function 
Yeah i know what you mean on result first efficiency later, when i first started programming on python i got into a lot of trouble for not following that. This time however, I made all my little modules, tested and optimised as best i could and then put them all together. The things you've shown me will help a lot in that regard and when it comes to testing. I did run into a memory problem at one point, where the values of the initial window functions were changing during my integration routine (they didn't even figure it). I had to change the way i was doing things in order to fix the issue. Perhaps it'll be the same this time... or maybe the published results are wrong.
Since we're on the topic of debugging, what compiler are you using?
Infinite loops still happen but since pretty much all modern processors have multiple threads (if not multiple cores) it's easy enough to kill the program using whatever task managing tools are available on the system.
Whew. At least there is no walk of shame back from getting your one page. 
Are you trying to do this on Linux? Windows? Mac OS X?
Well, you're in luck. You don't have to learn Fortran (phew!). I did a little research, climbed through some ancient 90's-looking websites, and found the following: The D2 data you're looking for is in what's called an HDF format. Now, if you try to search for that, you'll find a lot of newer versions of HDF that aren't compatible. So those avenues may not work. But, there are two paths that may decode your data without you having to wade through 70's Fortran code. 1) There is a C version of the reader program located here: https://badc.nerc.ac.uk/browse/badc/isccp_d2/software/ The isccp_d2_read.c file should do the trick (if you know C or want to learn C) 2) This site seems to have a lot of information on the D2 files: http://webapp1.dlib.indiana.edu/virtual_disk_library/index.cgi/4296021/FID1024/www/isccp_d2.html If you scroll all the way through it, you'll find a link to this software directory that has a bunch of programs that might do all the work for you (even though it says CIDC, its for ISCCP D2 stuff, I think): http://webapp1.dlib.indiana.edu/virtual_disk_library/index.cgi/4296021/FID1024/software/read_cidc_sftwr Of course, none of it may work. And if that's the case, I did see rumblings that a software package called [netCDF](http://www.unidata.ucar.edu/software/netcdf/) can decode HDF D2 files. But I couldn't find much on that. Good luck!
Windows 7 :)
Thank you so much for your help! Unbelievable. Do you mind if I ask for help later? I just want to check out the resources you've given me first. 
I don't mind at all. I'm glad to be of assistance.
Have you tried looking through the demos [here](http://gnuplot.sourceforge.net/demo/index.html)?
He died March 17, 2007. This was posted March 7, 2015. The timing seems a bit odd, but I suppose it is good to remember the guy.
Thanks for the response. I stumbled upon this QR algorithm last night after a bit more research, it certainly does seem to be the only option. Although, my matrix is in a slightly nicer form than completely general in that a general tridiagonal is already an upper Hessenberg. 
Right. The first thing geev will do is reduce a matrix to Hessenberg form before applying the QR algorithm. For your matrix the initial Hessenberg reduction is not needed. You could skip that step by combining the computational routines hseqr and trevc. But the Hessenberg reduction is less computation than the QR iteration, so you wouldn't reduce your run time by all that much. If the matrix is really so large that geev is not feasible and you can live with a relatively small number of eigenvalues and eigenvectors that are of particular interest, you might want to look at ARPACK. But if it's at all possible to use geev, that will be by far the easiest option.
I would seriously appreciate it atmmachinewut! Thank you!
I'm taking a few programming courses and I know that Fortran will be particularly used in many software in my field (nuclear). Any resources to learn would be greatly helpful :D 
Sent you the same links. It's mostly basic syntax stuff for 95 as an intro to the language, not programming itself. I started with Java as a teenager; I taught myself Fortran for university research and graduate work. My particular field was nuclear as well :) 
Would you mind posting the links atmmachinewut sent you? It would be great if we could all learn from them. Also, I've found the following link to be quite helpful: [http://www.fortran90.org/src/best-practices.html](http://www.fortran90.org/src/best-practices.html)
http://www.mrao.cam.ac.uk/~rachael/compphys/SelfStudyF95.pdf http://www-eio.upc.edu/lceio/manuals/Fortran95-manual.pdf Those are two guides I went to a lot for syntax basics. These class notes http://www-eio.upc.edu/lceio/manuals/Fortran95-manual.pdf had examples that were helpful as well. As /u/tomedunn said, the language standards are backwards compatible. Think of it as updates to the language. What matters is that you are consistent with the compiler you are using. I mainly use the GNU Fortran compiler; it works well for 95, 2003, and 2008. I also used SimplyFortran on my Windows computer. It's quite nice from the trial but costs money so wasn't an option on my college student budget. 
A good book is Chapman's Fortran 95/2003 for Scientists &amp; Engineers. You can buy it on Amazon though it's... eh... available in *other* sources.
And yet they still use goto?
It would seem so. Although most of their uses of `goto` in their `f90` code seem pretty harmless. 
Do you have a sample of the code you can post? 
We need to see a copy of the code, unless this is the same poster from before :-)
I could post the code I have so far I guess
Can you post here: http://pastebin.com/ and respond with the link? The formatting is a little wonky is all.
Also check these out for formulations to find pi: http://mathworld.wolfram.com/PiFormulas.html
Seeding the random number is a separate matter, but this is the idea behind the calculation: program findpi implicit none integer i,n real x,y n=0 do i = 1,1000 call random_number(x) ! x in range [0,1) call random_number(y) if(hypot(x,y) &lt; 1.0) n=n+1 ! intrinsic function for sqrt(x**2 + y**2) enddo write(6,*) 'pi is approximately', 4*real(n)/1000 end This plots 1000 points with x and y between 0 and 1, counting only the ones within 1 unit of the origin. The expected proportion of points thus counted is pi/4. Draw it.
Ahhh I see, on my script I have certain steps to follow but I'm stuck and I don't know what or how to do, what I need to do, therefore I couldn't answer your queries, but I'm sure you would if you saw the script. I have it downloaded as a PDF, is there any way I could send it to you? (btw, thanks again, I feel privileged to be helped by someone who seems to know what they're doing) 
Yes you can send it to me, I'll PM my e-mail address.
reference sheet http://imgur.com/9ys35dQ,y2np0Oi http://imgur.com/9ys35dQ,y2np0Oi#1
When you get to w=(p-y)*x, in the first loop y is yet to be defined. From that point forward your numbers would be off. You might need to rethink how you update your balance to get the loop to progress through time subtracting off the payments made and updating the interest payment.
I agree. Y is not defined or initialized at that point.
I am a little lost, it seems that within the defined functions W, y, and z each one is being referred back to within one of them. I think I might need another do statement for W, but I don't know how to set that up.
Could you provide a bit more information? Are you talking about the subroutine DSYGV in [LAPACK](http://www.netlib.org/lapack/explore-html/d5/d2e/dsygv_8f.html)? And what do you mean by print? Are you expecting DWYGV to do the printing for you or are you asking which of DSYGV's dummy variables correspond to variable `c` as you've written it so that you can print that variable using standard output methods in Fortran?
OK thanks for the tips, I'll try working on it tomorrow and let you know how it goes.
Thank you so much, it worked! If you want i can share the final code if you are interested.
I'm writing in f08 and i had to use a go to statement... couldn't solve the problem any other way.
Glad it worked for you. No need for the code for me.
I will, i'll modify my code once i get the hang of that.
Seems like an odd choice of language for this? I agree that it's a good idea to use a higher-level language for the less intensive calculations, but something like Python (with numpy) or R or matlab are much better choices than JavaScript.
Hey, you should really learn about "modern" Fortran. You are using some techniques that went obsolete around the time the Soviet Union collapsed. Firstly: indent your text! There's no length limit to lines, so there's no downside, and it makes things *much* easier to read. Secondly: avoid line-numbers if possible! These are essentially "goto"s, and can very quickly develop into something very hard to follow. Using line-numbers for format statements that immediately follow the print/read/write statement is fine, but Thirdly: there are plenty of beautiful array functions that will do what you want to do in a single line. Plus you've made some mistakes - I'm not sure what the purpose of *w* is, or why you print out data that's &gt;0 while taking the average of *all* data. Here is my version. It's not perfect, but it's an improvement: program P4 implicit none real, dimension(100) :: data integer::i,l,n,ierr real :: average, sdev print '(60("-"))' open(unit=100,file="p4data.dat",status="old") do i=1,100 read(100,*,iostat=ierr) data(i) if ( ierr==0 ) then n=n+1 else exit endif end do close(100) print *,"All original data",data(1:n) print *,"Original data (where data&gt;0)",pack(data(1:n),data(1:n)&gt;0) average = sum(data(1:n))/n print *,"Average:",average average = sum(data(1:n),data(1:n)&gt;0)/count(data(1:n)&gt;0) print *,"Average of data&gt;0:",average end program But really, this is not the kind of thing that Fortran is for. It's good to do this kind of stuff just to learn Fortran, but if all you want is to do some basic statistical analysis on data, you will have a much easier time using Python (with the Numpy libraries), R, or Matlab. 
You're right. My bad. Funny what intrinsics do exist, though.
OK thanks that helped a lot. Lets say I have a trailer number in my data file for example a negative number specifically -1, how would I exclude that number from my data calculations. Like make it completely disappear from the array or make the read statement stop reading right before the -1.
Last question why doesn't this subroutine find the median. Instead of giving me a random value it just shuts down the whole executable file. subroutine med (data,n) implicit none real::median,data integer::z,n z=mod(n,2) if (z.eq.0) then n=n/2 median=( data(n) + data(n+1) )/2.0 else n=n/2+1 median=data(n) end if print 4,median 4 format ("Median =",f11.2,/) end subroutine
You can do an internal write to a string instead of to a file: subroutine print_digit() integer int character(len=30) :: char int = 6842 write(char,"(i0)") int !Write the value of int to the string print *, trim(char) !prints 6842 print *, char(2:2) !prints '8' print *, char(3:3) !prints '4' print *, char(1:2) !prints '68' end subroutine print_digit And to convert back you could just do a read from the substring and store it in an int 
You could also use the [modulus function](https://software.intel.com/en-us/node/526462) `mod()` along with the [floor function](https://software.intel.com/en-us/node/526179) `floor()` to pull out each digit. But writing the number to a string and then parsing the string one character at a time is conceptually much simpler. And as for speed, as a general point, don't worry about speed until speed is a problem.
Thank you, too. I will look at the modulus and floor functions, since I am not familiar with them. It is better if I know several different ways of doing the same thing. It may prove useful at some point... 
I think you're missing a right parenthesis in that line.
Thankyou so much!!! Finally it compiled
A minimal example is a good idea, it should just be a working one (except for the actual issue that is causing trouble). That way, anyone can try compiling and running it, and find the solution more easily. The only problem with your example was that it had other issues than the one you were asking about, making it harder to help. 
Can you explain the "parameter" keyword please. I learned f77 in a rudimentary course and am coming back to fortran from C/C++ and python.
Ah.. thats simple enough. Thank you
Non-mobile: http://en.wikipedia.org/wiki/BMDP ^That's ^why ^I'm ^here, ^I ^don't ^judge ^you. ^PM ^/u/xl0 ^if ^I'm ^causing ^any ^trouble. [^WUT?](https://github.com/xl0/LittleHelperRobot/wiki/What's-this-all-about%3F)
Why would you open and close the file twice? Can't get my head around the fact that you can just check each line for your codewords and then read it's value and stop if you get to the end of the file or all codewords are read. Why should this approach not be working?
Can you change the format of the input file ? If so, why not use a namelist ? 
The first loop is to find the location of the word. Once I have the location I read every line into a variable and once I get to the correct line I stop and keep that variable. The reason for opening it twice is because once I find the correct word I don't know how to then stop at that line and read the variable. The code just continues to the next line. Is there a way to check if I'm on the correct line and then stay on that line to read the value? Also, the input file is huge and I only need certain value from it. 
Can you... 1. Create array of variable names 2. Create array of variable values 3. Open file 4. Read variable name, variable value 5. Find index of variable name (var_idx) 6. Set variable value array at var_idx to variable value ? (in addition you can not just create array of values but array of pointers to variables) Here is an example: program read_file implicit none type real_ptr real, pointer :: tgt end type integer, parameter :: file_unit = 10 integer :: stat, i real, target :: var1, var2, var3 character(len=50), dimension(3) :: names = (/ 'var1', 'var2', 'var3' /) type(real_ptr), dimension(3) :: vars character(len=50) :: var_name real :: var_value vars(1)%tgt =&gt; var1 vars(2)%tgt =&gt; var2 vars(3)%tgt =&gt; var3 open(unit=file_unit, file='config.in') do read(file_unit, fmt=*, iostat=stat) var_name, var_value if (stat /= 0) &amp; exit do i = 1, 3 if (names(i) .eq. var_name) &amp; vars(i)%tgt = var_value end do end do close(file_unit) print *, var1 print *, var2 print *, var3 end program
Thanks for the help, I'll try this approach out. 
Is there a way I could determine the number of characters in a variable name without having to count them? For example, if I had a variable: integer :: rotors rotors = 2 The amount of characters in the variable rotors is 6. Is there a way I could do something like len(rotors) and then have that return 6?
Keywords as "select type". https://duckduckgo.com/?q=fortran+select+type Google results are also relevant.
I am not quite sure you are addressing the question at the right place, this is a more general algorithmic question, not necessarily Fortran related. I am quite sure a bunch of us will be happy to help in any case, but there are many people who don't know Fortran who can help. In any case, could you explain your problem in more detail? Please put it in mathematical terms, and forget about the programming for the moment.
This is why it's a good idea to break these types of calculations up into multiple lines. It'll optimize to the same thing in the end, but it'll be much easier to read. Plus it's good to use a text editor that'll warn you if you've got the parentheses wrong.
Aha, a fellow astronomer! What luck! Thanks for this, I'm going to try it all right now. I already have the l/b coordinates though, so there's no conversion necessary, and I need the sky samples to be in l,b. I'll let you know if I have any more questions.
Ok, so question: In your third section of code you define ibin and jbin, but they're not declared anywhere. I'm kinda lost as to what these two parameters are. I've never really worked with 2D arrays in Fortran. Thanks again.
I've actually got the galactic coordinates already, that cos function in there was a legacy thing from a copied over code and wasn't necessary at all. I'm trying to figure out where this stuff would go in my code: Then for each point of data you can do: ibin = (ra-ra0)/ra_step jbin = (dec-dec0)/dec_step nbin(ibin,jbin)=nbin(ibin,jbin)+1 FeH(ibin,jbin)=FeH(ibin,jbin)+FeH ! etc Then at the end you can just do: FeH = FeH/nbin ! etc
Great, you've been a tremendous help. One more question---how do I write these arrays efficiently? I've literally never had to write an array before, heh... like I said, kinda a Fortran novice.
Oh wait, one more thing---in my original code, with these modifications, will I even need the first "do loop" (ie, the one that says j = 1, db)
Great. Is there a decent way to also include the l,b coordinates of each bin in the file? Edit: Also, compiling I'm getting this: FeH(lbin,bbin) = FeH(lbin,bbin) + FeH 1 Error: Incompatible ranks 0 and 2 in assignment at (1) EBV(lbin,bbin) = EBV(lbin,bbin) + EBV 1 Error: Incompatible ranks 0 and 2 in assignment at (1) 
&gt;Great. Is there a decent way to also include the l,b coordinates of each bin in the file? You can do something like: open(unit=12,file="feh_avgs.dat") do ibin=1,n do jbin=1,m l = l0+l_step*ibin b = b0+b_step*jbin write(12,*) l,b,FeH(ibin,jbin) end do end do close(12) &gt; FeH(lbin,bbin) = FeH(lbin,bbin) + FeH &gt; 1 &gt; Error: Incompatible ranks 0 and 2 in assignment at (1) Yeah, this was my mistake from earlier. FeH(lbin,bbin) means entry lbin,bbin of the array FeH. But "FeH" by itself means the entire array. So this is saying you should take the entire array, and then add it to one entry within the array. And it's saying it doesn't fit, which is correct. When you read in the data, you don't read in the whole FeH array for each line. You read in just one FeH value, say myFeH or something. SO it's like read(1,*) ncrt, ra, dec, l, b,&amp; V, dsun, myFeH, myEBV then FeH(lbin,bbin) = FeH(lbin,bbin) + myFeH
What does your code look like right now? My understanding is that if you're trying to read 8 values from a line that only has 4 values, Fortran won't just jump to the next line and continue reading - instead it'll just die and give you an error message. So I'm not sure how you are getting into this situation. Is this using namelists or something?
I'll ask again - you're talking about doing I/O with namelists, right? Could you post the I/O section of your code so I can see specifically what you're trying to do right now?
I'll write my code below and I'll define some of the variables. If anything doesn't make sense I'll try to clear things up. I'm not using namelists to read the file, but if there is a better method then I'm open to suggestions. Here's my code for reading the file: ! Determine line numbers for where the variables are located open(unit=1,file=inputFile) i = 0 n = 1 ! Read the file ! If variable name being read matches the variable name in the names array then record line # ! Save line # in line array do while (n .ne. dim+1) i = i + 1 read(1, fmt=fmt(n)) var_name if (names(n) .eq. var_name) then line(n) = i n = n + 1 endif enddo close(1) ! Write values into variables open(unit=1,file=inputFile) loc = 0 h = 1 i = 1 j = 1 k = 1 l = 1 m = 1 ! Repeat loop until i equals number of variables do while (i .le. dim) loc = loc + 1 if (loc .eq. line(i)) then h = h + 1 if (dataType(i) .eq. 1) then read(1,*) var_name,equal,a%ints(j) j = j + 1 elseif (dataType(i) .eq. 2) then read(1,*) var_name,equal,a%reals(k) k = k + 1 elseif (dataType(i) .eq. 3) then read(1,*) var_name,equal,a%intArray1D(l,1:dataLength(i)) l = l + 1 elseif (dataType(i) .eq. 4) then read(1,*) var_name,equal,a%realArray1D(m,1:dataLength(i)) m = m + 1 else read(1,*) endif i = h enddo close(1) dataLength: provides how many elements are in the array dataType: Array that tells which data type each variable being read is dim: number of variables to be read from input file names: array which holds all the variable names loc: Placeholder for the line #
I'm having trouble comprehending the code. How does it know if it needs to have the next line attached to it?
That function doesn't. It just reads the entire line. You'll have to come up with something that does the rest.
See the Suggested Links on the right side. For a book have a look at Metcalf, Cohen, Reid: Modern Fortran explained. It can serve as a reference but also has examples and tasks. Maybe this Linklist is also helpful: http://www.dmoz.org/Computers/Programming/Languages/Fortran/FAQs%2C_Help%2C_and_Tutorials/Fortran_90_and_95/
Meh. Just dig in. The best advice I can give is: do not forget to use 'implicit none' else every variable starting with i, j, k, l, m, n will be an integer!
I don't quite understand what your question is, but I suspect the answer is related to the fact that Fortran 77 (standard) has a 72-character maximum length for lines (even if compilers might not enforce it). Your editor (vim?) seems to be highlighting the parts that go over that, to warn you that it may cause trouble. 
Always use "implicit none," always... When we learned Fortran 90 in school we automatically failed an assignment if it wasn't included regardless of whether the program worked or not. I've spent hours hunting bugs back in the day in legacy code that were caused by a typo and missing "implicit none" combination.
This is how you do it in Fortran 90. In Fortran 77 you should put it in the fifth column of the next line. 
We use ifort as I understand that's 95, 2003 &amp; 2008? Other codes, the file type is .F.
Most compilers are backwards compatible with 77 code. Regardless, you're writing in f77 style, with &gt;6 column tabs and "c" for comments. It makes sense that your compiler would stop you from exceeding 72 characters, if only because it's recognized you're coding in f77.
Others have shown that these are implied loops, which is fine if all you want to do is understand this code, but I don't feel this is how you should write it if you ever want to write modern Fortran. I would use array slices instead, like this: DO h = 1,n_con READ(301,*) theta(h,1:k,1:n_res) END DO instead.
Oh okay. :D
FORTRAN77 is a subset of Fortran90 and above and current compilers should be able to compile Fortran77 (though you may have to deal with fixed formatting and unique compiler features). Any new code that you write should be written in Fortran90 and above. Write it for clarity and usability first rather than speed. In regards to compilers, ifort is generally the fastest and has more 2003+2008 features than some other compilers, though ymmv and it is a commercial product so you have to pay for it. Some compilers to choose from are: PGFortran ( has CUDA bindings) Ifort (all of F03 implemented and a lot of 08) Gfortran (free) There was a good benchmark comparing different compilers on the Polyhedron software website but it seems the page is broken. [Found it](http://imgur.com/7JKPihM) That's execution time in seconds with various compiler options enabled. 
Thanks. This was exactly what I needed to know, and the code has been successfully converted.
The FORTRAN code was actually written by someone else, and is now being rewritten in Java.
Pointers in Fortran point to variables, pointers in C++ point to the locations of variables. That's the simplest way I can think to differentiate them (although it has been some time since I last did any serious work in C++). Also a couple clarifying points: * As of the Fortran 2003 standard [procedure pointers](https://software.intel.com/en-us/node/525574) do exist. * As of the Fortran 2003 standard [unlimited polymorphic pointers](https://software.intel.com/en-us/node/526024) may be associated with any intrinsic type or derived type.
I honestly don't remember - I'd have to test it to check. But you can even just write write(301,*) theta to write out the entire array in ASCII. As long as you keep things consistent, you could read it back in with read(301,*) theta
I don't entirely follow this sentence "One thing you didn't mention that fortran pointers also store stride information, which allows for arbitrary slicing of arrays, so you can do x =&gt; M(1,:,3)" Can you elaborate? 
Do you know what compiler was originally used? Try with a newer version of that...
Yeah, I was trying to avoid that, if possible.
I think that it was compiled around 2000, so no idea.
Unless the code has a bunch of vendor-specific necessities from the old days, a modern compiler will be 99.9999% backwards compatible with F77 standard code. There's not really such a thing as a "fortran 77" compiler anymore. ~~Get a working compiler.~~ What are the syntax errors like from gfortran? It's possible some compiler flags will get things right.
Most likely not 16 bit then.
Try this before compiling again. - use the unix/cygwin "file" utility on the .exe file. What does it say? - run the exe, post the error message - 32 bit executables run on 64 bit windows, normally. E.g visual studio is 32 bit. Try to determine exactly what your problem really is - it must be something else. - check whether the symbols in the exe match those of your code. - use dependency walker to find which dlls it needs. This might also lead to determining which compiler was used or other useful info. Compiling: - digital visual fortran was big 10+ years ago. Intel fortran is the successor. Try it, they have a free 30 day trial, and it's anyway a great compiler - post your compiler errors. They are often a sign of vendor extensions to the language and could hint of which compiler was used before. - if the code is easy to rewrite, do it. Old fortran code is a lot of work to maintain. - if the code is big enough to be valuable, it has a build script, visual studio project file, or something. Track it down and start digging. Post on comp.lang.fortran if you sre still stuck. Include as much (relevant!) information as possible. People there are more active and knowledgeable, and some old fortran hands might instantly recognize your problems. 
Use libraries for matrix multiplication and other common operations. Theymll be faster than the code that you'll write yourself - unless you are extremely good. If you're that good, Intel will probably hire you to work on their libs :)
Yeah, I'll post the errors when I'm back at work tomorrow. This is quite a lot of code, written in the 80's, but I think I'll maybe just redo it. Thanks for the reply. 
Lots of stuff is, however it would probably be difficult to find a 16 bit compiler 15 years ago. 32 bit, however, that stuff is still alive, and generally still well supported wrt. libs etc. , at least on Linux. Have you tried ifort, or whatever used to be known as the Compaq compiler? 
hard to say, it could be ms, watcom, lahey or others.... I would probably look at watcom f77. Its free and supports 16 and 32bit. In my experience try working with as much "like" stuff as you can before ypu go changing stuff, or youll go crazy wondering if it infact ever worked. Try it on dosbox, or cpc, qemu etc. It may be tied to 32bit ms-dos, so you may be lucky. It could be that crazy ms powerstation 1.0 fortran that produced code that wont run on nt.
What is msdev95? Never heard of it. Are you referring to visual studio somehowv PAUSE is deprecated, by the way. 
This is a snapshot I found for this software: http://www.tuat.ac.jp/~kamelab/MSFP/02.gif I can still use the PAUSE command, however I was interested on having the breakpoints, step into, over, and watch features in different parts of the program. The way I've been debugging it is by using: print*, variable PAUSE. However I was told that the other way around, using the actual debugger tool within the program is more efficient. But I can't make it work... I really don't know how to set it up. Not even reading the help section which is not much help at all. Thanks!
Holy crap. I have no idea how to use THAT. It must be ancient! Intel Fortran is the successor to that compiler. Can't you use it instead? It uses components of visual studio for debugging on windows. It's quite simple to debug with. It should be the easiest migration path to a modern compiler, given its shared codebase, historically. 
Nah, just google "intel fortran". It's free for students, too. There's a 30 day trial for anyone interested. If you want a free alternative, try gfortran (it's in cygwin on windows). gdb is the corresponding debugger. 
Gfortran is, I believe, the most popular fortran compiler on Linux. I'm pretty sure your Ubuntu system should have this already, otherwise you'll have to install it with apt-get. As for IDE, I've never come across anything that worked better for me than emacs. It can do syntax highlighting, indentation etc etc. 
You essentially need 2 things, a compiler and a text editor. As others have said it is likely you already have gfortran installed, this is a free compiler by the gnu guys. To check if you do type "gfortran" in terminal and see if you get an error of "no input files". If you instead get a program not found error then run "sudo apt-get install gfortran" and follow any prompts. Once gfortran is installed you need to write a program. For this you can use any text editor. If you want to you can use a very basic text editor like gedit or emacs ("gedit" in terminal to open gedit). I personally prefer a more feature heavy text editor like "kate" you can "sudo apt-get install kate" if you do not have it already. Once you have written a program (hello world or whatever) then save it as myprogram.f if you wrote it in f77 and myprogram.f95 if you used f95. (this is a rough rule that isn't always necessary but can confuse the compiler if you use the wrong filetypes, it is to do with the difference between fixed form and free-form) To compile your program navigate in your terminal to the directory where you saved your file and run "gfortran myprogram.f95 -o myprogram.out" The first option there is the source code file and the -o is just me naming the executable. Now to run your program, again in the same directory type "./myprogram.out". Hopefully this gets you started.
Actually it's .f90 for free format; this is at least the suffix recognized by most compilers. gfortran will happily build .f95 afaik, but not many other compilers will. 
&gt;When I call this on a system of about three hundred equations or so the program runs in about half an hour That is awful and something is very, very wrong. 300 unknowns should be solved in a blink of an eye for even very stiff non-linear systems. Even the first comment of the routine you linked says not to use it! FWIW, you're probably better off using a more modern set of tools than DDASSL. PETSc will take a little more time in initial setup, but the payoff is trivially changing what time integration and linear and non-linear solvers you use, and easy parallelization. You almost certainly are using an inappropriate algorithm for solution. What kind of equations are we talking about here? Is the system dense or sparse? Also, check your tolerance inputs (atol and rtol). If those are too tight, the adaptive timestepping in the variable order BDFs will drop too much and you do a ton of unnecessary work. &gt;I started a seven hundred equation code running on Wednesday and t_current has just ticked over to 1e-9 (every five hundred steps the solver takes it throws a warning containing the time and stepsize). That's bad. If the timestep is so low you can actually bump up into machine accuracy, for double precision around 1e-16. If your timestep is getting close to that small, any update is completely unreliable and it'll never work. Don't worry about MPI or parallelism right now. Your choice of algorithms is almost definitely wrong -- get that right, and see your 300 equation system solved in a fraction of a second, then worry about larger systems.
&gt;Thanks for your reply. I know that dassl says not to use it any more, but the updated version it recommends (daspk) seems use essentially the same algorithm but has a lot of extra features bolted on top that I don't need. DDASSL uses direct dense and banded solvers for the linear systems. If your system isn't dense or banded (e.g. is a general sparse matrix) these are going to be much, much slower than a corresponding iterative sparse method. DASPK uses krylov methods which are likely to be much faster. &gt; From what you've said I suspect the time issue comes not from the solver itself, rather from the program that calls it. My intuition is that the problem lies in the equations I need solving involve evaluating roughly 3000*N (where N is the number of equations) high order polynomials at each step. Don't use intuition; profile it. gprof or kcachegrind are common tools for this - figure out where the program is spending most of its time. But note that doesn't tell you everything, even if 99% of the work is done in your residual evaluation; if you're using an inappropriate solver algorithm (and I'm pretty sure you are) the end result will be calling the residual evaluation many more times than are actually necessary. And definitely try increasing the error tolerances and running again. 300 equations really is nothing. A smartphone should be solving this in a second. The biggest red flag is that getting to t=1e-9 took days. Assuming that was thousands of time steps, this tells me the error tolerances are way too small, and you're getting numerical issues with tiny timesteps. The adaptive BDFs should be very stable and allow much much larger timesteps. &gt;PETSc does look kind of promising, although their list of nonlinear solvers doesn't mention anything about differential algebraic equations, which my system is (although only just). Do you happen to know if any of the solvers listed are appropriate for DAEs? Nonlinear DAEs are solved in three parts: the time integration algorithm (e.g. backward differentiation formulas are used in DDASSL), the non-linear system solving algorithm (Newton steps are used in DDASSL), and the linear system solver (some kind of direct/banded solver in DDASSL). In PETSC, the time-stepping algorithm is in the section TS, nonlinear solvers are in SNES, and linear solvers are in KSP. For a DAE you're selecting one from all three of those. A starting point for your problem would be to use backward euler for time stepping, newton-line search for non-linear, and a krylov method (gmres) for linear. It is a bigger undertaking to interface to petsc, but worth it. For now though you should be able to get DDASSL working properly with the right settings.
Annoyingly, my system is almost banded. Unfortunately it also requires nonzero entries in the first column of the Jacobian, otherwise I would have simply utilized the banded option and it certainly would be quicker. Will Krylov methods still be useful in this case? I will have another look at DASPK either way. (Edit - just as I click 'post' I realize that this is exactly what sparse means. I certainly will try the Krylov stuff in this case). My tolerances are pretty reasonable I think - 10^-5. I will try less stringent ones but I need a good degree of precision for my simulations to be useful. I've explored PETSc some more and it certainly looks like a hell of a tool. Thanks again for putting me onto it and your other help. 
Getting access to your university's cluster should be easy. Most have nodes available for students without purchasing a specific allocation. A cluster account will run your code much faster than your laptop, AND it'll let you queue things up to run for days or weeks. Some of my simulations have taken over 500 hours. Set it and forget it. As "low priority" as you think your job is, there are resources available for it. Cluster accounts also usually come with some small bit of technical support to debug problems with your code. Look into it. Writing parallel code can be very easy, or very difficult, depending on your problem. For a couple hundred ODEs you should be able to get results pretty quickly with DVODE or DLSODPK or another solver. Something seems wrong with your code. Are you compiling with optimizations on? Or with debug flags? Parallelization might provide a huge benefit, but it might not. The bits of my code that were easy to do gave us nearly linear scaling. How many independent tasks does your code do? If you can break the problem up into chunks and throw an integrator at each chunk you'll never need to touch the guts of the solver. Fortran 90 vs Fortran 77 shouldn't really make any difference. The compilers are smart enough to deal with it. Really need more info on what you're trying to do and what your code looks like. (Source?) Edit: Another thought ... are you doing any "sorts" of large arrays? I've seen some god-awful insertion sort routines that PhD students have written that were 3 orders of magnitude slower than a library quicksort.
&gt; My intuition is that the problem lies in the equations I need solving involve evaluating roughly 3000*N (where N is the number of equations) high order polynomials at each step. There isn't really a way around this, unfortunately. If this is the problem then parallelization could be a big help to me, no? /u/Overunderrated is right, you should profile your code and see where you're spending time. Even something as simple as dropping MPI timing routines in and printing the elapsed time between operations is a start. My experience with repeated polynomial evaluations is that they *can* take longer than you might think. One of my codes evaluates a 5-6 term polynomial in temperature, with T^4 and 1/T, etc. Each of those terms multiplied by a coefficient, then the same process repeated for every species in every cell of the mesh and summed. Pre-calculating all of the temperature powers saved a pretty noticeable amount of time. If the polynomials are all independent of each other, then that's a perfect place to add parallelism. Most cluster machines with dual/quad 4-6-8 core CPU's will now show up like a shared memory machine, so OpenMP might be a really quick and easy way to parallelize the loops where you evaluate those polynomials. MPI requires a good bit more work on your end.
I'd be more concerned about the order-of-magnitude problems here. OP mentioned that even for a tiny 700 unknown system it took 5 days to go to t=1e-9, so he's basically looking at years of CPU time, which is ridiculous. That's an algorithmic problem parallelism can't fix. Strange things are afoot at the circle K.
Oh yea. There's something else strange going on here to cause the major slowdown. But I think those polynomials are going to be promising for some speedup after that other issue is fixed. This almost looks like an array order transposition problem, where OP's reading data from virtual memory every loop iteration and it's taking 1000 times longer than it should to grab the data. I've never had anything go as slow as OP, but I have had code get at least a factor of 10 slower and start thrashing the hard drive when I tried to run it on my under-powered laptop.
Depends on if it's doing something stupid with the Fortran 77 memory allocation though. The code I use has a lot of statically allocated arrays defined at compile time, that we then only use a slice out of (hooray legacy!). So even when the number of unknowns is small, the rest of the empty array tags along, which in many cases was sized significantly larger than we needed. It should be obvious from the profiler if that's happening. I've had colleagues that increased array sizes for bigger meshes or chemistry and killed their code performance because they over did it and just tacked on a zero (or two) to each dimension instead of thinking first. Although, our systems are mostly chemical kinetics problems, and they're not that crazy stiff in most situations.
You'd think it would be easy, but the one guy with permission the grant people in the maths department access has gone on sabbatical and no one else I've spoken to seems to know a way around it. The last person I spoke to suggested that maybe Steve could help, before vanishing into the night. I don't know who Steve is. I'm not doing sorts or anything like that (i have been guilty of writing my own cretinous sorting algorithms before though - good to know i am not alone) and am compiling with the O3 optimization setting. I don't think it would be possible to break the residual down into separate chunks to feed the solver because of the way the system is coupled, although I could be wrong. As I mentioned, though, the code is required to evaluate a huge number of polynomials per step, which does seem to be where parallelization could help. If none of the (excellent and helpful) advice I've received so far gets me anywhere then I will post the code, but I don't expect anyone to sit down and try and make sense of it in their spare time. 
How do you know the efficiency of my code? We'd purchased an allocation for that work, those were *our* nodes we were using for those simulations. We were (are) stuck with a serial solution due to legacy concerns, and we needed to run several consecutive cycles of an engine CFD code as validation cases for a series of improvements we were working on. We don't know what OP's endgame problem size is going to be, or what his expected run-time for that problem will be. It could very easily be 24+ hours on a regular basis. That's a perfect application for a cluster. Almost regardless of what his final walltime requirement ends up being, he'll likely be better off running there rather than on a laptop. The 500 hours is an outlier to help make the case that he should utilize the resources available at his university.
Well that sucks hard. I'd try to get my hands on a reasonably fast desktop to let attack these runs so I wasn't tying up my laptop. Can try O2. Sometimes O3 does funny things. I'd double check through all of the compiler options too. I think some will let you give a debug flag that negates the optimization. Toggling a few of those on and off is a really fast way to check and see if something is fucked on that end of it. It may try to auto-parallelize loops or initialize arrays. &gt;I don't think it would be possible to break the residual down into separate chunks to feed the solver because of the way the system is coupled From what I've seen that's pretty common. Have you checked though all the flags and settings for the solver? The ones I've used had different flags for how often to re-compute jacobians or which algorithm to use internally. That can impact performance pretty greatly. It really depends on how big your code is, how well commented it is, and if there are any glaring problems. Some problems are obvious if you've seen them before. Like memory allocations inside of several levels of large nested loops.
&gt; How do you know the efficiency of my code? Point taken, I misread that. I've just been frustrated in the past by massive allocations for horribly inefficient codes. &gt;We don't know what OP's endgame problem size is going to be, or what his expected run-time for that problem will be. It could very easily be 24+ hours on a regular basis. Sure, I'm running 24+ hours on hundreds of cores, but that's with billions of unknowns. But since OP is taking 30 minutes for 300 unknowns, and days/weeks for 700, there is a huge problem here and offloading it to university cluster bruteforcing is a bad waste of resources.
fix the syntax errors
I accidentally said "mobile device" and I meant laptop not phone. Sorry if that tripped you. What you say isn't so crazy (about there being a good chance it improves runtime) that I don't believe it. I just doubt you will see any real change without exploiting the parallel nature of clusters. That is what they are made for after all. You are totally right about being able to use the laptop while it is running being a huge deal though.
It would help if you told us what the four error messages were.
To expand on /u/pablogrb's response, the second line in any Fortran program, immediately after 'PROGRAM whatever', should be '[IMPLICIT NONE](http://www.personal.psu.edu/jhm/f90/statements/implicit.html)'. This disables implicit variable typing. Implicit typing once reduced the number of punch cards needed for a program, but you're probably not using punch cards today. Are you using punch cards? That would be super-FORTRAN-hipster-cool of you. But you're probably not using punch cards, so disable implicit typing; doing so makes a lot of errors like the ones you're seeing easier to identify and fix.
Does something like this make any sense to get the Matlab behaviour? (not sure if the Fortran OOP is correct, or if the pointers will behave like I expect) https://gist.github.com/robince/56a5b25f75953b81f24d
i think a hash table is better then an array, there's an example implementation on the wiki for a static one. http://fortranwiki.org/fortran/show/hash+table+example preallocation has it's benefits though, instead of growing to much you could also replace items which take longer or are less referenced then other results? Growing is also limited to X ammount so..
The ';' in your format-string is wrong. It should be '(A,X,F0.5)'.
The second error means that you need to define a return type for the function and the final error is happening because you haven't defined the type/intent for y.
Yeah, that will work the the final error. For the other one you need to add a line like 'REAL :: myfunction' in the declarations section - you can read more about it [here](https://en.wikibooks.org/wiki/Fortran/Fortran_procedures_and_functions) 
If I'm not mistaken, it looks like you have the letter O (as in Oscar) in that format string instead of the digit 0 (zero). 
The dummy argument `x` in your function `myfunction` is of type `real` however you're feeding it the variable `i` which is of type `integer`. Since the dummy variable `x` is `intent(in)` you should be able to replace `myfunction(i,z)` with `myfunction(real(i),z)`.
How do you want us to help you? &gt; I need to write a program which... You clearly state that **you** need to write the program. This sound like a homework assignment. Be more specific about which parts of the program you're having trouble. 
In any case PROGRAM HOMEWORK IMPLICIT NONE CHARACTER(LEN=50) :: IN1, IN2 INTEGER :: STRLEN, I, COUNT READ (*,*) IN1 STRLEN = LEN_TRIM(IN1) IF (STRLEN &lt;= 6 .OR. STRLEN &gt;= 24) THEN WRITE (*,*) 'LENGTH MUST BE BETWEEN 6 AND 24' STOP END IF COUNT = 0 DO I = 1, STRLEN IF (IN1(I:I) &gt;= '0' .AND. IN1(I:I) &lt;= '9') &amp; COUNT = COUNT + 1 END DO IF (COUNT &lt; 2) THEN WRITE (*,*) 'MUST HAVE AT LEAST 2 NUMERALS' STOP END IF READ (*,*) IN2 IF (IN1 /= IN2) THEN WRITE (*,*) "PASSWORDS DON'T MATCH" STOP END IF END PROGRAM HOMEWORK 
Change the filename extension from .txt to .f90. Edit: further to this, grab a programmer's text editor (there are lots of them, and wars have been fought over less), but if you're on Windows, a nice one to start with is Notepad++. It'll do nice syntax highlighting and a few other things, that'll help a bit. 
For compiling, 2 good compilers are [g95](http://www.g95.org/) or [gfortran](https://gcc.gnu.org/wiki/GFortran). It sounds like you are using Windows, so compiling can easily be done from the command line: gfortran myfile.f90 -o program.exe where 'gfortran' can be replaced with 'g95.' 'myfile.f90' is your source code, and 'program.exe' is the name of the executable to be compiled. The command line input above is probably the simplest compile command you'll use. It gets more complicated when you start linking multiple files, libraries, etc. or optimizing the code or several other options. It's been a while since I compiled on a Windows machine, but I don't remember needing Cygwin64. Someone can correct me on that though. Edit: /u/qwya jolted my memory. I used MinGW for Windows environments.
You've done the right thing by installing cygwin. Code is written as plaintext, which you'll be used to seeing with the .txt label but is often saved with a different extension ("File&gt;Save As") according to the language (fortran = .f, .f90, .f95 ; python = .py etc.). One advantage of this labelling is that fancy plaintext editors know what to look for when, say, [syntax highlighting](https://en.wikipedia.org/wiki/Syntax_highlighting). Notepad++ is definitely the one for you to use. Fortran is a "compiled language", which means that the plaintext must be compiled into a binary executable before running. The compiler you want is gfortran, which is used in the cygwin command line (after navigating to the correct folder using [cd](https://en.wikipedia.org/wiki/Cd_(command\))) as /u/bakepot said. It may be packaged with cygwin, but if not then look [here](https://gcc.gnu.org/wiki/GFortranBinaries). Have fun! Let me know if you need more help.
Thanks for the clarification. My memory is coming back. On windows, I used MinGW.
If he doesnt even know what a filename extension is, he most certainly doesnt need a "programmer's" text editor. Start with the simple notepad and get comfortable with basic stuff first. Baby steps.
I added something called "gcc fortran GNU compiler collection" in cygwin. How do I navigate folders using cd? Inputting cd gets me the same thing as pressing enter with an empty line when using the cygwin terminal.
Yes it is
Well, there is that; everyone's got to start somewhere. But Notepad, man; nobody should have to have to deal with that... ;-) 
The name for the output file is given after -o. In this case, after running the command, you will have a file named program.exe, which is your executable.
The location in the file that will be read from and/or written to is the same. The write statement advances that location as it writes data, and the read statement advances the location as it reads data. Now consider where you are in the file when you start to read the data.
Ah, ok... Thank you!!
Got it!! Thanks. If I do not rewind, it crashes it. 
Maybe you can wrap it, keeping the calculations in Fortran or C(++), and do the input parsing etc. in Python?
Yeah, if this is just to learn Fortran, that's fine. But as the other guy said, you'd just be using a library for that in Fortran anyway. I'd also second the idea of using Python as a wrapper. Look into f2py - it might save you a lot of hassle in the long run.
This seems extremely verbose - over half the code is just data, you should throw that in a data file somewhere. Plus gotos :(
cobol, fortran 77 (well with extensions ;), what's next, pl/i? :)
Oh I know .. I was not attempting to write particularly good code, just to get something working as quickly as possible. I was challenged by a friend to write this in fortran-77 to get a free lunch. I had never written a Fortran program before and I wanted to emphasize the 77' ishness. I read an online Fortran 77 tutorial that said that structured loops were not supported by all compilers as part of the 77 standard. Is this true?
That might be older than FORTRAN77? There were do/end do loops (i.e. for loops) as far as I'm aware.
yes that's pretty neat indeed. I'm thinking of buying a pi myself to replace my aging powerhungry sparc system. It would be much faster also :)
[See this scicomp answer.](http://scicomp.stackexchange.com/questions/16150/which-version-of-fortran-should-i-learn/16151#16151) In the present year, you don't "write F77" or "write F90" or "write F2003", you just write in Fortran. Compilers (and the standard) have practically 100% backwards compatibility with older standards. &gt;and compilers like GFortran compiling for F77. They really don't, gfortran and all the others compile whatever fortran code you throw at it. All the major fortran compilers basically support all past and present standards (up to the point that they support the most recent standards, not all are fully F2003 compliant.) You don't even have to give it any flags specifying the standard you're using. Functionally the only difference is that compilers by default assume .f files as "fixed format" -- which some people incorrectly interpret as "F77" -- and .f90 files as "free format." "Fixed format" being the code you see that's indented 7 spaces, with a character in the first column indicating a comment line. But even in that format you can use the newest F2003/08 code. &gt;Is F77 still lingua franca of Fortran? You'll see a lot of F77 code simply because of legacy code. *You should never ever ever for any reason write new strict F77-compliant fortran code.* There is no reason for it. But if you're regularly working in Fortran you'll inevitably have to interface F77 legacy code, and it's good to know why they did things that they did.
Looks like old fortran 66. Essentially the same in concept just a lot messier with the do statements. 'Do 10' will cycle every time the program hits the '10 continue'
I love that "do" structure
Are you sure you are compiling this source code? It seems more likely that you are accidentally compiling a different file.
I think so, I use the command 'gfortran Read.f90 -o Read.exe' to compile it
If it compiled but didn't run is it possible it was looking in the wrong place for the input file? If changing command interfaces makes a difference that might be a possibility. Kind of silly but I thought I'd ask.
I'm not aware of a compiler for Android. But have an upvote and a comment because /r/fortran needs more NSFW submissions.
Do you have an internet connection? I guess the easiest would be to SSH into a machine which has a compiler. Maybe get one of these keyboard folios for your tablet.
Unfortunately the network is incredibly bad along the train line (the joys of living in Australia), otherwise I would be using my uni's virtual machine thing my via Citrix receiver. I've only started doing any programming as everything related to my course (genetics) I've previously done is wet lab stuff.
I am using [CCTools](https://play.google.com/store/apps/details?id=com.pdaxrom.cctools&amp;hl=en) with the Fortran Addon to run Fortran Code on my LG G3. It seems to function pretty well but I just run a very small and simple program with it. So I don't know if more complex code would perform as it should.
Citrix, do you really need a full GUI for this? SSH can run over a very limited connection. Alternatively/additionally, you could use a local editor running on the tablet, and then push anything which should run to the server via SFTP or maybe even dropbox. That way you would only have to deal with lags etc. when you are actually compiling the code, not when writing. Incredibly bad networks are commonplace all over the world :)
Are you using a gfrotran 5.1.0 mingw-64 build? There is a [bug](https://sourceforge.net/p/mingw-w64/bugs/487/) with that version it seems.
This alone won't be a solution to learning on the train with just an Android device. /u/Ugdalf's comment is best I think. But, maybe useful information....? http://specificimpulses.blogspot.com/2011/01/my-android-speaks-fortran-yours-can-too.html Blog post from 2011. Talks about using the NDK to cross-compile Fortran. His updates linked at the top will likely be more useful.
Yeah. It's a weird problem with that particular build. And just in case you didn't know, you can call gfortran --version (or any GNU program really) to get the version. It's useful to keep track of what you're using because of version/build specific problems like this. 
This was the issue, I have version 5.1.0 of gfortran on mingw
While I'm not a fan of using a preprocessor with Fortran myself, one typical use case I've seen is a program which you want to be able to build to work either in parallel with MPI or in serial. Or sometimes people also use those for easily toggling extra debugging output compilation time, or introducing ugly workarounds on some specific platforms. 
I've seen them used in a few different ways in scientific codes: - to enable some experimental functionality - to enable additional debug output and tests - work around some compiler specific bugs depending on what's detected in the configure step - to use fallback routines if some library was not detected
&gt; Compilers (and the standard) have practically 100% backwards compatibility with older standards. Actually the standards itself are basically backwards compatible. There are very few deleted features, so most F77 codes are totally valid F90 or F2008 codes. 
Is there one for an iPhone? I checked several months ago, and did not see anything... 
Not sure... I think this is an android-only thing. 
I haven't run your program, but it's possibly due to how you are calling cofactor and the definition of the cof parameter.
hm. do you mean that the cofactor subroutine expects cof to be type real, but i'm passing to it an element of an array? i would expect an element of an array of type real to be of type real. is it not?
thank you! that's exactly it. i copy/pasted some code from a previous exercise and wasn't very careful in modifying it. the tutorial didn't talk about modules. that's what i'm learning next :) i would like to understand why the code compiled successfully in the first place. if i declared "cof" to be a real array in the cofactor subroutine, why did it accept a real variable as parameter? edit: moreover, what difference does it make if i stick the subroutines in a module or not?
Basically, the way the code is written currently, when it's compiling the call to the subroutines it does not yet know what the interface to the subroutine is going to be like. So it just takes a guess based on what you've provided - this is called an *implicit interface* in fortran. You can in fact put the program block and each of the subroutines each in its own source file and compile them in whatever order you like. As you've noticed implicit interfaces are very error prone. You can make interfaces *explicit*, i.e. declare to the compiler what the interface of a subroutine is at the point that it is being called, in two ways. The first is using interface blocks, which basically repeats the interface part (the declaration of the subroutine and its arguments) within the scope of the calling program or subroutine (this is analogous to how header files work in the C language if you're familiar with that). Because you're basically repeating what is being declared already in the subroutine itself, it's still error-prone because you might decide to change the subroutine and forget to update it in the interface blocks. Interface blocks are a bit of an outdated feature that you typically don't need so don't worry too much about it. The better, and much easier way is to use modules - which apparently you're about to learn about, but basically, you just stick your subroutines in a separate module (file) - make sure you compile that first - then if you add a "use &lt;module_name&gt;" statement in your program it automatically picks up the interface information from the compiled module.
In addition to what the others have said, you can tidy things up a bit by using Fortran array operations. This: det = 0 do i=1,3 det = det + mat(1, i)*cofra(i) end do can be written as just: det = sum(mat(1,1:3)*cofra(1:3)) Similarly here: write(*,10) (ra(row,col),col=1,size) I think a more modern way to write this would be just: write(*,10) ra(row,1:size) or even just: write(*,10) ra(row,:) You can even just do: write(*,10) ra to print out the whole array without a loop, although the formatting won't be what you want. I'm also not a fan of using line numbers for format statements, but that's up to you.
You need to write [on paper] a work flow with inputs that you have and outputs that need. Then write [again, on paper] a pseudo-script of what you want it to do. Then come back here with a better idea of what you need from the Fortran. Good luck!
Some critique if it's wanted: If you're going for "modern", why not use OOP where it makes sense? e.g. for ode_int.f08, you've got RK4 and RK45 with essentially the same interfaces -- I would make a single "ODEInt" type abstract base class, and then you can create classes derived from that for any of your RK integrators. Similarly the derivative function passed can itself be an abstract object with some kind of function "dydt" or something to that effect.
Critique is always wanted. How else do we improve? &gt; If you're going for "modern", why not use OOP where it makes sense? Haha! Well... because I'm a noob. I didn't even know OOP was possible. I'll definately look into it. I do have one question though, what are the advantages of such an approach over the more achaic one?
&gt; I do have one question though, what are the advantages of such an approach over the more achaic one? Well... generally speaking, that's just asking what advantages OOP can offer any piece of software: the answer is a lot. for this kind of example of an integrator, I typically have a "RightHandSide" abstract base class, which is required at minimum to have a function "dydt" or something to that effect to return the derivatives. Then all the ODE integrator cares about is that it receives some object with that function defined. In my case, it's the right hand side of the navier stokes equations, and evaluating those can be a total nightmare and extremely complex. But I can write a class for that which has all manner of other complex things, settings, internal storage, and interactions with other things, but the ODE integrator doesn't care as long as it conforms to the base class with a "dydt" operator. "scientific software engineering: the object oriented way" has a number of solid examples.
How would you recommend I should go about it, bottom-&gt;up (derivatives class -&gt; non-adjustable integrator class -&gt; adjustable integrator class), or top-&gt;down (the inverse of bottom-&gt;up). Also, lets see if I'm understanding properly. I could make a general ODE integrator with common elements such as Butcher table vectors and matrix (with no explicit dimension), a matrix of all the K_i coefficients, an error vector, step-width, etc. And then create specific integrators which use those elements but give them a defined shape and value? It's gonna be a challenge, but I'll give it a go! 
Well from a design perspective, the abstract integrator probably doesn't need a butcher table and other things, since those are all going to be unique to the concrete integrator used. For example, I define an abstract class for an integrable right-hand-side: type, abstract :: IntegrableRHS contains procedure(IntegrableInterface), deferred, pass(this) :: d_dt procedure(GetLastDdtInterface), deferred, pass(this) :: GetLast_d_dt procedure(GetStateInterface), deferred, pass(this) :: GetState procedure(SetStateInterface), deferred, pass(this) :: SetState procedure(GetLocalDtInterface),deferred, pass(this) :: GetLocalDT procedure(GetMinLocalDtInterface),deferred, pass(this) :: GetMinLocalDT end type IntegrableRHS (really all that's absolutely necessary there is d\_dt, but I added some things to help out.) Then for the integrator I have something like this: type, abstract :: ODEIntegrator integer(p_int) :: maxiter = 1e8 real(p_real) :: exit_tol class(IntegrableRHS),pointer :: RHS contains procedure(ODEInterface), deferred, pass(self) :: ODESolve procedure(ODEInitInterface), deferred, pass(Self) :: ODEInit end type ODEIntegrator and there are some suitably defined interfaces. The end idea here is that your particular ODEIntegrator is completely ignorant of anything to do with the IntegrableRHS object, so long as that object has a function "d_dt". Similarly anything using the ODEIntegrator doesn't care (and is completely ignorant of) the details of the integrator, it just knows it can pass it an IntegrableRHS object and call Solve on it. [This is a nice brief article on syntax and usage of OOP in more modern fortran.](http://www.pgroup.com/lit/articles/insider/v3n1a3.htm)
Happy to help. Getting into OOP is a massive can of worms, but it's really the best way to build very large complex programs that are still manageable. 
Yeah, it feels like I'm staring down into the abyss... gonna be quite a journey. I'll see if i can get my hands on the book you recommended. It's bound to be *somehwere*. If I may, how did you learn this new paradigm?
It's not exactly new, although it is new to fortran (2003 standard). Anyone studying software engineering is immersed in it, and anyone doing any kind of serious development (including and especially scientific computing) needs familiarity.
To be honest, there aren't a lot of admissions committees that are going to give a flying fuck about programming skills beyond "competent."
I was under the impression they were the same. I haven't found much on how they differ except for `double precision` being the old way. I'll change it regardless, gotta get with the times! Thanks for the tip! **Edit: Nevermind, i just found something on the fortran wiki. Never would have guessed had you not mentioned it. Thanks!**
Even in the early 2000's my PhD advisor told me to program in f77 because you could compile it anywhere - f77 was installed on almost every unix machine. I now program in modern fortran because I know I *can* install gfortran on almost every 'nix machine.
I can see at least two problems with your code: 1. The READ statement has no variables to which it should be reading the data. It looks to me like it should be read (1,*,iostat=openstatus) x, y 2. Asking for a file name and opening the file should most likely not be inside your DO loop. That is, the DO loop should start after the OPEN statement, before the aforementioned READ statement. I hope this helps you forward. 
So it's either the jagged array-like thing i already have, or a linked list. I think each one will be better than the other in different scenarios. I'll try them both and benchmark. Thank you for the help.
That's actually exactly what i'm doing, though i do both steps together. type mytype character(:), allocatable :: val(:) end type mytype I tested it today and it works! I have gcc 5.1 and on highest priority but for some reason gfortram stays 4.9.2 and i can't get it to switch as well. I've looked everywhere but haven't been able to solve that issue.
Well for some reason it allows me to use allocate( character :: val(n) ) And i can use any string length i want as long as i reference val as val(i)(1:string_length) for the i'th string.
You should check to make sure the strings are being stored correctly. I just tried character(:), allocatable :: var(:) allocate(character :: var(2)) write(*,*) 'Adding first string...' var(1)(1:4) = 'word' write(*,*) 'var(1) = ', var(1)(1:4) write(*,*) 'Adding second string...' var(2)(1:9) = 'two words' write(*,*) 'var(1) = ', var(1)(1:4) write(*,*) 'var(2) = ', var(2)(1:9) using ifort (the intel fortran compiler) and it gives this Adding first string... var(1) = word Adding second string... var(1) = wtwo var(2) = two words Adding the check bounds flag gives an error when it tries to perform the first assignment `var(1)(1:4) = 'word'` as the upper bounds of `var(1)(:)` is 1. So you may be writing your strings over each other and outside of your variables bounds. 
Cool. I guess ifort and GFortran handle those cases differently. It's also possible GFortran is resizing all of the strings to be large enough to hold your longest string. I'll have to check that on GFortran later tonight.
I don't know what it does, i tried `len(var(1))` (for both cases) and they both gave `340373`. I tried allocating a length of 5 and the result both 'lengths' is still `340373`, i have to give it the proper form. It also doesn't give a shit about character lengths because i'm still getting this Adding first string... var(1) = word Adding second string... var(1) = word var(2) = two words var(1) = word 
If you change `len(var(1))` to `len(var(1)(:))` it should give you the correct length. Working with the previous code and adding write(*,*) 'len(var(1)) = ', len(var(1)(:)) write(*,*) 'len(var(2)) = ', len(var(2)(:)) gives len(var(1)) = 1 len(var(2)) = 1 Also adding compiler flag `-fcheck=bounds` gives an error on the statement var(1)(1:4) = 'word' saying the maximum bounds is 1 and not 4. Arrays for intrinsic types in Fortran are generally suppose to be placed sequentially in memory. The current behavior from your GFortran code appears to be placing the start of each string in your array far enough apart in memory so that you can go beyond their bounds without overriding the next string in the array. So my suspicion is that the ifort compiler is producing the correct behavior and your current program is working due to a compiler bug in GFortran, not an actual language feature.
I'm getting the same answer as before. -f-bounds-check on gfortran doesn't give an error in our example, but does raise an error for a character array component of a derived type that i'm also testing in my test program. It says its maximum bound is 0, yet its declaration is exactly the same as what we have except for it being a subobject of a derived type. Shit's weird.
Interesting. I did my testing just now using GFortran 5.2.0 for reference.
Now I have a new question, how can i update to the newest gfortran release? I updated to gcc 5.1, but gfortran stayed 4.9.2. I haven't found shit about how to do so elsewhere.
Fortran was the first language to ever be standardized - fortran 66. What do you mean?
I've got similar issues. I'm pretty sure it's caused by errors in implementation though. I think it's too much to ask compilers to behave identically when faced with the same memory error. 
Matrix multiply operator - like Python has! :D
Yes, but there is no operator that works on rank-compatible arrays directly, which is the correct equivalent. 
Having intrinsic functions makes it so you don't have to transport includes across projects.
That sounds like an error in the input loop. Some possibilities: - You're reaching the end-of-file. Check for inputstatus&lt;0 to find this. - You haven't defined the data array correctly (you haven't showed us where it's defined) - The input file isn't formatted correctly (it must have the correct number of space-separated columns on every line, with no extra carriage returns or comments) - The file isn't opened correctly (what does the "open" statement look like?) As a side-note, for this kind of thing you don't really need the speed of Fortran, and you might find it quicker and easier to do this with the numpy library in Python. There is a "loadtext" command that will load a text file of columns into an array in one statement. You can then do basically the same array-based operations you can do in Fortran to get your results.
EDIT 2: Well everything works fine in ubuntu. The earlier edit was done for windows with GFortran 5.2.0. _____________________________________________ EDIT: I just remembered why my way works. It *is* a language feature. It's in Modern Fortran Explained, character arrays were required to have a character length unless they were of an appropriate derived type. That is not so from Fortran 2003 onwards, it says so at the end of section 2.11 of the book. Both our ways should work, but there's apparently a bug in GFortran that doesn't properly carry out the simultaneous allocation of array size and entry lengths as in: character(:), allocatable :: var(:) allocate(character :: var(2)) var(1)(1:4) = 'word' print*, var(1)(1:4) var(2)(1:9) = 'two words' print*, var(2)(1:9) because it compiles but causes a runtime error (memory dump), *unless* the item is of a derived type. type mytype character(:), allocatable :: val(:) end type mytype type(mytype) :: var allocate(character :: var%val(2)) var%val(1)(1:4) = 'word' print*, var%val(1)(1:4) var%val(2)(1:9) = 'two words' print*, var%val(2)(1:9) in which case, it compiles and runs fine. So apparently, both compilers have their own bugs to sort out. __________________________________________________ I just updated GFortran to 5.2.0 and tested what didn't used to work. It works now. However, what you said about making an array with this type &gt; type mytype &gt; character(:), allocatable :: val &gt; end type mytype &gt; type(mytype), allocatable :: val(:) as opposed to how I have it &gt; type mytype &gt; character(:), allocatable :: val(:) &gt; end type mytype both still work without explicitly allocating an array length, but when I remove the derived type in my setup, it doesn't work (I have to allocate my array first and then allocate the character for each entry). I don't know what to make of this.
This is the best tl;dr I could make, [original](http://www.popularmechanics.com/space/a17991/voyager-1-voyager-2-retiring-engineer/) reduced by 86%. (I'm a bot) ***** &gt; Larry Zottarelli, the last original Voyager engineer still on the project, is retiring after a long and storied history at JPL. While there are still a few hands around who worked on the original project, now the job of keeping this now-interstellar spacecraft going will fall to someone else. &gt; &amp;quot;Although, some people can program an assembly language and understand the intricacy of the spacecraft, most younger people can&amp;#039;t or really don&amp;#039;t want to.&amp;quot;. you have a few tasks ahead of you and about 64 kilobytes of memory to work with. &gt; Still, the small team working on Voyager today has a list of engineers and others on-hand to call in emergencies. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/3qtlgn/why_nasa_needs_a_progammer_fluent_in_60yearold/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.6, ~10589 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PMs and comment replies are read by the bot admin, constructive feedback is welcome.") | *Top* *five* *keywords*: **engineer**^#1 **work**^#2 **spacecraft**^#3 **Dodd**^#4 **people**^#5 Post found in [/r/space](http://np.reddit.com/r/space/comments/3qtfu3/why_nasa_needs_a_progammer_fluent_in_60yearold/), [/r/programming](http://np.reddit.com/r/programming/comments/3qtfuo/why_nasa_needs_a_progammer_fluent_in_60yearold/), [/r/interestingasfuck](http://np.reddit.com/r/interestingasfuck/comments/3qsz3y/why_nasa_needs_a_progammer_fluent_in_60yearold/), [/r/fortran](http://np.reddit.com/r/fortran/comments/3qtkvs/why_nasa_needs_a_progammer_fluent_in_60yearold/) and [/r/technology](http://np.reddit.com/r/technology/comments/3qtfso/why_nasa_needs_a_progammer_fluent_in_60yearold/).
The people who wrote the software for these probes are the real programming rockstars. They worked within incredible resource constraints and still wrote some of the most stable software every written.
That would be sweet, I'd love to see it to really appreciate their efforts
Check out gams.nist.gov, possibly these: http://gams.nist.gov/cgi-bin/serve.cgi/Class/F1a1
Thank you very much for your time and effort! I'm looking forward to one day being competent in fortran; this will be the begin of a long journey!
Highly recommend you reviewing the [Stanford Fortran 77 Tutorial](http://web.stanford.edu/class/me200c/tutorial_77/) to orient you with some of the major constructs in the language.
that makes a lot of sense. ill give that a try, thanks a lot.
There is always the classic [minpack](http://www.netlib.org/minpack/) or you can check out [toms](http://www.netlib.org/toms/)
The line seems to be reading data to an element named "rat" in whatever derived type gRed(i) is. It's similar to the dot-notation in many other languages (C, Python...). Edit: For more information, read up on "derived types" in modern (90+) Fortran. 
A bit of a nitpick, but files ending in the ".f" extension are almost always fixed-format Fortran. I would consider changing it to ".f03" if you're keen on indicating you need a Fortran 2003 compiler or ".f90" otherwise. If you do make that change, you won't need to provide the "-ffree-form" flag to gfortran.
I actually want to make one too after I finish my current projects.
I'm probably violating all sorts of Fortran conventions, intentionally or not. I think things like my destructors, hard coded values, unresolved compiler warnings, lack of public/private, and my choice of image format are bigger issues.
You're right -- After I posted, I started reading about these methods, and the binning one seems to be the best fit. Eventually if I migrate to a GPU-based solution, I could process millions of particles per second, which would be a massive improvement. Thanks! 
Ah, thanks, I haven't tried either of those, and somehow didn't come across them in my search for existing Fortran REPLs. From a quick review of fytran, a couple differences are: frepl will allow you to redefine existing variables, functions and subroutines, so you can, for example, switch an integer to a real; frepl strives to provide a more REPL-like experience, so that many statements will be evaluated as expressions and their value will be immediately printed, so do don't need to manually call write/print, and you don't need to explicitly issue a compilation command. This latter feature probably has some drawbacks, e.g. fytran might probably provide a better UX for executing code that involves multiple sequential loops.
The bottleneck here is the disk ... it's the slowest part of the whole chain. What you'll want to do is allow for **buffered** io, either through a compiler directive or compiler dependent option in the OPEN statement. Buffered io allows the system to write lines to the disk in batches, minimizing delays due to waiting on the disk. In your code, if you need to ensure that the disk is actually written to in a given segment you can flush the buffer using: flush(unit)
for text you can supply a format string with a large repeat value (or calculate/write that string exactly in the program but a large number will work also) and print the array in one go. This should be faster then looping i think. But if you want it really fast like in c where you can write a buffer you can use unformatted i/o with a large reclen. [This](http://stackoverflow.com/questions/6526112/in-fortran-90-what-is-a-good-way-to-write-an-array-to-a-text-file-row-wise) stackoverflow question has the answers you need and an example of usage including timings.
Typically every time you use a write/read statement it goes down a line in the file. For instance if I do a statement like this with my integers a=100, b=2300 write(10,*) a, b The output will look like this 100 2300 Where a and b are written on the same line. But if I change it to this write(10,*) a write(10,*) b The output will look like this 100 2300 So basically every read or write statement moves down a line. Now why your program is doing that, can't really help you there. :)
Yeah that's a possibility, though usually you see blank read statements for skipping lines. It could just be the way the person programmed it I guess. 
I'm using Silverfrost FTN95 Express. How do I tell the compiler where the module is? And do I need to have a MOD file? I just created a regular F90 file and wrote "module variables" on the first line... 
I'm sorry, but how do I do that? I mean, I have my main program, my subroutines, and my variables module all open on the same project, but it gives me the error when I try to debug..
Most IDEs should have a way to specify dependency or at least specify the order in which the code is compiled. I've never used Silverfrost FTN95 Express so you'll have to check the manual on how to do that. But usually there is a compiler options menu and somewhere in that menu is a spot where you can add dependencies. The file that will be generated from the compiler is of the form (module name).mod so make sure to add that to all source code files that are dependent on the module. 
Hmm, the `gcc` port comes with Ada, C++ and Java, but [without Fortran](http://openports.se/lang/gcc/4.9) according to the `plist`?
The error looks like it's only complaining about the .f08 file extension. Try just renaming it to .f90 and see if it works -- most fortran compilers, gfortran included, only ever look at the extension to see if it's .f (for fixed-format) or .f90/.f03/f08 (most commonly f90, for free-format.) i.e., there's nothing keeping you from writing f2008 or f2003 standard code with a f90 file extension in any compiler i'm aware of.
Yes, but there is no `gfortran` 4.9.x on OpenBSD. Or at least I can't find it, that's why I posted.
Have you tried renaming them to .f90 and compiling without the std specification? 
 fblog.f90:17.3: error stop 'Internal error in Main' 1 Error: Unclassifiable statement at (1) Sigh.
Ah interesting, "error stop" on line 17 is indeed an F2008 feature. You might be able to just comment out those lines, it's only used 4 times. ~/tmp$ grep "error stop" ./* ./fblog.f08: error stop 'Internal error in Main' ! This shouldn't never happen. ./interactive.f08: error stop 'Internal error in subroutine Interactive' ./terminate.f08: error stop ! 1201 -&gt; 1210 subroutine html_year_archive ./terminate.f08: error stop 'Internal error in subroutine Terminate' otherwise you're going to have to get yourself an F2008 compliant-ish compiler. Intel has free non-commercial linux compilers.
I guess commenting out things until it compiles will break everything. So, well, which one works on OpenBSD? 
It's not that intensive at all, so maybe Python is best. But I don't know Python... like at all &gt;&lt; Since you'll be able to relate, what I'm doing is making a program that will create observing lists out of any file, so long as it's delimited. Basically, it'll prompt you to enter the column number for parallax, RA, and dec. The parallax input will set a limit on the parallax, then it'll print a list of the RA/Dec of all stars within the parallax limit you entered.
You can do this fairly simply in Fortran with the hints I've given you, but I do recommend giving Python a go. In particular, you want to look at the numpy, scipy, pylab, and matplotlib libraries for Python. They allow you to do things like this: import numpy as np x = np.loadtxt("somedata.dat") This loads all of the data in "somedata.dat" into a single array x, automatically recognising the format, in a single line of code. Then x[:,j] is the (j+1)^th column of data. Pretty nice eh?
Wow, yeah, that's beautiful. I'm just gonna give Python a go. I've put it off for far too long. I'm sure it'll only take me a few hours to figure out what I need. Any recommendations for beginners' guides?
The documentation for both Python and numpy are great starting points. The sidebar of /r/Python is also a decent place to look for books and such
Slavery has been banished in most countries
Fortran still has a major place in high performance computing and scientific applications . Additionally, a lot of codes in HPC are legacy. They seem to transcend time so there is still need to understand and develop in Fortran. 
I'm sure. Once you get familiar, Fortran is really useful and really simple. 
&gt; But i still think using another language would save a lot of time for the programmer on certain aspects wouldn't it? You would be surprised how not true this is for high performance computing for the following reasons: 1. Fortan has built in functions for things you commonly want to do. Like matrix multiplication, or sum functions, or a or array slicing, or the 'where' function, or all kinds of other common things you do in numerical situations. A C/C++/Java programer either has to link to extra libraries to have these features or code them themselves. In fact, there are so many of these nice features that programing in Fortran for numerics is almost as easy at matlab or Python modulo you have to declare types and compile. But like matlab or Python, there are many simplifying numerical functions built into Fortran that are nowhere inside C/C++/Java. 2. Fortran allows you to flag your functions special ways to make your life easier. For example, if you write a function and declare it 'elemental', you can apply that function to either scalars or arrays. A C/C++/Java programer either has to create separate functions for scalars and arrays or do something like for loops to apply a scalar function to a whole array. Again, like matlab or Python, with Fortan you can just use exp(x) no matter if x is a scalar or an array and it works. 3. A C/C++/Java has to worry about all kinds of things that add bloat. For example, in A C/C++/Java, you have to make sure to pass by reference or you could run out of memory when dealing with large arrays. Or when using classes, you have to worry about all this temporary creation of objects that similarly adds bloat. Sure you can code around it, but the point is it's extra effort and knowhow. With Fortran, this is done for you automatically. You don't have to worry about things like passing by reference to not add bloat as it's done for you. You can just code and know that the compiler will make sure that extra un-necessary bloat is blot created if you did not go out of your way to program around it. 4. As a language, Fortan is simpler in that it is less complex. Now C is also simple so it isn't a leg up on C. But if you study C++ and even Java one of the criticisms is it thousands of pages of books and years of experience to master all the features. Multiple inheritance... template meta-programming... etc... Fortran, like C, can have all of it's main features explained to a user rather quickly and without years of experience to master. It's true that newer versions of Fortran are trying to add this extra complexity, but for most programers, you will never encounter some crazy multiple inheritance template whatever whatever with friends function this etc... complexity. You will instead encounter a module with a bunch of sub-routine and functions that really don't get more complex than that. (Typically. Again new stuff is getting more C++ style complex) So the idea C/C++/Java is simpler to me is a myth. Fortran's more like Matlab on steroids and it's hard to argue C/C++/Java is easier to code in than Matlab for numerical things. To me the big solid argument against Fortran is that, since the mainstream computer science world rarely uses it, if Fortran is all you are good at programming in, it may be harder to find a job if you need to leave a numerical field. And since being employed is a big deal, being proficient in a language outside of Fortran is important. 
As mentioned by /u/mounder21 it is very useful in high performance computing situations, in fact it was designed for number crunching. Why should you learn Fortran? It's not like you [could be hired by NASA](http://www.popularmechanics.com/space/a17991/voyager-1-voyager-2-retiring-engineer/) ... Oh wait...Yeah, **legacy** is a big reason; many important systems still use it. Do you know how much it would cost (in terms of time, and effort) to write and debug a rewrite in a different language? 
What do I need to work there?
MATLAB is pretty easy to write, especially thanks to the IDE. Its just very slow at non matrix stuff
Do you guys have any recommendations for a FORTRAN 77 compiler which i can use on windoes interface? Except Force 2.0?
Fortran compiler are backwards compatible, so the latest version of any compiler will work just fine. Of the three most popular both Intel and PGI run natively on Windows, but are expensive. GFortran, which is free and libre can be run through cygwin easily.
I'd recommend intel over pgi any day. They have a free-for-students thing, too. The more important question is "why write fortran77?" Moden fortran is so much nicer, and fully backwards compatible. 
Me too! I also see that people spend a lot of time to implement buggy code that could be done easier and safer in any number of languages. There is no excuse for writing new fortran 77 code, and we're not doing that - we're writing fortran 90+, since it actually gives some of the strictness you're talking about. F77 effectively gives the disadvantages of strictness without its advantages. 
Right. Win or linux?
Intel is good for HPC and general programming, but if you want GPU programming PGI is the way to go. 
Fortran 77 and 90 have differences, but if you know one then learning the other isn't all that hard. It's not like the gap between C and C++ or things like that. 
Then cygwin + gfortran seems sensible to me, since it's the same compiler. 
Well you probably should have another language on your resume. If you want suggestions that are Fortran-like, I'd say: * MATLAB / Octave - Clearly similar to Fortran since they're both math-centric and feature 1-indexing * Lua - Designed by engineers, it's a relatively simple scripting language that is used far outside its original purpose because it's simple to embed in other software. Also features 1-indexing... * Python - Quickly becoming a powerhouse in scientific programming, although I never was a fan of NumPy's verbose syntax (compared to Fortran or MATLAB) The above, of course, are my opinions. 
I am not big into fortran myself, but I have dabbed in it, coming from Python. To me, it felt very similar to python, with a few differences here and there. You can also compile fortran into python modules using [f2py](http://docs.scipy.org/doc/numpy-dev/f2py/). Like I said, haven't done much with fortran, but python might be worth checking out again. Nothing will be identical, fortran is iconic, but you might find something with a likeness that you can deal with. It has been suggested MATLAB might be a good alternative, but IMHO python does everything MATLAB can do, typically better, and it's free. I have to use MATLAB for some research, and it's definitely not my cup of tea over python. I am biased ;P
What type of programming are you going to do in the future? Web/Desktop/mobile? I'm a big fan of Python but it really depends on your use case.
It's useful to learn multiple languages even if you were to stay in academics. Each language has their strengths and weaknesses. I wouldn't write a number crunching program in Python, but I wouldn't write a user interface program in Fortran. But ultimately the language you want to learn depends on what you want to do or what job you think you might be getting. 
A new guy comes in who only knows Fortran is going to have to learn Python or shell scripting real fast too. Source: me!
The new kid on the block is GPU programming. OpenCL, for example; it's really fast, and runs on anything; CPU, GPU, co-processor boards. It's a dialect of C, so it doesn't match the FORTRAN-like part of your question, but, honestly, no one designs FORTRAN-like languages any more (except MatLab, mentioned previously in this discussion, but it's not like MatLab is a high-performance language.)
I'm not sure what I will do in the future. Right now I do computational physics. The software I use and the analysis code I write is almost exclusively Fortran. I would like to branch out to other languages to broaden my horizons and strengthen my resume should a job with a more modern approach to programming comes about. I am trying to learn python and C, but I'm finding it difficult to not just go back to Fortran. Thanks!
Thanks everyone for your great responses! There is some excellent advice on here for me. I do have experience in BASH scripting and a little Python and C, but I'm just trying to figure out where to really spend my time. I work in computational physics (academia), but may be branching out into finance or even software at some point.
I'm a bit surprised that nobody mentioned Julia here. It's still in its infancy but has great potential in scientific and engineering computing, imho. It's designed with performance in mind and it's syntax is similar to Python and Matlab. Checkout /r/Julia and also of course, www.julialang.org 
This is ancient code. I've written up a modern rendition below: program GasVolume implicit none !declare symbols as variables real A0, a, B0, b, c, Ru, M real P, T, AA, BB, fv, fp, dv integer N character(len=*) formatstring !set their values A0 = 0.07132 a = 0.10476 B0 = 0.07235 b = 660000 c = 8.315 Ru = 707.2836 M = 44.01 write(*,*) 'Enter pressure value (kPa)' read(*,*) P write(*,*) 'Enter Temperature value (C)' read(*,*) T T = T+273.16 formatstring = '(A30, F8.4, A35, 15, 5X, F8.4)' !Use equation of state to establish best guess v = Ru*T/P write(*,formatstring) 'Ideal Gas Law prediction for v: ', v/M !Compute constants AA and BB for Beattie Equation N=0 do AA = A0*(1-a/v) BB = B0*(1-b/v) !Calculate function and derivative fv = P - (Ru*T/v**2) * (1 - c/(v * T**3)) * (v + BB) + AA/v**2 fp = (2*Ru*T/(v**3)) * (1 - c/(v * T**3)) * (v + BB) fp = fp - (Ru*T/v**2) *(c/((v**2) * (T**3))) * (v + BB) fp = fp - (Ru*T/v**2) *(1 - c/(v * T**3)) * (1 + B0*b/v**2) fp = fp - 2*AA/v**3 + A0*a/v**4 dv = -fv/fp v = v+dv N = N + 1 if(abs(dv) &lt; 0.005) exit end do write(*,formatstring) 'Specific volume ', v/M, 'Number of iterations ', N, dv end
I think Matlab is quite a bit better at matrix operations and general math based programming, but Python is better in almost every other category. 
CUDA may be a good idea for you. There is a Fortran CUDA as well so it should be pretty easy to pick up and it would probably be a great skill for the finance world. 
CUDA has a Fortran version OP would probably like. I know there are some downsides to CUDA over OpenCL, but it might be easier for OP to pick up? Oh and Matlab is still high performance for matrix/vector operations since it's built on blas/lapack. So if you write only vectorized code it performs pretty well. 
That was it thanks!
I am not sure how (or if) an array's number of dimensions can be specified as a user-defined parameter, so hopefully someone else can answer this. But I know the size of each of the already-specified dimensions can be defined in the code. The key words you are looking for are *allocatable* and *allocate*. Here's an example snippet: implicit none real(8), dimension(:,:), allocatable :: array integer :: nr, nc, i, j nr = 20 nc = 20 allocate(array(nr, nc)) do i=1, nr do j=1, nc array(i, j) = 1.0 end do end do Of course, after the allocate() statement, you can do whatever you're trying to do with the array. Since I can't think of any neat tricks at the moment, I made an array of 1.0's. Hope this helps Edit: Yep, I didn't read the question correctly. See the other comments.
Ahh, I see, so by doing x(:), it is specifying that the dimensions, and their sizes, of x are arbitrary? I have been looking for how to do that for *hours*. 
Ok that edit should hopefully cover everything. :)
Per your edit, is there anyway to get the size per dimension?
All the commands (size, ubound, lbound) will return an array proportional to the dimension. So if you have a 2D array those command can will return an array with 2 elements that correspond to the (x,y) dimensions. You can create an array to store the variables or use an array constructor like this. real :: array(:,:) [xUpper, yUpper] = ubound(array) or just have an array real :: array(:,:) real :: upperbounds(1:2) upperbounds = ubound(array) You can also have it return each of the dimensions separately. You can read more about it on the GNU website. https://gcc.gnu.org/onlinedocs/gfortran/UBOUND.html
how about using reshape? http://fortranwiki.org/fortran/show/reshape
We'll it's a good thing I'm starting on that road in less than a year.
Use [Cygwin](https://www.cygwin.com/) and watch [this](https://www.youtube.com/watch?v=GfCmiEbGtpE) very useful installation video.
Thanks, this is helpful.
You shouldn't need to pass it, you just need to put it at the start of the subroutine. program Test implicit none integer, parameter :: dp = kind(0.0d0) real(dp) :: x x = 2 call writeprint(x) end program subroutine writeprint(x) implicit none integer, parameter :: dp = kind(0.0d0) real(dp), intent(in) :: x write(*,*) x end subroutine This code works as intended. If you are working on a large piece of code and need it for a lot of variables in multiple subroutines then you can place the parameter in a module and include it in each of the files. 
Best practice here. A quick psuedo code would be: module varkinds implicit none integer, parameter :: dp = 8 end module subroutine mysub use varkinds, only : dp implicit none real(dp) :: foo .... end subroutine
made a mistake on the title. "Field does not exist" instead of "File..."
Nice, this is much more clever! Thanks
What is your error message?
Look again, z is not the rank (= dimension) of the array, but the extend in z dimension
Right, a z dimensional array....
Hu? bar(3,3,3,3,3) is a 5 dimensional array, even though z is 3.
&gt; bar(n,m,...,z) I guess bar is a z dimensional array with an extend of 3 in the z dimension, right?
naah. you cannot see the rank, cause I used dots. but we can switch to a notation from which on can read the rank: bar(n1,n2,n3,....nX) so now you can see that the number of dimensions is X. The extent in the first dimension is n1, in the second n2 and in X dimension is nX. Anyways, you can only use this style (if it works at all), when the rank X of the array in the subroutine is greater or equal the rank of the array your feeding into it. So you can feed the rank 2 array a(:,:) into foo, if bar is of rank 4 as call foo( size( a, 1), size( a, 2), 1, 1, a ) (I think) 
http://www.fortran90.org/src/best-practices.html
No, following guidelines for good code is not outdated...
On capitalization: There's still a fair amount of old code around that writes everything in ALLCAPS, but I find it rather shouty and unpleasant to read. Fortran is case insensitive, so although it's possible, it's obviously a bad idea to refer to the same variable with different capitalisation. This also means it's possible to choose a capitalisation for keywords such as if/then/subroutine/module/do/etc. but I would just stick to small caps for those. Most modern code I've seen uses small caps for everything, just like is common in C - the main exception being parameters which are often written in ALL-CAPS. Indentation: Like in most languages, this is a personal preference (as long as you do indent and it's consistent). Note that tabs are explicitly forbidden in the Fortran standard. Some general recommendations: * always use `implicit none` * always use `intent(...)` for *all* subroutine/function arguments. * make all your subroutines have an explicit interface - in practice this means they should always be in a module, not in seperate subroutine files * don't use `common` blocks 
Thanks for the reply. I generally try to adhere to these practices as well. I was wondering why the dislike for common blocks. I don't use them because my professor told me the same thing, never use common blocks. I just never asked him why, and now that you brought it up again I'm just curious.
Thanks for the link. I'll be referring to this when coding from now on. It doesn't have everything, but it does have a starting foundation I can at least adhere to for some consistency in my coding practices. 
You can add the``pure``attribute to functions to enforce no side-effects and intent. 
Another good practice that I haven't seen mentioned is defining types by using some version of selected_kind such as ``selected_real_kind`` or ``selected_int_kind``, or by using intrinsic modules such as ``iso_fortran_env`` which defines types such as ``real32``, ``real64``, `int32`, ``int64`` rather than relying on compiler specific implementations (like real*8, which may or may not be an 8 byte double).
It does a bit more than that, though -- ``pure`` requires that all procedures referenced inside the pure procedure are also pure. That can be a problematic requirement.
True, just thought I would mention it as an option though.
I like this too. I've been using CamelCase for my variables, but then switched to snake_case for variables. For me it makes reading the variables much easier than clumping all the words together. Another thing I do is using all caps if the variable is a global constant. So for certain variables like RAD_TO_DEG I'll use all caps so I know that value can not be altered.
I have built several &gt;1000 file projects with CMake. It's not perfect but I don't know anything better. It's got great testing functionality, too. 
Seconding cmake. Scales well and simple for small projects as well. 
Looks like I'll go with CMake for now. Thanks!
ok. I never used suse myself so i'm not sure if the following is correct but you can try running 'zypper install gcc-fortran', zypper should be your package manager and the package name should be gcc-fortran. I found these instructions on [this](http://www.amusecode.org/doc/install/install-prerequisites-suse.html) site which is not related but it has fortran as a dependency and shows how to install it under 'GCC'.
neat! Happy coding :)
Check out Chapman's book Fortran for Scientists and Engineers. It's a great Fortran book, but more than that, a great programming book.
If you've never programmed before, [this](https://www.youtube.com/watch?v=gSJhfnhs598) short collection of videos are great for getting started with Fortran (assuming you're not using 77). Then I'd just attempt some exercises like [these](http://www.chem.ox.ac.uk/fortran/exercises.html) to get some practice. Good luck!
If you want an alternative to GNU's compiler, you can use Intel's compiler. Download Microsoft Visual Studio Community 2015 and Intel Parallel Studio XE 2016. Visual Studio is free, and Parallel Studio is free for students.
Intel's compiler is particularly important if you plan on using some of Fortran's newer features (03/08). I actually consider myself partial to gfortran, but if you use lots of object oriented stuff, it is probably worth looking at gfortran's supported [2003](https://gcc.gnu.org/wiki/Fortran2003Status) and [2008](https://gcc.gnu.org/wiki/Fortran2008Status) features and seeing if any you need are missing. However, it's worth noting even Intel still doesn't fully support F08, and only recently completed support for F03.
Your gfortran installation is missing some files, in particular the executable f951. I've no idea why, since you didn't say what you did. Also, rename from .f to .f90 and use free format source. It will save you a lot of trouble. 
I had the same issue and found the answer on StackOverflow: The unix solution is: find the f951 file in your gcc , softlink to it from a directory, that is in $PATH. Basically make sure your command lookup (when you type f951 in the shell) will find the file f951 howerver you do that on Mac OS. *Edit: OS 
Or simply add the f951 directory to your $PATH, probably in your shell's startup scripts or something.
If you used the installers at https://gcc.gnu.org/wiki/GFortranBinaries#MacOS, gfortran will be installed in `/usr/local/gfortran`, with a symbolic link to the compiler placed at `/usr/local/bin/gfortran`. Your `/usr/local/gfortran` directory should be about 200 MB in size (exact size will vary depending on gfortran version installed). It should contain the `f951` executable file at this location: `/usr/local/gfortran/libexec/gcc/x86_64-apple-darwin14/5.2.0/f951`. If not, you probably need to reinstall the package.
The libraries you are trying to link with the compiler options `-L/opt/intel/mkl70/lib/32/`, `/opt/intel/mkl70/lib/32/libmkl_lapack.a`, `-lmkl_ia32`, `-lguide`, `-lpthread` require the intel compiler. If you want to use gfortran you'll need to figure out if gfortran has equivalent libraries that you can link instead. Do you know what version of ifort they were using? You can try to figure this out for yourself using the [intel mkl link line advisor](https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor).
You should always include all the code required in order to compile your subroutine, and ideally the test program, when asking for help. I had a quick look, but found the style very confusing, and had to guess at what the subroutine is really supposed to be doing. It seems to me that *c_chain%length(c_index)* is accessing the element that is one-past the end of *c_chain%length*, which could easily give you weird errors. Hah. Just noticed that this post is five days old, so you hopefully figured out what the problem was already.
you declared a two dimensional array (rank 2) and are trying to read to it as a one dimensional array (rank 1)
I wouldn't expect boundary issues in Fortran arrays to ever show up when compiling. The best way I've found to check for boundary issues is to include a compiler flag like the one /u/martin_gabe mentioned. Alternatively you can also use `-fcheck=all` if you want to have the program check more broadly for errors during runtime.
If it didn't automatically install the gfortran command you may have to find the executable and create an alias. 
I've now installed gcc using Homebrew and have TextWrangler. But now I'm not sure how to start. I mean I don't know how to run a program from TextWrangler now.
A classic start would be trying out a "hello world" program, to learn how to compile and run a program. So, for example, you could save this code: program hello implicit none write(*,*) "Hello, world!" end program using your text editor as a file with an ending .f90 (for example, "hello.f90") to wherever on your computer you want to keep your practice programs. Then, using the command line (it's not clear to me if you know how to do that, so I'm assuming for now that you know how to navigate to your working directory -- if you don't, you might want to google and go through a short tutorial on using the command line first), you can compile it with the command gfortran -o hello hello.f90 That command, when run on the same directory as a source code file named "hello.f90", creates an executable called "hello", which you should then be able to run with ./hello Once you have worked your way this far -- and don't worry if it seems hard, every one of us has been a novice once -- you can start going through a tutorial on Fortran, writing lots of small programs to test if different Fortran commands work the way you think they work after you learn about them. And after you start feeling comfortable writing Fortran, you can learn about more advanced but useful programming topics like version control and makefiles... but don't worry about those yet, just know that there's a big adventure ahead of you :) 
Thanks, I will look into MPI more.
Thanks, I was not aware of that language feature.
The MPI calls work pretty much the same way in Fortran as they do in C. They only differ on the bindings, but other than it is the same library. 
I'm my experience, OpenMP is far easier to implement than MPI. I would call what OMP does threading, not forking, but it very well could serve your purpose.
Though I support the death of F77 I understand the rationale behind teaching it. In my field (atmospheric modeling) there's still a lot of legacy F77 code in use and actively supported. People need to understand the oddities of F77, even if all the code they write is F95+.
Sure I agree, and there's plenty of F77 code in my field as well, and you do need to know the oddities to deal with it (because chances are if you're ever dealing with Fortran in the wild, you're definitely dealing with *legacy* Fortran at some point.) But if this is an *entire class* just using F77, that's a bad idea. Better off teaching the modern standard, and then some asides about the weird F77 stuff you'll see (lack of dynamic memory allocation, common blocks, goddam 6 letter function/variable names...) 
Yes, your interpretation of the code is correct. To answer your other questions, Fortran indexes starting from 1 not 0. To help figure out your code I would encourage you to add write statements see what the program just read.
Thank you so much. I'm actually just trying to incorporate this into my code which is written mostly in Matlab. I'm not even sure if I have a Fortran compiler (my machine is only running Windows right now), so I don't think it's all that simple for me to compile the code.
Okay, I did figure out how to install a Fortran compiler on my Windows machine, but now I am not sure how to write the matrices out (I'm trying to write each variable out as its own file). I have this: read(7,*) ni, nj read(7,*) &amp; (( x(i,j), i=1,ni), j=1,nj), &amp; (( y(i,j), i=1,ni), j=1,nj) open (unit=9,file="x_results.txt",action="write",status="replace") do i=1,ni do j=1,nj write(9,*) (( x(i,j), i=1,ni), j=1,nj), enddo enddo close (9) But I get an error (#5082) on the write line. Is my syntax bad?
You can. For simplicity I would use open(unit=9, file="x_results.txt") write(9,*) x Also, since you're using the Intel compiler I'd recommend using their online [documentation](https://software.intel.com/en-us/compiler_15.0_ug_f). It's a great Fortran language reference.
Hi, Can't try it now. But, are you sure i is defined as a real? Otherwise, just allocate the array and loop to fill it. I hope it can help.
It's an integer right now. I changed it from real after it said that it was a deleted feature 
This is the best way to do it. I want to emphasise that this is not a problem with Fortran lacking a feature, it's Fortran forcing you to be explicit about what you want, rather than silently giving you an answer that's slightly inaccurate. Making a do-loop or for-loop with floats/reals will sometimes give you one more iteration than you expected, because of rounding error (as you say). Python's range function similarly only works with integers, so it's not one of those instances where Fortran is just being old-fashioned (which does happen sometimes). So yeah, do it with integers.
MATLAB is super pretty easy to write. Fortran is not that difficult, but needs some extra stuff. Computationally, MATLAB is really slow, even for the operations you mention. An ok implementation of the same MATLAB code in fortran, could be 100 to 1000 times faster. Source: my phd source code. Still, first working draft i did was in MATLAB. Really nice debugging tools as well.
I thought about this. I was trying to do it in one line of code. Thanks for your advice! 
My instinct (as seen in my answer to OP) is doing this in an explicit loop, adding 0.1. After I saw your comment on the exact representation of 0.1 I gave your idea a shot. Here's my code PROGRAM loop_one_liner IMPLICIT NONE REAL :: t(101) INTEGER :: n t = (/((n-1)/10.0,n=1,101)/) WRITE(*,*) t END PROGRAM It works as intended, except for 8.4, 8.9 and 9.9, which are outputted by WRITE as 8.400001, 8.900001 and 9.900001. Any idea why?
Hey there! I am an avid Fortran user myself! I would love a promo code for Simply Fortran. I currently use Code::Blocks but was impressed with the style of Simply Fortran. 
This is precisely due to the inability of any computer that represents numbers in base 2 to exactly represent some decimal values. It's like trying to write 1/3 exactly in base 10. The best you can do is write 0.333333... The result you see is correct as far as floating point numbers are concerned. They are the closest representable number to the correct value.
I tried SilverFrost but had the same problem while running the program
If it is a hello world program, I'd be very hard pressed to assume it is a compiler or command prompt bug. Those pieces of software are relatively bulletproof for most everyday use cases (inb4 someone links some obscure bugs for gfortran...). I suggest triple checking your code and making sure *it* is bug free. 
The code does compile, I get: -------------- Build: Debug in holamundo --------------- Compiling: main.f90 Linking console executable: bin\Debug\holamundo.exe Output size is 97.99 KB Process terminated with status 0 (0 minutes, 1 seconds) 0 errors, 0 warnings (0 minutes, 1 seconds) When I execute it the command prompt pops up but remains blank. 
Its free for 30 days, and because its fully self-contained, it'll help to find where the problem is. I had forgotten about Simply Fortran when I wrote my earlier comment, but I will say that its absolutely fantastic. I used it a few years ago for several months and loved it.
If you are allowed to use any fortran functions it's actually pretty easy maxval minval Now if you have to write your own maxval and minval function you have a comparison problem. It's actually a simple procedure. Start with an element compare it to a second element, and winner stays to be compared to the next element in line. 
There's `f2py`for a FFI, but [you **really** don't want `GOTO` statements](https://xkcd.com/292/)
I believe that I had read that f2py is the wrapper of C. I will look in to it!! Thanks. I am working on a program for the pi. So this is only the tip of the problematic ice burg. ;)
"goto" statements should be used only if there are no alternatives. The reason being is that abusing goto can lead to downright unreadable code and it also inhibits the compiler's ability to optimize code. 
Thanks, love the name! 
You shouldn't even need to touch C to use Fortran code in Python. f2py gives you a command line compiler that you can use to generate the Python module files. Then you just call them from Python like any other Python function. Though to talk about your other statement, any language can be object oriented, but the different between C and Python is that Python's standard library was designed with OOP in mind. Though a procedural language structure isn't hard to understand at all even coming from a OOP type language. What can be hard coming from Python however is the fact that C doesn't baby you in the least. It is one of the most bare bones languages out there which means you will find a lot of situations where Python saves you from poor design. 
Yep
Or just remove the advance='no'? 
Looks like ni=1, nj=1 and x and y are 1x1 matrices with the values 75 and 25 respectively for the (1,1) element. If that's not all of the .x the file, I have no idea what the extra 1s serve in the file. Maybe there is a read statement somewhere earlier in the code which reads the 1s into some other variable. Let me know how it goes. :-) 
Ok, so if they can be inlined like C headers then I have reasonable enough understanding of how the values are passed. Funnily enough FORTRAN77 was my first language I learned. At the time I didn't even bat an eye at things like implicit types and other oddities of the language. Now that I know a little more and am writing more complex things, I've recently caught myself saying aloud "Fortran is a weird fucking language" several times. As to your second point, that's hacky and I love it,
Hey thanks for the response. I can write and use subroutines just fine and I understand why they exist. The reason for my post was in attempting to understand where subroutines were on the stack. My initial understanding was that subs were like code blocks that could be called, which in my head meant that they were functions. Obviously they're different and in trying to understand the difference I got a lot of shallow answers since subroutines would be something covered early in learning the language. I simply over thought it and got confused. I do appreciate your response even though it's not exactly the info I was looking for.
&gt; As to your second point, that's hacky and I love it, It's quite hacky, but not in a good way, IMO. I'd love it if the standard were such that my declaring `intent(in)` were ironclad, and the compiler could **optimize** around it. For instance, the compiler cannot fix: subroutine foo(rout,iswitch) real*8, intent(out) :: rout integer, intent(in) :: iswitch do i = 1,100 select case(iswitch) case(1) ... case(2) ... case default ... end select end do return end subroutine **edit**: before anyone jumps on it, the cpu will correctly branch-predict this case 99.99% of the time and there are certainly other ways to structure this, in a general sense. I'm just providing an example of where one would think that `INTENT` would help the compiler optimize a routine, but it in fact does not.
Ok, I think that I misunderstood your question. But I'll point out that I've been writing FORTRAN for about 25 years and never once thought about the stack.
While I would consider my knowledge of compiler design to be above Joe Blow, I'm far from an expert. So take this with a grain of salt... The added ambiguity would be too great to allow that since RETURN is closer to a pure jump instruction than any other language I know. Honestly, with what I learned from you today plus experience, I think it'd be smarter to not allow INTENT in functions than to allow RETURN in a subroutine (even considering it would be removed completely during optimization). It would actually penalize you for knowing more about how the underlying instruction work.
Interesting. I'm the the same boat as you. The more I learn about Fortran and it's compilers, the more WTF moments I have. I'm coming at this from the engineering/modeling side, not the CS side, so a lot of my experience comes from timings and reading through compiler and valgrind reports.
Oh I totally agree with you. Which is why I was able to code it just fine despite the confusion. Really my only motivation for asking this question was because the sources I was brushing up on were saying that they were very similar with out explaining why the two different procedures existed. I guess you could think of it as me asking why do subroutines work rather than how. It was really for assuredness in which was the correct procedure to use in a given context
That's not a Fortran function... If you want to return SQ instead of SQUARE you have to use RESULT(SQ). 
Nvm. If I write contains at the end of my main program I don't have to declare them in the beginning.
Crap, been doing too much Python lately. Thanks.
IFPORT seems to be an [intel](http://wiki.bluemodel.org/index.php/IFPORT) library, so you can either rewrite the code to remove the use of ifport, or use intel compiler `ifort`.
In my opinion, Chapman's Fortran for scientists and engineers is the best Fortran book available.
I'll give a second recommendation for Chapman's book, and then recommend reading Markus's Modern Fortran in Practice. Also, I'd recommend focusing on learning modern Fortram first (at least Fortran 95+, preferably Fortran 2003+ if possible), because that's really what you should be writing new Fortran code in, and then learning as needed how to interface and maintain legacy Fortran code. While modern Fortran is much, much better than Fortran 77 and in a lot of ways feels like a completely different language, it's still simple to interface with legacy Fortran code.
[Modern Fortran Explained](http://www.amazon.com/Explained-Numerical-Mathematics-Scientific-Computation/dp/0199601429/) [Modern Fortran in Practice](http://www.amazon.com/Modern-Fortran-Practice-Arjen-Markus/dp/1107603471/)
I second Chapman's book. Fortran was the first language that I learned. Basically, someone shoved 89 pages of fortran legacy code on to my desk (okay well really they just emailed it to me) and I had to make it work. I didn't know how to code at all and so I used this book to pick up the basics, scoured the internet for solutions the book didn't prepare me for, and eventually deciphered and got the code working. 
Get a used copy from AbeBooks / Amazon. ~$40 USD is much better than ~$200 USD.
The second parameter of the subroutine call Call Calc(Counter,Y(365)) is only the last element of the array Y  i.e. a single integer. You probably want to pass the entire array, like this: Call Calc(Counter,Y) 
it would be receiving a 2-dimensional array and should be declared as a two dimensional array I would also note that I am not fond of using functions to populate an output array
Thank you! I will have to change that.
Looks like I code down for the most part. Definitely not the prettiest code, but it seems to be somewhat accurate. Program Birthday Implicit None Real Lr,Prob,Counter Integer N,L,I1,I2,I3,Day,Seed,Y(365) c Initializing variables Write(*,*) 'How many people are in the room' Read(*,*) N L = 100000 Seed = 2 Counter = 0.0 c Loops Do 10 I1 = 1,L Do 40 I3 = 1,365 Y(I3) = 0 40 Continue Do 20 I2 = 1,N Call Random(Day,Seed) If (Y(Day) .EQ. 0) Then Y(Day) = 1 Elseif (Y(Day) .EQ. 1) Then Y(Day) = 2 Elseif (Y(Day) .GE. 2) Then Y(Day) = 2 Endif 20 Continue Call Calc(Counter,Y) 10 Continue Lr = Real(L) Prob = (Counter/Lr)*100 Write(*,700) Prob,'% probability' 700 Format(F10.7,A) c Write(*,*) Y End c Random birthday generator Subroutine Random(Day,Seed) Implicit None Integer Day,Seed Seed = Seed*3 Day = 365*RAND(Seed)+1 c Write(*,*) Day Return End c Part of probability calculation Subroutine Calc(Counter,Y) Implicit None Real Counter Integer Y(365) c Local Variables Integer A Do 30 A = 1,365 If (Y(A) .EQ. 2) Then Counter = Counter+1.0 c Write(*,*) Counter Exit Endif 30 Continue Return End
Did you install Simply Fortran as what you're currently logged in as? Because it sounds like you don't have permission to modify anything in c:\Program Files (x86)
[If you have questions about a particular function it's best to look at the documentation](https://gcc.gnu.org/onlinedocs/gfortran/SUM.html) It will sum the entire array, but there are other options you can specify as well, such as summing along a single dimension, or sum using a mask. 
If you don't need a particular range in the array it's actually simple sum(x) Done
Yeah, it got adapted so it only calculates the acceleration component from the sun.
Yeah that seems reasonable. I'll try it on my more sophisticated version when I get home.
Yeah, that was it. I'm pretty sure this works. This version is innacurate, but my more sophisticated one uses velocity verlet, so that's gonna be fine. It's a dimensionality issue. I should've carried out a proper dimensional analysis, I think I've found the issue. Thank you!
What does alignparts_lmbfgs.f90 actually include? Can you show us line 105 of it?
Yeah, we need to see the file. Does your code #include "fftw3.f" or #include "/usr/include/fftw3.f"?
This is a (deprecated) [arithmetic if](https://en.wikipedia.org/wiki/Arithmetic_IF) it will jump to the given labels depending on the value in brackets. Thus, your first statement will jump to label 4 if DR1 is smaller or equal than 0, otherwise it will jump to label 5.
Seconded. Can confirm that code will not survive a trip through a fortran compiler with any way to identify it except for dental records. Tcl looks plausible to me, too? (not my expertise)
It looks to me like a Tcl script intended to be run in the interpreter inside VMD, which is computational chemistry software.
Hello, Intel provides free, non-commercial version of their fortran compiler for students. If you are one - try it out.
If you are not into HPC, you can try the gnu compilers, gfortran [https://gcc.gnu.org/wiki/GFortranBinaries](https://gcc.gnu.org/wiki/GFortranBinaries) You can either download only gfortran, but as I can see the binary is a bit old &gt; Unofficial build of current development (GCC 5) source. Download the latest installer (dated 2014-06-29). It's very easy to use (basically, just click on the OK buttons), but some detailed info is also available. These binaries work on Windows XP and later versions. old download the whole gcc package. [http://mingw-w64.org/doku.php](http://mingw-w64.org/doku.php) From the downloads page, download *Mingw-builds* TL.DR: Download link [minGW-w64](https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download) Version: If you do not have any reasons, select the latest Architecture: I guess you have 64 bit machine so select x86_64 Leave the defaults for the rest Then you need to add the bin folder to the PATH. For windows 8.1, go to my computer right click -&gt; properties left side column -&gt; advanced system settings system properties -&gt; Advanced -&gt; Environmental variables Either on User variables for Username or System variables find on variable column a variable named "Path" and click edit, if you cannot find it (for User variables for Username, on the system variables it has to be there) you can select New then on Variable name it should be "Path" (without quotes " ) Variable name: add the installation path with the \bin at the end. e.g. for the default path. C:\Program Files\mingw-w64\x86_64-5.3.0-posix-seh-rt_v4-rev0\mingw64\bin; Then, if you want to compile, open cmd (command prompt) on the folder you want, and type gfortran -o test.exe test.f90 Or you can make a file e.g.: compile.bat and inside type gfortran -o test.exe test.f90 pause -1 test.exe pause -1
&gt; If you are not into HPC So if you *are* into HPC, what's wrong with GNU Fortran? Not optimized for the hardware?
Thanks for the detailed answer. I do use gfortran on my linux machine for prototyping, but on the HPC clusters I use ifort only because it was suggested to me (for runs that generally take about 48 hours) but I was not sure exactly why it's better. Generally I understand that vendors of hardware release their own fortran compilers which optimize performance. 
That's right - university. I have been using f77/g77 for so long it was natural to use gfortran rather than ifort, and also because there it's only a short prototyping simulation. Oftentimes the pressure to publish is great and I have other projects which do not involve supercomputing, so often I don't have much time to play around with these optimizations (also because I am only learning about them - I wasn't trained in HPC so my learning of it has been very ad hoc).
I see. It makes sense if it is not your main project. Then you can just download ifort, install it and give it a shot to time the difference. It might save you some time, with almost no effort. *If you are in UK, then http://www.archer.ac.uk/training/ have some training around UK.* 
Sounds good - thanks for the reference. Unfortunately, not UK... but I do intend to sit down and learn more about compliers and HPC (also MPI) when I can set aside the time...
Then allow me, some of my bookmarks about fortran which might be helpful. Since fortran is not so popular outside academia, I find it pretty hard to find information. http://www.archer.ac.uk http://www.fortran90.org/ http://www.fortran90.org/src/best-practices.html https://gcc.gnu.org/onlinedocs/ http://beam.helsinki.fi/~saparvia/fortran.html http://iprc.soest.hawaii.edu/users/furue/improve-fortran.html https://software.intel.com/en-us/compiler_15.0_ug_f (Intel's compiler manual has a lot of information) https://software.intel.com/en-us/articles/fortran-array-data-and-arguments-and-vectorization ( I haven't read that yet. ) Also, university has a lot of workshops/seminars, which I sometimes attend. Usually the instructors will also answer general/relevant questions as well.
Many thanks! So you are not in academia? On a basic level, I have enjoyed transitioning to Fortran 90+ and writing small bits of code for desktop simulation (though 90% of my time is spent in R/Python). It's a beautiful language, especially in its modern incarnation. Looking forward to scaling up.
There's absolutely nothing wrong with gfortran for HPC (especially more recent versions), and for many people, the differences between it and ifort are probably small compared to the performance gains that could be garnered by writing better code. If your code is already optimized and you have a large budget to buy compiler licenses, then start worrying about the small percentage improvements that a slightly better compiler can get you. In terms of performance differences, I've usually seen somewhere in the single-digit percentages for the code that I write. Unfortunately, there aren't very many systematic benchmarks between the two compilers (see [1] or the fortran.uk link that another commentator gave for a couple of options, with varying results). It is worth noting that Intel's compilers do have decent auto-parallelization that can really boost performance, but if you're doing HPC, you're almost certainly writing your own parallel code anyway. What does make a large difference, in my experience, is using optimized math libraries. The difference between using Intel's MKL and something like ATLAS can be huge. [1] http://www.nersc.gov/users/computational-systems/retired-systems/hopper/performance-and-optimization/compiler-comparisons/
It's just a warning not an error. Do nothing?
Just remove the argument from the subroutine definition. If it's not used, it doesn't need to be there, and if something doesn't need to be there it *shouldn't* be there. It's misleading to have an unused argument.
Eh, I like the standard software engineering advise of "compile cleanly at all warning levels." This warning is a flag of an easily fixed ugliness in the code.
Is using the `optional` keyword possible for your uses? Perhaps set `d` and `e` as optional, and invoke `e` with a keyword call mysub(mya,myb,myc,e=mye)
The thing is that the interface to the main program is fixed. That's why I can't remove it. I don't need it for this subroutine however. Additionally, I am not the maintainer of the main program. 
Yeah, but that's not what I want to do. It works, but it isn't clean.
I couldn't figure that quite out. The warning is showing nevertheless. I was using here: integer, optional, intent(inout) :: d where d is the variable 
The "good" solution is to fix the original interface -- anything else is sub-optimal. The reality is that you do actually have an unused variable, so unless you fix that, anything else is a hack. &gt;if (.false.) d = 0 where d is the variable should be suppressed. Not sure if this is a good solution. Philosophically I don't like this. You've just added a totally meaningless line of code just because an unimportant warning is bothering you. I'd rather have an unimportant warning pop up than to have something meaningless inside my actual code. Code is the thing that actually matters, don't start butchering it for the sake of the build tool. If the subroutine is off in its own file, I have no problem with specifying only for that file -Wno-unused-parameters. What's the problem there? It's either that, ignore those warnings when they pop up, or make a code hack. There is a gfortran preprocessor statement that is *supposed* to work but isn't implemented: !GCC$ attributes unused :: d
Right next to "Poverty Party." Man, casinos are just vile nightmares.
Yes, could you please elaborate. I downloaded both MS visual studio and the Intel compiler package but I just have no idea how to compile still..
I'm pretty darn new to this, and have very little computer science background so I'm wondering if you could elaborate a little on installing gfortran through Cygwin 64 if you know how?
No, you can use assumed-size arrays like this in your subroutine: real, intent(inout) :: temporary(:,:) integer n1, n2 n1 = size(temporary, 1) !Number of rows n2 = size(temporary, 2) !Number of columns (I prefer to declare arrays without the dimension attribute, but you can do it that way too) Fortran stores meta-data with arrays (unlike C) so you can query information such as the size or starting index.
Are there any Fortran searches you perform regularly that we could answer in fewer clicks? Any APIs that would turn into an IA? We want help submitting actionable feedback to the current developer for things that would benefit the Fortran community :)
Are the links above a way for us to help/become involved?
Fair enough. What compiler flags would I use to warn/report when I'm attempting to query an undefined pointer?
In GFortran `-fcheck=pointer` but apparently they have yet to implement it for undefined pointers... since GCC 4.5
That and compiler dependent bugs and behaviours.
The main problem with Fortran is not the language itself, but that it's used by loads of people who barely know how to program. While I suppose it's a strength that it's straightforward enough to be used without much understanding of coding, it's frustrating to get a program that's a single 10,000 line file, filled with GOTOs for loop control. You can use GOTOs in C as well, but people know they should actually use them. Not the case in Fortran...
From what I understand, which kind-values correspond to what data types has not been standardized; so you have to use either the selected_real_kind function or the iso_fortran_env intrinsic module to be guaranteed standards-compliance and portability. I wish that the Fortran standard could have defined that a real(4) was a 4-byte real and a real(8) was an 8-byte real, so that you could safely write: real(4) :: single real(8) :: double Instead of having to always do: use, intrinsic :: iso_fortran_env, sp =&gt; real32, dp =&gt; real64 real(sp) :: single real(dp) :: double I also wish that there had been some standards-compliant way of doing conditional compilation in Fortran. Since CoCo was withdrawn from the standard, and using a C preprocessor is technically nonstandard, the only way I know to e.g. perform assertions in a portable yet performance-effective way is to define a parameter debug=.false. that you manually set to .true. when you wish to execute the assertions, and hope the compiler understands it can optimize away the code. Another example is that I like to colorize and format my program output using ANSI escape sequences, box-drawing characters, and special escape sequences like '\r' when using Linux/Unixbut these often work badly if you try to run the program from cmd.exe in Windows. Instead of either removing the formatting entirely, or telling Windows users to manually disable some boolean flags in my Fortran files before compiling them, it would be useful to have a standard way of doing conditional compilation, and just let CMake enable/disable the flag depending on the operating system.
Here's a minimal recreation of one of the most annoying bugs I've had the opportunity to troubleshoot in my own code. The real code, of course, was far more complicated, and it took me longer than I care to admit to figure out _why_ the loop in the main program wasn't working the way I thought it should be working. program demobug implicit none integer :: i do i=1,5 call print_one_to_n(i) end do contains subroutine print_one_to_n(n) implicit none integer, intent(in) :: n do i = 1, n write(*,"(i0,1x)",advance='no') i end do write(*,*) "" end subroutine end program 
Did you even attempt the question? At least find your bloody equations.
Had to teach an exercise for some undergraduates. Some produced the following very expressive code. You are welcome to find out, in which flag constellation which code blog triggers. if (flag1 .eqv. .True. and flag2 .eqv. .True.) then ! do A else if (flag1 .eqv. .True. and flag2 .eqv. .False.) then ! do B else if (flag1 .eqv. .False. and flag2 .eqv. .True.) then ! do C else ! do D end if 
I really hate the fact that sometimes all you get for your troubles are a bunch of \*\*\*\*\*\*\*\*\*\*\*\*
I had a similar error to this when I first started using fortran. It didn't affect me until I tried it with modules.
Definitely not how I would write it  actually, I have yet to find a use for `.eqv.` at all in any of my code... However, I tried compiling and running that code snippet, and I still don't understand what goes wrong. Apparently, only the bodies of the first two if-tests are run; e.g., setting `flag1` and `flag2` both to `.false.` makes the first test succeed, while replacing the test condition with `flag1.and.flag2` gives the expected behaviour. Could you please explain why this snippet fails?
Do you have the HiTranCO2.txt file? 
I don't have the exact same one that they had, but I do have another one that I believe should still work. When I downloaded it from the HITRAN website, I made sure to set the number format to the same as what was described in the code. That is [Mol,isotope,wavenumber, S,Transition Moment, air width,self width] are [I2,I1,F12.6,E10.3,E10.3,F5.4,F5.4] respectively. However, I should probably mention that there were a lot of other parameters that I could have included in the data file (thus making more columns), but I didn't because it didn't seem necessary. Could that have made a difference? It doesn't seem like it would.
I got it to compile: save the file extension as .f90 and comment out the two optional timers- et=TIMEF() !optional timer It gave a bunch of warnings but it compiled with both gfortran and ifort. Hope that helps! 
I presume you're reading that file line-by-line. Mod the code to echo each input line back to the screen (or another file) so you can locate the error (if there is one) in the input file. As described, this runtime error could be caused by reading the title line (if there is one) as a data line. 
I didn't mind using Forge2.0 when I wanted to run simple but fast numerical programs.
Gfortran?
Also, he should do the simple optimization and provide indication of distance away from the best solution. 
Is there a reason why you have to run it through Wine? I don't think I've ever encountered Fortran simulation code that depend on a specific operating system. Do I understand correctly that on Linux you cross-compile a Windows binary, which you then run on another Linux system using Wine?
It was, I ended up switching compilers and copying over a few libraries to wine and it solved the problem. I needed some visual runtime libraries originally, some of which are not supported in wine.
Thanks, but still it is fetching same error even after I updated istep=istep+1 after end do
I think /u/nre_drums meant that you're not updating x0, x1 inside your loop correctly.
They're right. `x1` is only updated once. On the line x1=x0-(f(x0)/fd(x0)) But you want this to happen for every iterations. So you need to move that within the `while`. Make sure you see why that's the problem. For example, this "version" works: istep = 0 x1=x0-(f(x0)/fd(x0)) do while (abs((x1-x0)/x1)&gt;error) write (*, *) x1, f(x0), fd(x0), abs((x1-x0)/x1) x0=x1 x1=x0-(f(x0)/fd(x0)) istep=istep+1 end do See how you can improve on it, to avoid having to repeat the assignment of `x1` outside the loop.
Thanks a lot.
What did you try, and what is the problem? The program with the do-loop does not contain any code to check if the input is valid, while the loopless code does.
The problem with do loop code was it does not ask for another values of a and b, when I give the input a=3 and b=5. I am not sure which command to sure and where to put in do loop so that it asks for another values of a and b ? , just like this command in without do loop program - 15 if (f(a)*f(b) .lt. 0) then c=(a+b)/2.0 else write(*,*)"Try with another values of a and b"
Sorry, but it's not working for me. It's giving me same result as before.
For mathematical work it is always advisable to use selected_real_kind as "real" is not well defined , afaik. For example: &amp;nbsp; integer, parameter :: dp=selected_real_kind(15,300) real(kind=dp) :: x, y, z This gives you x y z which will all have 15 s.f. and can range from 10^300 to 10^-300 guaranteed.
Plenty of people use gotos in C all the time, they just call the gotos "pointers" and consider themselves really awesome coders for using them as much as possible. 
You should not be using Fortran to do this. Look into bash scripting (if you are on linux/mac) or batch scripts if you are in windows 
This reminds me of that web dev with assembly fake O'Reilly book
So Web developers can enjoy everything that fortran has to offer too! *shudders*
As someone else mentioned, this is not really a Fortran question, but I'll give you some hints anyway. If you want a program to run every time you start a new terminal, you would usually put the appropriate commands in the file .bashrc in your home folder, assuming that you use bash as your shell (the default for most linux distributions). A really primitive password lock could then be implemented in just a few lines of bash scripting in that file: echo -n "Password: " read answer if [ "$answer" != "test" ]; then exit fi This should close the terminal if you enter a password other than 'test'. However, in general, I wouldn't recommend relying something like this for anything important  with this example, you could just press Ctrl-C to circumvent the password check, and you always have the possibility of e.g. using other shells than bash. If you need this as a security measure and not just for learning, you should probably look for a more robust approach than a homemade terminal password lock.
Kind of subtle, great example. May be teaching some undergrads myself soon, nice example that computers can't think like people!
In context it clearly looks like a matrix vector multiplication, but the syntax (I think) is not standard compliant. Do they mention anywhere what compiler they use? When I see weird stuff in older code I wonder if it's a vendor extension. 
Yeah I figured it looked like that, and nah, they don't mention a compiler, just that the code provided is Fortran. Cheers for the input though!
Are you sure this is standard Fortran 77 and not some weird variant, or an older version? Something like F=MPY(A,S1) would make more sense.
I'm a tad frustrated I didn't pick up on that earlier. It wouldn't be the first time I've come across this heh. 
Huh, turns out you are right. It's defined in one of the modules. Incidentally, it seems as long as I linked them, I don't need to explicitly use or include the .f files that contain the function definitions. edit: I forgot. Thank you for the help.
&gt; Incidentally, it seems as long as I linked them, I don't need to explicitly use or include the .f files that contain the function definitions. That doesn't sound right. It's probably defined in a module you're `use`ing somewhere.
Can you use something like gprof to see where most of the time is spent?
This type of thing can be very dependent on details. Is this a serial code? Which versions of ifort? Do you have access to a cray compiler? What hardware are you running on? Are simd instructions being generated correctly? What about aligned vs unaligned loads and stores? Can you post the codes somewhere?
That is indeed strange behaviour. It may be that C++ is caching the data more effectively? Would your problem size approximately fit in the cache? Vectorization and parallelization are, imho, more easilly done in C/C++, because one can specify the memory alignment. This can be done in Fortran, but it relies on allocating a C-style pointer often with calls to C. For example: http://fftw.org/fftw3_doc/Allocating-aligned-memory-in-Fortran.html#Allocating-aligned-memory-in-Fortran For OpenMP, one can use local-scope variables in C/C++, which means that one doesn't have to declare things private all the time. If you're really looking for performance and vectorization/parallelization, OpenCL is a really interesting choice; it's a C-like language that runs on CPUs and GPUs. This could be very interesting for a PhD project - GPU is quite hot these days, and there seems to be demand for people who can code for GPUs. If your supervisor is planning on using Fortran, then I would probably go with that as well. It's for sure good to know multiple languages, though, and kudos for moving to OOP.
Yeah, I'll be using CUDA C and CUDA Fortran, MATLAB for prototyping. Though there might be the possibility to work with OpenCL and C++ because he wants to make an open source package for solid simulation. I don't know how I'm gonna fit all that into 3.5--4 years, and without a master's degree, but they believed in me enough to offer me one of the two places they had available this year. As you might imagine, I'm terrified but excited. And your answer pretty much just told me what the problem is. My data is not alligned, I have allocatable arrays. The C++ code uses the C++ equivalent of the method mentioned in your link. This also explains why the difference is greatest in procedures with heavy data access and little maths, and also why the subroutine that is considerably faster in Fortran is the matrix solve, and why duplicating changing variable precision only increases run time by 10 to 20% rather than doubling it.
Aligning arrays isn't necessarily that bad in fortran ifort -align array64byte or real :: A(1000) !dir$ attributes align: 64:: A [src](https://software.intel.com/en-us/articles/data-alignment-to-assist-vectorization) Not that I disagree about using C++ mind you, it also make intrinsics much easier. FYI: latest versions of OpenMP can also target GPUs
I mean the order of your inner and outer loops. If you use the same notation for both C++ and Fortran, then one of them is calling an array out of cache, due to the difference in which both languages store arrays (row vs. column major). [This](http://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays/) article discusses the importance on performance.
I'm aware of that but i also mapped the matrices/grid to 1D arrays.
I'd be very interested in seeing the source.
Yeah man i'll finish it off, try to fix by implementing the suggestions people made it and clean it up, it's a mess right now. But [here](https://github.com/dcelisgarza/applied_math/tree/master/fluid_dynamics/fscg/matrixless) you go, this is the OOP one, the other one i haven't really finished and is slower. The relevant files are fluid.f08 and test_fluid.f08. Using [this](https://github.com/tunabrain/incremental-fluids) as my guide.
That's right. AFAIK : You can use a function or subroutine as long as it is defined somwhere in your source code and not contained within any other program unit(so not linking against subroutines that are contained in modules or other subroutines). If it is not available at link time, you get a linker error. Note, if you do this, the arguments are not checked. (if you define your function for a real but call it with a double bad things happen, the subroutine will probably interpret the bits of the double in some strange way.) Also you can't use certain features of Fortran 95 like optional arguments. To avoid this you can either explicitly declare an interface for that subroutine (possibly in an include file that is included in any subroutine that calls your subroutine) or by putting the subroutine in a module and **using** it. 
Part of the problem is, as a novice, I'm not really sure what it means to link. Like, I always got the impression you need to include some library before using their functions. Turns out it's wrong.
&gt; I'm not really sure what it means to link. Compiling is done in two steps. First is compiling: The compiler takes a source code file checks it for syntax and other errors it can detect, optimizes the shit out of it and translates it to machine code. This is normally done by compiling with -c and creates an object file so commonly you name the resulting file with the ending .o . Linking means taking all those object files and concatenating them to one executable. Also when one function/subroutine calls another it has to know where that other is located. So the linker puts a pointer to the other function in there. But the linker does not check if the given arguments are the expected arguments this is only be done in the compiling step. But only if the compiler knows the expected arguments either via an interface in the file/an include file or via a module file that takes the role of an include file. If you use a library you need the include/module files for the compilation step and the object files for the linking step. Sometimes libraries files/folders are not explicitly mentioned in the command line argument you use to execute the compiler because their files are in default paths of the operating system. 
What exactly are you curious about in this code? The use of GOTO or on a basic level, more how to read this terrible code? I know this is likely Fortran77 but that should not excuse the overuse of the GOTO commands used within.
:P
Just thought of one: Are J, M, K, L, R, etc. variables, or just something in Fortran itself?
What's your CS background? It seems to me that you're hitting loop unrolling on the looping tests and that's why it's weird. Also, C++ is probably faster in non vector operations because it's more bare metal than Fortran. As far as I know Fortran only does better then C/C++ on vectorized/vectorizable operations and even that is open to debate nowadays with C's *restrict* keyword and compiler improvements. 
It's all a matter of your actual setup. Without seeing the code it's hard to make any use of your post or provide feedback.
I'll see if i can clean it up a bit 'cause the older versions are a fucking shitty mess and i've made some more optimisations that i'd have to roll back and patch from various past github commits.
I'll be using GPUs for my PhD. Most likely i'll use BLAS as well because i'm gonna be dealing with millions of atoms. I'll definately look into your advice. Thanks for the lengthy response, i really appreciate it. That's a lot of very useful info for me!
Yeah man you hit the nail on the head with this response. I'll use CUDA and work with MATLAB. I also knew about the data copying to and from the GPU. Bit it's good to know there's cuBLAS definately something i'll look into.
http://lwn.net/Articles/250967/
For those of us who use modern Fortran daily, this is the equivalent of someone going into a tool store and being amazed that people still use screwdrivers. Seriously though, I'm glad you're looking at Fortran. I wrote many cgi scripts as a grad student in Fortran (1998-2005), directly interfacing a model that I ran often. It would generate output images and a perl CGI::pm script would be used to glue things together "nicely". Just one quick plug: Fortran is blazingly fast for floating point calculations. If you need to crunch a lot of numbers and need to do it fast, it's the only language to use. 
@kylerean - I hope I didn't come off as condescending. This journey started as a bit of a lark, I'll admit, but I really like this language and where it is going. I can't wait to try and build my actual web framework!
I wouldn't recommend a web framework on fortran. I've had a ton of issues with strings. They're better now in gfortran-6 but still clunky as hell. However, I too like the way fortran is moving. It's a fun and easy language, and its OO capabilities are rapidly converging to C++'s, though compilers still have to optimise and fully support some of the more modern fortran features.
I'm a big supporter of Chapman's Fortran 95/2003 for Scientists and Engineers.
&gt; it's arguably the simplest language to learn -- it has a lot less depth than other common languages I don't think that's true. It has pointers, OOP, user defined types, everything you could want really... Just most people don't ever end up using them. 
Fortran compilers can often put checks for invalid indexes etc into the executable if you compile it with the right options
I get a ton of warnings when compiling. All about a possible change in value when converting from some combination of real, complex, and integer. Still get a segment fault when trying to run after that.
TDM-GCC-32 which I think is a variant of minGW. It is what was included in the instructions for how to run the program so it should be what was used previously. 
Since you're doing physics research I assume you are pretty decent at math. I taught myself to program using Fortran by solving problems on projecteuler.net You can find solutions other people have posted that will help you understand the language a bit better by reading through the comments on the site or by looking on github.com for "project Euler" and specifying the Fortran language. I think reading a book is great, but working problems will really cement the concepts in your mind (although working problems from a book would have similar results to the website)
I will say writing efficient Fortran code is way easier than writing efficient C code. I think that's a major reason many (non computer) scientists use Fortran instead of C with the restrict feature. 
In my experience the Intel Compiler blows away the GNU compiler when it comes to Fortran. You may want to double check what you are using to optimize the code. 
Yes, but now you do not have to worry about all of that you can just do: `gfortran &lt;options&gt; module1.f90 modeul2.f90 .... main.f90` making sure that the files are ordered with any dependencies coming before usages. This will generate an executable: `a.out`.
I asked this question over at /r/GPGPU; thought I should put a link here. Please post comments on /r/GPGPU (the link above), and not here.
Yes. See for example https://cds.cern.ch/record/2062033?ln=en PGI also seem to have some collaboration with nVidia: https://developer.nvidia.com/cuda-fortran
Yea, nvidia bought PGI. I think it's safe to assume nvidia will continue to push GPGPU computing via PGI's compilers. OpenACC is free on Linux, which can be used for Fortran.
The documentation and release notes state that "the compiler FTN95 provides some Fortran 2003/2008 features", I don't know which ones though. Personally, I hadn't found a free compiler to test out Fortran code on Windows (TDM-GCC is ok usually, but the latest has a Fortran bug in file reading). Found a list of some extensions: http://www.silverfrost.com/ftn95-help/netprog/f200xextensions.aspx Any 03/08 extensions that you use and are essential? I'd be curious to know. 
That's really neat. I have been using ftn95 on and off over the last 8 years, mainly to ensure that the code I write conforms to the standard and to weed out the more tricky bugs. Ftn95 will never produce the most optimised object files, but it will catch a lot of corner cases and a lot of incorrect code usage that Intel etc. tend to ignore. Having it for free for personal is just icing on the cake. 
Lol no it doesn't, and I'm a Fortran programmer 
If you like Fortran 77, wait until you try the newer stuff. 
What I took in college. I still gave the book. I am doing Java and C# at the present
Seriously, try modern Fortran with array operators, even co-array Fortran. Moving from fixed-format Fortran 77 ASAP is the best thing to do.
...and the author of Simply Fortran tends to hang out here (that'd be me!).
The matrix/vector stuff isn't even in FORTRAN-77 - that was added in Fortran 90.
deadly, thanks.
Being able to pass in a 1d vector and shape it to a multidensional array
In general the handling on of vector/matrices and also complex numbers. The type system might not be the best (nothing can beat Haskell here in my opinion), but I really like that it is statically typed ... tried it several times, but I just cant work with a dynamically typed language. Oh and it's really great that Fortran has OpenMP support.
I just find that C is so much more *cryptic* than Fortran. For example, to write a line in C, the code I'm using does something like this: fwrite(block, sizeof(block), 1, f); I'm writing some analysis &amp; initial conditions routines in Fortran, and the same thing is just: write(10) block 
In addition to the other comments: It's very fast for floating point operations. Also, no need to fully capitalize the name: Fortran. I like the dead simple array allocations, statc typing (although you can dynamically type, it's just poor practice). Lots of support for science/stat/math libraries. Integration with MatLab/Idl/Python. It's truly a modern language for science and fast computation. Edit: i don't know the difference between dynamic and static/implicit typing, my mistake remains. 
All of the things you can do with native multidimensional arrays. Slicing, strides, masks, all working transparently throughout the code. Nothing in C++ libraries comes close. Module system is okay, but it gets abused a lot and doesn't have any advantage over singletons in other OO languages. 
+1 for openmp. It took me a day to learn everything I needed
Array slicing, reshaping, and matrix operations and the like. I suppose it was the original bread and butter of the thing. Pretty much the only reason I use Fortran over C for my "scientific computing." I'd also mention portability, for what it's worth. Gfortran and ifort are available on several platforms and the code almost never needs are alterations, especially for the kind of code I/we do.
The nice thing about Fortran is that it has a lot of the benefits of coding in C, without a lot of the same headaches. 
integer division and the built in function "mod".
So for example, if the given number was 47689, you want to print the even digits 4, 6, and 8?
Yes thats what i want
Thank you sir
So you're the notorious hacker. 
You said it: OpenMP and the fact that FORTRAN has the vector / matrix at the base of the language. I would add also Array slicing. 
I'm relearning fortran for a math class. All the java fanboys think I'm crazy but I'm loving it (I'm also getting to be a bit obsessed).
Nitpicking a bit, implicit typing is still static typing, it's just selected by the variable name and not by a keyword.
Me too, these are the two languages I'm learning - python and Fortran. Interesting contrast and I have to say, for numerical analysis I do like Fortran more thus far.
Fortran has got some really great elements. 
I have learnt using compiler flags luckily, is it worth learning python as well or will that complicate things?
Yeah I've had a lot of stick from people for learning fortran and not java! What is there issue! Can't they see the mathematical beauty in fortran 
So I'm told that goto statements are bad practice and frowned upon (I'm somewhat agree) but people who use c++ disguise them as pointer statements, what problems can be caused by using goto's?
Fortran arrays are better though, because you can do `C=A*B` in Fortran but not in C++, where it's something like: long i,n=a.size();std:vector&lt;float&gt; c(n); for(i=0;i&lt;n;++i)c[i]=a[i]*b[i]; That gets old quick.
is there a big difference between `&lt;vector&gt;` in C++ and an array which you size by `dimension` in fortran?
Allocated arrays are very much still the best practice for Fortran. Array pointers are most useful as dynamic aliases to array sections when a particular section is referenced frequently (or referenced as part of a dynamic data structure). Fortran pointers in general are best used as tools to make dynamic data structures. Allocatable arrays in Fortran are *very* useful as is, and for linear algebra problems, there are very few reasons to avoid using them.
Yeah that makes sense 
Quite a big difference yeah. Unless you tell the compiler different, the memory for arrays with a size defined using the dimension keyword will be allocated in the stack. The size of the stack is often very limited compared to the size of main memory(the heap). Either way, fortrans arrays are contiguous in memory. The &lt;vector&gt; type in c++ is not, and you will incur a performance hit when looping through. It does however have a lot of helpful features that would be cumbersome to achieve in fortran e.g. dynamic resizing. 
Yeah seems about right. Have you messed around with Julia? I'ts supposed to be a good balance of performance and ease of writing. Somewhere in between what you and I are talking about.
I haven't had much need to explore it just yet. But it does seem interesting 
&gt; The &lt;vector&gt; type in c++ is not, and you will incur a performance hit when looping through. Uh no. &lt;vector&gt; is guaranteed to have contiguous storage. https://isocpp.org/wiki/faq/containers#vector-is-contiguous
That worked! Thank you. While I have you here: if I wanted the program to go back to the top after performing a chosen calculation, how would I go about doing that? Can it be achieved with a do loop? 
So just for clarification all I would have to is put a do statement before each if block? or just put a do statement before the whole code block starts and an exit statement after each if block? I'm kind of confused as a I am extremely new to this and have only a seen a do loop do an equation a set amount of times. Could you perhaps provide me with some examples? 
Do you have any good examples of this? 
The only difference between the "normal" do loop, such as do i=1,10 write(*,*) i end do and the "infinite" do loop, such as do write(*,*) "Hello" end do is that the latter one keeps executing the code inside the loop endlessly, unless an _exit_ command is executed inside it. So for example, do write(*,*) "Enter y to quit the loop:" read(*,*) choice if (choice == "y") then write(*,*) "Ok, quitting." exit end if write(*,*) "Okay, not quitting yet." end do write(*,*) "Exited the loop" keeps asking whether it should quit until the user replies "y". I hope this clarifies things. 
Yup that worked, thanks again! 
Second the Doxygen recommendation. It has Fortran support out of the box, and call graphs can be generated if [dot](http://www.graphviz.org) is also installed.
Wait, what? Doxygen is a documentation generator, it's not a static analysis tool. Yes it can generate call graphs BUT that doesn't make it an static analysis tool.
Well I don't know details about Understand (you can check the "Features" section on Wikipedia), but static analysis tools does a lot more than drawing call graphs. Usually they signal possible errors in code and get various software engineering related metrics. You can see this [wikipedia article](https://en.wikipedia.org/wiki/Static_program_analysis) for more details. Doxygen on the other hand, uses special code comments to create documentation. It knows a bit of the language and can create said call graphs but it isn't capable of doing much more than that.
I've been using [Eclipse with Photran](http://www.eclipse.org/photran/) for my advanced Fortran needs. Unfortunately it's still rough on the edges, but it's the closest to a real OSS Fortran IDE I could find.
that worked but now im getting an unclassifiable statement at 24:1 
See https://en.wikipedia.org/wiki/IEEE_floating_point#Basic_and_interchange_formats Short: real (= single precision) uses 4 bytes per number and gives you roughly 7 decimal digits precision, whereas double uses 8 bytes per number and you get about 16 significant digits In Fortran youd have to use 'double precision' instead of 'real' in the variable declaration. Furthermore you should define any constants as double precision numbers, i.e. 2891000.d0 (instead of 2891000.0 or 2891000.e0 which would be single precision by default with most compilers).
Thank you! This is what i was looking for. I do have one question though: say nlines at the end of the do loop is 1200, how do I set that value to the parameter ndp, which is the parameter used to initialize the size of the array?
Why are you trying to use a parameter to achieve this ? It could be easily done just with an ALLOCATABLE array and use an ALLOCATE statement after you scan the file to initilize it to the requiered size.
You can't change a parameter, but in this case you would probably want allocatable arrays. For instance integer, parameter :: dp = kind(0.0d0) integer :: nLines real(dp), allocatable :: data(:) allocate( data(1:nLines) ) That would be your best course of action for this. Parameters for arrays are good for quick codes that you only intend on using once or twice, but for long term codes they aren't all that great. That and if you plan on using Fotran for heavy coding in the future then you will need to learn how to use allocatable arrays. 
I'm hesitant about dynamic arrays because the package i use doesn't let me use them as global variables. I have about 20 different arrays, and each array would need two coefficients for interpolation function. That means 60 dynamic arrays that have to be defined multiple times in one code :(
I see you have your depth layers declared as INTEGER literal constants (numbers without decimal indicator), therefore the computations are being performed in default kinds integer aritmetic first, then transformed to floating point for the rest of the calculation. Your numbers are big enough so that the intermediate integer aritmetic overflows for the default kind of your compiler. Write every depth value (or any continuous value for that matter) ending with a ".0" to declare them as real literal constants and compile again. 
When being new in coding as you say, I think that every *don't want -&gt; try to circumvent* situation has to be considered a challenge that needs to be met and taken. Break down the situation you are having. Identify exactly &lt;what&gt; you need the code to do. Try to implement it in small steps (on paper first). You already became better at coding. Edit: I feel that you are trying to ask on how to create a dynamic filename, so you don't overwrite old output files when you rerun the same .exe(cutable). Is that it?
If you insist on having a parameter, the following workflow could work. In your code, that is ".F90" (uppercase F will trigger the preprocessor) integer, parameter :: nrows = NROWS real :: myarray(nrows) and then compile the code with a macro definition $ gfortran -o my_program my_program.F90 -DNROWS=20 $ ./my_program If your datafile is well formatted, you could even do it in one go using wc $ gfortran -o my_program my_program.F90 -DNROWS=$(wc -l datafile) $ ./my_program 
You could add another branch to your IF block ... write(,)"Input depth(m) d, negative value to exit" : : ELSEIF (d &lt; 0) THEN EXIT ENDIF Last statement leaves the DO loop, you could even label the construct for more clarity (and you can exit from any depth of nesting using labels). Other things to note: use IMPLICIT NONE and declare every real value with an ending decimal point.
So I would need an additional ELSEIF with the option to exit by giving a negative value to each different pressure calculation? I was kind of looking for something more general, not specific to this program, as I want to add it to a few other programs. I also don't really understand your second note, what does adding implicit none do? 
if you are trying to compile the entire fortan 77 code try this: gfortran Old_Code.f77 -std=legacy If you just need to call a function from a program: function pot_jensen89(poth20.rx1,rx3,xm10,xm20,xm30) !whatever the original function declaration was end function pot_jensen89 Program Jensen !These are comments !do whatever calcluations/data entry you need to get the numbers answer = pot_jensen89(poth20.rx1,rx3,xm10,xm20,xm30) End Program Jenson this should be enough to get you started. I would recommend looking up function and variable declaration if you get stuck. Fortran 77 may also give you some grief when it comes time to compile with gfortran. And finally the best advice i can give is Stack Exchange is your friend."
Implicit variables is a little bit of a hold over from the early days of Fortran. It allowed you to define variables without having to declare them which in the early days when you were using punch cards was quite useful. However in the modern day it's generally bad practice to define them implicitly and if you aren't aware of the naming rules it can create problems. So it's best to declare "implicit none" and just explicitly declare all your variables. 
The format statement 5 FORMAT (6F8.2) is designed to write 6 reals. This is what the 6 in the 6F8.2 means. If you want to output 5 reals at a time then you need to create a new format. The command will look like 200 FORMAT(5F8.2) Then in the lines where you write T(6) - T(25) you should use the statement WRITE(6,200) T(6), T(7), T(8), T(9), T(10) etc
Graduate studies in mechanical engineering! Specifically, I work with the boundary element method, and a bunch of old programs are written in Fortran and Fortran 77! I also use C++ and MATLAB/Octave, specially for plotting. 
I work as a researcher in hydraulic engineering at university. Our research group develops since 15 years a finite volumes code for solving shallow water equations. A few years ago, the code has been rewritten in Fortran 2008 (it was written in F77) to include the newest features related to OO programming. We also intensively use openmp and we are trying to use also Coarrays.
Graduate school for Chemical Engineering: Weather, Emissions and Air Quality models are mostly written in Fortran in a mix of almost all variants. I use it to modify and extend existing models as well as for pre and post processors for the data.
Was it a lot of effort to re-write your code into Fortran 2008 with OO features?
NASA uses Fortran in their weather/climate models. It's a mix of Fortran 90 and FORTRAN77. Some of the Fortran 90 code is converted straight from common blocks to module (global) variables, which is an improvement, but still not very nice. The non-legacy modern Fortran code is pretty nice though. There's a push to (eventually) move some of the code to even more modern Fortran (2003+) to take advantage of the better OO capability, but the code I write is Fortran 90.
Well, we use it because it's a lot faster than interpreted languages such as MATLAB, but it's harder to write and debug, I myself prefer Fortran 90 (which is just as fast as C++ from my experience), but we don't usually get to choose the language we are going to work with, specially if there are already a bunch of programs written by the research group! I spend my time mostly trying to understand the codes and translate between languages and getting the programs to work and get some nice results! I work in acoustics, the boundary element method is really powerful there because we can simulate infinite domains rather easily, but the formulation is really complex and implementation is kinda of hard... that's why it haven't got as popular as the finite element method.
It is possible.
Almost all Fortran compilers also support C Pre-Processor directives such as #include, #def, #ifdef, etc in addition 
I should have been more clear in my question. If the file 'first.txt' contains multiple subroutines, is there a way to call specific subroutines and have the code ignore the rest? So say that the file that I include has two subroutines (subroutine1 and subroutine2), is there a way I could use the module first in the module second and only call subroutine1 while having the code completely ignore the existence of subroutine2.
Thanks for the reply. I was actually unclear about my actual question. I have clarified what I meant in a reply to complex_pi. 
The `only` clause will make the other subroutine invisible to the program. All other subroutines will still be compiled though because the compilation of the module does not ignore them.
I believe some (maybe all) compilers can't find common coding errors in fixed form if over more then one line.
I actually find Numba in Python is excellent for anything that isn't meant to run for hours. It's almost as fast a Fortran code for smaller jobs. But for simulation codes definitely using Fortran.
I find with that sort of thing, the problem is that you have to massage your problem into a small number of big operations that are covered by the functions they've supplied. But if you really want to "roll your own" algorithm - like do a gravity tree - it's not really any more work to just write it in Fortran.
For Numba it's actually pretty easy. Usually you just add the @jit decorator to the start of your computationally expensive functions and it does the rest. Gives a massive boost in performance for very little work. The only annoying part is some python libraries aren't compatible with it yet. 
I work in insurance, currently writing a new code in Fortran 2003+
Don't waste your time changing the code format. We love and use fortran because of its legacy and back compatibility. If the program has been created according to the best standards, just use it and thank the programmer. 
[removed]
[removed]
I haven't used that before, but generally speaking gFortran is great because it is free and available on every platform. In terms of which compilers are "better" that's based on what you are doing. In my area the Intel Fortran compiler is miles above everything else I've worked with because it has some of the better optimization capabilities if you have an Intel Processor which most of the super computer clusters I work on do have. However it comes at the cost of being harder to debug code with. 
You'll be missing some features of the language that were included in the 2003/2008 standards. You can see what those are [here](http://fortranwiki.org/fortran/show/HomePage). The compiler itself seems sensible enough, I doubt it's buggy or anything. Specific optimisation and debugging options may or may not be to your taste.
Firstly, it is spelled Fortran, not FORTRAN. I personally do not care, but someone corrected me a while back on this sub and I thought I should share. Secondly, do you have access to a Fortran compiler? Thirdly, the best way to learn is to just program. I would try to find simple programming exercises for other languages and complete these tasks in Fortran. Fourthly, just like any language, try and use basic practices. Like using comments, be consistent when declaring variable, etc. As for books, it really depends on your goal. There are books specific to engineers, and then there are books specific to the basics of Fortran.
"Modern Fortran Explained (Numerical Mathematics and Scientific Computation)" is a nice starter. It has the added benefit that it teaches you to use the most recent version of the language and not have to worry about some of the quirks of older versions (think Fortran 77). Then you might want to pick up a book on numerical methods and scientific computing to learn about algorithms, distributed computing, etc. That stuff is not Fortran-specific. As far as compilers go, you can use gcc/gfortran. It's widely available on Linux and Unix machines, but you can get it on Windows too, easily: http://www.equation.com/servlet/equation.cmd?fa=fortran You don't really need an IDE, only a source code/text editor. You can use an editor that's aware of Fortran syntax, like atom, Sublime, etc.
Implicit none.
Agreed there... 
I've found Fortran to be order of magnitudes faster than Numpy is most situations (excluding set realtor stuff like finding intersection of arrays). If anyone had any tricks here I'd love to hear it. Most of my work is delivered via the web and you Julia can't hold a candle to the Python web / analytics ecosystem 
Interesting, I can post some tests but something like summing masked arrays is much faster in Fortran. 
Hum from what I remember masked arrays where indeed problematic. Any way you have to be careful with copies when using Numpy, that's the source of most performance issues I've seen in Numpy. Some Numpy functions even output arguments to avoid copying. 
If you already know Fortran and the whole program will be in Fortran I agree with you. But OP wants to use it from Python, and doing it correctly is troublesome. Interoperability between C and Fortran is a bit weak and you have to go through C to get from Python to Fortran (what f2py does is create a C wrapper for the Fortran code and make Python load it as a C library). For simple array in array out routines it might work, but God help you if you need to debug something using more complex going from Python to inside de Fortran code.
Some hints on Numpy performance: http://ipython-books.github.io/featured-01/
Modules whenever possible. They prevent so many errors and also make managing codes a lot easier. 
http://www.fortran90.org/src/best-practices.html
Ah yeah I missed that bit about f2py. Yeah, if I was already using a python codebase, then I'd look at numpy first, then maybe cython and finally f2py, depending on what you're wanting to do. 
Thanks a lot for the responses! I was able to get around the issue by initializing local arrays in the module with the array size read from excel. The initial arrays were set to a large size, and the first n points (n changes based on excel input) are computed using the dummy arrays whose size changes with n.
My college professor who taught numerical methods required us to write "implicit none" of course, but he wouldn't tell us why. I remember him saying, "If you don't add 'implicit none,' it will enable one of the worst features of Fortran ever, and I don't want you to know it even exists." He would also give you an automatic fail on any assignment if "implicit none" was not included regardless of whether the program worked. I was baffled at my first job when I originally saw implicit typing. I was horrified, and I realized my professor was quite right in not even allowing its mention in class.
What compilation error(s) do you get? If all of the work is done in the C++ code, why are you using Fortran at all?
Hi, Fortran can only interface with C code. There is no standard way to share the data structures or calling conventions with C++. The only way is to prepare a "wrapper" code that provides plain C interfaces.
So is FORTRAN better at numerical analysis that perhaps C, given a programmer who is equally versed in both languages? (supposing such a programmer actually exists)? I write stuff like - When the CA Lottery was brand new a local talk show host said "your chances of winning the lottery are about the same as flipping a coin 25 times in a row either heads (25 heads in a row) or tails (25 tails in a row). " In writing this program I found that indeed if you wait long enough you will encounter a string of 25 heads or 25 tails. == Would this have been better written in FORTRAN?
A lot of scientists and engineers are programmers by necessity. Fortran is A) often the most well-known among older senior scientists and B) one of the easiest languages to make fast numerical code easily. For example, you can optimize code in C to match Fortran's speed, but it generally takes extra steps. Fortran as a language has a history and culture of being centered around fast computational solving, and so the language developers have continued to focus in that respect. We're mostly dealing with matrices and numerical methods, not complex data structures, so speed and familiarity with the language is preferred by many over programmer productivity features. 
Fortran is just build for numerical computing in ways no other language is (including C/C++). For example: 1. **Memory issues common to large numerical programs are mitigated:** Two examples. First in C/C++ arrays by default are passed by value which can cause huge memory issues unless you do something like use pointers (leading to problem #2) or something else. Fortran automatically passes by reference without the programmer having to worry about it. Also, in C/C++ "temporaries" are created when using user-defined data structures like objects. (Google this) Once again, the attentive C/C++ programmer can program around this like he did when avoiding passing by value, but it's very handy knowing that with Fortran inefficient memory issues are avoided from the beginning by the straight forward approach. 1. **Rules for language allow aggressive compiling:** For example, in C/C++ you often have to use somethinpointers to deal with the "pass by reference" memory issues in #1 above. Except pointers in C/C++ have so much flexibility that compilers often will not compile them aggressively. This is why C introduced the restrict command, because it tells the compiler you are placing special restrictions on your pointers so that it can be more aggressive. Fortran avoids these issues. Furthermore, functions in fortran can be [labeled things like "pure"](http://www.lahey.com/docs/lfenthelp/F95ARPURE.htm) that allows even more aggressive compilations. C/C++ have no such counterparts. 3. **Fortran provides tools that are what every numerical person should want:** Again, a couple examples. Let's pretend you want to write a function that applies across a whole array. In C/C++ you have to write the function, then have something like a for loop send each element of the array one at a time. This is not only more tedious to code, but once again if the compiler does not decide that such a loop can be vectorized it becomes slower than it needs to be. With fortran you can just declare the function "elemental" and then you can pass it the whole array to the function that can be compiled aggressively. Then there's other things. For example, you can do slicing with Fortran arrays that is not available with C/C++. You have built in operations like dot products or matrix multiplication. There are many more mathematical functions defined. You can use classes like C++... but even better you can use modules that are like classes but greatly stripped down so that you get what is useful from them without the extra baggage/complexity that comes with C++ classes. This is both helpful for compiler optimizations and keeping programmers from hanging themselves. One thing I like with hydrodynamic codes is that you can declare that an array begins and ends with whatever integer index you want (not just 0 like in C/C++) which can be very handy like when the main data or your array goes from 0 to N but there are two ghost zones to the left and right. With Fortran you can say that your array's indicies go from -2 to N+2 and then you always know that the main data is always 0 to N and the zones to the left/right of that are ghost. This is also helpful if the number of ghost zones changes to say X so that you can just have -X to N+X and X can change but the main data from 0 to N stays in exactly the same place index-wise. Anyway, I am sure I can think of more things if I had more time to write but hopefully this provides a taste for my main point: Fortran is just build with numerical programming in mind in ways no other language is. It's true that a good C/C++ coder can code around all the issues I raised. The memory issues can be coded around, the non-aggressive compiling pitfalls can be coded around, you can find good libraries to help you when you need special functions or abilities (armadillo's C++ library allows slicing for example), etc... Or you can just use Fortran and all these issues are just taken care of for your from the beginning.
&gt;For big scientific codes starting from scratch however, it would be hard to justify using fortran considering the pedigree c++ has, not only from a software design standpoint but also library support. Most of the major computing libraries that are used by scientist are readily accessible in Fortran considering a huge fraction of them were written in Fortran or C. Things like linear algebra libraries for instance come to mind immediately. Typically the choice to write the code in C++ for scientific codes has more to do with the fact that it's easier to take it over the computer science department for help if you need it. But in terms of actual functionality I've rarely seen a case where Fortran can't access the same computing libraries. And the downside of writing it in C++ is that you actually have to learn C++ which is a much more complicated language. 
C and Fortran are usually comparable languages in terms of speed if you know how to optimize each respective code. However, the key difference between the two is that C was written for the purpose of writing operating systems and low level software while Fortran was written with the purpose of providing people with a way to translate their mathematical formula's into computer code. As such their syntaxes were tuned to optimize those opperations. This shows up in things like variable passing, array allocation, etc. and between the two languages Fortran has a lot more safe guards against the infamous ID10T error than C. A prime example is allocatable arrays. There's no comparison, Fortran is exponentially easier to perform array operations for number crunching purposes, but if you are trying to say write a compiler then C's memory allocation gives you a lot of fine tuned control. 
&gt; Most of the major computing libraries that are used by scientist are readily accessible in Fortran considering a huge fraction of them were written in Fortran or C. Things like linear algebra libraries for instance come to mind immediately. I use Fortran and like it but the library support is a problem. Like you say I had read a lot online that there should be plenty of stuff, but other than low level linear algebra I found it quite hard to find useful comprehensive scientific Fortran libraries. As soon as you want to do things like sample from some other distribution, calculate inverse standard normal CDF, use graphs or other structures it is really hard to find stuff compared to C++. For all of these problems I end up copying and pasting some function from a 1990s geocities style web page (often fixed form so I have to reformat to include in my free form project). So I found something in the end, but it took a lot longer (e.g. than browsing boost documentation) and I have a lot less confidence that it is correct and tested and I'm certain its not maintained in any reasonable way. I hate depending on stuff like that for low level and of course I don't have time to really look into the algorithm and do that kind of testing myself for every function. Intel libraries solve some of this but are not very convenient to use. Maybe NAG is better but I don't have access. TL/DR; I really like Fortran but only use it for simple stuff because the lack of libraries is really a problem.
Ok here is my C version of flip.c: I am not sure I get how yours works - are you flipping a bunch of coins into an array and then looking for strings of same coin? I guess mine trades storage for time... #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int coin(void) { return (rand() % 100) &lt; 50; } int main(int argc, char ** argv) { int run,mxrun,prev,next; long int heads,tails,dist; srand(time(NULL)); /* for calculating the number of flips since the last event */ dist = 0; /* for recording the number of heads and tails */ heads = 0; tails = 0; /* for remembering the longest run of similar kinds */ mxrun = 0; /* for counting the current run of similar kinds */ run = 0; next = coin(); /* flip 1st coin */ do { prev = next; /*save last coin and flip next one */ next = coin(); /* count heads and tails and with that count flips */ if (next == 0) heads++; if (next == 1) tails++; /* check if this flip is the same as the last*/ if (next == prev) { run++; /* if similar increment the count of similar coins */ /* if this is the longest run so far it is an event! */ if (run &gt; mxrun) { mxrun = run; /* display to the user how far we are */ printf("n:%d|h:%9d|t:%9d|m:%3d|r:%2.5f|t:%9d|d:%9d\n" ,next,heads,tails,mxrun ,(float)heads/(float)tails,heads + tails ,(heads + tails) - dist); /* calculating the new distance since the last event */ dist = heads + tails; } } else { /* this is not a similar to the last - reset the run length */ run = 0; } /* until we manage to flip 25 in a row */ } while (mxrun &lt;= 25); return 0; } How would that look in FORTRAN?
Ha, looks like I took an overcomplicated approach up there, implementing the first thing that came to my mind  basically storing the last 25 flips to a circular buffer and counting the number of heads in it on every iteration. Anyway, for your example, there's very little difference between the two languages, as it doesn't play into the strengths of either  no array operations that would naturally map to Fortran syntax, nor anything that would benefit from C's close-to-the-hardware nature or pointer algebra. Here's the Fortran translation of your example code, and it's practically a line-to-line translation: program flip implicit none integer :: run, mxrun, prev, next, heads, tails, dist dist = 0 ! for calculating the number of flips since the last event heads = 0 ; tails = 0 ! for recording the number of heads and tails mxrun = 0 ! for remembering the longest run of similar kinds run = 0 ! for counting the current run of similar kinds next = coin() ! flip the 1st coin do while (mxrun &lt;= 25) prev = next ! save last coin and flip the next one next = coin() ! count heads and tails and with that count flips if (next == 0) then heads = heads + 1 else if (next == 1) then tails = tails + 1 end if ! check if this flip is the same as the last if (next == prev) then run = run + 1 ! if similar increment the count of similar coins if (run &gt; mxrun) then mxrun = run ! display to the user how far we are write(*,"('n:',I0,'|h:',I9,'|t:',I9,'|m:',I3,'|r:',F7.5,'|t:',I9,'|d:',I9)") &amp; next, heads, tails, mxrun, real(heads)/real(tails), heads + tails, &amp; heads + tails - dist ! calculate the new distance since last event dist = heads + tails end if else ! this is not a similar to the last - reset the run length run = 0 end if end do contains integer function coin() implicit none real :: x call random_number(x) coin = int(2*x) end function end program P.S. You can get nicer code formatting in Reddit by indenting the code block by four spaces. 
Fortran is really great with arrays/matrices. If you're approaching a problem from a mathematical/physics standpoint, you're probably used to carrying out the calculations using matrices and vectors rather than loops. For example, you need to find the gravitational pull between n planets: you can perform the calculations with matrices rather than nested loops.
Ok - here's one then - do this in the most Fortran-like way - Assume an array named GRID 20x20 integers which is initialized to zero. Randomly choose and increment elements of the grid until one of them reaches 9. Would this be a good use? (edit typos) 
You're still not thinking of a mathsy enough problem. How about this: You've got a bunch of points in 3d space. What's the closest point to each? (We're going to ignore any ways to speed it up and complicate the code such as splitting it up into regions) In C or whatever you'd probably loop through each point, use a loop to measure the distance from that point to each point. In Fortran (or MATLAB) you could make an array with all the points, calculate the vector difference between each point, then calculate the length of each vector. Apart from making the array and finding which row is the minimum at the end, you're only doing two calculations: difference=a-b and length=a.a
So - for each point - find the point nearest? - In C I would have 2 loops taking an un-allocated point each time and find it's closest (taking them both off the list) until none remained. I suppose I should check for an even number of points. Or do we pre-define "a bunch" as say 20?
I updated with my Fortran "solution." (Which isn't quite right btw, for example I would have to make sure I ignore each time it works out the distance to itself.) If you're coming at the problem from a maths or physics standpoint, then doing it as vectors/matrices can be much nicer. You get much prettier and concise code too. And if you're using a formula that you found in a paper or textbook or derived yourself, chances are you used matrices then, so why would you change to loops now? (If you ever work with MATLAB, you're basically forced to use matrices instead of loops where possible. It's loops are slow) Other reasons for Fortran: it's basically the sameish speed as C, and you don't really have to care about memory issues or pointers
Would this be it then (given 20 points) - place the points in a 11x11 matrix so that they occupy the top row and right column. For each row/column find the distance between the top row and first entry of this row. (I would do this in a spreadsheet filling the formula in the middle) - It this the FORTRAN-most way to do this? Don't you still iterate by rows and columns to put the distances in the middle? - Oh that won't be correct you need a 21 x 21 array and copies of each point along the top -and- the side. (with a diagonal that would be zero distance)
I guess I am still thinking in terms of loops though I would have to iterate.
Sorry - I should have said up front that my array would be an array of structures (3 integers for the 3 coordinates) - you are storing them across the rows right? So assuming the array is already filled what does the FORTRAN that calculates the distance-squared values look like?
so for somthing simpler - I have 2 arrays of numbers and I want to multiply them giving a third array-- In FORTRAN can I just say IARRAY1 = IARRAY2 * IARRAY3?
An array would probably be best. A bad way would be to store it as an integer. If each game you can score out of 100 (0 being worst, 99 being best) , then you could do something like the following. Total_score = total_score + current_score*(100 *** i) If you start at i=0 then all your scores will be stored in the integer. You might run into problems depending on how accurate your integers are. 
Inverting matrices as well. The memory issues when inverting matrices on the order of xxx,xxx can be handled very well in fortran.
Edit: this may be inappropriate for this sub, but if anyone wants to turn this into a paid freelance project using source files I provide I think we could come to an agreement. Feel free to delete if I am breaking the rules.
If I understand your question correctly, the answer would be fancy indexing. Say, if you had the row indices listed as an integer array *index_rows* and the column indices correspondingly in *index_cols*, you can refer to the subset of the matrix A as A(index_cols, index_rows) Here's a tiny piece of code to illustrate the concept: program test_slice implicit none real :: a(3,3) integer :: ix(2) = [1, 3] a(1,:) = [ 1, 2, 3 ] a(2,:) = [ 4, 5, 6 ] a(3,:) = [ 7, 8, 9 ] print*, a(ix,ix) end program When compiled and ran, it prints out 1.00000000 7.00000000 3.00000000 9.00000000 
Ok thanks, maybe we can keep going with your example. a inverse: a(1,:) = [ 1, 2, 3 ] a(2,:) = [ 4, 5, 6 ] a(3,:) = [ 7, 8, 9 ] The subset a22 inverse in this case would be: a22(1,:) = [ 5, 6 ] a22(2,:) = [ 7, 8 ] We have G inverse: G(1,:) = [ 1, 2 ] G(2,:) = [ 3, 4 ] We need to do G inverse minus A22 inverse. Then reshape and add back to A inverse. 
Unless I'm missing something, H(:,:) = A(:,:) H(ix,ix) = H(ix,ix) + G(:,:) - a22(:,:) should do the trick. 
Thanks! Cache efficiency and roofline model are on my list of things to research.
Writing array-based number crunching is as easy as in Matlab, thanks to the built-in array notation, but larger programs are safer in Fortran than in Matlab because Fortran has static typing and modules. Runs as fast or sometimes faster than C/C++. Also programs stay safer, because you mostly don't need to meddle with pointer details like in C, or C++ templates.
I'm not using double precision currently. I've got a workstation with 128GB. But I think fortran doesn't come with a 64bit compiler? So the largest number would always be 2^(32-1) . I have to be able to go above that.
Link's down - surely r/fortran hasn't hugged it to death that quickly? EDIT: got some links from wayback machine: [setup guide](https://github.com/mapmeld/fortran-machine/blob/master/README.md), [github repo](https://github.com/mapmeld/fortran-machine)
Seems to be back up again. 
Could someone summarize the utility of this vs. "standard" web frameworks? I'm just trying to understand the purpose. 
Thanks!
I don't know what the inputs are, but I was able to compile it without any problem using the intel compiler (ifort) version 17.0.0 and the gfortran compiler (version 6.1). When I tried to run it it crashed because the file INPUT.TXT was empty). You can get the gfortran compiler here: https://gcc.gnu.org/wiki/GFortranBinaries and you can get instructions on how to use it here: https://gcc.gnu.org/wiki/GFortranGettingStarted Once you have gfortran up and running just save the source to a file ending with .f (which tells gfortran to expect F77) and run gfortran on it. (I got a bunch of warnings on gfortran which I didnt get on intel, so ymmv) 
Thanks for you reply, I am completely new to this. I've managed to get as far as compiling the source file but thats about it. I guess I would need to find someone who has used the model before but thanks for getting me this far. In terms of the input file, do you know where I should store that file for the model to find it or do you define its location at the start?
Yeah Im not too sure if Im getting the terminal syntax correct. The executable and the input files are all in the same folder but I think whatever I'm putting into terminal is wrong because its telling me theres no input files. 
No IDE that I know of but I'm a novice in both Fortran and programming in general, that being said. I use textpad and compile in command prompt
If you get yourself a Fortran compiler (like Intel's), then yes.
As with every programming language, you need to first get yourself a compiler (buy/download; most Linux distributions package `gfortran`). Then you open your favourite text editor and write code.
It doesn't have a dedicated IDE like some, sure, but it's just like any other programming language. If you prefer to edit in a unix-like environment like I do, you can install cygwin on windows, and include the gfortran package.
Just go fucking download [this](http://www.eclipse.org/photran/).
Jesus Christ these bot posts are appearing all over reddit 
I use Plato by Silverfrost (Google search will find it) and it works well for me.
I have been programming fortrash professionally for several years at this point. I have never found an IDE that I liked for it. I mostly just used Vim at this point. It gets the job done. As for compilers, there are gnu based compilers that will work on windows as well as the absolutely wonderful intel compiler suite which works on windows and linux and may even have some visual studio plugins. 
I forked the FLIBS project from [its former SourceForge home](http://flibs.sourceforge.net/). I'd like to extend it, clean it up, and add Mac support. I am already part way there but I would appreciate help from someone! Located in the Bay Area if someone wants to meet in person every now and then.
Hey, I'm the developer of https://fortran.io which uses FLIBS. I don't have a lot of info on Fortran compatibility on Mac OSX, but in my experience the FLIBS developers responded promptly and helpfully to my requests (over e-mail, as I was still trying to figure out how to compile things). Some files related to my particular FCGI scripting use-case were missing from SourceForge and they provided them.
Does it need to be a local person, or would you allow telework? 
Hi /u/kylearean, Unfortunately our client needs someone to be onsite for this role.
I'm not an expert, but I think it's bad form to just submit a link to a SO post...
I am the primary developer of [Simply Fortran](http://simplyfortran.com/), and I'm happy to see that you're considering it. Simply Fortran uses GNU Fortran as its compiler, and it comes packaged and pre-configured with our product on Windows and macOS. We have a relatively large user base, somewhere in the thousands, but I'm sure it's dwarfed by the number of total GNU Fortran users. If you do have any questions about Simply Fortran, I'll be happy to answer them!
Thanks! I appreciate it!
Is it written on FORTRAN, though?
How much experience would they need? I'm in the OC area and have studied FORTRAN77 outside of university.
 Oops. You also need some strings in you format. 75 FORMAT (A,I4,A,F7.3) But yes it does.
You need strings in your format (see above) and in your first line you need commas between the the string and the variables. Print 75, 'i=',i,'x=',x
While it's not ground breaking research, I coded a little genetic algorithm in FORTRAN today.
To my knowledge there isn't anything specifically on your list, likely because Fortran isn't normally used for that sort of thing. However I will leave you with this link that has lots and lots of libraries. http://fortranwiki.org/fortran/show/Libraries
Maybe this would be helpful: http://www.elch.chem.msu.ru/tch/group/FortranBooks/NumericalRecipesinF90.pdf This was the sort of thing we had to use in the olde dayes back before stack overflow was really a thing. We also had to wear rocks for shoes.
Could you link to some of those regularly updated libraries if it's not too much trouble? Thanks :) 
There are some conversion aids here: http://www.personal.psu.edu/hdk/fortran.html Also, check out the refactoring in Photran, the Eclipse IDE for Fortran
Many thanks to all the replies, suggestions and encouragement. I found the "ssort.f" subroutine (in fact a list of subs including dependencies) from netlib that does array sorting and inversed sorting. Also it optionally sorts an auxiliary array so kind of an argsort function as well. Still no sorting along a given dimension though, but I think that'll be sufficient for now. I also had a quick look at the Numerical Recipes book suggested by @choco_leibniz. That's quite a nice reference and I will probably resort to it before stackoverflow next time. I'll surely be keeping on learning Fortran (just figured out how to compile and link .so libs and made the ssort sources into one shared lib, feeling good about myself :) ). However I still feel that it's a bit shame for the lack an open, centralized and modernized Fortran package hub.
I tried to use camfort but apparently there are no usage instructions. Does anyone know how to use it?
Thanks for posting this. This is going to be required reading in the next lecture.
generally you can read a file of arbitrary length like so: open ( file = "filename.txt" , unit= 60 ) i = 1 do read( 60 , * , iostat = ist ) values(i,:) if (ist &lt; 0 ) then exit else if (ist &gt;0) then stop "error" end if i = i + 1 end do close(60) Now, this is leaving out some of the details, but ist is an integer, which tells you the status of the file. If it's zero you're in the middle, if it's negative you're at the end, so you exit the loop. Positive means the file format is wrong or something. you might want to consider counting the rows with this loop, use allocatable array for values, and then use "rewind(60)" to go back to the start and populate the array with a very similar loop. Go Huskies, http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/intro.html 
Thankyou very much! This has helped a lot, I think I should be able to figure it out from there!
Long ago, there were IMSL and NAG numerical libraries. These days I guess we pretty much only have the GNU Scientific Library, but it's in C so it takes some extra effort to call it from Fortran.
thanks!
BLAS is written to be usable by many different languages other than just Fortran. A lot of the vector operations you find in Fortran don't exist in other languages. Well to be more accurate you have to use loops or other structures to handle it. Also many of these routines often use algorithms that perform the same action in a more "computer friendly" way. Which improves efficiency. 
SPEED
The BLAS routines are extremely cache-friendly and optimized. (Similarly for OpenBLAS, MKL, etc. variants) Compared to a 'naive' aX+Y, they can be typically multiples of the speed of hand-written code. Its worth noting many modern compilers, if they spot blas-like expressions, optimise internally to call BLAS / MKL.
Be careful using code from the nr book. The license is not very friendly.
Have you tried to supply the parameter `-freal-loops`?
Could be a [SAS function](https://support.sas.com/documentation/onlinedoc/ccompiler/doc/lr1/lrv1ch3.htm) to "aopen * opens a file with system-dependent options" or an Asynchronous call to open a file. 
As u/FUZxxl said you can use the compiler flag -freal-loops to get the code to compile, but this is a hack that ignores the real problem. Older version of Fortran allowed the user to use a real variable for the loop control variable. For example the code DO x =1.0, 2.0, 0.10 write(*,*) x used to be acceptable. However a lot of problems can arise due to finite precision arithmetic errors. If you ran the above code on three different machines you could possibly get three different results. One computer might print out 10 numbers, another might print out 11, and a third could print of 12. It all depends on how the finite precision arithmetic errors are handled. This variability can lead to a ton of problems. On the other hand in most cases only a slight modification to the code in needed to avoid the above issue. The fix for the above example is DO index =0, 10, 1 x=index * 0.1 + 1.0 write (*,*) x If you're working with a small code, then I'd recommend spending the time to fix the do loops.
Thanks, this helped.
It's an issue with how you put in your numbers. &gt; T_C = (5/9)*(T_F - 32) Both 5 and 9 are integers the way you've written them, and as such, will return 0. You essentially have written &gt; T_C = 0 * (T_F - 32) whereas in the alternate, you have &gt; T_C = (x =/= 0) * 5 / 9 So while in this case you'll get an answer, it'll be an answer rounded down to the nearest integer. This is fixed by indicating right away that a given number is real, i.e. &gt; T_C = (5./9.) * (T_F - 32.)
If you are only doing the analysis once I would recommend transposing your data with excel and read inside a while loop. If you are going to have to deal with a lot of files formatted like this I would recommend using an implied do loop in the read statement. It's simple enough, but the implementation depends on your compiler (I used implied do loops with gfortran). Good luck!
Are you opening the file as unformatted when you are going to write to it? 
To be honest, I am not entirely sure. When I write to a binary file I expect everything to be ones and zeros, but this is not the case. Why does the text editor not show binary digits and show strings instead? Also, when I write out numbers to files I also get these weird characters instead of ones and zeros.
Yes, if you mean that I do not specify any format when writing to the file.
Here is a little sample code of writing binary: program binary integer :: iunit iunit = 1000 open(unit=iunit,file='test_binary.txt',status='replace',form='unformatted') write(iunit) "Hello" close(iunit) end program Here is the program that reads the binary text: program binary_read integer :: iunit character(5) :: string iunit = 1000 open(unit=iunit,file='test_binary.txt',status='old',form='unformatted') read(iunit) string close(iunit) print*,"String read: ",string end program 
The definition of selected_real_kind(precision, range, radix), where I believe "radix" is f08 standard. https://www.ibm.com/support/knowledgecenter/SS2MB5_14.1.0/com.ibm.xlf141.bg.doc/language_ref/realkin.html 
Thanks! 
I have always used integer, parameter :: sp = selected_real_kind(6, 37) integer, parameter :: dp = selected_real_kind(15, 307) integer, parameter :: qp = selected_real_kind(33, 4931) http://fortranwiki.org/fortran/show/Real+precision
Which industry is it? Mind to share some info? I am currently looking for consultancy work in my country.
Apparently MSFLIB (which presumably stands for Microsoft Fortran Library) is something provided by the Intel Fortran compiler for Windows to allow Fortran code to access the Windows API (which uses C/C++). If the license for the Intel Fortran compiler allows you to download it for other platforms at no extra cost, you could try downloading the Windows version and running it either in Wine or in Windows on a VM or real hardware. This would still however only produce a Windows executable, that requires a Windows environment to run. Porting the graphics code to something available on Linux would be non-trivial, since there's likely other graphics API functions used by the program that would need to be converted. Fortunately, there are a lot of cross-platform graphics libraries that facilitate running the same programs on Linux and Windows, but that doesn't help much when you come across platform-specific code like this. As for what the code does, it's pretty clear - it uses nested loops to fill a rectangle (defined by the corner coordinates (1,1) and (IM\*5, JM\*5)) with the color black (0x000000 in hexadecimal RGB 24-bit color code). It would probably be easy to find a Linux or cross-platform graphics library that does the same thing (likely with built-in functions to fill in a rectangle, rather than having to go one pixel at a time), though it would require you to look through the entire program and replace all Windows API functions with their equivalents.
there is one available for the atom editor, though that might not help you much..
here is one. http://www.aics.riken.jp/ungi/soft/kscope/ 
The atom linter is just a wrapper around gfortran ! So you can do the same, and enable all the warnings to use your compiler as a linter. 
fortran I/O is record based. You find details and examples here: http://stackoverflow.com/questions/8751154/looking-at-binary-output-from-fortran-on-gnuplot http://stackoverflow.com/questions/8751185/fortran-unformatted-file-format 
Thanks, had to set access="stream" and it works fine now.
&gt; a check and see if Fortran can read a binary file I wrote in python. In the file I wrote out a single integer of length 4 byte I think it's informative to do the opposite. Use fortran to write a binary file, and then try to read it in python. If you do it by hand once, you can see the extra data that fortran adds to the binary file. 
Sorry. Yes I/O is input and output, and C is another programming language. Fortran was created when computers were completely different, and for doing math it's great, but for anything else it's completely awful. I wish teachers stopped teaching it to [STEM](https://en.wikipedia.org/wiki/Science,_technology,_engineering,_and_mathematics) students (probably your case) and instead used [Python](www.python.org) or [Julia](https://julialang.org/) (also programming languages).
&gt;I could take C++ in the comp sci department but I figured Fortran would be more applicable. In general it is, but as you can see, it has huge drawbacks. For your future work, learn some Python (there are ton's of good places to do it, even great online courses), and only fallback to Fortran when you *really* need it (usually for speed), or better yet, try to pair with some one from comp sci dept to do the optimizing.
I'm not sure I really understand what your asking. However, you might find the following helpful http://www.tutorialspoint.com/fortran/select_case_construct.htm 
&gt; really long branched if-elseif statements Would "select case" help?
Version 15.0.3.187 Yes, it prints that the result is right.
you can also find expert help in the comp.lang.fortran google group. It is quite active.
Thank you.
Hm. I've got the same version here at my university and compiling and running it with 4 cores shows this output: https://pastebin.com/DTs4NepV Oddly enough it works for the size of 4. Hadn't noticed that before. 
&gt; You are right, ifort changes them to j-k-i. But that also means I was incorrect about having k as the outer loop. Well but you said k j i is fast**er** which might as well be. Does your k reach 4 for csize = 4 when you set the initial value for csize to 2? cause that is what i did for my output.
Hm. I'm not sure if I understand the difference between fixed and free form. Also when I remove 6 spaces in each line, my editor just highlights everything in red.
fixed form is the old punch-card conform format. compilers make certain assumptions based on the strict F77 format (fixed form) and the modern, free-form. Compiler decide the format from the file and/or from the file extension. Some small parts of the syntax changes. For example you might need to use "c" instead "!" for comments, and the line continuation changes. You basically used Fortran90 coding style with F77 fixed-form format. This should not be a problem, or at least should give obvious compilation errors. Though especially Intel has been known to "guess what the user wants" and correct it internally. 
What about omp directives? do they also use the c?
I can't really seem to create a free form version of the code that pleases the compiler, so I guess I'm just gonna use this weird but simple fix. Also pretty much nobody in the university wants to know that the Intel Fortran Compiler on our hpc system is assuming wrong... Thank for the help though. I appreciate it.
I use a linter which supports Fortran in Vim, but I cannot remember how it's called and I am currently only on my phone....
To be clear, I need to be able to execute multiple modules from a single command line argument. =/
Try this program main implicit none character(len=20),allocatable,dimension(:) ::args integer i,num_args !get the number of arguments num_args = command_argument_count() !allocate memory to store the arguments allocate(args(num_args)) !get the arguments do i = 1, num_args call get_command_argument(i,args(i)) end do !print the arguments do i=1, num_args print *,"Argument number ", i, ": ", args(i) enddo endprogram 
Thanks! I will give it a shot!
You're gonna need to take a basic Fortran class, or at least teach yourself to some extent. You'll need to write a short Fortran program which includes those reading loops and compile it.
That is a really old version of the compiler. Use this a guide to download and install it: https://gcc.gnu.org/wiki/GFortranBinaries Use this guide to figure out compiling and running a Fortran program: https://software.intel.com/en-us/node/691407 
Why are you using Fortran 77? Use Fortran 2003 or later. All modern compilers should be able to handle 2003
If you only need to target one platform you could consider writing a small bash/perl/... script which calls your programs.
No apology necessary! I really do appreciate the suggestion! :)
Yes, that is my current attempt, but it feels too verbose to write the same code over and over again. Maybe I will write a code generator for this ... Is there any way with class(*) to have a local variable with the same type? Something like: subroutine test(a) class(*), intent(inout) :: a(:) ???? :: b if (size(a) &gt; 1) then b = a(1) a(2) = b end if end subroutine test
I once tried and looked how to do this, but as far as I could find out there is no native way in fortran (I never came upon the class(*) option mentioned in the other comments, so it might be worth checking that out). Besides code generation as you mention, the only option I can think of is using preprocessor directives to bypass this limitation: (1) Write the common code in another file and include it in the subroutines. (2) Use define for the common commands: write them at the beginning of the code file and replace inside subroutines. (3) Use define inside the variable declarations and configure makefile so that it generates different objects passing different definitions. Much more elegant code because it actually looks like it was templated, but introduces more noise in the makefile. Since what other languages (such as cpp) do when compiling templates is to actually generate different symbols for each possible type, why fortran has never incorporated this as a language feature is beyond my understanding.
There doesn't appear to be any way to do what you want in Fortran 2003. In 2008 (which will support assignment to class(*) variables) you can do this, but I think it is unlikely to be implemented in your compiler yet. [You can find a discussion of this here](https://software.intel.com/en-us/forums/intel-fortran-compiler-for-linux-and-mac-os-x/topic/611490) Note that it is possible to set the kind of an intrinsic from another intrinsic of the same type, i.e. integer(kind=8):: i integer(kind=kind(i))::j But this is of limited use here as you would still need to write a separate procedure for each operation of each different kind. 
So I would just copy and paste the code? Sorry I don't understand. This is very specific. 
Include is a very good idea as the syntax is exactly the same, thank you!
Thank you, I will definitely give it a try!
Hello! i can copy-paste and compile and run your code fine. &gt; gfortran ./test.f90 -o test Other than the fact that then the endless DO runs again, you're trying to allocate the array again and you fail with &gt; At line 34 of file ./test.f90 &gt; Fortran runtime error: Attempting to allocate already allocated variable 'a' What command do you use to compile your code? Or do you let your IDE do it for you? Are you on Windows? You could try getting [this build](http://www.equation.com/servlet/equation.cmd?fa=fortran) of GCC/Gfortran 6.3 and compiling yourself.
I can compile the code on a linux based server with the command "gfortran -c project.f90" just fine and it creates the .mod and .o file but when i put that into my project folder it says "this .mod file was created with a different version of gfortran. I just wanna be able to run code with modules in Code::Blocks. It compiles the code for me but I don't know how to include the -c option using C::B. Don't worry about the DO-loop. It is not necessary. 
You need to compile the model and the main code using the same compiler, on the same platform. You cannot take the .mod file generated by one compiler and use it with another, unfortunately. With gfortran and gcc, "-c" will compile but not link. You only need it if you want to compile the module separately from your program. I am not familiar with Code::Blocks. You seem to be looking for a way to change its build script to first compile the module: &gt; gfortran -c myModule.f90 then compile the main program and link: &gt; gfortran program.f90 myModule.o -o executable It's more likely someone can help over at the Code::blocks support forums. 
If I wasn't busy getting paid to do that already (different code), then I'd totally jump onto this. 
NASA wants free skilled labor.
He passes the butter.
If I understand correctly, you want to build an equation parser, e.g. to specify some function that is then used by your program when doing calculations? Yes, this can be done; you basically have to build a language... I have personally written one such code (in Fortran; look up SixTrack's DYNK module), and I have seen several others. From what I've since learned, it would probably have been easier to use reverse polish notation than the way I actually did it.
Sorry for the wait. I'm not so sure about my purpose to be honest. I am working with fourier transforms and I would like to test some examples but without changing the main program every time i need to change the formula (function). But as I saw here, what would be needed for this would need to reinvent the wheel and the tools already exist (which is what I was hoping for).
I'm on mobile, but am curious -- are you using the Numerical Recipes RK code? And why are you forced to use F77 instead of more modern Fortran? 
The code compiles, but im not getting the expected outputs. I am unsure if it is a mathematical error or an overwrite issue with one of the dummy arrays. Here are the equations with the initial conditions: x" -x = t x(0) =1, x'(0) =2 x" -x' =1 x(0) = 1, x'(0) =1 Broken down by hand these 2 systems of two first order differential equations to be solved: y1' = y2 y1(0) = 1 y2' = t + y1 y2(0) = 2 y3' = y4 y3(0) = 1 y4' = 1 + y4 y4(0) = 1 When solving the 2 original equations in a calculator the answers are: x(t) = -t -e^-t +2e^t x(t) = -t +2e^t -1 My code is not giving me the same output as these equations would if i plug in a specific time. I honestly believe it might be a mathematical error at this point because I have gone over the code multiple times and done the differential equations by hand. Simply adding the two first order outputs together does not equal the output of the 2nd order. I appreciate the help Ill check the write statement but at most it would just be a time step off though right?
Every time you call *read* Fortran will read from a new line. So you can just count how often you successfully (via *iostat* or *end*) can read a string from a file. E.g. read(io,'(a)') string will read a line (of len(string)) until it encounters certain delimiters, e.g a line break. The line break characters themselves will not be read this way! Searching for characters in a string can be most easily done with the help of the string intrinsics (e.g. *index*) or a manual loop with if statements. if( IACHAR(string(i:i))==10 ) ... if( index(string,char(10)).ne.0 ) ... Don't know from the top of my head how to make Fortran read the special delimiters like line breaks. 
Oh my god
Funny, I tried googling this yesterday, but couldn't find anything. In the end I just compiled using terminal and just used code::blocks as an editor. Basically, commenting so that I can find this later. Thanks!
Sooo, to keep on beeing the only who replies: I have some problems if I update some of my modules, and recompile, code::blocks doesn't take into account some of the changes. For example, in one module I set a parameter=200. If I change that parameter to 50, the new compilation (even after rebuilding) doesn't update to 50. Sometimes it works closing and reopening, sometimes not. Did you experience this problem?
Do you put quotations marks around the program arguments, or the correct escape characters? Otherwise those brackets will give problems. Also it seems you just need a single string s of length n, not an array. This should also make the read statement clearer.
How do I declare a string of lenght n?
&gt; character(len=:),allocatable::s(:) remove (:) from s(:) in both the declaration and allocation. Essentially you have an array of length one. (Don't confuse this with the character length of the string). 
Please put four blanks in front of every line of code so the code appears readable.
 coordY(i,j)=coordY(i,j-1)+1.0 coordY(i,0) for j=1 is likely undefined. Also make sure coordY is defined (e.g. set to zero) before entering the loop.
In this particular case that shouldn't matter, because you are setting the initial value of coordY explicitly. OP, When I tried to run this program I got the expected output (-2 * 5, -1 * 5, 0 * 5, 1 * 5 and 2 * 5). What compiler are you using?
The problem is somewhat unclear to me, but maybe you find inspiration here: https://github.com/szaghi/FLAP
Sorry if I was unclear. I am supposed to receive some commands from the command line (which I can do), but I am not sure how to parse them from there. For example, if I use scan, I can find the operator(s), but I am unsure how to find an index for the location of the first instance of &lt; or = or whatever is there. So, basically, how do I split up the "phrase" into it's component parts after I have managed to receive it in from the command line and store them as character variables? In case that's still unclear, I can receive and store the information from the command line, but I do not know how to separate the information into something that is useable by the read command so that I can grab the values of lat@hdr that are between 50 and 70. If anyone could help me with that, it would be super helpful. I don't need someone to write the code for me, just help me understand how to parse the variable "lat@hdr&gt;=50" into "lat@hrd", "&gt;=" and 50... or direct me to the right way of thinking if splitting this into 3 parts isn't required. Apologies if this still sounds confusing. I am very confused myself, so it's hard to explain clearly. =/ *edit: This is for splitting a text file using the commands read into the program, so reading only lines that are between the two values as given above.
Oh man. THANK YOU! You're an absolute saint! This has been incredibly helpful and I have actually managed to split the line of text based on this method. Now if I can just figure out how to index the first line of a text file to find the column and print it out, I'll be all good! 
I think Textmate does that. I *know* it does autoformatting and autocompletion for LaTeX.
Emacs will do that 
Thanks Happy Cake Day! I actually just downloaded Emacs. Any Fortran-specific guide you know of that can get me up to speed with using Emacs?
Yeah, I've been tabbing by hand. It works for me just because the code I'm writing isn't typically that long, but I can see it getting difficult for complicated routines.
Sound intriguing, not sure how I could use it -- hopefully someone could give me a clue. I have a complex fortran 95+ codebase, and it uses 'make' for compilation. Would fcompile help me in some way vs. using make? 
&gt; Would fcompile help me in some way vs. using make? Are you auto-generating your makefiles or writing them all manually? If it's the latter, tools that try and automatically deal with dependency resolution and don't rebuild the entire source tree for every small update are very useful. 
[Floating point arithmetic](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html). It has to do with the internal representation of numbers in computers, which leads to "rounding errors". You're using 'real' (decimal) numbers, not integers (which can be represented accurately). 
If you specify numbers in the source code, you want to specify their precision and kind. a= 17.2d0 ! double precision a= 17.2e0 ! real (single precision) a=17.2 ! real (because default) but decimal rounding is unclear a= 17.2_dp ! modern version with self-declared kind 
&gt; python has arbitrary precision integers built into its domain by default Oh! I wasn't aware of that. C, Fortran and the like don't have that.
You usually have to work with custom data types (see derived types for example) or use an external library for large numbers.
Nice. That's a beast though. Fcompile is less than 400 lines of Python.
I only share Fortran stories with colleagues who have to suffer along side me. It would be cruel to expose the broader public the torture that is hacking new features into a 20-year old Fortran model written in a dialect from 20 years prior to that.
It's a $1,000. But OK.
This sounds like the classic symptom of a segmentation fault arising from an error in an array index. The way to debug this is to compile with array bounds checking: it's the flag *-fbounds-check* if you're using gfortran, *-check bounds* if you're using the Intel compiler. A longer explanation: By default, when you're referring to an element in an array, Fortran doesn't check if the element index actually is a valid value  it could be too small or too large, in which case you'd actually read or write random memory outside your array. If you happen to point outside the memory reserved for your code at runtime, you get a segmentation fault. Now, when you change unrelated lines (e.g. add write statements), it changes the memory layout in subtle ways, and can make the bug seemingly disappear  but the bug is still there, you're either reading a random value somewhere or corrupting some other variable's contents. 
Are you writing to a file, or just to the screen? If file, which file unit number are you using? 
Well, without seeing the errors it is hard to know what the issue is. Do you want a quick tutorial in Fortran77? On a quick look through, this line looks wrong COMMON/THIR/B(24,3),BT(3,24),CT(3,24),FF(24,24) 24,24) This is defining a set of arrays that are shared between subroutines. The set is called `THIR` and contains the arrays B, BT, CT and FF. The numbers in brackets gives the dimensions of the array. There looks like an extra `24,24)` at the end. If this is more than 72 characters from the start of the line than old compilers would ignore it. 
Line 81 is messed up as well, there is a rogue comma
I will take a look thank you. 
Thanks I will let the old timer know next time I go which will be soon. This is probably the smartest set of users in a sub-reddit that I've seen. But I will post the errors after I download a trial of fortran.
Here is the updated file with errors. Thank you. https://gist.github.com/anonymous/82b4346af7480e0bd8e0f977fb92f6f3
I managed to get it to compile, but the results that it gives are just NaNs. I don't know if this is due to the original code or the changes I made to make it compile. https://gist.github.com/Diemo-zz/41916b146f9e343900b552f6bc870693 There were a ton of changes that I had to make. If you have any questions about any of them, please let me know. When I compile it with gfortran, I also get the following warnings, which is likely causing the NaNs: test.f:162:72: Warning: More actual than formal arguments in procedure call at (1) test.f:325:72: Warning: More actual than formal arguments in procedure call at (1) test.f:84:30: COMMON/RED/X(3,9) 1 Warning: Named COMMON block 'red' at (1) shall be of the same size as elsewhere (108 vs 144 bytes) test.f:142:30: COMMON/RED/X(3,9) 1 Warning: Named COMMON block 'red' at (1) shall be of the same size as elsewhere (108 vs 144 bytes) 
Damn you guys are geniuses with this and I have no idea how it works. The old timer is better than I am but they keep calling me to go help as if I know everything. 
Hmm, you guys have a lot of problems. Who wrote this code, the old-timer? The first thing is that you have to tell your compiler that you are looking at Fortran 77. You can do this either through a command line argument or by naming your file `.f` instead of `.f90`. That is what is generating all of the C Error: Unclassifiable statement at (1) - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - and all the errors about `continue`, `end do`, etc. D=A(N,N) 1 Error: COMMON attribute conflicts with DUMMY attribute in 'a' at (1) You can't have the input of a function also be in a common block. A common block is shared across all subroutines that can access it. X(1,4)=1. X(2,4)=1. X(3,4)=0. 1 Error: Unclassifiable statement at (1) You can only define one variable per line unless they are separated by `;`. Look at my other comment to find typos that I changed to get it to compile - there were a fair few.
Yea he is the one doing th coding I have never even heard of fortran. He thinks I know how it works or what it is. That is why I'm trying to learn so I could help him out.
The entire problem is that the file has the extension ".f90" which indicates that the Fortran is using "free-format" syntax. It's using older "fixes-format" syntax, though. If you change the file's extension to ".f" the file should have far fewer errors. I'm the primary developer of Simply Fortran, so I can help with any questions you might have.
Errors e42 and e02 indicate that a build step failed and compilation could not be completed. They aren't particularly useful. See my [other post](https://www.reddit.com/r/fortran/comments/6kpgpl/help_with_simply_fortran_not_so_simple/djoj55t/) about how the file being compiled should have the fixed-format extension of ".f" if that is indeed your customer's issue (it was your issue). 
What exactly is NaN? and I got the same errors on Simply. Thanks for the help.
I saved as fixed and still getting the same errors. Thank you.
NaN means Not A Number, and generally means that the memory is corrupted (i.e. the computer is unable to read the memory for some reason). A likely reason is because your common blocks are of different sizes, though I have never worked with common blocks. I would advise you to tell the oldtimer to stop using fixed form FORTRAN77, Fortran90 is much better and Fortran2003/2008 are better again. All of these are supported by the (free) gfortran compiler. 
Can you please post the contents of the Build Status tab again after saving as, let's say, "test.f" and attempting to build? You'll get errors E02 and E42 again, of course, if there are any Fortran errors at all. Again, those two error codes are not really helpful. They just mean that the compiler failed. We need to see all of the compiler output.
Ok I will do that right after I get out of work. Again thanks for helping. 
https://gist.github.com/anonymous/b12c2ceebc70765c497e873bbc00c3bd
The file still has the ".f90" extension. It says it's compiling "l2.f90." Try renaming it to "l2.f" instead and building again.
I will try that right away
https://gist.github.com/anonymous/dd190aa2769f3eee0838cc42dbd80b14 The command prompt opened and showed this https://ibb.co/dELDXv Edit: Tried debugging after saving as project but nothing.
I've been learning from [Self Study F95](http://www.mrao.cam.ac.uk/~rachael/compphys/SelfStudyF95.pdf) (PDF) If you already know how to program you can breeze through the first few parts. I'd suggest you do the exercises though to make sure you really know what's going on.
Thanks a lot! I am familiarized with python.
I found "Modern Fortran Explained (Numerical Mathematics and Scientific Computation) 4th Edition" very useful, as someone who had experience with other languages. Also, it's built around the use of the Fortran 2008 standard (object oriented stuff included).
At this point, you're dealing with actual bugs in the Fortran code. The compiler warnings themselves are showing calls to subroutines with too many arguments for whatever reason and inconsistent array dimensions. For example, the common block initially sizes X as 3 by 12: COMMON/RED/X(3,12) but it's also dimensioned as: COMMON/RED/X(3,9) in many of the subroutines. Using [Diemo's code](https://www.reddit.com/r/fortran/comments/6kpgpl/help_with_simply_fortran_not_so_simple/djofw7j/), I can run the program, but it is generating bad array indices within the *SOLID* subroutine. On the first pass through *SOLID*, the routine attempts to assign a value into the *U* array at: U(NR+K,NL+L) However, both *NR+K* and *NL+L* are -2, which are both outside the array bounds, causing the program to crash. The original developer needs to figure out why the code is generating negative array indices, and his code should protect against that situation regardless of whether it works or not. 
Thanks I learned a lot thanks to you and /u/Diemo. I will let the old timer know about these problems. 
Fortran 90 and 95 are quite similar, correct? I'll start working with a F90 codebase soon, hope I can use this guide.
From what I understand 90,95,03, and 08 are all collectively called F90 and each newer revision is backward compatible.
Yup
I'll second this. Excellent book. You probably want to know programming basics first though
I like Modern Fortran Explained, though I'm not familiar with some of the other books. It covers features included in Fortran 2008, and I find it to be a useful reference sometimes.
I bought Modern Fortran Explained to learn Fortran for an internship. Good book.
I'll be a 3rd to chime in for Modern Fortan Explained. It's my go to when someone comes to me asking for a Fortran book. 
Ok, so you are using fixed form Fortran here (or Fortran77). This is a terrible idea, fixed form Fortran is awful (We can debate about how good it was for its time but now it is awful). It has a load of unnecessary restrictions (i.e. 6 letter names) and there is really no reason to ever use it nowadays. You want to use (free format) Fortran2003. A lot of the stuff that is available online is in Fortran 77, and it will all still work (Fortran is mostly backward compatible), though the way that you do comments and line continuations is different. Free format Fortran has comments being anything following a '!', and line continuation is by using '&amp;'. Line length is increased though, so the line continuation is not as important. Now, a note about programming in general, as you said that you were new to it. Whenever you are programming, you have to keep in mind that you should be writing it to make it easy to understand when read. So names should be descriptive, which generally means long. With modern IDEs (or vim) you can use variable completion so having long names doesn't increase the amount of typing that you do. I personally subscribe to the idea that you shouldn't ever have to comment your code, as the variable names will comment it for you. Ok, onto your problem. I am a bit confused at what you are looking for here. Do you want to return the load at a particular coordinate for a particular time? (Bear in mind that I know nothing about Abaqus FES). That is what the subroutine below will do. Also, is this the entire subroutine? Because you are passing in a lot of variables that are not being used. subroutine getForceAtTimeAndPosition(ForceOut, TimeIn, CoordinatesIn) implicit none ! You always want to include this for two reasons. Firstly, it helps prevent bugs where you forget to initialise a variable and it initialises to the wrong type. Secondly, explicitly declaring variables makes your code easier to understand. real, intent(out):: ForceOut !The compiler knows that it doesn't have to worry about what is in ForceOut before the function starts real, intent(in), dimension(2):: timeIn !I think this is real? Whatever type it should be real, intent(in), dimension(3):: coords !Intent in is telling the compiler that these will not be changed in the function real:: floor_span, velocity, foot_pressure, start_position, finish_position integer:: i floor_span = 40.0 velocity = 5.0 foot_pressure = 150.0 ForceOut=0 start_position = 0.0 + timeIn(1)*velocity finish_position = 1.0 + timeIn(1)* velocity !do i = 1, 40 I dont think you need this loop, but amn't sure exactly what you are trying to do !Note that your code redefines start here. I am guessing that this isn't what you want to do if ((coords(2) .ge. start_position) .and. (coords(2) .le. finish_position ) .and. (mod(star_position,2.5).eq.0)) then ForceOut = foot_pressure end if end subroutine getForceAtTimeAndPosition 
Of that list, the only to thorough reference is Modern Fortran Explained, it has over 60 pages of F2008 only features/changes, including coarrays. Message to any begginer that might be reading this: be advised that if find it a very bad book to learn the language for the first time. In that case get Chapman's Fortran for Scientists and Engineers, which has recently been updated to include the 2008 standard. 
I appreciate the response, I will definitely check out Fortran2003, thanks for the tip. Onto the problem: I want this piece of code to tell Abaqus when and where to apply a load that represents how a human would dynamically load a structure; essentially a series of impulses spaced at set time and position intervals. The variable I need to define for Abaqus is 'f'. In Abaqus I have an area that I have applied a pressure load to, and this subroutine should essentially apply a non-uniform distributed load across the area such that at say 1 second, a loading area of 1 foot long experiences 150 psf while everywhere else experiences 0 load. For this I am assuming a pacing frequency of 2 Hz and velocity of 5 ft/s which translates into an area being loaded every half second and moving across the floor at position intervals of 2.5 feet. The start variable (or start_position) is 0 at 0 seconds, 2.5 at 0.5 seconds, 5 at 1 second, etc. I guess a better name for start and finish would be heel and toe, respectively. My idea was to take the original code that evaluated coordinates compared to a start and finish variable which encapsulates the desired load region and changes at the desired rate, and add on the condition that when the remainder of the 'start' variable and 2.5 is 0, i.e. at intervals of 2.5, then f = 150, else it is 0. However when running it trying to use that logic and basic if and do loops, it either just wouldn't apply the load at all, or the loads would be applied and then never removed. I thought maybe I could write a loop to evaluate the start variable, determine if a load is to applied, pass the 'f' variable to Abaqus, then re-evaluate the variable. It didn't seem to work that way... As far as the variables being passed in; that is just the standard format that the Abaqus user manual provides, I probably could alter it. The only variables being passed in from Abaqus are the coordinates and time. EDIT: FWIW, here is an animation of my current code that applies the load moving uniformly across the plate, think of a block sliding across the plate or a wheel moving over it. Now I'm wanting it to be walking, essentially the same load but applied at discrete locations. https://www.youtube.com/watch?v=GwetPii_a4Y&amp;feature=youtu.be I appreciate your help. 
*H3LC.FOR* is definitely fixed-format Fortran source code. There seems to be an issue with a special character on the last line of the source code that the compiler is choking on. If you simply delete line 1222 of *H3LC.FOR*, it seems to compile. I haven't tried compiling all the files for AMBEM3, but they may have a similar "last-line" problem.
Thanks that was the problem!
I work with the boundary element method and had already used this exact Fortran codes for reference, was going to give the same advice, there's some weird character at the end of the file, right? Anyway, it's cool that your dad is working with the BEM in acoustics. I hope the code works out for you, good luck!!
The image should be a good description of what I am asking. I started learning python at the beginning of summer and recently had to switch to Fortran for work in the lab. I've done the entire tutorial on fortrantutorial.com, and was going to start continuing my project Euler work in Fortran. This is the result of trying to do project Euler 57 in Fortran, after getting some odd errors I made the same program in python and it works fine. If you have any idea what is causing the problem, please let me know. Also, if you have any reading that could help me circumvent this issue in the future, that would be much appreciated. Thanks!
are you in the U.S.? I am interested.
Both routines are the NAG Library version of LAPACK. The F02 routine was replaced by the F08 routine back at Mark 18. The NAG library is now at Mark 26. The F08 routine combined two F02 routines and the subroutine signature changed. Therefore what your passing to F08NNF probably doesn't have enough size to work with or the right types. The documentation can be found here http://www.nag.com/numeric/fl/nagdoc_fl26/html/f08/f08nnf.html If you have a valid licence for the NAG Library you normally also have support. You can reach them at support@nag.com. They should be able to help and you're probably not the first person who has had this issue. If you don't have support, then try working out it out how to translate the signatures. If you don't have a valid licence, then you need to change to a free version of LAPACK. You can install and that yourself from here http://www.netlib.org/lapack/#_lapack_version_3_7_1 Currently on my phone so I'm sorry for any spelling or grammar mistakes and for being a bit terse. If you are completely stuck send me a PM and I'll take a prober look but that would have to wait for me to have some free time beyond commenting. 
That entirely depends on the code before that. You are not reaching those lines so strr2 and strr3 simply contain, what they did before the loop.
Please put four blanks in front of every line of code so the code appears readable.
if rab2/rab3 are not initialized before the loop anywhere (check for common blocks or include statements), then the author relied upon the compiler to set them to zero. edit: add a compiler flag to check for uninitialized variables.
Did you type this or copy/paste the code? I thought something like A=(b)(C) Would fail to compile in standard Fortran
Thanks, I did not know that!
No, I forgot to mention they were uninitialized variables. This is the first instance of them
No, when I first copied the code over I didn't know how to format it to look like code
Yes rab2 and rab3 are initialized previously, but strr2 and strr3 are not initialized, so how would it treat the new line for rab2&amp;3 when strr2&amp;3 are undefined?
Then this a bad idea, as this is unspecified and could depend on the compiler.
I agree. I am just translating the code into a language I am more familiar with. The code executes fine and the output from Fortran is correct. The person wrote it 20 yrs ago using commands mostly from f77. I am not the greatest at Fortran and this segment caught me off guard.
sorry my comment does not make much sense. I meant to refer to the variables in question, strr2 and strr3, and not rab2/rab3. Same idea, the author relied on the compiler to set the variables to zero. 
This is what I was thinking. Just wanted to make sure. Thanks you!
You can insert a line like print *, strr1, strr2, strr3 after the if lines to see the values it uses (or at any other place). It's totally right that this seems strange to you ;-)
I think the east way to do it is to use a simple loop. Otherwise, you can write the number of element in a format string and use it for the entire array Write(string, '(i4.4,a)') number , 'f5.2' Write(100,string)x 
Can't you do DO-loops implicitly inline for write statements? So something like WRITE(*,*) (X(j), j=1,size(X))
For formatting, why not just write the formatting string the line before: Format_string = CHAR(SIZE(X))//'(F6.2)' Write(*,Format_string) X
Or you can use write (format_string, ...) ... if you have more complex things.
This is a good idea. Thanks!
I don't know.. Can you? I'll try it and report back. BTW- I went with /u/Pums974 suggestion on creating the format as a string.
It is supposed to return the number of elements in the array at least in F90. But I doesn't look like an array, so has it been defined earlier?
ibin is the number of bins. In this case 5. i is just what's being iterated on. This guy has been writing fortran since the 60's. Some of the code he updated. Some he did not. That's why I'm not sure if it was written in an earlier version. Edit: ahh, you're saying size might have been defined earlier. I'll have to check tomorrow when I get back to work. Edit again: now that you mention it, it would make sense if size was the size in the bins and frac is dividing that up. Thanks!
`size` is probably an array here. You'd see it as size[i] in many other languages, if that helps.
yesss but I feel that's considered kind of an old fashioned way to do it, seeing as you can just write print *,x and write out a whole array that way.
One trick is that `write` and `print` don't mind if you specify more formats than values. So if you have real, dimension(50) :: x and you do write(100,'(5000f5.2)') x then it'll just print out those 50 values without complaining. You just need to make sure the value in the parentheses is much larger than the biggest possible size of your array. So this method is very concise, but potentially a little bit dangerous if you are changing the size of the array at any point.
That is a **really** good tip. thank you!
You are correct. I see it defined earlier in the code now. I've been using Matlab the last few years, so I didn't think of size being anything other than size of an array. Thanks. 
Definitely the old fashioned way to do it, but if I'm coding in Fortran I'm almost always dealing with legacy code anyway.
Fortran has an annoying feature of being able to name your arrays the same thing as your intrinsic functions. It's more to keep compatibility with codes written for older F77 compilers, but I've seen people name a variable "sum" and completely lose access to the intrinsic sum function. 
That annoying feature is in MATLAB too so this kind of thing is a common issue in MATLAB code as well.
No premature optimization. Use F2008 features if your compiler supports them. Learn OpenMP asap.
To be fair, if you deal with a massively parallel simulation, you sometimes need to preoptimize because it will make a difference. But yeah, for learning, that's terrible practice. I would say, find some tiny project to learn Fortran around.
Some "optimisations" are always worth anyone's time. 1. When looping through matrix indices, inner loop index should be the left one, outer loop the right one. example: DO k, DO j, DO i, array(i,j,k) = ... 2. Use compiler flags: -fast /fast is the best one (always check documentation though), /traceback for tracking errors during compilation or run time. 3. Check up and use ALLOCATE. Makes life much easier. If you are a university student, grab Intel Parallel Studio XE 2017 for a year, and renew each year while you are a student. I do agree with OpenMP as well. MPI could be a choice for some projects as well. Understand that Fortran is not a good language for every project. Try to find out whether it is the better language for what your project is about. Edit: this was supposed to be a reply on u/markovperfect's comment.
 dt = 0.5 ! seconds dx = 0.5 ! feet s = 40. ! feet floor v = 5. ! ft/s footfall = 150. real f(0:s/dx) ! creates an array of 81 spots, from x=0 to x=40 feet, in 0.5 feet increments real x, x0 ! relative position, starting position DO tstep = 1, tstepmax f = 0 ! initialises the whole array to 0 every computational step x = (tstep-1)*dt * v + x0 ! this scales the time correctly to 0.5s/iteration, starting from time =0 DO i = -2:2 IF ((x/dx+i) .ge.0 .and. (x/dx+i) .le.s/dx) THEN ! check bounds of f f((x/dx+i) = footfall ! example: tstep=2, x=2.5, f(5-2) = f(3), f(5-1), f(5), f(6), f(7) ! ELSE ! this shouldn't be needed ! BREAK END IF ENDDO PRINT *, f, tstep ENDDO So, i did change some of the nomenclature you used, but this should correctly apply the value on all relevant f points, and then on the start of the next time step reset them to 0. Extract f at the PRINT level to get the correct values each time step. Hope it works. Also note that this simulation is 1D. Going 2D is certainly doable, but not handled correctly here. 
Python has break and continue which match exit and cycle in Fortran.
But such break statements only exit the nearest loop, not any further nested loop that the programmer can specify.
Use multiple break statements. :) In practice you don't need a separate command because you can usually structure your code so that if the break gets called in the inner loop it will also trigger a break in the outer loop. For example for x in range(7): for y in range(7): print(x+y) if x+y &gt; 10: break else: continue # loop ended normally (no break) break 
Alright. I've tried running the code and I feel like the solution you've given doesn't really quite solve the problem. To recap, the pseudocode is this: loop (outer loop) loop (inner loop) if (something happens) then break the outer loop (not this inner loop) /* statement 1 */ end if end loop end loop statement /* statement 2 */ When `something happens`, statement 1 which is this special break is executed. Once such a break is executed, it should exit the outer loop as well as the inner one and immediately execute the statement after the loop, statement 2. In the Python code you've given, I've observed that the final `break` statement on the last line in the `for y in range(7)` scope is *never* touched. Consequently, not only will x + y &gt; 10 once when x = 5 and y = 6, but also when x = 6 and y = 5. Me being a curious person, I tried moving the last `break` statement one scope up, to `for x in range(7)`. A new problem emerges: the x is never more than 0 in this program's evaluation. I did this only because I thought you might have indented wrongly, but it doesn't appear to be that way. So, this is the construct that I have been using and it is similar to yours: for x in range(7): for y in range(7): print(x, "+", y, "=", x + y) if x + y &gt; 10: break else: continue if x + y &gt; 10: break # This is like a break relayer. print("Broken out!") # Finally, this statement is executed when x = 5 and y = 6, the first case that satisfies the inequality: x + y &gt; 10. Well, I really don't like how it looks. The if construct is pretty redundant and it seems to add to the clutter, but this seems to be the only solution in Python? Correct me if anything's wrong.
Reddit formatted the code incorrectly. :/ Should be for x in range(7): for y in range(7): print(x+y) if x+y &gt; 10: break else: continue # loop ended normally (no break) break Where the second break is contained in the X loop. The else statement is attached to the Y Loop (In python for statements are sort of an if statement in themselves). Keep in mind this is one of a couple ways to do this. A way to do it that is almost independent of the language is passloop = False do i = 1, 5 do j = 1, 5 if(condition) then passloop = True break endif enddo if(passloop) break endif enddo
In C and C++ you can use goto for this. Java has break with label. But I think that in many cases using a separate function and `return` will end up more readable.
That's what I meant when I said "bad programming practice". I hear that `goto` is not the go-to solution (sorry, pun intended) for this in C. EDIT: It appears that there are certain exceptions to this rule. Thanks.
Perl has this, it's awesome. You can break or continue a specific loop. EDIT: here's an example... LINE: while (&lt;STDIN&gt;) { next LINE if /^#/; # discard comments ... }
After working on old F77 codes I can confirm, goto is the devil. :)
Many Fortran users feel the same way about using GO TO. The reason being that it may introduce unnecessary, un-optimizable branchings of the code. But if the logic of your program demands it, then there is no way around such a structure.
I'm curious what your actual use case here is? /u/LoyalSol 's answer strikes me as pretty language independent, the inner loop sets some kind of flag that the outer loop checks. One of the common rags on goto is that you can pretty much always restructure a code to get the same logic. I'm wondering what your tangible use case here is though, since it's essentially saying your inner loop knows something about what it's operating on that the outer loop doesn't know about, and now your inner logic is controlling your outer logic which is a code smell. There's probably a better solution than what you're looking to have looks do. 
I've had to do this a few times for some branch search algorithms related to molecular simulations. The outer loop in my case was a "guarantor" loop because the algorithm has a guarantee that if it hasn't converged in sqrt(N) number of loops that it will never converge so I can use this to prevent wasting time. Inside the loop is actually an i loop which also contains a j loop. This loops over the number of members in the network and the j loops over the neighbors of the current i member. Initially the I loop starts small, but can grow fairly large in size so it is beneficial to check if the convergence criteria has been met after the j loop exits so see if further computations are needed. If it's met you break the i loop and then you need to make sure to break the outer most loop as well. Very efficient overall. It's O(N^2 ) in the worst case scenario, but on average it's actually closer to O(N)
I do nonlinear Newton solvers that loop through inner linear solves that kind of has a similar bend, where if the inner solver diverges then the outer nonlinear solve needs to know about it. But you don't want to give direct control over the flow of the program to an inner loop thing that doesn't/shouldn't know anything about the rest of the program. In my case the linear solver diverges, or stalls, or converges overly fast, it should just inform the outer nonlinear solve what happened so the outer structure can decide how to proceed. Sometimes shrinking the Newton step and trying again will fix it, sometimes using a different linear solver or nonlinear solver will fix it, but in either case the inner iterations shouldn't have any idea about that. Lots of Fortran and C code solve this by returning error codes. In my case the nonlinear solvers need linear solvers, but I can't reuse linear solvers with other nonlinear solvers if you introduce a two way coupling where the inner process controls the outer one. It totally breaks encapsulation to give direct control of outer structure to inner ones. It's part of why desiring/needing a goto is a pretty bad code smell. 
In my case this is a small function that checks to ensure a geometry criteria is met. It's part of a larger Monte Carlo code. After each trial move, you check to ensure this criteria is met and if it isn't you reject the Monte Carlo move and go back. The problem with letting the outer loop handle everything is that sometimes the inner loop can grow to be incredibly large so if you don't break it the minute the criteria is satisfied you can end up wasting time on calculations that ultimately are meaningless. Which this function easily gets called billions of times over the course of the simulation so a small inefficiency is a huge inefficiency. I actually tried that for my first version of the function, but it ended up slowing down big time when you scaled the system size. The early exit from the inner actually resulted in a massive speed up. You could technically rewrite the loop as to merge the outer loop and the first level of the inner loop, but the resulting code would be much harder to understand if someone else ever had to work on it. Of course I never use goto statements, break usually does everything I need. This is more an edge case rather than the rule since most other cases I can rework the flow of the code more easily. 
To expand on the goto thing: goto has a bad name because of all the spaghetti code from the 60s and 70s, when languages didn't have all the looping and branching constructs you expect these days, which would lead to unmaintainable messes. Today the general advice is to not use goto, unless the other options are more ugly. You could introduce some flag variable, and put an extra `if flag then break` statement at the end of the outer loop. I think a simple goto is often much more readable than introducing a flag variable, but some people once read the title of "goto considered harmful" and decided that every use of goto is always harmful. There's a theorem that you can replace every goto by appropriate if statements and some people might refer to that, but that theorem doesn't say anything about how readable the code is after the replacement so I don't consider it to have any value.
Look at the value of n, does it ever change? Also does x,y, or z change in your code? If not why are you using them in an If-statement then?
Thanks for the reply. No, I know what I need to do in english: Set total = 0, x=1, and n=0. If x is divisible by 3 or 5 but not both, add x to total, and add 1 to n. Then add 1 to x. Repeat until n is 1234. I'm just not sure how this translates into Fortran code. 
The problem is currently in your code the values of n, x, y, and z are all constant. So basically you have an infinite loop that does the exact same thing again and again. When you say n = x + 1 you are saying set n to the value of x + 1. Well the problem is x=3 and there is nothing in the loop that changes x's value. Thus n = x+1 will always set n=4. If you wish to increment n then you need to write something like this n = n + 1 Either x or n needs to change, but neither changes in your loop. 
Alright, that makes sense, thank you !
* You should give 'n' an initial value, although not like the others. Do it in a separate line. * It doesn't really make a difference in your case, but you should be using MODULO, and not MOD. * Shouldn't you be checking the modulo of 'n', and not 'x'? You should first write down the logic of your program before you put it down in code.
For anyone who is interested, i've fixed the code and here is the solution: program sum implicit none integer :: x = 1 integer :: count = 0 integer :: T = 0 do while (count &lt;= 1234) if (mod(x, 3) == 0 .or. mod(x, 5) == 0) then print *, T T = T + x count = count + 1 end if x = x + 1 end do end program sum
Thanks for the reply, i've fixed the code :)
A couple of things. Your logical test in your while loop uses X which does not change within the loop, therefore you have created an infinite loop. Also, I don't know what your term is to calculate z but it does not resemble Taylor series expansion of sin. Also remember you only need to calculate the odd order terms. 
Hi, I've edited my code a lot and am now getting some better answers printed, but it gets progressively lower as oppose to closer to the correct value. Here's my new code: program taylor implicit none integer :: k = 0 real :: y = 0.75 real :: x = 0.75 do while (abs(y - sin(0.75)) &gt; 1E-6) k = k + 1 y = y + ((y * (-x * x)) /( 2 * k * (2 * k + 1 ))) print *, y end do end program taylor It doesn't resemble the taylor series because I found how much each term changes by (in terms of its ratio to the previous term) and am using that to print it. How can I fix this so it prints what I want? Thanks. 
Working program: program taylor implicit none integer :: k = 0 real :: fac = 1 real :: y = 0.75 real :: x = 0.75 real :: px = 1 integer :: sgn = -1 integer :: s = 1 do while (abs(y - sin(0.75)) &gt; 1E-6) k = k + 1 fac = fac * (2 * k) * ((2 * k) + 1) px = px * (x * x) s = s * sgn y = y + ((s /(fac)) * (px * x)) print *, y end do end program taylor 
For mathematical functions such as this, I often find writing them as a function class or a subroutine (if there's more than one input) makes the program much nicer. Obviously here there is no need, however it saves time as in the future you may want to modify this program and use it in a larger more complex program. Also, Its been suggested to me, by some serious computational physics gods to avoid using do whiles if you can, find another logic test to avoid the program going to infinity. Sorry this isn't a more direct answer to your question, I just had a few comments.
At least post an attempt; we can then help fix it.
The reason I didn't post my attempt is because it's pretty pathetic, but here it is: program pi implicit none integer :: count, n, i real :: r, x, y count = 0 CALL RANDOM_SEED DO i = 1, n CALL RANDOM_NUMBER(x) CALL RANDOM_NUMBER(y) IF (x*x + y*Y &lt;1.0) count = count + 1 END DO r = REAL(count)/n print *, r end program pi
Is this your homework? Because you keep asking these questions and then deleting them when someone answers
I posted it once before, and deleted it because I'd not made any real start on the physical code. I've since made a lot of progress, and have now re-posted it with my code. It's an assignment, yes. 
Just put a print statement inside the loop.
Thanks for the reply. So say I wanted to print out corresponding values for n = 10, 100, 1000, 10000, 100000, 1000000, how would I write this into my code?
Wrap the print statement in some ifs?
This isn't the program for this question, but anyway... What is wrong with the program? What error are you seeing?
Well, at this point I have this: program pi implicit none integer :: count, n, i real :: r, x, y count = 0 CALL RANDOM_SEED DO i = 1, n CALL RANDOM_NUMBER(x) CALL RANDOM_NUMBER(y) IF (x*x + y*Y &lt;1.0) count = count + 1 IF (mod(i,1000) == 0) then r = 4 * REAL(count)/i print *, i, r END IF END DO end program pi Now this prints out each value for pi for every 1000 "i". However, it goes on until the output limit is reached. How can I limit this so that it only goes to 10000? Thanks
What's 'n'?
Sorry, I forget that we're talking about code that is completely different to my original question. So it's a program to calculate pi by using the monte carlo simulation, and I want it to print out each value of pi (r) for each corresponding value of i (not n, my bad), as i increases in steps of 1000 until 10000. thank you
Get started by installing [homebrew](http://www.macinchem.org/reviews/cheminfo/cheminfoMac.php). Homebrew is a package manager - it lets you quickly and easily download and install tools, libraries, and applications that are (usually) pre-compiled and always ready to work with your Mac. Then, just install/update the **gcc** compiler. `$ brew update` `$ brew install gcc` Then you can invoke the command `gfortran` to compile your code.
You could try [Simply Fortran](http://simplyfortran.com/) for macOS. It includes a compiler and a development environment. On first run, it should trigger installation of some Apple development tools you might need. Simply Fortran is a paid product, though there is a 30-day trial, so I get it if you'd like to try some other options. Homebrew is also a good choice, as /u/counters suggests. *(Note: I am the developer of Simply Fortran)*
That is not what I meant. I'm asking you what the value of 'n' is, in your program.
As yes, I've set n = 10000 now and that's sorted it. Thanks ! 
Interesting. What compiler does it use?
It currently ships with GNU Fortran 7.1.
or a single one and using log
Very interesting project! Any plans for MPI support? I'm particularly thinking of Windows.