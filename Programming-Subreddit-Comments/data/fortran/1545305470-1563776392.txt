Here is an idea how to check: put the breakpoint inside `C_SUB` and check if all the fields of the result are allocated prior the call of `MKL_ZCSRADD`.
I actually just checked with ifort: you need to allocate inside the function, not on a caller side. No need to allocate on the caller side at all, so no double allocation and no need for `MOVE_ALLOC`.
As the other commenter said, I believe the problem here is that you might be trying to use parts of an object that have not been allocated yet. However, since you are worried about being memory efficient, I would like to add a comment. It might matter to you that whenever you call on C_SUB the memory required to store that values might be set in the stack. I'm not sure if this behaviour is compiler/SO dependent and I'm not sure how it works with user defined types, but it has happened to me that I had to change functions with array(:,:) outputs to subroutines because they were depleting all my stack. Technically setting it as allocatable was enough to indicate that the variable had to be in the heap but then there was the duplication of memory issue (var = C_SUB might be creating one object for var and another for C_SUB). In conclusion, and as far as i could find out, if you really want control over the memory, it is better to use subroutines instead of functions. Some co worker also told me that he found a similar behaviour when referencing data of an object (ie: C_SUB%values would create a temporary stack variable to store that instead of actually passing the pointer to the object data). However, this coworker is very anti-oo and I have never observed this behaviour myself, so I would pay attention to it but wouldn't take preventive measures yet. 
Don't, please. It's old and unused language. Wasted time.
Its for an assignment, I don't have a choice. If I don't do it.. I fail. 
Thank you, I'll try this! 
I understand. Do you have an option to use modern fortran, like 2008? At least you will learn something useful! 
Has to be 77 only. Otherwise its a fail. 
Thanks mate! That was exactly the issue. C\_Sub did in fact have unallocated fields, despite me allocating those fields in the assigned variable beforehand. Maybe it is the case that, as the function output is necessarily `intent(out)` the address of the LHS is not passed? This would be consistent with the subroutine variant requiring that the output C be of `intent(inout)` . 
Thanks for your comment, that is something I had actually been wondering myself. The fact that the function does not seem to initially receive the address of the LHS indicates to me that there may be some sort of duplication going on. I suppose this would explain the preference for subroutines in most high-performance Fortran based libraries. Though I sure hope that referencing object types does not cause the same behaviour! That'd severely limit their utility and sounds rather un-Fortran like to my (rather inexperienced) ears. But I'll keep an eye out for that behaviour. 
Yeah boi!!! Just picked up the 2018 edition of 'Modern Fortran Explained' so I am ready! \*waits for industry wide adoption\* \*dies\* My experience of learning Fortran over the last year has consisted of me finding that, however my professors have explained how to do something, there's probably a better way to do it using modern Fortran. Slightly frustrating, but hey, I get to feel kinda smug. 
F77 it's still in use, but only for particular routines on computationally heavy programs for scientific simulation or numerical integration (like fluid dynamics or plasma physics, for example) where this specific version of Fortran has proven to be or faster, or more compatible with some older, already optimized libraries. But I have to agree with you that the professor should have asked at least for an F90 code. For an undergrad assignment, F77 it's overkill. However, if it's for grad school, and the OP research involves scientific computing, it will be useful at some point. I think.. 
&gt;Thanks for your comment, that is something I had actually been wondering myself. The fact that the function does not seem to initially receive the address of the LHS indicates to me that there may be some sort of duplication going on. I suppose this would explain the preference for subroutines in most high-performance Fortran based libraries. To add up to this, I just remembered that the behaviour was predominantly compiler dependent. By default the Intel compiler puts these temporal variables in the stack, while the gnu compiler puts them in the heap. You can pass a flag to each to change this behaviour, but depending on your code this might have an impact in performance. 
I ran into this just the other day. They even do it with `logical(c_bool)`, which actually HAS a defined representation. It's absolute bullshit. The big hammer is [-standard-semantics](https://software.intel.com/en-us/fortran-compiler-developer-guide-and-reference-standard-semantics). Smaller hammer is [-fpscomp logicals](https://software.intel.com/en-us/fortran-compiler-developer-guide-and-reference-fpscomp).
Ah perfect, `-fpscomp logicals` sounds like exactly what I need. Thanks
That's just bizarre. Why? Did he explicitly say using free-format was a fail, or just some new features in F08/18? I'm trying to wrap my head around why this would be forbidden. Fortran is pretty good about allowing mixed syntax even in legacy programs.
I tested with the PGI compiler and the result it's the same as with the Intel compiler. pgfortran test.f90 -o pgtest ./pgtest .TRUE. = -1 .FALSE. = 0 The three versions (6,7 and 8) of gfortran I tested show this warning: gfortran test.f90 -o gtest test.f90:7:9: itest1 = ltest1 1 Warning: Extension: Conversion from LOGICAL(4) to INTEGER(4) at (1) test.f90:8:9: itest2 = ltest2 1 Warning: Extension: Conversion from LOGICAL(4) to INTEGER(4) at (1) but the code compiles, and gives the same results as yours for this compiler, as you can see. ./gtest .TRUE. = 1 .FALSE. = 0 Honestly, I only tested this because I always got curious about these differences between compilers. Since the PGI, another proprietary compiler, has the same result as ifort, we can conclude that this is some feature they implemented. Perhaps reading the documentation of both can help you to understand what is going on here. I wish I had time for that... 
Well, -1 is 0xfffffff (all bits set), so I can see the reasoning behind the choice.
A good rule of thumb is to always compare with zero, never with 1 (or -1). If it's zero it's false, if it's not zero it's true, no matter what is the value. That's also a good rule of thumb in C, anything different from zero is true (even negative numbers) in a Boolean context, so comparing with zero always works.
In this case, comparison wasn’t the source of the bug we were experiencing. We basically had an integer = logical and, if (int) then do a loop and increment said int by 1 every loop. Of course, -1 + 1 ended up killing the loop after 1 iteration every time. I ended up changing it to an explicit if (log) then Int = 1 Else Int = 0 end if
That's the correct solution. The point of the rule I mentioned is that you shouldn't rely on the integer representation of true value because in the end it's up to the implementation. And relaying on compiler flags is very fragile.
Cheers mate, this is good to know!
Not entirely sure what’s the magnitude of change you need. I have tried some tools but they are not very useful, just saves me 10%. Best to redo function by function. You could also bootstrap your auto conversion if you k ow your project well. Have you tried f2py? Writing for Numpy will be best to start.
I will read it up! Thanks!
The Fortran standard does not specify an implicit conversion of Boolean variables to integers. The mistake was that you assumed it. This behavior is very compiler dependent (as you discovered), and no code should rely on this. The IF conditional is the right way to do it.
If you’re happy to stay in Fortran I can recommend the pyplot Fortran library written by https://github.com/jacobwilliams. He’s written a lot of good modern Fortran tools! Otherwise f2py should require pretty minimal work to make callable functions.
Many use both Fortran and Python. Do the number crunching bits in the former, and write the data to a file; then perform all the analysis and plotting using python/scipy/matplotlib
 f2py sounds cool.
Fortran 77 should not be used anymore. It's been more than 25 years since F90 was published, codes that have not been updated since can be safely considered dead. It's a pain that OP is required to study such an obsolete language.
I'd recommend calling Fortran procedures from python. It's quite easy once you learn it.
Relying on compiler flags is not a good idea in this case as the code will be highly unportable. Just use ``itest1 = merge(1, 0, ltest1)``.
I think we can agree that OP's professor is a sadistic dinosaur. :v It's the only explanation! Poor OP... 
I dont really understand how it works
Not do I. Any resources on that?
Thank you! I only knew the (also great) JSON library...
Hey [**u/GayChemistt**](https://www.reddit.com/user/GayChemistt/) Currently I'm studying a MS in Chemical Engineering. Last semester we learned the basics in Fortran 77. I recommend that you read Chapter 1 of Coleman, T. F., &amp; Van, L. C. F. (1991). *Handbook for matrix computations*. Philadelphia: Siam. You'll get the basics there. Fortran 77 Reference Manual can do the job too. Good luck.
The "GO TO 70" is saying go to "70 H(1)=HR" that's the 70 it means not line 70.
Hi thank you for the response! So does that means the code should be something like this? &amp;#x200B; Also, after "60 CONTINUE" everything is under "DO 90" loop? DO 90 K=1,KMAX-1 T=2.*DT*K DO 60 I1=2,3 DO 50 I=I1,N,2 ... Q(I)=(3.142*(D/2)**2*ALPHA(I)/2)*(CA+CB) 50 CONTINUE IF (N.LE.2) H(1)=HR 60 CONTINUE C Upstream boundary conditions Q(1)=(H(1)-H(2)+B*Q(2))/(B+R*ABS(Q(2))) .... &amp;#x200B;
Something like this (sorry if formatting isn't perfect): &gt;DO K=1,KMAX-1 &gt; T=2.*DT*K &gt; DO I1=2,3 &gt; DO I=I1,N,2 &gt; ... &gt; Q(I)=(3.142*(D/2)**2*ALPHA(I)/2)*(CA+CB) &gt; END DO &gt; IF (N.LE.2)THEN &gt;C Upstream boundary conditions &gt; H(1)=HR &gt; EXIT &gt; END IF &gt; END DO &gt; &gt; Q(1)=(H(1)-H(2)+B*Q(2))/(B+R*ABS(Q(2))) &gt; &gt;C Downstream boundary, first determine TAU &gt; IF (T.LT.TC) THEN &gt; TAU=TI-(TI-TF)*(T/TC)**EM &gt; ELSE &gt; TAU=TF &gt; ENDIF &gt; CV=TAU*TAU*CVP &gt; &gt;C Calculate value QP and HP &gt; CP=H(N)+Q(N)*B &gt; BP=B+R*ABS(Q(N)) &gt; Q(NS)=-CV*BP+SQRT(CV*CV*BP*BP+CV*CP*2.) &gt; H(NS)=CP-BP*Q(NS) &gt;C Store variables for graph. Print results if needed. &gt; YTGR(K+1)=H(IGRAF) &gt; DO I=1,NS,2 &gt; IF (H(I).GT.HMAX) HMAX=H(I) &gt; IF (H(I).LT.HMIN) HMIN=H(I) &gt; END DO &gt; WRITE (8,802) (H(I),I=1,NS,2) &gt; IF (MOD(K,IPR).EQ.0) &gt; 2 WRITE (7,702) T,(H(I),I=1,NS,NP),TAU,(Q(I),I=1,NS,NP) &gt;CCC MISSING REST OF IF-LOOP &gt;END DO
Hi so sorry but can u put it in codeblock? I cant understand what you did haha... Thanks!
Sorry, working on it...
 DO K=1,KMAX-1 T=2.*DT*K DO I1=2,3 DO I=I1,N,2 ... Q(I)=(3.142*(D/2)**2*ALPHA(I)/2)*(CA+CB) END DO IF (N.LE.2)THEN C Upstream boundary conditions H(1)=HR EXIT END IF END DO Q(1)=(H(1)-H(2)+B*Q(2))/(B+R*ABS(Q(2))) C Downstream boundary, first determine TAU IF (T.LT.TC) THEN TAU=TI-(TI-TF)*(T/TC)**EM ELSE TAU=TF ENDIF CV=TAU*TAU*CVP C Calculate value QP and HP CP=H(N)+Q(N)*B BP=B+R*ABS(Q(N)) Q(NS)=-CV*BP+SQRT(CV*CV*BP*BP+CV*CP*2.) H(NS)=CP-BP*Q(NS) C Store variables for graph. Print results if needed. YTGR(K+1)=H(IGRAF) DO I=1,NS,2 IF (H(I).GT.HMAX) HMAX=H(I) IF (H(I).LT.HMIN) HMIN=H(I) END DO WRITE (8,802) (H(I),I=1,NS,2) IF (MOD(K,IPR).EQ.0) 2 WRITE (7,702) T,(H(I),I=1,NS,NP),TAU,(Q(I),I=1,NS,NP) CCC MISSING REST OF IF-LOOP END DO
Thank you so much for your help! &amp;#x200B; Actually i have one more question i would like to ask about the "..." in the main question. I don't really understand what is the use of calculating CP and CM, since it will not be used in other part of the equation, and we are assigning CA into CP? Do you understand the meaning behind it? (You can ignore the math portion, i am just curious whether can i remove CP and CM equations) &amp;#x200B; CP= B*(Q(I)/ALPHA(I))+ (1/PL*A)*((H(I)/10)-(HV/10)) +(A/2) 2 *LOG((ALPHA(I)*PL)-((1-ALPHA(I))*PV))/PL-(A*S*PS 3 *(PV/(ALPHA(I)*PL+(0.02*PG)+(1-ALPHA(I)-0.02)*PV)) 4 *(1/(H(I)/10))) CM= B*(Q(I)/ALPHA(I))- (1/PL*A)*((H(I)/10)-(HV/10))-(A/2) 2 *LOG((ALPHA(I)*PL)-((1-ALPHA(I))*PV))/PL+(A*S*PS 3 *(PV/(ALPHA(I)*PL+(0.02*PG)+(1-ALPHA(I)-0.02)*PV)) 4 *(1/(H(I)/10))) CP=CA CM=CB CA= another set of math equations CB= another set of math equations IF(CA.GE.CB) THEN ALPHA(I)=1-0.02 ELSE ALPHA=1 &amp;#x200B;
I'd just make sure they're not being used before being set to the other values. If this is the case, comment them out, compile, rerun and compare the results, if they're the same, it should be okay.
Hi thank you for your help, i really appreciate it! &amp;#x200B; I just have 1 last question to ask! &amp;#x200B; In the program, a graph (T to H) graph is to be plotted. However i cant tell or cant recognise which part of the code actually plot the [graph.Do](https://graph.Do) you happen to know ?
np, old Fortran code can be a pain sometimes. I'd need to see the code. There's a couple write statement but I don't know what the formatting is as it's not included in what's here.
It looks like the variables are just written to a text file so you can plot them with a different program. 
 DIMENSION H(21),Q(21),ALPHA(21),XGR(21),YGR(21),YTGR(400) DATA HMAX,HMIN,T,NP /-1E6,1E6,0.,1/ OPEN (3,FILE='SINGLE.DAT') OPEN (7,FILE='SINGLE.OUT',STATUS='REPLACE') OPEN (8,FILE='SINGLE.GRF',STATUS='REPLACE') READ (3,301) A,XL,D,F,G,HR,TMAX,CDA0,TI,TF,TC,EM,N,IPR,IGRAF 301 FORMAT(4F10.4/4F10.4/4F10.4/3I5) C Some properties not required WRITE (8,801) IGRAF,KMAX,NG,TMAX 801 FORMAT (3I5/F10.3) C Find steady state flow Q0=SQRT(2.*G*CDA0*CDA0*HR/(R*N*2.*G*CDA0*CDA0+1.)) H0=HR-R*N*Q0*Q0 QI=SQRT(HR*Q0*Q0*TI*TI/(R*N*Q0*Q0*TI*TI+H0)) C Store initial variables DO 20 I=1,NS,2 H(I)=HR-(I-1)*R*QI*QI XGR(I)=FLOAT(I-1)/N YGR(I)=0. IF (H(I).GT.HMAX) HMAX=H(I) IF (H(I).LT.HMIN) HMIN=H(I) IF (YGR(I).LT.HMIN) HMIN=YGR(I) Q(I)=QI ALPHA(I)=ALPHA0 20 CONTINUE CVP=.5*Q0*Q0/H0 TAU=TI YTGR(1)=H(IGRAF) WRITE (8,802) (XGR(I),I=1,NS,2) WRITE (8,802) (YGR(I),I=1,NS,2) WRITE (8,802) (H(I),I=1,NS,2) 802 FORMAT (6F10.3) 77 WRITE (*,701) A,XL,D,F,HR,H0,Q0,QI,CDA0,TI,TF,TC,EM, 2 G,B,TMAX,DT,N,IPR WRITE (7,701) A,XL,D,F,HR,H0,Q0,QI,CDA0,TI,TF,TC,EM, 2 G,B,TMAX,DT,N,IPR 701 FORMAT (' A, XL, D, F =',2F8.1,2F8.4/' HR,H0,Q0,QI =',2F8.2,2F8.3/ 2 ' CDA0,TI,TF,TC,EM=',5F8.3/' G, B, TMAX, DT =',F8.3,2F8.1,F8.3/ 3 6X,'N, IPR =',2I4//' HEADS AND DISCHARGES ALONG THE PIPE'//' 4 TIME X/L 0. .2 .4 .6 .8 1. TAU') WRITE (7,702) T,(H(I),I=1,NS,NP),TAU,(Q(I),I=1,NS,NP) 702 FORMAT (F8.3,' H=',6F8.2,F7.3/10X,' Q=',6F8.3) .... Program is above! .... WRITE (8,802) (YTGR(I),I=1,KMAX) WRITE (*,703) HMAX,HMIN WRITE (7,703) HMAX,HMIN 703 FORMAT (/' HMAX, HMIN =',2F8.2) WRITE (*,704) 704 FORMAT (/' -- Done! Tabulated output in SINGLE.OUT.'/ 2 ' Graphic data in SINGLE.GRF. Run GRAF.BAS for graph.') CLOSE(3) CLOSE(7) CLOSE(8) END &amp;#x200B;
Looks like the "write (8,..." statements are where the graph is being generated. 
So the statement "write" means print or plot graph? or print out the value of what we want?
Yeah, there's an "open (8, file="...",...)" line that tells you where it's writing to, and then the "write (8,802)..." lines tell you that it's writing to that file (8) and had the format defined by the line "802 format (..."
Thanks! U are amazing
Haha no worries and good luck with it.
This may not be the answer you're looking for, but when dealing with "updating" code I have found it easier to understand what the old code is supposed to do and re-write it from scratch using all the new features of the language you're porting to. Just my $0.02 :)
Poor me for sure, I'm racking my brains out over this assignment!! 
Thank you! 
I don't see how to help you here... Can you share what you would code by yourself ? Then we could help you if it is not working. Plus, could you please format the code ? it would be easier to read 
Your code is messy. If I got it right, you just want to create a new subroutine. You can add CONTAINS at the end end put it there. Take a look on some introductory fortran text.
also, there are some problems on thia code. You use n withy defining and a Do loop without a integer counter.
First things first, try compiling what you wrote, look at the compiler errors, and fix them one by one.
Yeh I've realised, ive fixed all the errors but I dont get what you mean by without an integer counter? &amp;#x200B; The point of that do loop is to read data from a file, where each line = number, the point of the do loop is to read each line and not to assume how many lines they might be. The file should work if theres 100 lines or 10. 
Fixed all the errors and I didnt realise you had to properly indent it and format it on reddit - sorry
Fixed all the issues with my code, what do you mean by a CONTAINS statement, could you explain what you mean please - searched online and couldnt really find anything
Fixed all the issues with my code, sorry 
I don't think you did any of the tings I asked. It is all still the same. 
Not on the reddit but on my actual code (which is a guideline of what I want to do)- I'm not posting my actual code on reddit - against university rules. &amp;#x200B; This code was literally just a guideline.
Yes, but what I meant to ask you to do was clean up the part that you posted, so that people will be more willing to look though it and help you.
The names of procedures in modules are mangled. You need to use DLLEXPORT attribute. See [here](https://software.intel.com/en-us/forums/intel-visual-fortran-compiler-for-windows/topic/402276) and [here](http://www.lahey.com/docs/lgf10help/lfugmlpdllbuild.htm). However, it is a question if this would work with Visual Fortran. (A side question: why do you still use it? if you don't have a license for Intel Fortran, you can opt for GFortran)
GFortran 8.1 should have up to the F03 standard at least. Generally speaking F90 or later is what you should be using for new codes. The old F77 style is kept around for compatibility with older code bases. F03 is F90 with some extra syntax and the introduction of object oriented programming paradigms. 
gfortran 8 implements a lot of [F2008](https://gcc.gnu.org/wiki/Fortran2008Status) and a lot of stuff from the some of the [new interop with C.](https://gcc.gnu.org/wiki/TS29113Status)
[This book](http://fortranwiki.org/fortran/show/Modern+Fortran+Explained) is a good start for "modern" Fortran. It's about general purpose programming and not specific to numerical methods/scientific computing. The large legacy codebase (some in F77) has its advantages and disadvantages.
Probably the wrong sub for this but:. If you don't have legacy code to maintain, why fortran?
Yeah I couldn't remembber which one went to the F2008 standard, but F2003 introduced some of the biggest changes minus the C interop. 
For scientific computing it's still one of the better languages out there. Learn it along with Python for high level stuff and you pretty much have everything you need. 
I second this book. It is really good and all the code examples are in the modern style. 
There are scores of textbooks written on this problem. There is no general answer. My advice would be to start reading and trying different solvers. If you find a good one, write a journal article!
Minimisation is not specific to Fortran. If you are looking for another algorithm, go and ask on r/datascience or r/opimization. Sharing you code can allow us to help you on the Fortran part. Anyhow, more information about the function are needed. Is it continues ? Can we compte it's derivative (Jacobian matrix)? Is there local minima ? Is the domain bounded ? Are the variables discrets or continues ? The answer to your question depends on the answer of all of these question. 
I've written some back-end code to aid Python. Things Numpy can well do but which need to be much faster. I wrote some in C but Fortran makes more sense. Also, really, just a lot of curiosity about a language that is still so well suited to task. Also, when I was a wee child I used to think punch cards were pure magic.
Thank you for the link.
You don't technically need an array, even. You can just have a DO loop with a PRINT statement inside it. 
Any idea how I could write a do loop where I only get 0,4,8,12 etc. Literally brand new to programming and brand new to fortran77.
Begin by finding out what each of the keywords do i.e., `DO`, `WRITE`, `IF`, `CONTINUE`. Use the internet. And then you can ask if you're stumped by something specific.
So, which other language(s) do you know? The loop: DO 90, K=1, KMAX-1 ... 90 CONTINUE is a loop from k=1 to KMAX-1 between those lines. (for loop, in C terms). '90' here is a line label. T=2.*DT*K Straightforward assignment. Note Fortran needs the "2." to include the decimal point, to make the calculation floating point, else "2" becomes integer and the result is an integer. WRITE(8,802) (H(I),I=1, NS,2) WRITE(8,802)(YTGR(I), I=1, KMAX) For the write statements, it writes results to "Unit 8", typically a file. If you've opened a file as unit 8 beforehand, it uses that filename, otherwise it writes to a file "fort.8". (Aside: when Fortran was invented, 'Unit 8' might be a physical device such as a paper tape printer or punched card reader, etc. This was retrofitted to use files in modern computers). The results of the write are formatted according to a "format" statement on another line, line 802 (labelled "802" in the first 6 chars of the line, similar to the '90' label on the continue line. If you need the format statement explained, include it; otherwise go to a manual for it. The same Format line can be used in multiple write/read lines (as shown in the snippet). In this case, the write statements receive a bunch of numbers: (H(I), I=1,NS,2))" Means "the contents of array H, from element 1 to NS in increments of 2". Similarly for the last line, where the increment is left out "YGTR" for I is 1 to KMAX, increment 1". The IF statement uses the "intrinsic" MOD or Modulo function, so K modulo IPR, '.EQ. 0' means "equals 0". And the WRITE(7,702) is another write statement, to Unit 7 according to format line 702. outputting a variable T, the contents of array H for range 1 to NS step NP, variable TAU and another array Q. 
DO I=0,40,4 WRITE(*,*) I END DO Do loop syntax is "variable=start, end, increment" With the increment being optional (default is 1). You could also do it with an "implied loop": WRITE(*,*) (I, I=0,40,4) The second part (I, I=0,40,4) translates to "the expression 'I', where I=0 to 40 in increments of 4".
yeah, I know. But an important constraint is the availability of the algorithm in fortran. I don't want to have to write it myself. The function is continuous, I cannot compute its derivative, rhere are possiblely local minimums and variables are continuous.
Hi, thank you very much for taking the time to write out such a detailed description for me! I apologise that i did not provide much information about the things i know! &amp;#x200B; I have some knowledge of python and basic fortran and C programming. &amp;#x200B; What i am trying to dois to convert a fortran code into python, but i need to understand which part of the codedo i extract the values to be used for plotting the graph. Do you by any chance be able to identify which part of the program ( or even better which variables at which line ) does that? I am plotting a H - T graph, and YTGR is the history of time variable head at section IGRAF for plotting. OPEN (7,FILE='SINGLE.OUT',STATUS='REPLACE') OPEN (8,FILE='SINGLE.GRF',STATUS='REPLACE') ... DO 90 K=1,KMAX-1 T=2.*DT*K ... WRITE (8,802) (H(I),I=1,NS,2) IF (MOD(K,IPR).EQ.0) WRITE (7,702) T,(H(I),I=1,NS,NP),TAU,(Q(I),I=1,NS,NP) 90 CONTINUE WRITE (8,802) (YTGR(I),I=1,KMAX) WRITE (*,703) HMAX,HMIN WRITE (7,703) HMAX,HMIN 703 FORMAT (/' HMAX, HMIN =',2F8.2) WRITE (*,704) 704 FORMAT (/' -- Done! Tabulated output in SINGLE.OUT.'/ 2 ' Graphic data in SINGLE.GRF. Run GRAF.BAS for graph.') &amp;#x200B;
Thank you so much! Youre amazing. &amp;#x200B; Quick question, after doing this Do loop and creating I which will list my numbers 0,4,8,12 etc. Is there anyway to save these numbers and pass them to another subroutine if required? 
Check out NLopt
&gt; INTEGER MYLIST(11),NCOUNT &gt; NCOUNT=0 &gt; DO I=0,40,4 &gt; WRITE(,i) I &gt; NCIUNT=NCOUNT+1 &gt; MYLIST(NCOUNT)=I &gt; END DO &gt; .... &gt; CALL mysubroutine(mylist,ncount, ..)
Alright. Then I'd like to know why the Nelder mead methode do not converge... Does it oscilate ? Or is it just slow to converge ? Have you tried with à dummy function for which you know the actual minimum ? You may try the swarm methode : https://github.com/zaman13/Particle-Swarm-Optimization-Fortran-95
Parallelized vector/matrix operations. That's about all I really see it used for nowadays outside of legacy code.
I would like to have a good answer for that. But, so far, I just have slow convergence. It requires too much iterations and always reach the maximum. One possibility that I suspect is that, for some parameter range, the function is not concave. But this is a guess. This is a problem specific to this function. For others, everything is ok. So I want to try different algorithms and see whicj performs better.
Basically a big fixed point problem. A bunch of loops, which are easy to write in fortran.
The wikibook (https://en.wikibooks.org/wiki/Fortran/memory_management) says that the COMMON statement is obsolete. If someone's telling you to use it, you might want to object. At any rate, take a look at that section on memory management if you'd like to learn more. 
Blame my University lecturer. I have to use it unfortunately, remember I am using fortran77. Imagine how old fashioned he is.
I develop a thermal-fluids code used to analyze power plant systems. The code I develop has a long history and we don’t have many developers left but I would consider the analysis we perform to be state-of-the-art
You do not need common to do it. Just use y as a parameter for your function. Else indeed just put a common /everybody/ y Statement under each subroutine or post everything in an include file 
How do I use y as a parameter for my function? In terms of common, I thought with my new subroutine I wanted to pass Y to, I could write REAL y COMMON y then can I just use y or will I have to write another array in order to list all the Y values? 
We have a big Fortran code for scientific simulations. We started it from scratch 4 years ago, but mainly because we knew Fortran. 
If your prof is old school, use implicit typing. Else yes put common y in the main program and your subroutine but it is considered better to use named commons for coherent libraries, and using an include statement allows to change your common once only in case you need to do it ; else you might get catastrophic memory management issues. For the parameter call just write Call toto(y) Subroutine Toto(y) Where y is the parameter I hide ancillary arrays and variables in commons but explicit input output of subroutines in parameters. 
Funny enough I've already tried the parameter approach, I did Subroutine two(y) then in the main program called it using call two(y) I defined Y as real variables in both the main and the sub Issue is, it gives me only 1 value rather than all the values of Y and the value is wrong! So I ditched that approach. &amp;#x200B; Trying the common approach, that works. However similar issue, it only gives 1 value of the Y values. However this value is the correct first value but I dont know how to get the other values of Y to show as theres like 100 values of Y 
Either way copy paste the definition of y if it is an array That is why include files are good Parameter (n=100) Dimension y(n) 
So in the new subroutine: COMMON/name/ Y INTEGER n n=101 Y(n)\*newvariable &amp;#x200B; Would that work?
That is what I know it is best for!
Nice, iterations really are easy in Fortran
Cool to see industry applications
Now you sound like one of my friends, any chance you are doing gravitational waves simulations?
Haha nop sorry ! I'm doing plasma simulations for satellite thrusters.
We do [stochastic dynamic programming applied to energy assets](https://builtwithdot.net/project/144/ts-energy) (Hydropower plants, thermal plants and contracts). We use OpenMP for parallelization. The Fortran code is used for all the optimization tasks, a C# infrastructure drives the rest. 
Editing legacy and others' code, mostly. Oh, and calling FORTRAN routines from C :)
Can you share the code?
Computing the fixed point of a system of functional equations.
I use Fortran whenever I'm doing something with 2D or higher dimensional arrays and I want it done fast. Otherwise I would probably use C instead.
Not really Common /everybody/ y Parameter (n=100) Dimension y(n) Do I=1,n Y(I)=y(I)*newvariable End do Return End 
Electronic structure total energy calculations, for example using Density Functional Theory (DFT) or post Hartree-Fock methods. The vast majority of these calculations are performed using Fortran codes partly for legacy reasons, but mainly because it is good at doing matrix multiplication (there are mature linear algebra libraries available), is an easy framework in which to develop massively parallel code, and can natively handle complex numbers. Calculations of this type are super popular, and can almost be used as a "black box" (with very little understanding required) to predict all kinds of useful properties for existing materials, potential materials and materials under conditions that can't be probed experimentally.
I run hydrocodes for meteorite impacts
Do you happen to work in the nuclear industry? 
This is due, I think, to the lack of a good free Fortran90 compiler until around ~2005. While Fortran was modular and as modern as C/C++ in 1990, the current generation of lecturers had to learn and use Fortran77 as colleges would typically not pay for newer compilers. This was only resolved with the development of gfortran to a usable state around 10 years ago.
Depending on how much of this you're going to do, I'd investigate f2py. This enables you to compile a Fortran module / subroutine into code that you can call from Python. If the calculation is anyway time-consuming this might be better. Your program appears to be writing its data into a file SINGLE.GRF, and then using another program GRAF.BAS to turn that into a graph. So, all the bits writing to SINGLE.GRF (unit 8) are relevant. That is, it appears all your data is calculated into the array YGTR(). If I was doing this and the code was significant (not trivial to translate to Python) , I'd wrap the bits in the DO loop: subroutine dostuff(someargs, ytgr) intent(inout) :: ytgr (KMAX) ... ! code goes here end subroutine so that you have a subroutine dostuff() that can be called from f2py. Otherwise, translate the code dostuff() into a routine for Python. See https://docs.scipy.org/doc/numpy/f2py/getting-started.html#the-quick-way for f2py
Hmm i already translated 90% of the code and i am left with this part where i need to print out the h t graph! I am just confused whether the code is using h[t] or ytgr
Your prof is a bad teacher if they specify not only what you have to do, but also the manner in which you may achieve that goal. You should ask them if you can't just use modern Fortran.
My thesis is based on a gotten program I wrote to simulate the neutron distribution and multiphysics effects in a nuclear reactor. The meeting distribution is solved using a hand written finite element solver.
Wide variety of plasma simulations MHD, PIC, hydro/radiatiave, almost entirely developed in house but plenty of legacy code in plasma physics too. Also used for CUDA code, it is almost as good as C for CUDA and I know it far better.
I run dynamic simulations with Fortran. Like simulating rockets and planes and stuff using Runge Kutta integrators. My boss was really into Fortran so it was the first language I learned. 
Nuclear reactor thermal hydraulics - I don’t have access to the source code, but I know it is Fortran. The development was started in 1986, but I presume some even older subroutines have found their way into the codebase. Fortran might be a dead language for programmers, but nothing beats three decades of bugfixing and benchmarking to safety experiments and nuclear accidents :)
&gt;Common /everybody/ y Parameter (n=100) Dimension y(n) &gt; &gt;Do I=1,n Y(I)=y(I)\*newvariable End do &gt; &gt;Return End Doesnt work :(
Cant use modern fortran, its 77 only :(
Error: Common blocks arent the same size. 
Yep. It seems like based on other replies that Fortran is still alive in this community 
Yes, I see that. But if this is a course, then it is highly inappropriate for the instructor to require an old version to be used. You can consider complaining to a higher authority if you are sure it will not come back to bite you.
You should have the same declaration everywhere. That is why I told you to use include statements 
No clue what that means but Ill try use include statements, got a guide/pdf on how I can do that?
I agree completely but I already spoke to him about learning C++ or fortran95 etc but no luck. He said fortran77 only and if its written in anything else I'd get 0. &amp;#x200B; No point going to higher ups, rather just do it and finish the task, get it over and done with
I know! I haven't studied the latest standard but to be still developing it is awesome to see
Nice! I'm in nuclear too. I've done thermal hydraulics work before. System codes are pretty much all Fortran.
I work at a US commercial plant, one of the *newer* ones (commissioned in 1988) and all of our codes for our plant computers is Fortran. The Radwaste control room has a rack of manuals with the physical code printed out for all the tanks and flow calculations for the various radiation monitors. Its still working, but the hardware is old and sad.
Adding onto this, if anyone is curious about how they're done in practice, here's some source from one of the more common codes out there: [CP2K](https://github.com/cp2k/cp2k/releases/) 
Previously PhD involving Scientific computing with MPI + CUDA for a multi-physics materials model. Fairly low core count usage of 150-500 cores. We had a nice 80% efficiency. Future is looking great as one of the solvers is ported on GPUs. Now still working with Fortran for a variety of scientific HPC. Semi-excited about Fortran 2018. 
Just put your common and parameter statements in a file called foobar.inc or foobar.h then put include ‘foobar.inc’ or #include “foobar.h” in your code every time you need it. In the second case name your code toto.F 
Since it is not about FORTRAN but algorithms, wouldn't be better to ask at r/algorithms/ ?
Just a quick style note: unless you're messing with legacy code, a lot of people find it more readable to use the shorthand comparison operators than the long-form ascci versions (since few people learn Fortran as their first language). For example, it might improve your readability a bit to change ".lt." to "&lt;".
Sounds like an /r/statistics problem. You could produce a box plot type of dataset to start with, and throw out outliers that way?
Molecular Monte Carlo simulations. 
 kudos to you and your team. I hope you started the project in Modern Fortran 2018, and not in F77.
I'd say try also Coarray Fortran 2018 instead of MPI. You'll be amazed by its neat syntax.
Almost everyone, except one faculty, in our Physics Department uses Fortran. My own group is leading the development of a multi-purpose Monte Carlo simulation Package, entirely written in Parallel Object-Oriented Modern Fortran 2018.
Since the array is only of size 4, I think you can actually compute the mean of all of the subsets of the array. Then, depending of the mean of the subset, you could remove bad values. Moreover, maybe using the median instead of the mean can reduce the impact of one element very different from the other. 
Thanks ! Well I wanted to, but the compiler was not always F2008 up to date. So we use Fortran 2003. 
Cray, GFortran (almost completely), and Intel compilers are now fully F2008 complaint, with all three of them also supporting extensive part of F2018. I also saw significant improvements in PGI Fortran compilers in the Supercomputing Conference 2018. In particular if I remember correctly, their implementation of Fortran 2008 DO CONCURRENT construct could offload the work to GPUs for computation. There was a lot more activities in PGI Fortran that I cannot remember now.
 I started my journey in graduate school with Fortran. I hated it so much at the beginning. Later I noticed the reason: we were taught FORTRAN77. But, the more I learned about the fundamentals of programming in general as well as the "Modern Fortran", the more I have fallen in love with "Modern" Fortran (2003, 2008, 2018 standards). Fortran is an amazing language that, despite being blazing fast (like C), it has a learning curve similar to Python (unlike C). If you know MATLAB already, then learning Fortran should be really easy, because MATLAB has borrowed a lot of syntax and concepts from its ancestor, Fortran. It has truly the most powerful array-based syntax among high-performance languages, even when compared to scripting languages such as Python. In addition, Fortran has one of the nicest, easiest-to-learn, and yet most powerful "native built-in" syntax and mechanisms for parallel programming on both shared and distributed memory systems. That means you could write a Fortran program and scale its performance from your laptop to the largest supercomputers in the world, without making a single line of change in your code. Compare the native one-sided Coarray Fortran parallelism to the monstrous syntax of MPI, for example. Here is where I started learning Fortran 90: [https://www.uv.es/dogarcar/man/IntrFortran90.pdf](https://www.uv.es/dogarcar/man/IntrFortran90.pdf) This notebook contains almost 70%-80% of what you need to start productive programming in Fortran. For more advanced features such as Object-Oriented and Parallel programming with Fortran, the following is an excellent guide: [https://books.google.com/books/about/Modern\_Fortran\_Explained.html?id=V7UVDAAAQBAJ&amp;printsec=frontcover&amp;source=kp\_read\_button#v=onepage&amp;q&amp;f=false](https://books.google.com/books/about/Modern_Fortran_Explained.html?id=V7UVDAAAQBAJ&amp;printsec=frontcover&amp;source=kp_read_button#v=onepage&amp;q&amp;f=false) Since you are in grad school, you could likely get access to a free pdf copy of the book, just as I did myself in grad school. Btw, there is also a new 2018 edition of this book covering Modern Fortran 2018 standard: [https://books.google.com/books/about/Modern\_Fortran\_Explained.html?id=sB1rDwAAQBAJ](https://books.google.com/books/about/Modern_Fortran_Explained.html?id=sB1rDwAAQBAJ) There is also an amazing online Fortran-Jupyter binder by which you test your "Coarray parallel" Fortran codes in real time: [https://github.com/sourceryinstitute/jupyter-CAF-kernel](https://github.com/sourceryinstitute/jupyter-CAF-kernel)
The code should probably be 0.9\* (sum(x) - x(i)) / 3.0 The way you have it written wouldn't compile. I don't know how to help with your question though. You need to think about what you're considering a 'good' value. If you have any kind of equally spaced values (e.g. 0,1,2,3), none of the values will be considered 'good'. 4 numbers probably isn't enough to make use of any kind of average. Consider another set: 0.1, 0.11, 1.1, 1.11. You have two pairs that are equally close. Which is the 'good' pair and which is the 'bad' pair? &amp;#x200B;
Hi, thank you very much for providing your insight on this code, it has been very helpful with such limited resources i provided for you! However, i already translated 95% of the fortran code into python, and i am just left with this part to print out the output as a graph. The problem is i do not know where i should put my command to print the YTGR code ( is itoutof the "for 90 " loop?) etc Also i noticed that some of the H(I) values are stored in file 8 as well, but based on your opinion the graph is only plotted on the YTGR against time? &amp;#x200B; May i also check is there any difference in the placement of the write command? Do 80 I=1,10,2 ... 80 continue write (8,802) (H(I),I=1,10,2) &amp;#x200B; VS &amp;#x200B; &amp;#x200B; Do 80 I=1,10,2 ... write (8,802) (H(I),I=1,10,2) 80 continue Thank you!!!!!
It may be a personal preference, but I find the alphabetical notation to be neater. Along with syntax highlighting, it looks better than the symbols.
Yes, median might be a good measure, but it depends a lot on the specific problem. As another user pointed out, this is a statistics issue, not a fortran one.
I'm sure there are tutorials online. An internet search gave me this: https://web.stanford.edu/class/me200c/tutorial_77/
You may want to look at, generally, how loops and variables work in any kind of logic (or just FORTRAN77 specifically) to solve these problems. I recommend taking a look at this FORTRAN primer: https://www.ldeo.columbia.edu/~mspieg/mmm/Fortran.pdf
I was bored this morning so I decided to see how I would do this in FORTRAN77 (I have only ever written FORTRAN90, so it was kind of a trip haha...) PROGRAM MAIN IMPLICIT NONE c Setup our program, variables INTEGER NUM_VALUES PARAMETER (NUM_VALUES = 100) INTEGER YZ_RESULT(0:1, 0:NUM_VALUES), AB_RESULT c Calculate the Y, Z numbers for "Step 1" CALL CALCULATE_YZ_ARRAYS(NUM_VALUES, 1, 2, YZ_RESULT) c Calculate the sums of Y and Z CALL SUM_YZ(NUM_VALUES, YZ_RESULT, AB_RESULT) PRINT *, AB_RESULT END PROGRAM MAIN SUBROUTINE CALCULATE_YZ_ARRAYS(NUM_VALUES, Y, Z, YZ_OUTPUT) INTEGER NUM_VALUES INTEGER YZ_OUTPUT(0:1, 0:NUM_VALUES) INTEGER Y, Z, I DO I = 0, NUM_VALUES YZ_OUTPUT(0, I) = Y * 4 * I YZ_OUTPUT(1, I) = Z * 1 * I END DO RETURN END SUBROUTINE CALCULATE_YZ_ARRAYS SUBROUTINE SUM_YZ(NUM_VALUES, YZ_INPUT, AB_OUTPUT) INTEGER NUM_VALUES INTEGER YZ_INPUT(0:1, 0:NUM_VALUES), AB_OUTPUT, I AB_OUTPUT = 0 DO I = 0, NUM_VALUES AB_OUTPUT = AB_OUTPUT + YZ_INPUT(0, I) + YZ_INPUT(1, I) END DO RETURN END SUBROUTINE SUM_YZ I wasn't entirely sure what you meant by your Step (2), but I gave it my best shot what you were trying to accomplish. Hope this helps!
P.S. I don't know what kind of sadist is having you write in F77 instead of F90, but what're you gunna do...
You've got alot of questions and also some errors in your code. &amp;#x200B; First, how to pass variables to a subroutine: 1. Define the variables in the main program 2. Call the subroutine with the variables to be passed enclosed in parenthesis and the subroutine needs to be defined with passed variables. &amp;#8203; PROGRAM main INTEGER y, z CALL ONE(y,z) END PROGRAM SUBROUTINE(a,b) INTEGER a, b END SUBROUTINE 3. Ensure the variables have the same type definition in the subroutine (i.e. INTEGER x, y) &amp;#x200B; If you are being forced to use the FORTRAN77 standard, you can accomplish the same thing via a COMMON block (e.g. COMMON x,y)) statement added to the main program and each of the subroutines. Then, you don't need to add the variables in the calling statement to the subroutines. &amp;#x200B; Second, multiplication in DO loops. INTEGER i DO 10 i = 0, 400, 4 PRINT *, y*i PRINT *, z*i 10 CONTINUE Now, for errors in your code: 1. The INTEGER array "x" has a dimension of 10, but you say that "hi.txt" has 101 entries. So, your DO loop with the READ will attempt to assign a value the dimension of "x" on iteration 11 and will generate a run time error. 2. In SUBROUTINE ONE, "y" and "z" should be defined as 1-D arrays or you will just be overwriting the previous value upon each new iteration. 3. In SUBROUTINE ONE, you do not have an array index that is being incremented with each new iteration. 4. In SUBROUTINE ONE, you are missing the array index on "x" in your multiplication steps. That DO loop should looks something like: &amp;#8203; DO READ(10,*,END=10) x(n) y(n) = var2*x(n) z(n) = var*x(n) n = n + 1 ENDDO 10 CONTINUE &amp;#x200B;
Awesome replies! Stickied :)
Surprised I haven't seen this yet: Computational Fluid Dynamics, specifically fast steady state simulation of multi species reacting flow with MPI for large scale parallel execution. I inherited the code base, which is about 20 years old and pretty messy, and I am now in the process of adding new physics models, adding automated testing, and generally cleaning out the cruft. My dream is to get the number-crunching core sufficiently modularized so I can call it via a driver in Python, instead of the current Fortran driver. We ingest a lot of data files and do some pretty nasty setup logic so we can support lots of boundary conditions, and doing that in FORTRAN is really cumbersome... &amp;#x200B; &amp;#x200B;
It amazes me that universities are still forcing Fortran 77 on students that have no programming experience. There should be a law prohibiting this. Seriously.
Awesome responses in this thread! I will just add, generally, how I feel about FORTRAN... FORTRAN is the oldest so-called, widely used, higher level language in the world that is still widely used today. What that means is, it has pioneered compiler design for all of our scientists, engineers, etc. to the point where machine code produced by FORTRAN code is some of, if not the most, highly optimized available to us as scientists and engineers. In short, compiled FORTRAN's resultant machine code is screamingly fast--without being a computer science specialist. It's this machine code that makes FORTRAN a trivially defensible choice for scientific computing--even without expertise in CSE--in the modern era. Moreover, its accessibility to scientists and engineers to do their maths has kept it competitive among other, more modern, languages while implementing their maths. 
This is the main reason it is still taught at my university
Lest we forget, the meaning of FORTRAN... FORmila TRANslator
GNU's FORTRAN (gcc/gfortran) compiler doesn't even officially support F77!
The write statement is a loop in itself. In the first case where the write statement is outside the loop, then all of the necessary values of array H have been computed. If the write statement is put in the loop, then for each value of I in the loop it will print out every other value of the H array, even though the entire array of H has not been computed, but instead array H with values that have been computed upto and including the value of I in the loop and the rest would be zero (assuming it was zero before the loop). The loop and write statement have the correspond to the same values of I. If you want to put the write statement in the loop and not have it print the entire H array each cycle of the loop, the simply write ```WRITE (8, 802) H(I)``` in the loop. 
DFT is what I’m doing too. The code I work with started in the late 80s, and I’m part of a group adding new methods and improving scalability/parallelization. 
Thank you so much for your reply. I've tried the COMMON approach to pass parameters and even tried the same DO Loop to times y/z by i but no luck and I think thats because of the error you pointed out! Fixing all 4 errors you spotted, I dont quite understand the first error. Should my code look like this? &amp;#x200B; [http://prntscr.com/m3nhc0](http://prntscr.com/m3nhc0) &amp;#x200B; Doesn't complie so im pretty sure I've not done what you've asked correctly. 
The `write` and `print` syntax in Fortran is similar to the `print` in python 2: you use it like `write &lt;dataToWrite&gt;`. Moreover, in Fortran you can use the array constructor, as in python : `array = (H(I), I=1, NS, 2)` is literally the equivalent of the python `list = [ H[I] for I in range(1,NS,2)]` So the write command will write to the file 8 à part of the array H. 
Two errors that I see are the COMMON definition in the two subroutines— should be COMMON /passover/ y, z (you don’t need the array dimension included — and you need to add the COMMON block definition and the y &amp; z array definition to the main program.
So add this to the main program INTEGER y(101),z(101) COMMON /passover/ y,z &amp;#x200B; and change all the common statements to COMMON /passover/ y,z &amp;#x200B; Are the array dimensions fine, 101? Only because with the 101 dimensions it lists the values like this: [http://prntscr.com/m3oq7i](http://prntscr.com/m3oq7i) rather than a list of values like before.
You need to put your PRINT statement in a DO loop and have the loop counter as the array index for y and z
It's my favorite programming language. I use it whenever possible. I work in computational chemistry. Fortran is still commonly used in many different fields of scientific computing. In chemistry, there are codes for electronic structure calculations (not just dft codes, but post-processing as well) for md simulations, or people developing their own models for specific systems and writing the code in Fortran. It's very efficient at doing the numerical part. And also for parallel codes. Believe it or not, there are some old codes out there that are still in Fortran 77. And there are people still writing code in Fortran 77 :)
I had a braingasm reading this thread! Relevant username :)
Thanks so much, unfortunately the common statements aren't working because they're not the same size throughout the program. I'm trying to mutiply two arrays together, as I said I wanted: y(1) x 0 y(2) x 4 y(3) x8 &amp;#x200B; however when I do this: [http://prntscr.com/m40m99](http://prntscr.com/m40m99) I get all the Y values times by each value of 0,4,8 etc. Rather than the first value of Y to be times by 0 then the second value of Y to be times by 4 etc. &amp;#x200B; Any idea? 
&gt;which Thank you so much for this, I'm going to try this code now and mess around with it. &amp;#x200B; Tell me about it! My university lecturer insists on F77, in fact, if we use anything higher we get severely marked down 
Yup, my university lecturer insists on F77, in fact, if we use anything higher we could get 0 on the whole project. 
I've fixed the COMMON issue. &amp;#x200B; I've tried putting this approach: [https://prnt.sc/m40vpq](https://prnt.sc/m40vpq) putting it in its own loop but it prints the last set of values rather than y(1)x0, y(2)x4, y(3)x8 etc.
That guy should get fired. Really.
His argument is that, apparently, fortran77 is widely used in industry. Not sure how true that is. 
That's a completely lazy excuse. He doesn't care about learning new stuff and is forcing their students to use a totally outdated language and making a self fulfilling "prophecy".
It's not even true...
You can’t use “z” as a loop index plus as an array in the same subroutine. Change your first loop to be j instead of z.
You need a [DO loop.](https://en.wikibooks.org/wiki/Fortran/Fortran_control#Loops) 
Yeh I know and I know how to use them but I have no idea how I would use a do loop for this question. Hence the post.
make the i'th iteration add the previous (i-1) elements. store in index 'i'
Are both arrays the same size and are you sure that what you are looking to do is correct? Take your example: if both arrays are are 5 then by your description Z(5) = Z(4) + Y(4) and the last number of Y is never used (Y(5)). In order for it to be used, Z has to have 1 more element. Think about the problem again and make sure this is what you want. Assuming you described your problem correct, the loop can looks like this: \`\`\`Z(1) = Y(1) DO I = 2, 5 Z(I) = Z(I-1) + Y(I-1) ENDDO\`\`\` The first line copies the first element of Y to Z. The look then starts at 2 for the second element of Z and goes to 5 (or the length of Z). &amp;#x200B;
Scientific software for Monte Carlo radiation transport (r/EGSnrc). It is actually written in Mortran, an old preprocessor for Fortran 77 that implemented macros, and we still maintain it like that! Nowadays there is also a c++ class library linked to the Mortran backend.
Fortran is still relevant in science but I am not sure about finance / economics - you might check with their community.
I am pretty sure Fortran is almost useless in finance. I was just wondering if it worth learn just the basics (now that I can) because I intend to learn C++. I don’t know if there are some similarities
There are some similarities, but in this case it's probably worth learning C, then C++ (or C++ directly if that's possible). Having said that, I always learn new things I can use in my current programming language when I learn another. Either because of the language itself or because of how things are implemented.
Not really. C++ is definitely closer to Fortran than python is to most other languages. It's a matter of context. If you have never programmed before, Id attend. The logic of breaking down problems into a set of smaller operations is fairly unilateral. How each language uses those steps is likely to change and the syntax will be specific to each language. However, if you've spent the last 3 years doing mathematical computing (matlab / maple etc) then these things may already be familiar.
Fortran is used extensively in several fields of Economics and Finance (say corporate finance quantitative model of firm capital structure).
Lots of Fortran in Econ!
Go to them. Given that the learning curve for FORTRAN is the steepest, your return on time investment would be the largest for those FORTRAN lectures. 
**First** thing first... from your question it seems that you are a novice/beginner programmer. This alone should be enough motive to attend the lectures from the beginning regardless of the language. **Second**. Be sure that the lecture is modern Fortran and not FORTRAN 77. Modern Fortran is as modern as it gets, latest standards just released (end of 2018) and support full OOP features and many many more, in your case I believe it would be even more beneficial than C++ since it offers all the same features that you will need and it is much much easier to learn and wright efficient and fast code... On the other hand, FORTRAN 77 is as old and as bad as it sounds... if that's the case Ruuuuunnnnnn!!!!! **Third**. You mentioned Python. In your field (math, finance, machine learning) python is the absolute KING (due to libraries, documentation, and community). Considering that it is also a beginner friendly language you should learn it first and stick with it until the end. **Fourth**. Forget about C and C++. As a beginner, the only outcome I see is frustration and quit. You will find yourself spending endless hours debugging and trying to understand what the debugging errors mean before you even start writing useful code relevant to the exact finance problem you want to solve. You will waste so much important time of your Ph.D. trying to learn C++ that you will risk not finishing it. C++ could be a choice of a CS graduate that wants to jump to finance but not the other way around. **Finally. Learn Python**, master it. **Then learn R**, master it. These two are the most used in your field and the safest bet, career-wise (after Ph.D.). **Only one exception**, if you are going to be provided by a code from your supervisor and you are supposed to work/modify/expand on it then forget all the above, your only option is to learn the language that this code is written at. &amp;#x200B; &amp;#x200B;
I think knowing the basics of Fortran, or any statically typed compiled language (such as C/C++), would help you tremendously when you start using Python. I find a large number of the bugs me and my colleagues have with our Python scripts generally boil down to thinking a variable is a type which it is not (among other annoying Python quirks). You don't need to do "big" simulations to get the benefit of using Fortran. Any iterative heavy procedure or array dependent algorithm will in most cases be faster in Fortran than in Python. Yes, Fortran code is a bit more difficult to program, with more developer time required. But, if you're going to be reusing this code over and over, I'm sure you will prefer that it has a short runtime.
I'm using it for macro/finance modelling and simulation. For people unfamiliar to academic macroeconomics, I write down mathematical models of household behavior under the assumption of rationality, and then solve the households decision problems (consumption, savings, portfolio choices, own/renting, retire/work etc). While solving each model takes everywhere from only a few seconds to a few minutes in Matlab, the reason I use Fortran is that I need to solve each model tens of thousands of times, since I need to try a large space of various parameters values (say time-discounting, risk aversion, altruism and dis-utility of work) and find the set of parameter values that generates results that corresponds with actual data.
Fortran is my favourite language! I'm graduating computer science and mathematics this Spring. Most of my peers do not work with Fortran, but I have taken quite a few scientific computing and numerical methods courses. I'm planning on working as a programmer for the military. Fortran and C are very common in this industry. So I have continued studying the language.
&gt;if [mobius-eng](https://www.reddit.com/user/mobius-eng), thank you for your answer. Please see [https://software.intel.com/pt-br/node/802217](https://software.intel.com/pt-br/node/802217) I will bear your advice on GFortran in mind.
Don’t use the basic PRINT *, ... command because it will print the full width of the character variable NAME1, etc. Either add an embedded format statement, use a WRITE statement with format, or truncate the blank values in the character variable with something like PRINT *, name1(1:LEN_TRIM(name1))
Your problem is unclear to me from your post, can you restate it in a clearer way? Are you asking how to write 3 values from 3 arrays on one line inside a do loop? write(6,'(a)') 'Name 1: Name 2: Name 3:' do i1 = 1, array_size write(6,'(3(f12.5,1x))') array1(i1), array2(i1), array3(i1) end do
You need to use Fortran format. If you want columns in rows to allign in a certain way. It's very powerful if you do it right.
Rarefied gas flow simulations, particular in gas micro-mixers. These are ([DSMC](https://www.wikiwand.com/en/Direct_simulation_Monte_Carlo)) Monte Carlo type of algorithms combining statistics and kinetic theory. 
In addition to all the scientific stuff i do, im currently writing fortran modules to draw things to a linux framebuffer, something lacking in existing fortran code is interactive graphics.
First, may I ask why you need to change the bounds? It might be that that isn't necessary at all.
I'd like to pass the array slices to local subroutines that expect 1-based indexing (parts of the Intel MKL for example), otherwise I'd prefer to maintain the original indexing. 
Yeah, I thought so. When you pass an array into a subroutine, and use it as an INTENT(IN), it is automatically a (1:n) array. You don't have to do anything to make it so.
Ah, of course! That actually caused me some grief a couple months back, can't believe I forgot. Thanks a lot mate.
I had something similar and I'll never forget it, passed an allocatable array that was something like (0:n+1) (for guard cells in a simulation) into an `intent(in)` and didn't realise the index would change. Caused all sorts of chaos.!!!
what about, &gt; equivalence (array_1, array_2(1:10)) 
You could use pointers, consider this program: program pointers use kinds, only :dp implicit none real(dp), target, allocatable :: a1(:) !real(dp), pointer :: a1(:) ! This works too real(dp), pointer :: ap(:) integer i1, i2, ioff integer is i2 = 10 ioff = 5 allocate ( a1(ioff:i2+ioff) ) write(6,'("Original Array")') do i1 = ioff, i2+ioff a1(i1) = real(i1,dp) write(6,*) i1, a1(i1) end do write(*,*) is = 7 write(6,'("reindexed with ",sp,i0.2," :")') is ap(is+ioff:i2+is+ioff) =&gt; a1 do i1 = is+ioff, i2+is+ioff write(6,*) i1, ap(i1) end do end program pointers 
You can also specify bounds for the intent(in) if you by chance did not want it to start at 1. For example you can start it at zero with: subroutine shifted_input( input_array ) integer, dimension(0:), intent(in) :: input_array ... Not particularly helpful in your specific question but can be nice if you had to go back to your previous indexing or something else all together later on.
Nice to know I'm not the only one! I was just simply using the index of the array as a function variable, not quite as exciting, but it sure had me chasing my tail.
I'd not heard of this! Though, after looking it up, the Fortran 95 standard describes it as obsolete in favor of using pointers as an alias or the transfer function. 
Thanks very much for the example, I might end up doing this if need. I haven't had had a reason to use pointers in Fortran has of yet and I'm looking for an excuse, ha.
Well it’s an option, depending on what you are trying to do it may be appropriate. Difference being TRANSFER is runtime and EQUIVALENCE is static, like a macro. Maybe best to avoid obscure language features in production code though.
Cheers for pointing that out, that's good to know.
I personally END DO is easier to read so I prefer it
But is there any difference? Any advantages of one over the other. 
Modern fortran practices, such as [2003](https://en.wikibooks.org/wiki/Fortran_2003), uses `end do`. You can also do [named loops](http://www.personal.psu.edu/jhm/f90/statements/do.html), which give you greater control using `cycle` and `exit` and can help readability for long loops. 
They are identical, use end do though, it is the newer syntax (and the one backwards compatible with f90+).
Please, use `end do`, its so much easier to read. I don't have my reference material handy to be sure but undoubtedly use of `continue` to terminate a look will be deprecated in a future revision of the language if it hasn't already. Unless you have a very specific reason for writing Fortran 77, I would encourage you to use a minimum of Fortran 95 instead. You'll thank me later.
For the compiler, probably not really. However when you're working with several levels of nested loops combined with if statements etc, normal do/end do loops are a lot easier to read. Also, if you use the f90-style formatting (free-form) instead of the punch card (fixed-form) formatting (which can still be used with the 77 language standard), you can effectively use indentation to keep track of the logic. Personally, I avoid numbered GOTO statements and their relatives as much as possible, as they generally make things harder to read and maintain.
In other words stop with that shit we almost on 2018 standard, let the legacy of F77 die in peace.
Are you specifically using FORTAN 77? Is there a reason for this? Are you working on some old code? Is your advisor asking you to use FORTRAN 77? There are some features with memory allocation that make FORTRAN 77 very difficult for the typical modern user. And syntax is a little difficult because of the fixed format. If it is possible, I would advise you switch to a newer version. &amp;#x200B; If this is an old code, and you are modifying it. Maybe for consistency, keep using "continue". If it is new code... I don't know. For readability, ENDDO is certainly a better option. Fortran compilers I think are backwards compatible. For example you can change the extension to .f90 on a FORTRAN 77 program, and it should compile, I believe. It's been a while honestly since I last dealt with FORTRAN 77 programs. But if you want to not have problems compiling your code in the future. If this is a new program. Maybe switch to at least Fortran 95 syntax? &amp;#x200B; If you are wondering which is better for the program. The do/enddo loops, basically have the "continue" method implemented underneath. It's the same thing. And it's easier to follow what's going on. Especially if the logic is a little more complex. &amp;#x200B; Are you working in computational chemistry? (I'm just assuming because of the username) I know that sometimes professors can pull out some old FORTRAN 77 code :) But. What is the specific reason for using it?
&gt;ndy to be sure but undoubtedly use of continue to terminate a loop will be deprecated in a future revision of the language if it hasn't already. &gt; &gt;Unless you have a very specific reason for writing Fortran 77, I would encourage you to use a minimum of Fortran 95 instead. You'll thank me later. Its for an assignment which is F77 only! Tried talking to my prof and its having none of it, its F77 only. 
&gt;certainly a better option. Fortran compilers I think are backwards compatible. For example you can change the extension to .f90 on a FORTRAN 77 program, and it should compile, I believe. It's been a while honestly since I last dealt wit Thanks for the reply, actually its Nuclear, an assignment where the prof said it must be in F77 no exceptions. 
I know your pain... the argument was somewhat: "You need to learn how to do it from scratch without all those improvements" I already knew Fortran 95 (4 years - hell yeah) and was obligated to not use `allocatable` arrays and other features just to do my assignments \[ r/WatchPeopleDieInside \]. So the answer is `end do`, or if you wanna screw this prof use a `goto` infinity loop and `implicit` typing like a hell in Fortran IV and write the most horrendous shit hahaha. (Just kidding, don't do it \[or do it I'm a random internet person not a cop\] )
Ok. Well good luck :) I guess maybe you're doing some numerical stuff. If it's only one or a few asignements I agree with your professor. It's good to have some sense of how some older programming languages work, just as a mental exercise. Plus you never know, you might run into an old FORTRAN program that you just have to work with at some point in the future :)
&gt; Its for an assignment which is F77 only! Tried talking to my prof and its having none of it, its F77 only. I don't like your professor. Its hard enough fixing legacy Fortran 66 and 77 code that is riddled with egregious memory errors and literally no structure without people cranking out more legacy Fortran code in 2019!
I wrote this in Fortran because... Fortran! https://www.mkdynamics.net/current_projects/current_projects_FFTW3.html#Fortran%202003%20Code
Pretty sure those are still copyrighted, friend.
This is true. Thanks anyway.
If you're at a university or at a public library you may be able to access an electronic copy.
Radical I will look there if they have the CD, or a digital download available. Thanks.
Depending on what you want it could be in [here](https://people.sc.fsu.edu/~jburkardt/).
Yeah, they are. I wanted to post them with the outputs to my site but then read in the first few pages that the source code is copyrighted. Oh well.
This is perfect. Thank you!
The variables `temp_f0, temp_f1, ...` do not exist, similarly for the other READ lines. You probably wanted an array, if I look at the lines with arithmetic.
So it looks like you are trying to read in a range of values. What you need is an array but you have declared temp_f, slp etc. as single values. To declare an array you do this integer :: temp_f(n) where n is the size of the array. So next is you need to reference these array indexes to read your data into the slots. Where you have temp_f0 you want temp_f(0) etc. Next, array indices in Fortran start from 1 not 0, while fortran does let you choose whatever start index you want... integer :: temp_f(0:n-1) for example would create an array with the indices that you would expect from [0:n] in python. It may be best to just expect indexing to begin at 1 as this will save you headaches later. Next, in the interest of your own sanity, don't manually enter temp_f(0), temp_f(1).... instead use a loop. In particular for this case Fortran has a tool called an implicit loop... read(*,*) (temp_f(i),i=1,n) will read in n values from terminal into the array locations 1 to n. Of course, the same idea will work for your write statements, you may also need to include format statements but this should be enough to get started, it looks like you have a lot to learn! 
Look into [Fortran formatting](https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html). You can use this to determine the spacing, number of decimal places printed, etc. You can end up printing something like: write(\*,format1) i, volume(i), ..., area(i) Look through the examples on that page. The format you'll need for this case will use (1 integer, 5 real), and you can edit the descriptors to get the spacing right. 
Since you aren’t specifying a format in your final write statement, each string is being printed at the full 30 character width and concatenation with the next 30 character string
but I've done that before still it'd give me lots of spaces. The problem is my numbers change. So let's say I have *I5* format for *i* and when I have 5 digit number it's fine but when I have one- or two-digit number I end up with spaces.
What it you use `*` on the Last write statment ? Plus, shouldn't you add the space between the trim ? Like `trim(l)//" "//trim... ` My Last remark, but which will not answer you question, is that I don't know why you would like to have only one space. If you want it to be readable by a human you would need the space to have a nice table... 
It didn't work. And regarding your remark, I have a question, will read() function read any numbers correctly regardless of how many spaces I have? I mean can that somehow cause any problem?
aaaaa I've found the way!
what is it
I've put the formatting for each and changed the last write to this: `write(21,*) trim(adjustl(str1))//" "//trim(adjustl(str2))//" "//trim(adjustl(str3))//" "//trim(adjustl(str4))//" "//trim(adjustl(str5))`
Can you provide any source for this? I mean I believe you lol but I need some online source to show to my coworkers
[https://docs.oracle.com/cd/E19957-01/805-4939/z4000743a36d/index.html](https://docs.oracle.com/cd/E19957-01/805-4939/z4000743a36d/index.html) Here's one. If you're reading integers or floats, all that matters is that you read in the correct type. the columns can be separated by any number of spaces or a comma. [here's a page](https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap02/read-1.html) with examples. 
You can write to a string and then use that as a format string. That way you cat get some kind of dynamic formatting.
With gfortran this seems to do what you want. You have to specify the length of the value as 0. program test write (*,100) 1.0, 125, 17.2 100 format (f0.4,x,i0,x,f0.3) end program test
Simply Fortran was always my favorite. 
I tried a bunch of different IDE’s and so far my favorite is Atom. It’s not a true IDE but with a couple of packages it’s the closest I’ve gotten. Simply Fortran is another good option, if you can afford it. 
PowerStation
I second this. Atom plus a terminal to launch compiler and debugers is the best I found. 
That’s what I do. I’ve set up a couple of bash aliases for common compiler options which has saved me tons of time 
I've used that algorithm in Fortran before. I found that it only works well when you rescale the variables to all be around one. PM if you want code.
I use Sublime Text with the Sublime Linter and Fortran packages, the linter is linked to the MinGW compiler, but you can link it to any other version of gfortran you have installed.
I use code blocks. 
If you know enough to write Fortran, you probably know enough to use Linux. If I have to use Windows I use WSL (r/bashonubuntuonwinfoes) and vim+make+gfortran
Emacs
Recently I found visual studio code with Fortran intellisense plugin and Fortran plugin is very nice. It does auto complete on derived types. I use terminal in there to run my build script.
Yes, dumb me I’be realized that later
Hi OP, I am 20 years old, and I am porting a 20 years old legacy code to modern Fortran to a readable, modular, optimized and OO version. It implements several routines to extract electronic properties of semiconductor structures (I guess we are searching materials that may be Topological Insulators, idk), by solving K.P Hamiltonian (Huge matrices like 1TB), this code implements also things like optical properties extraction, strain, exchange &amp; correlation and self consistency. I know nothing about the physical details yet but in the end is eigenvalue and eigenvetor problem with extra steps like out-of-core methods since LAPACK can't handle it well. Fortran is .not. dead haha.
Hate that, those dinosaurs that write new F77 code must die, my eyes bleed when I see F77 code: fixed format, GOTO and other stuff like that.
Those dinosaurs were writing code before "programmer" was even a profession.
I didn't meant that :) those dinosaurs I do respect LOL. However, unless you are editing legacy F77 sources, there is no reason, nowadays, to use or teach new students Fortran 77. Should we all learn how to write code in punch cards again? Once I saw someone who miss end statements in Python (Not limited to). That's what I call this disrespect.
I miss end statements in Python :) And I say that a lot. Do I know you? By the way. How is that disrespect?
MinGW is not an IDE. It's a set of compilers and other tools.
Oh no! :D I don't think we know each other, perhaps is a common felling among Basic-like programmers? It is disrespectful Python's \[relig... xD\] philosophy since end statements are useless by design. Indentation to other program languages are useless whitespaces that help the code readability, however everyone would agree that good programmers should indent their code, so Python promotes the indentation to a important thing (since it is) and free the programmer writing few (now useless) lines of code.
I am trying to write a code using the GAUSS-SEIDEL-METHOD for solving an equation system. I get the error code down below and i do not know how to resolve it.
If you post the source file it would be easier to help you as we could see line numbers etc..
It's type error, so either the inputs or the output is not consistent in terms of type or size, between routine and main code?
As the first file includes external functions from LAPACK, the compiling works with gfortran LinearAlgebra.f90 Sheet10.f90 -llapack &amp;#x200B;
The use of the function is not correct. Consider how you get a result back. The "type" of gausseidel is the type of its return value.
I declared the function as follows "function Gausseidel(M\_input,b) result(x)". According to my understanding of what you said i must use call this way: "call Gausseidel(x)". x is its return value, right ?
In your example though, you are saying that x is an input to Gausseidel, which is not correct. You need to look up how to use functions as opposed to subroutines.
&gt; "call Gausseidel(x)". That is a subroutine. y=Gausseidel(x) Is a function and the return type of Gausseidel needs to be set.
In Fortran they're not :) You use the end do / end if statement to signify where the loop / logical expression ends. And I am used to using that method of signifying where the end is. I am also used to looking at code written using end statements. It is not disrespectful to Python to say that I am not happy with a language that uses indentation for that purpose. I think it's a bad idea. It's also unintuitive and I'm not used to typing code that way. I'm used to explicitly saying this is where I want my statement to end. It's how I think when I am typing code and how I'm used to doing it. It just feels right. To signify end in some explicit way with a symbol. There is no justifiable reason for introducing that feature. Yet introducing that change has a negative impact on my productivity. Because it makes the code look weird. And also, difficult to follow what's going on when you have complex logic, and you need to keep good track of how many loops/if statements you are getting out of, and how many are left after your new statement. For example: Do i = 1, 5 Do j = 1, 4 if (n == 'm') then k = 0 Do while (k &lt; m + 3) if ... some code else if ... Do l = 1, m some code End do k = k + 1 End if End do End if End do End do I would like it to be clearly visible where "k = k + 1" goes. So that I am not wasting time counting the number of spaces/tabs. It's OK, I've grown used to it now. People do use Python in computational chemistry as well, so it's important to know how to write code in Python. But still. Yes indenting your code is important. But if a person chooses not to indent it, they may have some reason for it. If you're making a small change to a copy of a small script that you'll run only once. You don't really care about indentation.
(About Edit: You mean syntax highlight? I think it's not possible to do it on reddit...) Yes they are a necessary in the actual Fortran Standard. I understand the overall felling but its all about Philosophy and needs. If can write less to do the same thing, fast enough I will def. do it. # Python equivalent - if your logic is too complex there is something wrong! # Always try find a Pythonic way to do it and those many nested statements will be not # a necessary thing: example use a function! a OOP or functional approach # (Modern fortran support many things I paradigms that I discovered in Python). # There is plenty options to improve your code readability... for i in range(4*5): if n == 'm': k = 0 while k &lt; m+3: if ... #some code elif ... for l in range(1,m+1): #some code k += 1 ! Can't see what is going on here... :P if (n == 'm') then k = 0 do while (k &lt; m + 3) if ... some code else if ... do l = 1, m some code end do k = k + 1 end if end do end if I was born and raised in Fortran 90, I love the vector elemental operations (which makes it a distributed-ready computing lang) and the "Formula Translator" philosophy which is a way of "make it look like math and write less \[than C, for example\]". Then I found the Python "write less doing the same thing" (and others paradigms like OOP and functional). I loved the ideia to use the indentation to delimit blocks. I still love and use Fortran (as any new language I learn) however Python has **changed my mind****^(tm)** in terms of software development. Nowadays when I write some code I think on how another person would use it. We scientists, need to know that we work in (the largest than any other) project of humanity. We need to be kindhearted to each other... standard guidelines &amp; good practices are there to help. In this way I like on how Python is not only a programming language but a new way to think... their standards are there to reinforce the sense of community and openness. This transition is a matter of habit, it's understandable :). I really would love Fortran (and other languages) adopt this style in programming... but you may like this ~~heretic~~ project called [Bryton](https://github.com/mathialo/bython) (Brace Yourself XD). By the way, how long you are into Fortran's world? Probably a lot, I guess?
Geophysical modelling in usually done with fortran programs. It’s fast, easy to read and can handle weirdly formatted input files (such as well logs) with ease. I’ve been working on a Monte Carlo routine to evaluate the uncertainty of seismic refraction models.
I recently worked on a 2D Particle-In-Cell (PIC) code. I had to convert the existing F77 fixed formatted code with shared memory (OpenMP) into a hybrid (MPI - OpenMP) code. But Good Lord, how the heck did the previous guy even write a 6000 line code with no modules and no indentation. Now, after 2 months.. I'm done and I don't want to talk about how I managed to do it.
What have you tried? Where are you getting stuck? This is a fairly *academic* example, so I don’t want to keep learning from happening by just telling you how to code it. 
I'm going to be a bit bold here and say that the newest version of FORTRAN is strictly better than all previous versions.
Not sure if sarcastic—this is typically the case with most programming languages, but some do have enough changes in design over the years that the user base can become split. Looking over things, it seemed as though FORTRAN was in the latter category. If everyone agrees that the latest is the best, I’m certainly thrilled to hear it. Last thing I want is to have to choose between 50 different versions!
I'm not being sarcastic. I suppose there might be cases where you must use older FORTRAN versions specifically because you need to manage legacy code, but in that case the version is going to be completely arbitrary so you can't just choose one specific version anyway. I don't personally know of anyone who, for example 'prefers' an older version, or otherwise claims that it is better. I'm also not aware of any Python 2 vs 3 style split where one version is so new it has almost no support. Basically, I highly recommend just learning modern Fortran. Of course this is just my opinion, others may differ, but I'd honestly be surprised if anyone recommended anything other than the latest version for almost any case.
I don't know if you have much experience with Fortran, but in my (limited) experience the problem with the latest Fortran standards is the delay in their implementation and the consequent portability issues. When a new standard is created (i.e. Fortran 2008, 2003, etc) they are not fully implemented immediately by the organizations behind the compilers (gnu, Intel, IBM, PGI, etc), so unless you actually need one of the newest features, it may be safer to stick to a version that is fully implemented in several compilers (Fortran 95 or 03 nowadays?) That is if you want your code to be portable, of course.
This might be a fair point, all I can say is I've always used the latest Fortran the instant I was made aware of it and I've never run into issues compiling with the Intel compiler.
Ahh that's a different thing.... using the latest compiler does not mean using the latest Fortran standard :) Just because the compiler can process new features (like coarrays) it does not mean you're actually using them. In any case, if you want to maximize portability you should probably stick with the 03 standard, or do a survey of the most common compilers to make sure they implement any capability of the 08 standard that you may find necessary.
100% agreed. Any new Fortran codes should make use of the 2003/2008 standard whenever appropriate
&gt;I don't know if you have much experience with Fortran, but in my (limited) experience the problem with the latest Fortran standards is the delay in their implementation and the consequent portability issues. That was a problem for a while, but the recent versions of both the Intel and GNU compilers pretty much support all of the new Fortran standards. 
Just to be clear, I actively use coarrays in my Fortran code.
The only reason I stick with the 90 standard is that it was I was taught back in the day (2009 tho, my professor was a little not-up-to-date). I'd love to get to know the newest version.
None should give you a direct solution here. Obviously, you are trying to find someone to solve your academic 101 exercises. What you can do: 1. Solve it by writing pseudocode, 2. Look at one of many free online Fortran tutorials and match the pseudocode with Fortran commands. 3. If you can't do first 2 steps, it means that you lack basic/fundamental programming knowledge, you need to read again the first/second chapter of your programming book (regardless of the language). If you are still not willing to put some real effort, just google it but don't mention Fortran (since it's not so common language), put python, C or C++ there should be many variations of this kind of basic examples.
Others have said you should learn the newest version. I agree with them, to a point. You may also encounter old libraries such as (sca)lapack. This means you should be able to understand Fortran 77, as well. This is not the issue, as the book you are going to use to learn Fortran from --- Metcalf, Reid &amp; Cohen, Modern Fortran Explained, 4ed. --- covers the everything, from modern to obsolete features. It will also point out how a certain feature differs across different standards. When writing fortran in practice, you should take the pragmatic approach. You will have to understand how the hardware and the compilers support the constructs of the language. Current compilers usually support anything in Fortran 2003 and the most useful features of Fortran 2008. This holds especially for GNU fortran compiler (gfortran). If you are developing code to target specific, say Intel, IBM or AMD hardware, you are probably going to end up with the most efficient optimisations if you use compilers provided by vendors. They may have varying degree of support for certain features, so it is important to understand which features are, and which aren't supported by the compiler you are using. Also, some things, for example coarrays, are implemented differently on different platforms. As you see, there are many intricacies to writing good scientific programs. &amp;#x200B; A non-related remark --- you are free to stop referring to Fortran as FORTRAN. The language itself is case insensitive, and I think it is mostly the condescending and ignorant users of inferior computer languages (within the realm of numerical analysis) that use the capitalised form. 
A non-related remark reply/addition: Actually, FORTRAN77 was the last version the capitalized form was used. Anything newer and the proper form is Fortran.
Fortran 2008 or newer for sure. It's pretty comfy. 
In my personal, subjective opinion, Fortran 90/95 is generally the best version for most purposes. If you want better pointer functionality. Like for instance you want to be able to pass a function to a subroutine. Go with Fortran 2003. Or maybe other people would recommend going straight for Fortran 2003 because it is more modern. I personally prefer Fortran 90/95 precisely because it is less modern. It forces me to think just a little harder and do some things with a little more improvisation. &amp;#x200B; Also. Yes. Fortran is good for math definitely. Especially for numerical stuff and linear algebra there are some very good libraries. But it is limited in other ways. So. What kind of programs would you like to write exactly? If you want to write programs to solve problems that are in their nature mathematical, and print out numbers that you will look at, analyze and plot. Then Fortran si very good for that. Especially if there is a lot of integer arithmetic involved.
As someone who uses primarily Fortran '90 for basically everything compiled, is there any good writeup on what you get from the newer versions, and the design patterns that are common with them? Almost every writeup out there seems to focus on the 20th century versions.
I wrote an FFT program in Fortran 2008. I prefer the modern style of Fortran to the older all caps versions of decades ago. If you know C and understand declarative programming, the using Fortran 2008 becomes mostly syntax. Of course, Fortran has some powerful constructs that go beyond C, such as selected real kinds and built in array manipulation commands. You can even do things concurrently. It is a great language and definitely my favorite. 
I took FORTRAN in 2010 and 90/95 were the versions we learned. Honestly, it seems like the bulk of the cludge from 77 and older like fixed formats was removed by then. I think 2003 gained objects, which I never really grasped from C/C++ anyway.
I may be wrong, but I believe that 90/95 didn't require the all-caps, but was generally taught that way to improve compatibility with 77 and that was just part of the way it was taught. Sorta like how camel case is a *de facto* standard in C/C++. 
You should definitely learn the latest version. There are really only a few advanced features in Fortran 2018 that don’t have good compiler support yet, but you’re unlikely to run into them. I haven’t had a need for anything unsupported yet. 
The major additions is object oriented programming (classes, polymorphisms, inheritance, etc.), intrinsic C-types, and several additions aimed at parallel computing. 
I'd assume that it is no different than using it for any other compiled language.
I am not familiar with KDE but there are other alternatives for Fortran ide in Linux. Are you building strictly Fortran or mixed language?
I usually use gfortran with the "geany" and "code:blocks" IDEs. My codes .f90 and .f95 compile and run perfectly well. Besides, I think that Kdevelop is especially designed for C / C ++ languages. It does not propose to compile and run fortran programs.
Ok. So you are already using ide's. I recently found VS code is good for writing code and debugging, also has intellisense through extensions and language server. Though not a strict ide.
Great question. My advisor mentioned it as being of value mostly given its continued relevance to modern mathematical computing, suggesting that some libraries just wrapped 70 year old algorithms still executed in FORTRAN, because why reinvent the wheel. I’m not actually sure even what kind of thing I’d like to use it for. I do plan on going into data science, or AI, and like the combination of math + CS a lot generally. I think this sounds like it’s own post, really, since how will I know when it’s time to learn it if I don’t know what it’s good for in the first place? Would you be willing to elaborate on your choice of 90/95, why you prefer to think harder and be required to improvise more than you would in later versions? Typically programmers are interested in ease of use, and prefer to save heavy thought for the nuts and bolts of the work. 
I appreciate the advice and referral to the text. In case it changes anything, though I am a CS undergraduate student currently, I do not anticipate learning the language in a classroom setting at all. (Likely on my own personal time, in fact.) Thanks also for the style note. My shift key thanks you, and I’m happy to spare the extra keystroke; I was simply unaware. 
I prefer Fortran 90/95 because it is the easiest for the kinds of programs that I need. If there is no need to do any OS stuff or use a specific library, but I need the program to do some calculations for me. This is the language that I prefer. It is easier than FORTRAN 77 because memory use and allocation is much much easier, free format, and also, the syntax is fairly clean and easy to look at and write in. It is very intuitive. In general, working with integers is easier than any other programming language that I know. It is better than newer versions because I have to remember less. I can just be creative and not waste time trying to remember or look up how to do something. For example. Passing a specific function to a subroutine is possible in Fortran 90/95. Passing a generic function from the main program is not possible. If I want to pass a function to a subroutine and I only have three functions that I'm working with. Well. I'll just write an if statement, calling the subroutine with different functions. If I have A LOT of functions that I'm working with. Well then that would be a pretty long if statement, so this might not be the best option. Maybe in that case I should use Fortran 2003, and use a pointer to a function so that I am calling the subroutine from the main program once with a generic function, that points to a specific function that I want to use in that particular case/run of the program. But now I have to remember how to do this or look it up whenever I need to. And I would prefer not to. So unless it is necessary, I try to avoid newer Fortran version because I don't like remembering stuff. I just want to write code and be creative and let my mind loose :) Of course remembering things is inevitable. Especially for other programming languages. But at least when I am writing Fortran code I would like to be relieved from this need for memorization and write code quickly and with ease. As for what programming language I would recommend. If you want to do data science. I think Python might be a better language. Or c++. There are some libraries for data analysis, fitting, visualization, statistical distributions etc. Fortran is more for numerical stuff, linear algebra, integer arithmetic. And yes, your professor is right. For example, Lapack is a very famous library for linear algebra, and it is written in FORTRAN 77. To call those routines, it is useful to have an understanding of how FORTRAN 77 works. Especially how memory allocation in FORTRAN 77 works, because some of the variables that you'll pass to Lapack subroutines are related to allocating memory for your matrix. And the way that memory allocation is done in FORTRAN 77 is different from how later versions of Fortran do it. So it's important to know what numbers you want to pass to specify the size of your matrix accurately.
Concurrent computations. High performance computing. 
Fortran is best suited for high performance computing and is popular in academia. Python is easy and intuitive but very slow compared to Fortran. Julia is new and it would take time before it becomes a viable alternative.
A real life example is atmospheric and oceanographic models. Fortran may be old, but it is fast as stink.
We use Fortran for the optimization of [flexible energy assets](https://www.time-steps.com/en/home.html) such as hydropower plants and gas turbines. We have a C# application that prepares all the input data into the correct format, then launches the Fortran application. Once the process is finished, the c# application takes the output and post processes it for presentation / visualization and reports. The numerical part of the fortran is mostly parallel, we use OpenMP to dispatch the work over 20 to 60 cores in a single shared memory space (in effect on a single computer with up to 4 cpus). Internally, the work we do is solving a set of relatively small linear programs, doing some matrix multiplication and performing a dynamic programming backward integration and updating a shared area of memory with the solutions to the problem. Why Fortran? Because it was easy to express exactly the numerical problems we wanted, the slicing of areas of memory (matrixes) was easy and part of the standard library and the main mathematician on the task was comfortable with the language. The performance was better than our previous c/c++ implementation since the clear structure of the program allowed us to hoist some calculations out of the inner loop, trading calculation time for more memory. 
Crunching numbers. Numerical simulations.
Matrix operations 
All the answers here are spot on. FORTRAN has namelists and built-in multidimensional arrays, which makes it really easy to write programs that that take a few basic inputs and do lots of array math. The file I/O isn’t that bad either for simple stuff. A real world example where FORTRAN excels is solving partial differential equations, e.g. finite element or finite volume solvers. However... let’s take a moment to talk about alternatives. The other fast, compiled language in wide use is C++ (I don’t recommend straight C). If you use C++ with one of the popular matrix libraries (I recommend Blaze or Eigen) you can do everything FORTRAN can, and in some cases do it better. However, these libraries are pretty complex with a pretty steep learning curve. There’s no C++ equivalent of name lists, so you need a second library for input like yamlcpp or the boost’s property tree just to get started. So C++ can match FORTRAN, but it takes extra work. The upside is that C++ has a ton of libraries and tools that FORTRAN simply does not because the community it too small / scientifically focused. The IDE support is better. C++ is a more expressive language, so you build more complicated programs without going crazy and external libraries like HDF5 have nicer interfaces. But if you over do it on the object-oriented stuff you can quickly kill performance. The other “real” option is Python. It’s a wonderful, higher level language, and the standard library is amazing. Writing complex applications is easy. Scipy has great algorithms for optimization, interpolation, linear algebra, etc. you can generate plots with matplotlib. If you don’t need max performance and you can express your problem cleanly with Numpy, Python is fantastic. If you do performance from low level loops, I personally think the sweet spot here is Python for application logic and calling out to FORTRAN or C++ for the number crunching using f2py or pybind11, respectively. That’s where we’re headed at work. Julia promises the best of both worlds in one language, but I think that reality is still a ways off. Good luck. 
Hm. Well, I am a CS major who will have to learn C++ and Python over the course of his degree anyways, so it sounds like waiting to learn it is definitely the best strategy. Without disrespect to the language (it's mindblowing that a language so old would remain relevant even in for legacy use, much less still in regular usage and actively developed), it might be that Julia will be a better option by the time I could use Fortran; Julia having been recommended to me as being worth a look by the same person (an adviser) who suggested I learn Fortran.
A totally reasonable position. However, keep in mind one thing: part of the reason FORTRAN endures is the enormous amount of legacy code that is already written and works great. If you’re looking to be in scientific computing, you *will* hit FORTRAN, so starting early can give you a leg up. (And you definitely don’t want to be that guy reimplementing these sorts of mature, battle tested codes in [trendy new language]... you can lose years of productive time going down that path.)
I wouldn't blame your professor though; if I recall correctly, it took quite a while for most compilers to get proper Fortran 2003/2008 support due to the number of new features introduced. So it makes sense to teach 90/95 at least until (a) compilers supported it, and (b) some suitable textbooks started to appear. Depending on what you use it for, Fortran 2008 is really worth learning though. For my use, object-orientation with inheritance and polymorphism has been a godsend. For some people, I know that the possibility to interface with C libraries is a prerequisite to even use Fortran for their work. Coarrays also seem to be gaining in popularity these days.
Julia is fun but be prepared to have your mind melted by tracebacks.
Also it's quite comfortable when working with matrices and vectors. And modern Fortran even has some kind of object orientation so you can have some kind of hierarchy (e.g. write a function which takes a generic nanostructure and then call it on derived structures). And for stuff like configuration files there is even a great JSON library.
If you know C++ it's easy to go to Fortran and viceversa. The two languages have a lot of parallels. You just have to learn the key differences. 
 CALL RANDOM\_NUMBER(some\_real) 
is some\_real the seed? hence it's pseudo random?
You can specify the seed with RANDOM_SEED, the value some_real is either a variable or array of type real which will be filled with random numbers. 
right so for rand(1, 10\*b) in MATLAB I would do CALL RANDOM\_NUMBER(1,10\*b) &amp;#x200B;
No. Matlab: a = rand(1,10\*b) Fortran: Integer, parameter :: b = # Real :: a(10\*b) Call Random\_Number(a)
that produces an array of length a made out of random numbers?
it fills your array ‘a’ (which is length 10*b) with random numbers. 
Fanastic. Thanks for the advice. Fortunately, according to a helpful commenter down-thread, it sounds like the resources (or at least *Modern Fortran Explained*) that teach modern Fortran also teach the older features, so hopefully juggling all this modern vs dated stuff shouldn't be that bad. It is very good to know I can't treat Fortrans calls like black boxes, though -- as I would have otherwise assumed. 
I speak with some ignorance here but would it be any particular use when working with so-called "big data"? Since large amounts of data can often take a while to work with, even in languages or with operations that aren't slow under other circumstances. (I'm planning on a career path in AI or data science, is why I ask.)
Definitely noted, thank you. I will take special care around them when/if I pick Julia up.
Legacy code is more or less the reason [why I was encouraged to pick up Fortran in the first place](https://www.reddit.com/r/fortran/comments/anmvqe/for_a_given_use_case_how_can_a_neophyte_tell_what/eg4oaa6/), so this isn't a surprise to me. However, I clearly had no in-depth grasp of why the legacy code has stuck around for as long as it has, so I appreciate you going into detail. As for being in scientific computing, I think so? I don't have plans to work science, instead intend on going into data science or AI (in industry rather than academia), but am quite certain above all else that my professional niche is somewhere within the intersection of mathematics or stats and CS. I'd guess that's covered under scientific computing as much as, say, a computational subfield of a natural science.
Yeah, definitely. Python is great, but I've seen people encourage against learning it as a first programming language, and I think I agree with that; it's almost *too* easy. Fantastic to hear about C++ -- that means I should be well-prepared for Fortran when I need it.
The seeding procedure is a little more complex. For most normal circumstances, you can just use RANDOM_NUMBER, but whether on not you get the same sequence is very compiler dependent. That is where the RANDOM_SEED comes in. First, you have to find out the length of the seed array; this is not specified by the Fortran standard, and is compiler dependent. The following will write that number to `n`. CALL RANDOM_SEED(SIZE=n) Now, you can allocate an `array` of that size, fill it with your seeds, and then: CALL RANDOM_SEED(PUT=array)
*Wooo* It's your **7th Cakeday** LoyalSol! ^(hug)
Okay thank you, is there a way to produce numbers say from 0 to 5 instead of 0 to 1
umm... multiply by 5?
Doesnt work 
What do you mean? Look it is simple: x times 5 is 5x. So the multiplication maps the domain [0,1) to [0,5).
I don’t follow data science very closely, but from what I’ve seen it’s appears that many of the popular libraries are being developed in C++/Python. FORTRAN doesn’t really seem to be a popular language in that context (though many of those frameworks rely on FORTRAN under the hood for fast matrix math, e.g LAPACK). If that’s where you think you’re headed, that’s where I’d start. As another commenter said, once you learn one low-level level compiled language it’s reasonably easy to gain basic proficiency with another. 
Python is a wonderful language to learn regardless. You can do a lot really fast in it especially since the community support and such is really great as well. 
First, there is a syntactic mistake at line 28, `distances(k)=...` and not `distances=...` Aside from this, there is a mistake in your logic. Hints: are you sure you check all possible combinations? (if n points then total lines or distances are: n(n-1)/2). example: suppose total points are n then min\_dist = (put a large number) do i = 1, b-1 do j = i+1, b distance = find the distance between Point(i) and Point(j) if(distance &lt; min\_dist)then min\_dist = distance min\_point1 = i &amp;#x200B; &amp;#x200B; &amp;#x200B;
I'm trying to transcribe a script I made on MATLAB and I'm facing many difficulties putting it in Fortran
How would you tackle this problem then? I understand what you're saying but I'm not very fluent in fortran, how do you store min\_point1 and 2 in arrays?
the code you linked doesn't even compile so how are you even checking the distances? post the code you are currently testing
What’s the issue with the Matlab code in the first place?
I'm not an expert on the question, but im keen to look with you. By any chance, could you share your code ? If not, what are your compilation flags ? By experience, the compilation time is mostly due to the file length. The fact the two files of seemingly the same lengh result in two different compilation time is a surprise for me. 
Unfortunately I cant share the code, which makes asking for help a bit more difficult. ifort -O2 -ip -mkl=sequential -align all -xSSE4.2 -fp-model precise are the flags included in the makefile. I didnt create this code originally, I'm working with and adding to it. Yep, it's confusing me too. What's also confusing, which I forgot to include in the post, is that this issue appeared instantaneously yesterday. It was fine at length 4000ish, then the compiler began to play up. I removed a big chunk, dropping the size to about 3000 lines which it handled with no issue yesterday, and the issue is still there. Removing the optimization flags -O2 -ip doesn't do anything to help either. Totally lost.
A couple of questions and things to examine: How complex are your data structures? If they are too old then that version did the compiler might be struggling with them. That is a pretty old version of intel and at various times I have had issues with intel having long compiles with my code. Do the compiles take the same time with different optimizations? Again, just based on past experiences. Does your code rely on other modules (I.e circular dependency issues)? 
So if you change file B to match file A exactly then you still have a long compile time? But when you compile it as file A it is fast? That doesn't make sense. What's the difference in the Make output?
You mentioned Linux. Can you compile with gfortran-8? Any errors or warnings? Did you try debugging compilation flags? Anything there?
Cry
In addition to cry, I’d also ask “why?” 
&gt;Maybe do you know decompiler from dosos exe file, it was written by Fortran? I have no idea what this even is. Do you mean DOS? Because DOS isn't a single executable. 
Ok, I’ll try again: there’s special program written in the 90s (that’s why it’s not a windows program) on Fortran. It consists of 6 exe files which we can’t start (dosbox can’t run them) that’s why I must translate it in c++
You're going to need a disassembler and a lot - I mean a LOT - of coffee. Probably for a long time.
Probably not much going straight to Fortran, it if you can first even load the programs with * [Decompiler](https://sourceforge.net/projects/decompiler/) * [Ollydbg](http://www.ollydbg.de) * [SoftICE](https://en.m.wikipedia.org/wiki/SoftICE) no direct link, maybe you can find the doss version, was a paid product * [Boomerang](http://boomerang.sourceforge.net) * [IDA](https://www.hex-rays.com/products/ida/order.shtml) Starter or Pro - Paid product but it’s the reference in reverse engineering * [WCB](https://github.com/pavlukivan/windows-codeback-disassembler/releases) Otherwise you can try and see if anything from the [Disassemblers and Decompilers list](https://en.m.wikibooks.org/wiki/X86_Disassembly/Disassemblers_and_Decompilers) on wikibooks has something that fits. First you really should figure out if you can run the programs, or if you are missing something crucial like a library or data file. You need to run these correctly in a dos VM or something before you can really start to analyzer decompile them. If you have money, consider hiring a consultant specialist in disassembly, maybe Hex-rays would be a good place to contact, since they specialize in it. 
**SoftICE** SoftICE is a kernel mode debugger for Microsoft Windows up to Windows XP. Crucially, it is designed to run underneath Windows such that the operating system is unaware of its presence. Unlike an application debugger, SoftICE is capable of suspending all operations in Windows when instructed. For driver debugging this is critical due to how hardware is accessed and the kernel of the operating system functions. Because of its low-level capabilities, SoftICE is also popular as a software cracking tool. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/fortran/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
If you're note experienced at reverse-engineering assembly, you're probably going to need to hire someone to do it for you. This isn't something you're going to do as a weekend project.
Honestly as long as you understand what the program is doing it will be better to rewrite the whole thing yourself.
Get a better emulator. I wonder if you have Win32 or PowerStation 1.0 stuff that is actually pre-release Win32. Either way, you are up for a MASSIVE battle.
How complicated is the program? Honestly it's probably better to spend the time reimplementing it from scratch. 
Yes, it would be of use. I have disassembled simple Fortran executables and the main function is essentially C like in terms of opcode complexity. That, and the ability to perform array computations concurrently make it an excellent language as the back end number cruncher for big data. As a matter of fact, climate model calculations are performed using coarray Fortran.
I’m so sorry if you have some difficulties understanding me (I’m Russian) This program will a part of my PhD thesis and it could easily calculate some types of gears. I’m such an engineer, not a programmer. That’s why now I am just meeting with programming especially decompiling. Although this program was written a long time ago, it has a very good calculation algorithm which very hard to restore if I’ll must rewrite code. That’s why I’m looking for a piece of advice 🙁
Match file A's length exactly* Two unique files of equal length produce astonishingly different compile time (sorry for delayed reply). I've managed to bring the compile time way back to a reasonable level by removing all :: SAVE variables (4) from the script and turning them into global vars. No clue why it works, IT dont know why it works. Cant check anything until monday im afraid.
Sorry for delayed reply; the data structure [apologies if I'm misunderstanding, even basic IT/software jargon goes straight over my head] isn't overly complex when I compare it to other codes. Biggest variable is a global 850x850 matrix. It relies on one single module storing about 4 global vars (including the matrix). I managed to axe the compile time down significantly by simply removing all :: SAVE variables in the file. Clueless why that worked. I've also removed as many IF and DO statements as possible and stream lined the whole routine but that didnt have a noteworthy effect. It's weird.
Oh and removing -O2 -ip flags made no change also
Oh wow, you are in trouble. Is there no user manuals detailing the algorithms? Developer notes? Something that can help you? At least, you must know what the basic formulations of the gears must be, right? Then you can hopefully for you focus on some sections of the code. But it’s going to be serious archeology to get the maths out, because from the compiled code you won’t have any variable names, so you will have to rebuild the whole logic from: Load Memory Address ZZZZYYYYXYXY to Register A Add 5 to Register A Load 22.54 to Register B Multiply A and B, Store in Register C Store Register C at Memory Address XXXYYYYZZZZ That is going to take some serious work, because you will have to infer what A, B, C are as variables and they will be all changing through the code. Maybe the memory addresses are stable. Is there something you can share with us to help you? 
Follow-up: In case anyone is wondering, the source code to at least part of the exes was found in paper form, allowing the OP to start without having to decompile the programs yet.
Absolutely! Effectively, I don’t get a choice in the matter, as I need it *period* for my intended subfield, but even if I didn’t I would learn it anyways. It’s useful, easy, and insanely versatile, not to mention great for whiteboard interviews. 
I last used it for a population balance problem. Calculate the droplet size distribution of a water in oil emulsion and calculate separation in the presence of an electric field. It was for an electrostatic crude oil desalter.
Eclipse works fine for me.
That's definitely the better option. I was hoping OP had considered that prospect already
It might be worth asking this question on Intel's forums if you're using their compiler ( https://software.intel.com/en-us/forums/intel-visual-fortran-compiler-for-windows ). They're usually fairly active, and the actual devs of the compiler will sometimes even respond.
Most importantly, it won't be readable. Fortran is not that difficult to learn, if performance is really needed for your application, give it a try. To answer your question, I think the generated code should be quite alright, but it will depend of the complexity of the mathematica code. 
Thing people often forget is even if you write bad fortran code, it is still fast enough for most problems that you won't lose any meaningful amount of time...
I do not know about Mathematica export code to Fortran, but for many of these tools, the export is done by converting C++ code to Fortran. &amp;#x200B; Most of the time.. * it is not optimized for speed * readability is awful (awful names for subroutines, awful names for variables, tons old "DO \[label\]", a very few comments, ...)
as a general rule machine generated code is poorly optimized and unreadable. Fortran isn’t too hard to learn, if you really need the performance just use fortran from the start. If you’re doing array heavy stuff and don’t need the full performance of fortran then python using a lot of numpy is nearly as fast in a lot of cases and way faster to write. 
Pardon my ignorance, but you actually generate "real bona-fide code" with Mathematica? I always thought it was limited to do things like take the long and possibly complicated output of some (say) messy . symbolic algebra, and then generate an expression thats fortran legal. You then would copy and paste this into your program and be a bit more confident you havent made a typo.
OP, come to think of it: you mentioned that DOSBox didn't run the executables, but could you run them within a DOS virtual machine? That might save you a whole lot of trouble.
The number following simply declares the size of the data type. Int4 is the standard integer size and Real8 is the standard double precision size. It is equivalent to the statement integer(kind=4) real(kind=8) in the modern standards. For the most part all the code is doing is declaring double precision and integers. 
My understanding is that CUDA is for C/C++ only. However, there are options for compiling FORTRAN for execution on GPU: take a look at [OpenACC](https://www.openacc.org/). However, if using NVIDIA GPUs, you will likely get better performance by rewriting in CUDA. I wouldn’t suggest starting with that approach though. Start with OpenACC and the code you have now; once you have some experience running on the GPU and you know why your program is slow, you can decide if going to CUDA makes sense. 
Nope there is Cuda in Fortran. The caveat though is not every compiler has it.
I would advise against it in general. &amp;#x200B; PGI Fortran compiler is used to compile CUDA. Expect that it will be non-trivial, nothing simple about porting a single-threaded code to a GPU.
There's [CUDA for Fortan](https://developer.nvidia.com/cuda-fortran), Fortran is a 1st class citizen in the ecosystem.
The [PGI compiler](https://developer.nvidia.com/cuda-fortran) has several options for using GPUs with Fortran. Depending on which way you go, the code will likely need extensive updating.
Fortran is the 3rd language that has native CUDA support you must compile with the PGI compiler though. 
Why not add an additional loop, where you check the random numbers? You could also restart your application with POSIX signals (SIGHUP for restart).
Add a WHILE loop enclosing the random number DO loops.
I can confirm. I did part of my graduate work on porting science codes over to GPU and it's a much more difficult task. 
kind=4 or kind=8 are not modern, the values of the kinds depend on the platform. The modern way is to use selected\_int\_kind and selected\_real\_kind that give the value of the "kind" for a requested accuracy. Read all about them at [https://software.intel.com/en-us/blogs/2017/03/27/doctor-fortran-in-it-takes-all-kinds](https://software.intel.com/en-us/blogs/2017/03/27/doctor-fortran-in-it-takes-all-kinds) &amp;#x200B;
Yes I know which is why you usually define a parameter. However on most platforms 4 and 8 are the defaults. kind=xxx is part of the F90 standard. 
Random numbers are outside the DO loops. I think I've figured out adding a GO TO leading before the random number call. It's not very elegant but does the work. 
Nobody likes GOTO’s. What about an IF statement?
What's wrong with them? Sorry I'm pretty new to fortran
Use of GOTO’s makes the code difficult to read and debug. Block-style programming with IF’s, DO’s, etc is preferred. There are numerous constructs/statements that are allowed by the older Fortran standards but have been deprecated or eliminated in the newer standards.
Use of GOTO’s makes the code difficult to read and debug. Block-style programming with IF’s, DO’s, etc is preferred. There are numerous constructs/statements that are allowed by the older Fortran standards but have been deprecated or eliminated in the newer standards.
The code itself is not very long must be around 15 lines, it's more like a script. 
Always avoid goto. Just think of how you call the loop. And you might want to add a while
Can you just enclose everything you have currently in a subroutine with an exit_status argument, and call that subroutine within a while loop. If conditions are met, return from the subroutine with `exit_status` equal to `1`. Have an `IF` statement to check the `exit_status` - if it is equal to `1`, then break out of the main while loop with `EXIT`.
&gt;I'm not a programmer Then hire one. Seriously. People have to stop pretending programming is a walk in the park, especially parallel programming like what you want to do. Also, as far as I know, CUDA is more mature in C than in Fortran. A good programmer should be able to port your program to C and make it CUDA ready.
You need names do loops, and then you can EXIT or CYCLE a specific loop. http://www.personal.psu.edu/jhm/f90/statements/cycle.html
Use a do while loop. Change the seed for the rng inside that while loop. Also, fortran's rng is not that good; it's always better to write your own.
It will be part of my dissertation and there are only about 600 lines of code... Hiring someone isn't really an option....
What kind of code were you working with? I'm doing this for graduate school for a hydrologic model that feeds data to modflow. I'm obviously not going to tackle modflow (which is also Fortran) but my piece of code is about 600 lines in total.
Of course. But when you give advice on modern Fortran programming, it is best to promote "good practice", see here for instance: [http://www.fortran90.org/src/best-practices.html#floating-point-numbers](http://www.fortran90.org/src/best-practices.html#floating-point-numbers) or the other link I gave. On the other hand, "Int4 is the standard integer size and Real8 is the standard double precision size." is wrong. The values 4 and 8 are processor dependent and not fixed by the standard. It happens that many compilers on intel processors will do just that. But is it not standard and not recommended by Fortran practitioners.
Hi there, there are some misconceptions in your question and it is clear that you do not really understand what you are talking about. First things first, you cannot compile with CUDA. CUDA is a parallel computing platform and application programming interface model created by Nvidia. It means that if you redesign (gpu-parallelisation) and rewrite your code using CUDA you could compile it with a proper compiler i.e PGI Fortran compiler. *"it sounds like there are tools or there that do this pretty easily"* no there are not!!! In fact there is nothing easy about this. This is a demanding task even for experienced programmers. What you need : 1. Very good understanding of the physical problem and it's mathematical formulation 2. Excellent understanding of its implementation in Fortran and how this serial - cpu wise- algorithm works i.e. memory layout, algorithms, containers etc. 3. Read tutorials on cpu-parallelisation. The easiest way is using OpenMP. In short make the code parallel in cpu. If you succed this, then: 4. Read tutorials on gpu-parallelisation. Even if you understand the basic "hello word" examples, which are single vector additions, don't expect to be able to apply this to your code. There are alot of corners and details when you redisign a scientific code to be gpu-parallel. To sum up, what you ask, considering that you are not a programmer is impossible. My advise is to learn basic programming in Fortran, and try to understand (reverse engineer) those 600 lines of code (a debugger could be of great help at that point). Best case scenario is to be able to use OpenMP at some point when you are confident enough. Or simply hire a programmer who knows about these stuff, you explain the physical and mathematical part and he/she the programming part. 
Hey, st4vros, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
delete
Could you elaborate on Fortran's rng? Surely there is a good rng already written for Fortran somewhere. What do you recommend?
'delete'
I generally write my rng in c++ and then use it in fortran. If you want to find a good rng written in fortran maybe you could check numerical recipes, if I remember correctly.
&gt;Of course. But when you give advice on modern Fortran programming, it is best to promote "good practice", see here for instance: http://www.fortran90.org/src/best-practices.html#floating-point-numbers or the other link I gave. I didn't say to use it, I said it was equivalent to this. Since he was asking "what does this piece of code do?" Especially since he was asking about old F77 code. If he had asked what's the best way to perform a certain task then I would be promoting good coding practices, but that was not the question. &gt;On the other hand, "Int4 is the standard integer size and Real8 is the standard double precision size." is wrong. In the old F77 standard it was. https://docs.oracle.com/cd/E19957-01/805-4939/6j4m0vn6m/index.html And for the most part it is. There's exceptions, but when reading old F77 code REAL*8 usually means double precision. 
Goto statements are not inherently bad, but if used improperly can lead to a code being unreadable and extremely difficult to debug. It's like if you were reading page 102 of a book and suddenly it says "To figure out what happens to Joe, flip to page 1002" only to find when you flip to page 1002 you find a line that says "To figure out how Joe survived, flip back to page 101" Except it isn't a one off occurrence, but instead the whole book was written like that. 
Read in each line individually into a character array of long length (1,000 or 10,000). Then parse the character array and determine the number of entries in the row by looping 1 to 1,000 and count the number of delimiters on each line.
So it's kind of hack-y but it would just run it through awk first. awk '{print $NF, $0}' yourfile &gt; betterfile No need to reinvent the wheel, yeah?
Read a character at a time until you reach the new line character. For storage, place each read character in a buffer that starts out with a fixed size of say 16. When you are about to place the 17th character, reallocate _double_ the storage (so 32) and continue this way. Then you don't have clunky fixed size arrays like a pleb but your allocation is logarithmic instead of linear.
the delimiters are single spaces, I tried this approach but it just yields everything after the last record as more delimiters. Even worse the values in each space have different character lengths, so I can't just subtract out the final count.
Can't you trim the string before parsing it? http://www.lahey.com/docs/lfpro78help/F95ARTRIMFn.htm
MPI_LONG maybe? or MPI_LONG_LONG ?
*Modern Fortran Explained*, Metcalf http://fortran90.org/src/best-practices.html http://fortranwiki.org/fortran/show/HomePage http://www.sdsc.edu/~tkaiser/f90.html http://www.ifremer.fr/ditigo/molagnon/fortran90/engfaq.html http://www.mrao.cam.ac.uk/~rachael/compphys/SelfStudyF95.pdf 
Numerical recipes in Fortran 77 and 90 Author(s): William H. Press, Brian P. Flannery, Saul A. Teukolsky, William T. Vetterling Publisher: Cambridge University Press, Year: 1992 [http://lib1.org/\_ads/B5E18D06A64B334E8AF08EE82B1961D0](http://lib1.org/_ads/B5E18D06A64B334E8AF08EE82B1961D0) [http://gen.lib.rus.ec/search.php?&amp;req=fortran&amp;phrase=1&amp;view=simple&amp;column=title&amp;sort=def&amp;sortmode=ASC&amp;page=1](http://gen.lib.rus.ec/search.php?&amp;req=fortran&amp;phrase=1&amp;view=simple&amp;column=title&amp;sort=def&amp;sortmode=ASC&amp;page=1)
If you want to be serious about doing mathematical modeling, I would also suggest learning to use highly optimized mathematical libraries (like elpa/scalapack/lapack for eigenvalue problems, or any other library you may need for your modeling needs). No need to reinvent the wheel if there are very robust, scalable libraries out there.
For simple loops it is just as easy as replacing your do loop with an openMP do loop. The most basic example which works if you are not already inside a parallel region: !$OMP parallel do do i=1,n b(i) = 2*a(i) end do !$OMP end parallel do If you are inside a parallel region launched by !$OMP parallel. You drop the "parallel" and just use !$OMP do Likewise, you use the same clauses to define your parallel environment on line 1. e.g. private(i) or num_threads(n_threads) as you do when opening the parallel session. The openmp website has a f95 document which will teach you everything you need to know. https://www.openmp.org/wp-content/uploads/F95_OpenMPv1_v2.pdf
Can you debug the dumps? Run in gdb or whatever? Maybe it's about what you put or do not put in PRIVATE(...)
&gt;Why isn't is as simple to just convert a do loop ( which is parallelizeable) to a parallel one? A common mistake I've seen from beginners is that while a loop might be parallelizable purely in terms of the loop structure, that doesn't mean the algorithm itself is still correct in parallel. Simple example is take a loop iterating through time steps. You *can* write omp parallel do on that loop, and the compiler won't complain and dutifully parallelized it, but the results were certainly fail.
I wrote a long comment when you first posted this but it seems I maybe didn't hit submit or something so I'll summarise it again: There is nothing that can do it automatically, not even roughly. It will need to be done by hand. Where I am coming from is I have written many high performance scientific codes using CUDA Fortran. All it takes is the PGI fortran compiler (which can be gotten free for non commercial purposes). &gt;I'm not a programmer but... This is an issue, I am also not a programmer but I do have 5-10 years writing HPC numerical simulations, CUDA is not trivial to write. It will be many times harder than writing an MPI or openMP version of your code. Before you consider doing it answer these two questions. 1. Is my code HIGHLY parallelizable. I mean of the order of thousands if not tens of thousands of independent threads. If you do not have this then it likely will not be worth the effort to parallelise. Depending on the exact things the code has to do (e.g. if there is a lot of waiting for memory access) you could need up to 100,000 simultaneous threads in flight to get full occupancy. 2. Is the computers time more valuable than your own? It can be fun to optimise code, cathartic almost. However, it is going to take weeks for a reasonably complex code to be ported and if that will only make a 30 minute code run in 5 minutes then what is the point? Only consider it if your code takes an unreasonable amount of time. Remember also that the maximum speed up is just the difference in FLOPs. If you have a Xeon E6 at 500 GFLOPs and a titan xp at 12 TFLOPs then at MOST you can get a 24 times speed up but in practice, you will probably fall short by a factor of maybe 2. This brings me to the main issue, having decided it is worthwhile, you embark upon rewriting your code in CUDA. Now, imo, Fortran is easier to write fast code than C and CUDA Fortran is no different. However, just like cuda C, it is unbelievably easy to make a mistake. By mistake I don't even mean a typo that will give you a compile or run time error, those are easy to catch and fix. It can be easy to construct your code in such a way, such as by incorrect memory access order, that makes it unbelievably inefficient and yet looks fine. There are so many pitfalls in CUDA where you can slow down code by orders of magnitude due to improper practice. So, if it is still worth it, the best resource is what you have already seen, Nvidia's CUDA documentation is fantastic. Otherwise I can only recommend googling for lecture notes or textbooks.
Thank you for your detailed reply! It does seem like I have over-simplified my problem and over-estimated my ability.... Unfortunately I need to learn Fortran (or learn to rewrite the legacy code in something else) if I'm going to finish my PhD so I don't have a huge choice about becoming a programmer. I came across this research and may have over-estimated how this could be done automatically: https://www.cct.lsu.edu/~korobkin/tmp/SC10/tutorials/docs/S03/S03_Porting_Fortran.pdf About my actual project/code: I think it could benefit from GPU processing because the general process goes something like this: 1) Create file structure (flat text files) [single thread] 2) Read initial conditions for all the square polygons in the initial setting (2d grid) [single thread] 3) Calculate changes (multiply existing value and add/subtract a change) to each square polygon (only based on that polygon during one time step) [10,000 threads that are not dependent on what order they complete] 4) Add the sum of changes from the prior step together and track [single thread] 5)repeat step 3 but add a fraction of the total from step 4 6)repeat step 4 7)repeat step 3 8)repeat step 4 .... .... repeat about 25,000 times (daily for 70 years) .... 9) Summarize the daily values to a table. The step I described as having up to 10,000 threads could have a nearly infinite number of threads. Right now each "polygon" I described is a calculation about a 100x100 meter area on the ground but it could be a 10x10 meter area and I could calculate the value across an entire country instead of my research across a small valley. What do you think? Right now that step runs sequentially on a single thread but if all I need to do is make that section run in CUDA in any order at all then the hardest part is probably keeping track of the output from that in the flat files where everything is currently recorded. That is, right now polygon 1 always completes before polygon 2 so the file is always written in order, first polygon 1, then 2, then 3, etc. with each row being the values from a polygon.
In Fortran you have to be careful with the parallel/non parallel variables.
Based on your assertion that the loop is parallelizable, I'm assuming you are actually doing everything right with the variables (the correct values are private, reductions are used where necessary, etc...). However, it's very easily to make mistakes with parallel programming. There are a few additional issues which can cause failures. One is multiple threads trying to do i/o operations on the same file, which can be avoided with the open mp critical or atomic directives. Another thing that can cause horrible problems is declaring derived type private variables. It's a bug in the compiler or something, so it's implementation dependent. If you've made a derived type private, you should consider an alternative workaround strategy... A potential debugging strategy would be to put everything in a critical region (only one thread can access it at a time), and then slowly reduce the size of the critical region until you find the culprit. 
&gt; What do you think? I mean it could be worth it, if this code takes days to run and you need to run it tens of times. If you assume pessimistically that it might take 2 months to get the CUDA version working, base your cost estimate on that. So step 3 does sound trivially parallelizable, swap your loop for thread indexing and make it a CUDA call. As for step 4, assuming this sum is over all elements from step 3 and is thus contributes significantly to run time: host 2 device and device 2 host memcpy's are EXTREMELY slow (think about 2GB/s maybe even less) so you don't want to copy the data from step 3 back to the host to do step 4 and then back to the device to do step 3 again. These slow memcpy's mean CUDA is not like openMP where it is as easy as just doing the parallel parts in parallel and the serial parts in serial. Even without this slowdown, if your code is 5% serial and you get a factor of 50 speed up from CUDA then the runtime of the 5% part of the code will take 90% of the runtime so, in your case continuing to do step 4 in serial not only destroys your code by memcpy calls but also ruins any speed up anyway. You can actually parellelize sums (like in step 4) too by various methods for example, odd threads add the next value then repeat in a pyramid till you get down to a small number of values or something then add them serial. The values being summed are already on the device so you don't lose anything to copies but as the pyramid reduces more and more threads are masked out and do no work. &gt; hardest part is probably keeping track of the output from that in the flat files where everything is currently recorded. So you can label your output for one so it doesnt need to come out ordered. Secondly if you are sensible you are not outputting every timestep anyway (since if you need every timestep your timesteps are too large anyway), if you only output every 50-100 timesteps maybe the overhead is fine anyway. Keep in mind the device CANNOT write to the disk, that must go via the CPU. The good news here is that this output would be perfect to run async streams. You do an async device2host copy then write out the files while the device continues to timestep. You prob will need to alternate your "current data" array and "next data" array to have this properly async otherwise you are gonna be waiting on the copy to complete so you can update the data being copied to new values. Anyway, hope some of that was a help. I can not emphasise enough though that you should be ABSOLUTELY SURE it is worthwhile before you bother, I can almost guarantee it will not be worthwhile. If you just need a moderate speed up then vectorise your spatial loop and compile with -apo -O3 or with -O5, for significant speed gains by using compiler level parallelisation. Or replace your spatial DO loop with an openMP loop: for 2D do i=1,nx !$OMP parallel do private(j) num_threads(n_cores) do j=1,ny A(i,j)=maths_or_whatever(i,j) end do !$OMP end parallel do end do or something, I havent used openMP in a bit. 
I used a lot of fortran95 doing Monte Carlo simulations. Now i'm programming "user programmable features" for ansys in fortran77 that needs to be in f77 
Wow! Thank you! I think you are probably right that this isn't going to be worth the time. It currently takes about 12 hours to run the model at the current resolution. I'll need to run in many times over the next few years but that probably won't make it worth the effort of making it GPU code. I'll need to learn Fortran no matter what so maybe along the way I'll see if I can at least multithread it for CPU using OpenMP but you've convinced me that GPU programming is probably out of the question and unnecessary anyway. Thank you for your advice and detailed explanations!
thank you so much, I am still in the process of learning fortran as I am embarking on my first few projects and don't know all the keywords available yet. I think this will make my current subroutine work I'll tell you in the next few days!
Ö! Let me know how it goes. I've only started fortranning about a year ago and I never thought i could help someone with this!
Hopefully, the fact that we're on fortran subreddit and that the thread is old is going to mitigate the back-clash, because of what I am going to say. ;) I refer to C and C++ . I know you can use them to write excellent numeric code (in the course of my scientific lifetime I had to use wonderfully designed GEANT4 package from CERN). However, Fortran offers the most intuitive programming interface to algebra and, again, I am speaking of compiled languages here. But, hey, pick your poison. Lisp is, I guess, even worse than C in expressing what normal human beings call mathematics ;) . 
Worked perfectly
As other have suggested, "Modern Fortran Explained: Incorporating Fortran 2018" by Metcalf et al is an excellent resource (although it is too comprehensive for an absolute beginner). Whatever book you pick up, make sure you learn the new features of Fortran, most importantly, 2008, and 2003 Fortran standards. These new standards as well as the newest Fortran 2018, contain extremely powerful and useful concepts (parallelization syntax, advanced (sub)modular programming, OOP) that are essential for modern scientific computing. If you have just begun programming in Fortran, then I suggest you to have a look at my answer here: [https://www.reddit.com/r/fortran/comments/abzybf/which\_version\_style\_cluespointers\_to\_contemporary/ed9j2bi/?context=3](https://www.reddit.com/r/fortran/comments/abzybf/which_version_style_cluespointers_to_contemporary/ed9j2bi/?context=3)
I was going to comment to this extent. Even if complicated I'd do this anyway. Run the code with as many different inputs as possible (script it) and store any output. This will let you validate your new code. Assuming the exe ever worked fully at all.... Make notes regarding what the program actually does and then design a modern implementation that's scalable, portable and easy to maintain. You might spend months decoding the assembly only to find the coding works but is shite. Or was hacked. 
You can issue shell commands inside of fortran code. call execute_command_line('wc -c &lt;name.txt&gt; wc.txt') This will write the number of columns in a separate text file where you can read that text file later in the code to know how many columns you have I think 
Yeah I almost went that route.
my solution was very similar to this one https://stackoverflow.com/questions/26496993/fortran-count-number-of-data-in-a-line-of-a-csv-file I just added a trim function and rewind Read( 10, '( a )', End = 200 ) line numnum = Count( (/ ( line( i:i ), i = 1, Len( trim(line) ) ) /) == ' ' ) num = num + 1 rewind(ReadNumber) 
my solution was very similar to this one https://stackoverflow.com/questions/26496993/fortran-count-number-of-data-in-a-line-of-a-csv-file I just added a trim function and rewind Read( 10, '( a )', End = 200 ) line numnum = Count( (/ ( line( i:i ), i = 1, Len( trim(line) ) ) /) == ' ' ) num = num + 1 rewind(10)
Ix1 is just the variable name. It means whatever you assign to it Goto will go to a label, not necessarily the line number. E.g. ‘goto 100’ will find a line like ‘100 continue’. Then it executes that line and continues, it doesn’t to return to the goto
The value ix1 is set to in the first line is used in the RHS of the second line, which changes the value to something else, and then it gets new values about a hundred more times before the function returns. I'm not sure why they do it that way in this particular function which appears to be a PRNG.
All executions in fortran are also sequential, so if the goto 100 it will go to that line and execute every line afterward. The first column should have the continue numbers in it. goto 100 100 continue
All executions in fortran are also sequential, so if the goto 100, pops it will go to that line and execute every line afterward. The first column should have the continue numbers in it. Having lots of goto's especially in do loops is a sign that the program is compiled in Fortran 77
Some compilers assume the variable will be in integer because it begins with the letter i. Old convention.
What is the purpose of this function?
ix1,2,3 are temporary buffers in this case. They are just used to calculate a one liner, then use the value to calculate something else, erased and reused to calculate something else, repeat....
Not sure. That's what I am trying to figure out.
Thank you!
Thank you!
It's boiler plate F77 code from *Numerical Recipes, The Art of Scientific Computing*. Press, Teukolsky, Vetterling and Flannery. Cambridge University Press 1986. it is just a random number generator
I would have to see segments of the code to take a look. It's possible they overwrote the intrinsic word. Fortran unfortunately allows you to do that to an extent to keep compatibility with old standards. For example this is legal integer :: sum sum = 2 even though there is a sum function totalsum = sum(somearray) 
I'm quite surprised, I don't see how it should work... `TYPE` is used to define derived types (like an object) even with ifort. If you can share a piece of example, I'd like to try it. 
You should look for ` Format `. I guess something like `'(I5, ",")' ` instead of `*` could work! 
Better yet use I0 so that you can use any length integer.
What do you mean?
As u/calsina said, you can use a format specifier and do something like this: write(11, '(i5)', advance='no') numbers(1) do i = 2, number_of_primes write(11, '(",",i5)' advance='no') numbers(i) end do write(11,*) ! newline to write them out, but if you use the `i5` format specifier the numbers that are less than 5 digits wide will be padded with spaces. You could pad them with zeroes instead by changing `i5` to `i0.5`. Unfortunately I don't know an easy way to print left justified numbers, altough it's not that hard, see this [blog post](https://jblevins.org/log/leftjust). Alternatively you could just run the program through a simple post processing script. In bash for example it would be one line: `tr ' ' ',' &lt;results.txt &gt;newresults.txt`. 
The installation process is explained in the README file.
`I5` would mean that the `write` makes 5 characters worth of room for an integer of max length 5 digits. A larger integer, say 123456, would just produce \*\*\*\*\*, at least with my compiler. A smaller integer, say 123, would still be given 5 characters, ie. the first two would be spaces. Like this: ' 123'. `I0` adjusts to the integer such that it makes just enough space for the length of the integer. Oh, I also want to mention if you want to use `write` to write text, you can use just `A`. You don't have to specify the length of the string. I only learned about this recently and felt stupid for I have been counting my strings all this time lol.
Can't paste the code, but it's like so: &gt; program TYPETEST &gt; TYPE *, 'enter a number' &gt; READ(*,*) idum &gt; END PROGRAM 
Yeah, I know, that was my reaction too! See my response to the other comment for a minimal test case, although I don't have any idea whether this will compile as I only have access to gfortran at the moment. Which of course does not accept TYPE used this way!
I knew you could do `i0.w`, where w is the total width to print and it would pad any extra with 0s. I didn't know you could just do `i0` by itself and it would adjust the width. 
Do you see any pre-processor commands? IE #define TYPE = blah!
No
Hmmm. Well I can't really say I can pin it down without seeing the code, but if you have problems that prevent you from sharing it I can't really say much unfortunately. Typically it shouldn't matter in this case if you use ifort or gfort since this has more to do with the core syntax. 
Thank you all for your helpful comments.
The jobs that require Fortran aren't usually specifically for Fortran. They are more along the lines of either computational physics programmer, hpc consultant, or other fields where fortran code is common. He might have better luck looking at national labs or NASA sub-secitions for that. 
Anywhere with legacy code, especially NASA (who has to deal with interfaces for probes/satellites that was written decades ago) would defs be a great bet!
I have been told banks have a lot of legacy code written in Fortran that they are reluctant to change but still need to maintain. Is this true?
https://gcc.gnu.org/onlinedocs/gfortran/SIGNAL.html
Are you thinking of COBOL?
That would be COBOL... FORTRAN is in a lot of older numerical simulation models for energy sector.
I was told it was Fortran, but maybe the ones that told me where confusing it with cobol. Thanks for the education!
Flush buffers?
National Labs Nuclear Engineering Aerospace Engineering CFD/Fluid Mechanics Climate Science/Weather Modeling Atmospheric Transport &amp; Dispersion/Deposition Health Physics Check these areas they all do modeling that requires fortran
Thank you, but I don't understand how do you use it. Where do I call signal () ? &amp;#x200B; If I have a subroutine 'xyz' which indicates how to exit the program when ctr+c is pressed. I will compile 'xyz' in my module. How do I indicate to my program that xyz needs to be run when ctr+c is pressed. Can you explain please. &amp;#x200B;
You can also put the terminal into raw mode and read keystrokes. That's what I've done. It can capture almost anything. Take a look at this module i wrote that can do that: https://github.com/stewmasterj/fcurses 
Thank you for sharing. Its very interesting. So would it be able to read keystrokes during runtime and call a subroutine? Also I see that you have tested it on Xterm and GNU Fortran, I am currently using PGI compilers on windows, any chance that it might work on that platform?
https://software.intel.com/en-us/fortran-compiler-developer-guide-and-reference-auto From what it states, it is used to optimize the amount of memory being used to make programs run faster, though I have no experience in fortran optimization.
Oh, yikes. Compiler wouldn't be a problem, but this is designed for linux terminal interaction. Im not sure how to make it work on windows, sorry. If you could find something that works in another language or better interfaces with the OS maybe a fortran solution could be found. But i bet the Signal() function is the best start.
So it is not an array?
That links refers to a compiler flag. It's unrelated to your code. &amp;#x200B; This 'auto' function is not fortran standard. Is it defined somewhere in the code? Perhaps as a 'statement function' (which are easy to miss)?
Is this even fortran? Why are they using so many semicolons?
The code he posted isn’t even fortran
That's almost certainly Matlab. Semicolons are used to suppress output. Notice also all ends are the same. Do is for. Auto seems to be an array from here. Since it's Matlab, highlight it and press F1. It will open documentation and tell you what it is. You can also search the source code for the term.
This is the right way to do it. https://gcc.gnu.org/onlinedocs/gfortran/FLUSH.html
I would add all the companies that are involved in FEA simulation (structure, fluid, ..) like MSC, SiemensPLM, DassaultSystemes, ProEngineer, .. and so.
I think Auto is not a function but most likely an array variable defined and allocated earlier. Do you have the code before this?
That's matlab. Fortran has "do", not "for".
I am trying to convert the code from fortran to matlab.. I am not sure what to do with Auto though because it seems like it was called from somewhere else in the fortran code but it is not really shown.. so I am stuck with converting this part to Matlab. 
Initializes an array named data of size ldat to 0.0. The 101 continue is the end of the do loop.
Thank you. It is just the 1dat is not predefined anywhere. I don't know what its value is.
Without seeing the rest of code it is difficult to tell you what ldat is. 
do `grep -i ldat *.f*` to search all your .f files for ldat as a start to search for every time it’s used and try to find when it’s initialized
Alright, will do. Thank you for your time!
You have been posting a lot. We can’t tell what your functions do without seeing the whole code. Anytime you see `variable=` then yes it is just an assignment and holds whatever value is in the right side. If you see `var(i)=` then it is an array filling in the i’th element with whatever is on the right side. We can’t tell if what’s on the right side is a function or an array without seeing the whole code We can’t tell what a given variable is without seeing the whole code
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc c c Generate 3-D random rough surface by 2-D digital filter and Fourier c analysis for contact model of Gaussian distribution c c Note:Different Gaussian surface can be obtained by changing seed l in "GASDEV(L)" c Cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc c PROGRAM SIMU3D parameter (NDIM=2,NDI=128,NDAT=2\*NDI\*NDI) parameter (MDI=256,LDI=512,LDAT=2\*LDI\*LDI) dimension NN(NDIM),DATA(LDAT),DATA1(LDAT),DATA2(LDAT) dimension xx(mdi),yy(mdi) integer check DIMENSION ARRAY1(MDI,MDI) DIMENSION ARRAY2(MDI,MDI) DIMENSION ARRAY3(MDI,MDI) DIMENSION IPROF(MDI) CHARACTER FNAME\*30 real xmin, xmax,ymin,ymax,dx,dy c double precision a,b,gpei,x,y c double precision z,pre,de,GASDEV,profsin common/tian1/segma common/tian2/xbeta common/tian3/ybeta segma=1.0 c xbeta=10.0 c ybeta=10.0 NOPTS=MDI NOPRS=MDI XSEP=0.07843 YSEP=0.07843 print \*,'Enter xbeta,ybeta defined at rho = 1/e ?' read \*,xbeta,ybeta c c Required xbeta, ybeta based on actual xsep and ysep defined at rho=1/e c xbeta=2.3\*xbeta/xsep ybeta=2.3\*ybeta/ysep c c These xbeta, ybeta are based on xsep and ysep=1 defined at rho=0.1 c &amp;#x200B; YOU ALREADY DID THE FOLLOWING STEP gpei=3.14159265358979 do 101 i= 1,ldat data(i)=0.0 &amp;#x200B; DONE &amp;#x200B; 101 continue c generate Gaussian random series c Now set up initial values do 1 i=1,NDIM NN(i)=LDI 1 continue do 3 i=1,NN(2) do 2 j=1,NN(1) L=j+(i-1)\*NN(2) LL=2\*L-1 if((i.le.MDI).and.(j.le.MDI))then data(LL)=GASDEV(L) else data(LL)=0.0 endif data(LL+1)=0.0 2 continue 3 continue print \*,'test1' C c Fast Fourier Transform ISIGN=+1 call FOURN(DATA,NN,NDIM,ISIGN) print \*,'test2' do 4 i=1,LDAT data2(i)=data(i) 4 continue c Matrix multiple of DATA and the complex conjugate of DATA ISIGN=+1 call MULT(NN,NDIM,DATA,DATA,ISIGN) print \*,'mark1' C do 6 i=1,NN(2) do 5 j=1,NN(1) L=j+(i-1)\*NN(2) LL=2\*L-1 if((i.le.NDI/2).and.(j.le.NDI/2))then data1(LL)=Auto(i,j) elseif((i.ge.LDI-NDI/2+2).and.(j.le.NDI/2))then data1(LL)=Auto(LDI-i+2,j) elseif((i.le.NDI/2).and.(j.ge.LDI-NDI/2+2))then data1(LL)=Auto(i,LDI-j+2) elseif((i.ge.LDI-NDI/2+2).and.(j.ge.LDI-NDI/2+2))then data1(LL)=Auto(LDI-i+2,LDI-j+2) else data1(LL)=0.0 endif data1(LL+1)=0.0 5 continue 6 continue C c Fast Fourier Transform ISIGN=+1 call FOURN(DATA1,NN,NDIM,ISIGN) C do 8 i=1,NN(2) do 7 j=1,NN(1) L=j+(i-1)\*NN(2) LL=2\*L-1 c if((i.le.10).and.(j.le.10))then c print \*,'data(LL)=',data(LL),'data1(LL)=',data1(LL) c endif c data1(LL)=sqrt(data1(LL)/data(LL)) data1(LL)=sqrt(data1(LL)) c print \*,data1(LL) 7 continue 8 continue c Matrix multiple of DATA1 and DATA2 ISIGN=-1 call MULT(NN,NDIM,DATA1,DATA2,ISIGN) c Inverse Fast Fourier Transform ISIGN=-1 call FOURN(DATA1,NN,NDIM,ISIGN) c c c do 11 i=1,MDI do 10 j=1,MDI L=i+(j-1)\*LDI LL=2\*L-1 II=i+(j-1)\*MDI data(II)=data1(LL)/(NN(1)\*NN(2)) c c Convert data unit from mm to nm c data(II)=data(II)\*0.001 10 continue 11 continue N=MDI\*MDI call moment(data,N,AVE,ADEV,SDEV,VAR,SKEW,CURT) 
Please help with calling the variables and the "Auto" variable/function
Calling what variables? Also the auto and mult are probably defined in another file. You should go through some FORTRAN basics and tutorials. Learn how subroutines and functions are declared and used, learn how arrays are initialized, then you’ll be able to find them easier in your code. I mean you asked about `ldat` in another post, but it’s defined here in the code you just posted. Just look for the first instance of it. 
Seems likely it could be defined in a namelist in an include file (or just in the main program) and then initialised with a read statement.
This is the second half of the code; auto is actually defined but after it was used.. If this was a normal programming language an error would've results. As far as I know, the code runs in sequence, so "Auto" can't be used before it is defined! Right? And also the variable k in auto(k,l) was never defined! \*\*\*\*\*\*\*\*\*\*\*data array copied onto array1\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* do 61 j=1,128 do 62 i=1, 128 i2=2\*i-1 array3(j,i2)=array1(j,i) do 69 i=1,128 array3(i,256)=(array3(i,255)+array1(i,129))/2 do 64 j=1,128 do 65 i=2,255,2 array3(j,i)=(array3(j,i-1)+array3(j,i-1))/2 \*\*\*\*\*one half of copying done\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* do 74 i=1,128 do 75 j=1,256 i2 = 2\*i-1 array2(i2,j)=array3(i,j) do 73 i=1,256 array2(256,i)=(array2(255,i)+array1(129,i))/2 do 76 j=2,254,2 do 77 i=1,256 array2(j,i)=(array2(j-1,i)+array2(j+1,i))/2 DO 197 J=1,NOPRS DO 198 I=1,NOPTS IJ=I+(J-1)\*NOPTS data(ij)=array2(j,i) 198 continue 197 continue call moment(data,N,AVE,ADEV,SDEV,VAR,SKEW,CURT) 175 Print \*,'Input segma of the rough surface in microns' READ \*,segma1 print \*,segma1 f=segma1/sdev DO 111 J=1,NOPRS DO 121 I=1,NOPTS IJ=I+(J-1)\*NOPTS data(IJ)=data(IJ)\*f call moment(data,N,AVE,ADEV,SDEV,VAR,SKEW,CURT) print \*,'input mean' read \*,segma2 print \*,segma2 DO 190 J=1,NOPRS DO 191 I=1,NOPTS IJ=I+(J-1)\*NOPTS data(IJ)=data(IJ)-ave data(IJ)=data(IJ)+segma2 VALMAX=0.0 DO 100 I=1,NOPTS DO 100 J=1,NOPRS IJ=I+(J-1)\*NOPTS VALMAX=AMAX1(VALMAX,ABS(DATA(IJ))) subroutine FOURN(DATA,NN,NDIM,ISIGN) double precision WR,WI,WPR,WPI,WTEMP,THETA dimension NN(NDIM),DATA(\*) NTOT=1 do 11 IDIM=1,NDIM NTOT=NTOT\*NN(IDIM) NPREV=1 do 18 IDIM=1,NDIM N=NN(IDIM) NREM=NTOT/(N\*NPREV) IP1=2\*NPREV IP2=IP1\*N IP3=IP2\*NREM I2REV=1 do 14 I2=1,IP2,IP1 if (I2.lt.I2REV)then do 13 I1=I2,I2+IP1-2,2 do 12 I3=I1,IP3,IP2 I3REV=I2REV+I3-I2 TEMPR=DATA(I3) TEMPI=DATA(I3+1) DATA(I3)=DATA(I3REV) DATA(I3+1)=DATA(I3REV+1) DATA(I3REV)=TEMPR DATA(I3REV+1)=TEMPI end if IBIT=IP2/2 1 if((IBIT.ge.IP1).and.(I2REV.gt.IBIT))then I2REV=I2REV-IBIT IBIT=IBIT/2 go to 1 end if I2REV=I2REV+IBIT IFP1=IP1 2 if(IFP1.lt.IP2)then IFP2=2\*IFP1 THETA=ISIGN\*6.28318530717959D0/(IFP2/IP1) WPR=-2.D0\*dsin(0.5D0\*THETA)\*\*2 WPI=dsin(THETA) WR=1.D0 WI=0.D0 do 17 I3=1,IFP1,IP1 do 16 I1=I3,I3+IP1-2,2 do 15 I2=I1,IP3,IFP2 k1=I2 k2=k1+IFP1 TEMPR=SNGL(WR)\*DATA(k2)-SNGL(WI)\*DATA(k2+1) TEMPI=SNGL(WR)\*DATA(k2+1)+SNGL(WI)\*DATA(k2) DATA(k2)=DATA(k1)-TEMPR DATA(k2+1)=DATA(k1+1)-TEMPI DATA(k1)=DATA(k1)+TEMPR DATA(k1+1)=DATA(k1+1)+TEMPI return end function ran1(idum) dimension R(97) parameter (m1=259200,ia1=7141,ic1=54773,rm1=1.0/m1) parameter (m2=134456,ia2=8121,ic2=28411,rm2=1.0/m2) parameter (m3=243000,ia3=4561,ic3=51349) data iff /0/ if(idum.lt.0.or.iff.eq.0)then iff=1 ix1=mod(ic1-idum,m1) ix1=mod(ia1\*ix1+ic1,m1) ix2=mod(ix1,m2) ix1=mod(ia1\*ix1+ic1,m1) ix3=mod(ix1,m3) do 11 j=1, 97 ix1=mod(ia1\*ix1+ic1,m1) ix2=mod(ia2\*ix2+ic2,m2) r(j)=(float(ix1)+float(ix2)\*rm2)\*rm1 idum=1 endif ix1=mod(ia1\*ix1+ic1,m1) ix2=mod(ia2\*ix2+ic2,m2) ix3=mod(ia3\*ix3+ic3,m3) j=1+(97\*ix3)/m3 if(j.gt.97.or.j.lt.1)pause ran1=r(j) r(j)=(float(ix1)+float(ix2)\*rm2)\*rm1 return end &amp;#x200B; &amp;#x200B;
No thank you
Definitively no. Functions can be defined after there are called in many languages (and Fortran _is_ a normal programing language). See python for example. 
ISIGN=+1 is just a short hand version of ISIGN=ISIGN+1 It's just taking the previous value stored in ISIGN and adding 1 to it. &amp;#x200B; FOURN and MULT seem to be subroutines that are being called to use/change variables/arrays NN, NDIM, DATA, and ISIGN
&gt; As far as I know I think we can all surmise that you in fact, do not.
You could also put a write(*,*) ldat To see what the value is. 
It appears to be ldat, not 1dat, so perhaps you’re just searching for the wrong var name?
Random number will populate your array with a real between 0 and 1. But you can turn that into an integer yourself using multiplication and truncation.
Yes, but how that is the question....
Seriously? This is like one of the first things the teach in kiddie programming books. Page 23 : Introduction to Computer Programming, Usborne 1984 [Free download of ICP, Usborne 1982](https://drive.google.com/file/d/0Bxv0SsvibDMTUXdYTnRaTy1LLVE/view)
Good. Then I assume you will have no trouble answering the question with the appropriate code. Or could it be you are just an arsehole? Let's see....
 program test_random_number real :: r(2,3) call random_seed() call random_number (r) write (*,*) "array values.... ", int(r*15)+1 end program test_random_number Assuming you want numbers between 1 and 15. I'll send you a bill. ;) 
Try again! All that does is write integers out from a real array, even I can do that. The question was " ...populating an array with random integers...". Have another go before you send a bill. ;) 
 program test_random_number real :: r(2,3) integer :: a,b,r_int(2,3) a = 1 b = 15 call random_seed() call random_number (r) r_int = int(r*b)+a write(*,*) r_int end program test_random_number You can send the bill to me 
I'm not quite sure why the previous answer was unacceptable to you. Your example code just needed to print r to prove it was working and this will print integers in a certain range after being converted from real. If you're wishing to explicitly populate r with random integer values then you could write this as a function and call that. If you're looking for an intrinsic routine that returns random integers in a certain range then to my knowledge Fortran doesn't have such a utility, precisely because once you've got a 0-1 random distribution you can do as you wish. What is it we don't understand about your question? Other comments: please define kind type of variables, always use implicit none to stop assumed kind and type mishaps, indent code. 
You didn't say you wanted DIFFERENT integers in each spot. Your code had only one random call that picked from 0 to 1, I showed how to change that 0-1 to range from 1 to XXX
I think the OP wants DIFFERENT integers in each spot in the array, but their original code didn't have a loop for population, so I assumed they only wanted one random digit, just needed help changing the range...but it looks like they need much more help in programming that just that.
 program test_random_number real :: r(2,3) integer :: a,b,r_int(2,3) a = 1 b = 15 call random_seed() do 20 i = 1, 2 do 10 j = 1, 3 call random_number (r) r_int = int(r*b)+a write(i,j) r_int 10 continue 20 continue end program test_random_number If you want DIFFERENT random integers, you need to loop
Thank you *indestructible\_deng* and this is the way I do it at the moment, essentially converting a real array into an integer array. With very large arrays and frequent use in the main program it is time consuming. I was looking for a way to populate directly without using two arrays.
If true, then it's a random shuffle they were after- see here OP https://www.rosettacode.org/wiki/Knuth_shuffle#Fortran 
That is about the most inefficient coding I have seen *IkeEis* :) r can be a scalar or an array in call random\_number (r) and no the integers will not all be the same. *musket85* The previous answer was not unacceptable, as I said it is similar to what I do at the moment. Let me put the question another way. Is there a more efficient way to populate an array than the method used by *indestructible\_deng* above? 
Since you provide no docs on that function and used is so poorly in your first code how was supposed to know that it was not scalar only?. You keep changing what you a looking for. Good day.
*IkeEis* "...how were you supposed to know that it was not scalar only?" . Because this is r/fortran and it is a fortran function....
Generating random numbers is always time consuming is you want to do it right. You could generating a lots of random numbers using the method above and store them is a file. Using something like `2^{100} - 1` number for example could be enough. You can then pick quickly the random integer at run time. As always, you will trade speed for memory. If you tell us more concerning your need and your limitations we could try to find something better for you. 
You have a lot of guts asking a question and replying in hostility to someone who's trying to help you out. 
Weather forecasting (NWP)! All NWP models are written in fortran -&gt; what ever your favourite app shows you was produced by fortran :) 
Page 24
If you want to map a number r in [0, 1) to an intervall [a, b), use: r * (b - a) + a 
I built a web development framework in it just to show I could! http://github.com/bceverly/FABS if you want to see it. :) F - FORTRAN A - Apache B - BSD S - SQLite
It's the 1x in the format specifier, that's a single space. Remove that and it works. You were very close. 
And I'm making certain assumptions about the rest of your code but I wrote a simple test code on my laptop and it worked fine. This test loop works DO i = 1, 13 WRITE(*, '(i0)', ADVANCE='no') i END DO 
haha thanks alot!!!!
No problem.
In at least Intel Fortran, unless you change it, integers are 32-bit. What's the biggest 32-bit integer? 
32-bit signed integers overflow at 2147483648, and the sum from k=0 to 1860 of k\^2 is 2146682110. Thus, the next term will push it over the integer limits and turn negative.
I use Fortran to do high-performance optimization as part of a rheological property analysis project. I've also used it to write finite element analysis simulations for frequency-domain heat transfer problems, molecular dynamics simulations, particle-image velocimetry post-processing codes, uncertainty quantification simulations using Monte Carlo, and many other applications.
Fortran only has signed integer representation. You can get larger integers, by specifying it in your declarations. For example: #+BEGIN_SRC f90 :results verbatim program test integer(kind=1) :: int8 integer(kind=4) :: int16 integer(kind=8) :: int32 integer(kind=16) :: int64 print *, "Largest signed 8bit: ", huge(int8) print *, "Largest signed 16bit: ", huge(int16) print *, "Largest signed 32bit: ", huge(int32) print *, "Largest signed 64bit: ", huge(int64) end program test #+END_SRC #+RESULTS: : Largest signed 8bit: 127 : Largest signed 16bit: 2147483647 : Largest signed 32bit: 9223372036854775807 : Largest signed 64bit: 170141183460469231731687303715884105727 If you wanted to calculate a sum higher than that, you could setup a custom representation of some kind, but I doubt that is required for a first day introduction.
Wow, the more you learn. Thanks a lot!
Yes, as a first day this seemed a bit harder than usual. Anyways, your reply was really helpful and I completed the program with no other issue. Thanks again.
Check out Simply Fortran.
I actually just use Atom editor with a bunch of Fortran plug ins 
I think ultimately in the long run the most robust thing you could do would be to try and figure out how to get a basic makefile/buildsystem up and running for your Fortran projects, rather than relying on an IDE to do it automagically. Have you seen this http://fortranwiki.org/fortran/show/Build+tools ? Maybe something like the cmake example would be a good way to take care of the linking while being less complicated than a full blown makefile. 
I used to use eclipse with the fortran plugin and it was pretty good. It could compile multi-source program and use all the full IDE features for user written code (auto complete, function hints, error checking, etc.). Alternatively a basic make file isn't that hard to use and will pay some pretty serious dividends in the future if you plan to stick with programming (especially scientific programming). Here's a basic makefile that's an easy starting point if you'd like to try: FC=gfortran # which compiler to use FFLAGS=-O2 # what compile flags, -O = optimize code # This lays out the instruction for compiling .o files # If your fortran extension is different than .f90 change it here %.o: %.f90 $(FC) -c $(FFLAGS) $&lt; -o $@ # This is a list of depencency files, if your have file module1.f90, you add it # to this list as module1.f90, which will then call the %.o rule to make it MODS = module1.o \ module2.o # This is the actual make command to for the program. Whatever your # main program file is (i.e. mainfile.f90) should be put below as mainfile.o # This rule is what does the linking, it also links to the math library (-lm) program: $(MODS) mainfile.o $(FC) $^ -o $@.x -lm # This will remove all compiled code clean: -rm -f *.x *.o *.mod To use it you need save it in the same folder as your source files as a file named 'Makefile'. Change the files to your filenames to your files. Then to compile your program then you can either type `make program` or just `make`, it will put the executable in a file called 'program.x'. To remove compiled code you can type `make clean`.
Yes; either this^, or, if you always have to compile the same set of files, figure out your full compile line, and store it in a shell script, and run that every time. The compile line will look something like: gfortran -O3 &lt;other_options&gt; file1.f90 file2.f90 file3.f90 ... 
Unfortunately, this really is the correct solution. Working with makefiles is an important part of software design in Fortran. IDEs aren't common enough or standardised enough with Fortran, so if you get a Fortran source code you'll have to compile it with a makefile some way or another.
I really like the Atom interface and customizability. Were you be able to build and run the programs there? If so, which plugins did you use and how did you set it all up?
I wish I could, but it's too expensive for me to afford it.
I used the built in terminal and a healthy amount of aliases and so far that’s been enough. It’s not as good as a dedicated IDE would be but I haven’t found a decent fortran IDE yet. You can find a bunch of fortran packages by just searching for fortran. And make sure to use beautify
First, thank you very much for your answer. I actually started using Eclipse with Photran and everything worked fine. So far so good. I will start to learn about "makefile" in the next days and try to start using it. Thank you
Thank you very much. I used Eclipse today and worked really fine. In the next days I'll start to learn about the "makefiles" in order to use them. Thank you! :)
I tried this and worked well using Sublime Text only with three files. But because I will use tons of them I don't feel like writing them all, that's why I wanted something general. BTW, Thank you for your answer :)
The continuation character `&amp;` should be at the end of the preceding line, not the start of the next one. Depending on your fortran version there may have to be preceding spaces at the front of lines (for older fortran). It should probably look something like this though: REAL A(-2:9,-2:2) DATA A/ &amp; -.099, -.081, -.081, -.063, -.025, .044, .097, &amp; .113, .145, .167, .174, .166, &amp; -.048, -.038, -.040, -.021, .016, .083, .127, &amp; .137, .162, .177, .179, .167, &amp; -.022, -.020, -.021, -.004, .032, .094, .128, &amp; .130, .154, .161, .155, .138, &amp; -.040, -.038, -.039, -.025, .006, .062, .087, &amp; .085, .100, .110, .104, .091, &amp; -.083, -.073, -.076, -.072, -.046, .012, .024, &amp; .025, .043, .053, .047, .040/ 
Should the &amp; only be there for lines that break? The array should have 12 columns and 5 rows. If it was MATLAB zeros(5,12) would give me the right size. 
Yes, the `&amp;` is only for line continuation. The line `REAL A(-2:9,-2:2)` defines the shape and also does the allocation. It specifies length 12 in the first dimension and length 5 in the second (the first dimension is the fast dimension in fortran), with the first index for both as -2. The `DATA` part is filling in that array with those values.
In this case, the continuation character is probably at the beginning of the line because the source code copied was in the legacy fixed-form format, and a non-zero character in column 6 indicates continuation. This is one of the gotchas that pop up when copying old code. https://en.m.wikibooks.org/wiki/Fortran/Beginning_Fortran#Free_Form_and_Fixed_Form
Your input type does not match 
To put it another way, your main program defines the array as an INTEGER but you tell your function to expect a REAL.
How flexible is the driver function in python? I use sockets to couple different computational codes together and we wrote our own driver code to handle multiple code instances and address assignment. It would be nice if we could take advantage of something that has community support
In the i-pi repository socket connections are handled in threads allowing multiple connections in parallel. In my example I do not use that since I just wanted to make it as minimal as possible.
They are still teaching fortran in physics academia!
What compiler and compiler options are you using?
nagfor -O3 -o Turns out it was the -O3 that screwed it, -O2 works fine though. *shrugs* 
It basically said to figure out the teampeture of each point of a 41 point bar knowing the teampeture at each end (3° on the right, 0° on the left) And to use both Gauss and Thomas to solve it
Did you post this from the middle of an exam?
Might have done
You wouldn't happen to know how to do it would you?
I might, but I don't speak Portuguese or is that Spanish?
Then fuck off you dirty cheater.
Gauß is dead and Thomas couldn't be here today, so you gotta solve this all by yourself.
Figured it out
Literally had no idea how to define the "b" vector
Welp
Spanish
I managed but thanks anyway!
As always when we talk about speed and optimization : it depends! It depends of the variation in the number of elements, the speed of the network, the kind of communication you use... The advantage of one big array is that its size is already known. If the size changes all the time, you will need two communications : one to send the size of the array, and another to send the array. I suppose that the best would be a bit of both: reallocate the array from time to time, only if the size needed is very different from the size already allocated...
We really need more information about the problem. If your code only has a handful of "interactions", i.e. the allocation occurs infrequently compared to the rest of the code, then this isn't a problem. In a CFD code that I maintain, the information passing happens every iteration, so re-allocation would be a terrible idea. The problem statement is different, but each process holds only a portion of the problem, and only a portion of the array is passed between the processors. I pass the size, then pass the data. The arrays were allocated at the program start to be big enough to hold what needs to be passed.
The program does a Strömer-Verlet integration of a discrete particles model. Each time step would need a resize because every interaction particles would move from a region to another. Each region uses a processor. &gt;only a portion of the array is parsed Yeah, I'm reading about this. I can do this with mpi_status. This is probably the best way.
I agree with this. You can have a large array allocated if you’re worried about reallocating, but just make sure you’re only *sending* the data needed to reduce communication time. Another thing you could look it is allocating a shared memory array (mpi 3), and having each process access what they need, then the only communication you need is between nodes.
I might be wrong. But. If you are doing the reallocation. Won't you have to save the elements of the old vector to a new vector? And then reallocate the old vector and then copy all the elements back and then add the new element? Because to reallocate, you have to deallocate first. &amp;#x200B; When I find myself in a situation like this, I always try to predict the size of the vector that I would need before hand. &amp;#x200B; What are you holding in the arrays? Also. How many iterations are you expecting? What is the overall computational cost of your program? If you do the copy-new-to-old and then copy-old-to-new step in parallel, then it might not be that expensive. But then again... how many elements do you expect the arrays to have and how many processors do you have available?
You can guesstimate the max array size based off the density of the system then reallocate 50% bigger due that process every time it exceeds its limit. Also why region based multiprocessing instead of ensemble averaging? What kind of problem are you solving here.
Interesting, sounds like a DNS model? You might look at the move_alloc intrinsic as well, it might be useful if you end up changing the sizes of arrays.
Does this mean we'll be able to one day run Fortran in a browser with Web assembly?
I just recently made this interview, and I thought to share it. The article doesn't promote anything, by the way. &amp;#x200B; It's about a man who worked as a FORTRAN programmer in 1980s.
80's... VAX (750/780/ mini Vax called Vax2000).. same kind of history here, but in the FEA field.
Pardon my ignorance, but what is the relation of this project to [Flang](https://github.com/flang-compiler/flang/wiki)?
Flang is essentially PGI's Fortran compiler, targeting LLVM. It's a really old and crufty codebase from what I've seen. It's written in C, and pretty old and dodgy C at that; it outputs LLVM IR via printf equivalents instead of using LLVM libraries. f18 is a project to rewrite it in modern C++, using LLVM coding styles and infrastructure properly. I think it's still pretty early and doesn't generate code yet, but they're making progress.
Well, this is a real surprise. I've been watching the development of flang, which moves at the speed of academic funded projects (these clock in behind glaciers). I hope that this will mean I have two good open source Fortran compilers available in my standard repositories.
Some people pointed to this mistake: "by object-oriented languages like C and its variants". &amp;#x200B; C, unlike C++, isn't object-oriented. That's what Rob has said: "They are correct. I was generalizing too much in that sentence. I can post a correction." Please let us know if there any other small mistakes, we probably could correct them soon. And thank you for reading!
Nice to know, Phillip. I am from a younger generation of developers, and it's pretty interesting to know experienced guys like you or Rob.
You have a race condition somewhere. I can't go through all that code, but I did notice that counti may not be declared private properly.
Try using default(none) in the omp declaration. It will force you to declare every variable explicitly so that you can think through potential race conditions. Shared variables that are updated by all threads (counti maybe?) should be updated in an omp atomic or critical region.
Thanks for taking a look - I tried to keep it to a minimal example, but I wanted to make sure that I included the whole do loop. counti should be okay (unless it does something weird) because it is literally only a counter that prints out to the screen to track loop progress. I'm more worried about msd_cm and msd. Maybe without looking at code you could answer the following: if I have an array inside an openmp loop like this where each loop iteration affects a different part of the array, does that work? Or do I need to use a reduction on the array since the elements are likely close together in memory?
That approach is fine. As long as they address different parts of the memory it doesn't matter how close they are.
This is a good suggestion, thank you so much!
You only need a reduction (or atomic) if you do concurrent updates to the same memory location. You might debug by adding critical to one statement at a time to see if that helps identify a race. Intel Thread Checker or whatever it’s call now might help too. There may be a Valgrind variant that does the same thing.
If all else fails, then your favorite text editor and your friendly neighborhood BASH terminal are your best friends. It would be worth your while to learn how to create Makefiles to make work in the terminal more streamlined. You can save the template and use it for other programs in the future. I am using Ubuntu 18.04 with VS Code that has my local BASH terminal integrated into the editor. This saves me the hassle of having to have my Terminal application concurrently with my text editor. I am not aware if Sublime text has this feature, but you should look into that option it is available. &amp;#x200B; This is also a really cost effective solution ($0.00)!
A project I'm somewhat involved in (although not at all this part of it!) is using TCP/IP sockets so that two different simulation codes (SixTrack and FLUKA) can communicate and share particles: https://github.com/SixTrack/SixTrack/tree/master/source/FlukaIO Here it basically works by having a C library which handles the socket, and then linking this from FORTRAN. Another approach which is quite easy to implement but may be slow if you need to transfer a lot of data is to use UNIX PIPE files.
Thanks for posting this!
I think I already posted this interview though. [https://www.reddit.com/r/fortran/comments/bcalq9/interview\_with\_rob\_vugteveen\_an\_oldschool\_fortran/](https://www.reddit.com/r/fortran/comments/bcalq9/interview_with_rob_vugteveen_an_oldschool_fortran/)
Pretty interesting that link to this interview was posted twice by different users. [https://www.reddit.com/r/fortran/comments/bcalq9/interview\_with\_rob\_vugteveen\_an\_oldschool\_fortran/](https://www.reddit.com/r/fortran/comments/bcalq9/interview_with_rob_vugteveen_an_oldschool_fortran/)
Whoops, I didn't see it.
I was facing the same problem. turns out, we should mention default(firstprivate) for the variables to be initiated to take the values that they have upto that point.
This isn't really a Fortran question. It's really just a basic programming question. I'd recommend forgetting that Fortran exists and start with pencil and paper and try to order ten numbers. To answer one of your questions, you'll want to read the file into an array and then do operations with the array so you're not reading the file many times. Also, it's a good time for to learn good variable names. A good rule is to never use letter-number names. That is, do not name variables x1, x2, j9, etc.
A subroutine to read in the file into an array: subroutine read_in_file(filename, file_out) character(len=*), intent(in):: filename ! len=* means you can use any length, intent(in) means that it will not be modified by integer:: file_unit, ios, number_of_lines, max_size character(len=100000):: temp character(len=:), allocatable, intent(out):: file_out(:) open(newunit=file_unit, file = filename, action="read", status= "old") number_of_lines = 0 max_size = 0 do read(file_unit, *, iostat=ios) temp if (ios .ne. 0) then exit end if if (len(trim(temp)) &gt; max_size) then max_size = len(trim(temp)) end if number_of_lines = number_of_lines + 1 end do write(*,*) number_of_lines, "NUM LINES" write(*,*) max_size, "MAX SIZE" rewind(file_unit) allocate(character(len=max_size)::file_out(number_of_lines)) read(file_unit, *) file_out close(file_unit) end subroutine As /u/geekboy730 said, once you have it in an array you want to manipulate that array to get out the information that you require. Note that you can read from a character string just like you can read from a character read(character_variable, '(format_string)') variable1, variable2 To use the subroutine you would have something like this: program readFile implicit none character(len=:), allocatable:: fileo(:) integer:: i, j call read_in_file("temp.text", fileo) contains &lt;subroutine goes here&gt; end program
What he said.
Nice idea. I really like it. A repl for playing with Fortran will make it more approachable. It is actually quite a modern programming language, people just think Fortran is F77. I would include the installation instructions from https://docs.lfortran.org/installation/ in the actual README.md. Also, don't assume people have things like anaconda installed. A step-by-step installation for macOS / Linux, assuming a fresh install of both, would be a good first step. I had to: * download anaconda installer from https://www.anaconda.com/distribution/ (this is a 637MB file and takes 2.3G for installation!) Note: anaconda makes an entry into your ~/.profile and changes your prompt! That's a code smell. I removed the entry that the anaconda made into ~/.profile and just added: ``` PATH=$PATH:~/anaconda3/bin ``` * install antlr (followed directions at https://www.antlr.org/) You want to make it as easy and straight forward as possible for people to dive right in.
Could anyone explain to me how this differs from FLang? I don't really understand how LLVM works or what it really *is*.
Just check out the `build.sh` file and the other build files it calls. https://gitlab.com/lfortran/lfortran
One of the developers went into this a bit [on twitter](https://twitter.com/Jiawei_Zhuang_/status/1123306751862947840?s=19), although it's a bit technical. As I understand it, the difference is the interactivity and the capability of programs to interact with the compiler. LLVM is a framework to build compilers. Most new languages seem to use it (Rust, Swift, Julia). A cool thing about it is that it makes it easier to compile code to run on web browsers ([Emscripten](https://emscripten.org)) or video cards ([CUDAnative.jl](https://github.com/JuliaGPU/CUDAnative.jl)).
One of the authors here. Yes, Twitter does not allow to go into more depth. I started LFortran when Flang got open sourced and I realized that code base is extremely hard to contribute to, I would have to spend half a year just to get up to speed how to contribute some feature, such as interactivity. Which means it will be very hard to build a community that can contribute to the development. So I decided to start from scratch. NVIDIA itself realized that, and at the same time started F18, which is a rewrite from scratch. Both F18 and LFortran are thus starting from scratch. The question then is how LFortran differs from F18. * F18: I would say in general terms, the goals of F18 is to have an easier code base that can deliver on the goals that Flang set to do, which is to have a production compiler based on LLVM that can offload to CPU and GPU. * LFortran: our main goal is to provide an interactive compiler, that interoperates well with other languages, and even extends the Fortran language where it makes sense; that can be used by libraries like SymPy that need Fortran code generation; Easy to install packages (like Julia); All the other things listed at https://lfortran.org/ or the blog post above.
One of the authors here. Yes, I must apologize for the complicated usage experience. We only open sourced this recently. Eventually this will be completely rewritten to C++, and so the download will be a simple binary that shouldn't be too big. I started in Python because Python had all the nice libraries just as `llvmlite`, and because it is easier to refactor and iterate on the design in Python than in C++. We are pretty close with the design, and so we will start gradually rewriting into C++. I like Python, and have been using it for over 15 years, but the distribution aspect of it is very unsatisfactory, as you noticed. I will create Conda packages, so that at least it can be installed easily withing Conda / Anaconda. But I am with you, having to download almost 1GB of packages is unacceptable to me also. I like how the Zig compiler does it: https://ziglang.org/download/, it's just a 30MB download, in it is a single static binary which contains everything, including Clang. So eventually I would like to achieve something similar. If you want to contribute some improvements to README or documentation, we welcome any merge requests.
You must know that all the versions are backward compatibles, except for a few very old or SO dependent deprecated Intrinsic Procedures, the GNU Gfortran compiler manual states that: "9.1 Introduction to intrinsic procedures The intrinsic procedures provided by GNU Fortran include all of the intrinsic procedures required by the Fortran 95 standard, a set of intrinsic procedures for backwards compatibility with G77, and a selection of intrinsic procedures from the Fortran 2003 and Fortran 2008 standards. Any conflict between a description here and a description in either the Fortran 95 standard, the Fortran 2003 standard or the Fortran 2008 standard is unintentional, and the standard(s) should be considered authoritative". In [https://gcc.gnu.org/wiki/Fortran2008Status](https://gcc.gnu.org/wiki/Fortran2008Status) you'll find the not yet implemented features of the ISO standard, for Gfortran (each compiler has it own development), nevertheless beeing all new procedures you won't need it to learn and use Fortran 2008 (The new standard is the 2018 and not implemented yet) and the future one will be the Fortran 202X) you can get the documents in: [https://wg5-fortran.org/](https://wg5-fortran.org/) for a compiler comparison you can look at: [https://www.fortran.uk/fortran-compiler-comparisons/](https://www.fortran.uk/fortran-compiler-comparisons/) I use Gfortran for my programs and always the last version (2008). Be aware that any old library can be recompiled in the last version, with almost no complains. To conclude: Use the last version, remember that you always can mix languages in the linking proccess, or use other program as child proccesses. And avoid the bells and whistles of the compilers that are not standard intrinsic procedures (ISO WG5) in order to make your program compilable in any platform and compiler, and thus, able to migrate hassle free between them. And enjoy with a good cup of coffe!!!
Fantastic! I did not know this!
Hi Ondrej. First of all, I wanted to thank you for your work with SymPy. I recently had to (step by step) diagonalize a 11x7 matrix for a linear algebra course in college and thanks to SymPy.jl I was able to finish that assignment in a fraction of the time it would have taken to do it by hand (and with no errors!) Last year I messed around with Fortran and LFortran sound like it'll eventually be the answer to a lot of the gripes I had with it. Regarding the easy installation of packages, what do you have in mind? Some kind of package manager?
I am glad you found SymPy useful! It's always nice to hear that. Regarding packages for Fortran: what I have in mind so far is to do something similar to what Julia does. There is one problem in Fortran: currently you can't nest modules. However, when I look at most Julia packages, typically it is just one module, and inside it you include other Julia files. Fortran has an `include` directive in the language, so you can actually do exactly the same already. I am not sure if I like it, as I am used to using modules for everything, not have "loose" subroutines in `.f90` files. But if it works for Julia, then I think it's worth trying. That would be a good start. My understanding is that Julia allows you to also nest modules. For that we would need to extend Fortran to allow module nesting. LFortran will have a mode that it could translate any such LFortran extensions into proper Fortran, so that people can still use any Fortran compiler they want. Similar to how TypeScript works. In general my approach is to stick to proper Fortran as much as possible, but we will have LFortran language extensions where it makes sense.
I did it first on my paper, in french (not il "programming" language lol) and it was a failure. I have a file, cut in half with 9 lines of text (and 9 lines at first too), and want to do 2 array with the first half numbers and the second half numbers, and ignoring those lines. It's from a scientific file, on LAMMPS. I tried to read it until it finds the number one, then read it again until it finds the number two, etc. And the names are not the ones I use, I remember the program but not the names so I invented something
If you can't do it on paper, you definitely won't be able to do it in a programming language. You still are reading the file several times and not using arrays. Stop that. Use arrays. You probably need someone who can look over your shoulder or an intro to programming book...
How is the file being opened in the open statement (access, form, etc)? Are you checking the iostat of the open? Are you compiling with debug flags? What is a .dat file, does it exist?
This is what my test script looks like (it's based off of the original code I'm trying to get to work): program test integer a,b,c,d,e,f,g,h,check check = 1 c Error occurs at this point open(unit=8,file='test_data.dat',status='old') read(8,*)a,b,c read(8,*)e,f,g read(8,*)h,i close(unit=8) write(*,*)a,b,c write(*,*)d,e,f write(*,*)g,h write(*,*)check end I have compiled with the debug flags on, but they haven't provided any additional information about what could be going on. As for the .dat file question, I was basically handed this code and was asked to use it without much elaboration on the subject (it has worked in the past with Fortran77, however). It does seem to be an atypical file extension (based on what I could find); is there a more standard file type for importing information like what I'm trying to do? I've also considered creating a script that simply returns all of the values of interest if nothing else worked, but I only want to do that as a last resort.
If you can open the file with a text editor and read the numbers, then it is a formatted file and you can see if the numbers you're trying to read match the type of variable you're declaring. If you can't read the numbers (print like garbage, etc) then it is an unformatted file and you have to state that on your open statement. You also have to be sure the type of variable declared in your program matches the data, and that the data file was generated with a program compiled with a compatible compiler ( there seems to be some degrees of freedom on how different compilers structure binary data files)
A couple of questions. Are you running on Windows or Linux? If Linux, then filenames are case sensitive? Assuming it’s an ASCII file, are the correct line terminations (CR/LF vs CR) in place for the particular OS you are running your program on? If you add IOSTAT= to your OPEN statement, what value do the return?
Figured out what was happening. There's apparently a bug with the GNU Fortran compiler I was using before (version 5.1.0) where it is able to create files that don't exist but cannot read existing files; reverting to the previous version of the compiler fixed the issue: [https://github.com/mxe/mxe/issues/689](https://github.com/mxe/mxe/issues/689). Thank you for the assistance you all offered in the meantime!
\+1 on the idea of distributing just big thick executable. The fact that you open-sourced it is nice... but believe me, I work in an engineering office where fortran is used to perform hydrological and hydraulic analyses, and none of they guys have the ability to diagnose what went wrong if the steps to do it didn't work, like me...
Yes, open sourcing was just the very first step. It's not ready for production use yet. Now we need some time to polish things up.
I am not sure that kind=-1 has ever been a part of the language. The gnu documentation (link below) for the kind statement does a good job of describing the acceptable values. http://gcc.gnu.org/onlinedocs/gfortran/KIND-Type-Parameters.html
On most of the compilers that I have used, negative kinds are used to indicate an unsupported type. For example, if selected_real_kind is used to request a type which is not supported, a negative result is returned which causes a compilation failure. I would look at your compiler's documentation for how it interprets the kind of types. I don't think that the meaning of particular kind values is part of the standard, but on most *nix compilers (including gfortran) it corresponds to the number of bytes used for the type. On the Salford compiler the kind corresponds to the number of 32-bit words used for the type (bytes/4).
Thank you for the reply. I had used kind=-1 to indicate the longest integer possible. But I guess it must be some kind of mistake that I made and just left it like that for some reason. I changed it to something like kind=64int and it runs perfectly. The code didn't have any problems other than that. It's very unusual to me where that mistake came from, and why the rest of the code is perfectly fine otherwise :)
Take a look at f2c. It’s old but apparently still available at netlib.org
We can help if you try, and get stuck, and ask specific questions. No one is going to do your work for you.
What is the book? Some context might help! Also, there are probably other packages that have more readable code :-)
That is some ugly-ass Fortran right there.
Does it compile?
&gt;No one is going to do your work for you. Not unpaid anyway :)
Implicit everything...
Yeah, this looks familiar. Ive converted old fortran to newer formats like fortran 2008. ... too bad i don't know C++
All ya'll: -- Seriously? -- this is not tough.
All we are missing is some computed GOTO’s
I was thinking this is pretty simple matrix rotation routine. Any experience with indexed arrays and loops should be able to figure this out.
I tried to convert it to a more-modern version of Fortran, but there are still some questions, like "what does sort do?" especially since it relies on implicit typing. '''fortran subroutine rotate(a,b,n) integer,intent(in)::n real(wp),dimension(n,n),intent(in)::a real(wp),dimension(n,n),intent(out)::b real(wp),parameter::tol = 1.0E-12_wp integer::i,j integer::n1,i1 real(wp)::q real(wp)::t do i=1,n do j=1,n b(i,j) = a(i,j) end do end do n1=n-1 do i=1,n1 i1=i+1 if( abs(a(i,i))&lt;tol ) then do j=i1,n b(i,j) = -a(j,j) b(j,i) = 0.0_wp end do else do j=i1,n q = -a(j,i)/a(i,i) t = sort(1+q+q) b(i,j) = a(i,j)/t-a(j,j)*q/t b(j,i) = 0.0_wp end do end if end do end subroutine '''
I have a suspicion that line is supposed to be ````t=sqrt(1+q*q)```` Which would be more in line with matrix rotations
That makes a lot of sense. I might convert the thing to C++ tonight while I proctor an exam.
Looking again, it does look like SQRT. I am sorry but the book is reallyy old and a lot of letters/numbers are faded.
The line b(j,i) = 0.0_wp Sets the value of b(j,i) to 0.0, where 0.0 is a real value with precision defined by the variable wp. Presumably wp is either 4 or 8.
It looks like a Givens rotation to me, but there are quite a few more transcription mistakes. I bet it is t = sqrt(1+q*q). There are also some index issues, and I think some sign issues.
Oooh. It is a Givens rotation. Thank you very much for this.
Hmm, &gt; Nothing at all is put on the heap unless it was created by ALLOCATE. SAVEd variables, unless they are ALLOCATABLE, are given static allocations (fixed by the linker). The only way to put a variable on the heap is for it to be a POINTER or ALLOCATABLE and then you allocate it. There is no way to cause this to happen automatically \[1\] [https://software.intel.com/en-us/forums/intel-visual-fortran-compiler-for-windows/topic/274628](https://software.intel.com/en-us/forums/intel-visual-fortran-compiler-for-windows/topic/274628) &amp;#x200B; This said, there is actually a flag which puts automatic arrays on the heap. &gt; Puts automatic arrays and arrays created for temporary computations on the heap instead of the stack. [https://software.intel.com/en-us/fortran-compiler-developer-guide-and-reference-heap-arrays](https://software.intel.com/en-us/fortran-compiler-developer-guide-and-reference-heap-arrays) &amp;#x200B; For gfortran you maybe could play a bit with: `-fmax-stack-var-size=n` &amp;#x200B; Another thougth: `-fno-automatic` There you put everything in the program memory as far as I understood...
Thanks, I'll check that out.
If Givens rotation is what you want, you could look at the [BLAS level 1 routines](http://www.netlib.org/blas/#_level_1). There are several routines that will setup and apply a rotation. If you click on one of those routines, it will (should) take you to the LAPACK page, which has a DOxygen generated explorer to allow you to look at the subroutine interface, call graph, etc. There is also a LAPACK++ and C-LAPACK, but I don't know if that particular routine is in there or not. GNU Scientific Library also contains BLAS and LAPACK routines ([Givens Rotation](https://www.gnu.org/software/gsl/doc/html/linalg.html?highlight=givens#givens-rotations)), presumably written in C.
Are not using version control? In that case you should be able to see the temporary change as such?
Does this mean, a fortran to C converter could be more easy than it was in the past? At least to build automatic interfaces? &amp;#x200B; f2c is limited to f95 as far as i know doing it with rose is really hard in my opinion.. but flang, i didn't try so far...
Just wondering why do you *need* a variable to become nan?? Are you doing so to try and catch or signal a specific error? If so I think there are probably better/more advisable ways of error handling.
No. It is being used to construct vtu files for paraview, that uses NaN to make the thing being displayed disappear.
ahh okay. Instead of explicitly having \`a = 0.0 / 0.0\`, set \`a=0\` then do \`a = a / a\` on another line. I think gfortran won't complain about that (disregarding fpte flags etc) &amp;#x200B; 1 program nan 2 3 implicit none 4 5 real :: a = 0.0 6 real :: b = 0.0 7 8 a = a / a 9 b = 0.0 / 0.0 10 print *, a, b 11 12 ! on my setup, without any specific flags, gfortran will complain about b but not a 13 14 end program nan
Nice! That works, thanks !
extremely large numbers tend to become NaN with gfortran in my experience. Try to find the limit... And perform that operation .. like exp (a bazillion)
There's a bit of a nicer, standard, way of doing this with the IEEE_ARITHMETIC module: use, intrinsic :: ieee_arithmetic, only: IEEE_Value, IEEE_QUIET_NAN use, intrinsic :: iso_fortran_env, only: real32 real(real32) :: nan nan = IEEE_VALUE(nan, IEEE_QUIET_NAN)
Please OP, use the standard ways!
How do you plot with pure FORTRAN?
There is no reason it shouldn't - as long as you tell f2py to link with the same libraries as if you were compiling with any other compiler.
Write PostScript directly? Or maybe write gnuplot scripts and execute those?
Or write tex files for use with pgfplot.
I doubt it is pure Fortran. It likely links to some library. You could look at xfoil for an example, where they have a C-interface to the XWin API and use a Fortran abstraction layer on top of that.
I have a package of reusable Fortran modules that I have developed over the years. Included is a matplotlib-like interface to the plplot library. I've used it for my own work, as well as for students in a Computational Fluid Dynamics course that I taught. [https://github.com/hornekyle/CommonModules](https://github.com/hornekyle/CommonModules)
ASCII, just as God intended
I'm learning Fortran
Awesome!
Fantastic!
Instead of using a numbered format statement, I would save the format code as a character parameter in the module data section and then reuse that parameter in each write statement.
That's a good idea, I feel like I should have thought of that. Thanks.
I generally use a module with the common formats as parameters and then load only those that I need. Inside the program, on the variable declaration: use formats, only: f1000 In the formats.f module: module formats implicit none c common messages character(LEN=99) :: f1000,f1005,f1015,f1020,f1021,f1025,f1055, + f1060,f1076,f2000 parameter(f1000="(i2,1x,10f7.2)") And then, when using the format: write(6,f1000) ncount,ivarv(1:10)
This can be taken one step further when needed to create dynamic format statements based on current variable values.
Yea I've done this before for dynamic formats, which is why I feel like I should have thought of it.
2**49 is an integer expression. Try 2.**49
General rule of thumb in Fortran is to express numbers in the same precision as the variable you are assigning. IE Integer a = 1 Single Precision a = 1E0 Double Precision a = 1d0 Alternatively if you use an interger parameter for the kind definition you can also write it like this integer, parameter :: dp = kind(0.0d0) real(dp) :: a a = 1E0_dp In general you shouldn't leave it up to the compiler to guess especially with integers because you may not get the results you expect. Especially with things like division.
As pointed out, 2\^49 is an integer expression. The "2" in your example is assumed to be an integer of kind=4 (32bit, unless you change the default with compiler option), so the calculation 2\^49 is performed with that precision. After the calculation is performed, it is cast to the parameter type (if need be), whether "a" be real or integer. If you change the precision of either the base or the exponent (e.g. 2d0\^49 or 2\^49d0) you will get the correct answer, because the calculation is performed with 64bit precision. In your example, if you put "2.", the calculation will be conducted using real floating point (32bit) precision, which will not overflow, but could truncate digits at the trailing end. On my machine it does not, but I think this is somewhat unreliable. As /u/LoyalSol said, you should express the numbers properly, including the constants like "2". So, for example: program test implicit none integer(kind=8) :: i real(kind=8) :: r i = 2d0\*\*49 r = 2.d0\*\*49 end program test
Thanks, to all of you, for clearing this up. It's good to not only know what the problem is, but also the correct way to deal with it. So, again, thank you.
Powers of two are always exact in binary floating point.
That is a bold statement! In Lisp this is true if you are using integers, limited only by the memory of the machine. However with Fortran, this is not so; you are bound by the limits of the floating point model, which can only hold so many significant digits. For example, if you do a loop like: do n = 1, 132 write(*,'(I4,F60.0)') k, a
You don’t understand binary floating point and I encourage you to go look it up. Powers of two are exact. I write Fortran compilers for a living.
should be just after your compiler &amp;#x200B; eg. if i was using nagfor i would do: &amp;#x200B; nagfor -fno-range-check programname program.f90
Why do you want to ignore the problem rather than fix it? If the integer IS too big for its kind, what do you think happens in memory?
So I'm compiling directly from simply fortran, not from a command line.
Try this [https://simplyfortran.com/docs/full/windows/options/compiler.html](https://simplyfortran.com/docs/full/windows/options/compiler.html) &amp;#x200B; under "debugger settings"
If i change the integer size with selected_int_kind i can get the program to compile, but it doesn't run properly. I'm updating a program that was written about 12 years ago and i have no idea what program was used to compile it back then, and I'm a novice at coding, so I'm trying what the compiler suggests i try.
I put -fno-range-check in the arguments field, but still get the same error message :/
 What piece of code do you think is doing it? Do you want to paste some of your code or something?
I can't access Reddit from my work computer unfortunately, so I'm typing this all out on my phone. The error comes up in a do loop at the end of the program. If(end=="-----")then Write(*,*)" " Write(*,*)"your gis readable tsar is complete. " Do delay=1,1000000000 Delay2=Delay2+10000000000 End do Exit End if Im not sure what this chunk of code is for, and if go the selected int kind route, i can get the program to compile, but it doesn't work like the program that was compiled 12 years ago using the same source code.
 apparently i also don't know how to format Reddit comments. There are line breaks in the proper places in that code chunk
10000000000 is way bigger than the 4 bit limit, can you reduce that? Just run a DO WHILE loop instead?
I think that you want to set a compiler flag, not an argument.
First, different compilers will exhibit different behavior(esp with older versions of FORTRAN, F77, F90 etc) when dealing with invalid code, some will give a less eratic result or figure out what you really meant, but others just fail really badly(and the options will even change this within 1 compiler). Second my guess is this code is trying to create a delay so that the write completes and actually buffers out before doing something else. The Delay2 statement is there in the loop to keep the compiler from optimizing away the loop(IE deleting the code since it does nothing) When you changed the int kind did you do it for all ints or just the Delay2 variable? Delay2 isnt used anywhere else right? If you just did the Delay2(and its not used anywhere else), I suspect you have some other issue that is making the whole program not work correctly. There could be another bug OR the code could be written to assume some specific memory alignment(IE how variables are stored in memory), which when you switch compiler/OS/platform can quickly fall apart-this is big trouble. (These both assume Im right about the delay being about write buffer) Look at http://simplyfortran.com/docs/compiler/FLUSH.html#FLUSH I would replace this code with FLUSH(I think that will work on the intrinsic I/O) Also look at https://simplyfortran.com/docs/compiler/Data-consistency-and-durability.html OR One other solution if this is a delay(but potentially less portable) would be use a system function for the delay-Im not simplyfortran literate so cant recommend what.
It’s always bothered me that Fortran works this way. If you’re assigning to a variable of a type, the compiler should assume that the values you’re assigning to it are that type unless otherwise specified. Since there’s no type coercion, this should never cause any ambiguity, and would result in cleaner expressions.
That’s insane.
How so? Why does `2.**49` even work? Raising a real to an integer power? By your logic that every number needs to be exactly expressed in its type, you should need to write `2.* *49.` at least. Or, taken to the extreme, Integer,parameter :: fp = 16 Real(fp) :: x X = 2._fp * * 49._fp Or the compiler could just assume that since X is of type real(fp), the values I’m assigning to it are of type real(fp).
Fortran is defined to not convert integer powers.
That’s insane.
You could go look it up in the standard.
You are confusing the concepts of precision and range. The lone surviving floating-point model (IEEE-754) represents approximate real values as a sign, a binary fractional value 1.0 &lt;= f &lt; 2.0 accurate to 24, 53, 64, or 112 bits(*), and an integral power of two in some range. So exact powers of two can be and are represented precisely as 1.0*(2**n). (*) Or 8, or 106, in some oddball cases. And subnormal numbers are in the range 0&lt;=f&lt;1.0. And some special bit patterns encode zeroes, infinities, and invalid numbers. There’s a lot of details, but the paragraph above is what you really need to know. Older models used base 16 rather than 2, or different numbers of bits for the fraction and exponent, or used a range of 0&lt;=f&lt;2.0, or some other variations on the ideas we finally settled on back in the late 70’s.
The whole point of this discussion* was that the standard should be different. I presented a reason I think Fortran should work differently. Saying it’s in the standard isn’t an argument against the point. * To the extent that replying “That’s insane” to a well-explained proposal makes for a “discussion”
Sure, submit a proposal to J3 to change a rule that has stood for 52 years in Fortran. Never mind the literally billions of lines of code you’ll invalidate. That’s an entirely sane suggestion.
Thanks for the clarification.
To answer your actual question, the reason "why the data type would be acceptable in one programming language, but not another" is because you are not comparing apples to apples. Octave uses double precision by default, so "2\*\*49" is a double precision calculation assigned to a double precision parameter. Fortran sees "2" as an integer, so the operation "2\*\*49" is an integer calculation performed with the default integer model, which is usually single precision, which is then cast to the data type of the parameter. /u/pdxpmk answer using "2.\*\*49" tells Fortran to perform the calculation in the default floating point model, which is usually single precision floating point, and which he points out will be exact for 2.\*\*49. In general, if you want to replicate Octave's behavior (although it will *not* be different for 2.\*\*49), you would need to specify 2.d0\*\*49 as /u/LoyalSol/ mentions, which will cause Fortran to perform the calculation using the double precision.
What error do you get? If any? dflib is Visual FORTRAN module, and only works on Windows machines AFAIK
No error . The text is not being displayed
Oi tried in my friends pc . It is working there but in my pc the screen becomes blank
I am using developer studio in windows xp
Do you have a question?
I know I can't completely satisfy your question, but I personally use a combination of Visual studio Code with Fortran intellisense add-on for the analysis part, and FORD from GitHub for annotations and graphs ala doxygen. It's the best I have found yet. Probably eclipse IDE Fortran might be worth checking out?
How long is the original code?
Fortran is backwards compatible. Change your C comments to !, and your line continuation hyphens to ampersands, and see if it conpiles. Dig out the instruction book for your compiler and switch on all the debugging so it tells you if there's anything else it doesn't like.
Or change nothing, and just compile it.
OP, it can be jarring at first but you could compile, fix errors, compile, fix errors and so on. If it's for a class, it should be fairly trivial. Don't forget to change .f to .f90, and use gfortran-9 if you can (free and has nice error output).
Depends on what you mean by change to Fortran 90.
No. Don’t change anything. Any ‘77 program should still compile and run fine.
Agreed.. jumped to conclusions there..
I think OP means take F77 formatted code and "convert" to the F90 their instructor wants to see it coded in. Compiling and running the original F77 is irrelevant.
Obviously, you have not done a single search on the web for such trivial task. There are now even online converters on the web. https://www.fortran.uk/plusfortonline.php
I tried to convert some but it does not work for me :/
In the past, I have successfully converted a complete project of more than 200,000 lines of FORTRAN77 code to Fortran90 free-formatted code, using this tool here: [https://sourceforge.net/projects/fparser/](https://sourceforge.net/projects/fparser/)
I would use linux or set up virtual machine. &amp;#x200B; You will need a compiler. One free option is gfortran from gnu. Also try pgi [https://www.pgroup.com/products/community.htm](https://www.pgroup.com/products/community.htm) . &amp;#x200B; As for manuals I am not sure one is better than another. [http://www.egr.unlv.edu/\~ed/fortranv3.pdf](http://www.egr.unlv.edu/~ed/fortranv3.pdf)
Thank you so much! gfortran &amp; ubuntu is what I've been using on my placement so makes sense to continue with those.
I can send you a bunch of code examples if you want, from my years in uni.
That would be amazing thank you so much!
These are probably the most useful. https://www.dropbox.com/s/qbbiq62fq3bq99w/Fortran%20programs.rar?dl=0 The nbody simulator is probably the most complicated thing on there. A big tip would be to consult stack exchange regularly, they usually have answers for whatever programming problem you have.
MinGW-w64 will give you a working version of gfortran on Windows. Recommend the FortranWiki and the Fortran wikibook as a reference resources.
Thank you so much! I'll download it all when I'm my computer next week when I'm Back off placement!
Thank you! That sounds a bit more convenient than having two operating systems!
cool. That is the easiest situation. using multiple compilers is a good idea because they behave differently. What is your development environment?
I found a piece of code on the intel forum that at least works. Going to have to stress test it for bugs though. module CF_Strings USE ISO_C_BINDING, only: C_PTR, C_CHAR, C_ASSOCIATED, C_F_Pointer, C_Int character(C_CHAR), DIMENSION(1), SAVE, TARGET :: dummy_string="?" PUBLIC :: C_F_STRING !===========================================================================a contains !===========================================================================a FUNCTION C_F_STRING(c_str) RESULT(f_str) USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR, C_F_POINTER, C_CHAR TYPE(C_PTR), intent(IN) :: c_str character(:,kind=C_CHAR), POINTER :: f_str character(kind=C_CHAR), POINTER :: arr(:) INTERFACE ! Steal std C library function rather than writing our own. FUNCTION strlen(s) BIND(C, NAME='strlen') USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_PTR, C_SIZE_T IMPLICIT NONE !---- TYPE(C_PTR), intent(IN), VALUE :: s integer(C_SIZE_T) :: strlen end FUNCTION strlen end INTERFACE !**** CALL C_F_POINTER(c_str, arr, [strlen(c_str)]) CALL get_scalar_pointer(SIZE(arr), arr, f_str) end FUNCTION C_F_STRING !===========================================================================a subroutine get_scalar_pointer(scalar_len, scalar, ptr) USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR integer, intent(IN) :: scalar_len character(kind=C_CHAR,LEN=scalar_len), intent(IN), TARGET :: scalar(1) character(:,kind=C_CHAR), intent(OUT), POINTER :: ptr !*** ptr =&gt; scalar(1) end subroutine get_scalar_pointer !=========================================================================== end module
I had the same problem. I ended up doing the following to copy over the char\* into a Fortran character. module myModule use iso_c_binding, only : c_ptr, c_null_char contains subroutine myfunction(cstring, clen) bind(C) integer(c_int), intent(in), value :: clen character(c_char), intent(in) :: cstring(clen) character(len=clen) :: fstring fstring = '' do j = 1, clen if (cstring(j) == c_null_char) exit fstring(j:j) = cstring(j) end do end subroutine myfunction end myModule
Its been a while since I used fortran but I still have my old files. I code on Windows using Codeblocks to compile and run my code. Let me know if you want me to livestream you through using it. I can walk you through basic programming commands and file I/O. Not a wizard but its my first language so I think in Fortran lol
Thank you so much! I'm not at my laptop for another two weeks as I'm In another country for placement but I really appreciate it!
[Modern FORTRAN ](https://www.amazon.com/dp/052173052X/ref=cm_sw_r_cp_api_i_H6bfDbS5NV2JS) style and usage by Clerman and Spector is a good book for coding style and traps of the language. Modern Fortan explained by Metcalf is a good reference. I do not recommend it since it is not easy to learn from it. [FORTRAN wiki](http://fortranwiki.org) is a good online resource for almost everything. As others mentioned, using multiple compilers is a development good practice and catch bugs in the early phase. GNU and pgi community edition are quite good. For performance, one will prefer to use pgi rather than gnu. Intel and Cray are the best in class compiler performance wise. I’ll suggest to stay away from the intel compiler while you develop because it is very permissive. One last thing to keep in mind, if you are coming from C or C++, question everything you do. FORTRAN is not C
FORTRAN has become Fortran for the past three decades
 Here is where I started learning Fortran 90: [https://www.uv.es/dogarcar/man/IntrFortran90.pdf](https://www.uv.es/dogarcar/man/IntrFortran90.pdf) This notebook contains almost 70%-80% of what you need to start productive programming in Fortran. For more advanced features such as Object-Oriented and Parallel programming with Fortran, the following is an excellent guide: [https://books.google.com/books/about/Modern\_Fortran\_Explained.html?id=V7UVDAAAQBAJ&amp;printsec=frontcover&amp;source=kp\_read\_button#v=onepage&amp;q&amp;f=false](https://books.google.com/books/about/Modern_Fortran_Explained.html?id=V7UVDAAAQBAJ&amp;printsec=frontcover&amp;source=kp_read_button#v=onepage&amp;q&amp;f=false) If you are in grad school, you could likely get access to a free pdf copy of the book, just as I did myself in grad school. Btw, there is also a new 2018 edition of this book covering Modern Fortran 2018 standard: [https://books.google.com/books/about/Modern\_Fortran\_Explained.html?id=sB1rDwAAQBAJ](https://books.google.com/books/about/Modern_Fortran_Explained.html?id=sB1rDwAAQBAJ) There is also an amazing online Fortran-Jupyter binder by which you could test your serial as well as Coarray "parallel" Fortran codes on shared/distributed memory architectures in real time: [https://github.com/sourceryinstitute/jupyter-CAF-kernel](https://github.com/sourceryinstitute/jupyter-CAF-kernel) You can test it here: [https://mybinder.org/v2/gh/sourceryinstitute/jupyter-CAF-kernel/master](https://mybinder.org/v2/gh/sourceryinstitute/jupyter-CAF-kernel/master) There are also lots of other online Fortran compilers for education and testing on the fly. Just search the terms on the web. The book "Modern Fortran Explained: Incorporating Fortran 2018" by Metcalf et al (or the older Fortran 2008 version of it published in 2011) is an excellent resource (although it is too comprehensive for an absolute beginner). Whatever book you pick up, make sure you learn the new features of Fortran, most importantly, 2008, and 2003 Fortran standards. These new standards as well as the newest Fortran 2018, contain extremely powerful and useful concepts (Coarray Fortran parallelization syntax, advanced (sub)modular programming, OOP) that are essential for modern scientific computing.
Sorry auto correct
There’s a book called Fortran 2003 and 2008 for scientists and engineers by Stephan Chapman. Would definitely recommend.
Use [DosBox](https://www.dosbox.com/). Unless you have the original source code to recompile for the new arch, this is the next best thing.
Look for another old computer on ebay. Your local university might have a store that sells property the university no longer wants. They have great deals.
Try posting some of the errors here, along with the relevant lines of code, and lets see if we can help.
The source code of these programs should still compile, but you need to recompile them if you want to use them natively on a modern computer.
Recompile them. Don't use the old executives.. recompile and generate new exes
Yes, use g77 or gfortran to recompile them. Start with small parts of the code and see what compiles and what doesn't. You might need to refactor the code to make it ANSI compliant first.
Anyone here, please do not download unknown executable files. OP, please only post the source code.
I don't think that any of these files are Fortran code: they should end in \`.f\` or \`.F\`. Do you still have the source code?
Last time I checked, these files were the final executables, compiled for the specific unknown architect of the time it belongs to. It does not contain the source files. To run them on new hardware you need to compile and link from the source files again.
or .f90 or .f03 or .f08, but most importantly .f90
~.EXE is already an executable file, it has already been compiled. To recompile you need the source code. For Fortran that'd be a ~.f (or probably a ~.f90) file. To compile it on Linux I'd use [gfortran](https://gcc.gnu.org/wiki/GFortran). The output will be a runnable executable but it won't have the file ending ~.exe (that's for windows executables).
The source is there also. I tried compiling it with just gfortran std=legacy but it is pretty hopeless as far as I can see. OP you may just want to rewrite in a language you are familiar with, it seems to me that you would have to change so much to compile it that you may as well just start from scratch. The algorithms etc are all readable so if it had to be done wouldn't take forever I guess
Poster already has the .FOR files, but suspect problem is that the code is using a lot of Microsoft Fortran extensions meaning it won't be an easy recompile with gfortran.
My bad!
I had this problem last year and I solved it using a converter but now I need a code to read the file so I can export a txt file to MATLAB... The ulmate goal is to rewrite this file into a text file that I can import into Matlab. Thank you
GNU Fortran does not understand FORTRAN IV. Try MS Fortran 5.1 or an even older Fortran compiler for CP/M.
This question is not really clear... Looks like you got an answer already, what is your issue now?
I used a converter.bat file to read it manually... So ignore me fixing it.... I want to solve the original problem again this time use a Fortran code to read it and write it to dat file so I can import it into Matlab during optimization
If I understand the problem correctly, you need to read the file using one of the suggestions from the forum. Then, open a file for writing and use write(&lt;file id&gt;, *) to a plain-text file. You can specify the format with format specifiers for just use open(unit=12, 'filename.txt', status='old') !old replaces it if it already exists write(12,*) variable1, variable2 !keep going for other variables Writing without format specifiers will put a tab between the variables, and Matlab can parse it as space delimited.
I'll try it in the morning and see if it works... Thank you
Can you post the READ statement and the error? Also, are you trying to read out-of-bounds for an INTEGER vector?
read(21,"(T44,A1,T46,A1,T48,A8,T57,A4,T72,A1,T74,A1,T76,A1,T78,A1,T80,A1,T82,A1,T84,A1,T86,I2,T90,A1,&amp; &amp;T98,I2,T101,I2,T104,A2,T106,A1,T108,A2,T110,A1,T112,A2,T114,A1,T116,A2,T118,A1,T120,A1,T121,A1,T123,A1,&amp; &amp;T125,A1,T126,A1)",ADVANCE="NO")&amp; &amp;SOH,DAY,DATE,TIME,PCF,W,L,S,RC,RWC,TOC,NVEH,PT,K,I,OSP,LOC,OS2,LOC2,OS3,LOC3,OS4,LOC4,OAF1,OAF2,MOV,SDP,SDP2 NVEH, K, and I are all integers, everything else is read in as a character. What do you mean by reading out-of-bounds?
Concerning out-of-bounds, if you've defined an integer vector with a size of 10 \[e.g. INTEGER ivec(10)\], then you'll generate an error if you try to read an integer into ivec(11). You can check for this with your compiler by using turning on bounds checking. &amp;#x200B; I've never used tabs on a READ statement and haven't used them on a WRITE statement since about 1984. Do you need the tabs? Are the values delimited in any way? If you've pointed (via tabs) the READ statement to a certain point on the line to read an integer and it doesn't exist at that point of the line, that issue could also be causing your error. &amp;#x200B; What does the runtime error say exactly?
Its only reading a 2 digit integer, so I don't think bounds are an issue. The error message is as follows: At line 100 of file .\TSARtoGIS_V4.f90 (unit=21, file='in.txt') Fortran runtime error: Bad value during integer read. Error termination There are just spaces between the values, and I'm not reading all the values from the input document, so I think the tabs are necessary.
Do you know what row of the file you are reading (i.e. have you had a successful read of a complete row and just this particular row is failing)? &amp;#x200B; Is the integer truly only two-digits (i.e. no leading "+" or "-")? &amp;#x200B; Also, you could eliminate the tabs by using a temp variable in multiple locations in the READ statement to capture all of the data you aren't interested in using.
So, I have an old version of an executable that we use at my work to translate coded data. I'm trying to update the old fortran code to translate more of the data from the coded input. I've put the old code (V3) the new updated code (V4), and a sample input file (in.txt) on this dropbox folder. I'm having a runtime error: "bad value during integer read" at line 100 even though the tabbed to columns are correct and the read size are correct for the integers. I'm at a loss for what the issue could be, but am desperate to find a solution. https://www.dropbox.com/sh/4cq7cml308pj83c/AACGMJdh8QdN0-iLkPMgTGrTa?dl=0
https://www.dropbox.com/sh/4cq7cml308pj83c/AACGMJdh8QdN0-iLkPMgTGrTa?dl=0 This dropbox file has a version of the old code i'm updating (V3), my updated code (V4) and the input file (in.txt). The purpose of the executable is to translate coded values into something legible so we can make automated labels in a GIS program. The integers are truly 2 digits long with no leading "+" or "-". Any insight you can give is very much appreciated
Alright, it appears the previous non-advancing I/O was messing you up with where you thought you were reading data on the row. I only messed with V3 of your source, but here is how I changed it read(21,"(A)") in\_str PRINT \*,'in\_str: ', in\_str read(in\_str(21:),"(A1)") SOH read(in\_str(23:),"(A1)") DAY read(in\_str(25:),"(A8)") DATE read(in\_str(34:),"(A4)") TIME read(in\_str(49:),"(A1)") PCF read(in\_str(51:),"(A1)") W read(in\_str(53:),"(A1)") L read(in\_str(55:),"(A1)") S read(in\_str(57:),"(A1)") RC read(in\_str(61:),"(A1)") TOC read(in\_str(63:),"(I2)") NVEH read(in\_str(75:),"(I2)") K read(in\_str(78:),"(I2)") I PRINT \*,"soh: ", SOH PRINT \*,"day: ", DAY PRINT \*,"date: ", DATE PRINT \*,"time: ", TIME PRINT \*,"pcf: ", PCF PRINT \*,"w: ", W PRINT \*,"l: ", L PRINT \*,"s: ", S PRINT \*,"rc: ", RC PRINT \*, "toc: ", TOC PRINT \*, "nveh: ", NVEH PRINT \*,"k: ", K PRINT \*,"i: ", I The in\_str character variable has the length set to 127 to ensure it will read the line. I put a STOP statement after the last PRINT \* statement, so I didn't check the rest of the code. Also, the PRINT \* statements are only to ensure I was getting the appropriate data from the file assigned to the variables.
I tried but I get summation of the variables... But I need the file to print everything
Thank you, this is a huge help!
I've looked at your code, compiled it, and even got it to run once by commenting out broken lines. I think that you will have a hard time getting help here, since your question is really one of "please fix my code, without a good idea of what it is supposed to do". Also, you really need to use "implicit none" to prevent implicit variable declarations.
You're right I don't know how it works out in Fortran but I have done it in Mathematica... Works perfectly but I can't use it in Mathematica because I'm running an algorithm on MATLAB... My only option is Fortran to read the output from a different software without using a converter.... Were you able some part of the file?
Start a new project in VS... you will get an option to choose a fortran project. You'll be able to follow VS's instructions from there...
Thanks, maybe I'll try running DosBox in docker. Seems like such a hack though.
Create a blank file in visual studio and find out what intels fortran compiler uses as a command. Put some code in your text file, save it, then compile it using visual studios command prompt.
Make an attempt, and we'll help you.
Don't write the numbers every time. Keep adding numbers in that array, checking to duplicates every time you insert a item... then write the array to the file. Or implement a binary tree (insertion in log n, I guess) and when done write the items.
thank you all for answering I will give it a try
Be very careful with openmp in Fortran. I've seen lot's of issues with different compilers. Make sure any subroutines you call inside openmp blocks is declared as `recursive` and don't use module or `save` variables inside the openmp block. Depending on your compiler, make sure it is doing vectorization (i.e. using machine instructions to operate on the whole array at the same time, instead of looping). Many array operations (even expressions) can be vectorised, and it's faster than using openmp. At last, if you don't have a background in Computer Science, find someone who does if you really need this optimized for production use.
Why are you reading inputs (from user?) in the middle of computation? Can you separate the actual work, which can be parallelized, from input and other stuff?
 &gt;Make sure any subroutines you call inside openmp blocks is declared as `recursive` and don't use module or `save` variables inside the openmp block. You mean don't write into those variables or don't use their content either?
For better advice consider putting the code up on github. Also what is your target platform for this? Workstation? University cluster? Supercomputer center?
In theory, if inside the openmp blocks you only read them you're safe, but I still recommend you to avoid it, particularly if they are not scalars (arrays, derived types, etc). By the way, avoid `save` and module variables (unless they are declared `parameter`, i.e. constants) in any kind of parallel code. They are effectively global variables, and those are the bane of parallel code. Never, ever, write to them inside openmp blocks, unless you *really* understand openmp and know what you are doing.
What do you mean why? These are just functions returning a value within a certain routine. Nothing weird about it.
Yeah that’s probably a good idea. University cluster.
OpenMP is generally good for single node processes, but it's not particularly good at mass parallelization across multiple nodes. MPI is usually better for that purposes.
You could try the [http://fortranwiki.org/fortran/show/Libraries](Fortran wiki), which is probably your best bet.
Is there any open-source Fortran library similar to the Intel MKL?
The main disadvantage of using Fortran is the lack of standard libraries. There is nothing like the MKL. You do have BLAS and LAPACK for linear algebra, but that is it, and even there, it is written in really old F77, and it's interface is shite. The C/C++ interface called LAPACKE is much more usable. But otherwise, looking purely at the language, it truly is beautiful, and purpose-built for numerical computations.
Intel MKL is available for free for both Fortran and C. Why would you need an alternate (in any language) which is most likely far slower than MKL?
Also, keep in mind that any package that is accessible through C, is also (virtually always) accessible in Fortran via its intrinsic module iso_c_binding. See here for example: http://fortranwiki.org/fortran/show/iso_c_binding There are also many modern library implementations in Fortran on Github. But you will have to search for them and discover them by yourself, unfortinately.
As they said, Intel compilers &amp; MKL are available for free for Linux , but if you're still looking for an opensource replacement try gfortran + OpenBlas, it is a highly optimized blas/lapack library that works wonders when you're unable to use MKL due to licensing issues
The Netlib versions of blas&amp; lapack are THE standard in terms of numerical accuracy, and are used for reference purposes and last resort only. If you need an optimized blas/lapack implementation other than MKL try OpenBlas, it may not be as fast as MKL but I would say is about 95 to 98 % of MKL speed when properly compiled &amp; optimized. If what you're doing also uses FFT, there is fftw3, just make sure you turn on all the avx2 optimization stuff and it will fly
You can borrow a lot of C library functions thanks to the ISO C Binding
Well a it's not defined u should add a line specifying the array "a" ``` real :: a(:) ``` And a subroutine can't return anything (think as a void function)... so the correct code should be something like ``` module statistics implicit none contains function calculate_mean(a) result(mean) real :: a(:) real :: sum=0 real :: mean=0 integer :: i do i=1,size(a) sum = sum + a(i) end do mean = sum / size(a) end function end module ```
1. You told the module 'implicit none' and then you use an implicit variable 'a'. Don't use implicit variables and give 'a' a type and make it an array. real, intent(in) :: a(:) 2. Also, when you initialize 'sum and 'mean' to 0 it probably doesn't do what you want it to do. By assigning them to 0 at declaration they are given the 'save' attribute which saves their result between calls. It starts out as 0, but if you call the routine again it will start out as the result from the previous call. Instead split it up: real :: sum, mean sum = 0.0 mean = 0.0 3. You are trying to return a value from a subroutine. Subroutines don't have return values. Either make it a function or give the subroutine another argument for the output. function calculate_mean(a) result(mean) real, intent(in) :: a(:) real :: mean end function calculate_mean subroutine calculate_mean(a, mean) real, intent(in) :: a real, intent(out) :: mean end subroutine calculate_mean 4. The return statement doesn't work the same in Fortran as it does in C. You don't explicitly return values like 'return &lt;value&gt;'; the output values are returned automatically at the end of the function. Though, you can use returns if you need to exit the function early .
You declared implicit none. You'd have to declare variable type of a.
Also don't use variable name which is the same as an intrinsic procedure. Never use that. Surprised your compiler didn't throw up an error on that.
Fortran had domain specific libraries before most of the other languages. Before C had a standard library, before almost everyone(maybe not COBOL) - Check out the Lahey page at [https://www.lahey.com/other.htm](https://www.lahey.com/other.htm)
It used to be that you could compile it statically using whatever compiler (gcc is good) on a Linux machine with the same architecture, and the binary would work. I'm not sure if that works post Android 9 (?) tough, due to increased restrictions on syscalls.
You can use [Termux](https://play.google.com/store/apps/details?id=com.termux&amp;hl=en_US) on android, it's a linux style CLI. Then you can add the [its pointless](https://wiki.termux.com/wiki/Package_Management) repository so you can install gfortran
I strongly believe that computational libraries should be open-source. I do not like to use a “blackbox” with faith.
Sure. Yet I wanted to have an estimation of the Fortran ecosystem, and also avoid the two-language issue as far as possible.
If it's im the C standard you don't need two languages. Only need to write the interface and the compiler will link it.
I sure hope this is temporary. There's no other place like it.
Seems to be back up.
Yes, indeed. Yet having the library itself in Fortran is another thing.
This site is odd, www.fortranwiki.org seems to give an error, but just fortranwiki.org seems to be working now. The twitter account seems active, shows an edit yesterday.
I never use Netbeans, but I can give you instructions on how to compile your program with gfortran (since you mentioned gfortran, I will assume that you are running Linux and have access to a Linux terminal). If you have a main program, main.f90, and possibly some module files, first compile each file like this: gfortran -c file.f90 Then you link them all together to create the executable (note that executables in Linux don’t require an extension, but you can put one if you like): gfortran -o main.exe main.o file1.o file2.o etc As an example, say I have two module files, mod1.f90 and mod2.f90, as well as a main.f90 file. Then I would run the following commands: gfortran -c main.f90 gfortran -c mod1.f90 gfortran -c mod2.f90 gfortran -o main main.o mod1.o mod2.o This will generate the executable main, which can be run using ./main
It sounds like you have an existing project which you're modifying. The developer of that project might well have used a build system (Make, for example) which automates the compilation process. Of course, depending on the build system, the instructions would be different. Is there anything you can show us - a file listing might help? Otherwise, ghiggie's instructions are good.
Thanks so much for your excellent reply! Unfortunately, I'm running all of this through windows. I did install the Cygwin terminal and link it to Netbeans (which is primarily a Java IDE, AFAIK). I'm still not 100% clear on whether Cygwin allows for actually running Linux commands from within windows or not, but that's for another day. Nonetheless, I do have access to a machine with Linux, so I'll give these steps a shot on that machine. Thanks again!
Yes! There is a make file in the directory, forgot to mention that. The rest are just a series of .f90 files for different sets of computations in the model and then a \_\_\_com.f90 file that has all of the constants for the physics. I can post a full list of files when I get back to my work machine today if that would be more explanatory. &amp;#x200B; Thanks for your help!
If there's a Makefile then on linux just go into the terminal, navigate to the directory where the Makefile exists and run the command `make`.
The project consists of how many .f90 files? Do you know their roles? You can run gfortran on the command line on Windows too fine, this has nothing to do with Linux.
There's make on Windows too, with Cygwin or WSL or any of the other options.
I don't have them in front of me, but I believe there are 8. I'm not 100% certain of their roles, but I think each includes a different component of the model calculations (i.e. one for energy balance, one for radiation calculations, one for physiology etc). Good to know about gfortran at the windows command line, I'm going to give that a shot.
There is no reason to define util as recursive. It's not calling itself. You might want to declare your big arrays as ALLOCATABLE and allocate them once before use. That should free up a lot of stack.
There may be a compiler flag that does this automatically, but it's better to do so by hand for your large arrays.
You need a good Fortran compiler first. If you are a graduate student, you can get a [free license for Intel Parallel Studio](https://software.intel.com/en-us/qualify-for-free-software/student) which includes the Intel Fortran compiler. (Keep in mind that on Windows, you also need to install Microsoft Visual Studio before Intel). The MS Visual Studio Community version is available free of charge. Then simply search the web for keywords like "[ifort compile command example](https://www.google.com/search?q=ifort+compile+commands+example)". If you do not qualify for free, then GCC gfortran compiler is you second good option, but that is virtually only available in Linux. Having said that, if you need us help you with the compilation, you will have to tell what files you have, and what are the dependencies between them. Can you share them, or share their interfaces, if the content is private and sensitive?
Thanks, I'll try to see if changing them to allocatable helps. The only reason is I defined it as recursive was because the program crashed when I used openmp and -fmax-stack-var-size with an error message that it had to be recursive. Thanks
Try making your utility function PURE and ELEMENTAL. That helps with some things.
OP: I did try running as admin but still I can't install it. I even try this method (https://blogs.msdn.microsoft.com/astebner/2006/09/04/solving-setup-errors-by-using-the-subinacl-tool-to-repair-file-and-registry-permissions/) by installing SubInACL tool but to no avail.
OP: I did try running as admin but still I can't install it. I even try this method (https://blogs.msdn.microsoft.com/astebner/2006/09/04/solving-setup-errors-by-using-the-subinacl-tool-to-repair-file-and-registry-permissions/) by installing SubInACL tool but to no avail.
Any question?