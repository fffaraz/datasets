You seriously deserve more than just 5 upvotes for this resource.
Thanks, I really wanted to have a single useful list of important docs. Figured it may help someone pick up this gem of a language.
This is not-so-trivial? 
As compared to "Hello World". Apologies if the title seemed misleading. That is why the "first" is put there.
Actually, I think this sort of thing is useful for a language like Lisp. People seam easily caught up in the foreignness. 
I hope so. Honestly speaking I'm a n00b in Functional Programming/Lisp/Scheme. The reason I tried it was Reddit (proggit) and comments on this site and the first problem I hit was a good start point.
Keep at it - it is totally worth it. Don't let some of the smarty-pants dickhead types turn you off.
Thanks, its already been an eye-opening journey, even though I don't really use Scheme in my work - it now helps me think in terms of more generic and building-block style coding.
This book is mostly unfinished. :(
And fails to load, at least for me.
To give credit where it's due, this incomplete book was written by Prof. Paul Wilson at UT Austin. There's a link to a Postscript version [here](http://www.cs.utexas.edu/users/oops/) near the bottom of the page. Given that it's over 10 years old, I have serious doubts if it'll ever be completed, but what's there seems interesting enough.
I had the idea of updating it, because it is good but I never got an response from Prof. Wilson (because of licensing, source code etc.).
Not completly, looks like it was a game scripting interface. I would love a tiny high performance scheme for embedding though =) Speed as LUA and maybe even the posibility to compile to C for release mode.
PLT Scheme is faster than Lua and can build a self-contained executable for any platform it runs on.
[There you go](http://code.google.com/p/ypsilon/). Ypsilon is created by game-makers, namely LittleWing (maybe you know Tristan from Win 3.11 times or Crystal Caliburn on Win 95).
But has a license which makes it impossible to use on commersial games (xbox/ps3) due to the relinkable clause. But yeah, PLT is my main scheme =)
Lovley! looks really promising. EDIT: It's huge... 1.5 MB binary on OSX
Ok, this is probably because it implements a lot of R6RS. You can also try Guile which was designed for embedding or Stalin which is geared towards performance. And of course there is ECL, but that is not a Scheme.
I might try to strip it down by reducing the boot heap. We'll see =)
humm, IIRC PLT uses LGPL. easily expressed is that you can link against it dynamically as much as you want, preserving your own source code under &lt;insert your&gt; license. Can you explain the issue please?
Yes I can. LGPL code is unusable in environments where DLL:s are nonexistent. Game consoles for example, where code needs to be signed. LGPL with static link clause would probably be ok. Using such a library in a game engine limits your future platforms significantly.
hmm, didn't think of that. Probably because I'm never in touch with such environments. Thank you for information.
Cross-posted on fnord123's request.
Does anyone have any experience with the speed and stability of serving websites from PLT? I use DrScheme frequently and would enjoy writing web apps in the language, but I'm afraid of scaling problems.
You should probably look into CL (SBCL) for production work.
This might be a bit dated: http://www.untyped.com/downloads/icfp068-welsh.pdf At any rate the untyped guys are probably the best people to ask. They have been heavily involved with PLT Scheme for a while. 
This app is written in PLT Scheme and runs on the PLT Web Server: http://www.scribular.com/ It feels very very quick. In general don't worry so much about scaling. It's pretty much always doable. 
Indeed, it loads quite fast. Do you know what libraries, infrastructure etc. they are using?
Yes, they use leftparen: http://leftparen.com/
Interesting framework :) Indeed it looks very similar to the sexp to XML conversion I am doing in IronScheme. Sample: http://www.codeplex.com/IronScheme/SourceControl/FileView.aspx?itemId=348281&amp;changeSetId=17198
Incidentally, I was serious. http://www.google.com/search?q=common+lisp+web+server
Thanks. I did not know about any Scheme-web-frameworks besodes HOP which is not supported on PLT. Nice, I already have plenty of ideas for toy web-projects :)
Scheme doesn't have the community, and the tools. There is no equivalent of Hunchentoot in Scheme, for instance.
Hi, I'm the creator of Scribular and LeftParen. The LeftParen version that is at http://leftparen.com, unfortunately, is a bit stale (gee, never heard that before!). I've made a lot of progress on it while improving Scribular, so expect an update soon. And feel free to bug me about it or ask questions (rob at scribular dot com). I would agree with herdrick and not worry too much about scaling. I'm sure we'll hit lots of performance issues, but profiling and tuning can get you a long way. Right now Scribular is a single server, and it uses the flat-file persistence built in to LeftParen--which is to say, it doesn't use a database. So far, I'm loving the database-free life. It's easy to program with and it's fast. Will such a system scale to Facebook proportions? Who knows. But to spend a lot of time fretting about that now would be a premature optimization. ;)
Hunchentoot is a web server, right? There is a web server written in PLT Scheme. We also have database integration, a component framework, testing etc. We've been successfully doing commercial web app. development in PLT Scheme for the last two years or so. I'd say we have the community and the tools.
&gt; There is a web server written in PLT Scheme. A web server is technically anything that can serve HTTP requests. Using that definition, yes there's a web server for Scheme. &gt; I'd say we have the community and the tools. I'm glad it works for you. I personally find the CL community terribly thin if compared to Python. As far as Scheme goes, sorry, I don't see anything I could use. 
You can't overestimate the importance of a site like this. If someone is sitting on the fence of using scheme or (say) python for a project, the existence of clear "here's how you e.g. walk a file-system" type instructions are critical. And just to be clear, by 'someone' above I mean a guy I know, not me. Ok, it's me.
See this is what's wrong with lisp. :) "I have a proposal for something that is missing in scheme (well, is slightly cumbersome). Lets fix it. Here is a reference implementation in 4 lines of formatted code (15 non-paren tokens)." There was a great quote from Shriram in, uh, PERL before swine(?): "ok, we don't have for/while. But we've got macros, you got 5 minutes?"
This is one of my favorite papers since it's concise, strong on examples, and highlights possible errors (and offers a fix).
I would like to have a nice PDF of the whole series when it's done, so I could start promoting Scheme to Pythoneers.
Why does this guy insist on using his own macro system? These pages were obviously written to be read, but I see no compelling reason to use his sweet-macros in lieu of syntax-rules/case and one compelling reason not to: while you can write macros with sweet-macros, it makes it tough to read non-sweet-macros and for others to read your sweet-macros. 
I'm a computer science student and in one our classes, we did a little scheme. Soon after I fell in love with the language and I've been doing most of my spare time hacking in it. We were using DrScheme and the Essentials of Programming Languages (2nd ed) language. From what I understand that language is more for beginners and helps hide us from some of the more powerful features. I'm looking for a "big boy" interpreter and/or dialectic that I can use for more serious work. Thanks!
I like Gambit Scheme, but haven't used much of others :)
DrScheme is an environment that allows you to switch between several different languages. You can read the documentation here: http://docs.plt-scheme.org/drscheme/languages.html You can choose Scheme as defined in the different Scheme standards and some other languages too. So you do not need to leave the DrScheme environment to use the non-teaching versions of Scheme. 
Firstly - the underlying Scheme in Dr.Scheme is mzscheme and it's definitely a "big boy" scheme. It's probably the most complete freely available Scheme you'll come across. Failing that I have found both Chicken and Ikarus to be excellent. Another track you could follow though is to look at Clojure - it's not Scheme, but a closely related dialect built on the JVM. It's fun, practical, functional, powerful and deals with the nascent issue of concurrency with elegance.
DrScheme should be quite good, but you may want to look [chicken](http://www.call-with-current-continuation.org/) too (it has [quite many libraries](http://chicken.wiki.br/Eggs%20Unlimited%203)).
PLT/DrScheme/MzScheme are "big boy" Schemes.
Ah, exactly what I was looking for. Thank you very much.
I've been reading over the lisp subreddit too and I've been seeing the orgy of clojure love going on over there, so it's defiantly on my list of things to try out too.
I'd very strongly suggest PLT Scheme: * DrScheme is great in conjunction with HTDP. * Immutable cons cells are the way to go. * Nice tools (parser generators, etc) are included. * Performance isn't... awful. * It handles a lot of corner cases "correctly" that other Scheme's don't. * [Typed Scheme](http://docs.plt-scheme.org/ts-guide/index.html) is actually quite useful. * There are a fair number of libraries available (relatively speaking). If you're looking to deliver software, you probably want something more efficient that compiles to C. You probably also want to be able to write bindings easily and have a nice set of libraries to work with. If that's the case, check out Chicken Scheme. If performance is all that matters, look at Gambit.
The one main thing to be aware of with Clojure is that it's very young. A lot of stuff is still up in the air and changes regularly. It's interesting in many ways, but I'd not use it for commercial software development yet.
Seconded, the PLT Scheme family and Chicken Scheme. Choose the latter if you want a Scheme -&gt; C compiler. Works well enough.
What would you suggest for someone trying to do SICP on their own?
Good luck with EoPL. It's one of my favourite comp sci books! I do my experimenting in PLT scheme, but I use Bigloo for my grunt work (I love the parsing library).
I use Gambit-C when I want to create small fast executable programs with no runtime dependencies. The only problem with Gambit-C is that it does not have as many libraries as DrScheme (MzScheme) and Chicken. On OS X, I use something like this to create standalone executables: gsc -c extraction.scm gsc -link extraction.c gcc -o extraction extraction.c extraction_.c -lgambc -I/Library/Gambit-C/current/include/ -L/Library/Gambit-C/current/lib/ 
I realize they're student projects, but I'd be really interested in seeing the source code for some of these programs. It's also really great to see Scheme used beyond the typical introductory courses that SICP and HTDP tend to focus on.
Yes, [Sake](http://planet.plt-scheme.org/display.ss?package=sake.plt&amp;owner=schematics).
Thanks a lot! It's really hard to find such projects.
Just released 0.51 which was a minor release to fix a potential conflict with 3rd party (PLaneT) libraries.
Awesome, and strongly recommended, of course.
His idea seems to be based on Eugene Kohlbecker's classic Scheme puzzle - [here ported to arc](http://arcfn.com/2008/03/arc-continuation-puzzle.html)
brain... fucked. so, what does it do?
Oleg did it! [Normal-order Syntax-Rules and Proving the Fix-Point of call/cc](http://video.google.com/videoplay?docid=-7990603720514207956&amp;hl=en) (At Danfest)
That looks like a nice library. Looks like a lot of nice posts on that blog - google helps but still leaves a lot to be desired.
In the paper where Scheme was first defined, [Scheme: An interpreter for extended lambda calculus](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.128.80), there were features for process control (erlang, anybody?). I think R7RS should reintroduce these into Scheme; possibly/probably pulling from Gambit's Termite.
The only Lispy OS there still is is Movitz.
My scheme is better than ur scheme!
&gt;Actually there are many available implementations of list comprehension in Scheme. There is even an SRFI (SRFI-42 Eager Comprehensions) which however I do not like at all since it provides *too much functionality and an ugly syntax.* Sounds like NIH syndrome. The author dislikes SRFI42 because it's more complex than he's used to and ... well it just isn't done like that in Python. So the answer is to implement your own version, which is missing filter clauses and whole lot of generators and is not readily extendible, and is implemented using another self-invented construct (let+). Hmmm.
&gt; Sounds like NIH syndrome. The author dislikes SRFI42 &gt; because it's more complex than he's used to and ... well it just isn't done like that in Python. imho the whole series of these articles have suffered from this.
a small amount more info here (taken from the [mslug mailing list](https://webmail.iro.umontreal.ca/pipermail/mslug/2009-March/000357.html)) &gt; We are currently finishing the development of a game called "QuantZ" that has been mostly written in Scheme using Gambit-C. A video of the game can be seen at www.gamerizon.com. The current version of the game runs on Windows and Mac OS. 
I wish there were fewer, longer articles. At 18 parts and counting it's hard to stay interested.
I don't know anything about DrScheme, but could it be a reference to Logo?
According to [Robby from PLT](http://list.cs.brown.edu/pipermail/plt-scheme/2009-March/031606.html) it is a Honu. Still don't know what the significance is. Here's photos of that Honu [in PLT-colors](http://xivilization.net/flyserver/imgs/plt-turtleegg.png) [in violet](http://xivilization.net/flyserver/imgs/plt-turtleegg-violet.png) :)
It's war!!.. New Scheme VS Python! The winner will be Haskell!
Hmm... doesn't appear on DrScheme 4.1.1 for OSX.
I think his comments are useful as he has tried to make cross-implementation R6RS libraries. Maybe R7RS could take some of the observations into account to make it easier for future library authors.
It was Prince Kuhio day.
I just checked the FAQ and there is no "Why not emacs?". Why not use emacs? 
[This submission of the article](http://www.reddit.com/r/programming/comments/8n49k/typed_scheme_20/) has comments.
[Thank you very much Dave!!!](http://www.pawfal.org/dave/blog/2009/05/windows-fluxus-politics/) 
I finally discovered why the DrScheme splash screen shows a picture of a [Honu](http://en.wikipedia.org/wiki/Honu) today and on March 26th. /plt/collects/private/drscheme-normal.ss
It might be more helpful to point out what King Kamehameha day is: http://en.wikipedia.org/wiki/Kamehameha_Day
This file is quite amusing, there are quite a lot of easter eggs, like the one on Eli's birthday.
it's turtles all the day!
wow!! It's looking very nice. I wonder how a Guile Javascript interpreter would do in comparison to Webkit. It would be nice to have an extensible web browser using guile, integrated in a guile emacs :P And perhaps could guile replace gjs and seed in gnome. So that we can have choice in the extension language to use.
I think the JS interpreter is rather a proof-of-concept then anything else, and of course it has no access to any rendering engine nor DOM. A more realistic (haha, I have to smile at this as a write it down, since it still seems so unreal) approach is the implementation of Elist on top of Guile making it possible to finally transplant Emacs on top of Guile and migrate it to Scheme.
It's not Grant's comment. It's Aziz's comments (the author of Ikarus).
Am I blind or is there no complete PDF of the book?
link to single PDF version plz
No, there isn't currently any. You could use GhostScript to produce your own PDF. [See here for the discussion on c.l.s](http://groups.google.com/group/comp.lang.scheme/browse_thread/thread/22ab3d99fce5ff0d/69ab9e1b2d0809b6#69ab9e1b2d0809b6).
Could someone tell me why many of "scheme academicians" are now in northeastern ?
Heres a short and unverified history of the lab at NU. [Matthias Felleisen](http://en.wikipedia.org/wiki/Matthias_felleisen) founded the PLT group when he was at Rice around 15 years ago. The group consist of mostly [Dan Friedman's](http://en.wikipedia.org/wiki/Daniel_P._Friedman) academic children and grand children. Felleisen came to [Northeastern's PRL](http://www.ccs.neu.edu/research/prl/People.html) bringing with him a lot of his students. He founded the lab here with Mitchell Wand and William Clinger.
One of these days I need to swing by the Northeastern campus and meet some of these folks. I'm just a couple of miles away. Even if I'm much more of a Haskeller than a Schemer, its a shame to not at least say "Hello."
Why dont you come down at the Symposium? Im sure you'll meet a lot of PL researchers, Schemers and may be even Haskellers. It should be fun. Message me if you do decide to come down.
Not a bad idea. I'll show up. =)
You'd be surprised. I meet up with schemers and haskellers in my town and they appear to be completely separate groups. I would have thought the lingua franca of PLT papers and lingua franca of type system papers would hang out but it doesn't appear to be the case. Do you lot have different experiences?
I dont know that many people who program in Haskell religiously. But what really surprises me is that many Common Lisp guys treat Scheme as a toy and denigrate it. I would have never imagined a rift in between Lispers and Schemers. 
I had a few grad students from from the PRL as TA's in a course last semester, and let me tell you, I think they know their stuff. Mostly Scheme, but other functional languages too. My "prof" is the one who is working on Typed Scheme.
I'm still waiting for a tutorial into units, anyone wants to write one?
Turtles all the way down?
His mileage may vary but I find that most high level langauges can become a "C". So long as it is possible, with a reasonable amount of effort to get the speed and there is a fairly easy way to do bindings you can use whatever you want. (Even an language that can call out to C works fine for most cases.)
Depends... for me, for a language to be my 'C', it needs to have a good application deployment (ie, standalone(ish) executable) support, this obviously rules out pretty much all of the free common-lisp implementations other than ecl (sbcl could still be left 'in' from this requirement, but 26MB executables are a bit silly), it pretty much rules out python and ruby. My personal 'C' atm is bigloo, which requires some .dll/.so files (depending on what features you use) which isn't a huge distribution nightmare. 
That is a good point. I hadn't thought of that. My "C" does have that feature, but it hadn't occured to me that most lisps do not.
I think that's true. It depends on the environment. Java is the enterprise's C. That makes Clojure Java's Gambit-C Scheme!
The link is to my blog. Gambit-C compiles to C, and once I have a make file for building a standalone app, I can happily interactively work in Emacs+Slime+Gambit-C and then build using something like: app: gsc -c data/stop-words.scm gsc -c utils.scm gsc -c fasttag.scm gsc -c category.scm gsc -c levenshtein.scm gsc -c json.scm gsc -c generated-code/cat-data-tables.scm gsc -c generated-code/lexdata.scm gsc -c proper-names.scm gsc -c summarize.scm gsc -c key-phrases.scm gsc -c main.scm gsc -c testapp.scm gsc -link category.c key-phrases.c main.c summarize.c data/stop-words.c utils.c fasttag.c levenshtein.c json.c proper-names.c generated-code/cat-data-tables.c generated-code/lexdata.c testapp.c gcc -I/Library/Gambit-C/current/include -L/Library/Gambit-C/current/lib category.c key-phrases.c main.c summarize.c data/stop-words.c utils.c fasttag.c levenshtein.c json.c proper-names.c generated-code/cat-data-tables.c generated-code/lexdata.c testapp.c testapp_.c -lgambc -o kbtm 
oops, no newline characters in my make file listing :-)
Indent by 4 characters and end each line with 2 spaces. app: gsc -c data/stop-words.scm gsc -c utils.scm gsc -c fasttag.scm gsc -c category.scm gsc -c levenshtein.scm gsc -c json.scm gsc -c generated-code/cat-data-tables.scm gsc -c generated-code/lexdata.scm gsc -c proper-names.scm gsc -c summarize.scm gsc -c key-phrases.scm gsc -c main.scm gsc -c testapp.scm gsc -link category.c key-phrases.c main.c summarize.c data/stop-words.c utils.c fasttag.c levenshtein.c json.c proper-names.c generated-code/cat-data-tables.c generated-code/lexdata.c testapp.c gcc -I/Library/Gambit-C/current/include -L/Library/Gambit-C/current/lib category.c key-phrases.c main.c summarize.c data/stop-words.c utils.c fasttag.c levenshtein.c json.c proper-names.c generated-code/cat-data-tables.c generated-code/lexdata.c testapp.c testapp_.c -lgambc -o kbtm
How do you setup a good slime/gambit environment? Please enlighten =)
Scheming in parallel --- I like it!
The problem is that they say the implementation may not reflect everything in the papers; I'd prefer Termite (http://code.google.com/p/termite/) or Kali Scheme (http://community.schemewiki.org/kali-scheme/), just to avoid such issues...
Dialect of Scheme AND Common Lisp? What the hell does that really mean?
Does it give realtime guarantees? If it does, it can be my new C.
I have the third edition... any important differences in the fourth that I should be aware of? Does it cover R6RS?
[“This book covers the language of the Revised6 Report.” ](http://www.scheme.com/tspl4/preface.html#./preface:s1)
Did you say end each line with 2 spaces? What the hell is that?
i'm getting 404 issues ...
It's back up
Is this a good book for someone just learning Scheme?
It's more of a reference book. If you're just learning Scheme I'd recommend [SICP](http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262011530/ref=sr_1_1?ie=UTF8&amp;qid=1249488109&amp;sr=8-1) (of course), [HtDP](http://www.amazon.com/How-Design-Programs-Introduction-Programming/dp/0262062186/ref=sr_1_1?ie=UTF8&amp;qid=1249488140&amp;sr=8-1), and the [Schemer series](http://www.amazon.com/gp/series/92456/ref=pd_serl_books?ie=UTF8&amp;edition=paperback).
Will do...I have gotten that answer twice. So that is what I am gonna do.
Emacs migrating to scheme is about as likely as HURD becoming stable.
Let me know, I can show you around the CCIS building. Can't guarantee who will be there, of course.
OK r/scheme, I hear you. You either don't like questions, or are collectively unfriendly, or too cowardly to reply. I don't see how my question could be considered offensive or why it deserved to be downvoted. Still, you've made me feel unwelcome, so I guess I'll just stick with the more tolerant subreddits. 
This is stupid, the correct approach is obviously to petition the compiler manufacturers to make their stack traces more readable when using TCO functions, not to simply disable TCO and rely on not running out of stack space and all the other problems of non-TCO operation.
&gt; the correct approach is obviously to petition the compiler manufacturers to make their stack traces more readable Good luck with that. I don't really see the point in any of this, myself. Stack traces aren't particularly informative in languages that *don't* delete stack frames.
I would love to see a comparison between C-compiled schemes. For example, what's the advantage of Gambit-C over, say, Chicken?
Macro Stepper is one of the reasons why use Dr.Scheme. The debugging facilities in Dr.Scheme are just awesome.
Looks interesting, shame it's confined to a seperate implementation of scheme though. And since it's part of that implementation, it's doubtful they'll see much value in pulling it out to a more portable form :(
Splitters!
After having read the paper, I think if they manage it right, it will be a very good thing for Scheme.
Heh, that's nice. I made my own macro which did the same thing some time ago and was also pleasantly surprised how well it worked.
I started porting a bunch of (co)monads to scheme (because some strange ones like the cofree comonad are a damn sight easier to understand in scheme than they are in Haskell) and dealing with explicitly curried return and bind, let alone the rest of the monad transformer stack was driving me batty. ;)
 (i . &lt; . j) Looks like ASCII art for someone peeking over a wall
This is ridiculous. I know it looks like a mathematical "less than", but `&lt;` actually *acts* like an `increasing?` function. For instance, the mathematical comparison operator `&lt;` only compares two things, whereas in Scheme that character actually asks whether its arguments are listed in increasing order. That's why this works in Scheme: (&lt; a b c d e) There's nothing to fix.
Probably because you are using aspects of rnrs or core like "define", "lamba", "display". I don't actually know, however. 
According to the r6rs library spec display is in the (rnrs io simple (6)) library. See section 8.3.
you can make library without rnrs and display, but then "define will be undefined" (library (foof) (export bar) (import) (define (bar n) (n))) 
Thanks for pointing me at the right part of the spec. The fact that I could use either `core` or `rnrs` there kinda threw me at first. It seems they both export a lot of the same stuff. I guess I'll have to dig around and see if I can figure out why that is.
One-armed if is just really bad style. Either there is some kind of side effect in the condition (yuck), they are redundant (if true then bar) or (worst of all!) the programmer is using the empty else clause as a no-op.
It's possible, if it went through CGI (ie. Apache or something). Otherwise it would mean interfacing with the sockets API, which isn't portable at all.
[here](http://www.bluishcoder.co.nz/jsscheme/) and [here](http://www.gnu.org/software/kawa/XML-tools.html)
Maybe the [PLT web server](http://docs.plt-scheme.org/web-server/index.html) is something for you
From the article: &gt; There are about three or four such Web development tutorials I've found for Scheme. Unfortunately, they all use a Web development framework that only works on PLT Scheme. Well, hell — I don't want to have to change Scheme implementations every time I want to work on something in a new problem domain. Isn't there something like this that uses portable Scheme libraries, rather than using something particular to a specific implementation? Please read the requirements before offering "solutions".
It looks like Kawa is non-portable and jsScheme is an implementation of Scheme in JavaScript, neither of which is a Web development library or framework portable across different Scheme implementations. Please correct me if I'm mistaken.
&gt; the sockets API, which isn't portable at all. Please provide more details about this, or point me to a good (and easy to understand) source for more information.
&gt; the programmer is using the empty else clause as a no-op. I'd say that's not a big deal, except we have `when` for that.
Sorry, I was being cheeky. I do however think the idea of incorporating jsScheme into a Scheme-based web dev framework would be pretty cool though, similar to how GWT uses Java.
After thinking about it for a couple of days, I decided to upvote this because it's a good piece of information. Unfortunately, I think the reddit link really should have pointed to [the source](http://groups.google.com/group/plt-scheme/msg/39144ae84fe3518b), because the *Wisdom and Wonder* post didn't add *anything* to it other than some visibility. Since that's what reddit does, too, we really don't need visibility added to visibility -- we need it added to the original quote.
Yeah, that *would* be pretty spiff. If I ever get around to writing a portable Scheme Web framework myself, I may have to incorporate jsScheme (or something like it).
Is there a version of this that I can download rather than having to watch in the browser with a Flash plugin? YouTube would work, thanks to the `youtube-dl` tool, and Google Video would work because it allows downloads.
You could look into mod_lisp and apache. Writing an implementation of that protocol should be fairly easy.
Unfortunately, it's going to be a while before I do that. I'm still learning the basics of Scheme programming. Thanks, though.
Sorry, I've must have mistaken this for some "ask reddit" thing =)
Looking at the headline now, I can totally see how one might make that mistake. I always start my "ask reddit" stuff with something like "ask reddit", though -- and I always check headline target URLs to see if they're "ask reddit" things before just assuming, unless they say something explicit like "ask reddit". Now that I think about it, I should probably check target URLs for headlines that say "ask reddit", too.
The sockets API is what Internet Protocol and associated things (e.g. TCP) are accessed through on Unix (and Windows, I think). See [here](http://en.wikipedia.org/wiki/Bsd_sockets) for a run-down. Most Scheme systems provide a means of communicating with libraries such as these (this is usually referred to as a Foreign Function Interface). Like Common Lisp this isn't part of the standard. Ergo a Web server built on such an interface would not be portable. While it sounds pretty scary and stuff, a Web server is actually fairly easy to build. Just a bit of text parsing and co-ordination. Your best bet for the moment is to go for CGI, it's the easiest if not exactly the fastest method going. You'll still have to do a bit of text parsing, but it's not that difficult. See [here](http://en.wikipedia.org/wiki/Common_gateway_interface) for an overview.
&gt; The sockets API is what Internet Protocol and associated things (e.g. TCP) are accessed through on Unix (and Windows, I think). See here for a run-down. I'm aware of that part. I'm just not terribly conversant in the intricacies of Scheme yet. &gt; Your best bet for the moment is to go for CGI, it's the easiest if not exactly the fastest method going. You'll still have to do a bit of text parsing, but it's not that difficult. See here for an overview. I don't necessarily have to have the Web server part -- I can just slot my work into place with Apache, if need be. What I'm really looking for is the Web development part, where I write code that produces Webpages and Web applications. As you point out, creating a Web server isn't *too* scary, as long as you keep it simple, so I suppose I could even write my own when I get a better handle on Scheme, but writing code to run with that Web server, producing the site itself, is what I'm asking about. CGI isn't necessarily a bad option, though. I just need the portable tools and introduction that would help me get a handle on Web development in Scheme (I've done a fair bit of it with Perl, PHP, and Ruby in the past, including CGI work), as an approach to learning more of the practical side of things (since I've been working my way through SICP exercises, which is more theoretical in nature).
I think a cowboy approach to side effects is a big deal.
Assume for a moment nothing like `when` exists. What approach to a single-branch conditional would you recommend?
Except that SLIME doesn't work with Gambit. Once upon a time it somewhat worked with Scheme48 but that was two versions of Scheme48 ago and it no longer does. Some experimental support is there for a few other Schemes, but Gambit is not one of those.
There's hope: http://www.reddit.com/r/programming/comments/9iwr3/scheme_remote_repl_integrated_with_emacs_great/ 
I'm the author of this article - the mention of Slime was my mistake that is getting fixed. I use the Gambit-C Emacs support for Gambit-C, and Slime for various Common Lisps. Quack works well with mzscheme. Gambit-C is great when you want to code in a high level language, and at the end of the day, build small and efficient executables.
Eat more roughage
Hey, have you checked out SLIB? It's a fairly primitive library system, but it's as portable as they get. I just browsed through the packages it has, it includes things like a CGI library, something for relational databases and an XML library. Might be a good starting place.
Thanks. I'll give that a look.
&gt; Isn't there something like this that uses portable Scheme libraries, rather than using something particular to a specific implementation? No, but PLT is the implementation with the largest number of features and I would argue, the largest community, so I prefer that to [Hop](http://hop.inria.fr/) which is bound to Bigloo.
Should have linked to the [announcement](https://mercure.iro.umontreal.ca/pipermail/gambit-list/2009-September/004006.html), sorry.
&gt; PLT is the implementation with the largest number of features If the number of features was my primary concern, I'd choose Common Lisp at least -- if not just go with Java. Frankly, I'm not a huge fan of DrScheme, which is where many of the PLT Scheme features live, anyway, and last I checked I think PLT Scheme had no pretensions of being suitable for realtime programming. . . . and none of your argument about the subject of how fantastic PLT Scheme is changes the fact that saying "Just use PLT Scheme!" directly contradicts the primary criteria for a correct answer to the question that was asked. Would you tell me to get a Hummer H3 if I said I wanted recommendations for an off-road motorcycle? I don't care if it *can* carry more passengers -- it isn't a motorcycle!
&gt; and none of your argument about the subject of how fantastic PLT Scheme is changes the fact that saying "Just use PLT Scheme!" directly contradicts the primary criteria for a correct answer to the question No, but now we at least know why you dislike PLT. And uhm, I linked to Hop, while it is bound Bigloo, might be less objectionable to you. Don't know about how suitable that is for realtime programming, though. Others have pointed out that there is not really a solution, so besides rolling your own, people are trying to help you find some compromise.
&gt; Don't know about how suitable that is for realtime programming, though. I've been using Ypsilon, which has four major benefits I quite like: 1. It aims to provide concurrent garbage collection so it doesn't suffer the GC pause problem, making it better suited to realtime software development. 2. It conforms to the R6RS specification, which means that if anybody gets around to developing standards compliant portable libraries for Scheme, they're likely to work with Ypsilon. Unless and until R7RS provides a module system that more people like, an R6RS implementation seems to be the best hope for portable library development. 3. It's released under [copyfree](http://copyfree.org), rather than [copyleft](http://www.gnu.org/copyleft), terms. 4. The REPL/Toplevel interface is less annoying than most. For instance, any REPL that doesn't exit on `&lt;Ctrl&gt;`+`&lt;D&gt;` kinda gets up my nose, and having to take my hands away from home row to click an `X` button annoys me even more than having to type `(exit)` or confirm my desire to exit with the answer to a yes/no question. There may be other reasons that led me to choose Ypsilon over, say, Scheme48 or DrScheme, but they don't leap to mind at this exact moment. I seem to recall disliking something about the way MIT Scheme's REPL handled lexical context handling, too -- maybe related to trying to abort the current lexical context tending to be impractical without dumping out of the entire REPL.
Both 2 and 4 are true of PLT Scheme as well. Also, concurrent GC and realtime behaviour are very different. Also, almost all of the features of PLT Scheme are available at the REPL.
&gt; Both 2 and 4 are true of PLT Scheme as well. . . . but 1 and 3 are not. Meanwhile (for instance), 2 and 4 are not true of Scheme 48. Nor is 1, but 3 is true of Scheme 48. I was pointing out the whole set of compelling characteristics of Ypsilon, not saying that no other Scheme implementation provided *any* of the four listed characteristics. &gt; Also, concurrent GC and realtime behaviour are very different. Yes -- in the same way that a large engine and a fast car are very different. A large engine can still help make for a fast car, though. &gt; Also, almost all of the features of PLT Scheme are available at the REPL. You must be ignoring all those features people keep telling me are awesome about PLT Scheme, then.
As to your point 1, I'd be surprised if there were programs where, today, Ypsilon came closer to meeting real-time goals than PLT. &gt; You must be ignoring all those features people keep telling me are awesome about PLT Scheme, then. To the best of my knowledge, there are three features of PLT Scheme that I ever use that are only available in DrScheme, and all are the sort of features that only make sense in an IDE. The whole language is available at the REPL. Can you name any of these features you're referring to?
I love using PLT for general network programming when I have the opportunity to design the protocol. S-expressions usually make for very simple implementations.
&gt; As to your point 1, I'd be surprised if there were programs where, today, Ypsilon came closer to meeting real-time goals than PLT. Well, that makes it all better! I'll just use *your* favorite Scheme implementation, because *you* said it's better. &gt; Can you name any of these features you're referring to? From [here](http://www.udel.edu/topics/software/special/language/drscheme/): - Source text highlighting of syntax errors - Source text highlighting of run-time errors - Support for multiple levels of Scheme from "beginner'' to "advanced'' From [here](http://www.plt-scheme.org/software/): - various student-friendly features - integrated library support From [here](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.9543): - pinpoints run-time exceptions in a graphical manner - If the debugger discovers a potential problem, it explains the problem by drawing a value-flow graph In general: - editor-integrated execution window - syntax highlighting - editor-integrated debugger - multiple language levels - editor-integrated library support - "Help Desk" - syntax completion ("intellisense", to borrow a term) It boggles my mind that you're sitting here telling me you know more than me about PLT Scheme and DrScheme, but can't think of more than three features of DrScheme that don't exist without the IDE.
The following are all available at the REPL: * multiple language levels * editor-integrated library support * "Help Desk" * syntax completion ("intellisense", to borrow a term) * Support for multiple levels of Scheme from "beginner'' to "advanced'' The following are available in Emacs (and probably your favorite editor too): * syntax highlighting * editor-integrated debugger * editor-integrated execution window Here are the features that I use that DrScheme that editing Scheme in Emacs doesn't have (I assume that no one is using 'ed' (the standard Unix editor) to edit Scheme): * The graphical display of stack traces * The macro debugger * The 'check syntax' button And most of the macro debugger is available at the REPL. As to your dismissal of actual performance results, I'm not sure what to say. You can see this paper [1] for numbers (not from PLT people) that show the performance difference between Ypsilon and PLT. [1] http://www.ccs.neu.edu/home/pnkfelix/Published/klock-rgc-schemeworkshop-2009.html
&gt; multiple language levels I don't need *editor support* for multiple language levels -- and that's the feature people keep telling me is so great. I don't need the multiple language levels, either, but that's not relevant to the comment about what people seem to think is so great about DrScheme in particular. Of course, I accidentally duplicated the "Support for . . ." thing there, and didn't point out it's the editor support for it that is an IDE feature. I guess the confusion over this point is partly my fault. &gt; editor-integrated library support That is *not* available at the REPL, because the REPL is a REPL, and not an editor -- unless you're going to tell me that sh is an editor too. &gt; "Help Desk" Seriously? Is that really available, in the form of DrScheme's "Help Desk" (rather than just an interactive interpreter help feature), available at the REPL? I guess I'll have to take your word for it, because I haven't gone looking for that particular feature subset in the PLT Scheme REPL. &gt; syntax completion ("intellisense", to borrow a term) If you're talking about tab completion, that's not the same as what DrScheme provides. &gt; Support for multiple levels of Scheme from "beginner'' to "advanced'' This is just a duplicate of the "multiple language levels" point, quoted from a different source. &gt; The following are available in Emacs (and probably your favorite editor too): They are indeed available in my favorite editor (Vim), in some cases with a little tweaking. They are still touted as must-have features of DrScheme, and I still don't use them, though. &gt; The graphical display of stack traces I don't feel a burning need for a *graphical* stack trace. &gt; The macro debugger Considering I haven't even started writing my own macros yet, that's not even on my radar -- so I don't find it a compelling reason to use DrScheme. &gt; The 'check syntax' button I don't feel a burning need for a button, either. &gt; As to your dismissal of actual performance results, I'm not sure what to say. I didn't dismiss actual performance results. I dismissed your hand-waving. &gt; You can see this paper [1] for numbers (not from PLT people) that show the performance difference between Ypsilon and PLT. Maybe I'll find time to read it soon. Hopefully it'll actually cover the relevant issue (GC pause).
At this point, you're just dismissing the features that you claimed were the most important reasons that people used PLT. And you're skeptical that various features that exist at the REPL are real, but you've never used them. And you think that GC pause times matter when there's a 2-order of magnitude difference in overall GC time. It's fine if PLT doesn't fit your needs, or even if you don't like it, but you should at least figure out the facts before making that determination.
&gt; At this point, you're *also* dismissing the features that you claimed were the most important reasons that people used PLT. FTFY . . . and so what? &gt; And you're skeptical that various features that exist at the REPL are real, but you've never used them. By definition, something that isn't an editor doesn't have "editor-integrated" features (unless you're saying those features don't work without a compatible editor). It's tautological. I don't see why you're complaining about that. &gt; And you think that GC pause times matter when there's a 2-order of magnitude difference in overall GC time. Sometimes, changes in performance are more important than current performance. &gt; It's fine if PLT doesn't fit your needs, or even if you don't like it, but you should at least figure out the facts before making that determination. It's fine that you like PLT Scheme so much, but you should learn to make valid points.
http://clipnabber.com/ seems to work with the vimeo link http://vimeo.com/5615765
Thanks.
Instead of starting rumors like this, I personally think it's best to talk with people rather than *about* them. This said, I have not much more information than you do about that issue.
A single person with over a million lines of code? Does he refactor other people's code a lot, or is he just epicly prolific?
Flatt is profilific. But that's probably not the whole explanation. Originally PLT used CVS, and then later changed to SVN. Furthermore the PLT source includes copies of a few other projects such as GNU lightning. Since Flatt wrote the JIT, he is credited for importing GNU lightning. I am sure there are other examples. 
I thought this was pretty cool.
Very nice! So now we have apps written in: - Objective C - Scheme (Reverso) - Smalltalk (WikiServer, ST80Docs, SqueakDocs) Anybody aware of any other languages people are using to write iPhone apps? As MacRuby matures we should be seeing apps written in it as well which is exciting. 
There's [MonoTouch](http://monotouch.net/), but I don't know if any MT-powered apps have made it to the store yet
Thanks!
Lua, via [Wax](http://github.com/probablycorey/wax)
Won't Apple complain that Lua is a piece of interpreted (byte-)code? Gambit-Scheme is translated to C, and then compiled as C code, which is still allowed by Apple for its store. OTOH, Lua is either interpreted or semi-compiled, which could be forbidden by Steve's minions.
I was under the opinion that you're only forbidden from *downloading* code to be executed, not from writing your code in an "interpreted" language. 
Rather devoid of any information there, really :/ I'm guessing from the name, and other blog posts, that it's a scheme compiler for .NET, but other than that, this announcement is fairly useless.
Did some industrial strength googling and found lisp code of and Angband varient written in Common Lisp. I can will take a look at the code and see how easy it will be to port over. Author: Stig E. Sandoe Home page: http://langband.sourceforge.net/download.html LAngband is a written in Common Lisp. It is distributed under the GNU General Public License (GPL). LAngband has been designed to be a roguelike engine where you can write and/or customise your own variant/plugin which will not interfere or ruin other code. To do this it uses the powerful object-oriented features of Common Lisp (e.g multi-methods and generic functions) as well as the functional features which allows the engine to treat user-code (classes, functions, ...) as first-class objects and not just ad-hoc add-ons. 
Also found RLX: a cross-platform graphical roguelike engine currently being ported to Common Lisp by David O'Toole. http://dto.github.com/notebook/rlx.html 
Indeed, but following the link ou will get a detailed description at http://ironscheme.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=34587
Neat! &gt; call/cc only supports escape continuations, trying to re-invoke a continuation will result in an error :|
@fnord123: feel free to use CommonLarceny in R6RS mode if you need reify continuations :) Or some native Scheme. Also I have not even investigated how it would behave using the CLR for underlying procedures, it could mean I need to (re)implement every little thing from scratch.
&gt; Also I have not even investigated how it would behave using the CLR for underlying procedures, it could mean I need to (re)implement every little thing from scratch. call/cc tends to be the kind of thing that needs to be baked in from the beginning. [This article on how Bigloo for .Net doesn't fully support continuations](http://www-sop.inria.fr/members/Manuel.Serrano/publi/jot04/jot04.html#Continuations) can lend some ideas on why it wasn't done. My comment was somewhat out of frustration that these platforms don't support call/cc. Good luck! PS - Reddit has nested comments so you don't need to use @${username}.
Sorry, stackoverflow frustration :) It's on the investigation plate. But due to performance I think it might be quite hard. So the idea is build a fast statically typed compiler/language in the spirit of scheme as an underlying platform. Hopefully from there, I will be able to see if a CPS compilation is feasible (and by that I mean comparing it to itself, not some other .NET call/cc capable ones). I am in no rush however :)
Without this paper, I'd probably still be trying to understand how to use continuations.
Correct. I posted about this topic here, perhaps the OP had meant to cite the blog post? http://www.wisdomandwonder.com/link/3409/a-history-of-bootstrapping-ikarus-scheme
I realise this is just formalising a set of extensions thats been in guile for a while, as part of the core language... But part of me wonders if it wouldn't be more sensible to go with compatibility with other scheme variants, and embrace the way DSSSL style arguments have been rolled into the standard define/lambda forms with #!optional, #!key and #!rest by most others. Remaining incompatible with every other implementation when using the ice-9 optarg extension is fine, but making your incompatibility part of the core, just seems foolish, to me.
Hi NikkiA. I think that DSSSL compat can probably be done with read tables (for #!optional -&gt; #:optional) and macros if necessary. IIRC DSSSL is very close to the Common Lisp way of doing things which is where Guile's implementation comes from, historically. There really isn't a strong compatibility argument here though. What about SRFI-89? What about PLT's keywords? In the end, it will be nice to support these, but we have to respect our users' extant code as well.
Dunno; I've seen more Scheme systems with the DSSSL syntax than support SRFI-89 out of the box. That said, I don't think it's an argument for either one.
I just tried redefining #!, but #! conflicts with the otherwise very useful SCSH shebang block comments. Still should be overridable, of course.
Conflicts with SRFI-22 as well, which was my point really: there's no real reason to follow SRFIs if they're one-offs (SRFI-89 isn't widely used, from what I've seen, whereas the DSSSL syntax is more common). I think you're on the right approach with what you've described.
Here's a screenshot: http://imgur.com/T2Kqz
rio colours :)
Wow, I liked the concept but the only Lisp WM I knew was StumpWM and that one is in Common Lisp. Hooray, this might be an awesome topic for a presentation at a user group.
Good Eye! :-)
Scwm and sawfish would be two other examples.
And don't forget [Orion](http://freshmeat.net/projects/orion/), written in [Scsh](http://www.scsh.net/).
Sawfish is not written in Lisp, is it?
It's mostly written in librep which is a Lisp.
[Gambit](http://dynamo.iro.umontreal.ca/~gambit/wiki/index.php/Main_Page) does.
Try Nazghul. http://www.happypenguin.org/show?Nazghul Not PLT though. It's written in the author's own Scheme dialect. There used to be a scheme roguelike MUD called World (I think), but I can't locate it at the moment.
[chicken](http://call-with-current-continuation.org) can too as an extension.
I'll add in that bigloo indeed can, as you say, it's not an advertised feature, but you can do it. Obviously doing it in any implementation is going to require a bit of knowledge of the C FFI, the C embedding rules, and C itself. But Bigloo, Gambit-C and chicken are all capable of doing it. (I have done it in bigloo and gambit, gambit is my preferred scheme implementation atm).
Any specific reasons for you to choose one over the other? Or is it just a personal choice.
Yes, but they're not the most sensible of reasons... I had been using bigloo - and loving it's optional strict typing, but found some annoying bugs in it's socket handling on windows, and there appeared to be no rush for the devs to fix them. Also gambit routinely benchmarks faster than bigloo or chicken. Once I'd gotten into using gambit a bit, I discovered that I generally felt the community around it's developers is a bit nicer. They're really minor issues, but they were enough to make me switch from bigloo to gambit as my main implementation.
Ikarus running a demo and Ypsilon running the window manager - is it hard writing cross platform code for the two?
Hi Chris! :-) All the agave demos run in Ypsilon and Ikarus: http://github.com/dharmatech/agave My 'psilab' repository is for Ypsilon specific code. The xlib library currently only works in Ypsilon, due to it's use of Ypsilon's FFI. Ikarus supports some of the Ypsilon FFI api, but not all; my xlib library uses some of those not yet ported parts. Ed
Hi Ed! I've been playing around with Ypsilon and Ikarus, they're nice Scheme implementations. Thanks for your demos!
PLT is a good environment + implementation for learning scheme, although I would recommend sticking to its r5rs mode if you intend your skills to be transferrable in the short term - r6rs support is limited in other implementations, and large parts of 'r6rs knowledge' may be somewhat negated if the intent of splitting r6rs into 2 seperate standards occurs. PLT includes a number of scheme learning materials (TYSiFD, HtDP, TeachScheme!, etc) that make it an excellent learning environment that is directly supported by texts. Once you're comfortable with scheme, you'll be in a better position to evaluate which implementation you wish to use for specific tasks, based on the criteria that different versions are suited for.
The tutorials in [Teach Yourself Scheme in Fixnum Days](http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html) are pretty good.
I got interested in Scheme when I read about the game written and released in Gambit-C. As I looked further, I saw the Chicken had the ability to generate C code and be compiled to a binary executable. Chicken also looked like it had been around longer and had more support in the form of libraries. As I read the chicken docs and posts to chicken-users, and read the SRFIs, I keep on seeing the same names come up, so I think I made a good choice in Chicken. Compiling to a binary was a prerequisite for performance for the project I'm working on. Chicken also has decent integration with Emacs, which has been my editor for over 12 years.
And they are for PLT (although they are as general as possible)
I would give serious consideration to PLT Scheme's module language. While your code might not run in other Schemes right out of the box, the wealth of libraries and features integrated with the module language are extremely compelling. Your experience should be transferable to other Schemes, and you won't be left fighting less comprehensive library support. 
I'm actually a big fan of Ypsilon. It uses concurrent garbage collection to eliminate some GC pause time, it's R6RS compliant (including using [R6RS standard modules](http://sob.apotheon.org/?p=1548)), it has a really friendly license, and its REPL doesn't really take any getting used-to at all (for instance, `(exit)` and `&lt;Ctrl&gt;&lt;D&gt;` both do exactly what you'd expect). It's also very lightweight and seems speedy in my unscientifically evaluated experience. I seem to buck a lot of trends. I'm not a member of the PLT/DrScheme/Borg Collective and I use *[Vim + Scheme](http://sob.apotheon.org/?p=1589)*. Considering the biggest orthodoxies in the Scheme world (aside from certain topics in language design discussions) are using PLTScheme for "real work" and Emacs or DrScheme as the editor of choice, I guess I'm just weird using Vim and Ypsilon (which was, by the way, designed specifically for "real work" in game development). Your mileage may vary. Expect to live on the fringe of "mainstream" Scheming if you follow in my footsteps. You might consider running through SICP again with Scheme, by the way. If you've done it once, you'll be in a good position to get through it at a reasonable pace.
&gt; While your code **will never** run in other Schemes **unless you become a Scheme expert and have lots and lots of time on your hands to devote to the task of porting it** FTFY PLT is kinda like the Microsoft of the Scheme world -- embrace, extend, extinguish.
The question is what do want to do with scheme. If you want to learn the language, then PLT is a good environment as it has a number of teachpacks to help you out. A number of posts have already recommended it. If you want to generate C files that you can compile into an standalone executable then you can look at Gambit or Chicken. Plus both of these have good C FFI and so integrating with libraries is easier. If you want to try out shell scripting with Scheme then Scsh would be a good choice. If you want integration with .net and windows programming then Iron Scheme is a start. If you want to use scheme to do some image processing then, the GIMP scripting interface uses scheme. And if you really want to do things your own way, then you could implement it yourself! In short, the options are varied, but given how small the language (R5RS) is, it is worthwhile to look beyond just scheme.
http://dept-info.labri.fr/~strandh/Projects/Eclipse/ http://wingolog.org/archives/2008/07/31/introducing-griddy/, while we're at it...
An interesting take on the inadequacies of cons cells, from a functional perspective.
PDF warning...
You all probably new it but I didn't until recently.
what's gauche's sweet spot?
I happen to like Gauche's unix integration, as well as features it borrowed from STklos; I use it in most places one would normally use Perl or Python. It's relatively fast, has a nice module system, decent C api, and is all around pleasant to use. 
It is no where near finished though...
thanks. what kills me about scheme is that no one implementation has all the nice features. the nice bit is it's not too hard to learn several and pick the best one for any given problem. will give gauche a good look.
definitely; on top of that, there are the misc. factions (R5RS people, ERR5RS, R6RS, custom dialects, &amp;c.). Still, given a modicum of time, you can make *most* things work between systems, and, as you said, it's never too difficult to learn (the differences). That said, currently, I have tinyscheme, Scheme48, Gauche, Gambit, S7, Chibi, Chicken, Stalin, STklos &amp; PLT installed. Most of my work is Gauche (Unix scripting), Gambit (compiled programs distributed to peers) &amp; Scheme48 (server work) related, but every once &amp; a while I use something else (like embedded TinyScheme or Chibi). 
why did you pick gambit over chicken? i've been playing with both, and gambit produces smaller executables, but chicken has a much better packaging system. on the other hand, gambit has jazz, which is quite compelling if i ever want to distribute a desktop app.
Because I've worked with it longer, and I'm used to the way it works for compiled binaries. Also, I was able to get [Snow!](http://snow.iro.umontreal.ca/) working on Gambit with less effort when I first started using Snow (not that this is a mark against chicken, esp. considering [Eggs](http://chicken.wiki.br/eggs)). I've not yet tried Jazz; most of the GUI work I do is through a textual interface to gtk-server or web based, so it's not really what I need to do now (and the gtk-server work is mostly for historical reasons, although it is a nice way to get started). 
Yeah, I have Chicken, Guile and PLT installed at the moment, doing different things with each. I'm also fiddling with several implementations of my own, you know.
I am fiddling with my own implementations as well (well, one Scheme dialect, one PreScheme-inspired, one more primitive). It's always fun, and can be quite liberating (especially if you can use it extensively).
Finally! I'm constantly surprised how many Scheme implementations don't have native threads. Of course, there certainly are backsides of native threads, but having the possibility of using them is really nice.
Interesting discussion here : http://news.gmane.org/gmane.lisp.scheme.plt.devel 
&gt; I'm constantly surprised how many Scheme implementations don't have native threads Because non-native threads (threads within a single operating system process) are not dificult to implement when you already have a mean to capture continuations.
Yeah...I figured...but nice to know it is getting updated. I am getting that one and "The Scheme Programming Language".
I really like to read the articles about the development of Guile, thank you! Unfortunately, the other implementors don't post such nice articles what they do and how it works. Which is somehow understandable.
Thanks Leonidas. I think that writing about our implementations is important for Scheme itself; buzz "positions" a language with respect to others. That said, it's tough to write when you're in the middle of a hack, as I presume the other implementors are :)
http://git.savannah.gnu.org/cgit/guile.git/log/?h=wip-vlist
&gt; Another option would have been to require a new-enough version of Guile itself to compile the compiler. Isn't the simplest solution just to submit the compiled bytecode for `eval()` into your repository so you can use that to then compile whatever you need (including recompiling `eval()` to get a fresher set of bytecode)?
Good question. The first reason is that the bytecode is platform-specific -- at least as regards endianness and word size. The second is that I need to be able to change the bytecode, at least until Guile is stable -- so then bootstrapping would become a pain. Also I want to be able to have a known reproducible compile, that doesn't depend on the state of eval.go. Finally at some point the default target for some architectures will be native code -- and you don't want to have to check native code into the repo.
&gt; Finally at some point the default target for some architectures will be native code -- and you don't want to have to check native code into the repo. Ah, that makes sense. Thanks.
I am a bit embarrassed to have so many articles on the front page. I suspect others are amused or possibly even irritated :) So please, for the sake of diversity: may readers please post other links to Scheme articles or papers, new or old, so that we might have lots of lovely things on the schemit :)
You deserve it though!
Seems to be like JRM's presentation at this year's ILC about scheme on the CLR.
I've been using this approach in a toy compiler that compiles via c++ and I've rather liked it, so I thought I'd share.
Your Python code won't run in Ruby without a lot of porting effort either. And the analogy to Microsoft is uncalled for. Has PLT attempted to put anyone out of business?
I recommend PLT Scheme ( http://plt-scheme.org ). It comes with excellent documentation ( http://docs.plt-scheme.org ) and provides a wide variety of libraries and ability to integrate with other systems. If you're looking for a quick introduction from the perspective of an experienced programmer, then start with this to get up to speed: http://docs.plt-scheme.org/quick/ and move quickly to this, which shows interesting systems programming: http://docs.plt-scheme.org/more/
&gt; Your Python code won't run in Ruby without a lot of porting effort either. Oh, come on . . . My Ruby 1.8 code will generally run just fine in JRuby, and Ruby *doesn't even have a standard*. Why can't Scheme -- a language *with a standard* -- do the same thing? &gt; And the analogy to Microsoft is uncalled for. Clearly, we disagree. &gt; Has PLT attempted to put anyone out of business? I think "business" is the wrong term in this circumstance.
&gt; &gt; Your Python code won't run in Ruby without a lot of porting effort either. &gt; Oh, come on . . . &gt; My Ruby 1.8 code will generally run just fine in JRuby, and Ruby doesn't even &gt; have a standard. Why can't Scheme -- a language with a standard -- do the &gt; same thing? All your R5RS code or R6RS code will run just fine in PLT or in lots of other conforming Scheme implementations. I don't see why you should hold it against one Scheme implementation that the standard promises less than people want, when the Scheme implementation gives you what you want. It's just a mistake to think of Scheme as a language with a standard - it's a family of languages, for which the standard defines the overlap. &gt; I think "business" is the wrong term in this circumstance. What Microsoft-like things has PLT done? Signed anti-competive agreements? Abused a monopoly position? Anything? Or maybe you have no idea what you're talking about.
&gt; All your R5RS code or R6RS code will run just fine in PLT or in lots of other conforming Scheme implementations. Much of your PLT code won't run anywhere else. &gt; I don't see why you should hold it against one Scheme implementation that the standard promises less than people want, when the Scheme implementation gives you what you want. If you want it to do something additional, try offering it in a library -- instead of making your implementation one-way compatible with the standard. &gt; It's just a mistake to think of Scheme as a language with a standard - it's a family of languages, for which the standard defines the overlap. That's the usual PLT line. "It's not Scheme, it's PLT." Then, of course, the PLT programmer goes on to use shit written in PLT as proof that "Scheme" is relevant, advertises himself as a Scheme programmer, and so on. Pick one and stick to it. &gt; What Microsoft-like things has PLT done? Did you not read what I said? "PLT is kinda like the Microsoft of the Scheme world -- *embrace, extend, extinguish*." Emphasis added to make it obvious what you appear to have missed. &gt; Abused a monopoly position? Good point. It's *trying*.
&gt;&gt; All your R5RS code or R6RS code will run just fine in PLT or in lots of other conforming Scheme implementations. &gt; Much of your PLT code won't run anywhere else. Of course. Linux-specific code won't run on BSD. JavaScript on web pages won't run in Lynx. Your JRuby code that uses the Java libraries won't run in MRI. SBCL-specific code won't run on CMUCL, even though there's a standard for Common Lisp. Shockingly, it turns out that not every standard covers absolutely everything that people want. &gt;&gt;I don't see why you should hold it against one Scheme implementation that the standard promises less than people want, when the Scheme implementation gives you what you want. &gt;If you want it to do something additional, try offering it in a library -- instead of making your implementation one-way compatible with the standard. Not everything can be implemented as a library. For example, PLT *created* the module system on which the R6RS module system of which you are so fond is based. &gt;&gt;It's just a mistake to think of Scheme as a language with a standard - it's a family of languages, for which the standard defines the overlap. &gt;That's the usual PLT line. "It's not Scheme, it's PLT." Then, of course, the PLT programmer goes on to use shit written in PLT as proof that "Scheme" is relevant, advertises himself as a Scheme programmer, and so on. Pick one and stick to it. That isn't what I said at all. Scheme is a family of languages, of which PLT is one. Scheme also has a standard, which specifies some forms of compatibility between members of the family. I wouldn't ever say that PLT isn't Scheme, any more than Scheme isn't Lisp. &gt;&gt;What Microsoft-like things has PLT done? &gt;Did you not read what I said? "PLT is kinda like the Microsoft of the Scheme world -- embrace, extend, extinguish." Emphasis added to make it obvious what you appear to have missed. Precisely what *actions* are you referring to? Is your claim that providing system-specific facilities that can be accessed from otherwise-standards-conforming code is bad? How do you feel about these additions, then: http://www.littlewingpinball.net/mediawiki/index.php/Ypsilon#Other_utilities Is your claim that extending the standard is illegitimate? Should innovation be confined to standard committees? Is Linus sinning every time something not in POSIX is added to Linux? Come up with something specific and illegitimate the PLT has done, and maybe I'll believe that you have something more than sour grapes. 
&gt; Of course. Linux-specific code won't run on BSD. Actually -- it probably will, at least on FreeBSD. I'm using a closed-source Flash plugin binary developed specifically for Linux, using Linux-specific code, on this very FreeBSD system I'm using to respond to you. . . . but even if you were right, you're just proving my point: people who don't write portable code suck. &gt; Shockingly, it turns out that not every standard covers absolutely everything that people want. Shockingly, people write portable libraries to solve that problem sometimes. Sometimes, that "portability" only refers to being usable for implementations of a given language standard -- which seems to be a concept entirely foreign to PLT Scheme developers. There are, of course, cases where someone might specifically need to do something that relies on the specifics of an implementation, but this is the exception rather than the rule in sane circumstances. Thanks to the way the PLT community does things, though, things that would work just as well in portable libraries get incorporated into the language distribution and its specific toolset, thus *making* it all non-portable for no good reason. Then, of course, there are the cases where what you're developing will never be useful to anyone in any circumstance where a different implementation might be used, but that's obviously not the problem here. &gt; Not everything can be implemented as a library. True. &gt; For example, PLT created the module system on which the R6RS module system of which you are so fond is based. . . . and yet, PLT is only one-way compatible with it. Go fig'. You can import R6RS modules to PLT Scheme, but you can't export PLT modules to R6RS modules without being a PLT expert. &gt; I wouldn't ever say that PLT isn't Scheme, any more than Scheme isn't Lisp. Okay, so . . . there goes the meat of your argument based on the fact that PLT is its own language, because while that may be technically true it doesn't in any way suggest that portability is bad -- and a bunch of other implementations manage to keep things fairly portable. I wouldn't say Scheme isn't LISP, but it sure as shit isn't Common Lisp. &gt; Is your claim that providing system-specific facilities that can be accessed from otherwise-standards-conforming code is bad? Doing so *unnecessarily* is bad -- which is exactly what happens when the PLT Scheme module system *itself* prevents libraries written in PLT Scheme from being used with other Scheme implementations that are compatible with the standard module system. &gt; How do you feel about these additions What -- the additions that start with something like `(import foo)`, which uses the standard module system, and thus allows the relevant library to be loaded in code run by another implementation? &gt; Is your claim that extending the standard is illegitimate? No. My claim is that extending the standard in a nonportable way -- when portability isn't unreasonable -- is bad. &gt; Come up with something specific and illegitimate the PLT has done, and maybe I'll believe that you have something more than sour grapes. I keep talking about the one-way "portability" of standards-compliant libraries, and you keep ignoring it.
First, we have the incorrect assertions: &gt;. . . and yet, PLT is only one-way compatible with it. Go fig'. You can import R6RS modules to PLT Scheme, but you can't export PLT modules to R6RS modules without being a PLT expert. To quote from here [http://docs.plt-scheme.org/r6rs/Scheme_Interoperability.html]: "Using the conversion rules in Libraries and Collections, and R6RS library can refer to modules that are implemented in other dialects supported by PLT Scheme, and other PLT Scheme modules can refer to libraries that are implemented in R6RS." Then we have the failures to read: &gt;Okay, so . . . there goes the meat of your argument based on the fact that PLT is its own language, because while that may be technically true it doesn't in any way suggest that portability is bad -- and a bunch of other implementations manage to keep things fairly portable. Of course, as you say, Scheme isn't Common Lisp, anymore than Clojure is. But they're all Lisp. Similarly, R5RS, R6RS, Larceny, and PLT are all Scheme dialects. Other implementations manage to keep things more portable by doing fewer things. Bigloo, which does lots of stuff beyond what the standard specifies, makes its programs unportable. But you aren't ranting about them. Instead, you have a ridiculous vendetta about PLT, which you bring up at every opportunity, merely because you're unhappy that we haven't dropped everything we're doing to make the code we wrote more easily available to you. The source is all there - have fun. But don't expect people to port it for you, any more than Guido will port his standard library to Ruby. 
It's an interesting paper, although some of the touted flexibility appears to be lost when you have you muck around with the low-level representation every time you want it.
&gt; R5RS, R6RS, Larceny, and PLT are all Scheme dialects. PLT claims standards compliance. If people want to treat it as a non-standard dialect, they shouldn't pretend it complies with the standard in a meaningful way in the marketing materials. &gt; But you aren't ranting about them. PLT is the biggest offender amongst Scheme derivatives. I don't complain as much about "there" instead of "their" as I do about "u r" instead of "you are", either -- because the latter is a worse offense against the clarity of the English language. &gt; a ridiculous vendetta about PLT, which you bring up at every opportunity Every opportunity? Seriously? What's your evidence for this? Are you just making shit up out of thin air now? &gt; The source is all there - have fun. If I wanted to toil through the source, I'd just rewrite it myself. &gt; But don't expect people to port it for you, any more than Guido will port his standard library to Ruby. It's funny how you're back to acting like it's not Scheme again, after having told me so vehemently that you weren't claiming it's not Scheme.
1. PLT is standards-compliant, as much as almost any other Scheme implementation. In fact, Matthew Flatt, the primary maintainer, was one of the editors of R6RS, and is the author of the most-widely-used test suite for R6RS. 2. Your previous comments on the Scheme reddit have mostly focused on your bitterness that too much Scheme code is written for PLT. 3. Your confusion as to the nature of Scheme is mostly because you can't seem to understand that Scheme is not the name of just one language. PLT Scheme, R6RS Scheme, Bigloo - all of these are Scheme, but they are *not* the same language. And since they aren't the same language, you shouldn't expect that programs written for one would work in another. 
&gt; PLT is standards-compliant, as much as almost any other Scheme implementation. It's standards compliant in that it can consume any standards compliant code, but not in that it'd necessarily emit any standards compliant code. This is my point. One-way compliance is only halfway to real standards compliance. &gt; Your previous comments on the Scheme reddit have mostly focused on your bitterness that too much Scheme code is written for PLT. I doubt you've read all my comments about Scheme on reddit. There's probably some confirmation bias at work. &gt; Your confusion as to the nature of Scheme is mostly Your attitude about how anyone who would dare to prefer two-way standards compliance is mostly the result of you being a sanctimonious asshole, probably. &gt; Scheme is not the name of just one language. PLT Scheme, R6RS Scheme, Bigloo - all of these are Scheme, but they are not the same language. You think this is a great way to excuse one-way standards compliance. I think this is a fucking problem. That's like saying that anyone who wants code written for use with the Intel C compiler to also compile with Visual Studio and GCC and PCC is stupid, and portability between implementations is wrong. I cannot describe how stupid and wrong I think that is.
&gt;&gt; PLT is standards-compliant, as much as almost any other Scheme implementation. &gt;It's standards compliant in that it can consume any standards compliant code, but not in that it'd necessarily emit any standards compliant code. This is my point. One-way compliance is only halfway to real standards compliance. What do you mean "emit any standards-compliant code"? What standards-compliant code can you not write in PLT? Can you identify any R6RS programs that can't be written in PLT? If not, what do you mean by "one-way compliance"? &gt;&gt;Scheme is not the name of just one language. PLT Scheme, R6RS Scheme, Bigloo - all of these are Scheme, but they are not the same language. &gt;You think this is a great way to excuse one-way standards compliance. I think this is a fucking problem. That's like saying that anyone who wants code written for use with the Intel C compiler to also compile with Visual Studio and GCC and PCC is stupid, and portability between implementations is wrong. I cannot describe how stupid and wrong I think that is. This is a description of the world. Scheme, under any reasonable definition, no longer refers to a single language. In many ways, this is inconvenient, since many different Scheme implementations have different strengths and weaknesses. However, since PLT has developed lots of technology that goes beyond what is possible in the standard, not innovating beyond the standard would require giving up many useful developments. Further, GCC has lots of extensions that aren't in the C standard. Portability between implementations is valuable, but it isn't the only thing that's valuable, as the developers of GCC recognize.
And I thought that I was going to be spending Christmastime with my family, instead of being hunched over the computer ;)
&gt; What do you mean "emit any standards-compliant code"? I mean the kind of shit I've been saying above -- for instance, writing a fucking module for PLT means writing a module that can't even be imported by a different R6RS implementation, even if the code it contains is nothing but simple hello world shit that doesn't use any extensions of the fucking standard. Haven't you been paying attention at *all*? Jesus fucking christ. I'm not going to bother responding further until you read what has already been said. . . . except to say: &gt; This is a description of the world. It's funny how people manage to write C code portable across different implementations (as long as they aren't writing for the GNU project, which is kinda like the PLT of the open source C development world), then. &gt; Portability between implementations is valuable, but it isn't the only thing that's valuable, as the developers of GCC recognize. . . . and it's too bad the PLT people (like you) tend to forget "portability between implementations is valuable" is a two-way street.
&gt;writing a fucking module for PLT means writing a module that can't even be imported by a different R6RS implementation This statement is false. #!r6rs (import (rnrs)) (display "hello world\n") runs just fine in PLT, and in other compliant implementations of R6RS. And since I wrote it in DrScheme, I fail to see how your claim could be anything but false. &gt;. . . and it's too bad the PLT people (like you) tend to forget "portability between implementations is valuable" is a two-way street. Clearly, we forgot that when the primary maintainer helped to develop R6RS, and when we implemented the R6RS, and when said maintainer developed the R6RS conformance test suite. 
&gt; And since I wrote it in DrScheme, I fail to see how your claim could be anything but false. DrScheme is an editor. Writing something in an editor is not the same as writing it *for* a given implementation. &gt; Clearly, we forgot that when the primary maintainer helped to develop R6RS, and when we implemented the R6RS, and when said maintainer developed the R6RS conformance test suite. I guess so.
&gt; I believe the answer is roughly as follows. &gt; &gt; There were various versions of Gambit that generated 68020 code for &gt; early macintoshes and BBN Butterfly computers, for example; the &gt; version that is now "Gambit" started as the version that generated &gt; "C" code, hence "Gambit-C". &gt; &gt; Brad That's the closest to the real answer. Gambit (without the C suffix) is the generic name of the system which spans all possible target platforms. Up to now only two target platforms have been supported: initially Gambit had a back-end generating Motorola 68020 code (Sun workstation, Apple Macintosh, BBN butterfly multiprocessor, etc), then around 1994 a back-end generating C code was introduced. When the C back-end was released I decided to distinguish the systems with a suffix, so Gambit-68K was the first system and Gambit-C is the one generating C code. Note that at that point both front ends were identical, but the front-end of Gambit-C has evolved to support the C FFI and other extensions. I haven't worked on Gambit-68K in a long time, because my focus has shifted to portability rather than raw performance. Portability is the primary concern, followed by featurefullness, followed by performance. I think that's what most users want. Gambit-C is very portable, it works on any system with a decent C compiler (all the major workstations are covered of course, but Gambit-C has also been used on unusual target platforms such as the embedded PowerPC processor in Xilinx FPGAs and the ARM processor on the Nintendo DS). Gambit-C's abstraction of the target platform allows using it as a virtual machine (so that the same program will work on Unix, MacOS, Windows, and other systems with no modifications). Sorry, I'm rambling... Marc 
&gt;&gt; And since I wrote it in DrScheme, I fail to see how your claim could be anything but false. &gt;DrScheme is an editor. Writing something in an editor is not the same as writing it for a given implementation. Perhaps it wasn't clear that it runs just fine in DrScheme, and that all of the DrScheme tools work just fine for R6RS programs as well. Your concept of "one-way compatibility" makes no sense. &gt;&gt;Clearly, we forgot that when the primary maintainer helped to develop R6RS, and when we implemented the R6RS, and when said maintainer developed the R6RS conformance test suite. &gt;I guess so. And what have you contributed to the cause of Scheme standardization?
If he ran that code on a multi-proc machine, he'd probably get different results. Gambit-C doesn't use more than one core. You could use multiple processes with Termite, but that introduces overhead and the necessity for manual balancing of CPU-bound threads between them. Go apparently takes care of this for you automatically.
&gt; Perhaps it wasn't clear that it runs just fine in DrScheme, and that all of the DrScheme tools work just fine for R6RS programs as well. Your concept of "one-way compatibility" makes no sense. I really don't see how an editor's tools working with more than one "language" says anything about the compatibility of those languages themselves. &gt; And what have you contributed to the cause of Scheme standardization? What the hell does that have to do with anything? What have you contributed to the securing of Microsoft Windows code? I suspect the answer is "nothing, really," and that you'd *still* complain about compatibility problems if they affected your life.
My two cents. Neither Chicken nor Gambit have native threads, so that's a non-requirement. I switched from Common Lisp to MIT Scheme then to Chicken 3, then to Gambit, then back to Chicken 4. MIT Scheme has just about everything you could want in it, unsurprisingly, but it's not embeddable and it's a bitch to build. Between Chicken and Gambit, Chicken has far more SRFIs and extensions but Gambit's more pleasant to debug. (Don't be fooled by Gambit's snow repository. It's more proof of concept than useful. For example, the SRFI-13 strings library doesn't work and you can't import the example from the SRFI because Gambit doesn't support syntax-rules by default. You can turn them on but if you do that, you lose all non-R5RS syntax.) Chicken's a little rough around the edges and the documentation's a bit of a mess – half in a manual, half in a wiki, but overall it's easier for me to get things done in Chicken.
This is the kind of 2 cents I would love to hear about any language... words from experience. Thanks for sharing. I've been wanting to try out chicken, so this sounds like the right time. What do you mean by non-native threads? The language may not be the issue, but I'm concerned about the support for threads in the IO libs. If they attempt to deal with threads, I'll have a problem.
 &gt;&gt;Perhaps it wasn't clear that it runs just fine in DrScheme, and that all of the DrScheme tools work just fine for R6RS programs as well. Your concept of "one-way compatibility" makes no sense. &gt;I really don't see how an editor's tools working with more than one "language" says anything about the compatibility of those languages themselves. You claimed that PLT will not neccessarily "emit any standards-compliant code". I challenged you to provide a single example of standards-compliant code that PLT can't "emit". You haven't provided any. I provided an example of PLT "emitting" standards-compliant code. What more could you want? Also, the implementation of R6RS simply makes R6RS libraries in PLT modules, suggesting a high degree of compatibility. &gt;What have you contributed to the securing of Microsoft Windows code? I suspect the answer is "nothing, really," and that you'd still complain about compatibility problems if they affected your life. But perhaps I wouldn't be petulant about how people who worked on it hadn't worked hard enough, or didn't care. Perhaps. 
&gt; I provided an example of PLT "emitting" standards-compliant code. Are you even aware that there's a difference between PLT Scheme and DrScheme? Are you sure you know *anything* about this subject? &gt; But perhaps I wouldn't be petulant about how people who worked on it hadn't worked hard enough, or didn't care. Perhaps. . . . Seriously. Try having a conversation with someone some day, instead of whatever the fuck *this* is. You might enjoy it.
Non-native threads are like Posix pthreads or Java's green threads. They're managed by a run-time library at some layer above the OS. Native threads mean running as real threads in an OS that supports kernel threads, like OS X. In OS X, it would mean running as a mach thread. Chicken is thread-aware - its scheduler is wired for threads and it supports SRFI-18 as well as parameters (dynamic variables) that are thread-specific. But, the only portion of the I/O runtime that's thread-aware is the 'tcp' unit which provides non-blocking TCP, as well as custom input and output ports, which also support non-blocking I/O. The FAQ's pretty clear on this: &gt; Does CHICKEN support native threads? &gt; &gt; Native threads are not supported for two reasons. One, the runtime system is not reentrant. &gt; Two, concurrency implemented properly would require mandatory locking of every object that &gt; could be potentially shared between two threads. The garbage-collection algorithm would then &gt; become much more complex and inefficient, since the location of every object has to be accessed &gt; via a thread synchronization protocol. Such a design would make native threads in Chicken &gt; essentially equivalent to Unix processes and shared memory. Gambit's I/O runtime OTOH is thread-aware with locking. TinyScheme is, of course, completely oblivious to threads. Apple's using TinyScheme for their sandboxing in OS X and it's the Scheme underneath [impromptu](http://impromptu.moso.com.au/). So I wouldn't rule it out. But if you're going to be needing extensions, you're basically on your own if you go that route. It supports SRFI-0 and cond-expand and that's about it.
&gt;&gt;I provided an example of PLT "emitting" standards-compliant code. &gt;Are you even aware that there's a difference between PLT Scheme and DrScheme? Are you sure you know anything about this subject? Yes, I am sure. Also, I know that that program runs just fine in every other front-end for PLT Scheme. In fact, a program that begins with '#!r6rs' is just as much a PLT Scheme program as one that begins '#lang scheme' You still haven't provided a single R6RS or R5RS program that can't be "emitted" by PLT.
Ah, this is what I was worried about. Thread aware and scheduler 'wired for threads' means i will probably have to junk their tcp support, which is fine. Re: TinyScheme, yep, that is why I mentioned it as an alternative strategy. I try to not re-invent the wheel. In this case, I will try to make a version of Chicken that doesn't have any code for threading. If that turns out to be too hairy, then I'll go the nuclear option and use TinyScheme or Wasp. Thanks again for your help. I'll post here if I make any progress. 
I'll try to use small words: If you write a module in the style of PLT Scheme, that module cannot be used with (e.g.) Ypsilon. The code may be portable, if you intentionally avoid using PLT-specific constructs, but the module will not. Since one could conceivably use DrScheme to write modules for some other implementation than PLT (though I have no clue why you'd want to do that, since the only real benefit of DrScheme over many other options is its PLT-orientation), the fact you wrote something in DrScheme that is portable to other implementations is fucking well irrelevant, as you'd know if you weren't so intent on "proving" me "wrong" that you're willing to be an ass about it.
&gt;If you write a module in the style of PLT Scheme, that module cannot be used with (e.g.) Ypsilon. The code may be portable, if you intentionally avoid using PLT-specific constructs, but the module will not. * This is not the claim you started with. For example, I hope you now understand that your claim that PLT cannot "emit" various things is false. * DrScheme is useful for lots of things. It includes a debugger, refactoring tools, macro debugging tools, a module browser, and many others, all of which work **for R6RS too**. * The PLT module system was invented before R6RS, is more expressive than the R6RS module system, and is the subject of ongoing research by the PLT group. And it allows you to express all of the R6RS module system. Should we have gotten rid of our module system, breaking all previous code, when R6RS came along? Or should we not have done any innovating in the first place?
&gt; If he ran that code on a multi-proc machine, he'd probably get different results. &gt; Gambit-C doesn't use more than one core. Termite/GambitC can run on separate processes, AFAIK. For inter process comm, it uses TCP as of now and spports distributed computing over the network. But hacking it to use pipes shouldn't be a tough preposition. All in all, Termite goes way beyond Google Go.
&gt; This is not the claim you started with. For example, I hope you now understand that your claim that PLT cannot "emit" various things is false. Uh, no -- that's *exactly* the sort of thing I was talking about all along. Fuck's sake. &gt; DrScheme is useful for lots of things. It includes a debugger, refactoring tools, macro debugging tools, a module browser, and many others, all of which work for R6RS too. Yes, I'm sure it's all very useful to you. Then again, I can get much the same sort of functionality in other ways -- and those other ways don't include encouragements to make my code nonportable, to say nothing of the fact that DrScheme is ugly and clunky. Yes, I know this is a matter of opinion. &gt; The PLT module system was invented before R6RS I know. &gt; is more expressive than the R6RS module system, and is the subject of ongoing research by the PLT group. Good for them. &gt; Should we have gotten rid of our module system, breaking all previous code, when R6RS came along? Probably not. &gt; Or should we not have done any innovating in the first place? Of course not. Still . . . I can't use "standards compliant" PLT Scheme libraries with other R6RS implementations. Despite all the rationalizations and explanations and good reasons that bad things have happened, the fact remains that PLT Scheme accepts standards-compliant libraries, but doesn't emit them.
Yes, that is what I said: _You could use multiple processes with Termite, but that introduces overhead and the necessity for manual balancing of CPU-bound threads between them._ In any case, Termite has its place, but it doesn't make a good substitute on multi-core machines with CPU-bound jobs. What's needed is SMP support like Erlang's VM has, otherwise you end up juggling the threads between processes yourself.
&gt;Still . . . I can't use "standards compliant" PLT Scheme libraries with other R6RS implementations. Despite all the rationalizations and explanations and good reasons that bad things have happened, the fact remains that PLT Scheme accepts standards-compliant libraries, but doesn't emit them. I don't have any idea what you could be talking about here. Does the R6RS top-level program I presented earlier not work for you in other implementations? Also, I still don't know what you mean by "emit". Can you describe the process by which Ypsilon "emits" a library? Or Ikarus? AFAIK, the way you would write a library in Ypsilon is something like: 1. Open up your favorite text editor, and write some code. 2. Save it in a file called "mylibrary.sls" 3. Run it on the command line with a command like 'ypsilon mylibrary.sls' All of those steps are available for running standards-compliant R6RS programs in PLT. Is there something else you're referring to?
Fuck's sake. &gt; Also, I still don't know what you mean by "emit". Can you describe the process by which Ypsilon "emits" a library? Or Ikarus? This kind of willful ignorance, where you ignore the fact I'm using a term as a colloquial reference to the well-known and longstanding aphorism that it is best to be liberal in what one accepts and strict in what one emits -- it has finally convinced me that you're just stubbornly unwilling to have an actual fucking discussion. &gt; All of those steps are available for running standards-compliant R6RS programs in PLT. Is there something else you're referring to? Yes. PLT modules. Thank you. Have a nice day. I don't give a shit what kind of trollish disputation you will choose to follow this.
Blogspam
First, Postel didn't use the word "emit". Second, implementations of programming languages do not "emit" source programs. Which is why you can't describe what it means for any other implementation to "emit" a program. Does GCC "emit" C programs? Third, your complain appears to be that PLT claims to be standards-compliant, while also accepting things not specified by the standard. Isn't this precisely being liberal in what you accept? 
&gt; First, Postel didn't use the word "emit". Right. He said "send". I didn't bother to look up the exact phrasing at the time, and you might notice I didn't wrap it in quotes and claim he specifically said it. Anyway, I'm sure you'd have the same unreasonable shit-fit about the word "send" that you're having at the word "emit" -- so who gives a fuck? &gt; Second, implementations of programming languages do not "emit" source programs. Thank you for continuing to intentionally be a stubborn ass about it. The point was the reference to a common aphorism, and not the technical perfection of choice of term. &gt; Isn't this precisely being liberal in what you accept? You clearly haven't been paying attention to what I've said. This fails to surprise me.
PLT Scheme does not have native threads either (this seems to be common among Scheme implementation, I was very surprised that Gambit did not have them), don't know whether the green thread implementation that they have will get in the OP's way or not.
PLT Scheme, to be precise. Are the square brackets within conds a PLT-specific feature, or were they introduced in a revised report? SICP doesn't use them, for example. EDIT: &gt; In Scheme, parentheses and square brackets are actually interchangable, as long as ( is matched with ) and \[ is matched with \]. Using square brackets in a few key places makes Scheme code even more readable. [http://docs.plt-scheme.org/guide/syntax-overview.html](http://docs.plt-scheme.org/guide/syntax-overview.html) . &gt; r6rs-discuss issue report: The addition of square brackets to Scheme's lexical syntax has been controversial for several reasons. Most obviously, it creates a redundant alternative to Lisp's established lexical syntax for lists, for the sole purpose of allowing programmers to express their intentions through some subtly creative choice of parenthetical styles. [http://lists.r6rs.org/pipermail/r6rs-discuss/2007-June/002631.html](http://lists.r6rs.org/pipermail/r6rs-discuss/2007-June/002631.html)
Square brackets in PLT are used for non-function application.
I dislike square brackets. However I think I have to implement them, so I can use code written at other sites (the original purpose of the scheme standards).
Is there a download link somewhere?
And I have to admit that I actually like this feature, as opposed to wingo. Fortunately, they have the exact same meaning as parens, so they can be replaced at will.
I wanted to spice up my homepage with some Scheme code... *because I can*. There is also [this interpreter](http://www.bluishcoder.co.nz/2006/05/scheme-implementation-in-javascript.html) and [that compiler](http://www.omnigia.com/scheme/cpscm/home/), anyone ever used one of these?
Do you think this could also be useful for providing scheme tutorials on the web? When I was learning CSS, I always appreciated those tutorials on w3schools that allowed me to change the CSS code and see the results on the fly.
&gt; Do you think this could also be useful for providing scheme tutorials on the web? I guess so. The author [put it online](https://csel.cs.colorado.edu/~silkense/js-scheme/) and I guess it can be embedded in a Scheme tutorial. As far as I see it is meant more like an online REPL than to manipulate the DOM from Scheme, though.
This currently looks like the most promising option to embed Scheme in the browser. I haven't found yet a way for js-scheme to manipulate the DOM and Chris Double's Scheme makes it really ugly to call JS as all functions need to be wrapped.
I wish the slides would be made public. Or did I miss the link?
the point is, they could have been used for something really interesting, like reader macros or floating-point vectors or whatever. The chance is now gone. This is particularly sad because what your IDE or Editor shows must not be *exactly* what is in your source files. Some Scheme IDEs show the corresponding Greek letter instead of "lambda" and it would be no big trouble to show the outer parens in a "let" in a different face.
It is really a youtube video http://www.youtube.com/watch?v=GBpfOpk-ZBU So the usual tools work.
While I like the idea of the IDE to show outer parens as square brackets I wouldn't want to break the uniformity by introducing more syntax. The multitude of ' ` , etc in CL macros was what made me choose Scheme in the first place.
The download link is [here.](https://ccrma.stanford.edu/software/snd/)
This is a tinyscheme fork. Not r5rs, since it doesn't implement syntax-rules. Apparently it was written to [replace Guile](http://ccrma-mail.stanford.edu/pipermail/cmdist/2009-December/005827.html) as an project's extension language. The following somewhat gossipy history gives more detail: &gt; Since this is a big change in Snd, I feel like I should look back and try to explain what went awry. When I started Snd, I hoped to use emacs as the listener, and emacs lisp as the extension language. I was in the midst of trying to extract emacs lisp from emacs when someone mentioned guile. At that time I would have preferred a language closer to Common Lisp, but there were none I could embed in Snd. I read through the guile mail archives, and was impressed by Jim Blandy, at that time the head of guile. So I abandoned emacs lisp, and embedded guile. But several years later, Jim Blandy left guile (he now has his own Scheme named Minor), and guile's new leader was a disaster. Guile became comatose, and the guile forums became (in my view) ever more hostile. I tried to escape to Gauche, but then that project chose to go toward a compiler, and abandoned embedded language support. I reached a point where guile was getting in my way. I wanted solid multithreading (for with-sound in CLM primarily), and guile's was a morass of bugs. Since guile code was famously unreadable, it was impossible to find these bugs in any reasonable time. I also wanted multiprecision floats for my own research interests, but I had no hope of getting guile's developers to accept that. Although guile finally got a new, infinitely better leader, the project chose to go in two directions I did not like. First, it chose to move toward r6rs which I consider unspeakably ugly, and second it made a compiler its main goal. The latter wrecked the run macro because it (run) needs to be able to look into the current environment. So, I saw no way out except to find or write a new extension language. The list of things I looked at is in snd-xen.c. As you can see, that list ends with TinyScheme. As soon as I saw it, I knew I could make it into a "real" scheme that I could use indefinitely: s7. 
It's probably worth mentioning that Guile's multithreading seems pretty solid now, due to some changes in 1.9. Unfortunate that we didn't make it for him in time. It's true that Guile might implement R6RS this year, but it will probably be via a module, and not the default environment. (No dev I know of wants to program for R6RS, but it would be nice to use code from other sites.) His `run' macro is itself a sort of compiler, one that should have been implemented it in Scheme to begin with. In Scheme if you want access to first-class environments, you need to write your own interpreter, or compiler (via macros). It's not that hard.
Likewise, unfortunate that this project predates Chibi Scheme. And unfortunate that it didn't instead embrace one of the many other embeddable Schemes. The entire goal of having a subtly nonstandard (I'm not just talking define-macro) Scheme interpreter in a single Brobdingnagian C source file (two files, if you include the .h) I find misplaced. Note that the source of Chibi Scheme, concatenated, is smaller than S7, while delivering standard R5RS macros. God knows, I sympathize completely with somebody wanting to own it all oneself, ignoring parts of the standard with which one disagrees, particularly given snd's history of trying to interoperate with another project. I'm quite guilty of that myself. Doesn't make it any less of a mistake. All new gratuitous incompatibilities! All new bugs!
Cute! Where may I find more?
(a) This is *still* possible -- if you have some extension of the concrete syntax, then you can just as well break this use of []s since the code is no longer standard Scheme anyway. (b) The only way that this would be a problem is if there's some *standard* use of []s for one of these alternatives -- and after a few decades, I think that it's clear that no such thing will ever happen. IOW, you can think of this as implementing one use for []s, which happens to have been more popular than, for example, using them for vectors. Whether this is more or less interesting is subjective. (c) All of this is absolutely unrelated to letting your IDE have a different presentation for the actual source code -- if you choose to display "lambda" as the greek character, you can just as well choose to display []s as ()s and #(...) as [...].
Wow, delimited continuations. Nice touch!
I really like the last sentence : &gt; This is what I do for fun, because it is the exact opposite of &gt; the kind of thing people will pay for: an obscure implementation &gt; of a programming language everybody hates.
You're missing a link to said solutions, by the way. Self posts don't have links, for some strange reason.
Oh, you're right... That is weird. I'll fix it up (or go here: http://github.com/buntine/Simply-Scheme-Exercises).
I had a report on this and I agree that it's off topic. It's not a scheme or lisp. It's a parenthesis delimited polish notation calculator.
&gt; It's not a scheme or lisp. What would it need to become one?
To make something a lisp you ask an important epistemological question. What makes a lisp a lisp? Is it parenthesis? Some people posit that Dylan is a lisp. Yet is isn't a parenthesis delimited polish notation calculator. I think it's a cool project but I think it's more for r/go or r/coding or r/programming. 
The reason why people posit that Dylan is a lisp is two fold: * It has a homoiconic representation of syntax via [DExprs](http://people.csail.mit.edu/jrb/Projects/dexprs.pdf). This is not necessarily a big deal, since CGOL, Reduce, &amp;c. are *lispy* sans homoiconic representations. See the Dylan Reference Manual ch. 14 for macros implementing core forms. * It was originally expressed in S-Exprs, only changed to the "Algol-like" representations because of fears that the public wouldn't like it. This tradition is continued by [Goo](http://www.googoogaga.org/) and [RScheme](http://www.rscheme.org/rs/), amongst others. Still, you are correct about the epistemological question at hand, and it certainly *isn't* the parenthesis (recall that Lisp was supposed to use [M-Expressions](http://en.wikipedia.org/wiki/M-expression) originally). 
&gt; What makes a lisp a lisp? Presumably you know and you aren't telling me, because you can say that what I have made isn't. Are you going to let me in on the secret?
I assure you I am not keeping a secret. However, one thing I'd be interested to find out in your research would be how adequate goroutines are for implementing continuations.
I was just going to ask /r/scheme about this. Thanks.
No Problem :)
Great to see this. Thanks. Reminds me of this great line I read [at vontenegro.org](http://www.ventonegro.org/2010/01/babel-syndrome/): &gt; I just hope that they keep in mind that even the gods will fear us if they succeed at producing a report (or reports) that the vast majority of us like 
Favorite feature, anyone? :)
Speedup in floating point operations
I finally got it to build with our school's ancient mingw toolchain.
I found this in my ~/to_read and thought it was a peach. I noticed that the `transcribe` function contains the line `((macro-transcribeer mac) exp rename compare)))`. Does this mean that it could be used as a common base for both syntax-rules and say explicit renaming macros? How do the schemes that proved ER macros do it?
Nice and clear. Also interesting point about concurrently expanding macros with compilation / interpretation -- probably shouldn't work with procedural macros, though.
Cool, I read that paper yesterday and was surprised how easy it seemed. I felt a bit of the SICP-magic.
The text: If the WGs display some guile in pursuit of the gambit they've embarked upon they can PLoT a great future even if they are bit chicken about fexprs. If they fail, nobody will accuse them of larceny for robbing Standard Scheme of a promising future since, as it stands, chez lambda is in rough shape anyway. I don't mean to be gauche but they should be cautious about letting some kind of Stalin start taking over the process but I don't suppose that any of the members are really SCuM at the end of the day and if the WGs don't get stuck in any Rabbit holes they can grow from chibi into a mighty Oak(lisp).
Aw, man, author could've fit MIT in there (honestly, how many ways can you sneak MIT into a sentence?).
I love this comment: &gt; The community of scheme programmers was *REALLY* hurting for a module system, the one in R6RS appears good enough, and at this point I think most of the people involved really want to put the pain of arguing about module systems out of their minds. First Class Environments are a stillborn idea in that reality. A language in which environments are first class is not a language in which modules can be meaningfully standardized in a way compatible with the restricted compromise of module definitions that people are now desperately clinging to. &gt; To use a metaphor, a drowning man doesn't want a build-your-own-boat kit, even though he might learn a lot more about boats and naval architecture from getting one; he wants a boat. And a formerly-drowning man who now has a boat, has no room aboard for the kit and will rightly reject it for fear that its weight will upset his boat. 
Excellent :)
;-)
I do not understand the 2nd sentence of the first paragraph, at all. However, the metaphor makes sense. It's astounding and sad that Scheme still doesn't have (AFAIK) a community-agreed-upon module system, so that a "CSAN" can start growing. This is a WG1 task, correct? Have they made any decisions on this yet? 
by the second sentence, he means that okay, your drowning man didn't want your boat kit, he preferred the guy who gave him a boat of some sort, even though it wasn't the best boat possible. but now that he's safe within a boat, and you're trying to push your boat-building kit on him when he has the leisure to contemplate it, he *still* doesn't want it, because he's already safe within a boat, and your kit might overwhelm it and leave him back in the water.
also i don't think there's been any real progress towards a CSAN yet, sadly :( i keep waiting for it to happen, too.
Thanks, zem. What does "first class environment" mean? 
roughly, an "environment" is a set of bindings of variables to values, and a "first class environment" is on in which you have the ability to manipulate these bindings themselves as objects. [this blog post](http://funcall.blogspot.com/2009/09/first-class-environments.html) has a far better explanation.
[Nausicaa](http://github.com/marcomaggi/nausicaa) is an attempt at something similar to CPAN for R6RS; Before that there was [SNOW!](http://snow.iro.umontreal.ca/), which never really caught on. The issue before R6RS was that the spec was so minimal, that you couldn't even rely on anything other than the most basic things to be similar across systems. This led to things like SLIB having loaders for each Scheme system. R6RS fixed this somewhat, but it wasn't adopted nearly as universally as R5RS was. R7RS hopes to fix this with the dual WG approach (and forcing WG2 to maintain a modicum of compatibility to WG1), so hopefully R7RS + something like Nausicaa will bring us close to a CSAN.
Dammit the upgrade screwed with my SICP module installation.
I see no evidence of this.
Interesting - I read this a few years ago when I was learning Scheme, and it was totally opaque to me. I haven't written much scheme since then (but lots of Emacs Lisp) and now it makes sense.
s/\\..*/ [ps]/
Are you saying I should have put the post script alert earlier in the title? Sorry for that. At least it won't load the Adobe Acrobat Reader for our friends stuck on Windows.
Heh, what I was saying is this: $ sed -e "s/\\..*/ [ps]/" "Threads Yield Continuations". - You probably know that Continuations can be used to implement something resembling threads; but did you know that threads can, in turn, be used to implement something resembling continuations? [POSTSCRIPT ALERT] "Threads Yield Continuations" [ps] 
I don't think that your example is the right way to demonstrate lexical vs dynamic scoping. Indeed, I think that the first behaviour you describe (returning `(4 . 3)`) should happen regardless of scoping. (EDIT: But I'm [wrong](http://www.reddit.com/r/scheme/comments/bvpqk/question_about_static_and_dynamic_scopes/c0otssr).) My Scheme is not sufficiently up to date for me to type it off the top of my head, so here's what may be a better example, but in Perl: { # Curly brackets introduce a new level of lexical scope our $j = 2; # 'our' introduces global variables, which are essentially how we achieve dynamic scoping # EDIT: But the 'essentially' there hides an important point, as pointed out below. sub f { return [ $_[0], $j ]; # $_[0] is the (un-named) first argument to f } } $j = 3; f(4); # =&gt; [ 4, 3 ] illustrates dynamic scope, as opposed to { my $j = 2; # 'my' introduces lexical variables sub f { # Same as before } } $j = 3; # A completely different $j ('use strict' would reject this) f(4); # =&gt; [ 4, 2 ] EDIT: Indicated where we introduce a new level of scope.
&gt;Indeed, I think that the first behaviour you describe (returning (4 . 3)) should happen regardless of scoping why is that exactly? My thinking was that j would be bound to 3 when applying lambda (j) which then returns a function lambda (k) and we pass out of the scope of the j 3 binding and the binding should disappear? leaving only the binding caused by the application of lambda(k) to 4 i.e. k 4 I guess with your example of implementing dynamic scope as global variables, variables are declared globally and persist even when you pass out of the defining scope. I'm not sure if that's exactly the same. wikipedia defines it as follows: &gt;With dynamic scope, each identifier has a global stack of bindings. Introducing a local variable with name x pushes a binding onto the global x stack (which may have been empty), which is popped off when the control flow leaves the scope. Evaluating x in any context always yields the top binding. which is what led me to believe that it would fail in this case. I don't know for sure though. http://community.schemewiki.org/?dynamic-scope &gt;Scoping rules describe how the interpreter identifies the particular binding that is to be associated with a variable reference. Under lexical-scope, which is what Scheme follows, the interpreter searches in textually (or lexically) surrounding definitions (lambdas and lets). In contrast, dynamic scope dictates that the interpreter search in the frames of functions that called the function in which the variable reference appears. Which again makes me think that when the parent function application completes and returns a function, the stack-frame associated with that function disappears, so those bindings should be invisible. 
So I decided to google something different this morning and what do you know there is a newLISP dynamically scoped version of lisp in existence woohoo :) http://www.newlisp.org/ Running my code in it returned (4 nil) which apparently is how it deals with undefined identifiers in the global scope. i.e. return nil instead of crashing for binding not found. So it's working as I expected. Anyway thanks for taking the time to respond :) TIL: that's it's a good idea to look for lisp articles when trying to solve scheme problems 
Sorry; I'm so used to currying that I couldn't get my brain to see any difference between `(lambda (j k) (body))` and `(lambda (j) (lambda (k) (body)))`, which kept me from realising that, as you say, the "inner lambda", once returned from the latter, wouldn't be able to 'see' the binding for `j` any more. Thanks for clarifying! EDIT: Subjunctive.
scheme without a highlighting editor is brutal ^_^ especially when you remove the lexical scoping/closures which yields currying and you don't know which way is up anymore
Some schemes support dynamic binding by the "fluid-let" form. If your scheme implementation does, you can play with it. 
&gt; My thinking was that j would be bound to 3 when applying lambda (j) which then returns a function lambda (k) and we pass out of the scope of the j 3 binding and the binding should disappear? You're correct. The most concise explanation of this is in the wiki quote you gave: &gt; dynamic scope dictates that the interpreter search in the frames of functions that called the function in which the variable reference appears. When the outer application occurs, i.e. when (lambda (k) ...) is applied to 4, there is no binding for j in the calling environment. This means you're either going to get an error when j is referenced, or a default value like nil, depending on how the interpreter is implemented. In the old dynamically-scoped Lisp days this was called the [upwards funarg problem](http://en.wikipedia.org/wiki/Funarg_problem).
wow... neat didn't think of the change in scoping rules as a means of solving that problem 
In the Lisp world, solving the funarg problem was one of the main arguments used to promote lexical scope as a better alternative to dynamic scope, and a big part of why local variables in Common Lisp ended up with lexical scope. There are other good reasons to prefer lexical scope, though. Dynamic scope is harder to reason about in general, because reasoning about dynamic properties of programs requires simulating the runtime behavior of the program. In contrast, reasoning about static properties can be done based on static analysis of source code, which is easier to do in general. This means that dynamic scope doesn't make for a good default in a language with higher-order functions, but it can still be useful in some cases, which is why most serious Lisp &amp; Scheme dialects offer optional dynamically scoped variables. 
No, I don't know.
There are only two implementations of `syntax' that I am aware of: the one in psyntax and the one in PLT Scheme. You could take a look at those. Since `syntax' needs primitive access to the expand-time environment, there's no need to go through portable abstractions like parameter objects -- the necessary parameters can just be passed as function arguments, threaded through the syntax expansion. At least, that's how psyntax does it.
That isn't how `syntax' is implement in PLT Scheme. First, `syntax' is a macro, not a function. Second, it operates at expansion time, and so can't use parameters. Roughly, the implementation of `syntax-case' binds all of the pattern variables to special values that `syntax' then looks up and uses to construct the template. You can see the implementation here: http://svn.plt-scheme.org/plt/trunk/collects/racket/private/stxcase.rkt
&gt; That isn't how syntax' is implement in PLT Scheme. First,syntax' is a macro, not a function. Second, it operates at expansion time, and so can't use parameters. That is a good point about expansion time. I didn't explain it well in my original post. I meant that as it is expanded, it calls a function in the expansion-time environment. I thought the expansion-time environment had access to all of scheme, so that one could use parameters if one wanted to. &gt; Roughly, the implementation of syntax-case' binds all of the pattern variables to special values thatsyntax' then looks up and uses to construct the template. &gt; You can see the implementation here: http://svn.plt-scheme.org/plt/trunk/collects/racket/private/stxcase.rkt Thanks, I will have to study that code.
&gt; Since `syntax' needs primitive access to the expand-time environment, there's no need to go through portable abstractions like parameter objects -- the necessary parameters can just be passed as function arguments, threaded through the syntax expansion. At least, that's how psyntax does it. I don't know if you're familiar with [Syntactic Abstraction: The syntax-case expander ](http://www.cs.indiana.edu/~dyb/pubs/bc-syntax-case.pdf). In that paper, the expander has two environments, the run-time and meta (expansion-time) environments. So, could I just add a third environment for pattern variables in order to support the full-featured syntax form? Syntax-case would extend that environment with its input patterns and "syntax" would read from it to build the output patterns. I guess adding another environment should have been an obvious thing to try after I read the [Macro-by-Example](http://portal.acm.org/citation.cfm?id=41632) paper, since it uses an environment to store the pattern variables. They derive a compiler for the macros in that paper, which avoids creating environments as much as possible. Maybe environments are not actually built in the syntax-case implementations as well. But I think I'm going to try to find the simplest possible way to do it that will produce correct results. Building from there, I hope to eventually understand the real world implementations. &gt; There are only two implementations of `syntax' that I am aware of: the one in psyntax and the one in PLT Scheme. You could take a look at those. I found psyntax at one point, but found the code hard to follow, since I have no conceptual idea of what it is doing. I tried finding other implementations, but they all seemed to be based on psyntax. Then I searched for discussions about implementation ideas, but couldn't find anything. I guess if I really want to understand them, I'm going to have to work my way through the source code of these two implementations.
&gt;I thought the expansion-time environment had access to all of scheme, so that one could use parameters if one wanted to. The expansion-time environment does have access to all of Scheme. Therefore, communication between `syntax-case` and `syntax` could be implemented with mutation, for example. That would be much less nice than using binding, however, For parameters, it still wouldn't work, since the code of the `syntax-case` macro returns before `syntax` is run, meaning that the parameter value would go away before it could be used. 
Presumably it is simply part of the general reddit kablewey that's happened recently.
&gt; Note that the source of Chibi Scheme, concatenated, is smaller than S7, while delivering standard R5RS macros. Chibi Scheme also comes with a module system.
What is a kablewey :)? Seriously, do you have a link to some kind of overview of this problem?
\*blinks\* you didn't notice that over last week or two reddit had severe problems, including some stuff being lost from some users, among other things? I'm not a reddit admin or anything, and, IIRC, they'll eventually put an explanation of what the heck happened on the reddit blog, but apparently something went horribly horribly wrong. There's comments, complaints, posts, etc about it scattered all over reddit.
And now they've given some [info](http://blog.reddit.com/2010/05/reddits-may-2010-state-of-servers.html)
Thanks! I only use the Scheme reddit, so hence my ignorance.
code can be found on [github](http://github.com/hackinghat/misc/tree/master/xl-gambit)
Wow. I have written some COM automation wrappers myself, but looking into your description, driving Excel seems to be vastly more complicated. 
 checking whether usleep is declared without a macro... yes ./configure: line 20215: test: -lt: unary operator expected ./configure: line 20216: test: -eq: unary operator expected ./configure: line 20252: test: -lt: unary operator expected ./configure: line 20253: test: -eq: unary operator expected ./configure: line 20306: test: -lt: unary operator expected ./configure: line 20307: test: -eq: unary operator expected ./configure: line 20360: test: -lt: unary operator expected ./configure: line 20361: test: -eq: unary operator expected ./configure: line 20397: test: -lt: unary operator expected ./configure: line 20398: test: -eq: unary operator expected ./configure: line 20441: test: -lt: unary operator expected ./configure: line 20442: test: -eq: unary operator expected ./configure: line 20488: test: -lt: unary operator expected ./configure: line 20489: test: -eq: unary operator expected checking for ptrdiff_t... yes 
Hm, not sure your comment came out right; perhaps try mailing bug-guile at gnu.org, which is of course a better medium for reporting bugs? :)
If you hover over the download image, it says 'Download PLT Scheme'. Confusing! #1
Congrats to PLT folks for what looks like a lovely release. So, obvious question: can all Scheme implementations claim to be their own languages now? After all, it is rare for a program written for X to run without modification on Y.
If Guile can be used to write standalone programs, the announcement (and the Guile homepage) should say so. They make it sound like it can only be used if embedded in a C program. 
Regarding terminology, what does "PLT" mean? Aside: the [PLaneT](http://planet.racket-lang.org/) page still says "PLT Scheme". 
&gt; Regarding terminology, what does "PLT" mean? PLT is the name of a research group; see here: http://racket-lang.org/people.html &gt; Aside: the PLaneT page still says "PLT Scheme". The Planet page is being worked on at the moment.
The GUI still looks like ass on Ubuntu. Is there a way to make it consistent with the rest of the GNOME interface?
This is being worked on. Currently, the GUI libraries are derived from forked versions of an ancient toolkit, but they're being rewritten to use modern toolkits via the FFI. 
Thanks. Is PLT an acronym? If so, what do the letters stand for? Also, the [Community](http://racket-lang.org/community.html) page has a "PLT Scheme Inc." heading. Is that a real incorporated company? 
I can't recall the exact details, but I believe there were a situation, where it was simpler if a company existed. Maybe trademark related? The explanation can be found in the mail archive - somewhere... Edit: Sam is right, it was copyright related.
In CS it normally stands for Programming Language Theory. Here is a quote from Matthias Felleisen: When the team formed originally at Rice, the letters PLT were partially created as a joke but many of you are either out of context or too young to know. To be safe, we made up some long hand at the time, but over time the letters have lost their meaning. But, for anecdote's sake: when we were still at Rice, we were referred to as the "theoreticians" by the system's wing of the building, even though the PLT Scheme distribution contains more lines of C++ than anything they had built for distribution and it had more downloads than anything else there. -- Matthias P.S. The existing Rice "PLT" has no connection to this PLT.
PLT is not an acronym, just a name. It doesn't stand for anything. PLT Scheme Inc. is a real company, but it doesn't do much other than hold some of the copyrights. It doesn't make anyone any money.
This is now fixed. Thanks!
Thank you!! Where can I read more about this?
Can you say which modern GUI toolkit will be used? 
This status update is from january: http://www.mail-archive.com/plt-dev@list.cs.brown.edu/msg01992.html The context: http://www.mail-archive.com/plt-dev@list.cs.brown.edu/msg01477.html
See the links soegaard posted.
Can you say whether the rewritten GUI library will be backward-compatible with the current one? 
Fine. Now the reply to a complaint such as "My code written in DrScheme/DrRacket cannot run on xScheme" (where `x' you know stands for the name of various other Scheme implementations) is simply "It's supposed to be", ;)
Guile has always been able to write standalone programs. Run them, rather; one usually writes in Emacs ;-) Point taken regarding "standalone program", I agree the message is not being sent very clearly...
The release of Racket doesn't change anything in this regard. The Scheme standard (R5RS or R6RS) is a minimal standard (R5RS is very minimal, R6RS is larger). A language implementation that implements the standard is normally called a Scheme implementation. If a program uses nothing more than what is described in the standard, the program works in all Scheme implementations. But, since the standard is minimal, all popular Scheme implementations implement more than the just the standard. Some extensions are de facto standards and others are not. If a program uses an implementation specific extension, there is no guarantee that the program will run in another Scheme implementation. (Note: Porting a program from one Scheme implementation to another is considerably easier than porting, say, a Perl program to Ruby). The tension here is between easy portability versus exploration of different implementation choices for language features/libraries. The various Scheme implementors have various views on what to focus upon. 
Yes, that's the plan. Since the work isn't done yet, it can't be guaranteed, but programs using the current interface shouldn't need to change.
Interesting. Thanks, though I don't get the out-of-context joke myself. BTW, formatting note: to blockquote Matthias's quote, start each paragraph of it with a '&gt; '. 
The PLT people have been saying that for ages, that when one's using it one's not programming in "Scheme" but in "PLT Scheme" (used to say stuff like R5RS is a core that one builds a language around), IIRC.
Hasn't it been that way for a long time? (If not in name, in practice.)
This particular issue has been resolved, but if you notice anything missing in the future, don't hesitate to message us moderators.
They are right to say that, but Chicken and Gambit and Guile programmers can say the same thing, and none of those groups say e.g. "Gambit is a programming language".
Turned out to be this: http://article.gmane.org/gmane.lisp.guile.devel/10470
Why should one hack on this instead of the considerably more mature [IronScheme](http://ironscheme.codeplex.com/)?
For one thing, it's a completely independent implementation from IronScheme, so it may be closer to (or further from) your needs. You may find it worth a look unless you are already considerably invested in IronScheme. For another, since it's a younger project, you have a greater chance of making a difference.
Also, as long as you're rolling with the GPL, why not v3+?
Actually, I would have preferred v3, but Codeplex didn't have it as an option. I went for "v2 or later" so you can use v3+ if you like.
&gt; For another, since it's a younger project, you have a greater chance of making a difference. Of, what is basically reinventing the wheel. Sorry to say that but so far there aren't any compelling arguments yet for Sunlit Wolrd Scheme. (OT, but I had to smile seeing your nicks - "Daemmerung" and "Sunlighter" - both "light"-themed)
I don't find the "you must contribute to what others have started" argument very compelling. It's certainly not as fun as building it yourself. However, I think you and Daemmerung do have a point: while anyone can make a Scheme at some point, you have to have a good reason to convince others to be interested in hacking it.
Requires visual studio 2010 professional to build? "source and binary download" is only source? I t looks interesting and like you put a lot of work into it. I use the windows sdk, though. It does compile with the NEW sdk. You really should change those statements.
What we really need is some kind of Scheme Census, any takers?
Agree strongly! If I'm interested in a Scheme for scripting these days, I'm more likely to consider Alex Shinn's ChibiScheme. If I want/need something compiled closer to the metal, I'm more likely to reach for Bigloo or Gambit. All of these have/lean toward R5RS compliance with far fewer warts. There's also Ypsilon, but I've not had any real experience. With such mature and rapidly maturing candidates and also very strong offerings in the Common Lisp arena (e.g. SBCL and CCL), you'll need to do some very fast dancing to convince people Sunlit World is worth hacking on. It is perhaps a better use of your intellectual skills to code "batteries" for one or more of the excellent systems already in existence. All this is not to deny the pleasure of crufting a language up for hack value, but using that learning to fill an actual void seems a better use of a life.
There's a version adapted for R6RS as part of [wak](http://gitorious.org/wak/wak-prometheus)
There's also an egg available for [Chicken Scheme](http://chicken.wiki.br/eggref/4/prometheus) along with a SQL persistence manager called [pandora](http://www.chust.org/egg4/pandora.html). I haven't needed pandora, but the prometheus egg is a joy to use.
Found on [twitter](http://twitter.com/oniroi/status/17276071066), apparently it's a first year project.
Note that this is a video *about* teaching introductory programming using Scheme, not a video *teaching* introductory programming using Scheme. Also, Mr. Feldman got it wrong when he said UC Berkeley no longer uses SICP. That's just crazy talk.
Thanks for pointing that out!
It was interesting to watch, since I'm going to teach SICP to high school freshmen this fall, with PLT scheme or "racket" as the environment. If you have any advice, I'd gladly listen.
Don't get lost at the beginning and keep at it is my advice
Thanks, I'll tell you all in November how it's going.
SICP isn't at all appropriate for high school freshmen. Nevermind the fact that many *college* freshmen aren't ready for it.
I disagree in two ways. First, the beginning if SICP is very simple. Test for prime numbers. Calculate powers of integer with multiplication. If you're not ready for that, you're not ready for any CS. Second, I have a few aces in my sleeve. I'm a homeschooler, and in my experience homeschooled kids act about 5 years more mature than others. The school is a small startup, founded by parents who dislike regular school standards and want something better. Also, this is an extra curriculum class. I only get students, who are actually interested. In my experience, after teaching 101 classes for freshmen in college, makes the biggest difference of them all. As I said, I'll post how it's going. 
One of my favorite papers, as a scheme implementor. Full of insight, humility, and humanity.
I'm assuming that since I was able to get a directory listing of the source code with a .tgz file, I won?
Perhaps for full call/cc support :)
From my (limited) experience with gambit and comparing the two for game development purposes (so only doc / mailing list / blog posts for chicken): Chicken has a nice gem/cpan/etc repository for code and is better documented. Chicken has a copying garbage collector. Automatic FFI Chicken doesn't seem as focused on speed as the other schemes in the Scheme -&gt; C area (Bigloo, gambit and the others). Gambit has almost all of it's documentation inside of it's mailing lists (when you start to do the crazier stuff, it seems like it's a requirement). Comes with an infix mode. Fairly fast and knowledgeable responses on mailing list to questions you have however. Nicer garbage collector for game dev purposes (Not copying or generational, but can't remember the name of its particular GC at the moment). It's module system is still pretty early, and doesn't seem to have Scheme-&gt;C support well support (does have interpreted well supported however). Snow doesn't have all that much in it. Really easy to embed straight C/C++ code into your scheme when needed. The flags gambit has allows you the ability to optimize your numeric scheme code without having to leave into C/C++ land (but it's easy to if needed). Nice IDE with JAZZ Scheme (You can just right click arbitrary parts of the UI and start editing the scheme code that backs it), because the natively supports gambit. Jazz scheme compiles to gambit, and is a good alternative. It compiles to gambit-c, and features gradual type annotations, module system, a couple object system, a MVC-based UI api. Also is used to make software (they have used it for contracting for the past 10-15 years or so. http://www.jazzscheme.org/
Gambit's memory handling is a bit more complicated than first appears. It has three types of memory objects: * movable: handled by a copying collector. This is where Scheme objects live. * still: handled by mark'n'sweep. Objects allocated on the C heap live here. * permanent: live forever, so no GC. I think it'd be nice if Gambit had a generational GC -- all the necessary ingredients are already there -- but for now it seems game devs make do by shoving as much data as possible in the other two pools. Of course, game devs try to minimize allocation anyway, so not much change there. Also, be careful with Jazzscheme. It's a complex beast targeted at business apps. If you're going to write games, it'd probably be easier to write your own bindings to C libraries.
I used Chicken quite often before, plus did some playing with Gambit, and found Chicken interface (toward new users) much more friendlier than Gambit's. You have a much larger repository, which is quite well maintained, documentation is also very good (sans missing details about details in embedding) and (3.x feature) you had already precompiled Linux/Windows binaries (not sure why this is not done for 4.x). I always feel lost when I open Gambit page ;) On other hand Jazz Scheme (as other guys noted) is quite complex environment with a lot of potential and (IMHO) huge drawback: lack of documentation. If author made it a little bit more stable and do something about documentation, Jazz popularity would rise a lot, bringing new contributors and speeding up development and releases.
his problem is that he's mostly using jazz for actual, paying work, so it solves his immediate problem and doesn't leave much time for documentation :( i agree it has a lot of potential if it can get good docs and a user community behind it.
"Nearly R4RS compliant." I think there is even a nearly R4RS compliant Scheme in Emacs Lisp, dude. 
Fantastic!
For all those that want to know what cosr does: http://lists.moso.com.au/pipermail/impromptu/2008-August/000085.html
&gt;cosr requires that a beat symbol be available within the current environment (i.e. scope) so is usually used inside a callback routine that passes beat as an argument. So the macros in his scheme impl aren't hygenic?
It is a modified [TinyScheme](http://tinyscheme.sourceforge.net/home.html) under the hood.
SEGFAULTs in Cygwin at tmpcomp step. *le sigh* I'll try OpenBSD &amp; Linux later when I get home.
i looked through the docs but couldn't find any answer - is there any concept of packaging or deploying an app, so that a basic stklos installation can run it? or will anyone wanting to use it have to install all the dependencies?
Just how badly can they screw up the transcript? 
Awesome! I have to check this out soon. I agree totally with him. The Haskell tools were what kept me active at trying to learn the language. They just made so many things easy. I would have dropped Haskell far sooner without them.
&lt;grateful&gt; It's about time we had a working portable packaging system for R6RS. It will hopefully act as a place we can point to for scheme code rather than referencing a series of github/launchpad/sourceforge urls. &lt;/grateful&gt; &lt;ungrateful bastard&gt;Your ffi/process/filesystem seem less complete than spells, so I guess we'll need to get rotty to package his up for ucl. &lt;/ungrateful bastard&gt;
I haven't dove into the code yet, but does your `depends` form allow (depends (foo bar) (foo baz) (quux zot)), or would I have to do (depends foo quuz) and does it support version constraints similar to the r6rs library form? I ask the former because some library sets like the SRFIs have been developed separately and otherwise a gatekeeper would need to be found instead of it just being released by the author. The latter is just convenience *EDIT* Oh I see, the depends form specifies a package, not a r6rs library form. If I had a library called (foo bar) I could just call the package something like (package foo-bar) and then use (depends foo-bar)
Exactly right with the edit, but to clarify on version constraints: The 'depends' form can take something like '(package foo-bar)' as well as just 'foo-bar', and anything after the name is currently ignored. I plan to add version constraints in there eventually, like maybe '(package foo-bar (&gt;= (1 2 0)))' or something. But no version constraints yet, sorry.
Thanks! I hope to contact some authors of popular libraries about getting their stuff packaged up. Any suggestions? Compared to Spells, what features exactly does my FFI seem to be missing? Mine consolidated all the 'pointer-*-ref' functions into a single one, and did the same for setters, but otherwise the functions seem to almost be the same, and any that aren't, like 'pointer=' or 'pointer+' can be built on top of the ones I exported. The process library appears about the same, it just offers a couple of convenience functions 'call-with-process-input/output' and some to split up process output. But yeah, Spells is definitely on my "contact the author about packaging this up" list. Although I'm not sure how successful I should expect to be, given that the author is the same guy who's been working on Dorodango, another Scheme package manager implementation.
If we can get [marco maggi](http://github.com/marcomaggi/nausicaa/), [eduardo cavavos](http://github.com/dharmatech), and [derick eddington](https://code.launchpad.net/~derick-eddington/scheme-libraries/xitomatl) to package up theirs it would help reduce the amount of duplicated effort. [wak](http://gitorious.org/wak) is also really useful, and shouldn't take much effort. As for spells, I imagine Rotty will cooperate I retract the ffi/process remark, I had only skimmed them quickly. *EDIT* In particular, it is probably a good idea to get either the portable srfis or surfage packaged
Thanks for the suggestions. I just finished emailing them.
Disclaimer: I'm the author of Dorodango. Another attempt at a package manager is [Dorodango](http://rotty.yi.org/software/dorodango/). There's no release yet, it works on fewer Scheme implementations than UCL, has no web interface, but is more featureful FWICT. Let's see if Will and me can join forces...
You can use the [(require ...) form](http://docs.racket-lang.org/quick/index.html#%28part._.Modules%29) to pull in other PLT Scheme files. However, while you're learning Scheme, I recommend re-typing instead of importing. It's good for your muscle-memory! Incidentally, "PLT Scheme" [is now "Racket"](http://racket-lang.org/new-name.html).
Do you want to write Racket libraries or R6RS libraries?
While the other posters are talking about making a PLT/Racket library, it's worth noting you can just throw your definitions in a file and `(load "them.scm")`, assuming PLT isn't being weird and abandoning `load` or anything.
R6R2 libraries I guess
This is what I needed! It doesn't work with the sicp package I used with Dr.Scheme (neil/sicp), but I downloaded the new "Racket" and this has build in support for sicp, and here it works like you say =) Thank you. Why is it so simple and yet I couldn't find on google how to do it. Maybe I used the wrong keywords :-s
Are there videos of the talks available somewhere?
load is right up there with defmacro in my books
Great article, in spite of the title.
Interesting article, but the only way to make sense of his title is if "faster" referred to how long it took to implement his code.
In the end, he translated it to C anyway. I'm not really sure what that means in this context, though.
he was basically manually compiling his scheme code via c
I wonder whether he could have used Gambit or Chicken nowadays to do the same in less work. Nonetheless, great read.
There is a nice article written by Mario Goulart http://call-with-hopeless-continuation.blogspot.com/2010/03/lies-damn-lies-and-benchmarks.html Albeit being written in Portuguese it is quite readable and the code is international :)
DEC's Scheme-&gt;C compiler has been around for quite a lot of time though (1989 iirc), and provided decent performance (though I've not used it for quite some time). Plus, Stalin is like the grand old uncle of Scheme compilers; there are many stories about his antics in his youth, but now people just talk about him when he's in the room. The point being that there have been Scheme compilers since RABBIT, but not many people *necessarily* know about them :'(
Also, you can learn today that [sigscheme is a replacement interpreter for the UIM one](http://code.google.com/p/sigscheme/). :D
Great article! But I'm biased. ;-) With the little free time I have, I'm plugging away at graphics code in scheme (having forsaken haskell). I'm a graphics noob, but post up if you have something you'd like me to cover. Right now in the queue I have a boilerplate test for sdl, opengl with shaders that should be 2.x+ and ES compatible. I'm also in the middle of a basic roguelike engine using opengl for 2d stuff.
In my limited free time I'm working on a game in scheme, so its interesting to me to read how others are approaching things. We need more scheme advocacy, feel free to write more!
A bit off-topic but what's the difference between Gambit Scheme and Chicken Scheme? I know that both generate and link to C libraries. I know a bit of Scheme, and I'd like to write games with the SDL, but C++ is more and more annoying. Edit: I'm [a retard](http://www.reddit.com/r/scheme/comments/cs4rp/what_are_the_main_differences_between_gambit_and/).
I've used chicken in the past and it has been okay. A few years back, it was kind of a hassle using the egg system because things would just break and I'd be SoL if I didn't keep a copy of the old egg around. This was for a web server using spiffy and a few other eggs. It just seemed that one of the dependencies were always breaking. Naturally, the problem could have been me. YMMV. I'm currently using gambit because I have dreams of making iphone/ipad games and it has been done before with gambit. So far it has been okay, though getting though the FFI had some rough parts for me. Supposedly gambit generates faster code too... Overall, I like both systems.
Love the image of the chicken
Neat :)
Cool stuff :) Maybe I should replace SCIM by UIM, just to use even more awesome technology underneath.
Well, [per Wikipedia](http://en.wikipedia.org/wiki/Smart_Common_Input_Method#Goals), SCIM *has* bindings to UIM, since 2007. 
Am I the only one who thinks they secretly don't want to release 2.0 ;)
Perhaps in the Emacs tradition they want to drop the major version number. Then it would be *9.12!*
You can only so often release a big "new" .0 version. So if they're taking their time to polish and building up expectations, I'm perfectly fine with that. ;-)
I wish the author had included some of his code.
The essence of the transformation he's talking about is explained [here](http://www.cs.indiana.edu/hyplan/dfried/mex.pdf) (PDF) and [here](https://www.cs.indiana.edu/cgi-pub/lkuper/c311/_media/reg-tramp.pdf) (PDF)
Not sure why you would post this to /r/scheme...
I never used it for web development, but I did use a Dashboard version so that I could always have a REPL open at work, even if only for minor things. 
Interesting, never thought of a such a use for it..
It was quite nice, although I never really dug into it. I wouldn't have minded being able to use XmlHttpRequest or the like for instance (which would be great for testing). 
This probably counts as a toy project, but [this](http://mol.hungry.com/) was made with scheme2js. The source is [here](http://sourceforge.net/projects/smormoed/files/smormoed/1.20/smormo-www-0.1.tar.gz/download). Much of the functionality depends on a backend server. 
[Direct link to paper, in PDF](http://www.ccs.neu.edu/scheme/pubs/dissertation-kohlbecker.pdf)
Crazy, I wish I knew more about chemistry :)
Thanks for sharing this!
&gt; how does place-circle know that d is a structure? It doesn't. You have to keep track of that yourself. &gt; does this automatically put the position of the mouse into posn-x posn-y? No. You did it manually in (make-posn x y). Apparently, (make-posn x y) takes an x/y coordinate pair and returns a position structure. (probably just a (cons x y).) The accessors; (posn-x d) and (posn-y d) takes said structure and extracts the respective coordinate. (probaly just a (car d) and (cdr d).) 
&gt; I am taking Fundies For the benefit of other readers, this is almost certainly the Fundamentals of Computer Science class at Northeastern University, the intro CS class, which is taught in Scheme.
Yeah, I can confirm this. Actually, I was just doing this lab the other night (or a similar one, dependent on if he's in the Honors class or not). Sadly, I didn't really get to that part of it so I can't exactly help you on it.
(define (place-circle d) ;; how does place-circle know that d is a structure? Scheme does type checking dynamically. This means that d could be anything and that the type is checked when the program is running and not when it is compiled. This means that the type information about d must be passed along with d. To give you and example: (define eg (lambda (x) (number? x))) how does the function number? know if x is a number or not? Well if x is a number, that information will be attached with x (different implementations do it differently). A cool thing you can try to see that d can really be anything is to use the REPL to put a value that isn't appropriate (place-circle "hello"). You should get an error telling you that a certain type was expected and a string was received. The function that signals the error is the first function that validates the input (with functions like (number?)) or a built in function (they usually validate). Hope it helps, Cheers
You should read about [encoding data in the lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus#Pairs). Think about how you would step through an example like (car (cons 5 3)). The key is that a cons cell is being encoded as a function. How do you get the data from a function? You apply it.
Like the article states, that is the pure lambda calculus implementation of the functions. In short, lambda calculus is where everything in the language is written in terms of lambda functions. I'll leave it to you to look that up. In this example, imagine a list (list 1 2 3) This is actually (cons 1 (cons 2 (cons 3 null))) In terms of these lambda calculus functions, our list looks like this (lambda (m) (m 1 (lambda (m) (m 2 (lambda (m) (m 3 null)))))) So, we know that (car (list 1 2 3)) should be 1. In our lambda calculus, it looks like ((lambda (m) (m 1 (lambda (m) (m 2 (lambda (m) (m 3 null)))))) (lambda (p q) p)) which reduces to ((lambda (p q) p) 1 (lambda (m) (m 2 (lambda (m) (m 3 null))))) p is bound to 1 and q to the rest of the list. This call to this function returns p, which is 1, as we expected. I should have used a smaller list, but see if you can do it for cdr as well. Just remember that everything in this lambda calculus is a function, so the z is both the list and a function as shown above. I know that PLT Racket (basically a Scheme) implements cons, car and cdr in C, just as the article alludes to, for performance reasons. This is why you have probably never seen this before.
This can be a little tricky to understand, especially for those that don't have practice writing in a functional way. Cons returns a function that, itself, takes a function, evaluates that function with the arguments x and y from the cons call, and returns the value. You can pass in any function that takes two values, for example: (define (my-cons x y) (lambda (z) (z x y))) (define x (my-cons 2 3)) (x +) ;; returns 5 Of course, this is practically useless on its own, but it does allow you to write car and cdr by crafting functions that return the first and second values, respectively. Car, for example, has a lambda function that takes two parameters and returns the first. This function is passed into the parameter z, which is described above, and returns the first parameter of the cons statement used to create it. I hope this is helpful.
This isn't how cons, car, and cdr are actually implemented—it's an example of how one might define them in lambda calculus.
Sure it's not, I didn't try to convey that. The possibility is still interesting for a theoretical standpoint.
Can you elaborate a bit? I couldn't get any actual Scheme implementation to run that.
The notation is a bit obscure to me, but I might invest some time in grokking it later on. When I see that, all that comes to mind is prolog's append for some reason.
Thanks for the replies. Digging a bit I think I found where does that come from, verbatim. I was looking up SICP on the subject and there you go: http://mitpress.mit.edu/sicp/full-text/sicp/book/node30.html But none of that actually works in Bigloo, or Gambit, or DrScheme (DrRacket), ... what am I missing? So... drumroll... **CHALLENGE** Can someone implement *cons*, *car* and *cdr* in terms of Scheme lambdas? (let's call them *mycons*, *mycar* and *mycdr* to try them side by side). Something that actually runs in any standard-compliant Scheme implementation. Additionally, what's your best shot at implementing *cons*, *car* and *cdr* in R4RS with no limitations at all? (doesn't have to be originally yours)
It works perfectly well. I really don't know what you can possibly be missing. $ gsi Gambit v4.2.8 &gt; (define (mycons x y) (lambda (m) (m x y))) &gt; (define (mycar z) (z (lambda (p q) p))) &gt; (define (mycdr z) (z (lambda (p q) q))) &gt; (define acons (mycons 1 2)) &gt; acons #&lt;procedure #2 acons&gt; &gt; (mycar acons) 1 &gt; (mycdr acons) 2 &gt; ,q $
Thanks for that. Bonehead me I actually didn't wait to have the three defined and tried them mixing the results with the standard version (using car on the output of mycons and so on and so forth). I see. However these are not interchangeably "compatible" with standard cons, car and cdr apparently. I guess it's extra "typing" information for the sake of efficiency? So does cons produce something that I cannot 100% create with a lambda, or is there a way? Gambit v4.6.0 &gt; (define (mycons x y) (lambda (m) (m x y))) &gt; (define (mycar z) (z (lambda (p q) p))) &gt; (define (mycdr z) (z (lambda (p q) q))) &gt; (define acons (mycons 1 2)) &gt; acons #&lt;procedure #2 acons&gt; &gt; (mycar acons) 1 &gt; (mycdr acons) 2 &gt; (mycons 1 2) #&lt;procedure #2&gt; &gt; (cons 1 2) (1 . 2) &gt; (mycar (mycons 1 2)) 1 &gt; (car (mycons 1 2)) *** ERROR IN (console)@7.1 -- (Argument 1) PAIR expected (car '#&lt;procedure #3&gt;)
It's just an implementation example that is used to make an academical/educational point. Conses are not really implemented that way, that's why they aren't compatible. I don't know if you can even implement mutable conses (i.e, `set-car!` and `set-cdr!`) with lambdas.
You need to use the pure lambda definition of cons that you posted. Or think about renaming it... (define (my-cons x y) (lambda (m) (m x y))) (define x (my-cons 2 3)) (x +) ;; returns 5
I do know that they are not implemented this way, what I didn't know is that they have some extra typing info that couldn't be replicated with lambdas (or any other way?). I mean, they didn't have to be implemented that way to be compatible... can you even call them "a different implementation" being incompatible? I'd call them "analogous" This is probably a more advanced topic related to the innards of each implementation, but can you actually create a mycar that's completely indistinguishable to car in terms of its output?
 (define (set-car! cell val) (cell (lambda (head tail) (set! head val)))
well, that's me shooting my mouth off, regrettably. That doesn't work, of course, it only mutates the binding for head inside the message lambda. the head and tail values would have to be further boxed in their own containers in order to remain settable. A lambda used to box the value has to accept a non-procedure message to mutate the value. The pure lambda calculus doesn't support mutation, since it doesn't include a concept of a memory location to set.
Oh man, I still owe you editing for the last edition (plus the microKanren book)...
I bought the previous edition and it was awesome.
Lucky us, lulu.com is running a [40% off coupon](http://www.retailmenot.com/view/lulu.com) until 15 Oct, good for up to $20 off. I had actually forgotten that I bought the first edition that Nils published on lulu, so you can take this as a vote that it sounded so interesting I bought it twice :-) But I definitely prefer the HTML flavor over the PDF, since HTML is ripe for ePubbing.
There's a preview on Lulu.com (although it requires Flash). Then there's the code at http://www.t3x.org/s9fes/. And there's a link to the first edition somewhere on t3x.org/. And I got a lot of mail from people who liked it -- but I'm supposed so say that.
Don't worry! Life's too short to look back!
I never worry, nor do I look back. I'm just laughing that the situation hasn't improved since the *last* time :D
Oh, I got The Reasoned Schemer (introduces miniKanren) from Nils. Thanks, Nils :)
Cool! Just please please authors, make a site and documentation to reflect 2010. Every time I look at most of scheme/lisp sites, they send me back to '80-es. For most people, initial language/libraries impression comes from first look at material presentation :)
Original site: https://weinholt.se/industria/
I was referring to "Logic Programming in Scheme," by NMH. Nils' book introduced "Another MicroKanren."
I linked to the FreshMeat page, since it had a concise overview of *what* Industria is; the site you link to (which says the project site is [here](https://code.launchpad.net/~weinholt/scheme-libraries/industria), with an alternative [here](https://weinholt.se/industria/)) Doesn't have that nice overview. 
[this](https://weinholt.se/industria/industria.html) is exactly how HTML documentation is supposed to look like. A promotional site is a different thing. Sadly, the web is becoming mostly promotion and little content. Here you can see another excellent site (on a different topic): http://www.ijack.org.uk/
Chicken Scheme has been forging ahead will all kinds of progress lately. * They've got their new domain name set up (call-cc.org), * their site has been moved over and revamped a bit, * nice general documentation, * wiki seems to be either new or updated. * There's the "chickadee" API docs server, * a nicely-stocked package repository ("Eggs Unlimited") -- with docs online for each package, * and now this Chicket Gazette that has been coming out once a week. Lot of action happening with this friendly and active community. 
You're not going to get any help with that vague of a question. Go to one of the Fundies tutors. (You're an NEU student, yeah?)
Thanks, yeah. I figured it out eventually though.
I don't particularly have a need to know how spiffy works, but I *love* these short little descriptions of how to use some piece of the system. I've really fallen in love with reading the Chicken Gazette. I'm surprised someone goes to the effort every week of putting it out.
Hey Alan, thank you very much for the kind words, we really appreciate them! The effort is manageable because it is a shared one -- up until now we could find a volunteer for each week and the next two weeks are also settled, so look forward to some more Gazette :-)
Great article on Spiffy!
Wonderful presentation! Reminds me that I have to get back to making some software with Gambit.
Didn't quite get how SIX works. Can somebody elaborate a bit? BTW, stunning presentation.
with blackjack and hookers
"Forget the blackjack!"
I'm excited that Felix fixed the bug I found 30 minutes after I filed the ticket. I was sitting there wondering what the heck I was going to do to work around the bug, and suddenly I didn't have to. :-)
I'm not too sure of what software to use to create one but I'd certainly be interested in seeing one made :) A common-lisp one would be great too but obviously there's only so much you can put on a single page.. :P
a quick reference already [exists](http://clqr.berlios.de/) for common lisp
Thanks! Great resource for someone who is learning (me) :)
I'd like to see [something like this](http://www.thinkgeek.com/homeoffice/mugs/7bbe/). 
Looking at this again, I'm not so sure it's a "cheatsheet" per se, but rather more of a quick guided tour of the basics. It should be easy enough to create: * create the file in Emacs, * export to syntax-highlighted html using htmlize, * open the html in a browser, * take a screenshot, * open screenshot in the Gimp, * add text + arrows, and save as a png. Would be very useful to show to people who say, "Scheme/Lisp seems so esoteric. How does code in it even look? How would I even {print to the terminal, create and manipulate a simple data structure, open and read a file, etc.}?". 
Indeed, sounds quite easy to do; the Lua one is even easier. *sigh* if it wasn't for my lack of motivation, I would do it myself…
That's an excellent common lisp reference, and I'm not knocking it. However, at 25 (A4) pages and in small type face, it's about the same size as the [R5RS](http://www.schemers.org/Documents/Standards/R5RS/) spec. 
If you know Scheme well enough to do it, then please, do one like the Lua one! Someone can surely later step forward and strip out the comments and turn them into an overlay of blocks of proportional font text with arrows. You could post something to start with right here if you like, or on a pastebin somewhere. Then maybe someone could pick up the torch and put it up on github/bitbucket/launchpad/whatever. 
Well, you do realize that the Common Lisp spec is something like [1100 pages](http://www.lispworks.com/documentation/common-lisp.html), right? 25 pages is a neat reduction of such a large &amp; byzantine spec.
I am perfectly able to put stuff on github/bitbucket/launchpad myself, I have accounts on all of theose sites ;)
Yes. Yes I do. My big toe is still hurts from that time I accidentally dropped CLtL2 on my foot. In shoes. 
Cool, I didn't necessarily doubt it, but you mentioned lack of motivation, so I thought maybe mention ways to lessen the amount of work involved. 
Here's a start. Not that directly translating from Python is enlightning. In fact none of this is what makes Scheme unique (except the syntax maybe) (load "somefile.scm") (define (displayln line) ; this is a line comment (display line) (newline)) (define counter1 0) ; top-level variable must be declared (set! counter1 2) ; before they are mutated (define main ; the name 'main' is just a convention (lambda () ; lambda defines a function (displayln "Hello World!") ; a litteral string use double quote ; you can declare a variable local to a block (let ((counter2 5) (counter3 10)) (displayln (+ counter2 counter3))) ; end of block (let ((my-list ; identifiers can contain -_?!* ; we use - to separate words '("apples" "oranges" "cats"))) ; this is a list (displayln my-list)) ; counting to ten (let loop ((i 0)) (if (&lt; i 10) (begin ; begin define a sequence of expression, ; its value is the value of the last expression (displayln i) (loop (+ i 1))))))) (define (foo param1 param2) ; another way to define a function (let ((res (+ param1 param2))) (displayln "") (cond ((&lt; res 50) (displayln "foo")) ((and (&gt;= res 50) (or (= param1 42) (= param2 24))) (displayln "bar")) (else (displayln "moo"))) res) ; there is no 'return' in Scheme, the function 'returns' the value of the last expression ) (main) ; calling function main (foo 24 12) ; calling function foo
And you aren't willing to read the [free official online copy](http://mitpress.mit.edu/sicp/)?
PDF here: http://deptinfo.unice.fr/~roy/sicp.pdf
Lot of colleges and work have free printing stations. Print a chapter at a time.
And it seems there's a [MOBI](https://github.com/twcamper/sicp-kindle) version for those of us with Kindle or other eReaders. Now, drov just needs to find someone with which to trade for an eReader.
How about a used copy from e.g. ABEBooks.com? I see one there for $16.08 (before shipping). 
&gt; I have very bad eyes (they hurt very much after looking at the monitor screen for extended periods of time) Hmm, I'm curious how you intend to make use of the information in SICP. Are you intending on embarking in the field of theoretical programming?
That's good. Because, you know, actual programming requires "looking at the monitor screen for extended periods of time".
Actually e-ink shouldn't hurt your eyes at all as it works completely different. I would recommend picking up a cheap eInk ereader, then you can upload source code, pdfs etc into that and prevent your eyes from hurting. Or wait till the Notion Ink's Adam comes out, finally. You know; Duke Nukem Forever did, so maybe... Anyway; I use an ereader for that and it really works wonders spending less time behind the computer. 
I'd love to see some hello world tutorial running on Android compiled with Bigloo
Sorry, this was caught in the spam filter. I have approved it.
These are well-known CS textbooks that you can use to teach yourself Scheme, and have free full-text online: * [How to Design Programs (HtDP)](http://www.htdp.org/): Uses PLT Scheme. I recommend this one heartily. * [Structure and Interpretation of Computer Programs (SICP)](http://mitpress.mit.edu/sicp/): Haven't read this one myself.
The Little Schemer. I bet you will love it.
I've read both [The Little Schemer](http://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992/) and [Structure and Interpretation of Computer Programs](http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262011530/) I used both [PLT Scheme/DrRacket](http://racket-lang.org/) and [Chicken Scheme](http://www.call-cc.org/) while going through the exercises. If you're a Windows user, DrRacket is the best one to use - Chicken is *awesome* but a lot more difficult to compile successfully under MinGW or Cygwin, and the ramp up time may be a turn-off to you. I don't use Scheme in my daily job, but I really enjoyed learning it and would love to use it more. It completely changed how I think about computation.
The whole "Schemer" series is actually pretty neat. I would also recommend [Simply Scheme](http://www.cs.berkeley.edu/~bh/ss-toc2.html), which is similar in vein to SICP, but a little less dense. As for implementations, DrRacket or [PVTS](http://www.davidpilo.com/pvts/) are good "beginner oriented" systems, though DrRacket allows you to grow whereas PVTS does not. I've never used DrRacket for real work, but there are quite a few people who have, and it's generally considered to be a useful suite (I used to use a plethora of scheme systems for different tasks, but now I just use my own).
Another vote for The Little Schemer series and Chicken. SICP is good for a follow-up or if you're a hardcore math geek. If you go the SICP route, make sure you watch the video lectures.
You're getting a lot of recommendations for The Little Schemer, and I'll add to them: I really enjoy these books. I'll add a caveat to that, however. When I was first introduced to them, I didn't like them at all. It didn't fit how I wanted to learn the language. If you do get them, you're taking a risk that the teaching method they use won't be right for you. I've just purchased the Scheme Programming Language as a reference book, and so far it is working as advertised, though I haven't had it long enough to really make use of it.
Structure and Interpretation of Computer Programs (SICP) isn't really about scheme. It happens to use scheme but it's more about computing than scheme. Having said that, it is by far the best instructional book I have ever read and is a must for anybody who is interested in computation.
I've been working on genturfa'i as stated in the Gazette. The size of the code generation is in some part an issue with the way chicken handles large letrec structures and mutually recursive lambdas. The other part of the issue is that genturfa'i generates a lot of mutually recursive lambdas and some truly giant letrec structures. We're still experimenting with ways to structure the genturfa'i parser generator to avoid these problems, and I'm going to experiment on other Scheme platforms to see if the problem also shows up there. It has taken a lot of compute-time and effort to get this far, the Chicken Community really amazes me with its responsiveness and willingness to look at often complex problems.
Racket: &gt; (time (fib 35)) cpu time: 883 real time: 882 gc time: 0 9227465 Typed Racket: &gt; (time (fib 35)) cpu time: 826 real time: 825 gc time: 0 - : Fixnum 9227465 Untyped, without fixnums: &gt; (time (fib 35)) cpu time: 927 real time: 924 gc time: 77 9227465
To get reliable test results, here is a few suggestions: 1. Use collect-garbage before each use of time. (Garbage left by a previous computation shouldn't penalize the next) 2. Use racket (as opposed to DrRacket). Or make sure the debugging code inserted by DrRacket is turned of. 3. Can one trust a benchmark named fib? 
&gt; Use racket (as opposed to DrRacket). Or make sure the debugging code inserted by DrRacket is turned of. It still doesn't change too much: &gt; (collect-garbage) &gt; (time (fib 35)) cpu time: 963 real time: 960 gc time: 0 9227465 &gt; (collect-garbage) &gt; (time (fibf 35)) cpu time: 953 real time: 959 gc time: 0 9227465 *Typed:* &gt; (collect-garbage) &gt; (time (fib 35)) cpu time: 957 real time: 955 gc time: 0 - : Integer 9227465 &gt; (collect-garbage) &gt; (time (fibf 35)) cpu time: 950 real time: 947 gc time: 0 - : Fixnum 9227465 &gt; Can one trust a benchmark named fib? Surely not, but in the OP's post they use fibonacci, why would I compare it to something else? *edit: added the typed one*
&gt; &gt; Can one trust a benchmark named fib? &gt; Surely not, but in the OP's post they use fibonacci, why would I compare it to something else? Sorry, I have a weakness for puns. 
How are you going to be a programmer if you cannot look at the monitor for extended periods of time?
That's pretty awesome. I look forward to the release.
I'm really happy to see an omelette recipe for creating modules. This has been the hardest part of Chicken for me to really understand. I'm using it, certainly, but I don't understand the full set of things I *could* do with it.
Nice, but why, oh why, has it to be Windows Media?
Guile is the official GNU extension language. What you linked to is the guile library which is needed by programs which use guile to extend functionality. As far as I know, it does not get special attention by Ubuntu, it's just needed by a lot of GNU programs. Examples are: autogen, snd-nox-alsa, mailutils, gnurobots or aisleriot (gnome-games) and therefore installed on nearly every ubuntu machine. I'd also say it's supported by debian and ubuntu copies it and not, that it is "Supported by Canonical".
I found it amazing that a scheme implementation, or in general, a "Lisp", which is considered to be a exotic academic language by many, is shipped by default on the installation CD of the most widely spread Linux distribution, and thus immediately available on thousands of desktops. Although it is only the libs, not the interpreter itself, I still find it a remarkable achievement for a Scheme to be, in tems of numbers of worldwide installs, on par with Perl or Python and probably dwarfing both Common Lisp and Emacs. The whole of Guile, not only the libs, is supported by Canonical in the sense that it is in the core Ubuntu repository, no only in the community maintained "Universe", and thus will be supported with patches and updates, directly by Canonical, as long as all other core packages will. 
As an extension language, guile is intended to support multiple languages in the sense that a supported language will compile to bytecode and run on the guile VM. You can check out [Andy Wingo's blog for more details](http://wingolog.org/archives/2009/02/22/ecmascript-for-guile) about how it already supports ECMAScript 3 (JavaScript). Cool stuff! Some other applications that use Guile are [Audacity](http://audacity.sourceforge.net/) (plug-ins) and [Gimp](http://www.gimp.org/) (scripts). I've written for both and it's really easy.
Eh? Gimp's extension language is based on tinyscheme and not guile. How I wish some of these projects that look for a small scheme would consider Shinn's Chibi.
umm not quite. Audacity uses [nyquist](http://audacity.sourceforge.net/help/nyquist) (which is based on [xlisp](http://www.xlisp.org/)) and as already mentioned gimp [now uses](http://www.gimp.org/docs/script-fu-update.html) tinyscheme (previously SIOD)
I read this article thinking "Wow, this ought to be in the Gazette." It was only when I got to the end that I realized the author had the same thing in mind!
I have to say thanks for this awesome work...
What do you mean slow things down? As in computing time, or code writing time? Because as I understand it, the author (can't remember his name off the top of my head) is showing dry humour by talking about how long a seemingly simple procedure took a lot longer than he was expecting, and he hopes the other authors will do the same thing. So that way he isn't dinged by being slow compared to the others.
Explanation: Author tries to use computer to facilitate physics. When writing computer programs to solve problems, discovers that he doesn't understand the problem as well as he thought he did. This is uncovered by the nature of computer programming, which is necessarily precise. Mathematical formulas, on the other hand, are often maddeningly imprecise. After writing the program he finds he has a better understanding of the problem it solves.
There's a video of Prof Sussman where he expands on the idea of programmnig as a means of expressing computation/algorithmic ideas (e.g. teaching someone how to analyze circuits by having them read/write a program that does the same). In the same video, he talks about how the standard books were "accidentally correct" in a particular problem (I forget the details). The main thing is that by forcing yourself to explain yourself to a computer, you force yourself to be much precise. This process of being explicit everywhere may slow down the process, but leads to greater clarity of thought and understanding. 
Sussman spoke on *The Role of Programming in the Formulation of Ideas* at Dan Friedman's 60th birthday celebrations: http://video.google.com/videoplay?docid=-2726904509434151616# He also co-authored a paper with Jack Wisdom on the same subject: http://dspace.mit.edu/handle/1721.1/6707?show=full
Yup that's the video I'm talking about!
(It's missing `remainder`, which does the same as `modulo`, but does the "right" thing with negative numbers) Good job! I didn't knew that r5rs doesn't allow named `let*`s
Thanks. I'm a bit confused by the "named let\*s" comment; what would named let\* do if it existed? Is there an implementation you can point to? \[Edit:fixed formatting, thx phyzome\]
I made a pocket sized quick reference; can you [[take a look](http://www.reddit.com/r/scheme/comments/f0sv6/i_made_a_scheme_quick_reference_that_actually/)] and tell me if that suits your fancy?
Oh wait, disregard that, I've just realised that named `let*`s would be pointless and that Racket doesn't have them either. Sorry.
I hate to be 'that guy', but half of this is upside-down.
so you can fold it... why else would there be a line in the middle of the page?
Wait - is that a left fold or right fold? :-) Seriously though, it makes an 8 page booklet, 4.25in x 2.75in. 
&gt; Wait - is that a left fold or right fold? :-) Just wait until you have to unfold it... &gt; Seriously though, it makes an 8 page booklet, 4.25in x 2.75in. Exactly, that's what the lines are for; put it in your wallet, next to the other forms of protection.
I forgot my &lt;sarcasm&gt;quotes&lt;/sarcasm&gt;. :)
May I suggest you [Quack?](http://community.schemewiki.org/?Quack)
Basically was just trying to see what other enhancements I can I add to emacs that work great with Larceny.
You need to escape your asterisks with backslashes.
Quack is for PLT and my implementation is Larceny
but this is a perfect time for `quasiquote` &amp; `unquote`... :D
It's for Scheme in general, and has special support for Racket.
Oh thanks alot ;)
You seem to have submitted a link to the front page of your blog, not to a particular post.
Does anybody want to start a study group for this book? Are there any video lectures? I've attempted to read and understand the book, but it was far too dense for me to tackle alone. 
I'm really happy to see a new gazette! I was sad to not see them over the last couple weeks, but I've been as busy as everyone else has. :-/ Thank you Moritz, Christian, and Felix for putting this together.
And hey, why didn't this get out on the mailing list?
We forgot :/
It has been sent to chicken-users.
I [updated the MzScheme/Racket one](http://pastebin.com/BxUCsMdS). Great link, though, too bad the site's dead after his marriage, I'd really liked to send it to him.
Pardon, but if any redditor knows, I'm most curious about the [letrec](http://web.mit.edu/~axch/www/scheme/choices/r5rs-letrec.html) test. I think I may have "figured it out", but I'm not certain. Can you say if the reasoning that follows is sound and correct? It looks like the trick is whether or not x,y are assigned in parallel, or sequentially. If the `letrec` expands to: (let ((x #f) (y #f)) (set! x ...) (set! y ...) ...) Then x will be 1 when the continuation for y's initializer is invoked. Alternately, if the assignment is intended to happen in parallel, perhaps letrec expands to something like: (let ((x #f) (y #f)) (let ((x_ ...) ; x's initializer (y_ ...)) ; y's initializer (set! x x_) (set! y y_)) ; assign in parallel (lambda (x y) ...)) Which would yield zero -- x and y were initialized to 0, then the true-condition sets them both to 1, but (c 0) will return from y's initializer expression the value 0, and the original value from x's initializer (in x_) will also be zero, yeilding a zero sum. Is the parallel initialization of x and y the correct r5rs result? I get how it could be done, but I don't understand why it ought be done that way. Any references would be appreciated. \[edit: replaced incorrect usage of call-with-values\] 
Fork it, and build on it. :-)
Bad link? It says "No such item."
I recommend deleting your previous post.
Comments and criticisms are welcome.
I'm still a little new to macros, but whats the significance of capturing identifiers?
To be honest, I'm not a fan, but I'm prejudiced against capturing identifiers in general. If I were to write a 'capturing' macro, I think I would have made it a let-like form, rather than a define-form, as it could then be introduced more naturally into templates of existing 'define-syntax's (probably something along the lines of Aaron Hsu's `with-implicit` macro). Nitpick: `syntax-&gt;datum` and `datum-&gt;syntax` are the standard names according to http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-13.html#node_sec_12.6 and I didn't see anything in the errata that said otherwise. 
I used to use Scheme to do livecoding with Fluxus. I could create programs to do what I wanted to do with some degree of ease, it'd probably take me slightly longer to do in python, despite only using scheme once a month at most. I then tried to do something 'real' with Chicken and it was here I had issues. This was partly because I'm anal and like to do things "the right way" but didn't have any experience on what way that was. But the real issue was a lack of libraries. One specific task I was wanting to do was port a program that parsed an iCal feed I had written in python to scheme. Only, I had no fucking idea how to parse iCal because a) There was a library in python to do it for me and b) I had no idea how to begin parsing a defined format in scheme. so tldr, I probably could if there was a decent set of libraries. But there aren't so I can't. 
&gt; it'd probably take me slightly longer to do in python, despite only using scheme once a month at most. Interesting! &gt; I then tried to do something 'real' with Chicken and it was here I had issues. [...] But the real issue was a lack of libraries. Hm. Out of all the Schemes I've been looking at, Chicken seems to have the *most* libraries available. Guile looks like it has a lot of Gnome-ish bindings though. I hope that when R7RS (or whatever it will be called) arrives, the community and implementors all pull together to support whatever library module standard R7 specifies. 
"Capturing an identifier" means referring to an identifier that is defined in the enclosing scope. Generally, this is a bad thing in a macro because the point of lexical scope is to ensure that every input and output of a section of code is manifest in the code itself--in other words, we use lexical scoping to ensure that when we change something it's intentional, and we can see in the code that we're changing it. Capturing an identifier most of the time means that you think you are reading or writing something that is defined in the text of the macro, but in fact you are reading or writing something that is defined elsewhere. Although this is usually a bad thing, there are some situations in which it's exactly what you want. The classic example in Scheme is set!: the entire purpose of set! is to alter something that is not defined in the definition of set!. Once in a blue moon a Scheme programmer might have a reason to want to write something that works like set!--I've had reason to want to do it myself. For example, when writing implementations of polymorphic functions, I like to have a toplevel defining macro that works like Common Lisp's defmethod; that is, a form that adds a method to a generic function, arranging to create the generic function and bind it to a toplevel identifier if it's not already defined. This is not convenient to do in Scheme, where the common approach is to separate it into two steps: (1) use define to bind the generic function to an identifier; then (2) add a method to it.
i think it's about more than just standards. I use python for a large degree of SMOP tasks. It's exceedingly convenient the number of libraries that come in a vanilla Python distribution. I needed to prototype a CGI gateway - oh look, `import cgi` and i'm halfway there, with `import urllib` bringing up the other half. I've used Racket a little lately; its vanilla library selection is nice, has binaries available, and it's portable.
I had thought about CL and Clojure but didn't bother investigating as I was using scheme for something else at the time. One thing to note about Chicken, is despite having a comparatively small library compared to Python, it's FFI tools are pretty slick. I got bindings to [inotifiy](https://github.com/xlevus/chicken-stuff/blob/master/inotify.scm) more or less working in a few hours. Shit, I need a project idea. 
See also the measurements Mario Domenech Goulart has made using chicken scheme: http://call-with-hopeless-continuation.blogspot.com/2010/03/lies-damn-lies-and-benchmarks.html
&gt; To be honest, I'm not a fan, but I'm prejudiced against capturing identifiers in general. Me too. I'll probably never use it either, but it was a good exercise. &gt; Nitpick: `syntax-&gt;datum` and `datum-&gt;syntax` are the standard names according to http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-13.html#node_sec_12.6 Well, less portability problems for me!
tl;dr: WYSIWYG macros.
&gt; R7RS Chicken for R5RS with libraries and Racket for Scheme with libraries made R6RS and R7RS obsolete and harmful, except for `syntax-case` from r6rs.
Racket has a vcal/ical library i've used to migrate an addressbook to a new phone. In the first version I used regexes to read the data. It worked, but I switched to the library for better code.
I generally am more productive when writing in Scheme. Those irritating parentheses help me a lot to abstract the problem away, without having to think about the how to make the language do that (the evil syntax).
Oh, I don't doubt that Chicken produces wicked fast binaries, but what I'm asking about in this thread is developer time, not execution time. 
In what way? In Python and Perl I use functions and classes to abstract the problem into chunks I can work with. How is Scheme any different? 
Libraries. If I have a simple abstract problem to solve, I always reach for Lisp. I prototype a lot of computations in Lisp or Scheme. When it comes to doing non-trivial library work, I often find myself using something else. Not so much because Lisp libraries aren't there, but because they are hard/weird to set up, are underdocumented, or super idiosyncratic. That said, I did develop a fair amount of software in Dr Racket at one time. It is a pretty good ecosystem, if you don't need anything outside too badly.
With side-effects being annoying to perform (like, writing every time (set! var (+ var 1))), separating pure, functional code from impure code is simple and natural. You also can't talk about abstraction and Scheme without mentioning macros and DSLs, which add an immense semantic power to the language. Instead of having a god-class/god-module which does all the magic, you end up with many small *indipendent* functions that, together, do all the work. This brings to much more clean, concise and understandable code, and you don't have the problem of giving a clever interface to every aspect of a god-class. Real world example: I'm writing an irc library in Racket, it can only connect to the server and returns an #&lt;irc-connection&gt; struct, that contains an input port and an output port. You can send your commands writing directly to the output port, you can read server's responses reading directly from the input port. But having to handle everything by hand is tedious and error-prone, so I created another two structs: #&lt;irc-message&gt;, whose constructor takes a string and returns the struct containing all the parsed stuff, and #&lt;irc-command&gt;, that takes some parameters and when (display)ed outputs a command interpretable from the irc server, respecting the 255 characters limit, splitting the command if needed. These two structures are totally indipendent from #&lt;irc-connection&gt;, but they work together, abstracting the problem of handling responses and commands. If I change something in the way an #&lt;irc-command&gt; is (display)ed, I don't have to touch the #&lt;irc-connection&gt; code.
Racket is not a scheme.
It's not called RNS's Not a Scheme. Racket is a Scheme as much Scheme is a Lisp.
&gt; if you don't need anything outside too badly. (Implying you're talking about extern libraries) What about the Racket's FFI?
&gt; Ruby 1.9 &gt; real 1m14.576s &gt; user 1m14.565s &gt; Python &gt; real 2m21.908s &gt; user 2m21.349s Alright, I'm finally switching to Ruby as second scripting language. About the Chicken's benchmark, it's not idiomatic code and not tail-recursive. When he uses the fixnum operations to speed up the computations, he still uses naive recursion. (I wrote this scrolling down the document, now I saw this: &gt; C 0m1.374s &gt; Chicken (compilado) 0m1.088s even without tail recursion, it's faster than C. I can't believe it)
I've been coding in Scheme for years, and use it in place of Perl/Python for the usual log processing, applications, &amp;c. I do quite a bit of security work in Scheme, and the requisite log file munging &amp; port scans, &amp;c. all in Scheme. I find that I work at the same speed as the other two people in the office, one of whom uses Perl, the other Ruby. Of course, I have a large corpus of tools I've grown over the years to simplify things, which is the whole point of scheme to begin with (things like an `awk` syntax to process a file and run expressions when a certain regex is matched). I would never wish to switch away from it, even though it means other people may not be readily able to grok my code. 
You don't have to beleive it, you are free to try it for yourself!
I think Racket's FFI is actually all right. I used it for something once. However, it just handles C. The problem is that things accessible from C usually have pretty low level APIs which you have to write even more glue code to use effectively. It is really hard to beat the giant pile of libraries which you just install and use in a language like Python. I don't even mean to imply there is anything _bad_ about racket in this capacity, only that it is somewhat less convenient than Python.
&gt; I have a large corpus of tools I've grown over the years to simplify things, which is the whole point of scheme to begin with Do you find that most Schemers have the same? Is it common practice in the Scheme community to put these in a public repo somewhere so others can benefit from them as well? 
&gt; Do you find that most Schemers have the same? I think it's common for most Lisp-alikes; it's not all that different from perl programmers stashing away those one-liners they use for future purposes. The only difference is that I can do something like `save-lisp-and-die` and have an image to use later, or I can add it to my prelude so that it's loaded whenever I run the REPL, or I can make little utilities (in a SRFI-22 compliant Scheme implementation) or compile them into an executable, at which point no one knows what it was written in. &gt; Is it common practice in the Scheme community to put these in a public repo somewhere so others can benefit from them as well? I don't *think* so, no more so than Perl/Ruby programmers sharing their little utilities. Things like Chicken's egg system or [SNOW!](http://snow.iro.umontreal.ca/) would help, but they have their own issues. Part of the issue is that what works in one Scheme may not work in another, and part of it is that it may really just be one-offs for the problems you're working on.
Pattern language for `syntax-rules` looks like it's missing some productions. I'm not too sure about the explanation of the equality operators (though I could hardly do better). Otherwise not a bad summary.
&gt; arranging to create the generic function and bind it to a toplevel identifier if it's not already defined I've had need for this behaviour in the past, but couldn't work out how to do the "if it's not already defined" bit.
In racket, you'd use `(identifier-binding #'id phase-level)` to know if the identifier is bound at that *phase-level* and if it's a module identifier/lexically scoped identifier.
Thanks! Is there a particular production that you use commonly that's missing? 
 ;patterns x ;variable x ... ;repetition {pat} ... ;repeated pattern I could have sworn there were more than that.
Ah, but they combine. ((let ((var expr)...) body ... ) ((lambda (var ...) body ...) expr ...) 
It isn't at all clear how that happens from those rules. No parentheses, for one.
Yeah, true. I'd like more information to explain what's going on, but I only have enough room for short mnemonics
I understand, it's relatively minor anyway. If you don't know how to write hygienic macros you're not going to be learning from a resource like this.
All I can say is highly subjective: * I find myself coding easier in scheme than Perl (I did not use Python much, although I can find my way) * Interactive developmet is a huge advantage, although Python would give you that * I find chicken scheme's FFI easy to use and this is certainly way better than Perl's, I haven't used Python's FFI but rumors say it is not bad at all So, I guess it is all up to you to try and decide.
If this is useful to you, you might consider making a chicken egg out of it, maybe it will help others too!
At least in chicken scheme, there is a python FFI available (see http://wiki.call-cc.org/eggref/4/pyffi ). Haven't used it myself. Yet. Now if we had a perl FFI egg, that *would* be great (CPAN ....). I believe ocaml did this (not sure how much its used in the ocaml community).
Isn't SCMUTILS already kind of an REPL for Scheme, at least for MIT scheme?
What, in your opinion, defines "best"?
Yes, as there is scheme-mode for emacs too. The difference is that the SLIME backend here comes with integration of chicken scheme specific tools, such as the autodoc documentation lookup or the inspection of variables in stack frames. For a short introduction see http://gazette.call-cc.org/issues/17.html
I have no clue. Substitute "favorite" for "best."
chicken
The one that your write yourself. No seriously, implementing scheme, even if the result is not standards compliant or even known, is the best.
Why?
I agree with this; I used to use different implementations for different problems, then I wrote my own, then I wrote a compiler to C, then to asm, &amp;c. &amp;c. and long story short I only use that (unless I have to maintain old code I wrote for another implementation, such as Scheme48).
Because of its eggs. No, really. I tried a lot of scheme implementations, and chicken gave me what I really needed, a packaging system that worked. Scheme is a great language but having a lot of different implementations is both, good and bad. Bad is, that there is no standard packaging system which enables people to write libraries in scheme and make them available for everyone (like, for example, rugygems).
Why is it the only one you use? Is it because it's fast?
I only know MIT Scheme and Racket's poor implementation of R5RS. &lt;3 MIT Scheme, but that's because I've been teaching it for over a year.
The community. It might be small, but it's friendly, helpful and most importantly active.
I'll second this. I've only tried a couple of implementations briefly, but Chicken was the one that stuck for me. And the ability to run `chicken-install &lt;package&gt;` and have it download/compile/install is really useful. Still getting the hang of `csc` (the Chicken compiler) though, but for simple scripts it works really well. I've found that Chicken has the best documentation so far, and the ability to download it for offline reading. I also find the syntax and read macros to be really easy to use once you get the hang of them.
[Chibi](http://code.google.com/p/chibi-scheme/) is young, but my favourite right now.
Well, it's about the same as Gambit-C or Chicken in speed, both interpretation &amp; compilation, but I've added other things to it: * dict's (backed by tries) with `{}` literal syntax. * dicts have a `partial-key?` semi-predicate which returns `#t` on match, `#f` on no match and length of match if it is a partial match. I've used a similar method for search systems before, so I thought it would be useful to have in-language. * vectors with `[]` literal syntax. * unified collection API (`cset!`,`cupdate`,`length`,`nth`,`cslice`,&amp;c.). * collections are functions whose domain is their keys and codomain is the storage field * `case-lambda`s are there by default. * support for "strict enough" typing, and type inference (which I'm still working on). * extensions to `syntax-rules` to match against type. * extensions to various SRFIs. * Heavy POSIX integration that is abstracted away into modules. * large library (image processing, network protocols, file formats, &amp;c. still more to be added) out of the box. and various others. I want it to be ready "out of the box" for most work, like Python, but still small enough that you can carry it around with you from system to system (the interpreter is something like 11k lines of code, which is the run time, the core interpreter, the FFI, the POSIX integration &amp; some cruft; I'm hoisting the system so that it can be fully self-hosting, but that's a work in progress; for instance, I'm still working on the GC). The binary for the interpreter is about 166k in size. So, I wanted to "do it right" for most of the uses that I have for Scheme now. *edit*: I also forgot to mention that it has [W7](http://fare.tunes.org/tmp/emergent/secureos.htm) in the core (implemented as primitives) for security, plus Clojure-style metadata on all SExpressions (and a W7 environment to include taint checks).
Chicken, Racket. Chicken is a really fast Scheme→C compiler and has lots of libraries, Racket many interesting things like Lazy Racket and Typed Racket, and has a good ffi.
Even if the syntactic sugar for hashes and vectors may be implemented with reader macros, your work is *really* impressive. Does it support `syntax-case`, other than `syntax-rules`?
&gt; Racket's poor implementation of R5RS. Racket doesn't adhere to any standard. I used MIT/GNU Scheme for a while, then I discovered it has a compiler.
&gt; Even if the syntactic sugar for hashes and vectors may be implemented with reader macros, your work is really impressive. Thank you. I really just wanted to write Scheme everyday, rather than other languages, and while I *can* get these things in most current scheme dialects, I wanted them *now*, out of the box &amp; the same across all the various platforms I work on; when I started this project, I had IRIX, Mac OS X, HPUX, Solaris, Linux &amp; Cygwin boxes where I would have to run code, so it's much nicer to have *one* language rather than having to hack up code all over the place. I haven't tested HPUX in some time, but the others compile just fine. &gt; Does it support syntax-case, other than syntax-rules? I actually only support `define-macro` and `define-syntax`, which is `syntax-rules` with simpler syntax. There is also a `quasi-syntax`-like form called `define-simple-syntax`, but I'm phasing that out, as it hasn't been nearly as useful as I thought it would be. The overall goal is to avoid `define-macro`, use `define-syntax` and add the other types of syntactic expansions found in other systems as time permits, so `syntax-case` would be one of them, as well as the other flavours people tend to enjoy (such as syntactic closures). I would certainly want to extend `syntax-case` to include any typing mechanisms possible, so that would be more work, but overall I don't think it should be too crazy. It's on the to do list :D
Well, `syntax-case`, instead of wrapping the template everything inside `(syntax)`, just executes the template's code at expansion time and expects it to return a syntax object. I guess you could reuse most of your `syntax-rules` code (and, maybe, rewrite it with `syntax-case` direcly). Just a suggestion, by the way, but you could make `define-syntax` just a form that binds an identifier to a macro/transformer/how-you-call-it-in-your-implementation and accepts a function that takes one argument (the syntax list of the macro call, e.g. `(foo x)`), then doing all your macro-defining-trickery there, so you wouldn't have to invent a new name for every `syntax-*`.
&gt; Well, syntax-case, instead of wrapping the template everything inside (syntax), just executes the template's code at expansion time and expects it to return a syntax object. I guess you could reuse most of your syntax-rules code (and, maybe, rewrite it with syntax-case direcly). From what I've seen it should be pretty simple, as you point out, I've just preferred `syntax-rules` because it was so clean &amp; simple to write a decent implementation that I didn't want to futz with anything else, which leads to my next point: &gt; Just a suggestion, by the way, but you could make define-syntax just a form that binds an identifier to a macro/transformer/how-you-call-it-in-your-implementation and accepts a function that takes one argument (the syntax list of the macro call, e.g. (foo x)), then doing all your macro-defining-trickery there, so you wouldn't have to invent a new name for every syntax-*. Originally, my language was pretty complex (reaching, say, ISLISP-level of complexity), but I wanted to keep macros simple. So, while I was attempting to get `syntax-rules` working properly, I used `define-simple-syntax`, which worked with the built-in `quasiquote` (+ some extra machinery to support the normal workings of `quasisyntax`) to make hygienic macros. The intent was to have only `define-macro` (to support really old code) and `define-syntax`, since those would be the two that *I* would use. Later, I wanted to add the other forms in exactly the way you describe: some `define-n-syntax` which operated on syntax objects which could be returned from whatever the user wanted. I just haven't gotten to that step yet :D Of course, later I decided to strip down most of what I had to the simplest core possible that included the things I wanted, which is much where I am now (I've actually to add a few things back, but I'm pretty close); the difference between `define-simple-syntax` and `define-syntax` comes from before this period of primitive form rationing.
Wow, that sounds interesting. I have seen a lot of things in Clojureland that I'd love to see back home, in Schemeland.
I actually started with these ideas from Lush, but when I saw Clojure and thought it had a much nicer interface to the same notions. I don't support reverse mapping (i.e. not `(:key dict)`, but `(dict :key)` works; I could make the reverse work, but I just thought it would get weird with slices &amp; should I support the same for all collections? &amp;c. &amp;c.), since I was heading for more consistency (or at least attempting :D).
What language did you use initially?
The initial interpreter &amp; run time were written in C. I then scrapped the evaluator and rewrote a good portion of the run time. From here, I wrote a restricted subset compiler (it didn't guaranty TCO on all tail calls, just self tail calls which were rewritten into a `while`-loop) that used the same run time to write a poor interpreter that could self-host. From this, I wrote a better one, and I'm working on the "final" one now. I plan on having at least this last "interpreter" (VM compiler), and a fully, non-restricted compiler, as well as the restricted compiler (which I can work on to make better guaranties about low-level interaction; it's modeled on PreScheme, but has an optional GC and an FFI modeled on [KSM's](http://square.umin.ac.jp/~hchang/ksm/ref/ksm_10.html). I'd like to add verification, for instance).
(This reply assumes that the original thread's question is actually about which Scheme they should use. I think that's the question Zevrem was actually asking, and what shortsigtedsid and chupish were answering.) The above post and its parent show the problem that Scheme currently has: brilliant developers who, instead of contributing to and building up an existing implementation (thus helping make it more useful for the entire community), prefer to isolate themselves off and indulge in creating their own private corner of (impressive) toys. If you (Schemers in general) want to see Scheme use become more prevalent (thus allowing you and your friends to use it in more places), you need to come together as a community and contribute to one of maybe 2 or 3 Schemes that we can all get behind. 
It sounds like you may have meant to ask, "which Scheme should I use?". If that's the case, then: * use Chicken if you want a BSD-licensed Scheme with good community support, pretty good docs, nice selection of modules, good performance, and nice a community. As you may have read, there's also been some recent work on getting Slime working with Chicken, which seems to be seeing good progress. * use Guile if you want an official FSF-supported Scheme with good Gnome integration, good docs, fairly good selection of modules, probable future Emacs integration, and a very nice community. Guile has a new release coming (2.0) that brings with it a compiler and VM (which also now has support for eczemascript and elisp that's being actively developed). 
So Chicken has nicer libraries?
&gt; The above post and its parent show the problem that Scheme currently has: brilliant developers who, instead of contributing to and building up an existing implementation (thus helping make it more useful for the entire community), prefer to isolate themselves off and indulge in creating their own private corner of (impressive) toys. Well, that's certainly true, and I've thought about it several times, doing so wouldn't really help what I'm attempting to do (see below). &gt; If you (Schemers in general) want to see Scheme use become more prevalent (thus allowing you and your friends to use it in more places), you need to come together as a community and contribute to one of maybe 2 or 3 Schemes that we can all get behind. This might sound like hubris, but I'm trying to be humble: I want to create a "Lisp for the 21st Century." In this vein, I'm thinking like Qi or Clojure or whatever, and I'm not going to tie myself with "Scheme" per se (although I like Scheme *very* much, I want something beyond it, sort of). This is, of course, potentially unreachable, but the idea I've had is something of a fork of Scheme, with the what works for me. If I'm allowed to let my hubris soar, I'd say that I would want this to *replace* most other Scheme systems with something akin to Scheme + Python: functional goodness meets decent set of data structures &amp; "batteries included." On top of that, I've been using it for a my research interests, mostly in security &amp; grid applications. The core of my language has been written such that I can compile it without I/O or with a variety GC schemes or none (programmer is required to allocate &amp; manage memory) or as just a run time. I certainly *could* hack something into this shape, but it was quite a bit easier to start from this place. I could have spent this time documenting PreScheme &amp; using that, but I instead started with just a toy, some time &amp; an interest and now I have a system that I can use for client work. On top of those things, I don't think it's bad to see competition, and I *think* schemers are heading towards a "crunch." More &amp; more, I see Racket, Chicken and a Gambit-C or Gauche; Kawa or SISC in the Java space. I think the trend is already towards systems that include whatever people need (Racket) or have readily available (Chicken &amp; Racket). **tl;dr**: hubris + opinion that Scheme is already heading towards general consensus.
To see what libs Chicken has, see the [egg index](http://wiki.call-cc.org/chicken-projects/egg-index-4.html). To see what libs Guile has, see chapter 7 of [the newest manual](http://www.gnu.org/software/guile/docs/master/guile.html/index.html), and also their [project page](http://www.gnu.org/software/guile/gnu-guile-projects.html). 
Sorry, I didn't mean to suggest anything wrong with your particular approach. It obviously works well for you. What I think is wrong is the default response and attitude toward newcomers. If you want to grow the community (which benefits us all), I think the default response to a newcomer asking "which Scheme?" should be closer to: "what do you want to do?". If the answer is, "know every inch of my implementation and the reasons for the design", then "write your own" sounds like a great answer. But for those who just want to start using Scheme for their work, then think the answer should be something more like: "use one with good community support, that is actively maintained, and which has a good number of compatible modules available". 
is full of win. Really, it needs some work to be practical, but it doesn't look like anyone is working on it. Why not? It looks like the last release was on '06.
I've read the pdf on the dude's research projects, and he currently has like 5 of them.
Same. None of them are nearly as interesting as stalin. :)
Well, of course you'd think that.
[Dybvig](http://www.scheme.com/tspl3/)'s TSPL is good scheme tutorial.
Probably better to use [the fourth edition](http://www.scheme.com/tspl4/).
&gt; Sorry, I didn't mean to suggest anything wrong with your particular approach. It obviously works well for you. What I think is wrong is the default response and attitude toward newcomers. Oh, no worries; I was simply attempting to explain my motivation. I will say though that implementing a toy scheme interpreter can lead to a really deep understanding of Scheme in general, and help especially with more esoteric topics such as (delimited) continuations. &gt; If you want to grow the community (which benefits us all), I think the default response to a newcomer asking "which Scheme?" should be closer to: "what do you want to do?". If the answer is, "know every inch of my implementation and the reasons for the design", then "write your own" sounds like a great answer. I actually think things like [SNOW!](http://snow.iro.umontreal.ca) would have been great, but that brought along it's own issues. Most likely we'll see Chicken &amp; Racket continue to have large-ish communities, and most other projects will be either academically focused, toys, dead or off-shoots of scheme. Your point here though is 100% correct; if you want to *really* know scheme, implement it, which is why I think there are so many implementations to begin with: people were curious deeply curious about how something works in Scheme, and the syntax is so simple to create a reader for, that why not try it? That's how I got hooked; "Oh, this is a simple idea, let's see this &amp; that there..." &gt; But for those who just want to start using Scheme for their work, then think the answer should be something more like: "use one with good community support, that is actively maintained, and which has a good number of compatible modules available". Agreed; besides, there really *are* a goodly number of "production strength" scheme implementations out there, so it would be best to recommend one of those to people wanting to use Scheme for work (and, were you to put a gun to my head and ask "besides your own, which one would you use?" I'd go for Scheme48). 
Chicken Scheme users can easily play with Stalin as it is available as an extension.
As a reference the R5RS document is a nice read. 50 pages explain the basics. Although some other book might be needed to get into the thinking of it all.
Lots of people have found [Teach yourself Scheme in fixnum days](http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html) helpful.
Why is that useful?
If you want to practice or improve your Scheme programming skills, [Programming Praxis](http://programmingpraxis.com) provides a set of programming exercises with reference solutions in Scheme.
Presumably so you can implement inner loops in Stalin and integrate that code into the more liberal and modern Chicken Scheme project.
There's a lot I like about this text, but I wish it spent some more time making sure the reader understands some of the basics. For example, the discussion of lists, cons, and cdr in section 2.2. 
it is made an extension so you can install it easily with chicken-install. The result is a stalin compiler executable you then can use. See http://wiki.call-cc.org/eggref/4/stalin if you like for more information
Actually, its not too difficult to write your own scheme especially if you implement a subset of the standard. I found that out for myself by working through http://michaux.ca/articles/scheme-from-scratch-introduction which itself refers to Abdulaziz Ghuloum's amazing incremental approach to compiler construction (http://www.cs.indiana.edu/~aghuloum/). Both of them show you how to write your own scheme with tiny steps. I learnt a lot from these two resources. Its debatable about the role of scheme as a big language or a small language.
Stalin would be terrible for compiling inner loops. Stalin achieves its speed by compiling whole programs at once. This way it can prove lots of things about the program that a normal compiler couldn't. For example, it can derive the types and lifetimes of most objects at compile time so it can allocate then unboxed on the stack instead of on the GC'd heap. It can typically also tell if continuations are escaping, etc. Besides, the stalin and chicken implementations of GC are fundamentally incompatible. They really could never be used together.
Right, but why compile stalin which chicken when you can compile it with stalin itself and get a much more efficient executable? Maybe the point is to make hacking on stalin easier?
I suspected as much.
Stalin is written in scheme so either you use the bootstrap C files and compile that to compile stalin you can also use any other scheme system to compile stalin. As it happens there is a port to make this possible with Chicken Scheme. There is no answer to your 'but why?' It just is there. Same question would be 'Why should I use another compiler than gcc to compile gcc?' You don't need to. If there are several paths that lead to the same destination it comes to a matter of choice. There is no evident grade of usefulness in either one. Userfulness is all within yourself.
The [racket docs](http://docs.racket-lang.org/) are a pretty good starting point (though it's not, strictly speaking, Scheme). [The classic source](http://mitpress.mit.edu/sicp/) is also available as an online text.
Reading these every two weeks means that each issue is far more packed than they have been. I enjoy this format more! There is a tremendous amount of great work happening here.
Hey, my parser is now infamous. All right!
Unfortunately it also means it takes longer to compile the stuff. We could need more interested chickeneers to write it....
Chez Scheme is very good at compliance and compilation speed, but it's not free. The interpreter is available free as Petite Chez Scheme though. 
Really, what is the point of posting a 4-year-old Wikipedia article?
Probably Zevrem's first run in with Stalin. I think everyone, when first really wanting to learn Scheme, has this first run-in with Stalin, before they realize that it's not a cure-all for their problems.
I found it amazing that emacs lisp, or in general, emacs, which is considered a huge and unwieldy text editor by many, is shipped by default on the installation CD of most Linux distributions, and thus immediately available on millions of Unix systems. I still find it a remarkable travesty for a text editor to be, in terms of file size, on par with Eclipse and OpenOffice.org, and probably dwarfing most web browsers.
Neither seem to be on Windows.
As an online text... and for those among us who prefer passively absorbing our knowledge, as videos: http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/ The Berkeley webcasts of CS061A are also based on the same text and are also good: http://webcast.berkeley.edu/course_details_new.php?seriesid=2011-B-26281&amp;semesterid=2011-B
It's 1.9.15 :-). It's an impressive release, but why is there no news from the elisp implementation? I can't wait to have a working Guile based Emacs!
Racket implements the R5RS quite faithfully. It also provides lots of other languages, which are significantly better for basically all purposes, but that doesn't break the R5RS support.
The [anaphoric macros](http://letoverlambda.com/index.cl/guest/chap6.html) are great examples of using intentional identifier capture.
Just for future reference, I [rewrote it](http://pastebin.com/uzxYnpqd), now with 100% less bugs!
Wow, after the GUI layer rewrite, DrRacket loads really faster, and doesn't have those irritating glitches anymore! I liked the old open file dialog better, though, I hate the GTK one.
Why does DrRacket start a console window in addition to the GUI (Windows XP x86)? Nice update though. Can't wait to install it on Ubuntu.
It's doesn't do that on my machine. Are you clicking on the 'DrRacket' icon? Is there anything written in the console window?
No, the console window is blank. It doesn't pop up every time on startup. However, I can consistently bring it up by clicking on *Help &gt; Check for Updates...* (which gives a timeout error, btw). Also, when I press Ctrl+C in that console window, I get a new dialog box titled 'DrRacket Internal Error' with the following text in the body: user break === context === C:\Program Files\Racket\collects\mred\private\wx\common\queue.rkt:607:3 At this point, the main window becomes unresponsive and I have to force-quit. 
Ok, that definitely a bug. Could you send it to the bug report queue? Click *Help &gt; Submit Bug Report*. Do you have any idea why the update check might time out? Is there anything peculiar to your network configuration?
Regarding the update check timeout: I was behind our corporate firewall on my work laptop at that time, which might have caused that issue. I am at home right now, and I just checked for updates (Ubuntu install) and I don't see the problem. I submitted a new bug a few minutes ago regarding a compile: unbound identifier error when using '#lang planet neil/sicp' in the automatic #lang line. Also, I don't know whether this can be submitted as a bug, but the GUI is very sluggish; I am seeing substantial CPU spikes on my dual-core laptop (Ubuntu 10.04 x86-64 partition) when resizing the DrRacket window. The preferences dialog box is also very sluggish. If you need any more information, let me know. I am learning to program in Scheme using DrRacket and would love to help in any way I can.
Is there a good linux console alternative to racket? I love having two separate sections (one to declare definitions, the other to test them out). Is there a way to do this on linux console?
Scheme9 from Empty space has something like that, but you can use any number of emacs + scheme integration systems to achieve something similar. I'm sure with enough work you can do the same with vim as well (I know there has been work in this vein for Python + ViM, so I don't see how Scheme could be so far behind).
I've installed scheme9, but I can't figure out the command to actually get it to run. EDIT: I've figured it out, but I'm still not sure how to make this split screen.
Yeah, S9 is a bit different in many ways, and very much a reflection of `nmh`. Also, i would note that S9 is an R**4**RS interpreter, so you may run into some things that are missing from R**5**RS &amp; beyond (though Nils did a great job with extensions). I'm not sure if the [vi-style editor](http://groups.google.com/group/comp.lang.scheme/browse_thread/thread/f499bb378d580529?pli=1) is included with builds from packages though. *Also* I would recommend GNU/MIT Scheme, which has a built in emacs work-alike called `edwin`. 
I've noticed that the bug reports you've submitted don't include an email address. That makes it very hard to respond and get more information. 
You can use the 'racket' command at the console, to get an interactive REPL. If you want a less-gui version of the defintions/interactions window, I recommend using Emacs with racket and the Geiser package.
I think emacs + scheme is probably the best way to go, regardless of which Scheme/Scheme-alike language you go with, because at least the interface will remain the same, regardless of Racket/Scheme48/CL/JS/Factor/whatever.
Congrats! Hopefully this new, fresh drive behind Guile will lead to more Lisp used throughout the GNU system. Guiles relatively low profile lead to countless GNU packages depending on non-gnu languages like Python and Perl (latest Texinfo version is completely Perl), so the whole ecosystem can less and less function without "outside" dependencies, which somehow defies the logic behind calling it a "system" instead of just bunch of software. I'll use the chance to ask in what state the GTK bindings are, the last time I looked at them they were focused on gtk1.2.
Well, for quite some time Guile wasn't exactly a great Scheme system; it really seems like Wingo &amp; others have done a great amount of work to make Guile really awesome. All the work to make Guile faster, more compliant, easier to work with (elisp, JS, Lua work? awesome!) really makes me hopeful about what you say: that there will be, if not a return to Guile, a fresh look at it for future GNU &amp; other projects.
Does anyone have any experience with getting Guile compiled and running on the Windows platform? I'm fairly sure it's possible but there aren't any binaries or hints to be found on Google.
It should work on Cygwin of course, though that's untested. Currently the more proper windows plan is mingw cross-compilation, for which Jan Nieuwenhuizen is working on some patches: http://thread.gmane.org/gmane.lisp.guile.devel/11646
Regarding GTK bindings, our story there is actually pretty good: http://www.gnu.org/software/guile-gnome/ Build from git to get guile 2.0 support. You might need to build g-wrap from git too; I don't recall.
Thank you for that information! Much appreciated :)
&gt; you can use any number of emacs + scheme integration systems Quack has special support for Racket/PLT Scheme.
Well there you go. I'm a bit behind because I use neither emacs nor Racket, so I have to defer to those who actually know (or search google, but even with `(web/search :google "racket lang emacs")` it's a bit more work than I'm willing to do whilst working...).
I don't think it is going to supplant Perl or Python any time this century. It's just not going to happen.
Yeah... should I resubmit them with my email ID or just PM it to you?
For writing apps? No. For writing stand-along scripts? No. For writing application extensions, maybe. The API is certainly quite a bit nicer.
I'm using Racket for scripts and everything. scsh is still being developed, though, the svn is still active.
There's activity on their Google Code page: http://code.google.com/p/scsh/
No, definitely not dead.
Chicken [runs on windows](http://wiki.call-cc.org/compiling-chicken-on-windows-xp-with-mingw), but then you have to use... windows
For emacs folks? Yes. For everyone else? No.
Please resubmit with a real email -- I'm not the one who maintains that part of the software.
Is that the Google Code project? 
More info, please? 
It's another project (probably), their is on [sourceforge](http://sourceforge.net/projects/scsh/).
When do we say that a language is dead? It isn't when it's no longer evolving. It is when nobody uses it anymore. In the case of Scsh, it is still actively being used. It's just that not a lot of people talk about it.
&gt; unbound identifier error when using '#lang planet neil/sicp' in the automatic #lang line. It works for me. Are you able to reproduce it? &gt; I was behind our corporate firewall on my work laptop at that time, Did you mention this in the bug report? It's probably what's tickling the bug. &gt; I am seeing substantial CPU spikes on my dual-core laptop (Ubuntu 10.04 x86-64 partition) when resizing the DrRacket window. Yes, that's a bug. If you can reproduce it then it's worth reporting. 
I just submitted the 'unbound identifier' bug using one of my email addresses. I didn't submit my email address before because I didn't want to make my email public (which it is, now). Anyway, that bug *is* consistently reproducible. I have the 64-bit version of DrRacket on my Ubuntu 10.04 partition and a 32-bit version on my WS2008 R2 x64 partition, and I can consistently reproduce the issue in both environments. I also have the 32-bit version of DrRacket installed on my work laptop (Windows XP SP3) and I see the issue there as well. I can only find the high-CPU bug on my Ubuntu partition. Please check [this screenshot](http://imgur.com/ITjGV) to find evidence of both the bugs; the spikes you see on the CPU chart was me cycling through the tabs in the Preferences window. Let me know if I can be of further assistance.
Did you attach all this info to the bug report? I fear it's going to be lost if it's just here.
If you spend most of your time working on a large C codebase, then decide to add scripting to you app, Guile may appeal to folks who: * already know Scheme, or have some familiarity with it, or * prefer a simpler language for scripting (simpler than Python), but who aren't enamored with Lua, for whatever reason, or * generally support GNU and tend to use what they recommend, or * want to be able to script their app with the same scripting language used by other GNU projects Guile also seems to have bindings to various Gnome libs, so if your app needs that, Guile might be a good choice.
I stopped caring at some point during the R6RS debacle. Is R7RS still under consideration? What are the important proposals currently on the table? I realize I can trudge through scheme-reports, figured someone would be nice enough to summarize it though. To answer your question, I honestly never saw anything in CL that I wanted in Scheme, and I'm by no means a hardcore Schemer. If I want CL, I'll use CL. 
IMHO it's useless, all the major Scheme implementations have grown too much to unificate them all, and R6RS was mostly a failure, the only good thing was syntax-case. If it doesn't add anything new, just let the current implementations evolve.
&gt; Is R7RS still under consideration? Of course! The main site for R7RS is http://www.scheme-reports.org/ . There's active discussion and voting happening at the [wg1 group](http://groups.google.com/group/scheme-reports-wg1/topics). WG1 Ballot results (1st and 2nd) are online for anyone to view (check the discussion group for links). WG2 is less active, of course, since they need more of wg1 issues settled before moving much (that's my assumption). My understanding is that R6RS was indeed a debacle, and that's getting rectified with R7RS. By all indications, there's going to be pretty broad approval of at least what wg1 comes up with. And with wg2 comes the possibility of cross-implementation compatibility for modules, which would make something like a Scheme CPAN the next happy step. 
&gt; R6RS was mostly a failure I'm pretty sure that many in the community share your assessment. R7RS seems to be mainly about settling on best current practice, rather than inventing new rules. Once an R7RS standard for modules is accepted, we should start seeing lots of modules for R7RS. If implementations want to use these (which I think is very likely), they'll move toward R7RS compatibility. I see one of the end goals as having a CPAN of sorts for Scheme, and it looks like R7RS is the vehicle for getting there. 
i'd rather see it borrow from clojure, especially the strong namespacing and literal notation for data structures.
I'd drop the R7RS name altogether. R6RS -&gt; failure. R5RS doesn't need to grow. You can use CL if that's what you want. R5RS needs a standard for modules and absolutely nothing else. Call it "standard for modules" so you don't have to wonder what the heck is the new RxRS about and prevent anyone from sneaking in any other changes.
No, please not any more literals. I'd go any day for ``(dict key value key value ...)`` over literals. What it could borrow from Clojure is the Seq-abstraction and strong support for data types like arrays, dicts, sets etc. This is for me the most important point of Clojure, not the strange literals.
Oh, yes, while you're at it, what about becoming Java-interoperable and drop sexpr and become *XML-enabled* to deliver robust product compatible with novel tested technologies?
&gt; Seq-abstraction Is that that `(fn [vector] ...)` thing, or just the `everything is a sequence`? If so, almost all the implementations have a `sequence?` (like [this](http://wiki.call-cc.org/eggref/4/sequences?action=show) and [this](http://docs.racket-lang.org/reference/sequences.html)) and associated functions, use that. It would be ok to put them in the standard, but making Scheme sequence-oriented instead of cons-oriented is wrong. &gt; and strong support for data types like arrays, dicts, sets etc. We need hashes (and something to treat alists as dicts, like [this](http://docs.racket-lang.org/reference/dicts.html)) and, more importantly, *structs*, a way to make them work like dicts and sequences (like Racket's [prop:dict](http://docs.racket-lang.org/reference/dicts.html#(def._\(\(lib._racket/dict..rkt\)._prop~3adict\)\)) and [prop:sequence](http://docs.racket-lang.org/reference/sequences.html#(def._((lib._racket/private/base..rkt\)._prop~3asequence\))), a way to define more of those "classes" of data structures (not classes in the object-oriented way, of course) and standardized "keyword" datatype.
It would end like the SRFI: almost nobody cares. And just adding modules wouldn't be enough, it needs something like CL's `#+` for conditional compilation (hopefully a reader macro just like `#+`, and not a whole `(cond-compile (symbol expr) (symbol expr) ...)`, it would limit its usefulness)
I'm the one working on the google code project. The last release was in 2006, and things have changed quite a bit in scheme48 since. I'm trying to do (at least) two things: make scsh a library, and update it to work with the latest scheme48. I'm relatively close to a release, but as you can see from the mercurial logs, development has been slow and in bursts. I've been too busy, and the bugs are hairy. Less than a handful of people know the system well enough to help or answer questions.
are you thinking of scala?
Clojure is JVM-centric too. "It doesn't have something? Go cry to Java libs*!*"
yeah, that was a design decision, to bootstrap the library ecosystem. i don't like it either, but it's independent of the merits of the language itself. as for datatype syntax, my experience is that it makes vectors and hashes a lot more pleasant to use.
Nothing that a reader macro can't solve. We need standardised reader macros.
if we to standardise a reader macro across implementations, how does that differ from having it in the language?
I want to standardise a way to define reader macros, not the datatype syntax. If you really need it, you can write a reader macro.
ah, i see. yes, that would definitely be a good thing in and of itself.
I was referring to the latter. Actually, I quite disliked Clojure when I heard about it, but coming from the frustrations of Racket (everything is so damn complicated, this is not Scheme), Ikarus (unmaintained), Mosh (chokes on comments in code), Guile (bugs in regular expression implementation) it felt really nice and fluid to program with. I liked the way stronger functional focus of Clojure as well, it comes with so many functional goodies that I didn't even dream about in Scheme (well I could implement that, but what for?). &gt; It would be ok to put them in the standard, but making Scheme sequence-oriented instead of cons-oriented is wrong. Why do you think so? Serious argument. cons and the linked list is only a special case of sequence.
Oh, well, I'm ok with that, and all the Scheme out there provide generic sequence accessors and stuff. Racket's not so much complicated, when you learn what to use and when, and much more important to *never ever touch the class system*, you may want to try Chicken. &gt; cons and the linked list is only a special case of sequence. A vector is different from a list. Generally, a vector has O(1) access and O(n) splicing, while a linked list has O(n) access and O(1) splicing. That means they should be treated differently. I prefer implement the list map as `apply the function to the car, map the function to the cdr, consing up the list while recurring` and the vector map as `make a vector v2 of the same length of v, start with a counter i initially set to 0 and iterate over the vector, setting v2[i] to the result of the function applied to v[i]`, for efficiency. Sure, you can implement a generic function `map` that dispatches the correct method to iterate over the sequence, but that doesn't change that much Lisp idioms are list-centric, see: recursive macros. When I want my code to be polymorphic over sequences, I have my standard `sequence-*` functions. &gt; I liked the way stronger functional focus of Clojure as well, it comes with so many functional goodies that I didn't even dream about in Scheme Out of curiosity, what functional goodies?
I still think it should be called "Scheme 7". (Note to pedants: I know it's not the seventh standard. It will be OK.)
I'll look forward to it without holding my breath. ;-) When you write that you're making scsh a library, what implementations will/should it be compatible with? 
Thank you for that! I am not a fan of cygwin myself. The mingw compiled version will be nice to have!
If any of you Schemers use Stalin, would you try to do it? Thank you.
2.4ghz Core2Duo, with something somewhere using a little bit of cpu (yay accurate results!). Both schemes are using the same code. **Chicken** (The 1 queens problem has 1 solutions.) (The 2 queens problem has 0 solutions.) (The 3 queens problem has 0 solutions.) (The 4 queens problem has 2 solutions.) (The 5 queens problem has 10 solutions.) (The 6 queens problem has 4 solutions.) (The 7 queens problem has 40 solutions.) (The 8 queens problem has 92 solutions.) (The 9 queens problem has 352 solutions.) (The 10 queens problem has 724 solutions.) (The 11 queens problem has 2680 solutions.) ./8queens 2.93s user 0.03s system 99% cpu 2.972 total **Stalin** (The 1 queens problem has 1 solutions.) (The 2 queens problem has 0 solutions.) (The 3 queens problem has 0 solutions.) (The 4 queens problem has 2 solutions.) (The 5 queens problem has 10 solutions.) (The 6 queens problem has 4 solutions.) (The 7 queens problem has 40 solutions.) (The 8 queens problem has 92 solutions.) (The 9 queens problem has 352 solutions.) (The 10 queens problem has 724 solutions.) (The 11 queens problem has 2680 solutions.) ./8queens 0.75s user 0.06s system 98% cpu 0.824 total **C**. Note: not using the same algorithm so it's meaningless. 1: 1 total solutions 2: 0 total solutions 3: 0 total solutions 4: 2 total solutions 5: 10 total solutions 6: 4 total solutions 7: 40 total solutions 8: 92 total solutions 9: 352 total solutions 10: 724 total solutions 11: 2680 total solutions ./a.out 11 0.01s user 0.00s system 60% cpu 0.017 total 
Nice, thanks for the rapid response. What kind of unearthly prepared-constant hack did you use for the C program? Also, would you care to upvote the question if you think it's worthwhile? I'm curious why people even bother to downvote in this arid channel.
Sometimes reddit adds on a random number of votes in either direction, it seems.
 Summary gsi 68.308 gsc 4.836 stalin 1.700 csc 11.009 Gambit Scheme interpreter. $ time gsi queens.scm real 1m10.044s user 1m8.308s sys 0m0.104s Gambit Scheme compiler. $ gsc -exe queens.scm $ time ./queens real 0m6.584s user 0m4.836s sys 0m0.980s Stalin compiler. $ stalin -On queens.scm $ time ./queens real 0m1.905s user 0m1.700s sys 0m0.048s Chicken Scheme compiler. $ csc queens.scm $ time ./queens real 0m11.739s user 0m11.009s sys 0m0.080s CPU Info. $ head -n 8 /proc/cpuinfo processor : 0 vendor_id : AuthenticAMD cpu family : 15 model : 127 model name : AMD Athlon(tm) Neo Processor MV-40 stepping : 2 cpu MHz : 800.000 cache size : 512 KB
Changed data structure to (define (make-queen row col) (cons row col)) (define (get-row queen) (car queen)) (define (get-col queen) (cdr queen)) Stalin gives stalin -Ob -Om -On -Or -Ot queens.scm time ./queens 0.640u 0.030s 0:00.68 98.5% 0+0k 0+0io 0pf+0w Stalin doesn't have safe fixnum arithmetic, so I added (declare (standard-bindings) (extended-bindings) (fixnum) (block) (not safe)) at top of the file. Gambit gives gsc -exe queens time ./queens 0.230u 0.010s 0:00.24 100.0% 0+0k 0+0io 0pf+0w Chicken gives /pkgs/chicken-4.6.0/bin/csc -O5 queens.scm time ./queens 0.200u 0.020s 0:00.22 100.0% 0+0k 0+0io 0pf+0w model name : Intel(R) Core(TM)2 Quad CPU Q8200 @ 2.33GHz 
I'd say it's even much more productive than other languages. Virtually any language, given the libraries and/or a decent FFI, can do anything pratical. Chicken has a lot of libraries (the \`\`eggs''), and macros in general save you from writing lots of boilerplate.
&gt; and macros in general save you from writing lots of boilerplate I have not yet gotten to macros in my studies. They seem like deep magic to me. (I've used macros in C, but they were just basically search/replace operations from what I recall.) Can you point me to where I can learn more about Scheme macros (i.e. what they are and what they're useful for)? I hate to admit it, but Python manages to very easily fit into my comfort zone. 
&gt; Chicken has a lot of libraries Only thing is, its pale compared to the 13510 packages in the Python Package index (mentioning it since the OP did). So yeah, it might be more productive but you end up implementing a lot of things for yourself, because nobody did yet for Scheme or even worse, your particular implementation. The roadblocks I ran into with Guile: * Error output is not really useful * The documentation is sometimes hard to understand * Bugs in the Regular Expression implementation Except for that it is okay-ish, I guess.
Don't worry, when I started with Scheme, macros seemed some kind of strange magical beast I could never comprehend. I suggest you to read [this](http://www.eng.utah.edu/~cs6510/macros.pdf) to get an idea of how to write a macro and do some experiments.
&gt; its pale compared to the 13510 packages in the Python Package index You can use the pyffi, if you need them. Chicken eggs covers almost all the common things. It might not have a specific interface to some linux distribution's package manager, or an interface to my microwave oven, but at least it can move file and do all the unixy (and windows-y) stuff.
With Chicken Scheme I definitely think it is possible to use Scheme in place of languages such as Python. http://wiki.call-cc.org/chicken-projects/egg-index-4.html#web Awful provides everything you need to make kickass webapps. The best thing is to just jump right in to it and when you come across hurdles you can then google for an answer :) Even making games is perfectly possible, the OpenGL bindings work very well, and with the FFI you can call just about anything you need to. Which brings me to my last point, the FFI is just AWESOME. It is the single best thing you can learn in my opinion, and suddenly makes it trivial to put very high-level wrappers around just about any library you want :) I very rarely plug my blog, but three out of my last four\* posts are Chicken Scheme related, one of which is about Awful, and the other two are about the FFI, so feel free to take a look if you just want to see some code in action! http://demonastery.org \**Edit: I'm still getting loads of hits from this page, so for those of you finding this from Google, you might have to scroll a wee bit to find the Scheme stuff on my blog, but since this post I've added examples/mini tutorials for OpenGL, call/cc, macros (including an infix macro), and a couple of other things. Glad to see people are reading it!*
I don't recall having seen any bug reports regarding any of these.
&gt; You can use the pyffi, if you need them. I didn't know this. Nice. Unfortunately libraries from other languages always feel alien, whether it be C in Python via ctypes or Java via Clojure.
The error output not being useful is not a particular bug and the documentation being hard to understand was something that I wanted to fix. I forked the code but never got around to extend the documentation, because of time constraints. As to the regex handling, I posted on guile-user, message id is `&lt;20101219014738.3ae55884@halmanfloyd&gt;` (does the message id suffice to find the message? if not, I'll search it in Google Groups or something).
See the [Real-world software and services](http://dynamo.iro.umontreal.ca/~gambit/wiki/index.php/Real-world_software_and_services) page on the Gambit wiki for examples of non-toy software written with Gambit. I'm sure the other Scheme systems could have similar pages.
I know what you mean. Ever tried to make gtk bindings for a Lisp? The code becomes more underscores than parens.
Chicken has excellent practical library support. The canonical batteries-included Scheme is [Racket](http://www.racket-lang.org), which is absolutely viable for everyday practical projects. For where I'd be writing in C, I use Gambit, but Chicken works in that niche, too. However, I don't program in Scheme because it's "easier" (for some definition of "easy") than Python (or some other language). I program in Scheme because it's just damned fun to code in.
Chicken has a [similar list](http://wiki.call-cc.org/Software). I don't know of one for Gauche, Scheme48 or STklos, but I'm sure someone somewhere has one. Shiro Kawai (author of Gauche) had some interesting papers on using Scheme at Sony (in conjunction with PS2s &amp; Maya no less); the [relevant wikipedia article](http://en.wikipedia.org/wiki/Gauche_%28Scheme_implementation%29#External_links) has links
I shall take that into consideration, cheers! :) Edit: Done!
Some macro resources: * http://www.scheme.com/tspl4/further.html#./further:h1 * http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/ (there is a chapter on macros) * http://docs.racket-lang.org/guide/macros.html
No love for Racket?
Hey, it seems everyone's conveniently ignoring Racket!
Well, he's already using Chicken, which is already a pretty good implementation. Racket is the canonical \`\`batteries-included'' Scheme, but the PLaneT is pretty much dead (it *needs* to be cleaned up and revived), it doesn't even compare to the eggs. Racket's the best when it comes to extensibility, since it even provides a lexer and parser (and an undocumented parser combinator) to generate code, and `syntax-parse` it's pretty advanced.
[Sure](http://docs.racket-lang.org/continue/index.html) [[2]](http://docs.racket-lang.org/more/index.html), everyone loves Racket.
To be entirely honest, I've never used Racket for anything beyond toying with it. I only even have it installed on one of many systems I keep at home, and, according to logs, I've only used it once or twice. I've used quite a few Scheme systems for professional work, including my own, but I've never once used Racket for anything production worthy, let alone serious. So, when discussing Scheme, I very rarely think "Racket", until either another party mentions it, or the discussion naturally leads to feature discussions. 
Okay, I didn't realize Planet was inactive, and what do you mean by "doesn't even compare to the eggs"? Is one much harder to use?
The PLaneT is much more easier to use, you can just `(require (planet package))` and Racket will do all the download and things, but the eggs are **a lot** more than planet packages. It's not about ease to use, it's about size.
Could you elaborate on that? The eggs have more functionality? What exactly are the differences? Does this have more to do with the design of the system or the way users have written them?
I was asking because one user wrote me this when I was trying to figure out what Lisp or Scheme to begin with: &gt; There are a couple answers that come to mind, neither of which is perfect. One is PLT Scheme, which is now called Racket; if you go to http://racket-lang.org/, there's a big download link, and the setup is mindlessly easy on Windows XP. The most obvious download also includes a pretty good editor with a REPL and debugger. *Scheme is a tight language that's really well thought-out, and Racket has extensions that make real programming much less painful than basic Scheme. I wrote a medium-size aeronautical engineering app in it, and it was a pleasant experience.* &gt; If I had your Java experience, however, my Lisp of choice would be Clojure. It runs on the JVM, it can use Java libraries, it's brilliantly designed, it has simple, powerful macros, and it's designed from the ground up with concurrency in mind. I use Emacs as an editor for it, and it's good for me, but if you don't know Emacs, don't learn it for this. I hear that NetBeans with the Enclojure plugin is a great IDE for it, but I haven't tried it. There's also a plugin for IDEA called La Clojure that sounds okay. Here's a page that lists some of your options and how to get started: &gt; http://www.assembla.com/wiki/show/clojure/Getting_Started. &gt; In sum: PLT Racket is the easiest setup --- one install and you're done, but Clojure is not too hard, and the language is wonderful. Both are good choices to learn a lispy language, but Clojure will probably take you further in the real world. You're unlikely to get a job using either one, but Clojure is 10 times more likely, and you can slip it into a Java shop as a "concurrency library". I wrote him back with some more questions. He replied: &gt; A lot of what you're saying points to PLT Scheme/Racket, I think. It's an old, old Lisp with a simple core that gives you much of the benefit of learning Lisp, but it also has many extensions that allow it to do more of the modern things you mention. I did some web work in Racket, and even wrote a small web server from scratch as a learning experience. &gt; If you decide on Common Lisp instead (and that's not a bad choice, but it's difficult to avoid Emacs), SBCL is not a bad implementation, even on Windows; I've used the "port in progress", and it was pretty solid. Clisp is another Common Lisp implementation that is stable on Windows, but it's slow and quirky; I never liked it. Franz has some good extensions and a fast, solid implementation, but I'm too cheap.
The eggs are just more in number. Compare [the egg repository](http://wiki.call-cc.org/chicken-projects/egg-index-4.html) to [the planet](http://planet.racket-lang.org/). The planet: * [`datalog`](http://planet.racket-lang.org/display.ss?package=datalog.plt&amp;owner=jaymccarthy) end up in the [main "distribution"](http://docs.racket-lang.org/datalog/index.html), it should be deleted from the plt. * Most of the packages don't see an update since 2009/2010. * Most of the packages are either being deprecated by the `racket/*` libs, a toy/experiment of its implementor, a "oh, I could write a 5-lines macro for that" or overly complicated for something really stupid. * The only packages being updated are likely end up in the `racket/*` libs, like [this](http://planet.racket-lang.org/display.ss?package=scheme.plt&amp;owner=cce). * There are no really-useful packages, e.g. ncurses bindings. * It still says \`\`packages for 4.xx'' instead of 5.x or such. Just saying. It has the potential to be useful, but right now it's just the experimental repository of the PLT guys. The eggs repository: [ncurses bindings](http://wiki.call-cc.org/eggref/4/ncurses). Nothing more to add, just go and look. The packages are all up-to-date, tested and **useful**, there are no deprecated packages, they are ordered, cleaner, etc. It's just a different thing, for the content *and* for how it is served to the end user.
That's a really weird answer, not in total, but in some of the specifics. The first part (up until the "I wrote a medium-size..." sentence) is fine, although I would add that it's pretty easy on Mac OS X &amp; Linux too. I'm not sure if when asked "Which lisp should I learn, given that I have Java experience?" I would say "Clojure"; it makes some very specific choices about how it operates, and those things are pretty specific to what Clojure was intended for and it's relationship with the JVM. I mean, Kawa, SICS, ABCL, &amp;c. have Java integration too, but are based on "old, old Lisp"s and most of the knowledge can be transferred elsewhere. I think Clojure is very good at what it does, and can be a very useful tool for people who are using Java and want the things Clojure gives you, but as a learning tool, I think you can do better with another family member. I'm also not sure why Clojure would take you any further in the real world; I've used it in projects, and it certainly helped *me*, but the first request I would almost always receive, regardless of my use of Clojure or Kawa (or even Jython on occasion) was "could you please rewrite this in Java? We have a strict Java-only (or Java &amp; Jython only) policy for the general code base, and people find it difficult to wrap their heads around Kawa/Clojure/Jython." Besides, many more shops are using Scala from what I can tell, and Clojure is only now starting to speed up with 1.3, so if you're really worried about "real world applicability," I don't think that squares with learning Lisp, per se. (I write &amp; use Scheme code just about every day where others would use Python or Perl, so it's not as if I think it's *useless*, I just mean to say that if you're attempting to learn Lisp "in general," then you should use the one best suited to learning &amp; growing, not one the best suited to real world work, whatever that means.). Next up is the follow-up comment; I don't take exception to anything other than "it's an old, old Lisp." I guess he/she is referring to Scheme itself, rather than Racket in specific? I mean, PLT appeared in 1994, so in terms of Scheme itself (from 1975) and Lisp in general (1958), it's not terribly old, and PLT/Racket is quite active in research &amp; pedagogy. As others have said, PLaneT is a bit out-dated, but the system itself is great. I don't use it ever, but that isn't any commentary on quality; I have different goals &amp; uses. Next, and last is the CL commentary. iirc, sbcl's issues with Windows have been thread related, and it's been usable, save for threads, for quite some time. Franz's AllegroCL *is* quite expensive, but there is the rather nice "AllegroCL 8.2 Free Express Edition," which, as the name implies, is free. There's also LispWorks personal, UfaLisp, ECL, &amp; a plethora of others. I agree on clisp though; I've never liked it either. So, my recommendations for learning are as follows: **Total newbie** (no functional &amp; minimal programming experience) * PVTS * Racket Nice debuggers, plus Racket has all those nice "Macro stepper" goodies, and Racket has "no ceiling," (yay! a logo-ism) so you can keep using it afterward. **Experienced programmer** (but no real functional experience): * CL (most likely sbcl, but LispWorks, AllegroCL, Clozure &amp; ECL too) * Scheme (Racket, Chicken, &amp;c.). **Heavy Java programmer**: * ABCL * Kawa * SICS * and Clojure if they're used to functional programming, or have a neat use case. **Maths person**: * XLispStat/XScheme (such as WXLispStat); I'll probably catch flak for this, but, esp. WXLisp, it does have many of the features that people are used to from Matlab/Mathematica/R already baked in, and it is Lispy. Build on what people know :D * Scheme ** Functional Programmer**: * Whatever you want, just get a good book. At this point, the concepts are probably similar enough that you just have to learn the specifics of the new language. &lt;/rant&gt; **tl;dr**: whole bunch of stuff. 
You and Anvsdt are awesome! I think he meant something like "Racket is an extended Scheme with very little of the core language changed, as the LISP tradition has been passed down from generation to generation," if that is true. Please note he wasn't saying Clojure was actually more helpful toward getting a job, but was comparing a 10^-7 chance to a 10^-6 one (for example).
&gt; You and Anvsdt are awesome! I happen to enjoy Anvsdt's commentary too. :D &gt; I think he meant something like "Racket is an extended Scheme with very little of the core language changed, as the LISP tradition has been passed down from generation to generation," if that is true. It's certainly possible, and definitely true. Still sounds weird. It might be my perspective; I'm in my mid-20's, but I enjoy looking at old systems, so when I think "old Lisp," I'm thinking *old*. &gt; Please note he wasn't saying Clojure was actually more helpful toward getting a job, but was comparing a 10-7 chance to a 10-6 one (for example). I don't think getting Lisp jobs are *that* bad, especially depending on field (lots of Researchers use CL, for instance, and Scheme is quite heavily used in Academia. Clojure is used quite a bit in Java shops, but I've seen more Scala than Clojure postings in my searches). I still don't see the practical argument as being useful either though; Clojure has some sweet syntax for integrating with Java, sure, but Kawa &amp; ABCL do too (although you could probably improve them). On a data structure note, yes, Clojure is ahead, insomuch as you don't have to do a lot of the leg work yourself to get SMT &amp; purely functional data structures (and some people may prefer the added syntax from Clojure).
Well, please note I did not really intend to take the Clojure route, and he reaffirmed that Racket seemed the best match.
Oh, sure, I was just meta-commenting, and I did see his recommendations to Racket, but I still felt the need to expand &amp; correct certain things. It wasn't anything negative about the meta-OP, just my commentary thereupon. 
&gt; I'm not sure if when asked "Which lisp should I learn, given that I have Java experience?" I would say "Clojure"; I would say: "Learn some Scala, then Kawa or ABCL. After having mastered them, read SICP (hard mode: do it with MIT/GNU Scheme). Now you're mature enough to continue by your own, you just need a good implementation." &gt; I'm also not sure why Clojure would take you any further in the real world; "Parellelization", "concurrency" and "persistent data structures" are the buzzwords of the moment. Non-pure functional languages that are "interoperable" with "modern", "well-tested", "production-quality", "scalable", "enterprise-grade", "xml-enabled", etc, "technologies" are getting popular. Give them some time, they'll love Clojure. &gt; "could you please rewrite this in Java? We have a strict Java-only" You should've said that it enables all the benefits of concurrency, enhances scalability and interoperability with modern evolving technologies. Then they would accept it. &gt; I don't take exception to anything other than "it's an old, old Lisp." I guess he/she is referring to Scheme itself, rather than Racket in specific? Indeed the first Scheme predates CL, but R5RS is still "new", the current standard is ~~shit~~just 3/4 years old and they're working on R7RS. &gt; I agree on clisp though; I've never liked it either. There's no real reason to use it either. I agree with the rest. (s/SICS/SISC/)
&gt; I would say: "Learn some Scala, then Kawa or ABCL. After having mastered them, read SICP (hard mode: do it with MIT/GNU Scheme). Now you're mature enough to continue by your own, you just need a good implementation." Well, I agree if the question is "which really useful JVM-based languages should I learn?", although Clojure is part of that group too. If the question is "Which lisp should I learn, given that I have Java experience?" just remove Scala and I think you're there. Scala would definitely give you a good broadening to your background though. &gt; "Parellelization", "concurrency" and "persistent data structures" are the buzzwords of the moment. Non-pure functional languages that are "interoperable" with "modern", "well-tested", "production-quality", "scalable", "enterprise-grade", "xml-enabled", etc, "technologies" are getting popular. Give them some time, they'll love Clojure. That's true; Clojure certainly has many of the check-off items. I think it's a great experiment, and a really nice language for certain things, but I agree with you, I do think it's a bit over-hyped. &gt; You should've said that it enables all the benefits of concurrency, enhances scalability and interoperability with modern evolving technologies. Then they would accept it. Maybe at other shops, but that one (I no longer work there) was known for being extremely skeptical of new tech; they had several Solaris 2.6/7 boxes running, and were just starting to evaluate moving away from Java 1.4. &gt; Indeed the first Scheme predates CL, but R5RS is still "new", the current standard is shitjust 3/4 years old and they're working on R7RS. I actually like ERR5RS... oh, you meant R6RS. I think their hearts were in the right place, but the result was still really weird. R7RS is coming around so quickly because I think many implementors were wholly unsatisfied with R6RS; R7RS's "small" working group is meant to actively court such people. It's an interesting idea, but I'll most definitely be taking a "wait-and-see" approach. &gt; I agree with the rest. (s/SICS/SISC/) Woops, yes, the Scheme system, not the mainframe program :D
I'm only aiming at scheme48. The main implication of making scsh a library is to not have the burden of maintaining a fork of scheme48 as previous scsh releases have had to. After it's up an running though, scsh could be used as the basis of some standardization on scheme Posix interfaces. Because of the nature of scheme48's module system, a good portion of the code could be used on another implementation without modification.
This is a fantastic question. I learned about the internals of Scheme from [TinyScheme](http://tinyscheme.sourceforge.net/), though having done so I can't really vouch for the internals. I think there are easier to understand ways of approaching many of the implementation issues in Scheme than what TinyScheme does. TinyScheme did inspire me to write my own small lisp, [b00t](http://makeutil.cvs.sourceforge.net/viewvc/makeutil/makeutil/b00t.c?view=markup). It isn't Scheme, and some parts are easier to understand than others. I do think many of the techniques I use in that program are easier to understand. I'll be curious to see what other people say.
you might be interested in [Scheme 9 from Empty Space](http://www.lulu.com/product/paperback/scheme-9-from-empty-space/13002199)
Your intuition is correct. Scheme is more difficult and less practical than Python. People like me who pick Scheme over Python probably do it because they like difficult, impractical things that are nonetheless beautiful.
You could also look at the version by Peter Norvig, written in Python. Very clear, and easy to understand. I'm sure the google will find it for you.
It relies on Python functions and types, though. You can study how to write a simple interpreter, but not the internals.
My advice start reading: "Lisp in Small Pieces" by Christian Queinnec. Through several iterations and an increasingly number of details of a Scheme implementation is studied. All code is in the book - no cheating there. 
I have mirrored Nils Holm's scheme 9 from emtpy space [here.](http://pestilenz.org/~ckeen/s9fes/)
I'm not sure from your question what level of understanding you're looking for. If you're learning how scheme is implemented for the first time, * [Scheme In One Defun](http://www.cs.indiana.edu/scheme-repository/imp/siod.html) was written specifically to be compact and easily understood. * [An Incremental Approach to Compiler Construction](http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf) (PDF) walks step-by-step through the implementation of a compiler, written in scheme, from scheme to x86 assembly. 
&gt; written in scheme, from scheme to x86 assembly. That's what I was looking for! Thank you*!!*
Not having to fight with your language, having it behave and look just like you want, you can build your domain-specific constructs, etc. See also http://www.reddit.com/r/scheme/comments/f5kxh/can_you_produce_programs_as_fast_in_scheme_as_in/ http://www.reddit.com/r/scheme/comments/ft2q5/using_scheme_for_practical_projects/
So... Chicken is now fastest, at least to the user?
&gt; having it behave and look just like you want, you can build your domain-specific constructs, etc. I've head this before, but don't understand what it means. Does it simply mean building functions upon functions until you've got ones that map very nicely to the problem domain? 
I think Ikarus Scheme is pretty interesting. It's "incrementally compiled", as described [here](http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf). [PDF] 
Yes, with the addition that in Scheme, by way of macros, you can control the syntax used to combine these functions. That is a piece that python doesn't have.
Tail calls are implemented correctly. Here's a silly example: (define (even? n) (or (zero? n) (odd? (- n 1)))) (define (odd? n) (and (&gt; n 0) (even? (- n 1)))) (even? 123456789) ;; works fine! 
Reading a reply of yours in another thread here in /r/scheme, let me elaborate on my comment a bit. I'm currently working on an iterator-based data processing library in Python. I can compose several activities as might be seen in an iteration: x = source() x = map(fnMapProc, x) x = filter(fnFilterProc, x) x = sync(x) x.iterateFromSource() In the above python code, I'm retrieving some data from a source, calling a function over each record, filtering some of those records, and then writing the data to my sync. The basic idea of the library is that I have all of these operators that I can combine, and they track some domain-specific state as data passes through them. This works pretty well, but if I the program crashes, my stack trace isn't following the path my data is taking: it starts at iterateFromSource and winds through some internal library routines to point at whatever piece of code crashed. If I were writing this system in Lisp, I'd create a mini-language (through the macro system) to express the operations I'm expressing above, but in a way that I could transform the resulting code into something that aligned the stack and the data processing path, so on error I'd be able to see where I was in my iteration. I can achieve the same effect in python, but I don't get any syntactic help in doing some. I have to spread the implementation of such a feature around to various parts of the library because I don't have the ability to implement it syntactically. I'll eventually achieve the same effect, but I have to work around Python rather than have it support my expressing the problem in a natural way.
Why not the same algorithm?
Generally, Scheme has a very clean way of modeling control flow in terms of lambda. In practice, this makes you feel like you have much of the flexibility of machine code (first-class labels and goto) but you can use the high-level terms of the lambda calculus. For a very good description of how a Scheme compiler can translate lambdas to low-level gotos, see Guy Steele Jr's RABBIT compiler.
I was just copy pasting the code that was there. 
Thanks for the elaboration, alanpost. &gt; If I were writing this system in Lisp, I'd create a mini-language (through the macro system) to express the operations This is what I don't get. Could you show me an example of what this mini-language would look like in use? I can't get past imagining something like: (define x (source)) (set! x (map fnMapProc x)) (set! x (filter fnFilterProc x)) (set! x (sync x)) (iterateFromSource x) 
Awesome! Thanks for the link, mate.
The best examples that I can think of: * CLOS: The common lisp object system * CL's loops * Lazy Racket: added lazy constructs to scheme * Typed Racket: added a type layer implemented in macros to scheme It doesn't have to be large things... even minor things can be encapsulated. You know the following pattern: try: acquire resource do something with resource except some error: bla blah finally: release resource There are several with- macros (e.g. with-open file) that encapsulate this process. Peter Norvig's Paradigms of Artificial Intelligence has many good examples on good macro usage, including one to build a compiler for prolog in lisp. To summarize: they've been used to do insanely powerful stuff (implement typed layer on a language), but you can create your own macros to simplify your life without much difficulty too. 
The first thing I would do is remove all references to the variable x and make the order things are listed in the file be the order they're run in. I'd have the macro pass the temporary variable to the invocation on the next line, allowing me to write: source() map(fnMapProc) filter(fnFilterProc) sync() iterateFromSource() Then I'd nest all of these calls so my stack was the same as the way data was moving through the module: source(map(fnMapProc, filter(fnFilterProc, sync()))) I'm trying to express with the above code that sync is at the bottom of the stack, having been called from inside filter, which is called from inside map, which is called from inside source: source |-- map |-- filter |-- sync The macro then, in this example, would create the temporary variables that are used to tie components together, and would reorder the calls to be properly nested while allowing me to write them each on a line. The input form is the way I need to work with the iteration chain (I'll often reorder lines, insert new ones, comment old ones out, &amp;c) while the end result after macro transformation is how I want the code to execute (the stack trace is identical to the way data is flowing through the iteration.) while allowing me to remove code (the temporary variables) that are there for python but don't contribute to a homo sapien understanding the code. This example is a bit contrived/simplified, but I hope I've communicated the essential idea of writing code to be easy to change while also being able to transform it into code that conforms to my runtime constraints.
Clojure has a great construct for this known as the "[thrush operator](http://clojuredocs.org/clojure_core/clojure.core/-%3E%3E)". It's implemented as a macro in Clojure and could just as easily be implemented in Scheme. Here's how you would rewrite that code using it: (-&gt;&gt; (source) (map fnMapProc) (filter fnFilterProc) sync iterateFromSource) which is actually just a nicer way of writing (iterateFromSource (sync (filter fnFilterProc (map fnMapProc (source))))) which computes the same value without storing intermediate results in a variable. You cannot create this construct in Python. Your only options are deep nesting or using a variable. The fact that you can in Scheme and other Lisps is the one big thing that continues to set them apart from other languages.
&gt; Does it simply mean building functions upon functions until you've got ones that map very nicely to the problem domain? No, not at all. It means using macros to define new embedded domain-specific languages that integrate with the rest of your code seamlessly. Even though everyone here is saying "macros!" (for good reasons) it's still not the whole story of Scheme. Scheme has many features that works together in non-obvious ways. That's why after a while a new Schemer will exclaim "I get it now!" once they see how everything gels together. [The Swine Before Perl talk by Shriram Krishnamurthi](http://www.cs.brown.edu/~sk/Publications/Talks/SwineBeforePerl/) will give you a preview of what that looks like.
&gt; and could just as easily be implemented in Scheme. Indeed, it was so nice I couldn't resist, I [had to implement it](http://paste.lisp.org/display/120156). Now it can "parallelize" (and it could be easily extended to do actual parallelization, but that's too implementation-specific)
&gt; Scheme has a very clean way of modeling control flow in terms of lambda. When you grasp the power of `lambda`s, you'll start writing loops with just Y combinators.
I'm going to take a stab at this - I'm not that experienced with LISP/Scheme, but I ran into some cool practical application of using macros in emacs LISP. So, I'm working on something with a custom buffer that holds text for a console-like display, and to the client, the text is read only. To update the buffer, I'd have to do something like this: (let ((buf (get-buffer-create "display"))) (set-buffer buf) (setq buffer-read-only nil) ;; do stuff (setq buffer-read-only t) (switch-to-buffer buf)) Here, I'm getting the buffer (creating it if it does not exist, but it often does), setting it to editable, erasing it, filling it with text, setting it back to read only, then switching it to the front. Every time I need to change the display, I'd have to write this. In Python, I'd have to do something like this: # get or create the buffer - if exists, unlock it buf = getTheDisplayBuf() # do stuff lockTheDisplayBuf(buf) So, for a variety of functions, I have to remember to do this anytime I need to manipulate the buffer. With LISP/scheme, I can create a macro that addresses this (I'm putting this together from memory, so I'm not guaranteeing this is runnable code, but you should get the gist): (defmacro with-display-buffer (&amp;rest subexprs) '(let ((buf (get-buffer-create "display"))) (set-buffer buf) (setq buffer-read-only nil) ,@subexprs (setq buffer-read-only t) (switch-to-buffer buf))) With that macro, I can edit the buffer easily: (with-display-buffer (statement) (statement)) And it will get the buffer, unlock it, etc. If I added error handling, it would be exception safe (equivalent to a try-except-finally block in Python). This is what I imagine people are referring to when they talk about creating a DSL with macros. With Python, you can do this particular type of thing with decorators - not sure how those stack up to macros. I suspect macros still have an edge, but then I've become more of a LISP/Scheme fan recently. Edit: multiple edits - I suck at posting
Thank you, that's it!
Thank you all so much. I guess I will start with SIOD and the incremental approach, then S9fES or LiSP.
I tend to use Python more than Scheme, but knowing how Scheme works, I tend to get frustrated quite often with the way variable capture works in Python, and prefer how closures work in Scheme. That said, I use Python more often because it has the tools I need to get the job done quickly, especially numpy/matplotlib which I use all the time (has replaced matlab for me). I'd prefer writing a large application in Scheme in some ways, but never do it because of library issues. Also, the Python module system is quite nice. (In terms of how it deals with namespaces.) For writing real applications, one thing I like about Scheme is that I can compile it to an exectutable using Chicken, Gambit or Stalin. I wish I could do that with Python. Basically I'd love to use a Scheme that has all the advantages of Python. 
Better support for tail calls, non-retarded syntax, more functional programming. Conceptual elegance. Named let! People love macros, but I am not a huge macro writer. But it is nice to have them. Actual lambda expressions.
&gt; You cannot create this construct in Python. Aside from its name, why not? This example is actually an example of a functional construct. Here is a rough approach in perl, and keep in mind that I toss in a few workarounds to make perl a wee bit more functional/curried. The point is that this is one of those occasions where some good functions could be used instead of macros. use strict; use warnings; use List::AllUtils 'sum'; sub run_actions_in_order { my $action = pop; if (@_) { $action-&gt;(run_in_order(@_)); } else { $action-&gt;(); } } sub fmap (&amp;) { my $code = shift; return sub { map {$code-&gt;($_)} @_; }; } sub fgrep (&amp;) { my $code = shift; return sub { grep {$code-&gt;($_)} @_; }; } print run_actions_in_order( sub { 1..10 }, fmap {$_ + 1}, fgrep {$_ &lt; 7}, \&amp;sum); EDIT: I like this example better: http://news.ycombinator.com/item?id=2144880
Some may joke, but today I've solved a real business problems by emiting folds over C struct data types. Now we have a single pickler function (which invokes the fold for the particular struct) instead of one for each data type. And because fold threads through state, it even implements proper error handling. This is all in C++ of course, but having a lambda-friendly language makes life a lot better ^_^
 * Faster.http://shootout.alioth.debian.org/u32/which-programming-languages-are-fastest.php * Saner scoping rules, decent lambdas. * I find that my Scheme code has less errors than my Python code. I don't know if it's because I don't mutate anything or have to think a little harder when writing Scheme, but I can write 1000s and 1000s of lines of Scheme and not have to touch it again. The disadvantages: * libraries. At the moment I'm using gevent and ZODB in Python. There are no similar libraries in Scheme. * A different paradigm to what most programmers are used to. Something to consider if you are on a team of programmers or eventually want others to contribute to your project. * More verbose.
I'm porting my chess engine from Clojure to Scheme in order to finally learn Scheme. One thing I miss are the -&gt;&gt; and -&gt; macros. It clears up the code structure. Could probably try to write those macros myself.
I [implemented](http://paste.lisp.org/display/120156) and improved them a few days ago. If your implementation doesn't have `syntax-case`, you can use [the plain old ones](http://paste.lisp.org/display/120240). *edit: re`paste`d*
Why so much hate for r6rs? I liked it.
[Typed Racket](http://docs.racket-lang.org/ts-guide/index.html) / [contracts](http://docs.racket-lang.org/reference/contracts.html) / [structs](http://docs.racket-lang.org/guide/define-struct.html) &amp; [struct properties](http://docs.racket-lang.org/reference/structprops.html) / [Swindle](http://docs.racket-lang.org/swindle/index.html). Pick your poison. (Virtually, all the code you write is \`\`generic'')
Hi, thanks for the suggestions. I'll comment (as far as I can tell, correct me if I'm mistaken) each one individually: - Typed Racket: allows me to write polymorphic methods but provides no way to associate a function with a type. - Contracts: I might be able to require the arguments to respond to a set of functions, but then, that does not help me associate a function with a value/type. - Structs &amp; struct properties : allows me to associate a property but not a generic function? - Swindle: Well I'm not familiar with CLOS but, since this an object system, I guess it supports interfaces of some sort. I'm going to investigate this one more deeply, thanks!
Generic programming means a lot of things. With Typed Racket and struct, you could define your wrapper struct and derive from that. Same with contracts and structs/struct properties. Swindle is the fastest way to get what you want.
This guy thought it was practical: http://philosecurity.org/2009/01/12/interview-with-an-adware-author
PLaneT is certainly not inactive -- people upload new packages all the time. I don't know where you got this information.
That's because Planet isn't inactive.
There are many dead packages, and it could be *more* active. You can't deny it can be improved.
Certainly there are packages that haven't been updated, and probably won't be. Do you think we should take them off the repository? Plenty of other packages that people might want to use depend on them. Could it be more active? Well, it's not as active as CPAN, so yes, of course it could. If you posted some packages on it, it would be more active. :) Can it be improved? Of course. We're working on that. See here: http://lists.racket-lang.org/dev/archive/2011-February/005783.html
&gt; Certainly there are packages that haven't been updated, and probably won't be. Do you think we should take them off the repository? Plenty of other packages that people might want to use depend on them. Sure, you can't, but there are packages that now are in the core distribution. Forced backwards compatibility is the root of all evil. *coughc++cough* &gt; Could it be more active? Well, it's not as active as CPAN, so yes, of course it could. If you posted some packages on it, it would be more active. :) I would, but I'm not enough an expert programmer to do it. &gt; Can it be improved? Of course. We're working on that. See here: http://lists.racket-lang.org/dev/archive/2011-February/005783.html When I said "it can be improved", I had that in mind.
You must convince the others, then.
I don't see what you think is "forced" about keeping working software around so as not to break things. There are Planet packages that (a) work and (b) depend on some of those packages that have since been integrated into the core. You seem to be suggesting that they be intentionally bitrotted. 
Upvoted for the nostalgia experienced from the SIOD link upon reading the info for Silicon Graphics and Digital Equipment Corp. The unattainable head cheerleaders of my programming high school.
Good ol' Shivers. Apparently this got him in some trouble with the head of his department. :-P
It depends on the project. As most scheme implementations have pretty terrible libraries imo, and almost no interoperability, these days Scheme is best at competing with xml or hand rolled config/scripting languages. Basically, if you plant to have a lot of configuration in your system, you would use ini files or xml files or json. But if you choose s expressions then you can immediately use a Scheme like Guile. The benefit here is that it's not [XML](http://doc.cat-v.org/xml/the-case-against-xml) and not [Javascript](http://oreilly.com/javascript/excerpts/javascript-good-parts/bad-parts.html). In fact, I know of at least two projects where old crappy Fortran was reverse engineered to configuration files (some Fortran tends to be thousands of lines of 'if else' statements). One used xml and one of these projects uses S expressions which later matured into using an home rolled Scheme which called out to existing Fortran and C libraries. But this certainly isn't a greenfield project. However, I don't think one should oversell Scheme. If you're text or numerical processing, Python have some nice tools for doing that. Also, if you're building a tool for programmers who already use a lot of Python, it's best you keep supporting Python. I mean the original question is a bit like asking what some advantages of speaking Spanish over English are.
Is there a back-story?
Jack 'n Zac? Comedy gold.
Looks great! Coming from someone with a lot to learn, to me this looks like very idiomatic scheme :) I implemented a [tiny infix parser](http://demonastery.org/57/a-scheme-infix-transformer/) as a Chicken Scheme (but hopefully portable) macro not so long ago, although mine doesn't even do any operator precedence.
Looks like a much easier way to do what I spent hours and hours doing. THANKS. All kidding aside, that's an interesting approach to what I'm trying to do, I may have to try writing that myself to see how it goes. Thanks for taking a look!
Looks great to me, good job. I feel like all software licences should be like yours. (I am not joking).
Thanks! It was really tough to come up with. 1). Who would want to pay for shoddy code? 2). Nobody. 3). ??? 4). No profit!
I'm happy to see a parsing project. I have a PEG parser for Chicken Scheme called [genturfa'i](http://wiki.call-cc.org/eggref/4/genturfahi). I've written dozens of parsers over my years doing software development, it is an area I really enjoy working in.
Pardon the snarky-sounding tone, but Racket is a Lisp, so the answer is "no, by tautology". Can you clarify what you mean by "LISP"? You could mean: (a) McCarthy's Lisp in the 60's, (b) one of the various intermediate flavors in the 70's-80's, (c) Scheme, (d) Common Lisp, or (e) one of the various 90's-00's Lisps. I think being more specific will result in a more useful (less snarky) response.
Common Lisp.
Well, Racket is a Scheme dialect, originally. And Scheme predates Common Lisp by about a decade (1975 and 1984 respectively, according to Wikipedia). I think the only thing to it is that both developed in parallel, using ideas from the other.
Well, the macro system of racket is, as a Scheme dialect hygienic, with `syntax-case` and `syntax-rules`. I'd say that's a rather big step forward from Common Lisp macros (nearly as big as from text-based macros to CL, some might say). It is basically lexical scoping for macros. Of course you can have that in Common Lisp too, before the question comes up. I've seen ports to the system to Clojure, so I'm pretty sure someone ported it to Common Lisp already.
Racket even goes farer in the macro domain, with syntax-parse, presented in a [recent paper](http://blog.racket-lang.org/2011/03/languages-as-libraries-pldi-2011.html). Racket also has [defmacro](http://docs.racket-lang.org/mzlib/mzlib_defmacro.html), which is the same as in common lisp. However [Cliki says](http://www.cliki.net/syntax-case) that "no implementations of SYNTAX-CASE for Common LISP are known of.".
I believe Racket is largely used as a research and education language, but I may just have that impression from attending Northeastern University, which is sort of a hotbed of Racket development. :-P
&gt; Racket also has defmacro Yes, as most Schemes have, definitely those before R5RS. As it is quite easy to build, no wonder. I didn't know about `syntax-parse` yet, thanks. Apparently the [Clojure port](https://github.com/qbg/syntax-rules) does also support `syntax-parse`, but no idea how hard it is to port to CL or even how well it works.
Since you've seen it in use, could you comment why you think it hasn't caught on, even in the functional development circles? It seems to be pretty capable, it's sandbox mechanism is great, the macros, the multiple languages on the same runtime, the gui, etc. I'm baffled as to why it seems to only be used in education.
No idea, I'm afraid.
I think a lot of FP research is focused on static program verification, such as type checking and side effect analysis and isolation. While typed racket is closing the gap, Haskell and other ML-family languages have a lot of mindshare. 
&gt; And Scheme predates Common Lisp by about a decade (1975 and 1984 respectively, according to Wikipedia). Yes, but CL was derived from Symbolics Lisp (Zeta Lisp or Lisp Machine Lisp) &amp; InterLisp, which are of the same vintage as Scheme (and indeed, come from the same well spring, MACLISP). I also don't know what that matters; Scheme being older doesn't really add anything to the argument, does it? I mean, if all we needed were powerful, standardized, old languages, we would all be using something like Algol68. 
Older implies a break in the causality chain. As you described yourself, Scheme isn't a reaction to Common Lisp, but rather grew along an parallel genealogic line, with occasional crossover.
&gt; Older implies a break in the causality chain. Well, my point was that CL isn't *really* that much younger than Scheme is, if you consider that it's Mostly Zeta/LM Lisp plus a few goodies. I think the break in the "causality chain" from Project MAC &amp; MACLISP is that they have entirely different focuses: Scheme was made to test Hewitt's actors, and CL was made to be a reasonable accommodation of misc Lisp dialects. What I mean to say is, I believe mentioning the age misses the point, as there are quite a few Lisp dialects that have nothing to do with one another, aside from being Lisp dialects, yet I wouldn't think the age is the distinguishing factor, the *reasoning* behind the dialect's creation is. 
Agree wholeheartedly. 
I would say [umb scheme](http://www.cs.umb.edu/~wrc/scheme/) is easy to understand and modify as is [libscheme](ftp://ftp.cs.indiana.edu/pub/scheme-repository/imp/libscheme-0.5.tar.gz), in which Racket is based. Of them, I would recommend umb, because it includes a garbage collector and implements the whole thing, including continuations and the numeric tower. The code is about 14 years old, but don't worry, it compiles cleanly using either gcc or mingw. 
It means that in Racket, we've developed a type system, two module systems, two object systems, an extensible pattern matcher, a contract system, multiple domain-specific languages for writing macros, implementations of prolog and datalog, many languages for teaching, a language for functional reactive programming, implementations of the two most recent Scheme standards, an implementation of ACL2, languages for writing stateless web servlets, a language for writing slide presentations, a language for modeling and executing formal systems, a language for writing papers and documentation, a set of loop comprehensions, and so on, *all as macros*. Citations and explanations [here](http://bit.ly/langlib) [pdf]. Plus, Racket supports lightweight threads, delimited continuations, true parallelism, in-language/in-process code isolation, an expressive set of concurrency primitives, kill-safe synchronization, an extensible IDE, language-integrated documentation, generic functions, a really nice C interface, a set of cross-platform gui libraries, a fast JIT compiler, and more. Plus, a language-integrated set of hundreds of user-contributed libraries. 
It's always hard to know why languages don't catch on. I think we're growing though. And it's not just used in education -- there are companies using Racket in industry.
Please use the full URL instead of a bit.ly link, or at least give a PDF warning. Thanks!
Sorry bout that. I can just remember the bit.ly link more easily.
Thanks!
I think this is really great thing you're doing. If you're aiming to sell more copies may I suggest offering up a "sample chapter" of some sort for people to read before buying? (or you may have already that I've just missed). If I felt that I was more capable of writing a decent review then I'd love to help out, but I think there are others that will do a much better job than me.
I often hear from people who liked my books and only discovered them by accident. I guess that selling stuff is not exactly one of my strengths. :-) In the past three or four years I have sold less than 100 copies of S9fES (1st and 2nd edition combined) and even fewer of my other CS textbooks and novels. Feedback is predominantly positive, though, so I guess this is a "marketing" problem. BTW, I am not planning to make any "real bucks" with my books. I wrote them for fun, quite a few people found them useful, so I think that a little more exposure to the public would be a good thing. Not that I don't like the occasional royalty payments, though. ;-) EDIT: I forgot: there should be preview on the Lulu product page, but I have no idea if it works, because I do not have Flash installed. And: even if you write a review that is not decent in your opinion or finally decide not to write anything at all, feel free to grab the free book anyway!
I think you should publish the index and a prologue explaining how it differs from the first edition. TIL the second edition wasn't available for free in the first place.
i just went and looked through your book list, and they seem very interesting indeed! what about 'zen style programming' makes you call it obsolete?
Oh man, I would LOVE to read about implementing Scheme in C. I'll review it (if you don't mind me taking the time to work through it first!) :D
If this book is half as good as the first edition, and considering it's a second edition I'd expect it to be even better, it is written in pure awesomeness. I've been having little time, so I managed to get just to the half of first in the last month, but it's **great**. It's sad to see it sees low sales, though. Can't afford one right now, but I'll probably buy the new edition in hard copy (Yeah, digital is "ok", but nothing beats paper, to me) in a few months for sure!
I bought the paper version a year or two ago. A wonderful book, very interesting -- the diagrams and linear style brought the code together very well.
Pull up Dr. Racket or get Emacs+Quack. Chances are you want a REPL. Any dialect of Scheme should work with The Little Schemer... just make sure to start by defining the atom? command (definition is in the beginning of the book). You will be building your coding tools throughout the book, so all functions should be pretty basic. Just type a piece of code (like (+ 3 4)) into the evaluator and see what it outputs.
ITYM that the clojure port supports `syntax-case`. `syntax-parse` is a different beast altogether.
Thanks! That was the problem. I actually skipped over everything in tLS and went right to the 1st chapter, as the person who recommended it to me said that the best way to read it was to not have an idea what it was talking about. Unfortunately that means I missed the chapter on how to actually use the damn language. Cheers.
Why so sure that you got lots wrong? Looks like a good start. But you didn't implement any special forms that I can see, including the minimal 'quote. And I think you need a special case for NIL to be self-evaluating.
My idea was to implement an interpreter where I could explore different ways of combining/implementing special forms and other primitives. You'll find quote, set!, define, equal?, etc in the scheme_in_lispy.chicken file. This file is loaded when the interpreter starts. That's my interpretation of "languages as libraries" in that you can swap out languages simply by loading a different language. I haven't played around with Racket too much, but I believe this is how they do it (r5rs, pretty big, etc.) I do have to get around to hot-swapping languages while the interpreter is running, but for now I'm trying to cleanup a few of my projects, as I'm going to be looking for my first programming job soon. That's one of the reasons I wanted some feedback on this. And it's not so much got stuff wrong, as used inappropriate idioms or wrote inefficient/unsafe code. Thanks for taking the time to read it/comment!
Welcome; it's interesting to see. Anyway, that's what I get for speed-reading; I forgot to look at your other files. My comment about NIL still seems to the point, though, since it's not a boolean in Scheme, unlike Common Lisp. Your structure seems to be nice and concise; I like that. Full implementations get amazingly cluttered by (important) trivia like arithmetic, btw. If you're really into this stuff, [Lisp in Small Pieces](http://en.wikipedia.org/wiki/Lisp_in_Small_Pieces) is a fantastic book -- although it can also be deadly dull and tedious if one doesn't want *that* much examination of the subject.
Thanks for reading and commenting. I was going to allow for NIL to be defined in the syntax layer (define-primitive NIL 'NIL) with true, false and void. Is there a reason why this won't work? Or is the objection that a hash-table access to check for NIL would be too slow compared to putting it in the main cond? This is a reimplementation of another meta-circular evaluator I wrote, specifically made for the blog series. So I tried to make it as simple as possible to illustrate the basic concepts. That's probably why it's clean, but I try to write all my code like that. Thanks a lot for the compliment. You're the first person to read my code and give me comments, so I really appreciate that. I've read LiSP, or more accurately I've skimmed it a few times spot reading things that I was having problems with. It's a really good book. I wish I had the time to read it cover to cover. I'm very interested in the subject and try to read as much as I can. I think it was eval'ing members of a GP population that got me on it.
&gt;I was going to allow for NIL to be defined in the syntax layer (define-primitive NIL 'NIL) with true, false and void. Is there a reason why this won't work? I suppose you could do that, and that is not an uncommon thing to do, but the point is that you have a routine for self-evaluation, and consistency suggests doing the same thing with everything that evaluates to itself. So it seemed a glaring omission there. OTOH, if you simply rely on having NIL eval to itself, then couldn't you be consistent and do the same with #true and #false, and obviate the need for checking for booleans in the self-evaluator? It's not necessarily a big issue, it's just the only thing that leapt out at me. The one minor critique I have of this approach is that it's a bit dangerous for code walkers (or major system changes), that might go into infinite loops, or have extra conditionals to avoid doing so. Then again, that's minor enough that conceivably the elegance of (define-primitive NIL 'NIL) makes it worthwhile. &gt;I think it was eval'ing members of a GP population that got me on it. I did this with simple simulated CPUs before people started doing it with Lisp, and I've always meant to go back and do such things with a Lisp of some sort. I still think that's a very cool topic.
OK. I understand now. I snarfed a lot of features from the underlying Scheme to implement this as simply as possible. I was concentrating on the eval'ing process and not so much on the parsing process to keep things simple. One of the goals of this interpreter is to remove as much as possible from the core (kind of; what's the least I can write and still have a usable language platform). So I'll likely go the route of moving the tests in (self-evaluating? ...) out of that and into the syntax layer later on. Ideally I would like to have the implementation of all those Scheme data types be done in the language layer. If that makes any sense. Which would mean that checking for boolean is redundant, thanks for pointing that out. &gt; The one minor critique I have of this approach is that it's a bit dangerous for code walkers (or major system changes), that might go into infinite loops, or have extra conditionals to avoid doing so. I'm not sure I fully understand this. From my understanding this may cause problems with compiling or source analyzing tools? &gt; I still think that's a very cool topic. I have another project that takes function definitions (and meta-data about them) and tries to self-optimize the functions I write using GP. It is my ultimate goal to fuse these two systems together to get a self-optimizing Scheme that you can use to write programs by unit-tests or prototype functions. I'm not sure if that will even work or be worthwhile, but it's a difficult and fun project to work on.
[ERROR] Unbound symbol like
And a summary of the changes can be found here: https://groups.google.com/d/topic/comp.lang.scheme/MCfPoeir90s/discussion
I actually like Clisp, but from the view of the GNU project it has a big problem, and this is no free documentation. You only have the very dense implementation notes, but no documentation on the Common Lisp language itself. The language standard and basically all available books are non-free. Its a pity that GNU never really encouraged Clisp/Guile usage more then merely mentioning them somwhere. Today, even core GNU projects like gdb and texinfo use non-GNU extension languages like Python and Perl, which is a shame.
&gt;Today, even core GNU projects like gdb and texinfo use non-GNU extension languages like Python and Perl, which is a shame. I feel the same way, however, I then realize that it's just an emotive NIH response. 
I've also recently used Chicken Scheme for a project involving printing (with a mini DSL) via win32 GDI (so plenty of FFI going on), using threading + queues/mailboxes + XML-RPC to expose a printing service to a PHP web form. Chicken is awesome!
I've been watching with some fascination the research that has been going on around type theory, and wondering how it would apply to Scheme. This is the first example project I've seen since I began paying attention. For better or worse, I get bothered when my compiler complains to me about type mismatches; I know there is a cost to my having this attitude: type theory research is really showing me how costly it can be. I'm heartened by this program for that reason, that I can do some semantic analysis without requiring correctness in order to run the program.
you might want to check into PLT's [typed racked](http://blog.racket-lang.org/) language - there is quite some movement in the racked project and especially typed racked (which was typed scheme before they changed the project name to racked) gets a lot of love it seems.
Thanks!
We've folded in all of these to Guile's compiler now, I think. When you compile code, it will warn if it finds things amiss. The only thing I saw that was not handled were argument and expression types.
Except, as noted by a poster on HN, it only processes the first two items in a list: (+ 1 1 1) ; yields 2 No thanks. Reminds me of those folks who say "lisp in JavaScript" but without lambda.
As noted by another poster on HN, there's already a pull request for proper support of that.
Wow. That's amazing.
Oh lord, implement this into Awful and I think you won't have to touch a single bit of non-scheme code.
Is there any possibility to get Guile related news on Planet Scheme?
Link to "awful"? No idea what you're speaking of.
http://wiki.call-cc.org/eggref/4/awful
Yeah, that would be neat. It shouldn't be very difficult to have working once you know how to use spock. The awful part is, ironically, very easy. [awful](http://wiki.call-cc.org/egg/awful) + [spock](http://wiki.call-cc.org/egg/spock) + [scss](http://wiki.call-cc.org/egg/scss) + [ssql](https://gitorious.org/chicken-eggs/ssql) would give you a full set of parenthesized DSLs for web programming.
"Systems programming" means implementing a web server? I always thought this term referred to writing operating systems and device drivers, etc.
From an SA perspective I thought it meant replacing shell scripts. Seems we are both wrong.
The article is about threads and processes which is pretty "system level". The final product is a web server.
I thought too: http://en.wikipedia.org/wiki/System_programming "System programming (or systems programming) is the activity of programming system software." http://en.wikipedia.org/wiki/System_software
X is systems programming if writing X in C requires reading (or knowing) the Stevens book. By that definition, this qualifies.
I don't use MIT/GNU Scheme personally but according to their [website](http://www.gnu.org/software/mit-scheme/) they now have x86-64 binaries available.
You can compile it yourself. They have released a 64bit UNIX binary that is rather easy to compile and install (compared to compiling the native c version). http://www.gnu.org/software/mit-scheme/ Edit: you can use "sudo apt-get build-dep mit-scheme" to install all dependencies
Racket with DrRacket works fine.
Most of the scheme to C compilers should work. Guile, Chicken, Gambit, etc.
&gt; the only good thing was syntax-case Which lots of people don't like anyway (including me)... But I do hope R7RS will be a nice language.
Is the solution to manually reset the scope of the body forms to the scope of the internal with-x identifier?
The solution is to replace `stx` in `(datum-&gt;syntax stx 'x)` to `#'val` or `#'(body ...)`. I don't know how to explain it, but now it doesn't work because `stx` comes from `with-x*`, so `x` will only be visible inside it. To make it visible outside, you also need something that comes from there. Someone more knowledgeable than me will surely give you a more detailed/correct explaination.
I think I get it - stx might not necessarily reflect the correct lexical scope, whereas the scope of val, for instance, is unambiguously the same as the body. 
Not quite what you've asked for... (define-syntax my-proc (syntax-rules () ((my-proc binding) (list 'binding binding)))) &gt; (my-proc fruit) (fruit (apples oranges)) &gt; 
I should explain: when you call a function with some arguments, the arguments are evaluated before being passed to the function. The code inside your function never see the `fruit` -- it sees `'(apples oranges)`. A macro, because it's used to add syntax to the language, is passed `fruit` instead. That's how things like `if` can be implemented on top of `cond`. `if` can't be a function because in the case of `(if test-form true-form false-form)` all three forms will be evaluated before being passed to `if`.
If you look again, you'll see that my example passes `'fruit` to the procedure. Because the program evaluates `fruit` to `'(apples oranges)`, as you pointed out, I thought there must be a way for a procedure to evaluate the symbol to the list. After reading the Racket Guide some more, there seems to be a distinction between identifiers (like `fruit`) and symbols (like `'fruit`) that I need to think about some more. My background is in more conventional programming languages. 
Macros aren't something I've tackled just yet, but maybe it's time. 
This is Racket specific: (define-namespace-anchor this-module) (define fruit '(apples oranges)) (define (my-proc symbol) (list symbol (eval symbol (namespace-anchor-&gt;namespace this-module)))) (my-proc 'fruit) Though this is not what you'd usually do.
&gt; If you look again, you'll see that my example passes (quote fruit) to the procedure. This works for me: (define (myproc sym) (list sym (eval sym (interaction-environment)))) 
I'm sure it's possible to do what you want to do, but IMHO it's not something that you should want to do. You should think about the names of values in your program only as a convenience for the programmer - in many implementations the name table only exists during compilation, not execution. In order to provide the facility to convert from a symbol to its value, the name table would have to exist in runtime as well, as there's no way to know what the "value" of a symbol is until runtime. On the other hand, as Common Lisp does have support for accessing and modifying the name table during runtime, you may want to look into using that instead.
Haha, you saw that I mentioned this earlier today, huh?
No conforming scheme is required to allow you to perform this action, and from what I know about the style of Racket, I'd be surprised if it did. Values are associated with symbols at compile time only - when the program is compiled, and subsequently run, only data is moved around. The compiler is free to completely discard information about names. Scheme leans heavily towards the static end of the lisp spectrum, which is why I wouldn't expect this information to be generally available. Also, consider the meaning of the expression: (define (my-procedure a-symbol) (list a-symbol (symbol-&gt;value a-symbol))) The idea with lexical scope is that the value of a variable is apparent entirely by looking at the text around the variable. In this case, `(symbol-&gt;value a-symbol)` is, lexically, obviously undefined. There are many things you could do to simulate this, but I would simply write: (define (tag tag val) (list tag val)) ;;; or, a bit cheekily: (define tag list) Here we pass in both the tag and the value. Others have suggested whipping up a tiny macro (not worth it in this case, in my opinion, but go for it - whipping up tiny macros is the best way to learn). 
scheme = skeem schema = skeem-a
Thank you!
Scheme is the same word as scheme.
Scheme is pronounced scheme, as in a scheme. That is all. ;-)
It's /skeem/ as in what a [schemer](http://community.schemewiki.org/?scheme-faq-general) does. &gt;According to Steele and Gabriel's "The Evolution of Lisp" paper, Scheme was originally called Schemer, in the tradition of the AI languages Planner and Conniver. But the ITS operating system had a 6-character limitation of file names, so the names were shortened to PLNR, CNVR, and SCHEME 
&gt; My background is in more conventional programming languages. What conventional programming language lets you do this? It seems like what you want here is really a hashtable or some similar data structure.
That's what threw me off: Schemer could go either way... Anyway, I need to be certain because I don't want to look like a idiot when I suggest a Lisp or Scheme-like scripting language.
Really? I'm British and theres no way “schemer” and “schema” are homophones for me. YMMV
Схема
I guess I was thinking of symbols as being like pointers. Each one has an inherent value as well as being bound/pointing to another value. All I have to do is dereference it, right? Well, as I'm learning, no. 
You can't do that with any old variable in C either unless it's declared to be a pointer. And that's because the *value* bound to the identifier is a memory address. It's not something special about the identifier. If you wanted to deference a value in Racket, you can do that by using boxes. e.g.: (define (get-fruit fruit-box) (unbox fruit-box)) (get-fruit (box 'banana)) evalutes to 'banana. However, if you're using boxes and mutation then you're probably not thinking like a functional programmer. I recommend you read [How to Design Programs](http://www.htdp.org) to get some background in FP. The Racket Guide is good, but it doesn't teach you FP.
More like, a symbol is an offset from a pointer. Given some execution environment, the symbol names a cell that can hold one value at any particular point in time. I think what you're looking for is eval, but there's no portable way to capture the currently executing environment. Many Scheme systems will use the environment of the interactive prompt if you omit that argument to eval. Eg: Welcome to Racket v5.0.2. &gt; (define a 1) &gt; a 1 &gt; (eval 'a) 1 &gt; (let ((a 2)) (eval 'a)) 1 &gt; (eval (read)) a 1 That's the most you can do using the symbol, the name of the variable, at runtime. However, if you want to capture access to a particular variable, that's a bit easier -- you can just capture proceedures to read and write to the variable: &gt; (define set-a #f) &gt; (define get-a #f) &gt; (let ((a 2)) (set! set-a (lambda (x) (set! a x))) (set! get-a (lambda () a)) a) 2 &gt; (get-a) 2 &gt; (set-a 3) &gt; (get-a) 3 This will work across hygienic macros, top level and local scopes, you name it. Edit add: I just noticed that anvsdt already said this [here](http://www.reddit.com/r/scheme/comments/h6scd/novice_how_to_get_the_value_bound_to_a_symbol/c1t10fo)
I speak with a Lisp, so...
спасибо!
It's pronounced "shee-mee".
Could be from Boston. For many native Bostonians, "often" and "orphan" are homophones.
Page won't load. In the meantime, keep reading this list until you understand every item: http://clojure.org/lisps
a better link would be one directly to the video which can be found on vimeo [here](http://vimeo.com/22675078)
Anyone got a link to the slides for the *bandwidthly challenged*? aka New Zealand :)
I saw that. The bigger issue is that the developer has no intention to maintain or develop this due to lack of time. Which is fair enough but a bit of a shame. Wonder how hard it would be to port the interesting bits of this to Spock.
Sweet. I was thinking of switching from JavaScript to CoffeeScript myself for projects. How much does CoffeeScript simplify language implementation work? Does it add much overhead over coding directly in JavaScript?
It pretty much maps one-to-one onto Javascript. There is nothing added to the language it just simplifies things like iterators and classes.
Petite Chez Scheme has a 64 bit version. http://www.scheme.com/download/
What would the advantage/differences be in using this compared to [pattern matching](http://docs.racket-lang.org/reference/match.html)?
Man, maybe nothing? I hadn't really been aware of how comprehensive this pattern matching library was. It seems that there must be a way to specify default values in pattern matching? If not, this library features that. This isn't the first time I've discovered I've reinvented the wheel in Racket/PLT scheme.
Can you elaborate on "Saner scoping rules, decent lambdas." Why does it have saner scoping rules and why does it only have "decent" lambdas?
Python lambdas are quite limited. They are one line only, expressions only. I find I often start with lambdas and realise I need an extra line and have to change the format of the whole damn thing. Scoping: the global 'keyword'. Simple as that. » a = 1 »def f(): print a »f() -&gt; 1 »def g(): print a a = 2 print a » g() Traceback (most recent call last): File "&lt;pyshell#8&gt;", line 1, in &lt;module&gt; g() File "&lt;pyshell#7&gt;", line 2, in g print a UnboundLocalError: local variable 'a' referenced before assignment &gt;&gt;&gt; If you are a language designer and you want to baffle and confuse your new users, this is what you do. edit: how do you escape characters on reddit? 
Isn't scheme *designed* to reinvent wheels? I still think it's pretty cool that you came up with that all by yourself. Good on you!