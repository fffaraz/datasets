Upon further reflection, there are some features which are disjoint. My library is certainly more ad-hoc, but sometimes that is what you want. For instance, if you use `match` in Racket, you have to specify the equivalent of a default case and the value bindings and body separately, which is sometimes not what you want to do. On the other hand, match is more like pattern-matching. Because it dispatches on type, you can be much surer that your programs do what they say when you use match. I think for the library I am working on, I'm going to use match for now. See how it turns out. But Clojure destructuring bind is a fun thing too.
If there are things that would be useful to add to `match`, feel free to send suggestions (or patches :). I hope for `match` to serve everyone's destructuring needs.
So have I just not read the documentation carefully enough, or does match have a mechanism to provide default values in the case of a partial match. The use case I am thinking of is is you have a list that might contain four values, or it might contain fewer, and you want to match on that list, binding latter variables to default values if the list is too short. It also might be nice if match matched against abstract types like Racket's `dict`, which is sort of an umbrella for hash tables, alists and vectors (whose keys are indexes). It doesn't quite seem like it does that.
`match` doesn't have either of those built-in. However, they're easy to build yourself. Take a look at `define-match-expander` and patterns that use `app`. If you write them, send them to me (samth at ccs.neu.edu) or dev@racket-lang.org. 
Samth, I'll be sure to. Match is pretty amazing (and I confess I'm using it rather than my own destructuring library in my current project). 
I did notice, by the way, some strange, but perhaps correct, behavior in match. Consider: (struct room (x y w h)) (match (room 0 0 10 10) [(room x y w h) (list x y wh)]) The second phrase does evaluate to (0 0 10 10), which is what you'd expend. Slightly non-intuitively: (let ((room (room 0 0 10 10))) (match room [(room x y w h) (list x y w h)])) Gives an error. I see it is because we've shadowed the constructor of `room`s with our let expression, but somehow this struct me as odd behavior, because the LHS of each match clause is obviously not interpreted as standard scheme. I can see why it works the way it does, however, so maybe it is all as intended? 
The struct form binds the identifier to a [struct info](http://pre.racket-lang.org/docs/html/reference/structinfo.html) in order to communicate to other macros, so if you shadow that id then the match macro can't pick up the struct information (in particular, the predicate and accessors) in order to do the matching.
$0.99 for an interface to an open source project? :( In my opinion, it should be free with an option to donate.
"The application is sold for $0.99 as a demonstration that you can distribute on the App Store paid applications written in Scheme and containing an interpreter, something that wasn't clear with previous versions of the App Store developer agreement." (from [the announcement on comp.lang.scheme](https://groups.google.com/d/topic/comp.lang.scheme/6HQyibUgHMk/discussion))
Yes, structure names are matched by identifier comparison, not by symbol name. The same is true for match expanders, and will eventually be true for all `match` pattern keywords.
Samth, it also occurs to me that it might be nice if match supported recursive match specification/binding. Can that be written with the current formalism? Finally, I note that match-let does not support named-let like operation, which would also be pretty nice. I am not really a programmer in real life. How hard would you say it would be to jump into the code. I'd be happy to try to implement these things if I could.
Last things first -- if you're already implementing binding macros, you're a real programmer! See the code at https://github.com/plt/racket/tree/master/collects/racket/match to get started. `match-let` with named `let` would a great first place to get started. See the file `define-forms.rkt` there. General recursive pattern matching isn't well studied, although `match` provides destructuring of lists recursively. 
From [Guido's blog post](http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html) about this issue in Python: &gt; If you want a short answer, it's simply unpythonic. &gt; First ... TRE is incompatible with nice stack traces... &gt; Second ... Once tail recursion elimination exists, developers will start writing code that depends on it ... &gt; Third, I don't believe in recursion as the basis of all programming. The last reason, and I'm paraphrasing here, is "It's too hard to implement". And that more or less summarizes my problems with python. Oh, and a tidbit from a user named "ablakok" from the comments: &gt; Tail recursion elimination is necessary in functional languages with no side effects, like scheme, but not in a language with explicit state like Python.
Just to ensure readers don't get confused: ablakok is wrong when he says "functional languages with no side effects, like scheme" because scheme does have side-effects. For example, you can set! things. * Edit: I mistakenly attributed misleading comment to Guido
That quote is from a different user in the comments (clarified in the original post). And yeah, the reason I quote it is that it's outright false.
oops. I fixed my original comment.
This made my morning. :-) Paraphrasing: Q: why do you need TCE. Won't GC take care of it? A: you would think so wouldn't you. I look forward to more entertaining fireworks, and maybe another pretentious response from Guido. 
That last one is a funny quote. OO languages (which includes Python!) need tail-call optimization as many people have [pointed out](http://lambda-the-ultimate.org/node/3702) repeatedly. But look at me preaching to the choir...
Well done Chickeners! Looking forward to upgrading once my internet is usable again (damn New Zealand internet plans!)
See notes on the Lisp Curse. :-P
I really enjoyed this episode, and I think Matthew did a great job. I had this on my "to investigate" list, but the podcast re-invigorated me.
Maybe consider working at a higher level? From the main page of racket-lang.org: #lang racket ; Simple web scraper (require net/url net/uri-codec) (define (let-me-google-that-for-you str) (let* ([g "http://www.google.com/search?q="] [u (string-append g (uri-encode str))] [rx #rx"(?&lt;=&lt;h3 class=\"r\"&gt;).*?(?=&lt;/h3&gt;)"]) (regexp-match* rx (get-pure-port (string-&gt;url u)))))
&gt; `(write 'ping to-server)` If you're opening port 80, google.com is going to expect HTTP. Try writing (write "GET / HTTP/1.1\nHost: google.com\n\n" to-server) As far as HTTP client software libraries, a quick search on google revealed this library: http://docs.racket-lang.org/net/url.html?q=http , though that's for the latest version of mzscheme/racket.
Well, that does work. The issue here is that I'm trying to write a Twitter client for a language built on top of mzscheme/racket, so I was trying to avoid using too many scheme libraries if I didn't have to.
Awesome, this almost fixed it. Instead of using `write`, you have to use `write-string`. Then you get actual responses!
Yeah, i forget that `write` produces `read`-able strings, with quotes and all. Too used to `display`. 
(I'm new to scheme, so my opinion isn't worth much here (and my code might not run).) That looks useful. I think you can have something nearly as nice without redefining "and". What do you think of: (define (possibly x . funs) (cond ((null? funs) x) (x (apply possibly ((car funs) x) (cdr funs))) (else #f))) Then your examples become: (possibly (assoc 'a '((a . 1))) cdr) (and (possibly (assoc 'a '((a . 1))) cdr) 10) (possibly (assoc 'a '((a . 1))) cdr number?) (and (possibly (assoc 'a '((a . 1))) cdr number?) 10)
That works too, indeed I could have gone the other way with it and wrapped it in a lambda. (define (guard x f) (and x (f x)) Or whatever. That's probably a better idea. More sensible, anyway!
Maybe monad. 
I like `guard` much nicer as well. Macros are great, but are best saved for problems which can't be solved well without them. 
I use if-let\*, which is like and-let\* from srfi-2. (if-let* ((foo (assoc 'a alist)) (foo (cdr foo)) foo #f) That last #f is the else clause. and-let is cool too (and I use it), but sometimes you need to control the else value (if #f means something).
 (define-syntax if-let1 (syntax-rules () ((_ ((sym expr)) then else) (let ((sym expr)) (if sym then else))) ((_ ((expr)) then else) (if expr then else)))) (define-syntax if-let* (syntax-rules () ((_ () then else) (begin then)) ((_ (b1) then else) (if-let1 (b1) then else)) ((_ (b1 b2 ...) then else) (if-let1 (b1) (if-let* (b2 ...) then else) else))))
Bookmarking for later
amazing find, thank you! 
Great tutorial, I'm a [Chickener](http://call-cc.org) by day but Racket's alternative syntaxes is something that really intrigues me. This is a great writeup for someone unfamiliar with the way that Racket works, including the PLaneT stuff :)
 (greater-than) (plus)(plus) (period) AAAARRAHGLBLGL ---- Awesome tutorial, though.
What's the problem with that? The whole point is to then write a parser.
Nothing! It's a sensible way to support a parser... just even more visually confusing than brainfuck. That's all.
Thanks for the comment! I certainly had fun with this one! On the other thread in /r/programming, a few folks noticed that the performance of the compiled output was lacking. That forced me to take a closer look, and I fixed a few things in the implementation. Version 1.7 of my bf package includes those fixes, and I'm more confident that the generated code will perform admirably. But I will need to add one more section to the tutorial soon to talk about those optimizations. Work never ends. :)
Anyone actually using Guile? I'd be interested in using it but I doubt others at my workplace would appreciate if I would start to use Scheme as administrator scripts.
Configuration generally be can be ini, json, XML or s expressions. The easiest way to use scheme is to put your configuration in s expressions and then wrap it in scheme code. Then again you can also trivially load json into into various languages without the ability to store functions.
&gt; Anyone actually using Guile? The same question can be asked for Scheme in general and even Lisp in general. Getting a full time Lisp/Scheme/Guile developer job will be hard, but you will be able to use it for more personal projects, where you dont have to share code, so your employer doesnt care which language you use to produce the results. This is a rather common case in science/engineering.
True. I was surprised to find out that the other sysadmin here makes some web-based management tool in Clojure :) But its nice to see Guile progressing.
Pretty exciting stuff with Guile, thanks Wingo! I don't know much about ELF, but will this allow us to run guile programs at the shell prompt without having to explicitly invoke the interpreter?
That's a possibility, but the goal is to take advantage of the flexibility of ELF, not to mandate its usage on (say) Mach-O systems. Note that even on ELF systems you usually use some sort of interpreter; /lib/ld.so is the usual one. So there's always a runtime linker, somewhere.
What would be the benefit of not having to include one line specifiying the interpreter at the top of your script?
I meant compiled programs.
I also consider myself a beginner, but perhaps it's just to avoid the overhead of defining `unquote` each time?
Quote allow you to create datums with literal (unquote ...) in it. #lang racket (define the-first-unquote ',(+ 1 2)) (define the-second-unquote ',(+ 3 4)) (define the-whole-expression (list '+ (list 'quasiquote the-first-unquote) (list 'quasiquote the-second-unquote))) (eval the-whole-expression (make-base-namespace)) It's useful when writing compilers and macros.
Great question! I've wondered the same thing myself and one of the best reasons I could think of for keeping regular quote is that it has a readability advantage for large literal values. If the literal starts with quote, then you know right away that there is nothing deep in the s-exp that is being evaluated. That might help you scan it quickly. When the literal starts with quasiquote, you have to scan through to see where evaluation is happening.
From [here](http://www-pu.informatik.uni-tuebingen.de/cc-2002/scheme/schintro-v14/schintro_129.html): &gt; There's a big difference, though. quote constructs an s-expression at *compile time*, when the procedure containing the quote expression is compiled. Quasiquote constructs an s-expression at *run time*, when the quasiquote form is executed. This allows Scheme to "customize" a data structure, so that you actually get a different data structure each time you execute the same quasiquote form. You can use the unquote operator to specify which parts should be customized.
Here!
I wish I could be there! Maybe next year :-).
Great talk!
I really enjoyed your talk!
My understanding is that threading works for anything that is non-blocking, and so probably uses an internal scheduler, but I'm no expert. You will definitely get a quicker (and better) answer from either the mailing lists or #chicken on Freenode IRC.
There's very, very little information out there on Chicken concurrency. According to [this post](http://my.reddit.com/r/scheme/comments/ait6c/ask_any_decent_scheme_that_has_no_threading_libs/c0ht6g6), Chicken doesn't do kernel threads, so you're definitely not going to be doing multicore Chicken with threads. 
Chicken only has green threads and therefore real multicore processing is unfortunately out of question. Depending on what you want to accomplish, the [posix-shm](http://wiki.call-cc.org/eggref/4/posix-shm) egg or the [MPI](http://wiki.call-cc.org/eggref/4/mpi) egg could be real timesavers.
Sadly, MPI is GPL-3 so won't be admissable under the development terms of the project I'm on. Thanks for the fast response, though; somehow I had missed the posix-shm egg. Maybe that will be enough.
Yah, it seems there's distressingly little information on Chicken concurrency; or even concurrency in other Scheme implementations as well. Are Chez and Racket really the only Schemes that support hardware threads? Crazy.
Thanks, I'll check that out.
Currently CHICKEN Scheme implements green threads only. JÃ¶rg Wittenberger posted pthreads bindings to chicken-users. With the current situation blocking i/o operation in your FFI bindings will block all threads. An exception are the core i/o procedures (tcp unit for example &amp; ports). As of now there is no support to do kernel threading be it single or multicore.
Guile has [a lot of information on threading in its manual](http://www.gnu.org/software/guile/manual/guile.html#Multi_002dThreading). It fully supports kernel threads, so long threads that interact with the GC follow some rules, like checking into the GC thread-barrier regularly (pure Scheme code automatically does all this). 
Do you need to have shared memory between scheme threads? If not, maybe you could create a separate Scheme instance per thread and intercommunicate via messaging. Scheme data types are already serializable. 
You could checkout Gambit-C's termite as alternative. https://code.google.com/p/termite/
That's something I want to avoid, as the overhead of inter-process communication via pipes isn't very desirable to me.
The problem with Guile is that it relies heavily on libraries that I can't statically compile and distribute purely as binaries; so using it would never make it past the lawyers.
Very cool, thanks.
What about bigloo? Does it have the same library problems? It supports kernel threads, and has a conservative garbage collector. Performance is on par with gambit, larceny and chicken. 
I'm unclear if it will force us to ship an LGPL'd dynamic lib, which isn't possible on our target platform.
Even though I only talk briefly about Scheme in this post, I do mention it in the context of code represented as data, and specifically the idea that Scheme decorates the standard Lisp representation of code (as lists of lists and atoms) with lexical information. picoLisp serves as a pretty interesting example of taking the design of a lisp in the complete other direction. I think it reaps some rewards from its dynamic, interpreted, dead simple approach. Anyway, hope its interesting!
What picoLisp has is called `fexpr`s, which were the original form of metaprogramming in Lisp (see Gabriel &amp; Steele's history of lisp for more details). Note that this is very different from delaying when things are evaluated (which is what Lazy Racket and Haskell do) -- picoLisp functions can *examine* the structure of their arguments, not just evaluate them.
It seems to me that one could design a lexically scoped language where quotations had similar properties by simply requiring a symbol to remember its lexical context, so that it could later be `eval`ed "properly". You could re-fuse quotation and lambda this way, am I right? I actually added a link to a discussion of fexprs before seeing your comment here - I probably should have mentioned them directly, but as far as I know, the nomenclature isn't used in the picoLisp documentation. I did take a peek at newLisp, and I believe it does refer to this kind of syntax thingy as fexprs. I still need to send you my slides! Should I just send the slideshow file? 
Are you (commonslip) aware of a lisp dialect named [Kernel](http://web.cs.wpi.edu/~jshutt/kernel.html)? It's lexically scoped, yet manipulates code about as simply as picolisp (as far as I understand). 
Yes, that's what syntax objects are, but `eval`ing things outside the scope of their bindings doesn't really work. You should use the `-P` option to `slideshow` to print your slides to PDF.
I really want to know more about this&amp;#8212;someone live blog this shit or sumt!
Why don't you ask the authors of the libs to make them available under LGPL or something. Some people don't really pay attention to licenses and auto GPL everything they release. At least you've got nothing to lose.
I'd fill this out but I'm really not sure why such personal information is required.
LGPL isn't even good enough; needs to be BSD. It's ok, I'm writing my own solution. If it works out well I'll release an attribution-only licensed egg.
With ominous foreshadowing of Scheme hygienic macros!
Glad to see Arc mentioned, even if only sparingly. Of course, one of the few times is when it's pointed out as not having a namespace system. Which is unfortunately true.
So is Arc still in active development? I'd love to love Arc, since PG probably got me (and lots of other people) into Lisp, but it doesn't seem to have much to distinguish itself, at least philosophically.
&gt;I estimate that the emacs session I'm running right now, to write this piece, has about 25,000 functions and symbols bound. Mine, running bleeding edge, has 32,360 interned symbols, 13,244 of which are functions. Good guess! 
It's very slowly being developed. The problem is that pg's main priority is YC, [not Arc](http://arclanguage.org/item?id=12461): &gt;While I still hack in Arc constantly because I'm always tweaking HN, I haven't made dramatic changes to the language itself lately. I only seem to be able to work on 2 things at once, not 3. Since YC is a given, that means I have to choose between hacking and writing. The comment's a year old, but it's relevant. The good part for you, in terms of Arc development, is that many of the active posters on the Arc forum are people discussing changes to Arc. They don't get changes into the official release, but there are several alternate Arc implementations with changes from official Arc. It's a bit of a drag for me, since I don't have the necessary background to get everything they discuss. Where I think Arc shines is in its polish. It has fewer historical warts than other Lisps I've seen, and the choices it makes are more intuitive (e.g., Clojure uses vectors for arglists, not lists, so you have the confusing ugliness of square brackets at every function declaration). It doesn't have a design goal of adding a ton of newly created features; it's supposed to be more polished. That's why I like it. Here's an example of the polish I'm talking about: local variables. There are three ways of creating local variables: `let`, `with`, and `withs`. `with` and `withs` are similar to CL's `let` and `let*`, respectively. However, you don't need the extra parens around each `name val` pair: In CL: (let ((number-of-hackers 1000) (years 20) (arbitrary-elegance-bonus 0.5)) (* number-of-hackers years arbitrary-wordiness-penalty)) In Arc: (with (number-of-hackers 10 years 20 arbitrary-elegance-bonus 2) (* number-of-hackers years arbitrary-elegance-bonus)) It reads *much* nicer to me. Additionally, if you only need a single variable, that's special-cased with `let`: (let awesome? "yes!" (prn awesome?)) Obviously, there's more, but this is a good start.
There are two things I really love in modern lisps, and which I wish where in the same Lisp: persistent data structures (as in Clojure) and hygienic macros, as in Scheme. Clojure's vector syntax doesn't really bother me, but its weird relationship with the non-functional semantics of the JVM are weird. I guess when I think of Arc, I tend to ask "Why not Scheme?" Scheme is also very elegantly designed and if you include the whole package of Racket utilities, it is also a complete language. So why use Arc?
I'll have to take another look at Scheme. Mzscheme was actually my introduction to Lisp, and I didn't like it. It was probably because I didn't understand what the point of the assigments were -- some sort of Scheme interpreter written in Scheme. Man, I hated it. Since then, I've done almost nothing in Scheme. I'll have to do something there.
If you can't write an interpreter for the language you are using, you probably don't know the language. At least, that is the justification. My notions about computation were quite hazy, in retrospect, until I implemented a few different lisps.
The issue was that we were implementing Scheme in Scheme, so it made very little sense. It was very confusing, since you were translating the symbol "+" to the function "+", and so forth. It was an awful introduction to Scheme, and to thinking about programming languages. I did well enough, but got very little out of the class.
&gt; Here's an example of the polish I'm talking about: local variables. Local variables are nice in other languages too. Here's some Racket: (begin (define number-of-hackers 10) (define years 20) (define arbitrary-elegance-bonus 2) (* number-of-hackers years arbitrary-elegance-bonus)) You normally don't even need the begin because you're defining inside of a function body (or cond body or whatever) like this: (lambda (x) (define foo 'internal-definition) foo) Which is more consistent from a Scheme perspective.
I don't see that as nice at all -- in your first example, the only purpose of `let` is for scoping; it's not defining the variables. You have to then go and call `define` once for each variable. Racket's `let` is the same as Common Lisp's; it merely has `define` also, which is not nearly as nice as Arc's `let` and `with`. It seems to encourage procedural code, and replacing `let` with `define` in code looks like it'll be more confusing than using a `let`. Also, Arc can be used to do similar things, if it's inside a `let` block: arc&gt; (let x 2 (let x 3 (= x 4)) x) 2 But that's more a function of `let` than of `=` .
Actually, the use of let was more verbose than necessary. I've edited my post to reflect that (I forgot that begin introduces an internal def. context). I don't see this as encouraging procedural code because define is not really imperative. Not any more than let anyway. Also, the Arc code will end up being longer (vertically) in the case of defining local variables within a function, cond clause, or other forms.
The begin -- I assume `begin` is the same as `progn` from CL -- does look nicer than using `let`, but I still don't like it. Using `let` allows there to be a *single* statement in the `let` body, where you have four in the `begin` body. Having four statements feels like we're in the world of procedural programming to me. &gt;Also, the Arc code will end up being longer (vertically) in the case of defining local variables within a function, cond clause, or other forms. I think I'm misunderstanding this quote. Can you give an example where it's the case? 
&gt; I think I'm misunderstanding this quote. Can you give an example where it's the case? Hmm, so on actually trying both, I think they are usually the same number of rows depending on how you indent. (def filter (f lst) (if (= lst '()) '() (with (elt (car lst)) (if (f elt) (cons elt (filter f (cdr lst))) (filter f (cdr lst)))))) (define (filter f lst) (cond [(null? lst) lst] [else (define elt (car lst)) (cond [(f elt) (cons elt (filter f (cdr lst)))] [else (filter f (cdr lst))])])) Though my Arc code is untested because I didn't want to install an old MzScheme to get it to work. Both look pretty much just as good in terms of brevity to me.
Ah, fair enough. One note: in Arc, `=` is the *set* operator, not equality. For checking equality, you want `is` or `iso` (isometric, for lists, element-wise comparisons). Your code works perfectly when you replace `=` with `is`. One change I'd make at first is instead of checking `(is lst '())`, you can check `(no lst)` to get the same result. There's also `when`, which is perfect for this case. Slightly more idiomatic Arc, or at least what passes for ideomatic in my head: (def filter (f lst) (when lst (let elt (car lst) (if (f elt) (cons elt (filter f (cdr lst))) (filter f (cdr lst)))))) And the result: arc&gt; (filter [&lt; _ 5] '(1 9 2 8 3 7 4 6 5)) (1 2 3 4) `[&lt; _ 5]` is syntax for `(fn (_) (&lt; _ 5))` . There's no support for functions of multiple arity with bracket-functions. There is a builtin that does the same thing: arc&gt; (keep [&lt; _ 5] '(1 9 2 8 3 7 4 6 5)) (1 2 3 4) Of course, that's not at all useful for your example, but I just wanted to point it out anyway. Also, the newest release, Arc3.1, works on racket. It's not on the [Arc install](http://arclanguage.com/install) page, for some reason, but you can [download it anyway](http://ycombinator.com/arc/arc3.1.tar). They're both pretty brief, although I find it interesting that the way I style code makes it take one *more* line than your Scheme. I do it because `if` doesn't group together the test with the true-clause the way `cond` does. You certainly could put the true-clause on the same line; I just don't like it. Also, I like how Arc lines are shorter, what with not requiring some parens or braces, and not requiring `else` like Scheme does in `cond`. May I ask why you didn't use `when` instead of testing `lst` against `'()` and then manually returning `'()`? I love the elegance in not having that branch of the if, and I'd love to hear why you prefer it that way.
&gt; Also, the newest release, Arc3.1, works on racket. It's not on the [1] Arc install page, for some reason, but you can [2] download it anyway. Oh, that's nice to know. Thanks! &gt; May I ask why you didn't use when instead of testing lst against '() and then manually returning '()? I see that in Arc "when" returns nil on failure, but in Racket it returns the void value. Also, Racket does not treat nil as false. Only #f is false. That's the only reason I did it that way.
Ah, I always forget that Scheme treats `'nil` and `#f` differently. I understand how it makes sense to have separate values for truth and falsity, but ...damn, having `nil` be the false value and the empty list makes for some nicely concise code.
The name and the email address is just to distinguish users, IIRC so if you want to change your opinion later you can fill in your given name and mail address again and can change your mind.
I kind of find this emphasis on trivial things like precisely how one introduces new variables sort of bizarre. If you are into this sort of thing, though, consider looking into Racket's _match_ library or Clojure's destructuring bind. Clojure also has a nice match facility. But ultimately, I find it doesn't much matter. I've implemented Clojure's destructuring bind syntax in Emacs Lisp, which I use all the time, and I rarely actually use the new syntax because a regular let expression is really not that inconvenient. If you have deep nesting, you need to refactor anyway - it isn't let's fault. Arguably, concise binding forms that encourage you to express more than just destructuring during binding just let you write kind of ugly code. Few things are more brief that a good destructuring bind, in terms of variable creation. Or use factor, and just dispense with naming variables entirely!
Introducing new variables is something that's done often in code. If it's ugly or irritating, much of your code will be ugly or irritating. Arc feels better to me; it's less visually irritating, and that's why I like it. As far as I can tell, Arc has one of the two features of Clojure's destucturing bind. I may not be seeing everything you can do, though. untested Clojure: (let [[name calories &amp; ingredients] ["peanut butter" 150 "peanuts" "butter"]] (list name calories ingredients)) -&gt;["peanut butter" 150 ["peanuts" "butter"]] untested Arc: Arc&gt; (let (name calories . ingredients) ("peanut butter" 150 "peanuts" "butter") (list name calories ingredients)) ("peanut butter" 150 ("peanuts" "butter")) It doesn't have the `:as` feature, though. Am I missing any destructuring feature? I based this off the [Clojure doc here](http://clojure.org/special_forms#Special%20Forms--%28let%20[bindings*%20]%20exprs*%29). I'll have to look into Racket's *match*, as I didn't find a good introduction to it with a quick search.
Clojure destructure over lists, vectors, AND associations like maps. And its destructuring is recursive, that is, wherever a symbol can occur, any arbitrary nest of further destructurings can occur. Match, in Racket, is a bit like an extensible, data aware version of destructuring bind, but it doesn't always support recursive bind. It is true that introduction of new variables is important, but I think if you introduce more than two or three variables in one context, it is code smell. It is rare that a well designed algorithmic step will depend on more than 5 parameters, in my experience. If you find yourself binding a ton, I think its often time to factor out a few functions. I guess I just come from a forth/lisp bias. If a function is more than a few tokens long, I split it up.
&gt;I'll have to look into Racket's match, as I didn't find a good introduction to it with a quick search. Try this: [http://pre.racket-lang.org/docs/html/guide/match.html](http://pre.racket-lang.org/docs/html/guide/match.html) (and the link to the reference for more)
Well, I did apropos of nothing and divided the number of lines in the apropos buffer by 2.5.
Mmmm..? What did you try? If you want to use Scheme as a beginner I recommend [Racket](http://racket-lang.org/), it should be a piece of cake to install and then the documentation is very good, and people are here to help you and answer your question on the users mailing list or the irc channel (you can find all this in the "Community" webpage of Racket's website). What did you do in C that you didn't succeed to do in Scheme?
There are a couple of packages on [PLaneT](http://planet.racket-lang.org/) that have functionality similar to Numpy, though I don't think there's one all-encompassing package. I'd take a look at the linear algebra and science packages that are available there. There is also a simulation package that might be useful for you. I don't know of any R bindings for Racket off the top of my head, but it should be possible to make one using the [FFI](http://docs.racket-lang.org/foreign/). Edit: also, the [mailing list](http://www.racket-lang.org/community.html) is a good place to get answers. It's quite active.
Thanks, much. I guess I have an interesting road ahead.
Have you seen Williams simulation package? http://planet.racket-lang.org/package-source/williams/simulation.plt/3/4/planet-docs/simulation/index.html Also: Check out the packages (and source of) wmfarr's packages. 
Yes, I'm curious too. When starting out, I ran into trouble getting MIT Scheme set up on Windows, but Kawa, SISC, PLT (now Racket) and Petite Chez all worked fine out of the box. Maybe try one of those.
Any summary of the diffs from the previous draft?
there is a detailed post from Alex Shinn [here](http://groups.google.com/group/scheme-reports-wg1/msg/7e4d3e04153e98ec)
Thanks! 
Not sure what are your requirements, but "traditional" forked processes can work well, as long as the application doesn't need to share a lot among processes. I agree, Chicken has the best FFI of any Scheme out there. Made it (relatively) easy to write a web server which makes use of quad cores, and does not use threading to process http requests. Under linux, there isn't much difference in efficiency with processes vs. kernel threads, but other OS difference could be greater. Of course, a BSD license is no problem. (Except, possibly, if gnutls is used for TLS encryption, etc.) Don't know if that helps. The webserver source is available (for the moment) at webserv.bmedctr.com. 
&gt; as long as the application doesn't need to share a lot among processes. Therein lays why I cannot use processes instead of threads. Thanks for the link, though! I'm still waffling through this work in my spare time, so seeing how other people have approached it will be a boon.
Well, it is possible to use POSIX shared memory (shm_xx), mmap, and semaphore (sem_xx) functions among processes--it's the same API as POSIX threads. Threads are convenient as semaphores can be assigned to global variables, whereas in processes, access to semaphores is through mmap functions. On the good side, a child process inherits mmap areas and fd handles from the parent, so shared access isn't too complicated--not much different than pthreads anyway. I haven't played with this much, though in my web server all processes write to the same log files using inherited fd's quite transparently. Seems this would apply to shared mem access as well. AFAIK, Chicken has mmap procedures in the posix module; appears the shm_xx and sem_xx functions need FFI wrappers, but that should be pretty simple to do. Having said all that, I just may have to try it out...
Yah, I was looking at that approach when I was on vacation. Seems reasonable... And perhaps the extra layer of abstract may prevent unnecessary access to shared memory due to it being prohibitive to access in a casual way.
OK. Using the foreign-lambda interface, scheme procedures, semaphore-xx were mapped to sem_xx libc functions. Then a named sem was opened in the main process, and after forking the child opened a sem, etc. When I finally got everything in the right place, it worked fine. The tricky part was making sure that sems were closed, and that the main process unlinked the named sem before exiting. In Chicken, an exit-handler can be defined which will trap anything to be done on exit, and that's where I put the unlink procedure. Since child processes inherit memory mappings, using mmap procedures and the semaphore API makes it pretty straightforward to pass info around. Of course, it gets a more complicated if there are many mmaps and sems to juggle, but I suppose that's always the case trying to coordinate threads or processes. When I have a reason to dig into to it further, no doubt I'll find out what I missed doing this simple test...
You should make a post to r/scheme and get yourself some more karma. :)
This is very good. Thank you for sharing!
Are you using a book to learn Scheme? HtDP has the teaching languages builtin and SICP has a plugin available here: http://www.neilvandyke.org/racket-sicp/ . Otherwise just use `#lang racket`.
No, I'm not using a book right now, but I intent to, what 'worried' me is that if I found a good example online not explicitly for racket maybe it wont work or the other way around when writing something useful in racket not being able to run it in another implementation of scheme. But reading the answer I got in the stackoverflow post, guess scheme and racket are not quite the same other than in the most simple things, I'll check out the SICP 'extension?' when I start with the book, thanks for the reply...
Depends on your goals and motivation. If you want to learn FP with fancy features and/or need those features to motivate you #lang racket. If you want to learn it in a more pure, traditional way #lang scheme. Grab SICP (it's online somewhere), and use whatever #lang scheme variant gives you R5RS (maybe R6RS, it is a little nicer, but deviates from the book a bit). That will give you the traditional undergrad function programming experience if that's what you are aiming for.
The #lang line is there to accommodate different languages, and is also being used to accommodate for backwards compatibility. From the responses seen here so far, it's clear that there's a misunderstanding about the role of "#lang scheme". "#lang scheme" is a backwards-compatibility library meant to keep old DrScheme code from breaking (as is "#lang mzscheme"). The documentation states this up front: http://docs.racket-lang.org/scheme/index.html. Do not write any new code with "#lang scheme". If you want to program in Racket, with all its bells and whistles, you are best off using "#lang racket". Racket is not Scheme, so it can (and probably will!) diverge from the other Schemes out there. It's the main language that your standard Racketeer will be using. If you want to use the Racket environment, but write to the Scheme standards, use "#lang r6rs" or "#lang r5rs". See: http://docs.racket-lang.org/r6rs/index.html for a tutorial and guide to using the R6RS standards with Racket, and http://docs.racket-lang.org/r5rs/index.html for the R5RS docs. It sounds like you're concerned about interoperability with the other Scheme implementations, in which case it makes sense to look into this.
wow, great response it really clarified a few thing to me. I'll swith from #lang scheme to #lang r5rs to follow SICP and a very nice tutorial I found from a Spanish university (http://www.dccia.ua.es/dccia/inf/asignaturas/LPP/2008-2009/index.html) Then in due time i'll see if I go to use #lang racket or switch to clojure or one of this hip lisp-styled langs. Thanks for the help.
With regards to SICP: When you're doing SICP, you probably do want to use Neil's SICP language off of PLaneT (http://planet.racket-lang.org/display.ss?package=sicp.plt&amp;owner=neil). If I understand it properly, it's a combination of R5RS plus a little more to support some SICP-specific examples. The core parts of SICP will work pretty much anywhere, but some parts in the book are a little platform sensitive. Neil added in the extra support to do things like the picture language in SICP Chapter 2.2.4, for example. I think there's also support for the concurrency stuff in his package. I might be wrong, in which case I can help port what I did earlier (http://planet.racket-lang.org/package-source/dyoo/sicp-concurrency.plt/1/2/doc.txt) and push it upstream into his language. Let me know if you need this. I don't have the time in the immediate future, but I'll put it on my TODO. 
Just to clarify, this: &gt; If you want to learn it in a more pure, traditional way #lang scheme. is not correct. `#lang scheme` is almost exactly the same as `#lang racket`. The only reason both exist is for backwards compatibility. If you want to program in a standardized dialect of Scheme, you can use `#lang r6rs` or `#lang r5rs`. 
Thanks for the correction. I knew there were specific flags. Just too lazy look them up.
Backstory: a nice girl I met recently entered her phone number into my phone, but accidentially left out a digit. Wanting to meet her again, and being a hacker, I estimated the order of magnitude of the possible numbers, and figured it was a tractable set of numbers (on the order of 70). I then hacked up a Scheme program to output the set of numbers, later refining it to output only numbers with digits added that already occured in the incomplete number (assuming that a distinct digit missing would have had a good chance to catch here eye). So I was down to 22 numbers; then using an online phone book to see if there'd be a match, or cross out non-matches, calling the left-over numbers. Well -- I had a hit, near the end of my list :-). **TL;DR** Hacked up a Scheme program to find the missing digit in a phone number in order to meet a girl again -- success.
She clearly did it on purpose, to test your devotion.
I also talk about Factor, waaaay at the end!
So she's a schemer, too?
Great series btw, I've enjoyed it. However, I was surprised you didn't first include the non-hygiene-breaking way of doing [anaphorics](http://community.schemewiki.org/?anaphoric-if) in Scheme: (define-syntax anaphoric-if (syntax-rules () [(anaphoric-if it pred true false) (let ((it pred)) (if it true false))])) Then you can use it as: (anaphoric-if it (get-command) (handle-command it) '())
so how'd it go? you can't leave us hanging.
How did you know she left one out? She could also have entered one wrong (assuming that different prefixes can have different lengths). 
Nope, that is in there: CTRL-F for "named-anaphoric-if". It would have been an oversight, though, so thanks for pointing it out anyway.
Heh, can't believe I missed that. Like I said before, well done. 
I used Racket and HtDP because I go to Northeastern and like it a lot. I've also tried out Chicken Scheme, but tend to like Racket better. I could favor Racket, because that's what I started out with, though.
Racket is not Scheme. I primarily use Chez Scheme because it conforms very closely to the standard, is rock-solid stable, and very fast. But I also use other Scheme systems from time to time, because someone I am corresponding with uses another Scheme system, or because the other Scheme system has a library that I need, or for some other reason that makes some sort of sense. Here is the list of Scheme systems I currently have installed on my home computer (some of them are outdated and haven't been used for years): Bigloo, Chez, Chicken, Gambit, Guile, Ikarus, Kawa, Larceny, MIT, Racket, Scheme 48, SCM/SLIB, Tiny Scheme, and UMB Scheme. If you're learning scheme, you might enjoy my blog [Programming Praxis](http://programmingpraxis.com) which provides weekly programming exercises with suggested solutions in Scheme. Phil
I tried MIT Scheme a bit, but I've settled down with DrRacket. I don't do a lot of scheming anymore, but DrRacket is enough for what I need.
Anybody having trouble playing this? I've tried smplayer, totem, and vlc. Totem and smplayer stop playing near the 13:00 mark. vlc just does all kinds of weird stuff.
Hm. Let me double check it here. Sure enough - doesn't work past 13 minutes! Thanks for the heads up!
&gt; Racket is not Scheme. So, is it properly characterized as an application that supports Scheme but also other languages?
Racket contains Scheme as a subset. I think it was clear to non-novices what the OP meant though. 
Doesn't it have flags to make it "Scheme"? I believe you can do: #lang r5rs or #lang r6rs 
Thanks for the resource Phil! I have it bookmarked now. :)
I used to use Scheme48, Gauche, Gambit &amp; STKlos (as well as others) in my consulting. About 4 years ago I decided to write a Scheme system for myself with extensions that I would like to use (such as dictionaries and other things). I still use Gauche every so often (esp. for older clients), but I've been working with my own dialect ever since. I would say that, Racket is great for learning, the docs are solid and the supporting tools are great (such as the macro-stepper); I've seen people do interesting &amp; real-world projects with it, so it isn't something you have to "put away" after learning with it. 
Chicken. It integrated into Emacs easily (Emacs user for 16 years and I grew accustomed to building up a solution using sbcl and Python in Emacs). I also liked the performance and compile-to-exe ability. Runs fine under Linux, OpenBSD and OSX for me.
yup
racket for the ways in which they're experimenting with the language. chicken for the cross-platform compile-to-native capabilities.
CHCKEN Scheme for its nice extension system (aka eggs), the easy FFI to C and most importantly the awesome community and support on IRC and the mailing list.
Care to release / show off your own dialect? I'm interested in it.
I use Chicken Scheme--the community is fantastic, there are a couple eggs that I would struggle doing without, and the development environment integrates very well with Unix. I just had my first patch accepted to the core libraries! :-D
I'm a Chicken user as well. I wouldn't recommend it as a learning environment because errors and traces are sometimes a little unhelpful, though the situation is constantly improving and I actually learned Scheme using it so it is very well possible if you have some perseverance. What I like very much about it is the friendly community, its wealth of useful and solid extensions as well as its performance. Alan Post mentioned the Unix integration already and I have to concur--I tend to use Chicken these days where I would previously have used Shell scripts. I also use it for web development and as a general purpose utility language (e.g. converting or mining data). But first of all, enjoy diving into Scheme!
I use CHICKEN because it is practical, portable, flexible and fast. It has good documentation and an awesome community of users and developers.
I'm a Chicken user. I want to write applications; as I see it, there are Schemes that are good for embedding, and Schemes that are good for learning Scheme on, Schemes that are good for learning to implement Scheme with (eg, write your own tiny one!), and schemes that are good for apps. I've never looked for one that's good for learning on, but from where I stand, Chicken wins for apps, Chibi wins for embedding, and Guile wins when you need both and don't have any problems with the GPL. Why's Chicken good for apps? Well, others have listed the main reasons, but the ones that matter to me are compiling to actual executables, good integration with Unix interfaces, the wide range of eggs available, and the lovely community.
Guile for being very easily embeddable, and having a nice POSIX api. I've dabbled with Chicken, since it seems to be very actively developed and popular.
Guile is not a happy Windows citizen unless you run it under Cgywin, which I don't want to mess with.
I'll echo frustration about errors and traces. I've been frustrated doing debugging with Chicken: the errors aren't always easy to localize, I wind up writing a fair bit of trace code. Some days it gets to the point where I say "Ok, stop. I'm writing an interactive debugger now before I solve any other problem." I've developed behaviors and tools to work around this, but it still gets me from time to time. I often work with the Python debugger, which is insanely great--it can be a shock debugging in Chicken after that. I am, with all of that, still here. :-)
I hope to have it finalized by the end of the year. Currently working are the: - Interpreter (normal, just walks S-Expressions). - PreScheme-style compiler (generates human-readable C). - VM interpreter (self-hosting, compilable with the above). One of the things I'd like to finish support for is W7, which works in the interpreter, but isn't finished in the VM system (it shouldn't be hard to add though, I'm just pressed for time). For next year, I'd like to finish the improved PreScheme-style compiler (finish unboxing &amp; have better optimizations), start the full-dialect compiler (the PreScheme compiler only removes self-tail calls and focuses on generating human-readable C code, so removing those two restrictions would be tantamount) and work on the typed-syntax-rules extensions more (as well as look into syntax-case). So, the dialect-changes are: - `{}` for dicts (that are backed by tries) - `[]` for quoted vectors (I've always liked this, even though it's semi-heretical). - purely-functional accessors that work across all collexion types, as well as things like `cupdate` and `cslice`, which can update collections in the manner you'd expect from purely functional updates (there are also destructive update methods as well). - Originally I had Lush-style applicable data structures (e.g. `([1 2 3 4] 2)` would return 3), but I've been moving away from that, as I find they cloud the code in a way I'm unhappy with, esp. coming back to code 6 months later. - Extensions to SRFI-89 to include things like `:pre`, `:post` and `:constraint`. - Include Kanren-style literals (`#s` for success and `#u` for unsuccessful). - [W7](http://mumble.net/~jar/pubs/secureos/secureos.html). - Basic support for SRFI-34 using `error` and `guard`. - CL/Dylan-style `format` (though I'm moving away from this in favor of something similar to the ['Format Stinks'](http://lemonodor.com/archives/001280.html) article on Lemon Odor) - a CFFI, inspired by KSM, but I'm still working on this. - `require`, `import`, `from`, `use` - support for a goodly number of SRFIs - Something that's very important to me: a large set of base libraries, to support things like HTTP, FTP, JSON, XML &amp;c. These are in various stages depending on how much I've used them. I'm finishing something similar to Haskell's cabal. Since I use it for my consulting, I'm pretty happy with it, but I do find warts that I end up fixing, things to tweak, &amp;c. It has been a much more satisfying project than other things I've worked on, and since I've launched production code with it, I'm pretty committed to making it **good**. Plus, it's pretty enjoyable to write solutions to problems in a language you wrote (even if you're standing on the shoulders of giants) in a REPL you coded. 
I havent used used Windows since 1999, so I dont care. Guile is a GNU project, so they dont care for Windows either.
Which is why I wouldn't use it [Guile] either.
You're welcome.
Indeed! Thank you for sharing about Guile. You opinion is just as good as mine (probably more informed) and somebody could read about Guile from your post and start to use it.
Honestly, I'm getting really tired of thinking about monads.
Thank you very much for doing (and redoing) this. I hope you have a good long break from thinking about monads ... while I dig deep into them.
What! This is like a dream dialect and it sounds amazing! I would love to have a prerelease interpreter to play with. 
Nope, that'd would have been too much luck on a single day ;-).
Well... thank you! I've only released it to a handful of people, since I'm still working on it. I guess I could send you a stable build, even though it's far behind what I've been working on. PM your email address &amp; I'll send it.
chicken and racket. chicken has a great community and lots of packages (eggs)
I tend to use Scheme 48, because I've used [Scsh](http://www.scsh.net/) in the past.
interesting... it seems Chicken is getting much more love than Gambit. Is this because of chicken's community or libraries ?
I posted earlier that I was tired of thinking about monads, but I guess not tired enough...
Well, the benefits the poster talks about are certainly similar to that of Common Lisp. In fact, I would say they are stronger, since Schemes have had a chance at addressing some weaknesses in CL.
&gt; The language itself (or, more correctly, the language family) is actually pretty weak by modern standards. [citation needed]
My problem with Monads is that they hide behaviour. If you're a newb and unfamiliar with MonadFoo and how it works then figuring out how a chain of transformers results in the output is a headache, to say the least. Moreover, it works in Haskell because there's a generally accepted Best Practice where function signatures are written even when unnecessary in order to make divining the behaviour practical. Most Schemes don't support such a thing. I suppose you can document the behaviour but... Christ. Multiple Inheritance, Generators, Templates, Meta Programming, Closures, Anonymous Functions... I use all those regularly in projects written in languages from C++, Scheme to Javascript. But Monads? Not yet. Can someone please illuminate just where the cost/benefit tilts in their favour?
&gt; My problem with Monads is that they hide behaviour. (I wrote the blog post) This is true of almost every programming artifact. Abstraction hides behavior. Functions hide the kind of stack management you'd do in Factor or Forth, for instance. Modules present an interface but hide the implementation. There isn't anything particularly complicated about Monads once you get your head around them. They are just "computations in a context." I find pure functional programming to be a really comfortable idiom because I don't like to think about the fact that I'm tossing around pointers to memory locations. Write a list library in Scheme or Lisp to see why pure functions are so nice. Then go program in Clojure to see what its like when the persistent properties of Lists are extended to the other major data types. It is really very liberating. _Except_ that now you often find yourself passing around state between functions which means its nice to have the state monad. Another way to think of it is that functions of state are themselves values which you'd like to manipulate as easily as you manipulate lists. The list monad helps you manipulate lists (you've surely used List Comprehensions in other languages - these are very "list monady") and the state monad helps you manipulate _functions (of state)_ without breaking purity. Function signatures have very little to do with it - monads actually substantially restrict the kinds of values you can work with, and so keeping track of types is actually _easier_ than it would be in a regular piece of Scheme code. There is one practical reason you've never used monads in other languages. Monads are in a sense about extending the idea of variable binding (hence the "bind" part of the monad). In order to use them conveniently you need a language which already has this ability in the syntax (Haskell's "do" notation lets you extend "bind" for values in a do block with a monad) or you have to have a language which lets you _add the appropriate syntax_ (the `mlet*` expression in this blog post). You can try to squeeze monads into other languages (I've done it in Actionscript, for instance) but its quite hard to make it elegant and easy. This is either a case for languages with syntactic extension mechanisms or a case for Haskell, then. As for the practical application of this style of programming, I can't really comment - I'm a scientific programmer by day and I write most of that code in Matlab. I use emacs for a variety of scripting tasks and for that I do use monadic parser combinators a lot for constructing parsers (just the state monad, again, but with a monadic zero). I also find I use the maybe monad and the list monad a fair amount to represent computations that can fail silently or computations with multiple outcomes. But I don't do any "industrial strength" programming so I can't comment. I like monads because they make writing a program that works faster and easier for me, but beyond that, your mileage may vary. 
I notice you mention a few libraries you've made like better-monads, which sound interesting. Do you have these up on [PLaneT](http://planet.racket-lang.org)? :)
No, I've been meaning too, but I haven't documented the code much and I also kind of don't want to have to start dealing with multiple versions of my libraries and git is my primary source control system. Do you know of a "PLaneT for Idiots" tutorial covering how to get stuff up there? I've looked into it a few times (and I have some old code there, so I did it once) but every time I go to do it it looks like its going to take more than five minutes and I'm ashamed to admit that I move on to other things. Better monads and a ton of other things is available via [git](https://github.com/VincentToups/racket-lib). I really like the fact that pushing changes to github is a few commands in bash - I don't even have to open my browser.
&gt; (I wrote the blog post) This is true of almost every programming artifact. Abstraction hides behavior. Functions hide the kind of stack management you'd do in Factor or Forth, for instance. Modules present an interface but hide the implementation. There isn't anything particularly complicated about Monads once you get your head around them. They are just "computations in a context." Except in other cases of encapsulation, abstraction and general implementation obscuration there's often a syntactical method of expressing that this has occurred. Typically, this isn't the case with Monads. For instance: foo = do z &lt;- [1..] x &lt;- [1..z] y &lt;- [x..z] guard (x^2 + y^2 == z^2) return (x, y, z) If I didn't know that the List monad existed how would I ever divine the true behaviour of this function *quickly*? Of course, when I say "I" it is the inexperienced new developer on the project that I am meaning to refer to. I agree, implementation hiding is everywhere, but it's something that we generally attempt to notify other developers of its existence. Somehow this precaution is typically lost with Monad implementations.
Well, with `better-monads` you must specify the monad you perform `do` in: (mlet* in: the-list-monad ((x '(1 2 3)) (y '(4 5 6))) (return (+ x y))) So perhaps this is an issue with Haskell's type inference figuring out which monad a computation belongs in? 
&gt; Do you know of a "PLaneT for Idiots" tutorial covering how to get stuff up there? The [last part](http://docs.racket-lang.org/planet/Developing_Packages_for_PLaneT.html#\(part._.Write_.Your_.Package\)) of the PLaneT guide has a one page tutorial on developing a package to submitting it to the repository. Also dyoo's [Brainfudge](http://www.hashcollision.org/brainfudge/) tutorial culminates in deploying the package on PLaneT. Do those cover what you wanted? There isn't really any nice integration of git and PLaneT unfortunately, but you could, for example, put the git revision hash in the release notes for a PLaneT version and you could guide people to your github if they want the latest version. Or if you have version tags in your repo, use those as the 'version field for the package's info.rkt. The repository is designed to be orthogonal to however you manage your source code though. It'd be nice to have on PLaneT though just because it's more convenient to do: (require (planet commonslip/better-monads)) than using raco to link the git repo as a collection.
Hmm, excellent point. I don't suppose this is available for Chicken? Or does it rely on Racket-specific extensions?
You are right, I really should do it. I'll get to it soon.
It isn't that much code, but at the moment it depends on `syntax-parse`, which is racket specific, I think. One could whip up equivalent functionality in a few minutes for Chicken, just by translating the macros. It also depends on Racket's match features, which someone should port to portable Scheme anyway. The file is 300 lines of code, roughly, so like an afternoon of work. I've used chicken a bit but was turned off by having to futz around with build systems (maybe I am thinking of Bigloo?)- how do you manage your chicken projects? 
Depends on how weak your Scheme is. If you have something like chicken scheme , scheme48 or racket this will apply less. The library of those are somewhat limited though. Having an FFI tries to solve the library problem. What we need is racket to gain momentum and become the clojure of schemes.
I think the notion that Lisp is interesting only for its [lack of] syntax is problematic. The reason that Scheme is attractive for me is due to its *semantic* simplicity (it's not a far stretch from a call-by-value lambda calculus) combined with the fact that its syntax is extensible such that it can become *any* language. It's just that designing macro systems for languages with non-s-exp syntax is hard. It's not impossible though, as there's ongoing research on it and IIRC [Nemerle](http://nemerle.org/) does Scheme-style macros with non-Lisp syntax.
I just started using Chicken, I come from a C++ background so I first wrote this (which I need to push a patch to, actually, will get to that when I get home): https://github.com/dleslie/scheme-cpp-build Then afterwards I read about this: http://wiki.call-cc.org/autoconf%20-%20automake I'm sticking with my little Make-only build system, though. It works for me. I just write a .scm or .cpp file, drop it in src, or a header in include, export if necessary, presto. 
In Racket, you press the "go" button and your code runs which, you have to admit, is pretty nice. Chicken has other things to recommend it, I think. Can't you get much closer to the metal in Chicken?
In Chicken you can swap back and forth between C++/C and Scheme without a second thought. Something like: (bind* #&lt;&lt;EOF int foo(char *stuff) { \\... } EOF ) (foo "Hey there stuff!") Moreover, [bind](http://wiki.call-cc.org/eggref/4/bind) uses [coops](http://wiki.call-cc.org/eggref/4/coops) to produce a rather flexible object system from arbitrary C++ code. Nice stuff. I started using Chicken because it has a license that's amenable to embedded distribution in corpratocracies but stuck around for the eggs. Also, the chicken-hackers and chicken-users mailing lists are rather interesting reading.
Awesome - thanks for giving me an excuse to check out Chicken again. 
There are a lot of things to list here. * modules * a much, much more expressive macro system * contracts * a sophisticated object system with first-class classes traits and mixins * a CLOS-like object system * a dynamically-linked component system * a typed variant of Racket * reader extension * concurrency * parallelism (in both shared-memory and message-passing forms) * CML-style channels and kill-safe synchronization * sandboxing and isolated gui components * a sophisticated web server with continuation-based session management * a slick IDE (now with online compilation) * an easy-to-use and expressive FFI * a performant JIT compiler * delimited continuations That's probably enough for this list, but there's lots more.
You might want to check out [my library](https://github.com/samth/raco-git/) for installing Racket packages from git/github easily.
I think `bind` should use `syntax-e`, not `syntax-&gt;datum`. Or even better, pass the whole syntax object, and destructure with `syntax-parse`.
Immutable cons cells. 
Thanks for the list, samth. I also notice that Racket has its own very nice documentation system, Scribble. What about more mundane language differences? Such as, differences in procedure names, typically-used data structures, use of square brackets, etc? I see some things in the htdp book that I don't recognize from other Scheme texts. 
Awesome.
Yeah, I should have mentioned Scribble too. Basically all of the names of R5RS procedures are also Racket procedures in the `racket/base` language. The biggest exceptions are pair mutation procedures, which aren't available because the pairs created by `cons' in Racket are immutable. Racket provides lots more built-in data structures, such as hash tables, sequences, sets, streams, and more. They're used in the typical places you'd expect. `[]` mean the same thing as `()` in Racket. Note that HtDP uses its own sequence of languages specially designed for learning programming, which are derived from but not the same as Racket. 
&gt; Note that HtDP uses its own sequence of languages specially designed for learning programming, which are derived from but not the same as Racket. Oh, good to know. Looks like [the guide](http://docs.racket-lang.org/guide/index.html) uses and covers the full racket language. 
i just upgraded to try the online compilation stuff. i don't know that i managed to stumble across all the features of it, but what i did find in about 30 seconds managed to make my day.
Yeah, it's awesome. 
Yes, the guide is for the full racket language (and more). [This](http://docs.racket-lang.org/guide/dialects.html) points to some of the other languages built into Racket (there are about 40 in the distribution).
&gt; In Racket, you press the "go" button and your code runs which, you have to admit, is pretty nice. Its not too hard to duplicate the same experience within chicken. The [autocompile egg](http://wiki.call-cc.org/eggref/4/autocompile) will even take care of compiling the script for you (compiles the script after making a change, runs the cached binary afterwards, until the next change). For more complex projects, the [system egg](http://wiki.call-cc.org/eggref/4/system) can provide a more lispy way of handling them. Not saying that racket isn't good. It is. Just that chicken offers more of an easier user experience than perhaps its scheme -&gt; c -&gt; native executable compilation process might lead you to believe :) **Example** In your .csirc (script sourced by the repl at startup), with a: (register-feature! 'in-repl) and the following block at the end of your scheme files: (cond-expand (in-repl ; do something (else (main (command-line-arguments)))) A scheme source file *just works*, whether you load it into a repl for interactive development, or run it from the commandline, with either: #!/usr/bin/csi -s #!/usr/bin/env chicken-scheme compile and run it manually **PS** Really enjoying your series of posts on macros. Thanks :)
Thanks for the Chicken perspective, again. I'm sure one of these days I'll want to use Chicken for something, and its nice to know the tricks. 
I think the point about bind using syntax-e might be a valid one, and I considered that option too, but since none of this will likely ever be really useful, I just went with `syntax-&gt;datum`. If you just pass in the whole syntax object, I think you've got yourself the identity monad, at least with respect to how bind works. Having thought about this some, I think `with-syntax*` might really be the better binding form for actual use. Thinking of syntax as a monad is kind of a lark.
Important to note that the CLOS-like object system is distinct from the other object system, and they are not easy to squeeze together. And I had a nice talk with Eli (the author the CLOS implementation) about it wherein he suggested that its hopeless across module boundaries. I didn't understand at the time, but now I do. All that said, Racket is my favorite Scheme. Easy to use, install, good GUI framework, write once, run on Linux/Mac/Windows, has persistent hash tables. It feels very "batteries included." I suppose if you wanted to write pure R5RS or whatever, you'd never know. But you almost never want to do that.
To clarify, the thing that is hopeless, is getting a "well behaved" CLOS system, one that doesn't require mutation to extend generic functions. AFAICT, this mutation is very inherent in all CLOS-like systems. As for getting it to live with the other object system, it is probably possible but with a thin swindle wrapper, for example, not being able to extend GUI classes on that side.
Still figuring out how to make everything on Planet "nice", but you import the monad library like so: (require (planet "better-monads.rkt" ("toups" "functional.plt" 1 0))) Incidentally, I'm still relatively green at syntax/parse style macros and this library seems to take awhile to compile. If anyone with more experience would mind taking a look, I'd be grateful for any input. Finally, I'm implemented `lift` by basically tons of calls to `static-lift`, one for each number of arguments. I'm _pretty sure_ that you can implement `lift` completely at run time, but I can't quite figure it out. If anyone knows what I mean, let me know.
This is very cool. I'm teaching a seminar on campus about functional programming. I only have about 5 hours and teaching students the enough Haskell syntax to begin explaining concepts gets hairy. Since Lisp syntax is easy to get a handle on quickly (once you get used to prefix notation), I've been using Racket. I haven't covered monads so far, but I may put your library to use in explaining them. Unfortunately I don't know much in the way of macro programming, so can't help you much there. But very good work!
[Husk Scheme](https://github.com/justinethier/husk-scheme) is a nearly-fully R5RS implementation, unlike many others which are only partially complete. It has a Haskell FFI iirc.
Things are still a bit rough around the edges (especially in the documentation), but do let me know if you use the library. I'm interested in moving from science into education, and it would be nice to be able to say some code I wrote was used in a classroom somewhere.
Perfect! Thanks a lot.
This is available in git master now. It's implemented on the intermediate language level. I believe this means it should be available to any languages built on guile. It's also the core of some optimizations. For example, previous guile didn't collapse constant arithmetic expressions: GNU Guile 2.0.2.224-840cf Copyright (C) 1995-2011 Free Software Foundation, Inc. Guile comes with ABSOLUTELY NO WARRANTY; for details type `,show w'. This program is free software, and you are welcome to redistribute it under certain conditions; type `,show c' for details. Enter `,help' for help. scheme@(guile-user)&gt; (define (x y) (+ y (- 3 4))) scheme@(guile-user)&gt; ,disassemble x Disassembly of #&lt;procedure x (y)&gt;: 0 (assert-nargs-ee/locals 1) 2 (local-ref 0) ;; `y' 4 (make-int8 255) ;; -1 6 (add) 7 (return) Previously, this didn't collapse the (- 3 4). As one might expect, it works on other types too: scheme@(guile-user)&gt; (define (x y) (+ y (- 3 4+2i))) scheme@(guile-user)&gt; ,disassemble x Disassembly of #&lt;procedure x (y)&gt;: 0 (assert-nargs-ee/locals 1) 2 (local-ref 0) ;; `y' 4 (object-ref 1) ;; -1.0-2.0i 6 (add) 7 (return) However, it can't detect associative operations and collapse them. e.g.: scheme@(guile-user)&gt; (define (x y) (+ y 3 4)) scheme@(guile-user)&gt; ,disassemble x Disassembly of #&lt;procedure x (y)&gt;: 0 (assert-nargs-ee/locals 1) 2 (local-ref 0) ;; `y' 4 (make-int8 7) ;; 7 6 (add) 7 (return) scheme@(guile-user)&gt; (define (x y) (+ 3 y 4)) scheme@(guile-user)&gt; ,disassemble x Disassembly of #&lt;procedure x (y)&gt;: 0 (assert-nargs-ee/locals 1) 2 (make-int8 3) ;; 3 4 (toplevel-ref 1) ;; `y' 6 (make-int8 4) ;; 4 8 (add) 9 (add) 10 (return) All in all, this is some cool stuff and definitely worth checking out!
What is the PEG work the Guile team is performing?
http://en.wikipedia.org/wiki/Parsing_expression_grammar Current code is [here](http://git.savannah.gnu.org/gitweb/?p=guile.git;a=tree;f=module/ice-9/peg;h=764022b066311c91d10031a77aa715cd3a045a09;hb=wip-peg-fixed).
Linear types in a dynamically typed language? Quite ambitious.
This is usually called "constant folding" or "constant propagation". "Partial evaluation" is usually the name of something related to currying.
I guess I was asking for the wider story. Why is Guile working on PEG now? What is it going to be used for? What is it used for now? I'm the author of [genturfa'i](http://wiki.call-cc.org/eggref/4/genturfahi), a PEG parser for Chicken Scheme. I didn't think there was much work going on in this area.
Constant folding/propagation is performed during partial evaluation. You may be confusing [partial evaluation](http://en.wikipedia.org/wiki/Partial_evaluation) with [partial application](http://en.wikipedia.org/wiki/Partial_application).
I'm not sure that it's part of any particular grand-architecture project. The first post I found where Noah discussed PEG parsing was [here (2011/01)](http://lists.gnu.org/archive/html/guile-devel/2011-01/msg00030.html). I think the direction Guile is moving is towards becoming a platform to host other languages. There is already a Javascript and elisp implementation. I think someone is working on Lua. In this context, having powerful parsers is useful since it means people can more readily implement languages on the platform. FWIW, I reckon R would be a good fit if Guile had good BLAS/LAPACK bindings.
true.
Hello there, I'm Noah Lavine, the author of that email. I hope I can help explain it. As I understand it, the PEG parser was originally a summer of code project. At the end of the summer, the author left it in mostly-working state, but not quite ready for merging. Later on (a few months, I think, but maybe less), I became interested in writing a JIT compiler for Guile, because I knew that Guile might host Emacs soon, and I thought Emacs should be fast. I emailed the list, and the design we settled on was a very simple JIT compiler that would just paste in some code for each Guile VM opcode in a function. If you use that design, you can either a) duplicate all of the VM logic twice, once in the interpreter and once in the JIT compiler or b) come up with some representation that can become both an interpreter and a compiler. Obviously option b is better. We considered using an s-expression-based representation, but Andy Wingo (a Guile maintainer) wanted to leave the VM as it was, which means that in order to make the JIT in a reasonable way, you have to parse the VM interpreter (which is C code) and emit a JIT compiler. Hence my interest in parsing. But as the email says, I now think that this isn't the best use of my time for Guile. That JIT design is limited enough that it seems like a dead end. It's clear, however, that Guile would like an optimizing ahead-of-time compiler. I think the next step for me is to help make that. (Although eventually Guile might have a JIT, to allow you to trade performance for compilation time.) Also, in response to what you said - I think you're absolutely right about R. R is also an especially good fit because the maintainers of R are (I assume) statisticians, and therefore probably not interested in hacking a language implementation. They would probably be thrilled if they could just hand the details off to someone else and go back to statistics. And R is basically Scheme with more syntax (see: macros, call-with-current-continuation), so Guile would have to do very little work to implement R. The biggest barrier to using R is not the R language itself, but the C extensions people have written with R's C interface. I don't know what direction Guile is moving in really, but I'm excited for it. I think it could be going somewhere good. I'm also very excited to see one of my emails on Reddit! Thank you for reading it. Please let me know if I can answer any other questions.
The slides seen in the talk can be found [here](http://ccil.org/~cowan/scheme-2011-09.pdf)
Thanks for the link.
That's a cool discussion that I didn't know about. I don't know anything about a register-based VM, but other people might. You should email guile-devel@gnu.org to find out. I also noticed that you were interested in a data-flow tracer. Are you still interested? I think data flow will have to be a part of the static analyzer I want to write, so maybe this project can accomplish your goals too. (If so, I think we should talk about it on guile-devel just so that all of the Guile developers see it. Although of course I will reply to Reddit comments too.)
great talk. Thanks for the link!
&gt; I became interested in writing a JIT compiler for Guile, because I knew that Guile might host Emacs soon, and I thought Emacs should be fast. Do you have more details on this? I found [Andy's notes from last year](http://lists.gnu.org/archive/html/emacs-devel/2010-04/msg00665.html). Is the goal still to implement GuileEmacs as a drop in replacement for Emacs or is there any interest in making something to usurp Emacs?
As I understand it, the Emacs people want Guile (or at least some of them). There was some recent posting on emacs-devel about this. There was also more Summer of Code work on Guilemacs this summer, but I don't know how it went. I think it might be quite close to completion, actually. It seems like that's a project that is very close to being very awesome, and needs someone to push it over the edge. (If you're willing... :-) )
Then good luck on whatever you decide to do!
You can start with http://wla.berkeley.edu/main.php?course=cs61a
The authors of Structure and Interpretation of Computer Programs have made videos of their lectures free online. http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
This was posted a few days ago: [John Cowan on R7RS](http://vimeo.com/29391029) 
It's more Racket than Scheme, but Matthew Flatt had a cool [interview](http://blog.racket-lang.org/2011/05/racket-on-floss-weekly.html) on FLOSS weekly. There are also many ICFP talks on Scheme and other functional programming languages that have been recorded that you can find online.
Are these available for download anywhere, and in a format other than "ram"? 
I don't know if they are present in other formats than ram. But other SICP lecture material is posted in youtube for example.
&gt; R5RS is the result of three generations of very conservative (unanimously approved) extensions Small dig? :)
It was that talk that I finally learned how to pronounce 'srfi'.
Guile is a beautiful ugly dog? Really, John? TBH this makes R7RS sound like a Chibi ratification committee.
Because the module syntax is different from what alaric wrote. It should be: (module bar (foo) (import chicken scheme) (define (foo x . y) x)) Alaric did not specify a list of exported symbols in his paste.
Hi! Nice extension, thank you for sharing! A minor note on your example program: The hash prefix notation for the module namespace is not to be used outside the chicken core as it might change without prior warning. I am talking about the line 14 in example.scm. cluckcheck#gen-init should be rewritten as cluckcheck:gen-init as the other instances too.. Thanks again!
I'll add that the [mailing list](https://lists.nongnu.org/mailman/listinfo/chicken-users) and irc channel (#chicken on freenode) are very active. If you have questions about chicken they are the best places to get them answered.
It took me awhile to hunt down license terms for this software. I see the .meta files mentions the "BSD" license. Would you add a file more carefully explaining the licensing terms of this project?
Check this out http://programming-musings.org/2009/12/23/scheme-lectures-mostly/ :-)
This is a forum for the Scheme programming language. Please seek another place to complain.
Look what you have written in the ifs. (&gt; x y) is ok since &gt; is a function. (x &gt; z) isn't ok since x is in this case 2 and 2 isn't a function. I think you are thinking in infix terms and want (&gt; x z) 
Ugh, I make that mistake all the time too.
ouch. Thank you
By the way, is there a particular reason you're using MIT Scheme? DrRacket's error messages often have error highlighting to help track these things. Good luck!
I found [this tutorial](http://www.cs.rpi.edu/academics/courses/fall05/ai/scheme/starting.html) on using mit-scheme with emacs so I started using it. I see a lot of people talking about Racket. I'll probably try it out, or maybe chicken.
If you're an Emacs user, there's a setting in DrRacket to disable the menu key shortcuts (Alt+etc in Windows/Linux and Cmd+ in OSX). This gives you emacs-like bindings, but there are still some differences you can fix with a few hours of googling + tweaking.
definitely use racket to learn scheme with. its environment is superb. then pick up chicken for its excellent ffi and great collection of eggs.
I like both Chicken and Racket, and just wanted to point out that Racket has a pretty awesome FFI too. http://docs.racket-lang.org/foreign/index.html
Why does the x86_64 Windows version want to install in Program Files (x86)\Racket?
The Windows installer is made with NSIS, which simply uses $PROGRAMFILES for the target directory. If anyone knows if there's something to fix there, please contact me (eli@barzilay.org), and I'll be happy to fix it.
Plain delimited continuations do that with nearly the same syntax: (prompt (* 2 (control k (k (k 1))))) or (reset (* 2 (shift k (k (k 1))))) 
The problem with `shift` and `reset` is that they don't compose. Because `shift` only gives the continuation to the nearest enclosing `reset`, there's no way to get at delimited continuations that go to all the way to outer resets when nesting two or more `reset` blocks. This gives very strange semantics when dealing with several delimited continuations.
If you also want them to compose like this, then have a look at Racket: the extensive control library is built on top of its primitive forms that implement delimited continuations in a way that can easily compose, and using tags to distinguish continuations. You can then look at the source of the control library and see how they're implemented using the primitive forms. (And if you're using guile, this might be there, IIRC wingo studied the racket implementation.)
Racket's control library is awesome -- that's where I found out about `splitter`. Guile's control library has tags too; my implementation of `call/cpc` makes use of them as does Guile's implementation of `shift` and `reset`. I suppose my questions are 1. Why are `shift`/`reset` so popular if they have strange semantics when nested? Strange semantics are unschemely (the `splitter` paper makes this argument). 2. Why introduce the concept of tags when simple lambdas will work (and not in a church-encoding sense)? Using `shift` with a tag doesn't make any sense outside of a corresponding `reset` block -- using lambdas at least makes this harder to do. The `splitter` paper also makes the argument that needlessly multiplying concepts in this way is unschemely. 3. Why does `splitter` apply its argument to an `abort` function in addition to `call/pc`? It seems to me that `abort` is redundant. 
I can't answer (1) (obviously, there's a zoo of these things, so others could also have become popular, probably). I also can't answer (3), since I don't have experience using it... But as for (2), using lambdas seem suspicious -- it allows you to have access to the "pre-tagged" continuation, but shift does make sense outside of the lexical scope of reset, it should only be inside its *dynamic* extent. (You could have probably passed around the value, but then this is as inconvenient as passing values around when you don't have parameters.) 
I don't know if these links will help: [[1]](http://www.rhyous.com/2010/06/10/detecting-if-the-install-is-occuring-on-a-64-bit-or-32-bit-machine/) [[2]](http://bojan-komazec.blogspot.com/2011/10/nsis-installer-for-64-bit-windows.html)
Ooh, these do look useful -- thanks!
Good point. I assumed that the natural scope of `shift` would be the lexical scope of `reset` and that parameters/fluids would handle the unusual cases, but I can see how this would make doing certain things unnecessarily awkward. 
Congrats, racketeers! This looks like a fun one. I wonder about this, though: "Internal definitions are now considered preferable in style to `let'." Why is this? FWIW I see them as equivalent, sometimes using one and sometimes the other.
This was recently brought up on the mailing list too. [Here](http://comments.gmane.org/gmane.comp.lang.racket.user/9282) is a link to the discussion on gmane. It's mainly a matter of style and preventing lines from getting longer.
I'll be attending the hackathon over IRC. I've committed to finishing the documentation on my PEG parser and if I have extra time, work on performance enhancements; I still have one or two tricks that qualify as low-hanging fruit.
Please take a look at /r/TruerReddit and submit articles that are interesting to you but that don't get the former attention because the mixture of the reddit community has changed.
This has very little to do with scheme in any sense.
Not directly, but don't you think that it would be interesting to read articles that appeal to programmers without necessarily being programming articles? There is no other way to start such a subreddit besides calling for participation in programming subreddits. I have chosen to submit this to /r/scheme because I think that this community is the closest to the original reddit crowd.
I agree this has nothing to do with [r/scheme](http://www.reddit.com/r/scheme/).
Dear Rotti 81. I have just found myself in exactly the same position as u. I got a cell phone number last night with one digit missing. I like the idea of trying your program. I am however only very moderately computer literate. I have a windows 7 home pc. Exactly how do I enter an execute the program you wrote which u have published online? I am desperate to try this person! Your help would be so much appreciated!!
Better still to make it easier I would be really grateful if u could to the job for me!!! It is a uk cell phone number 0787587387 There is 1 digit missing somewhere!! Please help man! 
By intention, in the same way that it is not /r/programming or /r/python. But it's for articles that are liked by people who subscribe to /r/scheme. Where else can they be reached but in /r/scheme?
Are there any binary downloads? Just curious...
If you've ever been curious about Paul Graham's Arc (which is built atop Racket), it's very easy to try it out here without having to install anything. Hope you enjoy.
You might also look into Clojure, which is a concurrency-minded Lisp that targets the JVM. There are definitely some web frameworks written in it.
I hear racket is pretty powerful http://docs.racket-lang.org/web-server/index.html its derived from plt scheme which was the base language Paul grahm used to create arc which runs hacker news
For chicken there is a webserver called spiffy: http://wiki.call-cc.org/eggref/4/spiffy On top of it you can write awful code: http://wiki.call-cc.org/eggref/4/awful But maybe you have got plenty of advice from /r/lisp already.
Thanks for the info. &gt; But maybe you have got plenty of advice from /r/lisp already. Only about Common Lisp frameworks. ([This was my post](http://www.reddit.com/r/lisp/comments/mrk4k/sateoftheart_of_lisp_web_frameworks/) for those who are curious.)
Ah, I forgot about /r/clojure. I'll have to search it and see what I find. Thanks.
Racket _is_ PLT Scheme. ie, they renamed PLT Scheme into Racket, since PLT was starting to increasingly diverge more and more from the present Scheme standard, so they wanted to simply give it its own name.
Also, CHICKEN provides a lot of web-related extensions in case you don't want to have your work framed or you want to frame your work your own way: http://wiki.call-cc.org/chicken-projects/egg-index-4.html#web
There's a [tutorial](http://docs.racket-lang.org/continue/index.html) on the Racket site (which is written in Racket too)
I predict not many games are going to be written in Vala, whatever that is...
vala is actually an excellent language. it's c#-inspired, and uses gobject as its native object system. for a c-like language, it's pretty pleasant to work with.
Vala: Ratfor strikes back.
Gnome is quickly making itself irrelevent by discarding everything that works in favor of untested "modernization". Luckily, there are solid alternatives to Gnome.
Gee, I don't know, maybe it is. I glanced briefly at the tutorial and almost threw up, but then that's my normal reaction to the C family of languages. The only one that doesn't completely suck is [Go](http://golang.org). However, given that [Guile](http://www.gnu.org/s/guile/) was at one point the designated extension language for GNU, it seems ludicrous to reject a Gnome "game" for being written in scheme. Then again this also illustrates why some of us abandoned GNU/FSF decades ago.
Gnome's latest attempt to emulate Apple, amirite?
While I'm shocked and appalled at the linked page, it doesn't entirely justify the headline. Is there any more concrete evidence that Aisle Riot was unlisted, that this is the reason, and that "should" should be read as "must" in the guidelines? How about some mailing list controversy?
Maybe I'm a PL snob (but I guess I'm not alone on this reddit!), but Vala doesn't recommend itself to me in any way. * nothing that indicates a sound theoretical basis for the language * the only justification for its existence I can find is "GObject is unwieldy". Not even a discussion of how a programming language can be effectively constructed to improve the situation and benefit from whatever's good about GObject * *All* the documentation seems to be in the form of tutorials for migrating from {Java/C#/C/etc}. It gives me the same feeling as PHP 
There was a time, on its origins, when Gnome was going to be based on Guile Scheme... so sad that it never came true :( ..aisleriot was the only piece of Gnome that was still on its feet. Each decision they take now makes me glad I no longer use Gnome/KDE.
&gt; The games should be written in a modern language (Vala) using object classes and the model view controller design pattern. WTF is Vala? Okay, okay, I can google, but this is the first time I've ever heard of this language. I guess that makes it "modern". Sheesh, it's almost like GNOME has been infiltrated by its own worse enemies. Edit: http://www.reddit.com/r/vala : 8 posts, 5 &gt;= 1 year old, the rest older than 3 months. Wow, what an active community.
&gt; On top of it you can write awful code BTW, I think that documentation has more content than all the documentation for all the CL web libraries combined. :)
Why do the people in charge of Gnome care what language a piece of software is written in, if it meets whatever other standards they set? It just doesn't make a lot of sense to me. If the devs can make a Scheme game that follows all the other requirements, it should be just as welcome as something written in "Vala", which I had never even heard of before this post. Makes me glad that when I use Linux, I use XFCE. 
&gt; evidence that Aisle Riot was unlisted It is not listed any more where it was before. &gt; that this is the reason Ever "modernized" game now has Vala as an explicit goal that has to be reached. That might not be the sole reason to throw Aisle Riot out, but it certainly is one. They arent even rewriting it in Vala, though. &gt; and that "should" should be read as "must" in the guidelines * "eleven standards we want to have each of these games to follow." To me that reads more like "must" than like a "should".
&gt; Each decision they take now makes me glad I no longer use Gnome/KDE. Each decision they make now makes me question the point of GNOME *still* being an official GNU project.
&gt; Why do the people in charge of Gnome care what language a piece of software is written in They want Vala to be used, but nobody wants to use it, so they simply forbid all other languages. Thankfully, GNOME is not influential enough to intimidate anyone into learning their language, so they will just have all the work themselves. &gt; It just doesn't make a lot of sense to me. From a sick, North Korean point of view, it does. They probably want to differentiate themselves with their own little language, like their role model Apple does with ObjC, and are willing to enforce it.
&gt; However, given that [2] Guile was at one point the designated extension language for GNU It still is. &gt; why some of us abandoned GNU/FSF decades ago. Though GNOME is still being listed as an "official" GNU project, I doubt that somehow GNU/FSF have much (or any) influence on decisions made by GNOME. [GNU](http://www.gnu.org) does not even recommend GNOME as a desktop environment, but GNUStep.
I think you are probably right, your explanation does make a lot of sense. What they are doing seems very wrong to me, and against the spirit of FOSS. They should allow developers the freedom to program as they see fit, and then they (Gnome) can choose the best software to include. Trying to take such a monolithic approach to it seems to be a very bad idea, especially when all the work is done by independent, volunteer programmers. Apple can tell their employees how they want the games bundled with OSX (does OSX even come bundled with games?) to look, act like, and what language. Gnome doesn't have that luxury. 
What would you personally use instead of Gnome?
Is this actually a gnome thing or is a decision from the gnome-games team? Gnome is still mostly C and Python, right? edit: y'all are overblowing this, here's the impetus: https://mail.gnome.org/archives/games-list/2011-October/msg00005.html edit2: aisleriot has also been developed independently of gnome-games since april: https://mail.gnome.org/archives/games-list/2011-April/msg00005.html
&gt; aisleriot has also been developed independently of gnome-games since april Good to know, thanks for the clarification. &gt; y'all are overblowing this Misconceptions like that can happen when all languages but an (obscure) one are thrown out for no obvious reason other than to push said language. The fact is, if Aisle Riot hadnt (voluntarily) left in April, it *would* inevitably have been thrown out or rewritten in Vala anyway.
I've been using KDE. It's mostly recovered from the last bout of being rewritten from scratch and seems pretty solid. 
Gnome/KDE/LXDE etc are very useful for people that do not want to deal with shell/files etc. For anyone else, what's the point of using a desktop environment instead of mere programs ?
I don't need anything more than a file browser, drag and drop, and ability to launch programs as well as nice antialiased fonts. It seems that Gnome is getting less and less useful for that year after year. 
I don't think you're properly interpreting that first discussion correctly. gnome-games is being broken up as a monolithic package. Some of the maintainers of some of the games are discussing how to collaborate after that to produce a polished group of games which would be a shoe-in for inclusion by default in a distro. The chart in the OP is what they decide to do. There are AFAICT no diktats or expulsion of packages to outer darkness, just cross-project collaboration. In fact, there isn't going to be anything to be expelled from in the future.
[http://ftp.acc.umu.se/pub/GNOME/sources/aisleriot/](http://ftp.acc.umu.se/pub/GNOME/sources/aisleriot/)
yeah, it's definitely not an attractive language in the pl-theory sense. you are underestimating how much of a good thing "the gobject/glib/gtk ecosystem is unwieldy to use from c, but all of gnome is based on it; let's make a language specifically targeted to that" can be, though. i'll agree with you that the documentation is abysmal, and that bits of the language could have been better designed, but on the whole i believe it's a great addition to the c family.
the vala mailing list gets roughly as many posts as the chicken one does. it's a reasonably active community, just not on reddit.
Thinking about this after I posted that comment, I'm more sympathetic to the decision. It's not like Gnome is or should be in the business of blessing every game that is made available for Linux -- they provide a desktop environment, which traditionally includes a few small games. If I want to write a game in Scheme, Tcl/Tk or Brainfuck nobody's stopping me. On the other hand, Gnome is a big project, a huge ecosystem in itself of software making up the desktop environment. To contribute any code to a project like that I would expect to adopt their tools and conventions, both to make my job easier (interoperability and a common object model are hugely beneficial) and to increase the overall quality of the project by permitting consistent quality control, build and code reuse or review across the whole project. Even if I'm sacrificing some expressive power and beneficial features from other languages, the project-wide benefits of consistency are much greater than any loss I can't code my way around, or get somebody else to help. GObject, Glib and Gtk have certainly passed the point where using them from C is impractical -- there are so many patterns present that code generation or at least an intelligent lint-like tool which is aware of many such patterns can save programmer time, make code more readable and eliminate entire classes of bugs which might otherwise be pervasive. In this light, I have to praise the creators of Vala for making the bold step of creating a new language to solve these problems. I even have to accept that it's a good thing people can do this without having spent years in research and publishing a whole swag of papers -- even though I might imagine the quality of their invention is perhaps less than it might be if they had letters after their name and shared my world-view. Yep, that definitely makes me sound like a snob with my head stuck up my arse. ... but bringing the topic back to Scheme, let's imagine how this would have gone in the world we like to imagine we inhabit. Patterns are solved in Scheme by macrology -- Vala would be a `syntax-rules` library which expands into core scheme and glib/gobject/gtk. We might imagine this is much better because users "don't have to learn a new language", a falsehood which should be obvious to anyone who has looked at more than two CL or Scheme loop macro libraries. There might be benefits in that the tools for creating languages are common, but few of us would rationally claim that `syntax-rules` is not a dark art for anything more than the most trivial expansions. Finally, the community would probably spend so much time bikeshedding the library, or outright rejecting it because of some theoretically well founded issue of taste, and if it got any traction the waves of ill-will from its detractors would affect everyone's blood pressure for years.
Quickly? It's been doing that for at least 10 years iirc. And its ubiquity as the default desktop environment has been increasing all that time. Go figure.
&gt; Why do the people in charge of Gnome care what language a piece of software is written in, if it meets whatever other standards they set? What standards do you have in mind that are not best served by a programming language? I initially had the same knee-jerk response as you and as most in this thread. But later thought [brought me around](http://www.reddit.com/r/scheme/comments/n5awu/gnome_throws_out_guilepowered_aisle_riot_for/c36rugx). If you want to write a game or any other tool in Scheme or any other language and distribute it yourself, great. But calling it a *Gnome* game implies that it's going to work well in the Gnome desktop and be part of their build and QA process. GObject alone is complex enough that using it from C is unwieldy and error-prone. A Schemer's first response to that situation would be writing macros to more clearly and correctly represent what the code needs to do. That's not really very different from creating a pre-compiler using a syntax that's somewhat familiar to the community. There also doesn't seem to be a great shortage of [tools written in Vala](https://live.gnome.org/Vala/Documentation#Projects_Developed_in_Vala). On this reddit, you're saying your glad you use XFCE ... because C is a more suitable language? Really? :)
&gt; They want Vala to be used, but nobody wants to use it, so they simply forbid all other languages. &gt; From a sick, North Korean point of view, it does. Invective much? Check my other comments in this thread .. I shared your outrage on first reading the page you linked, but some actual consideration of the issues involved has brought me around.
I am not a competent computer programmer by any means, and I don't really know how big projects like Gnome are handled. I'm just saying that if a program works, integrates well with Gnome, and doesn't have a lot of errors, then I see no reason to disqualify it because of the language it is written in. It might be harder to write a game that meets their requirements in Scheme or C or whatever language, but if you can make it work well then what's the problem? I made the comment about XFCE merely to illustrate that I don't use Gnome myself, and prefer XFCE to it. I honestly had no idea what it was written in, I'm not a linux hacker that delves deep into the OS or WM.
How the hell do you think you're going to get integration without language support for the object model used by all the integration APIs? Hand coding GObject wrappers in cobol? Good luck with that, but I wouldn't want to be responsible for your code, nor chase you every time something breaks and I look bad because you're releasing under my brand, nor have to put a brainfuck compiler into my build process just to support your shitty version of minesweeper.
&gt; On the other hand, Gnome is a big project, a huge ecosystem [...] And ThereYouGo -- rediscovering the ridiculous concept that 90% of the managers related to software had: dumb everything down "because that makes it easy to fine more people". It's a myth, it has been around for a while, and it will continue to stay around. Most people will never learn, some people will continue to use this to their benefit. Still, it's sad that an "open source" project behaves more and more like the commercial companies that it used to stand against. Probably not surprising to anyone witnessing how low things can get once those big companies take over. &gt; In this light, I have to praise the creators of Vala for making the bold step of creating a new language to solve these problems. Um, no -- what they do need to do is justify *why* there is a need for a *new* language. (And the web pages provide very little of that.) Without a real reason for creating a new language, there's no boldness, only future regrets about yet another badly designed language. This has nothing to do with "letters after their name" -- that's another cheap shot using the tired "ivory tower" argument (and guess where else that argument is popular...). &gt; Vala would be a `syntax-rules` library You just broke the nonsense meter on my dashboard. 
What would you suggest they do? You obviously have strong opinions on the matter. Would you care to share them constructively, or is spewing invective more to your style?
I would suggest using a real language, or willing to make a real one. I would suggest behaving like an **open** source project and not like BigBrother Inc. I would suggest putting up sensible requirement lists, and not lumping requirements for a language next to requirements for trophies. I would suggest learning more about `syntax-rules` before spewing invective like "spewing invective".
So, you believe that an open source project should be unadulterated anarchy, a build nightmare and completely unmaintainable? Also that a less than perfect language is worse than none at all. The chip on your shoulder is showing. I'd give you a hug, but I'm afraid I'll get bitten. It's ok, we don't think you're unintelligent, just hostile.
There's a huge difference between anarchy and the way open source projects conduct themselves. In fact, the core argument for open source has always been intimately tied to encouraging diversity and letting the code speak for itself, based on its quality and not on corporate decisions like "you have to use Vala". To put this another way, if *not* requiring a specific language is anarchy, then 99% of the FS world is deep in it. And note that I'm not talking about contributing to a project like the linux kernel where you have to write in C: that *is* the language of that project; but here there is a meta project that requires a specific language, so the analogical "non-anarchical" world would be a linux distro requiring that all packages are written in C too. (And please cut the flamebaits out. (Yeah, "we" could keep dreaming that you will.)) 
I think we've discovered the disconnect. You see the Gnome project as more like a linux distribution (lots of loosely-coupled pieces) than the kernel (monolithic). I gave up on hoping it was anything like that years ago, when installing any single piece of Gnome software pulled in a hundred meg of libraries used by nothing but all the other Gnome tools. I think this really cuts to the core of the OP's misplaced issue. AisleRiot, as I recall, is a pretty good framework for expressing card games in a general way, and ships with definitions for dozens of games. It's a good project and I respect it. I do not see any reason it would benefit from becoming part of the Gnome ecosystem, nor any benefit Gnome would gain from the work involved in packaging it. Really, I have trouble understanding how Gnome-akin-to-Linux-distribution would be at all a useful project. Not that I'm waving any flags about how useful Gnome is now! I'm glad we've been able to tone down the discussion to more civilised levels.
I'm using vim, zsh, xmonad and... konsole and generally kde. Oh, not to mention okular, probably the best reader around. The desktop plasmoids are nice and shiny, don't hurt a bit, and it's nice to have a full set of desktop applications for stuff you just don't do often.
I've looked at the source of AisleRiot and found that its core is actually written in C, only the games are in Scheme. I think it wouldn't actually be a bad thing if the core were translated to Vala.
I'm not sure if my copy of DrRacket is bad because I got it from the ubuntu repository or what. The documentation says to go to the "general" tab of the preferences dialog but there is only one tab available and it isn't "general." Is DrRacket documentation out of date or is my copy?
Hmm, I'm on Windows. When I goto Edit&gt;Preferences, I see the tabs.. Not sure what's up with your copy. I just checked this: Racket preferences&gt;Editing tab&gt;General tab nested within. Then uncheck "Enable keybindings in menu" This is in DrRacket 5.1.3.
Yes, if it is considered as a *single* project than things are different. On one hand, the point of corporate-like evilness is obviously not there since a single project can do whatever it wants; but on the other hand, the point of a language just for that becomes more ridiculous. Now, obviously there are other clients for the language -- so there is *someone* who thinks that people should use this, and therefore the point about language design (or more likely lack of insight in this case) is still standing. Yet another point is that if this is a single project, then "gnome-games" is an incredibly bad name for it -- for example, "AisleRiot is not part of Gnome Games" sounds much worse than "AisleRiot is not part of Foo's Game Collection".
&gt; the point of a language just for that becomes more ridiculous. Now, obviously there are other clients for the language -- so there is *someone* who thinks that people should use this, and therefore the point about language design (or more likely lack of insight in this case) is still standing. I don't know what "other clients" you are talking about. As far as I know, the maybe hundred or so [applications written in Vala](https://live.gnome.org/Vala/Documentation#Projects_Developed_in_Vala) are all part of the Gnome project. I've never heard of the language outside the context of Gnome, and as far as I'm concerned that's its only audience. You know, the several thousand people dealing with a few million lines of C code which manages to interoperate and provide the features that sell Gnome, only because people use GLib and GObject correctly. How would you suggest this community make their life easier and improve their productivity? Should all of them learn Scheme overnight, or abandon GObject and do something else? &gt; **"gnome-games" is an incredibly bad name for it** -- for example, "AisleRiot is not part of Gnome Games" sounds much worse than "AisleRiot is not part of Foo's Game Collection". Err .. what? https://live.gnome.org/GnomeGames : &gt; GNOME Games is a collection of fifteen small "five-minute" games in a variety of styles and genres for the GNOME desktop. 
Re making their lives easier: I'd suggest using a real language. And no -- Scheme is obviously not a good fit for that, it needs to be something known that will lower the barriers for joining a project, and would best be something conventional in the C family (but the point it that an existing one is far better than making up a new one). There's another use for a different language: scripting. That's where Scheme was supposed to fit in, and as much as I like it, it is not a good fit for that either -- and that's for the usual (and admittedly bad) reason of not having a familiar syntax. My guess for a best language there these days would be Javascript or maybe Python. Yes, it would be nice to have a language with extensible syntax but the PL world is not there yet (though it's an area that has become much more popular in recent years). That goes back to what I started with about your statement of dealing with gobjects with some `syntax-rules`: while it (`syntax-rules`) is a reasonable tool for doing simple language extensions, it doesn't go much farther than that -- it is extremely limited and has some known problems. Many of these are answered by a proper syntax system (like `syntax-case`, which is part of R6RS), but even that is insufficient for making a language that fits "the masses". For that -- IMO -- there is no way to bypass the surface level syntax point, hence the need for a Scheme-like language with a standard syntax but one that still provides a way to extend the language. And re the name: yes, that "fifteen small" description is good, but "Gnome Games" is still a bad name for it. Not being in a project that has such a name has implications on how people view a game. This thread of comments is a witness to exactly that. 
Don't worry about it, just pretend it can read your mind. All will be well. (I'd like to see a formal spec too, actually.)
I don't know about a formal definition, but your example does work. You define the input part of the macro as "(test (a ...) ...)". "(a ...)" means a list of 0 or greater length where each element can be anything (because an identifier matches anything). Now replace the "a" with "(a ...)" and this means your macro expects a list of lists as input. Where the outer list can have a length of 0 or greater. And the inner list must be a list of length 0 or greater. You define the output part as "(list '(1 a ... 2) ...)", which means that each inner list in the input to your macro is transformed to '(1 a ... 2), where "a ..." represents the inner list. And the outer ... in the output part means to do this for every inner list. If your input code is "(test (a b c) (a b) (c) ())", after transformation, the code is "(list '(1 a b c 2) '(1 a b 2) '(1 c 2) '(1 2))"
Yes, actually I assumed it was working because plt-r5rs accepts it and does the sensible thing. But It's still not clear to me what it means when you mix two ellipses in the same subexpression: ((1 a... 2 b ...) ...) What happens there? A crossproduct? What if a and b don't have the same length? I'm trying to implement it (for fun) and I keep stumbling into these corner cases.
Yes, as a user that's fine but if you want to implement it, it's really annoying.
Are two ellipses in the same depth legal, though? I'm looking at http://docs.racket-lang.org/reference/stx-patterns.html which enumerates the possible shapes to templates. Every case of a pattern appears to have, at most, one ellipsis.
"((1 a... 2 b ...) ...)" will only work if "a ..." and "b ..." are nested within the same outer ellipses in the input part of the macro definition. This works: (define-syntax test3 (syntax-rules () ((test3 ((a ...) (b ...)) ...) (list '(1 a ... 2 b ...) ...)))) This doesn't: (define-syntax test2 (syntax-rules () ((test2 ((a ...) ...) ((b ...) ...)) (list '(1 a ... 2 b ...) ...))))
I've found the following papers helpful: How to implement a hygienic macro system: * [Macros that work](http://mumble.net/~jar/pubs/macros_that_work.ps) * [The Scheme of Things: Implementing Lexically Scoped Macros](http://mumble.net/~jar/pubs/scheme-of-things/easy-macros.ps) [JRM's Syntax-rules Primer for the Merely Eccentric](http://hipster.home.xs4all.nl/lib/scheme/gauche/define-syntax-primer.txt) - this talks about how to use the macro system, but talks a lot about ambiguities, edge cases and the like, which I found helpful in understanding some of the details in the spec and the papers above. After reading the first two, I returned to the spec. I found there were a lot of subtle points in there that were not clear on earlier readings, but which made themselves apparent given the new understanding I'd gained from the papers. I found that studying [R5RS section 7.3](http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.3) closely, and hand-expanding some of their usages (especially nested usage) in code fragments I had was a worthwhile (though very tedious) exercise. If I'd read JRM's primer earlier, I might have used his tricks to do staged expansion automatically, though I think I'd have missed out on some important behaviour if I hadn't been forced to consider it when manually expanding. Edit: some clarification on the contents of the papers.
It was originally specified in the paper *Macro by example* by Kohlbecker and Wand, in 1987. I believe that paper provides a specification.
Thanks, I'll check it out! 
How light is it?
Exactly what I was looking for (just read it), thanks a lot!
My god, that documentation is misled -- it seems to assume dynamic scoping...
This expect library have done the easy part of "expect". I think the harder part is to deal with tty allocation (passwd for example).
I don't have a Scheme REPL on hand, but I'm guessing an `apply` would do the trick.
It looks like the following are equivalent: (apply (curry (vector-map +)) list-of-vecs) (apply vector-map + list-of-vecs) I wonder if the dialect of Scheme you're using matters?
Vala is a me-too version of Java and C# that compiles down to C instead of a VM because the Gnome team doesn't understand the reason for having components compile down to a VM is so you can sandbox the components allowing one to pull in arbitrary components with the secure knowledge that the VM should be able to let you know if it's trying to access data it should not. This has been the evolution of such a system in Windows land: `OLE` (interoperating components) -&gt; `COM` (generic components with arbitrary interfaces) -&gt; `DCOM` (`COM` on a network) -&gt; `.Net` (`COM` components sandboxed in a VM) Gnome began as a clone to OLE but such an idea is long in the tooth. Miguel tried to get Gnome folks to accept Mono but they were correct to be suspect of cloning such a system so verbatim as it lets Microsoft drive innovation, the "intellectual property" issues, and it's just embarrassing to have a system which rips off their entire API. IMO, a sandboxed VM is needed. `Parrot` or `LLVM` are good choices. However, neither of those have platforms and are largely interested in providing tools for language implementation. Those are important features, but for a world of arbitrary components downloaded from arbitrary sources, a platform where you can set permissions on a process so it can only access certain features. You may have seen such a thing on Android. Another option would be to push Jails/OpenVZ to become more pervasive and allow user defined settings on a per component basis. This is so you can download and try programs without watching `netcat` and wondering why program X keeps sending your `.pidgin` file with plain text password to `passwordfarmer.program-x.com`
It's definitely not "iterative" in the sense that it will still consume stack space proportional to the size of the input. What you're looking to do is to "reduce" every execution to a new execution of the function with different arguments. Let me try to explain it better. When you say (cond ((= n 0) a) ((even? n) (square (expt-iter a b (/ n 2)))) ((not (even? n)) (* b (square (expt-iter a b (/ (- n 1) 2))))))) you're saying that your result is, if even, the result of squaring the result of the new call to the function. When you say that, you'll create a chain of recursion because (square _ ) is "waiting" for the result of the recursive call. an example of a simpler function with no recursion cost is, (using the good old factorial as an example) (define (fact n) (fact-iter n 1)) (define (fact-iter n acc) (if (zero? n) acc (fact-iter (- n 1) (* n acc)))) Hope it helps. Edit: I didn't really proofread this, so I might have made a stupid mistake. Just thought I'd leave this here. If you need anything else reply here and I'll try to make this better. It's just that I'm kinda busy in this very moment. Edit2: If I caught the method straight what you want is something like this. (define (square n) (* n n)) (define (expt b n) (expt-iter 1 b n)) (define (even? x) (zero? (remainder x 2))) (define (expt-iter a b n) (cond ((zero? n) a) ((even? n) (expt-iter a (square b) (/ n 2))) (else (expt-iter (* b a) b (- n 1))))) I did this by following the method I found on wikipedia here: http://en.wikipedia.org/wiki/Exponentiation_by_squaring#Computation_by_powers_of_2 In any way, Thanks. I didn't know that method before.
Aha, I see what I was doing the wrong way round now! Thanks very muchly indeed.
I would implement them on top of vectors. Structs are really just fixed-size vectors anyway, conceptually.
How would I do the symbols-&gt;indexes mapping, though?
I want an immutable data structure with a set number of named fields and generic accessors, so that I can do e.g. (thing 'type) or (thing 'name) without having to write functions that work only on one kind of 'thing'.
I'd love to see something like basic python implemented with this. Maybe something like J?
This was a brown-paper-bag release after 2.0.4, which has better release notes :-) http://www.reddit.com/r/scheme/comments/p4luv/gnu_guile_204_released/
Thanks for the pointer. My congratulations go to Ludovic, you and the rest of the team!
Here is some example output: ("Blino" "Ykudatth" "Krylego" "Psai" "Nabesona" "Undigakkse" "Dedilezus" "Zephor" "Unyla" "Baphmaranar" "Blgerded" "Drtavegort" "Dam" "Makity" "Mangharn" "Errferar" "Glighitazzo" "Blg" "Etrgisth" "Psamazzazzo" "Cholalis" "Larigas" "Maaank" "Qwaallicon" "Etris" "Kng" "N'zrdodart" "N'zuzeid" "Bagokhrazzo" "Norace" "Marffeg" "Gapho" "Rirkash" "Etrdath" "Gaawlarazzo" "Zuby" "Etnadoo" "Inzavek" "D'zuakande" "Knzak" "N'Honegllone" "Psu" "Qwelatia" "Bannatcth" "Etrku" "Gaacubawna" "Nouragueus" "Blibatiar" "Lit" "Ung" "Blikeg" "Peviffrart" "Etrorbusen" "Unguzu" "N'zratth" "Eragrdemo" "Fim" "Glarago" "Degu" "Zaqu" "Inylboo" "Naqurictee" "Bengrbryna" "Blinarawna" "Marghoo" "Qwery" "Drchieglione" "Ligudock" "Erane" "Ne'lbr" "Zuumazzog" "Zankumalio" "N'Holy" "Novill" "Pabichrd" "Blino" "N'rbattazzo" "Bliglliart" "Rit" "Ne'Lag" "Ung" "Lakstar" "Baquras" "Ze'Larawnar" "Maablira" "Ungokhes" "Slighimo" "Pezanerart" "Dordeg" "Tzu" "Knd" "Kralboo" "Faqurazuse" "Manokh" "Se'lariazzo" "Qwerorawna" "Etrnabuse" "Figoveg" "N'rny" "N'zrsetazzo") 
&gt; I'm writing a roguelike in Racket. nice, i'll be looking forward to that. ...now i think i'm going to burn the rest of the work day with angband.
I'm mostly interested in keeping it pure for didactic purposes and to see how it should be done. I put the entire game into the state monad, which seems to work ok, but is a little strange and then I got really into using _arrows_ over stream functions, but that was too hard to understand. Then I got a second job writing Common Lisp and all my time disappeared. 
I know how that works. My toy project started as a completely different game in 2008, and lay fallow for years. I just have an opportunity now to resume work, having a rare conjunction of both a better idea and a little time in which to play with it. See how far I get this time.
This version is slightly different because of the venue: CACM, in contrast to ACM Queue.
In the match expressions, I noticed you're using (list) instead of '() and similar with cons. Stylistic preference or a requirement of racket's dialect of scheme?
Samth's answer is more informative, but the answer is that it is a stylistic thing. I guess I'm vaguely suspicious of the conflation of quotation and list construction. I prefer to keep things symmetrical and explicit. If I use the pattern (list a) then I should use `(list)` to match the empty list, because `'(a)` is not the same as `(list a)`. You may notice if you poke around my code base that I don't use '(stuff ...) to make new lists too often. 
It is _amazing_. I just bought Tales of the Dying Earth too. I am optimistic that it too will rock.
no, i think you're right, libtcod does seem to assume a rectangular grid.
By the way, remember to have the doto form return the object that is being hammered on. user=&gt; (inc (doto (+ 3 4) (println "was printed"))) 7 was printed 8 (This means you can put a constructor call as the first arg to doto, which is great in the Java interop case.)
Thanks for your reply. Correct me if I'm wrong, but your solution looks like a defmacro style definition (like clojure's implementation) as opposed to a syntax-rules or syntax-case macro. Since I'm just learning about hygienic macros, I'm particularly interested to know how doto might be implemented as one.
I'm very out of practice with scheme macros, but this seems to work. Basically, just use one macro to setup the sequencing and another to do different things for (list) forms and identifiers forms. I hope this is what you were looking for. Pardon my non-idiomatic identifiers; too much C and ML recently. Also, if you end up doing much with syntax-rules, you should make utilities for defining macros. The syntax is pretty cumbersome as-is. (define-syntax doto* (syntax-rules () ((_ t (f A ...)) (f t A ...)) ((_ t f) (f t)))) (define-syntax doto (syntax-rules () ((doto target form ...) (begin (doto* target form) ... target)))) 
Thanks! I haven't punched this in yet but I think I grok it. Can you elaborate on your suggestion to make utilities for defining macros? Do mean that it's common to build complicated macros on top of simpler ones (sort of like you do in this example), or perhaps something else?
ah - yes, i didn't realise what you were asking.
I just mean that writing: `(define-syntax foobar (syntax-rules () ...))` every single time you write a macro is a lot of boilerplate. I always end up writing a macro to help with this, something like: (qmacro doto* (_ t (f A ...)) =&gt; (f t A ...) (_ t f) =&gt; (f t)) (qmacro doto (_ t F ...) =&gt; (begin (doto* t F) ... t)) Or whatever syntax you'd prefer.
You should ask Felix to add this to the miscmacros egg. It's certainly useful.
You may want to take a look at [clojurian](http://wiki.call-cc.org/eggref/4/clojurian). You can get the source code from https://bitbucket.org/DerGuteMoritz/clojurian
Excellent! You should join us in #chicken on freenode. 
Here's a slightly slightly improved version, in case someone stumbles across this thread in the future. Using your doto*, (define-syntax doto (syntax-rules () ((doto exp form ...) (let ((target exp)) (begin (doto* target form) ... target))))) This gives us the benefit phyzome points out, of being able to pass a constructor to the macro: (define v (doto (make-vector 2) (vector-set! 0 'foo) (vector-set! 1 'bar))) ;; v now equal to #(foo bar)
As of version 2.95 it has been removed from miscmacros in favor of a syntax-rules implementation available in clojurian-syntax
&gt; I've found it's a little bit slower than chicken/gambit-c, but not by much. that will certainly be the case if you compare the drracket repl to chicken or gambit's text repl. the drracket interface has debugging and tracing stuff running on all the code by default that adds just a bit of sluggishness. &gt; The Racket language is also different enough that moving to a different scheme would be more difficult than usual. moving code over, certainly. i think the more abstract skills would remain transferrable. the spirit of scheme is kept, if not the exact procedures and macros.
Lack of portability?
Can you elaborate please?
The issue with Chez is that it costs a pretty penny, and Petite doesn't really hold the same speed claims; Last I tested, Gauche &amp; Gambit were faster, and it certainly looks that way on the [Larceny benchmarks](http://www.ccs.neu.edu/home/will/Twobit/benchmarksFakeR6Linux.html). In the past, I've always found Gauche to be consistently fast (i.e. it isn't always the fastest, but it also doesn't decay like other smaller implementations) and near the front of the pack, so to speak. Really, you have to try a bunch of different Scheme systems to see which one best fits your niche. I do think that Racket has the appeal of "low barrier to entry, no ceiling" going for it though.
That looks promising, but a little more context would be awesome.
Awesome! Was looking for something like this over the weekend. Tutorials / more info would be greatly appreciated of course :)
As I understood, the original creator (not me) will provide more details in due time. Edit 2: it's here https://github.com/evhan/heroku-buildpack-chicken
Besides poor performance, what made me discard Racket was that the priorities of Racket developers are quite different from mine. The tasks where I use Scheme (text processing, log analyzers, monitoring, backup/restore) are usually considered by the developers as not Schemish enough. See, for example, [see this mail](http://lists.racket-lang.org/dev/archive/2011-November/008268.html): If a Perl-type person asks you, "What does this Perl one-liner look like in Racket?", the preferred responses are: (1) "That task looks like what Perl is good at"; (2) do as politicians do, and answer the question that you wish you had been asked; (3) pretend to speak only Swahili and to not understand the question.
Hey...i really need your help with something...i have to do a function in scheme like this (define recursive f) and it returns if the function f si tail recursive or stack recurvise.... i don't really know how to do it....and i dont want to use trace because it is not right. Thank you Oana
Note that in response to that mail (by Neil Van Dyke), Matthew Flatt (the lead maintainer of Racket) writes that he sped up that example [by a factor of 3](http://lists.racket-lang.org/dev/archive/2011-November/008269.html).
Yes, and it was a huge relief, but I referred to the attitude rather than this certain problem. A couple of years ago there was a thread in the mailing list about a motto for PLT Scheme. Todd O'Bryan proposed ["Function follows form"](http://lists.racket-lang.org/users/archive/2009-December/037316.html). A pun, of course, but a very deep one. It may explain the reasons behind the MIT decision to switch from Racket to Python.
I don't get what you are saying. What do you mean with "just a buch of diagrams"? I was asking for diagrams. There are diagrams for grammars, for structured programming and so on. I was asking for common way to draw diagrams that represent scheme programs. 
nothing about those diagrams depends on haskell in any interesting way. they're just as "for" scheme as they are for haskell. i think i even have an old book on C with similar things.
First, MIT never used Racket in an official course, although the student-led resurrection of 6.001 did use Racket. Second, I don't see what the problem with that motto is -- it's a reference to the idea that the implementation of a function should follow the form of the data it processes. Third, the point I was making is that not everyone agrees with the attitude you quoted. In particular, the lead developer doesn't agree.
Excellent! But, what is the catch? ;) Also, what kind of projects can be hosted (under which license) and is there bandwidth limit?
The problem is defining what's considered abuse meaningfully. One can be perfectly legit and well-intentioned and have his web service booming usage or even DDoSed. I'd prefer having a somewhat concrete set of limits before committing any significant amount of work. EDIT: by the way, I tried creating an account and got an Internal Server Error.
I am a Lisp programmer and Linux systems administrator; if he wants any help running things I'd love to lend a hand! Also, signing up for an account leads to a 500 error. 
Hi, I'm the actual friend mentioned in the headline. "Also, signing up for an account leads to a 500 error. " Thanks for the report; it should be fixed (I manually installed the rest of your account. I hope it works now). "I am a Lisp programmer and Linux systems administrator; if he wants any help running things I'd love to lend a hand!" Right now I'll try and fix embarrassing errors like a 500 during sign-up by myself, but if the need arises, can I contact you directly through the address you signed up with ? 
Thankyou. I'm going to try to use this to do a personal project to help my scheme learning.
The license prohibits binary-only distribution. This makes it a no-go if your platform disallows such things. IE, Microsoft Xbox, Sony PS3, et cetera.
*I add some details in my repository. For those who do not know: Nonogram or "Paint by numbers" is a logic puzzle that appear on newspapers. here is the Wikipedia [link](http://en.wikipedia.org/wiki/Nonogram).
I did not know that about the license. That kinda sucks.
&gt; The license prohibits binary-only distribution. Can you explain to me what you think that means? I am a little fuzzy on the LGPL.
The LGPL requires that you redistribute the source code of the library to anyone you also supply a binary to, if they request it; and provide a way in which they can relink their modified library to the original binary. However, it does not require that you redistribute the entire source code of the program, just the library itself. So you can link a binary to it and not have to redistribute the binary source provided only that you dynamically link the library. If you statically link the library you have to provide the users with a way to relink a modified library into the binary, or provide the object data that was used to link the binary. Now, closed hardware vendors like Sony, Microsoft and Nintendo absolutely, positively disallow this behaviour. You simply cannot allow users to compile a new library, link it to your object code or replace a dynamically linked object, and allow them to run it on their hardware. So, you can't use GPL or LGPL or other copyleft-licensed code, just zlib or BSD only.
Thanks for that.
There is [Lisping](http://slidetocode.com/) (ex touchscheme). It's not the same thing, but is a step forward in manipulating the AST directly, instead of a textual representation.
I am still yearning for a decent tutorial on monads. 
What happens is you have a programmer who fucked up and there's now a bug to be fixed. Scheme isn't Haskell, I'm not going to force a stricter type system on it for the sake of purity.
Thanks! I see where you're coming from now. It sounds like what I've written isn't what the signature I wrote describes, nor is it quite what you're saying how it should behave. I'm spending some time to double check that what you're describing isn't what it currently behaves like. **Edit:** I think it's ok? The define-monad function itself doesn't do much work other than to wrap the bind/unit functions up in a promise and force them when required. The rest is just hand-waving to get the doto-using and using syntax to behave as expected. The bind and unit functions themselves actually handle the wrapping/unwrapping/execution behaviour you described. And the functions the bind operate on clearly must have the signature of the form **a -&gt; M b**. So, with this, (thanks to Cameron Swords) the state monad is: (define-monad &lt;state&gt; (lambda (a) (lambda (s) `(,a . ,s))) (lambda (a f) (lambda (s) (let* ((p (a s)) (a^ (car p)) (s^ (cdr p))) ((f a^) s^))))) Looks like I was just completely and totally mistaken, and your previous wiki correction was correct.
this post is meaningless without context, and the context it provides needs context too! I would like the author to focus more on the explanation and less in babbling, in particular don't assume everyone reads your blog regularly.
i'm not aware of any racket-specific repository besides planet. the next most relevant thing would be projects on github, or just gist fragments there.
Ask on the user mailing list. Often someone will have some code they haven't posted publicly that they would be happy to share.
Yes, there are a bunch of people who put racket code on GH.
Step 1) get a prototype Step 2) let people evaluate that.
As much as I love scheme ... why? If you just want to have fun, go ahead. But if you really want to build something, you always have to ask yourself: "What's the right tool for the job." 
I will build the prototype. I want to hear your opinion maybe there is something that i miss.
What is the right tool php,rails? I do not hate php. I see three advantages in using scheme: 1. It will be new so we can learn from OpenCart mistakes. 2. The OpenCart engine is simple and clear but the code that use it is full with boil plate. The templates are too dense. Using scheme non oop approach and macros we can make it cleaner. 3. We can use it to make money, in our prefer language.
What platform and flavor of scheme do you currently use to write web apps?
I wish that I could use chicken scheme but if I use chicken scheme how I will be able to deploy the application. Because of it I think that I will use Kawa scheme. Do you have any suggestion?
Can you expand on why you think Scheme is not an appropriate tool for use on this project?
I didn't say it's not appropriate. Just, that there are better tools. I see the biggest problems in the lack of libraries and frameworks. Nowadays, a language needs a big and vivid ecosystem and that's not really happening with scheme. The community is fragmented on several levels and that makes everything difficult. The most at-home feeling in a community I found, so far, with chicken scheme. And yet this community is quite active, you'll have trouble finding all the puzzle pieces you need to write a web application at a reasonable speed. Other languages already have mature and stable frameworks that get you up to speed in almost no time (ruby+sinatra, e.g.). There's documentation and more than enough helpful people if you have questions.
I use Racket because it's what I know. It's also got some nice string processing things and command line argument handling.
Racket, it has a lot of great features and I know it best.
Gauche is intended to be used as a scripting tool.
Guile A few general reasons from the top of my head * It is an extension language - not only is it designed to extend c programs with scheme functionality, at the same time this means that it is designed to be extended. C-function callable from scheme? Really simple. I think this makes it generally more flexible and robust. I easily fear to be "trapped" by a language, not being able to easily extend it at any time if I need to (which yet never happened) * It is GNU's Ubiquitous Intelligent Language for Extension - and follows GNU standards * With version 2 it is quite mature, with its compiling to byte code for a new virtual machine, with the internal use of inbetween languages and the possibility to be extended to interpret other languages, and even switch between languages at the repl * It has a clean and sane naming scheme - actually one of the top 3 reasons why I like it this much * It supports r6rs, utf-8, has the srfi's and many more libraries * It supports the srfi-37 for command-line argument evaluation and a library called "getopt" I do write scripts in scheme and would think it's about as easy as it gets. I use a custom procedure to initialise a basic command-line interface in one line. But * Afaik guile requires 2 lines for a shebang, which I find ugly: \#!/usr/bin/guile !# * I don't know of any simple procedures for connecting multiple programs with pipes as easy as with bash, "a |b |c". But one could implement something in scheme. There are of course procedures for creating and using pipes * It took a long time to find out about all the useful procedures available * Frankly, I don't like the implementation of the new web features * The reference manual is good, better in content than presentation imho The original SCSH does not support 64bit systems I think, but there may be a separate library.
Scheme48, because it has scsh. Other than that, Racket when I need the performance.
I second chicken, been playing with it for scripting purposes. If you need to wean off slowly (or lazy like me) the posix unit can evalutate a "command line string" in various contexts (a bunch of piping calls, such as "call-with-input-pipe" or things like "process") eg. (call-with-input-pipe "a | b | c" (lambda (inport) (read-string #f inport))) will evaluate "a | b | c" in the shell, and read the output from the command (there are ways to manually connect pipes, but my efforts so far have been tedious) 
Can you show some example on how do you use guile for shell scripting? I would like to also practice scheme and avoid bash, but I'm not sure how would I start to even do simple calls to external programs, directory browsing and file management (other than maybe "shell-comand" kind of calls which are ultimatelly bash?).
The stupid square brackets they insist on foisting on everybody. Apparently they thing that counting parentheses is cool.
I needed a small http client to test an API I was developping using Racket so I made this : http://paste.fulltxt.net/FZ4-HeULc. *It is not general purpose*, only an ad-hoc script for my need at that time, but I'm sure you'll find what you are looking for in there.
Oh, *fantastic*. [get-pure-port](http://docs.racket-lang.org/net/url.html#%28def._%28%28lib._net/url..rkt%29._get-pure-port%29%29) appears to be exactly what I want, as for what I need to do, I need to send some headers. This is much better than creating the request string on my own, and -- unlike my own code, which is broken somehow -- might actually work!
The Little Schemer is good - at least, the little Lisper is good, and it's the same content. It moves you through things with a series of questions, building on previous stuff, quickly introducing the reader to recursive reasoning, etc. It dives right in with essentially no discussion of syntax or operators or anything - you will learn by doing and figure out what stuff means in context. It does require an interest in computer logic qua computer logic - if writing a little function to reverse a list or interpolate two lists or whatever doesn't sound interesting, you/he will be bored. I've never used [Casting SPELs in LISP](http://www.lisperati.com/casting.html), but if making a game helps keep your interest more, that might be something to consider if you're cool with Common Lisp.
Okay, so you want to know why one choice is better than another. For your brother, I think you can and should eliminate books like Teach Yourself Scheme in Fixnum Days or Dybvig's Scheme Programming Language. They are primarily language books- great for reviewing a feature or picking up Scheme if you know ML, but not the best for if you have no programming experience. The three good choices remaining are TLS, SICP, and HtDP. When deciding which text you want to use, I think that it comes down to first deciding if you want TLS or HtDP/SICP. The three books are all somewhat linked. SICP was written for a class at MIT- 6.001; their old introductory programming course. HtDP was written because the authors felt that SICP didn't do a satisfactory job as an introductory programming book- they felt it was too advanced to start with. The same lead author (Matthias Felleisen) wrote both HtDP and TLS. Here are some things to keep in mind. HtDP and SICP are both traditional textbooks. This has positives and negatives. They have exercises and practice problems and resources online designed for classes (MIT OCW has great SICP lectures too). However, that also means that they're textbooks- not everyone wants to read them in their spare time. SICP can be a bit difficult to jump right into, but goes the most in depth. TLS is definitely the most fun of the three, but it also covers a decent amount of advanced material. For a first time programmer and a high school student picking this up for fun, give him TLS. HtDP is a good choice also, but it's just not as fun. SICP will probably be too advanced to start off with. Besides, it shouldn't be all work.
Thought this was the best analysis until .. &gt; give him TLS I suppose "fun" is one way to say it but for myself I'd say "stuck to a quirky format that gets old in a half hour." :-) Anyway, try one or the other and if you and your brother like it then stick to it, else switch. Good luck!
Out of curiosity, did you read The Little Schemer as a first time (or similar) programmer, or did you read it after you were already experienced? Also, how far into the book did you continue?
Unfortunately, it's also extremely out of date. For example, there is a section on `define-macro`.
No, I read it as someone who had programmed in other languages. I got perhaps 1/3 of the way.
Also, note "Picturing Programs" -- it's by a teacher/fan of HtDP, but one who wanted something more engaging and (incidentally) image- and animation-leaning. It still follows HtDP's data-driven approach.
The second edition is also worth looking at, even in its incomplete draft. http://www.ccs.neu.edu/home/matthias/HtDP2e/ Also encourage use of forums like this one and mailing lists, so that we can help answer questions!
Actually, if he wants to learn programming, I guess you can show him the basic constructs of scheme and let him solve some problems on his own. Then start with one of the fine books others have mentioned. In my experience the books dive into the matter too fast for highschool studends, as they struggle with much more basic problems at the beginning (How to quit the IDE, how to debug my code, etc.) than having their minds free for the new things these books want to convey.
[Land of Lisp](http://landoflisp.com/) offers to teach Common Lisp "one game at a time". I don't know if that's close enough or worth translating into Scheme. If it ever comes out, [Realm of Racket](http://realmofracket.com/) promises to do the same (in Racket).
Yes. Dan's publisher won't let him distribute a PDF copy for any reason, but I will say that it's relatively easy to find a copy anyway. That said, if I were you I would not bother with The Reasoned Schemer. It's quite off the beaten track. And if you start in on The Little Schemer and it's too slow, see if you can't find a copy of [Scheme and the Art of Programming](http://www.amazon.com/Scheme-Art-Programming-George-Springer/dp/0262192888). Dan gave me a copy for reference and it certainly moves much faster.
I know this comment was a long ways back, but I figure you might want too know anyway. As someone who picked up the Land of Lisp book a few days ago, and is around page 75 or so, only at the first game.. I believe it would be extremely hard too translate this into scheme. Not impossible ofcourse, but considering how the teaching style works, you would have a much easier time going from Scheme-to-lisp (like some people do with sicp), instead of the other way around. edit: on a side note, if Realm of Racket does the same as Land of Lisp, it will be damn cool.
Use The Schematics of Computation by Vincent Manis and Jim Little. I call it "SICP for mortals". Has all the big ideas of SICP but is easier going. Has chapters with interesting projects, like relational databases.
"Chicken Scheme" has got to be best name for programming language that I've seen in awhile. 
It's the name of an implementation (interpreter, translator to C, libraries, etc.). The language is just "Scheme".
Great idea! Does it have an easy to use IDE like BASIC had?
Java? There are multiple Schemes that have a GUI library. You could have used Kawa on JVM. But Java?
He makes some nice arguments, and some of them I've been thinking about, myself (although with basically no formalism, so they're not "arguments" per se). I've been thinking about this problem on and off for a couple months now and would love to see a healthy discussion on the subject. Do any of you know of the opposite opinion being held and defended by any paper or article like this that we could refer to get a good look at both camps, if there are in fact two?
For someone who's never used continuations (of any sort), do delimited continuations answer all of these objections? 
Aw Yeah. I have a class with Prof. Ierusalimschy starting next week! Looking forward for it. Thanks for the link.
CHICKEN Scheme provides bindings to OpenGL, SDL, cairo and many more, such as the Chipmunk Physics engine. It may be worth a try.
Chicken Scheme is my favorite. Don't use Stalin unless you're compiling 5 line floating point calculations. It is definitely not a general purpose scheme compiler. 
4th in line to say that chicken-scheme is kick-ass.
Gambit Scheme has a very good Scheme to C compiler; it's arguably the best Scheme to C compiler available, and has a neat multithreading system. If you want native Scheme all the way down to compiled code, Chez Scheme can't be beat. Racket is fine, but it has moved far enough away from standard Scheme that it's essentially non-interoperable with other Scheme implementations, so if you choose Racket you're stuck with Racket. Bigloo is very good if you prefer C++ to C. Other posts have mentioned Chicken and its large collection of built-in libraries; it's not bad, but Gambit generally produces faster code, probably as a result of generally slower compilation. You're unlikely to go wrong with any of these compilers. [Phil](http://programmingpraxis.com)
If you're looking to do real scheme development, then Chez is the way to go. Fastest scheme out there, and Kent's book is really useful. It also has a good FFI
The 4.7 and 4.8 series of Chicken feature a bunch of performance enhancements. I haven't seen any comparisons between newer Chickens and Gambits, but I'm rather curious to see how they perform.
Bear in mind that licensing is a real issue with Scheme, so take care when selecting which you use. Assuming you're not making a GPL'd product: Gambit, Racket, Bigloo: you'll be shipping LGPL libraries alongside your bin. Chez: you'll be paying a licensing fee. Chicken: It's BSD'd, so just drop the copyright notice somewhere alongside your app, or be extra-friendly and voluntarily put it in the credits dialog of your app. Personally, I prefer Chicken due in no small part to the amazing community.
Care to link some references? Not trying to undermine the argument or anything, I just have an interest in the subject and would like to read the reasoning behind it. Especially, do you know of any standard resource to read on the definition of prompt &amp; control0 and it's strengths/weaknesses?
Sure. But beware*!* I've had an hard time understanding them because of the assumption made by the literature that you *perfectly* understand CPS and continuations in general. Since I'm lazy, have read so many papers on this that I can't remember them by name but only by argument, and that I can find most of them on Oleg's website as references with an almost plain English explaination, I'll be abusing of links to his dissertations. The standard definitions of the control operators (`control0`, `shift0`, `control`, `shift`) basically amount to: (note: `prompt` and `reset` are the same thing, I'll be using `prompt`) E[(prompt G[(control0 k expr ...)])] =&gt; E[(let ((k (lambda (x) G[x]))) expr ...)] E[(prompt G[(shift0 k expr ...)])] =&gt; E[(let ((k (lambda (x) (prompt G[x])))) expr ...)] E[(prompt G[(control k expr ...)])] =&gt; E[(let ((k (lambda (x) G[x]))) (prompt expr ...)] E[(prompt G[(shift k expr ...)])] =&gt; E[(let ((k (lambda (x) (prompt G[x])))) (prompt expr ...)] Where `E` is the continuation of the expression `(prompt ...)`, and `G` the continuation of the expression, i.e., `(control k ...)` up until the first `prompt` you see. The only difference between `control`/`shift` and their 0 counterparts is how they reinstantiate the prompt, and it only matters there are more than one operators inside the prompt. Some examples: (+ 2 (prompt (+ 3 (shift k (k (k 4)))))) ; The continuation E is (lambda (x) (+ 2 x)) ; The continuation G is (lambda (x) (+ 3 x)) ; The code is equivalent to the following: (+ 2 (let ((k (lambda (x) (prompt (+ 3 x))))) (prompt (k (k 4))))) ; Transforming the same code with the another operator is left as an exercise for the reader. It's a big deal because this: (define (f x) (+ 3 (shift k (k (k x))))) (+ 2 (prompt (f 4))) also works. As you probably you can see, `control0` can implement the others quite easily, `control` and `shift0` can easily implement `shift` too. But if you're willing to jump through some hoops, [they're all equivalent](http://okmij.org/ftp/continuations/index.html#impromptu-shift) and Turing-complete [[1]](http://okmij.org/ftp/continuations/index.html#cupto-nontermination) [[2]](http://okmij.org/ftp/continuations/index.html#typed-control-fix) The \`\`tagged'' counterparts I was speaking of in my original comment also take a tag to mark up to which prompt you want to delimit and capture the continuation: E[(prompt-at TAG G[(control0-at TAG k expr ...)])] =&gt; E[(let ((k (lambda (x) G[x]))) expr ...)] E[(prompt-at TAG G[(shift0-at TAG k expr ...)])] =&gt; E[(let ((k (lambda (x) (prompt-at TAG G[x])))) expr ...)] E[(prompt-at TAG G[(control-at TAG k expr ...)])] =&gt; E[(let ((k (lambda (x) G[x]))) (prompt-at TAG expr ...)] E[(prompt-at TAG G[(shift-at TAG k expr ...)])] =&gt; E[(let ((k (lambda (x) (prompt-at TAG G[x])))) (prompt-at TAG expr ...)] Example: (+ 1 (prompt-at 'here (+ 2 (prompt-at 'there (+ 3 (control-at 'here k (k (k 4)))))))) ; same as (let ((k (lambda (x) (+ 2 (prompt-at 'there (+ 3 x)))))) (prompt-at 'here ; reinstantiated by control-at (+ 1 (k (k 4))))) They're good because you don't want the prompt introduced by a generator to clash with those used to implement exceptions, or even between two generators, for example. So you want something to identify specific types of prompts. More references and useful links: * [Why undelimited continuations are BAAAAAD](http://okmij.org/ftp/continuations/undelimited.html#introduction) * [Part 2](http://okmij.org/ftp/continuations/undelimited.html#delim-vs-undelim) * Undelimited continuations alone can't implement exceptions [[PDF]](http://www.cs.bham.ac.uk/~hxt/research/exncontjournal.pdf) * My favorite dissertation on how to implement tagged delconts [[PDF]](http://www.cs.indiana.edu/~dyb/pubs/monadicDC.pdf), it all became clear for me after I understood their CPS implementation. Don't be scared about the monad part, it's at the end and completely optional (Haskell implementation) * [How can delimited continuations be used in OSes](http://okmij.org/ftp/continuations/zipper.html#context-OS) * A possible intuition on shift vs control [[PDF]](http://www.ii.uni.wroc.pl/~dabi/publications/IPL05/biernacki-al-ipl05.pdf) (tl;dr: nested recursive shift = depth-first, nested recursive control = breadth-first) I hope this will be helpful for you!
Thanks! So... I've read this twice already and I figure I'll have to read it a few more times, following the links. You, sir, gave me a lot of bed-time reading material. Thanks a lot! :)
oh, this is a good point. i didn't actually think of that because a lot of other compilers/whatnot don't make you mess with that... chicken is sounding pretty darn good. we'll probably release our code as open source assuming we actually make an engine, but we'd like to be able to actually sell games...GPL-ing your libraries seems like a poor decision if you're trying to get your language adopted. thanks!
&gt; can you extend the language with C like you can in haskell/python etc. Not quite. You can do it better. (bind* " int foo(int i) {return i + 1;} ") (foo 1) &gt; 2
wait...what...you can write c inline......that's...absolutely magical.
Join ussssss
* only works for compiled code. Chicken compiles to C and that's the reason why this can be done that easily.
I don't have any experience with either of them. If I recall correctly one of the motivations for chibi was to offer a proper scheme for similar use cases as tinyScheme. The author of chibi is also involved in the current scheme report process (r7rs). Chibi seems young but if everything works out it should have a longer lifetime. [s7](https://ccrma.stanford.edu/software/snd/snd/s7.html) might also be of your interest
I can't speak on tiny scheme, but I've embedded chibi and found it very easy. It was my first time embedding a scripting language into a c program and found it straight forward. I have also used guile but found it a little more involved to embed. Ive done all this on linux, so I can't comment on windows.
Thanks for the s7 link - just started reading the code and it is a very interesting / well commented read!
Thanks for the kindly comment about s7! I think the size of the C file should not matter in any reasonably modern C compiler. s7 runs in uclinux on the blackfin processor, so it needs very little runtime memory, I believe. s7's main goal is to easily integrate with C code, so if it isn't, I'd like to hear about it! I haven't done any timings, but I think s7 is as fast as Guile. 
I love reddit - you come across an impressive piece of software like s7 and the author is reading the same sub-reddit as you :) I will definitely keep you posted - the more I look at the code / documentation / etc., the more I like it. I have a feeling I'll be trying it out on my project, so hopefully I'll start to get a better feel for the "ease of use" factor soon. One question for you - is this also released under BSD (like TinyScheme)?
I actually use Gambit, but I didn't think / realize it would be good for embedding. It seems to require quite a large runtime if I'm not mistaken. I had similar impressions of Chicken, although I've done less work on that front. Thanks for the suggestion!
I've been using GPL for years (s7 is part of several other projects that are under GPL), but I don't actually care. For awhile I used the artistic license because I liked the name. If BSD or MIT are preferable, I'd happily change. I think I started using GPL because Debian was unhappy with the artistic license -- it was years ago and I may have everything backwards.
Ah, I see - well, I'd be looking for something like BSD / MIT / Apache, so if you don't care BSD would be great :) But either way, since s7 is a standalone project (er, at least, it could be) I would suggest making whatever license you choose explicit ... I didn't notice anything in the download nor on the landing page. Not knowing that it was part of the larger project, I had no idea (and I would suspect many others wouldn't either). Thanks again!
Ah, didn't realize. That's not nearly as bad. 
Why would you need to drop any copyright on generated code? that's not the case even with GPL compilers. You're not shipping the compiler itself, you're shipping compiled code.
Actually, you are shipping the compiler itself. Most Scheme implementations embed themselves in order to provide the full suite of scheme functionality. For instance, [eval](http://docs.racket-lang.org/guide/eval.html).
Even GCC, the main compiler from the GNU project, makes an exception for runtime libraries: http://www.gnu.org/licenses/gcc-exception If licensing is a real issue with major Scheme implementations I hope they rethink this. I guess it's best to run your own :P
The way of understanding `call/cc` that helped me the most was to this progression: 1. Study the difference between direct style and [continuation passing style](http://en.wikipedia.org/wiki/Continuation-passing_style) (CPS) code. 2. Learn about how code in direct style can be mechanically translated into CPS. You don't need to memorize it, just get the gist of it, and try a few exercises unrigorously by hand to test your understanding. Once you feel like you grasp those concepts, then you have a (relatively) simple mental model for `call/cc`: you just picture that every direct-style program you write is implicitly translated into CPS by the language implementation, and that `call/cc` is just a primitive that gives you access to the continuation procedures that the CPS-transformation generates from your program.
That's true in my experience too. The last boring bits, where you make things pretty/work more smoothly, are not always fun to work on. Especially if, as you implied, someone needs to spend a fair amount of time coming up to speed on the codebase in order to even find out if they can add the features they want.
MIT Scheme is now [MIT/GNU Scheme](http://www.gnu.org/software/mit-scheme/), last updated [November 2011](http://ftp.gnu.org/gnu/mit-scheme/stable.pkg/9.1.1/changelog.txt).
Hmm... What would be a first step, you think, to get DrRacket to be more Emacs-y?
Thanks for sharing those links. The second one looks especially interesting. Looks like I've got some reading to do.
... Why use an *almost* Emacs when you can use real Emacs? :) Most serious programmers are pretty attached to their text editor. An entire programming language community is highly unlikely to rally around a language specific editor since the sort of people who care about programming languages are the sort of people likely to have advanced text editing skills and preferred tools for doing so. Learning one powerful text editor well is a very large investment. Something has to be *really*, **really** powerful (e.g. so amazing its revolutionary) to justify tossing out years of accumulated text editing habits/knowledge. For an Emacs person, it's probably less work to implement whatever debugging and other features are nice in Emacs than switch to an entirely new environment when you're working on Scheme code. As you say, a massive active user base has significant advantages. Emacs has that enormously, and has for decades. Edwin does not really have that at all. I don't mean to come off as an Emacs snob, feel free to take on Edwin if you like, but you asked why this didn't happen. I'd say this is a large part of it.
Emacs recently added lexical scoping, at least. It's a step forward :)
i'd forgotten that motif was even a thing.
The webm versions can also be found on the author's ftp server: ftp://ftp.sacrideo.us/vids/scheme_gui_demo/
Thanks a lot! It works perfectly!
[Chicken Scheme](http://www.call-cc.org/) is really fun and easy to use, it's almost like the Python of the Lisp world. If you have trouble setting it up, read [Chicken Scheme Caveats](http://www.yellosoft.us/chicken-scheme-caveats).
What do you mean by 'representation of the web?' Can you provide an example of that? I would surmise you mean: '((1 ("tokenized" "document" "text")) (2 ("second" "document" "text"))) But I'm not certain.
Here is a hint. It takes the index and returns a normalized list of (word page) pairs. Is that useful toward helping you solve your problem? There are two 'tricks' in this code. the so-called 'apply append trick' and currying. If those are new ideas to you it may make it hard to understand what this code is doing and you'll need to read about them. ;; the input data ;; (define www '((1 ("the" "cat" "sat" "on" "the" "mat")) (2 ("the" "dog" "stood" "on" "the" "mat")) (3 ("the" "cat" "stood" "while" "a" "dog" "sat")))) ;; the top-level routine ;; (define (build-index www) (apply append (map-apply map-pages www))) ;; map over ever page in the index ;; (define (map-pages page words) (map (curry map-words page) words)) ;; map over every word in the page ;; (define (map-words page word) `(,word ,page)) ;; helper routine: see currying on wikipedia ;; (define (curry f . a) (lambda x (apply f (append a x)))) ;; helper routine: like map, but apply each ;; element to the function rather than passing ;; each element to the function. ;; (define-syntax map-apply (syntax-rules () ((_ f l) (map (lambda (x) (apply f x)) l)))) ;; execute the program ;; (write (build-index www)) (newline) (exit) Running this produces the following. Note that a word appears in the list as many times as it appears in the document, so this isn't the answer you're looking for, there is still work to do: (("the" 1) ("cat" 1) ("sat" 1) ("on" 1) ("the" 1) ("mat" 1) ("the" 2) ("dog" 2) ("stood" 2) ("on" 2) ("the" 2) ("mat" 2) ("the" 3) ("cat" 3) ("stood" 3) ("while" 3) ("a" 3) ("dog" 3) ("sat" 3))
How would you write this procedure is a language you already know? If this is your first programming class ever: write instructions in english for a person to execute. Have a solution in mind before you try to express the solution in a language you aren't yet familiar with. ps - post your solution here and then we can help with specific scheme questions.
That's a hell of a release. Awesome.
I'm about to port one of my programs to the web. I'm on Chicken Scheme so I'm going to use awful as my web framework. I expect I'm going to have trouble that I wouldn't have using something like Python/django. The appeal for me is the same language on my command-line as I get on the web. I'm also happy to see spock, a Scheme =&gt; javascript compiler. I have no idea whether I'll be able to use it, but part of my own porting to the web needs to involve javascript, and it would also help there to have the same language. Scheme for web programming is definitely a frontier and you're going to be slower coding and have fewer features available to you. Often you'll be working at cross-purposes: dealing with an organic not terribly well planned/thought out software stack with a language whose power often as not comes from shared metaphors at varying levels of abstraction. The promise for me in trying it though is that the web allows much better modularization of code: you plop down your Scheme code on a server somewhere and the whole world can use it without caring that it's in Scheme. To me that's worth the struggle of creating and using a Scheme-based web platform. Never have I been so close to being able to use a language like this for real/professional work.
How much does it cost monthly to deploy it?
I don't know. I believe there are some database libraries, but I haven't used them. You should try emailing guile-users@gnu.org, or perhaps whoever runs ellyps.net. The site advertises mysql, so there must be some way to do it.
Scheme as a web language has intrigued me for a few years. HTML is a hierarchical list structure that maps naturally to Scheme constructs, and makes Scheme undeniably appealing for the task. Of course, exploiting Scheme's capabilities isn't that easy. There are a number of approaches, as already noted, that are worth exploring. My own efforts are available at http://webserv.bmedctr.com. It's a Scheme-embedded-in-C compiled server written with Chicken Scheme. As development code, it has warts, but has been on-line for a quite a while. Since I have it running on my own server, I've not had to worry about hosting, but that is an important concern I've not yet looked into. It would probably require some kind of co-location service, but I really don't know. Virtualization might provide options--it's a subject I need to learn more about. Trustworthiness of libraries, and security in general are huge issues. No way I can prove it, but in terms of reliability, my impression is that Scheme compilers and compatible libraries I've used are no worse, and possibly better than average among widely used languages and libraries. Considering the direction of Internet developments, "clouds" and all, there may be opportunities to expand Scheme's use for web programming, which I'd regard as favorable progress toward simpler, more robust and secure web services. It's a new and unsettled world, and I won't even try to make predictions.
Get Slime for Emacs, like you would get it for Lisp. Once it is installed and setup, get ckicken-slime via chicken-install. Later in Emacs: M-x chicken-slime.
NearlyFreeSpeech has CGI support for: * MIT Scheme Release 7.7.1 * Guile 1.8.6 * Chicken Version 4.6.0 * MzScheme v370 [3m], Copyright (c) 2004-2007 PLT Scheme Inc.
The closest thing I can think of is [fluxus](http://www.pawfal.org/fluxus/)
[Build Your Own Block](http://byob.berkeley.edu/) is a visual Scheme designed to teach programming in grade school.
Not Scheme, but [OpenMusic](http://repmus.ircam.fr/openmusic/home) is a bit like that. (Based on CommonLisp.)
I am after something with more of a wiring/patching dataflow type feel, can BYOB do that?
Looks like you might have to invent it :)
[prgmr.com](http://prgmr.com/xen) offers VPS plans from $5/month, though you'd probably want to go up to the $6 or $8 plan to have a a bit more memory. That's assuming a trivial amount of traffic.
*before looking at the code* Scheme has mutable data .. look at the `set!` and `set-car!` procedures.
What is the command you use that returns `,'(1 ,4 ,7)` instead of what you want? What do you expect instead?
Are you just having trouble understanding the list notation? As you point out in your "edit" note, commas are not separators, but you're still using them that way in the code that you have posted here. A comma is used to evaluate a subexpression inside a quasiquoted expression. Quasiquotng is like quoting but lets one choose to evaluate elements of the expression. For example, the following comparisons are all true: (define c 100) (equal? (sqrt c) 10) (equal? '(sqrt c) '(sqrt c)) #;short-hand (equal? (quote (sqrt c)) (quote (sqrt c))) #;long-hand (equal? `(sqrt ,c) '(sqrt 100)) #;short-hand (equal? (quasiquote (sqrt (unquote c))) (quote (sqrt 100))) #;long-hand
None of those would produce `'(1 4 7)` when passed to an arbitrary output. But I think you know that. It is, however, useful to narrow down what's going on, so you can understand it. You'll understand more of the program if you narrow down your inputs from "something like \_\_\_\_" to "this function call produces the problem: \_\_\_\_" to "this piece of data is the problem: \_\_\_\_". It's harder, but you don't grow by only doing easy things. Let's take your first example: `(0 "(m/n)^2=2) with m/n being in lowest form." '(nil))`. How many elements are in `'((0 "(m/n)^2=2) with m/n being in lowest form." '(nil)))`. (n.b. why did I have an opening quote in that line, even though you didn't include one?). Once you know what the elements are, what are they? Literally write them out. Now that you've done that, what would *you expect* `(last '(0 "(m/n)^2=2) with m/n being in lowest form." '(nil)))` to be? Don't evaluate it yet! First think! Then think again! Then, once you've convinced yourself, go ahead and copy that code into the repl.
Racket cons cells are immutable and there is no `set-car!` or `set-cdr!`. However, there is a mutable version created by `mcons`, with associated `set-mcar!` and `set-mcdr!`. 
I see that you've updated the code since I wrote and have skimmed over your conversation with zck, but I'm not sure that I understand what your question is anymore. You mention that the program might be mistaking a list for a string, but `'(1)` is a quoted list and not a string. In fact, it's a short-hand for `(quote (1))`. Is that what confuses you? Can you be more precise about what's going wrong? 
You're very close. Consider what your function should be evaluating to. Is it returning a solution (a list of `a` and `b`) or a list of solutions (a list of lists of `a` and `b`)? Think about this both when you return a value, to make sure you return the right thing -- especially in the second `cond` condition -- and when you *use* the return value, that you consider what you're handling -- the third `cond` condition. For style nitpicking on my part, and you can ignore me here, you use both `null` and `'()` in the same program. That feels slightly inconsistent to me. :-) 
just out of curiosity, have you already written a working solution?
thanks :) I've also replaced '() with null. And I think I know where I went wrong, but I really need to think this through.
ok, are you using `append` or something else? I recognize that I'm not able to return a list of lists, because a lot of empty lists get added in each level of recursion. And I'm not sure how to deal with it. current version: https://gist.github.com/3844987
Spell it out for me. Let's say that a "line" is a list of '(int string list). `proof` is *already* a list of lines, and you want to go from that to __. Right now, `context` returns (list (void)), but I don't know how to fill in the blank. 
I'm afraid that you lost me. `context` is working correctly, but it isn't? Maybe you don't want to `display` the results but want to return a list of "becauses". If so, the function type would be something like `(line ...) -&gt; (because-list ...)`, and the following expression would be true, is that right? (equal? (context proof) '('(empty) '(1) '(2) '(3) '(4) '(5 2) '(1 4 7) '(8 1) '(empty) '(9 10))) 
Thanks, a lot.
You can get around this by forcing exact approximations to be used: &gt; (define sqrt-5 (inexact-&gt;exact (sqrt 5))) &gt; (define golden-ratio (/ (+ 1 sqrt-5) 2)) &gt; (define (fib n) (round (/ (expt golden-ratio n) sqrt-5))) .. note that while the final result is an exact integer, its accuracy is limited by the precision of the initial approximation of `sqrt-5`.
See my self-reply - there are ways around it. The trick is to note that you can make Scheme compute with bignums as long as you make them exact (ie rationals). You need to beware though that `(sqrt 5)` is not a rational so you will need to deal with an approximation, and can not take more significant figures from your result than the initial approximation holds. You could of course make your approximation a lot better than `(inexact-&gt;exact (sqrt 5)))` (which is bounded by the underlying flonum format) by computing `sqrt` using something like Newton's method until you get the quality you need ... how to determine just what that quality is though, is beyond me. Maybe someone else can chime in, or we can cross-port to /r/math :-).
Not yet. There too few changes to justify a new revision of the book.
Is it possible to disable all the unix stuff and compile it on Windows systems? (I see _MSC_VER in s9.h, but no MinGW target on the Makefile) edit: By the way, nice robust garbage collector. It must be the first small scheme implementation I find where the gc doesn't break after playing with it for 5 minutes.
&gt; A what_is_new document would be nice ;). There is [CHANGES](http://t3x.org/s9fes/CHANGES.html), but it is rather fine-grained. The basic S9 without the Unix and Curses extensions should still compile on Windows.
You are breaking the printer and not the garbage collector! When (define foo (stress-gc-mark 999999)) returns, the test is already completed and the tree being constructed is bound to foo. That being said, crashing while trying to print that tree is definitely a bug, too! Edit: grammar.
You can change the font size on most web pages, including my blog, by pressing CTRL + or CTRL - in your browser. Read Dijkstra's paper for help with the algorithm.
I just ran the gc test on mit-scheme 9.1.1 and no problem. Printing the resulting list gets a 'maximum recursion depth exceeded' but no crash.
A fix is in the queue and will be committed in the next days.
Yes, Dijkstra's functions are just reductions of the matrix technique that I used in my blog exercise. But his explanation is still worth reading.
I would also like to point out, in addition to SICP, the open courseware from MIT for the associated course. There is a huge pile of material there that is free to everyone including lecture notes, videos, a Scheme interpreter and more. More than you will ever need to learn Scheme. [MIT CourseWare](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/index.htm)
I learned Scheme by first learning what became Common Lisp. Eventually I read SICP and then much later came upon The Little Schemer. SICP is not particularly easy and it seems like most people rarely finish it and its myriad exercises on the first attempt. It's probably fair to say that most people don't finish it at all, and those who do go on to write their own Scheme interpreters. I'm only slightly joking. In contrast, The Little Schemer is a delightfully simple and strange little tale that very effectively teaches recursion, higher-order functions, and function composition. By all means work through the SICP lectures if you're up to it, but don't miss out on the Little Schemer. It's well worth the $24 on Amazon. And there's no better time for you to read it than now. I should note that neither really teaches you Scheme, the language. Neither will teach you how to read/write files, use the network, or write a Twitter client in Scheme. They're both aimed at teaching you the philosophy behind the curtain if you will. OTOH, since you're lucky enough to be taking a course that's using Scheme, I have no doubt that both cover what they're wanting you to learn.
Which school is this?
&gt; I noticed that there weren't many resources for scheme You haven't looked that hard then. In addition to SICP, there are 2 other free MIT published scheme books, and tons of stuff available online, including the manuals and other beginner stuff at the websites of many different Scheme implementations.
Is the problem the language itself, or the different way of thinking about programming? I found [Simply Scheme](http://www.cs.berkeley.edu/~bh/ss-toc2.html) and [The Scheme Programming Language](http://www.scheme.com/tspl3/) to be helpful. [This](http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html) was handy as a reference when writing programs.
Read the [R4RS](http://people.csail.mit.edu/jaffer/r4rs_toc.html). Try it! It's quite comprehensible!
Start from the The Little Schemer.
I have updated my mirror with the latest tarball version. I will watch this place for updates. Thanks!
Sorry, this was caught in the spam bin. I just retrieved it.
IU 
I was thrown in project and start fixing the bugs and develop new features. No books gives you more knowledge than reallife experience.
ok
This doesn't have anything to do with Scheme, instead it is support material for learning French as a foreign language.
Removed. Remember to use the "report" button!
I actually didn't know that vectors were static in size. As for just using recursive you could probably accomplish the same by just cutting the first element off of the vector(Assuming that vectors weren't static size, which apparently the are.) As for learning, I'm more or less just picking up as I go :)
Nope, haven't read any scheme books. I'm a bit familiar with some of the basics of functional programming, done small customizations for emacs for my lisp experience. I'll take a look at those, thanks.
I haven't messed with elisp at all, but from what I understand it's mostly dynamically scoped so yuck. You might need to un-learn some things :-).
If I remember correctly it's dynamically scoped by default, though it support lexical as well now. I haven't really done any major programming in it to get used to the different stuff, just smaller add-ons like new players for emms, new keybindings, etc.
Ah, got it. The keeping things functional angle never hit me(Or maybe I just thought that copying vectors would be really cheap.)
That was work as well, I think at that time I was on "I can exactly mimic everything a list can do with an array."
Yes i need to make a list of answers. And the termination is when the countdown reaches 1, because 0 does not count, and obviously negative numbers dont have squares.. so yea, 1. But i also needed to make a base case for when the number is 0, because scheme will say that (integer? (sqrt 0)) ---&gt; true
You don't need to apologize; you're learning. And that's just fine. To format code on Reddit (or to put any code into monospace, with no added line breaks), prefix it with four spaces. Ok, are you confident that this function works? Did you try it with some values, and see what you get? If you think it's good, it's time to take the next step. Don't worry about writing code just yet; just answer my question in words. Tell me the steps I would take, if I were using pencil and paper, to make a list of numbers between `n` and `1` inclusive that are square. Given that you've already given me a function to test whether a number is square, you don't need to explain that. You can say things like "if the number is square, take this step. If it's not, do this other thing". Once you can explain the basic algorithm, then you can try to translate it to code.
It doesn't really matter that (integer? (sqrt 0)) -&gt; #t, you're done when you get to 0. So (zero? n) is a perfectly good way to check if you're done. Let me remind you what you said in the OP: &gt; So for examples, if the function consumed 10, it would give (cons 9 (cons 4 (cons 1 empty))) So what does the end of the list look like? Hint: which portion of the recursion is responsible for the (cons 1 empty)?
Understood, but Edwin is pretty awesome. I've recently switched full-time from GNU Emacs and am loving it.
Small problem: (shortest-way 23) should give (a a a a a b), not (a a a a a).
I'm not sure why you think (a a a a a) is the incorrect solution. (a a a a a) does kill the monster and its shorter than (a a a a a b).
First, I don't see what CPS has to do with anything. Chicken certainly CPSs code, but it would have to on LLVM as well. Also, I think trying to measure how much work a compiler does for a high-level language in subjective terms is a terrible idea -- does a nanopass compiler do "more work"? Second, LLVM is notably *less* portable than C -- C is ported to just about every system on earth. Third, obviously your own personal level of infuriation is something the rest of us don't have access to, and thus we'll have to trust your self-reports. However, personal infuriation is not a great guide in the presence of actual numbers. Fourth, if your unhappiness with Racket is about *compile* or *load* time, then that's obviously a whole separate kettle of fish, and irrelevant to running web servers. After all, C++ compile times are nothing if not infuriating, and yet Google runs pretty fast. Fifth, as a pointed out in my original post on this thread, lots of people use Ruby for web development on high-performance web sites, a system which is by any standard much slower than any decently-implemented Lisp system, so raw performance is far from the only criterion to be used in choosing a back-end language. Fortunately, I happen to think Racket does pretty well in other areas, too.
It would seem there are three of us here.
Playing with new ideas. Syntax is a solved problem since a long time, all new ideas deals with semantics, be it new control constructs, non-deterministic algorithms, partial evaluation, library management, concurrency, or whatever. Scheme allows you to play with your ideas without having to wrestle with existing syntax or having to invent new syntax. Also, it is a very abstract language that gives you powerful tools for prototyping (homomorphism of data and programs, syntactic abstraction, continuations). 
I haven't used Scheme in a while, but I'm pretty sure (cons 'a (cons 'b empty)) is the same as (list 'a 'b).
Is your school using a variation of the language? Like 'beginning student'? Try going to the language and switching it.
 (define (perfect-squares-upto n) (map (lambda (x) (expt (1+ x) 2)) (reverse (iota (inexact-&gt;exact (floor (sqrt n)))))))
http://rachid.koucha.free.fr/tech_corner/pty_pdip.html is a decent tutorial. You just need a scheme that supports posix system calls.
uuuu nice I'll look into it. 
 * You could use fork(), pipe() and dup2() to make shared anonymous pipes between two processes. You would either need a man-in-the-middle program which launches both processes, or make one of your processes spawn the other with fork(). * You could use a [named pipe](http://en.wikipedia.org/wiki/Named_pipe). Named pipes can be read and written as a file, but it is in fact a special file, representing a pipe handle inside the kernel, not storage on a disk. * You could use the POSIX IPC interface, but in my opinion it's rarely required, and it's more complex than it needs to be. * You could use a TCP network socket, but if you use sockets over pipes, then a local Unix socket is better than TCP anyway. Not all of these are portable. Windows doesn't support POSIX, but it does have its own version of anonymous and named pipes, as well as Winsock 2. If code portability is important, maybe go with TCP internet sockets or files.
You don't mention what implementation you're using, and this level of IO certainly isn't specified by R5RS so that's fairly important. Others will hopefully suggest some implementation-specific methods, but honestly I'd do it in Tcl: it might not look it but [the language can be a bit Schemely](http://wiki.tcl.tk/22049) and it handles this sort of thing very well. The following code should work under ActiveTcl on all common platforms: #!/usr/bin/tclsh set fd1 [open "|chat foo bar baz qux" r+] set fd2 [open "|chat \"\" foo bar baz qux" r+] fconfigure $fd1 -buffering none -blocking 0 fconfigure $fd2 -buffering none -blocking 0 fileevent $fd1 readable [list relay $fd1 $fd2] fileevent $fd2 readable [list relay $fd2 $fd1] proc relay {in out} { set data [read $in] puts "$in&gt; $data" puts -nonewline $out $data if {[eof $in]} { puts stderr "EOF on $in" exit } } vwait forever 
you sure? might be based on implementation but I don't think that there's a guarantee that it'd all be contiguous like a C array
I was recommended to do some type of network socket programming by a friend, but I'm not exactly familiar with it. I think portability is most important for me, so it might be best to go with it. Anyway, do you know of any good tutorials/references on how to get started? 
You could try reading the sockets section of your scheme's documentation.
The most popular online resource I know of is [Beej's guide to network programming.](http://beej.us/guide/bgnet/) It's Linux/BSD oriented, but it serves as a great starting point. For actual production and for portability's sake, I recommend using [Boost Asio](http://www.boost.org/doc/libs/1_52_0/doc/html/boost_asio/overview/rationale.html) instead of POSIX sockets and Winsock 2.2. If you need to learn the Windows WinSock 2.2 API (For C and C++) I highly recommend this book: [Network Programming for Microsoft Windows - Second edition](http://www.amazon.com/Network-Programming-Microsoft-Windows-Edition/dp/0735615799). Don't let 2002 release date fool you. Everything it covers is still up-to-date, and it also covers IPv6 as well as IPv4. If your Scheme implementation doesn't support sockets, either change implementation or make a simple wrapper with its FFI.
How do you think it would be implemented - as a linked list? I don't see any other sane way to implement it, other than using a single array...
certainly possible. The point isn't which implementation implements how, but that it's generally a bad idea to assume that unspecified behavior will be universally implemented in the same way. There are situations where it'd be flat out impossible to implement it as a flat array, like if you wrote a scheme in python, for example(I think python arrays are as linked lists.)
I wonder how hard is to adapt this for chicken?
Alright, let's have a look at your code. I took the liberty to format it a little and replace that funny '?' character with 'lambda'. (define collect-similar Characters are *equal* (eqv?) to each other, not *similar*, so you might want to pick a better name. (lambda (xs) (if (null? xs) '() (let ((sortedxs (sort char&lt;? xs))) (collect-similar-helper 1 (car sortedxs) (cdr sortedxs)))))) Naming a function something-*helper*, IMO, is a dead-sure sign that the author did not know what he was doing. Every function has an exact purpose, and its name should reflect that purpose. So what *does* 'collect-similar-helper' do? (define collect-similar-helper (lambda (count x xs) (cond ((null? xs) (list (list x count))) When 'xs' is empty, it generates a count for 'x'. ((equal? x (car xs)) (collect-similar-helper (+ 1 count) x (cdr xs))) While 'x' is equal to the car of 'xs', it collects elements from 'xs' and counts them. (else (cons (list x count) (collect-similar-helper 1 (car xs) (cdr xs))))))) Otherwise, it continues with the next element. So this is (almost) what 'count-similar' is supposed to do, modulo sorting and checking for empty input. Let's clean this up a bit. Get rid of the helper and move the sorting and checking for the empty list to the main function. I'm using a named LET here to iterate over the input, but that's just a personal preference: (define (collect-similar xs) (let loop ((count 1) (xs (sort char&lt;? xs))) (cond ((null? xs) '()) ((null? (cdr xs)) (list (list (car xs) count))) ((equal? (car xs) (cadr xs)) (loop (+ 1 count) (cdr xs))) (else (cons (list (car xs) count) (loop 1 (cdr xs))))))) Alright, we could now eliminate linear recursion at the end of the function, which I suspect to be the greatest performance killer in your implementation: (define (collect-similar xs) (let loop ((count 1) (xs (sort char&lt;? xs)) (result '())) (cond ((null? xs) (reverse result)) ((null? (cdr xs)) (reverse (cons (list (list (car xs) count)) result))) ((equal? (car xs) (cadr xs)) (loop (+ 1 count) (cdr xs) result)) (else (loop 1 (cdr xs) (cons (list (car xs) count) result)))))) But you wanted to get rid of sorting. Is there any reason why the input needs to be sorted, other than your approach to counting? Basically you want to create a mapping of a (typically small) set of values ('characters') to a potentially larger set of values ('counts'). So what I would do is to set up a vector of the size of your small set and use its slots to reflect the larger values. Set all vector slots to zero, and then use the character code points (char-&gt;integer) to increment the values in the vector. When dealing with a larger character set, use a hash table instead of a vector. I'm not going to implement this here, though, just in case it should be homework. In that case, I have already spoiled too much of the fun anyway. BTW, that tiny input box sucks. I hope, the formatting is OK. Edit: I get it, the backquote has some special meaning. *Sigh*. Sorry, if I overlooked some of them.
What does "user land free software distribution" mean?
It's software that runs in userspace, i.e. not a kernel or other system stuff. Also you can install it as user and don't need to be root.
Sorry, I just pulled this out of the spamfilter -- I don't know how it got past me.
Oh I didn't know that. How nice ! Thanks mate 
Off the top of my head I believe (but could be mistaken) that gauche, guile, plt, and bigloo use the bdw gc. Certainly not *most schemes* as dig1 suggests but there are a few around. As you say many others tend to favor generational collectors (scheme48, chicken) or hybrid strategies (gambit) where the pause times are generally slim. 
Thank you for explaining my reply :) Also bdw powered: SigScheme, Mosh, STklos, Chibi (alternative, but more robust), Sagittarius... It would be interesting to make scheme implementations chart of GC usage; I'm getting feeling how generational GC's are not choice of most scheme systems... and I can be wrong, of course :D
You can use [diffpdf](http://www.qtrac.eu/diffpdf.html) to view them beside each other with difference highlighted. It is included in Debian. edit: There is a proper one made from the LaTeX source for draft 5 [here](http://trac.sacrideo.us/wg/attachment/wiki/WikiStart/r7rs-draft-5-diff.pdf), it would be nice if there was one of these for every version, but I'm not sure who generated it or how to do so myself (is the source public?)
from 2009, but an interesting read.
It is surprising that it is still in draft form.
* The proposal for `module` discussed on that post does not have a single word on controlling which identifiers are exported from a module and which are kept private. What's the point of having a module system otherwise? Or put alternatively, this isn't a module system proposal, this is an `#include` proposal (and the blog entry says as much). * There's not a word on how to extend the language to allow programmers to define new record types disjoint from all of the built-in types. The lack of these two is the biggest glaring flaw of R5RS Scheme. And yes, I call the lack of these two one flaw, because these two features are highly synergistic: if I have the ability to define my own types in a module, together with the ability to control what procedures are exported for my types, then I have the ability to define opaque types that can only be operated on through the procedures that I expose. Without that we are reduced to representing all data as concretely with the native types, which means that callers can couple themselves to implementation details of our code that they really shouldn't.
In what way is it surprising?
Ah-hah! Things have moved on a bit since I wrote that :-) R7RS WG1 scheme (the "core language") has modules and disjoint record types. Ta-da! The latest draft is out (and may be the final draft) - take a look at http://trac.sacrideo.us/wg/raw-attachment/wiki/WikiStart/r7rs-draft-8.pdf ; more general information about the ballots that led to the current state of affairs can be found by reading the surrounding wiki at http://trac.sacrideo.us/wg and the tickets. Enjoy!
Ah, I remember back to maybe draft 6, it was said that to be the last draft. Perhaps I mistake it.
This is really cool! We need more and better editors for livecoding scheme. 
From a cursory glance, it seems to be an interpreter. It does come with a ton of libraries and utilities (many SRFIs, networking, swing bindings, turtle graphics, and even a tic tac toe), most of which are surprisingly written in Java instead of Scheme. The bad news: it's excruciatingly slow. I don't mean: slower than Kawa (which wouldn't be surprising, Kawa is compiled), I mean: about 80 times slower than [Sisc](http://sisc-scheme.org/). 
Thank you! There is an overview of the curses functions at the end of the [curses.c](http://www.t3x.org/s9fes/curses.c.html) file. I think it is sufficient to write games. Please let us know when your game is ready for the public!
&lt;Home&gt; and &lt;End&gt; should work fine. Maybe your termcap entry does not define them? Or do they work in other terminal-based programs?
`number-&gt;string`?
Wow. You're absolutely right. Thanks!
This is why I love Scheme. 
First of all, I think that diversity is good! Then, from my perspective Emacs is too large and too hard to learn. I tried a few times and newer managed to do anything useful with it (this can easily be a problem on my side, though). Also, again IMO, saying that X does not need to exist because Y exists is a road to uniformity and uniformity is the death of creativity. Finally, Emacs is not written in Scheme, and I don't like Emacs Lisp. Mostly, though: diversity is good! :-)
My **only** issues with Emacs for scheme is I can't get it to tab complete in the REPL and I can't eval functions and regions in source files. I really wish I could use slime (I love slime) for scheme, but I can never get it to work. If you could get something similar, then I would use scheme much more. Currently I use common lisp for everything, but scheme is superior (provided it has defmacro) for application distribution and for solving many problems. I just don't have time to figure out how to set up a emacs/scheme system. Slime/emacs/CL works fairly easily and that is very important to me in development. Well, that's not my only issue with Emacs. I think it should be able to edit any type of media. See my [Qix Project](http://www.youtube.com/watch?v=TV2kAcd5E20) for more details there. 
Do you use Chicken? If so, have you tried [this script](https://raw.github.com/dleslie/chicken-scheme.el/master/chicken-scheme.el)? It uses auto-complete and chicken-doc to provide tab-completion and syntax hilighting in all scheme-mode buffers, without using SLIME. If you have a REPL running then scheme-mode will allow you to eval statements and full buffers from any scheme-mode buffer, without using SLIME. C-x C-e Eval last S-expression C-x C-r Eval region C-c C-l Load file
I don't disagree! I just use Emacs and wish to continue improving it; but variety never hurt anyone.
Thanks! I'll have to try it this weekend. Also, is there a good tutorial/setup for slime-scheme. I could never get it working.
I've never gotten it working reliably, either. Regardless, #chicken on irc.freenode.net is full of helpful folks.
You are a scholar and a gentleman.
For even more implementations than listed on Wikipedia, see [here](http://community.schemewiki.org/?scheme-faq-standards).
From "opinionated" I was expecting an angry ramble. This was actually a very good read.
Quick answers, Scheme is very easy to learn. I suggest you look into SICP or little schemer and go from there. Fastness of scheme depends on the implementation, for example Chicken scheme compiles to C and is fast enough for most purposes. Well, there are no stupid questions but this gets close :) All scripting languages are programming languages but not all programming languages are scripting languages. This too depends on the implementation. The ones like Chicken target more general use and then there are some like Gauche which target scripting. What do you mean by languages power? Scheme has pretty solid language features so you won't be quite limited with it. For cons its bit "fragmented". Meaning that you need to pick a implementation to use and stick with it as a lot of features are implementation-dependant and there aren't a lot of libraries available. I'd recommend you start with Chicken Scheme, it is easy to get started with and it has lot of libraries for you to use.
Part of your confusion about the nature of Scheme is likely due to Scheme being a *family* of languages that all more or less follow the same standard. Scheme may be easier to pick up than Clojure if you don't have any experience with Java, but once you have experience with one, learning the other wouldn't be hard. You would of course have to unlearn some concepts in the process due to the similarity, but you'd already have the functional programming mindset in your toolbox.
Alright, thanks. That answer was really helpful. For now I think I'll just use some online tutorials, because I don't really want to spend money on getting a book (Plus I prefer reading on my computer), in case I don't like the book, or don't like Scheme.
SICP is available on-line for free: http://mitpress.mit.edu/sicp/full-text/book/book.html I, among many others think of it as one of the best books on computer science. You should look it up. It goes through the basics of programming concepts with scheme. Was pretty eye opening experience.
Yes.
Also, I seemed to have worded my third question oddly. What I meant, was "Is Scheme a compiled language".
&gt; For cons its bit "fragmented". Please stop re-iterating that "fragmentation" is a bad thing! I call it diversity and would argue that it is the greatest strength of the language. Strong standards kill creativity. It happened to Forth and it almost happened to Scheme, with R6RS. Strong standards are useful for people who do "real-world" development, but there also has to be a language for tinkering and playing around with new ideas. So far, Scheme has filled that niche with pride. Let's keep it that way!
There is no such thing as a "compiled language". There are languages and interpreters and compilers. To answer your question, there are plenty of Scheme compilers, e.g. Chicken, Gambit, Stalin, Chez, and many others.
Well I live here in the "real-world" and would like to use Scheme but it proves to be unpractical compared to alternatives. One implementation has some libraries which would be useful, another implementation has other libraries. This leaves me in a position to either port one of the library to my selected implementation or creating my own from scratch. 
&gt; Please stop re-iterating that "fragmentation" is a bad thing! It is a bad thing because it prevents people from writing useful libraries, because they instead write base implementations over and over and over. It prevents people from writing useful books because they write the same basic implementation manuals over and over and over. So in Python you get GUI libs, Scipy and Numpy, can interact with FB, Google app engine etc, while in the scheme world you get 1001 implementation of call/cc and syntax-case. Yay! &gt; Strong standards kill creativity. Weak standards kill portability and productivity. People spend more time and effort into implementing yet another scheme than writing stuff in scheme. I personally would love to be able to write more day-to-day stuff in Scheme. But I cant, because I would have to reinvent the wheel and first write all the libraries I just want to use and that already exist elsewhere. &gt; but there also has to be a language for tinkering and playing around with new ideas. Fair enough. But that a language is primarily useful for PL theoreticists should be emphasized, and the language not recommended to programming newbies so they can finally write more hygienic macros.
To expand, compilation or interpretation are ways to *implement* a language. Different implementations (of which Scheme has many) may offer a compiler, an interpreter, or both!
i think [how to design programs](http://htdp.org) is a better first book. i know mit quite famously used sicp for its freshman comp science course, but it took some really brilliant teachers to make that work; as a self-study guide i wouldn't recommend it to anyone who didn't already have a solid computer science background.
I've spent the last few months learning [Racket](http://racket-lang.org/) (a version of Scheme) through [*How To Design Programs*](http://www.ccs.neu.edu/home/matthias/HtDP2e/). Now I'm learning Clojure, and I have found that to be a good path. The nice thing about Racket is that you can quickly download and install DrRacket and have a simple, friendly, self-contained IDE.
I have enjoyed using Geiser, which works with Guile and Racket: http://www.nongnu.org/geiser/
I'm not sure what you mean. `lambda` forms are how you create procedures in Scheme. That and `(define (myfun arg ...) body ...)`, which is a shortcut ("syntactic sugar") for `(define myfun (lambda (arg ...) body ...))`. You can of course use `myfun` in place of an already-defined lambda expression (as in the below example), but I'm not sure if that has any relevance to your question. (map (lambda (x) (+ 1 x)) '(1 2 3)) is the same as: (define (inc x) (+ 1 x)) (map inc '(1 2 3)) is the same as: (define inc (lambda (x) (+ 1 x))) (map inc '(1 2 3)) You can also say either of the following, as equivalent: ((lambda (x) (+ 1 x)) 2) (inc 2) Whether or not you give a name to something with `define` (or `let`), is first of all a matter of convenience (are you going to use it more than once?) and then taste (does naming this term help make the code more readable?). I have no idea if any of this is helpful. Perhaps you can expand on your question ... and is Scheme your first language, or do you have prior programming experience? If so, what language?
Oleg seemed to [show](http://okmij.org/ftp/Scheme/lambda-derived.txt) that, with the R5 macro system, lambda can be defined in terms of the rest of the language, and needn't be treated as a part of the core language.^1 In that sense, the built-in lambda is never strictly necessary. ^1 I don't know that these results hold in R6. 
Huh. I'm looking to be persuaded, but I'm not certain I'm following you so far. At least according to 5.2 of R5RS, two forms of DEFINE are _equivalent_ _to_ corresponding LAMBDA forms, but I don't read it to say that the DEFINE forms are **necessarily** sugared versions of the LAMBDA forms. That is, its *possible* to implement scheme with DEFINE as an atomic form, and LAMBDA as sugar. And how they're defined would presumably be implementation-specific, so strictly speaking one needn't ever use LAMBDA. It could very well be DEFINE all the way down! I'm certain you're right, though, that in almost every implementation those DEFINE forms are transformed to LAMBDAs. But even considering, its not correct to say that DEFINE is simply sugar for LAMBDA, right? The (DEFINE &lt;variable&gt; &lt;expression&gt;) form just isn't sugar for any lambda expression, no matter how the other two forms are implemented. No? 
Oh god how Scheme needs a unified API for foreign function interfaces. That'd be enough, with what already exists out there, to build libraries that are host agnostic. Then we could work to unify Chicken and Racket's disparate collection of extensions and begin treating scheme implementations the same way we treat C compilers, rather than as distinct languages.
 (let count ((i 1)) (if (&lt;= i 100) (count (+ 1 i)))) (do ((i 1 (+ 1 i))) ((&gt; i 100))) (letrec ((count (lambda (i) (if (&lt;= i 100) (count (+ 1 i)))))) (count 1)) (letrec ((iota ; many Schemes already have this (lambda (x) (if (zero? x) '() (append (iota (- x 1)) (list x)))))) (for-each (lambda (i) i) (iota 100))) 
You should give the little schemer a read :) 
The standard way is to use a accumulator. You could have your recursive function take another argument which has a default value so the function can be called without a initializer. (define (sum-list lst [acc 0]) (cond [(empty? lst) acc] [else (sum-list (rest lst) (+ (first lst) acc))])) Now personally I think this is ugly because it could let the user of our function optionally give the initial value of acc for the duration of the recursive call. Better yet you hide the accumulator in a local function. (define (sum-list lst) (define (sum-list-helper lst acc) (cond [(empty? lst) acc] [else (sum-list (rest lst) (+ (first lst) acc))])) (sum-list-helper lst 0)) Also I would direct you to the book "htdp: how to design programs"
The main difference between lists, vectors as available in Scheme and trees is how long it takes to access or change elements. If n is the number of elements in the structure, access is O(n) for lists, O(1) for vectors, O(lg N) for trees. Also in general, vectors use the least RAM and trees the most. Practically speaking, they're all just containers so they're interchangeable up until you have a performance requirement. It's when your code needs to do certain things very fast or fit within a given memory profile as the size/number of collections grows that the tradeoffs become important. You could build the vector operations on top of cons cells with any data structure you can imagine and preserve the ADT, but performance would be very different than "native" vectors. The data structure you described is a [heap](http://xlinux.nist.gov/dads/HTML/heap.html), which is a name you'll probably remember from storing it in an array in school. In Scheme with only cons cells it's slightly unusual because you need two cons cells per internal node. Ordinary binary trees only need one, so the standard recursive algorithms are a bit easier to write.
Functional Vectors: https://github.com/ijp/fectors Purely Functional Data Structures: https://github.com/ijp/pfds
Also a so called named let is possible: (let loop ((counter 0)) ; .... (loop (add1 counter)))
Oh, yes -- it does presuppose the ability to make primitive arrays.
Hello, What you're doing is almost all stuff specific to Meep, and maybe not similar to Scheme in general, so you might be better off asking on the Meep list. However, I looked through your code. Do you have to define "Ez" anywhere before you use it? I saw that it appeared in a lot of "component" properties, but I didn't see any declaration of what "Ez" was.
Thanks for your reply. You're quite right that it's specific to Meep; I knew I was pushing my luck when I posted. I've since found the Meep mailing lists and I'll see if I can find a solution there. Thanks for looking, the Ez is a built-in value in Meep, which is a measurement of the electric field in the z-direction at any given point. It's the value represented in red and blue in the image I supplied. Effectively, no, it doesn't need to be defined because Meep defines it for me.
The prospect of a new SCSH based on this is enticing too! I did the slight hoop-jumping to build a fairly modern scsh on a snapshot of 1.9 and it works nicely, but an official release would be really awesome. 
Hi there, It's been a while since I used MEEP but I will return to it eventually. I'm more familiar with its cousin MPB which uses the same scripting language. But first of all, my question is why don't you use the C++ library or the Python interface of MEEP? You mention you have used Python in the past and the C++ is faster for sweeps, avoiding the functional paradigm, and you can use everything available for C++ from IDEs to debuggers. But anyways I see you have fallen in the common tarpit of the non-functional programmer (functional as in the programming paradigm), the "parentheses haystack". I know, I'm kind of one of those too. The list you begin to define on line 144 contains not one, but 4 elements. You only wish one, the gaussian source you are defining, the component, size and center properties are defined outside of the (make source) function and they are considered as other elements of the source aside from the source. When the GUILE interpreter gets to the closing parenthesis of the (make source) function it realizes that no component is defined, and as you can see on the documentation of MEEP there is no default value, so that prompts an error. Just change the closing parenthesis on line 152 after line 155 and I think you're good to go (and indent it for readability if you want to). I highly recommend you to suscribe to the mailing lists, there are a lot of people willing to help on those lists and the archive contains almost any doubt that may arise. Just for curiosness in what field are you working? What are you using MEEP for?
Well, as usual when starting to work with MEEP or MPB you can get confused with the scheme syntax. Here are three recommandations for you: 1) Use a text editor with parentheses coloring (kate works well for me with scheme syntax highlighting) and stick to reasonable indentation rules. 2) Go read online "Yet Another Scheme Tutorial" or "Teach Yourself Scheme In Fixnum Days" to better understand what you are doing. Scheme is really powerful once you get it. It is particularly true to describe complex structures. Hint: if you try to use a loop, you do it wrong, you should appy something to a list or use recursion. 3) Force guile (the scheme interpreter that runs behind meep) to give you more explicit error messages, with the context of the error and the stack of the call by adding this to your script: (turn-on-debugging) (This way you'll never see again cryptic errors like "wrong type to apply at position 1) Hope it helps (BTW: suscribe to meep-users)
Thanks for the recommendations; one of my colleagues saw my code and told me in no uncertain terms that the indentation is horrible. I'm working on it. :p I'll look into Kate and get into those texts you recommend, but most of all thank you for this: &gt;(turn-on-debugging) I haven't had a chance to try it out yet, but this sounds like exactly the sort of thing that will save me from tearing my hair out. Oh and I joined the meep mailing list eventually (unless you mean /r/meep-users, which tells me I broke Reddit...) Thanks again!
Thanks so much for explaining in words what's going on. I'll have a close-up look at that section. :)
http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-9.html#%_chap_1 Have fun.
Again, excellent implementation with another great release. Please guys, just add support for color schemes: white on black and black on white are not enough for such a serious environment.
&gt; Please guys, just add support for color schemes: white on black and black on white are not enough for such a serious environment. You're talking about colors in DrRacket right? There is already syntax highlighting with different colors built-in and if you click "Check Syntax", it will do more highlighting. You can also change these colors in the preferences. Did you mean something more than that? (also feel free to submit feature requests via the [mailing list](http://lists.racket-lang.org/users/))
Ubuntu has guile 2 package. I don't know the other distros.
The official mailing list is guile-user@gnu.org http://www.gnu.org/software/guile/community.html . 
Debian (testing) has Guile 1.6, 1.8 and 2.0 in the repositories. 
No guile 2 repositorie in Fedora. if all goes according to plan, guile-2.0 may hit Fedora 19 in about 6 months or so: http://lists.gnu.org/archive/html/guile-user/2013-02/msg00069.html
I was more referring to predefined color schemes, like zenburn and etc. with ability to export/import them.
Are you sure that you have your base-case correct? Beyond that, I'll give a standard HtDP hint: You're transforming or processing a recursive data structure (a list), so your program should follow the same structure. That means making a recursive call to your fn. What would that call look like? What can you do with the results of the call?
Are you following the Design Recipe? That is, do you have any test cases? What's your contract? Where's your purpose statement? You should try to follow the Design Recipe when you're starting off, even if you're eager to code the first thing that comes to mind.
Yea I do the design recipe, with test cases and everything, i'm just trying to figure out how to code it. I can't find a way to add the numbers every single time they come up, while keeping the rest of the list the same. 
First of all, if you can, speak with your prof and/or TA about stuff like this before coming to reddit. They'll tell you precisely as much as they think is appropriate (whereas we will always err on the side of caution, since we don't want you to cheat), and it'll help you build a rapport with them - which is always good! Now then, I want to make sure I understand you. (add-num-keep-rest (list 1 2 3)) should evaluate to (6 1 2 3), right? Sum up the numbers in the list and stick it on the front? If that's the case, here's my hint: break up this problem into two different ones. Notably, add-num-keep-rest itself shouldn't need to be recursive. I hope that helps, and I hope I'm not giving too much away. Best of luck.
Thanks, I actually made a working code 20 minutes before reading this. And turns out I did make helper functions. 1 to add all the number entries. The other to remove all number entries from the list. And then the simple wrapper sticking them together. Thanks for the advice. 
Don't know, but article for some stuff make sense and for some not. For example, not once I was pis**d why scheme (car '()) throws error instead of returning nil, like in CL or Clojure; some really cool code and idioms from CL/Clojure can't be done elegantly due above 'feature'. This thing with substring and string-length and all safety just reminds me on Java: there will be too much bloat just for the sake of safety and where is bloat, it is easy to make mistakes. He also talks about UNIX philosophy and 'do one thing well'; well, this works for tools, not strings. Check regex stuff for example; now imagine it always throws and error/exception when something doesn't match. Some things should silently fail and on UNIX they are strings. When you need safe strings, you should use safe functions, like was done in C: you have strncpy or strcpy if you are brave enough :)
Nice. Anyone know what the deal is with the slime egg. Under 4.7.0 it fails compiling with this: Warning: reference to possibly unbound identifier `foldl' in: Warning: environment-list-symbols Error: module unresolved: apropos Also, there is no egg "apropos". Haven't checked it yet under anything newer than 4.7.0. Any help is greatly appreciated. 
Hi! Sorry to hear you are having troubles! The error you state above originates from compiling the apropos egg with a chicken prior to 4.8.0. So it is not related to the slime egg. One could argue that either the dependency information for apropos is incorrect, i.e. you should get an error stating your chicken being too old or that there should be an alternative implementation around this limitation available. I will file a bug report against the apropos egg. You should consider upgrading though you are missing out on a lot of features. **update**: https://bugs.call-cc.org/ticket/987 has been created for you :)
I think you need an eval in there as well, otherwise it's just a collection of symbols. Anyway, I can't imagine this is the best of way of solving your problem. Can't you just throw a conditional in there somewhere?
I realise this is probably not the best way, its just that I thought it would be a nice way to define a function at the beginning of a file that is then used to help interpret that file, that way semantics of my file are fully contained in the file and I can change file formats easily by altering the function. That way I can wildly experiment with the file formats and as long as the function provides the right output I don't need to touch the core program. And you were right, I was silly, just needed to wrap read in eval. I guess I was just used to how read would the object I expect, (number, string, list) Thanks
Well it's certainly not the prettiest thing, but: (define objects (with-input-from-file "test" (lambda () (let loop ((objs '())) (let ((object (read (current-input-port)))) (if (eof-object? object) objs (loop (append objs (list object))))))))) (define env (the-environment)) (let loop ((objects objects)) (if (not (null? objects)) (begin (eval (car objects) env) (loop (cdr objects))))) is what I came up with playing around for a couple of seconds. It works it's just ... ugly. There's probably wayyy better ways to do it.
&gt; I thought it would be a nice way to define a function at the beginning of a file that is then used to help interpret that file Definitely an interesting concept! The earlier I've heard of this being used is in the '60s, as described by Alan Kay in [the early history of Smalltalk](http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html). Yeah, you'll need eval for this.
Thanks, definitely going to give that a read.
Nice, luckily I'm currently restricting myself to only having one object after the initial function, so I don't need the entire power this would provide. Though it might have to grow into something like this later. Thanks
If you don't insist on placing anonymous functions in the file, you could just use LOAD.
I considered that but anonymous functions makes the file format cleaner. This way I just have a little anonymous helper function that doesn't need to know much about how the file is used, that's in the main program. Also load gives the file format a bit too much freedom, its only meant to be flexible in certain parameters.
&gt; Are there things that simply CANNOT be rewritten in another way, not using a lambda expression? Actually, lambdas exist precisely because there are essentially no things in Scheme that you can't translate into them. Take the let form, for example: (let ((v1 e1) (v2 e2) ...) (e v1 v2 ...)) is basically equivalent to: ((lambda (v1 v2 ...) (e v1 v2 ...)) e1 e2 ...) So, as you go down the compilation chain, lambdas become extremely useful as a unifying primitive. Now, whether or not you use them in your "user-level" code is entirely up to you. I guess you have to develop some taste regarding that matter.
Not like this: (define global-counter 0) (define (recursive-function am-i-recursed) (if (not am-i-recursed) (set! global-counter 0)) (set! global-counter (1+ global-counter) (if (not-yet-done) (recursive-function #t))) (recursive-function #f) Preferably like this (assuming that the function returns counter value): (define (recursive-function counter) (if (not-yet-done) (recursive-function (1+ counter)) counter) (recursive-function 0) PS: observe that in scheme this function is not really "recursive", it will not increase stack due to "tail recursion". The argument is here just passed as a variable in a loop. 
shareware? 
Not to be picky, but I guess this is more the kind of structure you are looking for. In each node you go left or right (or car or cdr if using cells) if the value you are looking up/storing is less or larger than the value of the current node. [5] / \ [3] [7] / | | \ [1][4][6][8] / \ [0] [2] 
The point was to emulate arrays, so there shouldn't be any requirements on the ordering of the values, only in what place corresponds to what array index. 
It's definitely nothing wrong with Emacs, I have been using Emacsen during my whole programming life (30 years), I've used certainly 10 different emacsen, however (GNU)emacs has also grown to the extreme, it's like the common lisp of editors where scheme is the swiss army knife of programming. I guess you get what I mean by just doing eg: `apropos "apropos"` I get 122 different apropos function :-) When I did an AI course in the late 80-ies, we were using a DOS based scheme, I think it was from Texas Instruments, it was integrated with a scheme based emacs-style editor named "Edwin" I think. Something like that I want, and this seems to be a good approach. Hmm, just found that [Edwin](http://www-mips.unice.fr/Doc/Softs/MIT-scheme-7.3/user_11.html) is part of the MIT-scheme... I know that some of the 'extensions' in emacs lisp like default parameters, interaction parameters and such are very useful though. By the way, the first emacs I used was written in MacLisp, by [Greenberg](https://en.wikipedia.org/wiki/Bernard_Greenberg) for [Multics](http://www.multicians.org/mepap.html), and... I see that the source is now available.
&gt; I use common lisp for everything Does common lisp have an integrated emacs style editor? I'm curios as I've actually never used common lisp, but lots of lisps (Lisp 1.5, MacLisp, AmigaLisp, ZetaLisp and a few more) but have since late 80-ies mostly been using scheme as my favourite language, in many flavours though, but the last 15 years mostly guile.
&gt; is too large and too hard to learn. You don't "learn" Emacs :-) It's a way of living. As I commented in another thread, if you just do ` apropos "apropos"` I get 122 apropos functions... When I was working for ASEA during the 80-ies (we used Multics) though I held courses in emacs and Multics and every new programmer was hinted to first go through the tutorial which I consider very efficient. I would recommend, don't try to learn it, just find a subset of useful keys and commands, and you are fine. However, there is one thing which I recommend, which I have done since the beginning of time. (global-set-key "\C-z" 'call-last-kbd-macro) (or other suitable one key). Keyboard macros are so extremely useful, I use the macro function certainly 10 times a day, but the default binding is a two key sequence which is tough for a function you use often. They were actually defined like that in the first emacs I used. Also, if you use to do a lot of very similar editing/fillin, the template mode is not bad. There were people coming to me at ASEA early 80-ies thanking me that I had learned them about macros and templates, it had saved them weeks of work. *PS. and don't forget the multiplier key, usually Ctrl+U. If you want to execute that specific keyboard macro you just defined 1000 times you just press Ctrl+U 1000 Ctrl+Z.* *PPS. and if you want to reuse the macro but make it more intelligent, then you can compile it into a lisp function which you can edit and save and reuse.*
&gt; Python was the first language I learned (second if you count QBasic, and I donât) that's kind of sad - qbasic was a great language. in fact i taught myself c by prototyping programs in qbasic and then translating them to c until they worked.
ah, i see :) yeah, it was definitely a great language, though i missed out on the community since i didn't have internet access at the time. you might like this 2008 post by james hague; it's one of my favourite-ever programming blog posts: http://prog21.dadgum.com/21.html [euphoria](http://www.rapideuphoria.com/) seems to be another fun language and community in the old basic tradition, though by the time i discovered it i had already learnt more modern languages and no longer found it as attractive. i was pondering using it to teach my nephew programming, but i figure i'll be doing him more of a favour if i just stick to python.
I prefer map. Map expresses its intent entirely in terms of fundamental objects without extra syntax, which is just a distraction from the underlying computation. I will admit that functional programming in Scheme is a bit cumbersome because there is not good support for automatically curried functions. It would be nice to be able to write: (map (. number-&gt;string (+/c 1)) (list 1 2 3)) (where `.` above is `compose` and `(+/c 1)` is a curried plus function. But you can add these features using only functions fairly easily, all without resorting to macros. Syntax extension is nice, but I prefer the simplicity of dealing with functions unless there is some really onerous inconvenience that only something static can resolve. As in all things, this is a matter of taste. 
Second time this month I hear someone say that. My view of the world is about to flip.
It's not a major point in the article, but I really dislike how it ended: &gt; Scheme is such a wonderfully expressive language that recreating your favorite features from other languages is extremely easy, although I recommend against it. If you want to program in every language simultaneously learn C++. This is Lisp. You can have it your way. That's one of the best reasons to use Lisp. If the Python syntax is more productive *then you should use Python syntax*. God created macro expansion for those who don't like it. A Python user will read this, get to the end of the article, and say, "Dang, it's possible, but I'm not supposed to do it."
I don't mean to dump on macros, or your post (which says, after all, that its just fun). I don't even mean to suggest that this style is wrong: it is a matter of taste. My preference is nevertheless to avoid macros unless I have a very clear abstraction in mind that cannot be represented with the features already present in the language. Having worked with large Lisp code bases where macros proliferate like cock-roaches, I've come to feel that changing the meaning of a language should be a carefully considered action. Especially in a lisp like Common Lisp, where the feature you want has almost certainly already been designed in. In Scheme, this is less of an issue. 
An [Open Cola](http://en.m.wikipedia.org/wiki/OpenCola_%28drink%29 ) or a [Free Beer](http://freebeer.org/blog/) pleaseâ£ 
commies are authorithorian, I'm left libertarian you may like my Nov 17 essay, [Evolution, Deception and Cookingâ¢](http://rolandorre.se/?p=175) _PS. I'll explain later why the exponential progress, leading to hyper exponential, if you don't see it directly._
I can't seem to understand what you mean. Maybe this: (display (string-append "'" s)) Where `s` is your string
Thanks for the reply! Here's what the test line in my homework says: (display (find-sublist '(7 1 2 3 4 1 2 1 2) '(1 2)))(newline) ; should return '(2 6 8) Right now, mine returns (2 6 8), but it's graded by a program so I want to make sure I get it right. What I return is a list so the string-append thing doesn't work.
'(a list of stuff) is just short for (quote (a list of stuff))
I'm not sure, I'll check tomorrow
This comment is wrong on all of its points. All of them! (1) Distros are updating to Guile 2.0. Fedora 19 has Guile 2.0. The next Debian stable has Guile 2.0. Any of the more recent distros also have it. (2) 1.8 and 2.0 are very similar! I maintain a number of C projects that build against both. (3) Guile is not breaking API among minor releases!!!! If you compiled against 2.0.0, your program works against 2.0.9. End of story! Finally, Guile does /exactly/ what GTK+ does -- parallel installation with pkg-config to choose between them, as advocated by then-GTK+ developer Havoc Pennington, over 10 years ago: http://www106.pair.com/rhp/parallel.html Note that GTK+ and Qt and all the rest change API between stable serieses, just as Guile does. "Get serious" indeed.
As nebogeo said, the ' isn't meaningful for the value. It's only a shortcut. '(1 2 3) ~ (list 1 2 3) which is represented as "(1 2 3)"
Really? Can you put it on github or somewhere public, please?
Hi. Guile 2.0.0 was released in February 2011. GTK+ 3.0.0 was also released in February 2011. The previous stable series, 1.8, was first released in 2005. The previous series was released in 2002 (like GTK+ 2.0.0). Thus, "changing my code every couple of months" is quite an exaggeration. There is a porting guide, yes, in the form of a list of user-visible changes: http://git.savannah.gnu.org/gitweb/?p=guile.git;a=blob_plain;f=NEWS It is quite thorough. You are correct that 1.6 and 1.8 (e.g.) are ABI-incompatible releases, though we try to preserve API compatibility as much as possible. That's the thing that really set me off about your comment, by the way: we spend /inordinate/ amounts of time thinking about how to make improvements while maintaining back-compatibility. Believe me, it is foremost in our minds!
Download scwm and scwm-icons (first install scwm-icons) http://scwm.git.sourceforge.net/git/gitweb-index.cgi Install all dependencies i usually on debian install `sudo apt-get build-dep sawfish` they have similar deps. and build it with ./configure --disable-imlib (scwm uses old imlib, debian has imlib2). Copy from sample.scwmrc simple.scwmrc to ~/.scwmrc
Thanks, apparently you don't need the quote and I'm just being paranoid
I completely forgot how much fun it was to draw things programatically in racket. /me ponders how he could get racket to compose music..
&gt; we spend /inordinate/ amounts of time thinking about how to make improvements while maintaining back-compatibility I'm very happy to hear this! Here is my story (for all you downvoters): long time ago I was satisfied scwm user and when distros dropped 1.6 I tried in numerous occasions to move the code on 1.8. However, due lack of clear documentation, negative comments around the net and overall lack of my knowledge about guile internals, I dropped it, including some projects I can't find today (e.g. guile-fltk where UI designer would generate scheme code). I was sad. Now, I'm also extremely happy to see scwm was updated to the latest guile version (and from changelog I'm seeing 1.8 is supported too). It is time me start using it again... PS: I always keep guile installed on my computer, no matter if I use it sporadically. Probably a habit... ;) 
Wrote above.
Thanks!!
Try [Chicken Scheme](http://www.call-cc.org/).
You're not going to get performance in a toy. Performance takes hard work on the implementers' part. Pick a standard Scheme, and limit which packages or features from same that you use. It's easy to put Racket in a minimal no-bells-and-whistles mode.
Add [parley](http://wiki.call-cc.org/eggref/4/parley#using-parley-in-csi) to the REPL to make it a little more awesome. 
How about [A++?](www.lambda-bound.com/) I'm not sure what performance is like, but it's based on the lambda calculus, and isn't really Scheme.
In Racket, you can ask for an empty language, to which you then add whichever primitives you are interested in. [From the documentation](http://docs.racket-lang.org/guide/mk-namespace.html#(part._.Creating_and_.Installing_.Namespaces\)): &gt; The make-base-empty-namespace function provides a namespace that is empty, except that racket/base is attached. The resulting namespace is still âemptyâ in the sense that the identifiers-to-bindings part of the namespace has no mappings; only the module mapping has been populated. Nevertheless, with an initial module mapping, further modules can be loaded. &gt; &gt; A namespace created with make-base-empty-namespace is suitable for many basic dynamic tasks. For example, suppose that a my-dsl library implements a domain-specific language in which you want to execute commands from a user-specified file. A namespace created with make-base-empty-namespace is enough to get started: &gt; (define (run-dsl file) (parameterize ([current-namespace (make-base-empty-namespace)]) (namespace-require 'my-dsl) (load file))) 
Picolisp?
It's not a Lisp, but... You could try Lua, since it's very much like scheme. LuaJIT will give you the performance you need.
I didn't understand what I read. What is it for?
Check out fluxus, which is built on Racket: http://www.pawfal.org/fluxus/
[Try Paren](http://tryparen.tistory.com/). https://bitbucket.org/ktg/parenjs 
Awesome reference! Is there something similar for Common Lisp as well? The Common Lisp hyperspec isn't really a good reference for the standard APIs and macros. Sorry if the question is off-topic.
How about http://minispec.org/ ?
bump?
Any demos using SPOCK? I have found nothing but the docs online.
There is http://www.call-with-current-continuation.org/spock/threads.html (code here: http://wiki.call-cc.org/eggref/4/spock#using-continuations-for-cooperative-multitasking).
Chicken or Racket? And why?
Great scott!
Looks super awesome. I think I'm gonna pick up Clojure and try make something fun. Not really sure what yet, but this calls for making something at least.
I've done [Tursas](https://github.com/zmyrgel/tursas) chess engine in Clojure. I also have semi-working scheme port of it but I haven't posted it online yet.
Try KAWA. I used it sometime ago and it is quite good.
Very cool project and approach to package management. It would be nice if there was a minimum install package for making your own GNU system , something along the lines of http://www.linuxfromscratch.org/ using just Guix, its dependencies and a kernel on a boot disk. 
I'll try to reply here; to blog author: if you would like someone outside Japan to reply on your blog, it would be nice you offer english translation as an option, since I have not clue where is *Post comment* button. IMHO, whatever has *let* in it's name (let, letrec, let-my-cool-foo) should make a scope. This is called consistency and unless you are going to clutter the language with ambiguities and various exceptions inside the standard, this should be a guiding rule. Scheme is such a nice (consistent) language, so N-times please, do not make a monster of it. Or, as Racket guys did, change the name ;)
Have the votes themselves been published yet? I didn't see anything poking around the site, but I bet they'd make interesting reading.
You mean [this](http://trac.sacrideo.us/wg/wiki/PlebisciteIndex)?
It's interesting that the Racket folks voted "no" and that they complain that R7RS small is too far a departure from R6RS. [http://trac.sacrideo.us/wg/wiki/PlebisciteObjections](http://trac.sacrideo.us/wg/wiki/PlebisciteObjections)
I would imagine that is in part because they were one of the only implementations that actually bothered to implement R6RS. If I did my best to make my code compliant with the latest standard and suddenly everyone told me that they were "just kidding" about said standard and were going to go in a completely different direction instead, then I might object as well.
This one has to be the most blatant. http://trac.sacrideo.us/wg/ticket/490 &gt;&gt; The draft has little to offer the working programmer over R6RS. &gt; This is probably true, if application programmers are meant. Library programmers, however, will be able to achieve more widely portable libraries if R7RS-small is adopted by the implementations that did not adopt R6RS, as adding R7RS-small support to an R6RS implementation is extremely straightforward. The WG often had the concerns of library programmers in mind while working on the draft. "Well, yeah, but it was made by those other guys, so fuck it, you'll use mine!"
With all the talk of maintaining consistency with previous practice, giving preference to SRFIs over R6RS, they chose to break backwards compatibility with older standards by making this one *case sensitive?* That's the most arbitrary way to break old programs!
There's an option to run it in case insensitive mode to accommodate such needs, IIRC, so you can run old programs without breaking compatibility. It works on a per-file basis, too, so I believe you can use case sensitive new libraries in old case insensitive programs without problems. It might have a few problems here and there, but on the long run I believe having the case sensitivity is a better option. Especially when you consider Unicode identifiers and some hairy rules about figuring out if a string should be considered equal to another in some case difference situations. http://www.w3.org/International/wiki/Case_folding
I thought of that argument, but is it really worth it to break backwards compatibility? Yes, it's a small change, but source code still would have to be modified to work in standard Scheme (implementations could provide a configuration option, but is it good for the standard?).
I don't know if they went through with the idea of having identifiers have any valid Unicode "letter" characters in them, but that was a possibility when the vote around case (in)sensitivity was being discussed. I do think that if they are valid identifiers, being case insensitive by default would be a mistake. I do think it's unfortunate that they had to break compatibility in this, but I believe in the end it'll be for the best. It might just be a matter of taste clouding my judgement, though, for I prefer case sensitive languages.
So, "why Sagittarius"? What's the goal or the pain point vs. chicken / gambit / TinyScheme / chibi / etc.? Anyone have any suggestions/thoughts?
Will the RTL VM be called [Sonic Boom](http://www.youtube.com/watch?v=jLJLyneZGKc)? &gt;[22:21:00 &lt;fnord123&gt; wingo. promise me that when you do a branch to optimize guile you will call the project "sonic boom" ](http://ccl.clozure.com/irc-logs/scheme/2010-02/scheme-2010.02.23.txt) &gt; [22:25:08 &lt;wingo&gt; fnord123: yes sir](http://ccl.clozure.com/irc-logs/scheme/2010-02/scheme-2010.02.23.txt)
Very exciting news. Guile is my favorite Scheme implementation.
The name is a bit confusing. Andy's *calling* it RTL, but it's actually a register-based VM like Lua.
Besides it's technical merit as a solid Scheme implementation that has gotten much better as of recently (and only continues to get better with the improvements mentioned in the OP), I really like where it stands as the official GNU extension language: "Guile is a library designed to help programmers create flexible applications. Using Guile in an application allows the application's functionality to be extended by users or other programmers with plug-ins, modules, or scripts. Guile provides what might be described as "practical software freedom," making it possible for users to customize an application to meet their needs without digging into the application's internals." There are very cool projects around Guile such as integrating it within Emacs: https://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/bpt/35002 And creating tools to help write applications that benefit from the Emacs way: https://google-melange.appspot.com/gsoc/proposal/review/google/gsoc2013/shanecelis/1
But are people actually using it as an extension language (outside of Emacs)?
[There are a bunch actually](https://en.wikipedia.org/wiki/GNU_Guile#Programs_using_Guile). Somewhat unsurprisingly, many of them are GNU projects. 
Hah, someone forgot the (non-GNU) [Vrr](http://atrey.karlin.mff.cuni.cz/projekty/vrr/) vector graphics editor for complex technical drawings. :-)
And conversely, another tool to disambiguate identifiers with some prefix series (to be able to run case-sensitive code in a case-insensitive interpreter). For Unicode reasons, case insensitivity is too problematic. I believe it's a good idea to ditch it. But I think it's better not to use case sensitivity in code if it can be avoided, or do it very carefully.
I often hear that one of the advantages of Haskell is that it is great for creatinng DSLs. Why would it be better for that than Scheme or Lisp, which has built in support for actually creating languages. Perhaps I'm asking this question in the wrong place. Is it the combination of strong-typing and the other advanced support for type inference along with something else that makes it great for DSLs?
Funny, I prefer Lisps and Scheme in particular, but often do my IO and similar tasks through my own monad syntax because I like the statelessness of Haskell and the stability of really, truly functional code. 
My take is a focus on tiny functions acting like grammar combinators with a very small syntax overhead that slightly gives the impression that you're writing in natural language.
&gt; This is a serious barrier to Haskell's usability that is rarely discussed, because you can only fix what you see, and if you can't inspect the inside of a function, you can't fix it. For debugging there is an impure function built into the Prelude: [traceShow] (http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/Debug-Trace.html#1) that can print any instance of Show out to the screen without being in the IO monad the same as ``printf`` or ``display``.
I'm not a professional Haskell programmer, but I can provide some insight as a dedicated Lisper with a strong interest in Haskell. What is a DSL, really? Well, one way of thinking of it is that it is a series of tokens which succinctly denotes some domain specific "action." Usually, in addition to being succinct, we expect the DSL to somehow be "near" its domain. For instance, in a parsing DSL, we expect to have a series of tokens which denotes a parser. Furthermore, parsers always eat up an input of some kind while accumulating an ouput, and so we expect that the DSL will "paper over" this commonality. Indeed, most parsing frameworks I am aware of handle this input/accumulation aspect of parsing in a more or less automatic way. In Lisp we may go all out and write a macro which reads a series of tokens and, through high level compile time transformations, produces more or less recognizable Lisp code which performs the job at hand. This approach is obviously powerful, but if you have ever worked in a code base with significant macro magic, you probably know that such power can often produce difficult to understand code. Personally, I'm not a big fan of macros because they are semantically disruptive: you are cruising along, reading s-expressions whose head's denote functions and whose tails are the arguments thereto and then, without a semantic hint that this is the case, you encounter a macro, and the entire meaning of the body thereof is now up in the air. For all you know, the macro expansion walks the whole body and totally changes the semantics of the content. Haskell takes a more disciplined approach: you can apply functions. Even infix operators are functions with some special extra information that defines their precedence in evaluation. But it turns out that if you think functionally enough, this is all you really need: your DSL consists of a vocabulary of prefix and infix functions which construct particular programs, themselves functions. The only wrinkle is that Haskell has specific syntax for one powerful abstraction called a monad, which basically allows you to extend in very particular ways certain kinds of function composition. But it turns out that this very minimal bag of abstractions is sufficient for a huge variety of very expressive DSLs. And the benefit is that a reader of the code knows that he is looking at either monadic code or function application (the former of which transforms to the latter by a simple set of rules). This makes Haskell DSL's expressive _and_ comprehensible. To return to the example of parsers: it turns out it is possible to conceive of parsers as constituting a monad. Once such a monad is defined then regular old monadic computation is sufficient to construct terse, expressive descriptions of parsers. You get an enormously expressive solution without any extra semantic baggage except the definition of the monad, which is a few lines of code. That is why I tend to use monadic approaches in Lisp, even when I have more powerful meta-programmatic features available. 
The author takes paragraphs to say "I am not saying Scheme is better than Haskell" "I am not bashing Haskell" ...etc, while he/she is precisely the one who puts a bizarre title to lurk you in and confuse people. Nice try.
I think it's simpler than that: aversion to parens. DSLs in scheme tend to be S-expression based, or else you need to write a full parser. This puts off an unexplainably large number of people. I don't know. I find it superficial and I can't see what the big deal is.
Thanks for your thoughtful reply. It's interesting you mention about the semantic clash of using macros and it's a good point. With all the tools available to us in a language, we have to be careful how they're used. As to the point about the functional composition - I've always tried to take that approach with any language I use - of course some are more helpful in that respect than others. I'm reading a bit between the lines here, but are you saying that it's Haskell's stricter purity (wrt to referential integrity) that helps more?
I would say that referential transparency helps to reason about any sort of code, dsl or otherwise. I think the strength of monads in creating DSLs as opposed to just free form macros is that monads give you a few benefits: - Monad follow a strict set of algebraic rules (the monad laws) this means that its much more natural to use them correctly. The downside however is that you must up a lot more thought into defining an instance of the monad type class since you always want to respect the laws. - You can get a lot of information about a particular DSL (monad) just by looking at the type signature - You can write code that is generic over any "DSL" since a monad is pretty much an interface to a DSL. - Monads compose with each other in a very elegant way (monad transformers).
Well, in a language with side effects the meaning of a function call is potentially much more variable than it is in a pure language: one can literally build a state machine into a function and have it perform different computations depending on some untracked or not-easily-understood series of mutations. This is forbidden in Haskell: a function call means exactly what it seems to mean, which is a significant simplification. Your mileage may vary, but I find this kind of very strict purity a great way to produce manageable code. My major gripes with Haskell are the infix syntax specifically and the non-s-expression syntax at large. I am a traditional Lisper in that respect at least. The first thing I do with any Haskell code I am trying to understand is expand the type definitions and then convert the code to s-expressions.
Speed.
Java and C are useful for their cross platformness and most languages allow you to link to C libs as well, so why bother with anything else?
But all of the languages I've listed are cross-platform. It's very easy to call Lua from C and to call into C from Lua. Supposedly you can call into D code from C. There are costs to using C. It's not very pleasant to write C if you want to write in the host language. It's not easy to dig into the internals of the implementation if it's written in C (something that's reasonable to expect with Scheme being used so much in education). You have to add first-class functions and garbage collection to a language that was never intended to be used that way.
If speed is sufficiently important that the you have to use C rather than LuaJIT or D, I doubt you'd be using Scheme. I'm not convinced that you'll end up with a faster Scheme in the end if it's C plus your own garbage collector, first-class functions, etc. rather than a language that has those things built in.
I agree with all your points (Hate cannot describe how I feel about writing bindings to C programs), but you have to see it from the language developer's point of view, there are a million in one other languages. So it is easier to just pick one, and then allow anyone who wants to use it to bind it for their preferred language. I also see C as a kind of universal language, even though I hardly use it.
Weren't they pretty much the people behind the last standard as well?
 [**@ID_AA_Carmack**](http://twitter.com/ID_AA_Carmack): &gt;[2013-06-10 13:45](https://twitter.com/ID_AA_Carmack/status/344087836384960513) (UTC) &gt;Haskell has the challenge of getting your program to compile, while Scheme has the challenge of getting your program to work. ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/1gefx3%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://yl.io/S) [^[Translate]](http://translate.google.com/#auto/en/Haskell%20has%20the%20challenge%20of%20getting%20your%20program%20to%20compile%2C%20while%20Scheme%20has%20the%20challenge%20of%20getting%20your%20program%20to%20work.) [^[FAQ]](http://yl.io/T) [^[Statistics]](http://yl.io/U) 
A new version (5.3.5) of Racket is out to support the book too.
First of all, it's a bit hard to see what's going on because of your formatting. So let's clean that up: (define m 4) (define n 4) (define (p m) (define (q n) (pp 3)) (define (qq x) (define (pp x) (+ x n)) (+ x m)) (qq 3)) Now it's confusing because you've got some variables shadowing others. When you see `m`, is it refering to that top level variable, or the parameter for `p`? We'll fix that by [alpha renaming](http://en.wikipedia.org/wiki/Lambda_calculus#.CE.B1-conversion). We'll give each unique variable it's own name by appending a number to the end. The resulting program is exactly the same semantically, it just doesn't have shadowing. The process is pretty simple. Roughly: 1. If you see `(define)` for a variable or parameter, increment the number used for that name and append it. So if it's the first `x`, you've seen, it becomes `x_1`. 2. Any other time you see a variable name, it's referring to an existing variable, so we have to figure out which one. Find the nearest enclosing `(define)` for the function that contains it. Does that function have a parameter for our name? If so, use the numbered name of that parameter. So, if you have `(define (foo x_1) x)` the inner `x` gets renamed to `x_1` because that's the name of a parameter that encloses it. If you don't find it as a parameter in the enclosing define, keep walking up. If you get to the top, then look for a top-level variable with that name. That gives us: (define m_1 4) (define n_1 4) (define (p_1 m_2) (define (q_1 n_2) (pp_??? 3)) (define (qq_1 x_1) (define (pp_1 x_2) (+ x_2 n_1)) (+ x_1 m_2)) (qq_1 3)) The `pp_???` one is a bit special. That's referring to a variable that doesn't appear to be bound at all in your program. Scheme allows that as long as you never try to evaluate it. Now that each variable name is unique, we can start simplifying things. You'll note that `m_1`, `n_1`, `pp_1` and `q_1` are never used. (This wasn't obvious until we alpha renamed.) We can ditch them: (define (p_1 m_2) (define (qq_1 x_1) (+ x_1 m_2)) (qq_1 3)) The body of `p_1` is `(qq_1 3)`. Let's apply that function by substituting the body of `qq_1` for the function call and replacing the parameter (`x_1`) with the argument (`3`): (define (p_1 m_2) (define (qq_1 x_1) (+ x_1 m_2)) (+ 3 m_2)) Now `qq_1` isn't being called anymore: (define (p_1 m_2) (+ 3 m_2)) Now we can ditch those numbers to clean up our names a bit since there isn't any shadowing any more: (define (p m) (+ 3 m)) The answer's pretty obvious now. :)
Great book, a must read!
I assume you went through it? I am thinking of getting it.
Part 1 was here: [Behind the Scenes with CHICKEN Scheme (Part 1)](http://spin.atomicobject.com/2013/05/02/chicken-scheme-part-1/).
Great blog! Aren't the fonts for your blog a bit to small?
Why wouldn't you start with the spec? It is after all *the* reference, and it is very well written (enjoyable as well as informative).
"The scheme programming language" by [Kent Dybvig](https://en.wikipedia.org/wiki/R._Kent_Dybvig) is a very good book and it is available online. The [3rd edition](http://www.scheme.com/tspl3/) covers R5RS. The [4th edition](http://www.scheme.com/tspl4/) covers R6RS.
Oh, must have miss that 3rd edition, thanks!
Read through a good portion of the book last night and today. I've read Land of Lisp and knew it would be similar. Sadly the most of the topics covered are those where CL and Racket are similar in style and syntax. If you have LoL then you won't gain a lot from this book. No contracts, macros, exceptions, regular expressions, modules, etc. That being said if you don't have LoL then the book is a great way to get started with Racket. 
Scheme in fixnum days is also worth checking. I like Simply Scheme by Brian Harvey, except for the "sentences" which I think is a deviation not really worth building. Pairs are not that hard. http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-1.html#node_toc_start http://www.eecs.berkeley.edu/~bh/ss-toc2.html
Which Scheme?
Sorry missed this. The plan at the moment is Chicken Scheme and Racket.
This is particularly funny/cool for me, because a couple of years ago I actually did a very similar project- I wrote a modified dialect of Scheme that did a source-to-source compilation to Cuda. Nice to see other people working on this stuff (far better than mine).
Cool, did you release your code? I'm somewhat sad they release code like this accoring BSD style though, as that implies that proprietary vendors may take advantage. 
&gt; I'm somewhat sad they release code like this accoring BSD style though, as that implies that proprietary vendors may take advantage. It's not unheard of for vendors to submit patches back to BSD projects; and perhaps the creator of Harlan wants the community to grow large? In industry, and especially anything bleeding edge, development studios are *very* hesitant, if not outright hostile, to embrace copyleft. If you intend your work to be used by those sorts of people then a non-copyleft license is probably the best way to go.
&gt; In industry, and especially anything bleeding edge, development studios are very hesitant, if not outright hostile, to embrace copyleft. If you intend your work to be used by those sorts of people then a non-copyleft license is probably the best way to go. WTF are you speaking about? How is this helping my freedom? Please try to understand why copy-left is essential. PS. that _industry_ you speak about has only short time left. My goal is to kill it, as it doesn't encourage freedom and competition.
BSD grants developers the freedom to use software in whatever means they can. GPL grants users the freedom to modify software in whatever means they can, at the expense of the developer's freedom to do the same. Some industries, due to trade secrets, national defense, and other still-valid secrecy concerns, cannot or will not broadly adapt licenses that require the revealing of implementation details to end-users. For instance, if someone wanted to use this software on a PS4 or XboxOne they'd be able to do so thanks to the nature of the BSD license. The GPL3 would make it very difficult, if not impossible, to use this software on such a closed system. If the developer's goal is to have wide spread adoption of their software amongst *other developers* then BSD is the way to go. If the developer's goal is to ensure the future ability of users to modify their software then GPL is the way to go.
&gt; Some industries, due to trade secrets, national defense, and other still-valid secrecy concerns, cannot or will not broadly adapt licenses that require the revealing of implementation details to end-users. Those industries which need to be eradicated from this planetâ¢ This is not a proper behaviour due to several reasons. &gt; For instance, if someone wanted to use this software on a PS4 or XboxOne they'd be able to do so thanks to the nature of the BSD license. The GPL3 would make it very difficult, if not impossible, to use this software on such a closed system. Closed system not acceptableâ¢ Why the heck would I like to encourage use of closed systems? &gt; If the developer's goal is to have wide spread adoption of their software amongst other developers then BSD is the way to go. If the developer chose to do that, and they have based their software upon BSD, OK, let them do it, it's up to them, but them may be misled. &gt; If the developer's goal is to ensure the future ability of users to modify their software then GPL is the way to go. Every user, is a potential developer. Every user, can learn from other's software, and improve this software, ad infinitum. I'm working on the same concept as a generic. The current work name, [Generic Pitchfork Licence](http://wish-it.se/genericpitchforklicence). PS. I know that I may sound harsh, but that's how it is. In a future, when the humanity has learned new habits, we can get rid of this license thinking completely, but as long as there is still proprietary closed software and technology left on this planet, I persist in being this harsh ;-)
You are free to release GPL software as you please, and to use only software which is licensed as such. Just as I am free to release BSD software as I please, and to use only software which gives me the freedom to use it as I wish. So long as there remains a need for trade secrecy there will remain proprietary and closed software; and so long as there remains developers who wish to produce software for that market in a broad and open manner then there will remain a need for licenses that retain total freedom from the developers. Those who use BSD licensed software are as free and able to distribute the source code as though it were copyleft, but retain the freedom not to do so for when the situation does not allow for it. I don't give a fuck about any lofty socialist ideals for reshaping humanity's future. I care about the next four quarters and my ability to rapidly adopt technology in as flexible a manner as possible.
This looks really cool, and I'm sure it exposes a lot of power to the author (after all, it's got Scheme in it). Unfortunately, even though I love s-expressions, I don't find writing a first draft of any text in s-expressions to be very easy. However, maybe that's the use case for the ``simpler'' outline-mode-like syntax? This seems like it could make drafting documents easier. Then again, I already have Org trying to take over my life... (`FOSS-world problems' indeed!)
Functional languages are nice for beginners because they take away some of the weirdness of maintaining state, allowing students to focus more cleanly on program design.
Also, they are nice for experienced professionals because they take away some of the weirdness of maintaining state, allowing the programmer to focus more cleanly on program design.
functional languages are closer to doing math, and make a bit more sense in some ways as they tend to give you answers when you run something, instead of dealing with state (as the others have said) and the idea of things being instructions executing in order as opposed to a constructed computation. it also is nice not to deal with control flow (for, if, while...) and saves you the trouble of trying to learn the intricacies of object oriented systems and the various things that come along with it like inheritance, polymorphism...pretty much those two. also your code tends to be shorter and more concise. instead you get things like function composition (remember f(g(x)) from algebra?) which is a little strange but can be easier to get into. it still gets complex, and is very powerful (closures are awesome, and monads are one of the weirdest things ever that no one likes to explain if you ever touch something that uses them).
[how to design programs](http://htdp.org/) is a really good way to get started. it will teach you both scheme and the general principles of good programming.
I reccomend the [SICP book](http://mitpress.mit.edu/sicp/full-text/book/book.html) and [SICP Video Lectures](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/) taught by Gerry Sussman, who is one of the creators of Scheme. Why? Higher-order procedures (Lecture 2A), Metacircular Evaluator (Lecture 7A) are simply badass if you've never been exposed to them. Also, pick up a copy of [The Little Schemer](http://www.amazon.com/The-Little-Schemer-4th-Edition/dp/0262560992) Why? I think the book does a good job of covering the mind-blowing [for me] concepts of continuations and the applicative order Y-combinator You can find some in-the-browser Scheme interpreters too like this one: http://repl.it/languages/Scheme
Scheme is one of the best-designed programming languages there is, esp for dynamically typed languages. (For statically typed, Standard ML plays a similar role.) Even if you don't ever want to program in Scheme, you should learn the basics because it serves as a bridge between the mathematical logic underlying the theory of programming languages and real-world programming. Think of Scheme as mathematical pseudo-code for the lambda calculus that can be run. Things like closures, macros, and continuations, the magic behind many cool programming language features, are most clearly illustrated in Scheme.
HtDP2e, and after that SICP? (And after that, perhaps LiSP and CTMCP - the last one for ideas.)
Wow there's some misguided thinking in this thread. First, I'll endorse the recommendations to Racket, HtDP and SICP (they're all great) .... now that's out of the way: There's a lot of talk ITT about the long-touted benefits of functional languages. I'm not quite sure why: Scheme is very firmly a multi-paradigm language and frankly probably not the best choice to focus on "functional". FP is a cool thing to learn about, and you can learn a lot about it in Scheme, but don't let them confuse you into thinking the two are joined at the hip. In the sense of a close relation to lambda calculus, they are, but it's not like scheme lacks `set!`, `begin`, `display` or doesn't talk about things that are procedures. But it is exactly this multi-paradigmness that makes learning Scheme so valuable, imo. It's a toolbox for building languages, experimenting with different programming styles and seeing how they interact. And jumping from functional to OO to prolog to metaprogramming doesn't require learning a whole new syntax and set of semantics - first class functions, syntax transformers and continuations let you express all these things. Working in a more restricted language can blind you to the forest for the trees, so to speak. 
Following this course from a distance, I found it 'too easy' at first. Since then I started to think I'd suggest it to any one learning the field. 
Maybe it's historical bias. Around the 80s scheme was probably the only 'mainstream' applicative language (I assume lisps were far more famous than ML) which could diffuse almost-FP to people. Since, the functional paradigm has been explore in deeper ways, so scheme seems further than before from FP.
So... wrong subreddit. And that's only the beginning of your troubles.
On the other hand, I think the better choice for you is learning math~logic right now. All other things for learning scheme will come with the beginning of college life.
I got this up and running with Racket last night on my Mac, and I was pretty impressed with how great this is. At first I'd wondered if I'd use this over DrRacket, but after running through a few examples, especially the ability to quickly jump to definitions of Racket library functions and display inline images inside Emacs, I was sold on it. I'd donate money to support this development being carried out. So I thought I'd share. 
Any benefit over Edwin for vanilla Scheme?
I use it occasionally (coursera,sicp,...) and am curious on what is y'all workflow with it. Or customization/extension in case you needed it.
Sure, you'd have all of Emacs instead of just whatever small portion of the functionality is implemented in Edwin. :)
:/ I've used scheme mode(s) in emacs that I couldn't get to work as well as Edwin, that's why I still use it
It's a pity it depends upon guile-2.0. I'm using guile-1.8.8.
That's extremely surprising! In my experience Guile 2 is quite a bit faster than Guile 1.8. Would you mind sharing some example that runs significantly slower on Guile 2? EDIT: I do remember testing the interpreter in 2.0 and finding it slower than 1.8, is that what you're using? In 2.0 you should really use the bytecode compiler.
Guile 2.2 will feature a new VM, fyi. Native compilation isn't there yet but it's being worked towards. From my experience, 1.8 was slow and 2.0.9 was much faster. Have you had any discussions with the Guile maintainers? I think wingo could explain why the architecture is what it is.
&gt; Have you had any discussions with the Guile maintainers? Yes, and I'll soon send them my report. &gt; I think wingo could explain why the architecture is what it is. He need to have a really good explanation... What do you like my proposal of forking them, as guile-1.8.8 and guile-2.0.0 are completely different animals? Not at all solving the same problems.
I guess you've found the reason compilation is the default on 2.0.9. :)
Those all sound like tiny artificial benchmarks, probably not representative of how fast "naturally occurring code" will run.
Fork if you want, but I wouldn't recommend it.
&gt; the reason compilation is the default on 2.0.9. to hide the fact that it's slower... ;-) Intuitively a VM introduces an extra abstraction level which usually imples extra administration. I did a test of CPython versus Jython (and some other python) a few years ago. The problem with CPython is that it doesn't work with threading on a multiCPU/multicore system due to the GIL semaphore (stupid solution if you are from the lisp/scheme world...) a problem which Jython (which runs on the JVM) does not have. However, despite Jython lacks the GIL problem and scales very well on a multicore system, the JVM introduces a slowdown to half speed... By the way, do you happen to know what the _delimited continuations_ are good for? One good thing which were in guile earlier was cooperative threads (built on continuations), but of some reason this was considered being unnecessary when they started supporting pthreads, but... pthreads and cooperative threads are two completely different animals. Cooperative threads would correspond to _greenlets_ or _tasklets_ in python (which I've used a lot) and what is default in "stackless python". Could delimited continuations possibly be a return of the _tasklets_ (light weight cooperative threads)? Also, I think it could be a good idea to get rid of the scheme stack and handle that as a list instead, which implies an "unlimited" stack, and then only use a "normal" stack chunk for C-programs. For my performance test I succeded finding a tail recursive ackerman, because otherwise I couldn't run that test at all in a meaningful way with the default stack.
&gt; "naturally occurring code" you mean like DNA :?) In case the guile-2.0 C-API is similar versus guile-1.8.8 I can later try with my software which is my "naturally occuring code" :-) but I considered the "factorial 10000" to be very representative for that, as well as running ackerman without compilation. I definitely do not want a one time C-program produced lambda to slow down the whole thing. It's intended as an "extension language" _(GNU Ubiquitous Intelligent Language for Extensions)_ but if you need to be really intelligent and clever to overcome the limitations and fine tunings of the language I wouldn't really denote the language "intelligent"... For me deterministic means a lot. A programming system that does not have a simple deterministic behavior is useless from my point of view. One thing which could improve though, with guile-1.8.8 is background gc. I've only seen background gc on Lisp Machines (Z-lisp) earlier, but now with multicore CPUs background gc should be everywhere. All what is required is two gc bits instead of one. This could be something to add to guile-1.8 maybe. (there was one guile-1.9 as well, but I haven't seen it). It could also be implemented in hardware, like FPGA, on systems that support co-processors (like ARM).
&gt; but I wouldn't recommend it. why?
There's nothing keeping you from compiling a lambda, no matter when and where you create it, but if you really create it fully at run-time, then that's no better than `eval', or am I missing something? If you really have a genuine use-case for that, then it depends on how often you need to create a new lambda: if it's create-once-use-many, then you can just compile it once and use the compiled one many times; otherwise, if you constantly create new lambdas at run-time, then the compilation will not benefit you either, but such a situation sounds like a very weird use-case to me; I'd say make sure that your code's architecture doesn't have any basic flaws. You say you measured: - load/compile-time Obviously 2.0 will be slower, since it compiles at all, 1.8 doesn't compile. :) - factorial 10000 You say you did this to test "library functions and memory handling"? Because I don't see how it tests either of those; please post the code. The obvious tail-recursive implementation runs in ~0.32 seconds for me. - ackermann You said it's 3 times faster in 2.0 when compiled, 50 times slower when not compiled. As already said, I don't think there's any common use-case where you *don't* want compilation, so I wouldn't think this is that bad. From what I know 2.0 does indeed use a Scheme interpreter written in Scheme, instead of a finely-optimized C implementation like in 1.8. Edit: someone teach me how to format stuff in Reddit. :P
Hello, I'm a Guile developer. I think you're partially right and partially wrong, but mostly, you're mixing up what a VM is for. The point of a VM is to move computation from runtime to compile time, thus making runtime faster. In a pure interpreter, you would have to have an "environment" structure (almost certainly a hash table) that stores the values of all of your variables, and look up variables when you need them. In VM code, you've already predetermined the location of every variable, so the lookups are just array accesses. Similarly, in a pure interpreter, you would have to look up the values of functions when you wanted to call them - in a compiled language, you can do some of that ahead of time (this is inlining). Shifting work from runtime to compile time is what makes compiled code fast. However, you are right about one thing. In some versions of Guile 2.0, typing code in the REPL, without doing any extra work, leads to it being interpreted, not compiled. This is bad, because the interpreter is really terrible. We should probably either be compiling all code by default or doing some clever adaptive thing like modern JS implementations do (but that's hard in many cases).
Could you clarify a bit about what conditions and which Guile versions cause the code entered at the REPL to be interpreted?
&gt; In a pure interpreter, you would have to have an "environment" structure scheme code can, as far as I know, not run in a pure interpreter, due to its lexical scoping and tail recursion. Thus all code is compiled in a sense, although only making text into lists and variable references as contextual references (haven't looked upon how this is implemented in guile, but there are no hash tables for repetetive variable references as far as I understand). &gt; typing code in the REPL, without doing any extra work, leads to it being interpreted, not compiled. This is how I normally work with scheme code development, interactively through the repl using an emacs interface and plenty of scheme buffers. This was also how I first reacted upon guile-2.0.9 being slower. There I did the simple factorial test The fac I used above was defined as: (define (fac n) (define (iter n res) (if (&gt; n 1) (iter (1- n) (* n res)) res)) (iter n 1)) and just running it like that, OK `(define foo (fac 10000))` made in average 60 ms on my tablet (L7400 1.5GHz) for guile-1.8.8 but 212 ms in average for guile-2.0.9 (no gc in either case). A very noticble difference. Then I read that when guile-2.0 is started interactively it uses a debugging VM (for tracing, breakpoints etc) so I run the rest of the tests using shell level scripting. There I noticed that the timing for guile-1.8.8 was slightly higher 111 ms (18 ms load time excluded) and for guile-2.0.9 it was 298 ms including compilation time and 187 ms when excluding compilation and load time (or running from cache). Load time for guile-2.0.9 is 32 ms about and 18 ms for guile-1.8.8. I also run the tests on a G5DL380 Proliant server which interestingly enough only performed slightly better, so my tablet is not bad :-) &gt; This is bad, because the interpreter is really terrible. I think it could be a good idea to at least use the old interpreter with "semi compiled" code as default. &gt; or doing some clever adaptive thing like modern JS implementations do (but that's hard in many cases). Too clever things can also be bad, as cleverness is usually based upon an assumption about user pattern/behavior. There is not one language suitable for all kinds of scenarios. That's one reason I consider a fork could be desirable, to simply be able to focus on different goals, but not everything in one box (like Common Lisp..).
Took me a few minutes to understand what Emacsy is -- it's "Emacs-like" in its philosophy/architecture/ability to change behavior at runtime, but it's not Emacs-like in that it's not a text editor (though presumably one could build a text editor with it) Also TIL, there is [another GSoC project](http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/bpt/35002) to run Elisp in Guile.
&gt; reserved for very special circumstances very different behaviours, that is suitable for different user patterns, I consider very special circumstances. &gt; think LibreOffice and MariaDB both were due to _political_ reasons, and an issue like this shouldn't be political.. &gt; I would have a more in-depth discussion with the guile maintainers before deciding to fork. Of course. &gt; there are enough battles that Guile is already fighting to gain a larger user base. It's exactly that about large user base which may be contradictive against not forking, just because different users/applications have different needs and behaviors. As I've used guile for 13 years earlier, I like it a lot, although there are still things I would like to improve (like background gc, simple reload/rename of modules like in python, light weight threads, like the old coop threads, stackless, much simpler library support (just check python, which has grown tremendously due to this, simple frontends to many different languages). I know that the latter now is a reality, but... so far not in the way I'm pleased with :-) PS. I am very hard to please ;-)
&gt; scheme code can, as far as I know, not run in a pure interpreter, due to its lexical scoping and tail recursion. Thus all code is compiled in a sense, although only making text into lists and variable references as contextual references I disagree about whether it can run in a "pure interpreter", but that's a question of definitions and not substance. Every Scheme implementation I know of turns text into lists. You don't *have* to turn variable references into vector refs (I assume this is what you mean by contextual references), but I don't know if any real Scheme systems work that way. As for your timings, it sounds like you haven't gotten it to compile your code. I think you can do that by putting it into a module and loading that module, but I completely agree that this is our fault - it really shouldn't be possible to put Guile into a slow-code mode. &gt; That's one reason I consider a fork could be desirable, to simply be able to focus on different goals, but not everything in one box (like Common Lisp..). It's great that you want to make a good Scheme interpreter! But instead of forking, why not work with us to make Guile that interpreter? I agree that you've seen some bad performance regressions, but I think those are artifacts of the fact that Guile doesn't compile everything right now. Guile 2.0 really is set up to be fundamentally faster than Guile 1.8, and Guile 2.2 is shaping up to be even faster than 2.0. You won't be able to beat compiled Guile 2.0 code except by implementing your own compiler. The challenge for us is make sure that every user can get access to that speed. If you're interested, why not post on guile-devel@gnu.org and say you'd like to make Guile fast in this case? I think it would be awesome if it were, and it's definitely doable. You could even do it by making the old interpreter default (it wasn't actually removed - it's still around in the compile process), although I personally think the best solution would look like the old interpreter, but switching to the compiler whenever a function was called enough. I am certainly not an expert here, and I hope wingo or someone will chime in with more, but I think you can accomplish your goals much better by working with the Guile team. Let's make Guile 2.2 awesome.
Sadly, I don't know enough off the top of my head to do that. I think you can get compilation by putting code in a module and loading that module, and of course by calling the compiler explicitly. I don't know about other situations. I hope someone else will chime in with more information.
&gt; why not work with us to make Guile that interpreter? I agree that you've seen some bad performance regressions Sure, I'm interested in doing this. (I've already written the apropos/quicksort/mergesort code), as I really believe in scheme first of all, and really like guile, from 13 years daily experience earlier. &gt; But instead of forking Forking does not necessarily mean forking under a new organisation, although you may even be interested from other aspects, as I also work on a [generalization of GPL](http://wish-it.se/genericpitchforklicence), suitable for an arbitrarily advanced technology (I've discussed it briefly with RMS earlier and he seemed to like the idea), but not connected to commercial copyright, but [Moral rights](http://wish-it.se/genericpitchforklicence) (or [idealistic copyright](https://sv.wikipedia.org/wiki/Ideell_upphovsr%C3%A4tt) which we say in Sweden, but in Swedish...). &gt; If you're interested, why not post on guile-devel@gnu.org I've been a member of that list as long as that list have existed :-) I have recently posted my preliminary concerns there, but will soon post my first draft of report comparing performances. &gt; Let's make Guile 2.2 awesome. Indeed, although I suspect that in the time frame and visionary state I'm usually working/thinking in, I would say guile-2.3 or guile-2.4 would be what to aim for :-) First of all I need to relearn guile-1.8.8 from the bottom as I'll use that for my currrent development project (server for data mining, pattern recognition, search engine, classification, trend analysis) , then I'll study the guile-2.x bleeding edge and see where improvements and my future visions can be applied. My dream is actually a completely open hardware running almost pure lambda calculus having message passing as the Transputer (I worked with the Transputer early 90-ies until Thomson killed it...). Then VMs could be defined from that level from my perspective.
&gt; Sure, I'm interested in doing this. (I've already written the apropos/quicksort/mergesort code), as I really believe in scheme first of all, and really like guile, from 13 years daily experience earlier. Awesome! &gt; Indeed, although I suspect that in the time frame and visionary state I'm usually working/thinking in, I would say guile-2.3 or guile-2.4 would be what to aim for :-) Even better. :-) Let's make Guile-2.2 pretty good, then! &gt; First of all I need to relearn guile-1.8.8 from the bottom as I'll use that for my currrent development project (server for data mining, pattern recognition, search engine, classification, trend analysis) , then I'll study the guile-2.x bleeding edge and see where improvements and my future visions can be applied. If you're planning to serve computationally intensive applications, then I strongly suggest that you look into getting Guile 2.0 to compile your code. I realize it doesn't fit with your development style, but I think once you see the performance improvements, you won't ever want to go back. As for the hardware, I think that's awesome. You might be interested to know that I'm doing some compiler work for 2.2 which involves using a continuation-passing style intermediate representation, which is very close to pure lambda calculus.
&gt; Ah, very cool! I've never actually tried using the C interface, so it's nice to hear that people do. I've used it since early 90-ies, before guile was born, then it was Aubrey Jaffer's scm, which was the basis which guile is built upon. The C-interface improved a lot with guile as I can remember. &gt; you can see the wip-rtl-cps branch Great, I'll download it tonight and have a look, I guess [this is where to look](http://git.savannah.gnu.org/cgit/guile.git/) ?
In my Guile 2.0.9 REPL: ,use (system vm program) ;A program is a compiled procedure. (define (test) #f) (program? test) ;=&gt; #t (let loop () (program? loop)) ;=&gt; #t (let ((test (lambda () #f))) (program? test)) ;=&gt; #t (eval '(program? (lambda () #f)) (interaction-environment)) ;=&gt; #t So it looks to me like things are generally compiled automatically. Maybe there are edge-cases where compilation can't/isn't done. Or are my examples too simplistic and those situations are more frequent than I imagine?
Yes, that's the place.
&gt; I don't know how one can have an uncompilable lambda other than in later-to-be-evaled code. I realised that this was something I had used extremely sparingly, very long time ago. In that case I had used eval-string from a C-program. Normally I refer to some function which is already compiled using trampolines. &gt; (Specifically, which exact quicksort/mergesort is that? libguile/sort.c?) Yes, but this was not an example of uncompiled lambda, apart from the scheme code used for comparison when you call sort, it was only an example using trampolines. &gt; I realize now it's Markdown. Yes, but it seems not to fully comply with the Markdown syntax, neither seems google+ do, even though I read somewhere they claimed that, (reddit does it much better though...)
&gt;If you wish to debug a function in Haskell you can't insert a printf to inspect its inner workings unless that function happens to be on the IO monad. Perhaps you should have read the whole sentence :) I'm not terribly well versed in Haskell, but I believe his statement is correct.
Yeah, not to hijack this thread even more but I already have an Emacs build here where I can e.g.: (setf (symbol-function 'scheme-multiply) (eval-scheme "*")) (setf (symbol-function 'exactp) (eval-scheme "exact?")) (let ((exact-half (eval-scheme "1/2"))) (exactp (scheme-multiply exact-half 2))) ;=&gt; #t That is to say, all first-class Guile Scheme objects (data types) are now also first-class Elisp objects (data types); `eval-scheme` can return them in Elisp; some of the types overlap, for example a Guile Scheme integer is an Elisp integer and vice versa, an Elisp float is a Guile Scheme "inexact real number" and vice versa, but a Guile Scheme "exact rational number" has no "old Elisp" equivalent so the normal Elisp multiplication function ("*") would give a type error on it; additionally a tiny patch of mine makes the Elisp evaluator allow Guile Scheme procedures in the `symbol-function` slot of Elisp symbols (the "function namespace" of Elisp), so one can simply have Guile procedures as Elisp functions. Currently `eval-scheme` is the only "gateway" between the languages, and it takes a string because Scheme s-expression syntax is not exactly the same as Elisp s-expression syntax, but more proper such "gateways" are quite easy to implement if you know the C APIs of both Emacs and libguile.
sounds cool, just to double-check that I understand -- you would be able to write Emacs extensions in Guile-the-language, but not execute Emacs in Guile-the-VM right?
Guile can actually already compile Elisp, and nontrivial Elisp programs like Dunnet have been run with it, however libguile lacks some fundamental Emacs data-types like buffers and windows so the Elisp it compiles cannot use these. If I'm not mistaken that was a somewhat separate effort than the current one of making Emacs's Elisp engine use libguile, however if my understanding is right they could be said to be tackling the same problem from two ends, and will merge in some way; what I can say for sure is that the end-goal is to make Emacs entirely be a (huge) Guile extension (see Guile manual for the precise terms "extending" and "embedding"), so e.g. all Elisp functions compile to the Guile IR/VM and can be accessed from the cross-language module-system and not just the other way around. (At the current state of the project, it could be said that Emacs merely "embeds" Guile, instead of "extending" it, so it can "use it" but "gives nothing back". Also see: http://twistedmatrix.com/users/glyph/rant/extendit.html )
Scheme in fact is standardized. The currently most widespread version is [R5RS](https://en.wikipedia.org/wiki/Scheme_%28programming_language%29#R6RS), [R6RS](http://www.r6rs.org/) has been standardized, but many implementations are skipping it. [R7RS](https://en.wikipedia.org/wiki/Scheme_%28programming_language%29#R7RS) is something I very much look forward to. There are many standard scheme libraries for Scheme called [SRFI](http://srfi.schemers.org/)s, but sadly, implementations usually implement different subsets. Also, up to R6RS, there was no unified way of packaging Scheme, so the methods of loading SRFIs and other libraries were usually incompatible between implementations. R7RS will hopefully rectify a lot of this by requiring a standard set of SRFIs and the unified packaging system.
[Scheme r6rs](http://www.r6rs.org/) has a well-defined module system, so a library written for it should work across any compiler/interpreter that implements r6rs.
Now we just need a common repository and package manager. Now wouldn't that be awesome!
Part of the problem is that all the schemes have slightly different FFIs, so wrappers for things like SDL are not necessarily compatible across Schemes. Even when R7RS becomes widely adopted, there'll still be separate ways of doing the FFI to C. Scheme tends towards pure rather than pragmatic (although R7RS might change this a bit). Basically, pick a Scheme you like and work out its kinks. I personally like [Chibi](http://synthcode.com/wiki/chibi-scheme): its C&lt;-&gt;Scheme interface is generally quite nice, although it doesn't do Scheme-&gt;C compilation like Gambit. Another advantage is it's going to be the reference implementation for R7RS.
A side question, but in what ways did Chicken not work well for you on OSX? I'm learning Scheme casually on OSX, and I'm using Chicken right now, so I'm curious what to watch out for.
In particular with the SDL egg. You need to fire up a X11 server (I used macports) to have GFX and Input working with it, which is, speaking in terms of distribution, a no go (This seems to be an bug, which I reported). I have the same app as an CL implementation, which will fire up a SDL window nicely. Like i said, I really like Scheme, especially Chicken, because I have the feeling I can develop more rapidly with it, compared to CL. Also in terms of compatiblity: With the Chicken implementation I was able to produce an executable for a gaming device in less than an hour. With CL I wouldn't have a clue how to do it. But I guess in the end, it's like the same with every technology, all have their pros and cons and we have to deal with them somehow. Thanks to everyone who answered for clearing things up for me.
relevant [xkcd](http://xkcd.com/927/)
We need an xkcd about mentiong xkcd#927
Yup, gambit scheme needs moar love (libs) :)
OSX users: I couldn't get the DemoHelloWorld running. It simply segfaults. All three other demos run fine.
Also in texinfo http://www.neilvandyke.org/sicp-texi/ Particularly usefull to REPLearn in your text editor as seen here http://www.neilvandyke.org/sicp-texi/#screenshot edit: coldlink
FYI: that website doesn't let you link directly to images. This works okay: http://www.neilvandyke.org/sicp-texi/#screenshot
Oh, the direct link still works fine here, but I'll edit to use your idea. Thanks.
The thought of a pocket SICP has me imagining feverish programming disciples leaving small bound copies of SICP behind in hotel rooms.
I got it running by installing MacTex and setting a path to /usr/local/texlive/2013/bin/universal-darwin. The demo was missing some artworks which would be created via some Tex apps.
Why do people skip out on R6RS? A lot of people seem to hate it, I've always wondered why.
For the time being the gambit mailing list is a good start for comments and questions, as there is already a LambdaNative thread there. But I guess something else needs to be sorted out. And yes, you are correct! Freetype is a library, not a program. It is needed in ttftools to make string textures and character libraries.
It apparently is "bloated" by requiring too big a standard library. This is seen as going against scheme's simplicity.
Context: a couple years ago my boyfriend and I decided to sit down and write up a version of [cowsay](http://en.wikipedia.org/wiki/Cowsay) in Scheme, for shits and giggles. So we did that. This library was written in Chez, so it's guaranteed to work in Chez or Petite, but I haven't tested it in any other implementations. It's not especially complicated so I suspect it'll be fine in most implementations*. In order to run it, you need to have [SRFI](http://srfi.schemers.org/)s [13](http://srfi.schemers.org/srfi-13/srfi-13.html) and [14](http://srfi.schemers.org/srfi-14/srfi-14.html) installed. Usage instructions are included at the top of the file. It could probably be done much more cleanly with macros, but I wasn't so used to macros back then, and I haven't yet been able to muster the motivation to rewrite it, haha. It's just a simple and goofy little library, and I thought I'd share in case anyone else found it amusing as well. \* One thing to worry about is that I think we used the add1 and/or sub1 functions, which are native in Chez but may not be in other implementations. I think it's pretty fucking obvious what they do, but in case they're tripping you up and you're REALLY confused, just add this to the library: (define (add1 n) (+ n 1)) (define (sub1 n) (- n 1)) edit: forgot to mention - obviously unless you're using Chez, you'll have to change the import at the top to not say (import (chezscheme) ....), but instead replace (chezscheme) with whatever implementation you are using.
Guile-2d author here. Pleasantly surprised to see this here. :) Guile-2d is coming along nicely, albeit slowly. It already can do some of the basics: make a window, handle mouse/keyboard input, draw sprites (including animated ones), and break textures into tiles for tile-based games. It can also do some slightly more advanced stuff like sprite batching for faster sprite rendering (but still quite slow, admittedly), and coroutines which are great for writing game scripts. I have a few blockers to reaching 0.1: * Guile lacks a freetype2 binding. I need to write one so that fonts can be rendered. * Guile-figl, the foreign interface to GL, needs to become a bit more stable. Hopefully they will make an official first release sometime soon. * Guile provides a REPL server that I want to take advantage of for live coding games, but it requires some tweaks in order to play nice with the game loop. I have solved basic multithreading issues with a global mutex that the game loop unlocks periodically. Unfortunately, SDL calls from another thread will crash the program. I am still working on overcoming this. Ideally, all input from the REPL will be executed in the main thread. Check out the TODO file to see where things are headed.
Thanks! SICP is a great book, I have one copy at home and one at the office. Now I have it in my computer as well :) But... why are sites like github having this weird policy I see a link saying https://github.com/sarabander/sicp-pdf/blob/master/sicp.pdf OK, I download it and... find that my pdf reader doesn't accept it... It was an html file, so the link info was false. This is something I explicitly told my students in web design I had a few years ago, if they ever design a crappy web page with fake info like this, then never ever tell anyone that I was their teacher. Is there no way to get around this, this crazyness started like ten years ago and has since then got worse and worse. OK, it worked fine for the [master.zip](https://github.com/sarabander/sicp-pdf/archive/master.zip) archive on the right though, that link was not a fake link.
Once there, "view raw" works for me. Are you browsing from mobile?
Great work so far! May I suggest you use Pango with Cairo for font rendering, instead of using freetype2 directly? If you want font rendering with proper internationalization support, you kind of end up reimplementing Pango+Cairo anyway. I speak from experience. If you decide to do everything from scratch, this is what I ended up doing: * Using libfreetype2 for actual font reading * Using the HarfBuzz library for text shaping. Required for arabic ligatures! * For Linux and OS X, use libfontconfig to search for installed fonts, based on name, family and style. Microsoft Windows has its own API.
I don't know what "view raw" means. No, I'm browsing using a normal browser (Iceweasel, i.e. firefox) on a normal laptop/tablet. When you say works, how does it appear to you? What I use to do with documents or similar links is that I copy the link (right click `copy link`) then download with wget, alternatively I drop the link (by pointing at it and moving it to a drop sensitive script which downloads it). In my case that didn't work for the pdf link, i.e. https://github.com/sarabander/sicp-pdf/blob/master/sicp.pdf I tried again, I copy the link, download it: `wget https://github.com/sarabander/sicp-pdf/blob/master/sicp.pdf` and checks `file sicp.pdf` which says: _sicp.pdf: HTML document, UTF-8 Unicode text, with very long lines_ On the archive link though, to the right, when I do the same, `wget https://github.com/sarabander/sicp-pdf/archive/master.zip`, there it works, after download and I do `file master.zip`, it says: _master.zip: Zip archive data, at least v1.0 to extract_ but the master was exactly what I wanted as that also contained sicp.pdf as well as .tex sources, images and all. I know that many of these links are often made so that you have to leftclick on them, but that is insane, of two reasons: 1. When hovering over the link it should not fool me, not point to a .pdf document if the link is not pointing at a .pdf document. 2. When I download stuff I always want to know from where, my scripts are loggin the url.
I know man, but that's the way github works. Links "fool you" all the time these days. A lot of this "cloud" malarky does funky things on the server side, it's not an FTP link, it's not a direct file link necessarily just because it ends with a pdf extension. Even this: https://github.com/sarabander/sicp-pdf/raw/master/sicp.pdf is really a redirection to https://raw.github.com/sarabander/sicp-pdf/master/sicp.pdf. Wget should be smart enough to follow it and download it. Curl would need extra options for that IIRC. They use javascript and HTTP headers all over the place, because the "cloud" (in this case github's) is in reality many servers doing multicast under the hood. There is no guarantee that all links will be transparent at all times. That's the way they work and that's the service the creators of these documents chose to use. And github mostly works with Javascript disabled, many modern sites won't. Many modern sites usually don't guarantee you that a file will be at a particular server (neither by IP nor by DNS domain). They prefer to expose links that they can manage under the hood to point to different places. Anyway, if you could download it then problem solved I guess :-)
Thanks for the tips about fonts. I don't much about font rendering, since I've always just used the built-in font support in other game libraries. It seems like it will be a complicated process. I'll try not to procrastinate on it too much.
Will do. Thanks. :)
The best two Scheme impls. IMHO!
Are you comfortable with anyone else using your code? I would like to port it but as the copyright issues are I cannot do so as is. Thanks!
CHICKEN Scheme, it's easy to do since you are mostly string juggling, I wouldn't even call it a port. But it is a nice and silly thing to have!
I have been looking for a Scheme project to play around with, this looks like fun!
I've been looking for a game programming lib for scheme for a long time but have never stumbled upon something readable enough. Thanks for the effort! BTW do you take part in the upcoming Ludum Dare?
Here's a follow up showing Turing completeness without having to add an extra instruction: [âTinyâ Turing completeness without [MMOV](http://blog.jverkamp.com/2013/08/22/tiny-turing-completeness-without-mmov/)
Oops. I had that; I think it got lost in copy pasting. :) OISC is absolutely fascinating. It's crazy just how small a minimal Turing complete language can be. For something equally crazy, check out [Lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus). In it's minimal form, you can take just variables, function definitions, and function applications and make a Turing complete language as well--you don't even need conditionals or numbers.
Yeah, websites UX wants to drop the url prefix, but webapps enjoy it for parsing ... And I know about pure LC, it's /r/scheme after all :), I share the amazement though. I didn't really get it when I was in college, but now I do (thanks to talks like 'programming with nothing' or Weirich's one). And two things I prefer in LC vs TM, are names and composability, effectively turning it into a human / computer logic interface whereas TM feels like compilation target only.
I will be too busy this weekend to participate. :(
S-expressions are the internal representation so they can be manipulated. It doesn't seem like a great document capture format. The text input format, http://www.nongnu.org/skribilo/doc/user-3.html#outline-syntax They should support other common wiki formats and markdown. The internal format seems too html specific. Still, it looks great. The major use case would be to represent a technical document and project it into epub (ver 2 and 3) and pdf (single column and two column).
Learning a Lisp based language is harder cognitively, but more rewarding. I find it harder to "babble your way" through something. If we model learning a computer language to that of learning a spoken language there are less anchors to get a foothold for analogy, syntax isn't a crutch for semantics. You need to understand what [syntax](http://en.wikipedia.org/wiki/Syntax) really means and the [semantics](http://en.wikipedia.org/wiki/Semantics) that is encoded in that syntax. Anything is representable in an s-expr. Infact nearly all compilers have an intermediate step where the program is represented in a data structure like an s-expr even if it isn't available to the programmer. In Lisp based languages (homoiconic), programs _are_ encoded directly in s-expressions, the [AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree). My advice: * Type in lots of code * Try different scheme implementations, install as many as you can * Spend a week or two writing trivial programs on a single platform, don't be too focused on the outcome. * Port those programs to new scheme implementation For a list of problems, I recommend https://sites.google.com/site/prologsite/prolog-problems which are valid in any language. If you are attending CS classes, skim the material and do some problems associated with the classes and lectures before hand. This [primes](http://en.wikipedia.org/wiki/Priming_(psychology\)) you for when it is presented in the lecture, providing an anchor for you to not get lost. Programming is hard for everyone. 
SRFIs tend to be useful. If you want to get into OOP then you probably want coops.
I personally enjoy the 'clojurian' and 'matchable' eggs. I also tend to use 'SRFI-1'.
Read the blog post http://alexey.radul.name/ideas/2013/cleverness-of-compilers/ Siskind was a collaborator on this. 
lamdanative/github (gambit) and chicken-android/github
There's a Gambit for Android too. I have it on my Galaxy Tab 2. Played with it a bit, but haven't yet done a whole lot with it. Last time I looked, you could find it on Google Play.
Sadly there is no current Chicken for iPhone. There is beamrider/github, but it is broken currently. I guess your best cross-platform choice atm is lamdanative.
Ah. I don't actually use scheme - I do some coding in common lisp and am subscribed to lisp related things. I just found the link jumping through mobile chicken scheme links amusing.
update : 1) the CVS repo is still here : http://cvs.savannah.gnu.org/viewvc/schemix/schemix/ 2) found a mirror for the archive : http://files.chatnfiles.com/gnu-mirror/savannah/files/schemix/schemix.pkg/0.2.1/ ---- Hmm sad, I can't find it even through waybackmachine. The closest I got is this http://web.archive.org/web/20031128184314/http://savannah.nongnu.org/download/schemix/schemix.pkg/0.2.1/ which lists the tgz but is not actually stored on their servers.
What does that mean in a practical sense? The article seems to end rather abruptly, having only just defined what it is talking about. "They are everywhere" isn't enough reason to be interested unless there is some information or understanding that comes from the knowledge that something is a monoid. I know that being able to recognize groups has been useful because of common properties shared by all groups, do monoids have those too?
Exactly my thoughts. &gt; before we start, we should answer the obvious question: why should you care? But we don't. Additionally, I don't see the connection to scheme except using prefix notation and parenthesis.
Later he says : &gt; (closure, associativity, identity) In lisps many operations demonstrate these properties. - They have neutral element: (+) =&gt; 0 - Prefix syntax permits n-ary operators, sheding light on this, in most infix languages you wouldn't write the line above, nor the next, and expect it to keep the computation going: (+ 1) =&gt; 1 - I can't test right now, but some schemes have arithmetic closed over Real+Infinity (/ -2 0) =&gt; -infinity (* (/ -2 0) (/ -2 0)) =&gt; +infinity
Was it just me or was that statement odd? I'd think we'd want to know a little bit more about them before asking why we care. Otherwise we would not understand at all the thing that we are suppose to care about.
Heresy.
You jest, but I love to see people experimenting with ways to make programming easier for monkies. It hurts me that Clojure still doesn't support heredoc. I have been meaning to play with the SIX syntax in Gambit Scheme. Lisps have lots of syntax, might as well use it make programming awesome.
How do you know they're not? I assume people in that area of computation (numerical) and are fans of Scheme, would be aware of its existence and probably using it. The question is, how well-suited is the code you write to this kind of aggresive compilation? In most cases, I would say not even close.
Dat comment about Haskell...
Where does it say 100 times faster?
Because unfortunately -- much as with free-energy devices -- no such compiler exists. As pointed out in the comments, the C version has an error that makes it do millions of times more work. Run either code through any basic block-based profiler, and you will immediately see this, from the difference of how often each function was called.
The title is incorrect. If you read the comments at the bottom of the post, a reader points out that the author made a mistake in the C code, using abs() instead of fabs(). Right below that the author replies that fixing the mistake brings gcc's performance about equal to Stalin's.
Well, as you noted, it's a pain to set up, it's a pain to maintain, and it's a not exactly friendly to use. Just look at the options used in [Jon Harrop's](https://groups.google.com/forum/#!topic/comp.lang.scheme/NJxRsdMNKz4) benchmarks. I realize Stalin is meant to be used as a "last step to production", but goodness is it fiddly. There's a [GUI](https://code.google.com/p/stalingui/) that is supposed to help, but I've not used it before. All told, I think I've used Stalin twice, and while the performance was good, it didn't seem worth the effort. Having said that, I think the type system is a neat idea, and is something I'd love to steal (it's on my big list of things to pull into what I'm doing).
Is it just me or is the volume really low except for the intro music?
[mp4 link](http://cdn.media.ccc.de/events/froscon/2013/mp4/c116_lisp_-_2013-08-25_11_15_-_building_knodium_com_with_scheme_-_andy_bennett_-_1281.mp4) for those interested.
This is epic.
The reference implementations in SRFIs are not necessarily intended to be 'the right way to implement this', so this implementation isn't inherently incompatible with srfi-18. While it doesn't implement all of the functions SRFI-18 defines, what it does implement appears to be perfectly capable of being compliant with the srfi.
Actually, what I meant about it being significantly simpler was that the extension to the language is simpler, rather than the implementation being simpler.
Whalesong produces very big code and is unmaintained. I kind of liked Spock's results, but still, it is a little weird, obscure and... I have no idea how I can access JavaScript code from it.
Would you say there's something, ahem, *fishy* about it, sir?
Wow, Moritz put some work into that. [Spock](http://wiki.call-cc.org/eggref/4/spock) and [jsScheme](http://bluishcoder.co.nz/jsscheme/) look promising. You don't have to download them all, make a sample app in your scheme of choice, port to a JavaScript scheme, profit. 
You should also check out Gambit-JS, the Gambit Scheme system with the JavaScript backend. The following paper gives a performance evaluation showing it is faster than Spock and Scheme2JS (in one case by a factor of 2000x): http://users-cs.au.dk/danvy/sfp12/papers/thivierge-feeley-paper-sfp12.pdf . There's also Gambit-in-the-browser (see http://feeley.github.io/gambit-in-the-browser). 
Thanks! Gambit is actually my favorite Scheme implementation and I didn't know this existed. It was on my weekend hack list to gambit-&gt;c-&gt;emscripten. Looks like I don't have to. Still need to practice some `SIX` syntax. It really would be interesting to implement a mid size project in these three js-scheme implementations.
Are you referring to my [survey of JavaScript Lisp implementations](http://ceaude.twoticketsplease.de/js-lisps.html)? :-)
Thanks thats cool
Are the slides available?
Don't know how kosher this is, but my question is not racket-specific; any suggestions or help would be appreciated.
Excellent, thanks!
Oh, it is yours? Thanks, I've been using it. Great work.
Oh why.
This one of the first Guile projects I have seen, and I am super impressed. Will look into this when I have more time.
Amen :)
Here is a [proposed repository format for R7RS](http://trac.sacrideo.us/wg/wiki/Snow). (I'm not the author.)
I have to second this; after fiddling around with Gambit and Chibi, Chicken's package manager makes it the nicest Scheme to actually use. I don't really like how it seems to encourage having its own little ecosystem, but pragmatically, it's the best implementation for getting stuff done in Scheme.
[SNOW!](http://snow.iro.umontreal.ca/) was an attempt at this that was cross-Scheme. Would be nice if someone used *that* as the basis of another system.
I hesitate to post this, because the code isn't very graceful, but [here](https://github.com/sethalves) are (incomplete but working) snow2 clients for chicken and chibi. They use a small [test repository](http://snow2.s3-website-us-east-1.amazonaws.com/) in an S3 bucket.
I love Chicken, but this isn't quite equivalent. QuickLisp provides at least some assurance that the underlying lisp isn't necessarily going to be important. `chicken-install` is strictly Chicken-only.
I just searched the online HTML manual for the word 'guile', and it didn't return any matches. Then I noticed that the documentation was last updated on July 28, 2010 (at least that's what the web page says). I wonder if the other formats are more up to date. I'll check later.
This is true of all schemes right now isn't it? One does not scheme in general, one (Racket|Gambit|Guile|Chicken)'s
Sadly, yes.
http://lists.gnu.org/archive/html/guile-user/2012-01/txtQceSqBcGlP.txt
If you are able to act in terms of S-Expressions, Guile has a pretty-print function that I believe does what you want. http://www.gnu.org/software/guile/manual/html_node/Pretty-Printing.html Edit: You could probably do what you want by using its [ports](http://www.gnu.org/software/guile/manual/html_node/File-Ports.html) and then [reading](http://www.gnu.org/software/guile/manual/html_node/Scheme-Read.html#Scheme-Read) from it as a S-Expr. Then all you'd need to do is call the pretty printer above. The problem with this approach is that it'll depend on the Scheme you're using having a read-syntax perfectly acceptable by Guile. On the other hand, it's quite likely that whatever scheme you're using can do the same thing. Edit2: I just gave this idea a go, but it turns out you lose white-space and comments, too. Edit3: If you want to check a (very badly written) scheme code for it in Guile, it's [here](https://gist.github.com/alexandream/6911494). It's been a long long way since I wrote lispy code, so bear with me :).
It would be a shame. A project like this has great potential. At the moment I'm considering its use in a beginner programming course at our hacklab.
Is there code for snow2 server
Guile, Emacs and Geiser is all I will ever need.
http://www.gnu.org/software/make/manual/make.html#Guile-Integration
Just for the record, I think it's a great book (even with my relatively weak french skills).
I have this book. It's very well written. The aim of the author is not only to teach scheme, but more generally to explain some transversal lisp and functionnal programming concepts. In this way, i think it's clearly inspired by "On lisp" (P. GRahaM, 1993). You will need some mathematical knowledge if you want to understand the last chapters of this book. If you can't find it nor if you don't read french, there are a lot of great free ressources on the web. Have a look on this page hosted on github https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md and specially all the functionnal programming related ressources.
Kawa is excellent!
Please come talk on #guile on freenode or subscribe to and email the guile-user@gnu.org mailing list.
I'm already on the IRC channel. I just wanted a second opinion from more schemers while I waited for people in the US to wake up. I'll subscribe to the mailing list though, thanks :-) I'm also currently building 2.0.9 to see if the issue is fixed there.
Purely speculating here, I think the simple form running in your thread may not ever hit [a cancellation point](http://www.gnu.org/software/guile/manual/html_node/Threads.html). &gt; Because Guile threads are isomorphic with POSIX threads, thread will not receive its cancellation signal until it reaches a cancellation point. See your operating systemâs POSIX threading documentation for more information on cancellation points; note that in Guile, unlike native POSIX threads, a thread can receive a cancellation notification while attempting to lock a mutex. The `display` function may not be a cancellation point. If so, there would be no way to cancel a thread running that particular code. 
[Pilo Visual Tools for Scheme](http://www.davidpilo.com/pvts/) has something similar, though iirc it isn't a full Scheme dialect. Are you looking for something pedagogic or for debugging work?
I was looking for anything that would allow me to step through the language that htdp was using in the same manner that DrRacket's stepper does.
Hmm. Dr Racket is probably going to be easiest there. PVTS is indeed a restricted Scheme system, though there may be some value there. You might also want to look at MIT Scheme, which I believe has a stepper debugger. Still though, if you're working through HTDP, Dr Racket's *probably* going to be the "path of least resistance", so to speak. Is there a reason why you *don't* want to use it?
I don't like package management, it is something that is made to solve problems, and potentially cause problems. 
Pilo's call diagrams were extremely helpful. I really appreciate the effort he went through making this. the sort from chapter 12 of the book ran when i converted it http://bpaste.net/show/Oe3SiFl3ty7FuxHPgxzg/ . however the permutation example that initially made me seek out another tool/ide, gives an unexpected ) error http://bpaste.net/show/j1EDtI9vYdGTF4QP4s3Y/ . it seems to run fine in this online repl http://repl.it/languages/Scheme 
do you know tutorial using other gui toolkits (qt would be nice)
What is a delimiter? Do you mean why doesn't it appear as a pair? As in '(1 2 3)' If yes, it doesn't need to appear as a pair. It says the following s-expression is to be quoted, and s-expressions are very well-defined and so the "ending" of the s-exp doesn't need to be demarcated.
Maybe to make it possible to have "prime" functions. `(define (f' x) ...)`
Are you talking about inside a string, or when tokenizing into symbols?
The latter.
Please see 7.1.1 in R5RS. For example, '(a'b) is invalid. But, some implements regards it as '(a 'b) .
Oh, Haskell style. Is there such implement?
For the lazy: /r/lisp --- I provide direct links to lesser known subs mentioned in the title if one isn't already provided. Let me know if I need to try harder: /r/LazyLinkerBot
quickly becoming my favorite scheme 
Copied your code, works great (and yes I had to add func-add). This is much nicer than my crappy recursive use of cond. Much more lispy :) This resolves the straight forward case. 5 items of data, 5 test functions. The part that I'm having difficulty wrapping my head around is how to make the functions list to be...more expressive? Instead of just supplying a list of test functions I'd like to make the list contain an identifier of the number of times the test function is valid. Instead of having a list of 3 tests cases for zero? (define functions (list zero? zero? zero?)) In a regular expression I would put /[0]{3} Or an even better case is "One or more zeros" /[0]+ I thought about having the code check "If (car functions) is a function, apply. If (car function) is a list the layout would be (list zero? +) or (list zero? 3). This is not too elegant, which I was hoping other people's wisdom could help.
I think macros might be the way to go. Either that, or a `repeat` function combined with liberal use of `flatten` (which might be Chicken-specific; I don't know if it's part of the standard). You'd then do something like this: (define (repeat N thing) (let loop ((i N) (result '())) (if (&lt;= i 0) result (loop (- i 1) (cons thing result))))) (define test-list (flatten (repeat 3 zero?) (repeat 2 string?) null? (repeat 2 zero?))) After you've got that done, you'd probably want to write a parser to turn the regexp style test-lists into Scheme lists. (Properly, I think `repeat` should really be a macro. I'm not very good at writing macros though, so I'll leave that to someone else to work out.)
I just tried this out in Gauche, and I think I found a bug :) gosh&gt; (define (f' x) (+ x x)) f gosh&gt; (f' 10) *** ERROR: unbound variable: x Stack Trace: I know it doesn't work in my own, since I treat it as a delimiter. `'(a'b)` *does* work there though; it expands to `(a (quote b))`. I could test some more out tomorrow, to see, but that's what I have installed on this workstation.
I'm getting much closer. #lang racket (define (test-list-against-validation-functions data functions) (map (lambda (f a) (f a)) functions data)) (define (passes-all-tests? data functions) (apply func-and (test-list-against-validation-functions data functions))) (define (func-and . args) (if (null? args) #t (if (not (car args)) #f (apply func-and (cdr args))))) (define-syntax-rule (repeat N thing) (let loop ((i N) (result '())) (if (&lt;= i 0) result (loop (- i 1) (cons thing result))))) (define (passes-n? f d n) (passes-all-tests? (take d n) (repeat n f))) (define-syntax passes-n-to-m? (syntax-rules () [(passes-n-to-m? f d n) (passes-n-to-m? f d n (length d))] [(passes-n-to-m? f d n m) (begin (let loop ((i n)) (cond [(&gt; i m) (values #t m)] [(passes-n? f d i) (loop (+ i 1))] [(= i n) (values #f i)] [else (values #t (- i 1))])))])) Now I can call &gt; (passes-n-to-m? zero? (list 0 0 0 1 1 1) 2 4) #t 3 &gt; I think the last step is to make a big macro around the entire thing so I can pass something along the lines of (passes-expression? d (zero? one? (zero? 3) (one? 2 4))) which would be the equivalent to /01[0]{3}[1]{2,4}
Yep; looks good to me. Glad I could help!
Oh yeah, definitely; I've spoken with Shiro a few times when I've run into minor issues, or when I've built Gauche on weird platforms. It's not a huge issue, but it's something I noticed whilst trying it.
Great reply ... I swear, if it wasn't I wouldn't be picking nits: &gt; If your Scheme implementation has and as a built-in or macro rather than a function `and` has to be a macro to provide short-circuiting behaviour. &gt; Chicken reckons that the second argument of apply has to be a list, but others might handle atoms there. The last argument to `apply` is well defined as being a list. If it weren't, defining `sum` (which takes a list) in terms of `+` would only be possible using `eval` ... or possibly a macro. I know Scheme is a broad church and even adherence to R4RS isn't universal in languages that fly the banner, but I'm not aware of any dialects that break either of these rules. It would make them quite hard to use and in a lot of folks' eyes "not a scheme". That said, if you have a counterexample I'd be curious to see it. Particularly `and` as a procedure, since you used that example directly.
I hadn't thought about `apply` like that; thanks! And yes, I see what you mean about `and` being a macro, although it'd be nice if the standard also included a function version for this sort of case. I confess I haven't actually read through the standard, just bits and pieces as I've learnt Scheme, so my knowledge is far from complete. I might have to do that when R7RS is finalised.
Pyret is a programming language designed to serve as an outstanding choice for programming education while exploring the confluence of scripting and functional programming. Made by the Racket folks.
&gt; The only compilers that will use R7RS are Larceny and, well, we'll see. [Chibi defaults to R7RS](http://synthcode.com/scheme/chibi/) [Chicken is attempting to be R7RS conformant](http://wiki.call-cc.org/r7rs-tasks) [Gauche has added some R7RS support](http://blog.practical-scheme.net/gauche/20130522-r7rs) [Kawa has also added some R7RS support](http://comments.gmane.org/gmane.lisp.scheme.kawa/2843), but is [asking for help](http://www.gnu.org/software/kawa/Ideas-and-tasks.html#R6RS-and-R7RS-libraries-and-syntax)
Touche. Even so, you've done nothing to address the problems of the SRFI implementations of things or the other general problems. There's a reason that people are fleeing Scheme for greener pastures in spades, and it is at least partially to do with the immense infighting and general lack of neatness in the RNRS committee. Everyone seems to forget that R5RS was the primary reason the Scheme community splintered.
In fighting? I've never seen anything but constructive discourse. If anything, the chicken and racket communities are growing. I suppose that those who embraced r5rs have come to dominate the community.
I thought R6RS was the main issue, with several implementors boycotting it because they saw it as "bloated". Wasn't R7RS supposed to fix that *and* finally bring a unified packaging system to scheme?
Jonathan Rees and Guy L. Steele, Jr. talked about issues related to this, briefly, in response to a question in the [Dynamic Languages Wizards Series - panel on language design](http://www.youtube.com/watch?v=agw-wlHGi0E&amp;t=97m45s) (linked video starts at the question, about three minute's worth before they go on to other things). Edit: I should mention that this panel took place in 2001, so a few years after R5RS was published.
Oh I think I watched this serie long ago, but at the time I wasn't able to parse everything they said. Time to rewatch, thanks a lot.
It's a good series. In case it helps, I am pretty sure that there's very little visual in the interviews (though I think John Maeda had a few slides he showed). Certainly nothing that would prevent just listening to it on an iPod or something. I ripped them to mp4 a long time ago and have listened to them countless times while walking.
The few parts I understood I loved. And ripping the audio is a good idea.
Yes. R7rs-small is what has been finalised, and it's basically what you describe. The second portion of r7rs will contain all the bloat, but is optional.
[Here's a poll of implementors](http://lists.scheme-reports.org/pipermail/scheme-reports/2011-October/001595.html). AFAICT it's nothing like the debacle of R6RS. Not being intimately familiar with the Scheme community, I tend to look for Manuel Serrano's opinion, since he seems to have a grip on both the theoretical and practical sides of things.
What does this mean? Frozen now?
I know several of the people involved in R7RS, and I assure you that infighting is the correct work for the long-winded arguments that went into writing it.
The code depends extensively on a nonstandard *match* syntax. Yeah, I know, they're all nonstandard, but the *guard* and quasi-quasiquote syntax threw me.
I known nothing about such tree implementation. Is it using functions with a "big" number of arguments?
Not sure if this will help, but if you use Dr.Racket to code, you can allocate more memory to your program.
For anybody who needs help with French programming vocabulary, there's a useful bilingual glossary [here](http://www.info.ucl.ac.be/~pvr/lexicon.html).
&gt; It's kind of sad that R6RS does specify a unified packaging system Does it really? I was under the impression that R6RS specifies a module system, not a packaging system.
There are plans to setup a new Snow repository aimed (at least initially) for R7RS libraries. Hopefully I'll have time to work on this over the holidays.
For Gambit? Does that mean that Gambit is going to go R7RS?
Hi! I'm the developer behind SchemeSpheres.org. The project aims at solving this issue with Gambit. As soon as R7RS is available in Gambit, schemespheres will be ported to the module system. At the moment it uses plain Gambit modules. 
That sounds like a job for ZSH, if you don't really care about using Scheme. KNOWN_DIRS=(~/Projects/Python ~/Projects/Proj1/ ~/Documents/) function chpwd(){ if [[ ${KNOWN_DIRS[(r)$PWD]} == $PWD ]] ; then echo "I am in a known directory ($PWD)" if [[ $PWD == "~/Projects/Proj1/" ]]; then export SOME_VAR=22 fi fi }
As I recall, scsh was designed for scripting, not interactive use. It may be too awkward for that.
I suspect that you could write the program you need to manage your configurations in scsh, and configure your interactive shell (bash, zsh, etc.) to call that scsh program when you change directories. Unfortunately, scsh doesn't have a 'true' interactive shell syntax like bash, it's an interpreter with a REPL. Writing your program in scsh would probably be much nicer than trying to hack a shell script, especially if your configuration needs are at all complex. I use scsh, and it's insanely easy to call out to external programs using the process notation. It really is much better than shell scripting. Plus you get a real programming language with a module system, debugger, etc. Slightly OT, but I've got a Texinfo version of the manual on github here: https://github.com/rmloveland/scsh-manual-texinfo This might make reading the docs easier for you -- please ignore the README, it's now completed and builds into all the Texinfo output formats (HTML, Info, PDF), with function and variable indices, etc. Finally, re: scsh, you may need to pass the -m32 flag to GCC to get the 0.6.7 version building. Don't worry, it works fine on 64-bit though, I use it on a new MBP as well as an older Fedora laptop. Let me know if you run into any issues, I'm no guru but I've used it a fair bit.
Reminds me of a cde() system where subdirs would accumulate specific, well inherit/extends env pushed by previous .env dirs.
This looks pretty interesting! Can you make a comment on how this compares to Kawa? 
This looks so incredible to me. Is this tightly coupled to Gambit or is there a possible future of also being able to use Chicken with these tools? I'm not partial to either, I'm entirely fresh to scheme really, but I recently hung out with some of the chicken crew and was pretty impressed. 
Could you put this in hastebin or something instead? I can't read it as its currently formatted.
You can even do this more portably, for zsh: function my_chpwd() { echo "Butts" # or whatever } add-zsh-hook chpwd my_chpwd
Could you please also measure the compiled code? I'd like to see how they compare.
I'm afraid you'll have to look elsewhere for that... The Rhizome/pi Scheme compiler is the only one that I use, because it is small, strictly r5rs, and has a well documented interface to Windows for doing Petzold-style programming. The executables that it produces are not very much faster than interpreted code. Usually, the faster the interpreter, the less there is to be gained in compiling to C and binary. But consider: since most scheme interpreters are simply scheme programs compiled by their own compiler, the speed of the interpreter indeed is a measure for the speed of compiled code. 
Yes, I might want to. But I was thinking, suppose you compile your interpreter program with Stalin. which reputedly optimizes very agressively, then the interpreter would be very fast. So maybe the inverse might also be true, that a less speedy interpreter must have been created by a compiler that produces "lesser" code. Of course this reasoning is incorrect unless you start with the same interpreter source code. 
It is currently tied with Gambit for some core functionality. But it would be possible to make it more general, losing some of its functionality. The point is that in order to enjoy Android and iOS cross-compilation (working on it right now), FFI, and stuff like remote REPL it usually involves code very implementation-specific. I started this way to make it real from the beginning, something usable. But that doesn't stop the project being ported with the help of some Chicken user. For instance, I was thinking about Bigloo, due to the scheme2js backend (with restricted functionality, you won't be able to use all modules of course). But then Gambit is going to release a javascript backend soon, making it easier.
It is a recurrent topic in the community indeed. The point is that Gambit doesn't support any module system natively. - Snow is not really a Gambit project, is an attempt to make modules that are compatible among a wide range of implementations. And, its a package system. - Blackhole is a real module system. It is great, but unfortunately unmaintained. I've worked with this system for a long time, but it's messy and my intention is not to build a module system but a set of tools to make it easy to build real projects. Ideally, I would have used Blackhole, but its core architecture made it very hard to have deep control of the compilation process (necessary for cross-compilation or remote debugging). Spheres tries not to be a module/package system that much, and affect R5RS code the least possible. Actually, dependencies are defined outside the code itself, so it can be easily ported (wrapped) to any other implementation, or just copied and pasted. Hopefully, R7RS will solve improve the situation. As soon as R7RS comes to Gambit, I'll make it completely R7RS-compatible. It's just not the layer that this project tries to fix.
Makes perfect sense. I'm looking forward to spending a bit of time with it! 
Thanks. I didn't know that plain source code could cause display problems.
As a single data point Gambit with the interpreter took 14:10 on my machine and the compiled version took 14:06. Very little difference. I also ran the compiled version for Chicken which took 15:49. Everything was compiled with optimizations on. These tests were run on a 64 bit Debian/Linux with an Intel(R) Core(TM) i7-3770K CPU @ 3.50GHz
&gt; I guess I should of added that I only ran it for 10^6 in each test. 
The main contributor to CPU time is this line: (erato (+ n 1) z (append primes (list n))) which makes the amount of memory used quadratic in the size of the final list of primes. So, with Gambit, nearly all the time is spent either (a) building the lists using append (which is a library function whose speed isn't affected by whether or not you compile your program) or (b) in garbage collection. E.g., with v4.7.1 20131230220244 x86_64-unknown-linux-gnu "./configure 'CC=gcc -march=native' '--enable-c-opt' '--enable-single-host' '--enable-shared' '--enable-multiple-versions'" you get firefly:~&gt; gsi Gambit v4.7.1 &gt; (load "sieve") "/home/lucier/sieve.o1" &gt; (define a (time (primes&lt;2n 100000))) (time (primes&lt;2n 100000)) 5913 ms real time 5914 ms cpu time (5909 user, 5 system) 6812 collections accounting for 2520 ms real time (2511 user, 4 system) 21040764992 bytes allocated 1489 minor faults no major faults So you generate (and collect) 21GB of memory to calculate the primes &lt; 2x10^5. Compiling Gambit to use 32-bit words rather than 64-bit words results in &gt; (define a (time (primes&lt;2n 100000))) (time (primes&lt;2n 100000)) 4865 ms real time 4864 ms cpu time (4857 user, 7 system) 2890 collections accounting for 1108 ms real time (1101 user, 1 system) 10520382336 bytes allocated 1258 minor faults no major faults i.e., it uses half the memory (but not the 64-bit instruction set, so it's not much faster). So this benchark measure (a) the size of words, 32-bit or 64-bit, (b) the time of a library function (append) and (c) garbage collection. The interpreter? not so much.
I didn't realize at once the full cost of append. Using cons will force you to reverse the list of primes before output, more seriously you lose the second test for primeness. And that really kills performance.
I think it would be nice in R8RS to define it in terms of R7RS-small. Then the runtime library can be portable across all of the existing implementations. The Intel [tick-tock](http://en.wikipedia.org/wiki/Intel_Tick-Tock) of Scheme.
*First paragraph from linked [Wikipedia article](http://en.wikipedia.org/wiki/Intel_Tick-Tock):* --- "**Tick-Tock**" is a model, developed by Ashwani Gupta of Jones Farm 5 (Hillsboro, Oregon) and adopted by chip manufacturer Intel Corporation since 2007 to follow every microarchitectural change with a die shrink of the process technology. Every "tick" is a shrinking of process technology of the previous microarchitecture and every "tock" is a new microarchitecture. Every year, there is expected to be one tick or tock. --- ^| [^About](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^This ^bot ^automatically ^deletes ^its ^comments ^with ^karma ^of ^-1 ^or ^less. ^| ^It ^didn't? [^(&amp;#9873; for manual &amp;#9746;)](http://www.reddit.com/message/compose/?to=/r/autowikibot&amp;subject=Just%20hit%20send%20:%29%20&amp;message=Parent%20comment:%20http://www.reddit.com/r/scheme/comments/1qnwjq/r7rs_ratified/ceia0vf)^.*