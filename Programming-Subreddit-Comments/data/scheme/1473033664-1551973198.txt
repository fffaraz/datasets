This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: https://www.reddit.com/r/Serendipity/comments/516qgw/dotted_pair_looks_like_infix_notation_xpost_from/
The link is incorrect but it's at the top of https://nalaginrut.com
ISSUE-1 is only related to the variable named 'self'. You can call table.insert(t,v) with out 'self', right?
you don't get: class = {} function class:dothing(i) self.thing = i end meta = {__index = class} obj = setmetatable({}, meta) class.dothing(obj, 1) In Lua it will set `obj.thing = 1`. With your "fix" it will be `class.thing = obj`.
No, it won't. First, I confess I haven't gotten time to handle the extra first argument as passed in 'self'. But it's in my TODO. The ISSUE-1 appears because Lua implement 'self' as the first hidden argument. My fix dropped this method by binding 'self' in the nearest scope outside of the function. Because of this, the explicit pass-in 'self' shouldn't be implemented in the original way. The simplest way is to bind new 'self' to the first parameter of the function if the compiler detected there's extra arity. So the function will find the correct 'self' because of the static scope. 
/u/funny_falcon is right: by attempting to "fix" this behaviour you're making something that looks like, but is not, Lua. If you're going to stick with this you *really* should rename it to something else to avoid confusion. Your change also seems to be based on making assumptions about the programmer's intent in a way that can bite someone in the ass later. When you say you "dropped the old design to pass the current table as the hidden argument" what you mean is you broke well-defined, potentially useful Lua behaviour because *you* don't understand why someone might want it. Maybe I'm misunderstanding what you've done, but it looks like you've completely undermined the usefulness of having an implicit self argument in the OO-style foo:bar syntax while also allowing the use of foo["bar"](foo) and foo.bar(foo) when suitable. For example, I've dealt with "OO"-heavy Lua code that defined everything OO style and had a lot of code repetition, especially for UI elements. In order to clean a lot of it up, I wrote a function that used a closure so I could just call, say, make_button(args), which returned a function that I could then use that as the method definition. In doing so, I had to use both foo["bar"](foo) and foo.bar(foo) syntaxes during the method creation, but the end result was intended to be used as foo:bar with its implicit self. It sounds like your changes could break this sort of code because you're trying to do magic instead of what the programmer wants. Sure, it's not an everyday use sort of thing, but that doesn't mean Lua's behaviour is *wrong*, and it's not something you should be screwing with if you're trying to actually implement Lua. If you're just making a something that vaguely resembles Lua, that's fine but you should drop the pretense and give it a new name and an explanation that it's only Lua-*like*.
One of the purposes to post this preview is to get feedback for my later work. It's appreciated that many people (some are not here) gave me many comments on it. I want more, so please don't hesitate to tell me if you have other thoughts, before this project goes to be stable. I have to clarify something here: 1. The language name is trivial for me, it's called Guile-Lua, not Lua. So it never implies this language will stick to the original Lua strictly. I just want to let it be compatible as possible, but no guaranty. If I want a strict original Lua, why bother to write a new one? 2. I want to fix something unreasonable in the original Lua design to let this Guile-Lua be a better one. I'm not writing yet another Lua compiler which follows the wrong way again. 3. Python3 is incompatible with Python2, but it's named Python. Why do you think Guile-Lua should be named differently, say, Aul? 4. There'll be many cool features in Guile-Lua but Lua may never have. Because the benefit to use Guile for implementing languages is to provide these good features. I may write Guile-Python in the future, with proper tail call and delimited-continuations. Let's see which one people will love to try. 5. We have to keep on making a language better, or it's dying. The back compatibility is important to reduce work and make the evolution a steady progress. Not a rule to stop creativeness and enhancement. 
About 1 and 3: The name "Guile-Lua" still implies that it's Lua in some form. That gives the impression that it's "Lua implemented on Guile" which also implies some attempt at compatibility with the standard implementation. Also, Python 2-&gt;3 isn't exactly the same thing, since it's breaking changes implemented by the language creator, as part of the reference implementation. The Python 2-&gt;3 compatibility break is more akin to the 5.1 to 5.2 change in the standard Lua. 2,4,5: Like I said in the other comment, if that's what you want to do, that's fine, but it's *no longer Lua* in that case. For example, Clojure is a Lisp dialect that makes extensive changes compared to other lisps, and it makes no claim to being CL or Scheme. Once you cross that line (which you already have with your "ISSUE-1" change), you're no longer Lua, you're a Lua-like language. A Lua dialect. Which, again, is fine if you go that route. Just give it a new name to reduce confusion. If your ideas on what's better for Lua work out, the Lua devs can decide if they want to implement them as well, regardless of what your Lua dialect is named. The problem here, to me, is that you're taking someone else's language, *deliberately* making compatibility-breaking changes to the language without any real discussion on it, and stubbornly arguing that you should still be able to call it Lua. Actually, there's another option you could take: optional language extensions, like the Haskell extensions in GHC. If you were to do that, Guile-Lua would operate in a way that's compatible with other Lua implementations by default, and then the user could enable extensions via Guile-Lua-specific pragmas at the start of the file if desired. For example, your ISSUE-1 change could be enabled by putting `--# LANGUAGE MagicSelf #--` early in the source file if a user finds it useful. This would also let you learn which extensions are considered useful to users, since you could see which ones are actually being *used* by people.
Thanks for the reply! Let's ignore the naming issue, since Guile-Lua isn't stable and many ideas are not decided yet. I'm not sure if these new features are really welcome and useful for users, so I post them for feedback. I'm not going to add new incompatible features willfully, and call it "a better Lua". What I want is to try something new and discuss about them. Maybe they're not so good and could be dropped. I think the optional language extensions is a good idea, although it may bring more complex work. But it's my habit to research how to implement language features technically. And I hope folks thinking more about ISSUE-1, is it really helpful to avoid exception? Is it really a reasonable activity in logical? My understand is that ISSUE-1 is actually the side-effect of "pass the current table as the first argument named self' in Lua design. You can say it's well-formed in language design, but may not be a good one in practical programming. 
Good call, can't believe I didn't think to mention that along with the GHC extensions. 
As you said, function foo:bar() is trouble in the original design. I'm trying to find a way to let users not be trapped into the trouble if they unfortunately used it. 
And I'm not going to experiment many big changes against the original Lua. So far, I think just ISSUE-1 and 'continue' is worth to try anyway even if it may bring compatibility isuses. In addition, I have two ideas to try, but never break the compatibility potentially: 1. To add delimited-continuations interface. 2. To add type annotation for my later type checking experiment. I choose Lua for it because it's simple enough. This won't break the compatibility since the type annotation will be in comments part and detected by a special parser when reading Lua code. All these are superset of Lua. What folks afraid of seems only ISSUE-1. But I still think it's worth to discuss. 
Maybe the textbook you couldn't be bothered to read before asking other people to do your homework has some hints, special snowflake.
My interpretation was correct, then, and your attempt to fix one trap (mistakenly using `foo.bar` when you want `foo:bar`) is creating another trap because the behaviour of `foo.bar` is now inconsistent. In fact, you're likely creating an even worse trap, because your change means that what `foo.bar` does can change, not based on anything *you* do, but on something *someone else* did, and can even potentially introduce breakage later despite working initially. To illustrate, I'll give a couple example scenarios. Both will be based on the same initial case: a programmer downloads a library to add needed functionality, and that library provides a class that the programmer uses to make an object, `foo`. -------- #### Problem 1: inconsistent behaviour The programmer, accustomed to the dot and colon syntax magically being equivalent, calls methods of `foo` with the period. Because it's not his library, he's unaware that method `baz` was defined differently (using `function foo.baz` instead of a colon), and continues to use `foo.baz(args)` like normal. The code doesn't work, and he's left wondering *why* it doesn't work. `foo.bar` works fine, and everything he made also works. He only discovers the problem after looking at the source of the library to determine that it's because of the period and colon syntax difference. #### Problem 2: changing behaviour This programmer has been using the library to provide `foo` for a while, also with the dot syntax, with no problems. She's only needed to use the `bar` method, so she hasn't encountered Problem 1 yet, and has been happy with the library. At least, she was until she updated the library to the newest version. The library author made some changes to `bar` and in doing so, decided to define it with `function foo.bar()` instead of `function foo:bar()` for some reason. Now the programmer's code no longer works, despite making no changes to her code and the library author only making some changes that were intended to be for internal cleanup. --------- Do you see why I think this is a worse trap than dot and colon syntax acting differently? You're making it so that the same code (`foo.bar`) may do completely different things just based on how the `bar` function was *defined*. Best scenario here is that users eventually stop trusting the dot notation completely because it's unreliable, so they fall back to using `foo["bar"]` and `foo:bar` and treat the dot notation as being dangerous. *Maybe* you could make it work if you make `foo.bar` *always* provide an implicit self and leave the `foo["bar"]` syntax alone for people that don't want that, but I'm not sure what kind of trade-offs that will incur since it means using the dot for pseudo-namespaces will involve passing around a `self` that isn't needed Anyhow, I think I've explained my reservations about the problem as best as I'm able, so I won't continue to be a pest about it :) I don't even use Lua that often, it's just something I have to deal with occasionally, so I don't really have anything to gain here. I just saw the discussion, got curious, and then decided to throw in some feedback.
I mean I'll not do many big changes which breaks the compatibility. The ISSUE-1 is special since I dislike the original behavior. The other new features that I want to try will not break Lua, just add new things. So ISSUE-1 is the only feature which may arouse controversy. 
I'm not on the stage to design new language, at present. I'm researching and practicing the skills how to implement the features according to the language design. But sometimes I'm trying to fix the design which I think is wrong. So please let us focus on Lua. If you want to talk about new language design and inspired by other cool languages. We may have chance to discuss this topic in the future. I still need more complex practices to let me understand compiler writing deeper.
If you are interested in developing a superset of Lua, here are some improvements you might consider: * A shorthand for declaring functions with arity checks. Leave `function` alone, but introduce `fn` which acts the same but raises an error if called with the wrong number of args. * Destructuring against non-array tables. Binding locals to an unpacked table is very handy for sequential tables, but for k/v type tables it's still quite tedious. * A keyword for globals, so you can run in strict mode where non-qualified globals will raise an error. Both these could be implemented in a way that adds to the existing language instead of introducing 2-way incompatibility.
I think of Lua as basically Scheme with a C-like syntax. Like Scheme it has limited syntax, minimal standard library, first-class functions, etc. Main thing it's missing is macros, which is a damn shame. Kind of off-topic, but seriously, I'd love some kind of macro system in Lua, even if it has to be done via preprocessor that dumps Lua code with the macros expanded. One of the biggest problems I found with Lua is that it's hard to introduce new syntax due to the lack of macros. The only option you really have to do something like that with Lua is `loadstring` and that is insanely slow and can't access locals, so it ends up insufficient. That leaves implementing everything as functions, which has its own set of problems. For example, I tried to implement a Clojure-esque `cond` once and spent a lot more time than I should have trying to find a good way to do it, and it all ended up frustrating compared to having a macro system. Ultimately, the best I could manage was to wrap the expression portions in anonymous functions to defer execution, but that also caused it to execute at about half the speed of using if/elseif chains. It was disappointing :/
Whoa! The author! By the way, *thank you* for s7. Amazing work. 
There's no "better or worse". Use whichever looks more pleasing to you. In any case, the first form just gets macro-expanded to the second form anyway. Better yet, make your own 'def', with doc-strings and the like :-) Its the same issue between using 'let' and nested define's. Some like it, some don't (I don't). Personal preference. Lets talk about something far more important instead. Like, how many spaces do you indent by? :)
Thank you. I will check it out. I do have Racket on my computer, but even if I didn't it would be pretty easy to get hold of anyways (it is in the package manager).
Not sure whether this passes your filter, but for Guile there is [Skribilo](http://www.nongnu.org/skribilo/), which also seems to be [Skribe](http://www-sop.inria.fr/mimosa/fp/Skribe/) based. There is a recent [HN thread](https://news.ycombinator.com/item?id=11951556) mentioning both tools. 
The site is broken, just displays raw HTML.
The published version is also available here: http://scheme2016.snow-fort.org/static/scheme16-paper3.pdf Source is on GitHub: https://github.com/8c6794b6/guile-tjit/tree/tjit/module/language/trace
As an aside, you may want to use your editor's Scheme mode if it has one. Emacs+Geiser for example can handle indentation and inline documentation as you type.
You're right, it was because I took my professor's skeleton code to use as an example for testing. I removed those, but now I'm getting a new error: ; Loading "schemeSublime"... ;Ill-formed special form: (let (...)) ;To continue, call RESTART with an option number: ; (RESTART 3) =&gt; Return to read-eval-print level 3. ; (RESTART 2) =&gt; Return to read-eval-print level 2. ; (RESTART 1) =&gt; Return to read-eval-print level 1. I'm using Sublime Text Editor
This is an extremely helpful answer, thank you so much I'll be sure to delve into this and try to solve it. 
Nash should be a maths library. A jit: "sonic boom."
did you try (car disk) 
You gonna ignore all the feedback to your other question, hm?
So simple, should've tried without the parenthesis haha, thank you.
Because I still can't figure it out. I keep referring back to his post as I keep working on this and this project is due tomorrow night. Our professor gave us very little guidance in terms of how to use scheme and I'm really reaching out trying to figure out this language. I. Don't. Get. Scheme.
Look you haven't even gone through the trouble of reformatting your code to make it easier for people to help you. I don't believe you. I think you want people to solve your homework for you and not think about it any more. 
I'll check it out, thanks
Funny, I was about to suggest [that](https://7chan.org/pr/src/The_Little_Schemer_4th_2.pdf). 
PS, The Little Schemer is not a free book. You really ought to buy a copy of it. It's worth the [$14/used](https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992) a hundred times over...
To paste code into reddit: put 4 spaces at the beginning of each line Let's talk about lists! Code in scheme, lisp and other lisp-like languages use lists of keywords, values and variables to make code. You are unlikely to use this in your class, but this is really powerful because it allows you to make things like "if" in these languages (which is really hard in many more traditionally formatted languages). Don't worry about those facilities, I am just putting that in for background, so you know "code is data and data is code", that way you understand why we have to say "This is data yo" to scheme sometimes. Scheme uses a "function" (it's not really a function, but think of it that way) called "quote" to mention a list (or other stuff), but not execute it. By default, if you wrote (car (1 2 3 4 5)), the computer would first try to call the function named 1, with the arguments 2 3 4 and 5 (before ever really doing much with "car"). That's certainly not what you always want when talking about program data. So you can use a function called "quote" to make it not execute, and instead return a list of the items: (car (quote (1 2 3 4 5))) Which when you run it, will return 1, as you expect. It turned that list starting with 1 into a constant. Now that would be reeeeeeeeeealy wordy to write out "quote" all the time, so the language developers made some shorthand (commonly called *syntactic sugar* by programmer folks), called the quote mark. That means you can call "quote" on a lot of things by prefacing them with a ' (car '(1 2 3 4 5)) which will return 1 as you expect as well. Okay, onto variables! When you call a function the variables are *bound* to what's passed in. They already have been loaded into the memory of the program, so there is no need to quote them. Remember, we have to quote stuff to separate data from code so the computer knows which is which. If the computer has already read something, there is no need to quote it: it already knows which is which. I'll tell you what several random things that kinda look like the right answer mean that you probably blindly typed in not understanding the above Also, I'll use **first** instead of **car** as it's 1000% clearer. You should also almost always use **rest** instead of **cdr**. You should only extremely rarely go into stuff like caddr etc. **First** and **car** are the same thing. (first (disk)) ; =&gt; this returns the first item in the list returned by the function "disk" if it is a function, or otherwise errors out. (first '(disk)) ; =&gt; this tells you disk is not defined in the module (first 'disk) ; =&gt; this tries to get the first item in the constant identifier (that has nothing to do with your data structure). This gets raised as a contract violation for the function first (or car). (first disk) ; =&gt; what you really want, it goes into the already loaded list that was bound to the variable disk, and then it returns the first item in the list Good luck! Did you get into DrRacket yet? It helps with this stuff. 
So many times, instructors are either 1&gt; not good at teaching something they know well or 2&gt; not good at explaining things in layers in a way that people get. Scheme is a pretty good first language, but you're not "seeing" the parts clearly (which is why I want you in DrRacket, it helps a ton with that). I'd also point out, rather than hours of hitting your head on the desk, doing another free course real quick on it will likely be the fast way through. 
for-each takes a function and one or more lists, not two functions and a list. In visit-tree you need to use a lambda that takes one argument and calls visit-tree with the appropriate arguments. Or if your scheme implementation has a fold function, look into that.
Closing in on getting [tup](http://gittup.org/tup/) to build a .boot file correctly!
I don't know enough about Chez to be all that helpful but I did check it out a while back and it appears fairly simple to distribute something built with it. You just need the binary and the images (boot files), which I imagine wouldn't be that hard to merge together or am I missing something?
generally you should use emacs+geiser or drracket for scheme(/racket), other plugins exist but nothing will give you what they will afaik
This is covered in some detail in SICP, section 3.5 See https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5
Part of the point of scheme is to be a simpler lisp. Scheme starts with just the one namespace; within a lexical scope, a given symbol has the same meaning no matter where it appears syntactically. If 'x' refers to a function, I can call that function (x 1) or pass that function to another function (f x) or do something nonsensical like try to goto that function (goto x). This is in contrast to common lisp where a single symbol could be used as a value cell, a function name, a goto label, etc. -- all in the same scope. The meaning of that symbol depends on its position syntactically. (goto x), (x 1), and (f x) talk about three different things all named 'x'. I can't goto the function x, I can't pass the function 'x' to another function by saying (f x), and so on. I can't call the function stored in the value cell 'x' by saying (x 1), because that calls the function named 'x', not the value held by 'x'. The label, the variable, and the function are three different things, behaving as though they had distinct names.
So the paper is incorrect to suggest that Scheme has five namespaces?
That paper is about Common Lisp. I'd recommend reading chapter 2 of _Lisp in Small Pieces_ because it goes through a lot of this in delightfully explicit detail.
Which part of the paper are you referring to? I may be mistaken, but I thought the 5 vs 6 things was in regards to [EuLisp](https://en.wikipedia.org/wiki/EuLisp) which had many of the complexities of early lisps, but *did* unify the function and variable namespaces. If you're referring to this section -- "other namespaces include tag names (used by TAGBODY and GO) and block names (used by BLOCK and RETURN-FROM)" -- I believe even [early scheme](ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-349.pdf) lacked such complexities, opting instead for exceptions and continuations. 
"Scheme [Rees 1986] and the language being designed by the EuLisp group [Padget 1986] are Lisp1 dialects." Then they later say, "Thus, the names Lisp1 and Lisp2, which we have been using are misleading. The names Lisp5 and Lisp6 might be more appropriate." I took that to imply that Scheme (and EuLisp) actually had five namespaces rather than just the one, but I may be misreading it.
I don't think giving you the answer to your question would be appropriate, however here is a very good article on the subject: http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/
Neat! I had trouble getting the sparklines utf 8 to work correctly w/geiser.. let me know if anyone else has solved that. Could probably use `list-ref` instead of your `nth` implementation, though it doesn't matter. There is a lot of simplificataion in your letrec that could happen as well: (define *bars* '(#\x2581 #\x2582 #\x2583 #\x2584 #\x2585 #\x2586 #\x2587 #\x2588)) (define (spark-line l) (list-&gt;string (map (lambda (x) (list-ref *bars* x)) (map (lambda (n) (floor-quotient n (/ (1+ (apply max l)) (length *bars*)))) l)))) The `+1` hack is a smaller summary of the `if zero?` done in your code.
 (define int-build (lambda(x) (if (= x 1) '() (append (int-build (- x 1)) (list x))))) (define filter (lambda (num lst) (if (null? lst) '() (if (= (modulo (car lst) num) 0) (filter num (cdr lst)) (cons (car lst) (filter num (cdr lst))))))) (let ((delayed (delay (filter num (cdr lst))))) (force delayed)) This is the error I got, any clue? ERROR: unbound variable: num Stack Trace: 0 num 1 (filter num (cdr lst)) At line 17 of "./main.sc"
If you wanted to help instead of insult you could take a look the potential solution I posted above, I'm not attending any institution, I'm just trying to learn scheme for a CS intern, from the manual "Simply Scheme: Introducing Computer Science by Brian Harvey,Matthew Wright" I don't even know why I have to justify myself and I would appreciate an apology. Thanks
 (define multiply (lambda () (let ((result (call/cc (lambda (k) (set! halt k) '())))) (if (procedure? halt) (tester ((multiply (lambda (k) (if (= k 0) (halt k) (multiply (* k 1)))))) (result 1)) halt)))) ok so my plan was, in a procedure called test I defined multiply recursively as you guys suggested me and I created a 'fail' expression in the body of the let. I tried to invoke (halt 0) to escape from multiply thus it makes a value of 0 for result that cause termination when the if returns 0 or not a procedure. how is it? 
If you could clarify what you don't understand, tail-recursive in general, writing tail-recursive function, why tail-recursion is important, or the practical matter of writing code to test whether a scheme function is tail-recursive ( [u/madmax9186](https://www.reddit.com/user/madmax9186) discusses a very general case). In scheme detecting a tail-recursive function (one that only functions in a tail-recursive way (sometimes call tail-form)) is not very difficult. It can even be detected at run-time by a scheme interpreter and optimized. I'd point you to the wikipedia article on Tail call, it covers the topic decently. If the question is related in anyway to a class, check your text book, I'm sure it discusses the topic. It's a vital topic in many functional languages. 
You posted your "potential solution" AFTER I called you out for not doing your own work. You've already more than justified that you're nothing more than a lazy student (and now a simple liar) trying to get others to do your work for you. Here's a hint, junior: your professors frequent this newsgroup. If they or the powers that be in your internship find out that your approach to learning is to get others to do your work, and then whine like a child when you're called out for it, good luck. I hear fast food is hiring. Take your whining and your laziness somewhere else thanks.
You've never defined the variables "lst" or "num" which you use in your last "let" form. If this is for a class, I'd recommend getting help from your instructor/TAs, or classmates (if allowed).
The standard specifies which positions are tail-recursive. See [this section of R6RS](http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.20). You might or might not find [the documentation for Guile](https://www.gnu.org/software/guile/manual/html_node/Tail-Calls.html) more readable.
call/cc is about time travel. Think of a program executing. It is making many small steps towards a goal. Each step corresponds to time going forward. When you call call/cc, it will create a time portal. This time portal is available to you, and you can use it zero, one or many times. If you at some point use the time portal, you will go back (or forward!) in time to the point where call/cc was invoked initially. When you invoke the time portal, you always invoke it with a value, and it will be as if the body of the call/cc returned that value. Since you can invoke it with different values, the program can continue in a different way than what happened earlier.
Imagine you're a function. You've done some calculating, you've got your return value. Suppose it's 5. You're about to return 5, and once you do, your influence is gone. The rest of the program will execute without you. But at the moment, you have influence. The rest of the program will behave differently if you return 7 instead of 5. The rest of the program is 'the continuation'. In most languages, you (the subroutine), just return the value. Or another way of looking at it is you run 'the continuation' with 5 as its input value. In a language where continuations are things you can get your hands on, you could save the continuation in a variable somewhere, and then return. So now imagine you're the programmer. The subroutine returned 5, but it's also stored 'the continuation' in a variable called 'magic'. You call (magic 5), and the second half of the program runs again. (It might not do the same thing, because some values like global variables might be different) You call (magic 7) and the second half of the program runs again, but as if the original subroutine had returned 7 instead of 5. You can use this 'continuation' to repeatedly run the second half of the program. Maybe trying different values to see what happens. And you can use this as a fundamental building block to build all sorts of interesting control structures. The simplest is just a GOTO. The running program can set a label, and after it's over, you can just jump to the label, and the code will re-run from that point. But it's not time-travel. You're not storing the whole state of the program, and when the program runs again, it won't necessarily do the same thing. It's more like storing the program counter in assember language, or the stack in C. It gives you a way to jump into a program in the middle, so that you can do the second half without re-doing the first half. I think that you can actually do something similar in C. I've never used it in anger, but there are functions called 'setjmp' and 'longjmp' that save the current state of the stack so that you can jump back to where you were when you called setjmp from anywhere else. I think they're usually used for error handling, so that from any part of the program you can jump to the error handler. And that's another sort of control structure that you can build with continuations. call/cc is a scheme-like way of getting hold of the continuation. Where in C you might say magic=setjmp(); //or something, been ages since I played with it ........ longjmp(magic); or in a hypothetical continuation-BASIC you might say magic = current-continuation .... GOTO magic or in assembler you might say (if you're not using a return stack. If you are then you need to save and restore that too) STORE MEMORY[x0AD4], PROGRAM_COUNTER .... JMP MEMORY[0xAD4] In scheme you'd say (call/cc (lambda (x) (set! magic x)) .... (magic nil) DISCLAIMER: Haven't actually tried any of these. If people get actual examples working, add them as replies.
I figured out a way to do it. I just made a recursive flatten call and appended the x y z as a list, after list? car list was false. Sorry for the late response!
A list, i suppose? Whatever will turn '(1(2(7(17 72 7))3)) to '(1(2(14(17 72 14))3)). 
Does the hint "the function forEach should create a closure around the list and the required behaviour" mean something to you? If you understand that, the problem is not too difficult.
(define (forEach l) (lambda (f) (map f l)) So forEach is a procedure of one argument, which is a list. It returns a procedure of one argument (lambda (f) (map f l)) The output will thus be the map of f over the list. 
To square a number, you take the product of that number with itself. To multiply two numbers, you repeatedly add that number with itself. So, you can define `square` as: (define y (lambda (f) ((lambda (g) (g g)) (lambda (g) (f (lambda (. args) (apply (g g) args))))))) (define square (lambda (x) ((y (lambda (self) (lambda (z a) (if (&gt;= z (abs x)) a (self (+ z 1) (+ a (abs x))))))) 0 0))) Replace with calls to `add` as needed. 
So, every time you do something a bunch of times you need to know when to stop. In recursion, that's your base case. For mathy things like this, the base case is going to be an identity like x+0=x or x*1=x. We're using recursion to add something a bunch of times, so we're going to check for the first one. (cond ((= x 0) 'done) ; ....... what do if i'm not done ) As you know, multiplication is adding something to itself several times, and a square is just a special case for that. So let's make a `mult` thing (that assumes positive integers). (define (mult x y) ; I want x added to itself y times (cond ((= y 0) 0) ; if I've 'used up' my y number of additions, I'm going to return zero (else ;; here's the recursion. Add one x and repeat, but don't forget to mark off the x we already added! (add x (mult x (- y 1)))))) Scheme returns the result of the last evaluated form. In the case of this type of recursion, the value of the last form depends on calculating the value of a modified call to the same procedure. In effect: (mult 3 2) is 2 = 0? No, then (mult 3 2) = 3 + (mult 3 1) is 1 = 0? No, then (mult 3 2) = 3 + 3 + (mult 3 0) is 0 = 0? Yes, so (mult 3 2) = 3 + 3 + 0 Then to make our square procedure, we can just wrap the mult we created. (define (square x) (mult x x)) Make sense? This assumes a positive integer as input, but it should be easy enough to modify to handle negatives. 
This helped a lot, thanks! 
Look at the (include ) module clause. Think of it as #include in c. The C externs then go into a file named something.sch and they can be (included ) by both x.scm and y.scm. 
Got it to work. The y needs to be defined like (directives (extern (type xo int "int"))) and x.scm needs to have (include "y.scm") in the module definition. 
Try racket or chicken scheme. I use both, all work great. Racket have nice ide (dr racket), but I prefer emacs. Docs look good in both, but Racket have more handy and detailed documentation.
google dr racket +SICP
I used MIT/GNU Scheme and it was mostly fine - the occasional slight problem, but nothing major. Racket was good for the painter stuff, tho - meant you could really see the code work.
I would vouch for Chicken Scheme personally
I did a write up a while back explaining call/cc and continuations. [here](https://commentedcode.org/blog/2014/06/14/explaining-continuations/) is a link
MIT scheme is fine, but Edwin I'm not so sure about now. Do slime + emacs for better repl support. 
Off-topic?
I've played around with it a bit before, and I have used the following as a definition for `call/cc` within a delimited continuation. (define (delim-call/cc f) (shift k (reset (f (lambda args (shift k2 (apply k args))))))) I think I originally found it [here](http://okmij.org/ftp/continuations/dyn-wind.scm), on line 241, but it says that it took it from somewhere else. (EDIT: for anyone playing along later, this definition I've given here is incorrect. See below, or the file referenced in the previous sentence, for the correct version of `call/cc` in terms of `shift`.) That being said, I'm fairly sure that Racket's `call/cc` works as you'd expect with the delimited continuation stuff in `racket/control`. I haven't played around with it in a while, but I think it all works nicely together.
Awesome. This works fine, I just don't know how. Would you mind to explain how it works? I mainly ask because I'm new to delimited continuations, and I'd like to implement a language using continuations as a primitive for control flow. I'm not sure how to implement delimited continuations either -- would you have any pointers?
&gt;The first shift captures the continuation from "here" (ie. the call site) all the way until the nearest reset above us in the call stack, which we then call k. That's our outer continuation. Is our implied `reset` at the beginning of `delim-call/cc`? So that would make it: `(define (delim-call/cc f) (reset ...))`? &gt;Then internally we reset, which delimits the internal shift, causing it to "throw away" (or short circuit) the continuation if the inner shift runs. I suppose let's clear up my understanding of the operators first: If we have, for example: (reset (displayln "a") (shift k (k 0)) (displayln "b")) Is `k` representing the continuation *of the `shift`*? In this case, would `k` be somewhat akin to `(lambda () (displayln "b"))`? Whereas if `k` is not called, it aborts to the continuation of reset? --- Back to our code: (define (delim-call/cc f) (shift k (reset (f (lambda args (shift k2 (apply k args))))))) So I think you're saying that: - `shift k ...` gives us the continuation `k` which represents the continuation *after* the `shift` - The inner `reset` limits the inner continuation here; then `(f ...)` is called. If `f` calls the lambda, we `shift` and ignore its continuation `k2`, which means that we escape back up past the inner `shift`, but return the result of `(apply k args)` Now, since we call `k`, does this transfer control back to continuation of the outer `reset` immediately, or does it just return the result to the continuation of the outer `shift`? :-/ If that were the case, why do we need the inner `reset` and `shift` at all? In fact, this seems to work for me, for both original cases: (define (delim-call/cc f) (shift k (f (lambda args (apply k args))))) Which seems to imply that, indeed, the inner continuation is unnecessary and in the lambda, we simply hand off control to the continuation of the `shift`. What am I getting wrong here? I feel like I am overcomplicating it *massively*.
&gt; Is our implied `reset` at the beginning of `delim-call/cc`? So that would make it: `(define (delim-call/cc f) (reset ...))`? There is no implied `reset` here. The implied `reset` is around the _entire_ program (in a REPL there is often another one around the current evaluation). &gt; I suppose let's clear up my understanding of the operators first: &gt; &gt; If we have, for example: &gt; &gt; (reset (displayln "a") &gt; (shift k (k 0)) &gt; (displayln "b")) &gt; &gt; Is `k` representing the continuation of the `shift`? In this case, would `k` be somewhat akin to `(lambda () (displayln "b"))`? &gt; &gt; Whereas if `k` is not called, it aborts to the continuation of reset? Correct. `k` is the continuation of the `shift` up until the nearest `reset` (so if it was `(reset (shift k (k 0)) (displayln "b")) (displayln "c")`, then `k` would still only be equivalent to `(lambda () (displayln "b"))`). &gt; Which seems to imply that, indeed, the inner continuation is unnecessary and in the lambda, we simply hand off control to the continuation of the `shift`. If you don't add in the internal `reset` and `shift` then you run into the problem that the `(apply k args)` call returns a value and still continues on where it is. Look at this example: (reset (delim-call/cc (lambda (k) (let ((value (k 10))) (displayln "hi") value)))) With my version of `delim-call/cc` it returns `10` and nothing is printed. With your version it returns `10`, but before that it prints out `hi`. The second `reset`/`shift` pair ensures that we don't continue from where we left off, but we properly throw away that continuation.
Alright, I see! &gt;There is no implied reset here. The implied reset is around the entire program (in a REPL there is often another one around the current evaluation). Right, but `k` here refers to the end of the function, not the `reset`. Gotcha. So `(apply k args)` runs the original continuation -- returning a value -- then resumes execution at this call site inside the inner `shift`, correct? But since we have the internal `shift`, and we ignore `k2`, we're throwing away that continuation and returning the value all the way up to the outer `shift`? If so, that actually makes *some* sense now. Thank you. :) Although: Why do we need the outer `shift` if we can simply return from the inner `shift`? --- &gt;In terms of implementing delimited continuations, it depends a bit on what your target is. I've mostly played around with compiling them to Javascript, which is a massive pain. What would your compilation target be? Either bytecode or just a bunch of lambdas. I'm considering writing a new dynamic functional PL that supports them, and instead of implementing control flow manually in the language I'd rather support continuations and write them in the library instead. If I were using bytecode, would I just have to store the stack up to the nearest `reset` stack frame, plus the PC? What about with lambdas? Must I use CPS or is there an easier way? 
And here it is for CHICKEN Scheme: http://paste.call-cc.org/paste?id=2f926c21f5699dad6af70315fda7f49c09a75a61
Thanks. I have to work my way through the book when things settle down for me. 
Go for racket, and stay with it.
I have mapped a map many times! Depending on the task at hand, it could be wiser to work with a different data structure. But for better or worse I've done this many times out of convenience. Gets the job done for me! 
Ah thanks! This is what I suspected. :)
Hmm, Racket's not happy with 'atom?'. It's saying it can't apply the procedure to the list. Any idea why that would be? I looked and it looks like atom checks to see that something's neither a pair nor null. Is that something that could be applied to the sublists? I'm basically trying to reach into the document, and encrypt every word by shifting the letters around in the alphabet. I have the encryptor working on individual "words" (as in, I can feed it '(h e l l o), give it a value by which to shift the letters, and it'll return a correctly-encrypted '(he l l o)), the problem is geting *to* the words in the document haha. My original plan was basically to say something like (map (map encoder words-in-list) lists-in-document), but I'm having trouble figuring out a way to tell Racket what I mean when I say 'words in list' - it knows about the document, but has trouble recognizing sublists.
Why does it have to be R7RS? If all you want is a scripting language for a project, plenty of Scheme implementations are available that offer tons of features, but are not strictly conformant to R7RS.
For exactly that itch I wrote a pseudo-scheme2lua compiler. But it's far from any RNRS conformance, as Lua has no first class continuations and the numeric operations are not exactly behaving like Scheme demands. And no hygienic macros, as I was too lazy to implement them.
https://github.com/leftmike/foment
If you have regular macros then the hygienic variant is just a few macros away.
Use racket via https://docs.racket-lang.org/sicp-manual/index.html
Use DrRacket. 
Having perused the [PDF](https://7chan.org/pr/src/The_Little_Schemer_4th_2.pdf), it would seem that they don't have a specific variant in mind, rather, they let you use whichever you want, but give you what you need to define in the preface.
I like Chicken but you'll need to define a few things on your own, like 'atom?'. I'd recommend you include all these definitions from your .csirc, so they're just there (along with whatever problem you're working on from the book, don't go too fast; you need time to absorb) the next time you run the Chicken scheme interpreter. Same recommendation would apply to any Scheme... I also think that DrRacket and chez-scheme are fine choices.
Yet it does, but I'd also like to try to write the code in advance (just from it's described behaviour), since I'm not new to functional programming but only to the LISP family in general.
I did end up working this out, though I honestly forget what I did. Such is life in computer science lol
Both are procedures, why would you wan't to highlight them? You should highlight a syntax like `cond` or `if` as they behave differently from procedures. But even emacs isn’t 100% consistent here, e.g. she highlights most `with-*` procedures. 
I want my code to be highlighted as consistently as possible. If `log` is highlighted, `square` should also be highlighted. Of course, it's also OK if neither `log` nor `square` is highlighted.
Have a look at `scheme.el` in the GNU Emacs sources. It's what a lot of people use for Scheme coding.
If you're using the continuations *strictly* for escaping, Racket provides "escape continuations", which are more efficient than real continuations, but you can only use them to go up the stack and not down. Just use `call/ec` instead of `call/cc`. 
This macro system is horrible and should be forgotten. It confuse begginers, make them lose their time. Is an ultra complicated macro system and way less powerfull than simpler alternatives like syntactic closures.
Thanks. I think the Racket guys are working on a new foundation for macros. I remember a talk about proper multilayer scopes for macros.
IMVHO it is probably the main point of Typed Racket's existence.
[ADTs in Typed Racket with Macros](https://lexi-lambda.github.io/blog/2015/12/21/adts-in-typed-racket-with-macros/)
This description in Abdulaziz Ghuloum's compiler tutorial is my favorite description. It isn't quite 100% complete but it is very easy to understand since it is broken down into a list of simple cases. All other cases are not tail calls. It might help you better understand when something is tail *recursive* as well by checking whether the thing Excerpt: A procedure call is called a tail call if it occurs in a tail position. A tail position in our language is defined recursively as follows: • The body of a procedure is in tail position. • If a let expression is in tail position, then the body of the let is in tail position. • If the conditional expression (if test conseq altern) is in tail position, then the conseq and altern branches are also in tail position. • All other expressions are not in tail position. Edit: I just realized that this thread is quite old. But maybe someone perusing the subreddit will find the comment useful anyway.
Maybe [Shen](http://www.shenlanguage.org/)?
&gt; I can't immediately think of why this wouldn't work: In the following code: (call/cc (lambda (outer) (call/cc (lambda (inner) (outer #t))) #f)) With *true* `call/cc`, We could deliver values to the outer continuation in the inner ``call/cc`` using ``(apply outer ...)``. But this definition can't because of ``reset``.
Please note that I have already acknowledged my error with that. I replied to my own comment with the correct definition. I haven't checked that it works correctly for your example, but I assume it does.
Yes, it works for single value. I tried this puzzle (implement ``call/cc`` in terms of reset/shift) before, and made the same error definition: (define (call/cc* f) (reset (f (lambda v (shift _ (apply values v)))))) I found out the error with above example (call outer continuation inside inner ``call/cc``). I hoped it helps and posted it.
Yes. Firstly, there are two ways to deliver values to the continuation of ``call/cc``: * ``(call/cc (lambda (k) ... (k vals...) ...))`` Call the escape procedure ``k`` with zero or more arguments. * ``(call/cc (lambda (k) ... (values vals...)))`` Don't call the escape procedure ``k`` and call ``values`` with zero or more arguments in the *tail* position. The definition in ``dyn-wind.scm`` is equivalent (with some renamings) to: (define (call/cc1 f) (shift outer (outer (f (lambda (x) (shift inner (outer x))))))) To accept programs like ``(call/cc (lambda (k) (k zero-or-more-values)))``, we should change (lambda (x) (shift inner (outer x))) to (lambda xs (shift inner (apply values xs))) To accept programs like ``(call/cc (lambda (k) (values zero-or-more-values)))``, we should change (outer (f (lambda xs ...))) to (call-with-values (lambda () (f (lambda xs ...))) (lambda xs (apply outer xs))) And ``(lambda xs (apply outer xs))`` becomes ``outer`` after *eta reduction*. So the full definition is: (define (call/cc* f) (shift k (call-with-values (lambda () (f (lambda v (shift _ (apply k v))))) k)))
Scheme isn't too difficult to perform static analysis on. For well-behaved programs, popular refactorings are possible such as rename, extract function, inline, extract variable (extract a local let). I'm not sure if refactoring tools exist but I'd expect them to support a narrow list of implementations for cross-module refactorings. One hurdle to writing such tools for scheme are the different module systems for each implementation. Some schemes do support optional types. Typed racket is the most popular. Scheme's standard type system is strict and I don't think it is terribly difficult to reason about. But I agree that large codebases written in late-binding languages like scheme, ruby, and python can be a pain to understand since you can't be certain what type of data is valid for any given variable name unless you are familiar with the codebase.
That's a very broad question, and I don't know where you're getting stuck. Maybe these hints are too basic. * Try asking yourself how a [symbol table](https://www.tutorialspoint.com/compiler_design/compiler_design_symbol_table.htm) is organized. What information does it need to record? * How would you implement a predicate for it? * What procedures would you need to insert data? What if a given symbol already exists? * What procedures would you need to extract data? What if the symbol does not exist? 
Have a look at GNU Guile. Very probable that it'll just run.
See sections 3.9 and 2.1 in the s48 manual. Basically you create a custom S48 image containing the program and defining an entry point, then execute the s48 vm passing it the name of that image to use and any variable arguments.
I don't know Scheme48 but if it's portable just run it on Chez, Gambit, Guile or Chicken. They allow running it just as easily as Python (you can even compile to a static binary), plus Chez and Gambit are just ridiculously fast
You've got two variables, r and h - you'll need to hold one constant to take the derivative, so you need a function that just takes the varying value, and has built into it the value of the non-varying value. At least, that is what I think you want to do.
That's a rather advanced book for this question! OP, the basic thing you need to realise is that let can be implemented as syntactic sugar for lambda. e.g. (let ((foo 5)) (* 2 foo)) is equivalent to ((lambda (foo) (* 2 foo)) 5) Both are ways to bind the variable foo in the multiplication form. So the one can be implemented by conversion to the other. HTH
thanks, a friend of mine linked me to a really good example aswell
Could we have results for Chez as well?
Wonder, why plt not in list.
Probably because Racket does not ship with an R7RS implementation. Alexis King has made an R7RS language for Racket, so it maybe next time? https://github.com/lexi-lambda/racket-r7rs
You should study what a dotted list or a cons cell is. (cons 1 2) = (1 . 2) (cons (list 1 2) (list 3 4)) = ((1 2) . (3 4)) = ((1 2) 3 4)
If x is a proper list, (car x) is the first element of x and (cdr x) is the **list** of elements coming after the first element (aka the tail). For example, if we do &gt; (define x '(1 2 3)) then we get &gt; (car x) 1 &gt; (cdr x) '(2 3) &gt; (cdr (cdr x)) '(3) &gt; (cdr (cdr (cdr x))) '() With this in mind, note that (cons (list 1 2) (list 3 4)) constructs an object whose car is (list 1 2) and whose cdr is (list 3 4). That object could be interpreted as a list whose *tail* is '(3 4) and whose *first element* is '(1 2). This would be written '((1 2) 3 4) 
I suggest renaming "Scheme" to "Racket" ;-)
Ah that makes perfect sense. Thank you!
dude, I am shocked to find that scheme48 totally sucks in benchmarks
dang - line break is impossible here look at https://scsh.net/docu/howto.html Mr Gasbichler's post on executable scripts
I don't understand why you say that, this is not at all the information I get from the [ecraven](http://ecraven.github.io/r7rs-benchmarks/benchmark.html) benchmarks -- I get that stalin is consistently faster. If you compare the `stalin-unknown` and `scheme48-unknown` columns of the first table, you will see that stalin is often among the 5 fastest implementations, while scheme48 is almost always between the 10th faster or the 20th faster. In the "number of benchmarks this implementation was the fastest on" summary below (called "times-faster-than-any-other"), `stalin` was the fastest implementation on 15 benchmarks, and scheme48 was the fastest implementation on 0 benchmarks. It would rather be a tie between `stalin` and `chez`.
This is awesome. Thank you for sharing this with us. 
What were the specific platform dependent speed hotspots in JavaScript, in case you kept account? What browsers, OSes etc. did you test with? I assume these inconsistencies were sometimes serious slowdowns, did you find that Scheme / Gambit-C outperformed JS in general, or was it equal or worse, but more predictable? In JS land, did you follow practices eg. preferring `for` loops over `forEach`, `reduce` etc., and did you do profiling and jsperf checks to try to resolve?
It's been years since I looked at the JS version, but I think the issues were with features like `bind` on functions (not always supported in older JS engines) and with rendering performance. I think for the most part, I followed good performance practices. I can dig up the code if you want to take a look? I recall using the Chrome profiling tools to find and fix a few hotspots without much apparent improvement on portable platforms. My experience with Lambdanative was that performance improvements made on the desktop almost always correlated with improvements on mobile. On the other hand, I had to write my own profiling code there myself and that isn't trivial. 
You should crosspost this on /r/roguelikedev
Gambit-c can use c-libraries, but integrating them into the build process for lambdanative isn't super-well documented and writing the glue code isn't fun, so I went with Scheme level code wherever I could. The game loop looks almost exactly like the one in [Devil's Pong](https://github.com/VincentToups/DevilsPong). I described Corpse Wizard in lots of detail in a bunch of tweet chains tagged with #CorpseWizardDev, if you want more details. There is a lot of functional programming in Corpse Wizard, though usually purity is compromised for performance.
Thank you very much for the write up and I wish you success with it. As I understood, everything is compiled to machine code, right? So you could not do any live or interactive development to try things out on the fly, or?
Gambit can run a repl on top of compiled code - lambdanative has a module which starts a repl on a local port, and instructions for how to connect to it with Emacs, so that you can do interactive development.
So I thought I'd give a more detailed answer on the question of the game loop. Lambdanative allows you to define callbacks which are executed on each frame and on in input event - fairly standard stuff. Corpse Wizard has two game loops, conceptually - the one doing the rendering, and the one which executes once per turn. It was important to me that Corpse Wizard feel a little dynamic, and so input events are buffered so that you can input a few moves at a time, if you'd like. Each time an event is received, it is added to a queue and the tail of the queue is popped. The event is interpreted and side effects into the game state are calculated. This process produces something called a "dureme," which is a struct which represents an animation. If the player action doesn't result in the end of the player's turn, then this dureme is started immediately. If the player action does result in an end of turn, then the monsters are iterated through, each of which side effects the game state and produces a dureme. A little dependency analysis figures out which duremes depend on which other duremes (for instance, if monster A attacks monster B, then the animation of monster B moving must be finished before the animation of A attacking B can play) and then the duremes are combined using two operations (called `simultaneously` and `in-parallel`) to produce one giant dureme representing the animation for the entire turn. This is then played, and input is buffered until its finished playing. This repeats until the player is dead. 
I'd like to, but I guess I'm worried about seeming to self promote a commercial product. Here among Schemers I hope that information about using Scheme makes it worth everyone's time, but I'm not sure Scheme is popular enough elsewhere.
Wrong sub
It's just a spammer.
Something like (define sys* *) (set! * (lambda ...)) would probably do the trick 
I presume that the new definition of * would need to have something like "if the arguments are functions, then...; if the arguments are numbers, then..." Is there a way in scheme to just write a version * for functions in such a way that the interpreter calls the appropriate version based on the arguments? I'm guessing not?
I can't manage to comment directly on the blog (it gives me a blank page when I submit), so I may as well comment here. (The comment was directly addressed to the author, which feels weird on reddit, but whatever.) &gt; I [previously mentioned](https://wingolog.org/archives/2016/10/12/an-incomplete-history-of-language-facilities-for-concurrency#4b0f1239f865df8c986cff3412c02febc7f2b610) the work in the OCaml community to present fibers using algebraic effect (as a structured approach to delimited control). You may be interested in a new article presenting asynchronous I/O as an extension of this view: &gt; &gt; http://kcsrk.info/papers/system_effects_may_17.pdf &gt; &gt; (Are you planning to attend ICFP, which is in Oxford, UK in early september? The authors will be there, as well as the Scheme workshop of course.) 
Is this what you are looking for? https://srfi.schemers.org/srfi-111/srfi-111.html
The thing that ML calls `ref` is generally called a `box` in Scheme: (define (box v) (vector v)) (define (unbox box) (vector-ref box 0)) (define (box! box v) (vector-set! box 0 v)) There are more complicated implementations available, but that's simple and useful.
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: https://www.reddit.com/r/Serendipity/comments/6ljbii/i_developed_a_medium_sized_cross_platform/
I was just looking at lambdanative this morning, as something that might actually get me to dev on mobile.. thanks for this writeup!
This is one of the first Scheme books. Published by MIT Press in 1989. Just got it from a used books store.
it has the best description of continuations i have ever seen.
Friedman was my professor in college. I'd recommend any of his works.
Friedman was one of the authors of The Little Schemer which is a classic compsci text. I've seen Scheme and the Art of Programming referenced a bunch of places as well (but never read it myself - definitely planning to at some point though)
I haven't finished it, but I've started it. It's definitely a no-bullshit guide to Scheme, and for me, from what I've read so far, it's a textbook reference to how a good book about a language should be written, and has possibly the best foreword I have ever read in a book - the foreword is from Guy Steele, one of the designers of Scheme. 
How does this text compare to Structure and Interpretation of Computer Programs?
i'm answering my own question, but i think yes. it's only a matter of getting a hold of the environment before the transformer. the utility functions (identifier= and friends) don't look hard. i guess i'll try it out. ps: ir-macros for chibi! https://gist.github.com/baguette/2632464 ... the fun never ends.
https://github.com/write-you-a-scheme-v2/scheme/blob/master/sources/Scheme-and-the-Art-of-Programming-Springer-Friedman.pdf
Scheme is a high level language no matter what. So it will never be "bare metal". However, Guile is built on C binding, which allow you to only be one step removed from C, which is probably what you want.
PreScheme? Google: prescheme readscheme 
Oooh! There is a recent PreScheme to GCC compiler available! https://github.com/nineties-retro/sps 
Schemers.org lists 3 hardware-targeting implementations: Armpit, BiT, and Microscheme: http://community.schemewiki.org/?scheme-faq-standards#implementations
http://www.call-with-current-continuation.org/bones/
&gt;Scheme is a high level language no matter what. So it will never be "bare metal". 1. Lisp's core data structure was literally based on [IBM 704 assembler](http://www.mschaef.com/blog/tech/lisp/car-cdr.html) machine code. 2. [Lisp machines](https://en.wikipedia.org/wiki/Lisp_machine). 3. There are Common Lisp compilers which compile to native machine code for modern systems. There's nothing about Scheme which makes it inherently unable to be "bare metal".
scsh hasn't had a release since 2006. It might be time to find a replacement.
yeah, some parts of the code have been oved to guile but there's a lot of work left to do.
~~Just say, *"I don't know."* That would be more helpful than what you posted.~~ **Edit:** I am always annoyed when people ask for help with program *"X"* and the response they get is along the lines of, *"No one uses that anymore, use this instead, or find something else."* Sometimes that response is very valid, but people should at least ask *why* using *"X"* is important to the user instead of completely dismissing it out of hand. Regardless, your response triggered that pet peeve. But that's no justification for being rude, so I apologize.
Huh, really? I try to keep up with Guile's development but haven't done a great job it, so I wasn't aware of any move towards Guile. Thank you for the info---I'll have to check that out.
Sure, but there are still maintainers, and it works fantastically. https://github.com/scheme/scsh Please consider filing bugs for things that you're finding that aren't working.
My understanding is that SICP is less of a "Scheme book" and more about ideas you could apply in any (functional) language, but happens to use Scheme.
You can't when using `quote` (which is what the prefix `'` is short for), but if you use `quasiquote` (or the prefix `` ` ``) you can use `unquote` (or the prefix `,`). Applying that to your code you get: (define message-text "hello") (element-insert! "#render-output" (element-new `(p ,message-text)))
It should be mentioned that `quasiquote` is just a normal macro defined in userspace. Quoted syntax is just a list, you can use `cons` and `map` and so forth. It might be a worthwhile project to write your own `quasiquote` implementation some time if you want to understand macros better. 
You forgot [`unquote-splicing`](http://www.biwascheme.org/doc/reference.html#syntax) (`,@`), for when you want to splice in another list: `(0 1 2) ;; Same as '(0 1 2) `(0 1 2 ,(+ 2 2)) ;; '( 0 1 2 4) `(0 1 2 ,(list 2 2)) ;; '(0 1 2 (2 2)) `(0 1 2 ,@(list 2 2)) ;; '( 0 1 2 2 2) In some Schemes, like Racket, you can also do `(quasiquote (0 (unquote-splicing 1)))` and get `(0 . 1)` ([ref.](http://docs.racket-lang.org/reference/quasiquote.html?q=#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._quasiquote%29%29)) but that gives an error in biwas. Finally, [here's a link to the above examples on repl.it](https://repl.it/Jxtd/0).
Awesome, thanks to you and the others for your replies. Btw, I see my question was downvoted - are noob questions not welcome in this subreddit? I don't care about fictional reddit points but don't want to annoy the community.
you are very welcome to ask these questions!
Wtf?
Us senior citizens plan to save Scheme! Gotta check &amp;amp; first, of course. Details to follow. 
This is what happens when hou don't use Scheme for your bots. 
It is custom to name the continuation `k`, so let's do that: (define (xyz x y k) (let ((a (+ x y))) (k a))) Also let's name the function after what it actually do: (define (add x y k) (let ((a (+ x y))) (k a))) If all functions in your program take an extra argument, the continuation, and instead of returning, simply call the continuation, then the program is in continuation passing style. Here the one function `add` in the program is written in continuation passing style: It takes a continuation `k` as an argument, and it uses the continuation `k` in a tail position to pass the sum `a` to the continuation in `(k a)`. In Scheme a call in tail position is called a tail call. A function call that haven't returned yet is called an active call. In Scheme you can have an unbounded number of active tail calls. Implementations that support an unbounded number of tail calls is called properly tail-recursive. Does the tail call gets "optimized"? Well, are you thinking of optimization with respect to time or space? The answer depends on the implementation. 
Well, I was thinking of optimization in chicken scheme. I remember reading somewhere that direct calls are more expensive than tail calls in chicken scheme, so I was wondering if that qualified as a tail call. Thanks for clarifying the terminology
Take a look at: https://wiki.call-cc.org/programming-for-performance 
The first form is definitely more widely used of the two, especially for defining new functions.
the first does seem more popular, though personally I had my emacs set up to display lambda as the greek character and I liked to have it (and I put it on its own line) (define second (lambda (lst) 'lambda displayed as greek character in my emacs (cadr lst))) but that doesn't seem to be as common
The first is more popular, most likely because of a combination of three things: 1. It's shorter to type 2. Removes a level of nested parentheses 3. It makes function definition seem "special", which is more familiar to people coming from languages where functions aren't first class. Using the same syntax to define variables *and* functions is just weird and scary, at least initially. ;) That said, the sugar-free version is still the way to go sometimes, such as when working with higher-order functions that return functions you want to give names to. Example: ;; Partial application (define (partial f . a) (lambda l (apply f (append a l)))) (define inc (partial + 1)) (define double (partial * 2)) (inc 42) (double 21) 
Definitely the first, but you should be aware of the second form especially when you get down to real Functional Programming. A function is just a value after all, not special.
That looks good! Would you mind sharing the line in your .emacs that does that? ;-) Thanks
The grandparent commenter probably uses the poorly documented and rarely understood `prettify-symbols` mode, which uses a buffer-local variable, `prettify-symbols-alist`, containing an alist of strings and character replacements, like this: (setq prettify-symbols-alist `( ("lambda" . ?λ) ("|&gt;" . ?▷) ("&lt;|" . ?◁) ("-&gt;&gt;" . ?↠) ("-&gt;" . ?→) ("&lt;-" . ?←) ("=&gt;" . ?⇒) ("&lt;=" . ?≤) ("&gt;=" . ?≥) )) That list turns `lambda` into `λ`, `|&gt;` into `▷`, `-&gt;` into `→`, and so on whenever `prettify-symbols-mode` is enabled. (I use `(global-prettify-symbols-mode t)` in my init.el to enable it globally.) The annoying thing is that, for each mode you want to use it in, you have to add a hook to set the alist. You can also do multi-character replacements with a bit of trickery, but it's clunky as hell. That's why I got frustrated and made [prettify-utils.el](https://github.com/Ilazki/prettify-utils.el/blob/master/prettify-utils.el), to try bringing some extra documentation and helper functions to a cool mode that is a pain in the ass to use. Now I can just do `(prettify-utils-generate ("lambda" "λ") ("|&gt;" "▷"))` etc. anywhere I need a prettify alist, which improves consistency by making single- and multi-char replacements identical on both sides. Even if you don't use the library itself, it's worth looking at if you plan to use prettify-symbols for anything, because I also used it as a way to better document how prettify-symbols works and where to find further information in the official docs. Along with explanations of how things work, it also includes a couple examples of how to set up prettify-symbols for a single mode, or the same list for multiple modes.
The first expands to the second. You can even make your own define that does something special. However most people think the first one looks nicer for top level definitions.
I am pretty lazy with my emacs so I mostly grab what other people have done, but https://www.emacswiki.org/emacs/PrettyLambda is what was passed around at my university. and then I dropped (require 'pretty-lambdada) (pretty-lambda-for-modes) into my .emacs after putting the .el file from the above into into .emacs.d ( https://www.emacswiki.org/emacs/pretty-lambdada.el ) The other response looks good too, that seems to do way more. 
I've tried putting the pretty-lambdada.el in .emacs.d and adding that to my .emacs but seems emacs can't find the file. I have a lot of problems with emacs in Win10 at work. At home either on osx or linux it is much simpler.... 
 (define ((partial f . a) . l) (apply f (append a l))) also works, in Racket.
Yes, it works if you edit the `configure` script's `CFLAGS` to add `"-m32`", which tells gcc to build a 32-bit binary. After doing that, it should build cleanly. I haven't tested the resulting executable in any rigorous way, but I use it for scripts without any issues on Linux and Mac OS X.
At nursery school children learn all kinds of important academic social skills. In fact, it is at nursery school that the foundations of your child’s education will be laid http://www.angelsacademy.co.za/2016/10/five-good-reasons-child-attend-nursery-school/ 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/olzd] [A small nanopass example](https://np.reddit.com/r/olzd/comments/6xgy5w/a_small_nanopass_example/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
he gives a class on this: https://groups.csail.mit.edu/mac/users/gjs/6.945/ 
{lambda talk} demonstrates - that lambda calculus can be a pleasure, - that there is a life out of closures, - that recursion needs neither booleans nor Y-combinators, - and more. Your opinion is welcome.
The github repo does have a 64bit version last I checked. I'm also pretty sure I have built the 64bit scsh at least 5 years ago from that repo.... I also think it's been 5 years since I've used it. I thought the answer was pretty good, but thanks for cleaning up your answer too.
This sub is not what you thought it is.
You'd do better to study well enough to be able to read a subreddit's sidebar, tbh.
Wow! Sagittarius scheme looks like a bucket of fun. Lots of neat little things that makes it look really nice to work in.
I am no programmer, but write me a PM with the details and your ideas about approach and I will see what I can do.
I have quite a bit of programming experience. Am learning Scheme at the moment by going through Racket and Art of Programming in Scheme. Ping me if you want, may be I can help. 
https://news.ycombinator.com is written in arc but the interpreter is written in PLT Scheme / Racket . https://github.com/arclanguage
There's a few Chickeners who use Scheme in production; the service names elude me at the moment, but I recall one was a British service for schools. It has a a bunch of [extensions for web](http://wiki.call-cc.org/chicken-projects/egg-index-4.html#web); `awful` being the one getting most focus these days. Ask on #chicken on Freenode to see who's using what.
There recently was [a thread in the racket-users mailing list](https://groups.google.com/d/msg/racket-users/qD9JhjCnwQ0/z2NmTAz6CQAJ) about web server performance, so you may look and see if there's a solution to the performance problem you encountered.
Purdue ran a homework on the web app from about 2002 to 2011 in interpreted Gambit, using S-expressions and RCS to hold student data. One process was running Gambit and there were 5 Maple "backend" processes for symbolic data (so there was no "startup" time for each Maple request). The course was trigonometry (pre-calculus), about 600 students in the fall and 800 in the spring. Handled 40,000 requests/hour easily (no performance data with finer timescales, things got hot just before the midnight homework deadlines). There were lots of hack attempts on this open port, but all data was scrubbed/parsed/verified before being passed on, and there were no known hacks. (Edit: politics removed.)
I think the British service for schools you are referring to is Knodium -- they had a nice [presentation]( https://media.ccc.de/v/c116_lisp_-_2013-08-25_11:15_-_building_knodium_com_with_scheme_-_andy_bennett_-_1281) about how they used Chicken. I'm not sure they are still in business, however. 
Thank you, very useful - I'll try Racket with scgi, that looks a lot better than the servlets.
Tried it out with the example code here https://docs.racket-lang.org/scgi/index.html behind nginx. Very speedy - will continue with this.
It was; and oh damn, too bad.
Gerbil webserver yes.
Link gives me a 404.
gdm it .. how did I mess this up. https://github.com/ryansuchocki/microscheme Thanks ps: reposted here https://www.reddit.com/r/scheme/comments/737e65/microscheme_a_subset_of_scheme_for_the_arduino/
No problem. Cool project! I've wanted something like this for some time now.
Same, I have a bunch of cheap atmel/esp here so having scheme on them is hmmm
The reference documentation is really well thought out and to-the-point. I like how it handles the lack of garbage collection and it would be even better if it could detect lambdas that do not need closures and lift them or inline them automatically. Kind of like how guile handles lambdas: https://wingolog.org/archives/2016/02/08/a-lambda-is-not-necessarily-a-closure
probably not too hard to add at "compile" time right ?
Sadly, the video appears to have disappeared.
Here's a [mirror to it](https://www.youtube.com/watch?v=cblhgNUoX9M).
This just tells me "This video is unavailable." Fortunately, I already had it downloaded before anyway so I was merely pointing to a possible problem for others. (Sadly, I hadn't done so with many other LispNYC videos that have disappeared from Vimeo as well.)
Sorry I forgot to set it as public.
It is very nice. Great documentation, and a lot of batteries added that are useful for practical needs today. 
There is package manager “[Pegasus](https://github.com/ktakashi/pegasus-library)” and a [repository](https://github.com/ktakashi/pegasus). At the moment only 9 packages by sagittarius author are registered in the repository. If you make something interesting, please make it public. 
I'm running backend server of http://news-reader.nl/ with Scheme. Setup: Reverse proxy server: NGINX Backend: Scheme (Sagittarius) Backend server: Paella (https://github.com/ktakashi/sagittarius-paella) Frontend: Angular Database access: https://github.com/ktakashi/r7rs-postgresql I haven't got that much traffics so not sure if performance is okay or not. 
Yes, the macro system allows arbitrary computations at expand-time, which is a layer of what other languages call compile-time. On the right-hand side of a `define-syntax` syntax use you can put any expression to be evaluated at expand-time. Such right-hand expression is first expanded, then compiled (if the implementation is a compiler), then evaluated. You can rename the syntactic identifier `syntax-case` using the import spec `rename`: #!r6rs (import (rename (rnrs (6)) (syntax-case sc))) (display (sc #'ciao () (?id #'(quote ?id)))) (newline) Some Scheme implementations allow aliasing in addition to renaming; but aliasing is not in the standard. 
The question basically boils down to, does the macro expander need an environment and evaluation model that is just as powerful as the main language? I hope not, because the expression context limits definitions in the macro expansion context according to R7RS and R6RS. I don't want to have to do the "tower of evaluation" model like Racket does -- it's just too much.
Might be an unfortunate answer for you but yes. Low level macro (e.g. syntax-case) allow you to do whatever you want.
If I understand your question correctly, then syntax-rules has the same [limitations/freedoms]( http://okmij.org/ftp/Scheme/macros.html#syntax-rules-compiler), it's just not as straightforward. The end of Joe Marshall's syntax rules tutorial, for instance, gives [an interpreter written as syntax-rules macros.](http://www.phyast.pitt.edu/~micheles/syntax-rules.pdf) 
http://snow-fort.org/link/ is also available on sagittarius.
Well, my peers will not call that production but I built a small weblog in Gnu Guile (backend) and BiwaScheme (frontend) http://presence.hyperdev.fr/
Continuations are a preformance killer. Supporting full continuations will incur a preformance penalty, in many implementations even for code that doesn't use them. The future for continuations is delimited continuations as found in guile scheme48 and racket. The section about.optimizing tail calls is wrong. That is only a problem if you are using a trampoline, and not if the tail call is transformed into a goto or jmp. Most implementations get this right (even the ones that the wiki page claims have disabled it) One of the most problematic things for r5rs is the lack of modules. A proper module system will make it clear to the compiler whether bindings have been redefined and will make procedure calls less expensive. It also simplifies some type inference (since the compiler can safely assume things about your code - this is why set! is usually a bad idea). A good way to learn is to try to.make really fast versions of project Euler problems. They are short, easy to solve up until maybe problem 35, and allow you to quickly test new things. 
this is really interesting, thanks for taking the time to write this out on a phone.
please give your suggestion on scheme
Wrong subreddit.
plz give your opinion on the scheme
Is it for stupid people that can't read a sidebar? because I'm pretty sure it is.
plz give ur view on scheme
My view is that you should take your shitty spam and ram it up your ass until you explode.
hello, why did you wrote me like this? whts wrong with u?
plz give your view
plz check and give ur view
plz give ur suggestion
give ur view
give ur view
the welfare of girls by providing oppotunity of education
opportunity
r/scheme is about the scheme programming language, you're spamming non-related shit stop spamming, fucker.
May be you will post your project and some questions and after getting answers you will be able to do your homework by yourself.
What is the project about? Have you programmed before?
Based on your submission history, you have an odd habit of blaming teachers for your own problems learning and completing work. The woods are always empty when you're a lousy hunter. It's not going to get any easier. You're going to have to actually put your big boy pants on and take responsibility at some point.
Submission history? You are tripping. This past summer I received a full time offer from Amazon post internship. I pay $700 out of pocket to have a professor who can lecture. Not blaming mine, but his disability prevents him. Regardless I sat down and finished it myself today. Cheers
[removed]
chicken's nice. chez is supposed to be wicked fast but didn't used to be open source. both are great, basically.
i guess guile deserves a mention these days too.
I see chicken has a reasonable selection of libraries, what do you think about chez's support there?
I like chicken and kawa (Runs on the jvm, lets you easily use java libraries).
I think JVM is out for me for pragmatic reasons, I work in a laboratory environment and it's often hard to get things installed on new machines, and I'd rather not have to carry around a jre installer with me...
How's guile performance wise though?
[Here's a giant comparison table](https://ecraven.github.io/r7rs-benchmarks/).
Gambit seems decent too.
Guile is my go-to scheme implementation (and my #1 favourite language in general) these days. Honestly I don't have any good reasons outside of "Their website has cute robot drawings on it", so you can probably guess I'm just in it for the fun. Besides that I just use Chez.
both fine choices from what i’ve seen. i like guix too, so i have my eye on guile.
well, yes and no. it’s performance is great but it lacks the libraries and it’s really not as standards compliant as some of the others, especially with its macro system. it grew up preferring defmacro and hygienic macros and keyword parameters don’t play very well together in gambit. you don’t have that problem in chicken. snow was a good idea for a package management system but no one but marc ever wrote any snowballs.
Oh wow, thanks for the info. I appreciate it.
I have working on scheme with chicken and it's pretty good. 
Ok and getting better. A lot slower than chez, a little slower than chicken an a lot faster than pyhton for numerical stuff.
My go to schemes are guile and chicken. Guile is what I do most stuff in, but I can't really let go of chicken since they are probably the nicest community on all of the internet.
Second chicken here. Nice community, easy to begin development, small and fast enough.
Yes, #chicken guys are nice and warm to newbies.
I went through the trouble of installing GNU Scheme when it's easier for a Linux user to install and use Guile.
chez scheme or racket, both have great documentation. I find chez really "complete" but racket "wholesome".
I also have to recommend Chicken. Integration with C/C++ is straightforward since it compiles to C; you can even embed C code. It also has a nice numerical tower. And while it has less extensions (eggs) than racket, I never really missed anything. Oh, and there is an R7RS extension that makes it 99% compatible - R7RS Small is really clean and nice. And last but not least, please join the IRC. It's small and very friendly!
Good suggestions here. Chez has a Google mailing group thing which one of the main contributor often replies on. We should add some of this stuff to the subreddit's wiki
Go with Gerbil. http://cons.io you won't regret it. 
Chibi is a great system to start with.
Stick with an r7rs system. Anything else might as well be proprietary. As you can't write portable software for anything but the most trivial of items. There is a lot of older neckbeards who will cling to pre-r7rs stuff, but you'll be dividing your efforts if you ever want to switch later on. If it's not listed here on http://snow-fort.org/link/ I would avoid it. 
Can you elaborate on the portability problems with something like R6RS? What's R7RS have that makes it so much better? I've looked and haven't been able to find a good summary of differences between standards.... 
Just find r6rs equivalents to anything on snow-fort available on all of those schemes.
I'm a big fan of the Little Schemer books.
Faster than numpy/scipy?
SICP. 
Of course not :) if you want that stuff you should probably go with CL and something like Matlisp. 
I like The Schematics of Computation by Vincent Manis and Jim Little. I call it "SICP for mortals". Has all the big ideas of SICP but is easier going. Has chapters with interesting projects, like relational databases. 
I have not read the book, but [here are his lectures](https://archive.org/details/ucberkeley-webcast-PL6879A8466C44A5D5)
i'm always suprised this book is not more popular. if it wasn't for it, i still wouldn't know what a sql join is.
`(random-real)` on r6rs or r5rs with srfi-27 support If your chosen implementation has neither, then you *might* find a implementation-specific version, if you're lucky. Base r5rs defines only `(random x)`, iirc, which means you'd need to do something like `(/ (random X) X)` where X is a value of the form (2^n )-1 (anything else and the distribution won't be even). 
yeah I checked out (random) ... think ill just use a plain text file to store the 250 values in read them in, if I can't get (random-real) to work
 sash&gt; (import (srfi 27)) #&lt;unspecified&gt; sash&gt; random-real #&lt;closure random-real 0:0&gt; sash&gt; (random-real) 0.7868209548678019 HTH
Try putting your recursive loop within the lambda of call-with-output-file. Then, every time the recursive function is called, it will append to the opened file.
Not sure if it's good practice but you could bring the contents of the file into memory and write the modified contents back to the file. Pseudocode: (define (write-list-to-file file list) (write-to-file file (string-append (file-contents file) (function-that-turns-list-into-string-with-newline-at-beginning list))))
You can't mix and match *cons*, *car*, *cdr* with *kons*, *kar*, *kdr*. *kons* builds aggregates that you dis-aggegrate with *kar* and *kdr*.
[You're not the only one](https://stackoverflow.com/questions/12496482/scheme-procedures-that-return-another-inner-procedure) that has struggled with [this exercise](https://stackoverflow.com/questions/21769348/use-of-lambda-for-cons-car-cdr-definition-in-sicp) For me, this was one of those mind-expanding moments [when it was introduced in SICP](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.3) - you might need to read the whole sections in order to follow. Up until that point I'd firmly viewed cons cells (and lists, trees etc.) simply as structures that stored data inside. It might help to step through what happens when you use the procedures. Here "parameter" is the name given with the procedure definition - so for `kons` the parameters are `kar` and `kdr` - and "argument" is the values that get passed to the procedure when it is called and those values are bound to the parameter name. `(kons 'x 'y)` returns an anonymous procedure (`lambda (selector) ...`) that has access to the arguments `'x` and `'y` bound to the parameters `kar` and `kdr` respectively. Let's call this procedure `p1`. You can see in the body of `p1` that the `selector` parameter is itself also a procedure, which will be called with the *values* bound to `kar` and `kdr` - in this case the arguments `'x` and `'y`. The procedure `kar` has one parameter `c`. Further `kar` will be called with the argument `p1` (the anonymous procedure returned by `kons`.) `c` is passed *another* anonymous procedure as its argument - `(lambda (a d) ...)` - let's call that procedure `p2`. Since `p2` is passed as the argument to `p1` it gets bound to the `selector` parameter`. Now `p2` has 2 parameters `a` and `d` and simply returns the value bound to its `a` parameter whenever it gets called. The actual arguments passed to `p2`'s parameters `a` and `d` will therefore be the values originally bound to `kons`'s parameters `kar` and `kdr` when `selector` is called - so `'x` and `'y`. `p2` just returns the value bound to its `a` parameter - in this case is `'x` The procedure `kdr` works in exactly the same way, the only difference being that it returns the seciond parameter `d` instead of `a`. 
The most straightforward way is to use `with-output-to-file` rather than `call-with-output-file`. In CHICKEN this might take the form: ```scheme (with-ouput-to-file "/path/to/file" (lambda () (for-each (lambda (s) (display s) (display " ")) string-list) (newline)) ``` Note that if you are using the [fmt](http://api.call-cc.org/doc/fmt) or [format](http://api.call-cc.org/doc/format) eggs you will probably find the abstractions easier to work with and extend. I suggest learning `fmt` over `format`, but it's a matter of taste.
I'm replying to this immediately because I realized that I overlooked the question you had above regarding the line being overwritten. It seems your problem is that you're using the `call-with-output-file` as if it opens the file in append mode. This would be a mistake, because it always opens the file in write mode. You could first open a port to the output file, and then pass that port via `with-output-to-port`, but manually opening ports is somewhat of a hassle and can be fragile and error prone in certain schemes (e.g. by R5RS what happens if you open an output port to a file that already exists is undefined). So instead you're better off writing a procedure that writes a list of strings in the format you desire, testing that it works in the REPL, and then wrapping the entire call with a `with-output-to-file`. It might look something like this: (define (print-words list-of-strings) (for-each (lambda (s) (display s) (display " ")) list-of-strings) (newline)) (with-output-to-file path (lambda () (print-words string-list))) or, if you have a list of a list of strings, you could even abstract it as such: (with-output-to-file path (lambda () (for-each print-words list-of-lists-of-strings))) Note that here if you use `call-with-ouput-file` or `with-output-to-file` you'll close the file port after the thunk / procedure passed into `with-output-to-file` is called. When it opens again at the next call, the file is opened in write mode, which means that the file is written from the very beginning (i.e. the previous content is erased and the file is written as if it is brand new). The above is probably the best way to get what you want without relying on weird append behaviour. 
Thank you for your answer and detailed explanation. Now I see how `kar` and `kdr` work in terms of `kons`. But there is a function `add-at-end` earlier in this chapter: (define add-at-end (lambda (l) (cond ((null? (kdr l)) (konsC (kar l) (kons 'egg '()))) (else (konsC (kar l) (add-at-end (kdr l)))))) where `(kdr l)` and `(kar l)` have a list as their argument and we know that they expect a lambda expression. How is that so?
Check out Gerbil. A layer on top of Gambit that brings many libraries, r7rs, #lang support and many other niceties.
He's asking you to do the thinking for him. Choices are hard to make. 
Thanks. Now I see.
*add-at-end*, *kdr*, and *kar* do not accept a "list" (in the standard Scheme sense) as their argument, nor do they accept any arbitrary lambda expression. They take a value that was returned by *kons* as their argument. Review p 144 "What is a non-empty list" and p 147 "Is *kons* different from *cons*"
A scheme list is itself constructed from cons cells - `(list x y z)` is shorthand for `(cons x (cons y (cons z '())))`. Similarly it's reasonable to assume for `add-at-end` that the "list" `l` is not a regular scheme list, but created by repeatedly calling `kons` e.g. `(kons x (kons y (kons z '())))` especially since it's *also* using `kons`, `kar` and `kdr`. I think that's the important lesson from this exercise. If you design your data structures (even as humble as a single cons cell) by writing a set of procedures for creating and accessing them and you use those procedures consistently, you can totally change **how** they are implemented and your programs will continue to work as expected. 
I think that's the important lesson from these exercises. If you design your data structures (even as humble as a single cons cell) by writing a set of procedures for creating and accessing them *and* you use those procedures consistently, you can totally change **how** they are implemented and your programs will continue to work as expected. 
Well, now that explains everything. I should pay more attention to details. Thanks.
Definitely. Watch the videos first though - there is a huge difference in style ; the book is a lot 'drier' and more formal - but makes much more sense after having seen the lectures. 
Just got back to check this thread, I actually figured it out right after I hit post (seems to be the way with me, once I know how to ask my question properly I get the answer). Your abstraction at the bottom actually solved the crux of the next problem I was thinking about today so thank you very much for your help! 
I wish there was some work on using Chez for webapps. Sounds like it'd be pretty dreamy. 
R7RS isn't that much better than R6RS from a technical perspective (or better said, it's a matter of opinion). The reason GP wants you to use R7RS is that it's the most recent standard, so by targeting R7RS you will not have access to portable libraries. Think of it as Python 2 vs 3. The more people who switch to 3, the better of we will be. R7RS is getting some nice libraries like functional data structures, but those things are a work in progress.
If you want to be cross-platform, I suggest Racket. Performance won't be an issue in the future because they are moving towards the Chez scheme implementation. Racket has the most libraries and the nicest development environment.
Yeah, it's a little big for my application (embedding as a scripting language), and I live and breathe linux so supporting windows isn't as important to me.
I see, in that case have you considered Chibi Scheme? It's not very fast but it's specifically meant for embedding and can call C code. I never worked with it this way however. 
I did look at it, but the performance is an issue for me. I want to use this in a plotting application, and I pretty regularly have to handle many millions of points, so it needs to be reasonably quick.
I think your best bet is using your favourite numerical libraries from Chez since it seems to have a very decent FFI. It's what I'm going to do anyway (I seem to have similar goals to yours, including the plotting.)
Agree - something like a chez adapter for nginx, like openresty is for lua, would be great.
Do you appreciate that exercise ? It stuck in my mind for a very long time to see how things could come of nothing (except lambda). I found it very eye opening in how solving a structure against its own "interface" can make it emerge.
Not yet but I'm on my way to it. I've taken a break to internalize this concept. The question that bothers me now is - is this a practical thing or it's just a demonstration of what you can do with lambdas?
To me its mostly about the "vaporous" notion of computing, a structure/concept can be defined as a bidirectional relationship on information and its use. Here a cons list is defined by kar/kdr. It's an abstraction, not directly practical, but it helps recreating useful ideas far from the machine. That's only a tiny opinion, I'd be curious if others more experienced devs have criticism I miss.
Yeah, it surely does show common things from different perspective. The topic is really interesting and I would like to hear more opinions as well.
Simply Scheme is for people who don't know any programming language, so it starts out very slowly and gently walks you by the hand. Much the in the same vein is How to Design Programs by Felleisen et. al., whose second edition can be found online, and it is great for initiation. Now, if you are an experienced programmer, you may go directly to The Scheme Programming Language (4th ed.) by Dybvig, which is more of a language reference with a work-through intro. It is fully updated to the R6RS standard, also, and it is freely available online. If you care for a mix of the two approaches, to start out slowly and work through exercises towards greater complexity, I can't recommend highly enough Scheme and the Art of Programming by Springer and Friedman, which is the book I cut my teeth with. It is sort of dated, but still very usable.
The Schemer series are not for learning the Scheme language or to program as such: they are more of a way to exercise your programming skills, like finger exercises for the piano student as the authors say in the foreword. Actually I have found that to read these books away from the computer is better, as it forces me to parse and understand the code in my head and thus developing my ability to think before coding.
Thanks!
I'll further destroy the parent's myth by showing LISP can also be everything from a CPU implementation to something for designing, representing, or synthesizing hardware. By that standard, it's C that starts looking super high-level and inefficient. ;) https://www.cs.indiana.edu/pub/techreports/TR544.pdf https://www.researchgate.net/profile/Marc_Feeley/publication/249930260_SHard_a_Scheme_to_Hardware_Compiler/links/02e7e5321df5bba251000000.pdf?inViewer=0&amp;pdfJsDownload=0&amp;origin=publication_detail
In case anyone is interested, here's where nineties took all that work going from assembly to a mini-LISP to a full language: https://speakerdeck.com/nineties/creating-a-language-using-only-assembly-language Very impressive stuff.
This is a hard one because outside of Racket's htdp2/universe, it's kinda limited. If however, you're flexible about which lisp you wanna use, there's Quil for Clojure (which is effectively just Processing in an idiomatic Clojure wrapper) or Sketch which is essentially the CL equivalent of Processing.
Chicken has a few: http://wiki.call-cc.org/eggref/4/doodle http://wiki.call-cc.org/eggref/4/hypergiant And there's the venerable Fluxus: http://www.pawfal.org/fluxus/
Definitely Quil for ClojureScript. http://quil.info
You might have luck using the canvas element from within http://www.biwascheme.org/ , a browser hosted Scheme.
&gt; Gerbil https://github.com/vyzo/gerbil This is really cool.
What's the advantage of Guile over Chicken for you?
In Chicken there is "Hahn" for in-code documentation, which will also generate HTML.
Not a direct answer, but Clojure is Scheme-inspired and has docstrings, and [Urn](http://urn-lang.com/), a lisp that compiles to Lua, uses them as well and has a mix of Clojure, Racket and CL influences. Might be interested in looking into them as another alternative for branching out a bit.
Didn't find that in my searching! Thanks for the tip. I might be wrong, but it looks like structured comments around code (like Scribble) and doesn't seem to integrate with the editor (like elisp's docstrings do) - but with Geiser you can at least look at the Chicken docs (though not your own code's docs)
I didn't know that about Clojure. It was a little off my radar b/c I guess I wanted to keep the ability to call C++ code (where I've done all my work for the past 6 years). The JVM/JS ecosystems are pretty far from work I've done so far (simulation and computer vision) and it's nice to be able to get closer to the metal when you need to. It does look really appealing as a language though.. I might reconsider
[Guile](https://www.gnu.org/software/guile/) is a scheme that has docstrings and is supported by Geieser.
When using Geiser Emacs is able to display function signatures for guile scheme in the echo area. I haven't played with it enough to know if it could possibly provide full `C-h f` functionality. As it stands, Emacs' *describe-function* command seems to only work with elisp functions.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/emacs] [Some other Lisp dialects also have docstrings. Is there a way Emacs could provide them with M-x describe-function?](https://www.reddit.com/r/emacs/comments/7g8f8u/some_other_lisp_dialects_also_have_docstrings_is/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I replied in your other post with how to do it using Geiser. It's just a different keybinding :)
After spending about a week with this I've settled on Chicken Scheme for backend and Clojurescript for frontend. Pros of this are you can compile the clojurescript, compile the chicken executable and bam you have a deployable folder. Since I'm focusing on SPA chicken only has to have functions that handle routing and database access on spiffy. It seems to work fairly well. The documentation took a little bit to figure out how to get "hot time" changes in the backend. For now I've settled on a simple general case router that allows me to re-evaluate code and have it show up in the site without restarting spiffy. Clojurescript is incredibly nice with figwheel, and probably the best lisp solution atm for frontend baring comparisons to Parenscript (but then you'd be using CL anyway). This is a really bad test but I had a single page web-app that was simple running in CL at about 50mb of ram and varying low CPU usage. Chicken scheme for the same page when compiled came out to 8MB of ram, and 50% lower cpu usage. This is a bad comparison because there isn't a ton of activity stressing the system, it's simplicity, and the fact that chicken is green threaded while CCL I think might have native threads. So in the long run CL might perform better at a higher workload compared to the identical chicken version but that'd require further testing. A note: I've found geiser to not work well at all for hot re-evaluating server components while you're trying to build up. I highly recommend swank/slime-chicken for these purposes. Lisp web development is awesome.
don't document the code. Code the document :-) Literate programming
I like literate programming as well (with org mode). I even publish it as HTML on GitHub, which is kinda fun (geokon-gh.github.io) but that's not the same as documentation. If you look up a function you want a short description of its interface and behavior, not a full blown document. Sorta the difference between an instruction manual and a reference book.
If you're using emacs as your lisp IDE, then install SLIME and utilize the extensive SLIME documentation system: https://common-lisp.net/project/slime/doc/html/Documentation.html#Documentation
https://arxiv.org/abs/1707.04755
Urn with Love2d bindings.
What an appropriate name.
yo dawg i heard you like pyramid schemes...
That depends on what scheme you are using. I've worked with rackets test framework *1. That has been working great for me. I've also tried an egg chicken scheme *2. It would seem that there is a testing framework for your implementation. I've also seen what you mention, a file with some basic value-checking. https://docs.racket-lang.org/rackunit/quick-start.html http://wiki.call-cc.org/eggref/4/test
[srfi 64](https://srfi.schemers.org/srfi-64/) is what you're looking for
I'm using chicken scheme right now. *2 looks exactly what I need. I am going to try it out. Thank you~
The most popular test library in CHICKEN is the test egg: http://wiki.call-cc.org/eggref/4/test
Announcement on the list: https://groups.google.com/forum/#!topic/chez-scheme/4-y3T1V06wA
Documentation: https://github.com/becls/swish-win/releases/download/v1.0.0/swish-win-1.0.0.pdf
The flat rate paid is sector dependent, with those in IT consultancy currently paying VAT at 14.5%.Am I right for this vat percentages for as consulting.
Think about it ;) The operator `&gt;` means "Greather than", so `(&gt; n m)` means "Is `n` greater than `m`". If this is too abstract, try to replace `n` and `m` with the numbers 1 and 2, and think wat would happen of you swap the values.
Is it easier if you think about the infix form? (n &gt; m) isn't the same as (m &gt; n)
The terminal conditions being referred to are in the program listed on page 72, in the definition of `&gt;`: (define &gt; (lambda (n m) (cond ((zero? m) #t) ((zero? n) #f) (else (&gt; (sub1 n) (sub1 m)))))) Specifically, the termination conditions are the two `zero?` conditions that return a boolean value. The `else` condition is the recursive case, as it calls the function (`&gt;`) recursively. &gt; Does the order of the two terminal conditions matter? Think about it. &gt; Does the order of the two terminal conditions matter? Try it out! &gt; Does the order of the previous answers matter? Yes. Think first, then try.
Terminology: `n` and `m` are *arguments* to function `&gt;`, not *terminal conditions*.
"Is n greater than m" was the key to this clicking for me. I wasn't thinking about what was really being asked by the program. The reason is because we are focused on n. We check for ((zero? n) #f) first because in the case n's recursion terminates first, it has to be less than m and therefore the question "Is n greater than m" has to be false. That same question has to be false as well even if m is the same number. It can only be true if n's recursion is still at some step other than the 0th because it causes the terminal condition ((zero? n) #f)) to evaluate to false so we have to ask the next question which would end up true and return the value #t. Thanks for the help. 
It was a lot easier. I left my thinking cap at home. Thanks for the assist!
You pointing out the fact that the program returned a boolean value made me question what the program was even trying to evaluate as true or false. Thanks for taking the time to help!
Infix is pretty ingrained, takes a little bit to reprogram your brain. But now you can have things like + take more than two arguments (+ 2 3 4 5 6), and everything unifies to simple function application. No difference between (plus 1 2 3) and (+ 1 2 3), except for the totally arbitrary name you gave the function.
Not very much. I prefer syntax case over renaming macros and delimited continuations are very neat compared to call/cc. I have implemented racket-like for-loops for guile, which I don't know how to implement using ER macros. I switched mostly because it allowed me to have a common prelude between chez and guile without much fuss, since guile supports most of r6rs. Then I ended up using guix, and from there it was pretty much settled. Guile3 (which is many years away) will probably do native compilation if I understand the posts in guile-devel correctly, which will more than close the small remaining speed gap.
You might want to check out LFE or CSCM, which are lisps that run on the Erlang VM.
I'm trying to dive into Scheme more (coming from elisp) but I'm a bit confused about all the versions. I was going to use Guile (BC it has docstrings which are great and id like to use GUIX eventually) but then reading up it seems r7rs is more portable and shinier and new (so maybe Chibi?). It says Chicken supports r7rs - but does that mean it's through a compatibility layer? that the core library and eggs are on an older scheme version? the library hasn't been updated in 2017 it seems - so maybe its a dead project? http://wiki.call-cc.org/eggref/4/r7rs
Thank you so much for the feedback! Now I just need to figure out how IRC works :)
Any questions? AMA.
Yes. Why? Just for fun?
Yes, and and a somewhat serious alternative to wasteful proof of work. Should the market demand it, the mining opeation of a 'coin' eventually becomes hardware should it's market cap be high enough to warrant the creation of such hardware. I eagerly anticipate the research of our forefathers to be looked at again[1], bringing us a next generation of 'scheme' chips to...process transactions (I guess ;-).
fucking beautiful
Should be pretty easy to implement using today's tools.
Interesting; I don't see it immediately in the code, but what kind of blockchain is this, if it's not PoW?
It's a simple, what I consider 'standard' blockchain based on a Haskell implementation that allows for transactions that can contain 'data' and 'value'. I chose to interpret the data section of the transaction to hold 'Scheme' code, which is meant to be the PoW function. There is a piece still in development that is missing from the code ATM, which is to allow for the group estimation of the evalulated value an arbitrary piece of code, where there are possibly hostile or colluding parties in the network.
[1] https://dspace.mit.edu/handle/1721.1/6334
FPGAs? I have an Oberon machine... I wouldn't mind playing with at scheme CPU! :-) 
An original Oberon with the NS32032 or one of the newer FPGA ones?
FPGA
Very cool series - thank you for writing it I don't really know much about compilers, and I'm very new to scheme, so maybe I'm off-base here. This was just a thought that came up in my mind - "Internal to tarot we use LET to refer to LET*" This seems like cheating a bit b/c let* is equivalent to nested let-s :) . I get you're trying to simplify things to one data structure to make compilation easier though - and that's very understandable; But to me denesting seems problematic in the longer term. You're throwing away scope and environment information by simplifying things with let* - which eventually will lead to performance issues b/c you loose guarantees on the independence of operations I remember optimizing some tight loops in C a few years back and having this be a constant annoyance. C/C++ doesn't have an immutable/"real" 'const' so simple statements like a = foo(args1); b = bar(args2); return boo(a b); unless inlined, to the compiler don't mean 'a' and 'b' can be calculated independently. (You can fight the compiler to do what you want.. but it can make the code very ugly). In r7rs the contents of a let aren't guaranteed to execute in any particular order so if you do (let ( (a (foo args1)) (b (bar args2))) (boo a b)) The language gives you the guarantees you need. Your method ends up throwing that nicety away I think
great question. thank you for asking I get what you mean: leaving some semantic details unspecified gives a compiler freedom to perform optimization. For example leaving evaluation order unspecified allows the compiler to rearrange the order, picking the one that allows it to do the most optimization. you're completely right that what I'm doing throws that away, it sets evaluation order in stone and precludes us from performing rearranges that would allow more optimizations. The thing is, we are compiling from scheme down to this bytecode language that is a sequence of statements that get executed in order - so at some point in the compiler pipeline we have to pick an exact evaluation order and lay it out: that's what this pass does! If we wanted to add some optimizations that take advantage of rearranging the order of things we would just do that before this pass: I think the best place for optimizations would be after the hoist pass and before this pass. 
Thanks for the explanation. I guess if you assume no SIMD and compiling to atomic instructions then that information serves less purpose. I think I'm just projecting my frustrations with C :) But this has given me more to think about! - now I'm trying to picture how you'd encode the dependency between sets of instructions, and how you'd optimize such a graph. It's an interesting problem!
Step 1. Split the list into lists of length m (you will get k lists). Let's name the result xss. Step 2. Map first over xss. Step 3. Apply + to result of 2. 
Your post title and body are two very different things.
map, apply, and +. Are you going to post every homework problem you have? 
Can you please show me how? There are no enough resources about that. I spent hours trying but, could not figure it out. Also, I tried map, apply, +
What did you try? Show some code.
 (DEFINE (cobmine_helper lst) (IF (NULL? lst) '() (MAP + (CAR lst) (cobmine_helper (CDR lst))) ) ) (DEFINE (combine_m_rows matrix) (IF (NULL? matrix) '() (CONS (cobmine_helper (CAR matrix)) (combine_m_rows (CDR matrix))) ) )
What's with all the upper case functions and syntax? That's not valid on any scheme I tested with. Lower case! Your 'cobmine_helper' is *almost* working. You just need to think about what happens when map gets lists of different sizes (Compare `(map + '(1 2 3) '(4 5 6))` with `(map + '(1 2 3) '())` and add checking for one more special case... 
I am using Guile implementation and all uppercase words working well. Yeah, my problem is that how can I extract the elements of a list and combine them by adding the i'th elements together.
I checked your posting history, so I must ask: are you using Reddit to do your college homework? If so, shame on you! Step up to your career choice or change majors. Cheating is no way to learn or to become anything worthy.
Do your own homework.
Dear @fbelisario, first of all, it's not good to use this rude manner in a scientific community. Second, know what is "CHEATING" before then, talk! Our professors always say that DISCUSSING "not SHARING" algorithms is not considered as cheating! but sharing the whole or partial code it is. And it's clear that I did not ask for the code but rather the algorithm and the members did not post any code "I already posted MY OWN code and managed to solve the problem on my own". Lastly, I don't like negativeness. Take Care!
There is no need to tell me what to do. I may give up or continue to do. Take Care!
Thank you! I managed to solve it by: 1) Splitting the list using my own implementation of "take, drop" as Guile does not support them. 2) I used a recursive function to sum up the first "n" elements of each sublist to form the resultant list without using **map**. Appreciate it :)
Great. 
Before r6rs, scheme was case-insensitive.
Do your own homework, cheater.
Great work! Respect!
Then, fuck you up! Keep your fucking business stupid!!!!
https://www.reddit.com/r/scheme/comments/7ofd11/racket_on_chez_scheme_status
Nice. For everyone want to learn howto embed scheme/guile into a C++ application, take a look on the "Studio" sources from libfive.
Megaparsack is by far my favourite library for monadic parser combinators. It's a shame it is so much slower than parsack.
I have retrieved these for you _ _ *** ^^To ^^prevent ^^anymore ^^lost ^^limbs ^^throughout ^^Reddit, ^^correctly ^^escape ^^the ^^arms ^^and ^^shoulders ^^by ^^typing ^^the ^^shrug ^^as ^^`¯\\\_(ツ)_/¯`
Yikes, will you're right I didn't provide much details about what I had done. As I was writing up what I did after reading your response I noticed a second command line argument in the unmscheme.c file that I did not notice the first time (The first one causes an error with an unrecognized command line option '-03') and it actually compiled and ran. I'm assuming you compiled it per the second gcc based argument found in the unmscheme.c file? Thanks for your time regardless.
And for when syntax-case becomes too clunky, racket has syntax-parse which is just a dream come true for macro writers. 
Seems awfully much like a bug in guile to me. For me that works just fine, but I am on guile2.2.3 from guix. Does other addresses work ok? What about things without https?
smells like the handshake is failing
Late to the party, but guile is really easy to embed in a larger c/c++application. It is one of Guile's selling points. I am creating a "simple ffi" to help interop with c (automatic conversion of strings and such to null-terminated char*,implicit bytevector pointers, easy foreign-ref and garbage collected foreign memory allocations). If you are interested I can send it to you when i upload it.
That seems to be the problem. I can't even install the latest version of Guile from source because I don't have at least version 4.1 of libgmp. Starting to get mad at Ubuntu for never having the latest packages in their Repos.
That's the price you pay for using a LTS OS. Stable is the byword, not up to date.
What Scheme implementation are you using? And what are the types of the elements of your vector? (It probably shouldn't make a difference, but I'm curious.)
All the values in the vector are floats.
Again, what Scheme implementation are you using? 
If they're floats, the answer may be that the value at position 255 is in fact not 255, but slightly less than 255 and only gets rounded to 255 when you print it.
Ok, this is my theory: the scheme implementation you are using is truncating the output of vector-ref, but using all the decimals when comparing. Chicken scheme exhibits similar behaviour in those cases: &gt; 225.0000000000001 225.0 How did you fill the vector? did you do floating point addition? 
So this scheme prints an object not eqv? to 255 as "255" ? If its an inexact we should at least see a decimal point. And if its less than 255 it should not print the same way 255.0 would either. 
yes, stars are beautiful
Formula are a concise way to express what are often very complicated ideas. The notation is challenging for a beginner, and so you should probably consider reading an introductory text on the subject before attempting to dissect any contemporary research, or "you're gonna have a bad time." Once you get used to the notation, it won't bother you. 
Here's the R5RS paragraph about the numerical comparison predicates: &gt; __procedure:__ `(= z1 z2 z3 ...)` &gt; &gt; __procedure:__ `(&lt; x1 x2 x3 ...)` &gt; &gt; __procedure:__ `(&gt; x1 x2 x3 ...)` &gt; &gt; __procedure:__ `(&lt;= x1 x2 x3 ...)` &gt; &gt; __procedure:__ `(&gt;= x1 x2 x3 ...) ` &gt; &gt; These procedures return `#t` if their arguments are (respectively): equal, monotonically increasing, monotonically decreasing, monotonically nondecreasing, or monotonically nonincreasing. &gt; &gt; These predicates are required to be transitive. &gt; &gt; *Note:* The traditional implementations of these predicates in Lisp-like languages are not transitive. &gt; &gt; *Note:* While it is not an error to compare inexact numbers using these predicates, the results may be unreliable because a small inaccuracy may affect the result; this is especially true of `=` and `zero?`. When in doubt, consult a numerical analyst. The last note should be particularly relevant to your case.
_test_
I think only people are inspirable.
Why not just tell us which Scheme implementation you are using and save everyone time? At this point it is clear either the float in the vector is smaller but rounded when you display it, or the implementation has a bug. Are you using some secret implementation we can’t know about? :P
The advantage of notation is that it takes less space and is more concise than prose. Because of this, it is often easier to compare formulae than different passages of prose. It might also be easier to spot errors. Most importantly, it is much easier to spot patterns in formulae than in prose, because of how most people’s brains work—humans are pretty good at recognizing visual patterns. The downside is formulae being harder to read, especially in the presence of errors. This sometimes happens when people are more interested in making their paper look fancy than actually doing something interesting. 
255.0 *should* be an number that can be accurately represented in floating point though, unless you're using something with less than 8 bits of mantissa. 0b0.11111110.. * 2^0b100 should exactly equal 255.0 without any rounding errors.
Yes, but a floating point number that get's printed as 255 is not necessarily exactly 255 internally. It's not unusual to print floating point numbers with limited precission.
Are you supposed to use a recursive approach? do, named let, plain recursive functions, etc.?
 (let ((score (- score 1))) score) ; Will return decremented score
You can use a named let for your main control loop and modify your variable bindings for each iteration.
Noticed this question has some downvotes—I think it’s cool that they disclosed it’s for an assignment. At the least, instead of downvoting, maybe we could suggest resources in the comments.
Chicken scheme is probably your best bet. I don't know offhand how big a hello world executable will be, but it'll pretty much be the minimum unless you hand-roll a puts FFI call. Anything else is going to either have a big runtime to carry along (the various CLs*, and some of the other scheme alternatives), or uses the same approach as chicken but is slightly less well supported (eg, Bigloo, Gambit). \* ECL or it's fork MKCL might be an option for common lisp, they'll still be a couple of MB, but should be less than the 30-50MB minimum you'll see with SBCL)
Chicken, Clozure (CCL), or SBCL. I really like Chicken but I much prefer debuggin in Slime.
Yesterday, I've build a minimal webserver with SBCL and Woo. Roswell build produced a 15M compressed binary. 
I'm mostly using Bigloo (on Linux) in case I need executables from a Lisp (the SBCL executable images are usually a little bit too heavy in case you cannot make use of heaving the whole CL wrapped with the image). Bigloo has much less of a community than Chicken, but that also means that it's quite self-contained, even if a little bit bare-bones. Performance is quite good, and if required Bigloo's C-FFI is also nice to work with. A hello-world binding to Bigloo's dynamic runtime is ~11 KB, a statically bound executable is ~3 MB.
 I did some testing in Windows. As regards Bigloo, I am unable to get a standalone executable (without a bunch of DLLs). Is it me? [gambitscheme.org](http://downforeveryoneorjustme.com/gambitscheme.org) is no more. Newlisp (Windows only) has some killer technology or simply compromise on the features. Just 300K to say hello. How do they cope with the runtime? Unfortunately, when I tried to read a web page, the `get-url` doesn't work with https (only http). 
Can it produce [standalone native executables](https://www.reddit.com/r/scheme/comments/7yarrv/mature_and_maintained_scheme_or_common_lisp/?ref=share&amp;ref_source=link)? 
&gt; gambitscheme.org is no more Not currently following it myself but https://github.com/gambit/gambit shows activity.
[gambitscheme.org](http://gambitscheme.org) is up for me and it's also up on the link you posted.
oh, it's up now. Thanks for posting! The dev version on git does not work right now for Windows, but the main site has prebuilt binaries. 
Try `fold-left` instead of `fold-right` or better some built in `sum` function. You are working with single linked lists, it's more efficient to traverse them from left to right. The R routines are probably written in C so some hand written scheme will never be as fast. `+` needs to do some type checking which might be avoided in R.
Yep. Use `fold` instead of `fold-right`. Also, I played a bit with your code using Guile, and if you're using integers as input, Schemes with rational support will use rationals for the result, which slows things quite a bit. Try using floats instead. I got from ~5s to ~0.33s by doing that.
I'm not sure that Chez has a built-in list sum. However, your advice to use fold-left makes sense. It doesn't seem to make too much difference for my list of 1000000 random numbers, but might do for larger lists. It would make sense that R has optimised routines like this, as you suggest. Thanks for the response!
So, you are also doing a shitload of passes over the list. A total of 6 that I can count without really trying. In order of execution: fold, length, map, map, fold, length. This is pretty inefficient. Some of the passes are out of convenience (multiple calls to length), but the sum-of-squared-deviations is pretty wasteful. I did this: https://pastebin.com/Xb8ar5cj (guile, should be trivially ported to che) . The new sum-of-squared-deviations runs in about half the time of the old one. The next step would be to use vectors to have everything in the same region in memory. That usually speeds up things by quite a lot since you benefit from cpu caches..
Cons cells can be all over the place, whereas vectors are in the same place in memory. In chez scheme you could use fl/ and fx+ to skip type checks, which would make it slightly slightly faster if you know you won't exceed fixnum size. 
That is generally also the reason why most languages have arrays as the basis for their lists (like python). I scheme we have first class continuations, which means the mutability of vectors is not a good general case. It also depends on the scheme implementation. In guile the difference is often a lot smaller than in chez.
Answering your other question: You could have a look at racket. They have great list comprehension facilities, a built in maths package and a rich set of libraries (and a package manager which removes a large part of the problem of depending on third party code). 
I second Racket for your initial explorations. It's a bit slower than Chez, but it comes with a [very nice plotting library](https://docs.racket-lang.org/plot/intro.html#%28part._.Plotting_2.D_.Graphs%29) that would be useful in this context.
So, I just modified the code very quick and dirty to use vectors, and managed to squeeze some extra performance out of it, but most of the work seems to already be done. On my computer, chez scheme runs the code in 0.028s (as compared to 0.038s using lists). WARNING, ugly code ahead: https://pastebin.com/D1915h7t
No.
Don't be too discouraged by the speed difference. R, Python, MATLAB and so on all rely on highly optimized external libraries written in C or Fortran for most of the heavy mathematical lifting. Even if you wrote your own in, say, C you'd be unlikely to be nearly as fast or robust.
Thanks again for all your responses. I think I'll stick to lists for the time being (for my own convenience) but it's interesting to see how it would be done with vectors.
Yes, that makes sense. Since I'm writing this code for my own edification rather than for serious use, I'm happy enough. The speedup from just using floating point rather than rational arithmetic has me sated.
I'm avoiding Racket mostly because it isn't a scheme, per se, but a superset of scheme. I don't want to be tied down *too much* to any specific system. I also have a fairly nice workflow set up with Chez at the moment. That being said, you're (both) probably right in suggesting that Racket would be a fairly convenient choice of language for this sort of thing. I have found a set of data science procedures for Racket [here](https://github.com/n3mo/data-science) that I'm liberally borrowing from.
Yes, writing your own is a great way to get experience. Just don't take the speed comparison with production-level math libraries seriously.
Gerbil Scheme will give you truly static files. And much faster than Chicken.
It's very much alive and very active.
Gerbil adds a lot of batteries to Gambit.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://fare.livejournal.com/188429.html) - Previous text "Yes" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20dunwepb) 
I switched from fold-right to fold-left, forced everything to be floats &amp; combined some of the passes through the list (e.g. instead of computing deviations then squaring them, then summing that I just compute the sum of the squares of the deviations). A list of one million whole-numbers, before the optimisations, was clocking in at about 3.2 seconds. A list of one million floats, after the above, clocks in at between 0.1 and 0.2 seconds. That's good enough for me, as further optimisation would probably involve obfuscating the code a bit (defeating part of the purpose in me writing it).
[Gauche can build a standalone executable](https://github.com/shirok/Gauche/blob/master/doc/HOWTO-standalone-gauche.txt) from the next release. But not native compile, link VM code &amp; runtime.
There is a docker image up now of the latest Gerbil/Gambit. docker pull gerbil/scheme:latest 
Looks good! I do however feel that I would be annoyed at it if I tried to use it since Guile's PEG parser has a slightly different syntax.
A fun project, given that Chez has a very nice C FFI, would be to write your own stuff with an eye towards using abstractions that would make it easy to swap in your own wrapper around BLAS (or similar). This would lead to a real understanding of the tradeoffs and performance benefits of bringing in a fast C/FORTRAN numerical computing library.
To quote [Guile's manual](https://www.gnu.org/software/guile/manual/html_node/Integers.html): &gt; Scheme integers can be exact and inexact. For example, a number written as ‘3.0’ with an explicit decimal-point is inexact, but it is also an integer. The functions ‘integer?’ and ‘scm_is_integer’ report true for such a number, but the functions ‘exact-integer?’, ‘scm_is_exact_integer’, ‘scm_is_signed_integer’, and ‘scm_is_unsigned_integer’ only allow exact integers and thus report false. Likewise, the conversion functions like ‘scm_to_signed_integer’ only accept exact integers
Exactness is a property of the number value itself, not its type, and typically originates in the operation that generated the value. Here the value originated in reading the inexact number literal "2.0." See R6RS 3.2.
Right, I do need to spend time in the docs. Thanks.
That gives me a way to reason about it, which is the best I could hope for. Thanks. For what it's worth, this behavior seems very unintuitive to me. I don't have enough knowledge about scheme to claim it is wrong, but it really threw me to see it.
https://en.m.wikipedia.org/wiki/Numerical_tower Is a good read on these concepts 
Correct me if I'm wrong, but I believe what Scheme calls an integer is not the same as the way most languages use the word. "Integer" in most languages refer to the representation of the object in memory, so you contrast integers vs. floats, for example. In Scheme, "integer" refers to the _mathematical property of being an integer number_, and does not say anything about how that number is represented in memory. In this sense, `2.0` _is_ an integer, in the sense that "2.0 ∈ Z" is true. But that does not mean it's not a float! `2.0` is an inexact number, which in most Scheme implementations means it's represented as a float in memory. In this sense, `2.0` _is_ (mathematically) an integer, and _is_ (representationally) a float. `2`, on the other hand, is an _exact_ integer, which in most implementations means it's represented by either a fixnum (a small integer in memory) or a bignum (an arbitrary-precision integer in memory).
I see this is one of those subs where productive, on-topic discussion is punished.
A related motivation: - after rounding a real-number, you always have an integer - if you round a number that is *approximately* the correct value, the rounded result *might* be incorrect. Hence is it an inexact integer. Fwiw, I recognize *why* it works like this, but I almost always find it frustrating in real life. (For instance, I'm `round`ing or `ceil`inging in order to do something like `substring`, and so I end up calling `inexact-&gt;exact` more than half the time I call those others.)
This reminds me of a story about the assessment of the height of Peak XV of Mount Everest made by the British Surveyor General of India in 1856. His best calculations indicated exactly 29,000 feet (presumably to the nearest foot). However to avoid giving the impression that this was a rounded number, he publically declared the height to be 29,002 feet. https://en.wikipedia.org/wiki/Mount_Everest#Early_surveys
as easy as `docker run -it gerbil/scheme:latest /root/gerbil/bin/gxi`
Wow this looks really interesting, definitely scratching my scheme itch!
Congrats to @vyzobot. This is amazing progress in such a short time.
You didn't paste any code, so I can only speculate. The name "formals" refer to the parameter list of a lambda form. You can use it in the following ways: (lambda (&lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt;) &lt;body&gt;) (lambda (&lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; . &lt;rest-args&gt;) &lt;body&gt;) (lambda &lt;rest-args&gt; &lt;body&gt;) where &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; and &lt;rest-args&gt; are all symbols. So for example the following expressions are legal: (lambda (x1 x2) (+ x1 x2)) (lambda args args) because `x1`, `x2` and `args` are all symbols. What is illegal though is to place something different than symbols in those places, so the following expressions should produce an error similar to yours: (lambda (1 2) (+ 1 2)) (lambda "string" "doesn't work!") (lambda ('x1 'x2) (because 'x is (quote x))) (lambda (() (())) (lists are not symbols!)) 
I actually figured it out! Sorry for not posting code but in my code it was basically (Define (nameoffunc (Lambda (..... When it shouldve been (Define nameoffunc (Lambda ..... So i messed up on the first line of my code
I specifically had to use lambda in this program for an assignment
Hi! If you have not implemented any intepreter before, perhaps you could start with something easy and familiar, like arithmetic formulas. Besides familiarity, they always terminate. Here is how you might do this: ``` (define (value formula) (cond ((number? formula) formula) ((eq? '+ (car formula)) (+ (value (cadr formula)) (value (caddr formula)))) ((eq? '* (car formula)) (* (value (cadr formula)) (value (caddr formula)))) ;;; add more operations here if you want )) ``` For example `(value '23)` yields `23` and `(value '(+ 2 3))` yields `5`. Actually this is pretty ugly, but it seems in chibi you do have `match` macro... ``` (define (value formula) (match formula (`(+ ,a ,b) (+ (value a) (value b))) (`(* ,a ,b) (* (value a) (value b))) ;;; again more crap here (n n))) ``` This should do the trick (I'm too lazy to install chibi though to test it; in case it fails, consider guile and start your code with `(use-modules (ice-9 match))`. [Also, mind that traditionally this procedure is split into two parts -- `eval` and `apply`, but I really dislike using verbs in applicative languages...] Now the next step would be to allow variables and some environment which binds them, so that you could do `(value '(+ a 3) '((a . 2)))` to get `5` again. Easy peasy! ``` (define (value formula bindings) (match formula (`(+ ,a ,b) (+ (value a bindings) (value b bindings))) ;;; etc... ((? symbol? s) (lookup s bindings)) ((? number? n) n))) (define (lookup symbol binding) ;; think of "lookup" as a noun, not a verb ;) (match binding (`() 0) ;; suppose the default binding will be 0... (`((,s . ,v) . ,binding*) (if (eq? s symbol) v (lookup symbol binding*))))) ;;; or just use assoc/assq or whatever you have for a-lists... ``` Just in case you don't have `match` (or really don't want to use it -- though that would be really unwise!) the last 2 clauses of match in new definition for `value` in cond-version would be simply ``` ((symbol? formula) (lookup formula bindings)) (else formula) ;; or ((number? formula) formula), whatever... ``` Allrgith, now if you made this work, there you go -- you wrote your first interpreter. Now the next step would be to write a simple lisp variant. This post is already getting lengthy and it just gets interesting in here, with function definitions, scoping and stuff, so instead I delegate you to Steele and Sussman's "The art of interpreter" (http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-453.pdf) -- a super lovely read which you should find entertaining and enlightening. Read at least part 0 and part 1, try the examples, re-read it, take your time. Now you are ready to grasp Might's article (I assume you mean this one http://matt.might.net/articles/implementing-a-programming-language/). If you still want to ;) Good luck! PS as of displaying consecutive substitutions if you don't mind seeing them "in reverse" just add `(pretty-print formula)` at the beginning of `value`'s definition
This is a rather broad claim. Please explain your point of view.
Yes. And the answer is to write better documentation and build better tools to make it easier to understand and debug such code.
Thank you, that answered a lot of questions! :) Also, your use of "(match)" makes an excellent introduction of how to use it and demonstration of why it's cool. I've been meaning to look into it so that was quite useful too. All of the above worked flawlessly on Chibi, except that I had to change the line reading "(`() 0)" from quasiquote to quote: "('() 0)". In light of what you showed me above I think one of the big things I struggled with in terms of Might's article (indeed the one you linked) was misunderstanding the bindings. I will definitely be asking more questions! Thanks for the offer. ^_^ Though for the moment I think I have to first put some effort into Steele and Sussman's article before I'll be able to formulate a good question. :) So, I'll be back, and thank you! :)
[removed]
Be useful to know what are the key differences between rascas and [maxima](http://maxima.sourceforge.net) (other than the latter being wrotten in lisp).
What a gem... is there a github or some other place where I can snag the .ss files?
anytime, and good luck!
the Igropyr project need more contributors. It's a very new project but it's very effective!
You may want to check out the Go-based zygomys lisp: https://github.com/glycerine/zygomys/blob/master/README.md
If you want to know what transducers are, I would suggest watching: https://www.youtube.com/watch?v=6mTbuzafcII . If you have any questions, please feel free to ask.
That's very interesting, I have been wondering about the problem of not producing intermediate lists too, except in the context loop iterators. Could this be used for that? I made a solution that uses shift and reset.
This is terrific. I'm not sure why you label it "pointless" and a "waste of time." On the contrary, would you consider submitting this as a draft SRFI? See &lt;https://srfi.schemers.org/&gt; for details. Regards, SRFI Editor
generators (srfi-158) are another solution to remove the necessity of intermediate lists. maybe it's a good fit to combine those two. e.g. (tmap fn) == (cut gmap fn &lt;&gt;).
This is hella cool and a really neat, functional alternative to generators.
Well. This is really just a generalisation of map/filter/etc, so it would probably not be as flexible as you want a looping facility to be. Early return from transducers are possible, but it isn't as nice as say a named let or rackets loops. I made a guile implementation of a large chunk of rackets for loops ( https://bitbucket.org/bjoli/guile-for-loops ), and the racket way of just having many similar looping constructs (all of course variations of for/fold) treating the loop and end result slightly different is pretty handy. My for loops actually produce pretty much optimal code. Transducers will never be optimal (but, hey, neither will anything using continuations, even delimited ones). The neat part of having my for-loop macros produce named lets is that I can avoid all mutation in the produced code. That makes it easier for the optimizer to work it's magic. The stateful transducers will have a performance penalty, at least in many of the schemes I use.
I already implemented them with support for &lt;&gt; arguments placeholders. Look at my Nietzsche repo under (syntax threading)
damn thanks those look nice.
yeah i really need to get the gist of syntax-case, i have dybvigs papers downloaded if they'd shed more light on how it's supposed to work. i mean i have a syntax-rules macro with a cond on it on two of the pattern matching templates and i figure that'd be easier *maybe* on syntax-case.
I have a couple of macros in my prelude: Threading macros with cut-like insertion: (~&gt; (list 1 2 3) ;; left threading (+ &lt;...&gt;) ;; display) For loops: (for/list/parallel ([a (in-range 30 40)]) (fib a)) but the most confusing one is one I only use at the repl: #c(let ([a (current-time)]) (+ a &lt;&gt;))) becomes (lambda (x) (let ([a (current-time)]) (+ x a)))
That’d be a fold in Haskell. Sometimes called reduce in Lisp. 
Thanks to both, that helps quite a lot. :) Yes I would like to extend it arbitrarily, the three values in the example was for simplicity of explanation.
Then based on your example, {fold,reduce}-right is what you want. You can create variadic or multi-arity functions in scheme in a couple of ways. The first is: (lambda args ...) This is a function that accepts any number of arguments and any arguments given will be placed in the list identified by "args". There is a variation on this which allows specifying a minimum number of arguments with any extra being put in the list: (lambda (a . rest) ...) This is a function that accepts at least one argument. Any extra will be placed in the list identified by "rest". You may specify any number of identifiers before the dot to require at least that many parameters. The last way to create a multi-arity function is with case-lambda: (case-lambda [() #;(accept no arguments)] [(a) #;(accept a single argument)] [(a b c . d #;(accept at least 3 arguments)] [rest #;(accept any number of arguments)]) case-lambda is more flexible than normal lambda in that each arity specified can have a different code path. Note that the code path taken depends on which arity-specification matches first. In the above example the final specifier - "rest" - will only be used when given two arguments as all others will match first . Based on your example, I suspect (lambda args ...) covers your needs. 
this reminds me of the debates around `cut` and what should it be called when it's not actually currying. too bad `tandoori` would've been too unwieldly to type, but atleast we got `cute`
Just out of curiosity, why use libuv? Doesn’t Chez support non-blocking sockets natively?
Thank you, this is a great example! I've used the first and second before but self recursion gets really annoying given that suddenly everything gets wrapped in two lists. Case-lambda is quite compelling though, I'll play around with both fold and case-lambda and see what I can come up with. I really appreciate your effort, thank you. :)
Nice! The code is very readable, but is the input sanitized enough before passed to read? In some schemes read is not safe. And how compatible are scheme and JS strings? I already have an idea how to speed it up, but at the cost of continuation safety: there is lots of copying of strings going on, with both substring and string-append. An imperative approach with a string buffer will result in much better memory usage. 
I am very concerned about security issues: For now I think read is safe here, it is not eval. If you have more suggestions I am very willing to listen. Its code is very easy to filter some of the characters that cause non-safety factors.
Sorry about the bother. I had misunderstood a conversation in the guile IRC channel. In guile they don't recommend using (read xxx) on untrusted data since it wasn't written with potentially untrusted data in mind.
 (use srfi-13) 
Same thing: ;; foo.scm (use srfi-13) (string-intersperse (command-line-arguments) ":") When executed as above, I get exactly the same results. Compiles fine but fails at run-time due to string-intersperse being an unbound variable.
&gt; (string-intersperse (command-line-arguments) ":") #;1&gt; (use srfi-13) #;2&gt; (string-intersperse (command-line-arguments) ":") "" #;3&gt; ^D I wonder if there's something up with your installation.
That did it - thanks a million. By way of followup, answers to the following questions will help me in my pursuit to improve 1% daily: - Is there a systematic way that I can determine what csi loads that csc does not, or is it just (use data-structures)? - The docs for [unit srfi-13](https://wiki.call-cc.org/man/4/Unit%20srfi-13) don't mention the (use data-structures) dependency... how would I have deduced this on my own?
Installation was my next target but u/snoutbeetle identified the problem. Thanks again!
• I'd say http://wiki.call-cc.org/man/4/Non-standard%20macros%20and%20special%20forms#cond-expand but the doc is out-of-date, it doesn't mention data-structures. So seeing the result of (features) is best. • afaik srfi-13 doesn't have a data-structures dependency. string-intersperse is not part of SRFI 13. ex w/ no init file: #1892 $ csi -n CHICKEN (c) 2008-2017, The CHICKEN Team (c) 2000-2007, Felix L. Winkelmann Version 4.13.1 (dloader) (rev 5669049d) macosx-unix-clang-x86-64 [ 64bit manyargs dload ptables ] compiled 2018-03-31 on c-67-180-144-20.hsd1.ca.comcast.net (Darwin) #;1&gt; string-intersperse #&lt;procedure (string-intersperse strs582 . tmp581583)&gt; #;2&gt; (features) (csi: ports: srfi-28: extras: data-structures: srfi-31: srfi-26: srfi-16: srfi-15: srfi-11: srfi-8: dload-library: module-environments: hygienic-macros: syntax-rules: srfi-0: srfi-2: srfi-6: srfi-9: srfi-46: srfi-55: srfi-61: chicken-4: chicken-4.13: 64bit: ptables: dload: manyargs: little-endian: x86-64: clang: macosx: unix: chicken: srfi-6: srfi-10: srfi-23: srfi-30: srfi-39: srfi-62: srfi-17: srfi-12: srfi-88: srfi-98: irregex-is-core-unit:) #;3&gt; 
Perfect. I can use (features) as a starting-point to see what might be missing from csc environment.
Um, if I do a lookup, it tells me what unit/egg the procedure is in (like, if I do `chicken-doc string-intersperse`): path: (data-structures string-intersperse) -- procedure: (string-intersperse LIST [STRING]) [...] The path part is relevant. An alternative representation can be found on the API documentation: http://api.call-cc.org/doc/data-structures/string-intersperse.
probably better to treat the compiler environment as almost empty &amp; be explicit about what you are using. ex: (import scheme chicken) (use ;this is a chicken "module" import btw (only srfi-13 concatenate) (only data-structures string-intersperse o))
I wrote a json parser in scheme once... It's a fun little project to do.
I think using a turing-complete language for configuration is generally a bad idea.
this is a pretty old paper
Also note that this will change in CHICKEN-5. It should be saner then (no implicit imports).
Heh, tell that to Emacs ;)
The latest Gauche supports R7RS (include R7RS style import). Gauche switch to R7RS environment automatically when use R7RS style import.
Right. Better to build them fix into printers. Like Postscript ;-)
yes this is half way to Y
You're close! Now, you just want to generalize this a little more, i.e. (define Y (lambda (f) ((lambda (g) (g g)) (lambda (self) (f (lambda (n) ((self self) n))))))) (define factorial-generator (lambda (factorial) (lambda (k) (if (&lt; k 2) 1 (* k (factorial (- k 1))))))) ((Y factorial-generator) 5) ; =&gt; 120 We can motivate this really well. In lambda calculus, all functions have a fix-point, meaning that if F is a function, there exists some term X so that FX=X. Proof: let F be a function. Define X=λy.F(yy) and W=XX. Then, W=XX=F(XX)=FW. Now, what you did is realize that you can pass a function F to itself as a parameter to achieve recursion. The fix-point of F is the "solved recursion," and we know in general that we can find such a solution. All the Y combinator does is solve that recursion.
For Racket it's: (require srfi/1)
Not sure what you're trying to say. Variadic functions are required to be able to write every possible function (e.g., printf). Variadic functions give you a lot of power; it's not possible to write many functions (for example CL keyword style functions) without the variadic syntax.
I was wondering how to get by if you didn't have them, by passing lists instead of multiple args. 
\&gt; Why did you choose Guile and not another scheme implementation? I started Scheme 4 years ago, at that time I choose Guile mainly because of GNU to give back and [guix](https://gnu.org/s/guix). It is well documented and the community is somewhat active. To be honest, that choice was \(and still is\) fanboism toward GNU project as one of the most prominent community geared toward building free/open software. At that time, I tried Gambit but experience was not very good at that time in particular regarding module system. I did not buy the "build your own language" philosophy of Racket and was not particularly attracted to chicken. My choice was and still is not completely rational. Nowdays, Guile has fibers which are particularly appealing asynchronous framework/library. To be complete, I will add that I choosed Scheme because of its standard commitee that is group based and more importantly because of its philosophy, quoting R7RS: &gt;Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary. Scheme demonstrates that a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language that is flexible enough to support most of the major programming paradigms in use today. I wanted to learn functional programming in a context that is more "pragmatic" than haskell and shen, that is with a lisp syntax. \&gt; Neon, for example, could use a speedier implementation, no? Well, I started Neon with 'chez' but debugging is more complicated. Even Guile debugging is not as easy as Python, it's better than chez. Also 'chez' doesn't have readily available web libraries. Racket doesn't support POSIX threads. I tried bigloo but the documentation is scarse. Again, I did not consider chicken too much for no good reasons. Actually, I faced two options: 1. Build the database service using chez and the web interface using Guile \(that option requires serializing the queries\) 2. Build everything in Guile I choose the option 2 because at the end of the day, I don't need speed and at this point \(except OpenCog\) scheme users don't need to scale they first need the correct tools to bootstrap. Also I want to keep things simple. The initial reason I started working with wiredtiger and then Guile is to research database abstractions that empower developers to express ideas. I am researching the minimal abstraction that provide the maximum flexibility. I think I reached that goal with Neon. To keep things simple in terms of deployment and configuration, which is an open problem to me, I choose the monolithic path everything in a single process that is written in Guile. The two services \(guile backend \+ chez database\) option also requires to serialize the database queries which is a pain IMHO. Mind the fact, that this is not possible to do in Python. CPython is much slower than Guile, and even if PyPy is faster, because of the Global Interpreter Lock you can not embed the database in the same processus. So it goes against the KISS monolithic principle. Also, Ahead Of Time \(AOT\) compilation is in the GNU Guile roadmap, I expect similar to 'chez' performance in the future. \&gt; Roadmap for Culturia? Well, Culturia has really no roadmap per se even if I write down from time to time what idea I have at some moment... it's more like an ongoing research project for an interesting end\-user application. When I started I wanted rewrite opencog then to build a NLP toolkit, then a wiki, then a search engine, then a blog, then a personal knowledge base etc... I trying hard to apply the [monorepos](https://hn.algolia.com/?query=monorepo) idea. Basically, instead of creating a new repository each time I have a new idea, I \(try\) to code everything in the same repository to be able to share code between "projects" and help my followers to keep track of what I am doing. That said, I mostly fail to stay in the same repository. For instance, Neon has its own repository. Simply said, there is really no clear roadmap for culturia. The goal I have for it, is to build an application that will be my "homepage" using the result of my researches in database, backend and frontend dev using Scheme. That being said, I have another idea about cutluria roadmap... \&gt; How are you going to use NLP in it? Well, when I started I was not sure what were the possible applications of NLP except that I wanted the AI of culturia to be an Intelligence Aumentation \(IA\) software, hence the ia in culturia. Now, I know that: 1. The user interface will be a ipython\-like notebook REPL except that it will use Natural Language \(NL\). In this context [rasa natural language understanding will be helpful](https://github.com/RasaHQ/rasa_nlu). That being said, the get started I can put to good use regex and pattern matching. The reason for this REPL NL is to keep things simple. With a powerful language understanding feature you can factor all the menu in you application into a single input box. That being said, there will be widgets for displaying specific data, map and calendar comes to mind. Just like ipython notebook does, most of the time it ouputs strings but sometime \(and more and more\) it displays graphics or interactive data viz. 2. Mostly the commands will be what you can do with other softwares, calendar, email, feed reader, bloging, note taking, messaging whatever. Those don't require really require NLP. 3. What requires NLP, is the search and research tutoring application. Things like can you summarize that blog post, what are key terms, what's the main idea. Give me similar results but don't pick things that talks about Python language. Also, word2vec like library can help the user with other search terms like Google try to do already. \&gt; What's your development environment? Emacs? \+ Geiser/SLIME? Something else? Yes, I use emacs by habit with [bm](https://github.com/joodland/bm), ag and rainbow\-delimiters. 
Hey, amirouche, just a quick heads-up: **commitee** is actually spelled **committee**. You can remember it by **double m, double t, double e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
&gt;Would you say Scheme is your most favorite programming language? What do you miss from other languages? Scheme is definitly my favorite programming language, the R7RS quote from the previous reply summarize my goals as engineer. Here is it again: &gt;Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary. Scheme demonstrates that a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language that is flexible enough to support most of the major programming paradigms in use today. I like the fact that the community has many implementations, it feels like I have choices and different trade\-offs. People cooperate but at the same time they compete. I like that Guile displays variable values in tracebacks. I miss from other community a broader recognition. I would like to work professionally in scheme because I think it's the right path for software enginerring.
Thanks for the detailed reply. Your replies are very informative for someone like me who's learning Scheme. I'm curious whether you've seen https://www.cs.indiana.edu/chezscheme/debug/? Would you still say debugging Chez programs is harder than Guile debugging?
&gt; Amazing! Thanks. &gt; Although I'd say "def" is cheating a little bit ;) Do you think so? In fact "def" is used "temporarily" to build easily readable expressions, then disappears in the last expression with nothing but words, lambdas and applications. 
I've done some scraping tasks previously with scheme, I used Gauche at the time and it was a good experience overall (I just used the libraries that were bundled with Gauche).
Use jsoup with kawa
Does it support TCO?
I am also using gauche. Gauche is useful for text processing. Gauche's string has been designed that be able to use multibyte character strings. (It is necessary for me as a Japanese.) But, be careful to random access and mutation. It is [very slow](https://practical-scheme.net/gauche/man/?l=en&amp;p=Strings). If you want parse broken HTML, I suggest to use [html-prag](https://planet.racket-lang.org/package-source/neil/htmlprag.plt/1/6/planet-docs/htmlprag/index.html) at same time.
TCO, or Tail Call Optimization, is, of course, an "optimization". Proper Schemes don't need this because they already properly handle tail calls. So, I think the question you really want to as is: "is there a call stack?" The answer is: No. 
Further clarification: Calysto Scheme can call Python code directly. When it does, it uses Python's call stack. When calling its own functions, there is no call stack. So this would work fine: (use-stack-trace #f) ;; turn off debugging (define loop (lambda () (loop))) (loop) More info here: [http://nbviewer.jupyter.org/github/Calysto/calysto\_scheme/blob/master/notebooks/Reference&amp;#37;20Guide&amp;#37;20for&amp;#37;20Calysto&amp;#37;20Scheme.ipynb](http://nbviewer.jupyter.org/github/Calysto/calysto_scheme/blob/master/notebooks/Reference%20Guide%20for%20Calysto%20Scheme.ipynb)
Part of why you're finding this difficult is because this doesn't cleanly fit into scheme. We tend to avoid infix operators.
I know, I'd rather not dwell too much in infix-operators, this is more like a proof-of-concept. I'm fucking the basic Scheme-operators in a major way just to see how far can I go. An example of this macro in action. ```scheme (define (rev xs) (let^ rec aux := (λ x y -&gt; (cond ((Ø? x) y) ((¬ (O? x)) ⊥) (else (aux (tl x) (:: (hd x) y))))) in (aux xs Ø))) ```
Thanks, especially for mentioning html-prag and text processing in Gauche! I didn't know about the text processing, that certainly adds weight to it's use. Slow random access in Unicode strings is to be expected and string mutation is very rarely needed in my experience so neither is an issue for me.
Why not put **in** and **and** in your literals list and have separate rules instead of those **cond** forms? Otherwise your use of syntax-case itself seems fine, but the macro output itself seems odd in the first output clause - you bind x with define, and then immediately hide it by binding x again with lambda.
This is exactly the transforms we took to turn a complete Scheme language written in Continuation\-Passing Style Scheme into Python and C#: [https://github.com/Calysto/calysto\_scheme/blob/master/calysto\_scheme/src/Makefile](https://github.com/Calysto/calysto_scheme/blob/master/calysto_scheme/src/Makefile) CPS Scheme \-\&gt; Data Structure Scheme \-\&gt; Register Machine Scheme \-\&gt; Python or C# It isn't quite self\-hosting yet \(we use Chez Scheme to do transformations\) because the limits of our define\-syntax. But it is a full Scheme language \(and can use Python libraries as well\). Currently it is a couple of magnitudes slower than C# or Python, but we have some ideas.
Actually that is how letrec* is defined. The definition holds on the appointed closure so it can be called again and again. I did cast them as literals, but I'm trying to learn syntax-case specifically (which might be for nothing, considering the direction of R7RS). Thus the `free-identifier=?`-checks
Oh yeah I've been Google Translating Kei's blogposts every now and then. My japanese is too poor, especially considering Kanji, but wasn't he the guy behind Sagittrius? Some scheme-implementation anyhow, I copied his portable er-macro-transformer macro and it's hella cool
Good point, I need to take a closer look t the code. And yeah, I've tried to delve myself into fenders but I think the problem of not speaking english natively (or not understanding some of the Scheme core concepts) is putting me off from understandin syntax-case wholly. Also I guess I agree with the general criticism against `syntax-case` and I'm still hoping for a decent understandble hygienic macro system to come. Syntax-case is too cryptic atlest at the moment to serve the purpose, so I'm looking at er- and ir-macro-transformers also. Like I said this is kind of a test on how far can I take the syntax-case on creating new syntax to parse.
[my fucked up syntax so far](https://github.com/karahobny/scheme-misc/blob/master/guile-prelude.scm). feel free to point out some mistakes, if you will.
This stuff is tricky for english-speakers too. ;-) 
Yeah I bet and it might kinda be the last nail in the coffin of `syntax-case`
I recommend that you bind *auxiliary syntax*. In this case, `-&gt;`, `..`, `rec` and others. Please remember standard's `else`. It is bound. Simple definition is a following. ``` (define-syntax -&gt; (syntax-rules())) ``` Better definition is such as: ``` (define-syntax -&gt; (identifier-syntax (syntax-violation #f "misplaced aux keyword" #'-&gt;))) ``` User gets a solution for the case of name conflict. When we use it at wrong place, implementation inform error with understandable message. By the way, names starting with `-` or `.` are illegal in R6RS, except `-` and `...`. Portability is improved by change them. (Not important. I do not know Scheme implementation that does not allow it.) 
Good point. Iv'e seen that used elsewhere but never really thought about using identifier-syntax =&gt; syntax-violation's myself for some reason.
Also, thanks again, I think I'm looking for the least common denominator in applying ML-syntax and leave the `:='-literal out. Also applying SaitoAtsushi's fine points and re-defining my lambda with a `=&gt;'-literal instead of `-&gt;'. Still thinking of a nice quick symbol to indicate a rest arg lambda. So far new syntax: ``` (define (rev xs) (let^ rec α (λ x y =&gt; (cond ((Ø? x) y) ((¬ (::? x)) (error "rev expects a proper list")) (else (α (tl x) (:: (hd y) y))))) in (α xs Ø))) ``` To continue this specific example. I might leave `:=` for `(define)` and very APL/J-like syntax for quickly defining vars and procs, but I'm also messing with the guile Guix Monads module so I'll see if I can set everything as immutable only holding references to them, that's how ML-type languages reserve the `:=`-syntax for.
If I were to disallow all mutative (side-effect generating) procs, should I use `(error)` or this type of `(syntax-violation)` etc. or some other way? What are your opinions?
If you're looking at munging together the syntax of various terse languages, I'd recommend throwing scheme's [named `let`](https://www.scheme.com/tspl4/control.html#./control:s20) into the ring as a possible candidate. I think for examples like `rev`, it's a lot more natural than `let rec x = y in z`: #lang racket (define (rev xs) (let loop ((ls xs) (acc '())) (cond ((null? ls) acc) ((not (pair? ls)) (error "rev expects a proper list")) (else (loop (cdr ls) (cons (car ls) acc)))))) (rev '(1 2 3 4 5)) ;=&gt; '(5 4 3 2 1) Also, while you're playing around... If you implement a [thrush combinator](https://docs.racket-lang.org/threading/index.html) and [anonymous function literals](https://blog.racket-lang.org/2017/02/on-application.html), you get something that's concise but legible. Here's a tiny implementation to ponder that makes use of some racket specific features: #lang racket ; Basic thrush combinator (define-syntax ~&gt; (syntax-rules () [(~&gt; v) v] [(~&gt; v (f a ...) fs ...) (~&gt; (f a ... v) fs ...)] [(~&gt; v f fs ...) (~&gt; (f v) fs ...)])) ; VERY naive function literal support that will ; replace (+ 1 %) with (lambda (x) (+ 1 x)) (require (rename-in racket (#%app core-app)) (for-syntax syntax/parse)) (define-syntax (#%app stx) (syntax-parse stx [(_ pre ... (~datum %) post ...) #'(lambda (x) (core-app pre ... x post ...))] [(_ fn vals ...) #'(core-app fn vals ...)])) (~&gt; '(1 2 3 4 5) (filter (even? %)) (map (* 2 %))) ;=&gt; '(4 8) (syntax-&gt;datum (expand #'(~&gt; '(1 2 3 4 5) (filter (even? %)) (map (* 2 %))))) ;=&gt; '(#%app map (lambda (x) (#%app * '2 x)) ; (#%app filter (lambda (x) (#%app even? x)) ; '(1 2 3 4 5))) 
You might try both [geiser](http://www.nongnu.org/geiser/) and [racket-mode](https://github.com/greghendershott/racket-mode) to see which works better for your setup.
geiser doesn't have support AFAIK for typed/racket (racket-mode has the nice `racket-run` or w/e function for loading the #lang). geiser is doable, but atm it isn't much better than nothing. Also, Ithought I posted about `racket-mode` having a lag typing anything out, but the new Reddit isn't showing me anything
&gt; but the emacs-mode has this unexplainable lag with typing characters and them actually showing up. You didn't mention a mode so I suggested both. Geiser doesn't support the full set of features with custom `#lang`s (especially custom lexing) but it works great for me with vanilla `#lang racket`.
`syntax-violation` is representation of syntactic error. I think it is not proper to use it as argument type error. In this case, in my opinion, good choice is making new condition type with some [standard type](http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-8.html#node_sec_7.3) as parent type by [define-condition-type](http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-8.html#node_sec_7.2.1). The specific definition depends on your policy. Recoverability, seriousness, message for users... There are two ways to combine condition types in R6RS. It is compound and inheritance. It is difficult to use different way depend on situations. I have not found best practice. 
Yeah, I'm super interested in `#lang typed/racket`. I'm even implementing a kind of a contract system for guile with the exact same syntax, but there's still a lot to figure out, but it's pretty cheap "for each variable check that they are the predicate contracted and the returning value is of the return predicate contracted". I definetly love Racket and I wish I'll fix the lag issues with racket-mode somehow (fucking with gc-threshold or something like that).
Sounds similar to this: [Is Scheme Faster than C? by Jonathan Sobel](https://web.archive.org/web/20100310163003/https://www.cs.indiana.edu/~jsobel/c455-c511.updated.txt).
This must be it, though I seem to have misremembered quite a lot. Thanks.
[Here is a very old Hacker news thread on this story](https://news.ycombinator.com/item?id=2235281). [Here is a 2001 Dan Friedman talk that recounts this story (PDF)](http://www.cs.indiana.edu/hyplan/dfried/mex.pdf).
In Dan Friedman talk, I don't understand why emulating tail call in Java is a good thing. Help?
You make me think. I am considering moving to chez. See [**https://github.com/cisco/ChezScheme/issues/304**](https://github.com/cisco/ChezScheme/issues/304)
Glad to hear that Chez is not that bad for debugging as I'm learning it too.
Nice explanation, but I feel that it lacks _actual_ motivation (feel free to correct me if I'm wrong): in strict functional programming, functions can't be recursive because they can only refer to their inner state (themselves being out of that scope). The Y combinator allows us to work around that limitation by finding the fix-point of a higher-order function (which can _not_ be recursive itself--here `factorial-generator`). This fix-point happens to be equivalent to the regular recursive function. Also see http://rosettacode.org/wiki/Y_combinator.
stis syntax-parse is pretty complete, and the cases where it doesn't work are well documented. I can only recommend it.
On my environment -- Windows, Akku is not able to use because file name cannot contain colon. I think language implement's help is necessary to solve this problem. For example, percent encoding of file name as like Sagittarius, Ypsilon. I hope this behavior is standardized. 
Just so you know, Chicken has a javascript backend, see the spock egg.
Thanks for pointing that out. If the Emscripten thing doesn't work out I'll look into rewriting the backend code that talks to SDL2 to work with spock.
How do the FFI calls in the SDL egg map to emscripten calls?
This guy called Steve Yegge seems to disagree 😏 [https://sites.google.com/site/steveyegge2/the\-emacs\-problem](https://sites.google.com/site/steveyegge2/the-emacs-problem)
Try Chicken Scheme, e.g. But since even Windows is POSIX, basically every Scheme via C compiler should cover your platforms.
Chez is getting there through the work by the racket7 folks. You should probably be able to run everything else through wsl :) Racket is not strictly scheme, but it is pretty comfy.
[Gambit](https://github.com/gambit/gambit) is very portable (see [Lambdanative](https://github.com/part-cw/lambdanative), a cross-platform development environment, based on Gambit).
Chicken scheme on windows is annoying to me. Sure you might be able to compile everything from C, but deploying C (or really anything) on windows is just such a headache. 
Is spock still alive?
Kawa. It's written in Java so as long as you have a jvm you can run it.
Gambit is both one of the fastest Schemes and the most portable. If you have a decent C compiler on your system then you can use Gambit. It has several configuration options to remove some features you might not need, and to tune its performance. It will automatically take advantage of gcc features if you are using it. It has an interpreter with lots of debugging features, and you can mix compiled and interpreted code freely. You can easily generate executable programs by using the "\-exe" compilation option. You can also easily interface to C code and libraries with its FFI.
I really want to like Kawa, but man those benchmarks were not kind to it. Also, TCO-shenanigans and some other stuff.
Using type annotations can give orders of magnitude improvement in run time, especially in number crunching code.
We should write more about how it works. The main idea is that "code is data." Calysto Scheme is written in Scheme in Continuation\-Passing Style \(CPS\). That version is translated into Scheme with Data Structures, and then that code is translated into Scheme as a Register Machine. Finally, that code is converted into a target language \(we have implemented C# and Python, but could be Assembly Language, or any other language\). The result is a Scheme with all of the bells and whistles \(continuations, amb/choose/fail, quasi\-quotes, define\-syntax \(macros\), etc\). Plus, a little glue code allows it to use Python libraries, functions, etc. I talked a bit about this at PyCon 2018: [https://docs.google.com/presentation/d/1NQ0tH88PNS8y9IHpC5xatRf6DMtVLBtMIWdkiiHE\_9E/edit?usp=sharing](https://docs.google.com/presentation/d/1NQ0tH88PNS8y9IHpC5xatRf6DMtVLBtMIWdkiiHE_9E/edit?usp=sharing) We have also implemented Calysto Hy that wraps Hy up so that it can be used in Jupyter, so you can easily compare these languages yourself. The big difference is that Hy merely converts Lisp syntax to Python syntax. So a Hy function is merely a Python function. On the other hand, a Calysto Scheme function uses continuations without a callstack, has TCO, has different scoping rules, etc. You can read more about the differences here: [http://nbviewer.jupyter.org/github/Calysto/calysto\_scheme/blob/master/notebooks/Reference&amp;#37;20Guide&amp;#37;20for&amp;#37;20Calysto&amp;#37;20Scheme.ipynb#Differences\-Between\-Languages](http://nbviewer.jupyter.org/github/Calysto/calysto_scheme/blob/master/notebooks/Reference%20Guide%20for%20Calysto%20Scheme.ipynb#Differences-Between-Languages)
Gerbil Scheme. [http://cons.io](http://cons.io)
Thank you for answering and yes I've kinda missed guix except for its excellent monad-module.
Gerbil adds a lot of features to Gambit, on which it is based; it is likely to be as portable as Gambit.
If you are just looking for a Scheme environment that will run everywhere (Unix, Windows, Plan 9, your toaster), you might try [S9fES](http://t3x.org/s9fes). It's not the fastest, but will run on any system providing a C89 compiler and a few megabytes of RAM.
I recommend writing it out in pseudo-code first. If you know a good prototyping language like Python, try building a proof-of-concept there. Then translate to Scheme. The basic thing you need is some kind of a "next_tree" routine. This routine takes a tree as input, and generates the "next" tree. To get the binary tree with one node (root): next_tree(empty_tree) Now that you have a root, you can generate the binary tree with the root and two child nodes: next_tree(next_tree(empty_tree)) Once you have a binary tree with a root and two child nodes (let's call them L and R), each of these nodes can have children as follows: 0) L and R each have no children 1) L has a child but R does not 2) R has a child but L does not 3) L and R both have children Notice that this is just binary counting order (00, 01, 10, 11) with the caveat that condition (0) is ignored because that is the condition in which we first called `next_tree `-- (a root and two child nodes with no other children). So, you count through each of these conditions and once you reach (3), another invocation of `next_tree` will increase the total depth of the tree to the next "layer", where you will recursively apply this same logic. Just fill in the details and you will have an enumeration of trees.
This may sound like a bad answer, but why design it yourself? We already have SRFI 121 which can give you generators. I am fairly certain the github implementation works on chibi, so you should be able to get it going. I suggest writing a generator using `make-coroutine-generator`. See the docs at https://srfi.schemers.org/srfi-121/srfi-121.html
Not a bad answer, I've been looking at that SRFI and 158 to learn from them and am considering using them. :) The only reason why I'm trying to design it myself is to learn. I don't have a formal education and as a result I'm missing a rather large number of obvious solutions to common problems. So whenever I come across something that I don't understand, especially if it seems like other things I've been toying with have a similar pattern I try to take the time to understand how and why it works. Hence the desire to design it myself.
This was roughly what I had in mind. The trouble however is that each level has multiple returns. This means that either one needs to somehow figure out how to pass state all over the place. Alternatively one needs a construct like yield which keeps the recursion stack in place (to keep the state in the stack). Am I wrong in this? I mean I would /love/ to be wrong in this but I can't see another way of doing it?
Crap. After re-reading my post above, I now realize that it won't work because it assumes that the tree is growing row-wise (all sub-trees with depth less than d are full). I recall seeing a purely recursive solution to tree enumeration; IIRC, I think the trick is that you need double-recursion.
This problem is really bugging me, not sure why. I found [this SE question](https://softwareengineering.stackexchange.com/questions/261143/how-to-enumerate-generate-all-possible-binary-trees-from-n-leaves-and-n-1-nodes) and I think the answer will work for you scenario, too.
So I've gone through that SE question, but I'm not really making heads nor tails of the pseudo code. I managed to get the following partially working in Lua, except that it /also/ generates trees that are smaller than specified: function livep( c ) if ( coroutine.status( c ) == 'dead' ) then return false else return true end end function c( n ) local t,L,R = { } if ( n == 0 ) then return 'x' end for i=0,n-1 do L,R = coroutine.create( c ), coroutine.create( c ) while( livep( L ) or livep( R ) ) do if ( livep( L ) ) then t.l = coroutine.resume( L, i ) else t.l = 'x' end if ( livep( R ) ) then t.r = coroutine.resume( R, n - i - 1 ) else t.r = 'x' end coroutine.yield( t ) t = { } end end return 'x' end x = coroutine.create( c ) while ( livep( x ) ) do print( bstring( coroutine.resume( x, 2 ) ) ) end This returns: (x(xx)) (xx) ((xx)x) (xx) x This being incorrect as it should return `(x(xx))` and `((xx)x)`, where `x` represents a null node (used as such in the rest of the code). `bstring` just turns the tree into a string representation Now the statements like `return 'x'` and `t.l = 'x'` etc, in `c()` are the points where the function (incorrectly) returns smaller trees. So it's pretty close to working, but I'm not sure how to get the rest of the way. In particular, I /don't/ want it to return smaller trees, only the trees with the specified number of nodes.
RemindMe! 1 day
I will be messaging you on [**2018-06-10 03:53:05 UTC**](http://www.wolframalpha.com/input/?i=2018-06-10 03:53:05 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/scheme/comments/8p0h3b/generators_i_think_its_called_in_scheme/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/scheme/comments/8p0h3b/generators_i_think_its_called_in_scheme/]%0A%0ARemindMe! 1 day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
[SICP](https://www.youtube.com/watch?v=2Op3QLzMgSY&amp;list=PL8FE88AA54363BC46) is the classic introduction to Scheme. It even comes with a book with exercises. [SICP book](https://mitpress.mit.edu/sites/default/files/sicp/index.html) See also: [how to use Racket for SICP](https://stackoverflow.com/questions/19546115/which-lang-packet-is-proper-for-sicp-in-dr-racket)
I don't know of any Scheme projects similar to Typed Racket. 
If you aren't concerned with the particulars of Scheme itself, I'd instead recommend the latest and greatest version of How to Design Programs. I suggest this because while Scheme the language is great, in many cases what's historically been Scheme practice and style is now a bit dated from the perspective of much of modern functional (or even semi\-functional) programming language practice. I think the Racket framework/toolkit/language/library gives you a more modern look at what's great about languages of this flavor, alongside a strong, well\-supported community. You aren't prevented from SICP, but for my money it's not where I'd go for your use\-case if I weren't looking at the language as an historian of programming languages or a PL community &amp; style anthropologist.
 (define (dup list) (cond [(null? list) list] [(null? (cdr list)) list] [(eq? (car list) (cadr list)) (dup (cdr list))] [#t (cons (car list) (dup (cdr list)))])) (dup '(1 1 1 2 2 2 2 1 2 2 3 3)) ;=&gt; (1 2 1 2 3) My code has four cases. First, is the list empty? If yes, return it. Second, does the list contain only one element? If yes, return it. Third, are the first two elements equal? Skip the first element and return the rest of the list. Fourth, otherwise? Keep the first element and continue processing the rest of the list.
Thank you! And this uses tail recursion because the final call is the recursive function correct? 
Both Kawa and Bigloo support some optional typing, see [here for Kawa](https://www.gnu.org/software/kawa/Types.html) and [here for Bigloo](https://www-sop.inria.fr/indes/fp/Bigloo/doc/bigloo-28.html#The-syntax-of-the-foreign-declarations). Both are much more limited than what Typed Racket tries to achieve, so it's up to you to decide how much mental bandwidth you want to spend for typing. 
Last time I checked, Typed Scheme didn't support type inference. Just something to keep in mind.
No. The final call is `(cons (car list) (dup (cdr list))` because in the fourth case the call to DUP is not returned, but is instead wrapped in a tail to CONS, which is returned from the function. Do you know the steps required to turn this function into a tail-recursive version?
Oh.. then in that case im not sure. I thought tail recursion was when you create something recursively by appending to the end of a structure. How do i need to approach it to get tail recursion 
CS 61A too: https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E https://people.eecs.berkeley.edu/~bh/sicp.html 
Tail recursion happens when your implementation does not have to "remember" the previous function calls to compute the value of the next recursive calls. Here, the CONS calls need to be remembered, so the implementation is not tail recursive. Hint: try accumulating your computed values inside an extra argument to the function, and when you are done, simply return that argument. This will require a helper function, most likely, since you want to expose a one-argument interface to the user, but your internals will use two arguments.
Chechen Scheme has optional types as well. 
I was wondering why there're Typed Racket and Lazy Racket but not a combination of the two. It turned out it exists: [Hackett](https://github.com/lexi-lambda/hackett), a Haskelly Scheme. It's far from complete right now but, even in its current state, it's got very powerful features. Since you seem to have taken a liking to Haskell, I'm sure you'd love Hackett. --- I'd also like to mention [Carp](https://github.com/carp-lang/Carp), even though it's not a Scheme. It's a GC-less Lisp intended for IO heavy programs.
There is currently a project name Lux that aims at creating a lisp (derived from cojure) with a type system like Haskell including strongly typed macros. https://github.com/LuxLang/lux
Okay, so I have a functioning version in Lua, it seems to be pretty close to the SE question claytonkb posted (except for the use of coroutines). Messy code ahead: create,yield = coroutine.create, coroutine.yield resume,status = coroutine.resume, coroutine.status function bt( n ) local c = create( function( ) local i,l,r if ( n == 0 ) then return 'x' end for i=0,n-1 do for l in bt( i ) do for r in bt( ((n - i) - 1) ) do yield( { l = l, r = r } ) end end end end) return function( ) if ( status( c ) ~= 'dead' ) then local _,t = resume( c ) return t end end end The `bt()` function is defined the way it is to take advantage of Lua's for loop structures, in particular the lines `for x in bt( y ) do` returns a function to the for loop which then keeps getting called until it returns `nil`. It makes the code a little cleaner as (in my laziness) one needs two nested while loops each having multiple calls to resume, etc. So I have a functioning program that generates (on demand) binary trees of specified sizes! :D I'm quite unsure how to convert this code to scheme though. Especially with the coroutines (which I don't know how to remove) in the mix. Effectively, the coroutines suspend the computation at a given point. Most people would say this is what call/cc is for, and maybe I should look into that again. But in my experience call/cc creates errors rather than solutions. I'm currently looking into Chibi's threading capabilities. If anybody can think of a way to remove the coroutines that would also be nice. :)
hope it's strongly typed, hygienic, referentially transparent macros 0_o really, I miss simple textual substitution macros...
&gt;I tried searching for an existing implementation, but I didn't find one. Assuming you actually mean a [TI-Nspire](https://education.ti.com/en/products/calculators/graphing-calculators/ti-nspire-touchpad) and not an Nspire CAS or Nspire CX, an interpreter already exists (not sure about REPL, but they included the source code, so it can be extended). Step 1: Use the TI-84 Plus Keypad Step 2: Download and install [Spencer Putt's Scheme interpreter](http://spencerputt.com/scheme/scheme.8xk) for TI-83+, from Google Summer of Code 2007. If that version does not work, try the version in [this TAR](https://web.archive.org/web/20160112164533/https://google-summer-of-code-2007-detached.googlecode.com/files/spencer_putt.tar). Barring that, no, nothing already exists.
These might be good initial resources: * https://hackspire.org/index.php/Hackspire_Home * http://www.t3x.org/t3x/book.html * http://www.t3x.org/clc/index.html
Here is an implementation of LINQ in (mostly portable) R6RS Scheme. https://github.com/leppie/IronScheme/blob/master/IronScheme/IronScheme.Console/lib/ironscheme/linq.sls Was a fun exercise for a primarily .NET programmer. It ended up being quite useful too.
I have the TI-Nspire CX and do not have a TI-84 Plus Keypad. I don't know much about other TI calculators. Are TI-83+ programs compatible with the CX?
&gt;Are TI-83+ programs compatible with the CX? They are not. The original TI-Nspire (and TI-Nspire Touchpad) had interchangeable keypads. One of the keypads was for normal use, and the other one made the calculator operate like a TI-84+ (contained a TI-84+ emulator). TI-83+ programs are compatible with the TI-84+, so you can use that keypad to run TI-83+ stuff.
[removed]
Thank you, I'll have a look at that. :) Having taken a look it's pretty neat code with a few tricks that I've been trying to implement in some of my projects.
I've never used gzochi, so I probably won't be good for more questions, but: the "configure" file is in the download. just decompress the .tar.gz archive. you can run it by typing "./configure". the client for [mazewar](https://gitlab.com/joolean/gzochi/tree/master/examples/mazewar/client/src) is writtten in "C", so probably any language that can do networking would work. I don't know, but I don't see why you couldn't write a client for mobile, since _I think_ all you need is communication over the network.
It is a neat way to write self-referring function definitions with lambdas alone, but does not work as Y combinator, because you still need to write your functions with additional argument [the function itself] and passing it around, right? and then the only way I see to fix it is the original Y (actually: Z) combinator anyway... or am I missing something? also, what about mutual recursive definitions? [there might not be a problem with them, just asking so that I don't have to think myself :)]
No, in the original text this Y is inlined; as long as Y is not bound in its own definition, nor needs to be in the definition of its first argument, it is fair.
But is more of a Haskell than scheme.
Link seems broken? http://practical-scheme.net/gauche/gmemo/index.cgi?Release%200.9.6
Chicken Scheme? Cause chicken scheme does, heh. 
I get there with the link you posted.
I really like to work with Gauche Scheme - it has a large library, good documentation and is quick enough for usual tasks. And it did never let me down when using it for AoC 2017. Probably the main feature of the new release is generation of standalone executables (not by compilation in Chicken/Gambit/Bigloo style but by some tricks explained [here](http://blog.practical-scheme.net/gauche?20180405-standalone)). Still very convenient to distribute one-off scripts. Some embarrassingly simple compilation results: * Executable size for a "Hello, World" (Linux, 64-Bit): SBCL &gt; Gauche &gt; Gauche &amp; upx &gt; Bigloo (47 MB &gt; 17 MB &gt; 4,6 MB &gt; 3,2 MB) * Start-up time for the executable: Bigloo &lt; SBCL &lt; Gauche &lt; Gauche &amp; upx (all in the range of 0,01 sec .. 0,1 sec; with JVM-based Kawa as the expected outlier with ~0,6 sec) 
I tried to install Gauche 0.9.6 on Xubuntu 18.04 and got following errors: Testing interactive ... \*\*\* ERROR: cannot find "rfc/zlib" in ("../test" "../lib" "../libsrc" "../src" "/usr/local/share/gauche-0.9/site/lib" "/usr/local/share/gauche-0.9/0.9.6/lib" "/usr/local/share/gauche/site/lib" "/usr/local/sha ... While compiling "../lib/text/info.scm" at line 34: (define-module [text.info](https://text.info) (use srfi-13) (use srfi-14) (use text.parse) (use gauche.process) (use file. ... While loading "../lib/text/info.scm" at line 45 While compiling "../lib/gauche/interactive/info.scm" at line 34: (define-module [gauche.interactive.info](https://gauche.interactive.info) (use srfi-1) (use srfi-13) (use [text.info](https://text.info)) (use file.util) (us ... While loading "../lib/gauche/interactive/info.scm" at line 45 While loading "../test/interactive.scm" at line 9 Stack Trace: \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ 0 (map (lambda (sym) (global-variable-ref module sym #f)) (hash ... at "../lib/gauche/test.scm":380 1 (toplevel-closures mod) at "../lib/gauche/test.scm":330 2 (for-each (lambda (closure) (for-each (lambda (arg) (let ((gr ... at "../lib/gauche/test.scm":314 Testing r7rs-tests ... passed. Total: 19471 tests, 19471 passed, 0 failed, 1 aborted. Makefile:463: recipe for target 'test-summary-check' failed make\[1\]: \*\*\* \[test-summary-check\] Error 1 Makefile:48: recipe for target 'check' failed make: \*\*\* \[check\] Error 2 ======================= Can anyone help me to sovle the errors? Thanks, Tsaifuan
Anyone know vim syntax plugin for recent Gauche?
How can I register to attend? 
You could try using selenium. It runs as a local server and exposes a rest api you could interact with. 
I suspect Gauche didn't find zlib during build and didn't make rfc.zlib, but some tests unconditionally relied on it. My bad. Could you check if you have zlib1g-dev package? If not, could you try install it and rebulid Gauche?
&gt;zlib1g-dev Shiro, Yes, after installing zlib1g-dev, gauche 0.9.6 was installed successfully on my Xubuntu. Thank you. Tsaifuan
r7rs says to use delay/force to create streams. So I guess you'd have a list of lists of trees of increasing size: ( ( x ), ( (xx) ) ... ) with the cdr being delayed and upon forcing it would take the already forced lists of trees of smaller size and construct the trees of the next size. But I'm not fluent enough in scheme to write that out on a whim.
I think you ned (... ...) to escape ... inside a inner macro definition
Thank you very much ! Your answer helped me to find [https://stackoverflow.com/questions/38275779/capturing-a-variable-number-of-arguments-via-an-ellipsis-in-a-nested-macro-miss](https://stackoverflow.com/questions/38275779/capturing-a-variable-number-of-arguments-via-an-ellipsis-in-a-nested-macro-miss) which is what I was after. So it ends up with (... (syntax-rules (define-syntax g (syntax-rules () ((_ f x) (define-syntax f (... (syntax-rules () ((_ y body ...) (begin (display (+ x y)) body ... ))))) ))) (g gizmo 123) (display (gizmo 42 54 'Total "Win" (display "Yeah"))) 
R5RS do not include escape of ellipsis. You can use dot pair. ``` (define-syntax g (syntax-rules () ((_ f x) (define-syntax f (syntax-rules () ((_ y . body) (begin (display (+ x y)) . body ))))))) (g gizmo 123) (display (gizmo 42 54)) ``` In R7RS style, give identifier as ellipsis to `syntax-rules`. ``` (define-syntax g (syntax-rules () ((_ f x) (define-syntax f (syntax-rules ::: () ((_ y body :::) (begin (display (+ x y)) body ::: ))))))) (g gizmo 123) (display (gizmo 42 54)) ```
Thank you very much, great answer !
That's actually not a bad idea, thank you! :) I've got some vague idea of how to do something like that. I recently moved so this project is somewhat on hold. I've gotten some ideas from the r/Lua as well. Once the move is complete and I've had some time to work on memoization and porting from Lua I'm hoping to post the code here for anyone who's interested. :)
Here's a sneak peek of /r/lua using the [top posts](https://np.reddit.com/r/lua/top/?sort=top&amp;t=year) of the year! \#1: [Lua 5.4 has decided to move to 0-based indexes!](https://np.reddit.com/r/lua/comments/88sgte/lua_54_has_decided_to_move_to_0based_indexes/) \#2: [Helping to make LuaJIT faster](https://blog.cloudflare.com/helping-to-make-luajit-faster/) | [4 comments](https://np.reddit.com/r/lua/comments/77cywp/helping_to_make_luajit_faster/) \#3: [Any interest in a 100 days of Lua for the New Year](https://np.reddit.com/r/lua/comments/7nd6ve/any_interest_in_a_100_days_of_lua_for_the_new_year/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
By the way : is there any downside to the dot pair method, then ?
A list can appear insted of identifier before ellipsis. (define-syntax foo (syntax-rules () ((_ (a b) ...) '(a ... b ...)))) (foo (1 3) (2 4)) Dot pair cannot express this case.
Oh, I see, thank you very much for the practical explanations, they are very much appreciated !
I think that you want [this](https://dspace.mit.edu/bitstream/handle/1721.1/5600/AIM-848.pdf).
That's it, thanks! I should have been searching RRRS instead of R2RS it seems.
Lol at *"We also thank Betty Dexter for the extreme effort she put into setting this report in yTeX, and Don Knuth for designing the program that caused her troubles."* (page 3)
Fascinating. What implementation, GUI toolkit?
It is my own implementation, called Razor Scheme (afrer " Ockham's razor"). The GUI toolkit including the window system is also written by myself from scratch in Scheme. It is a concurrent window systen, which means each window is implemented as an individual process (cooperative thread) and they communicate through channels to pass messages such as key, mouse, and redraw. If you are interested in this, please see the pdf file in the following page. It is written in Japanese, but you can see the figures and piece of codes which help you understand the structure of the window system. [A Scheme extension for concurrent programming and a concurrent window system](https://principia-m.com/ts/0125/index-jp.html)
Did you had any success with your approach ?
I didn't continue with this project, sorry
No worries! I just love to hear about Chicken in conjunction with games... In the end, I will have to write the story on my own ;)
Memoizing a function just means having it save a mapping from arguments to results that it populates as it returns. This means you want to change your function at two points: before it does anything (to return early if it has previously been returned after being called with the same arguments), and right before it returns, to update the mapping. Does this help to give you an idea of how to write a function that can memoize functions like yours? It sounds like the trickiness you are encountering comes from the fact that you are returning by calling a function. But this is not fundamentally different from having a return statement (at least in your case), so I hope it helps you to think about the problem more abstractly like I’ve done above. 
While your description indeed helps quite a bit, I'm having significant trouble working out how to memoize the continuation itself. Although I'm wondering whether I'm not overthinking it. Two possibilities present themselves, the one being that instead of passing `(dsp)` as the continuation passing the memo function (sorta) instead. This is kinda interesting as it folds the nested continuations down to the latest continuation and a string. This is based on the observation that the "return" at the end of the recursion is `(k "x")`. This however is currently outside of my skill in that I'm not figuring out how to do that. This leaves memoizing the continuation itself. So either right before the recursive call or the `(k "x")` call (I'll have to test this) call memo on the continuation. This however leaves me with exactly the same issue I had above in my original question. With that in mind, and trying to work out your hint this leaves another possibility. In the original Lua code that I created for this I replaced a function call with what effectively amounts to a recursive coroutine call (glossing over Lua semantics a smidge). If one (somehow) does something similar here one could have what looks like a recursive call but which has a memo call sandwiched inbetween. Meh, I only really came across continuation passing with this project and it already hurts my head. Anyway, off to see whether I can make any of this actually work.
I’d definitely be interested in helping you solve this, looks like you’ve thought it through a lot. Super busy this week so I can’t type much. But here is a rough sketch: (define (memo f) ; make table to keep track of previous results (lambda (args k) (if (* args in table *) (k (* result from table *) (let ([k* (lambda (x) (* store x in table as result for args *) (k x))] [f* (* wrap f again so it uses the same table for results, but make sure that before we call the k that f* has been provided we store the argument it’s given as a result for f*’s args rather than f’s args *)]) (f f* args k*) Then you have to add another argument to your original unmemoized function so that when t makes a recursive call it calls it’s memoized version rather than the unmemoized version. In a real rush but I can write in detail tomorrow. 
Just did the third release (0.3 version) of my PEG parser library. Basically it’s a tool that helps mocking up a new programming language design a lot quicker. Here’s an example: https://github.com/rain-1/nand-lang This release adds “semantic actions” which are a powerful technique that lets you perform computations during parsing to produce results without a whole extra compiler pass. Happy to answer any questions about it. 
I'm in no rush. :) I've been slowly working on this project (between life) for about two months now so waiting some more isn't an issue. I'm having some trouble understanding your one comment though and my understanding of how the control flow is/should be moving isn't sufficient to work it out myself. To avoid dealing with (as far as I can tell) irrelevant details I made the table global, and have defined `(insert! k v)` and `(lookup k)` that operate on the global table. `(lookup)` returns the value stored at `k` or `#f` if `k` isn't in the table. With that in place I believe the definition for memo should look like: (define (memo f) (lambda (a k) (if (lookup a) (k (lookup a)) (let ( (k* (lambda (x) (insert! a x) (k x))) (f* (memo bt)) ) (f f* a k*)) ))) Apart from being modifier to take a memo-ed function, the recursive call in `(bt)` should then also be modified to call the memoed function instead, something like: `(f* ??? i (lambda (l) (f* ??? (- n i 1) (lambda (r) (k (% l r)) )) ))`. And should be called as `(bt (memo bt) n dsp)`. Am I managing to follow so far?
Yep, thanks for keeping at it! Ran out of time again, but here is some progress (in Racket, but everything should be portable): ``` #lang racket (require racket/match) (define level 0) (define (prefix) (let loop ([i 0]) (unless (= i level) (display " ") (loop (+ i 1))))) (define (% l r) (prefix) (string-append "(" l r ")")) (define (dsp x) (display x) (newline)) ;;; We have to make bt accept an argument of bt so that recursive calls go to ;;; its memoized version. ;;; If you're interested in this sort of thing, you can observe that the ;;; original recursive definition of bt is a 'fixed point' of `make-bt`. ;;; When we memoize the function we are finding another fixed point. (define (make-bt bt) (lambda (n k) (if (= n 0) (k "x") (begin (let lop ((i 0)) (unless (&gt; i (- n 1)) (bt i (λ (l) (bt (- n i 1) (λ (r) (k (% l r)))))) (lop (+ i 1)))))))) (define (make-fib fib) (lambda (i k) (match i [0 (k 0)] [1 (k 1)] [n (fib (- i 1) (lambda (a) (fib (- i 2) (lambda (b) (k (+ a b))))))]))) (define (memo make-fn) (define table (make-hash)) (define f #f) (define (f* e k) (if (hash-has-key? table e) (k (hash-ref table e)) (f e (lambda (e*) (hash-set! table e e*) (k e*))))) (set! f (make-fn f*)) f*) (define bt* #f) (set! bt* (make-bt (lambda (n k) (bt* n k)))) ;;; Doesn't quite work, because `k` is called multiple times inside of the loop ;;; for the same argument to `bt`. (define bt (memo make-bt)) ;;; Works for fib because fib only calls `k` once in its body. (define fib (memo make-fib)) ``` Unfortunately as the comments point out it doesn't quite work because `k` is called multiple times inside of a loop in `bt`. Thus `memo` works for `fib` but not for `bt`. There are multiple ways you can fix this. One way is to make `bt` more amenable to memoization, somehow. This could be as simple as having it return a list of all the trees it construct, rather than calling the continuation on each individually. As it's written right now, I don't think that it can be memoized in the conventional sense. Alternatively, you could modify `memo` to keep track of a list of results that `k` was called with. You'd have to take care to make sure that you didn't accidentally populate this list yourself while returning memoized results! Not trying to be coy and force you to keep following hints, I really did run out of time and have to get to other stuff and would have liked to finish this :) Let me know how you'd like to go on from here.
While I'm still quite bad at thinking about fixed points and how that works having had a quick glance at the Wikipedia page on fixed-point combinators I can see the correspondence you're talking about, so the basic idea is starting to make sense to me! :) Incidentally the line `(f e (lambda (e) (hash-set! table e e) (k e)))` should actually read something along the lines of `(f e (lambda (r) (hash-set! table e r) (k r)))`. :) In terms of how to make bt work with the memo function. I don't actually know how to make it return a list of trees, I only recently got it to work with the continuations, and that's a translation from Lua where I implemented it with coroutines so again no lists of trees. I vaguely suppose that iterating from 0 to n is not that different from iterating over a list so with some thought I could perhaps make that work. Modifying memo to keep track of a list of results seems quite fascinating honestly, but I have no idea how that might be done at present nor where one might start. So in terms of my current skill that option is currently outside of it although I'm quite willing to learn. In terms of modifying it I've actually already done that, except that it doesn't actually work. :P `(make-bt)` gets modified to: (define (make-bt bt) (lambda (i n k) (cond ((= n 0) (k "x")) ((&lt; i n) (bt 0 i (lambda (l) (bt 0 (- n i 1) (lambda (r) (k (% l r)) )) )) (bt (+ i 1) n k) )) )) `memo` would have to be modified to follow suite. I altered the call `(hash-has-key? table e)` to something along the lines of `(hash-has-key? table (cons e i))` (and the other table functions where altered in a similar manner) which I thought is a reasonable way of doing it. This however doesn't work, I'm not entirely certain what the problem is, however I noticed by dumping the table that there are multiple insertions happening for the same arguments. I suspect that perhaps what's happening is a sequencing problem where the lookup happens before the insertion. This already shows up with `(bt 3)`. I should be able to get this working with sufficient effort though so if you're out of time it's not a problem. :) I honestly don't mind following hints as there's usually a certain satisfaction in solving something with minimal information. I just honestly couldn't manage to work it out myself. I'm still busy working through The Little Schemer and am lingering around the section on continuations trying to get a solid understanding. This particular project is reaching a little. Speaking of time though, I caught ill and so may not make much progress over the next couple of days until I've recovered. :) Once I've got a working solution I'll post it here though.
Great to hear that you are making progress! Sadly during the work-week I am super busy between the dog and work. But it sounds like you are on the right track :) I really admire you and hope to help if you are still stuck on the weekend! Looks like the new Reddit UI messes up the rendering; on my computer the `e*` is displayed correctly but I see the same problem as you on my mobile client... Hope you get well! If you have time I hope you let me know how it goes :)
And this has to do with The Scheme Dialect of the Lisp Programming Language how exactly?
Lmao I'm crossfaded as shit and I thought this was related to a completely different concept
Ha this is great. That's what we do here, scheme.
i dont like this
Like scheming 
I'm very sorry 
Thanks my guy, that's what I'm saying. It was a simple mistake. I didn't read the sub description.
Interestingly, this state can help with Scheme sometimes.
I know you don't belong here, but I love you all the same
that's a pretty common race condition when running threads on multiple processors (on the same or different servers). if you want to treat the id check as a service bus, you'd need to additionally pass a token to the user to present instead of id. in some instances, this can be accomplished by a 'wrist band' architecture pattern.
Come for the plans, leave with a copy of SICP and a neckbeard 
I very much regret being as messed up as I was last night, but this mistake was hilarious.
What is this language even used to code?
Gave me a good laugh. No need to be sorry.
Yeet, good😘
Nothing
Does this restaurant serve cookies, by any chance?
Make sure your wrist band is cryptographically secure, otherwise processes on the server could fake a wrist band and get past the check. 
i mean, they do form elliptic curves... look, this guy's got schemes for days, i bet. how can you beat social engineering with technology? they keep building bigger and bigger idiots!
It's very simple, yet extensible, so it's popular for teaching and researching computer science topics. If you have any interest in computer science after your hangover recedes, I very strongly recommend going through [Structure and Interpretation of Computer Programs](http://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html), written for Scheme.
Any word on performance improvements? How's it compare to Chez now?
I don't think performance has been the focus for this release, and I think Cheney on the MTA isn't capable being that fast (but that is just a hunch). It is fast enough for most, and it currently is much nicer to work with, at least in emacs 
I'm already on my way. I did some crude Lisp in high school, and it's coming back to me now. Thanks very much!
No problem at all! Have fun
If you were using `syntax-case` or `syntax-parse` the requirement that the number of forms in a `bindings` must be even, could have been checked with `(even? (syntax-&gt;list #'bindings))`. In `syntax-rules` there is no way to use Scheme, so we must use your observation, that if there is an odd number of forms in the bindings, then eventually you will hit the case with a single form. At this point we can signal an error. However we need to keep the original syntax around, so we can report an error in terms of the original syntax. Here is a solution using `syntax-rules`, but it would be better to use `syntax-case` or `syntax-parse`. ``` (define-syntax clj-let (syntax-rules (error-odd) [(_clj-let . more) (clj-let-helper (clj-let . more) (clj-let-helper . more))])) (define-syntax clj-let-helper (syntax-rules (error-odd) [(_ stx (__ () body body* ...)) (begin body body* ...)] [(_ stx (__ (name-or-expr) body body* ...)) (begin (display "clj-jet: missing name or expression in the given bindings") (newline) (display 'stx))] [(_ stx (__ (name expr) body body* ...)) (let ((name expr)) body body* ...)] [(_ stx (__ (name1 expr1 name2 expr2 ...) body body* ...)) (let ((name1 expr1)) (clj-let-helper stx (clj-let-helper (name2 expr2 ...) body body* ...)))])) (clj-let [a 5 b] (+ a b)) ```
Thanks, that helped a lot! Now to read more about `syntax-case` and `syntax-parse`
My advice is to spend a little time on learning scheme before you start SICP. It will help you when you start SICP, as you will be able to concentrate on the exercises without getting stuck on the syntax. That said, you don't need to learn very much - we are proably talking a few days. I suggest that you see if you can do a few of the early project euler problems and then dive into SICP. The thing about SICP is that some of the material is a bit tricky - the examples are intended for first year MIT students and their level of background knowledge.
I didn't start with SICP myself, and honestly never got around to doing more than a little bit of it. I learned from some other resources I was able to find online to get the basics and then started working on a few small zero-consequence projects while looking things up as needed in the R6RS and R7RS-small standard documents and the Guile and Chicken manuals. Perhaps going through SICP would have helped - I don't know. But, I will say that it is not the only path. My one worry is that I write sloppy scheme and don't use a readable style since I didn't use the sort of standard resources most people seem to use. However, like /u/revberl said, if what you are working on is time sensitive, it might be wise to do this in something you are more comfortable with and start learning scheme so you can do a project in it at a later day. If it isn't time sensitive and you are prepared for some hard work including some rewriting as you go and learn more Scheme and realize what you wrote before requires improvement, then I say go for it.
&gt;I think Cheney on the MTA isn't capable being that fast What do you mean by "that fast" and could you elaborate on why you think this? (I don't know anything about this, just curious)
I found "Little Schemer" more instructive in learning Scheme than SICP. 
Cheney is used for compiling, right? So performance would mean at least two things based on your answer, runtime of interpreted code and compiled executables....
Sorry for the delay in responding. I've been using Chez Scheme. I am aware that some Schemes include defmacro and that it can be implemented, but I wanted to avoid it since it isn't necessarily idiomatic. In this case, having the Clojure-style let wasn't terribly important, it was just an exercise to get familiar with the Scheme way of doing macros.
Also true
I was just afraid that jumping in without having done sicp I'd miss the "transcendent experience" everyone talks about. Learning from the reference documentation is slow and frustrating because I don't know what's in the standard library and bundled external libraries of my implementation (guile). Common Lisp looks big and scary though. I picked Scheme in part because I wanted a small Lisp that doesn't get in the way of my ... creative solutions. The gargantuan CL library makes me feel intimidated.
There is more than one way to get the experience and I have a hard time imagining that coming to SICP at a later date wouldn't provide it. That is one of the nice things about scheme - it is smaller. Though, to be fair, CL's main size problem isn't so much that it is so much larger than R6RS but how big the one and only builtin module/namespace is big rather than being split up into smaller chunks like R6RS, which can make it a bit hard to work with it in chunks (I'm about half way through reading the final draft of its specification actually). As for knowing what is in the standard library vs. somewhat standardized extensions like the SRFIs vs. guile extensions; I suggest you download the R6RS standard from http://www.r6rs.org and just keep it on hand to look things up whether things are in there or not and also keep https://srfi.schemers.org/ handy for the various SRFIs.
Continuations, especially, when using `amb` lets you implement the problem in a much more declarative way. Compare the Kalotan puzzle implementation here: https://ds26gte.github.io/tyscheme/index-Z-H-16.html#node_sec_14.4 to how it would look with recursion. 
Undefined is mostly used to denote side-effecting operations. Begin should have the result of the last statement. That is also the reason something like (when a b) is undefined when a isn't true.
Right, thanks for clarifying that.
I see now that (begin foo bar baz) returns baz, and in my test baz returned #&lt;undefined&gt;. Thank you.
So it seems that whenever my expression returns #&lt;undefined&gt; I am doing something outside the standard and should not rely on that value. Is that right?
I don't think it's right to say you're doing something outside the standard, just that the value of the thing you are doing is not defined by the standard. It's perfectly legitimate to do: &gt; (begin &gt;. ; Blah blah blah &gt;. (display "did something")) It just doesn't have a value you should do anything meaningful with.
From guile's user manual: https://www.gnu.org/software/guile/manual/html_node/lambda_002a-and-define_002a.html#lambda_002a-and-define_002a You can use lambda* or define* for optional and keyword arguments. (define* (foo a #:optional b (c 14)) (list a b c)) Default value is #f if unspecified. In above example 'c' will default to 14.
A more portable way than the guile-specific define* is case-lambda. https://www.gnu.org/software/guile/manual/html_node/Case_002dlambda.html 
Note that improper argument lists in Scheme implement Common Lisp's &amp;rest and not &amp;optional. See [http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html]
Is my lambda incorrect? Is it not standard? It seems to do what I needed in this scenario.
Both &amp;rest and &amp;optional are standard, and so are improper argument lists in Scheme. However, you can have multiple &amp;optional variables which all bind to individual arguments: (defun f (&amp;optional x y) (list x y)) (f) ==&gt; (NIL NIL) (f 1) ==&gt; (1 NIL) (f 1 2) ==&gt; (1 2) (f 1 2 3) ==&gt; error while a &amp;rest variable binds to a list containing all remaining arguments: (defun g (&amp;rest x) x) (g) ==&gt; NIL (g 1) ==&gt; (1) (g 1 2) ==&gt; (1 2) (g 1 2 3) ==&gt; (1 2 3) etc... Scheme's (define (f . x) x) would mimic the latter.
Now, I have written some multithreaded programs on top of chez, but mostly using the lower level primitives. When it comes to writing parallel stuff with scheme, I always en up using guile for it's guile-fibers (which uses all available cores). Concurrent ML is really a game-changer. Writing something like that on top of chez scheme's engines should be possible without much fuzz.
It's not Chez, but you might like https://web-artanis.com/ Building a RESTful API to access a DB should be really straight forward.
&gt; Both &amp;rest and &amp;optional are standard, `&amp;rest` and `&amp;optional` are standard for CL's `defun` forms. And yes, they behave as you demonstrated in CL. I did not know about the dotted formal arguments for Scheme's `define`. I'm reading r5rs for the first time right now. Thanks.
That's a pretty weird question if you don't provide more context. For starters, Common Lisp and Scheme are both quite different beasts. And sice both the implementations you mention are relatively fast I think your decision should be based on other factors, IMHO.
It's worthwhile to know the answer, sorry if you don't see the value.
Grab a copy of the Gabriel benchmarks and find out! https://common-lisp.net/project/cl-bench/running.shtml http://www.cs.utah.edu/~mflatt/benchmarks-20100126/log3/index.html Let us know about the results!
He didn't say he didn't see the value. He just said perhaps other things should be considered.
&gt; - Builds are fully bit-for-bit reproducible (for core, but user code too) very nice
I'll try that, may well be worth it since it'll be somewhat language agnostic. Thanks. :)
The user manual and reference manual are contained in the source code archive[1] under docs/user-manual and docs/ref-manual. [1] http://ftp.gnu.org/gnu/mit-scheme/stable.pkg/9.2/mit-scheme-9.2.tar.gz
SICP is also available in info format! https://github.com/webframp/sicp-info. Might not be relevant right now, but I like to have it easily accessible for future referencing.
Your question is more akin to asking "Which is faster, a truck or an offroad four wheeler?". Sure, both have a max speed, but they are built for different things and should primarily be compared on those merits.
Yep! I am using an mit-scheme repl in Emacs and the sicp-info package on elpa. Makes it horribly easy to run examples from the text :)
Sounds like a good workflow! When you come the the chapter about picture manipulation, I would recommend temporarily switching to Racket. It has its own IDE, and a sub language which is built exactly for that chatper (and possibly the whole book). You can get pictures to work in Emacs too, but it's not worth the hassle.
I'm on the fourth chapter now, but I used Racket for the first couple of chapters (did the picture language section there). Intrigued by org mode, I decided to bite the bullet and learn Emacs and I am very happy with that. A debugger is the only thing I'm missing in Emacs (I know that Edwin has one), though TBH as a learner it's probably better to debug manually...
I think it's better to debug manually for a bit, and then move over to a debugger. Most important thing is however to be able to see stack traces.
https://bitbucket.org/cowan/r7rs/raw/4c27517de187142ad2cf4bcd8cb9199ae1e48c09/rnrs/r7rs.pdf
r7rs.org
Hello Boro, A few comments: (1) as was noted elsewhere the substitutions are incorrect, (2) traditionally lambda calculus "describes" unary functions only, (3) i'd fix the vocabulary, you called a procedure "method" here and there; and I'm not sure lambda calculus is "a formal system for representing computation", rather to capture function application syntactically -- but I'm not a philosopher. Probably I'm wrong anyway, as I don't see how `x` or `y` capture *anything*, and it is not obvious that `((λ (x) (x x)) (λ (x) (x x)))` captures any application (though, a point for you, perhaps it does capture "divergent" computation, if there is such a thing). &amp;#x200B; As of (1), I'd do it like this (also I'll use `(grand scheme)` because pattern-matching and `e.g.` form are the way to go): (use-modules (grand scheme)) (define variable? symbol?) ;; if you care (define (substitution #;of v #;for e #;inside expr) (match expr [(? variable?) (if (eqv? expr v) e expr)] [('λ (v*) e*) (if (eqv? v* v) expr ; can't touch this! :D `(λ (,v*) ,(substitution #;of v #;for e #;inside e*)))] [(e* e**) `(,(substitution #;of v #;for e #;in e*) ,(substitution #;of v #;for e #;in e**))])) (e.g. (substitution 'x '(y y) '(x x)) ===&gt; ((y y) (y y))) (e.g. (substitution 'x 'y '((λ (x) x) x)) ===&gt; ((λ (x) x) y)) (e.g. (substitution 'x 'y '(λ (x) (x x))) ===&gt; (λ (x) (x x))) And as of (2) and beacause it was so much easier to write `subst` for unary-functions-only l.c. I'd treat non-unary lambdas as a syntactic sugar, eg like this: (define (desugared expr) (match expr [(? variable?) expr] [('λ (v) e) expr] [('λ () e) `(λ ,(gensym) ,e)] ;; in case you care about deferring the computation ofc [(f) `(,f (λ (x) x))] ;; apply whatever to this one [('λ xs e) (fold-right (λ (x e*) `(λ (,x) ,e*)) (desugared e) xs)] [(f . es) (fold-left (λ (e* e) `(,e* ,e)) (desugared f) (map desugared es))])) (e.g. (desugared '((λ () x))) ===&gt; ((λ () x) (λ (x) x))) (e.g. (desugared '((λ (a b c) ((a b) c)) x y (x x))) ===&gt; ((((λ (a) (λ (b) (λ (c) ((a b) c)))) x) y) (x x)) ...or something along these lines (mind the gensym -- it can be done "purely" but with more writing; the point is to have a warranty that the "artificial variable" does not clash with any other inside `e`). Then you can write `lambda-eval` however you like; it's worth pointing out what you implement is applicative evaluator, and as a haskeller you might prefer a normal ("lazy") one as well. Best, d.
I've seen `match` but TIL about `e.g.`. Need to read up on both. Thanks for your answer, it's a really good one!
This is a foundation for a distributed magnetohydrodynamics simulation code I have written (yet to be published). I find two-language approach to building simple-to-optimise Fortran programs quite helpful. Instead of building in run-time complexity into Fortran program itself, use Guile layer to determine from inputs the things that remain constant and implement them using the simplest possible Fortran idioms. Instead of a complex OO code, the compilers deal with something which is easy to understand. Users, on the other hand, have the flexibilty of Guile to help them reason about top-level structure.
I wrote two articles about applications of SyncStitch. &amp;#x200B; "Priority inversion and priority inheritance" [https://dev.to/hatsugai/prioriy-inversion-and-priority-inheritance-nl3](https://dev.to/hatsugai/prioriy-inversion-and-priority-inheritance-nl3) &amp;#x200B; "Safety verification of a spin lock used in Linux kernel based on x86-TSO memory model by using SyncStitch" &amp;#x200B; [https://dev.to/hatsugai/safety-verification-of-a-spin-lock-used-in-linux-kernel-based-on-x86-tso-memory-model-by-using-syncstitch-4d56](https://dev.to/hatsugai/safety-verification-of-a-spin-lock-used-in-linux-kernel-based-on-x86-tso-memory-model-by-using-syncstitch-4d56)
I'm a fan of both Lisp and Fortran (and use both) so this is of interest to me. Though recently I've used python to generate some Fortran code. When you say that &gt; Ancient structures of pre-90 standard are not implemented. You generate Fortran code that is compiled anyway right? So it's just that your code doesn't generate pre-90 Fortran code but the compiler can still recognize it if it were present.
Correct. I haven't got to writing an optimizing fortran compiler, yet :) . Instead, I let the gfortran, or ifort do the job. Schemetran is, in large part, a selection of Fortran expressions wrapped in Guile Scheme for convenience. There are some functions to generate Makefiles and compiler calls, too. Since the results of Schemetran functions are just strings of text, you can easily mix in pure Fortran language. You can even extend Schemetran easily using the provided set of utility functions for defining new constructs. Should you ever do that, think about donating your work back. 
Good luck with this (and its community if one develops). It's also a good showcase for Guile Scheme.
Thanks. I had no idea it exists. I got a Reddit account just a couple of months ago then forgot about it until i noticed r/scheme .
Bought my copy as soon as it came out. I've really loved this series and I've been challenged more than a few times about how I thought about things (thanks reasoned schemer). I'm a little worried that I won't be able to work through the book using anything other than MIT Scheme, but I'm looking forward to when the book comes in the mail. 
Which would you recommend first, The Little Typer or The Reasoned Schemer?
logic programming shift onto program search space was a beautiful mental step that I wish everybody to know
Hello! I'm one of the authors. The book doesn't use Scheme, but rather a little dependently typed language that we (the authors) built for the purpose. This little language is called Pie. The most friendly implementation of Pie is in [Racket](https://racket-lang.org/). You can get it by installing Racket, opening the DrRacket IDE, and selecting the "File" -&gt; "Install Package" menu item. Type `pie` in the dialog box, and click the "Install" button. Then, it's a matter of starting a file with `#lang pie` instead of `#lang racket`. There are some more instructions on using Pie directly in the first recess following chapter 2. Pie code also works in any other editor that directly supports Racket, like Emacs, although it won't have the language-specific syntax coloring or the type tooltips from DrRacket. If you prefer to use a command-line REPL instead of an editor with integrated Racket support, you can get that with `racket -l pie -i`. I hope you enjoy the book!
MHD + scheme + FORTRAN.. you win
yeah expansion should happen completely before the next compilation step. check out the scope sets work. it seems to me the best way to implement a macro expander. you need a data structure for syntax objects with a set of scopes attached. 
&gt; should macro expansion happen completely before compilation You *can* do so. Expansion timing is ambiguous in R5RS and R7RS. It is strictly specified in R6RS. (See chapter 10) But if your implementation has REPL, user may wants overwrite macro definition. Also, full expand may make difficult error messages with wrong program. You have to choose between convenience and speed. There is trade off. &gt; I am guessing 84, since the reference to x in the call to double has referential &gt; transparency with the scope where syntax-rules occurs. Yes. `x` in macro template is interpreted in macro definition place. &gt; (define-syntax mymacro syntax-rules () &gt; ((mymacro (a ... b) ...) (a b))) &gt; (mymacro '(1 2 3) '(4 5 6) '(7 8)) Lack a ellipsis and parens. Your intent is follow? (define-syntax mymacro (syntax-rules () ((_ (a ... b) ...) '((a ...) ...)))) (mymacro (1 2 3) (4 5 6) (7 8)) In R6RS and R7RS this will be expanded to `'((1 2) (4 5) (7))`. `(a ... b)` is unspecified pattern in R5RS. (But some R5RS implementation allow it. See 4.3.2) 
classic! btw: r/https://twitter.com/PaniczGodek/status/1047041708985335809 \-- mind that "Felleisen's Y" is applicative one \[sometimes called Z\], while "Godek's Y" is normal one. but the core idea is similar.
Im surprised there is so little written about delimited continuations. It is such a neat primitive, and IMHO nicer to use than coroutines for most tasks where you would use coroutines or delcc.
They seem like a great tool for implementing control constructs of a programming language to me. But they are pretty difficult to understand too!
I'd say that they are easier to understand than undelimited continuations. Call/cc has a lot of undesired and unexpected behaviour, whereas delimited continuations make it very clear what is captured and what is not
What's the point to change to Apache which is weaker license if not avoid FUD?
This is an excerpt from The Little Schemer. Great book. Great surgeries. Wonderful drawings. In the Seasoned Schemer they also create the imperative Y Combinator with you, the one done with (set!).
last commit 2017 :(
Every now and then this project makes a come back! Interesting how people love this project.
[There's always the Wayback archive.](https://web.archive.org/web/20170618043948/http://community.schemewiki.org/?c=a)
You could use scheme variant that supports green threads together with multiple processes. That gives you a wide choice Chez is high performance (I have been looking at it for that reason myself) but does that matter for a REST API? Network and DB are likely to be your bottle necks.
&gt; Nils has been kicked out of school, has dropped out of job training and then out of university, and has quit a few well-paying jobs in technology (among others: for an IBM shop, a Linux startup, and a SAP contractor). However, the traits fostered in business and academia are simply not compatible with his values. Are you me?
AND he is super nice. I bought one of his books and had a question regarding Kindle conversion. He helped out directly...
It's been quite a while since I dealt with this as I had no idea how to proceed. However I wanted to update this with my latest thoughts on the matter. I think the problem with my approach so far has been the fact that a given depth doesn't return a single result, but rather a list of results. I am however only memoizing single results. So I suspect the solution may be to rewrite the memo function to memo result sets. At present this is only an initial thought however as I have no idea how to a) ensure that a given computation only ever runs once, and b) have subsequent computations loop through the precomputed list of results. However this could actually be a viable solution if done correctly since every new depth will only loop through the previous depth's list which I believe will be as good as it gets for memoizing this type of function. Now to work out how to code it! :)
Check archive.org, but it is not there. And what has happened to readscheme.org ? 
Perhaps you can write to Krishnaswami and ask for a copy. https://www.cl.cam.ac.uk/~nk480/
Have you tested your `avg` function yet? Test early; test often! Your counting function will be recursive and have an extra argument to hold the number of values above average. The header will look something like: (define (count len values above) ...) 
Yeah the average function works fine. 
`car` returns the first element of a list. `(avg (car (list 7 10 60 3 55 15 45 40)))` reduces to `(avg 7)`. Do you want to take the average of 7? 
Have you tested it with the code that you posted? You might be in for a surprise. 
Sorry I was replying on my phone. The average function is as follows `(define (avg listlen)` `(if` `(null? listlen)` `0` `(/(+(car listen)(sum(car listen)))(theInt))` `)` `)` &amp;#x200B; And the last two lines are `(display "The average is: ")` `(avg ( car numbers))`
I fixed the code I had on here. I guess I didn't copy the code from my file to here as well as I thought, my apologizes. 
I used `theInt` because I didn't know of another way to take the first number the user inputs, besides storing it within a variable. But after seeing @comtedeRochambeau's post explaining the difference between the two, it'd make a lot more sense to do it like that. 
In the OP your avg has (sum (cdr listlen)) so I'll assume the above is a typo. With that in mind the function will work, but why do you do (/ (+ (car listen) (sum (cdr listen)) (theInt)) Instead of (/ (sum listen) (theInt)) Also there is no need for theInt to be a function. Currently theInt computes the first element of the list each time it is called. Instead you could store the value. (define theInt (list-ref numbers 0)) So you would write (/ (sum listen) theInt)
There are 3 possible paths for this function. When listlen is null, when (car listlen) is greater than the average and anything else. So you need a nested if statement (if (null? listlen) 0 (if (&gt; (car listlen) &lt;average&gt;) ...)) You can look at my original post for how to fill in the dots. Also rather than computing average everytime you call countGTA you should add an additional parameter. (define (countGTA listlen average) ...)
Okay so it looks like car is being called on the result of calling avg. So make sure that you are passing a list to countGTA and also double check that avg works correctly. That + needs to be in parenthesis (if (&gt; (car listlen) (avg (cdr numbers))) (+ 1 &lt;recursion&gt;) &lt;else&gt;)
Sometimes I have seen this question here: is Scheme suitable for web development? Sure, why not? Ok, maybe MIT Scheme is not exactly the obvious choice here but it was a fun project. It's deployed here: [https://textboard.org/prog/](https://textboard.org/prog/)
Nicely done.
Le bon comte is brilliant! ;-) Did you get your counting function to work? 
yes, but only if you have the count function. Which implementation are you using?
Are you going to start the project!
Use conses. *(If you want a better answer, please define your problem in a better way.)*
 I need to build a Node object to be the base class for the following two node types: RootNode - holds a start of the range, end of the range and some number of Nodes (can be RootNodes or LeafNodes). LeafNode - holds any number of integer values. There should be a single RootNode that is the "top" of the tree. Its range should encompass the range of the whole tree. ## Searching If the current node is a RootNode and the number that we are looking for is between the start and end of the range, follow the nodes that are descendents of this RootNode. If the current node is a LeafNode, check each value of the leaf node to see if it matches the value that we are searching for. &amp;#x200B; This is an example of that tree: (define tree ' ( "R" 100 999 ( ("R" 100 199 (("L" 120 140 160 180))) ("R" 200 299 (("L" 220 240 260 280))) ) ) ) 
The list structure is right there - the example tree definition defines an example tree. Do you know how to read S-expressions?
I don't use chicken, and this almost certainly also depends on which OS you're dealing with. Trying to avoid stating the obvious here, but it may well be that you /aren't/ getting a string from a C-c but a bit sequence of some description. This is entirely dependent on some combination of OS, terminal emulator (DOS terminals behave differently from Unix etc), particular library (ncurses or some other library), which scheme interpreter you're using, etc. The short answer is that there is no easy way of knowing what you're receiving. I'd recommend trying to print it perhaps and see what type Chicken thinks it is. I unfortunately cannot coherently comment on your question about your code apart from observing that it's neat however. Hopefully someone more skillful than me can help you with that. :)
Thanks for the comment! I figure out it is platform dependent, I'll be happy if I make it work from bash for start. Guess I'll have to experiment some more.
C-c is sent as a signal to your program, specifically SIGINT. The following is some documentation that may help you with handling those. https://wiki.call-cc.org/man/4/Unit%20posix#signal-handling
Thanks for the link.
Curious, why store one element lists in your hash table and then call eval when pulling the value out again? Usually direct eval is frowned upon. Try storing the function directly in the hash table, then the eval becomes unnecessary, e.g. ((hash-table-ref words word)) Maybe you’d have to define the functions first - don’t know chicken scheme all that well
Great, thanks for the tip, I didn't know I could do that.
I was thinking (hash-table-set! “-“ subtract) for example. Without the quote, and not in first position, it should just grab the value, which is a function. Which is why subtract needs to be defined before that executes. But yes, apply works too
Thanks!
Which implementation? Can you use [format](http://practical-scheme.net/wiliki/schemexref.cgi?format)?
Looks like racket uses [fprintf](https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._fprintf%29%29)
I tried that actually. I wrote (real-&gt;decimal-string temp), but it just displayed nothing. I didnt get any error, it just wouldnt display any value
you'd have to print the string afterwords: (print (real-&gt;decimal-string temp))
Hi, I'm a new Gerbil user and have some questions/feedback, how should I contact the Gerbil developers, is a Reddit PM okay? So fare I really love Gerbil (coming from Common Lisp).
You can reach us on irc in freenode, #gerbil-scheme is the channel. 
And sure, a reddit pm is ok too. You can also contact me (vyzo) on keybase as well.
Is it the count procedure that gives you the wrong number of arguments? You can replace that with a named let loop (let loop ((nr 0) (num (cdr numbers))) (if (null? num) nr (if (&gt; (car num) avg) (loop (+ 1 nr) (cdr num) (loop nr (cdr num)))) 
I think you should read the sub's sidebar.
PEG is similar to META. You might find it useful to read my code https://github.com/rain-1/racket-peg the macros are in peg.rkt &gt; I'm running into what appears to be a whole stack of issues. Writing a a recursive function that does the necessary transform is trivial, however I cannot write a recursive macro that does the same. The function `peg-compile ` is just a normal scheme function except that it produces syntax objects. And that a macro makes use of it, so that I don't need to use eval. Are you using syntax-rules macro system? it is a lot different to normal recursive programming in scheme. Feel free to put your whole code online and ask more questions and stuff. 
I bet he's going to mark them up and pocket the difference between what he paid and what they sell them for!
I find it quite difficult to translate Racket macros to R7RS macros, there is a /very/ large semantic gap between the two and I suck too much at macros period to be able to figure this out as well. So unfortunately your code doesn't help much. :/ Sorry. I am indeed using syntax-rules. I actually did post all the code I have, however reddit screwed with the code and I didn't notice. I fixed the formatting and added desired output so that should help some. :) I have the vague feeling that I'm trying to do something similar to what happens in the `(match)` macro. Though I don't understand the various `(match)` macro implementations well enough to use that as a starting point either...
&gt; I am indeed using syntax-rules. You might be quite limited by them. It's possible to simulate normal applicative programming with them http://okmij.org/ftp/Scheme/macros.html#ck-macros but there is a fair bit of interpretive overhead. I don't recommend it. A lower level macro system may be a better choice for this application (of implementing META). &gt; I have the vague feeling that I'm trying to do something similar to what happens in the (match) macro yeah it's very much an advanced version of match
Only just found your site Nils. Think I'm going to grab some books!
here you can get ck https://github.com/ilammy/sr/blob/master/sr/ck.sld
Yeah I think that working on match first could be a good idea. There are some difficult parts to it that you can get good practice with. One of the matchers I wrote in the past worked this way: Each pattern is transformed into a sequence of destructing and binding operations. Then there is a second macro which transforms those simple operations into actual scheme code. A method like this is similar to META and can be done with syntax-rules.
I think I sent you the code for the program to your dm's. What do you mean when you said "only if have the count function"? &amp;#x200B; How would I implement that function? 
I'll give that a go thanks. I found this explanation of syntax-rules: http://www.phyast.pitt.edu/~micheles/syntax-rules.pdf which seems to be close enough to my current capabilities that I can learn from it. :) So I think between your suggestions regarding implementing match, and figuring out how syntax-rules works from that PDF I have a decent notion of how to proceed. Thanks for the help. :) Oh, I incidentally managed a straight up translation using rsc macros, but it's not hygienic and honestly pretty bad. But it's progress non-the-less. :)
You cannot use scheme procedures during macro expansion time inside a syntax-rules macro. You would need to either implement a continuation passing version of list reversal as a syntax-rules macros, or use a procedural scheme macro system like explicit renaming or syntax-case which allows you to use scheme procedures.
Ok, I have some questions about that. I've seen some example macros which use map, but that's a procedure rather than a syntactic form (well, at least according to the documentation I have) - why is this acceptable, or more generally how could I tell if a procedure is allowable in a macro or not? And further.. I wrote my own reverse as a macro as suggested. I now have: (define-syntax rev2 (syntax-rules () ((_ body) (let loop ((ulist body) (olist '())) (if (equal? ulist '()) olist (loop (cdr ulist) (cons (car ulist) olist))))))) (define-syntax backwards (syntax-rules () ((_ body ...) (begin (rev2 '(body ...)))))) (rev2 '(2 3 4)) (backwards (print "1") (print "2") (print "3") (print "4")) Now the test for rev2 works, but I still get the same result for backwards! It still just prints the s-expression I think it should be evaluating.
Part of the problem is that you passed '(body ...) to the helper macro. You should pass (body ...) to it instead. Secondly you cannot do normal scheme programming with procedures and IF, that is stuff that will happen at execution time. You need reverse to happen at macro expansion time. To achieve that you can use 2 different syntax-rules patterns. So define backwards like this ``` (define-syntax backwards (syntax-rules () ((_ body ...) (rev2 (body ...) ())))) ``` and then rev2 like this: ``` (define-syntax rev2 (syntax-rules () ((_ () acc) __________) ((_ (body . rest) acc) __________))) ;; recursive case ``` 
Rain5 mentions that using procedures in syntax-rules macros during expansion time is impossible. This is of course correct, but you can work around it using recursive macros: (define-syntax backwards (syntax-rules () ((_ last) last) ((_ some ... last) (begin last (backwards some ...))))) This means (backwards (display 1) (display 2)) will expand to (begin (display 2) (begin (display 1))) which any sane scheme will optimize to (begin (display 1) (display 2)). If you want to generate nice code you can of course do it with the method rain5 proposes further down in the comments. That is the correct way of doing things, and is also how macros like cut and cute works. For this simple case, relying on the optimizer makes sense since it will make the macro a lot simpler and will produce optimal output.
&gt; using procedures in syntax-rules macros during expansion time is impossible. This is of course correct Hmm, let me challenge that.. based on my experimentation this appears to be plain false, so could it be possible this is implementation dependent? (I am using CHICKEN) Since I last checked this thread I've written this poor copy of Clojure's thread-first: (define-syntax ~&gt; (syntax-rules () ((_ funcs ...) (let ([args (reverse (list funcs ...))]) (foldr (lambda (f x) (f x)) (car args) (cdr args)))))) Now car, cdr, reverse and foldr are all procedures (according to chicken-doc), and I also obviously have a lambda which.. I can't be sure if that counts as a "scheme procedure" or something you would call a valid expansion, but none-the-less, this macro works...
Most bang in that macro runs during runtime, not during expansion. Check it yourself using chickens expand : (expand '(~&gt; a b c)) 
What do you mean by skeleton?
I think it's interchangeable with "library"! Basically something to include in your program when you want to upload files to CGI program written in guile.
Ah, I found a bit of what I'm looking for [here](https://cisco.github.io/ChezScheme/csug9.5/foreign.html#g34). So it seems this is supported. But I'm still curious to hear anybody's experiences in doing this.
If you don't receive an answer here, try the Chez Scheme mailing list. https://groups.google.com/forum/#!forum/chez-scheme
I have just had a cursory look through your code, and if it takes that long you are probably doing something more that's off, but: You are doing a shit load of (length ...) which is an o(n) operation. Most of them seem unnecessary. I have no idea why, but this seems like thing that should comfortably run in way less than 1s. 
I have just had a cursory look through your code: You are doing a shit load of (length ...) which is an o(n) operation. You are going through many many millions (billions) of list elements when only about 260k is necessary. You are going through 1+2+3+4+...+262k cons cells. That is bound to take a lot of time. 1+2+...+(* 512 512) is 34359738368. And you are doing it twice!
Thank you! The repeated use of \`length\` was indeed the problem. I've been mostly coding in Clojure, and mistakenly assumed that the implementation of \`length\` would be efficient as there would be some sort of internal counter for the number of list elements as they're \`cons\`ed up or \`cdr\`ed off. Using an explicit index for setting the vector elements did the trick.
How much can you trust the input data? If you still want to improve performance you can just populate the vectors directly after you split the input strings. Or depending on read buffer performance do the reading and splitting in one go. I might want something to play with if you want any help making it faster :)
I am moving to Chez Scheme because performance matters. I made [a prototype using epoll and call/cc](https://github.com/amirouche/xp-chez-scheme/commit/d13bc83020b292c3258cbd409411372a1339b590) to create a library that allows to do async network without callback. But most of my free time is spent on something completly unrelated. I am coding a emacs-like editor on top of termbox: https://github.com/amirouche/zk/
I'm working on a musical sequencer. There will be a GUI frontend because most musicians don't want to code, and it's useful to visualize music (see: 100s of years of using scores). But behind the scenes all note/patterns will be created and transformed with Scheme. Those who want to dip their toes can add their own algorithms using a little DSL I'm making. Or if they want to go full-nerd they can just write Scheme code.
You don't find that you meet lots of weird nesting behaviour of regular call/cc? Porting things from delcc to callcc has been a lot of weird buts since it captures a lot more and restores old things.
I am not sure what I am doing when it comes to the call/cc thing yet. I tried to imagine the implementation of [Guile's prompt](https://www.gnu.org/software/guile/manual/html_node/Prompt-Primitives.html#index-call_002dwith_002dprompt) using call/cc. So far, on my very small experiment it works. At any time there is single prompt active see https://git.io/fp90B. &gt; Porting things from delcc to callcc has been a lot of weird buts since it captures a lot more and restores old things. TIL delcc. 
The problem is that your prompts are not in any way delimited. something like (define a 0) 
The problem is that your prompts are not in any way delimited. something like (define a 0) (define c #f) (call/cc (lambda (k) (display a) (set! c k))) (set! a 1) then run (c) from the repl. demonstrates this quite nicely. 
I use Scheme for scripting instead of Python or whatever. I typically use Guile because it used to be the only thing I could reliably get working in my work environment. Recently I’ve been working on my own expect library so that I can migrate some of my scripts to another implementation if I want to. I’ve been playing with Chibi because I’ve been thinking about doing a presentation or two about Scheme for my team, and I was thinking I’d like my examples to be properly R7RS.
Does Racket count? I am working on a bike trainer application in Racket, this collects speed, power, cadence and heart rate data and simulates travel on a map and adjusts trainer resistance based on the slope of the virtual course. It allows me to put my bike on an indoor trainer and watch a dot move on a map while I pedal... I am now working on adding some actual training features, such as real time plots for the data and ability to run through workouts. Here's a demo: https://www.youtube.com/watch?v=D1E2fSQFy7k&amp;t=5s 
I’m continuing to (slowly) develop a program called MassMine in Chicken scheme (http://www.massmine.org/ ). It’s a tool designed for researchers interested in networked and online data. It aims to be a single interface for harvesting data from online sources (Twitter, most notably so far). In anticipation for a GUI analysis front end on the way, I’ve been developing a (currently undocumented) server mode where MassMine can be controlled over sockets. 
ncurses bindings for racket :) [https://github.com/dys-bigwig/racket-ncurses](https://github.com/dys-bigwig/racket-ncurses) Still very very much WIP, but most of the functions are there ready to use directly. Currently working on making some of the functions a little more friendly. Like condensing some of the essentially-the-same-except-very-slightly-different functions into single functions of variable arity.
I don't understand how delimited continuation would improve the situation? My understanding is that delimited continuation are a performance trick when call/cc is slow but it is not the case in Chez. Maybe I am wrong.
If you run the code I provide you will see that the continuation also captures the earlier a (ie:running (c) will display 0). A delimited continuation will only save the everything from the prompt "and down" and any other bindings will be as you would expect (ie: (c) would print 1). Not only is it more efficient, but it is also easier to reason about.
Going through SICP with MIT/Scheme. Never done any real programming before. Struggling but plugging through.
i have been trying to learn f# and racket enough to do large projects instead of little side projects. however, now i am learning mit/gnu scheme and going through the edx *how to code* courses and sicp because i'll be taking a course with gerald sussman at mit next semester. super pumped and nervous.
i am doing that as well. i heavily recommend the *how to code* courses on edx as well. they're taught by grego kiczales, who helped design CLOS (the common lisp object system) and the metaobject protocol, and the class is based upon the *how to design programs* book. it takes a similar route as sicp but has different methods. i find they complement each other nicely, where neither one is a replacement for the other.
Thanks. I'll put that course near the top of my list as to what to do when I'm finished with SICP. Although right now my plan is to take on Concepts, Techniques, and Models of Computer Programming by Peter Van Roy and Seif Haridi and the Odin Project, not necessarily in that order. We'll see. I'd like to get hired as a full time developer as soon as I can manage it, so I'm wary of getting too caught up in theory as aposed to practical application. Enough about my neurosis. Good luck on you journey. Thanks again for the tip.
Currently been doing some Advent of Code in Chicken 5, and a text adventure as a test of using it for native apps. I have a partially-playable jump &amp; bump game in Chicken 4 &amp; SDL2, but I'm waiting for the SDL2 egg to port it forward. I like Chez better, but it has fewer libraries and I can't get a native binary out of it with libraries, so that's a pain. The Chez REPL is excellent, the Chicken REPL is appallingly primitive, but compiling a native binary is a thing all languages should learn how to do. Posts about these at http://mdhughes.tech/category/scheme/ 
i would honestly recommend doing *how to code* in parallel with sicp. peter van roy has an edx course he runs every fall. there is also dan grossman's programming languages course on coursera.
I'll register this weekend and see how it goes. I don't want to get burnt out. I'm already progressing slower than I thought in SICP. But I guess it will take me the same amount of time to do both either way. Thanks again.
I didn't know that native binaries weren't possible with every language. 
Awesome! Which class? You might enjoy [a story about someone else's encounter with Sussman.](https://marioaquino.blogspot.com/2011/09/teacher.html)
Python (you can do it with Cython, if you don't use certain libraries or functions it can't handle…), Perl, Julia, most Schemes and LISPs: no native binaries, every user has to install the runtime system. Java and all JVM languages don't make native binaries, though you can package a JAR file and an application wrapper to fake it; we used to consider that a stupid waste of resources, but now it's the easiest way to make sure the correct JVM is installed. Native binary compilers are hard to optimize, which is why Chicken and Cython generate C and compile that. 
Thank you for following up. Interesting, I'm taking notes. This raises more questions for a later time. 
Gambit Scheme can build what you seem to be calling "native binaries": No separate runtime system installation. Unless you consider the existence of libm and libc too onerous.
I'd actually be much more interested calling scheme/racket from other languages like R. It'd be nice to be able to write scheme libraries for R.
yea, it's up to you. focusing is always good, but i feel the two things cover something so similar but it different ways, it's helpful. once you finish, definitely follow up with the programming languages course. it's really fun. i just finished it this fall. https://www.coursera.org/learn/programming-languages
it will be the latest iteration of this class: https://groups.csail.mit.edu/mac/users/gjs/6.945/
? 
alanmarty, did you forget the link?
Yes, thank you, here it is: [http://lambdaway.free.fr/lambdaspeech/?view=lispology4](http://lambdaway.free.fr/lambdaspeech/index.php?view=lispology4) &amp;#x200B;
why did you use { instead of (
Because we are in a wiki context (and not in a console) with a complete mix between pure text (unprotected inside quotes) and code. In lambdatalk words are made of any character except curly braces {} exclusively used to bracket commands (applications, abstractions, ...). For instance {b Hello World :)))) } just displays **Hello World :))))**. How could be evaluated (b Hello World :)))) ), where parentehses are unbalanced? This is another example: {def smart\_add {lambda {:a :b} {b :a+:b} is {u equal} to {b {+ :a :b}} }} -&gt; smart\_add {smart\_add 2 3} -&gt; 2+3 is equal to 5 mixing easily HTML, maths and pure unquoted text. Much more explanations in this page [http://lambdaway.free.fr/lambdaspeech/](http://lambdaway.free.fr/lambdaspeech/). Your opinion is welcome :))) &amp;#x200B;
nice!
This is insanely cool!
Wow! pffi is my new go-to ffi for scheme. Finally no more envy of common lisp's cffi! Amazing work! 
Prototyping a game using Kawa and libGDX
Regarding the comment: this is not the full r7rs large, but only the red docket which contains the data structures that should be available in r7rs large.
I'm not sure of what _exactly_ you want to write in scheme and glue things up with, but, from a high-level perspective, I would definitely recommend [chicken scheme](https://call-cc.org/). Depending on which way you would like control to go, you could either write stuff in chicken and use it in your c/c++ code like [so](https://wiki.call-cc.org/man/4/Embedding), or use c/c++ code within chicken using its nice ffi like [so](https://wiki.call-cc.org/An%20extended%20FFI%20example).
I don't think any scheme will really get in your way if you compile the c code to a shared library. If you want really closely bound scheme and C code, I'd try chicken scheme. It's the best one I've found for mixing languages in a single library/executable. There are libraries to automatically generate FFI bindings from a header, you can write inline C blocks in scheme, etc. Is it a good idea? I think so. I'd probably do it.
Thank you, I was actually thinking to choose chicken or guile. Chicken because it is popular and guile because it is created to operate with other languages such as C. Thank you for links, I am still figuring out how to make it best. Now I have a code in C and I realized that it is a pain to extend it. For example I want to read a mathematical function from file. I it totally possible in C writing something like polish notations, etc. but I scheme it would be x10 easier. With time, I will need to modify my code further, test new ideas, etc. So I think scheme would help enormously! How to structure this thing, is another big question... Thank for the link again.
Thank you, chicken looks like a nice option, take a look at my other answer. Thanks.
that's the only docket that has been specified... when the rest gets finalized, it will get implemented too!
One consideration: You may want to run this code on a cluster some time in the future. So pick a scheme that compiles easily without a lot of external dependencies, and that's not picky about which compiler you use. That will make life a lot easier for you later on. As another aside, many high performance codes are written in the way you describe nowadays. And scheme is absolutely a valid choice for a scripting/glue language. But I would say the majority use python for this nowadays. I'm not saying you should not use scheme, but if you look for collaborators in the future that may become a minor stumbling block. 
GNU Guile is specifically designed for what you have in mind. 
I'll probably be downvoted to hell, but have you considered using Python instead of scheme? Python is really great at doing this kind of glue code.
Yes, it does run on a cluster, I forgot to mention it. I thought noting MPI would be enough. So what dialect would you suggest? I hear you about python, but what fun in that? :) More seriously, I thought about it. And python is designed for scripting, and it has strong support for numerics, and almost every linux/unix system has it, and everyone knows it. Eh, I wish lisp would be more popular, this is a tough choice, as I am not fun on python... 
No you would not be downvoted, because you are right. I will even upvote you, From my other answer: "I hear you about python, but what fun in that? :) More seriously, I thought about it. And python is designed for scripting, and it has strong support for numerics, and almost every linux/unix system has it, and everyone knows it. Eh, I wish lisp would be more popular, this is a tough choice, as I am not fun on python..." So it boils down to: python would be right thing to use, but scheme would be fun thing to use. I can choose either now, because I am the only developer of this code (for now)! but would it bite me in the future? I am really struggling to choose, so I write everything in C for now. It is a pain :( even do something simple as closures is pain... &amp;#x200B;
Yes, I am deciding between guile and chicken. Guile looks more suitable, but it looks that no one uses it in comparison to chicken. Can you comment on this? are a lot of people/community who use it? 
I completely agree with you. Lisp *should* be the default choice for scripting, but (un)fortunately, Python got the upper hand here. One other thing I would consider is if you want your project to be developed by others, Python has a bigger market share and lisp can make the barrier to entry a lot higher, specially among other scientists.
I can't claim to be a scheme expert so maybe what I am gonna say should be taken with suspicion. My impression is that Scheme is rather fragmented community especially as far as support goes. For example, I like Gambit because I find it easy to compile, etc. But the packaging system and the support seem lacking. Same thing with pretty much all implementations including Chicken once you try to install their packages. In fact, I find some systems just hard to even compile. So my feeling is, it all depends on what you want. Guile with FFI mechanism in principle should cover everything you would want. So the rest is how easy it is to integrate with your code. Given how Guile is supposed to be the barebone glue scripting language like TCL, I think it may be a better fit. I used it before in a context similar to yours although at the end of the day, for my purpose, I discovered a dumb parser is really all I needed for myself and piping data to third party tools turned out to be more productive than using Guile to glue into other libraries. 
I am using guile in a similar sci stuff like you probably. It's very convenient both for calling C from guile and working with guile from C. There is all the comfort with types, arrays... Documentation is nice, the source code (if needed) is readable. Earlier I found many extension languages (also some scheme implementations) sack with 32bit limitations, some by design, others because noone cares. Specifically array indices are often hard-coded as int, though other related variables are 64bit.. Guile (now 2.2.4) is reliable in this and other similar things that were crucial for my sci work. I didn't test chicken for such things yet, as I am happy with guile so far. But one thing I don't like in chicken is that I always have issues with the eggs. The useful ones are often broken. 
Thank you for sharing. so far I am inclining to use gulie. Is it usually installed on clusters? Did you work with MPI?
Chicken definitely, as long as performance is not a concern.
I recommend building and installing in your home on clusters or other machines not maintained by you. I doubt any scheme or other cool lang is installed by default anywhere. I don't use (I dislike) MPI,so I can't share experience. Otherwise threads are fine.
Yes, I also do not like MPI, but I do not have much choice. And I mostly use it through PETSc which is a little bit more high level. In my job I regularly use around 10000cores and there is no really way around it (I do kinetic simulations, which are usually have billions/hundred billions of unknowns). Parallelism which is more high level usually works well only on shared memory systems :( Maybe there is a better solution then MPI (maybe chapel or something similar), but I am not aware of it. Plus, I am hooked on petsc, rewriting what it provides would be impossible for me :(
I see. I believe guile may be a good choice for it. Though you have to give it a try. I think you may have to write the absolutely necessary glue code for PETSc functions you need in C (because of PETSc types I'm afraid) and then use them in guile. Then you are happy. I am actually interested in your success as it may also be the way for my planned project. Otherwise using Julia for everything is also an option,but I have only limited experience with it.
well, julia is neat, I will give them that, however, so far, I tried it only for 1 machine jobs, not for anything I use petsc for. I use it daily for data processing/plotting, nothing major and it was pleasant. Multiple dispatch is neat, batteries are neat. I never wrote macroses, only used primitive metaprogramming with symbols and evals. I would still prefer lisp syntax to be honest :) but probably if they would do julia with lisp syntax, it would not be as popular =D So, some time ago I was thinking to use CL to write whole things, but decided that PETSc just gives you to much and I am not sure I would be able to write some parallel linear algebra myself... here is some interesting thing to read [https://www.dursi.ca/post/julia-vs-chapel.html](https://www.dursi.ca/post/julia-vs-chapel.html) 
Thanks for the link! 
In the menu "DrRacket" choose the menu item "Preferences". Choose the tab "Font". Voila! On my computer it says "Menlo" - but I can't remember if I made any changes.
How do you go about figuring out what the best library is in any other language?
Other than Scheme, I only use Java and JavaScript. Both languages * are very popular, and such opinionated lists and comparisons already exist * their spec is much more detailed, and so I can use same libraries across the board. I mean I take D3.js and just use it, I don't care if my code is ran by chrome's implementation of JS, or firefox's.
Well if your definition of "best" is "popular", the answer is easy. Projects that come up in a generic search ("scheme web server library") on Google will be most popular. Projects with the most stars on Github will be the most popular.
I only said popular in the context of amount of blogs / opinions / comparisons / etc. there are on the internet. 
That is exactly what I meant by popular. I'm not denigrating popularity. I'm trying to understand what you want and it seems like you want exactly what Google excels in bubbling up. &amp;#x200B; There are no more hidden sites that offer comparisons for Scheme libraries that I know of than what I find on the first page of a Google search.
nice work!
i guess the ballots to determine [which SRFIs should be included in R7RS-large](https://bitbucket.org/cowan/r7rs-wg1-infra/src/4fae6654e08cf509994a0310c43cdb680f4a11eb/WG2Dockets.md) might end up being somewhat of an indicator for at least some libraries?
Thanks! Hope you like it :)
Both do the same thing. The former is syntactic sugar for the latter.
Two points: 1. The former is shorthand for the latter. 2. You mean to say `body`, not `(body)`. 
Some interpreters will bind the name to the procedure for e.g. debugging, but yes the semantics are identical.
It can be done, and it's not too hard at all! You'll need to link against `kernel.o` (or csv*md.dll on windows) and distribute the `petite.boot` and `scheme.boot` files with the application. I'll go over the basics of setting up Chez from the C side, but you should look through the `scheme.h` to see the functions / macros available to C. Setting up Chez involves three functions: `Sscheme_init`, `Sregister_boot_file`, and `Sbuild_heap` - in that order. - `Sscheme_init` accepts a single argument which is a function called on abnormal exit. You can pass `NULL` to use the default exit handler. - `Sregister_boot_file` takes a path to a boot file. - `Sbuild_heap` is the final step. It takes two arguments: a final boot file and a custom init function. If you have previously specified the boot files with `Sregister_boot_file` and have no custom init function you can pass `NULL` for both arguments. To initialize a basic Chez Scheme you can do this: Sscheme_init(0); Sregister_boot_file("/path/to/petite.boot"); Sregister_boot_file("/path/to/scheme.boot"); Sbuild_heap(0, 0); - `petite.boot` contains the complete Chez Scheme system. It is required. - `scheme.boot` contains the compiler. This is not strictly required, but you seemed interested in having the ability to compile code on the fly. Incidentally, adding a new boot file is probably the easiest way to set up the bridge between your program and the scheme code. You can make boot files out of arbitrary scheme source files[1] and the code within will be run as part of `Sbuild_heap`. At this point, you're ready to connect scheme and C. You almost certainly want to do this from the scheme side as calling normal scheme functions from C is meager. You're limited to calling functions (easily) with 0 - 3 arguments, and those arguments must be scheme data. Using Chez's `foreign-callable` is a much easier way to call scheme code from C, and the scheme side will handle converting the data to/from the scheme representation for simple data types. You found the full documentation, but I'll give a simple example of using `foreign-callable`. // add.c int64_t (*add_impl)(int64_t, int64_t); int64_t do_add(int64_t a, int64_t b) { return add(a, b); } ;;; add.ss ;;; You can use the function Sforeign_symbol to expose C objects ;;; to the scheme side without needing to use load-shared-object. ;;; For your application, I assume most of the C data that Chez needs ;;; to access is already in the process's memory so you would pass ;;; #f here instead of a path to a library file. (load-shared-object "./add.so") (define add-impl (foreign-entry "add_impl")) (define fc-add (foreign-callable + (integer-64 integer-64) integer-64)) ;;; locking the foreign-callable object isn't needed if this is ;;; inside a boot file as all data created ends up in the static ;;; generation and is never reclaimed or relocated. (lock-object fc-add) (foreign-set! 'void* add-impl 0 (foreign-callable-entry-point fc-add)) ;;; do-add is a convenience as it is easier to test from the scheme ;;; repl than create a C runner. (define do-add (foreign-procedure "do_add" (integer-64 integer-64) integer-64)) You can now call `do-add` to get the sum of two 64 bit integers. I'm not sure how you want to handle bridging C &lt;-&gt; scheme, but declaring function pointers on C side and assigning them from the scheme side is probably the easiest thing to do. If you have a large number of functions to create, this macro will reduce the boilerplate of that whole process: (define-syntax define-foreign-callable (syntax-rules () [(_ name (conv ... (arg-types ...) ret-type) fn) (let ([fc (foreign-callable conv ... fn (arg-types ...) ret-type)]) (lock-object fc) (foreign-set! 'void* (foreign-entry name) 0 (foreign-callable-entry-point fc)))])) [1] http://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s75
Well, SLIB (https://people.csail.mit.edu/jaffer/SLIB) is an older library that many have used, which is quite large and portable between implementations. It has a lot of things in it, so take a look.
Ah thanks for the detailed reply, this is extremely helpful!
Forth too!
Deja vu: https://en.wikipedia.org/wiki/Oric
Not relevant to Scheme programming language
Those things (graphics library, gui, web server) tend not to be cross-implementation because scheme does not have a binary API.
Yes, I know, which is why I said &gt; I'm not discouraged by using a new dialect / implementation
Hmm I think I'm having a hard time understanding your last sentence. You mean a list of libraries across different implementations?
Yeah. Something that be like &gt; Racket webserver, Guile webserver, Chicken "Awful" library, &lt;...&gt; were looked at. They have in common &lt;...&gt;. The relative advantages/disadvantages are &lt;...&gt;. Personally I think out of the ones considered, &lt;...&gt; is best, because &lt;...&gt;. 
You probably meant the [https://en.wikipedia.org/wiki/Jupiter_Ace](https://en.wikipedia.org/wiki/Jupiter_Ace)
**Jupiter Ace** The Jupiter Ace by Jupiter Cantab was a British home computer of the early 1980s. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/scheme/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
That's the one.
This idea can be developed further to implement a full lambda calculus interpreter, to allow macros to be implemented in a more familiar applicative form.
Indeed. See the last page of Joe Marshall's "Syntax Rules for the Merely Eccentric" [http://www.phyast.pitt.edu/~micheles/syntax-rules.pdf](http://www.phyast.pitt.edu/~micheles/syntax-rules.pdf)
The R7RS standard is short enough that I will use it as a reference when necessary. I look up SRFIs more than R7RS though.
I found that Chez was rather easy to connect to C stuff, but perhaps my needs were too limited to stress it. In any case, I think you should try it out.
thanks
In case of embedding, you should look at [scheme.h](https://github.com/cisco/ChezScheme/blob/master/boot/ta6le/scheme.h) - just around 250 lines of the complete C interface - and [crepl.c](https://github.com/cisco/ChezScheme/blob/master/examples/crepl.c) to see how to use it for embedding in basic cases. In the other direction, look at [Chapter 4](https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:h0) of the documentation describes the C FFI inside Scheme for calling C from Scheme (including callback capability, though), and at [socket.ss](https://github.com/cisco/ChezScheme/blob/master/examples/socket.ss) for an example of its use.
Thanks
A wayland Guile Scheme WM would be great! 
*Programming in Scheme* by Eisenberg and Abelson, Scientific Press ISBN 0-89426-115-0. A good book, that. 
Thank you!
What are you going to do with it? If you get a version of it to run in Racket, and if you contact someone and get it under a Free license, let us know. I'd be interested for my class.
Sounds sexy.
Looking forward to double_cream!
##r/racket --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/9wy10w/ignore_list/)
This sub is for the scheme programming language. this is completely irrelevant. 
For the last one, the indentation and formatting are off. OP, are you the author? `(define (qs xs)` `(if (empty? xs)` `(list )` `(let (` `(middle (first xs))` `(others (rest xs)))` `(let (` `(left (filter (lambda (x) (&lt;= x middle)) others))` `(right (filter (lambda (x) (&gt; x middle)) others)))` `(append (qs left) (cons middle (qs right)))))))` 
Interesting! Like the amount of inspiration it takes from Racket.
That's interesting, for I've never really used Racket, and really, when I did, well, let's just say it became Racket PLaTer on. Can you tell me where the similarities are? 
AFAIK, Racket influences are, pretty much, the module and the macro systems
The module system is very similar to the PACKAGE-INFERRED-SYSTEM that I helped develop in ASDF, so to me, it's a common way to layout file and namespaces. I did not know that it was unique to racket in the lisp-1 world. I'll look into the docs. As for the macro system, that's cool as well. I am coming from a CL background, so generally syntax-&gt;datum and datum-&gt;syntax, and forgo most else. I do like our defrules, which is simply a combination of define-syntax and syntax-case, and I also like the fact that we use gambit underneath for the reader. Can you tell me a little more about what was influenced by racket? I like to read docs :D 
Here and there in the documentation PLT Scheme and Racket are cited as a font of inspiration. I understand the influence is more of ideas than actual implementation. As in https://github.com/vyzo/gerbil/blob/master/README.md - "It also provides a full-blown module system, similar to PLT Scheme's (sorry, Racket) modules. The main difference from Racket is that Gerbil modules are single instantiation, supporting high performance ahead of time compilation and compiled macros." 
In addition to what has already been mentioned the `for/` forms and the `in-` iteration forms seem to be very rackety but maybe these concepts actually come from somewhere else and Racket got inspired by them too.
Yeah, I've seen that, and do often look at racket docs when I am scheme'ing. Having said that, I've seem similar module systems in all sorts of schemes. Perhaps I am just not aware of the differences enough to see beyond the similarities, or rather, what makes racket and gerbil stand out as different from the others and similar to one another. It's been over a decade since I PLT'd, so am somewhat clueless in that regard. :D 
Yes, there is plenty of inspiration from racket! But the focus is different, Gerbil intends to bring racket-like facilities to a practical language with emphasis on systems programming.
Understood. When I was reading through the docs it actually made the impression of “the Go of the Scheme world” on me :)
Wrong sub, this is about the scheme programming language
If you buy 3 timeshares and sell 2 of them, you'll get paid to vacation.
[removed]
Most R7RS small is old stuff and already most of it. &amp;#x200B; R7RS red and tangerine is another thing.
pffi is very nice indeed
* I have continued my work on [http://scheme-lang.com/](http://scheme-lang.com/), I removed the custom font (Linux Libertine) which is nice but very big (1MB) and it was slowing down rendering. * I also prototyped a small reactjs application using chibi-on-wasm (r7rs) that you can check out at [/cons](http://scheme-lang.com/cons/). The code is available on [github](https://github.com/amirouche/scheme-lang/tree/master/cons). It doesn't support XHR / Ajax even if it is possible with more code obviously. I decided to not continue on this path and prolly drop the browsers all together... * I started an effort to put together R7RS libraries for Chez with partial support for `define-library` form. The code is at [source hut](https://git.sr.ht/~amz3/azul). You can `git clone` [`https://git.sr.ht/~amz3/azul`](https://git.sr.ht/~amz3/azul) `&amp;&amp; cd azul &amp;&amp; make pull &amp;&amp; make check` to get going. Yes the test suite will end with a failure, I am working on it. I also started to document it, check out the [nice rendering](https://vigorous-golick-e57443.netlify.com/library/scheme/base.html) that is (p \[built on ,(code \[skribe\]) syntax\]). &amp;#x200B;
I have no idea what it means, but the guile manual defines ,load as "Load a file in the current module. " And (load...) "Load filename and evaluate its contents in the top-level environment.". The current module at the repl is probably (system repl) and I guess we need a guile guru to explain what ,load is good for.
[http://www.astrostatistics.psu.edu/su07/R/html/base/html/Foreign.html](http://www.astrostatistics.psu.edu/su07/R/html/base/html/Foreign.html) [https://docs.racket-lang.org/foreign/index.html](https://docs.racket-lang.org/foreign/index.html) &amp;#x200B;
Not doing any scheme right now (only Y combinators in elisp) but lovely topic idea :)
The R foreign library can only call C, C++ and fortran code, and compiled shared libraries, no?
Yes, yes it can. Say, #include"scheme.h" or [libracket.so](https://libracket.so)? [https://docs.racket-lang.org/inside/embedding.html](https://docs.racket-lang.org/inside/embedding.html) &amp;#x200B;
In the guile port of my PEG parser library I implemented heredoc strings for guile https://github.com/rain-1/racket-peg/blob/guile/guile-heredoc.scm we could make this into a stand alone library
Practical like that https://www.greghendershott.com/2018/05/extramaze-llc-using-racket-postgresql-aws-but-no-ads-or-js.html or that www.schemespheres.org or http://www.lambdanative.org or https://www.gnu.org/software/guix/ ... or javascript creation, etc... ? 
&gt;Idk I'm finding it hard I think that's the point. "I think it's hard, therefore it's useless"... Scheme is a very tiny and flexible language. It's one of the smallest languages available, it can be used as a scripting language, as a prototyping system, as a code analyzer - you name it. Of course, these things are also possible in other languages, but the whole point of Scheme is to keep it simple and clean.
I didn't mean it's hard at all you misunderstood me, Im asking why strain of counting 90 parens &amp; relatedly reading code that looks like spaghetti scribbles is worth it, is it any much better than other, prettier functional languages?
Yeah like that, I feel like I've never really seen things written in scheme but thanks for pointing these out! Scheme was the first language I learned many years ago &amp; I haven't really heard anything about it since, was curious what kind of uses it has.
If the code looks like spaghetti to you, it's either badly written or you haven't had enough time to learn the language. Or both. ;-) The parentheses are actually quite useful, since they translate directly to a tree of cons cells, which means that code transformers ("macros") can be written with ease. They also allow for a huge amount of abstraction, since every operation (e.g. "if" or "while" and even function definitions) can be expressed as a function call. So it's mostly about uniformity. For example, one could write a function/macro called simplify, and `(simplify (* (+ 15 0) 2 1/2))` would be converted (at compile time!) to 15, *even if this kind of optimization was never included in the compiler*! Other languages don't really have this "insight" and "self-awareness", and I think that's what makes Lisps cool! 90 parens are btw quite uncommon, that's because functions in Lisp(s) tend to be shorter than functions in other languages. Also, indentation and paren highlighting make it a lot easier to read and write code.
Yeah you make some great points! I haven't really looked at it in years. Come to think of it I haven't heard anything about it either, why isn't it more widespread?
Oh, that's not an easy question, but I'm assuming that it's *too* flexible for most people. It can literally do *everything* (e.g. running code "sideways"), and a lot of programmers expect languages to make it hard to write bad code. Lisps have the property that writing bad code with them is just as easy (or hard) as writing good code. Therefore, they tend to blame Scheme for their own mistakes. Also, at the time of Lisp's invention, computers were really slow, and every instruction was expensive. Lisp was using garbage collection and was therefore slow as molasses. That's why faster languages - which were mostly using the imperative programming paradigm, allowing them to be compiled quickly to extremely fast assembly - prevailed. Lisp's reputation remained the same over the years because only a small percentage of programmers have learned it.
Is it still the case that assembled or compiled languages are faster?
Compared to purely interpreted languages, yes, but fortunately, these days Lisps are compiled, too. :-) SBCL compiles down to native machine code, and a few Lisps tend to run in 1.5 times the time a C program would take, being faster than Python and in some cases even faster than Java or C++. Technically, speed shouldn't be a problem anymore.
Further to @opinion\_rings point about SBCL, Chez Scheme also compiles to native machine code, as do Gambit &amp; Gerbil via C. These are all pretty fast now, being easily faster than Python, and, depending on the workload, often in the range of modern Javascript VMs. Unless you require hard realtime guarantees or are writing high throughput servers, I think they should be plenty fast enough for most use cases.
I remember a friend once looked at some Scheme code and asked "lolwut, could there BE any more braces?!" is no syntax. And the answer is no, you couldn't add any or take any away without changing the meaning of the programme. That's the whole point. Seriously, maybe give it an hour or two more before you come trolling. Or just look it up. You're not the first to notice, this question has been dealt with.
Still working on my musical pattern system, made big progress since last month. I adapted the [rsc3](http://rohandrape.net/?t=rsc3) library for Chez Scheme, so I now have sound via SuperCollider. My patterns DSL is coming along nicely. I will probably make the repo public some time in the next month.
Learning the language right now, but are your points really valid for scheme's hygienic macros? Mere pattern matching doesn't seem to benefit from "everything is cons cells", doesn't rust's `macro_rules!` do the same thing? Also, how would you write something like that `simplify` example?
Well, being able to extend your language with macros that can provide high level zero cost abstractions is a fantastic. Racket's for loops are for example just regular (albeit complex) macros. And with a proper editor you will have properly indented code. That way the parens disappear and you have neatly structures code.
You're right, hygienic macros are a bit limited in what they can do (although they're still very powerful), but most Scheme implementations support conventional macros, too. It's possible to write simplify using hygienic macros only: (define-syntax simplify (syntax-rules (*) ((_ (* something 0)) 0) ((_ (* something 1)) (simplify something)) ((_ (* something other)) (* (simplify something) (simplify other))) ((_ something) something))) 
I'm no expert on Rust macros, but AFAIK Scheme macros can match *any* expression ("destructuring") while Rust macros can't do that. The cons structure is important when it comes to embedded languages, e.g. parsing some source code in Lisp, analyzing it, modifying it and loading it into the system (evaluation). You can't modify Rust expressions in Rust (at least not natively, there's of course a way to parse an AST). 
Thank you!
I see, thanks.
You're welcome :-)
My pleasure :-)
LISP has had a working compiler since the early 1960's (LISP 1.5). MACLISP's NCOMPLR generated faster numerical code than DEC FORTRAN in the 1970's. Even if we assume, for the sake of the argument, that there is such as thing as an "interpreted language", LISP has not one of them in a long ,long time.
I make my living programming practical applications using Scheme and Common Lisp. That's quite worth it to me. If you cannot make it worthy to you, you will never know it's worth. Stop by for a pint o' Guinness, and I'll show you some worth that it brings! 
Thank you for pointing out Lambda Native. I'm going to look into it.
Could you actually share? I know I came across bombastic but I am genuinely interested in the practical applications &amp; honestly would grab a brew to talk about it if you were nearby.
I'm interested to know what sort of things you have done with Scheme and Lisp.
It there a way to avoid garbage collection with Scheme/Lisp?
Not really, no. There are some Lisps without a GC (e.g. BoneLisp), but unfortunately it's not possible to do manual memory management in it. Please note that Lisps are very fast these days, and GC doesn't have a huge impact on the overall execution speed anymore.
You can do arbitrary computation at expand time using `syntax-case`. Similarly in Rust procedural macros can do this as well. A lot of times the simple pattern matching and template filling (`syntax-rules` style macros) limits what you can do more than hygiene.
Rust `macro_rules!` macros are pretty similar (and probably somewhat based on) `syntax-rules` macros in Scheme. They just work over different AST elements.
&gt;They just work over different AST elements. I think that's the key difference.
Is syntax-case part of R5RS or R7RS?
It is in R6RS. It remains to be seen if it will be in R7RS large. Outside of R6RS it is one of the most commonly used procedural macro systems in Scheme.
The biggest example is slightly over a decade ago I was a contractor with ITA software, which is now a part of Google. https://www.itasoftware.com/ . The software that I worked on was originally for Air Canada, but ended up being using in part by airlines such as Alitalia, American, ANA, Cape Air, Delta Air Lines, United Airlines, US Airways, and Virgin Atlantic. I did have a small patch in QPX, which is also written in Common Lisp, and is used by Bing Travel, CheapTickets, Kayak.com, and Orbitz and, most prominently, https://www.google.com/flights. While not me personally, https://en.wikipedia.org/wiki/Grammarly is CL, and I use it all the time. That is fairly practical. I have been a Lisper, practically full-time, for just under 15 years, and have done a few commercial, "practical" applications over that time. My main one, and the reason I started Lisping in the first place, is a simple CRUD application with a web front end and a postgresql backend. It started in CL, and is now migrating to gerbil scheme. To me, personally, that is the most practical I can figure out, and right now we're talking 25+ billable hours per week. The more that's done in those hours, the more my clients pay for those hours. I choose scheme/lisp because they allow me to, practically, achieve more in the same amount of time. Again, it's a simple web app/database. but their business relies on it, so, practically 25+ people are, practically, using a lisp and scheme (and a wee bit o' C and sh and POSIX thrown in) environment in order to make their living. Practically :P Just playing around with the practical word, did not mean to offend or be rude. Basically, the world is a massive place, and in reality a tiny spec of dust in some tiny solar system in a galaxy close close near. It's our choices that make something practical, and really, we choose what it is practically for. Otherwise, well... Brainfuck is practical! And it's also practically ... inconceivable. It's a practical choice, either way. 
So \`syntax-case\` can do everything hygienic \`defmacro\` s do, right? Thank you, having only read r7rs I had missed that!
Yes `syntax-case` is a next level of power between pattern/template (aka macros by example) macros and low level macros where you are manipulating syntax/sexps directly. Another useful system for expand time computation is [syntactic closures](http://community.schemewiki.org/?syntactic-closures), which is supported in Chibi and MIT Scheme.
Thanks for this! I had no idea grammarly was Lisp, but it makes a lot of sense. You talk a lot about CL but what about the scheme dialect specifically though, are any of the platforms you listed utilizing pure scheme? Would you say it's more of a niche language, better for like string &amp; list processing but needs to be supplemented to provide full functionality for say a GUI or user I/O based application or webservice? Also how does it compare to other functional languages like haskell or OCaml?
same
this man APLs
If you could write a post or two about that CL -&gt; Gerbil transition that would be huge... especially since it’s about a webapp, which is a common task these days. I recently discovered Gerbil and like it. Knowing what’s it like to port an actual production webapp to it would be very beneficial for the community!
Nobody is matching parens by hand. Editors do it and given the nature of the langauge they can easily provide refactoring movements that are not that trivial in “other” languages. That’s what fascinating about Scheme - the virtual absence of syntax. Regarding amount of parens. This is what it’s all about: https://www.thejach.com/imgs/lisp_parens.png
I'm not sure what you mean by pure scheme. I'm not an academic, and do not know what purity you refer to, and beyond that, am not pure myself. ;) I would not say it's a niche language. and certainly has never been for strings and list processing, Perhaps you need to look outside your shell and realize you should teach yourself, not simply believe what you are told? I'm also not sure what you mean by supplemented, as all of my scheme dialects are much more focused on I/O than strings and list processing. Finally, scheme is not a functional language, so exactly what comparison are you seeking? 
That's a wonderful idea, and I am somewhat already doing such a thing, so will work a wee bit harder on it! 
Hmm I'm not sure. Scheme was the very first language I learned something like 8 or 9 years ago (and haven't used it since which brought about my curiosity in it's practicality) and had discussions back then about it with some people in academia &amp; that's what I'm going off of. Albiet my memory could not serve me correctly and they very well could have been wrong and a lot can change in 8 years but that's exactly why I opened this discussion. I inferred the string/list processing based on examples like grammarly which is purely string processing along with the fact that I only ever used scheme for list processing though these are narrow scoped inferences but I don't know much of the functionality of the other projects you mentioned though I suppose the flight tracker would be more data processing &amp; network related functions. But you said you threw in C, sh &amp; a bit of POSIX so that led me to believe it would need to be supplemented with other languages to render and compute a fully functional program which is what I meant by 'pure scheme' a program written solely in scheme no other dialects no supplemented C, no CL etc. By IO I meant user interaction I'm not sure why I worded it like that, I'm sure system IO is a strong suit. I was told it was a functional language in the family of haskell, OCaml and the likes though on the other side of the "spectrum" but if you say its not and therefore doesn't compare then that answers my question though it raises the one of well what kind of language is it then? It's definitely not OO and I was under the impression that any language was either OO or functional but now I doubt the validity of that. 
I think you need to be willing to learn, and not take what you were told as fact. Grammarly is hardly string processing. Phonemes and Graphemes are not strings, characters are not strings, and things made up of string-like attributes, like says vectors of characters, or null terminated bits, can be considered strings, but processing bits is not quite what you are referring to, yes? Scheme has never been about string or list processing. Not 8 years ago, not 20 years ago, not 48 years ago, not when it was SCHEMER. Yes, the syntax was based on LISP. https://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language LISP was also not a list-processing language, and it reality, never really was. That's really just a play on words. The original syntax was m-expressions, and list + fexps + macros came around a lot later. http://jmc.stanford.edu/articles/lisp.html If you have an operating system that is written and runs only whatever version of scheme you consider pure, and you do not have to interact with other systems, I commend you. My work involves developing computers programs and systems for my clients to get real work done, not to redesign OS's, so indeed, I am forced to use an implementation that runs on many operating systems and interacts with standards. As you seem to have a very limited perspective on programming and computer science in general, I hope this can expand your viewpoint: Scheme is not any single "type" of language. It's a multi-paradigm: functional, imperative, meta language. If you want to mutate bits and bytes, go for it. If you want an Object Oriented approach, that is more than available. If you prefer functions, go ahead! TCO is guaranteed, and continuations are available at any point. None of the existing approaches fit your issue? No worries! It's a meta-language, that can define entirely new syntax to express the solution you most desire, hiding the details under macros. Perhaps, instead of attempting to recall what may or may not be true or significant, you should read! :) The same holds true for programming. Read code, read what people are doing with scheme, realize that all users are not students nor teachers, and move on up. https://en.wikipedia.org/wiki/Scheme_(programming_language) Salut! 
[https://www.reddit.com/r/scheme/comments/atsrm2/what\_practical\_uses\_are\_there\_for\_scheme/eh4mrvg](https://www.reddit.com/r/scheme/comments/atsrm2/what_practical_uses_are_there_for_scheme/eh4mrvg)
[https://www.reddit.com/r/scheme/comments/atsrm2/what\_practical\_uses\_are\_there\_for\_scheme/eh4mrvg](https://www.reddit.com/r/scheme/comments/atsrm2/what_practical_uses_are_there_for_scheme/eh4mrvg)
damn I didn't read the nick u_u
good enough! 
:)
Nice! Bookmarked. Looking forward for more blog posts. 
Thank you for the compliment! I look forward to writing more, and sharing some of my projects. &amp;#x200B; If you use an RSS reader, I also have a feed for that. Whatever is most convenient for you. https://scm.pw/feed.xml
I have been using guile for awhile and davexunit's code is always an inspiration and a great learning tool.
I love the it, keep it steady!
The feed URL doesn't seem to be advertised in the HTML head. Since the Haunt author's website suffers from the same problem I guess it's a bug in Haunt itself, correct?
There are bits of code I took from David's configuration. This is one of them. Thankfully, it isn't a bug, just an oversight! Thank you for bringing it to my attention, I will fix it.
Back in my internet days (mom-and-pop ISP) I hacked up a cybercafe system and two RADIUS servers in Bigloo scheme. These systems were basically designed around fancy graph walkers, and that's a pretty trivial strength on the lisp family. I wrote our report generators in common lisp as format was far more powerful than anything I could do in PERL. These days, I'm mainly hacking LuaJIT + C as my stuff runs on embedded single board computers. Nonetheless, I still have a fondness for the lisp family and smalltalk.
And I finally got it to work! (use-modules (gnome-2)) (use-modules (oop goops) (gnome gw cairo) (gnome gobject) (gnome gtk)) ;Get size of gdk-window ;deprecated, but replacement methods unsupported in debian stretch (define get-size (lambda (gdk-window) (call-with-values (lambda () (gdk-drawable-get-size gdk-window)) (lambda (a b) (cons a b))))) ;draw: this is a test pattern, replace with what you ;want to draw (define draw (lambda (c width height) (cairo-scale c width height) (cairo-set-source-rgb c 0 0 0) (cairo-move-to c 0 0) (cairo-line-to c 1 1) (cairo-move-to c 1 0) (cairo-line-to c 0 1) (cairo-set-line-width c 0.2) (cairo-stroke c) (cairo-rectangle c 0 0 0.5 0.5) (cairo-set-source-rgba c 1 0 0 0.80) (cairo-fill c) (cairo-rectangle c 0 0.5 0.5 0.5) (cairo-set-source-rgba c 0 1 0 0.60) (cairo-fill c) (cairo-rectangle c 0.5 0 0.5 0.5) (cairo-set-source-rgba c 0 0 1 0.4) (cairo-fill c))) ;get window info and call draw with it when window is exposed (define pattern-expose (lambda (widget event) (let* ((gdk-window (get widget 'window)) (cr (gdk-cairo-create gdk-window)) (window-size (get-size gdk-window)) (width (car window-size)) (height (cdr window-size))) (apply draw cr `(,width ,height)) #f))) ;make the drawing-area and link it's expose-event to pattern-expose (define make-drawarea (lambda () (let ((drawarea (make &lt;gtk-drawing-area&gt;))) (connect drawarea 'expose-event pattern-expose) drawarea))) ;make the toplevel window (define make-window (lambda () (let ((window (make &lt;gtk-window&gt; #:type 'toplevel #:title "Test Pattern" #:default-width 300 #:default-height 300))) (set window 'border-width 10) (connect window 'destroy (lambda args (gtk-main-quit) #f)) window))) ;put the window and widget together and start it all up: (define win (make-window)) (define wid (make-drawarea)) (add win wid) (show-all win) (gtk-main) &amp;#x200B;
I don’t know why the site is down, but the GitHub repo already has couple of open tickets reporting the issue. The author (feeley) has responded to at least one of the tickets, so only thing we can do is wait. https://github.com/gambit/gambit/issues/383 https://github.com/gambit/gambit/issues/377
[This link works](http://dynamo.iro.umontreal.ca/wiki/index.php/Main_Page): [http://dynamo.iro.umontreal.ca/wiki/index.php/Main_Page](http://dynamo.iro.umontreal.ca/wiki/index.php/Main_Page) The link you cite has been non-working since December, apparently the maintainer may no longer have access to the system (see issue 377 linked in the sibling comment). 
ahh, i see. thanks for the link to that documentation. this is the official gambit documentation?
ahh, okay. thanks for that detail. forgot his password maybe? haha.
Yes, this link is where [gambitscheme.org](https://gambitscheme.org) would redirect.
If you are from Canada I believe you are legally allowed to copy and use up to 15% of any text book for a educational purpose. 
You can cons elements to the start of the list. (cons 1 '(2 3 4)) returns the list (1 2 3 4). The canonical way of building list is using recursive functions and maybe reversing the list at the end. 
You probably want to look into `set-car!` and/or `set-cdr!` to modify the list. &amp;#x200B; Alternatively, you might consider using `cons` and simply returning a new list, though that would probably require the caller to use a `set!`.
(define dude (lambda (hash1 dictionary) (define x '()) (cons (list-ref dictionary 1) x)) ;;cons (define newdude (lambda (word) (member word x) ) ) newdude)) &amp;#x200B; I had this, and doesn't work. With set however the same thing worked. Or am I not using this correctly? This function (dude) returns a function (newdude) which then checks if the list we made here has an element passed in that other function (newdude).
Thanks! I will have to check to see if set-car! is allowed because set! is not.
I'm not sure I fully understand the question I'm afraid. I'm not sure why you're creating a sort of object, and then seeing if a word is in a list. Did you professor ask you to make a sort of object using nested functions (closures)? It seems like that's the sort of idea here: (define make-dog (lambda (name age breed) (lambda (attribute) (cond [(equal? attribute 'name) name] [(equal? attribute 'age) age] [(equal? attribute 'breed) breed])))) make-dog allows you to pass in the name, age, and breed of the dog: (define shep (make-dog 'shep 5 'collie)) this returns the inner lambda, which a procedure that takes the name of an attribute, and returns that attribute: (shep 'breed) =&gt; 'collie the way this works is that the outer lambda "closes" over the three values you pass in for name, age, and breed. This is like "setting" something without changing anything. Notice how you can't change the object once it's made. This is important in scheme, you're more likely to create a new object entirely than to modify an existing one.