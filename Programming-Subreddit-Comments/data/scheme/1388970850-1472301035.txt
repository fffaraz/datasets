The FFI in Lua (stack based) or defined by LuaJIT (reads C code) are both clean and amazing. The [cffi](https://cffi.readthedocs.org/en/release-0.8/) in PyPy and Cpython is based off of the LuaJIT FFI. I would just adopt the intersection. So what you want is for say, a Gambit Scheme extension (in native code) to be compatible with Chibi or Chicken with no changes? I applaud that. Time to fire up an SRFI.
Absolutely! If you can get an SRFI passed... Yow, that would be awesome.
The klezlab.it link is still giving a GitHub 404 error, the direct link to federicoculloca.github.io is OK though.
:'(
I think it's now fixed for good.
If you try a game for each possible permutation of the deck, you will in the end see what is the longest possible sequence of turns. I wonder if there exist a permutation who never ends.
Nice idea. How would you do the permutations in scheme? If my math isn't failing me there would be 815915283247897734345611269596115894272000000000 (40!) possible permutations.
This is a bit of a guess.... In Gambit I notice that (eqv? 0.99999999999999999 1.0) =&gt; #t. Which I'd assume is an artifact of the underlying IEEE representation. This means the precision of the inexact number implementation affects the result of operations like floor. The R5RS document says that the output must be inexact if the result is affected by the value of the input.
At http://www.schemers.org/Documents/Standards/R5RS/HTML/ if you search for "(floor x)" it says: &gt; Note: If the argument to one of these procedures is inexact, then the result will also be inexact. If an exact value is needed, the result should be passed to the inexact-&gt;exact procedure. I only guess that it's so decimal numbers continue to stay decimal numbers, and exact numbers stay exact numbers. So if your calculations are based on inexact numbers, then it'll be inexact numbers throughout, even if you use floor.
It's hard to think of a pragmatic concern where something would go badly if floor were in fact exact, the way one would expect from mathematics. Maybe I'm just missing something.
Good point. I was thinking in terms of floor returning an integer. 0.0 is clearly inexact. Thanks.
Consider (floor 1.2e30). If returning a fixnum, large floats can't be floored at all. If returning a bignum, large floats return a value with a huge amount of spurious precision.
Type tagging. You don't want to change the type partway through a computation, because you have to change the "type". Also, if you are certain you are going to keep the same type, you can exploit things like IEEE Floating Point for faster rounding.
Yes, thanks. I see that it satisfies the spec.
But isn't someone who asks for (floor 1.2e30) asking for just that? (I'm not intending to be argumenative; I'm genuinely puzzled about what else could a person who asks for (floor x) want when x is represented as a floating point. Probably I just don't get 'exact'.)
I've never heard of this, thanks. I had wondered if the idea was to make writing an implementation easier.
I find #;1&gt; (floor (* (/ 1.0 3.0) 3.0)) 1.0 but I think I get your point. Thank you.
The important concept here is (in)exactness. Think of a Scheme number as numerical value together with a flag of exactness. If you measure something and get the result 3.9, then will represent the measurement with an inexact 3.9. Now (floor 3.9) must be inexact too (since the true value of the measured entity might have been 4.1). On the other hand for an exact 3.9, the floor value is an exact 3. Note that numbers entered with a decimal dot are read as inexact numbers so the prefix #e must be used to indicate exact numbers. &gt; (floor 3.9) 3.9 &gt; (floor #e3.9) 3 
No, not necessarily. There are a lot of formulae containing floor() where you want exactly this behaviour. Eg. the formula for the nth Fibonacci Number: [; Fib_n = \lfloor{}\frac{\phi{}^n}{\sqrt{5}} + \frac{1}{2} \rfloor{} ;] If you're using this to calculate Fib(n) for large n (for use in some other calculation), you're probably not going to want to compute every last digit. (In fact, if you did want an exact solution, you'd probably use a memoized recursive computation rather than the explicit formula.) There are other functions for common use cases where you want to take an integral floor. Eg. the most common case is probably flooring a quotient. This is provided by the **integer-floor()** function. (integer-floor 7 3) ;; --&gt; (floor (/ 7 3)) --&gt; 2
I don't find integer-floor in r7rs. Is it specific to an implementation? 
Yeah, sorry, that's an MIT Scheme-specific function. I was careless when I looked up the name. "quotient" is the standard function (which is much nicer than "integer-floor" anyway).
You need to define delay as well as cons-stream as macros. If you define them as procedures, the arguments are evaluated when they are called. Check out this link http://programmers.stackexchange.com/questions/95535/scheme-stream-implementation
Okay... after fixing the bugs in the code on stackexchange I've got it. thanks... 
Have you tried Racket? http://racket-lang.org It's not exactly RNRS scheme for either N=5 or N=6, but the interpreter has an R6RS mode: http://docs.racket-lang.org/r6rs/Using_R6RS_with_DrRacket.html
Seconded - I had a very good experience learning Scheme with Racket.
I saw Racket but how different is it from Scheme? I'll have a look into it regardless though, thanks :D
If you use the R5RS and R6RS modes, then it's for all intents and purposes identical. Even if you use the regular Racket mode 95% of learning exercises will run without modification. The only thing I can immediately think of is examples using `set-car!` (mutable pairs), which you should probably avoid anyway.
Excellent. I'll start toying around with it when I get off work. Thanks for the help!
I recommend GNU Guile. It is well documented and a joy to hack with. Additionally, here's a guide to Scheme implementations by one of the Guile maintainers that might interest you: http://wingolog.org/archives/2013/01/07/an-opinionated-guide-to-scheme-implementations
I know it is not scheme, but check out Clojure.
What was the issues with Chicken? It's a very good implementation! Chibi Scheme is also quite good, and it's much more lightweight than Chicken.
Last time I played with chicken, you had to compile it yourself.
... On windows?
Playing with programming languages on windows is..... not fun. I run windows because of Starcraft and Cubase, but I do all of my programming on Linux in a virtual machine.
Does Windows still not have some sort of unified installer system? (I've managed to completely avoid the the OS in any way that matters for well over 15 years). Still, looks like there's precompiled bundles available for chicken on Windows.
Here are some [installers for Chicken on Windows](https://bitbucket.org/roti/chicken-installer/downloads). I found them by reading the downloads page of the Chicken scheme website: there is a link to prepackaged binaries for several platforms.
Exactly.
My favorite implementations of Scheme are - Racket: http://racket-lang.org - rich library, good documentations, tonns of languages (not just Scheme!) - Chicken http://call-cc.org - amazingly simple C ffi
Yeah, but they need to make that sort of thing official. Personally, I hate installers. Give me a zip and ill throw it on my path.
I suspect anyone clued up enough to want to hack scheme is well aware of Clojure.
This with emacs. [This](http://users-cs.au.dk/danvy/dProgSprog/Lecture-notes/tools.html) guide can help you with the setup.
I do not want to enter that war, but the guide I linked assumes that you use emacs or plan to do so. That said it looks fairly easy to set it up with Sublime, and if he wants to avoid the steep learning curve of emacs then he should strongly consider that alternative.
I never felt satisfied with Racket, to be honest. I just want something simple, with little options and not having to click a million times here and there. 
I agree that Racket is exactly what you are looking for. The IDE that comes with it (DrRacket) does what you need, test snippets, step through close, etc. It's close enough to Ross for what you want. 
It's fairly easy to compile yourself aslong as you have mingw (which you'll need anyway). ~~Also, it's linked under the platform-secetion.~~
Racket or Gambit-C
This is an obnoxious answer, but if you know another language, you shouldn't have too much trouble implementing your own scheme interpreter. I did it in Java (ack!) a few years ago and enjoyed the exercise. The less obnoxious answer is to try PLT Scheme, which I see has been renamed Racket. Been out of this loop for a long time!
Hmm, a Google search doesn't turn up any obvious Racket eDSLs, _but_ I did find something interesting: GNU Guix, which is apparently a purely functional package manager with transactional package update and rollback capability. It describes packages using a Scheme eDSL: http://www.gnu.org/software/guix/
Good catch. I was a little presumptuous about some of the DSL I've heard about, like scribble (documentation) http://docs.racket-lang.org/scribble/reader.html?q=cache:4LcqSx-DW5EJ:docs.racket-lang.org/scribble/+&amp;cd=1&amp;hl=en&amp;ct=clnk for, unlike guix, they come with reader syntax, that may not be what you want.
This is actually kind of a nice compromise between the bloat of DrRacket and the normal one which doesn't have proper text selecting and stuff. I like it, thanks, didn't know it existed.
I just read the following note in the latest [v5.92 announcement](http://download.racket-lang.org/v5.92.html) of Racket: &gt; * The main Racket distribution has been separated into about 200 &gt; packages. The Racket installer combines the core system with &gt; bundled versions of these packages. &gt; &gt; Alternatively, you may now install a Minimal Racket distribution &gt; --- which is about 1/10 the size of the main distribution --- and &gt; add only those packages that you need. You may try to have such a minimal Racket installed and then selectively install those packages you want. 
Well, you complained that it is bloated. Presumably it loads a lot of stuff on start-up. Hence I thought if you install the minimal version, it may start faster. Though I have not tried.
Two of my favorites are in scsh: * the 'rx' package for expressing POSIX regular expressions as s-expressions * process notation for expressing UNIX pipes and redirects in s-expressions You can read more about them in the [manual](http://web.archive.org/web/20120229005319/http://www.scsh.net/docu/html/man-Z-H-1.html#node_toc_start)
From what I understand the point of `nonlat?` is to return `#t` when all elements of list are non-atoms, which is `#t` in third and fourth (zero elements) case. If you've fixed indentation/spacing the code would be easier to understand. HTH
Try posting here, too: https://lists.gnu.org/mailman/listinfo/guile-user/
The indentation method is how its showed in the book. I'm sure traditional methods are easier, but I'm trying to stick to what's shown in class, since it's only week two. You are correct on the nonlat? definition. I'm just unclear on the tracing. Thanks for the response. 
Thanks for the response, I'm trying to stick to indentation methods used in the book and in class. It is a bit goofy I'd admit.
Well, in order to understand the code, I've to add couple of spaces, which makes code look slightly more legible to me. Indents seem fine, just spacing I think is a bit off, but that's more of a personal preference.
The little Schemer, 4E By Daneil P. Friedman and Matthias Felleisen pg 16. [Amazon](http://www.amazon.com/The-Little-Schemer-4th-Edition/dp/0262560992/ref=sr_sp-atf_image_1_1?ie=UTF8&amp;qid=1390774985&amp;sr=8-1&amp;keywords=the+little+schemer) Pg 19 on the "Look inside" version For those that wish to understand where I'm getting the indentation/spacing
Thank you, reddit formatting i suppose. Looks nicer in DrRacket.
Thank you for taking the time for a well thought out explanation. I have tried your method and it works perfectly, cleaner as well. It makes mores sense than what i had initially. Thank you! Other than spacing, and perhaps a bit more extra code, do you see anything inherently incorrect with what i had? Even if it isn't the easiest way to do it.
It all works correctly, just a little convoluted is all. A good rule of thumb is that your recursive step should be the last one in your (cond) statement. There are exceptions, but they tend to stick out when it comes.
if you're interested in language implementation, i can recommend http://cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/ martin
8 pt type. Gimme a break.
ctrl,+ in most browsers. That said, I was hoping more that people could point out small inaccuracies.
That sounds about right. See http://www.ccs.neu.edu/racket/pubs/jfp2004-fffk.pdf for a take from the HTDP authors on their focus with the curriculum.
Thanks for having a go at this! i've been looking for a more straightforward intro to syntax-case for a while also. :-) Because i *don't* know syntax-case, i can't comment on the technical accuracy of what you've written; but overall it seemed to make sense to me! Formatting issues aside (e.g. when i zoom in to enlarge the text to a readable size for me, paragraphs aren't reflowed, but go well past the edge of my browser window), i just wanted to note a few typos: * "defines a true syntactic æquivalence" - should be 'equivalence'. * "a single syntax object repræsenting the input syntax" - should be 'representing'. * "First of" - should be "First off". * "Note the analogeous" - should be 'analogous'. Finally, i'd like suggest that "A pair of the most used ones is syntax-&gt;datum and datum-&gt;syntax" be rewritten as "The most used ones are ..." Thanks again for your efforts on this!
&gt; Thanks for having a go at this! i've been looking for a more straightforward intro to syntax-case for a while also. :-) I've been capable of more or less writing syntax-case for years now but I never really felt like I truly understand the operative semantics, then I left Scheme alone for a while but came back because a project required it around 1.5 years back and it suddenly clicked when I made the realization that syntax-case is much like ML pattern destructors. Anyway, thanks for the spelling errors. I hope it'll make you understand syntax-case because in my experience there has been no easily assimilated source on it any-where and most literature on it seems to assume you already sort of know what it does but like to know exactly what it does to make a conformant implementation.
http://www.scheme.com/tspl4/ is an excellent teacher of macros.
My attempt was here, FWIW: http://www.gnu.org/software/guile/manual/html_node/Macros.html
&gt; ... hoping more that people could point out *small* inaccuracies. Boom tish.
ah yes, quite clever, still, the font size is not an "inaccuracy" though. This is why I absolutely hate PDF by the way and feel that aside from communicating to a printer people need to switch to something else. Things like font size, font family, line spacing, font face, margings, should never be a property of the document but rather of the viewer. There should be a format which looks as appealing as a LaTeX generated PDF except that you can adjust all those properties in your viewer and the page layout will slide along fitting normally. Despite the popular myth that there is some optimal legibility for everyone, this isn't true at all. Apparently it's even the case that people in Europe tend to find sans to read more easily for body text and people in the US find serif to read more easily, on average of course. As for myself, large letters give a huge headache. I have all my fonts at about 6.5 pt on my computer. Certainly an extreme case but I have to zoom out significantly on all PDF's to not get a headache which means that the margins also get really small with it.
The link has the release notes too.
[You could always try a different instructor](https://www.youtube.com/playlist?list=PL6879A8466C44A5D5) Brian Harvey's final run of the SICP class from U C Berkeley
is each of those lectures in scheme? I'm definitely going to bookmark that, it certainly could be helpful. Do you know if that is the intro CS class at Berkeley? If it isn't an intro class I would imagine there will be a lot of differences in material covered between that dude and my professor. I think my main problem is I'm not really sure where to look on the internet for scheme stuff when I have questions, I guess there is always office hours but they are in inconvenient times.
Yeah my Professor actually mentioned that starting with scheme will supposedly make us better programmers later on, but I actually didn't know if he was just full of shit. Yeah my intro classes consist of 2 scheme, 1 java, and some discrete structures math thing. Then we pick a specialization to focus on, and thats like 20 something more credit hours.
Yes those lectures are Berkeley's Introductory Computer Science class. It uses Scheme and is based very heavily on [SICP](http://mitpress.mit.edu/sicp/full-text/book/book.html) If it's learning Scheme you're concerned about you could also try: * [How To Design Programs](http://www.htdp.org/2003-09-26/) - that link has both the first and second edition of the book * [The Scheme Programming Language](http://www.scheme.com/tspl4/) * [SICP](http://mitpress.mit.edu/sicp/full-text/book/book.html)
Wow thanks
Also, you can use [Stack Overflow](http://stackoverflow.com/questions/tagged/scheme). It's a "question and answer site for professional and enthusiast programmers". You are expected, when you post there, to have made an effort to solve it yourself, to have previously searched, and looked at documentation, and to post the specific part of the problem you're having trouble with. So a bad question is "how do I write Fibonacci in Scheme?" because it's so open-ended. A good question is "given my code: &lt;code here&gt;, it works fine if called with arguments 0 or 1, but I'm never actually getting a value returned from the function if I give it any larger argument." Actually, this is good advice anywhere, but on Stack Overflow, your question would be closed if you don't follow this.
You can PM me and I'm happy to help.
Let me give you some context about what your prof is saying. The claim that 'Scheme will make you a better programmer' comes, in a warped way, from one of the most widely-respected computer science courses, Structure and Interpretation of Computer Programs (SICP). That course, and its corresponding book, are taught at many schools. However, there is another school of thought about SICP--that it is flawed in certain ways. To address these flaws, some people came up with a new course--'How to Design Programs' (HtDP)--and a corresponding book. This course and book still use Scheme to teach CS, but in a simplified way that they feel is more suited for a 101-level course. [Wikipedia article here](http://en.wikipedia.org/wiki/The_Structure_and_Interpretation_of_the_Computer_Science_Curriculum) with a summary of the arguments. And I highly recommend reading the [original paper (PDF)](http://www.ccs.neu.edu/scheme/pubs/jfp2004-fffk.pdf) which describes the rationale for the newer HtDP course/book. I feel this will help you get a feel for how CS courses and teachers think that students should be taught.
Yeah, that's true. People don't want to solve your homework for them, but don't mind answering specific questions about problems you're having. Again, "here's my code, I expect to be getting X, but I'm getting Y. why is that?" is a good way to ask about a homework problem.
&gt; he sometimes give questions over things he hasn't covered in class Are they in the readings?
We don't have an assigned textbook for the class. We only have some novel: 9 algorithms that changed the world, and it isn't over material in the class. Idk why we were even required to buy it, its just like talking about things like google's pagerank algorithm
i've heard some things about stack overflow. I've heard even if you follow the steps like you said, you'll often get talked down to in the responses if its a noobie question.
its just intro to computer science: intro to programming, and algorithm design/analysis. Its my first CS class in the degree.
I'm not saying that never happens, but generally, you're pretty safe if you've done these few things: * Done an internet search for your problem * Done a Stack Overflow search for your problem * Looked at the documentation for the language * posted a specific problem you have.
Your CS curriculum sounds quite familiar... &gt;We only have some novel: 9 algorithms that changed the world ...Very familiar. If this is true, I have *very* relevant knowledge on what you're going through. 
Yeah I do. I normally don't like saying where I go to since I've had doxxing problems a couple years back on here.
No problem! I edited it out. But yeah, I've been there done that. I'd recommend reading *The Little Schemer*, as it's a favorite of the department, and will be infinitely more helpful in building a foundation in Scheme than *7 Algorithms...*
yeah that other book just talks about random algorithms and its really boring.
They're unrelated to monads.
Care to explain this one? A scheme syntax object is basically a symbol except that it also encodes what it is bound to. That, or a list containing such symbols. They exist to solve the problem that the `+`in (+ 1 2) can mean different things depending on the lexical environment it is defined in, as in: (let ([+ *]) (+ 1 2) (let ([+ -)) (+ 1 2))) Both `+` are obviously very different things here, in order for a procedural macro system to work without collapsing it has to respect that difference.
Maybe you'll find this interesting? http://dorophone.blogspot.ca/2011/09/scheme-syntax-is-monad.html cc: /u/elibarzilay
Well, it encodes procedural manipulation of syntax objects in monads. You can encode pretty much any pipe chain into monads including addition on numbers. Doesn't mean numbers are monads. In Haskell this works: let double x = [x * x]; return 2 &gt;&gt;= double &gt;&gt;= double; -- is [8] I've just sequenced doubling 2 twice in monads.
Sorry, but that doesn't make sense. First of all, your `double` function is squaring its input, not doubling it. Second, you've just used the list monad here, not a 'number' monad. You started with a non-monadic value 2, turned it into a monadic value [2], applied the function to get [4], then applied the function again to get [16]. The reason the article is able to encode syntax objects as monads is because syntax objects are actually made up of a combination of ordinary Scheme objects and their surrounding context. Which was my original point.
If you end up liking SICP, the authors have [MIT open courseware video lectures]( http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/) available to watch free.
It looks like some form of acquisition happened in December 2011 based on SEC filings [here](http://www.sec.gov/Archives/edgar/data/858877/000119312512140103/d325053dex992.htm) and [here](http://apps.shareholder.com/sec/viewerContent.aspx?companyid=CSCO&amp;docid=8514044).
As a huge fan of SICP, i agree with the "flawed" characterization. However, I don't know of anything even approaching it's breadth in such a short book. HtDP is nice, but covers half the half the breadth in more words. It probably contains 1/4 the magic (which is nothing to balk at), and can be good or bad, depending on your perspective.
My understanding is that after Cisco bought Chez Scheme, they stopped selling/releasing it, like straight up. This PhD candidate from Chez's author's department was telling me they have to go through special channels only available due to "I know a guy" to get the copies they need to continue his research. edit: "a guy" meaning "the author"
The perspective here (and the rationale for the authors of HtDP) is that SICP is in parts too advanced (and in parts requires too much domain knowledge) for year 1 undergrads.
that's sad and unfortunate I don't understand why corps keep doing that, buying stuff just to close it down...
It's listed for $65 on [this price sheet](http://www.centurylink.com/business/asset/channel/cisco-us-global-price-sheet-pricing3-pr120538.pdf). Could it be as simple as calling a Cisco reseller and asking for a SP-SW-LMX01CHL?
Chez Scheme was bought by Cisco when they hired R. Kent Dybvig out of the IU CS department. He works for Cisco now (much of what he does is under an NDA), and part of the contract was that the Chez license would become Cisco's. Andy's a pretty good friend of mine, and as far as I can tell Cisco has started using Chez in-house for what I suspect is a router firmware language. (Note that Andy's work with Kent for Cisco is also under an NDA, and he's said explicitly that he cannot confirm or deny his usage of Scheme in that work, but Cisco hired Kent and bought Chez, so I'd be more than shocked if it wasn't the case.) Cisco didn't buy the license to "shut it down", they bought it so that they could use it in-house without paying licensing fees.
Doing a PhD on proprietary software: bad idea.
I worked on one such format and viewer! Flow viewing was a royal pain. The problem is, you never know just where line breaks will fall, and your document can get ugly fast. Knuths line break algorithm is great, but even that gets confused sometimes. And images - there is nowhere to place them that works for even a small majority of documents. Ultimately, html produced just as good of results. Want an OK flow content document? Zip up some html. Just make sure to disable script before opening.
Yeah, this document viewer already exists, it's called HTML basically. HTML's line breaking together with floating images is pretty satisfactory in the end. I just think what Latex generates looks prettier in a lot of cases. Would be great to be able to combine the two.
To be fair, html (in 2004) has dreadfully poor typography support: custom typefaces, ligature selection, hyphenation, etc. We were not entirely misguided.
It has the typefaces and ligatures but yeah, that's exactly the stuff I want into a format that combines the strength of both. I wouldn't mind mathematical modules too which allow you to define useful mathematical concepts in external files. Being able to define that something is a fraction and let the viewer decide if it should be done with a horizontal bar or not or even configure the viewer to display stuff in S-expressions if I so desire.
Surely you meant $650 or $6500? There's no way in hell Chez would sell their full system for $65.
Have you tried using DrRacket instead?
This is probably a dumb question, but is the package included with the download of Dr.Racket? I'm pretty new to interpreters and I don't see any links to the package itself on the site you linked.
Errr, do you mean for the SICP language? It's not included in the DrRacket download - it's an add-on. There are **very** clear and explicit instructions on how to use it under the [2 Installation heading.](http://www.neilvandyke.org/racket-sicp/#%28part._installation%29). I'm frankly baffled how you could miss that
No, I saw the installation section; I don't know how to download it. It talks about how I need to "require" it, but I have no idea how to do that... 
Reread the section that bhrgunatha cited. *The steps in detail for how a beginner may do this through DrRacket are:*
Gambit works just fine beneath emacs on win7 x64, with its own emacs mode derived from xscheme. There's no reason that any other Scheme with sufficiently primitive I/O couldn't work just as well.
OK, so I just got this message: tcp-connect: forbidden client access to planet.racket-lang.org:80 with: "PLaneT: Finished with soegaard/sicp:2." below it. I tried googling and didn't find much... Any ideas? 
Yes. You can always change it back to plain "racket" or whatever you prefer later.
If you want to use emacs, look at using [quack](http://www.neilvandyke.org/quack/quack.el) to interface with the scheme repl.
[Here](https://cgi.soic.indiana.edu/~c311/lib/exe/fetch.php?media=install-emacs-on-windows7.pdf) is a full guide on it.
I got it to work doing this: (eval (quasiquote (macro-id some-label (unquote (quote the-list))))
nope, didn't work... thanks for giving it a try though.
Look here: http://docs.racket-lang.org/guide/eval.html There is a subsection about namespaces, maybe that's what missing.
Alright, here's what I was really trying to do, after I cleaned up the problems: (define-syntax my-define-empty-tokens (lambda (x) (syntax-case x () ((_ arg1 arg2) (with-syntax ((result (datum-&gt;syntax x (map string-&gt;symbol (syntax-&gt;datum #'arg2))))) (syntax (define-empty-tokens arg1 result))))))) ...that will turn: (my-define-empty-tokens legal ("else" "if" "void")) ...into... (define-empty-tokens legal (else if void)) ...but I'm not sure that's what you really want. After reading your message again, I think you want something like: (define legals '("else" "if" "void")) (my-define-empty-tokens legal legals) ...communicating run-time information to the compile time.
As for `syntax`, that's just defining the template for pattern matching variables. It is like a specialized version of `quote` for syntax objects. The reader understands `#'` as `syntax` also. You'll want to read up on `syntax-case` for the full gory details.
I'm not a schemer, but I think you might have to brute-force it: (define legals '("else" "if" "void")) (define my-define-empty-tokens (lambda (t ts) (let ((f (open-output-file "intermediate.ss"))) (begin (write `(define-empty-tokens ,t ,(map string-&gt;symbol ts)) f) (close-output-port f))))) (my-define-empty-tokens 'legal legals) ...and then compile the file "intermediate.ss". 
There has to be a better way. But your answer genuinely made me laugh; that's a clever, if not hideous solution. It's kind of awesome that one could conceivably do that in the worst case.
["Nevertheless, the only portable way to make available at expand time a function defined at runtime is to define the function in a different module and to import it at expand time."](http://www.phyast.pitt.edu/~micheles/scheme/scheme20.html)
This worked for me; which implementation are you using?
He is using [Racket](http://racket-lang.org/). Which implementation did it work with? 
I tried it in Petite. Technically he isn't using Scheme :]
If anyone is interested: I've done quite a bit of work (and three releases) on ggspec since posting this: https://github.com/yawaramin/ggspec/releases Thanks to /u/grettke for pointing me to the ML, that turned out to be pretty interesting.
looks great but I'd like to use it on windows, and doesn't seem to be usable on windows atm
I want to second /u/rhorama's recommendation of The Little Schemer, in case you haven't already picked it up. I've been enamored of SICP for several months now, but it wasn't until I picked up TLS last week that I got the essential patterns down well enough to program higher-order procedures without feeling like my brain was being twisted into a pretzel. Edit: do the exercises though. When it asks you to define the function, actually cover up the right hand of the book and write it out. If you do this consistently for the first 7 chapters, you'll have an amazing foundation for the very hard stuff that the authors throw at you in chapter 8 and beyond.
I tried it the other day. Specifically 2 python implementations (one was painfully slow), a Ruby implementation (didn't compile). However, without a truly open license, this language won't make it. Also, I need to pay, just to learn a bit of the language? This is 2014, there are plenty of great and free options. If you want to earn your living based on the language you create, there are smarter strategies.
Not a good idea to read up on the lambda calculus-the Y combinator piece is just a bit of fun. What you want to do is work through the exercise on the Y combinator until you get it. It may take a few goes. Check out stack overflow.
Why is it not a good idea? Not doubting you, I'm just curious. Seems to me that a lot of general programming patterns can be expressed in terms of the lambda calculus, and Scheme patterns especially.
SICP is great on many levels, but it's not a syntax reference, and it only makes passing references to lambda calc.
I always find it difficult to grok the BiwaScheme website and/or tests page to figure _exactly_ what it supports. Is there any clear API reference manual/user guide?
Read it later, but it's not necessay to undertsand the chapter in the Little Schemer.
When list of the library name consisting of single identifier, huski report an error message. $ cat &gt;test.scm (import (lib) (scheme base)) $ cat &gt;lib.sld (define-library (lib) (export foo) (import (scheme base)) (begin (define foo 'foo)) ) $ ls test.scm lib.sld $ huski test.scm Expected 1 args; found values This behavior is a bug?
thank you! I found a another problem. huski report a error in follow case: (define-library (lib) (export foo) (import (scheme base)) (begin (define-syntax bar (syntax-rules () ((_) 'baz))) (define-syntax foo (syntax-rules () ((_) (bar)))))) (import (lib)) (foo) I think (foo) must be expanded to 'baz. Sorry, I am not sure of where it is specified in R7RS. But, another implementation seem work as my expected. 
Good catch - yes, I think you're right that it should expand to 'baz. I'll create an issue for it...
I read, somewhere a while back, that Tektronics invested heavily in embedded Scheme for their industrial/electronic measurement tools.
Interesting. There was also Cisco's purchase of Cadence (makers of Chez Scheme) some time back. Do you remember where you might have read about it? My Google-fu is not powerful enough, apparently.
Careful with just using reddit as a way to promote your site. That's frowned upon. https://pay.reddit.com/wiki/faq#wiki_what_constitutes_spam.3F
C211 by any chance?
haha yeah
I've taken that class. PM me if you need help with something 
alright thanks for the offer. I actually just got done with the midterm a couple hours ago.
:-O ok, but isn't a post I wrote about Scheme interesting to reddit /scheme community? Anyway, I'll take care now that I know this. It looks to me that many links appearing here are software releases, isn't that considered self-promotion in the same way? I mean, I think I can contribute to this community from my site. If you think otherwise, I can stop posting here.
For what it's worth, I thought it was a valuable post. A kinder way to post links to your own site is via text post. Summarize in a sentence, post a link, and disclose that it's your own site. I've done this in /r/programming before where it was well received (though, I see people post their own blog links all the time -- I think the mods are just less active over there). ~ Somewhat off topic, I was impressed by the thought and breadth of experience demonstrated in your recent post on languages. I've noticed in my own experience developing a feeling of "this topic becomes absurd as soon as you are well-versed", and am deeply curious if it's universal, and the implications about most programming language designers.
Thanks for your comment and suggestion :) I honestly thought posting your own project was normal (with so many posts in this reddit being just a link to the latest release of a software). Next time, I'll follow your suggestion. I'm glad you enjoyed it! It is highly opinionated and biased, as you may expect from any post related to programming languages. It has been very controversial in Hacker News. Very sensible topic for programmers ;)
It's a matter of balance -- you've mostly been posting your own stuff, and not doing as much commenting. Mind you, I haven't actually removed your post or anything! It's just a heads-up, since other moderators might see it differently. Sorry about being terse; I have to say something similar to a number of folks every week -- and many of them really *are* borderline or actual spammers. (And I also think this post was valuable!)
Thank you very much for clarifying! I will really take care of this, community is something we must build together.
Neat! Why Gambit? I'm curious how you went about selection.
[The source.](https://github.com/jlongster/farmageddon) The developer of [this game](http://www.reddit.com/r/scheme/comments/1zuqr4/my_current_app_store_featured_game_was_written/) built on some of this work [as mentioned in the comments](https://news.ycombinator.com/item?id=7362217).
Screme: a Scheme for the 88000. There was some interesting design choices, in-particular using code alignment restrictions on the 88000 for procedure type-checking - the procedure? primitive had zero-cost during procedure calls. It also specialized other type-tests primitives in the test in (if test ...) syntax. Chapter in this excellent book: http://www.amazon.com/Topics-Advanced-Language-Implementation-Peter/dp/0262121514 Paper: http://dl.acm.org/citation.cfm?id=68199 "The Runtime Environment a Scheme Implementation for Screme, on the 88000" Steven R. Vegdahl at Tektronix Laboratories, Uwe F. Pleban at Applied Dynamics International 
The main reason to use Husk, aside from being a (mostly) solid implementation of the Scheme specs, is integration with Haskell. You can plug into any existing Haskell code / API's, and applications you develop could be deployed using Haskell's package management system. Husk may also be a good platform to hack on, since the code is written in a higher-level language and there is a large test suite. Husk is not necessarily intended to replace other Schemes, though - it just opens up new opportunities. There is a [R7RS progress report]( https://github.com/justinethier/husk-scheme/issues/24). Most of R7RS is already supported, and the goal is to eventually support as much of that standard as possible. Husk includes a working compiler as well as an interpreter, although a lot more work could be done to improve the generated code. For example, huskc generates too many intermediate functions at the moment. I am open to new ideas and/or pull requests, if you are interested :)
Very cool. Congrats on getting way past where most people get to with their own Lisp/Scheme implementation (and bringing something new and unique to the party, to boot)!
I like the new web page. But the only thing I find a bit strange is that the home page and the documentation page use different color schemes.
I think the most important features of this release is better Windows support, and easier Windows builds. Prior to 2.0.10, the build script was kind of broken for Windows builds if you did cross-compiling. If anyone wants guile for Windows, my build instructions [here](https://gist.githubusercontent.com/Madsy/9578867/raw/5e90eaa810bee9f8521ad416353033a85a3338f1/gistfile1.txt) might be helpful.
Maybe it's ripe enough for Guilemacs now..
Check out the cooperative REPL servers. I co-authored the patch and it is essential for integrating a live coding environment with an application that runs an event loop. Here's a demonstration of live coding and functional reactive programming using Guile 2.0.10: http://dthompson.us/functional-reactive-programming-in-scheme-with-guile-2d.html
From Mathematica. There's a procedure called "AppendTo[list, elem]" that destructively update the list appending element.
Fascinating that you ended up using the exact same name.
It looks nice (in fact has a lot of what I want in a Lisp dialect), however the community seems to be dead; the last update was in 2011. [Source for anyone interested.](https://code.google.com/p/owl-lisp/)
Source can be browsed at: http://haltp.org/aoh/owl/owl-lisp. The source is at the author's private git repository rather than googlecode.com: git clone http://haltp.org/git/owl-lisp.git Last update seems to have been at 25th February 2014. 
This is a wonderful article. It must be pretty difficult to test a garbage collector. To those who have written one, what are some of the tricks to testing?
I've only written the most trivial gc, but here's what I did. I added test hooks that let me pause and resume the gc, a well as force a gc. A test does a number of allocations, mutations, possibly forced gc, then asserts states about the objects -- eg which are reachable, unreachable, or already collected. The assertions name the object of interest by its content, not address, avoiding dangers of dangling pointers. Test cases are things like object cycles, long chains, deep arrays, unreachable locals, and forcing gcs from every callback in your runtime. Real programs are useful for performance, especially tracking the number of gcs and liveness ratios, as it can help you identify missing test case coverage. 
https://github.com/offby1/doodles/blob/master/circ.rkt
Well, scheme does have an explicit loop construct actually, but that's be defeating the point. What you want to do (if you think of the algorithm as a loop) is do the current iteration in a function, and then if you should do another iteration, recurse (you want to do it tail-recursively in the end, but first get the basic recursion, then deal with converting). 
To make it more space-efficient, keep track of the length in a separate argument. (define (length** a-list so-far) (cond ((empty? a-list) so-far) (else (length** (cdr a-list) (+ 1 so-far))))) (define (length* a-list) (length** a-list 0)) 
Thanks! 
Harry is one of my professors! He's looking for grants to do more research on the computational art history he talks a little about at the end. He also talks exactly like that paper is written and makes cellos in his spare time.
This may be worth looking at [http://cc.byexamples.com/2007/04/08/non-blocking-user-input-in-loop-without-ncurses/](http://cc.byexamples.com/2007/04/08/non-blocking-user-input-in-loop-without-ncurses/) 
As /u/mgreenly's link discusses, the function you want is select() with 0 timeout. It should work on Windows as well. The only annoyance is all the scaffolding to build and check the file descriptor sets.
Thank you! That actually answers another question as well that I would have asked on /r/c_programming about getting input before the user hits enter, but I don't have to now! Thanks!
I had the same question before and I asked [on stackoverflow](http://stackoverflow.com/questions/6206893/how-to-implement-char-ready-in-c). The answer is: &gt; You will need to go below the stdio level. On UNIX, you can use fileno() to get the file descriptor associated with the stream, and then you can use select() and read() system calls to do non-blocking reads.
Thanks! I was just going to ask that. The presentation is nice, but some context in order to understand some slides is much better! ps: do you have a mirror for the R6RS library?? The server crashes..
This link works: http://smyles.com/projects/r6gambit/
You are very lucky. Make the most of it.
Brilliant.
Any info on what's new and improved?
See the NEWS file. Direct link: http://code.call-cc.org/dev-snapshots/2014/04/17/NEWS
How long can it possibly take? (:
A summer? 
Glad you have seen the light! Instead of using list-&gt;vector you can use '#. For instance, '#(1 2 3 4 5).
For some reason doing so gives me contract violations "vector?" in my accessor methods. I intend to learn more over the summer, but finals start in less than 36 hours -.-
I think you can get Racket running without admin privs. I remember getting DrScheme (back when it was called that) set up on Linux without root privs.
I am in no way capable of compiling my own binaries on this windows machine, so I'm stuck with the installer. Maybe if I unpack it somehow.
Well, yes. I use linux exclusively on my home computer, so I really don't have a clue about how to go about sneak past this lockdown.
Since you are already using Racket, you may get more out of it using #lang racket instead.
My assignment required scheme :) But I'll be sure to take that advice in the future. 
[IronScheme](http://ironscheme.codeplex.com/) is a zip download.
Ill try it later today!
Luck.
Implementation fragmentation and the lack of a standard FFI. You can't simply pick a scheme and use a common library. You have to pick features and concessions, and probably have to port the library yourself. It's an enormous barrier to entry.
What means "commercial software"? If you ponder over that expression for a while you will likely find it meaningless...
Agreed. I remember when Java broke onto the scene its biggest win for many was not the language itself. It was the standard library that came with the JDK that was the real revelation. Other than perl and CPAN (arguably), at that time (1996 or so) there was nothing like it. Scheme's small size and lack of a standard library make it a great scripting language but a very awkward "whole stack" solution. 
No. I think this attitude is harmful for the Lisp community. People don't have something against Lisp (sure, some people might not like the parenthesis, but they'll get over them after the first couple of minutes or so). People are willing to invest their time in learning Haskell, which IMHO has a much steeper learning curve than any Lisp. Lisp's (and by Lisp I mean CL and Scheme, Racket seems to be on the right track, at least community and tooling wise) problem is that it lacks an active community and a good ecosystem. This is a cultural issue, not a technical one. You might want to read this: http://www.lambdassociates.org/blog/bipolar.htm. while I don't agree with it 100% it does make some fine points. If the community keeps clinging to the idea that Lisp programmers are misunderstood (and persecuted) geniuses Lisp is doomed to irrelevance. The community (and by its request and efforts) the language should evolve to meet people's needs and expectations instead of keeping its "damn kids, get off of my lawn" attitude. "Lesser" languages have done so to great success, e.g. Python, which many Lispers scoff at, has done so to great success.
Beside the fragmentation issue. I'd say too esoteric (lambda-isms became mainstream only a few years ago only) and not business oriented/marketed.
Fair enough, perhaps "commercial software" is not the correct terminology. Perhaps if I rephrase to ask, "are there any features or lack there of that prevent scheme being a viable tool for teams to adopt?". I realize that it is mostly used in academic settings (and has a history in AI research). 
i can't speak for all times, but ~15-20 years ago free implementations weren't that great on unix (which by definition had c), and on windows microsoft went with vb et al. i can remember when java came out, and had been playing around with lisp at a similar time. java was free and cross platform and soon had a pile of useful libraries. in contrast, lisp was fragmented and the only decent implementations were commercial. i worked for a startup at the time and we went with java - it wasn't my choice, but at that point lisp was about as fringe as prolog (at least in edinburgh, where i was, and which had something of a tradition in prolog).
Great post. I've just recently made the effort to learn CL/Scheme, and I haven't enjoyed learning a language more. From my (limited) experience, I prefer Scheme simply because of its simplicity. I would love to use it to build tools but still wondering where its limitations are, IO, std library etc. From the answers so far, it seems quite fragmented (I know I had to spend some time finding an adequate implementation for mac osx, settling on gambit). Anyways, still learning, and still trying to get a sense of its history. 
That works great! I'll have to configure an editor to use it seamlessly, but this works just fine! Thanks!
Scheme is a good educational language. Maybe you can have a look at Racket. Despite being quite baroque as a language, it has obvious advantages such as comprehensive documentation and a polished IDE -- DrRacket. BTW, you can use DrRacket to develop scheme programs, check out http://docs.racket-lang.org/r6rs/Using_R6RS_with_DrRacket.html
Some of the points you made are not accurate. Namely: - Even though scheme is not purely functional, i.e. it allows side effects, I would't go as far as to say that it's closer to C than to other functional languages; - The fact that CL is compiled and interpreted does not hinder debugging in any way. On the contrary, when using CL + Emacs + slime you get a great debugging experience, similar, if not better, than what you get in commercial IDEs such as Visual Studio or Xcode.
The problem with Racket is the license. If you cannot ship source or allow user modification of your application for whatever reason, then Racket's license effectively bars it from use. As a game developer I could never use Racket. The vendors and publishers I work with would laugh in my face if I presented them with its license.
Is that really the way the license works? &gt; First, if you distribute your Racket application in source form or as compiled bytecode files, the Racket license does not restrict you at all. &gt; &gt; Second, if you distribute your Racket application as compiled binary generated by raco exe, there are no requirements placed on the licensing of your software. However, the LGPL requires that you make it possible to re-link your software with modified versions of Racket. This means, basically, that you need to provide the compiled bytecode files used to produce the compiled binary, if requested by someone who got your software from you. Note that this does not mean that your software has to be made open source, nor do you have to give the source code to anyone, nor do you have to make the compiled bytecode files available to the public or let other people redistribute them. Furthermore, this is not revealing any more of your source code than the raco exe format, since the bytecode is embedded in an extractable way in the resulting executable. From what they state on the site its more of how to deal with swapping out Racket versions. Sure its a pain in the butt but is it really the same as giving away your code?
Note this: &gt; &gt; However, the LGPL requires that you make it possible to re-link your software with modified versions of Racket. This means, basically, that you need to provide the compiled bytecode files used to produce the compiled binary, if requested by someone who got your software from you. This is impossible with read-only media or on closed platforms. Users simply cannot re-link software on their Playstations or Xboxes. As a result, large game studios are very hesitant build technology around LGPL'd software. It's similar for other markets where users cannot modify the software.
Aaaaahhhh. I see what you mean. Then again, doesn't that also solve the problem for you? No one can re-link but how are they going to attempt it in the first place to request code/binary from you?
I guess I've always always read that differently. What you are saying is that if you release a product with LGPL code you have to give the user a way to flash their own image? I always thought it was more of a "conceptually you can re-link but you might not be able to physically." Someone can then request a binary/source.
Thanks! I understand the syntax case algorithm relatively well, I'm mostly confused about syntactic closures, which don't seem as well explained online. I may be overcomplicating my thinking though. As far as I can understand, the interpreter keeps track of current lexical variables during expansion (environments); uses closed over forms of these in macro expansions to avoid using names (which can collide); then at runtime these syntactic closures are executed to get at the actual variables. Lots more reading to do, hygiene is hard.
You could always [read the closures paper](ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-1049.pdf/). The full description of their hygiene preservation is at the top of page 6.
There's nothing "baroque" about Racket. 
These are two equivalent expressions in Clojure (another Lisp, close enough): (let [a 1 b 2] (+ a b)) ((fn [a b] (+ a b)) 1 2) Does that give you a start?
And to increment Triclops200 comment. If you want to support the named let pattern in Scheme with lambdas, It's something like this (couldn't test on this machine): (define (sum-up-to n) (let loop ((accumulator 0) (i 1)) (if (&gt; i n) accumulator (loop (+ accumulator i) (+ i 1))))) (define (sum-up-to/lambda n) ((lambda (loop) (loop 0 1)) (lambda (accumulator i) (if (&gt; i n) accumulator (loop (+ accumulator i) (+ i 1)))))) 
My opinions on SICP is that although it teaches fundamentals, a lot of people are lacking those fundamentals. I don't mean to be offensive and say you lack basis knowledge, but it's just that lots of programmers, as I see it, somewhat go through the programming path by skipping this basis. I believe lots of people will avoid (and have avoided) the sort of knowledge which is in SICP (and lots of other books too, btw; SICP isn't the only one) and go right to for example web applications with javascript, jquery, php and mysql (or something like that -- imagine this as the vb6 and delphi of the past) without considering what it is they're doing at a more fundamental level. It's not that these technologies I've mentioned are particularly bad, what happens is that they allow you to program even if you don't know much of these fundamentals (this was actually, iirc, a design goal of javascript in the sense that it had to be friendly to non-programmers). I understand this kind of comment I'm making is highly arrogant, but again, my intention is not to offend anyone. It's just that this is, in my opinion, something which is happening to lots of people in programming. SICP is amazing, anyway. If you liked it, check out some other books too. Like "The Little Schemer" and "The Seasoned Schemer". Like SICP, they use scheme, but they have this more fundamental goal throughout.
I'm really not sure what you're trying to convey in your reply. Yes, I'm sure many programmers lack some of the basic knowledge that is covered in SICP. I'm also certain that most programmers go through a journey of discovery and learning to become a better and more rounded programmer. My background is computer science and electronics engineering, so I was fortunate to learn the principles of computation. What I was attempting to do was point out that SICP covers these principles like no other material I've come across. I've enjoyed going through the exercises, learning scheme, and returning to the basics. It's provided me a new frame of thinking about some of these principles and a high appreciation for scheme (or lisp). I wanted to jot down my experience so that others may come across it and take a look and hopefully get as much out of it as I did.
I'm sorry. I wasn't clear. What I wrote was pretty much an answer to: "It seems to be aimed at first year under grads, but I feel even experienced developers can benefit from the presentation of the material, and the benefits of lisp and its dialects like Scheme." I agree with you (both in the original post and in your reply). I was just commenting on that statement I quoted. Many of the experienced programmers lack what SICP teaches, even though they're very experienced (many are much more than I am). You've mentioned you learned much of the foundations on your computer science and electronics engineering course, which is great, but keep in mind that most CS courses out there suck, MIT, Berkeley (both of which teach SICP) and many of the famous ones are exceptions. So, even experienced developers who have a degree in computer science can be lacking those fundamentals (I've seen a large number of people like that). Which is why I agree with you that SICP can help tremendously an experienced person. I'm not sure if you agree with my reasoning. I can see it's very arrogant of me to say such a thing, but again, I don't have the intention to offend anyone. Thinking back, maybe I shouldn't have posted that previous comment in the first place because of how arrogant it sounds. I just don't know a nicer way to say it. Berkeley video lectures of SICP: http://webcast.berkeley.edu/series.html#c,d,Computer_Science -- It's somewhere in there. By the way, it isn't just Berkeley which teaches SICP. My internet connection is too slow for me to look up, but there is a website which, iirc, lists lots of the universities which do and also links for their video lectures.
I get you now, and I agree. I wish my University taught SICP.
So what compiler/interpreter of scheme did you download? Petite Chez Scheme? I would suggest downloading Racket, it is a good IDE for either Scheme or Racket (a language very similar to scheme). If you are working from the command line (either linux or windows) scheme is the command generally to run the REPL (read-eval print loop), where you can actually run your code. So say you are in a directory where your file with all your code is saved at. Use 'scheme' to run the REPL, then the use the function 'load' in scheme to load your file. For example, (load "test.ss"). Then any definitions you have in that file should be accessible to you in the REPL. 
You're overestimating my knowledge here haha, I realize this probably sounds stupid but I literally have no clue how to run stuff. I have my code in notepad and it's saved in a txt file on my desktop somewhere. I also have the MIT/GNU program I downloaded. That's all I know. I know how to run python files from CLI but when I do scheme 1.2.txt it says scheme isn't recognized (also I figure the file has a type of extension, like python have .py).
Gotya. So do you have a PC, mac, or linux? Yes, typically scheme files are saved as .ss or .scm. So I would suggest downloading Racket, http://download.racket-lang.org/. It is an integrated development environment, and if you want to write purely scheme code just use #lang scheme instead of #lang racket, but really both are very similar. So then if you use racket, you can type your code, and then load/compile/run it all in the same place. I would suggest doing this to get acquainted with scheme, and then later consider checking out a text editor like emacs or vim. Check out this quick tutorial on learning scheme/racket: http://learnxinyminutes.com/docs/racket/. Happy coding. 
I absolutely agree with /u/daasb, racket is absolutely beautiful and user friendly. if you really want to run MIT scheme, you can try typing "scheme" in the terminal, which will bring up a very basic scheme prompt or REPL, you can actually get things done here, but it's very difficult to do so. You want a smarter environment that you can use to write scripts and pass them on to mit-scheme to evaluate. You should look up emacs and slime for scheme swanks if you want an idea of how much easier it is to just get racket. Emacs is an editor, SLIME is an extension of emacs that stands for Superior Lisp Interaction Mode for Emacs, that connects scripts you are editing to a Lisp environment so you can test parts of it on the fly. A 'swank' is an internal component of SLIME that is specific to a Lisp dialect and I believe takes care of relaying information to and from the actual lisp interpreter, it is deep magic to me. Anyway, the problem is that SLIME is built for Common LISP, scheme's fatter counsin; the issue here is finding a way to configure SLIME to work with a Scheme swank instead. I've done it before, so I know it /is/ possible, and it is not difficult, but it's a pain to figure out how to set up. Honestly, it works beautifully once set up! But racket outshines this setup by virtue of portability and convenience. You might consider working through How to Design Computer Programs, written by the makers of Racket specifically to address shortcomings in SICP, it's really good, and let's you do interesting things early on.
Not trying to bash you or add extra distractions or anything, but I wouldn't program in Windows. Linux is very conducive to programming and a lot of programming docs assume that your using some kind of Unix variant. For example If I want to execute scheme code on my computer, I can simply type it in my text editor, highlight it and type "eval-region" and watch it run. Best of luck and I hope you have tons of fun programming.
After downloading racket you can follow [this](http://www.neilvandyke.org/racket-sicp/) steps so all the SICP code unmodified.
I'm a Linux user but that's bad advice, and the example you gave doesn't even have to do with OS.
Also watch: https://www.youtube.com/watch?v=T4Myub8sJH0&amp;list=PLx6RT3-VNKAwf_P2ttdHye40RFKVzoE3x which is a video playlist on how to use DrRacket.
Getting sidetracked by installing Linux when your real goal is to learn programming could definitely be pointless yak shaving, but that's how I switched from Vim to Emacs... I started out working through SICP in Vim and realized that there was a better environment to support my goals. I've used Emacs on Windows. It might've been fine if I was more familiar with the OS, but in reality it was awkward for me. Certainly the Emacs way of doing things is it's own thing, neither Unix-like or Windows-like, but Emacs seems more natural in the *nix world.
Don't beat yourself up about it. IIRC, my first attempt was similar to your own. My first attempts at most things were often over-engineered, and that's fine: there's a lot I don't know, so I'm bound to make mistakes. But I would rarely make the same mistake twice. It's a learning process. Don't feel bad that you're not a genius. Most of us aren't.
Thanks for the encouragement. I've been a software developer for a while, and I have to say that algorithm development is certainly something that I need to develop my skills. Although it's challenging I find it enjoyable.
When I downloaded MIT scheme, a few years ago, it came with an emacs-emulating editor called "Edwin". If you've just typed some code into Edwin, and you want to execute it: position the blinking cursor just past the closing parenthesis; then, while holding down the control key, press "x" and then "e". You'll see the result in the bottom line of the window (called the "mini buffer"). You can get a lot more help from Edwin himself, by typing ctl-h (hitting "h" while control key is held down) then "i" (without the control key). 
Exactly what I was looking for, thank you! Did you go through the SICP course?
[Introduction to the theory of Computation] (http://www.amazon.co.uk/gp/aw/d/0619217642/ref=mp_s_a_1_fkmr1_2?qid=1401296025&amp;sr=8-2-fkmr1&amp;pi=SL75) by Sipser et al.
Another MIT course: [Mathematics for CS](http://courses.csail.mit.edu/6.042/fall13/). Click on Materials, there's a ton of resources for each topic, and finally the eponymous book, updated so often I just downloaded a newer version than the one I had. Nothing on lambda calculus there, so here's [Introduction to Lambda Calculus](http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf).
It should support any scheme the user wishes to use. Scheme is too fragmented for an editor to satisfy users with a single option. But, failing any, it should at least support Racket, Chicken, Guile, Gambit, Chibi, Gauche, and Chez.
The package has to have at least one default. Users can change their default after, but I have to make an opinionated choice at the start.
Be like Emacs, the default is to launch 'scheme' and push input through stdin and read stdout. Relaunching the process for all evaluations sort of thwarts the value of being a lisp.
Hat off to you for releasing a new version with preliminary iOS support on the same day Apple announced a new language for iOS ;) Keep up the good work.
I'm still finding R5RS the best Scheme standard yet: easy to implement, easy to follow and had true Scheme spirit. Everything after that is like trying to make the hippo dance...
I am working at it now too. To me it's pretty dense. But it's very interesting to read, work on and think about. Just finished 1.1 the day before yesterday and hopefully I can finish 1.2 by tonight!
How great is that?!?!?!
Did you mean to post in a different subreddit?
I'm provisionally removing this because it looks irrelevant.
This is probably the tenth explanation of call/cc that I read and I still don't get it. Why start with the "contains?" example when it doesn't really have anything to do with the problem? Why is the value of the current continuation only shown in a trivial example but not in the more complicated ones? Why are there no "steps" on how the computation works in the non-trivial example? &gt; When next is called the first time, state is called with the current continuation Which is? The whole "iterate" function? This is the major gripe that I have with all the explanations that I have found so far. A trivial example is shown and explained but then the non-trivial example isn't being explained at all. Or maybe I am just too retarded for continuations. Also a very possible explanation. **Edit:** Also why use a hard-to-read continuation when the same can be achieved with a tail-recursive function and some state inside a closure?
&gt;This is probably the tenth explanation of call/cc that I read and I still don't get it. Why start with the "contains?" example when it doesn't really have anything to do with the problem? Why is the value of the current continuation only shown in a trivial example but not in the more complicated ones? Why are there no "steps" on how the computation works in the non-trivial example? Yeah, This is a pretty strange way to start explaining continuations. I'm guessing that this is where the author had their "aha" moment, and are hoping the reader will as well. &gt; **Edit:** Also why use a hard-to-read continuation when the same can be achieved with a tail-recursive function and some state inside a closure? First off, I acknowledge continuation-based code is something most folks aren't familiar. No contest. However, just because it is hard-to-read for you doesn't mean it's hard to read for everyone. Are tail recursive functions hard to read? List comprehensions? I had a colleague recently complaining about all of these as if it were obvious to everyone that they're "hard to read". I'd caution to understand the technique used before determining if it's a hard-to-read instance of the technique. (Also, you're right, the use of continuations is overkill in this case. However, it's a tutorial; it's meant to be simpler in order to be understood. Like an array example that uses the array to add a couple numbers, it's meant to illustrate the operators, not illustrate the use cases)
&gt;This is probably the tenth explanation of call/cc that I read and I still don't get it. Have you tried [a page about call/cc]( http://www.madore.org/~david/computers/callcc.html)?
I'm the author. Thanks for your feedback! &gt; Why start with the "contains?" example when it doesn't really have anything to do with the problem? Functional programming languages are all about recursion and, depending on how you write your code, you can get entirely different results. The idea of that first snippet was to explain the effects of recursion in the stack, and, in the later examples, how the stack can be "manipulated" using continuations. I'm sorry for the confusion; I'll try to come up with some better way to introduce the reader to the problem. Any suggestion is welcome. &gt; Why is the value of the current continuation only shown in a trivial example but not in the more complicated ones? Why are there no "steps" on how the computation works in the non-trivial example? You can use DrRacket to step through the code and inspect the state of the program at any point, but you are right. It would be better if I replaced that textual "step-by-step" explanation with some sort of diagram. &gt; Also why use a hard-to-read continuation when the same can be achieved with a tail-recursive function and some state inside a closure? Yes, that particular problem could have been solved without continuations, but the idea was to keep things simple.
i remember continuations in ruby used to be really frustrating, because there was a lot of cool stuff you could do - but only if you were willing to take the ~50x speed hit (not a typo) in an already slow language.
Try reading this one: http://3e8.org/pub/scheme/doc/Call%20with%20Current%20Continuation%20patterns.pdf - this is the paper after which I got interested enough in call/cc to have the patience to read other papers and finally get it :)
Hi, Author here For Schemers who don't like Haskell so much, you'd probably enjoy the [presentation](http://community.schemewiki.org/?90min-scheme2c) that inspired me to start this project. I've diverged in some respects, but the original presentation is great!
This is a pretty misleading/terrible way to write a Scheme compiler. [Here is someone talking about how to do it correctly](https://www.youtube.com/watch?v=Os7FE3J-U5Q).
It's an awesome one and pretty lispy, but it's pretty rare too.
@comradeGnull The problem of the missing command line history is most likely due to the fact that GNU Readline has a GPL license - and that the some Schemes are using a more liberal license. That implies that one can not distribute readline with the Scheme in question. However there are solutions. In Racket one can use the library: http://docs.racket-lang.org/readline/index.html?q=readline#%28mod-path._readline%29 In other Schemes there are similar solutions. A general solution is to use the utility rlwrap : http://linux.die.net/man/1/rlwrap This can be used even if the Scheme in question has no readline suppot.
Then choose one Scheme implementation and stick with it, Guile or Racket are great. If you don't want to learn a new IDE, then download DrRacket. If you learn Emacs, then you will never have to learn another IDE again. If you are offended by having to learn a new IDE, then you should explore your feelings regarding why you are offended.
 - Second the use of rlwrap - Depending on your experience with languages, your willpower and the time you can allocate to scheme, I can't help but to suggest using Emacs. At the very least because of paredit which is IMO a game changer. Never ever write lisp or s-exp by hand. Just never. That could be rule #1 of the lisp philosophy: placing you at the right level of abstraction, in this case not an array of ascii char, but nested lists. 
your third and fourth comments are inconsistent. either there's a cost to learning new ides, in which case emacs is an advantage and it's reasonable to be "offended", or there isn't (in which case the silly remark about being offended makes some sense but emacs doesn't).
1) I don't know of any good answer other than "Follow you heart, simply choose an implementation and stick with it" :) I'd strongly suggest Racket. It's practical, has a lot of modules and functions but the most important thing for you as a newbie is: epic documentation. 2) Well, as others suggested, DrRacket might be a good solution here. I am a Vim guy so I didn't have to learn a new IDE when diving into Scheme and you may not need to as well - depends on what your favorite editor is. In fact, I only use DrRacket as a REPL because it's editing capabilities cannot (and should not) be compared to Vim. I'm sure there are other editors than Vim and Emacs that can be beefed up with plugins and serve as good Scheme editors.
A useful addition to any discussion on continuations: http://okmij.org/ftp/continuations/against-callcc.html
Well done, sir. Your first example is one of the clearest practical examples of continuations I've seen so far. Can't count how many times I've been in a situation like this...
So here is another example. The blog post OP provided gives an example of an iterator. It is a nice and simple design. But of course there is a down side. It requires you to generate a list to iterate over. But what if you wanted to create an iterator that actually generated the list on demand, i.e. a Stream. (define (iterate-fn f [init 0]) (define (state return) (let loop ([value init]) (let ([new-value (f value)]) (let/cc item-cc (set! state item-cc) (return new-value)) (loop new-value)))) (define (generator) (call/cc state)) generator) (define ints (iterate-fn add1)) (ints) ; -&gt; 1 (ints) ; -&gt; 2 (ints) ; -&gt; 3 So how does it work? The current continuation binding, state, is replaced after each iteration of an infinite loop that uses the last output as an input. Horrible explanation but I'm currently writing a blog post that will actually walk through the development of this iterator, or better yet a Stream Generator.
I've added a lot more explanation of my thought process when using continuations, might be of some help. [Explaining Continuations](http://jecxjo.motd.org/code/blosxom.cgi/coding/explain_continuations)
Interesting explanation. Thanks for the post.
Is it required for learning Scheme? No it is not.
The basics of the untyped lambda calculus are extremely simple - just three grammar rules and three reduction rules, and only one of those rules is truly important (beta reduction). So, find a gentle intro tutorial and learn those basics. After that you can decide whether you're interested in learning more.
To my own little understanding, LC is useful by its abstract side. It's empty yet you can model almost anything. Quite counter-intuitive. See it in action https://www.google.fr/search?q=programming+with+nothing I like the fact that you end up modelling relationships between functions and building 'machines' out of recursive relationships.
The problem with this wikipedia page is that it does not *define* `shift` and `reset`, it only builds intuition and gives example. It will surely be improved but, for now, it is not very useful. You should go read one of the articles cited in the bibliography, or a better presentation, if you want to be able to follow the execution of shift+reset code.
The Wikipedia article was misleading, but I found these rewriting rules in [the Racket documentation](http://docs.racket-lang.org/reference/cont.html#%28form._%28%28lib._racket%2Fcontrol..rkt%29._reset%29%29). Not surprisingly, they are recursive. (reset val) =&gt; val (reset E[(shift k expr)]) =&gt; (reset ((lambda (k) expr) (lambda (v) (reset E[v])))) ; where E has no reset So the code transformations would look something like this: #;"original" (reset (begin (shift k (cons 1 (k (void)))) (shift k (cons 2 (k (void)))) null)) #;"first transformation" (reset ((λ (k) (cons 1 (k (void)))) (λ (v) (reset (begin v (shift k (cons 2 (k (void)))) null))))) #;"second transformation" (reset ((λ (k) (cons 1 (k (void)))) (λ (v) (reset ((λ (k) (cons 2 (k (void)))) (λ (w) (reset (begin v w null)))))))) #;"third transformation" ((λ (k) (cons 1 (k (void)))) (λ (v) (reset ((λ (k) (cons 2 (k (void)))) (λ (w) (begin v w null)))))) 
for many, such simplicity is a negligible detail for evaluating the effectiveness of a language. apart from the general preconditions that have to be for one to find interest in scheme, it seems to me that in a commercial setting the questions "is there anyone successful using it?" and "what problems does it enable me to solve without much effort?" are the most important ones. for scheme there are currently afaik not that many good examples to answer the first question - for java for example there probably would be. the second question is a basic business matter - why invest effort for recreating solutions when you can reuse somehow. the most likely to be commercial users seem start-ups and companies who want to try something new. they would have to decide on an implementation and have to recreate some solutions that are already available in other languages. but all doable i think.
Thanks for the info, I'll add a note in the post to show in cases where let/cc is missing. I think its probably a Racket thing.
How is this related to Chicken? (Noticed the base url).
Just an FYI, [there's a slew of useful Scheme monads here, with a good license](https://github.com/dleslie/monad-egg).
Is it possible to run this in a vm?
Someone with adequate knowledge should try. Maybe that's as easy as running a small image through qemu.
Hm... from your description, Scheme REPL will already do most of the job. You only need to find implementation suitable for embedding, like: Guile, TinyScheme or Chibi. Now the question is, what are primitive operators? Math operators like &gt;,&lt;,+ or something your project will provide? Also, how would you like your command line to look like? To enter s-expressions or to enter expressions that will be converted to s-expressions?
&gt; I'm not aware of what the s-expression conversion approach involves. Could you please elaborate on that? i.e. do you want to enter sexps on the command line directly: (+ 1 2) or do you want to be able to do something like: 1 + 2 which then gets converted to an sexp like the above?
&gt; When I mentioned primitive operators I had in mind, for example, routines that added points and surfaces to the model as well as deleted and edited them. OK, in Scheme (and other Lisps), there is no (visual) distinction between builtin operators and user supplied operators. For example: (list 1 2 3) (my-func 1 2 3) Here, *list* is, in many Schemes, builtin primitive, but *my-func* user defined one function. Now, they both can accept expressions that will be evaluated to primitive types in they argument list, like: (my-func 1 2 (+ 1 2)) (my-func 1 2 (some-call)) Is this what you were looking for? &gt; Forgive my ignorance, but I'm not aware of what the s-expression conversion approach involves. Could you please elaborate on that? Sure. In the past I had a chance to built 'command line' for a user, with ability to extend it. That command line was disguised Scheme REPL, but without parenthesis to make adoption easier. Instead of using: &gt; (do-something) ;; or &gt; (do-something 1 2 3) he could do: $ do-something $ do-something 1 2 3 This was very easy to achieve: just read expression until newline was hit, wrap it around parentheses and send to Scheme eval function. Obviously, this would not accept nested expressions, but for the given case, this wasn't needed at all. Then, user could switch to 'Scheme' mode (by entering *scheme-mode-on*) where he could easily add new commands and write complex evaluations.
To write command-line one-liners, the outer parenthesis might be a bit redundant (i.e., annoying to type), but I believe that form would work. One example of what might be an acceptable expression command line expression: + (+ 2 3) (+ 1 4) But redundancy aside, the standard s-expression form would work.
&gt; Is this what you were looking for? I believe it is. The main requirement is that it's possible to evaluate expressions before they are passed to a command. The rest is just added value. &gt; Then, user could switch to 'Scheme' mode (buy entering scheme-mode-on) where he could easily add new commands and write complex evaluations. Among those complex evaluations, would it be possible to evaluate nested expressions? 
Yes.
Then it sounds just what the doctor ordered. So, what's the best way to implement such a system? For example, is it preferable that this sort of system is implemented as a custom interpreter or is it better just to adopt a third-party component?
qemu-system-i386 -fda dreamos.floppy
So easy I almost can't resist procrastinat...
Honestly, I'd use Tcl. Scheme's a nice small language but paren-heavy syntax makes it uncomfortable to use from a REPL - you want slime or at least decent editor support. Tcl has even less syntax and the majority of commands look like something you might type at a shell prompt. Tcl was designed for exactly this sort of thing, gives a very tidy C embedding/extension layer and turns out to be even more homoiconic than Scheme (!). A convenient lightweight implementation is [http://jim.tcl.tk/index.html/doc/www/www/index.html](Jim) if you don't want the full weight of core Tcl.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Greenspun's tenth rule**](https://en.wikipedia.org/wiki/Greenspun's%20tenth%20rule): [](#sfw) --- &gt; &gt;__Greenspun's tenth rule of programming__ is an [aphorism](https://en.wikipedia.org/wiki/Aphorism) in [computer programming](https://en.wikipedia.org/wiki/Computer_programming) and especially [programming language](https://en.wikipedia.org/wiki/Computer_programming_language) circles that states: &gt;Any sufficiently complicated [C](https://en.wikipedia.org/wiki/C_(programming_language\)) or [Fortran](https://en.wikipedia.org/wiki/Fortran) program contains an [ad hoc](https://en.wikipedia.org/wiki/Ad_hoc), informally-specified, [bug-ridden](https://en.wikipedia.org/wiki/Computer_bug), slow implementation of half of [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp). &gt;This expresses the opinion that the perceived flexibility and [extensibility](https://en.wikipedia.org/wiki/Extensibility) designed into the [Lisp programming language](https://en.wikipedia.org/wiki/Lisp_programming_language) includes all functionality that is theoretically necessary to write a complex computer program, and that the core implementations of other programming languages often do not supply critical functionality necessary to develop complex programs. &gt; --- ^Interesting: [^Common ^Lisp](https://en.wikipedia.org/wiki/Common_Lisp) ^| [^StumpWM](https://en.wikipedia.org/wiki/StumpWM) ^| [^Jamie ^Zawinski](https://en.wikipedia.org/wiki/Jamie_Zawinski) ^| [^List ^of ^eponymous ^laws](https://en.wikipedia.org/wiki/List_of_eponymous_laws) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj0ms98) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj0ms98)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
also, best project name ever (:
Epic readme
Really needs a TL;DR version ....
Damn, I wish I had thought of that.
I really like to see such frequent updates on Sagittarius, and that it's not already 2.0 or whatever is nice, nothing is being rushed or quickly deprecated like I've seen in so many other languages/implementations. Curious, anyone using Sagittarius for any projects, and why?
I'm a big fan of Scheme, but I have to agree with you here: Tcl is small, easy to use, and as a bonus, Scheme-like syntax is possible if one prefers it. Jim is excellent when a GUI isn't necessary.
I thought Peter Norvig had written one, but it's only a subset of scheme. It still might be useful to you: http://www.norvig.com/lispy.html
I'd recommend using DrRacket (used to be DrScheme) instead of notepad. It will also do the compilation for you. You should choose R5RS as the language (it's a version of scheme that matches most books). I've read both SICP (available free online) and the little schemer and would recommend SICP hands down. SICP fit my learning style perfectly and I consider it the best computer science book. This isn't true for everyone so you might want to try both.
Fwiw there's [a third-party Racket package](http://www.neilvandyke.org/racket-sicp/) that provides a SICP-specific mode, designed to make sure everything goes smoothly for people working through the book. SICP expects some specific things, like ability to redefine built-in functions, which not all implementations allow. In addition, some of SICP's problems are more interesting if you have the 2d drawing library it assumes (Picture Language), which was originally written for an ancient platform and doesn't run on most Schemes; this Racket package implements a compatible graphics library.
I recommend DrRacket as well. Great, easy way to get started. One little note is that DrRacket ostensibly is for Racket Scheme (formerly called PLT Scheme), but it supports other variants too. IIRC you might have to change the language setting since Racket Scheme doesn't match the Scheme used in SICP precisely. [Here is some suggestions on that](http://stackoverflow.com/a/943136) and [here is some tips on using it with The Little Schemer](http://stackoverflow.com/a/13004005).
Wow, watching that video made me physically uncomfortable :/ strong stuff
What I miss from Racket and other scheme/lisp implementations is an easy way of creating standalone programs with command line parameter processing. Common lisp has Clon but try installing it thru quicklisp and to create shebang/.bat -scripts and cry. In Python, I can just instruct the user to install Windows interpreter and to copy *.pyc file into path and that's it. I would like to develop and test my scripts in Racket and then just press "create fas -file or standalone executable" -button. 
I think the Racket developers made a conscious effort to set themselves apart from the minimalist Scheme language of the early days. I mean, they did change the name from PLTScheme. It's very good for newbies, but as a result its source isn't as hackable as, say, chibi-scheme.
I want Scheme—the RnRS—to be minimal. I want—at least some—Scheme implementations that aren’t minimal. I think what the PLT/Racket group has done is impressive, and I’m very glad it is there for the times when I want to use it.
With the modularizarion of Racket and its dialects feature, how can you say it's bloated? Does anyone force you to use the modules that go beyond the basic Scheme stuff? Maybe the problem is that you are trying to put Racket next to all other schemes and you are trying to view it through the "classroom only" optics. But Racket devs apparently made the decission to be more than that - they want to build an industry-recognizable general purpose language and I applaud them for that. They inspired many other languages and that's a good thing. Too bad they get orders of magnitude less attention than, say, Clojure. They deserve more.
I totally agree that Racket is bloated! Look at this: http://s10.postimg.org/e1ylfxm2x/bloatware.png Also, I must say that, from my experience, Racket community is just awful. And their web-server library is totally unusable, documentation for it unreadable. Should not be surprised that number of real (not toy) web applications written in Racket is aproximatelly zero! In short, awful bloatware, awful community. A shame, because the Scheme is so nice language.
If you're looking for an SICP support group, drop by #symbo1ics on the Freenode server. About a handful of us are going through SICP, mostly using Racket. I just finished chapter 2 this summer myself, and am just starting on chapter 3. Ping me @ DrDuck
Whatever you think of R6RS, I don't think it's accurate to say it was specifically by the Racket people. There were developers from four implementations on the committee: Chez, Larceny, Racket, and Scheme48/scsh. The original committee had developers of six implementations, but the devs of Gambit and Bigloo resigned before the final report came out.
The environment and massive "batteries included" set of packages that Racket has built is great, but I wish it was built on standard Scheme. Minimal core, add the rest as packages. I TA a course that uses Racket, and the "racket vs Scheme" distinction makes education difficult at times. Finally having a standard library form should be a great help here in theory, divergence has severely harmed Scheme as a productive language. Unfortunately with Racket having forked away from Scheme in general, I suppose we can hardly expect them to throw in with r7rs :/
I don't want them to take part in R7RS to be honest. Maybe with the large wg if they can come up with something idiomatic and not duct-taped together, but I like the small wg right where it's at. Chibi-scheme, sagittarius, CSCM, et al are plenty powerful enough to meet needs if the effort is present. 
Scheme's eternal problem has always been lack of extension in terms of apps and libs, but I like the route that some of the new schemes are going. Chibi has a builtin package manager now I think, I've heard rumors that Guile 2.2 is going to use Guix as a lang-level package manager, but it still doesn't solve the problem of fragmentation. It's easy to tape shit on like Racket does, but at least they've built their platform around that exact concept. As for R7RS scheme, I'd like to see a simple, powerful mechanism for extension. It needs to be simple to use, simple to hack, and simple to learn. If the large WG can do that, there may be a chance of righting the wrongs of R6RS 
Doesn't Racket's license make it difficult to produce closed-source software? IE, if I use a Racket syntax macro in my code and build a binary with it, am I not deriving LGPL'd code and not adhering to the license?
I don't see any mention of additional language support in the latest release of chibischeme. I'd see that as 'bloat' on top of the small, embeddable Scheme implementation it has always been promoted as.
Whatshisname had it posted on the google code introduction. Maybe, but why bother embedding into just one lang? Might as well embed anywhere you can. You are mistaking extensibility with bloat. I don't need a core primitive for OAuth, or parsing JSON or shit like that, but I think that an embeddable language oughtta have the means to let people extend its reach beyond one particular language. Chibi's API already allows it, I haven't seen anyone do anything really cool with it yet, and I have too much with Guile to bother. But yeah, apples and oranges. Chibi has a solid core, that doesn't mean you can't improve on it without bloating.
Racket is "batteries" included. You have to come at it that way. It isn't meant to be minimal. There are other Scheme systems for minimal.
The difficulty comes from how to enable users to link against a replacement system. You would need to release your code in both a binary executable and a compiled set of objects that someone could use to link against. This definitely has kept me from using Racket in production related projects.
I've never understood that, its "batteries included", not "batteries forced on you". If anything I almost always use the base version of racket for all my code and include just what I want. That was always my big issue with CL. There is just so so much "standard" stuff in there that I couldn't wrap my head around it. For the most part Racket's "bloat" is modular so you really could think of #lang racket/base as _the_ language and #lang racket as the "I just want everything" mode.
Not only do they need to create this mechanism, we need people to stop creating "one offs" based on them. When a standard is written there cannot be implementation-based special cases for things. It makes generating platform agnostic libraries impossible, which is what we really truly need. If one implementation starts to create their own deviation from the standard we need to not support this. If you find a flaw in the standard we need to come up with a _standards_ way to solve it. But what usually happens is each platform creates their own work around and compatibility goes right out the window.
First off, I see you in #racket all the time, so I already know this conversation will be largely biased. Secondly, Scheme is all about elegance. Minimalism contributes to the cause by removing obstacles instead of tacking on extra stuff like lib-hack-opengl-pre-alpha-0.0.1 or whatever. Don't confuse yourself, Racket is a conglomerate of inconsistent, unnecessary bloat. I know you think it's great, but that mindset is precisely the reason it's unable to progress into non-academic industrial settings. I don't dislike Racket per se, but if you can't even keep your naming conventions consistent across a core module, what makes you think the next AAA studio is going to use it for rendering, or a scientist sequencing genomes with Racket? It won't happen. In conclusion, if you like Racket I've no qualms with it personally. What I'm getting at is the *fact* that Racket won't be able to keep up with R7RS without a serious teardown. But hey, why not just tack on a new #lang for that, right? After all, calling it PLT lets you throw pragmatism out the window anyways, so why worry? 
Most of us think your assertions about both R6RS and Racket are silly. And no, you don't speak for a lot of us.
I don't really care. Your misunderstanding of R6RS is unfortunate, tho. 
Our official position on this is here: http://download.racket-lang.org/license.html You should be able to produce closed-source binaries with Racket.
You say: &gt; Racket is a conglomerate of inconsistent, unnecessary bloat. and: &gt; I don't dislike Racket per se It seems pretty clear you aren't interested in a serious discussion.
Well, some closed-source software. Some of us aren't so lucky as to be working in environments or for clients that will allow users to relink software.
:( ur achy breaky heart... 
Sure, I can imagine that. However, note that this doesn't make it any harder to produce closed source Racket programs than closed-source Python, Ruby, or Java programs.
Python has a BSD style licence, which is why you find it in video games that target certain consoles.
reformat
http://www.cs.indiana.edu/~dyb/pubs/stack.pdf
True, but python doesn't have a way to compile to an executable, so your source is always relinkable in the sense I mentioned. If you're modifying the core Python source code and not releasing those modifications, then that indeed is something you aren't allowed to do in Racket. But if all you want to do is ship some closed source Python code with your game, then the racket license lets you do exactly the same thing.
Please don't bore us with redundancy. It's apparent you don't care and that you haven't a clue about what you're talking about. The scores on your comments and post show how little the rest of us think of your technical judgment. You'd think you'd at least try to support your assertions Instead, you are seen (rightfully) as an idiot. Please go somewhere else, child. 
Assuming I understand the question ... A: `(x)` becomes (let ((i 0)) (set! i (+ 0 100)) ;unused value (set! i (+ 100 10))) `(cc 50)` leads to ; i was last set to 110 ; unused (set! i (+ 110 10))) `(cc 50)` again leads to ; i was set to 120 ; unused (set! i (+ 120 10)) B: `(x)` becomes (let ((i 0)) (set! i (+ 0 100)) (set! i (+ 100 1)) (set! i (+ 101 10))) `(cc 50)` leads to ; i was last set to 111 but (+ i ...) was stacked before the call/cc (set! i (+ 100 50)) (set! i (+ 150 10)) `(cc 50)` again leads to the same thing. 
if the value of context variable i is saved before call/cc, both case of A and B should behave like B; in the case of A, the value of i saved by call/cc is the final execution of cc, not the value of i in the execution point of call/cc.
How about going with Racket and its [`for/sum`](http://docs.racket-lang.org/reference/for.html?q=for%2Fsum#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for%2Fsum%29%29) comprehension? Or use a Scheme (ummm... Racket?! ;)) that implements SRFI-42 and go for `sum-ec`. Other than that I think that folding is a valid approach to summing numbers.
Spoiler alert, if you didn't want code ... I just unrolled the DOTIMES macro in the first CL example. You could write a DOTIMES macro if want one, or use DO. This wasn't hard; you may be fighting the mind-twist involved with Scheme if you're used to the normal iterative coding style. (define (max-consecutive-sum v) (let loop ((i 0) (max-ending-here 0) (max-so-far 0)) (if (= i (vector-length v)) max-so-far (let* ((max-ending-here (max 0 (+ (vector-ref v i) max-ending-here))) (max-so-far (max max-so-far max-ending-here))) (loop (+ i 1) max-ending-here max-so-far))))) (max-consecutive-sum '#(-1 5 6 -2 20 -50 4)) ; 29 (max-consecutive-sum '#(-2 1 -3 4 -1 2 1 -5 4)) ;6 If the input were a list it would be about the same. Usually when I'm building a single object from a list I use FOLD. But here we're passing along two values, so we would need a multi-value FOLD. I happen to have one. (Needs SRFI-16, CASE-LAMBDA) (define foldv (case-lambda ((f inits xs) (foldv/main f inits xs values)) ((f inits xs k) (foldv/main f inits xs k)) (args (raise `("Bad arguments" (foldv ,@args)))))) (define (foldv/main f inits xs k) (let loop ((xs xs) (inits inits)) (if (null? xs) (apply k inits) (let ((inits+ (apply (compose list f) (car xs) inits))) (loop (cdr xs) inits+))))) (define (compose f . fs) (if (null? fs) f (let ((g (apply compose fs))) (lambda args (call-with-values (lambda () (apply g args)) f))))) Then the code is: (define (max-consecutive-sum/foldv xs) (foldv (lambda (x max-ending-here max-so-far) (let* ((max-ending-here (max 0 (+ x max-ending-here))) (max-so-far (max max-so-far max-ending-here))) (values max-ending-here max-so-far))) '(0 0) xs (lambda (x y) y))) (max-consecutive-sum/foldv '(-1 5 6 -2 20 -50 4)) ; 29 (max-consecutive-sum/foldv '(-2 1 -3 4 -1 2 1 -5 4)) ;6 Mike
Interestingly this problem can be parallelized. See http://blog.sigfpe.com/2008/11/approach-to-algorithm-parallelisation.html
Anything important happening around Kawa?
I like these short presentations sharing the same shape. I find it very useful. What would you think of this one: * [learn lambdatalk in 10 minutes](http://epsilonwiki.free.fr/alphawiki_2/?view=learn_in_10_minutes) ? Thanks
About 2: I just don't see the point in steering Scheme that way, because Common LISP is way ahead in that niche. If you want a language with a massive "core" and "standard libs" then why not Common LISP? there are great implementations. Obviously for any group or "brand" there is a pull towards making themselves distinguishable and add features, because otherwise their work will be completely anonymous and therefore they stop having a "brand". Racket is fine. They provide an environment that works with "batteries included". I'd appreciate if most of that stuff is NOT in the "reference standard" though. It's fine that Racket (the language) is not R7RS, like other LISPish languages aren't (v.g. Clojure).
Looks great. I've read the 1st edition (which is available for free) and this looks like a big step forward in features from that. Just bought the PDF myself.
My main problem with R5RS is characters/strings being strictly ASCII. This has aged pretty badly due to common computing needs of today and cannot be easily fixed on the userspace side of things without huge performance hits.
Good to see Scheme 9 progressing. Instant buy ;)
I don't know if something happened lately, but Hal Abelson led the development of the App Inventor for Android in Kawa ( http://en.wikipedia.org/wiki/App_Inventor_for_Android ). I think most of the JVM-LISPy thunder has been stolen by Clojure, though.
The reason to care about languages in the Scheme tradition, rather than CL exclusively, is that there are a bunch of technical differences: hygenic macros, truly first-class functions, no silly namespace tricks, no package system, etc. Existence of libraries is not the sole critera for language choice, otherwise there would never be new languages.
Yeah but Scheme tradition contradicts some of these points. Therefore you have Racket and Clojure, which really are not Schemes. Racket's IDE does support Scheme, but Racket the language is not a Scheme. As for the package system, that has always been a point of debate ever since R5RS.
&gt; But isn't it kinda bloated? What would you remove from it to make it less bloated?
Racket is clearly a descendant of Scheme -- most R5RS-style programs simply work when run as Racket. And the point I'm making is there's a reason to want a practical Lisp that isn't CL -- in particular, the technical issues I listed.
W00t! MacPorts had it too, and I now have it installed. Now I have to relearn it. Thanks!
You're welcome! Enjoy. :-) 
You can build it for 64bit, and I've done so years ago. It took them a little while to get there, but check the github repository for it. I like scsh, and there are occasions where it definitely is better than using some other shell. It makes for a decent enhancement to both scheme and posix scripting where both gain from the advantages of the others.
https://github.com/scheme/scsh
as i said in the /r/programming thread, this is interesting mostly for the look at the cultural forces at work within the guardian, rather than because it's anything particularly new or brilliant about how to parse json with scheme
Yes
nope. If I do that it gets rid of all the parenthesis. 
(define cdr (λ (ls) (if (null? ls) ls (cdr ls))))
I had the same.thing except I passed '() instead of ls if it's null. Did.U have a chance to look at my code? I know it's messy. I'm wondering if there's an.easier way
Maybe use the reverse.function after ur at the last 2 elements
Why the downvotes tho
Because Reddit. Don't like something? Weird username? Didn't like formatting of post? Generally different opinion of your own, regardless of reasoning? Downvote! Because engaging in constructive discussion is so annoying. 
Because it reads like a homework question, and folks are hesitant to give out the answers to homework.
This is one of the differences between lisp and scheme. In sbcl: * (cdr nil) NIL [Arc](http://arclanguage.github.io) is basically an attempt to transplant many lisp idioms (nil, the above more lenient behavior, quasiquote-based unhygienic macros) to the more modern racket runtime.
I like that it's intended to be a drop-in for an existing project, and is ANSI C with no external dependencies.
And maybe crosspost and link it here? many of us would miss it if in just stackoverflow. There's also IRC: http://community.schemewiki.org/?%23scheme-on-freenode
Chibi is the R7RS reference implementation and can be found on google code: https://code.google.com/p/chibi-scheme/
Well, here's the thing. I've wrapped my 3D engine (written in C) with gambit before and it was a less than elegant process. When I looked at what it would take to integrate Guile, I immediately balked. Integrating with Lua on the other hand was straightforward and has never let me down. The downside, of course, is that you have Lua and not Scheme. Also, the readme directly calls out integration into a game engine as a use case. It looks like a new project, so the docs aren't where they should be yet, but what I want to see is what this integration process looks like. For example, the basics of Lua integration goes like this: 1) create a Lua state, 2) initialize that state's libraries, 3) to extend your app, bind functions to global space or a table to modularize it, 4) enjoy. Binding functions to table items is pretty easy. Writing Lua-&gt;C functions is also pretty easy. Getting C compatible parameters is also pretty easy. Those are all key features for integration in my book. When I've tried with other languages to do similar things, it was always a gigantic hassle. Either things took 20x the code or the right process was undocumented or it blew up the build process or it was an non-debugable mess, etc. Chibi was something I've thought about integrating for a while now. It declares broad OS/CPU support and seems to be progressing nicely. For various reasons I ended up going with Lua (fast enough, stable, super well documented, very well tested, etc.), but I always wanted a scheme. So I think Chibi would be the direct competitor in this space and that's why I mentioned them.
I just added to README a new section describing an example utilizing function binding protocol of benz -&gt; https://github.com/picrin-scheme/benz#more-example (it's very very rough explanation. I agree that necessary docs are not provided at all.)
Thanks for the reply. And I know all about the pain of trying to document a project. =)
Haha, definitely yes. Not mentioning in the reply, I recognize chibi. Actually chibi is something I don't want benz to be. She has too complex interface to use as a glue even in an easy application. If I remember correctly, it requires to use some strange macros wherever I declare C variables of scheme value type (because of GC), right? At least I don't feel like using that... But I know yeah that's a strategy. Besides her APIs, she probably contains only 3 or 4 c files in herself, which is perfectly opposite to benz's two or more dozens files. I don't know for sure which is more important code size of interpreter or API simplicity. I took the latter. That's why I started to develop Benz.
I have for my own worked with guile since long, even before it was guile, (guile is based upon Aubrey Jaffer's SCM), although I have not used it so much as an embedded language for extensions, merely as a way to easily interface a lot of low level C code with scheme. During all these years I have been quite annoyed by all the work needed at C-level to adapt to a new version, and was therefore pondering over whether I should use another scheme for the current project in development. However, I realized that would be much much more work, due to all guile-adapted C-code so I continue along that track, but I have downloaded Chibi and will test it. It looks nice.
I'm still new to Emacs but I agree. I'm having a lot of fun with Guile for my own projects; it's become my go-to scripting language. Shame that it's getting resistance from Emacs devs.
I can't help you directly, because I just started getting back into continuations after a very long break from Lisp &amp; Scheme... However, I've found a [search] (https://www.google.com/search?q=tagged+delimited+continuations&amp;btnG=Search+Books&amp;tbm=bks&amp;tbo=1&amp;gws_rd=ssl#tbm=bks&amp;q=tagged+delimited+continuations+reset+shift) on Google books to be a good resource. 
I really like the style from the book. I take my hardcopy off the shelve and page through it every now and then if I need a reminder of simplicity...
[inexact-&gt;exact](http://en.wikipedia.org/wiki/Scheme_\(programming_language\)#Numerical_tower). You might need a round or floor in there, too.
Why is 'index' an inexact in the first place? That's somewhat unusual: can you say more why it has that value?
It comes from a random number function that produces random inexact integers. I'm not sure why it does that.
(inexact-&gt;exact (round 1.0)) or in R6RS/R7RS just (exact (round 1.0))
This and some more is done in the readable project: http://readable.sourceforge.net And the indentation SRFI which is not the same but also aids the parens impaired: http://srfi.schemers.org/srfi-49/srfi-49.html However, when you try to write some macros you'll miss the traditional s-exp syntax and you'll understand why m-exps where considered early on and de-facto abandoned. Back in 1960: http://www-formal.stanford.edu/jmc/recursive.html http://en.wikipedia.org/wiki/M-expression http://en.wikipedia.org/wiki/MLisp 
I know some expressions like T. I designed Sapphire specially for C or Java programmer. Sapphire has friendly face, but it is weak for macro. S-expression is powerfull for macro, but it is awkward for ordinary programmer. Purpose of Sapphire is to add another friendly face to Scheme. Sapphire is not substitution of S-expression, it's only another easy expression. 
It's neat, but I think that for it to be useful it should be portable and translatable to and from regular s-exps, rather than just interpreted. The way readable does it, through macros, I understand that it's more complex but it translates to s-exps which allows the code to be used "in the real world". I also think it's not necessary to focus so much on C syntax as it's not appropriate for scheme. My main criticism for "readable" is that tabulation-sensitive parsing is problematic in many environments and I generally oppose it (I think it's brain-dead but hey, Python is so popular). It's still a nice exercise, mind. Regards.
&gt; but went through his "rite of passage" Yup. However, this is one reason I prefer pattern rewrites (ie Scheme) to macros (ie Common Lisp) is that rewrites *are* compatible with Algol-syntax -- or nearly any syntax really. It avoids the whole "rite of passage" because the syntax may begin as elegant (or inelegant; e.g. C) as the author prefers. Wadler explains this in detail in ["Why calculating is better than scheming"](http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf), though please pardon and try to look past the the anti-Lisp sentiment expressed within. I point only to the challenges he identifies in the concept of a homoiconic language. Racket's [`match`](http://docs.racket-lang.org/guide/match.html) operator is an excellent example of what I mean, and makes me wonder how Scheme might have looked had match been the first principle rather than the end product. &gt; Created Scheme and also was spot on in this one. I think this is really an excellent counter-example. Steele's redesign of Lisp's syntax wasn't superficial (replacing `(X Y)` with `X(Y)`) but very deep, creating a Lisp-1 that could be described in very few forms. If Lisp's syntax was more accessible, I wonder if we'd see more deep and meaningful "rites of passage" instead of just superficial ones.
?? Scheme is applicative-order. You say as much at the end of your "Applicative Order" section. But at the end you conclude: &gt;"I've tested that the (test 0 (p)) in the gambitc interpreter never returns. So it is using the normal substitution method." Isn't that the exact opposite of what you just said? The call would return in normal order. It doesn't in applicative order because it evaluates the arguments first and the second argument goes in an infinite loop.
The problem is in your definition of b. (define b (cons 3 4)) =&gt; (lambda (pick) (cond ((= pick 1) 3) ((= pick 2) 4))) When you call (car b) you are calling the lambda with the value 1 for pick. b actually contains THE LAMBDA expression. b is is defining a fixed name for an anonymous function by creating a symbol that references it. (cdr b) =&gt; (b 2) =&gt; ((lambda (pick) (cond ((= pick 1) 3) ((= pick 2) 4))) 2) =&gt; (lambda (2) (cond ((= 2 1) 3) ((= 2 2) 4))) =&gt; 4
Thanks for the reply, that got me from a dense fog, to a light fog, just a bit more clarity to go :) So I am mistaken in thinking that "b" is a nice representation of a pair (x and y)? b is actually the anonymous function (with 3 and 4, in this example, "embedded" to it's calling) Correct? ( Again, clearly writing what I am asking for is a skill I will hopefully improve, thanks.)
Yeah, b is a function! But who cares? You don't really want people to be looking at b and its internals; instead you're providing an interface through car and cdr that removes the user from having to be aware of how cons is implemented. The usefulness of this is that should you ever change the implementation of cons, any user of cons doesn't need to make corresponding changes to their calls to car and cdr -- you change how car and cdr work, and the user is none-the-wiser.
Yes you are correct. B is a function. And the magic is the embedding. This implementation shows the data structure and method of retrieval built into the symbol (B is a function that pulls the car or cdr and contains both values). The definitions of of the functions car and cdr are just calling the base function with predefined values. The other way to implement a data structure like this is to create a cons function that only generates the structure. You would then need to manipulate the data structure with the car and cdr functions.
Thanks!
Yeah one of the exercises was asking for the reimplementation using: (define (cons a b)) as the extent of the cons definition. That's where I stopped, I have no expectation of struggling through most of the SICP exercises, all I try and do is fully understand the solutions before proceeding.
I really enjoyed this video. The speaker brought up a lot of problems that I have noticed with using RPCs in other languages. I'm also really glad to see Scheme being used for "real world" applications. Now I want to port the 'rest-bind' API to Guile.
... and he wasn't kidding about how small the implementation is! https://bitbucket.org/knodium/rest-bind/src/78dc51d3a8161283199af1a0ba47bf67f900ab54/rest-bind.scm?at=master
I always had a hard time not daydreaming of a system where HTTP and RPC would disappear and it would all be normal functions.
Well most schemers are used to writing things from scratch! Thanks for the input!
look [here](https://github.com/part-cw/lambdanative/wiki)
then surely you know you don't have to write "things from scratch" ? Anyway, that is what made me write my answer :)
Cool. It may well be very underappreciated.
Discussion on HN: https://news.ycombinator.com/item?id=8449488
Waitaminute, Chicken has support for non-ASCII characters in its symbols? That's news to me.
A similar message from 2 years ago: http://www.reddit.com/r/programming/comments/10ld5i/cisco_systems_acquires_chez_scheme/ 
Sample implementation of Sapphire is here. http://homepage1.nifty.com/~skz/Scheme/normal.html Normal is my own making Scheme compiler and Babbage is simple IDE for education. Normal is included in Babbage. Sapphire code is included in "compiler.scm" 
Not that I care in the slightest what you think, but all I said is rigorously true. BTW the spirit of Scheme as opposed to LISP in general is best conveyed in the first few RRS (not in the lambda papers), and minimalism is THE *raison d'être* of Scheme because larger implementations with heaps of features already existed in the 80s.
If you don't feel like joining one of the big editor churches (The Church of Vim or The Church of Emacs) then I don't know of anything better than DrRacket... Grab a copy of HtDP and you have all you've asked for in the title of your post ;) I'm not the book type of guy though... so my recommendation would be to grab a project idea and start working on it. Sure, it's good to go through some basics before but I personally need the driving force of an actual project idea to learn new techs. YMMV.
&gt; Using Python (v2), I usually load up Sublime Text and a terminal window to start coding. Have a look at SublimeREPL, it does support all kind of REPL, Scheme included. https://github.com/wuub/SublimeREPL
Not that I want to start a flamewar here... But how exactly does one 'outgrow' Racket? :)
We are not a church either, more like a cult, having devoted our puny souls to The Beast itself.:wq&lt;CR&gt;
the differences are in the supported standard and (how to make) use of srfi's (like 'standard' libraries). Also interfacing with foreign libraries (ffi) will differ between implementations.
A basic outline of key terms: RnRS: Revised nth Report on the (Algorithmic Language) Scheme A "standards" document that defines the core language. This is usually a minimal set of specifications or ideas. You probably don't need to worry too much about which set of standards your scheme compiles to. SRFI: Scheme Request for Implementation These are equivalent to "standard library" or "modules" in other languages. Some scheme versions distribute these with the core, others distribute them as separate libraries. From there, you can look at various implementations: * Racket: A system that includes a cross-platform editor, debugger, tools, libraries, and multiple teaching and learning modes. However Racket has a large number of non-standard additions to their base language, some of which are parallel to SFRIs. A fair bit of Racket development is centered on teaching and learning scheme. Racket is a good place to start since it provides everything and the kitchen sink in a single package. * C-schemes: Chicken, Chicken, and Bigloo offer the capability to translate to C and compile. They might be good choices if you want better performance or want to interact with C libraries. Chicken has a package manager for getting additional features. I don't know about the other two. * J-schemes: Kawa and Bigloo can run on the JVM (similar to Jython). Might be worthwhile if you need access to Java standard libraries. * Guile: Probably can be classed a c-scheme but it's developing into a multi-language virtual machine. Guile is in active development as an extension language for gnu software. I'd say start with Racket because it has many of the features and data structures of python included with a functional-first syntax and structure. Then if you need to, you can go into Chicken or Guile and figure out the differences. If you don't like the DrRacket IDE, you can use any text editor and command-line Racket. 
Like everyone else says, Dr Racket. Although you should embrace what ever command line is on your os. The ability to start up Vim and and 3 separate shells for unique languages all in one window is aweeeeeeesome
Andy Wingo wrote an interesting post about that topic: [an opinionated guide to scheme implementations](http://wingolog.org/archives/2013/01/07/an-opinionated-guide-to-scheme-implementations). See also the comments on that post.
Picrin (Benz), Chibi and TinyScheme are all worth considering as embedded schemes within existing code.
A bit more info I didn't see here: Racket has [a specific SICP language/module](http://stackoverflow.com/a/19561746), to give you just the scheme the authors had in mind. Dr. Racket is great, but if you're attached to your editor interface (as I am to my emacs set up), there's a racket package for sublime: https://sublime.wbond.net/packages/Racket I can't vouch for it, and another scheme package might have more features, but there you go, fwiw.
Yes, Gambit, bad edit on my part. 
Thank you, I'm not familiar with the embedded schemes. 
&gt; Once you outgrow Racket, and you will, I strongly suggest Chicken Scheme Whoa whoa... some people are going to resent that line ;) But you do know that Racket compiles too, right?
Yes, I know it does. But it has a licence that is hostile to commercial use where source redistribution or binary modification is impossible.
And doesn't care about performance.
When even the APIs of the vendors you're working with are protected under NDAs, or the algorithms you're deploying to the closed platform are considered a trade secret. These things happen a lot in game development, for instance. Then there's simple bias: there's absolutely no way I would ever be able to pollute our products with copyleft code without being fired. MIT, BSD and zlib licensed code is everywhere, but copylefted code is never to be seen unless it happens that you have a dishonest employer who's chosen to ignore the terms.
Supplying the bytecode doesn't provide any less obfuscation to simply shipping the exe. Reverse engineering is just as possible. As for the bias, yeah some people are just irrationally biased. LGPL is just fine for this kind of product that you aren't supposed to modify, but just link to, or use its input. LGPL really isn't copyleft by GNU's own definition. It's a "compromise form of copyleft" that basically doesn't affect you unless you modify the library proper. 
Even if you're willing to abide to that absolute bullshit, you can still produce native code via a C compiler. And then, you don't need to ship anything Racket and your output is yours no ifs or buts. No JIT then though, but then neither does Chicken "JIT" unless you use GNU lightning which is also LGPL. Long story short, Racket's licence is not a problem except for people with irrational biases.
Abiding by bullshit pays well. JIT isn't something we would ever consider. At worst, we have dumped the output of jit processing for later use, but such a hit at runtime would be a total failure. What's Racket without the libraries? I may as well use a scheme where most or all of the libraries have a favourable licence, and one which was designed with C interoperability in mind.
Racket compiles to C. Then your code output is yours and you don't need to ship anything LGPLed. As for libraries, that depends on the individual library just like with Chicken. This library is BSD for instance: http://planet.racket-lang.org/package-source/bzlib/jsmgr.plt/1/1/YUI-README
Re-purposing the compiler is hardly an argument (more so if you're learning Scheme). The majority of libraries in Planet are un-licenced, which would make them Public Domain.
Unlicensed would not make them Public Domain, it would require you to adhere to standard copyright restrictions. You've just convinced me that Racket is incredibly dangerous if you care about adhering to copyright law.
It really is simple: you check the licensing of the particular library like you should do regardless of the language you use. If in doubt you can even message the authors in Planet.
Hence why I use Chicken. It has a licence which I find acceptable for the usage restrictions I face, and the clear majority of its modules share a similar licence. Few if none have no licence stipulated. If there is any doubt about licencing, and such doubts are common, it reflects very poorly on the rigour applied by the depot maintainers. How can anything on Planet be trusted?
nah man you are wrong
Racket doesn't actually compile to C -- that part of the system has been removed. You can generate an executable, but that just embeds the bytecode into the executable. If you really need to generate C, then Racket may not be the best solution.
Right, it was removed in Racket 5.2, and I doubt that it worked comprehensively for a while before that.
It's time for a yearly reddit rant. How in the world is this post sitting at -1 votes?
I, Sir, have no clue.
A tl;dr, this is an actual Scheme interpreter written in ARM assembly -- there's no C involved, nothing, you flash it and you get a Scheme REPL on the bare metal. You can (read ..) and (write ..) to arbitrary locations in memory like PEEK and POKE on a C64, but being Scheme you've also got lambda, closures etc. etc. for strucuturing your code. It is an extremely impressive piece of work, seemingly quite well-written and well-documented, and of course well cool if you're into electronics. Interrupt service routines written in Scheme, hell yes. I have played around with this on STM32F4 processors. It's not exactly production ready (at least not on that platform), but it does work, and it does allow you to use Scheme to blink LEDs and toggle GPIO. I successfully talked to a character display over a parallel bus, and a parallel input DAC (not SPI). Be prepared to really learn your SoC, though, a lot of functionality will involve shoving magic numbers into magic locations, which gets tedious (especially with ST's horrible docs), but has its charm if you're the right sort of person. Unfortunately, the port for the STM32F4 Discovery board does not support an SD-card, so the only way to transfer code to it is typing it in over serial console. You can write strings to files in Flash memory, but that's quite difficult to work with. On a different board where you can load code from SD-cards it might be a lot more usable. Nearly two years without updates, though -- and I suspect the subset of Schemers who like working in ARM assembly is vanishingly small :( The distribution also comes with an assembler written in Scheme that runs on the thing itself, but due to the above-mentioned limitations on the board I have, I've not tried it.
Thanks a ton for this detailed description. Scheme in assembly feels so vintage and pure. Feels like toying with McCarthy's computer.
&gt; and I suspect the subset of Schemers who like working in ARM assembly is vanishingly small Precisely this. If you want scheme on ARM (or any uC for that matter), wouldn't you generally prefer one in C? Or in compiled Scheme, for that matter. Seems like it would be much easier to extend that way.
It does have an incredible and impractical coolness about it. I've no idea how it ever come to be, the guy who wrote is a university researcher and it's certainly not a weekend project. Some of the supported boards are very cheap, but I can't really comment on which port is more complete.
Maybe. Probably. I don't know if such a project really exists, though.
Could the Chicken Scheme Compiler fill this role? Or did I misunderstand what you meant?
...and now you're at 15. This is just very strange behavior...
They compile to portable C that'll run on a UNIX-like OS, with malloc and multitasking and a filesystem and no doubt a bunch of other things. They have runtime in the megabytes if not tens of megabytes. Armpit runs on chips with up to a few hundred K of RAM and no OS at all. At CCC last year, I asked some of the Chicken guys about getting their runtime to fit in that and they just shook their heads. This is a whole different game.
That's awesome. Does [TinyScheme](http://tinyscheme.sourceforge.net/home.html) fit in that sort of budget?
Damn. I just got my metacircular interpreter working for class so I'm kinda feeling like a bad ass. And then I see this and remember I don't know shit. Inspiring and discouraging
:%iaiacthulhufhtagn&lt;CR&gt;
And on and on and on. Protip: unsupported assertions mean nothing. Let me repeat: if what you've said is "rigorously true", then how about you do something, like, oh, I don't know, CITING something besides your own ass, ie your own tastes? Cite the Scheme literature that demands that we purge anything other than the ice statues of lambda, eval, and apply or whatever your pure little perfect snowflake conception of "the spirit" of Scheme demands. Indeed, since you now want to shift discussion to the RRS, why don't you start by telling us all what the RRS were designed to do, and what the rest of the RRS were all about? Here, let me demonstrate how we CITE material: the original 1975 Report states, "Here we present a real live SCHEME interpreter. This particular version was written *primarily for expository purposes*; it works, but not as efficiently as possible." From the Revised Report: "We can define a few essential features which constitute a 'kernel' of the language, *and also enumerate several syntactic and semantic extensions which are convenient and normally included in a given implementation*. The existence of a mechanism for such extensions is a *part of the kernel of SCHEME...*" [emphasis added]. Oh my. Those RRS authors just started screwing up the purity of "the spirit" of Scheme right from the beginning, didn't they. They just ruined it. Nobody cares from a technical perspective what you happen to think is "the spirit" of Scheme (whatever bullshit that is) and your disregard of the lambda papers in influencing the design and goals of Scheme is stupid. And now, to continue your really vapid argument that Racket isn't a Scheme, start by posting a link here to some of the massive amounts of the pristine, virginal, "standard", minimalist Scheme code that you've developed... the result of your decades long study of the lambda papers and RRS and all...you know, all that code that Racket won't run because it's not a Scheme. Have a nice day. I don't have any more time to waste on tutoring you on how to make technical assertions. 
It seems to me that you missed when I said "80s", as opposed to 1975 or 1978. You need to learn some English, then you can understand comments in reddit and maybe even the RRS documents. As I said before, Scheme today is mostly defined by RRS documents. The "necessary" Scheme was that of circa R2RS-R3RS on. It has a historical context, it wasn't a lab language anymore and its motivation was to fill the need for a small language as Common LISP grew into a big one and was already well established. By the time of "R1RS" (1978) the defining characteristic of Scheme was lexical scoping. This was not the case any more in the early 80s as other LISPs and very especially Common LISP were also lexically scoped. So that battle was basically won across the board. The Scheme from the 70s is barely the embryo of what later established a Scheme language style and practice. The landscape was shaped vs Common LISP since 1984 or so, as it evolved differently. Thus R2RS was named "the UnCommon LISP" ( http://dspace.mit.edu/bitstream/handle/1721.1/5600/AIM-848.pdf?sequence=2 ). This is basically the basis of current Scheme (with letrec and all, as opposed to before). Its focus was remaining small. Since you like quotations, straight from R2RS, &gt; "The Revised Report on Scheme &gt; or &gt; An Uncommon Lisp" : &gt; "Scheme shares with Common Lisp the goal of a core language common to several implementations. &gt; Scheme differs from Common Lisp in its emphasis upon simplicity and function over compatibility &gt; with older dialects of Lisp." ----- The reality of the world ever since the mid 80s is that Scheme growing into something as big or bigger than Common LISP is rather pointless as they are essentially founded on the same principles otherwise and the menial differences that can be solved by libraries or minimal refactoring, don't merit a new standard and division of the community. A big Scheme is a bit of a pointless redundancy. This is obviously not the opinion of everybody and this schism was what lead to the refusal of many people to adopt/acknowledge R6RS. Have a nice day, I don't have more time to waste teaching you basic English or reasoning. 
Cool. Keep up the good work.
[This](http://gambitscheme.org/wiki/index.php/Gambit_benchmarks) is the only one that comes to mind. I suppose other implementations might have similar pages. No R7RS there, though. 
I will upvote anything from Andy Wingo. :)
from 2010: http://www.cs.utah.edu/~mflatt/benchmarks-20100126/log3/index.html
In your library you need to import chezscheme I think.
Don't know what the problem is, but as /u/ascw said you don't need eval, as a statement expanded from a macro will get evaluated multiple times as if you just wrote the code in there directly. In general, if you ever find yourself using eval in a program (the exception being of you just read it from a file or the keyboard) you should consider using a macro instead, and if you use it in the definition of a macro you are doing it wrong.
That works great, thanks! I guess I was still thinking of a macro as a fancier lambda expression, which is why I used `eval`. When I tried this in Racket (not R5RS mode), it tells me that I need an `else` expression in the if. Does R6RS require an else, and R5RS doesn't? Trying out the macro stepper, it seems like an incredibly useful tool.
Yeah, you just have to remember that macros in scheme are rewriting your code for you. As far as I know Racket has really deviated from the scheme languages, I don't think R6 requires an else for an if, but obviously the Racket language does.
Do you think Racket is still a good way to learn scheme, or is it different enough that it's not applicable to other schemes?
Check out PICOBIT. Scheme on PIC microcontrollers. Craziness I tell you!
I'm not sure I can handle that.
from http://www.reddit.com/r/scheme/comments/2kl5ru/a_scheme_interpreter_for_arm_microcontrollers/cmbbaqm
Can't help upvoting this too :)
I think that by "argument's structure" they are referring to the fact that a list is either empty or non-empty. The first cond in the first example covers only those two cases directly (so it coincides with the structure of a list), whereas the simplified version has conditions which don't directly correspond to the basic structure of a list.
Ah, that make sense! So would the first example be the preferred method, or was that just for the purpose of example?
I think it's mostly just an example. I personally find the simplified version which uses only one "cond" easier to read.
Yep, http://wingolog.org/archives/2014/11/27/scheme-workshop-2014
Here is a link to the entire dissertation: http://gradworks.umi.com/35/60/3560746.html
It is for a whole course (I believe a semester). So that's four months right there. Also there is a tradition of putting into such a book about 50% extra, to give instructors some leeway. In addition, it is an MIT course, so you are drinking from a fire hose. I know others will disagree, but I don't think a very careful year is out, at all.
I like watching one of the lectures, and then reading the corresponding part of the book: [http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/) Disclaimer: I've barely gotten past the first lecture.
Oops, I forgot .. &gt; Did you finish SICP? Yes, and it was a formative experience, for me
I've watched the first several lectures. They definitely help. And the teacher is very very good. 
FYI, it looks like the [BeagleBone Black](http://www.digikey.com/product-search/en?lang=en&amp;site=us&amp;keywords=BB-BBLK-000-REVC-ND&amp;WT.z_slp_buy=TI_BeagleBoard) will host this.
I'm sure it's a wonderful project and all, but armpit scheme is an awful name.
read the explanation of the name
I'm curious, are there any online materials from K. Dybvig's lecture classes? I found couple of really nice scheme compilers on github from his students, but accompanying material would be very helpful to get the reasoning behind design. Hell, if one day he decide to teach on Cursera, I will be the first one on line to roll in :D
yep, i think it's funny.
If you are not at college: 1 One month-impossible. 2-Three months-if you are a genius. 3 Six months-you are clever and work hard 4 A year if you work steadily but have a life You might want to look at the online resources at: http://icampustutor.csail.mit.edu/6.001-public/ There are lots of problems which are more accessible than those in the book and some short '.lectures'.
I actually went to Indiana University during the time he was teaching, though I never had him. =[ I would give links to his course material, but the website (and the whole CS dept) went through some restructuring and he's no longer listed in any of the courses I know he taught. The notes for his compilers class survived him, but that material is behind an authentication barrier. http://www.cs.indiana.edu/~dyb/ is/was his homepage. His papers are still an intersting read.
:S He is no longer teaching on Indiana University?
Thanks. The problems in the book get difficult very quickly. 
I have been working through the book on an off for a couple of years.Am on chapter 3 at the moment, but it is only one of several learning projects that I have on the go. I am a learner programmer, so as you can imagine there is a lot of stuff to deal with. I first had a look and found it really hard going, then by chance spotted there was a study group. This met in the spring and then restarted the following year.During this time we covered some stuff in chapter 1 &amp; 2 (the guy in charge's aim was to introduce people to functional programming). Since then I have dipped into the book from time to time and am steadily learning new stuff. What has helped apart from the group was: The Little Schemer (weird book, which some people like and others don't but is a very good way to learn about recursion in scheme) The online stuff that I mentioned. By the way, the stuff that you are finding hard will probably become easy after a while. 
No. The compilers class is now being taught by Ryan Newton, but it still uses the nanopass framework.
I started it on a plane ride to London. Devoured the first two chapters in a couple of hours. Started the third before I realized I was getting diminishing returns and moving much slower through the material. Went back to the beginning and did every exercise and practice question, basically treated it like a course for university. Got way more out of it then but I stalled out after the 4th chapter because life got busy. Probably put in a solid 20 to 25 hours while I was traveling a lot. Need to get back to it.
There is nothing in the Scheme standard which dictates the order in which subexpressions are evaluated; a perfectly compliant Scheme implementation could very well have printed the newline before the message in your first example. It's true enough that any decent interpreter will "do the right thing" in most cases, but using `begin` to strictly sequence an evaluation ensures it.
This is very wrong. For example, look for "evaluated sequentially" in [r6rs](http://docs.racket-lang.org/r6rs/r6rs-std/r6rs-Z-H-14.html#node_idx_364).
It's not necessary in your examples because lambda includes that behavior automatically. It's more useful when you want to stick multiple things to do in places where a single form is expected, like if.
I was wondering about this. r7rs specifies that a lambda is evaled sequentially and it mentions internal defines being similar to a letrec* (4.1.4) Later on when explaining begins (4.2.3) it mentions that the body is evaluated sequentially left to right. This made me wonder as I couldn't find the wording 'left to right' in the lambda spec, but my assumption was that it should behave the same as a begin.
Toy example (If (begin (define a 11) (+ a 13)) (display "yes") (display "nope"))
If you know C or another language in that vein, you can understand this by analogy. `begin` in Scheme is equivalent to a block statement (`{ ... }`) in C. You don't need one in a function definition because functions always have curly bodies. But you do in other statements: if (foo) bar(); baz(); // Oops! Not part of the if! if (foo) { bar(); baz(); } So, a `{ ... }` lets you insert a series of statements where only a single one is expected. `begin` is the same in Scheme. (Except Scheme is all expressions, so I suppose `begin` is more like the comma operator in C, but no one knows about the comma operator. :) )
Side-effects which require sequencing. Purely functional programs do not need sequencing. IO, (display ...) (newline), require sequencing. Edit: clarity.
Yes, `(lambda (...) a b)` is by-definition equivalent to `(lambda (...) (begin a b))`. The few Scheme compilers I've studied just desugar the first into the second as part of macro expansion.
You might be confusing "the order of evaluation of arguments" to "the order of evaluation of a begin form". I'm pretty sure r7rs states that implementations can evaluate arguments in any order. The begin form is not a procedure application, it's syntax.
In most cases you wouldn't need `begin` as a primitive because you could replace `(begin foo bar)` with `((lambda () foo bar))`. The gotcha is with `define`; the defines here become local variables: ((lambda () (define x 1) (define y 2))) The defines here become global variables: (begin (define x 1) (define y 2))
lambda is implemented to have an implicit begin. cond also works like that. Is a language desing choice, a reasonble default since is what you normally would want. There are others uses for begin, like in macros. 
6 months for 2 chapters. I have done most of the exercises in these chapters.
Latest version is [here](http://people.delphiforums.com/gjc/siod.html).
I spent 3 months for the first chapter. The whole mind of the book is totally refreshed all my knowledge when I first time met this book. I think that's the reason why I took so long time. PS: I'll tell every new comers of SICP to be patient since it is not easy when you've already taught a lot of rubbish in programming before. 
That seems to be my pace right now. I'm almost done with the first chapter and it's already changed how I program. I'm pretty good about being patient with myself. I'm self-taught when it comes to programming. There's no telling how much rubbish I've taught myself. 
It not runs on Hyde, I just use it to generate static pages. It runs on github currently. I'm trying to do all this project (include sites and manuals) with Lisp/Scheme things. So the site is generated with Hyde, the manual is generated with org-mode. Maybe I should use biwaScheme to replace JS... The code of the project itself is written with Guile Scheme. I don't see any problems to mix them all, since my purpose is to build web site with pure Scheme. And I've done it. 
Sure, I'm just curious if there's another reason other than "why not".
http://www.nongnu.org/skribilo/
Thanks for the link! I have to say, at the time I need it, I didn't find it. But I got the help from author of Hyde of Chicken for the work. That's why I honored this cool project on the page. As I said, I don't see any problem to mix them all. They're all Scheme.
Thanks for your feedback! ;-)
Yes, but I'm interested in the games that other people write, because they frequently come up with clever things that I never thought of.
&gt; chicken-install hypergiant, It should work now, the author has pushed the missing tag, so the package will be available on mirrors soon. Thanks for trying it out!
In your initial example, the `&gt;&gt;a` macro accepts a single list argument, e.g. (&gt;&gt;a (...things...)) ; where ...things... = (display) (add6) ... But then later on, you try to use it with an invocation of `&gt;&gt;b`instead of a list of things (&gt;&gt;a (...things...)) ; where ...things... = &gt;&gt;b (() (return5) ... In that second example, &gt;&gt;a would see two things in its list of things to pipeline: the expression `&gt;&gt;b` being piped into that big list `(() (return5) ...)`, like so: ; expansion of &gt;&gt;a (() (return5) (add6) (add6) (display) &gt;&gt;b) I'm guessing that's not what you intended. What do you want the result to look like?
Ultimately, I just want a macro "&gt;&gt;" that will transform (&gt;&gt; (return5) (add6) (display)) into this: (display (add6 (return5))) To get that, I ultimately hoped that this: (&gt;&gt;a (&gt;&gt;b (() (return5) (add6) (add6) (display)))) into this: (&gt;&gt;a ((display) (add6) (add6) (return5))) 
With a little googling, I found [a (usenet?) discussion](https://groups.google.com/forum/#!topic/comp.lang.scheme/7HjBuRWzIDs) on precisely this topic that might help. 
Using [LambdaNative](http://www.lambdanative.org/) may be a solution. https://github.com/part-cw/lambdanative/wiki
Wow! That's works perfectly! It does't work in gnu scheme but it works in racket's r5rs interpreter. Thank you so much for your help!
First of all, thanks for this cool project. It is highly appreciated. I have a question regarding interactive development: What can, and what cannot be changed on the fly? E.g.: once the Go example is running, I see the board and can click the grid, etc. Changing gl:clear-color results in the expected change, or changing other simple things like the string-meshes of the score function. Then I thought lets rotate the camera, which gives an error. Also calling set-ambient-light! isn't allowed/or not possible. Is there a way to achieve these things on the fly? Could you please elaborate why it isn't possible to make these manipulations? BTW: Maybe you should change the font in the examples for macosx to: "/Library/Fonts/Microsoft Sans Serif.ttf". At least this works for me under Yosemite.
Is it important that it is MIT Scheme - or do just need some Scheme? 
Use whatever editor suits you. You can install MIT Scheme through MacPorts. So first [install MacPorts](https://www.macports.org/install.php) then run: sudo port install mit-scheme. Use .scm as file extension. 
Not that there's anything wrong with MIT Scheme but unless you have a particularly good reason for wanting to use it in particular (and simply working your way through SICP is *not* one of those reasons), Chicken Scheme is a lot easier to install and use and has a much richer library of extensions ("[eggs](http://wiki.call-cc.org/chicken-projects/egg-index-4.html)") than MIT does.
 brew install guile ;)
It works now (more or less). I wrote a Hello World procedure used .scm as file extension and then compiled it with (cf "HelloWorld") and loaded it with (load "HelloWorld") and it worked. So I guess I correctly installed it. https://groups.csail.mit.edu/mac/ftpdir/scheme-7.5/7.5.17/doc-html/user_5.html#SEC33 Thanks btw :)
Alright. Yeah my only reason would be working through SICP. I will give Chicken Scheme a go. Are all Scheme implementations inherently the same?
&gt; Did I understand correctly, that Chicken compiles Scheme to executable C programs? What Chicken Scheme does is compile Scheme to C source and than compiles that code to an executable. This is done in one step with the csc compiler. Check out Section 1.3 - Examples at http://wiki.call-cc.org/man/4/Using%20the%20compiler Basically, compiling code looks like this $ csc foo.scm and running code looks like this $ ./foo
BTW, Chicken Scheme is a R5RS scheme with its own extensions. It is always handy to have a copy of the standard when you are working with scheme. I suggest grabbing a R5RS pdf from here: http://www.schemers.org/Documents/Standards/R5RS/ 
Pretty much all Scheme implementations implement Scheme as described in [R5RS](http://www.schemers.org/Documents/Standards/R5RS/) and most are committed to moving to [R7RS-small](http://www.scheme-reports.org/2014/working-group-1.html). R6RS was not well received, hence the R7RS revision. That said, extensions, whether they're [SRFI's](http://srfi.schemers.org/) or general purpose libraries, vary greatly between implementations. [Racket](http://racket-lang.org/) and Chicken are both notable because there's generally a library for whatever you need.
PS, one of the things I like about Chicken Scheme is that it is compiled to C and embeddable in C (and Objective-C ). When combined with its foreign function magic, it's possible to write a lot of code in Scheme even when you're forced to live within a C framework.
Congrats on the new release, nalaginrut!
How would the GPLv3 license of this framework affect my hypothetical web app? Let's say I make a closed-source web app and actually makes a living of it.
Artanis is GPLv3+ &amp; LGPLv3+ (dual liceses), so it's OK if someone decide to not reveal some code. Of course, in this situation, one may close all the code, but it's his/her problem with God, personally I don't care. And if you are talking about SaaSS[0], which means to provide certain web services to avoid the duty to reveal source code in a tricky way. The answer is "don't use SaaSS", since there's no available way for it. [0]https://www.gnu.org/philosophy/who-does-that-server-really-serve.html
I've started it 3 times. It doesn't seem too hard, but I easily get distracted. I want to point out the book "How to Design Programs" was written to address some concerns with SICP. They use Racket which is awesome, put you can use "teachpacks" to work through it or SICP (a more minimal language). Both the 1st and 2nd edition are online.
If you quote a list you don't need to quote the elements in the list. If you quote both the outer list and the inner elements and you want to evaluate the inner element, you have to call eval more than once. Thus: '(a 'b c) Would need one eval to unquote the list itself, and an extra eval to unquote 'b. Imagine quoting in Scheme to be similar to quoting in natural language. Consider this sentence: &gt; Love is just a word. When reading that sentence, the meaning of it is a claim about the concept of love. That love as a concept is just a word. Compare that to: &gt; "Love" is just a word. By putting the first word in quotes, that changes the meaning of the sentence. It now reads as that the *word* "love" is just a word. Because of the quotes we didn't evaluate the word's meaning. We are talking *about* the word "love". Just as we can nest quotes in natural language, we can also nest quotes in scheme. In linguistics, forgetting to quote or quoting when you didn't mean to quote is called a *use-mention error*. Edit: My sincere apologies for making the mistake jfb1337 pointed out. I got the behavior of Clojure and Scheme mixed up I think.
Whops, thanks for pointing out the error. I got the behavior of another Lisp dialect mixed up with Scheme. Embarrassing :(
Thanks for the release and chicken integration. Also congrats to Don for his little baby child. How is Geiser compared to Chicken Emacs Slime ? 
So I see it is you (the developer and OP) that posted. Out of curiosity, do you have a fleshier example, perhaps one you use in your own life? I recently read that Geiser is starting initial support of Chicken Scheme, which might finally push me into taking another wack at the awful framework, but does not seem to have clear REST-JSONP buzzwordy awesomeness you are rolling out, so I would love to dig into this if I decide to return to yet another Scheme kick.
Thanks for the explenation. I have to try Geiser :)
Yes, I have a case using it, that's one of reasons why I keep updating it. But, although it's GPLv3(I mean the case), I would not reveal it before all things done (at least workable). I think it could be also a best practice for whom following Artanis. If you care about some modern stuffs (REST, JSONP, etc), I would like to put advertisement here: there'll be CLI tools in the next version (say, 0.1.0), which will save your time to avoid typing some code, but generated automatically. Well, it's not a big deal if you've already gotten familiar with Rails or Django...
Of course there're already some useful examples in the tarball.
Yeah. I could lie and say otherwise, but I will be sure to look at the repo. It has been a while. So, you should dismiss any of my comments if they are inaccurate. Also, congrats for the Summer of Lisp. I had no idea about that project, and I started to download all the PDFs of different applicants as all of you are doing wonderful things!
Oh, I see. Thanks for the explanation. As far as I understand, implementing a JSON-based protocol should not be difficult. The documentation for [awful-response-headers](http://wiki.call-cc.org/eggref/4/awful#awful-response-headers) has a very silly example. Lately I've been experimenting an approach similar to the "modern" web development techniques with [awful-picman](https://github.com/mario-goulart/awful-picman) (spock branch -- work in progress). It uses CHICKEN on the client side and [SPOCK](http://wiki.call-cc.org/egg/spock) for the client side. SPOCK is a Scheme-&gt;JavaScript compiler. So, the client side is mostly in Scheme as well. HTML generation on the client side is made via SXML, just like on the server side. Instead of using a JSON-based protocol for communicating the client and server sides, I've been using a sexp-based one , so you can just use Scheme's read/write procedures instead of using a JSON parser. Of course, if you want interoperability with other systems, JSON will probably be a better option. Many thanks for your kind words. :-)
Oh! I love the idea of SPOCK! Maybe I should write one with Guile to generate asm.js. I'm still thinking a better way of providing server-side support to interact with the modern client-side render, like AngularJS, Backbone... Hack long and prosper
nalaginrut: I seem to remember ijp on #guile was planning something like that.
Thanks very much! 
And holy hell is it ever fast: http://www.larcenists.org/benchmarksGenuineR7Linux.html
No R7RS support, maybe?
Thanks. That's interesting! I tested it in Larceny in R7RS mode and got a Syntax violation - does it have the same issue as Gauche and Picrin? Syntax violation: syntax-case Invalid form Form: (syntax-case x (_) ((dummy _ seq alt) #'seq) ((dummy p seq alt) #'alt)) 
No. Different cause. Larceny's syntax-rules is r6rs style. So that, place holder cannot appear in literal clause.
Enbugged on 0.6.2. It's fixed in the HEAD.
If nobody takes over maintainership, there will be no new SRFIs after July 2015 and no mailing list discussion either. While you can argue that the title is a bit sensationalist, it remains a serious problem if nobody were to step up to continue the tradition.
I didn't really understand the proposal. What would be the base set of primitive types in such a language? What do you mean by 'generalized'? I don't see how the identification of strings and characters would work? The tree and matrix concepts sound quite nice, though.
It sounds to me like the author is a little bitter that R6RS fell flat. I feel that, I've had [major projects fail spectacularly](http://en.wikipedia.org/wiki/Duke_Nukem_Forever) and I understand intimately the pain of seeing your efforts fail to succeed. &gt; Larceny &gt; There has not been a release in years. I do not know what this means. There was one last week, with near-complete R7RS support. &gt; The R7RS of my dreams is bigger than R6RS and backwards compatible. &gt; ... &gt; The R7RS “small language” looks useless to me; is it only a convenient base on top of which to implement the future R7RS “big language”? As I understand it, one of the goals of R7RS-small is to formalize those most common extensions to R5RS which are useful in a generalized sense. cond-expand, library forms, et al. R7RS-big is still being developed; perhaps the author of Vicare should involve themselves?
yes, I feel like R6RS has fragmented the community more than using a specific mailing list or anything else. What I think R7RS contributes most is libraries/modules which was missing from R5RS for so long and held scheme back a lot. What is so important about libraries/modules is it lets us retain a small core language while also being able to important as many new language features and extra things as we want, in a portable way.
I like to think of R7RS as R5RS + Libraries + Bug fixes. R5RS is a rather good little language.
BSD? s7.c has some verbiage. 
Using GitHub is a really bad idea. Its proprietary SaaS.
Well, frex, Perl has no character data type - it just has strings. A character is just the degenerate case of a one-valued strings. And it seems to do okay without them. I think APL might treat numbers as mere matrices of size 0, IIRC. Similarly, a lisp pair/cons could be seen as just the specific case of a list with two values; a list itself is merely a tree with no branches. A vector could be viewed as the degenerate case of a matrix with only one dimension. A box is just a vector with only one cell. Just wondering what the ramifications would be for a language designed in such a way. Most modern languages with strings don't make the programmer worry about the null terminator \0 the way C does; most with lists don't make one worry about the underlying structure or null terminator '().
If you give me cons cells, I'll make lists and trees. If you give me trees, I'll make cons cells and lists. They're two sides of the same coin and OP's notion of _minimal vs. general_ is a matter of perspective. Closures and objects are similarly related. If you have one, you can cobble together the other. Whichever seems better at any given moment probably depends on the problem you're trying to solve.
&gt; What I think R7RS contributes most is libraries/modules which was missing from R5RS for so long and held scheme back a lot. This is not exactly true. R7RS **will** have contributed libraries only if, in the future, a significant amount of portable libraries will be actually written (with decent tests, documentation and installation infrastructure). The amount of work required must not be underestimated, because it takes years and devotion. R7RS will have succeeded if its amount and quality of portable libraries can **quickly** catch up with the ones in Vicare. 
i think that asks the wrong question - a better question would be "is the r6rs standard worth branching off into its own language family?" the op clearly feels so, whereas the scheme community as a whole has decided r6rs was a mistake and is starting over with r7rs. the cleanest solution would be to bite the bullet and call the language "scheme++" or something like that - sticking with "r6rs scheme" is limiting insofar as there will not be any more evolution of that standard, and calling it just "scheme" will unnecessarily focus on the r7rs compatibility issue, which does not seem to be any sort of goal for vicare.
I think it's a little easier to start with cons cells than trees. Mostly for simplicity because it doesn't take long to wrap your head around using cons/car/cdr. It's also a little more natural to build larger abstractions atop smaller ones. The difference between vectors and matrices is mostly sugar.
&gt; "Foolish pupil - objects are merely a poor man's closures." &gt; "When will you learn? Closures are a poor man's object." The message? You'll only become rich if you learn COBOL and sacrifice your soul to a bank, maintaining legacy applications. :D
*sigh* I would -love- to see a high-level cross-scheme R7RS library for handling FFI bindings.
For good or bad :?)
First class modules and functors, as they appear in the ML family languages, are something that most languages don't have. More specifically you'd be hard presses to find a dynamically typed language that supports them. Also, you are conflating the implementation details (ML-like modules and functors) with the problem at hand (having a function that works for multiple representations of Peano numbers).
I haven't seen those libraries yet. Would you say that these would bring a lot of improvements to, say, the Gambit-C FFI interface?
Oh yes, absolutely, without a doubt. (bind* #&lt;&lt;EOF double sumarray(double *arr, ___length(arr) int len) { double sum = 0; while(len--) sum += *(arr++); return sum; } EOF ) (print (sumarray (f64vector 33 44 55.66))) http://wiki.call-cc.org/eggref/4/bind Bind is basically a trivial way to embed C and C++ into Chicken Scheme without having to write bindings. In practice, the subset of C it uses is a little too small. But that's where Chicken Scheme's foreign and foreigners eggs come into play; the syntax is clear and clean, and with foreigners specifically, you end up with SRFI-9 records instead of coops objects. IE: #&gt; struct servent { char *s_name; char **s_aliases; int s_port; char *s_proto; }; &lt;# (define-foreign-type port-number int ; used by servent type (foreign-lambda int "htons" int) (foreign-lambda int "ntohs" int)) (define-foreign-record-type (servent "struct servent") (constructor: make-servent) (destructor: free-servent) (c-string s_name servent-name servent-name-set!) (c-pointer s_aliases servent-s_aliases) ; const (port-number s_port servent-port servent-port-set!) (c-string s_proto servent-proto servent-proto-set!)) http://wiki.call-cc.org/eggref/4/foreigners Chicken's FFI is a big part of why Chicken enjoys so many eggs. 
Well, seems it's similar to guile-inline I've written in 2011. git clone git@gitorious.org:guile-inline/guile-inline.git =========================================================== (use-modules (inline inline) (define in (make &lt;inline&gt; #:name "mytest")) (inline:eat-code in "int func(int a ,int b) { return a+b; }") (let ((my-fun (inline:get in))) (my-fun 1 2)) ============================================================ But I didn't polish it. Maybe sometimes it should be activated again. 
Chicken Scheme has an inline egg which is basically bind for the repl; replacing bind* with inline in the previous example would yield something that works in the repl. It makes Chicken into a C repl, of sorts.
Awesome! Will definitely try it out!
I just found this environment http://davidpilo.com/pvts/ It's a standalone Java jar. Has lots of little features that are quite nice, like viewing variables and flow and such. 
[ideone.com](http://ideone.com)
Do I want an EQ? atm and if it is an atom return that atom to the list of odds? 
I'd probably just use `(eq? (length lis) 1)` myself. It won't be an atom, it'll be a list of one element.
Others have pointed out the specific problem in your function. It's a good rule to avoid taking the cdr of something unless you know that the it exists. (Exact same concept as never derefereeing a pointer in C or a reference in java if you don't know it's non-null). For the most part, while fun to use (more fun to try to say), the cd..dr, ca..dr, etc functions should be avoided unless you know a lot about your input (your function is only being called another function of yours that you know is putting things together in a specific way).
You don't need the parens around the '1'. The parens indicate that you want to evaluate the function '1', but '1' isn't a function (or a variable bound to a function), it's a numeric literal. So the interpreter would bomb on that. Otherwise it seems ok. Are you having problems with it (aside from the 1 part)? Note: typically folks don't use capital letters since the language is case insensitive
What is the behavior that isn't working? What do you see, and what do you expect to see?
That's how it was listed on Pierard's publication list.
You can catch extra variables in a list. So say I have a procedure (lambda (x) x), if I wanted to be able to apply it to any number of arguments, then use the . syntax, where all arguments past the first will be captured as a list in the variable args: (lambda (x . args) (if (empty? args) x (error "wrong number of arguments")))
Actually, yes, indeed it does invalidate his opinion. Bite me. was me too. 
I noticed the Chicken support, that's awesome! I also notice I always get a Chicken REPL buffer, even when working in Guile, which occasionally squawks about csi not being installed. Anyone else experienced this?
I have a vague understanding of Unicode and code points and such. It seems like Ruby and Python's string classes have methods by which one can convert to and from bytes, given some encoding. I guess my question is more about which API is more useful/friendly (ie strings and characters vs just strings), if both allow the same power. Or do they? Can Scheme do things with chars and strings that Ruby and Python can't (or can't easily) do?
C char's and short ints are different types, and don't even have to represent the same size. But yes, char is a fixed size numerical type, nothing else. That's distinctly different from "character" in higher-level languages. With a real "character" type you can represent variable length characters, or use different encodings in a transparent way. 
This thread has been linked to from another place on reddit. - [/r/plt] ["In 8 hours, Daniel P. Friedman, famous for his work in Lisp and Scheme, will be fielding questions in a real-life AMA. Post questions \[𝒐𝒏 𝒕𝒉𝒂𝒕 𝒕𝒉𝒓𝒆𝒂𝒅\] and we'll try to ask them." \[xpost/scheme\]](https://np.reddit.com/r/plt/comments/34ii8u/in_8_hours_daniel_p_friedman_famous_for_his_work/) [](#footer)*^(If you follow any of the above links, respect the rules of reddit and don't vote.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
What are the most exciting recent developments in Scheme (say, last five years)?
excellent question with great insight. if answered, great impact would happen.
What is your opinion on Automated Theorem Proving, Formal Verification, Program Synthesis and Gradual Typing?
Yeah, The Little Schemer!
What time machine are you, Oleg Kiselyov, Will Byrd et al using to transport yourselves and your technology back from the future?
Three questions: 1) Do you plan to offer an online-course (at coursera.com, edX.org or similar sites) about programming in scheme? That would be great, one such MOOC is terribly missing! 2) Please, tell us more about your upcoming book "The Little Prover". 3) Have you heard about relatively unknown Mark Tarver's programming language [Shen](http://shenlanguage.org)? What do you think about it?
Continuations. What else?
It's likely to get back on track this summer. [The rest of the answer is redacted.]
&gt;his blog Got a copy?
https://yinwang0.wordpress.com it is closed now :'(
I sort of think that characters are a "semi-relic" from the ASCII era. With variable-length encodings (and their benefits having to be paid for by also accepting some quirks), it makes much less sense to work regularly with characters. You also get some implementations of Scheme (such as Gauche) trying to improve on the old strings-as-mutable-vectors-of-characters model by doing some massive internal rearrangements of how the text data gets physically handled.
Partially accessible though http://web.archive.org/web/20140107054458/http://yinwang0.wordpress.com/
Where is the list of unsolved task. I would think this would be in one place. 
There's a link in the box to the right in [the Racket page][1]: [Tasks not implemented in Racket][2]. [1]: http://rosettacode.org/wiki/Racket [2]: http://rosettacode.org/wiki/Reports:Tasks_not_implemented_in_Racket
Thanks!
I managed to modify the scheme package for SublimeRepl (changed "scheme" to "gsi" "-:d-" (this flag came from the gambit documentation for integrating into emacs) This has given me a functional repl, though the eval in repl/transfer to Repl aren't working. Any hints?
Check my post history and you will see I am a newb, so take the following as such... It seems each particular flavor has it's own package management system, Racket has Planet, Gambit has Blackhole (and another I believe), chicken has eggs. Most support srfi's as well. I keep wanting to use Gambit for its FFI and general praise, but Racket s community, documentation, and editor keep making me turn my head. Its like a non-minimal scheme, that isn't weird-ass common lisp.
Racket can do that too, no? It used to spit out C, but no longer does, however it can kick out a standalone binary. I think at this level the difference between Racket and Gambit in regards to speed would be smaller if not negligible. I'm not trying to sell you on it, I just think if its for those reasons, then maybe Racket is a good option for you as it does work on Linux, is fast, and can compile to fast files.
No clue, I'm looking at both right now myself
I would really like to keep this post technical, but unfortunately this is a political answer. Since the adopted standards are so small: it is quite difficult to program useful and portable libraries, so almost everyone writes packages for specific implementations. The work of those who write portable libraries is not valued very much. A significant part of the Scheme non-community considers a true value to have small standards, so that is the way it is. Pick one or two implementations and stick with them and their packages. 
[Portable DrRacket](https://bitbucket.org/chust/racket-portable/wiki/Home)
何必在乎呢
Thanks for the corroboration! I was worried I had done something hopelessly awful in my Racket program
great !!! I am Dan's fans :) but it is unlikely that I will be able to buy the book easily in the place I live. I have to wait for the pirate version. 
why not?
Damn, if only this were R5RS compliant.
You can certainly do whatever you want, but indenting standards help readability of code. And if you're using a "normal" text editor, you're going to have a lot more things than indenting that you have to do by hand -- rather than have the editor help you.
You forgot to include the actual Scheme function. 
I think you need to use Scheme to write a sum function. When you have that we can see if it leads to a recursive process or an iterative process. You can't tell from the mathematical formula. 
That's the mathematical definition. What does your Scheme implementation of sum look like? 
I think the idea is that you're supposed to do that.
I thought you were interested in the difference between recursive and iterative processes. Anyways read this section of HtDP. It shows how to multiply the numbers from 1 to n. With very small changes you get a sum program: http://www.htdp.org/2003-09-26/Book/curriculum-Z-H-15.html#node_sec_11.4
You just posted this an hour before. Please don't repeatedly post the same question.
That's not quite true in scheme....Remember we are talking about processes, not functions! In scheme "recursive" functions can generate iterative processes or recursive processes depending on how they are implemented.
I could done to answer the question!Thank you everyone!!! 
That would be better i think, thanks! e: this walk errors on certain symlinks, maybe find-files will handle that better :) $ playrandom / Error: (directory-exists?) system error while trying to access file: "/sys/bus/cpu/devices/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0/node0/cpu0" 
[A snapshot of the home page when it was still active.](https://web.archive.org/web/20120104224418/http://www.roadsend.com/home/index.php)
Relevant: http://julianherrera.me/2015/05/building-bigloo-4-2a-for-windows/ Just my experiences getting a working build together
There should be a way to expand macros and see what the code really is. http://docs.racket-lang.org/macro-debugger/index.html?q=
good point, i think it's rewritten to the same thing. I'm using chicken and/or guile so i'll search for such a function.
i've remade the shuffle function since it should be tail recursive and not use remove but delete!. It doesn't work on lists with duplicates however so it's not really a general shuffle without writing another delete/remove which stops after the first found item. ;; shuffle a list in random order (define (shuffle lst) (let loop ((lst lst) (shuffled '())) (if (null? lst) shuffled (let ((item (list-ref lst (random (length lst))))) (loop (delete! item lst) (cons item shuffled)))))) also, i fiddled in exec in the shell command so it doesn't leave an extra shell running but just the play-command; [snip] (string-append "exec " play-command " " quoted-file " &gt;/dev/null 2&gt;&amp;1")))) [this](http://pastebin.com/Xne0UPVJ) is the current version which seems to work pretty fine for me.
I believe one of the reasons was lack of contributions and author assumed Scheme was the cause. However, I don't see any significant number of new devs after C++ rewrite either....
i'm trying to macroexpand/expand them but that's not as easy as i thought, it just shows the same. But, it's a matter of personal preference then i guess, i think in scheme the loop version is more common, under lisp i used optional parameters so that's also why i was a bit confused about which one to use.
At times it can be convenient. Back in the day I was rather fond of `do` and wrote (still a good read): https://web.archive.org/web/20061004051043/http://schemecookbook.org/Cookbook/IdiomLoopingConstructs These days I am using `for` and friends in Racket. For Scheme look into srfi-42. 
I guess these holes in our walls that let the sunshine in.
Yep. Couldn't have put it into better words.
:) How do you have time to refactor side-projects like these, while we're barely keeping up to read them. What is this voodoo.
Thanks a lot for developing scheme9 nils. I really like it. Imho the wealth of library functions is a really great resource for a beginner. Especially because everything is written in a clean and simple way (and comes with documentation). But what about the scheme9 editor, any plans to include it again someday in the future?
Working part time (if at all), living a simple life (so you don't have to work much), and having a small common denominator with most people (a.k.a. no social life to speak of) help. :)
Ah, the editor. I miss it myself, but I never managed to get it stable, and my policy is to kick unstable programs out of the distribution. Interactive programs are notoriously hard to unit-test, so my current plan it to write a set of unit-testable functions and an editing protocol and then stick a front-end to it. But even my time is limited, unfortunately, so this may take some time.
https://hy.readthedocs.org/en/latest/ plus any Python might qualify
Imho racket [plot](http://docs.racket-lang.org/plot/) with racket [math](http://docs.racket-lang.org/math/index.html) If you don't want to use Racket perhaps [slib](https://people.csail.mit.edu/jaffer/slib/) would be an option.
Linux or MinGW/Cygwin, right? Forgot the POSIX prelude (POSIX_SOURCE, POSIX_C_SOURCE, etc) when refactoring and FreeBSD doesn't need it. Aww, should have kept that Linux VM for testing. :/ I'll be at the drawing board, expect a fix later this day.
Yes Linux. Thanks for looking into it.
a bit off-topic, but I am wondering: you said chicken and gambit have an octave egg. I then recalled that e.g. chicken scheme adopted termite from gambit to be able to do some concurrency... are gambit and scheme that similar that eggs/modules can be adopted easily or are these just coincidences ? maybe someone can enlighten me.
"macro built with a template"? Can you provide more details, since macros are usually evaluated at compile time (depending on implementation) and templates expanded in runtime? But if you would like macro to return unquote symbol (or ,) you can use some trickery, like: (define-macro (foo) `',',(+ 1 2)) =&gt; ,(+ 1 2)
Thanks, I appreciate it.
Strings in Scheme are not immutable values like in Python or Javascript, they are more like (mutable) arrays of characters. Mutable arrays must be composed of other objects, and somewhere down the road you need a basic value type like "character" to end the recursion.
What changes would it have?
And following the release expect Racket to return to the previous policy of a release every 3 months. @sigzero: Note that there are nightly builds of the Git repository available for download at: http://pre.racket-lang.org/installers/ 
Cool thanks. I was just curious.
Maybe they heard you, they just released an update: http://blog.racket-lang.org/2015/06/racket-v62.html
Thanks, Captain Obvious. I was asking if you knew if there were any specific features or important bug fixes coming out
I guess I asked a little too soon. :)
Take a look at Gambit scheme. Compiles down to C, which you can then link to whatever you wish. It's previously been used for some iOS games by linking against the iOS libs. http://jlongster.com/Open-Sourcing-My-Gambit-Scheme-iOS-Game-from-2010
In particular, Gambit lets you write inline C or C++ code: http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html#C_002dinterface This means you don't need to bother with a specific FFI at all. You can use $engine's API directly and only expose what you need at the Scheme level. The engine is embedded in the Scheme interpreter (build a custom library of Scheme procedures around the engine, then compile and load it into a repl) rather than the other way around, which makes it a great choice for desktop-oriented game development too.
There's [Chibi Scheme](http://synthcode.com/wiki/chibi-scheme) which is explicitly intended for embedding. It seems to be fairly active, too.
I agree that it's possible to mix up those two notions and it won't make a language less practical. Scheme could live with such approach too. It's just the matter of PLT aesthetics: I'd rather not confuse value types with reference types. [edit] Also, Ruby-like behavior is full of subtle unexpected corners, e.g. `s[0] = 'baz'` inserts 'baz' instead of 'f' (for some reason I guessed that it would throw an exception) [/edit] And yes, now it looks more plausible for me that it's just historical influence of other languages like C and Common Lisp (Scheme is a rather old language). I'd like to see immutable strings in the language though.
I've never used it. I'm not even sure how. (let loop) works for me.
I try to use scsh but it does not work on 64bit linux.
Hi CHICKEN developer here! Thanks for your post, it is currently being discussed on the CHICKEN users mailing list: https://lists.nongnu.org/archive/html/chicken-users/2015-06/msg00061.html
Unfortunately you have to edit the Makefile to add `-m32` to `CFLAGS`. If you do it should build. I'm running it on 64-bit Mac and Linux boxes right now. If you give it a try, let me know if you get stuck and I'll try to help.
Hey, glad to run into another scsh fan. If you use Emacs you might also enjoy having a [Texinfo version of the manual](https://github.com/rmloveland/scsh-manual-texinfo).
*fwiw* a few scheme pi-digits programs which don't use gmp can be found in [the oldest archive](https://alioth.debian.org/scm/viewvc.php/shootout/bench/pidigits/?root=shootout&amp;hideattic=0) see: [pidigits.chicken (dead)](https://alioth.debian.org/scm/viewvc.php/*checkout*/shootout/bench/pidigits/pidigits.chicken?root=shootout) 
Gambit includes an infix extension.
You are looking for infix math operators, something like [this](http://demonastery.org/2011/03/a-scheme-infix-transformer/).
There's [a SRFI](http://srfi.schemers.org/srfi-105/srfi-105.html), but it's almost completely ignored; only Guile and Sagittarius seem to have implemented it.
I don't have to do heavy math, but the -&gt; macro is nice for heavily nested expressions. You can find it in Chicken's 'clojurian' egg.
Sorry, if you use a calculator, the fanction is here. ∑ ((Π (i+j) , j, 1, 30) , i, 1, 20) 
Then, how to edit that? I did all of my best, but I couldn't... Please tell me the solution? 
Thanks a lot!!!
Oops! I was ambiguous. I meant to ask about the differences between scsh and guile, not between scsh and the guile port. 
I'm so sorry, but.... the answer couldn't do the same..... my program is........ (define (f m n) (define result 1) (define i 1) (define j 1) (for (range i m) (lambda (i) (for (range j n) (lambda (j) (set! result (+ result (* result (+ i j)))))))) result) If run this program, the answer has over 800 figures:(
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Prime-counting function**](https://en.wikipedia.org/wiki/Prime-counting%20function): [](#sfw) --- &gt; &gt;In [mathematics](https://en.wikipedia.org/wiki/Mathematics), the __prime-counting function__ is the [function](https://en.wikipedia.org/wiki/Function_(mathematics\)) counting the number of [prime numbers](https://en.wikipedia.org/wiki/Prime_number) less than or equal to some [real number](https://en.wikipedia.org/wiki/Real_number) *x*. It is denoted by (this does not refer to the number [π](https://en.wikipedia.org/wiki/Pi)). &gt;==== &gt;[**Image**](https://i.imgur.com/mR5GPd6.png) [^(i)](https://commons.wikimedia.org/wiki/File:PrimePi.svg) - *The values of π\(n\) for the first 60 integers* --- ^Relevant: [^Chebyshev ^function](https://en.wikipedia.org/wiki/Chebyshev_function) ^| [^Prime ^number ^theorem](https://en.wikipedia.org/wiki/Prime_number_theorem) ^| [^Ramanujan ^prime](https://en.wikipedia.org/wiki/Ramanujan_prime) ^| [^Foias ^constant](https://en.wikipedia.org/wiki/Foias_constant) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+csnb23c) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+csnb23c)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](/r/autowikibot/wiki/index) ^| [^Mods](/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Call ^Me](/r/autowikibot/comments/1ux484/ask_wikibot/)
I came across this post thanks to /u/Atupis, so credit to him or her for finding it. **Edit:** [Discussion about the topic over at /r/programming](https://www.reddit.com/r/programming/comments/3bqaj2/john_carmack_proposal_for_scheme_as_a_vr/).
Continuations?
I'm fairly new to guile, and am taking baby steps with the FFI. I used a bit, but it was quicker for me to do most of the bootstrapping in C. I added one file, guile.c, to the sundown library to make it all work. After a tiny bit of thought, your worries make a lot of sense. To make the installation less dangerous I've: * Renamed my modified libsundown to libsundown-guile * Modified the Makefile so that the shared lib is installed in the proper guile site directory, with the scheme code. Everything is up to date on the repo. The installation should be fairly isolated now, and there is no potential to muck up an existing system.
Last week [I shared a collection of links re. the Scheme Shell](https://www.reddit.com/r/scheme/comments/3as8yr/scsh_collection_of_links_related_to_the_scheme/). Today I wanted to share a Scheme Shell script I recently wrote simply to demonstrate a realistic use of scsh, to demonstrate how scripts in scsh differ from their counter-parts in `/bin/sh` and similar shells. I leave it to each of you to draw your own conclusions about the pros of cons of using scsh for this kind of task. But if you have any questions please don't hesitate to ask! **Edit:** [A blog post I wrote yesterday](http://ericjmritz.name/2015/07/03/useful-srfis-for-scheme-programming/) briefly talking about the [SRFIs](http://srfi.schemers.org/) I used in the script.
I've been playing around with [GNU Guix](https://www.gnu.org/software/guix/) and so far I like what I see in it. In the future I intend to write about its design and what I feel are its pros and cons after I do some more research and spend some more time using it.
I look forward to reading it.
Thanks! :)
You've been asked repeatedly to stop posting your homework questions -- and to stop re-posting them. Next step would be a ban, I think...
Are you sure? I think there's a 64bit capable fork somewhere on github. Dang it's been years since I got it running. I had to install an experimental s48.
Thanks! If you have any questions about the code feel free to ask, because I know it is kinda hard to read without any highlighting. I wish GitHub would highlight the source code of stuff based not only on filename but also things like Emacs file-local variables (I'm writing a patch for [Linguist](https://github.com/github/linguist) for this that hopefully they'll accept).
Thanks for the links. I have very little experience with CHICKEN so it's high on my list to learn more about. Its `er/ir-macro-transformer` mechanisms look interesting. Honestly, at a glance they look much more like `defmacro` from Common Lisp than the usual `syntax-rules` facility I see in other Schemes. My immediate impression is that it looks easier to write complex macros in CHICKEN compared to other Schemes (if one is comfortable with quasiquoting and splicing and such). &gt; Finally, no list of Scheme resources is complete without The Scheme Programming language. Oh duh, heh. Can't believe I forgot about that one.
Awesome, thank you very much!
I'm interested in you library too. Why are you using Sundown instead of Hoedown?
The numbers egg has been worked on which adresses some of the problems. There is an explanation by Peter here: https://lists.nongnu.org/archive/html/chicken-users/2015-07/msg00007.html Note that due to other bug reports the changes have not been published yet.
wow, thank you very much for fixing it and the in depth explanation! I'll check out the numbers trunk to play with it. e: a quick test shows it is much faster indeed, thank you very much! 16.624s CPU time, 4.796s GC time (major), 225718 mutations, 957/1276 GCs (major/minor) 
Well, I needed to get something working quickly for a project -- and I didn't realize that Hoedown existed. When I have a break, I'll move the whole thing over to hoedown. For now, it's getting the job done.
Apologies for not replying to this earlier, but I'll try to enumerate some differences (I know of no comprehensive comparison). At a fundamental level, the largest difference is in how Scheme treats macros vs. how Common Lisp treats them. In Scheme, macros are just operations / closures over syntax objects or syntax transformers, which are considered first class in the language. In contrast, Common Lisp macros work directly on lists and symbols, and really just expand forms through the use of quote / quasiquote / unquote. The difference may not be all that apparent, but it's mostly to do with when symbols are bound to the functions / values in a macro. In Scheme, the symbols are bound immediately, so for e.g. if you pass a form (my-macro (lambda () ...)) or some variant, then what actually gets read in is the syntax (my-macro016 (lambda348 () ...)), where the numbers after denote the unique reference to the function or symbol that is captured at compile time. In contrast, Common Lisp binds these symbols late, so using the same example, when you type (my-macro (lambda () ...)) into a REPL, what is actually sent to the macro is (my-macro (lambda () ...)). Here the symbols do not reference a "syntax object," but are merely Lisp symbols (think as if you were to type (quote lambda) in the REPL, what is returned is just the symbol lambda). There's arguments both ways about which are better, but this is largely the reason behind how hygiene works, and makes a big difference on how you are expected to write your macros. The major reason many don't like Scheme macros is that it creates some overhead in how you write your macros. Sometimes, you want name collision, e.g. in an anaphoric-if-macro: (aif (hash-table-ref/default tbl key #f) it (error "no value at key in table" key tbl)) Where `it`, is bound to be the result of `(hash-table-ref/default tbl key #f)`. If hygiene were preserved here, then we could never reference `it`, because the hygiene would hide `it` from us. ; Broken (define-syntax aif (syntax-rules () [(_ pred then else) (let ([it pred]) (if it then else))])) Here, the `it` in the let statement is expanded to the syntax object it048 or some equivalent. If you type the same as above though, you may find it expands to: (aif002 (hash-table-ref/default003 tbl001 key050 #f) it404 (error122 "no value at key in table" key050 tbl001)) The numbers themselves aren't too important on their own, but with hygiene you can't access it048, and if you haven't defined it404 in another part of your program, you'll get a "symbol not defined" error. In contrast, Common Lisp binds late, and is just symbol manipulation, so it's much easier to write the macro, and likewise, we don't run into the issue of hiding it048 with hygiene. The macro expander works the way you would expect it intuitively, but keep in mind that hygiene becomes somewhat desirable as the number of symbols you need to manage increases. Sometimes people say they hate Scheme macros because syntax-rules is too restrictive (you can't break hygiene as with the it048 case above), and syntax-case is far too confusing (without mentioning that breaking hygiene with syntax-case is verbose/tedious). Fortunately, low-level macros in the form er-macro-transformer and ir-macro-transformer give us the best of both worlds, but that's a whole post in itself. 
*[How to Design Programs](http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html)* is the introductory programming book from the [Racketeers](http://racket-lang.org/). It uses a series of subsets of Racket/Scheme as teaching languages and is a gentle introduction to thinking "Schemingly". This and the docs to whatever full implementation you choose should be a good start. P.S. What is MEEP? 
Python:Scheme::Blaster:Light saber
Hahahah! As in I should learn how to use Python before Scheme? I wish I had the time, but right now I have no choice but trial by fire. Would learning Scheme now make Python easier later, though?
Would that allow for me to start coding pretty quickly? P. S. MEEP is an engine that allows for computational characterization of magnetic and electric fields using Maxwell's equations, is the only way I could describe it. It's above my understanding, but hopefully, not for long.
Thanks for all ofthe help, but I'm in an even worse place than I thought--I can't even get coding. I'm using two different tutorials ([Teach Yourself Scheme in Fixnum Days, [User's Manual](http://groups.csail.mit.edu/mac/ftpdir/scheme-7.5/7.5.17/doc-html/user.html#SEC_Top)](http://ds26gte.github.io/tyscheme/index-Z-H-1.html#node_toc_node_chap_1)) but I don't seem to be able to even communicate with the program. Whenever I try to launch the program from the Command Prompt, I get this error "scheme: can't find a readable default for option --band. searched for file all.com in these directories: c:\local\mit-scheme Reason for termination: Inconsistency detected." That file is actually in c:\Program Files (86)\MIT-GNU Scheme\lib. When I launch Scheme from the desktop shortcut, my inputs get no response even though I am following the manuals verbatim. For instance, I'll load up Scheme, type in (exit), press enter. . .and nothing will happen. What am I doing wrong? 
If you want to start off sprinting, maybe not. Books like *HtDP* and *SICP* are good but more tortoise than hare. In case you haven't seen it, MEEP has its own page of [Scheme and Guile links](http://ab-initio.mit.edu/wiki/index.php/Guile_and_Scheme_links). It's pretty old and some of the links are out-of-date, but it may serve you better. 
I checked. You re right...
Couple issues. First your cond statement is misformed, you need an extra set of parens our each condition. Second, you can't return (x y) because that is how you would call the function x with the parameter y, if you want to return a list of the two items x and y you need to do (list x y). Third, if (greater 1 2 3) is going to return a list of two items you need to call (apply sumsq (greater 1 2 3)) in order for those 2 variable to be passed as parameters. (define (greater x y z) (cond ((and (&gt; y z)(&gt; x y)) (list x y)) ((and (&gt; x y)(&gt; z y)) (list x z)) ((and (&gt; y x)(&gt; z x)) (list y z)))) (define (square x) (* x x)) (define (sumsq x y) (+ (square x)(square y))) (apply sumsq (greater 1 2 3)) 
Think of returning a single value as calling the current continuation with a single argument; with ‘values' you can pass more arguments to the continuation. A Scheme compiler may translate a procedure call to machine code that pushes each argument into the stack and then calls the procedure; this way consing is avoided and thus no garbage is generated.
The advantage is that values is more concise if you don't have pattern matching. Now that pattern matching has been invented, values can be seen as a kind of historical oddity that adds complexity to the language semantics without adding much ... err... value.
I agree, you're giving the person reading your program or using your library extra semantic information. You're telling them to expect a fixed amount of values, whereas a list has a variable amount of values - including zero! 
This is a very good question. Here is one view: Consider this situation: The function f calls a function g. The function f needs several values from g. Without multiple value return, g must pack the values in a list (or vector), which is then passed to f. Then function f then immediately unpacks the list. With multiple value return, the values are just pushed on the stack. Thus no packing and unpacking is done. Whether this should be called an optimization hack or not, is up to you. For a very interesting discussion with many different views of the matter, see this discussion in comp.lang.scheme (35 persons participated!). https://groups.google.com/forum/#!topic/comp.lang.scheme/ruhDvI9utVc%5B1-25%5D Also if you are interested how the multiple values return feature was designed take a look at the discussion in 1985/1986. https://groups.csail.mit.edu/mac/ftpdir/scheme-mail/HTML/ 
Great answer, thanks for the old links. It looks like the relevant discussion begins with a survey by Gary Brooks [here](https://groups.csail.mit.edu/mac/ftpdir/scheme-mail/HTML/rrrs-1986/msg00365.html), way back in 1986!
That message doesn't show up [in the index](https://groups.csail.mit.edu/mac/ftpdir/scheme-mail/HTML/rrrs-1986/maillist.html). Very strange. 
T and Oaklisp(object-oriented Scheme) has it. * http://repository.readscheme.org/ftp/papers/t_manual.pdf * https://en.wikipedia.org/wiki/T_%28programming_language%29 * https://en.wikipedia.org/wiki/Oaklisp * http://www.bcl.hamilton.ie/~barak/teach/F2002/CS451/hw/4/oaklisp-runtime-and-docs/lang.pdf
Additionally, CL has things like reader macros.
You're looking for Guile (if the license isn't a problem).
Locatives complicate GC slightly, but are a powerful abstraction when coupled with getter/setter/locator operations. Oaklisp is worth checking out. The paper describing its implementation is a good read.
CHICKEN has them: http://api.call-cc.org/doc/lolevel#sec:Locatives
Not sure what good is expected of such adversarial questions. Guile and Racket are both exciting systems and you should use *both*. The only thing I got from this IRC log is the following: when user mark_weaver starts a sentence by "I'm sorry,", something relatively rude follows.
There is value in choosing one system and going deep with it. You get all of the great network effects of the implementation-specific package manager, you get integrated in a community of people building and building on a shared base of software, and you have one uniform coding style. I also think you are taking the wrong conclusion about Mark :) It could be that as a community our standards of politeness can degrade or change over time, and having new people notice things like you have done is great. I'm sure Mark would want to know if the things he says are perceived as rude, because I don't think he means them to be. He has been one of the three Guile co-maintainers for a couple years now, and has shown a consistent pattern of empathizing with user needs in his work. [added] One more thing: we should be able to "sell" guile over racket, or racket over guile, without being adversarial. Neither system is going to go away any time soon, so there is no danger for saying "use X over Y", and being able to articulate differences from e.g. Racket is necessary for Guile as a project, from a project direction standpoint. If we aim to be the same, why wouldn't we merge? And if we did aim to be the same, the reason for not merging would be interesting to find out.
Well Gambit (since it uses the common subset of C and C++ as its output format) [allows C or C++ code to be embedded directly into the program](http://www.iro.umontreal.ca/~gambit/doc/gambit-c.html#C_002dinterface): (c-declare #&lt;&lt;c-declare-end #include &lt;iostream&gt; c-declare-end ) (define println (c-lambda (char-string) void "std::cout &lt;&lt; ___arg1 &lt;&lt; std::endl;")) (println "this will be automatically converted to a c-string") `c-declare` can be used at the toplevel to add C declarations to your output program's global scope, and `c-lambda` defines blocks of C or C++ code that can be called as Scheme functions. (The reverse, Scheme functions callable from C, is provided by `c-define`.) That said I think Gambit doesn't support C++ (rather than C) by default, so you need to pass `-cc-options "-x c++" -ld-options "-lstdc++"` or similar to the compiler.
I don't know Mark (nor much of the Guile community, except you, whose fantastic blog I read with passion, and Ludovic which I've met a couple of times and is very nice), and I wouldn't want to give the impression that he seemed generally rude in this IRC log; on the contrary, he is the main provider of interesting points and seems eager to help. It is just a (perhaps amusing?) pattern of conversation that one can't help noticing, which is that the *specific sentences* starting with "I'm sorry" are somewhat crude. This is actually rather common, when people have some form of afterthought about what they're going to say, to start a paragraph by "I don't mean to &lt;X&gt;", and then do X. I don't know if Mark himself is reading r/scheme, but in case: I meant no harm, but when you start writing "I'm sorry", just skip the sentence altogether and go work on whatever you like instead.
This seems to be the work of hygienic macros in action. It's been a while since I dabbled in these things, but my guess is that syntax rules notices you use / in your body and automatically replaces your let binding for some non conflicting one. You might want to check what ooptions for unhygienic macros guile gives you. Sorry I can't be of more help. Edit: if you do want to use unhygienic macros for this, check guile's support for some [CL style defmacro](https://www.gnu.org/software/guile/manual/html_node/Defmacros.html#Defmacros)
https://github.com/dleslie/monad-egg/blob/master/monad.scm#L10 Looking at the definition for the Maybe monad, it seems to just pass in (Just a) to the function f. He also defines in the README that the binding function is a -&gt; (a -&gt; M b) -&gt; M b When it should be M a -&gt; (a -&gt; M b) -&gt; M b
Thanks for checking that for me, and thanks for the implementation :)
Hi! Egg author here, Please do file bugs in GitHub. I appreciate it. :)
Egg author, Sorry for the confusion, there appears to be a valid bug with the Maybe monad; and it appears that I utterly failed to update the documentation. `do` should read `do/m` The above should now be fixed.
Ahh, great, thank you for the response :) The list monad is working if I use `do/m`: (do/m &lt;list&gt; (x &lt;- '(1 2 3)) (y &lt;- '(a b c)) (return `(,x ,y))) ((1 a) (1 b) (1 c) (2 a) (2 b) (2 c) (3 a) (3 b) (3 c)) 
When you write recursive function, you need to consider the base case and the construction of complex objects. In your case, the base case is for 0. As you noted, (doggy 0) --&gt; () so the code will need to look like (define (doggy n) (if (= n 0) '() (doggy-do n))) where doggy-do is the construction step. In order to see how it should look like, you need to consider (doggy 1), because it is one step further than the base step. Obviously, (doggy 1) &lt;-&gt; '(dog) &lt;-&gt; (cons 'dog '()) &lt;-&gt; (cons 'dog (doggy 0)) and since the reduction step to take 1 to 0 is to subtract 1 from it, we could define doggy-do of n as (cons 'dog (doggy (- n 1))) and finally we get: (define (doggy n) (if (= n 0) '() (cons 'dog (doggy (- n 1))))) 
Thank you!
Homework cheating.
what's your use case? unless you're doing some ancient cgi thing you don't pay the startup penalty all that frequently, and on my machine (macbook pro) it's about 0.2 seconds for racket, which seems tolerable (but it is a lot more than guile).
I believe Chicken's scrutinizer (-strict-types) does this.
Maybe that is one of the reasons why "The Little Schemer" doesn't use `values` when dealing with multiple return values. It instead takes a function to fill the role of a continuation, and then calls it with the N return-values-would-be.
As per [the wiki](http://wiki.call-cc.org/man/4/Types) `-strict-types` does not provide a gradual or optional type system in the way that Typed Racket or Clojure's `core.typed` do. The reason for this flag is to help provide more optimistic opportunities to use the `-specialize` flag. It won't stop compilation if types are not strictly adhered to. To answer OP's question, see the toplevel reply from /u/nullbuilt0. Shen is the way to go here, there's little way around it unless you want to use Racket. 
my bad, I missed part of the article when first submit, now it's fixed... sorry for misguide.
advantage: (list-&gt;string (map char-upcase (string-&gt;list "fuck loops"))) 
Attempting to make Lisp work without parens is how a lot of people learn to first live with them and then like them. By the time the project is done they look back and realise that writing it wasn't really that bad...
Maybe square brackets, but probably not. Languages with syntax derived from C use parens pretty heavily too and it isn't something people complain about much.
As someone who designed [a whitespace-sensitive lisp](http://akkartik.name/post/wart), I don't understand why the imperative to reduce parens 'slips' to eliminating *all* parens. I still like my approach the best :p &gt; Used tastefully, taking out parens can make code markedly more readable. My heuristic is to skip parens when I want to highlight side-effects and control-flow, and to insert them when I want to indicate functional computation. Or macros. Or just when I plain have to. But at least you don't have to learn any new cryptic tokens. The precise rules are here: https://github.com/akkartik/wart/blob/24e754b556/004optional_parens.
wisp does not eliminate all parens, and it does not attempt to (though it can look like that). It leaves parens out where they can be inferred completely from indentation and provides a limited syntax to avoid parens which are closed at the end of the line. Anything within parens isn’t touched by wisp at all — it is directly passed to the Scheme reader in Guile. The paren-avoiding rules in wart look like a restricted version of SRFI-49. Did you already test that? In wisp replacing inline parens with the colon started as a side effect from using the colon to indicate the indentation of empty lines (for double-parens) which proved so useful and beautiful that it became a feature of its own: It allows representing the definition of procedures the same way as the later usage. define : hello world format #t "Hello ~A!\n" world hello "World" My own usage removes outer parens and keeps parens for most inline calls. format #t "~A ~A ~A" 1 (+ 1 1) 3 Also I keep the parens for quoted lists and similar: display '(1 2 3) Also wisp is much smaller than wart: It is just a reader for Guile: After adding the parens it passes the resulting sexps to Guile. All the wisp-specific code taken together is less than 800 LOC (and it’s written in wisp) — after all it’s just plain Scheme without (most of) the parens ☺ If you could pass the wart-code with added parens to the Guile reader, you should be able to directly benefit from all the optimization passes in Guile (though that would be only your paren-adding, else you’d have to translate def! to define and such). Here’s an old version of the wisp-reader which used a plain string preprocessor to turn wisp into Scheme. It should be easy to wire in wart instead: https://bitbucket.org/ArneBab/wisp/src/e74574385b7e167e818a910b4fbfc5abcebb7049/wisp-reader.w
That would be great, yes. It’s an optimization problem, though: When should you use inline-parens, when do you switch to the next line? That requires defining aesthetics.
Are you aware of any lexically scoped Logo's?
psyntax is also using extended KFFD algorithm for performance so it's pretty much complicated. It might be better to start with SRFI-72 (http://srfi.schemers.org/srfi-72/) aka van Tonder expander. In short: R6RS requires macro expansion before runtime or more precisely there are (at least) 2 phases, runtime and expansion. On expansion phase, all macros are expanded including `let(rec)-syntax`. Evaluating an expression contains macros also applies the same rules. So `eval` should do those phases. NOTE: R6RS `eval` takes 2 argument, expression and environment. The environment is, sort of, a set of libraries. The expression must be evaluated in the given environment. Thus local variables (or even global) can't be seen inside of the evaluation. So thus raises an error: `(let ((x #t)) (eval 'x (enviroment '(rnrs))))` NOTE2: R6RS doesn't require to have REPL because of this. R7RS, on the other hand, doesn't specify how/when it's expanded. So you can also do on the fly, means whenever your interpreter met a macro then you can expand it.
Macros By Example (MBE) is an easy way to get started (IIRC).
Thanks for this! It articulates what as been itching me for years. It is the reason I pretty much stay with Lisp/Scheme, since I can try and create a DSL to test new ways of attacking a problem. I am learning LFE (Lisp Flavored Erlang) at the moment, so I can take advantage of the BEAM VM, and all Erlang has to offer. I think Sussman is really insightful about the present and future apart from his past contributions. What a smart and funny guy.
You need to use letrec for recursive references.
Yes, overcoming this error can be done in various ways. My aim, however, is to conceptually understand this error--instead of solving it. 
In (let ([factorial expr]) body) the identifier `factorial` is only bound in `body` not in `expr`. With `letrec` the identifier will be bound in both `expr` and `body`. 
as far as I understand it, let compiles the expression assigned to factorial, such that at the point where factorial calls factorial, there is no function 'factorial' for it to insert a reference to, the assignment happens after the compile stage.
The problem is that the variable 'factorial' is only visible in the body of the let expression. To understand why you have to know that (let ((var exp) ...) body1 body2 ....) is just syntax for the equivalent ((lambda (var ...) body1 body2 ...) exp ...) So transforming the let expression results to ((lambda (factorial) (factorial 3)) (lambda (n) (cond ((= n 0) 1) (else (* n (factorial (- n 1))))))) Thus the variable 'factorial' is unbound in the second lambda expression '(lambda (n) (cond ...)'. So what to do? One option is to pass the variable as an extra argument to make it visible. ((lambda (factorial) (factorial factorial 3)) (lambda (factorial n) (cond ((= n 0) 1) (else (* n (factorial factorial (- n 1))))))) Retransformed to let: (let ((factorial (lambda (factorial n) (cond ((= n 0) 1) (else (* n (factorial factorial (- n 1)))))))) (factorial factorial 3)) This is not a nice way to solve this problem so we need an easy way to make the variable visible; 'letrec' to the rescue. If you use letrec (recursive let) the variable 'factorial' will not only be visible in the body '(factorial 3)' but also within the expression (lambda (n) (cond ...). (letrec ((factorial (lambda (n) (cond ((= n 0) 1) (else (* n (factorial (- n 1)))))))) (factorial 3)) And just like let, letrec can also be rewritten (let ((factorial #f)) (let ((tmp (lambda (n) (cond ((= n 0) 1) (else (* n (factorial (- n 1)))))))) (set! factorial tmp) (let () (factorial 3)))) And again transformed to a form without let: ((lambda (factorial) ((lambda (tmp) (set! factorial tmp) ((lambda () (factorial 3)))) (lambda (n) (cond ((= n 0) 1) (else (* n (factorial (- n 1)))))))) #f) For tl;dr see [reply](https://www.reddit.com/r/scheme/comments/3r0mps/let_error/cwjx50z) of [/u/soegaard](https://www.reddit.com/user/soegaard) Edit: formatting Edit2: tl;dr
You can't do that with regular functions. You need to write a macro.
Yes, I am aware. I am just trying to think through what will be the right approach to solve my problem above. What will be the best way to evaluate each of the subexpressions, from left to right, while if a #t value is returned in one of them, the loop terminates itself.
I'm not sure what you're not aware then. Just evaluate the expressions one by one, as you said, and return the result as soon as you know it.
I believe this is how most schemes do it under the hood (other than native coding it).
[This](https://github.com/shaurz/amp/blob/master/boot.lisp) is how I did it for a little Lisp interpreter I wrote a few years ago (see the expand-and/expand-or functions). This uses non-hygenic style macros, but it should give you a rough idea.
This is subreddit for scheme, not schema.
I don't want to give away the answer, but there are some excellent notes here. https://cgi.soic.indiana.edu/~c311/lib/exe/fetch.php?media=cps-notes.scm https://cgi.soic.indiana.edu/~c311/doku.php?id=cps-refresher
In my biased opinion, you might find Danvy's [Three Steps for the CPS Transformation](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.1962&amp;rep=rep1&amp;type=pdf) a good source for structurally applying the CPS transformation.
Appreciate your response, but as I mentioned I'm not asking about practicality. I don't know why I get the feeling sometimes that there is some deeper mystery that I'm unable to unravel. I'm trying to find out if others feel this way and whether they reached some meaningful conclusion.
You're doing a lot of unnecessary work that essentially translates to 'increased readability', BUT the problem is so simple that readability really isn't necessary. If you were dealing with a problem that had thousands of lines the readability might be worth it. Beyond that, most of your defines are redundant text, eg (define (pair-first pair) (car pair)) could be simply written as: (define pair-first car) or you could skip that step completely and do: (define formula-fixed-cost car) Personally, if I was writing such a ticketing system, I'd be tempted to encapsulate the ticket price structure with a `define-record-type` not so much because it's necessary, but because it gives you something like: #;25&gt; (make-ticket 180 0.04) #&lt;:ticket-price&gt; Which makes debugging a system a little easier than just seeing `(180 0.04)` and trying to work out what each value represents (and source diving into your 'make-formula' or whatever. Different implementations can even make the debugging a little easier, with things like: &gt; (make-ticket 180 0.04) #&lt;:ticket-price #2 fixed: 180 per-person: .04&gt; A more functional solution might be to make a function that returns a function that computes a total price given a number of attendees, so that you're external interface becomes something like: &gt; (define ticket1 (make-ticket-generator 180 0.04)) &gt; (define ticket2 (make-ticket-generator 0 1.5)) &gt; (ticket1 4) =&gt; 181.6 &gt; (ticket2 4) =&gt; 6.0 But that's a little bit more complex, and an exercise for the reader (ie, I CBA to write example code for it :)
Well I wanted to do (define pair-first car) myself by I'm doing BSL mode on DrRacket so it wasn't available. Other than that, as someone coming from an imperative C/C++ background, is it a fair observation that lisp/scheme let's you construct towers of abstraction much more quickly and easily, but the problem of over-engineering, and micro-abstractions, and overkill are the still the persistent problems, so you have to exercise judgement? Regarding your define-record-type, is that a strong type, comparable to ML's type system? I've been asking around about ML vs lisp/scheme comparisons and it seems both having a strong/static type system (ML) vs having a dynamic type system (lisp/scheme) has its pros and cons and areas of applications. ([mainly I read this](http://stackoverflow.com/a/3326652/3973303)). Either that, or I'm need more literature search, study a PL/types book or two.
&gt; Other than that, as someone coming from an imperative C/C++ background, is it a fair observation that lisp/scheme let's you construct towers of abstraction much more quickly and easily, but the problem of over-engineering, and micro-abstractions, and overkill are the still the persistent problems, so you have to exercise judgement? I think that's probably fair, yes. The 'good' side of the abstraction is that you can build code that is self-documenting and much easier to maintain than 'lesser' languages. &gt; &gt; &gt; &gt; Regarding your define-record-type, is that a strong type, comparable to ML's type system? I think that depends on what your definition of 'strong type' is. It's been a while since I programmed in ML last, but as I recall it's a latent type system, and hence 'weakly typed' by most definitions. In this sense it would be a weak type, as scheme and lisp are a dynamic type system - but so, largely, is ML. In the sense that it has types that cannot be implicitly coerced to other types, ML is 'strong typed'. Using this definition scheme too can be, it depends on the implementation - some schemes implement srfi-9 (define-record-type) on top of a coercable type like a list or vector, some implement it natively, and some introduce a native un-coercable type system that is then used to implement srfi-9 and srfi-99 (the 'other' record system in scheme). &gt; I've been asking around about ML vs lisp/scheme comparisons and it seems both having a strong/static type system (ML) vs having a dynamic type system (lisp/scheme) has its pros and cons and areas of applications. (mainly I read this[1] ). Either that, or I'm need more literature search, study a PL/types book or two. Both static and dynamic have their pros and cons, and an ideal situation is to have both available if possible. As for latent vs manifest types, I don't think that 'strong type' in that sense is all that useful, if that's the only way that static typing can be implemented (as is with C and it's ilk) then so be it, it's the price you pay, but most modern languages have leaned towards latent typing with or without strong types available. The problem as you can see is that strong vs weak, latent vs manifest and static vs dynamic are all independant traits of a type system, and can exist in any of the 8 combinations.
There aren't really any good definitions for a 'strong vs. weak' type spectrum. I would recommend against trying to use those terms to characterize a type system at all, despite the continuing popularity of the terms. They mostly cause confusion rather than clarity. ML is actually two languages; there's the language of values and functions and then the language of modules. Both are statically typed, but while the value/function language is latently typed (types are not required to be written down, but are inferred from context via the Hindley-Milner type system) the module language requires explicit type 'signatures' for 'structures' and 'functors', which are functions between structures (structures are the language construct that define modules). I think the similarity between define-record-type and ML record types is that they are both 'type constructors'; when you create a record type in either language, you get a *new* type that is distinct at the type level from structurally-similar types. When you write Scheme functions that work directly on pairs vs. a specific record type of two elements, then *any* pair passed to the pair functions will pass the dynamic type checks, even if it's a pair of completely inappropriate things for the particular function. A function that is implemented via the accessors provided by a define-record-type macro can be made to fail the dynamic type check in those accessors if passed a value of a different but structurally-similar record type. In the terminology of type systems, these are "nominal" rather than "structural" types. In order to pass the check, the values must have types of the same name rather than just having compatible representations. If your scheme data structures are built around cons cells, then you're using dynamic structural typing. Data will be compatible with functions when it's built in the shape the functions assume. The aspect of ML's type system that matches signatures with structures is a static structural type system; any structure that provides the elements required by a signature will pass the type checker; it need not mention the signature by name. The way that dynamic typing is implemented is that the various types are all distinguished from one another at run-time via some sort of tagging mechanism. ML provides a way to create a set of tagged variants that belong to a single type which ends up working fairly similarly at runtime to Scheme's define-record-type mechanism; defining a 'sum type' (as this sort of thing is called in type theory) gives you a set of contructors for data of each variant as well as a pattern-matcher that serve mostly the same function as the record type predicates generated by define-record-type. This allows you to have a little 'dynamically-typed' world inside a program that is mostly statically-typed. The Racket language also provides a statically-typed variant, called Typed Racket. It's fairly similar to ML, and might be easier to explore for a beginning Schemer than ML itself. If you'd like to see another example of this sort of abstraction you're exploring in action in a very fine-grained way, you should check out the book 'Thinking Forth', which has been published for free download online. Forth is an untyped language (there's not even any automatic dynamic checking of types) with very flexible reverse polish notation syntax. Parameters are passed and results returned via a separate data stack, and if you try to do too much in a single routine, it quickly becomes littered with stack manipulation code so it's nearly impossible to understand. So Forth code is filled with tiny routines that do one really simple thing and are designed to work with one another to accomplish something larger in many small steps of abstraction rather than long routines with complex control flow in them, as you tend to find in languages like C that provide features like local variables and built-in control structures that make it easier to reason about control flow in medium-to-long length routines. Like many things in programming, there are trade-offs between different approaches, and the value being traded isn't always the same in every context. It takes study and lots of practice to get a good sense of when various design criteria are more important than others, so don't worry too much if you feel like you're struggling with it. Everyone struggles with it. :)
Patches welcome
Certainly, but I assume feedback is worth something too
«Basically, GNU Artanis has no ORM yet, and maybe never. GNU Artanis is trying to experiment new ways to solve the problems of ORM. » ([source](https://gnu.org/software/artanis/manual/html_node/ORM-problem.html#ORM-problem)) Its experimental solutions (SSQL, FPRM) are not documented O_o Interesting, but puzzling no ? What do we use instead ? 
It's worth approximately the cost of the bandwidth to transfer it. As the saying goes: Talk - Action = Zero
So you're gonna fix it? Great! Thanks!
Why should I scratch your itch?
ORMs are a bad fit for functional languages like scheme. The data model of databases maps well to the data model of lispy languages so there is usually no need for any intermediate layer, except (often) something to construct the SQL strings 
i.e. `Talk = Zero + Action` or `Talk = Action`. sounds legit.
Yes, it's not documented well, and the features are still unstable in design. After all, it's still Beta. Acturally, even there's no ORM, one may get the same convenient with FPRM. ORM is an over-boasted thing, basically, user just need an abstract to handle a table with an object. In Scheme, we just use closures. Nothing new, they are just the same.
The text says that the coins are in some sort of order.
That's awesome! I recently downloaded the guile port from http://sourceforge.net/projects/ezwinports/files/ (which is "heavily patched" according to the project's README.txt) but haven't done much beyond starting up a repl.
Yeah, some patches are needed in order to get earlier versions to build. There's little way around it. My script patches 3 or 4 files to get 2.0.9 to work. I have still some work to do in order to make 2.0.7, 2.0.5, 2.0.1 and 2.0.0 build. I also recently added makeinfo 4.13 to the automatic build, because makeinfo 5 breaks guile's tex information in versions older than 2.0.9, but it's not commited yet.
Paren balance all comes from learning how to indent, and an editor that matches parens helps, I use vim.
vim is certainly OK, but it's another editing paradigm. I assume that vim is a continuation of the vi paradigm. I prefer the emacs style better. I have used emacsen around 33 years now. I also like the lisp extension language better, even though I've used some emacs editor which used a C like extension, it was epsilon. What does vim use?
&gt; What does vim use? [MzScheme](http://vimdoc.sourceforge.net/htmldoc/if_mzsch.html). Well, vim can be scripted with many languages, but VimScript is built-in and a terrible language.
&gt; MzScheme cool 8-) scheme is one of my favourite languages. There is a project to make scheme the extension language of GNU emacs as well, then as [GuileEmacs](http://www.emacswiki.org/emacs/GuileEmacs), although I haven't tested it yet, but guile is the scheme I've been using mostly.
If you really want to learn Scheme, write an implementation. ;-)
Scheme is conceptually a work of art.
I'd like to follow that but I don't see a RSS feed :/
&gt; learning how to indent, [Or using emacs](https://raw.githubusercontent.com/Malabarba/aggressive-indent-mode/master/lisp-example.gif). Seriously, this is like magic for lisp.
emacs is definitely better for lisp, I'm just a vim person.
If you want another easy-to-read resource, you could also try *The Little Schemer*. You could plow through it in a few days, easily. (the author is one of my former professors, so I always feel obliged to plug it, haha)
Aha, I thought editing grammar was referring to providing a syntax for the document to be edited. &gt; because you never have to take your hands away from the keyboard to fetch the home This is the principle behind emacs keys. You mentioned home, an emacs user never use the home key as home is just \^A, alternatively Meta-A which goes to the beginning of statement, paragraph etc. &gt; do finger kamasutra with ctrl and alt. There obviously was some conspiracy going on in the late 80-ies as then the new style of keyboard (I think they named it PS2..) when they switched positions of the extremely useless CAPS Lock key and the extremely useful Control key It is extremely annoying for each new linux distro one installes one has to put `XKBOPTIONS="ctrl:nocaps"` in /etc/default/keyboard which switches this back, so the Control key is at the position it should be, easy accessible. can also be done from the command line as: `setxkbmap -option ctrl:nocaps` or use the GUI's settings of course. FYI: for an emacs user the Control key is directly mapped in the spinal cord so it's not an extra charcter. Do you consider e.g. the Shift key, Meta key or Alt key to be extra characters? When I see your examples, the first thing I'm reacting upon is that you have to make several keystrokes for simple actions in some cases, I can make a comparision. Here I'm expressing Ctrl-char as ^ char with char in lower case, apart from Ctrl-SPACE (^ @) which I express as \^@, I write Alt as A and CR as R below. emacs|vi|command :----|:----|:---- \^s x |fx| move forward to x \^s x\^b|tx| move forward to char before x Ae|e| move to end of word \^@s x\^mw|dfx| delete from here to and including x \^@s x\^bw|dtx| delete from here to the char before x \^@Af\^w|de| delete to end of word \^@s x\^ssmw|d3fx| delete up to and including the 3rd occurrences of x \^@u3Af\^w|d3e| delete up to the end of the third word OBSERVE due to Ctrl actually being a modifier, not a character \^s\^s would imply just one press of Ctrl and two presses of s, thus \^ss the R (CR) is because \^s is incremental search and you can add more characters, to end this search press e.g. CR. PS. I changed the CR to Ctrl-m instead, to not needing to lift the finger before pressing Ctrl-w. &gt; like elist power What is elist power? I have tried vi mode in emacs some time. PS. added a space after \^s before x as x was symbolising a string where control is not pressed.
I came into this topic to mention this :)
Friedman! One of the harder classes I took.
&gt; elist Sorry, I meant elisp. 
Awesome, thank you ! Freenet installed.
Use the extensions pareddit for Emacs that allows to remove block codes, always close parenthesis, match parenthesis, wrap parenthesis in the S-expression. Another useful extension is rainbow delimiters that keeps parenthesis in different deep levels at different colors that helps to visualize an s-expression. Emacs has also special key bindings to navigate lisp code that is useful to any lisp dialect, including Clojure. 
[Hi.](http://www.randomhacks.net/2002/09/13/hygienic-macros/) Also the reply by Daniel.
But the hygienic macros are more verbose and requires more code to write advanced macros and it seems that not all of them works in all scheme implementations. The classical macro also gives more control to the developer. Removing define-macro is a huge mistake in many implementations they should at least keep it. It is more simple: (define-macro (unless cond . sexps) `(if (not ,cond) (begin ,@sexps) )) than: (define-syntax unless (syntax-rules () ((unless condition body ...) (if (not condition) (begin body ...))))) A reader can easily spot what the macro does in the first case. Another advantage in the non-hygienic approach is that the developer can use functional programming to manipulate the code as a list. According to [Oleg Kiselyov](http://okmij.org/ftp/Scheme/macros.html) &gt; &gt; The syntax-rule macro system of R5RS does not seem to scale beyond simple macros. **It is very difficult to write macros that compose, to assemble complex macros from already written and tested components.** ... &gt; Syntax-rules are difficult to compose because of their evaluation order: the arguments of a macro-invocation are not expanded. That per se does not preclude functional composition since the normal-order lambda-calculus or non-strict languages like Haskell do not evaluate arguments of a function application either. ... 
It will break because this macro requires that each function or s-expression returns something and log will return nothing, if log returned the message passed it would work. This kind of macros are widely used in Clojure like: [-&gt;](https://clojuredocs.org/clojure.core/-%3E) It is similar to Ocaml Pipeline operator, however it doesn't need function calls every time the parameter is passed through the pipeline: Ocaml Pipe operator (|&gt;) &gt; 500 |&gt; (fun x -&gt; x * 2) |&gt; (fun x -&gt; x - 40) |&gt; print_int ;; 960- : unit = () &gt; If your code was (with the log function at the end): &gt; ($-&gt; 500 (* $ 2) (* $ 3) println ) 3000 &gt; It would work.
&gt; It will broke because this macro requires that each function or s-expression returns something You are right, my example was garbage. Please excuse my derp moment. Here's a better one: (define (symbol? s) (&lt; 0 (length (member s '("a" "b" "c"))))) ($-&gt; 500 (* $ 2) log (* $ 2)) 
I tested it in Gambit Scheme, here the results: **Gambit** It worked: (log here is logarithm) &gt; ($-&gt; 500 (* $ 2) log (* $ 2)) 13.815510557964274 &gt; Now it will break because you redefined the built-in function symbol? that will break any way: &gt; (define (symbol? s) (&lt; 0 (length (member s '("a" "b" "c"))))) &gt; ($-&gt; 500 (* $ 2) log (* $ 2)) *** ERROR -- (Argument 1) LIST expected (length #f) &gt; The redefined symbol will break: &gt; (symbol? 'dummy) *** ERROR IN symbol?, (console)@5.10 -- (Argument 1) LIST expected (length #f) 1&gt; **GNU Guile** scheme@(guile-user)&gt; (define (symbol? s) (&lt; 0 (length (member s '("a" "b" "c"))))) scheme@(guile-user)&gt; ($-&gt; 500 (* $ 2) log (* $ 2)) $2 = 13.815510557964274 scheme@(guile-user)&gt; GNU Guile protects the built-in functions from being overridden. Here one example of it in Clojure: user=&gt; (-&gt; 500 (* 2) (Math/log) (* 3)) 20.72326583694641 This macro will expand to: (* (Math/log (* 2 500)) 3) user=&gt; (* (Math/log (* 2 500)) 3) 20.72326583694641 user=&gt; 
&gt; Now it will break because you redefined the built-in function symbol? that will break any way: The point is that a hygienic macro doesn't break in that scenario. &gt; GNU Guile protects the built-in functions from being overridden. &gt; This macro will expand to: (* (Math/log (* 2 500)) 3) That's because both Guile and Clojure (unlike LISP!) transform defmacro into a hygienic version.
At a high level, variable capture is a very subtle, difficult problem and hygiene gets the default right. It should be easy to write simple macros that don't have problems with capture and you should have do a little more work when you're trying to be tricky and introduce intentional capture. I think the _real_ problem with hygienic macros is they aren't as immediately obvious as symbolic macros and we don't have a lot of easily accessible literature explaining them well. You should go read /u/elibarzilay's explanation of [hygienic racket macros for people coming from symbolic macrologies.](http://blog.racket-lang.org/2011/04/writing-syntax-case-macros.html) If you want to go a little deeper, I'd recommend Kent Dybvig's paper on [writing macros with syntax-case.](https://www.cs.indiana.edu/~dyb/pubs/tr356.pdf) Let's look at your two specific examples in racket though. We'll do `bind-cons` first because it's incredibly straightforward: #lang racket (define-syntax-rule (bind-cons (x . y) form body ...) (let* [(s form) (x (car s)) (y (cdr s))] body ...)) (bind-cons (x . y) '(9 . 8) (* x y)) ;=&gt; 72 (map (lambda (pair) (bind-cons (h . t) pair (* h t))) '((1 . 2) (3 . 4) (5 . 6))) ;=&gt; (list 2 12 30) We use `define-syntax-rule` to map a pattern to a template and everything just works because the syntax objects for your binding names are of the same scope as your body. Was that simple, practical, and intuitive? I'd say yes. I think it's even easier than your `define-macro` version because you don't need to manually destructure or worry about `gensym`ing to avoid capture. Your `letc` example is a little trickier, but only because pairwise grouping isn't naturally supported in the so called [macro-by-example destructuring format.](ftp://www.cs.indiana.edu/pub/techreports/TR206.pdf) #lang racket (define-syntax (letc stx) (define (pairwise lst) (reverse (let loop [(rest (syntax-&gt;list lst)) (acc '())] (cond [(null? rest) acc] [(null? (cdr rest)) (raise-syntax-error 'letc "no value for binding!" (car rest))] [else (loop (cddr rest) (cons (list (car rest) (cadr rest)) acc))])))) (syntax-case stx () [(k (b ...) body ...) (with-syntax [(bindings (datum-&gt;syntax #'k (pairwise #'(b ...))))] #'(let* bindings body ...))])) (letc [a 10 b (* a 10) c (+ a b 3)] (+ a b c)) ;=&gt; 223 (letc [a 10 b] (+ a b)) ;=&gt; letc: no value for binding! in: b First we introduce a function `pairwise` to take a flat list of syntax objects and group it into pairs of syntax objects. Next we use `syntax-case` to destructure the pattern with the flat list, `with-syntax` to create a new pattern variable called `bindings` that contains our groups in the same scope as the original `letc` keyword `#'k`, and dump things out with a simple template into a `let*`. The error checking also works nicely and highlights any offending imbalance in DrRacket. Was that less simple, practical, and intuitive than your example? I think it's fair to say yes, a little. You need to know more about the underlying machinery when you're doing something nonstandard. Of course if you wanted this to feel more standard, you could always write a `with-groupings` macro to hide the heavier lifting in `letc`: (define-syntax (letc stx) (syntax-case stx () [(_ (b ...) body ...) (with-groupings [(bindings #'(b ...))] #'(let* bindings body ...))])) While this is perhaps less immediately intuitive than using `define-syntax-rule`, I think it's very easy to read and comprehend for someone even passingly familiar with racket macros. So to reiterate, in my opinion, it comes down to a fundamental difference in philosophy. Hygienic macros want to make it harder to shoot yourself in the foot so they require more work when you're doing nonstandard things. Symbolic macros don't care if you shoot yourself in the foot so long as it's easy to pull the trigger - it's your responsibility to aim them carefully. -------- Edit: I thought it might be helpful to provide a rough table comparing the different facets of symbolic and hygienic macro systems. Note that this is more approximate than exact _(i.e., there's nothing about hygiene that requires patterns and templates, but most hygienic macro systems use them instead of `syntax-car`/`syntax-cdr`, etc.)_ and it's compiled off the top of my head. | Symbolic | Hygienic --------|--------|-------- operates on | lists | syntax objects destructuring | [extended lambda lists](http://clhs.lisp.se/Body/03_dd.htm), then manual | [patterns](http://www.scheme.com/tspl4/syntax.html#./syntax:h2) templating | backquote, unquote, splicing, ... | [templates](http://www.scheme.com/tspl4/syntax.html#./syntax:h2) macro defining macro ugliness | nested backquotes are tricky | `(... ...)` is verbose not capturing someone else's binding | `gensym` | _(hygiene)_ not having your bindings captured | [packages/namespaces](http://www.gigamonkeys.com/book/programming-in-the-large-packages-and-symbols.html) | _(hygiene)_ introducing a binding | _(auto, implicit)_ | `datum-&gt;syntax` _(explicit)_ running arbitrary code | _(auto)_ | `syntax-case` or a manual syntax transforming function scoping | dynamic _(but namespaced)_ | lexical source information | lost | preserved I think basic `syntax-rules` is the easiest to learn, followed by symbolic macros, and finally full hygienic macros. I find hygienic macros easier to use on a daily basis because I don't have to constantly worry about capture, lexical scoping is easier to reason about, and I get better error messages. Like all things in life, one option isn't categorically better than the other and you need to pick your preferred set of tradeoffs.
You're right, they aren't. Something like explicit or [implicit-renaming macros](http://wiki.call-cc.org/man/4/Macros) can give you hygiene while working at a very low level on lists akin to how `defmacro` works. Granted, the pattern matching of syntax-rules is incredibly powerful if you're willing to learn it, so I would recommend that, but low-level macros have their use too.
&gt; I can't understand the advantage of hygienic macros It's (mostly) a matter of abstraction, in determining meaning. Consider a simple function "f". In Scheme, variable scoping is lexical. So I can say for instance that these two expressions are equivalent -- they must "do" the same thing: (f (+ 1 2)) (let ((x (+ 1 2))) (f x)) In Scheme, my variable 'x' can't affect what 'f' computes. This differs from Common Lisp and other dynamically scoped languages - Matlab is another example. Defining 'x' could change what the 'f' function does. We might have called lexical scoping "hygienic scoping" and dynamic scoping "unhygienic". Likewise, suppose "m" is a hygienic macro. In that case, the following two expressions are still equivalent: (m (+ 1 2)) (let ((x (+ 1 2))) (m x)) Hygiene ensures that, even if the macro 'm' defines a variable named 'x', it's not the same variable 'x' that I've named. Just like how even if the function 'f' used a global variable 'x', it's not the same variable as the one I named in my 'let'.
Ok bind-cons works in Racket, that I know it is a superset of Scheme, but bind-cons doesn't work in many Scheme implementations, the only one that works is GNU Guile. The letc macro only works in Racket. I understood why Hygienic macros are necessary after read [Symple hygienic Lisp-1 macros](http://pereckerdal.com/2012/11/27/hygienic-lisp-1-macros-no-phd/) and [hygiene-versus-gensym](http://community.schemewiki.org/?hygiene-versus-gensym) but I don't know if they can do everything the "dirty macros" (define-macro) can. It seems that lack of standard namespaces in Scheme makes them unsafe unlike Clojure. Common Lisp makes the "dirty macros" safe by protecting standard functions and variables from be overridden in a let, flet or setq statement and also protects it with namespaces. (define-syntax-rule (bind-cons (x . y) form body ...) (let* [(s form) (x (car s)) (y (cdr s))] body ...)) Scheme implementations where bind-cons works. Scheme Implementation | Result :--|:--| | Racket | Ok | | Guile | Ok | | Mit Scheme | Not | | Chicken | Not | | Gambit | Not | | Bigloo | Not | | Gauche | Not | | Kawa | Not | | Scheme48 | Not | I tested the hygienic macro constructs that are available in the scheme implementations and not all of them are available as default in all implementations. Scheme Implementation|Executable|define-macro|define-syntax|syntax-rules|define-syntax-rule|datum-&amp;gt;syntax|syntax-case| :--|:--|:--|:--|:--|:--|:--|:--| Racket|racket|Not|Ok|Ok|Ok|Ok|Ok| Guile|guile|Ok|Ok|Ok|Ok|Ok|Not| Gambit|gsi|Ok|Not|Not|Not|Not|Not| Bigloo|bigloo|Ok|Ok|Ok|Not|Not|Not| Gauche|gosh|Ok|Ok|Ok|Not|Not|Not| Kawa|java -jar kawa.jar|Ok|Ok|Ok|Not|Ok|Ok| Mit Scheme|scheme|Not|Ok|Ok|Not|Not|Not| Chicken|csi|Not|Ok|Ok|Not|Not|Not| Scheme48|scheme48|Not|Ok|Ok|Not|Not|Not| Is it possible to something like that with hygienic macros ??? I tried it with Guile and it didn't work: (define-syntax dummy (syntax-rules () ((dummy body) (let ((i 10)) body)) )) scheme@(guile-user)&gt; (dummy (* i 10)) ;;; &lt;stdin&gt;:7:7: warning: possibly unbound variable `i' &lt;unnamed port&gt;:7:0: In procedure #&lt;procedure a18a3b0 at &lt;current input&gt;:7:0 ()&gt;: &lt;unnamed port&gt;:7:0: In procedure module-lookup: Unbound variable: i Entering a new prompt. Type `,bt' for a backtrace or `,q' to continue. And something like that ??? (define-macro (define-with-suffix name suffix value) (let ((new-name (string-&gt;symbol (string-append (symbol-&gt;string name) "-" (symbol-&gt;string suffix))))) `(define ,new-name ,value) )) Test in GNU Guile: scheme@(guile-user) [1]&gt; (define-with-suffix http get 10) scheme@(guile-user) [1]&gt; http-get $1 = 10 scheme@(guile-user) [1]&gt; Trying with syntax-rules in Guile: (define-syntax define-with-suffix (syntax-rules ((_ name suffix value) (define (string-&gt;symbol (string-append (symbol-&gt;string name) "-" (symbol-&gt;string suffix))) value ) ) )) Error: While compiling expression: ERROR: Syntax error: unknown file:24:2: syntax-case: invalid literals list in form (syntax-case x ((_ name suffix value) (define (string-&gt;symbol (string-append (symbol-&gt;string name) "-" (symbol-&gt;string suffix))) value))) 
We've raised a bit over $8,000 USD so far!
Pretty cool thanks
This is great advice, thank you. I will try this. Update: Works perfectly with `qemu-img convert -O qcow2`
IIUC you already have a `make` macro which, when the first argument is `block`, supports the clauses `center`, `size` and `material`; you do not want to modify this macro; you want to add clauses. Best of all would be to modify `make` using the full procedural macros facilities of Guile, but this path is for experts only. Without full procedural macros it is daunting to write an implementation with hygienic macros that allows any order for the input clauses. It may be that Guile has some facilities to write this kind of macros, but I do not know them. So let's start with this: we limit ourselves to `syntax-rules` macros and impose an order to the clauses. This is a script to try out: (import (rnrs)) ;;This macro allows easy definitions of clause's keywords. ;; (define-syntax define-auxiliary-syntaxes (syntax-rules () ((_ ?id) (define-syntax ?id (syntax-rules ()))) ((_ ?id . ?id*) (begin (define-syntax ?id (syntax-rules ())) (define-auxiliary-syntaxes . ?id*))) )) ;;These two forms mimic the original MAKE macro. You have to comment them out to ;;have the code work with your implementation. ;; (define-auxiliary-syntaxes block dielectric center size material index) (define-syntax make (syntax-rules (block center size material dielectric index) ((_ block (center ?xc ?yc) (size ?sx ?sy) (material ?expr)) (list 'block (list 'center ?xc ?yc) (list 'size ?sx ?sy) (list 'material ?expr))) ((_ dielectric (index ?expr)) (list 'dielectric (list 'index ?expr))) )) ;;Here is the new code. (define-auxiliary-syntaxes upperleft lowerright) (define-syntax make* (syntax-rules (block upperleft lowerright size material dielectric index) ((_ block (upperleft ?xul ?yul) (size ?sx ?sy) (material ?expr)) (let* ((sx ?sx) (sy ?sy) (xc (+ ?xul (/ sx 2))) (yc (+ ?yul (/ sy 2)))) (make block (center xc yc) (size sx sy) (material ?expr)))) ((_ block (lowerright ?xlr ?ylr) (size ?sx ?sy) (material ?expr)) (let* ((sx ?sx) (sy ?sy) (xc (- ?xlr (/ sx 2))) (yc (- ?ylr (/ sy 2)))) (make block (center xc yc) (size sx sy) (material ?expr)))) )) ;;Let's try it. (write (make block (center 1 2) (size 3 4) (material (make dielectric (index 5))))) (newline) (write (make* block (upperleft 1 2) (size 3 4) (material (make dielectric (index 5))))) (newline) (write (make* block (lowerright 1 2) (size 3 4) (material (make dielectric (index 5))))) (newline) Maybe you should go with `define-macro` style macros... 
Waouh, thanks a lot. Such a solution was clearly out of my reach. I just gave it a try and it seems good. I just had to change: (import (rnrs)) into (use-syntax (ice-9 syncase)) and it worked! Now I will try to add more clauses based on your code. Thank you again, you made my day! Cheers
OK, I tried to include it in a real simulation file and it seems to break all the existing macros in the script engine. It seems to come from the use of: (use-syntax (ice-9 syncase)) It seems to enforce syntax rules that the scripting engine is not following. I tried to use (import (rnrs)) instead, but I got a "Unbound variable: import". What am I missing? 
Without seeing the error message displayed when using `use-syntax` I cannot help. Maybe it is time for you to move this discussion on the Guile mailing list. 
The thing with use-syntax is that it seems to enforce some coding rules (like define should all appear at top-level, ...) that the script engine is not respecting, generating many errors: meep&gt; (define-param a 1) ; so far so good meep&gt; (use-syntax (ice-9 syncase)) meep&gt; (define-param b 1) ; does not work anymore ERROR: invalid context for definition of b ABORT: (misc-error) I investigated a bit further and found a solution: (use-modules (ice-9 syncase)) instead of (use-syntax (ice-9 syncase)) is working. I have no idea what is the key difference between the two! Thanks again for your help
Did anyone actually clicked the link? 
The page is gone, but I have these dates for those interested. Important Dates Paper deadline June 10th, 2016 Author notification July 8th, 2016 Camera-ready deadline July 31st, 2016 Workshop September 18th, 2016 I assume, eventually info will get posted at http://schemeworkshop.org/ 
&gt;I'm trying to write a program that makes a automated test of whether the input is a syntactically valid Scheme program. Doing this requires knowledge of Scheme. This might be a good one to save for later, if you don't have that knowledge yet. &gt; But for instance the compiler's response to "(5 2 3)" was to issue a warning and give a return code of 0. Erm...it issued a warning and returned 0. Isn't that a 'no'? &gt;And eval seems to want only one list. Think about this. Is there any way you could split a list of multiple functions into separate functions?
Thank you for the reply. &gt; Doing this requires knowledge of Scheme. Yes. I was hoping there was some library function, or relatively simple construction. One that I would not be coding. :-) &gt; Erm...it issued a warning and returned 0. Isn't that a 'no'? Yes, I am obviously not understsanding. I read a return code of 0 as being unix's way of saying "no error". Thanks again.
does it handle forms that submit multiple files?
Yes, and the parsing of multiform-data was optimized to handle larger files. I've tested uploading for 2G file.
Yes, that's the page it's supposed to be on :)
Maybe try Gambit.
(1) Scheme implementations usually have a vector data type. In guile scheme, there is the make-vector function. They are usually significantly faster than lists, and you can reserve their size/default values in advanced. I might be wrong, but I think vectors are required in R5RS (2) In Guile scheme, there are mutable data structures. Of course, you don't have to use them. Keep in mind that cons is side-effect free, and so many Lisp functions are just recursive list processing while consing together results. Also, most of the list building structures are side-effect free, like map, for-each, append, cons, etc. (3) Clojure is really great. You said you don't like syntax, and it definitely has more than most Lisps. Java isn't really that heavy weight, but you might not like the startup time. It supports concurrency so well out of the box, and simply can't be beat on that front. (4) Out of the box Guile does not have any mechanism to do graphics. However, a quick google reveals others have ported GTK to it. If you are really doing graphics intensive operations, Clojure might be your best bet since you can just use Swing libraries. Also, you might consider using some spreadsheet software to create data plots, if that's all you're doing. You can easily write code in Guile scheme that produces a CSV, open that up in Libre Office, and then create a chart. You said you don't like all the weight of the JVM, but your job might require that weight. If it doesn't, then I'd go with Guile Scheme. 
Why do you want green threads? In many implementations, green threads are co-operative and therefore cannot use multiple cores. You probably want a Scheme that uses native threads (and a suitable low-latency GC). In R6RS and up, pairs (lists) are immutable, by default, unless you load the (rnrs mutable-pairs (6)) library. 
I haven't programmed in Go, but for what I've read it seems much simpler than C++ and performance can be high in a big number of cases, maybe not in what I need...
With Clojure, I think (maybe I'm wrong) that sooner or later would have to deal with Java somehow (libraries, ...) and the JVM that seems daunting to me, due to its perceived (by me) complexity.
I've never worked with Stalin, but Chicken-Scheme is still being updated, and can compile. It also can interface with C code if you really need it. http://wiki.call-cc.org It looks like vectors are in SRFI-4 and multi-threading in SRFI-18. Chicken also has a growing library scene, called "eggs." This is the first matrix library that came up, but there seem to be a few more: http://wiki.call-cc.org/eggref/4/matrix-utils Edit: Foreign function interfacing is the easiest I've ever experienced, ever. Put all the functions you want to expose in some header file, install the bind egg, and do (bind* "#include \"exposed-functions.h\"") Edit#2: I'm illiterate. Chicken's implementation of srfi-18 is green threads.
Chicken is well-supported and the FFI is very good. Calling out to fast C/C++ numerics should be relatively easy. Chicken (last time I checked) works around the older assumption that hosting C compilers will not optimize tail-calls, when in fact clang does at -O3. 
You are right. Chicken doesn't depend on the compiler to optimize tail-calls. Rather it converts all functions to continuation passing style. Tail-call optimization happens as a side effect of the previous call having no active data and being garbage collected. It's pretty clever. http://wiki.call-cc.org/man/4/faq#why-does-a-loop-that-doesnt-consstill-trigger-garbage-collections
Maybe lush? It's used for ML and numerical stuff. lush.sourceForge. net
I'd say look at Rust (not a lisp/scheme), but the syntax is pretty brutal. Rust is all about concurrency and memory safety. It also is relatively C-like, but brings in a lot of concepts from functional languages like pattern matching and immutability. It's incredibly fast too.
That's the same thing and has the same implications that the op explained 
Here is one approach to functors in scheme: [http://mumble.net/~campbell/scheme/functor.scm](http://mumble.net/~campbell/scheme/functor.scm)
Here's a starting point: [http://t3x.org/s9fes/programp.scm.html](http://t3x.org/s9fes/programp.scm.html). It expects a program in S-expr form. To convert a program in string form to S-expr form, you would use [read-from-string](http://www.t3x.org/s9fes/read-from-string.scm.html).
You want/need native thread support (not green ones). So you will be forced towards Gambit and Chez. If you already have a good subset of C++, maybe you could embed Chibi and use it for scripting ?
There's no need to embed Scheme in a C program. This ends up making things more difficult with no payoff. Now output has to be passed from Scheme to C, which doesn't make sense because displaying output is not the bottleneck. Even then it would be easier and faster to call C output printing functions from inside Scheme. If output isn't passed from Scheme to C, then the embedding was pointless. What is the point of embedding if the code is just going to be this?: &gt;int main() { start_scheme_interpreter(); scheme_eval("script.ss"); return 0; } You also overestimate the difficulty of interfacing C code. In Chicken, interfacing some math library is as difficult as: &gt;(bind* "#include \""some_statistics_lib.h\"") EDIT: Removed strange grammatical errors
The idea of [Hom A? B?] is that is takes in two predicates (which form a category), and makes sure that x passes A?, and (f x) passes B?, then if that's fine, returns (f x) otherwise, the functor returns the empty category. This is a functor, no? It takes Scheme syntax to scheme syntax or to nothing. Hmmm... 
I'm not sure exactly what is all going on here. :P
I don't have the C++ code working well. OOP is not for me, that's why I'm looking for alternatives within the Lisp family. But I'm curious: what could Chibi do when embedded? What advantages could I get? Could you please give two or three examples? 
My scheme of choice is Racket, it has a speedyish typing system, albeit mostly static at the moment. 
that's an ML module 'functor' rather than a category theory 'functor'.
I think something like this might work: (define records '(("Person1" (65 60 65 67 62)) ("Person2" (67 62 67 74 57)))) (define (speeds record) (cadr record)) (define (avg record) (let ((ss (speeds record))) (/ (apply + ss) (length ss)))) (map avg records) ; =&gt; (319/5 327/5) ; If you want floating points: (map exact-&gt;inexact (map avg records)) ; =&gt; (63.8 65.4)
I think you just did OPs homework.
You could see another answer in http://epsilonwiki.free.fr/alphawiki_2/?view=average which could help you to write a very basic code in Scheme, writing a function list.sum, a function list.length (even if it exists as a primitive), a function list.avg, all things easy to understand step by step. I hope so.
Of all things that will be most difficult to give up from Clojure, data structures will be the most difficult. I'm considering converting to Clojurescript so I can just execute the code as embedded Javascript.
I embeded tinyscheme in a Qt/C++ project. Everything compiles, i have a repl.... But what next? Could you eleborate a bit on how to glue these two worlds together, to expose states and objects? 
It has been a while, but looking at my code it uses scheme_define to add C-functions that the scheme-code can call. Looks pretty straight-forward. Then I call scripts using scheme_load_file and scheme_load_string (the latter of course also for executing things from the REPL). I have a very thin C++ wrapper just to be able to pass around a Script object (and also because I was not sure at first about what scripting language to use, so I wanted an abstract way to do things; in fact I experimented with s7 a bit first before I switched to tinyscheme).
I was missing or didn't understood back then the part about "...uses scheme_define to add C-functions...". Thank you very much. Best regards!!!
Would an Electron based ClojureScript app be an option? To me this looks like a very appealing combo.
If so you should check: https://github.com/ducky427/electron-template https://github.com/Gonzih/cljs-electron https://github.com/karad/lein_template_descjop and this talk: https://www.youtube.com/watch?v=tBnu2JmK4p0
what do you mean by iteratively? Like a purely iterative solution with no recursive function calls?
yeah purely iterative although if not possible, partial recursion I suppose
Sounds like a homework problem, but if the list is only one level deep you could just implement a right fold with map
It's not really clear what you want. Do you want a random string, consisting of only `#\1` and `#\0`, like `"01100111110101"`? Do you want a list/array-like structure of random bytes, like `(35 186 14 ...)`? Or are you looking for something else? A small example using a placeholder for the random generation function might make it easier for someone to suggest what you could do.
Thank you for your time, I really appreciate the help. I'll post the program when I'm finally done with it.
Seems like a smart compiler could decide to replace (list-ref x 0) with (car x), but my guess is that (car x) is going to be faster, but they are going to have the same result unless you've modified one of them.
not sure how to interpret this. car refrences the first element in a list, list-ref is specified to refrence the first element of a list. Your example does two different things but give the same result?
*car* takes a cons cell as its argument. *list-ref* takes a proper list and a non-negative integer as its arguments. All proper lists are cons cells (*edit:* or the empty-list object), but not all cons cells are proper lists.
&gt; car refrences the first element in a list, list-ref is specified to refrence the first element of a list. Which is wrong. `car` references the first element of a *pair* while `list-ref` references the *nth* element of a *list*. &gt; Your example does two different things but give the same result? So does yours.
&gt; `list-ref` references the *nth* element of a *list*. Which is [wrong](http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list-ref%29%29) - `list-ref` as specified is quite happy with improper lists. It's not specified as such in R5RS, but think about implementation and O(n) ...
No, `list-ref` [doesn't mind an improper list](http://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list-ref%29%29). *okay, s48's `list-ref` does mind - but no other implementation I have on hand*
Racket differs from Scheme in that respect. R5RS 6.3.2.
The spammers are busy today.
You're asking a hard question to answer, because it's basically "here's some unformatted code. Please read it and improve it somehow." What does your code currently do? What's the next thing you want it to do? Or do you want help with the algorithm? You are probably best off taking the code you were given, then adding *one* feature and making it work. Then add one more feature, and repeat until you're done. That's usually easier than trying to make everything work at once.
&gt; (define student-advisor (lambda () (define repeat (lambda () (let ((input (read-list))) (if (not (equal? input ’(exit))) (begin (displayln (respond-to-input input)) (repeat)) (display "Thanks for using the student advisor. Goodbye!\n\n"))))) (display "\nWelcome to the student advisor!\n") (display "(To leave the conversation at any time, enter EXIT)\n\n") (displayln "Have you selected a major yet?") (let ((input (read-list))) (cond ((equal? ’() input) (displayln "Please enter your response.")) ((not (equal? input ’(exit))) (display "Go to respond-to-input.\n") (displayln (respond-to-input input))) (else (display "Hope you can reschedule your appointment soon. Goodbye!.\n\n"))) (cond ((not (equal? input ’(exit))) (repeat)))))) I can't even begin to read this. Can you? I hope the code you're working with has linebreaks in it. If you put four spaces at the beginning of each line, reddit will put the code in a monospaced font: (define (my-function val) (print val)) &gt; I'm trying to get it to try to perform the proper following step after it receives input. Like either respond with "please enter your response" if the input is equal to the list, exit if "exit" is entered," or "go to respond-to-input" if the list is not equal to the input. But I just keep getting an error involving the '() conditions for the input. If I add "yes" in to the parens, it will give me the response for when it equals, but then will still give me an error when it tries to look at the final cond listed. Not sure what is happening at this point. Can you give some code that reproduces this? I'm having trouble understanding what you want.
I was wondering how you got the monospaced font! Thanks for the heads up. I'm a reddit noob, as I'm sure it's obvious. Anyways, I edited the last reply with the spaces so it is actually organized. And yes, I have plenty of linebreaks in my code. Now that the code is organized, I'll try to explain what I mean better, as I think part of my problem is a lack of confidence in that I know what I'm trying to do. Before I start trying to match the user input to a list of example responses, I was hoping to figure out how to get the conditions to work properly. The other functions listed above the main function are used to turn the user input into a better format that is easier to use with the matching function. And if I'm understanding it correctly, the user input is put into the "read-list", which is then used to compare with another value in order to determine if the program exits, asks for another response, or sends the input to the respond-to-input matching function. Obviously the code won't work since I have the unknown function calls to "respond-to-input," but when I try to just have the program display confirmation messages to me so that I know that the proper conditions were met, I get a list of errors all involving the conditions with "not" in them. Example: (define student-advisor (lambda () (define repeat (lambda () (let ((input (read-list))) (if (not (equal? input ’(exit))) (begin (display "Go to respond-to-list.") (repeat)) (display "Thanks for using the student advisor. Goodbye!\n\n"))))) (display "\nWelcome to the student advisor!\n") (display "(To leave the conversation at any time, enter EXIT)\n\n") (displayln "Have you selected a major yet?") (let ((input (read-list))) (cond ((equal? ’() input) (displayln "Please enter your response.")) ((not (equal? input ’(exit))) (display "Go to respond-to-input.\n")) (else (display "Hope you can reschedule your appointment soon. Goodbye!.\n\n"))) (cond ((not (equal? input ’(exit))) (repeat)))))) And i get the errors: ;;; WARNING: compilation of /opt/homes/stu03/x576g772/test.scm failed: ;;; ERROR: Syntax error: ;;; unknown location: unexpected syntax in form () ice-9/boot-9.scm:543:29: In procedure map: ice-9/boot-9.scm:543:29: Syntax error: unknown location: unexpected syntax in form () Can't figure out what is causing this error, so I've been stuck here rather than moving on to trying to write a working match function. In case this helps make my end result any clearer, my match function progress and sample responses function are: (define respond-to-input (match input response-rules) (cond ((and (null? input) (null? response-rules)) #t) ((equal? input '(*)) #t) ((or (null? input) (null? response-rules)) #f) ((or (equal? (car input) '?) (equal? (car input) (car response-rules))) (match (cdr input) (cdr response-rules))) ((equal? (car input) '*) (cond ((match (cdr input) (cdr response-rules)) #t) ((match (cdr input) response-rules) #t) ((match input (cdr response-rules)) #t) (else #f))) (else#f)))) And: (define response-rules ’((() (Please enter your response.)) ((* hello *) (Nice to meet you.) (What is your name?)) ((* computer science *) (Have you taken the necessary math courses?) (When are you planning to graduate?) (Are you more interested in software or hardware?)) ((* engineering *) (What are your plans for your senior design project?) (What about engineering interests you?) (What type of engineering work would you like to do?)) ((* computers *) (Is that based on your own interest or because you feel required to?) (What interests you about computers?)) ((* i don’t know *) (Do you think there’s some way to find out?)) ((* you don’t know *) (That is probably true.) (Please tell me about %2.)) ((* if *) (Do you think its likely that %2?) (Do you wish that %2?) (What do you think about %2?)) ((* can you help *) (I may have some ideas if you can give me more details about your question.) (I will try to think of some ideas.)) ((* i want *) (Do you think %2 will help?) (How will that help you?)))) Thanks for bearing with me. I honestly feel like I'm making this more complicated than it needs to be. If I could just figure out how to get a simple program working that takes user input and figured out which responses apply, then I could probably get rid of a lot of the condition stuff.
The most basic builtins are embedded in the interpreter itself, written in the interpreter implementation language (either C or assembly) for practical and performance reasons.
Finally some good PR for scheme, and a website that is not hosted by a university or outdated, or Racket.
Nothing could get any better than [Structure and Implementation of Computer Programs](https://mitpress.mit.edu/sicp/) Once you get a hang of it, it just goes from there.
I've read 3/4 of SICP (and done 2/3 of the exercises), so I'm not starting from scratch. I was thinking more of a high-level overview of Guile, its API and what it has to offer over Racket, Chicken, etc.
Well, you _can_ implement it, very inefficiently, by doing something like ;; all arguments are now in `arguments` (case (length arguments) ((1) (fn (car arguments))) ((2) (fn (car arguments) (cadr arguments))) ...) and so on until the implementation's argument count limit.
Yes, it has to be provided by the implementation. Although I'm not completely sure, but something like this *might* work, although inefficiently: (define (apply fun args) (eval (map (lambda (x) (list 'quote x)) (cons fun args)))) As this will wrap everything in a quote, which will be unwrapped when evaluated. (Sorry if the indentation is off, I was on mobile) 
You paved the way for me but I found a much simpler way. (define (apply fun args) (eval (cons fun args))) edit: This still entirely answers the question though since I don't know how you would define eval 
Not sure that would work because things would end up being evaluated twice, e.g. if you passed in 'a, the function will be called with the value of the variable a rather than the symbol a itself. 
It doesn't work for me in Racket: #lang racket (define (bad-apply fun args) (eval (cons fun args) (make-base-namespace))) (define (good-apply fun args) (eval (map (lambda (x) (list 'quote x)) (cons fun args)) (make-base-namespace))) (display "This works: ") (display (good-apply list '(x y z))) (newline) (display "This errors: ") (display (bad-apply list '(x y z))) (newline)
&gt; (define (bad-apply fun args) (eval (cons fun args) (make-base-namespace))) Well that's really weird because I copy/pasted your bad-apply function as is and it works for me
Have you read it in SICP?
 (define (first-data obj) (if (compound-data? (first (rest obj))) (first (rest obj)) (first-data (rest obj)))) not really sure that i understand the data structure you are trying to query here (why the arbitrary nesting?), but something like that should work.
Define and use a ['flatten' function](http://rosettacode.org/wiki/Flatten_a_list#Scheme). ETA: The [Objective-C implementation of 'flatten'](http://rosettacode.org/wiki/Flatten_a_list#Objective-C) on that page is .... startling. 
While using an interpreter, I get a [panic] out of memory if the problem is too big. I was wondering if it's possible to augment the memory accessible while using the interpreter or if I will have to compile it. Thanks for the link I will make sure to look it up.
Bummer. I'm probably out then. :(
There are many free software game programming libraries for a variety of Lisps that you could try instead. The jam page has a good collection of them and other resources.
The lispgames.org links don't seem to be working. But really cool to see this. I'm implementing the card game love letter in clojurescript for a game development class this semester.
If only this weren't right before finals week for me... :/
Racket is great! *Any* Lisp dialect is fair game. One of our participants invented his own Lisp for an entry, and that's cool, too!
If you can suggest some appropriate Racket links to resources etc, I'll add them to the jam page. Let me know what you think
[**The Racket Graphical Interface Toolkit:**] (http://docs.racket-lang.org/gui/index.html) [**Racket games Examples:**] (http://docs.racket-lang.org/games/) [One thing that you can start playing with is **"planet cute"**] (http://docs.racket-lang.org/teachpack/2htdpPlanet_Cute_Images.html) [There's a **lightweight** library for writing simple graphical programs through 2htdp/universe. See: How to Design Worlds.] (http://world.cs.brown.edu/) [*Why John Carmack thinks Racket is aces for beginning programmers*] (http://www.itworld.com/article/2978142/development/why-john-carmack-thinks-racket-is-aces-for-beginning-programmers.html)
Wrong sub.
Well I don't know anything about chicken scheme's implementation but I'm willing to bet its interpreter's process doesn't allocate its heap to be your entire block of available memory. Even if the linked-list's pointer is an 8 byte pointer (most likely 4) it should only be 16 bytes or so per link. Even if it was a doubly-linked list, it would be 24 bytes per link. So I highly doubt you are using all 4 gigs of memory. Most likely the interpreter's process gets some static chunk of memory for the heap like 128 or 256 MB. Look into chicken scheme's documentation for a way to increase it. You might have to run your function as its own thread or process where you specify the stack size. 
This article shows how lists are stored in memory in Lisp, Scheme, etc. In addition to the data, they have to store the structure of the data. Even if the data is entirely linear, they have to store structure information in case additional dimensions are added later. http://www.pavley.com/2015/09/01/lisp-cons-cell-and-list-cheat-sheet/
I'm using tail recursion. The exact error I get is : [panic] out of memory - heap full - execution terminated edit: It does say in the doc only half my heap is used at any given time though. 
Are you confident that an infinite loop isn't happening? Do you know if gambit optimizes tail calls?
I believe his numbers are for whole pairs :both data and links. So you'd have 40 million times your 48 bytes i in 64 bits. Plus any overhead of the memory management and dynamic usage on the interpreter itself. 
Also worth considering -- using a vector instead of a list for the whole thing. It should cut the number of pointers in half.
Does compiling to C/C++ preclude image-based development?
[removed]
i think many people are going to read this as "Best (existing) successor to Scheme". i do not think there exists a successor to scheme or that there necessarily needs to be one. there are modern implementations that can be exciting and are actively developed. for improvement i could think of a modified scheme, but still basically scheme.
One of the things I love about Scheme is that there is almost no language feature you can’t add to it yourself. Or find an existing Scheme implementation of. So, there’s not as much need to learn a new language to explore further if you already like Scheme.
Why? So implementations can finally stop chasing the moving target?
Isn't that Racket?
Please do your own homework instead of bothering us for it.
I will check this project out tonight. Thanks for sharing!
I will put in my 2 cents. Readability. Not much different from the non-esoteric languages, once you get used to parentheses. With the correct indentation: most simple programs look very readable. Once you add error handling: it becomes the usual mess. A wise use of macros can be very effective, both in the small (allowing the implementation of new control statements) and in the large (with domain specific languages and high-level syntaxes). Writability. You need a good and customisable editor, with a Scheme mode, as usual. Reliability. Once the program grows non-small: you really, really miss static type checking. I will not discuss implementations. 
In other words, you're asking us to do your homework for you. Your homework assignment doesn't look like it was some kind of survey of practitioners. You were undoubtedly asked to evaluate those things YOURSELF. Instead of doing it YOURSELF, you asked a bunch of people on the web to do your work for you. This isn't the only [group to which you posted this crap](https://www.reddit.com/r/lisp/comments/4e9dim/what_is_your_opinion_on_the_readability/), and you were called out elsewhere for it too. If you were my student, I'd fail you. Learn some integrity now.
thanks :)
I've never played a MUD, so I'm not sure if this is helpful. "[Creating Languages in Racket](http://cacm.acm.org/magazines/2012/1/144809-creating-languages-in-racket/fulltext)" by Matthew Flatt develops a small text adventure game to show off some of Racket's features. 
This is a very nice blog series on a Rogue-like game in Racket: https://blog.jverkamp.com/2013/03/12/the-house-on-the-hill-day-1/#more-4112 Unrelated (but new to me) a mud implemented in WorldScheme: https://code.google.com/archive/p/worldtm/ 
(eval (car test))
Thanks, but I'm not doing something right. (define test '(pi 1 1 1 1)) (eval (car test)) gives me this error pi: unbound identifier; also, no #%top syntax transformer is bound in: pi. 
The Clojure initiative is called [Arcadia](https://github.com/arcadia-unity/Arcadia).
I wonder what this means for Dybvig? That he got bored with hacking on his thirty-year-old-plus project? Or was it really Cisco's call-- I know that they bought Chez lock, stock, and smoking barrel a few years ago. Either way, awesome. Looking forward to reading the code for inspiration.
Indeed, I feel conflicted reading this. I hope he landed well in this deal but I can't wait to clone the repo and dig in.
Looks like he's making new commits, so I doubt he's done with it.
Is this the original chez scheme source code or one that is heavily modified just for open source purpose? Could someone used it before elaborate on it?
For what kind of applications is Chez Scheme a good fit? 
&gt; someone said that chez switched to the nanopass framework so it is slower now. any source (link?) of this? I have heard that chez scheme can compile itself in 5 seconds. after some test, I feel this open source version is not that fast.
Finally I can point to something more practical than Harlan as a showcase for Nanopass.
(define (average l) (/ (apply + (cdr l)) (length (cdr l)) ) ) would work for one person. If you want to do it for a list of persons: (define (averages l) (map average l))
Run make in that directory?
~/stex/Mf-stex: No such file or directory Hope it could be fixed.
With something like this, I think : (let* ( (initialised-var init) ...) (let loop ( (var initialised-var) ...) (if test result (begin body (let* ( (var step) ...) (loop var ...)))))) It should not be too hard to turn that into a macro if needed. 
 (define-syntax DO* (syntax-rules () ((_ ((i &lt;init&gt; &lt;next&gt;) ...) (&lt;terminate?&gt; &lt;result&gt; ...) &lt;body&gt; ...) (letrec ((loop (lambda (i ...) (cond (&lt;terminate?&gt; &lt;result&gt; ...) (else &lt;body&gt; ... (let* ((i &lt;next&gt;) ...) (loop i ...))))))) (let* ((i &lt;init&gt;) ...) (loop i ...)))))) 
Two more from the net (caveat lector or whatever): (define-syntax do* (syntax-rules () ((do* ((var0 init0 step0) ...) (test expr0 ...) command0 ...) (let* ((var0 init0) ...) (let loop ((var0 var0) ...) (if test (begin expr0 ...) (begin command0 ... (set! var0 step0) ... (loop var0 ...)))))))) (define-macro (do* spec end . body) `(let* (,@(map (lambda (var) (list (car var) (cadr var))) spec)) (do () ,end ,@body ,@(map (lambda (var) (if (pair? (cddr var)) `(set! ,(car var) ,(caddr var)) (values))) spec)))) |
Thank you to everyone for the help. I shall think about all the answers. I appreciate it.
Thanks!
No Racket?
It seems weird to have an average when not all the implementations actually run all the benchmarks. Also, how did you run R7 code on Chez?
Kent Dybvig has one in the exercises at the end of his Scheme book. It's very short. SICP by Abelson and Sussman tells much about building interpreters and compilers. You could also look at _Essentials of Programming Languages_ by Dan Friedman and _Lisp in Small Pieces_ by Christian Queinnec for book-length treatments of Scheme interpreters.
My understanding is that those benchmarks are not very representative of typical useful programs (the visualization is nice, though, and I very much like the color palette). They are mostly fairly small programs exercising in a disproportionate way a single feature or performance aspect of the language (such as `call/cc`, or input/output): they are micro-benchmarks rather than macro-benchmarks. This is useful for language implementors to know where they stand, performance-wise, on specific features, but it does not give a realistic view of how fast actual programs are going to run on these implementations -- except maybe on specialized problem domains that exercise a single corner of the language, such as tight numerical loops. What are large programs that take time to run and do a variety of different things? For user decision-making, it would be very important to also have a benchmarks of those. I suspect, however, than many of those programs will not be R6RS-compliant; for example, Racket has realistic programs that are interesting for users to benchmark, but they typically use advanced/incompatible module system features. I think it would be interesting to look for such larger benchmarks; if they are not R6RS compliant, try to port them on the implementations which support similar extended features, or even to all implementations.
Gabriel said as much, in his book that introduced the benchmarks (*Performance and Evaluation of Lisp Systems*). &gt; Benchmarking is a black art at best. Stating the results of a particular benchmark on two Lisp systems usually causes people to believe that a blanket statement ranking the systems in question is being made. The proper role of benchmarking is to measure various dimensions of Lisp system performance and to order those systems along each of those dimensions. At that point, informed users will be able to choose a system that meets their requirements or will be able to tune their programming style to the performance profile. and &gt; Benchmarking and analysis of implementations will be viewed as complementary aspects in the comparison of Lisps: benchmarking without analysis is as useless as analysis without benchmarking.
That seems very sensible. My point was not really to criticize the use of micro-benchmarks, but also to suggest that another set of benchmarks could be interesting. It is very hard in general to find good macro-benchmarks, but it is my understanding that some actually exist within the communities of Scheme and its dialects -- I'm not very familiar with it, so apologies for not giving many direct examples. For example, the [Pycket](http://soft-dev.org/pubs/pdf/baumann_et_al__pycket_a_tracing_jit_for_a_functional_language.pdf) paper mentions two macro-benchmarks ("ODE" and "binomial" in Table 1), the first being an Ordinary Differential Equation solver, the second a trace replay of a computer-vision application. I understand that porting them to run on Chez or Larceny (for example) would be work, but it would also give a fairly interesting insight over the performance difference on realistic applications.
Just looking at what you wrote it would appear you forgot the 'm'
I'd be interested in seeing **stalin** on the list.
Yeah, I've been wondering about that myself. In Andy Keep's [PhD dissertation](http://andykeep.com/pubs/dissertation.pdf) from 2012, he mentions that before nanopass, Chez Scheme could compile itself in 3 seconds on contemporary hardware. They had the overall goal that nanopass would not make anything more than 2x as slow, and they cite extensive benchmarks where they claim they achieved that, with compilation times generally being about 1.7x of the old compiler. (Though note that they also rewrote the register allocator and use a more expensive, but better, algorithm now.) So it's surprising to me that (using my 2012 Macbook) it takes ~25s to bootstrap the full Scheme source. (The main nanopass file, cpnanopass.ss, takes about 15s of that.) Bootstrapping everything, including the C code, takes about 65s, which their README indicates is typical. So it seems to me that either that initial claim is *quite* misleading, like "it can compile this one core module in 3 seconds", or their claim about the compilation speed doesn't cover *the compiler itself* (again, very misleading), or it's just plain nonsense. (And I mean, they didn't release any actual code of their measurements back then, so their concrete timing results were always suspect by default for me anyway.) Still, overall that's not *too* bad, especially given that the nanopass stuff does no pass fusion or serious optimization at the moment, so that's not any serious evidence against the approach as such. I find it more concerning that it goes through &gt;1GB of memory during compilation. Harlan (using nanopass too) also has that problem, noting that it takes &gt;3GB of RAM to bootstrap, I think. But then it's Scheme, what do you expect, really.
That, and shouldn't `display` be used instead of `write`? 
Yay, it works. Thanks a lot.
It's usually that you have to turn off line buffering. I know nothing about Larceny, but check the stdio functions for buffering modes.
Seconding the SICP recommendation. OP probably wants to read chapter 4 of SICP, which explains a very short Lisp implementation, and then subtly modifying it and adding unique features.
Thanks for that info. The guy who wrote that issue made this: https://github.com/michaelballantyne/homebrew-chez
Messing around with the compiler got me down to 23 seconds. Still not as fast but decent
If you were to use call/cc to make the continuation passing explicit would it help the compiler? I'm new to this so I could be way off. 
Thanks for the info. 
 10.46s CPU time, 0.542s GC time (major), 344/22887 GCs (major/minor) Very nice. I didn't realize the fixnum procedures would speed it up so much. Brought it to around a second slower than the algorithm I linked in the OP! 9.206s CPU time, 0.408s GC time (major), 355/15704 GCs (major/minor) Would you mind me asking what **(declare(pure ...))** does?
&gt; Would you mind me asking what *(declare (pure ...))* does? The answer to that is on the wiki :) http://wiki.call-cc.org/man/4/Declarations#pure As for the code, doing the same optimizations as above, I managed to get it down to the following on my machine: 8.673s CPU time, 0.449s GC time (major), 362/29908 GCs (major/minor) Arguably though, I have some concerns about your code, going beyond what was stated above. `enumerate_list` is really just a call to `iota` from SRFI-1. And your call to `(list (car x) (car (cdr x)))` should be `(take x 2)`, again from SRFI-1. What's more, why are you writing a prime sieve that way? Would a sieve of Eratosthenes not be a better way? It's kind of sad to see CHICKEN getting judged here for what is IMO some poorly written code. Anyways, good luck in learning Scheme, I don't mean any of this as a shot at you personally. If anything, this should go to show you that not all performance problems are clear, and you need to consider the problem carefully if you want to optimize.
I totally agree. It's terrible code. I was just trying to mess around with continuation passing style for the first time. The reason it started is that I had found the sieve code from the first link I posted and it was running faster on racket than chicken which didn't see to make sense to me. I've learned a lot already just by going through all this. Thanks for mentioning your critiques, I'm just trying to get better at scheme and programming in general. I was not trying to judge the merits of each scheme implementation by my code but I suppose that is how it came across. EDIT: Made changes you suggested and it looks much better. I'll have to take a look through the SRFI's to see what's available.
Once again, thanks! I'll go through those SFRI's you mentioned. I agree with the benchmarking; it does take a lot more to get a comprehensive comparison.
Stalin is dead and stone cold, right? 
If your compiling issues are related to X11.h, you just have edit one of the files to correct the include directive. Was the only problem I ran into when compiling it on OS X, so let me know if you had the same one.
This is how it's defined in my Interpretation of Computer Programs class: (define (apply procedure arguments) (cond ((primitive-procedure? procedure) (apply-primitive-procedure procedure arguments)) ((compound-procedure? procedure) (eval-sequence (procedure-body procedure) (extend-environment (procedure-parameters procedure) arguments (procedure-environment procedure)))) (else (error "Unknown procedure type -- APPLY" procedure)))) It's part of a meta-circular evaluator, and as the class name suggests, based on the one found in Structure and Interpretation of Computer Programs.
Well, it's not written in C nor does it require GCC to run, so there's that. If it were a LuaJIT- or Corman Lisp-style dynamic library to boot, I'd be in heaven.
Why would it be a disadvantage that it is written in C? I just wanted to write that you do not need GCC / Clang with Chicken to use it, only for deployment. How ever all extensions you would pull, and which you will do at some point, would require so, and I am pretty sure that same will be with Chez. One real benefit between Chez and Chicken would be real-threads against green ones. 
You can also try this [short and witty] lambda paper "The Art of the Interpreter or, the Modularity Complex" by Steele and Sussman -- eg here http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-453.pdf -- it's about implementing variants of lisp differing in scoping policy. Highly recommended! (No macros mentioned though.) Holding thumbs for your compiler, good luck and have fun!
the fuck?! you cant be serious dawg!! `((lambda (&lt;var1&gt; ...&lt;varn&gt;) &lt;body&gt;) &lt;exp1&gt; ... &lt;expn&gt;)` so dank
It's easier to see bindings here (let ([var value]) ;;; 600 lines of code ) than here. ((lambda (var) ;;; 600 lines of code ) value) 
I believe so. R7RS is split into two portions, a small/minimal spec of scheme which is complete and can be found at http://trac.sacrideo.us/wg/wiki/R7RSHomePage and the large spec mention in the OP. 
No...it's a simple and clear function. You don't have to use it, but some prefer it.
http://letoverlambda.com/
lol!!!
holy shit thats pretty awesome haha!
Using a named let allows you to do recursion, while for lambda you have to use the Y combinator for recursion.
OP, you seem either stoned or drunk
haha, I remember that
what would you expect from a lisp weirdo?
don't forget the much useful named let, let* and letrec
Copy allocation could fail with essentially anything that allocates, even if it's purely functional cons allocation. 
hey there :) I was also looking at [chibi scheme](http://synthcode.com/scheme/chibi/), with some [nice docs](http://synthcode.com/scheme/chibi/#h2_EmbeddinginC), will take a look into chicken scheme as well. 
Green or native threads? Apparently Gambit is super good at green threads and has the best FFI for C and C++.
Why do you say it is "clearly wrong" ? Apparently, the expansion transformed your (if ...) form to an (and ...), but the semantics are correct.
Yep agree with that. I'm just a bit confused why Guile's macro transformer decided to do that 'optimisation', when I thought its responsibility would be just to transform the lanuage. Like in that article there's the following point: &gt;when Scheme is applying the syntax-rules rewrite there is NO SEMANTIC MEANING attached to the tokens. The meaning will be attached at a later point in the process, but not here. And the fact that my Guile setup is doing this is throwing me off. At any rate, I think being able to examine what macros are currently defined in the Guile environment would is a useful thing.
Hi a_Tick - thanks for your reply. I get the same output as you for Guile 2.0.11: #&lt;tree-il (if (apply (toplevel negative?) (toplevel x)) (begin (apply (toplevel newline)) (apply (toplevel display) (const "Bad number: negative."))) (const #f))&gt; The previous way I was expanding it was using (use-modules (language tree-il)) (tree-il-&gt;scheme (macroexpand '(testwhen (negative? x) (newline) (display "Bad number: negative.")))) Which gave: (and (negative? x) (begin (newline) (display "Bad number: negative."))) I tried using Geiser's macro expand as well, which gave the same output as above. I wonder why these two methods differ? Any tips you could give for debugging/developing macros generally :) 
OP here. I set up a Jenkins server for building various branches/tags directly from Guile's git repository. Standalone deployable .zip archives can be downloaded from each build. The build process also runs the testsuite.
The point with Jenkins is that you'll never have to use MinGW. Guile is built for you :p Just download the finished binaries.
Hmmm, interesting. I was hoping it would be something surmountable but that's a pretty steep incompatibility. Thanks for answering.
Thank you! I'll definitely give those a read. By the way, what implementation of scheme (or common lisp?) do you use/would recommend? I picked up guile pretty arbitrarily to learn scheme, but am now wondering whether to switch to Racket for the less terse documentation.
I'd recommend [Chicken Scheme](https://www.call-cc.org/) 
 (define p (with-input-from-string "((x 7) (y 4))" read)) 
I just noticed that too -- I assumed it was in r5rs. 
Thank you. I was trying to stick to R5RS, just to stick to some standard, and so I thought I could do that by writing out to a file, and then reading back in, which I think is along these lines, but I was unable to get that to work. To be precise: ;; rw (define FN "fn.scm") (define (rw s) (define myfile (open-output-file FN)) (display s myfile) (load FN) (close-output-port myfile)) Here, *less fn.scm* gives this. (define pe '((incr r1)(loop r1 (incr r0)))) (The contents of the list is a long story.) I get "Error: unbound variable: pe" when I ask for (write pe) (newline) 
I personally prefer the former syntax (i.e. without explicit lambda). Moreover, following Structure and Interpretation of Classical Mechanics (co-authored by Gerald Sussman), I prefer (define ((f x) y) (list x y)) to (define f (lambda (x) (lambda (y) (list x y)))) because it is more concise and easier to analyze in terms of the substitution model of computation -- definiendum simply gets replaced with definiens. Also, it allows to use preposition/role comments before the function arguments, making their order easier to memoize: (define (alter #;element-number n #;in list #;with replacement) (if (= n 0) `(,replacement . ,(cdr list)) `(,(car list) . ,(alter #;element-number (- n 1) #;in (cdr list) #;with replacement)))) 
I think the explicit `lambda` form is useful for pedagogical purposes, since it emphasizes that the function is just another `define` like any other variable, the value just happens to be a lambda. When teaching Scheme, I think it is definitely best to introduce this first, and only later reveal the sugar. That way, students know it's just that: sugar. This is especially important since most students these days unfortunately start by blindly copying and pasting boilerplate in more cumbersome languages, which starts a nasty habit of not understanding, or even caring to understand, what they have written. That said, elegant though the uniform `define` approach may be, in practice, the extra indentation and parentheses is just unnecessary syntactic bloat, so I embrace the sugar.
I had a very brief stint with cSound but I found it to be verbose and far too complex for my needs. I've seen Supercollider and it did look good but I never got around to trying it. I think it might be worth me giving it another go, thanks for reminding me! :D
yeah i had the same sentiments with them as well. very steep learning curve 
&gt; Structure and Interpretation of Classical Mechanics https://www.google.com/imgres?imgurl=http://t0.gstatic.com/images%3Fq%3Dtbn:ANd9GcSF_JaHYa2ucWn6brIJdefRF1fHoeSLQHAfh7sA_QqjrcZND4jX&amp;imgrefurl=http://books.google.com/books/about/Structure_and_Interpretation_of_Classica.html%3Fid%3Da4-pBgAAQBAJ%26source%3Dkp_cover&amp;h=648&amp;w=436&amp;tbnid=DGha8Ah4Lhhx-M:&amp;tbnh=160&amp;tbnw=107&amp;docid=PfFRd828o_YDzM&amp;itg=1&amp;usg=__EwZEN1B-Ewm1A0Yk1ymABKV8GaQ=
Yeah, I know what he's talking about. Though I thought he meant SICP. Didn't realise SICM had any lisp relevance.
Where have you been learning how to implement this? Or are you already experienced in implementing languages?
Wrong scheme.
better a schemer than a spammer
Congrats! How is it compatible with R5RS at the moment?
Sadly we're a dying breed, but I will wield my father's parenthesis till I die. Elegant weapons, for a more civilized age. 
It can't even do hello world yet. There is a reason I said "very incomplete". It is missing: - A reader - A printer - I/O builtins - function objects In what order should I add these features? Note that the bytecode compiler is written in Scheme, and heavily uses lambdas, so it will be a while before I can get a REPL. Full R5RS compliance is the goal though.
I would suggest to take a look at Norvig's lispy. It is very simple and easy to understand. Once you get the idea, just refactor and extend it and make your own. Start with Reader. It gets a string/input stream as an input, tokenizes it and returns a list of tokens (AST nodes or S-expressions in our case). And that's it! Lisp "syntax" is very simple. My Reader has the following methods (just for a reference): read (main method), nextToken (gets next token from input), readAtom, readHash (reads all tokens that start with #: chars, vectors, booleans etc.), readQuote, readQuasiquote, readIdentifier, readComment, readNumber, readString, readCharacter, readList, readVector (+ some helper methods). See that basically you have a separate read method for each expression type. Note that it is common for one function to call another and so on. For example, reading a vector goes like: read -&gt; nextToken -&gt; readHash -&gt; readVector -&gt; readList (because vector is just a list that starts with #, so we read them the same way) -&gt; then call nextToken multiple times until list ends, then meet EOF or line end - and we are done. Also, in Java I am using so-called PushbackReader (https://docs.oracle.com/javase/7/docs/api/java/io/PushbackReader.html). It allows you to to push characters back into stream, which allows you to have a 'peek' (common and useful method for Readers). Also, readQuote and readQuasiquote methods are used to read short-hand versions (because they have special syntax). readQuote, for example, reads form 'expr and returns list of 2 elements: 'quote' and 'expr'. Look at some examples, read theory about Recursive Descent Parsers (that is what you are going to implement). When you are done with Reader, start making Evaluator (The Metacircular Evaluator). You may need to make your own Type system and so on. Good luck and have fun! PS: Racket docs are great and very useful (be careful, they have separate docs for r5rs and racket): https://docs.racket-lang.org/ PPS: I highly recommend you to start writing Unit Tests now! They are extremely helpful and it will be difficult to write them later. 
Good overview .. but you missed Gambit-C
You read these ? http://peter.michaux.ca/articles/scheme-from-scratch-introduction
&gt; Unlike previous Cheney on the MTA compilers Compiler**s**? I was unaware of any other than Chicken. I mean, I thought that was Chicken's great claim to fame: the only implementation of Baker's wacky idea.
scheme should never be large at all. It should just have byte vectors and ffi in the report - SRFI is clearly not enough. That way, wrappers to thousands of native libs could be common among all scheme implementations - wrapper libs is what scripting languages such as python offer a clear edge over scheme. well, at least assuming implementations all agree on the same library/module/whatever importing and exporting conventions too... 
Gauche calls it begin0 for some reason. And so does Racket, apparently. Also, what about multiple values?
I'm wondering now, isn't (lambda ( . x) x)) equivalent to (lambda x x)? This version seems to work, though. Native implementations could be expected to be faster, but this should have the right semantics, too.
&gt; I'm not actually sure if (lambda ( . x) x) is guaranteed to work by the standard; It's not. If you want standard, you want `(lambda x x)` as jakub_h mentioned. Here's R5RS (the text in R{4,6,7}RS is similar, and the rules are the same): &gt; 4.1.4 Procedures &gt; syntax: `(lambda &lt;formals&gt; &lt;body&gt;)` &gt; Syntax: `&lt;Formals&gt;` should be a formal arguments list as described below, and `&lt;body&gt;` should be a sequence of one or more expressions. &gt; ... &gt; &lt;Formals&gt; should have one of the following forms: &gt; * `(&lt;variable1&gt; ...)`: The procedure takes a fixed number of arguments; when the procedure is called, the arguments will be stored in the bindings of the corresponding variables. &gt; * `&lt;variable&gt;`: The procedure takes any number of arguments; when the procedure is called, the sequence of actual arguments is converted into a newly allocated list, and the list is stored in the binding of the `&lt;variable&gt;`. &gt; * `(&lt;variable1&gt; ... &lt;variablen&gt; . &lt;variablen+1&gt;)`: If a space-delimited period precedes the last variable, then the procedure takes `n` or more arguments, where `n` is the number of formal arguments before the period (**there must be at least one**). The value stored in the binding of the last variable will be a newly allocated list of the actual arguments left over after all the other actual arguments have been matched up against the other formal arguments. &gt; It is an error for a `&lt;variable&gt;` to appear more than once in `&lt;formals&gt;`. (**emphasis** mine) Source: http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.4
&gt;It's not. I pointed this out in the last line of the comment to which you're responding, though I only checked R5RS. I'm assuming from Guile's documentation that this is an error on their part. I'll have to check their newest version to see if this has been fixed. I wonder what scheme jakub_h checked against, as he said it worked there as well.
The Guile documentation says the same thing as the standard. You'll likely find that it's *very* common among Scheme implementations that they deviate from the standard in such ways. You have two options: you can write programs that conform to the standard, or you can write programs that are accepted by a particular implementation. One way isn't necessarily better than the other -- in fact, the Scheme standard is so meager that it's often impossible to stick to the standard 100%, and you'll likely wind up implementation-bound in one way or another. If you prefer having an `&amp;rest` keyword, you can, of course, have your cake and eat it, too, with a suitable macro :) (Just for fun, I wrote one. I don't mean to imply that you're so attached to `&amp;rest`, but it seemed like a fun little challenge and I couldn't resist ;) ) ;; Helper macro since recursive syntax-rules macros can only be tail-recursive (define-syntax aux-lambda (syntax-rules (&amp;rest) ((_ () (&amp;rest var) body ...) (lambda var body ...)) ((_ (args ...) (&amp;rest var) body ...) (lambda (args ... . var) body ...)) ((_ (args ...) () body ...) (lambda (args ...) body ...)) ((_ (argz ...) (arg args ...) body ...) (aux-lambda (argz ... arg) (args ...) body ...)))) ;; Same as `lambda`, but accepts `&amp;rest` ahead of a rest parameter (define-syntax kw-lambda (syntax-rules () ((_ (args ...) body ...) (aux-lambda () (args ...) body ...)))) ;; Test... (define println (kw-lambda (&amp;rest args) (do ((args args (cdr args))) ((null? args) (newline)) (display (car args)) (display " ")))) (define funcall (kw-lambda (f &amp;rest args) (apply f args))) (funcall println 'this 'is 'a 'test '!) 
Another way to write `(lambda x x)` is `list`
Welp. *One more search* turned it up, finally. Something that doesn't just point to the documentation page (which really ought to have a link to the source pages). Here it is, answering my own question: https://ccrma.stanford.edu/software/snd/ 
The list notation itself is a shorthand for recursive cons applications. The dot is simply a part of that shorthand notation that gets seldom used. There's no reason for the dot to be considered on the same level as the actual elements, since it's a notation and can afford to be arbitrary. You'd need *some* way to say "oh, and BTW, don't put an empty list into the last cdr, put there this instead, please" anyway. Or at least that's how I've always viewed it.
I'm sure you're right, but having gotten used to the prefix notation, the dot in the middle looks as odd as seeing (2 + 2) would.
The way I like to think of it is that not having the '.' is the special situation. The pedantic syntax for the list '(1 2 3 4 5) is: '(1 . (2 . (3 . (4 . (5 . ()))))). But that's so verbose, we've made it legal to use the abbreviated form '(1 2 3 4 5) instead. Note an interesting thing about this shortened form - it does not explicitly state what's in the cdr of the last cons cell in the list. You can write a slightly less abbreviated form to explicitly point that out if you want: '(1 2 3 4 5 . ()). Now, if you want something that doesn't have a nil in that last cons cell, you can't use the full abbreviation - because it implicitly specifies what that last cdr has in it. But you can use the slightly less concise form: '(1 2 3 4 5 . 6). That's still smaller than the full-blown pedantic form.
That doesn't answer the question though (which is a really good one). Why is the long form not '( . 1 ( . 2 ( . 3 ())))? Why do we have one infix operator when all other are prefix?
It does look like infix notation in the one special case of only two elements. With three or more elements it is clear that it is a special notation that only applies to the last element: (1 2 . 3) I suppose they could have used (. 1 2 3) to mean the same thing. But, personally, I think it is already confusing enough that special forms and function application use the exact same syntax. I like that this doesn’t.
In what you're proposing, the parentheses are a binary operator/construct so the dot is redundant.