So, what we have to do is have a generator function which generates a checker and the checker is defined by passing the generator. The generator takes in a list of words and a list of functions, all the functions should work with all the words and whatever results we get, we store them in a list. Then, the checker is built with the list of functions and list of words by generator function. The checker takes in a word as a parameter and works with the list of functions and checks if they are in the list we created. Now, I don’t seem to be able to store the values as I go and return a checker with that list. The code I posted just returns a function which checks if the word is present in the list. 
So, what we have to do is have a generator function which generates a checker and the checker is defined by passing the generator. The generator takes in a list of words and a list of functions, all the functions should work with all the words and whatever results we get, we store them in a list. Then, the checker is built with the list of functions and list of words by generator function. The checker takes in a word as a parameter and works with the list of functions and checks if they are in the list we created. Now, I don’t seem to be able to store the values as I go and return a checker with that list. The code I posted just returns a function which checks if the word is present in the list. 
&gt;Thanks for your help. &gt; &gt;(define dude &gt; &gt;(lambda (hash1 dictionary) &gt; &gt;(define x '()) &gt; &gt;(define y (cons (list-ref dictionary 1) x)) ;; defining a new list here &gt; &gt;(define newdude &gt; &gt;(lambda (word) &gt; &gt;(member word x) &gt; &gt;) &gt; &gt;) &gt; &gt;newdude)) Defining the pointless list did work, so I guess that should do it. Thanks!
You're very welcome :) I think in your code above it should be (member word x). Otherwise you'll be checking if the word is a member of the empty list. That was probably just a typo, but just encase it wasn't: consing something onto x doesn't actually change x. It's y that is created by the *result* of consing something onto x. For example: (define x 3) (define y (+ x 3)) y will get the value of 6, but x will remain 3. y takes the result of adding 3 to x, but x does not change, it is merely used as an operand in the + operation used to define y.
It's back now!
Is *global* preferred over GLOBAL by convention when writing in Racket? HtDP seems to indicate that the convention is the latter.
I'm a bit of a wanderer when it comes to Scheme implementations (I've got over a dozen installed), so I don't know which convention is more common within the Racket community. My intention in pointing out that it was a convention was not to claim that it was the preferred way of writing it in Racket, but to point out (especially to those who may not be very familiar with Lisp) that the asterisks were not some special syntax but just convention.
My only points of reference is HtDP and your article. So I really don't know the answer. Thanks for the article. It's the first Racket tutorial I've read through. 
I hadn't heard of [LambdaNative](https://www.reddit.com/r/lambdanative/) before, but it seems to be the kind of thing that I've been looking for. I look forward to reading your next tutorial. 
I'm about halfway done with the LambdaNative tutorial. I'll probably be ready to post it in a week or less. Other than (the somewhat sparse) documentation on their own site, I can't find any other tutorials on LambdaNative, so I hope my small contribution might help out anyone trying to figure out the framework.
Well said :)
Thank you for this, it hits a spot for me. (If you are the author then double thank you.)
I'm fairly new to Scheme, and every time I try to learn about continuations my head explodes. This was a pretty good article, and the first part especially helped me to understand the basics of continuations pretty well. But then I got lost in the second half.
Just for reference for the first part. On mobile so was a pita to find a generalization of a scheme lambda expression: `((lambda (parameters) body) arguments)` 
Any specifics I can try to help you with?
Saved
I'd love to know how long it takes on average to grasp continuations. For me it came in stages.. of ~1 year apart periods.
I used Chicken for a while for monitoring parts of our software stack. There was a recent blog post from someone about running their business on Racket and Postgres.
Not "production" exactly but I like using [Gauche](http://practical-scheme.net/gauche/) for shell scripting purposes. It's a Scheme with some extra shell script-oriented features included, and fits its niche nicely. 
[https://github.com/vyzo/gerbil](https://github.com/vyzo/gerbil) &amp;#x200B;
What do you use it for?
The only schemes I have read about used in production are chez scheme and racket. Someone wrote about using guile for internal scripts on hacker news a couple of years ago, but that is just what I have heard over the years. I am but a lowly classical musician, so I real
&gt; schemes I have read about used in production are chez scheme Any non-proprietary details on that that you could share? I'm very interested in going the Chez way. Sadly there's not much material available for many things. 
My hosting platform is built on chicken! It's great for systems tasks. 
I just released the LambdaNative [tutorial](https://dev.to/goober99/learn-lambdanative-by-example-desktop-gui-277l).
So, your algorithm is basically this: Go through each number up to and including `x`, and see if that number divides `x`. Are there ways to rule out some numbers, so you can stop before you check `x-2`, `x-1`, and `x`?
I could change this part: `(if (&gt; i x)` to `(if (&gt; i (/ x 2))` But it doesn't seem to speed it enough. I still have to wait ages for result.
Ok, why does that work? Can you use the work you've already done (e.g., "`x` is divisible by 2) to change the work you have to do in the future?
This is great! Exactly I was looking for!
You probably suggest some prime factorization method. After looking at other people solutions I have changed my algorithm: (define (divisors-number x) (define (divisors-iter x i divisors) (if (&gt;= i (sqrt x)) divisors (if (= (modulo x i) 0) (divisors-iter x (+ i 1) (+ divisors 2)) (divisors-iter x (+ i 1) divisors)))) (divisors-iter x 1 0)) It now finish in 21 seconds on my laptop (not the fastest machine). So there was no error in my program, had to use better algorithm, got it. Your idea would be even faster. 
There is a better algorithm. Let's start with a function to find the factors of a number *n*: (define (factors n) (let ((wheel (vector 1 2 2 4 2 4 2 4 6 2 6))) (let loop ((n n) (f 2) (w 0) (fs (list))) (if (&lt; n (\* f f)) (reverse (cons n fs)) (if (zero? (modulo n f)) (loop (/ n f) f w (cons f fs)) (loop n (+ f (vector-ref wheel w)) (if (= w 10) 3 (+ w 1)) fs)))))) We use a method called [wheel factorization](https://en.wikipedia.org/wiki/Wheel_factorization); at O(sqrt *n*), it's not the fastest factoring algorithm available, but is sufficient for Project Euler. Next we use the factorization of *n* to determine the number of divisors of *n* by counting multiplicities of factors: (define (numdiv n) (let ((fs (factors n))) (let loop ((prev (car fs)) (fs (cdr fs)) (f 2) (d 1)) (cond ((null? fs) (\* d f)) ((= (car fs) prev) (loop prev (cdr fs) (+ f 1) d)) (else (loop (car fs) (cdr fs) 2 (\* d f))))))) Now we can generate the triangle numbers, count the divisors of each, and stop when we've seen enough divisors: (define (euler12 limit) (let loop ((n 1) (tri 1)) (if (&lt; limit (numdiv tri)) tri (loop (+ n 1) (+ tri n 1))))) On my system, using Chez Scheme, that finds the answer in about a fifth of a second: &gt; (time (euler12 500)) (time (euler12 500)) 13 collections 203 ms elapsed cpu time, including 0 ms collecting 208 ms elapsed real time, including 0 ms collecting 55714592 bytes allocated, including 54737696 bytes reclaimed XXXXXXXX In the spirit of Project Euler, I elided the answer. You might enjoy some of the Scheme code at [my blog](http://programmingpraxis.com).
**Wheel factorization** Wheel factorization is an improvement of the trial division method for integer factorization. The trial division method consists of dividing the number to be factorized successively by the first integers (2, 3, 4, 5, …) until finding a divisor. For wheel factorization, one starts from a small list of numbers, called the basis — generally the first few prime numbers; then one generates the list, called the wheel, of the integers that are coprime with all numbers of the basis. Then to find the smallest divisor of the number to be factorized, one divides it successively by the numbers in the basis, and in the wheel. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/scheme/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Systems Development, Software Programming, and Production. I am a computer programmer for a living, and Gerbil is now my primary compiler. Or: What in specific are you asking for?
Great stuff, especially I am gonna check you blog for tons of scheme code.
R5RS also stipulates that the define statements should come before the body of a function, so I'm actually surprised that so many support them anywhere in the body! O_O Thanks for sharing :)
Kawa lets you `define` anywhere. 
I don't think I've ever used define in a lambda or anywhere but top level definitions... 
I prefer the nested define to let statements when possible.
My definition of a Scheme implementation is broad. Not all of these claim R5RS or R6RS compliance or even have that as a goal. Some (such as FemtoLisp) are merely Scheme-like. Interestingly, when you use #lang r6rs with Racket it enforces `define` at the beginning of the lambda body, but #lang r5rs does not.
I'm looking for a GUI library for a project I have in mind that will require a GUI. I hadn't considered Guile-Gnome, because my impression was that it was essentially unmaintained. The last release was in 2017 with release notes stating "But don't hail, this is a maintainance release, which actually merely comment the build of the Corba and Gnome-VFS modules, due to incompatible changes in Guile-2.2 (see their corresponding entry in configure.ac for a better explanation): This is reversible though, if you think you have the skill and some free time to fix these two, please do! And get in touch with us of course..." The last release before that was in 2015. It is also still based on GTK 2. With GTK 4 around the corner, I wonder how long it will be before GNOME EOL's GTK 2. Even if GNOME were to EOL GTK 2 tomorrow, I'm sure it would still be in the repos of more conservative distros (such as Debian and CentOS) for several years to come, but if the current maintainers don't have the time to keep up with changes in Guile, I doubt their going to have the time to port this library to GTK 3 (or 4). Since you actually use the library, I'd be interested in your thoughts. Would you recommend Guile-Gnome for a new project that will have to be maintained for many years to come?
It's a bit tricky to define the what internal definitions mean - and how they interact with macro expansion. The Racket way is described here: https://docs.racket-lang.org/reference/syntax-model.html#%28part._intdef-body%29 I think it is a bug that internal defines are working in `#lang r5rs` in Racket. 
I am trying to learn scheme, on the side, using HTDP. So I'm definitely a novice. But these are my thoughts: 1. You can see how little traffic this group gets, r/guile gets even less. 2. If you look at the documentation for all the parts of guile-gnome you'll see the bulk of the sample code is in C (I think- I don't know C or C++, so it's almost useless to me). There's also not a lot of cross-linking in the documentation so if you are trying to find out the name for an event like 'button-press-event and you are reading about events in gdk, if the events aren't listed there, there probably won't be a link to where they are listed. 3. I spend a lot of time figuring out things like what is the type of argument this function takes? how do I get the values I need out of the object this function returned? what is the name of this auto-generated function? Some of this may be because I'm not familiar with guile, and goops in particular, but this is all on top of stuff like figuring out that I have to use a label if I want a statusbar where the text changes color, and how to combine widgets to get the look I'm supposed to get- the normal kinds of problems anybody who didn't know anything about gtk would have. But it does seem like I spend a lot of time reading the GTK+2 or cairo documentation and trying to figure out what would Guile do? Or reading the source code and hoping it's not a bunch of auto-generated functions with no names, much less documentation. &amp;#x200B; I didn't know it was incompatible with 2.2, since I'm on Debian stable I've been using 2.0- but even on my system there are some sample apps (macrospline.scm) that I can't get to run, and some others I had to modify. What is the difference between Guile 2.0 and 2.2 that makes it incompatible?
Here's a sneak peek of /r/guile using the [top posts](https://np.reddit.com/r/guile/top/?sort=top&amp;t=year) of the year! \#1: [Andy Wingo - Guile 3: Faster programs via just-in-time compilation](https://fosdem.org/2019/schedule/event/guile3fasterprograms/) | [0 comments](https://np.reddit.com/r/guile/comments/aoqtma/andy_wingo_guile_3_faster_programs_via_justintime/) \#2: [\[ANN\] GNU Artanis-0.3.1 released!](https://lists.gnu.org/archive/html/artanis/2018-12/msg00000.html) | [0 comments](https://np.reddit.com/r/guile/comments/ab08tf/ann_gnu_artanis031_released/) \#3: [Scheme @ FOSDEM 2019](http://community.schemewiki.org/?FOSDEM2019) | [0 comments](https://np.reddit.com/r/guile/comments/99zak7/scheme_fosdem_2019/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
I'm not sure what the incompatible changes in 2.2 were. All I know is what the latest release notes for Guile-Gnome stated. Thanks for the description of your experience with Guile-Gnome. I think I'll continue looking at other Lisp GUI libraries for now. I don't want to dissuade you from using Guile. I think it's an excellent Scheme implementation to write shell script-like programs in Scheme, but may I suggest Racket to you for GUI programming with Scheme. It has a well-documented GUI library built-in to the language. I've written a [tutorial](https://dev.to/goober99/learn-racket-by-example-gui-programming-3epm), and here's another [tutorial](https://alex-hhh.github.io/2019/03/password-generator-gui.html) that honestly is even better than mine.
From the SICP: "Management is not responsible for the consequences of running programs that intertwine definition and use."
Here is an implementation in generic Scheme: [http://okmij.org/ftp/continuations/implementations.html#delimcc-scheme](http://okmij.org/ftp/continuations/implementations.html#delimcc-scheme) Here is an implementation for Scheme48: [http://www.deinprogramm.de/sperber/papers/shift-reset-direct.pdf](http://www.deinprogramm.de/sperber/papers/shift-reset-direct.pdf) And then, of course, there is Filinski's paper first describing shift and reset (although in SML): [http://hjemmesider.diku.dk/~andrzej/papers/RM.ps.gz](http://hjemmesider.diku.dk/~andrzej/papers/RM.ps.gz)
The delimited continuation operators can be implemented using call/cc. For example http://okmij.org/ftp/Scheme/delim-control-n.scm http://okmij.org/ftp/Scheme/delimcc.scm you can also implement them directly by coping segments of the control stack: (1990) Representing Control in the Presence of First-Class Continuations - Robert Hieb, R Kent Dybvig, Carl Bruggeman.pdf Or you can implement them with a virtual machine following (2010) Functional derivation of a virtual machine for delimited continuations - Kenichi Asai, Arisa Kitani
I benefitted from your good answer thank you
Well, I looked at Racket first but it seems like my laptop is under-powered (I had the same problem with VSCode, Atom, and Emacs) but using Guile and Vim is no problem, start-up-wise. Most of the "gui" programs in HTDP so far have built up one step at a time (and are just moving a cairo image around a gtk drawing area) in terms of new features I have to learn, so the learning curve isn't too bad (since this is a hobby) I just saw chance to vent. But it doesn't seem like it would make sense for a project you would have to maintain, because even on the mailing list there isn't a lot of talk about it and it seems like several threads are like this one: [http://lists.gnu.org/archive/html/guile-user/2018-10/msg00008.html](http://lists.gnu.org/archive/html/guile-user/2018-10/msg00008.html) as opposed to answers to how-do-I's. Figuring out this problem (how do draw with cairo in a window) took me the longest (but then it was the first one I tried).
One way would be to do a CPS transformation twice to CPS your CPS. I don't know about the efficiency of that, nor do I know any practical implementations of it, but it seems simple enough. Using call/cc to implement delimited continuations seems like a strange choice, since you will not gain any speed benefits over regular call/cc. In guile, replacing call/cc by the prompt-based call/ec in the standard continuation benchmark fibc.scm yields a 4x speedup. You will also have problems with dynamic scope and a few other things. Andy Wingo has written about it and usually responds within a couple of hours in #guile on freenode. He wrote this about the guile implementation: https://wingolog.org/archives/2010/02/26/guile-and-delimited-continuations
Are you talking about the DrRacket IDE? I personally don't use it. If you type `racket` into a terminal, you get a good ol' fashioned REPL. I just use that and a text editor (my preferred text editor is Geany). I've tried VS Code too, and my computer isn't powerful enough to handle it either. I didn't know editing text could be as demanding as playing a 3D game. If you want something similar to VS Code and Atom, I'd recommend Geany. It's written designed to have short load times and limited dependencies plus it's written in C, so you don't have the Electron penalty. I've never tried Vim. When I was a student worker in the IT department of my university as a freshman, I was tasked with updating some files on an HP-UX server (this was around 2005). I was directed to the files and dropped into vi to edit them. None of the keys did what I was used to. I was too proud to ask for help. I eventually figured it out with much googling, but I think that trauma has stuck with me. Today I have sysadmin responsibilities for a few Solaris servers, and I installed nano on all of them for when I need to edit the Crontab or do other quick text editing.
I'm just curious. Gerbil looks cool no doubt, but it also seems rather young and yet I've seen plenty of people mentioning using it in production/work. I'm tempted to use Gerbil too but I'm not a big fan of this trend of glueing a good scheme front end to a good scheme backend. (Racket/Chez, Gerbil/Gambit). That seems like it would result in issues unless the projects are communicating well together. Is there any way you could be kind enough to explain why you picked Gerbil?
Um. Start each line with at least 4 spaces to have code formatting, and also try... not doing whatever that URL-encoding thing is. 
Code in URL? Sorry, but no. Just. No.
So far its working great, and I don't have to set up a server just for a little example app. I fail to see what the big deal is. Unless you're using IE11?
&gt; what the big deal is A URL is a Universal Resource Locator. Its purpose is to locate resources. The very last thing you want in a URL is anything that is executable. There are an infinite number of possible attacks made possible by embedding active code in URLs. Read about [SQL injection attacks](https://en.wikipedia.org/wiki/SQL_injection) to begin the journey of understanding why code in the URL is a hacker's playground.
Ok, in this case, what would a hacker compromise by putting arbitrary code in to a bot? The whole point of the language is to run user configurable code.
I'm not going to explain the obvious as though it needs to be defended. Study up on SQL injection attacks, buffer overruns, poisoning, and so on.
So condescending!
&gt; A URL is a Universal Resource Locator. Its purpose is to locate resources. So? Hacking has always been about using things for stuff that is *not* their purpose. &gt; There are an infinite number of possible attacks [...] I have had URL-programmable interpreters for various languages online for years. One of them got exploited *once*, because that interpreter exposed C's system() to the user. Oh well. Live and learn. OP: don't get discouraged! It's a great idea!
&gt; that interpreter exposed C's system() to the user. &gt; ... &gt; It's a great idea! /facepalm
[Readscheme.org](https://Readscheme.org) was a wonderful resource. Alas, it disappeared without warning in late 2018. I haven't been able to contact Jim Bender, who was its long-time maintainer, nor have I been able to obtain a complete archive. I've managed to extract the Scheme bibliography pages from [archive.org](https://archive.org), but the huge library of PDFs is missing. &amp;#x200B; I reached out to Namebright, the DNS registrar that controls [Readscheme.org](https://Readscheme.org). I didn't ask for any contact information — just that they pass along a message inquiring about the domain for the purposes of restoring its content, even somewhere else. They refused even to do that, citing privacy concerns. &amp;#x200B; If anyone knows how to reach Jim, or knows another way to recreate the library of PDFs without lots of manual labor, please let me know.
Very clever to take me statement out of context!
Not out of context, the thread is right here for everyone to read. It's *not* a great idea. However, some people are only capable of learning in the School of Hard Knocks. Let the skull cracking commence!
What PDFs are missing? I thought all the linked papers were hosted elsewhere.
I'm considering that I'd start using Chez by porting substantial portions of Gauche's API (in those places where it makes sense) to Chez to make it possible to do useful (for me) stuff in it, but no promises yet. ;)
&gt; Readscheme.org was a wonderful resource yes! If we had a list of missing PDFs we could try to locate them. I guess people have copies of some of them.
Ha, I invite Your Mightyness to hack into [github.io](https://github.io) through my web app! Let us know how you do! I think SQL injection is unlikely since its a fileserver that has no SQL database - and for that matter no API to call either. 
Most of them are available, but it will be a manual, time-consuming process to find them, download them, and link them into the bibliography. Before, many of them were hosted on the [Readscheme.org](https://Readscheme.org) site itself.
&gt; I'm not a big fan of this trend of glueing a good scheme front end to a good scheme backend. That's interesting. I've only started using scheme in earnest, being a Common Lispnick for the last 15 years or so, but almost all of the lisp dialects I've used or played with have been been bootstrapped on top of another interpreter/compiler, back to the original LISP. I did not realize there was a trend towards writing from scratch. What I like about such things is that we have a prelude in which the rest of gerbil is implemented. That prelude can be built on top of any scheme (gambit is not the first), which means that the rest of gerbil (excluding gambit specific libraries) can be built on top of that. What I like about using gambit is that it is a well implemented and widely used implementation that is developed daily. It can compile to different languages, and interacts quite will with C code and shared libraries. To create/write/debug gambit from scratch may take, I don't know, say 31 years. :P One of the reasons I chose gerbil was there is no waiting game. It's ready for use now, not 31 years from now. I did not know that they had a Racket that runs on Chez. That's good news! I tried PLT out, back in the day, but did not like its focus towards academia. &gt; That seems like it would result in issues unless the projects are communicating well together. It would indeed! For almost all software I use in production, since I work for myself, communication with upstream is quite important. If other scheme projects you interact with with don't communicate well with their tools, that itself may be a reason I stayed away from scheme for so long. We communicate quite well with Marc Feeley and the Gambit project, and use bleeding edge versions in order to get our work done. We are quite practical in that regard. &gt; Is there any way you could be kind enough to explain why you picked Gerbil? I chose it Gerbil because it is an "opinionated dialect of Scheme designed for Systems Programming". I love the Lisp language, and share my opinions of needs with Gerbil. I program systems for a living, and love how well it interacts with my operating system. Its module system is top notch, and reminds me of how I used CL packages with a file of the name name. Basically, I choose Gerbil as it has all the things I like from Common Lisp, yet is more modern and made for doing what I do. Have a look! :) https://github.com/vyzo/gerbil#documentation 
Absolutely stellar response, thank you. I will definitely be giving Gerbil a closer look.
what about making a git repo for it, like https://github.com/rain-1/continuations-study-group/wiki/Reading-List
Can you post a link to the bibliography?
Add or multiply?
I would do: (map (lambda (elem pos) (* elem pos)) list_1 (iota (length list_1)) If you don't have access to iota you can probably import srfi-1. How depends on the scheme version.
 (map * list_1 (range (length list_1)))
Range is racket specific. For scheme there is iota from srfi 1
Don't see a bug here. Which result you would expect? Keep in mind that you are calling reverse within the recursive function poly\_derx2, i.e. you are reversing each time you add an element to the list, shuffling the result in a strange way.
How can I wait till the entire thing is done and then reverse the final result?
You can split it into two functions: public-entry-point do pre steps call internal-recursive-routine do post steps internal-recursive-routine: ... 
You can split it into two functions: public-entry-point do pre steps call internal-recursive-routine do post steps internal-recursive-routine: ... 
It looks like the actual server is still up and running. If you add a custom entry to your hosts file you can still browse the site. 212.110.186.28 readscheme.org library.readscheme.org repository.readscheme.org www.readscheme.org 
How did you figure this out?
A while back, someone (I don't remember who, sorry!) in #scheme on freenode mentioned the server was still running. This morning, I used a DNS history site (https://securitytrails.com/dns-trails) to lookup the IP address, and then edited my hosts file until it worked.
A while ago I implemented Haskell like monads in Scheme to get a better understanding of how Haskell works. This is a quick write-up about how at least part of it (hopefully) works. Feel free to ask any questions and come with feedback.
There are a number of object systems for Scheme. Which one are you using here?
Very nice, really shows the power of scheme macros that one can simply add "do" notation!
GOOPS, Guile's CLOS like system. It was a good choice here since it has multiple dispatch.
I'm still amazed at how simple it was, and how powerful it became.
Thanks, that DNS search engine is amazing.
Thanks. I'm not familiar with GOOPS or its naming conventions, but I'll look it up.
Im right where you are with Monads. I get their feature set, but why that is so neat still eludes me. I see how powerful it is, but I cant bring myself to think generatively about them. Ive read tutorials in every language I could, Scala, Scheme, Haskell, I think C++.
Maybe you'd like this paper: http://cswords.com/paper/alamode.pdf Also, at the very end you mentions still not get to ng one or two bits... Can you name them? Or is it more you don't have a deep intuitive understanding yet?
I just tried out your suggestion and it works! Thank you! I guess we need to somehow recover the domain name then (or register a new one)?
Nice, I did a similar thing here: [https://github.com/jhidding/r6rs-monads](https://github.com/jhidding/r6rs-monads)
The short version is that `define-method` creates procedures which can have multiple instances depending on their types. Multiple dispatch is possible on the type of all arguments, and if a argument has a specified type it's given as `(name &lt;type&gt;)` in the parameter list. And that `&lt;top&gt;` is the base class everything extends from.
Good work! It's really interesting to see how you solved the same problems in different ways. Your solution for return with explicit scopes feels much cleaner than mine. I had return as a generic function, which took a monadic value, and returned the return function for that type. So `(return '()) =&gt; list`.
I made a quick backup of the server at [https://github.com/scheme-live/library.readscheme.org/releases](https://github.com/scheme-live/library.readscheme.org/releases)
I made a [git repo](https://github.com/scheme-live/library.readscheme.org/releases) but the repository is very big 1.5G. My POV on this, would be to create a dedicated application to store all the things and improve it with paper abstracts, make them searchable and easy to download. It could go in scheme-lang.com.
Good to see more Chez users :)
Uh, nowhere... :D There's not anything to be shared yet, to be honest. It's maybe a plan for this year, if time allows, which is quite an aspiration in itself. :/
That was a great read! It's comforting seeing someone else having almost identical implementations to mine, including the identity Monad, or how the State monad is implemented as functions taking pairs. My ending part, about not understanding to connection to monoids, is probably a combination of me having missed some of the steps, but it might also be an intuition problem. It was after all this problem that let me see the connection between Monads and Functors with (define (&lt;$&gt; f m_) (&gt;&gt;= m_ (lambda (m) ((return m_) (f m)))))
could we automatically translate the HTML into markdown?
somtething like this maybe https://bpaste.net/show/769d65e64429
For me the thing that helped was taking a haskell do block and hand transforming it back to bind &amp; friends, then reformatting it to be fully expanded and drawing lines through so I could see how everything related and threaded through. I won't claim to have a full intuitive understanding, but it is no longer mysterious to me.
I used html2text, see https://github.com/scheme-live/library.readscheme.org#bibliography-of-scheme-related-research
Omg this is perfect!!!!!
I as well. Sometimes I just want to name something in the current environment without creating a whole new one (and yet another level of indentation).
The compiler was proprietary at one time, but I believe the whole thing is open source now. https://github.com/cisco/ChezScheme
I have the compiler, I was asking about the projects.
I'm curious to see what your game looks like. What are you using for graphical display?
We got a graphics-file from our TA's, since it's apparently rather complicated to do otherwise. They didn't want us to spend time on that since it is a first bachelor project
Since scheme does not have global variables, they tend to just pass a data structure through the entire loop. As long as you pass the actual data structure and not a copy, any change should be visible to anything that access the data structure in the future.
it sounds like you’ve figured a solution, but: Maybe your car’s field is called something like `time-left-at-current-speed`; it’s update is “if positive then sub1 else current-random”?
&gt;scheme does not have global variables What? It does! `define` makes a binding with dynamic scope (unlike the lexical one of `let`) -- that's why in repl you can "redefine" procedures and the rest uses the new one rather than "remembering" the old one.
first time I read about this implementation of scheme.
For the headline question, try this: [gcartier@jazzscheme.org](mailto:gcartier@jazzscheme.org) If that does not work, try this: [https://github.com/jazzscheme/jazz/issues](https://github.com/jazzscheme/jazz/issues) I do not use JazzScheme personally, but I love Gambit, so he's got good taste for foundations. :)
To answer my own question: there is also [SLIB](http://people.csail.mit.edu/jaffer/SLIB.html), which is a cross-Scheme implementation of useful methods and datatypes.
I've dropped an email to the author of JazzScheme...
This is a good question, sadly. With sadly I mean that Scheme is a wonderful world but very fragmented/incompatible. Myself, I've been looking for a Scheme setup forever. Gambit is an excellent implementation, but I have not found a module system/package manager to match. What I ended up finding, however, is Akku.scm, a package manager for portable Scheme, initially for R6RS but now with support for R7RS as well. It is actively maintained, and works very well. Not sure how well Gambit can be made to work with [R6RS](https://smyles.com/projects/r6gambit/). Personally, I use Chez scheme with Akku.
Does srfi-19 cover what you are looking for in dates and times and does Gambit support it?
Yes, Gambit seems to support it: https://practical-scheme.net/wiliki/schemexref.cgi?SRFI-19
Akku.scm is a wonderful hint. I'm new to Scheme programming, but as far as I can see Gambit does not implement the whole R6RS standard. But as I'm just evaluating different Schemes and playing around with the language, I'm not bound to Gambit and can switch easily to whatever I like ;-)
Thanks for sharing! Is it suitable for developers new to the Scheme language?
Absolutely. And please note that if the value proposal of a package manager compatible across the R6RS standard would have been compelling in and of itself, Akku.scm goes one step further and allows consumption of R7RS libraries too. This produces a significant compatibility/portability surface.
I never attended, I guess it is (somewhat) like any other conference. Check out previous conference for a glimpse of what happens there: - https://brinckerhoff.org/scheme2018/ - http://www.schemeworkshop.org/2017/ - http://www.schemeworkshop.org/2016/ - http://andykeep.com/SchemeWorkshop2015/ - http://www.schemeworkshop.org/2014/ - http://schemeworkshop.org/2013/ - http://schemeworkshop.org/2012/ Others can be found in the git backup of [library.readscheme.org](https://github.com/scheme-live/library.readscheme.org#workshops-on-scheme-and-functional-programming). What I can say, is that it is a unique occasion to meet schemers IRL. Also this year it is in Europe!
Hi there! Scheme Workshop sits somewhere between a traditional "academic" workshop and an industry conference. The focus is on discussing cool ideas, but it's not so much about teaching programming: though we **do** value the presentation of ideas and we want talks to be accessible to everyone. I don't want to mislead and give the impression that it's a great fit for beginners, since the average attendee will be a fairly seasoned programmer. On the other hand, if you find the ideas within the Scheme ethos exciting, I expect the workshop could be a really fun time. It's worth noting that it's in Europe. So if you attend Scheme Workshop, you'll probably also want to consider attending other events, such as the international conference on functional programming (ICFP). This definitely leans more academic, but usually has a lot of interesting attendees in a variety of roles! We'd love to have you come out. Please feel free to reach out to me personally ([http://kmicinski.com](http://kmicinski.com)) if it would help!
Thanks for the insights! As I'm located near Berlin, it will be a great opportunity - even when I'll understand only the half ;-)
Old post, but I found this sub because I'm trying to find Scheme resources. I use Gnucash, which is open-source accounting software, and I want to get under the hood to modify the business reports. If anyone knows Scheme and wants to contribute, Gnucash doesn't have a big developer base. It's a great piece of software but is a little rough around the edges.
why not commas?
Try out Gerbil! It's built on top of Gambit, with a highly capable module system and an extensive standard library.
Links: \- documentation: [cons.io](https://cons.io) \- implementation [vyzo/gerbil](https://github.com/vyzo/gerbil)
The next draft is [in progress](https://github.com/scheme-requests-for-implementation/srfi-167/pull/1). Here are the current changes: - add a list of compatible libraries - remove lexicographic from the specification - better naming
You mean some value `e` such that `(cons L e)` evaluates to `L`? It wouldn't be hard to define a symbol, e.g. `emptytree` and then define a custom cons (let's call it `conse` for "empty") that can accept the `emptytree` symbol in its list and return the expected result: (conse L1 L2) ==&gt; (L1 . L2) (conse L emptytree) ==&gt; L (conse emptytree L) ==&gt; L (conse emptytree emptytree) ==&gt; emptytree
I think you mean, is there an identity element for the `cons` operator, not for `cons` cells themselves. You're right that `append`, when viewed as an operator, has an identity element (`nil`). But `cons` does not. Consider that `cons` is quite literally a "constructor", i.e., using `cons` always produces a new object. So an identity-preserving `cons` operation can't exist, because that would imply that we can have an application of `cons` that not produce a new `cons` cell.
No, they do not have identity (neither left or right), and they should not have one! Assume an expression `e` exists such that `(cons x e) = x` \[or `(cons e x) = x`\]. then you get `x = (car x)` \[or `x = (cdr x)`\]... for any `x`. Bravo, you just broke `car` \[or `cdr`\] -- are you proud of youself? ;)
(car (cons x y)) must be x and (cdr (cons x y)) must be y for all values of y and x, so that doesn't appear possible.
Thanks everyone for having the patience to point out where my reasoning went wrong for me. Reading through the replies is a little embarrassing since with the benefit of hindsight your answers are obvious. :)
No need to be embarrassed, it was a good question!
Nice! It would have some surprising properties, though. With cons, it's guaranteed that `(length (cons a (cons b (cons c nil))))` will always equal 3. With conse, it might be anything from 0 to 3, depending on the values of a, b, and c. Still, a "maybe-cons" like yours could be handy sometimes.
I think it's a mistake in the book I guess ((nullo l) fail ) should be ((nullo l) (nullo x) ) since the reverse of '() is '()
Sorry, I forgot to mention that `(memberrevo)` is wrapped in a function `(lambda (l) (run* (out) (meberrevo out l)))`. If I'm not entirely mistaken `(memberrevo)` returns each result (sorta) individually. `(run*)` then collects all the results and returns them to Scheme via a list.
ohhh! so it's just supposed to return each member of the list - but backwards. So it's logically equivalent to member but the order of results is different. so I think you just need to take MEMBERO and rearrange the order of the CONDE clauses.
That makes sense and seems in line with my current vague understanding. However going back to check it still seems like it's correct. Here's the `(membero)` relation: (define membero (lambda (x l) (conde ((nullo l) fail ) (succeed (fresh (d) (cdro l d) (membero x d)) ) (succeed (eq-caro l x) )) )) Reversing the `(conde)` clauses in a copy of `(membero)` also doesn't produce the desired effect...
it looks right to me, what happens when you query it like ([rev]membero x '(a b c))
`(run* (x) (membero x '(a b c))` returns `(a b c)`. `(run* (x) (memberrevo x '(a b c))` returns `(a b c)`...
oh I think I know what's happening. minikanren has a fair search, not a depth first search. If we did the same thing prolog we would get reversed order - but in mk we can't really expect the order to be a specific one. What happens with a much longer list? My guess would be at some point they will have a different ordering.
On lists of length 10000 they're still the same. Also, I'm not entirely certain about this. The impression that I got is that the behaviour you described earlier (reversing the `(conde)` clauses) is the expected behavior.
If you have SRFI 1 (Lists), which most implementations do, you can use `drop`: (define (nth n lst) (car (drop n lst))) Note that this is unsafe - if your list has fewer than `n - 1` elements you'll get an error. If you don't have SRFI 1, you can do this: (define (nth n lst) (if (&lt;= n 0) (car lst) (nth (- n 1) (cdr lst)))) Which is likewise unsafe. You could use the `length` function to make these safer, but note `length` is fairly slow on lists.
I think LIST-REF is in RnRS for n&gt;=4, so pretty much every implementation should have it by now.
Aren't the arguments of the recursive call swapped?
Oops, yeah, fixed
List-ref Is slow since you have to transverse the list to find the element you are looking for. If you want to access something by index, a vector is probably what you want.
"Lisp in Small Pieces" will take care of you.
There's a youtube video by Mathew Flatt called (I think) "how to implement a hygienic macro expander" on the set of scopes algorithm. It also has an associated set of git repositories.
&gt; There's a youtube video by Mathew Flatt called (I think) "how to implement a hygienic macro expander" on the set of scopes algorithm. https://www.youtube.com/watch?v=Or_yKiI3Ha4
R. Kent Dybvig wrote a chapter in [Beautiful Code](http://shop.oreilly.com/product/9780596510046.do) about the older way of implementing `syntax-case` hygienic macro system. You can get the PDF copy off of his site [https://cs.indiana.edu/\~dyb/pubs/bc-syntax-case.pdf](https://cs.indiana.edu/~dyb/pubs/bc-syntax-case.pdf) The newer Flatt algorithm implemented in the Racket expander is (IMO) easier to understand and implement. - [Binding as Sets of Scopes](http://www.cs.utah.edu/plt/scope-sets/) - [Matthew Flatt's Strange Loop Talk](https://www.youtube.com/watch?v=Or_yKiI3Ha4)
Yup, that one! Thanks. :)
In "some.rkt" the two first lines should be: #lang racket (provide (all-defined-out)) Save the file. In the repl, you can now use `(require "some.rkt")`.
Nice approach. Interesting leverage of JVM tooling to build and launch the demo, working around the absence of Kawa tooling proper. Kudos! &amp;#x200B; Note: I would love to see the equivalent to the Maven [mojo](https://github.com/talios/clojure-maven-plugin) that compiles Clojure code + availability of Kawa on Maven Central.
Second draft published: - better naming - no ownership of the transaction to be able to compose layers https://srfi.schemers.org/srfi-168/srfi-168.html
[guile-wiredtiger implementation of srfi 167](guile-wiredtiger implementation of srfi 167) with [tests](https://framagit.org/a-guile-mind/guile-wiredtiger/blob/master/tests/okvs.scm)
[guile-wiredtiger implementation of nstore](https://framagit.org/a-guile-mind/guile-wiredtiger/blob/master/wiredtiger/nstore.scm) with [tests](https://framagit.org/a-guile-mind/guile-wiredtiger/blob/master/tests/nstore.scm)
Just keeping on at [my blog](http://programmingpraxis.com).
 (define wrong-subreddit (get-post this))
Learn to code
That's quite a racket. Are sure you have the guile to make that gambit payoff or will you chicken out in the end?
I will work on wiki using Guile based on my work on srif-167 and srfi-168 that will continue to improve.
I think each has a different set of goals. Chicken compiles to C code, so it is more of a meta-language: program your application in Scheme, then compile to C so it can be built anywhere. Guile is a C library that can be embedded into larger applications, making it easy to turn your C functions into Scheme built-in/intrinsic functions so they can be called from Scheme scripts. This allows any application to be scriptable using Scheme. Also, Chicken is MIT licensed, Guile is GPL.
This is a good question for newbies like me. I feel the difference really stems from the License? one is GPL the other BSD — that may be a deal breaker for many developers tbh.
I'm currently extending a C/C++ app to have a plugin system. I'm using Chicken at the moment, but perhaps Guile would be an even better solution. I'll have to take a look at both to see which works better for me.
The guile-ffi package is your friend.
I suppose it depends on how the details of your plugin system. If you want plugins to be compiled to binary objects that are compiled once and then shipped to end users in binary form, and you load them using functions like `ldopen()` and `ldload()`, then Chicken would be a good way to go, although if you're using `dlopen()` you could use any language to produce binary plug-ins, not just Scheme. If you want your plugins to be scripts that can be easily changed during runtime, even changed by end users themselves, at the expense of slightly worse performance (since scripts are interpreted and not compiled) then probably Guile would be the way to go.
Chicken is the nicest community online, and I say this as a guile guy. I ended up in guile because I preferred the r6rs way and the syntax-case macro system. Guile is rushing forward (mostly due to the work of Civodul and Wingo, the maintainers). The upcoming guile 3 will close a large chunk of the performance gap between chicken and guile as well.
Chez Scheme, definitely.
You don't. There's practically never a reason to index a list.
I haven't used Guile, but I really love their homepage (especially the illustration): https://www.gnu.org/software/guile/ Chicken I just adore. To me it's great because: 1. You get `csc` to compile files to binary and `csi` to run/interpret them. So you can write either scripts or programs pretty easily. 2. The wiki. It includes the manual, tutorial, explanations, and other docs about chicken itself, as well as docs for 3rd party packages (called eggs). I love "one stop shops" when it comes to documentation: https://wiki.call-cc.org/ 3. Eggs are simple, seem to work well, and have official support. 4. Easy C interop. It compiles to C itself, but also has support for calling and using C code directly. (I think C++ too) 5. Good syntax choices - subjective, I know, but I like seeing `(import (chicken process))`) and `(import srfi-13)`. 6. Compiles to C. Maybe this is the same as #4, but you can do fun stuff as a result of this decision like compile chicken programs into C without a `main()` so they can be linked into and called from regular C programs. 7. Last but not least, as others have said, just a wonderful community. I mean it's called Chicken right? It's not too serious or anything, but it's quality. Like chicken.
Still the same plans. Although a crazy recent idea was to make an automated port of REDUCE or something similar.
Ask for help on gnucash or guile mailing list.
Although not indexing exactly, there are functions for up to four (?) combinations of car and cdr like (cadr l) -&gt; (car (cdr l)) ;the second element of a list (cddr l) -&gt; (cdr (cdr l)) ;the rest of the list after the second element (caar l) -&gt; (car (car l)) ;the first element of the first element that let you pick out a particular part of a list
Cool!
Have you published, or do you plan on publishing this code? I'm interested in reading what this does and how it works.
- SRFI 167 and SRFI 168 code is published at framagit - SRFI 167: [code](https://framagit.org/a-guile-mind/guile-wiredtiger/blob/master/wiredtiger/okvs.scm) with [tests](https://framagit.org/a-guile-mind/guile-wiredtiger/blob/master/tests/okvs.scm) - SRFI 168: [code](https://framagit.org/a-guile-mind/guile-wiredtiger/blob/master/wiredtiger/nstore.scm) with [tests](https://framagit.org/a-guile-mind/guile-wiredtiger/blob/master/tests/nstore.scm) Or you are interested in the wiki?
FWIW, I discovered a flaw in the bindings, I am not sure how to fix it. Here is the program that fails when run over a large dataset https://git.sr.ht/~amz3/guile-gotofish
[https://www.gnu.org/software/guile/manual/html\_node/Guile-License.html](https://www.gnu.org/software/guile/manual/html_node/Guile-License.html) Guile is under LGPL and there is no constraint on the licencing of your app if it use it so I think it is not much of a problem unless your really want to modify the core of the lib. But that is probably quite rare. Also as said in other comments there are a lots of fundamentals differences between the two project more important than licensing.
Thanks for your comment. Licensing is one of those things I'm not too familiar with. Cheers.
Workin on an IRC bot from scratch using Guile’s 8sync library
I actually interpreted this question differently, as "Do cons cells (i.e., pairs) have identity?" In that case, the answer is yes: `(cons 1 2)` and `(cons 1 2)` return different pairs that can be distinguished with `eql?`.
The Guile REPL is GPL because it includes readline, but if you removed that, you could release a REPL under any license you like, because libguile is LGPL.
Working on SRFI 170 so I have an excuse for not writing tests for SRFI 160. I hate myself.
If you mean by "dotted" list an improper list. It's because a proper list ends with an empty list. But a "dotted" list ends with an atom of some kind. The dots are a way to display tuples which is why the dotted list doesn't mean much here as any list is made from tuples. Here's a proper list `(1 . (2 . (3 . '()))) =&gt; (1 2 3)` Here's an improper list `(1 . (2 . 3)) =&gt; (1 2 . 3)` So without the empty list, there is no way for map/reduce and such method to actually know when to end the algorithm and it would make the code more complex than checking for the empty list. For example a `map` call would map a method to each `(car)` of a list. In the case of an improper list, you'd have to map the to the `cdr` of the cons cell instead. At the same time it would require a check to see if `cdr` is a tuple or not. But in case a list is formed from custom cons cell, chances are that checking for the `con` type would be a bad idea. As for the reduce method, it's technically the same thing as the map but with an accumulator and the value is always the `car` of a `cons` cell. Think of it like many C languages requires a null char at the end of a string to detect the end of the string. Otherwise, a more complex data structure would have to store the length of the string somewhere.
Just convert the dotted list into an ordinary list. If we were to explicitly write out a list (showing the nil at the end of the list), it would look like this: (list 1 2 3 . nil) This is exactly equivalent to: (list 1 2 3) So, when you write: (list 1 2 . 3) You are removing that nil that tells pretty much any list-based function that it has reached the end of the list. Since you get no benefit in return, why store your lists in this way? Just store it in the standard form and your life will be much easier.
What about checking if something is a pair, then if the cdr of that pair is not another pair or null stop the iteration?
I mean, there are lots of ways to "solve" your problem that don't involve just re-consing the end of the list into standard form. Almost all of them will involve enormous performance penalties. Why is it important to keep your list in this form?
Then how do you tell a `(list (a b) (c d))` from a `(list (a b) . (c d))`? Inconsistencies like that add up and lead to a lot of exceptions and magic
Yeah is bit more complex, want to work with something like this. I guess the complexity is the reason. And is not entirely equivalent to the normal map. (define (imap fn lst) (let loop ((x lst)) (cond ((null? x) `()) ((pair? x) (cons (loop (car x)) (loop (cdr x)))) (else (fn x))))) (imap (lambda (x) (+ x 1)) '(1 2 . 3))
For some destructuring macro that accept arguments like (a b . c) for destructuring a list like (1 2 3 4 5 6 ) - this would bind `a` to 1, `b` to 2 and c to the rest (3 4 5 6) Pretty much the same semantics as the formals of a macro definition. Something like [this](https://www.reddit.com/r/scheme/comments/bo8d8i/why_map_reduce_and_other_list_functions_dont_work/endb2xr/?utm_source=share&amp;utm_medium=web2x) is what I am using at the moment.
I was thinking in something like [this](https://www.reddit.com/r/scheme/comments/bo8d8i/why_map_reduce_and_other_list_functions_dont_work/endb2xr?utm_source=share&amp;utm_medium=web2x). Seems to work with your examples. But I guess is more complex and less optimal than the normal functions.
It's not that I don't understand you, it's that I do understand and I disagree. You feel like `(1 2)` is the essentially the same thing as `(1 . 2)`, so since `(map double '(1 2))` is `(2 4)` then `(map double '(1 . 2))` should be `(2 . 4)`. Right? That's just not correct. `(list 1 2)` *is not* the same thing as `(list 1 . 2)`, even conceptually. Treating them as the same will lead to inconsistencies. It's easy to feel that way when all we're dealing with is integers, but when we start having more complex data types you start to see how it breaks down. Let's imagine that our 2D graphics library uses pairs like `(1 . 2)` for its vector type. Your feeling is that `(map double '(1 . 2))` on that type should be `(2 . 4)`, right? But what if we need a vector of some 2-dimentional quantity for a rotation matrix or something? So we have a vector of vectors, like `((1 . 2) . (3 . 4))`. Conceptually, this is a vector of vectors and we can reasonably address it that way. But it's *equal* to the improper list `((1 . 2) 3 . 4)`: the same bytes in memory represent both of those types. Your `imap` function would *do the wrong thing* to this list, it would just silently give wrong answers. And it would do that because it's making assumptions about the structure (that listness and atomness are the only defining qualities of a type) that aren't correct. If `map` did work that way, it would be impossible to work with pairs where an element is actually meant to be a list because it can't tell them apart. In general this is the problem with functions that try to be "clever" and guess the user intent instead of just trusting their input: it can't tell "I made a pair on purpose because I know what I'm doing" from "I just think pairs are the same as lists" and trying to autocorrect is going to result in guessing wrong.
I see. Thanks for the insightful answer. I see that this is a semantic problem and I agree, is highly more convenient.
This sort of definition is tricky as it wont work for all kinds of lists. Take for exampe an improper list of lists... say, `(imap (lambda (L) (append L '(1))) '((0 1 2) (3 4 5) . (6 7 8)))`. The user intended for the result to be `((0 1 2 1) (3 4 5 1) . (6 7 8 1))`, but instead will get an error about `6` not being a list.
What if my representation of list elements uses pairs?
im working on a lambda calculus interpreter. &amp;#x200B; I have implemented 'version 1' - it works on some expressions. no environment though so i cant name functions yet.
I'm working on scheme like lisp in JavaScript called [LIPS](https://jcubic.github.io/lips/) and I've recently started working on porting it to PHP it will called [LIP](https://github.com/jcubic/lip) in version 0.14.0 I think that lisp macros finally working without errors. PHP versions is mainly for people that only have shared hosting with LAMP and want to use LISP on the server. Lot of shared hosting have CGI but PHP is much better target platform that any CGI script.
There is certainly nothing \*wrong\* with your approach. Unfortunately I have not used the Chez FFI but do have experience here with other Schemes such as Bigloo and Cyclone. An FFI leads to a cleaner, more closely integrated solution, but the downside is your GUI will be tightly coupled to your Scheme backend. Depending on your architecture and future plans this may not make sense for your application. &amp;#x200B; One thing you might consider with your IPC, as the application scales, is if it makes sense to parse S-expressions from your C++ application. You might consider writing Scheme code (you won't need much) to covert them to a format that is easier to parse (and for which lightweight C++ solutions already exist) such as JSON before sending. This made things much easier for me when writing a web front-end to an existing Scheme-based solution. Since you are writing a native app you will have better choices for S-expression parsing, though :)
Thanks for your thoughts. The coupling you mentioned was one thing I was thinking about too. The engine is currently written against Chez, but I may decide to swap it later, or even support multiple Schemes. With the serialised approach the door is left open to that. That's certainly an interesting idea about using an alternative to s-expressions. I'm aware of at least one very good JSON parser for C++ ([this one](https://github.com/nlohmann/json)). And what do you know, there are several s-exp parsers too ([1](https://github.com/BitPuffin/sexpresso), [2](https://github.com/mjsottile/sfsexp), https://github.com/SuperTux/sexp-cpp). I will check them out. It's appealing to keep everything as sexpy as possible, but it does sometimes feel like the shape of my data could get too freeform - I'm using quite a lot of alists, for example, but there's nothing that really marks them out as such, they're just lists of pairs. I am a little bit worried about the details of my ad-hoc protocol getting out of sync on both sides. I think a suite of integration tests may be crucial if I keep going down this route.
Chez ffi is fantastic. Probably my favourite one. The only problem I have had with chez is that floats and doubles always are boxed in chez, so going back and forth between chez and C has quite some overhead.
Have you ever used Chez to call FFI into a GUI app that needs an event loop? If you have, do you have any strategies to help with that?
Awesome! Many current scheme implementations offer a compatibility layer over the host OS's API/resources, but it would be nice to have a more direct &amp; standardized set of procedures for working with my system. +1 for this SRFI 170!
Not a direct answer, but take a look at [akku.scm](https://akkuscm.org), a package manager for R6RS with pretty good Chez support. If you can't find a library here that does what you're looking for, you can always find a similar FFI GUI toolkit binding library and look at how they do things! I've only slightly messed around with it, and it takes some playing around with it to play nicely with Geiser, but I like the way it does things compared to other language package managers like npm.
I know I'm not the first person to run into this problem but the JSON data also has iso-8601 durations: "2019-05-27T23:00:00+00:00/P7DT13H" Now the 13 hours I can convert to seconds so I can convert the date to a time and use add-duration (for that matter I can do that with minutes and seconds, too.) But the days I can't (because 2 days after 12:00 is still supposed to be at 12:00 regardless of time change, whereas 48 hours is supposed to be 48 hours). All of this would be OK if there was a way for me to ask "When does the time change?" "How many days in this month?" "How many days in this year?" But I haven't found them. Is there something I'm missing?
The Chez FFI has to be one of the best high-level-language FFIs I've ever had the pleasure of working with. It's limited to calling C functions, but if all you need to is C interopability, I'd highly recommend trying it out. In terms of embedding Chez as a library... it's distinctly possible, but maybe not advisable. Launching Chez in-process and executing scheme files is easy enough, but having a fine-grained back-and-forth between C/C++ and Chez is another matter entirely. Chez isn't Lua or Guile, and has precious few mechanisms to integrate C/C++ with its garbage collector. Unless I'm mistaken, there's no way to tell Chez about external GC roots, so the object-locking mechanism is the only way to keep a scheme object from being collected when it's not referenced by scheme code. If you want to use a C++ framework for handling the GUI stuff and Chez for a scripting backend, then I think that your IPC route might actually be the best way to go. If you're open to other schemes I'd suggest taking a look at Guile, which is designed to be an extension language and uses a conservative garbage collector.
Assuming that the GUI app has a C API, I'm guessing you probably can. The Chez FFI has an incredible feature list, so to give a rough idea of what kinds of situations it can handle: - You can load arbitrary dynamic libraries and call C functions out of them by name. - You can call any C function by address, with the address given as a Scheme integer. This makes it possible to call C functions via function pointer. - You can describe almost any C data type in Chez using the surprisingly powerful `define-ftype` syntax (this includes `struct` and `union` types), at which point you can start manipulating individual fields using the `ftype-ref` and `ftype-set!` syntaxes, and even compute derived pointers using the `ftype-&amp;ref` syntax. - You can pass scheme strings to C as nul-terminated C strings, and scheme bytevectors to C as pointers to their contents. - You can generate C-compatible function pointers to arbitrary scheme procedures (including closures) using the `foreign-callable` or `make-ftype-pointer` syntaxes, so you can bind with callback-based APIs. - You can have an arbitrary nesting of C and Scheme calls (e.g. Scheme calls C which calls Scheme which calls C which calls Scheme, etc.), and continuations "just work" provided you don't try to return more than once from a C-to-scheme call. - The threaded version of Chez can optionally deregister a thread from the runtime when it makes a particular C call (e.g. one that blocks for a while) so that the garbage collector can run while that thread runs C code, and then re-register it once the C call returns. It can also handle C-to-scheme callbacks on threads that were deregistered using the aforementioned mechanism, or on threads that weren't created by Chez to begin with, and register them with the runtime for the duration of the callback. Both these are new features in 9.1, so be sure to see the docs on the `__collect_safe` calling convention. Of course, none of this is particularly relevant if it's _C++_ functions you need to call. Of course many ABIs use the same calling conventions as for C functions, so it would still be technically possible to invoke the right functions with Chez, but it would hardly be easy given name mangling and the complex semantics surrounding C++ ABIs. If you wanted to handle exceptions thrown by C++ functions, that would be extra difficult (and probably entirely ABI-specific).
Not a coops user myself, but I mentioned the issue you posted here on IRC and was told that the the problem with coops is known and is being addressed: https://bugs.call-cc.org/ticket/1583
Thanks for your thoughts. It seems the Chez FFI is universally well-regarded. And from your comment above, it seems very powerful. Sending callable pointers to Scheme procedures over to the C++ app sounds very interesting - GUI events could then trigger Scheme procedures with no extra ceremony. The thread-related features you mentioned put my mind at ease too - I think dealing with the GUI event-loop thread will be one of the challenges of this approach. It's definitely reassuring to me that this is a path I could go down, though as you mentioned I'd have to write a C wrapper to my C++ app. That's not too bad though. I'm not exactly using Chez as a scripting backend - it forms the main engine of my app. I just need the C++ frontend for visualisations and as a code editor. I don't want to inflict Emacs on my users, and it will let me do more stuff specific to my DSL. The C++ framework I'm using already has a decent (if basic) text editor in it and I'd rather not write one from scratch if I can avoid it! I think for now I will push forward with an IPC/serialised approach, because I can get going quickly. But your comment has given me great confidence that if I need to go there, the Chez FFI will give me all the tools I need to make a tighter integration. I really appreciate your input!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/guile] [Last call for comments on SRFI 167: Ordered Key Value Store and SRFI 168: Generic Tuple Store Database](https://www.reddit.com/r/guile/comments/bw936h/last_call_for_comments_on_srfi_167_ordered_key/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
[TSPL](https://www.scheme.com/tspl4/) has some "extended examples" in chapter 12. Not sure how comprehensive it is to your liking.
It would be nice if the example applications in [Practical Common Lisp](http://www.gigamonkeys.com/book/) were converted to scheme. Look at these practical chapters: &amp;#x200B; 1. [Practical: A Spam Filter](http://www.gigamonkeys.com/book/practical-a-spam-filter.html) 2. [Practical: Parsing Binary Files](http://www.gigamonkeys.com/book/practical-parsing-binary-files.html) 3. [Practical: An ID3 Parser](http://www.gigamonkeys.com/book/practical-an-id3-parser.html) 4. [Practical: Web Programming with AllegroServe](http://www.gigamonkeys.com/book/practical-web-programming-with-allegroserve.html) 5. [Practical: An MP3 Database](http://www.gigamonkeys.com/book/practical-an-mp3-database.html) 6. [Practical: A Shoutcast Server](http://www.gigamonkeys.com/book/practical-a-shoutcast-server.html) 7. [Practical: An MP3 Browser](http://www.gigamonkeys.com/book/practical-an-mp3-browser.html) 8. [Practical: An HTML Generation Library, the Interpreter](http://www.gigamonkeys.com/book/practical-an-html-generation-library-the-interpreter.html) 9. [Practical: An HTML Generation Library, the Compiler](http://www.gigamonkeys.com/book/practical-an-html-generation-library-the-compiler.html)
&gt; First you pick the Scheme implementation you like the most, Chicken Scheme of course. Then you notice it provides an amazing foreign interface to call C libraries. And boom it clicks. &gt; We will use the Chicken compiler and get the language we want. And we will write simple interfaces to the best C libraries, making them feel all Schemy. &gt; The language we love, every library we could ever need. Interesting
Nice :) Did you considered providing eggs ?
OK I think I figured out the meaning. It's just a name, like the `a` in `a = 4` in Python.
It depends on the context what \`(a b)\` means, but essentially you need quotation to distinguish data from code sometimes. For example, in an evaluation context like the body of a function, \`(+ 2 3)\` means "the function \`+\` applied to arguments \`2\` and \`3\`" (i.e., 5). What if you want to represent "the list of three elements: \`+\`, \`2\`, and \`3\`" though? Not 5 in the end, but literally that list? You need to quote it: \`'(+ 2 3)\`
You know how strings are a data type? (define a 1) (define other-variable "a") `other-variable` is not related to the variable `a`; the value `"a"` is not the same as the variable name `a`. Similarly `'a` is a data type like a string (but different from it). This data type is called a _symbol_. So `(list 'a)` is similar to `(list "a")`; it creates a list with one thing in it.
Another way to look at it is that Scheme (and other lisps) use symbols to represent variables, so that when you need to have the symbol represent a literal symbol in a program, instead of a variable, you have to "escape" it. It's analogous to having strings represented in Scheme by characters delimited by quotation marks, so to represent a quotation mark in a string, you have to escape it with a backslash. e.g. "The following \"a\" is quoted."
Also \`'\` is just syntactic sugar for \`(quote \_)\` In short it's just telling the interpreter what to evaluate and what to not evaluate.
Trying to translate this into conventional programming languages confused me for a long time, but here's how I think about it now. Hopefully I've finally gotten it right! The *identifier* `a` can be bound to a value like `4` (as you did in your Python example), but `'a` or `(quote a)` is something else; it designates a *symbol*. Symbols are like strings in that two symbols are equal iff they are spelled the same, but they can *only* be compared for equality. They are not ordered and they cannot be split into characters. You might be able to convert a symbol to a string and vice versa, but that's about it. Some authors like to like to say that symbols are unevaluated identifiers, and some don't. I'm sure that there are some technical issues of which I am not aware.
For an example, '(+ 3 a) is a list containing 3 elements: a plus symbol, an integer with value 3 and a symbol a. (+ 3 a) is an expression which evaluates to 3 plus the current value of the variable a, which must already be defined or you will get an undefined symbol error.
Use lambdas. There are no objects in "vanilla Scheme", so you can basically implement your own object system. There's a great book about Scheme, called SICP, [you can find it here](https://mitpress.mit.edu/sites/default/files/sicp/index.html).
Not directly answering your question, but you might find [this collection of pages on "Object-oriented programming in Scheme"](http://people.cs.aau.dk/~normark/prog3-03/html/notes/oop-scheme.html) helpful.
I just love that stuff.
It's up to you, Scheme's feature-rich but maybe not well documented. I use record types (SRFI-9) for general "objects", hash-table (SRFI-69) for dynamic objects. But if I just have a simple structure, lists, vectors, or alists and some functions to manipulate them are easiest. I don't use coops, but it's there if you want a full object system.
For the simple thing OP wants you should most certainly not roll your own using lambdas and closures. That is a perfect use case for srfi-9 records (define-record-type is available in chicken without extra imports). If you want object orientation there is coops for chicken.
For that you should use srfi-9 records. If you want dispatch based on data type with overloading and all that jazz you should use one of the object systems, but if you just want to send structured data around define-record-type is what you want.
As already said, Chicken have COOPS which is the "standard" full-blown object oriented system. However, being inspired by CLOS (common lisp object system) like other scheme object oriented libs (at least also guile's one, GOOPS), is very different from the object models from mainstream languages like js prototype or js/python/ruby/java/c++ classes (those are all quite similar). Coming from python and js I personally cannot get used to COOPS and use to build record and closure based custom systems that give something very similar to js prototypes. I am not sure how efficient it is and I probably would not use this kind of system with a program that have several instances of my prototype because I believe that each instance hold a copy of its methods (not sure how the compiler optimize things though). If you need data object, without methods records is the best choice, srfi-9 for Chicken.
The simplest way to have objects is to use Alists (they are just standard lisp structures available in every lisp), it's just list of key value pairs just like in JavaScript. (define person '((name . "foo") (age . 0))) (cdr (assoc 'name person)) ;; "foo" (cdr (assoc 'age person)) ;; 0 to create pair you ca also use cons function, but you need to write some utilities, if you want to grab the value because it will throw error if don't find the value. Because assoc will return empty list or false and cdr will fail to get the value. so you can use this function: (define (value key alist) (let ((pair (assoc key alist))) (if (not (null? pair)) (cdr pair))))
Your examples is just creating a dictionary/hash, where you're treating the keys as field-names. If that's what you want, you can do exactly the same thing (using an association-list or a hash table, as /u/jcubic mentions). A bit more structured would be to use a 'struct', and this is in the same spirit as most other posts here: (define-record person name age) (define p1 (make-person "foo" 0)) (person-name p1) ;; "foo" (person? p1) ;; true [docs](https://wiki.call-cc.org/records-and-oop#variant-records-and-object-orientation) It looks like Chicken also has a variant which provides "functional updates" (instead of changing a field, it returns a new struct with that one field updated, leaving the original unmutated): [defstruct](http://wiki.call-cc.org/eggref/5/defstruct)
Few years ago I've created Common Lips like defstruct macro (it use alists) for Guile Scheme, that didn't have such nice structures, they can probably be used with any scheme, if they already don't have them, they less efficient because they need to iterate over list to find the filed but with small structures it should not matter (unless this is bottle neck) Here is the code: https://jcubic.pl/struct.txt here is same code in a blog post with example usage (I probably should add this to comment at the beginning of the file) https://jcubic.wordpress.com/2010/05/17/structure-implementation-in-guile/ the macro generate bunch of functions but the name of the macro is defstruct instead define-record like in CL.
I'm not sure about speed, but it seems [chibi](https://github.com/ashinn/chibi-scheme) is pretty much designed for what you have in mind (embedding as extension/scripting language), and it's fully r7rs small compatible. There's a note on the README about 'basic' windows support that I haven't looked into though.
Yeah, chibi is currently the frontrunner, from the ones I've tested. Though, there are a few things going against it, which is why it still up in the air: \- Per the author, he doesn't own a Windows machine and so generally can't test there. \- There's a tiny bit of documentation, but it is generally lacking. \- Doesn't fair well in these benchmarks: [https://ecraven.github.io/r7rs-benchmarks/](https://ecraven.github.io/r7rs-benchmarks/) &amp;#x200B; My first choice was actually Racket, since the documentation is excellent and the speed is amazing(per the benchmarks above). However, even thought there is a portion on their website which discusses embedding, you can tell that it's not really designed for that. It wants to be called and then own the execution of the program. So, it's not designed to be called intermittently, how one would do so in a game engine. Also, I was having a hard time even running the embedding examples on the website; the code kept segfaulting, even on a plain main.cpp file. Finally, it's LGPL.
Right. I know those benchmarks well. However, I really encourage you not to be swayed too strongly by them - yes, racket is fast, and chibi may be slower for these particular benchmarks, but it may be good enough or even exactly what you need for your use case. Pure speed might not be something you need out of an extension language, generally, but is also not very well defined depending on the use case. Basically, try it and see. Someone else's tests that measure a specific aspect of a language are no match for your own tests and can't account for other factors like ease of use or how well it will work for your own project. Don't 'pick the fastest', pick the right tool for the job. As an aside, I've had an annoying time trying to embed racket too, but I'm a fairly novice C programmer
I don't think there's any fitting all requirements. Here's a few coming to mind, with their shortcomings: - Guile (R6RS, GPL, untested on Windows) - Chibi (slow, LGPL, untested on Windows) - CHICKEN (R7RS support bolted on, not designed for embedding, compiles to C) - Tinyscheme (R5RS subset) - S7 (Tinyscheme with extensions) - Picrin (broken,untested on Windows)
As you mentioned chicken: there is the egg called defstruct. You would construct, read and write person objects as following: (defstruct person name age) (define *hugo* (make-person name:"hugo" age:42) (display "name:" (person-name hugo)) (person-age-set! hugo 41)
&gt; Runs either bytecode or JIT, so not one that compiles to C code or machine code. Chez can be embedded, but it's not R7RS. Not quite sure how you want JIT without generating machine code, though.
How about Lua with fennel on top? Might be worth considering.
From what I've read online, Chez 'can' be embedded, but it wasn't designed for that, so the API is weak in that regard. Chez wants to be incharged. A good thing about Chez is that it looks like it's the fastest Scheme implementation. &amp;#x200B; &gt;Not quite sure how you want JIT without generating machine code, though. I mean, no compiling to C code or to native libraries (.dll, .so)
Thanks for the suggestion. Currently, I'm hoping to find a C/C++ native Lisp/Scheme that fits my requirements, so hopefully I can find one.
Chibi was the main contender. Still in the race, but I'm not crazy about it because Windows it not a primary target. Btw, Chibi is not LGPL: [https://github.com/ashinn/chibi-scheme/blob/master/COPYING](https://github.com/ashinn/chibi-scheme/blob/master/COPYING)
Good catch, fixed.
I think embedding Chez is not too hard. I wrote a brief intro on embedding Chez Scheme in a C/C++ program: https://www.reddit.com/r/scheme/comments/a3oogf/questions_on_embedding_chez_scheme_into_a_c_app/ed2b3us/ In addition to everything in there, I should add that the custom init procedure allows you call Sregister_symbol or Sforeign_symbol before running the code in the boot files. You probably want a custom boot file to set up the C++ -&gt; scheme bridge as it's easier to create from the scheme side than C++.
From that post, you mention that the functionality for calling from C to Chez is meager. For my app, which is a game engine, I must have the engine in control, calling specific scheme functions at specific times. From the example, you have Chez load-up a library file and call its functions. That's a big no-no, for my usecase. Neither is I/O, and other unsafe operations. &amp;#x200B; What I'd like to do is: \- During init, setup the scheme environments. There would be more than one running focusing on different things. \- At certain points during the session lifetime, load some scripts to setup up the environment for the next phase. \- At different times during the game, the engine would be dealing with different scheme script. For example, if you're at the main menu, those scripts would be different than if you're at some level of the game. \- From the engine side, I would get ahold to reference to well-known scheme functions, and call those depending on certain events. For example: \-- call 'OnPlayerInput' to handle joystick input. \-- call 'OnCollision' to handle 2 entities colliding. \-- etc. \- I would want to turn the GC on/off during certain times. Since the engine knows the state of the game, it knows when it can have the GC running without affecting framerates. &amp;#x200B; I still have this feeling that Chez is not a good candidate for this. Though, believe me, I'd love to be wrong, in thi case, since Chez's performance is the best.
Not the GP, but I think you may want to take a closer look at some of the fine-tuning knobs and dials Chez exposes, because I strongly suspect that it can work for what you want. * Chez has multi-threading support even on Windows (GC is single threaded). May or may not matter for your use case. * If there’s some reason why you can’t load all the scripts as part of the boot image or immediately thereafter, Chez can still load code at arbitrary times. (There’s some more nuance for the multi-threaded version.) * Chez gives a _lot_ of hooks into the garbage collection behavior. I haven’t needed these myself, but I imagine these are what you’re looking for: * https://cisco.github.io/ChezScheme/csug9.5/system.html#./system:s27 Running blocks with the GC disabled * https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s9 to force a GC (evaluation) * https://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s17 Can be used to disable the GC outright
&gt; From that post, you mention that the functionality for calling from C to Chez is meager Calling any arbitrary scheme function from C *without prior setup* is not great[1]. However, it's easy from the scheme side to create scheme functions that can be called from C and store those foreign callable functions in a place that's easy to call from C. I gave an example of that in the linked post. If you decide to use Chez, my recommendation is compile a custom boot file that creates the scheme functions you want and exposes them to C. You can disable the GC pretty easily: http://cisco.github.io/ChezScheme/csug9.5/smgmt.html#./smgmt:s17 You would then need to call the collect function manually. --- 1) Chez provides 3 convenience functions for calling into scheme: Scall0, Scall1, Scall2. They accept 0, 1, and 2 arguments respectively and are expected to be scheme data types.
Did you actually read the link you posted? It's shocking well documented haw to embed chibi scheme into a c program. They give you example code and everything so you should be able to copy paste code to answer at least half of your questions. Did you try running the examples given in the documentation?
Cool, it sounds like this is really easy for you. &amp;#x200B; How do you do this one? 3. The loaded file prints something from the scheme side to the C stdout.
It's not really about me. It just bums me out when someone brings a 9 point bulleted list to a forum like a project manager and expects people to do their work for them. My thoughts on your more specific question: If you eval a scheme printf, your likely going to get just the side effect (the actual printing to the screen). Sounds to me like you want to load a scm file into a buffer in c, eval that buffer with embedded chibi as in the example code to get a return value into a c variable and then print it from c.
I'm confused. So, have you successfully embedded chibi into an app before?
Nope. I just looked at the docs because chibi sounds cool. Back to the specific question. Does what I said in my previous comment make sense? Do you agree that you want to evaluate a scheme function that returns a string and then print from c? Doesn't that seem pretty doable since the example code shows you how to eval a chibi sexp and get the return value in c?
&gt;...example code shows you how to eval a chibi sexp and get the return value in c. &amp;#x200B; I didn't see this part in the example. Which part of the document is this in?
http://synthcode.com/scheme/chibi/#h3_ContextsandEvaluation
See section: Embedding in c -&gt; quick start -&gt; a sample program might look like See functions: Sexp_load Sexp_eval Sexp_eval_string Read about all the functions lower down in the document. In fact read everything from the quickstart until the end. Looks like they throw away the return values of the evals in the example, you obviously don't want to do that, so save them.
[Look no further](http://wiki.call-cc.org/chicken-projects/egg-index-5.html#oop)
I hate to admit it, but I never ran across Akko before. Really nice! One reason why I don’t use Chez more (I usually use Common Lisp, sometimes Racket) was a batteries not included issue. Also, a great screen capture demo. In 30 seconds, I understood that it is like Anaconda for Python.
Author here. If you have any questions that you don't want to post to the mailing lists I am happy to answer them here.
i don't have a question, but i *would* like to thank you for the 'Rationale' section of the SRFI. i've not been able to understand the fuss over transducers in the Clojure world, because the explanations i've read seemed to suggest they're merely trendily-named higher-order functions. But the 'Rationale' section, and in particular the sentence: &gt; Transducers are oblivious to what kind of process they are used in, and are composable without building intermediate collections has succinctly helped me get a sense of what they're actually about. :-)
Just wanted to say: I'm happy to see this work!
Thank you. I am not a programmer by profession nor am I a technical writer. I spent quite some time thinking about how to express myself about certain concepts. I am very glad it seemed to have paid of.
Lists are function calls, and you can't call a not specified function.
What do you hope to accomplish by translating lambda to define? IMO, Scheme notation is not really a good notation for understanding Lambda Calculus, which is the basis for Church numerals. I would rather write (where \ == lambda): 0 == \fx.x 1 == \fx.fx 2 == \fx.f(fx) 3 == \fx.f(f(fx)) and S == \nfx.f(nfx) and go from there. Lambda calculus (LC) is mathematics rather than programming in the sense you are used to, and it really benefits from a more suitable (i.e. terse) notation. Given S (successor, the same as ADD-1), 1 == S0 2 == S(S0) 3 == S(S(S0)) etc To see how it works, use the rules of LC to convert a form, like S0, to its normal form: S0 == (\nfx.f(nfx))(\fx.x) ==&gt; (\fx.f((\fx.x)fx) ==&gt; (\fx.f((\xx)x) ==&gt; \fx.fx == 1 Each ==&gt; above indicates one beta conversion step. The beta conversion of a form is basically what would be function application in Scheme: (\x.fx)y ==&gt; fy means: substitute each (free) x in fx by y, giving [fx/y] -- fx with (free) instances of y replaced. In the first step, \n is "applied" to 0==(\fx.x), giving the result in the next line. Note that the \n is missing in the next line, because the function has been applied (or, rather, the form has been beta-reduced). In the next step, the inner form (\fx.x)fx) is reduced to (\x.x)x and then (\x.x)x to x, leaving the final (normal) form \fx.fx which is syntactially equal to 1. If you excuse the plug, there is an introduction to LC in my book, [Compiling Lambda Calculus](http://t3x.org/clc/index.html). I also covers Church numerals (including division!) in detail. Lambda Calculus is not (normally) something you dive into for half an hour and then it clicks and you get it. It takes some getting used to, like many parts of mathematics. No understanding it will not harm your further progress in SICP.
Great answer, informative easy to understand. Thanks!
Never heard of Akku either, but isn't CL also "not batteries included" ? Once you have quicklisp it kind of is, but anyway, per se, its not....
&gt; Lambda Calculus is not (normally) something you dive into for half an hour and then it clicks and you get it. It takes some getting used to, like many parts of mathematics. Not understanding it will not harm your further progress in SICP. Got it. Bookmarked your reply, will be diving into lambda calculus from time to time. Thank you very much.
Feel free to create pull request for your favorite Scheme project(s). They must be up-voted 10 times before being included in the list. Try to stick to the existing sections. Tho, creating new sections is allowed.
I'm not an especially good Scheme programmer, so if any of these thoughts are incorrect or misleading, I invite clarification. That said, say () was a function call. What would be gained? Presumably we're recognizing a symbol with a length of zero. Now we have the name of a function to call. That call would return an empty list, so that expressions like '(2 . ()) would still work as expected. But then, if you have a space after the opening parenthesis of a different call, we have to assume that it's preceded by the zero-length symbol. So: ( print 1) would actually be something like (() print 1), and the empty list isn't a function, so you'd get an error. In fact, you'd start seeing that zero-length symbol all over the place. Or you could just let () represent the empty list, and (()) represent the not-very-useful attempt to call the empty list as a function.
Yes. I understand that list are interpreted as function calls, and thank for your response. However, in most of the more popular scheme's the character sequence "()" does not represent a list (nor a function call). It represents the value nil. Perhaps another way to state the question I'm trying to ask is: "Why must nil be quoted (i.e written as "'()", or "(quote ())"), instead of as just "()"? Was that an arbitrary decision by the standards body, or is there some deeper semantic reasoning behind it?
There is no "nil" in Scheme. From a mathematical point of view it's pretty nonsensical to define a self-evaluating symbol to be the same as the empty list (and vice versa), so they got rid of it. So the answer to your question would be "mathematical sinplicity". I can't stress this enough: The empty list is nothing special, it's just an empty list. And lists are function calls.
Thanks. I'm not sure I follow. I'm not suggesting that "()" be interpreted as a function call. I attempted to clarify my question in my response to opinion\_rings. It's my understanding that "'(2 . ())" represents a pair which, incidentally, represents the "proper list" "(2)". Perhaps yet another way to state my questions is: I don't have to quote a number such as "1". Why do I have to quote the value nil, and more importantly (to me) is what is the rationale?
I don't mean to come across as rude, but I honestly don't understand your rationale. You say it is nonsensical to define a self-evaluating symbol to be the same as the empty list. How is that nonsensical? The character encoding "1" represents the number 1. A "proper list" is a sequence of pairs that end with the \*value\* "nil". I would say there are no real "lists" in scheme. There are pairs that can be chained to represent a list, but I don't understand why you say there is no such things as "nil" in scheme.
&gt;A "proper list" is a sequence of pairs that end with the *value* "nil". This is how a list is usually *represented*, but that's not what a list *is*. &gt;but I don't understand why you say there is no such things as "nil" in scheme. In Scheme, lists and symbols are completely separate things. Just like a vector in maths is not a variable. Lists are defined in a recursive way: a list can be either a pair (containing the first element and another list), or the empty list. Note that this definition doesn't even mention things that aren't lists. No symbols here! The empty list is therefore not a "special" list terminator, *it is by definition a list*. Sure, it serves as the terminator for the recursive definition of lists, but that doesn't stop it from being *nothing more* than just a list. And since lists are always function calls, "()" can't evaluate - it contains no function. Lists in CL on the other hand are defined as *linked pairs terminated by nil (a symbol)*. The fact that NIL is both a symbol and a list breaks the evaluation rule, since NIL is treated as a symbol by the evaluator (and not as a list!). So Scheme's behavior isn't the exception, Common Lisp's behavior is the exception.
The fact that a proper list ends in nil, and there is a nil in scheme, does not mean nil (spelled ()) can't evaluate to itself. Math has nothing to do with this. (In scheme the empty list is special -- it has its own type, separate from pairs). Lists are not restricted to being function calls. And an improper list is still a list no matter what standard scheme's misnamed "list?" function thinks.
&gt;and there is a nil in scheme There isn't. It's called the empty list, and it's a list. Type in (cons 'a 'nil), and the result won't be (). Type in '(), and the result won't be NIL. &gt;does not mean nil (spelled ()) can't evaluate to itself It could, of course, but not in Scheme. &gt;Math has nothing to do with this Recursive definitions aren't part of maths anymore? &gt;In scheme the empty list is special -- it has its own type, separate from pairs But not separate from lists. And a list counts as a function call, not a pair. &gt;Lists are not restricted to being function call They are in Scheme. Look at the spec. &gt;And an improper list is still a list no matter what standard scheme's misnamed "list?" function thinks. That has nothing to do with what I was talking about.
Are you saying that in "Common Lisp" "()" \*is\* the value "nil"? I'll admit I'm approaching all dialects of "lisps" from the specification of "scheme" (that may not be entirely true because my memory often fails, hence my confusion). Anyway... You state: "lists and symbols are completely separate things". I'll buy that, but isn't "()" just a symbol representing "nil"? Aside: how do you describe a list recursively without having to distinguish between a continuance of a sequence and a termination of a sequence without having both "pairs" and "nil" respectively?
I said it was spelled () -- (cons 'a '()) is '(a) -- why would it be ()? The recursive definition says nothing about the evaluation of (). The spec does not say all lists are function calls --- that would be idiotic.
&gt;Are you saying that in "Common Lisp" "()" *is* the value "nil"? Yup, they are the same object. Literally the same object. &gt;I'll buy that, but isn't "()" just a symbol representing "nil"? In Common Lisp, yes. It's different in Scheme, though. In Scheme it's a *unique* object called *the empty list*, not a symbol. &gt;Aside: how do you describe a list recursively without having to distinguish between a continuance of a sequence and a termination of a sequence without having both "pairs" and "nil" respectively? Well, that's not what I meant. I meant that in Scheme one can build a list entirely out of lists (i.e., only pairs and the empty list, which is a list). In Common Lisp, you build lists out of pairs and one specific symbol (nil). Therefore, a list in CL is "not pure" in the sense that it can't be built entirely out of lists (since NIL is a symbol).
&gt;I said it was spelled () Even then it wouldn't be nil, because nil is also a symbol, and () is *not* a symbol. Therefore, () can't be nil. &gt;(cons 'a '()) is '(a) Yes, but (cons 'a 'nil) would be (a . nil) - an improper list - in Scheme, not (a), because Scheme's lists don't end with a nil, they end with the empty list. &gt;The recursive definition says nothing about the evaluation of () Correct. &gt;The spec does not say all lists are function calls Every list that is passed to the evaluator is treated as a function call. Since empty lists don't contain a function to call, passing them to the evaluator results in an error.
"what I say 3 times is true" I think we're talking past one another, but just for completeness, I mentioned improper lists because I don't accept the recursive definition of a list.
I hate to keep pressing you on this, but really don't understand \*why\* "()" is invalid as a symbol that represents nil (the termination of a list). I also still don't understand how you can recursively specify a list without two distinct "things" that represent 1. the continuance and, 2. the termination of a list. How do you build a concrete list without two such "things" (pairs and nil)?
&gt;but really don't understand *why* "()" is invalid as a symbol that represents nil (the termination of a list) Because it's not a symbol in Scheme. That's how Scheme works. The reason why it works in Common Lisp is because it's defined as NIL there, which is a symbol. &gt;I also still don't understand how you can recursively specify a list without two distinct "things" You can't, and I didn't claim that you can. Look, the "list terminator" that ends the recursion in the definition is (), *but () is not a symbol* in Scheme. It is a completely separate data type. *The only difference between NIL in Common Lisp and () in Scheme is that NIL is a symbol and () is not a symbol*. *Since NIL is a symbol in Common Lisp, you can evaluate it and it will return its value, which is NIL*. *Since () is not a symbol in Scheme (but a list of zero elements), you can't evaluate it*. *And a list in Scheme in both Common Lisp and Scheme can be either a pair or the list terminator. In Common Lisp, the list terminator is NIL (a symbol, see above), and in Scheme, the list terminator is (), which is not a symbol*.
&gt;"what I say 3 times is true" That is a complete misinterpretation of my intentions and not very respectful. &gt;I mentioned improper lists because I don't accept the recursive definition of a list. Just because you can define lists recursively doesn't mean that you can't define lists in another way. I was talking about how you can build up lists recursively, not how you can build up *every list that is a valid (but improper) list in Scheme*.
Okay. Does that mean scheme is under specified and leaving room for future efforts to explain what they cannot? Can you please help me understand the rationale that "()" is NOT interpreted as NIL in ALL schemes? Is it because, as you state, you cannot. Or is it just an arbitrary decision by the standards comity to leave things open until somebody figures it out? I've stated a couple of times I'm mostly interested in the rationale, rather than the status quo.
The intention was to keep Scheme simple and not obfuscate datatypes, so, instead of introducing a special symbol that is both a symbol and a list they came up with the null-object "()". They essentially got rid of the fact that there's a symbol in memory that is different from the others. So it's basically all about efficiency and having a clean concept. By the way, the same happened to T, which doesn't evaluate to T anymore. They introduced booleans instead, which replaced the boolean identity of T and NIL.
Please forgive my apparent ignorance, but I don't understand how the pair \[a-value, nil\] can be represented as anything but the pair \[a-value, nil\] in memory. How is having a memory location that represents the value "nil", and (two distinct byte addressable) memory locations that represents the value that is a pair \[something, possibly-something-else\] an obfuscation of data types? That there are (at least) two different "things"/"values" seems intuitive to me. Perhaps I just don't get it from the point of view of implementation. I thank you for you responses regardless.
The obfuscation doesn't lie in the pair, it lies in the fact that the list terminator in Common Lisp (NIL) is *both a symbol and a list* (the empty list). This breaks the barrier between symbols and lists. Introducing a list terminator that is not a symbol ("()" in Scheme) resolves this conflict. Again, just for clarity: Evaluating "()" in Common Lisp is the same as evaluating "NIL" in Common Lisp, since "()" is just a fancy name for the symbol "NIL". Since "NIL" is a symbol, the interpreter looks its value up and spits it back at us (the result is "NIL"). --&gt; Common Lisp is not evaluating a list when we type "()", it actually evaluates a symbol. On the other hand, evaluating "()" in Scheme means that you want to evaluate the empty list in Scheme, *which is a list, not a symbol* (since the people behind Scheme didn't want to introduce a datatype that is both a symbol and a list of zero elements). Evaluating a list means that you want to call a function, but since the empty list contains no function name, you can't call it. That's why it produces an error.
I just ran into this problem. I am writing a program to assist with determining which to buy - two small pizzas or one larger pizza. As part of my program I include a section to get input from the user: (define (pizza-compare ) ; get data from the user (display "smaller pizza diameter: ") (define smaller_diameter (read)) (display "smaller pizza price: ") (define smaller-price (read)) (display "larger pizza diameter: ") (define larger_diameter (read)) (display "larger pizza price: ") (define larger-price (read)) (let* ... (rest of the program here) Racket is allowing this but Gambit is not ("Ill-placed 'define'") . It needs to work on Gambit because I am using that on my IPhone. I am still new to Scheme, I found this pattern while looking around at http://www.cs.grinnell.edu/~rebelsky/Courses/CSC151/2016S/readings/simple-input-reading.html The other pattern I have heard about is the one where I nest _let_, which seems like a really painful way to handle getting data interactively from a user.
Incidentally, MIT Scheme does treat the empty list as self-evaluating.
Yes, but this is a nonstandard addition, not a feature.
This is pretty cool, looking forward to using it when it gets more mouse control. Nice work
Very nice.
To reply to my own question: it took a couple days (I was distracted) but the answer is to do this instead: ... (define (prompt text) (display text) (read)) (define (pizza) (let* ( (smaller_diameter (prompt "smaller pizza diameter: ")) (smaller-price (prompt "smaller pizza price: ")) (larger_diameter (prompt "larger pizza diameter: ")) (larger-price (prompt "larger pizza price: ")) (smaller-sq-in (circle-area smaller_diameter)) (larger-sq-in (circle-area larger_diameter)) (smaller-sq-ft (/ smaller-sq-in 144)) (larger-sq-ft (/ larger-sq-in 144)) (dollars/smaller-sq-ft (/ smaller-price smaller-sq-ft)) (dollars/larger-sq-ft (/ larger-price larger-sq-ft)) ) ...
I have several items in my todo: * Change the licence of arew to Apache 2.0, * To do that, I need to extract the GPL-only part, so I thought building [yet-another-functional-package-manager](https://github.com/scheme-live/sin#abstract) would be nice * I still need to port my work on [qadom](https://github.com/amirouche/qadom) to scheme for which I started to [document the interface](https://github.com/scheme-live/peer-to-peer-network) * Still working on SRFI-167 and SRFI-168
An implementation of R7RS-small. And a text-based fantasy RPG.
Why not just use guix? I speculate you are trying to do something similar to guix, only using another scheme implementation instead? I packaged guile-wiredtiger for guix some time ago and I really enjoyed using the grf3 interface. It appears the package has split into smaller more relevant components, which I think makes complete sense. I have shelved my data-mining experiments temporarily to work on some other projects, so I haven't kept up with the changes..
I haven't done much in scheme in ages. Should do something about that... Just don't know what.
Nothing Schemey sadly. Just CLR/C# stuff. Though, I do walk the AST and do compile time and runtime codegen in C#. I have toyed with using IronScheme as a config/gameplay layer, but I havent done it yet.
I think its good to use radically different languages periodically to keep thought patterns fresh and not just more of the same.
FWIW, we are looking for contributions to [awesome-scheme](https://github.com/schemedoc/awesome-scheme/), this is not a coding task, basically documentation task. I have too many ideas to implement everything myself, like I discribed in my post on the same topic. Maybe pick one of them. Otherwise what do you like?
Microsoft released a scheme-based configuration language but I can not find the link right now.
&gt; Why not just use guix? The main reason is that I want to bridge the gap with python's pip useability in the sense it shoud require no super user rights at all. &gt; It appears the package has split into smaller more relevant components, which I think makes complete sense. The grf3 interface was superseded by SRFI-168. You can implement grf3 on top SRFI-168. Or you could go the SRFI-167 route and implement a linked-list based graph abstraction. I find those less useful than SRFI-168 but maybe it makes sense for you. Also I recommend not hiding the SRFI-167 interface, but hiding it, like grf3 did, reduce cognitive load.
Nice! Id love to see it whenever you find it.
I do have a bunch of kawa specific libraries I need to polish up for an actual release. And I've been toying with the idea of making a heavyweight sqlite egg for chicken with a bunch of extension modules bundled in. But what I'd really like to do is some actual program, not just libraries. I just can't think of anything that would be useful to me that I don't already have installed.
Maybe this? https://github.com/Microsoft/schemy
First off, congratulations on writing this. &amp;#x200B; It's definitely interesting, but i need \_way\_ more documentation before I really use it. I have no idea what the key bindings are or ... well anything. I'm assuming it's \_not\_ a modal editor, but I'm not sure. &amp;#x200B; I definitely need more docs before I can write a plugin for it, and I've got enough side projects that I'm not inclined to spend a lot of time reading the source code to figure out what I can and can't do with extensions. &amp;#x200B; Other questions: * does it support syntax highlighting for languages other than scheme? * how do you write a new syntax highlighter if it doesn't?
Sagittarius?
Scheme Spheres
Looks really neat.
If you're looking for a single document version of the report, I don't think it exists. They probably won't release one until the R7RS-large is complete. The results of the Tangerine Edition were [announced on the R7RS Working Group 2 mailing list](https://groups.google.com/forum/#!topic/scheme-reports-wg2/ZDG-J5Mi2og) on Feb 2019. The definition (really just a list of SRFIs that passed the vote) can be found [here](https://bitbucket.org/cowan/r7rs-wg1-infra/src/default/TangerineEdition.md). For more info on the previous (red) edition and the future editions, you may refer to the [R7RS hompage](https://bitbucket.org/cowan/r7rs-wg1-infra/src/default/R7RSHomePage.md).
Thanks.
There is \[guile-r7rs\]([https://git.sr.ht/\~amz3/guile-r7rs](https://git.sr.ht/~amz3/guile-r7rs)) and \[arew scheme\]([https://git.sr.ht/\~amz3/chez-scheme-arew](https://git.sr.ht/~amz3/chez-scheme-arew)).
This incomplete but I put together SRFI specifications into a single pdf https://git.sr.ht/~amz3/chez-scheme-arew/tree/master/arew-scheme.pdf
Well done! Keep going!
Not a schemer, but I've just begun trying to translate Schorre's "Metta II A syntax-oriented compiler writing language" from the 1960's. It's a paper that Joe Armstrong recommended a few years ago. I think Alan Kay took the ideas further in his OMeta language. BWTFDIK. It got me thinking the other day about Snobol, another relic from the past. Despite its age, it can do some backtracking on its matches, and features gotos. Much lambasted today, gotos are useful for creating state machines, which is exactly what you want if you're building a compiler. It's difficult to work out whether the state of the art in computing is actually progressing or regressing.
Im seriously contemplating purchasing a physical copy of your book based on your answer here. Lambda calculus has always been a mystery to me.
Incidentally, Racket defines the symbol `null`: an empty list constant. It simply evaluates to `'()`.
Just released a [(cyclone concurrency)](https://github.com/justinethier/cyclone/blob/master/docs/api/cyclone/concurrent.md) library as part of the latest version of [Cyclone Scheme](http://justinethier.github.io/cyclone/). From the release notes: &gt;Added a new library (cyclone concurrent) with support for atomics, futures, shared queues, and thread pools. As well as helpers for immutability and shared objects. Overall the goal is for this library to make it much easier to write multi-threaded programs using Cyclone.
Chicken5 uses import instead of use and require-extension. Try (import http-client)
I'm making a [library](https://gitlab.com/pclouds/gauche-xcb) to communicate with X11 in pure scheme (the protocol description in in XCB's xml files). So far I managed to recreate "xwd" and "xprop"
Already wrote a documentation tool, but it needs more work before I can release it. Just put docstrings inside your functions, and it produces nice HTML with an index. Writing a better data serializer. read/write doesn't do hashtables, records are kind of a pain in them, json doesn't round-trip preserve scheme types like lists and symbols, and I'd like more human-readable output. Once I get that running, I can build a couple medium-sized tools and then start writing my games in Scheme. (I'm using Chicken and SDL2)
Some may consider the CFDG demos that come with: https://github.com/dharmatech/agave to be generative art. There's also a port of this CFDG library directly to Ypsilon: https://github.com/dharmatech/psilab
/me will have to steal the phrase "expressions of doubtful provenance."
Funny... The libs still use 0.97 in their names: `./src/libgauche-0.97.so.0.8` `./src/libgauche-0.97.so.0` `./src/libgauche-static-0.97.a` `./src/libgauche-0.97.so` Is this intentional?
It's the ABI version. We'll change it when binary incompatibility is introduced (in case soname isn't enough). The plan is that once we reach 1.0, it'll be mostly in sync with the minor versions.
thank you!
A good starting point would be Racket's [image support](https://docs.racket-lang.org/teachpack/2htdpimage.html), which can also be used to make animations with [universe/big-bang](https://docs.racket-lang.org/teachpack/2htdpuniverse.html).
I enjoy working on [my own Lisp derivative](https://github.com/TurtleKitty/Vaquero). The interpreter is written in Chicken 5. It has no FFI, but can talk to sockets, so I've had it talking to a Postgres database via a Perl script acting as an intermediary. This has led me to thinking about writing a little tool to sit in front of Postgres, listen for connections, and accept and return sexprs representing database queries and results. Been wondering if I should write it in Chicken, try a new Scheme, or maybe try my hand at another Lisp.
I'm unfamiliar with these. Is this just for performance/memory improvement, or does it give you extra expressive power as well?
Well, they are reusable in different contexts. You can re-use your transducers for lists, vectors or even queues or asynchronous channels. They are not faster than writing your own named let loops, but they add quite a lot of comfort. It is like a general protocol for all your algorithmic transformation needs. Instead of saying "if you want to transform/filter things in a channel you need to send it a lambda that takes a lambda that it calls with any result it wants to push through the channel" you say "takes a transducer". The process then takes care of the rest by providing a reducer function to be used at the end of the transducer. Very simple. For transforming collections they don't create any intermediate results which will usually mean much better GC performance, even for unboxed things like fixnums.
So kinda like an extra layer of abstraction over collections and streams? Cool. I can dig it.