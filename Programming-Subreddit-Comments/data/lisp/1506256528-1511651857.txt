Alas, true.
Jokes aside atom and vscode both have paredit these days. Sadly no slime yet in vscode, atom is wip
Screen space is not valued as highly as programmer time/effort. And some python shops require one function call param per line,
Those damn parens amirite?
One thing I really like is that the standard library uses multiple dispatch extensively. When I learned about CLOS, I remember thinking that it would be nice to have the whole Common Lisp standard library rewritten to use it.
IOLIB seems maintained. You might want to make contact with its author on #lisp (freenode).
AFAIK `#lisp` on Freenode is competent with iolib and is able to provide support in some more concrete questions.
Thanks. Didn't know the author was active on freenode. Will give it a try.
Thanks, will give it a try.
Sure! @chuchana provided the output from brew qt formula. If you can help me with passing the options to eql build script, I'll try to make a brew formula for it
IOlib is only a pretty thin layer over POSIX syscalls so writing a manual for it would IMO be redundant, and low priority given my little spare time. That said, I'm curious to know what you think is missing and why.
Just in case, there exists lispified wrapper around libuv: `cl-async` - https://github.com/orthecreedence/cl-async
If you configure the hat correctly, it will give you a slight electric discharge to the scalp if you write one too many parentheses on the board.
Check out basic-binary-ipc for another good non-blocking sockets library.
Hi, Thanks for responding! Some concrete issues I've encountered: 1. Are async DNS lookups supported? 2. Can I do async file I/O? I understand that non-blocking behaviour is not always guaranteed and some event libraries create a thread pool to work around this. Does iolib do anything about it? 3. What is the idiomatic way to do async reads/writes on a pipe? Should I use `ISYS:READ` and `ISYS:WRITE`? 4. Related to the previous one, is there a common interface to perform async reads/writes from streams such as sockets, pipes, files, etc.? I saw `IOLIB/STREAMS`, but these are gray streams, which won't be non-blocking. 5. An overview of how the event loop works would be great. (e.g. [see libuv](http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop)) 6. API documentation of the event loop would also help a lot. Apologies for unloading all of this in one go, but I was getting a little desparate ;-)
Thanks.. I didn't know about this one. Will take a look.
I've checked cl-async in the past. AFAIK it doesn't have support for pipes or file I/O. Also, it follows the node.js model of draining an input stream as fast as possible. This is not ideal -- I prefer to have more control over how much memory my sockets are consuming.
1. No. If you see libuv, it uses a thread pool with blocking calls to getaddrinfo(). It could be made async but it's not easy to make it perform well. 2. No. POSIX I/O is non-blocking only for sockets/pipes. For file access you must use thread pools, like libuv. 3. Yes, use basic I/O syscalls like in C. 4. No. Lisp streams are buffered objects designed to be blocking and making them async would require writing a new stream library. 5/6. That could be done, can't promise promptness. The important point about the IOlib multiplexer is that I wrote it using simple straightforward code, and can perform well for sockets, if no more than a few hundreds. To achieve full support for all types of file descriptors and high performance it would need to be rewritten. If you truly need high-performance I suggest you use libuv, but beware that you'd have to write code in a way very similar to C. P.S. An good summary of the issues with event loops just got posted on /programming: https://tomjoro.github.io/2017-02-03-why-reactive-fp-sucks. The gist: if you can afford it, use blocking threads.
Hey, I made https://gitlab.com/ralt/laap which is woefully under documented, but the tests show the API. It is not complete, but it's doing enough for what I needed. 
Are there any good IOLib examples in the Common Lisp Recipes book? 
Status is: Fast! ```src/sockets/address-arithmetic.lisp: (declare (optimize speed)``` ```src/streams/zeta/iobuf.lisp: (declaim (optimize speed)))``` ```src/syscalls/ffi-functions-unix.lisp: (declaim (optimize (speed 3) (safety 1) (debug 1))))``` ```src/syscalls/unix-syscall-path-strings.lisp: (declare (optimize (speed 3) (safety 0) (debug 0)))``` ```src/syscalls/unix-syscall-path-strings.lisp: (declare (optimize (speed 3) (safety 0) (debug 0)))``` ```src/syscalls/unix-syscall-path-strings.lisp: (optimize (speed 3) (safety 0) (debug 0)))``` ```src/syscalls/unix-syscall-path-strings.lisp: (optimize (speed 3) (safety 0) (debug 0)))``` ```src/syscalls/unix-syscall-path-strings.lisp: (optimize (speed 3) (safety 0) (debug 0)))``` ```src/syscalls/unix-syscall-path-strings.lisp: (optimize (speed 3) (safety 0) (debug 0)))```
Thank you, this helps a lot. I'd like to avoid using libuv, so I'll see if I can make do with iolib. I agree that it makes sense to just stick to blocking I/O where possible, but some use cases (e.g. long lived duplex streams) are better served by single threaded non-blocking I/O.
Hi, I'm stuck at the qmake step. qmake eql5.pro =&gt; qmake: could not exec '/usr/lib/x86_64-linux-gnu/qt4/bin/qmake': No such file or directory though which qmake /usr/bin/qmake I installed qt5-qmake afterwards to make sure. Any idea ? thanks.
I think you may have to: sudo apt install qt5-default there's also this: https://askubuntu.com/questions/820054/selecting-qt5-using-qtchooser It seems you are trying to use qt4, qt5 is a requirement for nEXT I don't have this stuff installed on my linux laptop though, I may give it a try later /u/eql5 may have more information as he uses a linux laptop
The book does not seem to contain any IOLIB content.
A bit ambiguous: macro doesn't work for multiple forms: we can't express `((a b c) (d e f) (g h i))` where the forms `(d e f) (g h i)` are on the same level, other than by wrapping them in `progn`. Also, breaks on `((a b c) (d e f) g h i)`, trying to treat `g` and `h` as nesting levels of binding constructs. Can we do better, or is it already at a local maximum, optimizing the available trade-offs? The symbol `:` (keyword simple with empty string name) could serve as a fairly unobtrusive separator, as in: `(nest (a b c) (x y z) : form1 form2 ... formn)`. The absence of `:` could be diagnosed as an error, catching mistakes like (nest (o o p s) (a b c d) (do this) (do that)) whose shape suggests that it wants to be: (nest (o o p s) (a b c d): ;; &lt;- note colon (do this) (do that)) I have made a fair bit of use of `:` in my own Lisp dialect. * It occurs in lambda list syntax for separating optional arguments: (lambda (req1 req2 ... reqn : opt1 opt2 ... optn . rest) ...) * In the `tree-case` construct, if `:` is returned as a value from a case, it falls through to trying the next case. * If the value of an optional argument is specified as `:`, then the default value is substituted: 1&gt; (defun foo (: (x 3) (y 4)) (list x y)) foo 2&gt; (foo 1 2) (1 2) 3&gt; (foo : 2) ;; note mnemonic association with optional arguments (3 2) this defaulting propagates to child functions if we make `:` the default value: (defun wrapper (: (x :) (y :)) ... (real-func x y) ;; Generally, it is handy as a third special value, when `nil` and `t` aren't enough. Not sure how portable is `:` as a token among all the Common Lisps out there. (The symbol can be encoded as `:||`, which is esthetically objectionable). Requirement-wise, according to [2.3.5 Valid Patterns for Tokens](http://clhs.lisp.se/Body/02_ce.htm), *:xxxxx* is a valid pattern. It is stated that *xxxxx* does not denote number syntax. Of course, it doesn't mean there must be exactly five characters (one for each *x*) nor that there must be at least five, since it is more or less self-evident that `:A` is a valid keyword symbol token. Nowhere is it written that *xxxxx* may not be empty; and an empty sequence of characters meets the requirement that it doesn't have numeric syntax. Alas, it does appear to be explicitly ruled out as undefined by a match against the *aaaaa:* pattern, where *aaaaa* can be anything. If *xxxxx* can be empty (which we need for a match on *:xxxxx*), so can *aaaaa* (which cause a match on *aaaaa:*). The only thing that can save it is the idea that if a token pattern simultaneously matches two of the rules in 2.3.5, the earlier one prevails. This is not written anywhere, but a sufficient facsimile of this basically follows from the summary of the rules, which is broken into numbered paragraphs that indicate ordered interpretation. Paragraph 1 clearly states that a package marker at the beginning of a token leads to the interpretation of a symbol in the keyword package. 
&gt; Not sure how portable is `:` as a token among all the Common Lisps out there. SBCL doesn't like it: [SBCL] CL-USER&gt; (symbol-name :||) "" [SBCL] CL-USER&gt; (symbol-name :) debugger invoked on a SB-INT:SIMPLE-READER-ERROR in thread #&lt;THREAD "main thread" RUNNING {10028F7443}&gt;: illegal terminating character after a colon: #\)
That's really too bad---what a bummer! Add that to the list of little things to fix in the next revision of ANSI CL. `:` as a universally accepted token denoting a self-evaluating keyword would be handy.
It works *if* the next form starts with a left paren: (list : (+ 2)) =&gt; (:|| 2)
thanks, qt5-default was needed for this command but not enough for the rest, `make` doesn't find Qt modules. Actually I didn't install qt5 and I'm not sure how to do it properly (using apt instead of again downloading sthg manually).
hi, I am not sure how to install qt5 in ubuntu, is there maybe like a qt5-devel package available in apt-get?
The whole idea behind the simplicity of this macro is that each binding construct only accepts one form as its last argument. If you want or need to complicate this, then you'll need to resort to other constructs.
no but there's quite a lot of `libqt5xxx` libs (gui, opengl, qml,…) and no return of grepping `uitools` &gt; make &gt; Unknown module(s) in QT: uitools
I'd rather refactor the code than use nest, but the post was interesting.
To install Qt5 + webkit + uitools on ubuntu, run: sudo apt-get install qtbase5-dev libqt5webkit5-dev qttools5-dev qttools5-dev-tools (I always prefer the official Qt download from the [archives](https://download.qt.io/archive/qt/downloads), but this is only needed if you use Qt5 for developing your own apps.) edit: you should comment out all modules except `webkit` in `eql5.pro`, in order to reduce the dependencies
Great macro! Looks like inverse version of `-&gt;&gt;` from cl-arrows to me and that one along with others from the library also really help in keeping code compact and readable.
Only mildly related: A spy manages to steal the last 50MB of the Lisp program governing U.S. missile launches. Fortunately, it was all closing parentheses. 
The "whole idea", as it were, is to flatten nested binding constructs and automate their nestings. Most binding constructs in Lisps accept multiple forms, so not accepting them in this macro is a regression; it means the macro can't be used in some situations (without adding a `progn` around multiple forms). That `progn` is extra nesting. This "other construct" can be almost the same thing with one piece of punctuation: 1&gt; (macroexpand '(nest (let ((a 3))) (let (t r s)) (let (w x y)): d e f)) (let ((a 3)) (let (t r s) (let (w x y) d e f))) Code: (defmacro nest (:form f . args) (let ((colon-pos (posq : args))) (unless colon-pos (compile-error f "~s: missing : separator" 'nest)) (when (zerop colon-pos) (compile-error f "~s: head expressions required before :" 'nest)) (tree-bind (heads forms) (split* args colon-pos) (car (reduce-right [chain append list] heads forms)))))
It looks like it will work if there is a next form, period, or just white space. So that pretty much rescues it for this use case. 
I had trouble compiling EQL with webkit support on Mac OS and later I found out qtwebkit has been deprecated since QT 5.5. Any plans to replace qtwebkit with qtwebengine? EDIT: OK I just saw the reply regarding qtwebengine down below.
Hi, thank you for your interest! You are correct, yes, technically deprecated, but actually not really deprecated, there's a version being maintained on a separate fork here: https://github.com/annulen/webkit As alluded to earlier, it should be fairly easy to maintain support for both engines
In my personal library I use the name `&lt;&lt;-` for this `nest` macro.
I'd suggest making the colon optional: instead of raising an error, if there is no colon, pretend it's right before the last form.
Allegro CL supports hierarchal packages via a . separator. I like the idea of package-local nicknames. It would take work from all implementors to make it happen. The motivations for implementors is varied and "because it would be cool/good/nice" is not going to cut it across them all. But I think it would be great if it could be clearly outlined, implemented by example, and encouraged.
Having hierarchical packages is awesome and encourages using longer global package names, which I definitely think is the way to go, but it doesn't really help when you want to make use of a package in a different part of the hierarchy than you- you still have to specify its full name, right? Package local package nicknames, then, would be even better in the context of a hierarchical package system. You're right though- it will be a lot of work before this becomes useable in portable libraries, and until then it could be difficult to really justify the effort.
@25:27 `M-x slime-enable-concurrent-hints` Is this in one of the contrib packages? I searched around first in my install of slime, and then on google, but I can't find anything about this. Can't help but wonder what other cool stuff I'm missing out on.
That's unhelpful to the programmer in cases when the division was intended to be elsewhere. In some cases, the expanded code will not trigger errors. The head forms appearing in `nest` are valid forms on their own! So both of these are well-formed: 2&gt; (macroexpand '(nest (x y z) (let ((var (fun))) (do-something var)) : (other))) (x y z (let ((var (fun))) (do-something var) (other))) 3&gt; (macroexpand '(nest (x y z) : (let ((var (fun))) (do-something var)) (other))) (x y z (let ((var (fun))) (do-something var)) (other)) In some cases it won't even matter; but it could. Suppose there is a global scope `var` and that last form is `(other var)`. In one form then it refers to the outer scoped one, in the other to the locally bound one. Sometimes we want syntactic variants with sensible defaults (it would be irksome for `if` to require exactly three arguments, with explicit `nil` instead of the two-arg case). My intuition is siding with making this one strict. Some constructs call for having it both ways. In functions, we sometimes want required arguments and sometimes optional ones with default values, or mixtures of the two. Now some Lisp dialects have had it so you could call **any** function whatsoever with fewer arguments. The missing arguments would get `nil` default values. I would call that "bad", even though with optional arguments, we essentially get something resembling that behavior: (but in doses that we control, with default values of our choosing, and a way to detect whether arguments were supplied). Also, dynamic typing is great, but allowing `(+ 2 "2")` is pretty stupid. Other than perhaps inside a very special-purpose sublanguage that is properly contained. My close to final version: check for duplicate colons, and non-compound head forms; correct uses of my `compile-error` macro: (defmacro nest (:form f . args) (let ((cpos (posq : args)) (rcpos (rposq : args))) (unless cpos (compile-error f "missing : separator")) (unless (eql cpos rcpos) (compile-error f "duplicate : separators")) (when (zerop cpos) (compile-error f "head expressions required before :")) (tree-bind (heads forms) (split* args cpos) (whenlet ((a [find-if atom heads])) (compile-error f "head ~s expected to be compound expr" a)) (car (reduce-right [chain append list] heads forms))))) Ha; let's see the hygienic Scheme version with all the same checks. 
Could this be combined with threading somehow: Suppose that: (-&gt;&gt; (+ 1) (* 2)) is a function which adds `1` to its argument and then multiplies it by `2`. Can we sneak in an operator which causes variables to be bound using any construct, such that they are visible to the pipeline forms to the right? (-&gt;&gt; (+ 1) (! let ((x (* _ _)))) (expt x)) The `(! ...)` performs the bindings, and acts as the `identity` function otherwise, passing through the result *r* of `(+ 1)`. The `x` variable is bound to the square of *r*. Then `(expt x)` raises `x` to *r*.
ECL will have package local nicknames from next release on (it is already implemented in develop branch). This is API-compatible with what SBCL and ABCL have.
Nope, sorry that one was a function in my `.emacs` file. Here it is: (defun slime-enable-concurrent-hints () (interactive) (setq slime-inhibit-pipelining nil))
That could easily be implemented in scheme. read supports reading a single colon: (with-input-from-string ":" read) ;; -&gt; : Which means it could be matched as a literal in syntax rules and syntax-case. 
Yeah. I would probably use some sort of and-let* for such a scenario (where read returns #f on failure). That would be an idea for an improved and-let*: an and-let that supports multiple values. Edit: here is an improved and-let* with multiple-values support and an example of a "ported" version of the code in the web page (using a hypothetical read-file-or-false.) https://pastebin.com/w74vv5H3
I think this can make it more confusing. Initial threading macro is very simple - it just places every form at the certain position of the next one. With this change this assumption won't hold anymore. But this can solved with `&lt;&lt;-` which works in the reverse way of `-&gt;&gt;` - takes last one and puts it in a certain position at the previous one, so we can get a desired behavior by mixing them: ``` (&lt;&lt;- (let (...)) (destructuing-bind) (-&gt;&gt; value (map #'func) (another-sub))) ```
If you like implicit progn, but without the "LOOP-y" keyword style: (defmacro nest* (forms &amp;body body) `(nest ,@forms (progn ,@body))) (nest* ((o o p s) (a b c d)) (do this) (do that)) 
 (:local-nicknames nick package nick package ...) Sigh, score yet another victory for the omitting "superfluous" parentheses school of "modern" lisp design...
Yes; just like, according to David Wheeler, every problem in computer science can be solved by another layer of indirection, every problem in Lisp syntax can be solved by another round of parentheses.
Suppose we take this one level further and condense successive occurrences of the same binding syntax. (Let's ignore for a moment that the following, if naively implemented, doesn't "play nicely" with all forms, mind you, such as `with-slots`, `destructuring-bind` or `multiple-value-bind`.) The basic idea is captured in the following transformation: (nest (op1 (a b c) (d e f g)) (op2 (r s t) (u v) (w x y z)) form) --&gt; (op1 (a b c) (op1 (d e f g) (op2 (r s t) (op2 (u v) (op2 (w x y z) form))))) Obviously if `op1` is `destructuring-bind`, it is nonsense to turn `(destructuring-bind (a b c) (expr))` into `(destructuring-bind (a b c) (destructuring-bind (expr) ...))`. Depending on what requirements are articulated, that leads to some combination of restrictions or complications in the spec. A possibility is that `nest` has to recognize the binding operators and know their arity; so it knows that `destructuring-bind` has a two-form binding specification and so the nesting repetition has to decimate the arguments pairwise. The special variable `*nest-ops*` could associate (via a hash table) binding operator symbols with handling functions which perform the decimation. E.g. the handler for `destructuring-bind` could take the form `(destructuring-bind a b c d e f)` and return two values: the symbol `destructuring-bind` and the list `((a b) (c d) (e f))`. The `nest` macro takes this and it knows to generate three nestings, distributing into them the `destructuring-bind` symbol. 
It's the difference between buffered and unbuffered IO. See the functions CL:FINISH-OUTPUT and CL:FORCE-OUTPUT...
Oh ok, thank you.
Very cool. I love seeing stuff like this, it's a fantastic reminder of how bloated and ridiculous the Android development system is right now. It's an incredibly frustrating experience building large scale and widely supported Android apps.
That's awesome to hear!
How would you add more parens to it?
As noted, buffering. I'll add that Common Lisp is unlike SOME languages I could name, in that the execution order is specified in the great majority (all?) of cases. I love this, since it makes testing easier. (Edit: and helps portability of course.)
this is some real wizardry!!
How is it with the argument evaluation order? This has bit me once or twice in scheme where it is left unspecified.
Thanks, I think I got it now.
Left to right but unspecified when the function argument is evaluated, so this: (multiply (prog1 3 (setf (symbol-function 'multiply) #'+) 2) is undefined.
 (:local-nicknames (nick package) (nick package) ...)
It's almost always left to right. In particular, in function forms, the evaluation order is left to right. http://www.lispworks.com/documentation/lw50/CLHS/Body/03_ababc.htm The minor exception being that when the function itself is looked up is not fully specified, but this almost never matters, since the binding from symbols to functions rarely changes. Common Lisp not being a [Lisp-1](http://www.nhplace.com/kent/Papers/Technical-Issues.html) helps here, since if you are binding a function value to a lexical variable then calling it you use FUNCALL, and then the function variable's order of evaluation is well defined. The SYMBOL-FUNCTION values, where functions defined with DEFUN go, almost never change. FLET and LABELS do not affect the SYMBOL-FUNCTION value. In my opinion, not specifying order of evaluation is a mistake in language design. This has made testing C compilers a lot harder than testing Common Lisp compilers using differential testing, since the generated programs must have no undefined behaviors. https://embed.cs.utah.edu/csmith/
Alright, I can see that.
That's already undefined simply on the grounds of messing with the binding of a standard function in the `common-lisp` package. 
MULTIPLY is not a symbol defined in the standard. You're thinking of *.
Just because Common-Lisp already has so many things, for your solution you could have used terpri, fresh-line or (pprint-newline :mandatory) instead of your newline, or use a write-line instead of the print and write. Just some options.
Thanks for the tips, I just started learning it.
Likewise, `-&gt;&gt;` is sometimes called `tsen`. `-&gt;&gt;` and some other variants are built into Clojure, but the convention is to use them for building functional pipelines, not lexical contexts.
Maybe i'm just missing your point, but what is the problem with progn? I prefer just adding a couple of these than rely on a magic separator.
What is wrong with just nesting the code, then? Don't like "magic" separators? Don't use `&amp;optional`, `&amp;key`, `&amp;rest`.
I happen to like standard conventions and out of the box features, rather than ad hoc hacks. The beauty of this construct is that it does not rely on any.
A better S-expression support would be nice, but julia is a pretty cute language overall.
Reading 'open source code' using a closed source &amp; walled garden service?
sounds good, I would like to try it out
The macro part is not really good: the example is not very useful and slightly wrong. First: macros are not linked to compile-time. A Lisp interpreter also has no problems executing macro forms and usually does that at runtime. Second: your example of calling head and head-macro doing the same is not really true for the general case. EVAL evaluates X in a null lexical environment. The macro OTOH returns X and that can be a lexical variable. Your example works for a global special variable. An example where it does not work: CL-USER 5 &gt; (let ((y 42)) (head-macro (y z))) 42 CL-USER 6 &gt; (let ((y 42)) (eval (head (quote (y z))))) Error: The variable Y is unbound. Another example where it breaks: (let ((foo '(x y z))) (head foo)) ; works Vs. (let ((foo '(x y z))) (head-macro foo)) ; does not work The latter does not work, since HEAD-MACRO tries to get the CAR of the symbol FOO - which is not possible.
You are right, the example was bullshit. Though simple enough to introduce the concept. Yes, the whole eval/quote thing was just a help to imagine how it works: &gt; This is not at all how they are implemented As for the second point: Don't macros happen at compile time? I thought that's even mentioned in the spec.
But I will make it clearer and mention it again after showing that paragraph, that this is just a way to think about it and not 100% technically correct
They happen at compile-time if the code is compiled, which is not necessary to evaluate code.
You are absolutely right. I appreciate your feedback and updated the article. Thank you a lot :)
Something a lot of non-lispers don't get is that "lisp family" is a very broad term. To a certain degree, it's like lumping C and Java together in the "algol family." While technically true, C and Java are very different languages. That there is an /r/lisp and not an /r/algol is perhaps due more to the fact that each individual lisp community is much smaller than due to strong technical similarities in the language.
I personally think I succeeded in pointing that out. The article refers to lisp as a family and mentions that there are some imperative and some more functional dialects. I also explicitly referred to Common Lisp as Common Lisp (some articles just call it Lisp, but that is not allowed (see the newLisp naming debate)). Do you think I should make that clearer? I could write a little Note at the end mentioning that. 
Nice write up, carry on ! I bet it's a great exercise. I fint it too bad you introduce `car` and `cdr` without speaking about `first` and `last`. I'd speak first about those two, and have a word about the weirdo ones last. And it would be nice to link to good resources out there, wouldn't it ? There are a lot in this reddit's sidebar, but don't you miss my favourite ones :D [lisp-lang.org](http://lisp-lang.org/), [awesome-cl](https://github.com/CodyReichert/awesome-cl) and the [Cookbook](https://lispcookbook.github.io/cl-cookbook/) :) (also http://malisper.me and http://lispmethods.com/ among a few others)
I don't think lisp is hard to google, but you are right: pointing to some interesting resources is a good idea. As for the less popular languages I write about, those might even be a must have, thank you :)
Wow! Is it feasible to start from the tiny 'My' app and make it grow to something 'useful', or it's ment just as a proof of concept?
You can grow it into a real app, of course! The QML file can include any number of other QML files, and can link to images etc. present on your PC. This is a very recent example, so currently there is no automation of, say, re-loading all Lisp files after restarting the android app: but since it would be possible to copy them directly to the device, it would not be difficult to have it all automated (but I still need to think about this). BTW, when I discovered that one can reload QML from any url, it blew my mind... **edit**: I'm currently using this approach to add copy/cut/paste of s-expressions to the REPL example, and I can say that this is a very pleasant way of developing interactively, especially because the android device acts as a poor man's 2nd screen!
This is a very interesting subject, I will watch the Youtube recording, it is difficult for me to make it on the live stream.
Quite interesting. Do you know if there's a way to follow your coding using SBCL &amp; Emacs on Win10? I usually code on linux or macOS, but now I'm trapped in M$. Thanks
Did you ever get somebody with SQLITE or SQL experience to help?
Absolutely. cl-opengl &amp; cl-sdl2 both work on windows and so CEPL piggybacks it's way to success on top of them :) I haven't tested the newton bindings on windows yet but I may get time tonight. 
Awesome! I might actually drop in this time around. I'm quite curious how ND compares to ODE usage wise.
nope not yet!
Thanks. cl-opengl &amp; sdl2 loaded with no problems. I think I have an issue with the sdl2.dll libs though....not sure how to make cl-sdl2 aware of the location of the libraries.
I have some experience with both SQL and SQLITE, I have actually used CL to create and query SQLITE DBs. I don't usually have too much free time, but I am willing to help.
There is a proper answer to this question, but I just dropped them in the same directory as sbcl.exe and left it at that :p
nice! this is the exact release we are working on: https://github.com/nEXT-Browser/nEXT/tree/master/next#003 Basically we are trying to figure out a couple of things. 1. What is a portable CL SQLITE library that we can use (so that it is distributable in a binary bundle) 2. What is the best way to store metadata about every page that the user visits (tags, notes etc). E.g. how to make a good database model to do this? What is the structure our database should take for the history and / or bookmarks 3. The rest of the owl :P
That suffices at least to me ;) Thanks a lot. 
You can't explain what makes lisp different than all of the mainstream languages in a blog post like that any more than you can explain multiplication via blog post. macros are just code substitution. it's very easy to explain and you should use a language like python or java to explain it. 
He claims that the right fold-ish syntax rules version is quadratic, but in my tests it is only about 7% slower than the one he ended up using in his prelude.
Why should I use a language like Python or Java to explain it?
who is your audience? Most programmers can understand python and java regardless of the languages they're most comfortable in.
Honest answer: since I posted the article here, probably my audience consists of frequent r/lisp users. 
so this is like an exercise/practice on what you've learned about lisp? ok. give me a second. im gonna find an explanation i wrote for macros that'll help explain the difference between a macro and a function.
So you can read this wall of text, or you can just skip right to the pseudo code. The pseudocode shows how you can change the syntax of a language via code substitution (also known as macros). The important part is that a function can't do this. A function needs to be given valid code. A macro does not need to be given valid code. By being able to take code that is invalid, you can decide what's valid and what isn't. You can decide between infix and prefix notation. The language designer doesn't decide this for you. Lisp macros do not rely on S-expressions. They rely on the fact that arguments are not evaluated, the code is passed in raw to the function, and then the code is replaced by the result of the function. If macros existed in Python for example, you could do this (sorry if my python isn't 100% correct. haven't used it in a while): defmacro exists (code list): for x in ,list: if ,code: return True return False exists(x &gt; 10, [1 5 333]) =&gt; t Macros are great in Lisp, because lisp makes it easy to code your code. It does this by treating your file of code like you might think of an array or a list or another data structure in another language. This data structure is really simple and is called a list. Lisp provides a bunch of help to make it easy to work with lists, just like Python provides a bunch of help for working with strings, lists, and tuples by giving you functions and variables for manipulating, printing, and debugging these things. Because the code you write is a list and lisp provides a bunch of help for dealing with lists, it's as easy to manipulate a list of code as it is to manipulate a list of songs or emails or zombies like you're probably already accustomed to doing. In other words, macros are awesome and you could easily put them in another language. Lisp isn't great because of macros, it's great because of how well (mind blowingly well) macros play with with all of the other parts of lisp. Macros are empowered by the rest of the langauge, and the rest of the language is empowered by macros. And this is really the theme of lisp, it's not one feature that makes the language impressive, it's how the features seem to amplify one another.
&gt; what makes lisp different than all of the mainstream languages If lisp is different than all of the mainstream languages , then why and how to explain the lisp in other mainstream languages ? If we try to explain it, so we got &gt; If macros existed in Python for example, you could do this (sorry if my python isn't 100% correct.) 
Uhm, because when you explain things you do so in terms the person already understands not with a bunch of pseudo-intellectual jargon as is so unnecessarily common in the programming world. But more importantly you can explain macros to anyone. And you can do so very quickly and easily. It's just code substitution. You cannot explain the difference between lisp and mainstream languages in a blog post. Macros are just one aspect of lisp. The difference between lisp and other languages is a lot more than just code substitution. You are confusing explainging macros with explaining the differences between lisp and mainstream languages. They are two completely different things.
Defvar is super useful for interactive programming. If you have a variable that shouldn't be reset when you reevaluate the buffer, e.g., it comes in handy. Say you have a variable where you track how many frames you've rendered -- maybe you don't want it to go back to zero every time you update the running image code by throwing the whole file at it en masse.
&gt; Both of them? Emacs has been forked again?
No, it just mutated.
I'd go with Racket (which is about 23 years old btw), since you are interested in it and it has a lot of resources available for beginners. The documentation is solid all the way around (libraries and core). Plus Dr. Racket is pretty neat. I've never written iOS/Android, so I can't help there.
I'd go with any of the above except Scheme. I use Common Lisp.
This is a really nice convenience. I kinda wish Elixir took more after LISP and had more `with` macros.
I would use Common Lisp, particularly SBCL, but basically any implementation will be good. SBCL does more type checking than many Lisps, which if that's what you're into can be very nice. In all honesty, though it's a matter of fierce debate among a lot of people, I don't think you're really going to think very much about the difference between a Lisp-1 and a Lisp-many in day-to-day life. Plus, most importantly imo, I think that the learning resources about CL are the best - Practical Common Lisp is a wonderful book and I cannot recommend it enough.
If you wan't high portability, especially to Android I would recommend using Common Lisp, specifically ECL. ECL also allows standalone executables. The kawa Scheme implementation or Clojure also work (somewhat) on Android, but they are tied to the JVM and have other problems, e.g. horribly slow startup time for Clojure. I'm not aware of a free Lisp supporting iOS, but again porting ECL is probably the easiest solution.
Use common lisp with the ECL implementation, it will allow portability on literally anything that can run C. It has been shown to work on Android, and it should theoretically be embeddable in an iOS app as well with a small amount of work. iOS should actually be easier afaik.
Looking at your design document, I'm going to suggest CL, for a few reasons. Your seem to be familiar with Emacs Lisp; CL is easiest leap from Elisp. Most of your code examples could be ported directly into CL (except that CL, by default, ignores case when reading in symbols). Also, unlike Clojure or Scheme, CL has a type system. As a Haskellion, you might appreciate that. It's not as powerful as the type system of Typed Racket, but (in my opinion) it's better integrated into the language. For example, your `either` type is already present in CL, where it's called `or`, and you can use it as the type of field in a struct: (defstruct either-example (a 1 :type (or string number))) I don't want to oversell the type system. Glaringly, there is no support for user-defined distinguished parametric types -- I mean, there are user-defined types, and there are parametric types, and there are user-defined parametric types that "expand" into built-in parametric types, but there are no distinguished user-defined parametric types. And some implementations care more about types than others. Nonetheless, the type system is there, if widely underutilized (for cultural reasons?). You can do surprising things with it. You can have [algebraic data types](https://bitbucket.org/tarballs_are_good/cl-algebraic-data-type). And (if I can be forgiven the appearance of self-promotion) one thing I’ve tried to do with [Serapeum](https://github.com/TBRSS/serapeum) is to make the type system more useful for *organizing* programs, not just optimizing them. Whatever Lisp you choose, you deserve credit for taking on this problem. A good, non-cloud, open-source reference manager is a crying need.
Clojure (specifically clojurescript) will run on iOS, with gui provided by react-native. That being said, any of these are fine. Spending more than a day deciding is probably less efficient than just rolling some dice to choose. The big feature of Clojure is immutability by default. If that's interesting to you, go for clojure, otherwise you can rule it out. If you were every wondering what a dynamically typed haskell with macros would be like, this is the language for you. I use Common Lisp (specifically SBCL), I like it, it works fine. The tooling for it is superb, and what keeps me going back to it. Get [portacle](https://portacle.github.io/) for a quickstart setup if you do choose common lisp. Running a bare sbcl REPL is not the most exciting experience. Racket has a lot of momentum, and it does have a typed version (as well as the best support for creating entirely new languages on top of their platform). Scheme is a minimal core, which means every platform has at least two scheme implementations for it. Downside is that a lot of features you might want will be implementation-specific.
I'm a Common Lisp/Clojure guy- CL is my personal preference, but occasionally I find Clojure to be a better fit for a project. All three are great langs tho. As far as mobile goes you might want to look into Clojurescript with React Native- RN lets you write cross platform mobile apps in JavaScript and Clojurescript is a fully featured implementation for JavaScript.
I started out with Racket, then Clojure and then CL. I found Racket with its IDE to be really easy to get started with; I wasn't that familiar with emacs when I started learning Racket. Since you already use emacs, you shouldn't have a hard time setting up SLIME and learning Common Lisp first. CL + emacs + SLIME, along with all the nice shortcuts for manipulating s-expressions in emacs, is loads of fun to work with. I enjoy writing Clojure, and it's definitely the most likely to land you a job. *But* I wouldn't recommend it to start out with purely because the error messages aren't very informative. Nonetheless it's a great option for bigger projects because of the ecosystem around it and clojurescript.
It would be awesome and very informative to see you writing some blog posts about the difference of language and platform with the three you tried. Even notes in a gist posted here is enough ! :) We lack material like this and I know I'd enjoy it very much. My main questions are "how is the workflow different in each language, how is the debugging experience, how is it to build a self-contained app or deploy a web app,…". thanks :)
links: - https://gitlab.com/embeddable-common-lisp/ecl - https://gitlab.com/eql/EQL5-Android
Also learning CL. My favourite resources I don't want you to miss: - http://lisp-lang.org/ showcase, successes, recommended libraries - the [CL Cookbook](https://lispcookbook.github.io/cl-cookbook/) highly improved this year and still ongoing - [Awesome-cl](https://github.com/CodyReichert/awesome-cl) - http://quickdocs.org/ - and my ongoing [tutorial](https://vindarel.github.io/cl-torrents/tutorial.html) (web scraping, building executables, command line arguments parsing,…) There's something that is simple(r) in CL and that surprised me: working with external libraries. We don't set their version number (strange right ?). We download them from a Quicklisp "dist" that has been built with every available library, so they don't clash together. Or we clone one in `~/quicklisp/local-projects/` and we can quickload it in the REPL. Or we use Qlot (Rake-like). So far it's been smooth and a relief.
I know you didn't say this, but just to be clear Clojure runs pretty quick inside a REPL on the desktop, and a long-running Clojure application runs quickly too. Startup is just dog slow.
Racket is probably the best thing for learning. I think I saw an iOS framework target in the build docs but no idea if it's working. No idea on android. This is a nice learning tool http://davidpilo.com/pvts/index.html ClojureScript compiles (transpires?) to JS and so is probably the most cross platform. Has some quirks that it inherits from JS.
Clojure (via clojurescript) already runs on iOS and Android, see e.g. https://github.com/drapanjanas/re-natal
First, if you're interested in learning, then does portability to iOS matter? Second, why pick just one? :-)
You should really checkout Lambda Native. It is based on Gambit Scheme and has mobile support for iOS and Android. Much more complete for building apps than say ECL. http://www.lambdanative.org/ With Gerbil you get additionally R7RS and a whole lot of other goodies.
I remember getting into this sort of analysis-paralysis dilemma. The key is to remember that *it doesn't matter*. Picking *any* option is better than the time wasted waffling over the decision. Since you're just learning, there's no way to get this decision wrong. If you pick one and find something wrong with it tomorrow, you can switch again and try something else! (The road to mastery is never a straight line. Mastery is mostly accumulated scar tissue. Knowing where the dead ends are.) Still not convinced? Ok, I'll give you a tie-breaker. Pick the dialect that'll give you the easiest access to a mentor, someone you can conveniently ask questions of. (If you need someone, come to the [Arc Forum](http://arclanguage.org/forum). I hang out there, and that's the "gateway drug" dialect that finally got me into Lisp. It has significant issues in the long run, but if you're just looking to learn it'll do you fine for a while.)
(love 'PicoLisp)
How about all of them, at least to some modest depth? I have a bias toward Common Lisp, but Clojure is probably the most employment-friendly at this point.
If you are into professional web development and wouldn't mind the Java'isms, I would choose Clojure. Otherwise you may try SBCL.
Can you provide the non-Mac people with screenshots?
what do you mean? Should look the same on every OS afaik except for the window borders 
Can you make some screenshots of the browser in action and post them somewhere?
like on Ubuntu or something? If you mean screenshots in general, I can also post some more, but basically it’ll just look like web pages :D I can also take a screenshot of the tree history diagram 
Or better - if you are able to use something like OBS, you could record a video of it in action.
I'll make a short video on Mac OS, it won't be extremely exciting, but it'll kind of show where we are at :)
Hi I made a short video: https://youtu.be/6pAjwPgF7lE Shows creating buffers, deleting buffers, how the tree looks (granted I didn't make a tree that shows anything remarkably interesting), switching buffers etc. Best option is taking it out for a spin yourself ;)
note from IRC, apparently QtWebkit has lots of unresolved CVEs. Be warned if you run it.
To what extent do you envision it being customizable if the engine is WebKit? It seems like the primarily customizable portion will be navigation.
actually, because i am using webkit and not blink, manipulation of web content itself is also possible through lisp you can write functions that directly manipulate the source of a page literally everything about it is customizable and exposed to the end user, think of it like emacs as a browser 
Scheme is a very good language, so you should be fine with using it. Racket is also very interesting and it grows from Scheme realm. That said, Common Lisp has some adventages (in my opinion) over Scheme: - organic macros, which doesn't tie your hands (in contrast to sterile, or as some put it - hygienic macros) - diverse set of maintained compilers (from high-performant through very portable to specialized) - large ecosystem of libraries - well-designed standard with full numeric tower - Common Lisp Object System - arguably most advanced OOP you can get Some good qualities are shared among Scheme and CL, so I'm not listing them. There are definetely more points, these are worth highlighting though (once again, in my opinion).
As mentioned in another thread, nEXT could quite easily use QtWebEngine instead. (Personally I already did it. The changes are trivial, as by now.)
Oh that's neat. I suppose WebEngine has less vulnerabilities ? or just less eyes looking ?
WebEngine uses tremendous effort to keep the engine stable and secure. This is independent from the Qt folks (they simply can't afford to keep WebKit at the same high level of stability/security as WebEngine). Stability etc. is the very reason why Qt5 switched from WebKit to WebEngine. **edit**: well, the above is "their" official explanation; but since Qt is a Giant in IT world, we will probably never ever know the really real reason, I guess...
Thanks you all for your very detailed answers, they're really appreciated! I've started reading I'll start by browsing through Racket and CL books/guides and quickly decide on a language (u/Aidenn0 is certainly right in suggesting that although it's technically possible to spend more time deciding on a language than doing actual programming, it's nevertheless likely to be a bad idea :) Some people noted that Clojure was the most likely to get one a job, and to be honest I was surprised (and pleased) to learn that some Lisp dialects still had enough enterprise traction to be reasonable choices for CS students. As a PhD student and teacher in... philosophy, I don't feel much concerned about jobs opportunities, but it's great to know that I'm not stepping into a lost niche. Regarding portability, it seems that both Racket and CL compile to ARM and seem to work on Android. Racket on Android also [support bridging to Java apps](https://www.infoq.com/news/2016/10/racket-67-android-apps), which is good news for me. Again, thank you all. Beyond looking for languages, I've kept working on my little design document, and I feel more and more convinced that any Lisp is the best language to do what I want. And by the way, thanks to all those who expressed interest in said project ([Tkacz](https://github.com/thblt/tkacz)). Although it's a bit frightening to get github stars (ok, 2 of them, but still!) before writing a single line of code, it's also really, *really* motivating. If this kind of reference/bibliography manager can be of any interest to you, please, please feel free to discuss it, even (and especially, at this stage) informally: any ideas on how such a program could be useful for other people than me will be greatly appreciated.
I would guess the number one reason is library ecosystem. I much prefer Racket as a language, however Common Lisp simply has a more comprehensive catalogue of mature libraries.
See a related [blog post](https://news.ycombinator.com/item?id=15077519) by Fare.
Thanks
Some schemes have those common lisp features also. I know guile has common style macros (and hygienic), and also an object system that tries to be like CLOS.
I agree with you about moat things, but not About macros: implenting defmacro in syntax case is simple. Implementing syntax-case in defmacro is a PhD thesis. Selectively breaking hygiene with syntax case is, imho, the best solution. If you really want something defmacro like, either implement defmacro (which can be done in about two minutes), or use a scheme with explicit renaming macro transformers, which gives you a defmacro-like experience.
Read the blog post again. He jumped ship to gerbil scheme.
The reasons I prefer Common Lisp to various Scheme dialects: * **Tooling**: SLIME + Emacs is hands down the best IDE, even when compared to IDEs of other languages (including Scheme). Geiser came close, but still has a long way to go (and a lot more bugs to fix). * **Library ecosystem**: Common Lisp has more libraries that are usually more mature and battle tested. Also, most Common Lisp libraries are compatible across various implementations, unlike Scheme where getting a library that was written for one dialect/implementation to work on another dialect/implementation is often nontrivial (if not downright impossible). * **Performance**: Modern Common Lisp implementations, especially SBCL, are *fast*, especially when used to solve real world problems. For example, I recently implemented a simple program to parse graph datasets (the size of which are around 1GB to 10GB) from one format to another, and the SCBL implementation is 2x faster on average than the equivalent Chicken Scheme implementation. * **Macros**: Common Lisp's macro might be unhygienic, but it is also easier to grok and use (while still retains its power). And I have yet to run into a situation where Scheme's hygienic macro would be useful enough to justify its complexity. Don't get me wrong, I like Scheme, and it has interesting features (first-class continuation being one), but it still has a long way to go to catch up with Common Lisp.
&gt; Implementing syntax-case in defmacro is a PhD thesis. Agreed. Case in point: [nest macro](https://fare.livejournal.com/189741.html) (or how (re)implementing a one-line macro from Common Lisp in Scheme literally required a PhD). 
Yes, I've read it. He outlines a lot of strengths of Common Lisp and Scheme, which suits the question rather well.
&gt; an object system that tries to be like CLOS A language implementation experience is not defined by the number of features it has. The language implementation experience is defined how those features play together and how much thought has been put into that. Guile mostly does not use its object system GOOPS. It's integrated into mostly nothing (with very few exceptions). With a good CL implementation I would expect that streams, conditions, stack-groups, queues, fonts, windows, editor, systems, ... and all kind of other stuff is using CLOS. CL-USER 142 &gt; (let ((class-names nil)) (do-all-symbols (sym) (let ((c (find-class sym nil))) (when c (pushnew sym class-names)))) (length class-names)) 2008 There is some stuff loaded into it, but the implementation itself has close to 2000 CLOS classes. 
I suppose there is no size which fits all. I'm sceptical if it is that easy to implement defmacro with syntax-case. For me scheme macros are too sterile and doesn't map well as part of the code. I understand that you like sterile macros better, but organic ones are more to my liking. nb: defmacro-like doesn't count as defmacro, also we are not talking about possibility to implement something in terms of something else, but rather about something used by programmers as idiomatic code. I'm sure both languages are turing complete. Note I didn't include the fact, that implementing Scheme in CL would be easier than implementing CL in Scheme as someting putting one above the another.
setf is a powerful mechanism for generalized setting things. you can for instance setf element in a list: &gt; (defparameter *list* (list 1 2 3 4 5 6)) *LIST* &gt; (setf (nth 2 *list*) 42) 42 &gt; *list* (1 2 42 4 5 6) setq is used for setting symbol values: &gt; (setq *list* 4) 4 &gt; *list* 4 which setf can do too! Just like you have used setq, you can `(setf *list* 8)` . set is a different kind of beast which sets element, which is pointed by the symbol being value of symbol you pass parameter to it. I would discourage using it, it is rather obsolete thing of the past: &gt; (defparameter *xxx* '*list*) *XXX* &gt; (set *xxx* 186) 186 &gt; *xxx* *LIST* &gt; *list* 186 For all practical purposes you should use SETF.
The right fold syntax rules macro by gwatt in the post is only about 10% slower than the final macro. Chez expands about 30k syntax rules 7-deep nests per second. I myself find the syntax rules one easier to read, but I have written my fair share of scheme macros: https://bitbucket.org/bjoli/guile-for-loops
SETF is what you should generally use. However, if you are interested in understanding how things came about, this post might be of interest: [Kent Pitman on the history of the set and get functions](https://groups.google.com/d/msg/comp.lang.lisp/1OERjYfSKqc/keoNb0gdKjoJ). Here's the final paragraph from that post: &gt; Ultimately, the reason the names are not more regular is that they were added over a long period of time, compatibly, without disrupting things in the language that didn't need fixing. We could stop and fix things, which would make the language a tiny bit easier to understand, at the cost of millions of dollars (literally) to the industry for fixing all the places we broke in so doing. We're a language about stability, and that's not our way.
No "sorry" required: as people gain experience, their own valuation will vary widely between long-enough periods of time!
I'm not to familiar with either object system. I do however agree with you that having it tightly integrated makes it work much better. You can however redefine a bit of the language with the help of GOOPS, for example: (use-modules (oop goops)) (define-method (+ (a &lt;string&gt;) (b &lt;string&gt;)) (string-append a b)) (+ "Hello" "World") =&gt; "HelloWorld" (+ 1 2) =&gt; 3 ---------------------------------------------------------------------- Also, I ran your code in `clisp`, and got the following: [1]&gt; (let ((class-names nil)) (do-all-symbols (sym) (let ((c (find-class sym nil))) (when c (pushnew sym class-names)))) (length class-names)) 180 What gives?
http://www.gigamonkeys.com/book/variables.html You will want to read sections Assignment and Generalized Assignment.
&gt; Case in point: nest macro (or how (re)implementing a one-line macro from Common Lisp in Scheme literally required a PhD). Getting off topic, but if nest has appeal wouldn't it be more sensible to just not indent after binding forms? (multiple-value-bind (a1 b1 p1) (foo1) (with-open-file (f1 p1 ...) (let ((x1 (read f1))) (when x1 (multiple-value-bind (a2 b2 p2) (foo2) (with-open-file (f2 p2 ...) (let ((x2 (read f2))) (when x2 (bar x1 x2 ...)))))))) I could see people being annoyed, but I can also see a nest macro being annoying.
&gt; You can however redefine a bit of the language I want the implementation to use CLOS already, not just MY code. My point was about 'integration' of features, not about writing more unused code. &gt; What gives? Different implementations have more stuff predefined. 
What do you want to accomplish ? I wanted to write a web app based on a web scraper. I found one primitive lib in Racket but looked at the Awesome CL list and found Plump&amp;Lquery. Then different choices of web frameworks, template engines etc. 
 (define-syntax define-macro (lambda (x) (syntax-case x () ((_ (macro . args) body ...) #'(define-macro macro (lambda args body ...))) ((_ macro transformer) #'(define-syntax macro (lambda (y) (syntax-case y () ((_ . args) (let ((v (syntax-&gt;datum #'args))) (datum-&gt;syntax y (apply transformer v))))))))))) Anaphoric if is then (define-macro (aif test-form then-else-forms) `(let ((it ,test-form)) (if it ,then-else-forms))) 
In case you haven't noticed: main part of my answer was that it misses the point to compare, how hard is to implement one in terms of another. I was about to give a defmacro example with question, how are you going to translate it to define-macro, but after a thought I have decided that it would be childish from my side. Even if this macro were correct it doesn't mean much in light of my (maybe wrong) assertion, that it's not about what's possible, but about what is more practical / idiomatic for programmers using given language.
more info at : https://www.cse.buffalo.edu/~shapiro/Commonlisp/
SETF is a generalized version of SETQ that can work on so-called "SETF expanders". It is very easy to define a simple SETF expander: (defun (setf blah) (new-value argument1) (+ new-value argument1)) (setf (blah 3) 4) ;; returns 7 What this does is define a function called `(setf blah)` that allows things of the form `(blah foo)` to be expanded when used with SETF. `(setf (blah foo) bar)` expands to `((setf blah) bar foo)`. The function `(setf blah)` can do anything! SETF expanders are defined for many built-in symbols, such as CAR, CDR, NTH and so on, which do the right thing, that is setting the relevant part of an object to a new value.
To get some idea of what SETF is doing in your implementation, use MACROEXPAND. In SBCL, for example: (macroexpand '(setf (car x) y)) =&gt; (sb-kernel:%rplaca x y) SETF expansions are allowed to be implementation-dependent, as long as they do the right thing. Off the top of my head I don't remember if a conforming implementation of Common Lisp is allowed to define setf functions for builtins. In SBCL, these do exist: #'(setf car) =&gt; #&lt;FUNCTION (SETF CAR)&gt;
Most CL implementations (clisp included) are compilers, not interpreters. Most people use Emacs + SLIME + SBCL (where first two provide great IDE and SBCL is a free and very performant CL implementation).
So I guess clisp is the best option out there?
no, sbcl is. But I guess your problem is that you don't user Emacs + Silme + (any cl)
Yes I have no idea how those are even supposed to work and why they're better than any other text editor.
Common Lisp is an interactive programming language and Emacs + Slime is the toolkit that is capable of leveraging this interactivity. https://www.youtube.com/watch?v=xzTH_ZqaFKI &lt;- music livecoding example.
Is there any difference between emacs + silme and cmd + notepad++?
YES. There is so much difference that it is hard to even compare these two. With CMD + Notepad, you cannot program incrementally, writing and compiling your program function by function.
Apart from Allegro CL (which is horrendously expensive), I think SBCL is the best CL out there. You don't need to use Emacs and Slime (but they help A LOT) to use SBCL. If you're not doing anything huge, you could try the free [LispWorks Personal Edition](http://www.lispworks.com/downloads/index.html). It's been a while since I've used it but it has a great IDE. 
nice! 
you have Emacs, Vim, Atom, LispWorks: http://lisp-lang.org/wiki/article/editors with either SBCL or CCL. See Portacle to get started easily with Emacs&amp;Slime (in the link).
Notepad++? You gots to be kidding me. At least give this a shot if you don't like emacs: https://atom.io/packages/atom-slime
The question of "what is an interpreter" is an interesting one. Walk the syntax tree while executing it in software? Translation to bytecodes that are interpreted? Bytecodes that are JIT translated to machine code? I wonder if clisp's byte codes could be JIT compiled, or if an existing Java VM could be tweaked to be more lisp friendly (adding cons cells and immediate fixnums/base chars, say) and also be JIT compiled.
From your question I'm guessing that you're writing code directly at the CLISP REPL and finding the experience lacking. You're right to hate it; nobody develops Common Lisp that way. I don't want to recommend any particular program -- nothing is right for everybody -- but I will suggest that you look on YouTube for videos of people editing Common Lisp. It might give you a sense of what the CL workflow looks like.
My god! How marvelous - absolutely singular.
&gt; I could see people being annoyed, but I can also see a nest macro being annoying. I think you are right on both points. I have never seen anyone actually use such a macro in real life.
Slime is the component that communicates between Emacs and a Common Lisp implementation. It means you edit your code in an editor that understands Lisp syntax and can query your live implementation to find out about your current code base, to update it by sending code to be compiled or evaluated, and to allow you to interactively debug it.
If notepad++ is a sesame seed, Emacs is a gigantic planet where sesame plants grow.
Yeah, but high quality sesame plants, not like low quality notepad++ sesame.
This is certainly very true. Emacs planet is weird since it's like Jupiter, VERY big, but somehow hosts the best sesame plants in the universe along with some other, interesting, exotic life-forms that are evolved to make cool stuff.
Sorry about that. I am pretty tired of the whole "hygienic macros suck", which IMHO is based on 1. that the person probably hasn't even tried learning them, just done an "oh this isn't like in CL. it sucks" 2. belief that (= hygienic-macros syntax-rules). My trigger finger has gotten a bit over-reactive. In my opinion, scheme is all about a well chosen set of primitives that can be used to build more complex abstractions. The only thing it is really biased against is mutation, since 1. it makes things slow since scheme compilers do a lousy job at optimizing it. 2. it is not continuation safe when using multi-shot continuations (arguably not a very big deal). This explains a lot of what is considered idiomatic scheme. For a macro such as nest, where hygiene does not matter, I doubt many would have any objections against implementing it with define-macro (my own prelude uses guile's define-macro to do just that), but I do believe most people find the syntax-rules form more readable.
If we talk about an interpreter then we should ask: interpreting what? A Lisp interpreter interprets Lisp code, not byte-codes. &gt; I wonder if clisp's byte codes could be JIT compiled Years ago in the CLISP release notes: &gt;Experimental Just-In-Time Compilation of byte-compiled closures is now done using GNU lightning (this is a configure-time option). Thanks to Yann Dauphin &lt;yann-nicol...@polymtl.ca&gt;. 
Many implementations support both compilers and interpreters. It's then typically that REPL execution/definition uses the interpreter by default. Only SBCL is different, it recently got an interpreter, but it isn't used by default. 
It seems you want a self-contained Lisp development environment on Windows. Just go and buy [http://www.lispworks.com/](Lispworks)
If you want a self-contained Lisp IDE on Windows, go and buy [Lispworks](http://www.lispworks.com).
Are you using that plugin on a daily basis? It's a wonderful project and I hope it succeeds however last time I tried it it was not ready for prime time.
Sorry that you are getting downvoted for the question. u/sickofthisshit &amp; u/flaming_bird covered the answer pretty well. I would just add that coding common lisp without slime is kinda like working on large c# projects without something like VisualStudio/VSCode/XamarinStudio, it's possible but you are not getting anything like the coding experience that everyone else is.
Can I know *why* you have such an opinion? What's so undoubtably better about emacs than it is about other text editors such as notepad++ or brackets?
Wow so you can edit a program *while it is running!?* How does this even work?
I used notepad++ for a year or so back when I started programming, so I know what it is capable of. Emacs is infinitely more powerful. When I say infinitely, I am not making up some number, I literally mean infinitely. Things notepad++ cannot do are *trivial* in emacs. Do you want to open pdf? Browse internet? Manage git with two key strokes? Have an awesome inbuilt debugger (gdb-mode, python gdb, various other)? WYSIWYG latex editor? Instantenous, built-in and transparent integration with GNU tools like man, make, grep, parallel...? Optionally using vim keys? Org-mode to organize projects, and your life? A package manager? Alarms, notifications, warnings? Built-in terminal? Built-in shell? Built-in bash-like shell? An package system written completely in lisp (everything is customizable)? **And all this, when emacs looks simpler than notepad++**. Emacs does not look like a bloated, shiny $10000 IDE. It's not slow. It's not memory hungry. But it can do much, much, *much* more than IDEs like PyCharm, Netbeans or whatever. I can of course go on. Do yourself a favor, and learn how to use emacs. It'll change your life.
From what I understand from your comment the only program I will ever need on my computer is emacs since emacs has a built-in web browser and webapps do a lot already. Okay, giving it a shot
&gt; he only program I will ever need on my computer is emacs Pretty much. Some emacs users run emacs window manager and live only in emacs. &gt; Edit: Okay, I am confused by everything. Why is there a command terminal telling me what I just did, why am I able to delete text in that command terminal, why are all the icons so big and ugly, why... Adapting to emacs will take a little time. Also, default emacs is pretty ugly (imho), but there are tons of themes around. Emacs is 100% customizable without need of recompiling since it is almost completely written in lisp. Also, understanding emacs the way I described above might take a bit of time. Emacs is like an Operating System, it certainly has a certain learning curve. But at the end of the day, it'll make you very productive. Happy hacking!
Is there something like this but for Scheme? (Yes I can see many advice in the pdf is also applicable to Scheme)
&gt; Emacs is 100% customizable without need of recompiling since it is almost completely written in lisp. Sure, but what I want is not something I can customise in order to make it work exactly the way I want, I want something that works out of the box with the option to customise stuff here and there. &gt; since it is almost completely written in lisp. Not very useful for a beginner in lisp like me though.
Try Atom editor which is rather user-friendly and its Common Lisp plugin: https://atom.io/packages/atom-slime Alternatively you can download Lispworks Personal IDE to play and study http://www.lispworks.com/downloads/index.html
&gt; Sure, but what I want is not something I can customise in order to make it work exactly the way I want, I want something that works out of the box with the option to customise stuff here and there. You're totally right. Install spacemacs. It's philosophy is "emacs that 100% works out of the box". I don't use it myself, but people have good opinion of it, so I guess it's good. As you learn emacs, customizing it in favor of your workflow is a strong perk of emacs. Just saying.
Most CL implementations include the compiler in the run-time. Your code gets compiled and the function pointers in your other code get updated. (Multi-threaded behavior is implementation-dependent.)
The qualities of Emacs are not really important in this context. What matters is that Emacs has good integration with Common Lisp implementations. The only better option is if your chosen CL implementation has its own IDE included. Notepad++ might be a good editor, but it is less popular than Emacs among open-source Emacs users and therefore has inferior integration with most CLs. One reason for this is that Emacs was invented by Lisp programmers in the 1970s, so it is part of the culture.
Wow, very nice! It would be really cool to develop an Android app in lisp.
Best at what? There are several Common Lisp implementations that continue to find use because they're good at different things. If you want a comfortable development environment right out of the box, and don't mind that you can't distribute delivered applications, use the free personal version of Lispworks. This is often the best choice when you are starting to learn Lisp. If you want a free Lisp that you can use to build delivered apps on the Mac, Linux, and Windows, and you don't need to build GUIs (or don't mind wrestling with low-level interfaces to platform-native GUI toolkits yourself) use SBCL or CCL. If you mainly want very fast generated code, use Lispworks, SBCL, or Allegro CL. If you want commercial support and don't mind paying for it, use Lispworks or Allegro. If you want integration with the Java ecosystem, use ABCL. If you want a fairly small and highly-portable implementation, use CLISP. If you want a Common Lisp you can use to write programs that can be embedded easily in C and C++ applications, use ECL. If you want fast compilation and good support for Mac GUI frameworks, use CCL. If you want the most commonly-used free Common Lisp development tools, use SBCL and Emacs with SLIME. They all have their uses. Which one is best will depend on what you want to do.
Common Lisp, and a couple of other languages, notably FORTH and Smalltalk, are designed for incremental programming in a style where the language evaluator runs in a loop and the programmer types in expressions that ask the running program to modify itself. For example, when you type in and execute a DEFUN expression you are asking the running Lisp to add a new function definition to the running system. After execution, the Lisp system continues to run, but now it's a new Lisp system, in the sense that it knows a function that it didn't know before. The idea is that you start with a program that is running, but it's not yet the program you want to build. You incrementally turn it into the program you want to build a little at a time, by defining the features that it lacks. When it has all the features you want it to have, it's your program. When it starts out, the set of features it has includes the features needed to interact with you and the features needed to modify itself as it runs. Lisp, Smalltalk, and FORTH are all designed to be extended and redefined a little at a time. Lisp and Smalltalk in particular also provide extensive tools for inspecting and exploring the dynamic state of the running system, to help you figure out what to change and how to change it. 
In short, because the system was designed to support redefining things- even classes, in the Common Lisp world, have a process for what happens to existing instances when you change the class structure. The real reason everyone uses emacs, btw, is because SLIME (the emacs package for Lisp) is designed to take advantage of this functionality by letting emacs talk to your running program while you are updating it. This gives you debugger integration, inspectors, and a much nicer REPL than what you just have at the command line.
Okay but when I ran slime and wrote some code in it there wasn't the option to run it from the text editor. Am I missing something?
Awesome! btw. someone on the subreddit suggested me using spacemacs. Does it support this style of programming?
Well, so working through this, I'm assuming that you 1. Installed emacs 2. Installed slime in emacs 3. Started slime (M-x slime) and have a REPL inside of emacs If you open a .lisp file in emacs now, you'll have a bunch of extra keybindings for sending code to your running Lisp (and there ought to be a menu option too, but I haven't run with the menu turned on in a while 😅) I'd suggest checking out Practical Common Lisp: the first couple chapters show you the keybindings for vanilla emacs, if I remember correctly, and there's a link to a free online copy of it in the sidebar 😁
Well, I'm assuming that you 1. Installed emacs 2. Installed SLIME 3. Started SLIME (M-x slime) and have a repl inside your emacs window Now if you open a .lisp file you'll have a bunch of extra keybindings for sending code to your running Lisp program (the REPL slime started). There should also be a menu, I think, but I haven't had that turned on in a while 😅. I'd suggest checking out Practical Common Lisp- the first few chapters are a tour of the basic slime keybindings and there's a link to the online version in the sidebar.
Spacemacs is a configuration of emacs that, IMO, makes a lot of things easier. It doesn't add any Lisp specific features of its own, really, but it packages together things like SLIME and smartparens (one of the many nice packages for managing the parenthesis). However, spacemacs is, by default, also designed to act more like Vim than Emacs, so if you don't like vim you may find the user experience lacking in places.
I'm assuming that you 1. Installed emacs 2. Installed slime in emacs 3. Ran slime (M-x slime) and have a REPL inside of emacs now Now if you open a .lisp file you'll have a bunch of extra keybindings and menu options for sending code to the lisp program behind that REPL. I'd suggest checking out Practical Common Lisp- the first chapters walk you through the basic slime keybindings in vanilla emacs, and there's a link to the online version in the sidebar.
To answer your other question, it's SLIME which is supporting the incremental development in this whole system 😁
Atom is a huge resource hog, isn't it?
I don’t use spa Emacs, but as I understand it, it’s a collection of conveniences for various kinds of editing. As long as it doesn’t conflict with anything that SLIME provides, then I expect it’s fine. Be warned, though, that there is quite a bit to learn in order to become productive with Emacs, and then some more to learn on took of that to be productive with Lisp and SLIME. It’s not hard, exactly, to set. Up Emacs to work with Common Lisp, but it’s obscure, and if you don’t have experienced help it might be pretty frustrating.
Depends on platform. CCL on mac, SBCL on Linux, ??? On windows (maybe lispworks if I had to?)
Allegro is very slow unless you compile-file. 
If you used slime under emacs then whether your CLI Lisp repl experience was to your liking or not wouldn't be so important. As far as CLISP CLI REPL goes I don't see my cursor disappearing ever. It sounds to me like a local windowing system issue. On the interpreter vs compiler thing in practice there is no difference. A CL REPL is a CL REPL except for less immediately observable artifacts such as performance. A compiler is simply an intrepreter that goes further - down to machine code.
&gt; It sounds to me like a local windowing system issue. Maybe but it only happens when I am using clisp and not any other cmd application...
Fare sums up 'why scheme?', very well. http://fare.livejournal.com/188429.html In my opinion, it's not boolean. You can use CL and then see if you prefer it over a scheme. Use more than one, and it will be worth it. 
Chicken is very slow. the Cheney MTA implementation really has not done well over the ages. Compare performance of it to say Gambit/Bigloo/Gerbil. On Gerbil it's almost 4x faster, provides a truly static binary. Chicken has more libs atm, but is really a poor performance example among schemes. 
With r7rs, and srfis, some scheme implementations finally feel as valid alternatives to CL. Previously it was not easily possible to get real world work done on scheme, due to lack of libraries, or portable ones at least. CL continues to have that advantage over most schemes. 
Lolol, this is pretty funny. Hey, check out Portacle and install that instead. It's emacs with all the Common Lisp goodiness readily installed and it looks way better than the default. Respond to me when you've done that and I'll give you a short list of commands you'll want to know.
Well, you can already develop android apps in Scheme, in PicoLisp; you can do it with very professional commercial products like mocl or LispWorks mobile; most of them exist for years already. This here is special in the sense that even the UI can be very easily developed interactively, running directly on the device, with a UI technology (QML) which is hard to beat, once you start to understand it more profoundly (running both on the desktop and on mobile, so you are free to develop wherever you feel more comfortable for the task at hand).
It seems like lack of standardization has been the plague scheme has suffered from, where as CL is almost like C, pretty much the same everywhere.
No, haven't used it at all. Just noticed that it existed and figured it might be worth a shot. I've mostly been using racket lately.
If you use its interpreter. You can also compile individual functions. That makes things faster. The file compiler then might improve things further. I haven't used Allegro CL recently, but I guess its still the same like most compiler implementations: it does some inferencing, but I would expect that fast code needs more explicit declarations compared to SBCL/CMUCL.
Kinda. But I dont use it, so cant say anything about it. I think I was able to setup it together with the plugin out of curiosity. Anyway it is a new kid in the block, hyped and shiny, and in order to attract new people to CL we better to support this project and spread the word.
It's still missing a bunch of stuff that one would expect. No stack traces, no 'compile this file', etc. I don't think that it's *yet* ready to be how we introduce people to lisp. To me, losing people to the 'I dont like emacs/vim' problem feels better than 'oh the lisp folks said this tools was good but it was unusably unfinished' problem. But damn it, i'm so stoked for the atom plugin to get good enough, it'll be amazing for getting people to try out the language.
You can run both CCL and SBCL on Windows.
Why no default keybinding works. Why ctrl+z minimises the ide, why ctrl+a doesn't select the whole text, why does this shit have so many features to the point of being literally unusable. I don't understand why anyone would need ***so much*** customisability. I just don't get it.
Bro watch the video, I told you about cua-mode in there.
It's a bit misleading to say you can type DEFUN at the REPL and write your program that way. That DEFUN doesn't get saved. Real development occurs by editing files and compiling/loading them into the running image. If the editor were integrated into the Lisp then I think your description would be better, but modern CL implementations mostly moved away from that.
I'm so split on this. On one hand if I start using emacs I will become god-like, but on the other hand it's so alien that I have no idea how to even *approach* this thing. 
Dude, look at it this way: To gain a bunch of nice stuff from using SLIME you really only need copy, paste, cut and undo and the compile stuff. I've given you all of those commands AND made copy, paste and cut into the regular key binds. Now whenever you code Lisp just fire it up, enable cua-mode, disable paredit-mode, open a lisp file (all shown how to do in the video I made!!) and just code and do your stuff. If you want to learn Emacs then that's a different thing and sure, go ahead. It's a powerful tool that can do a lot of cool stuff. But if you just wanna experience SLIME then learn the absolute basic Emacs stuff and just code!
Yes but every time I touch this portacle I always manage to glitch it somehow...
Well :-/ I dunno, you do you man.
So Scheme now is pretty much where Lisp as a whole was before the Common Lisp effort?
&gt; I have never seen anyone actually use such a macro in real life. https://clojure.org/guides/threading_macros These macros are *extremely* common in many projects, they ease reading for people used to C-style syntax &amp; scope. I've found the real kicker is paredit vs no paredit. If you have paredit, and you learn to read lisp, you don't need nest. If you don't have paredit, having each clause on a separate line makes line based editing (e.g. vim) easier.
No, it's not that bad as there is a standards document.
Sorry to bother you again with questions on setting up... I managed not get neither compile errors nor warnings. However, after properly loading sdl2 and evaluating (ql:quickload :sdl2/examples) (sdl2-examples:basic-test) Slime is running but I get no window. I am really clueless. Thanks in advance and sorry to be a PITA. Nacho
sniffs ur so smart I WANNA BE JUST LIKE YOU first i have to stop being such a neet hehe
i agree yes
Lisps sound kinda cute sally sold sea shells at the sea shore
People are going to think you're a spam bot if you post spammy looking stuff.
I've started working on implementing geometry clipmaps for Trial. The first three hours of the attempt are recorded [here](https://www.youtube.com/watch?v=x3s056w6-B4). I'll likely stream the rest as well. Might even make streams like that a weekly occurrence or something, but I'm not sure about it yet.
Video linked by /u/Shinmera: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Gamedev Stream - Pt. 5 (Geometry Clipmaps 1)](https://youtube.com/watch?v=x3s056w6-B4)|Shinmera|2017-10-10|2:49:54|1+ (100%)|6 $quote Likely contains: gamedev! Papers mentioned:... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/Shinmera ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
Hey again Nacho, Bummer, that is odd. by 'properly loading sdl2' you mean running `(ql:quickload :sdl2)` right? The examples depend on sdl2 so it should load that automatically, so theoretically testing the lib should be: - `M-x` `slime` - `(ql:quickload :sdl2/examples)` - `(sdl2-examples:basic-test)` But I'm not 100% sure as I don't work on that project. It's a shame we arent in a closer time zone, otherwise we could just skype/hangout and get this worked out. You might want to try coming to #lispgames on freenode. A few of the folks who worked on cl-sdl2 are there and can provide better info that me on the cl-sdl2 part. Of course for any CEPL info feel free to email me (email is on my github page) or ping me on reddit.
I opened two [PRs](https://gitlab.common-lisp.net/clo/cl-site/merge_requests) on common-lisp.net's gitlab to add some useful links and asked two questions in the [issues](https://gitlab.common-lisp.net/clo/cl-site/issues), suggesting to add syntax highlighting, all with no answer. I may need to use the mailing list, but still. I'm exploring web scraping, creation of standalone binaries, parsing command line arguments, unit tests, with mocks, and some other stuff and documenting it in an ongoing [tutorial](https://vindarel.github.io/cl-torrents/tutorial.html). Highly lacks error handling. 
I am writing an easy-to-use automated hyperparameter tuning framework. Made in 2 days and is already useful. https://github.com/guicho271828/dynotune 
Thanks again. It didn't work. The process cl-connect.. is running in Emacs but no window so far. I will check that IRC channel! I want to have this working because I want to follow your pushing pixels Episodes!! It's frustrating hahaha. Cheers Nacho 
bad bot
Thank you Baggers\_ for voting on \_youtubot\_. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
I'm currently trying to make the android REPL finally usable and stable; it seems almost done now (editor, command line, undo/redo, copy/paste/eval of s-expressions). Links: [screenshot 1](https://gitlab.com/eql/EQL5-Android/blob/master/screenshots/REPL.png) | [screenshot 2](https://gitlab.com/eql/EQL5-Android/blob/master/screenshots/REPL-copy-paste.png) | [download repl.apk](http://lights-of-holiness.eu/tmp/repl.apk) You'll need android version 4.1 or later, and it works best in portrait orientation (not landscape).
Yeah, thanks for the time you put into writing all of these replies, I appreciate it. Anyway, I'm gonna go back to learning lisp. :)
I am finishing my work on racket-like for loops for guile. The last little part is to make it possible to define your own sequence types and, since guile hasn't got a jit, make some sort of hinting for ranges and vector-like sequences where the step is unknown at compile time so that you can squeeze maximum performance out of it. It ended up not being much code at all. Most of the complexity is dealing with accumulator passthrough for for*-style loops. I am done with most optimization work,and for the vast majority of cases my loops are as fast as hand rolled named lets. With the exception of for/list they have no mutation and as such are multi-shot continuation safe (whereas for/list uses reverse!, but I provide a pure version). https://bitbucket.org/bjoli/guile-for-loops I have been thinking of porting the CL loop macro, but I am not sure it would bring much. It is hard to implement without mutation and, if I understand correctly, continuations if you want to support making mid-loop exits, continues and collects. That will make it a lot slower than the ones I already have, with very little benefit.
bad bot
:)) I translated as: "let's annoy Shinmera by punishing the bot that over-exposes his videos" All in good fun of course. 
I made a small buggy blog engine (https://github.com/a-guile-mind/presence) using Guile and Biwascheme inspired from ReactJS. I cycle back to my search engine work (mostly https://github.com/a-guile-mind/Culturia). Help/Feedback/Brainstorming welcome!
Haha, I'm try to corner a market here :p. Honestly though it's just odd to go to the trouble of using markup to make the link unobtrusive and then a bot comes in and makes it massive
Bad bot
I have ported CCLDOC away from CCL and made it run on SBCL and ECL, and one other person made it work on LispWorks. I am now actively working on Swank for Lisp Flavored Erlang and hope to have it finished by the end of the month, along with an associated conference paper. It turns out that other people might be interested in using and extending PROTEST, my protocol and testcase management library. It might see more attention soon.
Np! I hope you'll have a good time and learn lots of interesting things :).
Ooo LFE goodness! please post news here as that progresses.
Will do!
I've written a prototype of a library that wraps the ASDF loading process, saves any warnings, and generates an HTML report for later browsing. I'm not sure how portable it can be made to be, or how much detail about warning contexts can be extracted, but it's useful (to me) even as-is.
But that's not what I said. I said that if you *do* type a defun and execute it, the running Lisp is modified. The same is true if you type a DEFUN into a file and load it: the running Lisp is modified. Recall that the context was someone asking how it could be that a running program is modified while it runs. The answer is that the Lisp runtime is designed to support runtime modification of the data structures that represent its features. The same is true of a few other languages, of course. You are unquestionably correct that, given the way most implementations are designed, you would not develop a program by just typing DEFUN at the repl. You would write files full of code. That's a different matter, though. Its true that when I'm working on a Lisp program I pretty much always write code into a file. It's also true that a frequently interact with the running Lisp to modify its capabilities as it runs (most often by evaluating expressions from a file or by loading one or more files).
Just for the sake of completeness: Clojure is also like that. And Clojurescript is a system that compiles Clojure into Javascript. You can change youd Clojurescript code while it's running on a browser (search for "clojurescript figwheel").
Theme voting has now ended. This year's theme will be: Darkness
It's the same as this LET expresssion: (let ((x a) (y b)) (+ x y)) Thus it's useful in the same cases.
Interesting article about the reasons why Clojurescript was chosen to implement a UI for Oracle Cloud.
Interesting also for why they choosed clojurescript's Reagent over elm and other solutions.
I think the most awesome LISP is actually a Scheme and more precisely GNU Guile. Scheme because it has this powerful minimalist spirit. That philosophy aka. minimal abstractions for maximum usefulness is *the* enlightenment. The second enlightenment I had is how lambdas are powerful. The third enlightnement is POSIX thread support. Also there is many awesome libraries fiber, 8sync without forgetting the super duper Guix, which is the most forward seeing distribution since a long time. Guile only allowed to unleash the true power of the programmer, the proof is in the eating. Tell me one project that is as forward thinking as Guix?
my old friend...
Wouldn't your way of running it include compile time?
This is a pretty trivial way to write it, with minor optimisation: ``` (loop (write-sequence (load-time-value (format NIL "~{~a~^ ~}~%" (or (rest sb-ext:*posix-argv*) '("y")))) *standard-output*)) ``` Note that this *actually* performs like `yes`, unlike your own solution which ignores the arguments.
Yeah but we are only measuring the throughput so the upfront cost of compile time wouldn't be a problem.
This works but the problem is that throughput is nowhere close to 1 GiB/s which is what I am trying to achieve. I get around 2-4 MiB/s with this code.
As I understand it the problem is that writing to character streams is slow, whereas writing octets to a binary stream is fast. That said, you are right: I should aim to make it behave exactly like `yes`, and I've added a new version above using your `FORMAT` trick.
Well,as lispm says, it is a form that is regularly used for abstractions. Local bindings in scheme (and CL) is expressed that way. In fact,lambdas and macros lets you create an awful lot of syntactic abstractions. 
you can shave a few characters with: ``` (loop (write-sequence #.(apply #'#2=concatenate '(vector #1=(unsigned-byte 8)) (loop repeat 8192 collect (map 'vector 'char-code (#2# 'list (or (cdr sb-ext:*posix-argv*) "y") " ")))) #.(sb-sys:make-fd-stream 1 :element-type '#1# :output t))) ``` 241
I like lispm reply, he is completely right, I think you can use it for cases where it is easier/clearer to writh things as a formula and then have the values substituted. An example, parallel resistance: ((lambda (r1 r2) (/ (* r1 r2) (+ r1 r2))) 5.0 8.0) It is easier to understand the formula and you don't have to write the numbers twice, of course you could just write. (/ (+ (/ 5.0) (/ 8.0))) But it might not be so easy for other formulas.
By the way that is just one use I am suggesting could be useful as a simple form, lambdas are invaluable in macros, closures, and higher order functions, amongst other things.
 (coerce (loop repeat 8192 nconc (map 'list #'char-code (format nil "~{~a~^~}~%" (or (rest sb-ext:*posix-argv*) '("y"))))) '(vector (unsigned-byte 8)))
... I've come to talk with you again...
A short-but-slow-but-good-enough-for-actual-yes-usage version is (2MB/s): (format t"~@{y~%~}"t) 
Your Edit is much larger than need be; sbcl opens standard-output as a bivalent stream already... `(loop(write-sequence #.(coerce(loop repeat 8192 nconc(map'list'char-code(format()"~{~a~^~}~%"(or(rest sb-ext:*posix-argv*)'("y")))))'(vector #1=(unsigned-byte 8)))*standard-output*))`
Would we need then '(vector(unsigned-byte 8)) or just 'vector ?
A minor problem with that kind of macro is that it's not always ok to put the name of a function in the CAR of a form. If the function name is (SETF &lt;symbol&gt;) it doesn't work, even if #'(SETF &lt;symbol&gt;) evaluates to an actual function.
(loop (sb-unix:unix-write 1 #.(sb-sys:vector-sap (coerce #8192(2681) '(simple-array (unsigned-byte 16) (*)))) 0 8192))
sb-vm::(loop(unix-write 1 #.(vector-sap(fill(%make-array 8192 153 4)2681))0 8192))
That is running at the same speed as yes, 10GB/s, but if you just want the shortest possible: sb-vm::(loop(unix-write 1(fill(%make-array 4 153 4)2681)0 8)) around 20MB/s
And with parsing arguments: sb-vm::(loop(unix-write 1 #1=#.(format()"~4096@{~{~a ~}~%~:*~}"(or(cdr *posix-argv*)'("y")))0(length #1#)))
The shortest without arguments using format: (format t "~@{y~%~}"1) with arguments: (format t"~@{~{~a ~}~%~:*~}"(or(cdr *posix-argv*)'("y"))) 
FORMAT is all the control structure you need: (format nil "~8192{~{~a~^~}~:*~}~%" (or (rest sb-ext:*posix-argv*) '("y"))) Yes, *all* - you can get rid of the OR as well, (format nil "~8192{~:[y~;~:*~{~a~^~}~]~:*~}~%" (rest sb-ext:*posix-argv*)) but that's one character longer, unless I miscount. So, taking /u/lispm's `coerce` with `(unsigned-byte 8)` = `(mod 256)` and a couple other abbreviations: (loop (write-sequence #.(coerce (format () "~8192{~{~a~^~}~:*~}~%" (or (cdr sb-ext:*posix-argv*) '("y")))))) '(vector #1=(mod 256))) #.(sb-sys:make-fd-stream 1 :element-type '#1# :output t))) That's 181 chars, I think, if you squeeze out all the unnecessary spaces. But really, why would `yes` need that speed?
Didn't know that `MOD` was a type specifier, thanks! There was a slight issue with parenthesis in your code, after fixing it I tried running it and ran into this error: Unhandled SB-C::INPUT-ERROR-IN-LOAD: READ error during LOAD: The value #\y is not of type (UNSIGNED-BYTE 8). (in form starting at line: 1, column: 0, file-position: 0) It seems chars cannot directly be converted to ints, you have to use `CHAR-CODE`. Also for some reason your format string doesn't output newlines.
This is wicked cool! Didn't know about that you could give a length in `#()`. Also, what exactly does `VECTOR-SAP` do? Couldn't find any documentation for it.
Never knew that you could give an entire expression and not just symbol names on the RHS of `::`. Is this an SBCL extension or standard CL? Couldn't get this to run for some reason, I get this error (OS X): Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded. Backtrace for: #&lt;SB-THREAD:THREAD "main thread" RUNNING {1002DE6A43}&gt; Help! 11 nested errors. SB-KERNEL:*MAXIMUM-ERROR-DEPTH* exceeded. Backtrace for: #&lt;SB-THREAD:THREAD "main thread" RUNNING {1002DE6A43}&gt; 
Awesome! I think we have a winner.
Nice, but also see [this](https://www.reddit.com/r/lisp/comments/75wla9/writing_a_fast_yes_program_that_can_fit_in_a_tweet/doajixx/) that's even shorter!
That's an extension.
Thanks, I thought so.
&gt; It seems chars cannot directly be converted to ints, you have to use CHAR-CODE. Ouch, thinking with my C brain there. Yes, `char-code` is needed, or `char-int`, to save one character. Use MAP with that to do the conversion: (loop (write-sequence #.(map '(vector #1=(mod 256)) 'char-int (format () "~8192@{~{~a~^~}~:*~}~%" (or (cdr sb-ext:*posix-argv*) '("y")))) #.(sb-sys:make-fd-stream 1 :element-type '#1# :output t))) That's 185 chars. Ought to work if the type system code is reasonably good on integer ranges. In fact, if there are no vector types between that and `bit-vector`, you might be able to get away with writing `(mod 3)` and relying on upgrading, but I don't know what `make-fd-stream` would make of that and I don't have SBCL to test.
SAP means System Area Pointer, so this basically gives a pointer to the vector, but unix-write already calls vector-sap, so it's not needed.
(%make-array 4 153 4) is deeply internal and unportable, 153 means SB-VM:SIMPLE-ARRAY-UNSIGNED-BYTE-16-WIDETAG and its value actually varies.
This can be useful during development, suppose you are writing: (call-something (lambda (x) ...)) and you want to test the anonymous lambda form alone. You wrap it in a pair a parentheses: (call-something ((lambda (x) ...) 10) | ) ... with "|" being the cursor. Then you eval the last form.
Sorry for the late reply. The latest version of the Chicken code I wrote is [here](https://github.com/zodmaner/parse-dataset). If you find any mistakes or have suggestions, please don't hesitate to share. &gt;Would love to see how it compares on Gerbil. Me too! Please do share the results. &gt;I found Chicken to be very slow as well. The Cheney MTA implementation really does not seem to compare well to many other schemes that also compile to C. Ah I see, I didn't know that. That's a shame. Despite performance issues, the ecosystem of Chicken Scheme is really nice.
more background info @ https://news.ycombinator.com/item?id=15466124
Very cool project!
Cool. If you could save an image as a bootable ISO this would be useful for writing minimalist cloud servers in Lisp.
The only lists which are allowed as the first element of a 'form' is a valid lambda expression. http://www.lispworks.com/documentation/HyperSpec/Body/03_abab.htm 
That was a REALLY good talk, thank you for sharing. It shone my night!
[removed]
In CL, `((1 2 3) (4 5 6) (7 8 9))` is a list of lists, and also valid Lisp data. But, if you want to *evaluate* a Common Lisp form, then the first element of that form must be a symbol, or a lambda form. But in Schemes and such, you can write things like `((if #f + -) 4 2)`.
The term "form" already includes the requirement for it to be intended for evaluation. See the [glossary](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#form).
Got it.
Homoiconicity is the naive concept that the program's elements are stored in the machine in the same way that they are typed in. Examples of homoiconic languages are classic BASIC and Bash. The lines you enter into BASIC are stored either verbatim or in a tokenized form that is almost the original text, just with keywords replaced by codes. In Bash, you can see your function definitions if you execute `set` with no arguments. There are pretty much only whitespace differences between what you see and the original definitions and you can cut and paste these definitions into anther shell instance. Making a source code AST available to macros, so that it may be transformed before compilation or interpretation, isn't homoiconicity. Common Lisp has some limited, implementation-defined support for homoiconicity behind the function [`ed`](http://clhs.lisp.se/Body/f_ed.htm). `(ed yourfunc)` is not possible if the Lisp compiles all functions. Even if it fully macro-expands functions and then stores them in source code form, it is no longer truly homoiconic; editing the macro-expansion of your function is going to be mildly to severely inconvenient, depending on what sort change you intend to make. 
That was an interesting talk, and I enjoyed the historical review of the concept. At the end, he segued to promoting a program architecture that he implied was homoiconic, but that could be more accurately described as organized around transformations of a core data structure (I don't know of a good single word for this style). That can be a useful approach, but I'm not entirely converted to it, and I don't see a strong connection to the kinds of homoiconicity that he was talking about earlier.
Very interesting. The first part of the talk is mostly history and background. Meat of the definition starts here https://youtu.be/o7zyGMcav3c?t=19m54s
Wait... You can't write that in CL? Why on earth not?
Because this: ((if (some-predicated-using-the-position-of-the-moon-p) #'+ 42) 2 3) Common Lisp wants a function/macro/special-form/lambda-expression in the first place in a list form. It was thought that this helps simplifying things for the interpreter/compiler/runtime system. If it would allow evaluation, then arbitrary things could suddenly be there. Like the number 42, which is not a function. In Common Lisp you have to use FUNCALL and FUNCALL will actually check that the first argument is a function object. (funcall (if (some-predicated-using-the-position-of-the-moon-p) #'+ 42) 2 3) 
Because CL is not a Lisp-1.
I had no idea this existed. Looks like a promising, really well done socket library at first glance. Will check it out for use in Erlangen!
Cool. Thanks for the explanation.
Good stuff 40ants team, may you produce more material like this ! 
The topic is covered very well in its the Wikipedia entry. I believe Lisp people should distance themselves from the term "homoiconic". It is a "code-is-just-character-text" concept that is harmful and its use misrepresents any decent member of the Lisp family. The main use case of homoiconicity is decades obsolete. Homoiconicity provided for the ability to edit programs in an environment that didn't have adequate OS facilities like multiprogramming, files and editing programs. If the language interpreter could hold the code in memory in editable form, all editing could be done without swapping to another program and using intermediate external storage. A REPL with history editing and recall is today's best facsimile of that use case: in a REPL with history recall, you can fix your mistakes and improve code without leaving to use another program or intermediate storage. The history effectively provides the homoiconic concept of the program being stored in the same representation in which it was entered. Just instead of function definitions, it's just raw command lines. This is a good form of homoiconicity that sits as a layer above the language, without forcing itself into the semantics of how functions are represented. The absolute need to have functions stored in the original form is outdated. When working on any significant project, we put functions into files. When we want to edit them, we refer to the files. The files are processed and the code is converted to a representation that is quite unlike the original: not homoiconic at all. That's what executes. There is no need to revert that back to the original form; we can update the original form, process it again and re-load to replace the previous translation. The useful concept in Lisp is kind of a cousin of homoiconicity, namely *read-print consistency*. Read-print consistency lets us debug complex data transformations, and to marshal data structures for external storage and communication.
Inspired by [this entry](https://www.reddit.com/user/svetlyak40wt), I decided to record some late-night hacking. Turns out it's too big for asciinema, so self-hosted. Small droplet, be gentle.
Nice work. How did you record it? BTW, below are project generators for common lisp: * http://quickdocs.org/cl-project/ * https://www.xach.com/lisp/quickproject/ * http://quickdocs.org/eazy-project/ * http://quickdocs.org/trivial-project/
Sure, we'll do! Actually, it is a part of a bigger tutorial. But it is in Russian. 
Some optimizations are language-independent. For example, full traversal over a short key/value list is faster than a hash table lookup. This can hold true for surprisingly large N. A lot of CL optimizations are implementation-specific. SBCL is a good choice. You might start with the SBCL internals documentation and some articles by Paul Khuong. Fateman has some writings on how to structure code for fast symbolic algebra processing. There were also a couple libraries for exposing SIMD and GPU operations, but I don't know how active they are. http://www.sbcl.org/sbcl-internals/index.html https://www.pvk.ca/Blog/2014/03/15/sbcl-the-ultimate-assembly-code-breadboard/ https://www.pvk.ca/Blog/2014/08/16/how-to-define-new-intrinsics-in-sbcl/ If you are comfortable with the performance model of C/C++ and are just looking to lisp for the flexibility, then you might prefer ECL over SBCL. ECL makes it very easy to interact with native code. Not Lisp, but Halide has perhaps the best organization of different loop/array traversals for optimization. Very clean separation between arithmetic and optimization. http://halide-lang.org/
&gt; ECL makes it very easy to interact with native code. All contemporary CL implementations offer CFFI for interacting with shared libraries that export C bindings.
As nuntius said above, you're digging into the land of implementation details - the standard specifies only very basic tools for profiling and timing, and leaves a lot of performance details for implementations to define and use. If you want number crunching, you'll want to look at SBCL. It has a lot of possibility to optimize code for speed and a compiler that is going to flood you with information the moment you want to squeeze maximum possible speed out of the language, and also tools for profiling the code. As for processing of huge mutable data structures, then it depends on the data structure - but the moment you once grab a hold on a "place", which is a defined term in CL, you are both able to read the value from that place and set a new value in its place, saving you an additional traversal. An appropriately constructed data structure will allow you to do that. I also know that SBCL has tools for atomic CAS (compare-and-swap) that is thread-safe.
Thanks. I used [asciinema](https://asciinema.org/).
Progress: I tried to dig a little deeper and found out how truly amazing sublime text is. Like the multi-cursor thing is a simple and powerful tool that I really like. And it has those little things that I sort of always wanted so it's super awesome. 
Something that compiles through C has other possibilities. Chicken scheme has by far the easiest interop with c, since it supports loading and parsing header files.
Something that compiles through C has other possibilities. Chicken scheme has by far the easiest interop with c, since it supports loading and parsing header files.
Interaction is not the same as "calling". ECL allows using Lisp from C/C++ as well, or even compiling Lisp systems to shared object.
Emacs has that :P https://www.youtube.com/watch?v=jNa3axo40qM
I don't follow how "translates to C/C++" causes "embeddable in a C program" to be ruled out.
Because if it's embeddable then it either needs to be interpreted or compiled on the fly. I don't want something that spits out C/C++ source code that then requires a C/C++ compiler on the end-user's system to build it before it can be loaded back into the host program.
Why the "no GC" rule? 
Yes, emacs has everything but sublime text both has it *and* is usable. It's the perfect middle ground between emacs and notepad++
Damn, I guess I must have dreamt all those years that I used Emacs ;-). Perhaps what you think of as usability is merely habit?
Now I'm wondering if there are any production-quality embeddable languages at all without GC. Can't think of one off the top of my head.
Maybe. My point is that it's a lot easier to switch to sublime than it is to switch to emacs since all of the stuff you had before work exactly the same way, it's just that it's a lot more on top, while in emacs nothing works the same way and there's this steep learning curve. It's like learning dvorak - you will be extremely unproductive for the first week and won't be able to do *anything.*
In my experience, "embeddable" and "compiled on the fly" are not commonly understood as synonyms.
If it doesn't have GC, it either isn't Lisp, or else it has situations in which it crashes due to OOM unnecessarily. What you're basically asking for is some sort of Algol or Fortran descendant with parentheses. 
If it used reference-counting for all dynamic objects, which way would you call it? GC or not? 
Not. https://en.wikipedia.org/wiki/Automatic_Reference_Counting
Sure! I can't disagree with that.
X-Post referenced from [/r/common_lisp](http://np.reddit.com/r/common_lisp) by /u/flaming_bird [Hexstream's online MOP reference is complete!](http://np.reddit.com/r/Common_Lisp/comments/76kkfu/hexstreams_online_mop_reference_is_complete/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I'm using embeddable in the Lua/Python/Ruby sense of the word.
There are lisps without GC, e.g. https://github.com/carp-lang/Carp There are embeddable ones, ECL and Guile. There are reliable ones, e.g. SBCL. But nothing that satisifies all 3 it seems. Sadly even after 24 years of development Guile is not yet reliable. Read it and weep: http://lists.gnu.org/archive/html/guile-user/2017-07/msg00058.html
Right, not, e.g., in the "Embeddable Common Lisp" project's sense of the word.
&gt; Last, any ressource featuring a thorough discussion about how to profile a Common Lisp program (e.g. using SBCL and SLIME) would also be very useful. You might already know this, since you asked for a thorough discussion, but you can do simple profiling by calling the time macro (http://clhs.lisp.se/Body/m_time.htm).
Embeddable Common Lisp has an interpreter and a byte code engine/compiler. Thus you can use ECL as a scripting engine like Lua/Python/Ruby, without the need of a C compiler at runtime and still able to execute new Lisp code. 
tools for parsing header files are available for C, too.
https://github.com/cosmos72/cl-parametric-types
newLisp http://www.newlisp.org/index.cgi?page=FAQ
I believe he gave a version of this talk at the latest Clojure conference. https://www.youtube.com/watch?v=dCuZkaaou0Q
Arcadia https://github.com/kimtg/arcadia
I doubt there are such tools that are actually *casually* usable. groveller is not enough. for example you can't look up the value of the constant/preprocessor symbols treating the file as a simple plist.
I simply would like to know *why* 'no GC'. I'm not trying to argue with you, but some context would help me understand your thought-process.
It compiles to C, though, and it shouts a warning about being a research project.
Of *course* [refcounting is garbage collection](http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon04Unified.pdf), whatever some anti-GC evangelists may claim. It's not complete - it won't collect cyclic structures - so it's usually backed up with a tracing collector; but it is (generally) incremental, and (unlike a tracing GC, which demands whole-system knowledge) it can work across a distributed system, even in the face of degradation. However, in a naive implementation any pointer write might end up setting the refcount of a huge tree structure to 0, resulting in a cascade of free()s and an unpredictable pause; in fact, the overhead of a naive reference counting implementation can exceed that of a naive mark &amp; sweep algorithm [by 30%](http://users.cecs.anu.edu.au/~steveb/downloads/pdf/rc-ismm-2012.pdf), although optimisations can reduce that overhead. Like everything, the choice of GC is governed by acceptable trade-offs. Stop-the-world tracing collectors give pauses proportional to the active heap size, but minimise memory consumption; stop-and-copy collectors double the heap size, but automatically relinearise data, which helps with performance overall; concurrent tracers remove the potential for relatively unbounded pauses, at the cost of much larger heap:live ratios; reference counting minimises pauses in the general case, at the cost of relatively unbounded pauses in the worst case; Henry Baker's Linear Lisp has excellent memory performance, at the cost of doing a deep copy of everything all the time; but all still beat managing memory by hand, which combines the worst of all possible worlds with a potential for disastrous error all its own. 
That was the thing we were discussing. The original claim was that ECL has the best interop with C, and I used chicken as another example thereof.
Maybe s7 scheme. you can explicitly turn off the GC. Not sure if that gives what you want.https://ccrma.stanford.edu/software/snd/snd/s7.html
&gt; The original claim was that ECL has the best interop with C 'ECL makes it very easy to interact with native code.' Where is the word 'best'? 
I used LispWorks profiler build in their IDE. One can use LispWorks Personal to load the code and profile it there.
Which is precisely why I'm not using it.
Look, the reason I replied in the first place was that the grandparents claim was redundant. ECL makes it very easy to interface with c compared to other lisps. The reply that CFFI exists in the context that "ECL makes interfacing with c very easy" implicitly comparing to other lisps and CFFI required a response. I have failed in conveying what I wanted to say. So I try again: My experience is that interfacing with C is easier from languages compiled through C. My experience with CL is limited to ECL, but with scheme chicken is by far the easiest for relatively simple things,whereas the chez FFI is probably the most elegant for when you have for a lot of shared state with C code without having to convert to and from scheme objects.
&gt; ECL makes it very easy to interface with c compared to other lisps. He did not compare it. He did not say 'easier'. Just 'easy'. My Porsche is fast. It's not faster than my Ferrari. It is just fast. &gt; My experience is that interfacing with C is easier from languages compiled through C. That's what a lot of Lisp implementations do. ECL, mocl, GCL, CLISP, and a zillion other Lisp implementations are compiling to C or written in C. There are also a zillion other Lisp implementations written in C. I seriously have no idea which has the easiest integration. Many years ago I used Macintosh Common Lisp, which had the whole Apple' toolbox header files pre-parsed and incrementally available, and this thing wasn't even compiling though C. My personal impression that ECL might have a relatively good C integration, since it was built for that purpose. ;-) https://common-lisp.net/project/ecl/static/manual/ 
added to the sidebar. I also left the link Robert Strandh's version for those that prefer plain vanilla html. Though this new version looks ok in w3m/emacs. Big thanks for leaving the text and especially the [hyper-text](https://github.com/Hexstream/clos-mop.hexstreamsoft.com/blob/master/UNLICENSE) in the public domain.
[twitter announcement](https://twitter.com/HexstreamSoft/status/919623972408487936)
Seems broken/inconsistent; you should be able to use a `(setf ...)` form. Works in CLISP: [1]&gt; (defun (setf foo) (obj ix new-val)) (SETF FOO) [2]&gt; ((setf foo) 'x 3 42) NIL [3]&gt; ((setf foo) 'x 3) *** - EVAL/APPLY: Too few arguments (2 instead of at least 3) given to (SETF FOO)
That's an extension in CLISP. It's not a feature of ANSI Common Lisp.
Sure, if we stretch the word "extension" to mean "add the only possible requirement which could apply here, and which is gapingly missing, and then implement it".
I kind of fail to see the advantage of (setf (s1 foo) bar) over ((setf s1) bar foo) Which then confuses me, because the argument order is changed - which you then already got wrong... Given that it encourages to write non-portable code, I would propose to remove it.
ANSI CL document `(setf ...)` forms under *function-name* right in the glossary. You should be able to use any *function-name* in a function call form. It's the least you can ask of a **Lisp-2**, in which you can't have an expression there. For any syntax `X`, `(funcall (function X) ...)`, if well-formed, should be equivalent to `(X ...)`, or else both should be ill-formed.
The proposal had been made already in the ANSI CL standard process. It was voted against at that time. It was part of a larger proposal for adding setf function names.
I am new to Common Lisp (but otherwise a seasoned programmer) and after having read Graham's book “ANSI Common Lisp,” I would like to understand better the performance model of Common Lisp: what constructs are to be avoided and what constructs are to be selected in order to write programs that run fast. I'll take a stab at this but I'm pretty new to perf stuff so please shoot this down if I'm talking crap _note_: For this I'm going to take Chandler Carruth's stance that (roughly) "Efficiency comes from algorithms, Performance comes from data structures" IIRC the spec itself doesnt have much to decree about the performance &amp; CL itself doesnt have a mantra like the 'never pay if you never use it' from c++. This is understandable given that a valid implementation can be interperated or compiled and that alone *can* imply significant performance characteristics. Even basic container types like array don't imply elements are contiguous in memory but instead it is the interface that is defined: &gt; array n. an object of type array, which serves as a container for other objects arranged in a Cartesian coordinate system. My feeling is that you can't get much hard information on performance from the spec itself, but naturally algorithmic complixity still applies, so anywhere you can do less work you can see the benefits. When it comes to numerics you can see these implementation specifics quite clearly. With the correct type hints SBCL[0] is good at storing things like floats unboxed in `simple-array`s and structs, and emits good code. However for bignums ECL has traditionally beaten other implementations due to using GMP behind the scenes. However this factor can be seen as constant to the implementation and so I think if you looking at cost in the bigO sense then this isnt the part you'd be interested in. The standard doesn't contain a user extensible sequences api and doesnt have an analog to iterators, however if you are traversing a datastructure made of the standard sequences/structs/objects then each element will be a value you can hold a reference to, so avoid rewalking a branch of a tree is something you absolutely can do in your code. I don't recall seeing much info on profiling though I found both http://john.freml.in/sbcl-optimise-profiling and http://nklein.com/tags/optimization/ helpful. Classic profiling rules still apply but a few little tips : - if testing a function make sure you are doing enough iterations for the results to be significant - use a dataset large enough that it likley doesnt fit in cache - Make sure the compiler has to keep the result (e.g. mutate something outside the loop) so the loop (or parts of it) don't get optimized away. - Look at INTERNAL-TIME-UNITS-PER-SECOND to get an idea of the resolution of the time results you will be getting. For me it's been milliseconds which has made it a little tricky to meassure variance of runtimes of fast functions, however getting an average has served well enough I hope this helps a little, also there is much to gain when you are optimizing for certain implementations so feel free to ask more about that too. Again I'm a noob in the optimizing space but I'm hoping that if this is wrong it'll get shot down and we both learn from it :) [0] I chose SBCL here as I havent got enough experience in other implementations to say much there (and barely enough in sbcl) 
FYI that wiki page is about an Apple thing, not about the technique itself.
Not even C has to suffer stop-the-world garbage collection. The [Boehm GC](https://en.wikipedia.org/wiki/Boehm_garbage_collector) is designed for GC-hostile languages and environments, and can collect incrementally. In fact, stop-the-world garbage collectors haven't been state-of-the-art for at least four decades now. We even have [hard real time GC](http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Metronome.pdf) these days.
by the way, is "Search Engine &gt; Common Lisp Documentation Search" really up-to-date? It seems recent libs are not here, not up-to-date. I think you can drop it in favor of Quickdocs. lispdoc.org is 502 too.
I opened an [issue](https://github.com/AccelerationNet/manifest-search-web/issues/2) for the Common Lisp Documentation Search. If I get no response, I will remove it. lispdoc.org was [up last month](http://web.archive.org/web/20170916125227/http://lispdoc.com/). I will look into it.
I think I can contribute something to this discussion, because I frequently happen to write numerical code in Lisp. Lisp has a ridiculous number of ridiculous features (subtypep, load-time-value, define-mehod-combination, compile, ...), so benchmarking is crucial to develop some intuition about performance. I use the following tools for benchmarking * plain old CL:TIME, mostly because it displays the number of bytes consed * [slime-sprof](https://common-lisp.net/project/slime/doc/html/slime_002dsprof.html) for statistical profiling * [the-cost-of-nothing](https://github.com/marcoheisig/the-cost-of-nothing) when I really care about nanosecond precision. You can also (asdf:test-op :the-cost-of-nothing) to have it print the cost of various core CL functions like CONS and GETHASH * CL:DISASSEMBLE, or M-x slime-inspect, to check whether the compiler does sane things What I can say in general: Lisp is pretty damn fast. But gracefully fast, not will-segfault-on-every-minor-issue fast. If you want that, too, you have to (declare (optimize (speed 3) (safety 0))) and add some type annotations :)
POSIX shell is Lisp-2; I've never seen a complaint: $ foo() &gt; { &gt; echo 3 &gt; } $ foo=4 $ foo 3 $ echo $foo 4 $ echo $(( foo + foo )) 8 $ echo $(( foo + $(foo) )) 7 
Apropos project generators a recent post from Leo Zovic http://langnostic.inaimathi.ca/posts/quickproject-revisions
FWIW, Common Lisp already has parametric types via `DEFTYPE`, and obviously supports metaprogramming without templates. I can certainly see the use of a library supporting easier to use parametric types a la OCaml's functors. [Lisp Interface Library](https://github.com/fare/lisp-interface-library/) seems like a pretty cool library that does this.
What exactly are parametric types
How would you recreate the PAIR struct example with DEFTYPE?
If I had to parameterize a structure, I would use eval: (lambda (&amp;optional v1 (t1 t) v2 (t2 t)) (let ((name (alexandria:format-symbol t "~a-~a-~a" :pair t1 t2))) (unless (find-class name) (eval `(defstruct ,name (first ,v1 :type ,t1) (second ,v2 :type ,t2))))) For classes, I would use closer-mop:ensure-class. 
One thing I feel missing in the CL declaration system is the lack of relational constraints that facilitates type propagation. You can imagine something lile `(declare (same-type a b))`. 
I'm not an expert but the way I look at them are "variables that will be filled in with a concrete type later on" (I think this only applies to 1-kinded parametric types, or something like that). So eq : a -&gt; a -&gt; boolean means "eq takes two objects of the same type and tells us if they're equal or not".
Very nice, thanks. As lisp beginner such screen casts help a lot to get a feeling for the language.
CFFI is a shadow of what ECL provides. You can treat ECL like Lisp, or like a C library. There is a reason why EQL uses ECL and is not supported by other CL implementations.
That sounds awesome 😁
http://www.markwatson.com/opencontentdata/lispbook.zip There is some code for an old LispWorks and old Allegro CL...
Thanks!!. I imagine that GUI stuff is for CAPI... Cheers! 
Cool. But, Clojure is no Lisp :)
Isn't it dialect of Lisp? :)
Everything is a dialect of Lisp at some extend :)
Been following you on youtube. I just watch small chunks at a time so I've only just finished Ep 4, but I'm enjoying the content. Thumbs up. :-)
Well said :)
Thanks! hearing stuff like this is super motivating. Hope you enjoy the rest of the queue and please always feel free to ask questions in the reddit comments, youtube comments or via email.
There's also [uLisp](http://www.ulisp.com/), but that targets the Arduino specifically
Unlike with-slots with-accessors needs (variable-name slot-name) pairs in its first argument so you'd need: (defun note-name (obj) (with-accessors ((value value)) obj (car value)))
http://clhs.lisp.se/Body/m_w_acce.htm The syntax definition of "slot-entry" is very small in my mobile browser, but describes this.
Huh, okay.. I must've looked at the definitions for so long that I completely missed that bit
[removed]
By the way, the hint is in that it fails during the macroexpansion of WITH-ACCESSORS
Yeah I didn't understand the error at all
&gt; fails during the macroexpansion + == the failure happens *during compilation* , not runtime + == syntax error / misuse of macro or some kind. If the error says something like `TYPE-ERROR while calling VALUE...` , it means that the error occured in the runtime and the runtime data is wrong. For example, `obj` is a wrong object like a string or nil, not of class `note`.
 I am really interested in using Lisp to make games. I personally have created some small games with ClojureScript. Perhaps I'm wrong, but I don't think ClojureScript atop something like Electron is going to get me very far in creating a desktop game. I am looking for something else that I could use to make production level games that uses Lisp. The questions I have are: 0. How do you get the lisp display window going? Which Lisp do you suggest for development? How do you make compiled binaries of a game with lisp for Windows/Mac/Linux etc? 1. In ClojureScript, I use the requestAnimationFrame function of Javascript. This is very convenient as the loop is only as fast as the resources allow it to be. I've tried it in Java with Clojure with simple recursive loops, but the loop consumes all of my resources and I have to put artificial constrains on the loop that cause it to wait for a certain period of time. How do you go about making a game / animation loop with Lisp? 2. As an aside, are you able to track FPS? How is this done? 3. How would you control a character? In ClojureScript, the game loop listens for keydown/keyup events and mouse events and then the character is moved accordingly. 4. How can I include sound? 5. Are there libraries / APIs for game controllers? 6. How can I import objects created in software such as Blender? 7. How would you suggest making a graphical menu? Perhaps you have a blog post on getting started with making games? I'd like to give it a shot. Thanks!
You can use setf with with-slots as well, by the way.
So what's the big difference then?
with-slots writes directly to slots, without calling the accessors. So it matters if you want to use custom accessors.
Oh yeah that makes sense 
My answer will be constrained to Common Lisp, which is what Baggers uses as well. 1. You use a library that handles the window creation over the operating system. There's a lot to choose from, GLFW, SDL2, Glop, etc. For GLFW and SDL2 you'll be using the respective bindings libraries from lisp, of course. You could also use higher level engines of course. Depends on what you want. 2. Same as any other game. https://gafferongames.com/post/fix_your_timestep/ 3. You measure the time it takes between two frames or average over multiple frames. 4. You use whatever input events you want. 5. By using a sound server or sound library like Harmony or OpenAL. 6. Yes. There's cl-gamepad for just that, and SDL2 includes controller support. 7. You either export to a format you know how to load yourself, or use a library to read it out and convert into the proper GPU data. 8. By using a graphical UI library. There's a lot of those, but none that I know of that have bindings from lisp. A lot of your questions here aren't really related to Lisp, and more about just general gamedev stuff. Google around for what you want to know and just start rolling with it.
That `alias` thing is described in a wrongheaded way. Firstly, as far as **forms** go, we already have an alias mechanism: `symbol-macrolet`. `(declare ...)` expressions **are not forms** and are not subject to macroexpansion; it is misleading to say that `alias` performs expansions on **forms** and then use `(declare ...)` as the example! `alias` necessarily has to treat embedded `(declare ...)` expressions **as if** they were forms; and for that, it has to walk the code to find them. 
It might be more CLOSy to specialize methods parametrically at run time. That is, have a way of specifying that if a method for a particular generic function is invoked with a particular set of classes of arguments, and you have not yet generated a specialized method for those classes, generate that method now and then invoke it. This would be an efficiency hack, and possible could be helped if method lookup could be cached on a per-call-site basis.
There's dedicated community exists around making games with lisps: `#lispgames`. Feel free to drop into #lispgames at irc://chat.freenode.net and/or check out [lispgames wiki](https://github.com/lispgames/lispgames.github.io/wiki). Depending on how deep you want to dive into technical parts, there exists low-level libraries like `cl-sdl2`, high level ones like `CEPL`, frameworks like `Chickadee` and even full blown engines: `Trial`, `cl-bodge` (`trivial-gamekit`) or `Xelf`. More info could be found at aforementioned lispgames wiki.
First off thanks to u/Shinmera whos answers were spot on. I'll just try to add some stuff So it depends what you mean by a 'production level' desktop game, there are plenty of browser based games so its not that it cant be done in electron but that environment does have it's restrictions. Clojurescript, like CL is just a language and neither get you that far immediately. My honest advise is that if you *just* want to make a game, an existing game engine is the way to go, whether goldot or unity or whatever. If you arent doing that then, regardless of the language, you are making the decision that you are going to be responsible for everything from physics to asset loading to ai. I'm not saying don't do it, I love making tools and I'm going to be doing this stuff in lisp for the forseeable future. However if right now I had a game idea I was burning to *ship*, I would grab Unity. &gt; How would you control a character? There's a lot that goes into that. Most the the libraries that provide you with the window and context (SDL2, GLFW, etc) also provide fucntions for querying the input events that have happened since you last queried. What you do with these is up to you and you game. Do you want objects to subscribe to events and flow them around you system? do you want each object to check whether a specific button is currently held down? When you have the information what kind of character do you have? Do you want to apply a physics push to you character (maybe for jumping) maybe you want to set your character's speed directly? It depends on the style and feel of you game and how you are handling physics. So for a 'production level' fps you are going to need a collision system and physics system. Maybe you want to write your own but that is a multi-year project in itself. You will likely want to use bindings to an existing library which are (usually) written in c &amp; c++. There are bindings for ODE and I'm slowly working on some for NewtonDynamics (but I wouldnt rely on those yet). But controlling your character is more than just moving a box, it's going to be an animated model. There are a pile of different ways of implementing animation. None are 'the right way' so you want to find out what you want and that also is going to be based on the skills of your artist/s, the tools you are using and your features of your engine. I'm interested in implementing a [gpu-skinning](http://mmmovania.blogspot.no/2012/11/skeletal-animation-and-gpu-skinning.html) system for example, but skinning on the gpu has it's own tradeoffs that I won't go into here. Woops, we have mentioned assets! One of the single most underrated parts of good game-engines is the content pipeline, the system of getting assets from your art tools into your game? You will need to be able to load images (see libraries like cl-soil for this) and 3d models (see classimp for this). But games rarely ship the files that came out of the 3d modeling software, those things have tonnes of uneeded data and are generally slow to load. Most commercial games will have a custom format which is just the data their engine needs. It is also probably laid out so that it can be loaded quickly. It's not just models that have complexity though, those images can be too. A lot of modern engines are moving to 'physically based rendering' and as such the values in the textures may need to be in specific formats too. cl-soil does support loading HDR images however so that part is somewhat covered :) &gt; How would you suggest making a graphical menu? It depends, you could just texture a plain and use your collision system's raycasting feature to 'pick' it. You may want to roll you own very simple 2d ui library, you might want to use something like libnuklear or dearimgui. &gt; Perhaps you have a blog post on getting started with making games? I'm afraid not, I've only made 1 game in lisp for a jam so far as my main focus is in making the process of working with GL really fun from common lisp. I'll stop now simply because this is getting to long but we have ignored a TONNE of stuff and only skimmed the surface of the stuff above. Little bits of advice: - Have a look at the [bodge game engine](https://github.com/borodust/cl-bodge) and [the trivial gamekit](https://github.com/borodust/trivial-gamekit) by borodust. It's the most active game engine in CL currently and the author is a great chap. He's often on the #lispgames irc channel so can help out with technical issues too. - consider trying to make pacman or arkanoid in 3D. Seriously! They are simple games but making one of them will have you touch a huge amount of stuff and build you skills in area you will need for making bigger games - Use SBCL or CCL. I prefer SBCL as it gives better type and perforance information when I want to optimize a function. - Don't be afraid of C libraries. There are hundreds of man-years of work put into these libraries, recreative them all would be a nightmare! I hope somewhere in this ramble is something useful, Peace
I adjusted with-accessors, it produces a less confusing error: ` error: during macroexpansion of (WITH-ACCESSORS (VALUE) OBJ ...). Use *BREAK-ON-SIGNALS* to intercept. Malformed slot entry: VALUE, should be (variable-name accessor-name) `
The most immediate way to get feedback and get involved with what's going on would be to ask and lurk on the Freenode #sbcl channel. Once you have a working patch, it should be submitted to the mailing list so that the maintainers can discuss or approve it to merge it in. You could submit a feature request to launchpad if you want to record a ticket to it, but it isn't the fastest way to get a discussion going. GitHub is just a mirror and PRs or issue tickets there are disregarded for the most part.
Hello, from my exploration of the ecosystem I am not aware of such a CMS but I found related projects. [Coleslaw](https://github.com/kingcons/coleslaw) is a static sites generators. If by CMS you mean there is a user frontend to manage the site, there is no. There should be one in [weblocks-cms](https://github.com/weblocks-framework/weblocks-cms). Didn't try yet. The last commit was this year (hurray!). Speaking of Weblocks, Svetlyak40wt is re-factoring and updating it. His new quickstart tutorial to build a TODO-mvc app is clear and easy: http://40ants.com/weblocks/quickstart.html His branch of Weblocks is still a moving puzzle. He builds [Hacrm](https://github.com/40ants/hacrm), "a hackers CRM - Emacs in the world of CRMs" at the same time (didn't try yet).
I suggest you look for some examples, search github with text caveman2 language common-lisp: full production example written by caveman2 author: [quickdocs-server](https://github.com/quickdocs/quickdocs-server) A very simple example with no database just to test out websocket-driver: [websocket-caveman-chat](https://github.com/aarvid/websocket-caveman-chat) 
This is not a beginner project. And it's already supposed to be transformed, just not very robust. There is very little performance gain, if any, and it can be applied in very limited circumstances, when I is known to not overflow, bounds checking either disabled or proved to be in bounds. Basically, only (safety 0). So, it's not really worth it. 
This was a 15% runtime improvement in a fixed-size matrix gemm with a slight unrolling. Just to note.
Keep in mind that some of the stuff is only of historical interest. For example DART is more than 25 years old... For other stuff see: https://en.wikipedia.org/wiki/Category:Common_Lisp_software 
The first step is figuring out what sort of intermediate code SBCL generates for your example. My usual procedure for doing this is to write a simple function that generates the code you (don't) want--be sure to use `declare` inside the function for types, optimization levels, etc. etc. Once you've done that, put that function in a file of its own and run `(compile-file FILENAME :trace-file t)`. That will write out a `.trace` file containing information about sbcl's intermediate representation. Then you need to look at that, see what's generating the three assembly instructions in the above, see what sort of IR was there in the previous step, and then work out why those aren't getting transformed into `sb-kernel:data-vector-ref-with-offset` with a non-zero offset. You'll want to check out the `deftransform`s for `row-major-aref`, `hairy-data-vector-ref`, `data-vector-ref`, and `data-vector-ref-with-offset`, among other things. Offhand, looking through the code, it seems like your example *should* work; I'd be curious to see what sort of IR sbcl is generating here. Maybe it's just not going through enough rounds of optimization, and you stop just short of being able to get to `data-vector-ref-with-offset`.
I have made a collection of high-res logotypes (originally 4000x4000px) in Photoshop. The upside is that I still have the original PSD files, the downside is that they are pretty huge and the logos are raster rather than vector. You can see the smaller transparent PNGs at https://imgur.com/a/QEd1p
Cool ! Just started mine also: https://lisp-journey.gitlab.io/software/ (announce: new site !) It lacks some but you lack pgloader at least. You could also link to [lisp-lang.org's beautiful list of success stories](http://lisp-lang.org/success/).
Thanks for sharing. Although, Sawfish WM has its own Lisp implementation, not Common Lisp.
You are right, the standard function [LAST](http://clhs.lisp.se/Body/f_last.htm) returns the last cons, and you need to use CAR to extract its element. A popular library ALEXANDRIA has a function named LASTCAR that does what you want.
15% is not that much, but I just don't want to spend time optimizing unsafe code.
Instead of (compile-file FILENAME :trace-file t) I do (setf sb-c::*compiler-trace-output* *standard-output*) And the transform doesn't work because of casts, principal-lvar-use could help, but then it needs to be careful about deleting the casts.
Thanks!
Ah, good point about `*compiler-trace-output*`! Yeah, the cast thing hurts (cf. the comment in the `sb!bignum:%bignum-ref` `define-source-transform`). You can somewhat work around that by carefully declaring the type of `i`, e.g.: ``` (defun f (x i) (declare (type (simple-array single-float (*)) x) (type (integer 0 (4611686018427387899)) i)) (declare (optimize (speed 3) (safety 0))) (row-major-aref x (+ i 2))) ``` gives the desired assembly for me. But declaring types like that can be tricky, and it'd be nice if the compiler could automatically see through the cast somehow.
And, of course, `(car (last x))` always works, just as you have noted. (:
Please add nEXT-Browser to the internet section ;) https://github.com/nEXT-Browser/nEXT 
before I have the browser section, but I have deleted. wow this application is awesome I've added.
To add to this: The chief honcho appears to be Christophe Rhodes but he's not very active/visible. Then, we basically have 5 individuals: nikodemus, stassats, pkhuong, jsnell, scymtym Stas Boukarev (stassats) is the most active of them all and although he can be a bit of a prick sometimes, he's extremely good at the areas he's chosen to focus on and a juggernaut in terms of dedication. Nikodemus was great but he more or less left the project to go work for a robotics startup. Paul Khuong was a genius but he more or less left the project to go work for scummy advertising company (pls come back). Juho Snellman was outstanding but he more or less left the project to work for networking startups (pls come back). The new blood (stassats excluded) isn't even close to the talent that left so development can be a bit slow and narrow focused. 
I have added "Historical purpose" section, thank you so much for your suggestion and link. I also want to find the link last night. any other suggestion for items that no longer in use ?, I will be happy to move to Historical Purpose section. thank you. :)
oh, thank you. :) yes, I have added the lisp-lang.org link. would you like to make a PR so your name in contributor, but if you are busy I want to ask your permission to take the list in your site and add to awesome-cl-software list.
in https://github.com/SawfishWM/sawfish, it use 70% of Common Lisp. is it better to remove it from the list or not? thank you.
I don't know where it says Common Lisp. And yes, better to remove, since the list specifically mentions Common Lisp software, and Sawfish WM is not Common Lisp based/implementation software.
I was really amazed, actually I want to make another logo other than the lizard, but my designer friend want to take a rest for while, I love JSCL logo that you made so I ask my friend to adapt that and change here and there. fortunately you come up with so many beautiful logo, I often look for lisp logo but never find yours in that list, sometimes I find but it's just a thumbnail. why don't you put it in blog so people can easily find it :) -- let's continue the talk in github issue :)
Thanks for the question, I updated the Cookbook: https://lispcookbook.github.io/cl-cookbook/data-structures.html#last-butlast-nbutlast-optional-n
Note: this does not result in fused address computation, since there is ADD instruction; ; disassembly for F ; Size: 28 bytes. Origin: #x100BAA83A9 ; A9: 4883C704 ADD RDI, 4 ; no-arg-parsing entry point ; AD: F30F10447901 MOVSS XMM0, [RCX+RDI*2+1] It should become a MOVSS XMM0, [RCX+RDI*2+9] instead.
 ELISP&gt; (defun clast (l) "Returns the car of the last cons from list L." (car (last l))) clast ELISP&gt; (clast '(1 2 3)) 3 (#o3, #x3, ?\C-c)
Should be called `caast`. :) 
Okay - let's talk there. I will respond on GitHub later today.
The example modifies a literal list. Which is in most programming languages, including Common Lisp, a good idea. The exact effects are undefined in Common Lisp: you could modify multiple lists (since the file compile may share the cons cells in several lists), it could throw an error, it could silently fail, ...
SETFing anything inside a literal quoted list is undefined behaviour in CL. A cookbook should not include such examples since newbies will be learning how to invoke UB.
For a language that's been around so long this is rather underwhelming :(
If you actually look at the whole period from 1981/82 (when the CL development started) there are probably a few thousand significant applications/tools but you would have to know where to look to find information about them, since many are in research or inhouseThe big Lisp Machine companies of the 80s all had CL and lots of applications were written for them. Lucid CL, Allegro CL, LispWorks, ... were the big Lisps on Unix with many applications. On the PC and the Mac there are/were many applications. Currently there are quite a bit less applications under development. The problem is that the many of the historical Lisp applications are good examples what can be done, but they are not really relevant anymore and it makes little sense to repeat all the old stories. Naughtydog's games written with Allegro CL, Interleaf Publisher (a big application similar to Framemaker), Mirai (animation), Axiom (IBM's computer algebra program), Sk8 (Apple's prototype of a next generation media development environment), Metal (Siemens machine translation system), Action (Expertelligence' Interface Designer, which inspired Apple's Interface Builder), iRobot system and application software for many exotic robots incl. the Roomba, Gensym's G2 controling/diagnosing chemical plants/factories, OpusModus for music composition, Franz' Allegrograph graph database, PTC's 3d designer, SRI PVS theorem prover used by NASA, ACL2 theorem prover used by the processor industry (AMD, Intel, ...) in various applications, Refine (used to maintain large software systems in various programming languages), SISCOG's planner/schedulers for the railway companies, the first publication server for the whitehouse, Lisp Machines running real-time vision systems to monitor the rockets of starting Space Shuttles, Lucents ATM switch, Hamburg"s first public transport information system (90s) with touch screen and live search, maintenance scheduling system for Powerplants, the scheduler for the Hubble Space Telescope and a dozen other large scale Telescopes on earth and in space, large-scale Battle simulation system for ground troops with Lisp systems creating the battle scenarios, a large-scale prototype for a Pilot assistant for combat, real-time online help for Tornado fighter planes, Symbolics' NS chip design tool, ... the list is really endless. But much of the stuff is 20 years old. Much of the TV industry used 3d animation systems written in Common Lisp by Symbolics: Smarties commercials, Peter Gabriel's music videos, Apple commercials, Logo animation for dozens of TV studios, ... But that is all old stuff. 
Thanks...
&gt;Sadly even after 24 years of development Guile is not yet reliable. Read it and weep: http://lists.gnu.org/archive/html/guile-user/2017-07/msg00058.html None of those sound like a problem you'll encounter in use as an extension language...
I'd like to thank all of the contributors of McCLIM, you're doing a great job!
Awesome! I can't wait for the day I can ditch Emacs for Climacs. 
thanks, I'll revert this commit and suggest something else in a PR, as I used to do.
thanks for the review, I removed the setf part.
yeah… there's a better showcase here, with commercial products: http://lisp-lang.org/success/
I beg to differ
No need to remove SETF - just use `(list 1 2 3)` instead of `'(1 2 3)` and you're golden.
I was testing on an older version of SBCL; it's possible that the type declaration for the array index needs to be adjusted. The important thing is that SBCL thinks the arithmetic doesn't overflow a fixnum.
A troll question (please ignore, if you can...): "And when will it be ready to support android/mobile/phone/watches/thumbnails..." (That was not a real question; just a reminder that Real World often times will never touch Scientific Progress, tangentially speaking...)
http://lib.store.yahoo.net/lib/paulgraham/onlisp.pdf
https://youtu.be/WxR6Y73yjKY?t=40m21s Don't we all feel like that sometimes lol?
and after On Lisp, i would recommend [Let Over Lambda](https://letoverlambda.com/). although imo some of the code borders on unmaintainable, it will get you thinking about new ways you can use macros.
The thing is, simple programmes usually have no business using macros. You don't really start with macros and then look for places to use them, rather, there will be times when nothing else will do and then you go "well, guess I have to use a macro ".
I understand that, but then again, I would have no practice with macros and usually it would involves more complex requirements. I prefer doing simple to intermediate program with simple macros for educational purpose!
Can you do very simple stuff like implementing while loop etc?
When trying to wrap you head around a new programming idioim, there is no substitute for exposure to the patterns which would be made simpler to abstract with use of the idiom. Sometimes, you need that exposure before you truly understand the reason for the idiom's existence. So its not just about practice. If you never find yourself needing to use macros then you can get along just fine.
You can use `defun` in simple programs; that's a macro.
Even in the simplest program you might want to create some kind of (with-some-resource ...) macro.
Just write code and let the macros find you. Sometimes you have to write numerous (or at least several) expansions of a macro first, without knowing that you're writing the expansions of a macro. Then, aha, look I'm repeating myself in a certain pattern; let's give it a name and make the machine write it.
Simple programs usually have no business *defining* macros. Simple programs *use* macros all the time. 
Right you are, it was a mental shorthand that made it confusing. I really meant to say "defining".
Try redoing the macros PCL introduces and defines, but on your own, peeking only when you're absolutely stuck. That should give you a more visceral understanding of how the whole thing operates.
Emacs comes to mind.
Macros allow you to extend the compiler in some respects. Most languages arrogate that power to compiler writers only. 
**Mirai** https://www.youtube.com/watch?v=-IRsYGfr4jo http://www.izware.com/mirai/paint.htm **Symbolics Graphics Suite** https://www.youtube.com/watch?v=f4Lo0IfUSPk **PTC Creo Elements/Direct Modeling** ( ~10 MLOC Common Lisp) https://www.ptc.com/en/products/cad/elements-direct/modeling 
- There's a tutorial here: https://lispcookbook.github.io/cl-cookbook/macros.html - an example use of backquotes and comas: https://lispcookbook.github.io/cl-cookbook/data-structures.html#creating-lists-with-variables - an example factoring and isolating tests: https://vindarel.github.io/cl-torrents/tutorial.html#org7804e15 hope this helps !
You'll find great examples here: http://lisp-lang.org/success/ (some are not open-source) Mcclim screenshots and links to a couple github projects: https://common-lisp.net/project/mcclim/excite.html 
1. Write a large Lisp program. 2. Notice the parts where the code is repetitive, but has enough differences that you can't simply refactor it as a function. 3. Write a macro that can generate all the instances of repetitive code. 4. Replace repetitive code with macro calls. &gt;the old procedural programming reflex is strong Actually, macros are the epitome of procedural programming. If you were using functional programming, you would still replace the code in pt.2 with a function, except you'd use lots of lambdas to achieve a similar (though less efficient because of funcalls) result as with the macro.
I would second On Lisp, and Let Over Lambda, in that order, you can probably do without Let Over Lambda, but it is a book that has tons of examples the author found useful and some other people do too. Remember there is more than one type of macro in Common Lisp, so at least reading those books you get exposed to what those are, what to use them for, and when to use them.
I highly recommend the Macrology site. See for example the sections [Basic macros](http://malisper.me/category/basics/) and [Advanced macros](http://malisper.me/category/advanced-macros/), but there is ore there.
Thank you!
[Google Flights](https://google.com/flights) is written in Common Lisp.
GNU cash and aisleriot solitaire are both written in a mix of guile scheme and C.
Though it's the backend, which is written in CL, not the UI.
DrRacket, I guess
Emacs is written in C, but has a Lisp (elisp) layer on top for extensions.
I mean, technically thats true, but in practice so much of what you're interacting with in emacs is handled by elisp that I think its fair to say they're at least on equal turf.
I mean, I mean, I mean ^^^I ^^^am ^^^a ^^^bot. ^^^This ^^^is ^^^the ^^^320th ^^^comment ^^^that ^^^starts ^^^with ^^^the ^^^phrase ^^^"I ^^^mean" ^^^that ^^^I ^^^have ^^^detected.
dat factor implementation tho
Are there any ways to obtain a working copy of Mirai today?
The C core of Emacs is a Lisp machine with a few facilities for displaying text buffers in windows grouped within frames. The whole actual editor is in Lisp, and the whole UI is implemented in Lisp. The Lisp layer is not a plugin framework, but the way the whole editor works. This is actually what makes Emacs different from all other editors.
Depends which Emacs you are talking about. The Emacs, called Zmacs) on my Lisp Machine is written in Zetalisp and Common Lisp. If you think about GNU Emacs, that one is actually written in C and Emacs Lisp. Emacs Lisp is not only the extension language, but also the implementation language for large parts of the editor.
I notice that none of the macro examples people have talked about here use &amp;environment parameters. I've found these to be useful when layering a DSL onto Lisp, when I want to include declarations of some kind in the DSL. The information in the declaration can be encoded into local macros using MACROLET, and the values stored there read out by macros used lexically inside it, by using MACROEXPAND with the environment argument. Trying to do this by assigning to or binding special variables doesn't work.
Thats not entirely true, even in simple programs macros save time and space for typically copy-pasted code which better not to move to another function (even with flet) but easier to simplify with macrolet.
Reddit was originally written in Lisp!
http://www.izware.com/mirai/
Sorry to hear. Feel better. Btw what keyboard are you using in the videos?
AFAIK the company is defunct and won't sell anything, is that not true?
I think nobody has mentioned: * [Mezzano](https://github.com/froggey/Mezzano) * [StumpWM](https://stumpwm.github.io) * [Sketch](https://github.com/vydd/sketch) 
Looks very nice! What software did you make it in?
Classic. 
A CAD package called Solidworks, actually. It has very basic rendering capability, but you can lay out things perfectly with its CAD functions. So that is a true 3D object I can do arbitrary rotations with.
Fair enough, I should have said GNU Emacs and not limited elisp to just extensions. I stand corrected :)
In the absence of further details I would assume this means it doesn't need anything more than a minimal libc, but still probably wants `malloc` to be present in the background. Hard to imagine how it would function at all otherwise. If you're interested in Scheme for super-constrained platforms, Feeley is also the original developer of [Picobit](https://github.com/stamourv/picobit), which focuses on efficient memory usage more than on speed (it's a pure interpreter).
I wrote the user interface for Opusmodus (https://opusmodus.com). It's pretty nice, if I do say so myself. It is implemented with Clozure CL's Objective-C interface. It uses Cocoa directly. The downside to this is that you end up writing what looks like Objective-C in Lisp. On the other hand, it is an existence proof that if you know Cocoa well, you can take advantage of it from Lisp. You asked about "large and non-trivial" user interfaces, so https://github.com/Clozure/dpf probably doesn't qualify, but its source code might it might give you an idea of what the Cocoa UI code ends up looking like.
Thanks, I'm using a 'microsoft natural ergonomic 4000'
https://github.com/cbaggers/cepl - CEPL (Code Evaluate Play Loop)
It's clojure rather than common lisp, but [play-clj](https://github.com/oakes/play-clj) does a great job wrapping Java's libgdx's graphics engine into an idiomatic functional style that works nicely with clojure live coding tools.
Looks good. I did just say "lispy" so any dialect goes. And I've worked full time in Clojure, so I don't at all mind using that.
[Processing seems to have Clojure bindings](https://clojars.org/search?q=processing), but I don't know how idiomatic they feel
Oh I know about [Quil](https://github.com/quil/quil). And I've been meaning to experiment with it, but I guess I'm trying to broaden my options.
The direct equivalent to Processing in Common Lisp is SKETCH. You can install it using quicklisp and here is the project website: https://github.com/vydd/sketch
This is a really cool tool, but it's 3d/OpenGL. I think OP is looking for something they can make 2D games with.
This is perhaps more than you're asking for, but consider [Arcadia](http://arcadia-unity.github.io). It lets you use Clojure in Unity.
Guile Scheme has Chickadee https://dthompson.us/projects/chickadee.html A game creating framework by David Thompson. The downside is that dependencies for it are a hassle to install.
Thanks for recommending it, however CEPL is essentially lispy OpenGL. You need a bunch of other stuff to match what processing has.
Take care, man ! See you next week.
Well, it's Love2d ;) So there are these crazy guys, who made Urn, a lisp which compiles to Lua and has Love2d bindings. Take a look [here!]( https://user-images.githubusercontent.com/1434138/31722265-f1ff3e12-b41b-11e7-8e94-20ccaccc08da.gif) This is a simple Urb example which emits Love2d/Lua code from with the atom editor and which is live reloaded... You can read about it in the Urn [issues!](https://github.com/SquidDev/urn/issues/12) page! 
Commenting on the nature of stassats: over the years, he has proven to be a very knowledgeable individual who has generously given me and countless others copious online advice and code to advance the state of Common Lisp implementations. Never a prick, always a solid person, and a team player in the Common Lisp community. 
Can't speak for racket, but chezscheme can re-import libraries on the repl, however you have to reload the file first. &gt; (import (foo)) &gt; #| oh darn, I found a problem and changed foo.ss #| &gt; (load "foo.ss") &gt; (import (foo)) This isn't perfect, and if you have a dependency hierarchy (foo depends on bar depends on baz) you'll have to reload and re-import the leaf dependencies first.
Can't wait! Are the talk proposals going to have to be in the 'academic paper style' that was required in previous years?
I'm curious about Chez scheme as I've heard that it supports unconventional means of interacting from the REPL (using arrow keys or similar to operate on s-exps rather than lines, working with multiple lines....). Do you know anything more? Is there an easy way to try it?
I doubt ELS is suddenly going to change its format.
Have a look at Chez [user manual](https://cisco.github.io/ChezScheme/csug9.5/use.html#./use:h0). It is definitely quite advanced.
Yes, I am. 2d games and interactive art.
I wish I were familiar enough with the Unity API to use this.
I shot a bunch of random tester bugs to him over the last few weeks and he's knocked them down with impressive speed.
the new line here - http://learnlispthehardway.org/book/ (i'm a cheat)
how long does it take to get a reply in this loony bin?
well?
fuck it i give up
look i got through the JCSL bit
i'm in a psychiatric unit and bored out of my marbles
can you get 10motives eciggs over there?
i'm bribing you for help coz i'm a lazy git (and i have a tIGHT DEADLINE TO WORK TOWARD, THUS FORSOOTH HPW COULD Y OU forsake me like thius thouh . and i'm an idiot
i made www.cz2.co.uk, coded it in html
Oh right, your second question. There are a number of differences between scheme and common lisp. The first difference is that common lisp is a language and scheme is a motley collection of LISP-1's. And I mean that in the nicest possible way. It's just that there are seven different revisions to the scheme reports, and implementations of scheme will do things the way they want. Having said that, there are almost always shared features. In common lisp the empty list is false. All other values are true, with a sentinel value T for if you don't have a more meaningful value for true. Scheme has #f as the false atom. All other values - including the empty list - are true, with #t as the sentinel truthy value. Schemes are usually monomorphic. What this means is that each type has its own set of functions for working with objects of that type. In common lisp you can work with collections (lists, vectors, string, etc) using the same functions. length, nth, map, will Do The Right Thing. In scheme each collection type has its own set of functions. E.g., vectors have vector-length, vector-ref, and vector-map which only work on vectors. Schemes do not have a separate namespace for functions and objects. You can pass around functions as normal ojects without quoting or using the (function id) syntax and likewise can use any identifier as a function without the need for funcall. (Provided of course that the identifier does in fact identify a function). This allows a single syntax to introduce both variables and functions: define. If you look at scheme source and see a form like: (define (fname arg1 arg2 ...) ...) That is exactly the same as (define fname (lambda (arg1 arg2 ...) ...)) Schemes do not have complex set! expansions. In addition to each type having a -ref function, they also have a -set! function. There's really no reason scheme couldn't have complex set! expansions, but implementations just don't. The macro systems are different. Schemes tend to have hygienic macro systems as well as pattern matching macro system. If you are not familiar with the term "macro hygiene", think of it as lexical scoping for macro expansions. Identifiers introduced into the AST by the macro definition will not conflict with identifiers introduced outside the macro usage. For example, (define-syntax add-x (syntax-rules () ((_ expr) (let ((x 20)) (+ x expr))))) (let ((x 10)) (add-x x)) In scheme, that returns 30. The equivalent macro and usage in common lisp will return 40. (defmacro add-x (expr) `(let ((x 20)) (+ x ,expr))) (let ((x 10)) (add-x x)) Many schemes provide a way to break hygiene. r6rs conformant schemes have syntax-case, which is a more general version of syntax-rules that can introduce new identifiers into the AST at the expansion site. Schemes do not have complex lambda lists. Common lisp function definitions and lambda expressions allow specifying default parameters and specifying types of parameters. It's certainly possible to write a macro that would do that for you, but such a macro is not provided in any standard. Library definitions are different. Libraries were added to r6rs, and are mostly unchanged in r7rs. The only difference I can remember without looking anything up is that in r6rs libraries are introduced like so: (library (foo bar baz) ...) and in r7rs like this: (define-library (foo bar baz) ...). Scheme also allows for arbitrarily nested libraries whereas common lisp does not. This means you can have a library (foo), (foo bar), (foo bar baz) ad nausuem. I don't think this is a huge practical difference, but some people like to structure their code that way. continuations - schemes provide first class fully reusable continuations, and at least as far as my googling goes I can't seem to find anything that shows common lisp has continuations at all. There are also some style differences between schemes and common lisp. My favorite is the function suffixes in scheme. functions that mutate end in a '!' and predicates end in a '?'. * set! * set-car! * vector-set! * number? * symbol? * string? These aren't mandatory, but all scheme code I've read follows this style. Common lisp ends predicate names with P and mutators with F. * SETF * INCRF * NUMBERP * SYBMOLP * STRINGP Which leads to another stylistic difference, schemes are almost all case-sensitive with rnrs and the srfis specifying everything in lowercase, while common lisp is case-insensitive and seems to prefer displaying everything in upper case. I'll admit to not using common lisp all that much, so I hope I haven't made some glaring omission or egregious misrepresentation.
aah.
Learning Lisp is always a HARD way, baby! ;-)
There is a srfi that provides a generalized set! that mimics the CL one. Maybe 17? I don't remember. Scheme promotes a functional style, so set! is pretty rare. My scheme of choice provides a define-macro that works just like defmacro, and it is trivial to implement yourself using syntax-case. Sometimes it really is the clearest way (the nest macro from CL comes to mind). There are good reasons o avoid set! in scheme. Most implementations do a lot better job at optimizing your code if you avoid it, since it can safely assume things.
I tried but got, ``` $ setxkbmap -option parens: swap_brackets Error loading new keyboard description ```
Very nice, thanks. Would it be possible to have one with a transparent background? What kind of license does it have?
Let's hope they are going to have cheaper fees than this year.
d'Oh! Wasn't sure where to look for announcement(s)... nothing on Twitch... wondered where you'd gone :-/ Hope you feel way better RSN. Cheers! :-)
Not very complete but promising. It has a nice select box to search for a symbol from the specs and see it nicely formatted, with manually added examples not from the specs.
Public-domain dedication license, feel free. Transparency... let me see... this should do the trick: https://imgur.com/QHVDpkr.png I also re-rendered it slightly better, making the rounded edges smoother.
Moi aussi, FWIW :-) One of M$' better products.
FWIW, by usual conference standards, even this year was very cheap.
Sorry, there's a space where there shouldn't be, I fixed it in the description. `parens:` and `swap_brackets` should be written together, not separately.
AFAIK CL does have continuations. The weblocks framework is based on them, for example. a blog post in my history: https://8c6794b6.github.io/posts/Delimited-continuations-with-monadic-functions-in-Common-Lisp.html
What exactly does it change?
On a QWERTY layout you normally have to press shift and hunt for the right key on the number row to type parentheses, while brackets aren't that far away and can be typed unshifted. This options swaps them so that typing brackets becomes harder and parentheses easier.
CL does not have continuations built-in like Scheme (see CALL-WITH-CURRENT-CONTINUATION). Adding continuations by a library is only partly possible. Scheme has continuations, but that makes other problems.
Thank you, it works now. I have been chasing this option for so long! I saw it cited somewhere, but could not find how to enable it. Thanks.
Thank you for the transparency and the license.
 I know, for its content it is was a bargain. But for people struggling to make ends meet [not necessarily students], it was not in easy reach. I wish there would be a "pay as you can" option. I know, wishful thinking.
another solution in my .Xmodmap: !caps lock becomes control remove Lock = Caps_Lock keysym Caps_Lock = Control_L add Control = Control_L !! swap () and [] keycode 18 = 9 bracketleft keycode 19 = 0 bracketright keycode 34 = parenleft braceleft keycode 35 = parenright braceright 
Looking forward to your next one. Get well soon!
This is another way, but I prefer the XKB version for a few reasons: - Setting it is idempotent - It can be used from your Xorg config - It works with Wayland by customizing the `XKB_DEFAULT_OPTIONS` environment variable
Obviously your solution is better because it is high level where as mine is low level. I only said "another" solution for a reason. I have used this solution unchanged for over 10 years. If I lost my .Xmodmap file, I would have trouble recreating it. Your solution I could probably remember. Now, if there was just a built-in option to make the caps lock into a control key. For some reason, I could not train my pinkie to use only the caps lock key as the control key so swapping did not work well.
FYI. this is based on the old Association of Lisp Users logo: https://web.archive.org/web/20020112032027/http://www.lisp.org:80/table/about.htm#navigate
There is such an option, too and unlike the presented one, `caps:ctrl_modifier` is documented in the human-readable `/usr/share/X11/xkb/rules/base.lst` file. You can enable both by using `setxkbmap -option parens:swap_brackets -option caps:ctrl_modifier`, in a Xorg config with `Option "XkbOptions" "compose:102,parens:swap_brackets"` and in Wayland with `export XKB_DEFAULT_OPTIONS=compose:102,parens:swap_brackets`.
You know you can make caps lock an extra control using setxkbmap as well? That way you can rely on setxkbmap and get all the nice things that brings.
I just put left paren on a thumb key. Right now I have it and alt on the same key. I prefer not to use the bracket positions at all.
The placement of ( ) in the numeric top row seems to have a long history. Check out this Underwood: https://i.ytimg.com/vi/VgRppno8hN8/maxresdefault.jpg 
I have this only in emacs (with the benefit of working in windows as well) with: (keyboard-translate ?\( ?\[) (keyboard-translate ?\[ ?\() (keyboard-translate ?\) ?\]) (keyboard-translate ?\] ?\)) 
Sure thing, have fun with it.
KDE: System Settings:Input Devices:Keyboard:Advanced:Parentheses position:Swap with square brackets
Darn, any way to do this with dvorak?
X-Post referenced from [/r/programming](http://np.reddit.com/r/programming) by /u/yogthos [What did Alan Kay mean by, "Lisp is the greatest single programming language ever designed"?](http://np.reddit.com/r/programming/comments/78v9m2/what_did_alan_kay_mean_by_lisp_is_the_greatest/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
"A fun thing about it this is that once you’ve grokked it, you can think right away of better programming languages than Lisp". All true. Except that I still can't and don't see anything even remotely close to CL)
What did he mean? * that he thinks Lisp is a word which denotes a single programming language. * that Smalltalk isn't the greatest language ever designed. Or that Smalltalk is two or more languages and so not the greatest *single* language.
One interpretation is that Lisp encourages the use of domain specific languages. Since one can freely extend and modify the language in a way that you can't in most others, you'll extend and modify it to create a language that makes solving your problem easier. In essence, you program in Lisp by writing making a better language.
also would you guys recommend learning scheme before Common Lisp? I was thinking of going through the sicp book is it worthwhile for a beginner 
i know of [quil](http://quil.info) in clojure and [fluxus](http://www.pawfal.org/fluxus/). i don't think the latter has been maintained at all though. https://github.com/quil/quil https://github.com/zzkt/fluxus but searching for these links i also just found praxis. https://github.com/createuniverses/praxis
&gt;In essence, you program in Lisp by writing making a ~~better~~ *more specific* language. This is how I understood it. Dan Ingalls implemented Kay's Smalltalk-72 in Lisp I think.
Not sure why you're downvoted, you are adding to the conversation after all.
This submission could be attracting Smalltalk fans, and that's what you get for basically flaming Alan Kay. Oh well, what he said deserves it. Lisp simply isn't one "single" programming language that is fixed in stone (hasn't been for over fifty years!) that cannot get better but only inspire better languages. Sorry, I don't worship your hero. Can that guy even code any more, you know? In this game, you're only as good as your last commit. 
The problem is that you don't want to understand what Alan is actually saying. Alan talks about the Lisp McCarthy invented, not about Interlisp or BBN Lisp. It's about stuff that was early described like the meta-circular interpreter and having the core ideas of Lisp semantics described in a small function. Kay talks about the ideas of the early Lisp and what kind of thinking and further progress it enabled. 
&gt; *Alan talks about the Lisp McCarthy invented* That is obsolete as a definition of "Lisp" for a comment made today. If he's talking about the Lisp McCarthy invented he should word it as "Lisp 1.0 is the greatest programming language ever designed". &gt; *It especially helped Kay to shape Smalltalk and the ideas behind it.* That is good and well, but it also shaped better descendants that are still Lisps. That is not less significant than helping to shape non-Lisps.
He is talking about McCarthy's Lisp and the abstract formulation of the meta-circular interpreter. Not especially about Lisp 1. McCarthy wrote about that stuff in the context of Lisp 1, but also in more general terms. &gt; but it also shaped better descendants that are still Lisps. That is not less significant than helping to shape non-Lisps. That's not important for me. McCarthy paved also the way for functional programming languages, other languages with simple evaluation systems, etc. What's important was the thinking behind McCarthy's Lisp.
Lisp may not be one language, but it is very much one concept.
"Lisp" is a kind of a cloud without a very clearly defined edge which contains a bunch of design patterns for making languages and environments. Lisp languages and environments, if it is understood and applied properly, but bits and pieces of it can be pulled elsewhere.
Ah, if only you had. That you seem to think you did, when you quite blatantly didn't bother, is probably why people are dinging your down arrow.
[Hy](https://github.com/hylang/hy) seems pretty cool although it's given up on a lot of features (like... `let`)
Hy makes many of the classic "Lisp on X" mistakes. They are easy to make, and I've made them before too. I'm not the world's biggest Clojure fan, but it demolishes all other "Lisp on X" implementations, largely by Rich having solid knowledge of why CL does particular things. Not counting new features, his departures from CL fall into two categories: 1) Places where he thinks CL is wrong (the most obvious is using lists for function calls and vectors for all other groupings, but there are plenty others) 2) Places where Java interop and JVM limitations suggest departing from CL In the case of #2, he *always* has a clear enough understanding of CLs reasoning to create a feature that fits the same goals. One good example of both of these is how namespaces and gensyms work in Clojure. Many people don't understand how an interning reader and packages interact with macros to allow creating hygienic macros in common lisp. Symbols can't easily work in Clojure like they do in lisp without making java interop more difficult, and Rich is not alone in finding the interning reader of CL a source of problems. The solution of namespaces and causing backquote to expand the hash suffix addresses the overwhelming majority of usecases for package-interned symbols in CL while fitting in better with Java's pre-existing namespace system *and* eliminating the package-aware reader. Just slapping s-expressions on top of an existing language gives you something that is fun to play around in, but has fragile metaprogramming (and really the primary reason for using s-expressions is the ease of metaprogramming with them).
Michael Fogus talked about some here: https://leanpub.com/readevalprintlove001/read
I've been having fun with [uLisp](http://www.ulisp.com/) on my Arduinos.
[Urn](https://squiddev.github.io/urn/) is a lisp that compiles to Lua. There's a lot of influence from Clojure, Scheme, and CL in it; naming tends to be more like C (e.g. `defun`), but it's a lisp-1 due to Lua, has Cloure-like reader literals for Lua tables (`{foo bar}`), and some other random things from each. It's not the only Lisp-to-Lua implementation, but it's worth mentioning because not only is it still being worked on, it works with 5.1, 5.2, and 5.3, and it's the only one I know of that can compile to Lua source that has no need for outside dependencies or separate interpreter. Its compilation phase embeds all its stdlib functions into the generated Lua, aggressively removing unused functions, which means it can be used in places other Lisp-to-Lua options aren't possible, such as Lua interpreters embedded in software and games. This is something that I wish Hy did as well; it would make it much more attractive, but it requires you have the Hy stdlib installed where you run it. :/
NewLisp is quite old (created in 1991 IIRC) but it is still relatively unknown: http://www.newlisp.org/index.cgi?page=Differences_to_Other_LISPs
&gt; *He is talking about McCarthy's Lisp and the abstract formulation of the meta-circular interpreter.* Okay; so that is what is identified as the "greatest single programming language", not something that actually runs somewhere. Since anything that you make with those ideas *does* hopefully run somewhere, of course it's a better language. It all clicks now. 
Julia is a matlab like syntax on top of a lisp. Its powerful type system combines with jit compilation in a way that makes it as fast as C for CPU bound taks and it has a growing, competent, surprisingly mature package ecosystem that’s easy to develop for and contribute to. It has full on lisp style macros allowing for really powerful meta programming. It’s a really exciting avenue of language development and whether or not one wants to call it a lisp, it’s worth checking out. 
But that's nothing unusual. An algorithm is not something which runs. The meta-circular evaluator is an algorithm. Mark&amp;Sweep GC is an algorithm. The idea of doing automatic memory management with mark&amp;sweep GC was revolutionary. The implementation was a first. Thus McCarthy's Lisp was revolutionary in many ways - on a conceptual level and it was the first implementation of many of these ideas.
Shen is the most interesting recent Lisp I've heard of: http://shenlanguage.org/
Depends on what you mean by new and interesting, but Clojure, clojurescript, racket (extended scheme dialect), lisp flavored Erlang maybe.
Whilst it doesn’t call itself a lisp, [scopes](http://scopes.readthedocs.io/en/latest/about.html) is a slowly developing languages which I think some lisp programmers might be interested in. It's an non-garbage-collected language, intended as an alternative to c++ for games and realtime applications. It has a llvm and SPIR-V backend (so runs on cpu and gpu) is strongly, statically typed and has good type inference. It allows for paren based (braced) or indentation based (naked) scoping. I wouldnt expect this to be 'done' any time soon, but may be worth keeping an eye on
An interesting one which is often mentioned in posts (I think that by the developer) IS [TXR] (http://www.nongnu.org/txr/). 
[Pixie](http://pixielang.org/) was under development until recently (less than a year I think) so it might fit your criteria.
But fundementally, everything is either constructed from s-expressions or it isn't. Are there any languages that are kind of a binary tree of lists recursively cons'd together but not quite?
Clasp
Nice simple tutorial. I tried it. It works okay without any issues. This example is simple but it does demonstrate a powerful feature of CL especially for long running applications. 
Use `throw` and `catch`, they are the dynamic equivalent of `return/block`.
Ah!!! Thank you. It does make sense. Not even with (compile) I was able to do this.
In my last job we used LispWorks but could not run swank in production, because a "delivered application" in LispWorks has had some capabilities removed including COMPILE-FILE, which swank depends on. I did plan on working around that but never got around to it. We had console access to the REPL via a screen session to inspect and change the system and we distributed custom patches in compiled form that the system could load at startup or on demand.
Lux. Statically typed Lisp, with Clojure'y approach to syntax, and monadic macros https://github.com/LuxLang/lux I believe in it.
By the way, though "shen" ([https://en.wiktionary.org/wiki/神](神)) does mean "spirit", it also means "god" or "gods", and there is a religious overtone to the "spirit" meaning: it's closer to, say, "holy spirit" than "put more spirit into it". That one is perhaps better represented by qi ([https://en.wiktionary.org/wiki/氣](氣)).
Your comment seems to be (entirely?) about Clojure, in reply to a comment about Hy, which is a Lisp-in-Python thing. 
&gt; *Symbols can't easily work in Clojure like they do in lisp without making java interop more difficult*. Not buyin' it. 
Your first if statement requires six items, one of them being that rnew is a list. You are requiring that rnew be a list, and you are not passing it in as a list. It is easier to see if you set the indentation.
`eq` doesn't compare lists for equivalence; `eq` tests whether or not its two argument values are both the implementation of the same object. Objects which are implemented as value references to some item of information (a piece of memory in a heap such as a cons cell, or an offset indicating an entry in a global table of some sort) are only `eq` if they are both references to that same item. Two occurrences of the list value `(-4 -1)` in a program are not necessary references to the same list object; there can exist separately instantiated lists `(-4 -1)` which are not `eq` (but are `equal`). 
There are also 1.[Toccata](toccata.io) - Clojure-inspired, with reference counting, compiles to C 2. [Carp](https://github.com/carp-lang/Carp) - syntax inspired by Clojure, semantics more ML-like. No garbage collection.
Also pico lisp form the same era, "similar" in that they use none conventional evaluation ideas. https://picolisp.com
&gt; *full on lisp style macros* As someone who cherishes the semantics of North American English vernacular such as "full on", I cannot but beg to differ. From the Julia documentation on metaprogramming, it's apparent that: * it has global macros only, no lexical macros. * macros are in their own namespace, demarcated by the `@` sigil. (Which is annoying: every invocation of macros noisly draws "I'm a second-class macro call thing" attention to itself). * for the above reasons, macro expanders don't take an environment parameter (why bother, since macros cannot be lexically shadowed by functions or other macros); expansion is oblivious to scope. * no documented evidence of symbol macros. * no documentation hinting at the existence of destructuring lambda lists or equivalent. 
Fair points! I’ve struck out ‘full on’. Admittedly, I have only a beginners understanding of macros and in my ignorance, most of those don’t seem like a big deal to me though I can see how the lack of lexical scoping is a non-trivial limitation. 
Agreed. Chicken has a great selection of libraries, a user community most other lispy languages would kill for.
Certainly. Using lexical macros and symbol macros, with proper treatment of environments, I've been able to implement things like: http://www.kylheku.com/cgit/txr/tree/share/txr/stdlib/place.tl (Complete implementation of syntactic places (i.e. assignable forms)). http://www.kylheku.com/cgit/txr/tree/share/txr/stdlib/awk.tl (Awk language in Lisp). http://www.kylheku.com/cgit/txr/tree/share/txr/stdlib/op.tl (Anonymous function syntactic sugar providing currying/partial application. http://www.kylheku.com/cgit/txr/tree/share/txr/stdlib/tagbody.tl (Macro implementation of `tagbody` with correct nesting of labels when `tagbody` forms are nested. This uses a lexical macro for `go`, with a same-named global macro `go` for error-handling fallback. `go` forms which reference a nonexistent label are assumed to belong to an outer block; the lexical macros expand them into a representation which "smuggles them out" and they percolate to the outer level through multiple rounds of expansion, where the global `go` macro errors them out. 
So I've made a thread [here](https://www.reddit.com/r/Julia/comments/79vwpf/could_i_get_some_opinions_on_another_users/) trying to get some insight from Julia users about your comments because I don't really know enough to be able to intelligently reply here so maybe we'll get some more info soon. In the mean time, correct me if I'm wrong but is that big of a limitation to not have lexical macros? The macro is defined in the global scope but if you call it inside a smaller scope it should still act inside that scope. I guess this way one can't define macros or functions that define macros? I suppose though that one really wanted, they could always just define a macro in the global scope that takes a code block and *allows* them to lexically define a macro. &gt;macros are in their own namespace, demarcated by the @ sigil. (Which is annoying: every invocation of macros noisly draws "I'm a second-class macro call thing" attention to itself) As a novice I think I greatly appreciate the `@` sigil when reading other's code because when I see it I know immediately that the code I'm looking at actually gets parsed differently than I might expect and that I definitely need to pay special attention here to understand what's going on. &gt;no documented evidence of symbol macros. For an infix language like Julia, is there an appreciable difference between a macro which takes no arguments and a symbol macro? Couldn't I just get all the same functionality (enough though I have to write 3 extra characters) by writing `@foo()` ?
I'll ad this app, in Racket: https://github.com/alex-hhh/ActivityLog2
Drink some tea with honey! By the by: when are you finally going to stop by the Treehouse?
Thanks :) and yeah I should have tuned in Sunday. I'll try catch up and join for the next one.
Or, you can hire some guy to COMMENT on your coding session, like in a live TV chess game :)) " ... and now, he's fixing the bug? yes, he seems to be fixing the bug! he's fixing the bug! finally! yes!" Get well! :) (i recommend cognac, and mint tea with honey, separately, for double heating effect)
With symbol macros, we can write code which finds certain variable references in code and then rewrites them to something else. E.g., TXR Lisp: 1&gt; (load "with-instance") nil 2&gt; (let ((x "foo") (date (time-struct-local (time)))) (with-instance date (list x year month))) ("foo" 2017 10) This `with-instance` macro finds unbound variables inside the right argument form, and treats them as slots of the left argument object: (defmacro with-instance (:env macenv inst expr) (tree-bind (expan free-vars free-funs bound-vars bound-funs) (sys:expand-with-free-refs expr macenv) ^(symacrolet ,(mapcar (ret ^(,@1 (qref ,inst ,@1))) free-vars) ,expan))) `with-instance` takes `expr` and expands it in the correct lexical environment, using a function which returns useful additional information about the free function and variable references which occur in it. Then it **generates** custom symbol macros which target the free variables in the form, which are assumed to be slots of the object. Note that the macro is smart enough to know that `x` has a binding in scope, and so isn't treated as `date.x`. The expansion is: 3&gt; (sys:expand '(let ((x "foo") (date (time-struct-local (time)))) (with-instance date (list x year month)))) (let ((x "foo") (date (time-struct-local (time)))) (list x (slot date 'year) (slot date 'month))) `year` and `month` are rewritten, `x` isn't. We can put a `trace` on the macro to see what it put out: 4&gt; (trace (macro with-instance)) nil 5&gt; (sys:expand '(let ((x "foo") (date (time-struct-local (time)))) (with-instance date (list x year month)))) ((macro with-instance) ((with-instance date (list x year month)) #&lt;environment: b710054c&gt;) (symacrolet ((month date.month) (year date.year)) (list x year month))) (let ((x "foo") (date (time-struct-local (time)))) (list x (slot date 'year) (slot date 'month))) In the trace we can see the `symacrolet` form that the macro returned: (symacrolet ((month date.month) (year date.year)) (list x year month)) Symbol macros are the mechanism for renaming the selected set of variable references to other forms. 
dougk (Douglas Katzman) has made incredible improvements to the compiler/GC/etc... over the last couple of years. He, stassats, and scymtym have been doing the heavy lifting of late. And the recent changes have been quite impressive. Check out the highlights here: https://github.com/sbcl/sbcl/blob/master/NEWS
Thats a very neat macro! Once I stared at it long enough I think I now have a bit of an appreciation for the points you've made. I'm very interested to try and find out how difficult this behaviour is to duplicate in Julia.
He's totally right. If only Clojure would run outside the JVM!!!
It's difficult to duplicate in Common Lisp, because of the dependency on that `sys:expand-with-free-refs` which provides information about variables occurring in the form. Without a way to get at this information, we need to write a code walker. That function (invention of mine) actually takes two environments, the second of which is expected to be "outer" with respect to the other. It distinguishes totally free variables from variables which are "partially free" either fully free, or free with regard to the expanded from but having a binding within the outer environment: (defmacro free-refs-report (:env ei expr eo) (tree-bind (expr-x ffv fff lfv lff) (sys:expand-with-free-refs expr ei eo) ^'(:fully-free ,ffv :locally-free ,lfv))) (defmacro fr (:env eo expro) ^(macrolet ((free-refs (:env ei expri) ^(free-refs-report ,expri ,',eo))) ,expro)) 1&gt; (let (x) (fr (let (y) (free-refs (let (w) (list x y z w)))))) (:fully-free (z) :locally-free (z y)) `z` is completely free, and for that reason it is also "locally free". `y` is only "locally free": it's free with respect to the `(let (w) (list ...))` form, but has a binding underneath the `eo` environment": the environment in which the `fr` call finds itself. `x` is not free at all because it has a lexical binding external to `eo`, and `w` is not free because it's bound within the form being interrogated. The "locally free" concept is very useful in some macros, for the following reason: if we take the set difference between the "locally free" and the "free", we isolate `y`. That gives us the set of bindings which **are** established within the `fr` contour, but are free inside the `free-refs` argument form. A macro, together with its local macro helpers, can identify these "in between" bindings and do useful things with them, while staying away from unknown variables: those that are totally free, or have lexical bindings outside of the entire macro. The TXR Lisp `awk` macro uses this to implement the following diagnostic: 2&gt; (awk ((let ((from #/from/)) (rng from #/to/)))) ** warning: (expr-2:1) rng: form from is moved out of the apparent scope and thus cannot refer to variables (from) ** warning: (expr-2:1) unbound variable from Although the Awk range expression `rng` occurs physically inside the `let`, ranges are subject to a code transformation which relocates their evaluation elsewhere. When `awk` reads a record and splits it into fields, the range expressions are evaluated then in their own pass. They don't have the surrounding code in scope. The `awk` macro is thus able to detect when `rng` expressions are making false "trompe d'oeil" references to an apparent lexical scope that isn't real. If the binding is moved outward, out of the condition-action clause into a global `:let` clause, then it's okay: 3&gt; (awk (:let (from #/from/)) ((rng from #/to/))) Why that is not diagnosed is because the binding has moved from "locally free" to "fully free" with respect to the appropriate pair of environments that are considered. The Series package for Common Lisp implements this type of diagnostic. There are situations in which sub-forms in a `series` are evaluated in a lexical scope that isn't their apparent one. Series catches this with the help of the code walker implementation that is bundled with it. 
Yes, but we need to hire a spanish sports commentator for this.
Hope you feel better 🤗
Well, there's ClojureScript and ClojureCLR, although I've never seen any discussion on the latter. Though I get what you mean, I'd love to see a Clojure native, or at least a more complete standard lib.
in julia if there is lexical macro then it's impossible to statically analyse the code and generate fast code. hence why maceo are only allowed at global. 
Interesting talk and interesting points about Common Lisp meaning if he were able to put his common lisp projects on production, there was a chance that clojure wouldn't be developed at all, since from the talk I understood that he really liked common lisp as a language. Another interesting points are about the fact that he thought about making clojure as a common lisp library but decided not to do it partly because of the previous point (not being able to push cl code to production), partly because he wanted to have a language with certain features (e.g. immutable structures with very good support from standard library, good interoperation and library support etc). 
Rich Hickey came from the Java side. He tried to interface Common Lisp to Java, which worked somewhat. But in the end this was not satisfactory, since to interface with the JVM the best way is to have a language running on the JVM. IIRC around that time ABCL was tied to an editor, not really a full CL and integration was not optimal. Also CLOS is an object-system on top of the JVM's idea of objects -&gt; it does not map directly to JVM objects, though it can integrate them somewhat. When he used Lisp he was mainly a LispWorks user for some time. Which he probably liked, but LispWorks is commercial. So for deployment you need an actual developer license (-&gt; $, €, ...) for that OS/architecture to create applications. He could try to deploy using 'free/open source' Lisps, but the typical operations group does not have an idea how to install/maintain/monitor it. Often there are policies to use only certain tool chains (like JVM platform, specific Java versions, ...). Rich Hickey's Common Lisp contributions: http://jfli.sourceforge.net , Java Foreign Language Interface for Common Lisp, originally using LispWorks http://foil.sourceforge.net , Foreign Object Interface for Lisp, portable, interact with foreign VMs, supports .net and JVM http://lisplets.sourceforge.net (example for LispWorks, the code is just Java) There was an early sketch of Clojure in Common Lisp, which was in the Clojure repository some time ago... this was not far developed. 
:'( I'd'a settled for Rod-Stewart-impression-Chris! :-)
WAT - no CEPL txt-to-Hawking-synth? :-/
Macro calls are completely gone after expansion, so any analysis on expanded code doesn't care about what kind of scoping the macros used. Analysis done before expansion just has to follow the scope properly. Lexical scope **is static** and is in fact sometimes called "static scope". Lexical scoping (of anything) doesn't make static analysis impossible almost by definition. For instance, selective expansion of different macro alternatives based on static information can work with lexically scoped macros.
It seems that, given JVM enhancements that are being worked on right now (project Graal), soon OpenJDK will properly support AOT, hence proper native executables. Along with other proposals (like continuations in scope of project Loom), this means that Clojure running on JVM will be able to cover many native code scenarios.
If you read the talk, he mostly came from C++ actually, and didn't seem to work in Java until much later in his career. The Clojure source is also far from idiomatic java. I agree with the rest of what you've said though.
My friends used to say I should **drink a lot of whiskey** --- no I don't recommend it.
What I wanted to say: he came from the Java side and tried to connect his Lisp explorations to it. Rich Hickey started exploring Lisp at the same time when he started commercial work with Java/C#. He didn't try to combine C++ and Lisp, since his commercial work was moved to JVM / .net/CLR/C#. Hickey in 2010: &gt; I worked in scheduling systems and broadcast automation all in C++. Then I moved from that to Java and C#. At the same time, I also started doing some Common Lisp
And again, in the OP link he describes how he had to port his CL program to C++ so it could run on production.
Take care mate ! The gang is still there :)
Again, he did not try to connect C++ to Lisp (like for example Christian Schafmeister does with CLASP). He used the JVM/CLR and tried to use that together with Lisp and then developed a new language on top of JVM/CLR. it was not about him being a C++ programmer originally. Hickey in 2010: &gt; One watershed moment for me was when I designed and implemented a new system from scratch in Common Lisp, which was a new language for me at the time, only to have the client require it be rewritten in C++, with which I was quite proficient. The port to C++ took three times as long as the original work, was much more code, and wasn’t significantly faster. I knew then that I wanted to work in a Lisp, but realized that it had to be client-compatible. I worked on bridging Common Lisp and Java, while doing functional-style programming for clients in C#, for a couple of years, then bit the bullet and wrote Clojure.
Given the amount of efforts spent, it's really unfortunate that he did not succeed.
Thanks for all the replies. It's been very informative. I've [made a post](https://discourse.julialang.org/t/lexically-scoped-macros/6835) on the Julia discourse asking why we don't have lexical macros. If there isn't a good reason to not include them, I'm going to try and lobby for their inclusion as well as environment variables being passed to the macro expander. I'll let you know if that ever goes anywhere.
Hi! Have you managed to make any progress with you projects? I found data manipulation and visualization part really lacking in common lisp world as well, so I'm curious about your work.
The author misses the point. The `EDN` type defined makes it essentially untyped, at least in static sense - and that what Clojure is. And yes, it is easy to move from strictly typed into untyped direction, well sort of. The first problem is that the author uses EDN which is completely fixed. More general Clojure data is extendable. If I define a new type/record which is not in your union-type, than what? Also, it is easy to program in Haskell existing spec, but try to program one while it is still evolving and not fully defined. The whole point of Clojure, for me personally, is that you can express and do what you want without type-wankery. It might not be 100% mathematically correct as it might break on some kind of inputs. Just spec the user input and check the correctness with tests elsewhere - in the end this will be faster than extending and changing the monstous ADT every time you realise some piece of information is missing. 
thank you so much for all contributors of McCLIM, thank you.
Ah, apache zookeeper, not [this one](https://en.wikipedia.org/wiki/Zoo_Keeper) ...
**Zoo Keeper** Zoo Keeper is a tile-matching puzzle video game developed for the Web by Robot Communications and later ported to the Nintendo DS by Japanese video game publisher Success. The game was then brought to American and European shores by Ignition Entertainment, and has since been released for iOS and Android devices under the title Zookeeper DX Touch Edition by Kiteretsu. In Japan, before the release for Nintendo DS, Success released this game for Game Boy Advance and PlayStation 2 with alternative name Zooo. The PlayStation 2 version of this game was later released in Europe by 505 Game Street under the title Zoo Puzzle. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Regarding your "whole point of Clojure" remark, do you find CL to differ from Clojure in this regard?
links: - https://zookeeper.apache.org/ - https://en.wikipedia.org/wiki/Apache_ZooKeeper - https://duckduckgo.com/?q=apache+zookeeper&amp;ia=web &gt; Apache ZooKeeper is a software project of the Apache Software Foundation. It is essentially a distributed hierarchical key-value store, which is used to provide a distributed configuration service, synchronization service, and naming registry for large distributed systems.[2] ZooKeeper was a sub-project of Hadoop but is now a top-level project in its own right. - https://github.com/AeroNotix/cl-zk
Interesting question actually. Building abstraction in CL and Clojure is quite similar (compared to Haskell). However, CL, being multi-paradigm, leans strongly towards OOP which requires a bit of boiler-plate. Possible advantage - ability to change already working system (sort of a "brain surgery"). But I do find myself prototyping much faster in Clojure even though I miss certain features of CL (especially the debugger and restarts). Also, in Clojure the move from prototype to a solid program is easier.
Well, sort of. The R like lispydata stuff is still pre pre alpha but gradually becoming usable. Once it gets to an acceptable stage I will announce it, but that’s a while away. My commercial project is taking most time, mainly because of fricking JavaScript. Which I am now trying to remove as much as possible from the project, mainly for performance reasons on mobile. The lisp side is a delight to program in, though I am clearly biased there. Visualization of data in CL is pretty much roll your own. To date I use a gnuplot interface vgplot, which works acceptably. Looking at Vega lite it seems to be a reasonable choice if one accepts a browser based interface and probably not too much work to get going. That will be the next cab off the rank as an experiment
I second the recommendation of first learning to reproduce without peeking some of the simpler macros of "On Lisp", because until you internalize how macros help the programmer you will not recognize opportunities to leverage them when they come up. Then do not worry about it, Just Write Lisp and let the boilerplate code ask you to write a macro. 
We also have been having similar issues.Becasue of that, we decided to switch all our codebase to SBCL. We do miss LispWorks' Treehsaker a lot, though. I hope it will be part of a Kickstarter campaign for SBCL. 
There are only a couple of things I would change 1. Have a variable to stop the loop. This is really useful in case you want to really stop everything. 2. Have loop only call dostuff and put the sleep in it. That way you can change the sleep timer if needed. 3. Don't call swank in runner. That way if you stop it, you can start it again by calling runner.
It has a C API you can FFI your way into
Confirmed that it works (tried it a month ago or so). Great work there. Ministro kept failing in the middle of the installation for no apparent reason, and resuming the installation was not easy (delete + reinstall). In the end it worked, and the live experience was really nice (at least from the toying point of view). Do you have any ideas on how to interact with the device sensors/apis? 
Thanks for your feedback! The sensors should all be accessible from QML, see [Qt docu](http://doc.qt.io/qt-5/qtsensors-qmlmodule.html). In QML you can then call Lisp functions from any handler, e.g. `onXChanged`, using either `Lisp.call()` or `Lisp.apply()`.
this is great to see, thanks!!
great app, thanks lot. added to [awesome-cl-software](https://github.com/azzamsa/awesome-cl-software)
I wrote a random tester for Common Lisp compilers some years ago, as part of the GCL ansi-test suite. It's found bugs in all the Common Lisp implementations it's been used on. It's a bit different from your generator in that it generates valid lisp functions (mostly involving integer-valued operations), and either looks for errors thrown by the compiler/evaluator (which should not happen) or differences in behavior when the code is evaluated in different ways (different optimization settings, eval vs. funcall of (compile nil '(lambda ...)), presence of notinline and type declarations.) This approach, called differential testing, was pioneered by McKeeman on C compilers back in the 1990s and has since been used on many other languages. Of particular note is the work by [John Regehr](https://blog.regehr.org/) and colleagues. They have made notable advances in generating random C programs that don't violate the large number of semantic constraints C programs have to satisfy, and in simplifying failing test cases while still satisfying the constraints. If you want to try the Common Lisp random tester it (and ansi-test) is available via git clone https://gitlab.common-lisp.net/ansi-test/ansi-test.git Note that someone has added some logical pathname stuff that makes random/random-int-form.lsp not compile/load correctly; the file needs to be modified slightly to also use that. I'll check in some fixes to that when I get around to it.
I am cylcing back to trying to build on top of wiredtiger (mongodb database engine). I am considering adding versioned grapphdb to my zoo. So I am asking around the web whether this would be useful somehow before writing yet-another-useless-scheme-code :)
After finishing the several tools (dynotune and dirtylogman as I posted earlier) now I am implementing a STRIPS planner for entering the International Planning Competition 2018 with some novel idea to conclude my PhD research. It won't enter the thesis though, not in time...
[removed]
I've been working on rewriting large parts of my sound mixing and server stack ([libmixed](https://github.com/Shirakumo/libmixed) [cl-mixed](https://github.com/Shirakumo/cl-mixed) [harmony](https://github.com/Shirakumo/harmony)). I'd like to add native audio backends for all operating systems, but so far I've only done ALSA and Pulse Audio for Linux, as they are very easy to interact with. WASAPI for Windows and Core Audio for Mac on the other hand are really daunting and I'm not sure when or if at all I'll ever complete them.
Thanks, will check this out.
Planning and Scheduling is the oldest and still core part of AI. There seems many SIFT people who are lispers, I wanted to do intern but most positions required a US citizenship (obviously due to military contracts...)
I'm working on a library for the Discord API. So far working with the API has been quite pleasant. 
Fixed the bitrot in my [twitter bot repo](https://github.com/sjl/magitek) so I can make some stupid Twitter bots for [procjam](http://www.procjam.com/) this week.
Nice. I'd be interested in that for my [Maiden](https://shirakumo.github.io/maiden) chat bot framework.
I've been looking more and more into the cl-parametric-types library. Specifically adding support for cl-algebraic-datatype but I've struck some other issues in the library that I'm working to fix. This will go very slowly however since I'm studying and have a part-time job.
I'll probably put it up on GitHub next week. You might wanna check out 'lispcord' as it's already been published, though I don't know how complete it is. 
Woa cool. What do you use your sound mixing library with?
Currently nothing, but it's intended for use in game engines, where the alternatives are often either too simplistic, or huge commercial C or C++ libraries.
I also just set up a bunch of repositories that should be useful for research. + https://github.com/guicho271828/trivial-package-manager + https://github.com/guicho271828/cl-minizinc + https://github.com/guicho271828/cl-smt + https://github.com/guicho271828/cl-prolog + https://github.com/guicho271828/cl-milp This is a manifestation of the idea summarized here: https://github.com/guicho271828/common-lisp-project-ideas/issues/5
* Working on a [matrix](https://matrix.org) client library and server implementation. * Cleaning up my CouchDB Mango client library so that I can request that its addition to quicklisp without feeling too much shame. * Going to try to finish the last bits of my rewrite of the C side of roswell in CL.
Lispcord is far from ready for primetime yet. It connects to the gateway and dispatches events, that's about it, the user-facing bits are not even really started with xD
Just started [youtube-decompile](https://github.com/burhanloey/youtube-decompile). I plan to add a loop mode in the future.
I almost finished revamping inelegant and hacky resource management system of [`cl-bodge`](https://github.com/borodust/cl-bodge) into awesome and streamlined 2-layered one. This is a precursor to [`trivial-gamekit`](https://github.com/borodust/trivial-gamekit) distribution facitilites where one would be able to make distributable binaries (Windows/Linux/macOS) with one command similar to [`NOTALONE`](https://borodust.itch.io/notalone#download) binary package. 
I almost rewrote part of Weblocks which renders widgets. Throwing away cl-who and replacing it with more modern and flexible spinneret. Based on this work, I'm started a small side-project — a machine learning powered fairy tales feed. It will track how do you read a fairy tale and automatically suggest you a next tale. In a trendy "infinite scroll" way. 
You can view this scheme-lib may help you. https://github.com/evilbinary/scheme-lib
Thanks. BTW, the license is MIT (forgot to add the file, will do).
spinnernet looks interesting, thanks for the pointer!
I've been working on a small project around sound analysis. Nothing exciting, however I've managed to make a prototype of a pipeline to filter and analyze the sound. My hopes are to prettify the project and to apply it to some real world use case.
This is the resulting quickstart tutorial: https://github.com/40ants/weblocks/blob/reblocks/docs/source/quickstart.rst
It is more flexible, but slower than CL-who from two to three times. 
Actually, I need to update the tutorial now. Thanks for reminder. 
I'm working on a simple plant visualization application at https://bitbucket.org/ajk/plant-control in an effort to learn Common Lisp and Dynamic Windows. Pretty basic right now but I have some improvements planned this month.
I love this game, even the ios version.
Finally making progress in getting multiple GL context support into CEPL
btw, will you post here when you consider your rewrite done or quite stable or at least usable by others ? (if it is not already the case ?) 
Sure. It is progresses very slow. I'm improving parts which I need right now. For example now I'm adding an ability to insert widget after another as a result of AJAX action. I need this because it takes huge amount of time to re render whole feed with infinite scroll in my pet project.
Have made some progress on my csharp-parser/code-writer thing project. Managed to parse a basic function definition (in addition to a basic class with class variables), and made a ton of refactors to clear up the main parser file, so one can actually follow the parsing logic.
Sounds awesome! 😁
I've been meaning to do that all week. Thanks so much.
Made a simple Lisp implementation into C a Multiboot kernel with video and keyboard IO. I haven't released sources for it just yet cause it's hardly safe for Ring 0 work and the REPL is terrible.
&gt;The Clojure source is also far from idiomatic java. Thank god for that. If it were, the first version would probably still be in development.
I think you might be confusing lexical macros and fexprs.
That really doesn't sound anything like Lisp. What's the tie-in to Lisp? Lisps aren't statically typed, and they are garbage-collected. How does it avoid GC?
GC is one solution to an issue. Defining lisp as 'its GCd' is just as useful as looking at early lisps and say that 'lisps are interpreted'. That's how the solve an issue, not what they are. Here is another lisp without GC https://github.com/wolfgangj/bone-lisp. If you are interested in how scopes does things, read it's docs, it's not my language. CL has a facility for declaring types, so it is hardly against the concept of statically typing things, and it wouldnt be the first statically typed lisp. However, like I said originally scopes `doesn’t call itself a lisp` but it is a language that *some* `lisp programmers might be interested in` 
Wouldn't be better just to define a CL wrapper around Roslyn?
nice
As an example of an earlier foray into typed lisps [A Practical Formal Semantic Definition and Verification System for Typed LISP (1979)](http://oai.dtic.mil/oai/oai?verb=getRecord&amp;metadataPrefix=html&amp;identifier=ADA045722)
Maybe, but i am not sure it supports my use case. Basically to parse a c# file to an ast strucure and to be able to modify it according to commands, and rewrite/modify the c# file in an "offline" manner ( not having to start up visual studio ). Seems easier to code a C# =&gt; AST =&gt; C# parser than getting in to clinch with Roslyn. But then again i have never used Roslyn.
https://www.infoq.com/interviews/Steele-Interviews-John-McCarthy I've enjoyed reading around on this. Here is the question of dynamic -v- static typing when put to John McCarthy &gt; Kent Pitman: [wanted to ask] whether you think dynamic typing, which I really consider to be one of the central features of the language, whether the absence of static typing in Lisp is a bug or a feature? &gt; &gt; John McCarthy: I suppose both. As far as my thinking is concerned it was a bug in my thinking. Namely, I remember the first discussion of Slagle's problem and my attitude was: "Oh, you guys will fix them somehow!" and then were having a serious discussion that ended up with their talking about having two kinds of variables and so forth. I didn't really take part in that discussion or in the decisions that they made how to do it. So, here was a whole issue not merely with regard to Lisp, but regard to other programming languages, that I didn't understand all of until very much later. Doesn't sound like an anathema to the concept of Lisp. McCarthy was also very open about not being the boss and as a result there was a lot of innovation in and around lisp.
Doesn't everyone write a Lisp, as an intermediate stage of development as a Lisp programmer? Lisp reminds me of that early Max and Dave Fleischer cartoon, at the dawn of the medium when ideas were most fluid, where characters in a chase drew the means for their own escape. For all of Haskell's brilliance it misses this essential trippiness. You're looking at Lisp code if the syntax highligher sees Lisp code, but the semantics is entirely an invention of the programmer for that task. It's nearly impossible to achieve this goal in other languages, and it's unnecessarily difficult to achieve this goal in any actual Lisp. Why are there separate languages for compile-time and run-time processing? A primary goal of any future Lisp should be to automate this distinction, as we now automate memory-management. There's this meme that Haskell "doesn't need macros" because it has lazy evaluation. Therein lies the exercise: Haskell is flawed by wiring lazy evaluation always on, while Lisps are flawed by wiring lazy evaluation always off. In each case, one can overcome this, but one is fighting a strong current. So, design a language with fluid control of evaluation, that achieves the power of Lisp without a separate language for macros. 
&gt;GC is one solution to an issue. Defining lisp as 'its GCd' is just as useful as looking at early lisps and say that 'lisps are interpreted'. That's how the solve an issue, not what they are. Nope. Garbage collection is one of the reasons the entire Lisp model works. Manual memory management in Lisp would make it not Lisp. &gt;However, like I said originally scopes doesn’t call itself a lisp but it is a language that some lisp programmers might be interested in It doesn't seem at all similar to Lisp, so I'm just asking why you think it would be of interest to Lisp programmers especially.
Sorry, I never updated the graphics examples. Too bad since the code to visualize the weights in a neural network was cool enough (for 25+ year old code)
We did similar job in our project, but all C#. Parse code, perform defined refactorings (replacing old APIs with new ones and some other small changes) and generate C# code back. The experience with Roslyn was quite positive.
How did you do it? You did it as a plugin run within Visual Studio? Or as a separate program?
What compiler did you use?
I upload archives of my lisp dev streams [to youtube](https://youtube.shinmera.com).
That's cool, I considered doing the same at some point. I especially wanted an API that lets me to have a simplified API and environment for the server-level, because I imagine that's the usual use-case (but of course allow for more, for when it is needed... or even less, maybe just channel level). Just sharing fwiw. I hope it'll go well! best of luck!
No compiler, sorry. It was just a simple Scheme-ish interpreter I found written in C and GPL licensed. I don't know much about low level development and C, so I just wrote enough of a libc to run it on bare metal.
Hello, I started a collection here: https://lisp-journey.gitlab.io/resources/ for instance: - https://www.youtube.com/watch?v=bl8jQ2wRh6k web dev with CL and ClojureScript - McClim demo: https://www.youtube.com/watch?v=XGmo0E_S46I - pushing pixel with Lisp, as advertised here
I'm a Lisp beginner but, I've been working on some FPGA/CPU architecture tools to help me in converting C (RISCV ISA) disassembly -&gt; Intel HEX file -&gt; Modelsim (HDL Simulator) mem/mti file. This lets me load my computer design's ROM with a custom C program for verification, as well as, when I decide to synthesize the design onto an FPGA, I can also load that ROM into the hardware. They're simple tools, but if anyone is interested so they don't have to go through the pain, I can post a link for the entire design with tools.
http://www.cliki.net/lisp+videos
Somehow found myself somewhere implementing a new C++ daemon for a satellite. Common Lisp is currently used to prototype the daemon's socket and serial communication. Might need to simulate some hardware over serial because getting actual flight hardware from the clean room to test isn't feasible. Later may need to write unrelated functionality tests for the flight hardware in C++ but will switch to Common Lisp if pressed for time. Thinking about homework, lack of sleep, art, and the possibility of an all-purpose satellite related hardware/software testing suite configurable with a DSL and deployed with a GUI.
It is not related to Lisp though. Basically it is a stand-alone command-line tool. How to implement it read for example here: https://github.com/dotnet/roslyn/wiki/Getting-Started-C%23-Syntax-Analysis
I was very pleased to see this when I saw it in Miles Brundage's twitter feed earlier this year!
Thanks then please check it out again because the paper was significantly improved from the last version! It finds an action symbols (similar to gensym function names?) now. And it was accepted in AAAI, the real publication, "quality guaranteed" paper.
https://www.youtube.com/channel/UC55S8D_44ge2cV10aQmxNVQ https://youtu.be/PuGgCOyBMyc https://www.youtube.com/channel/UCKfZ9JfFgg7cxa2hYfC5O0A (the Xelf related). https://www.youtube.com/playlist?list=PLoH3jteqsb2h-F5AHG4XVyZ6GwODX4uVB https://www.youtube.com/channel/UCMV8p6Lb-bd6UZtTc_QD4zA https://www.youtube.com/user/burtonsamograd https://www.youtube.com/watch?v=_DjEK3DMY_0&amp;list=PLkDl6Irujx9MtJPRRP5KBH40SGCenztPW https://www.youtube.com/channel/UCByOqLrDdflAKDvHW3edcgw
**update**: you reminded me to try the **sensors** module; I just added an example called [sensors](https://gitlab.com/eql/EQL5-Android/blob/master/screenshots/sensors-phone.png).
Sounds cool!
I haven't read it, your best bet is probably to try to find it in a library http://www.worldcat.org/title/lisp-a-portable-implementation/oclc/86002704
https://www.reddit.com/r/lisp/comments/7aqnrg/what_are_you_working_on_nov_2017/
I've forked Scenic GUI toolkit and ported to SDL2, added widgets, animations, and made experiments. My fork is here: https://bitbucket.org/mmontone/scenic on the 'tinker' branch. (ql:quickload :scenic-demo) if you want to have a look. I've also started an implementation of propagation networks: http://web.mit.edu/~axch/www/phd-thesis.pdf https://bitbucket.org/mmontone/cl-propagators 
it is better if there is a description in each link :)
Was a fun stream, thanks again!
Thanks for stopping by! By the way, while I was taking a shower after the stream I realised why we needed to have `1` in the `uv_outer`: vec2 uv_inner = position.xz + 0.5 + block + offset; vec2 uv_outer = (position.xz + 1 + block - offsetp)/2 + offset; Namely the `0.5` in the inner is the centring of the coordinates in the map. For the outer we only want to halve the offset from the centre. Less confusingly written then, it would be like this: vec2 uv_inner = position.xz + block + offset + 0.5; vec2 uv_outer = (position.xz + block - offsetp)/2 + offset + 0.5;
Link?
 &gt; Link? [Here you go!](https://upload.wikimedia.org/wikipedia/en/3/39/Wakerlink.jpg) --- ^(I am a bot. | )[^Creator](https://www.reddit.com/user/alienpirate5)^( | Unique string: 8188578c91119503)
Not quite sure what they put in the water @ Cambridge, these prices are outlandish to say the least. I laughed out loud when I saw their "hobbyist" edition pricing. 
No kidding. I just don't get it. I'm willing to pay money for a good lisp UI library like LispWorks' CAPI, but $750 for a hobbyist version that can't even create standalone executables is too high; $1,500 for a version that can create non-commercial executables is obscene. For comparison purposes, Visual Studio Professional is $499.
&gt; Visual Studio Professional is $499. Does it support Common Lisp?
&gt;LispWorks for Android Runtime allows you to deliver (non-GUI) &gt;LispWorks for iOS Runtime allows you to deliver (non-GUI) Now I can understand that making GUI library on android would require them have java application that calls into the lisp library and it might be even harder when targetting IOS but still for commercial product I would expect them to let me target GUI application to each platform. These are just my values, though. 
Too bad there is no cost associated with posting pointless comments. :P
Yes, contrasting with another Lisp implementation would be a better comparison, but Allegro CL didn't appear to have their licensing costs on their site.
Guess why. ;-)
&gt;but Allegro CL didn't appear to have their licensing costs on their site. You won't like it) It's ~9K$ for 64bit version.
The iOS general model is already somewhat supported on other platforms: LispWorks generates a library which is linked into the iOS app. But the runtime needed work to run under iOS. It for example has a special GC for iOS, because of various platform limitations. Sure a GUI lib would be cool, but that would be a bit more work. Difficult to say if it could be financed...
Lord have mercy! I guess that makes LispWorks look like a steal. That being said, I don't know many hobbyists of any variety that spend $1,500 on software.
Allegro CL has a different license.
I don't know if that is really 9k$, but generally the commercial license of Allegro CL has not royalty-free application delivery. You'll pay per users of your end-user application.
$$ do not matter. 1) Make successful business using SBCL 2) Then buy ACL
Oh, man... can I afford to zip to San Francisco for a night?
SBCL and CCL are completely free and I bet SBCL beats Lispworks in flexibility of code generation / performance. I have no use for any of the add-ons that come with Lispworks and have no equivalent in SBCL (CAPI, knowledgeworks, ?) and I prefer to pay for support if and when I need it. I therefore find the Lispworks pricing preposterous. 
It is arguable that Microsoft Bob was the most successful software development of all time... for Melinda Gates, anyway.
Is it possible to make successful business on Lisp?
My personal take: the LispWorks runtime and delivery is a lot better. Some of the reasons people buy LispWorks: cross-platform GUI toolkit, cross-platform IDE, runtime supported (!) on various OS/machine types, various delivery options, good support for Windows and Mac OS, ... I'm using Macos and the LispWorks IDE is by far the best Mac IDE for Lisp, which is not surprising, since all the other options are far less attractive: Clozure CL has mostly just a sketch of an IDE, Emacs&amp;SLIME is just, SBCL comes with nothing additionally and, Allegro CL wants me to use X11/GTK+ on a Mac, ...
7pm UTC happens when this comment is 9 hours and 45 minutes old. You can find the live countdown here: https://countle.com/RBz100015b --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Do we know how many people are working at LispWorks ? Just curious.
The Lisp business of Harlequin was always only a small part. Harlequin tried to share the knowhow in various ways (Dylan, MLWorks, Garbage Collection technology, ...) and tried to use Lisp in some products - some successful (like the applications from Xanalys), some eventually not so much (like Webmaker). 
I agree, sorry about not doing that, I was in a hurry and thought the person asking would check each one anyway.
In the same order: [ELS: European Lisp Symposium](https://www.youtube.com/channel/UC55S8D_44ge2cV10aQmxNVQ) [Computer Process Hacking](https://youtu.be/PuGgCOyBMyc) [DTO Xelf Game Engine](https://www.youtube.com/channel/UCKfZ9JfFgg7cxa2hYfC5O0A [Bay Area Lisp: BALisp](https://www.youtube.com/playlist?list=PLoH3jteqsb2h-F5AHG4XVyZ6GwODX4uVB) [Baggers mainly Pushing Pixels](https://www.youtube.com/channel/UCMV8p6Lb-bd6UZtTc_QD4zA) [Burton Samograd, Eturia (initially Skynet) Lisp Machine](https://www.youtube.com/user/burtonsamograd) [Shinmera Treehouse](https://www.youtube.com/watch?v=_DjEK3DMY_0&amp;list=PLkDl6Irujx9MtJPRRP5KBH40SGCenztPW) [Jeremiah Stoddard. Lisp Adventures](https://www.youtube.com/channel/UCByOqLrDdflAKDvHW3edcgw) 
I never saw the appeal of the Lispworks IDE, it looks and feels terrible to me compared to Emacs/SLIME. I've tried to *get it* given that I've seen you bring this point up repeatedly over the years, but I just don't see it. I consider myself an expert in Emacs Lisp and I can heavily customize everything I want to shorten the feedback loop. The Lispworks IDE is completely opaque to me. I don't know where to begin looking for things like fuzzy completion/fuzzy doc search/fuzzy buffer switching which are things I use all the time and they don't come built-in to Lispworks. 
&gt; I consider myself an expert in Emacs Lisp I don't want to be an expert in Emacs Lisp and the GNU Emacs libraries. I actually want to touch that as little as possible. It took the maintainers two decades (or more) to add lexical binding. I also want to be away from Stallman's design choices for Lisp &amp; editors as far as possible. For me it's more important to have a Common Lisp GUI toolkit, an IDE which uses it already, having this all in CLOS - instead of alien stuff in GNU Emacs which I have to enhance in Emacs Lisp and which I have a hard time to reuse from Common Lisp and which is totally unlike anything on the Mac. &gt; buffer switching Personally I have no problems switching 'buffers' or even better 'windows' (especially since now a lot of GNU Emacs buffers are actually real windows). If I would need a special way to switch between windows (listener, inspector, backtrace, editor, ...), I would like to have that macos-wide and not only in the editor. &gt; killer features of Emacs ... paredit, hydra, org-babel I won't use paredit and hydra. org-babel is fine, but I'm not a user. Again, I'm not tied to GNU Emacs features. I use SLIME in GNU Emacs, but if I develop any substantial amount of Lisp code, I tend to avoid it because of its clunkiness. Probably with more configuration it could be made more user friendly (starting from keybindings, to when stuff pops up, ...). To give you an example: by default I see this in SLIME: CL-USER&gt; (break) Now the backtrace comes up and my REPL is blocked. I don't want that. I can probably hunt for a config option now. Now I want a second listener. To do that is completely non-intuitive and hard to discover. In LispWorks I see this: CL-USER 2 &gt; (break) Break. 1 (continue) Return from break. 2 (abort) Return to top loop level 0. Type :b for backtrace or :c &lt;option number&gt; to proceed. Type :bug-form "&lt;subject&gt;" for a bug report template or :? for other options. CL-USER 3 : 1 &gt; My REPL is still there. I can tell it to bring the debugger up on break, but still the REPL is there. I can easily choose to bring up the backtrace. But I can also stay in the REPL for some time. Now I want a second Listener. Podium -&gt; Listener Icon. Or command-control-l or Windows&gt;Tools&gt;Listener. Clone Window. The whole handling of the main Lisp development tools is much more intuitive for ME. But I'm coming from Symbolics Genera and Macintosh Common Lisp. But that's just ME. If it does not work for YOU and you are more productive in GNU Emacs, that's fine. I've observed what I intuitively do when developing Common Lisp code and GNU Emacs + SLIME is not my first choice. One of the things which makes me reach there is SBCL, since I like the SBCL compiler and it is best used from GNU Emacs / SLIME for more demanding stuff. 
IIRC its only 4 people or around that, last time I've spoken to Martin.
They haven't changed the price from previous release. Its bad, but it is a niche business and the only way for niche business to survive is to keep the prices to be able to afford to continue to exist. Even if they make a price like 1$ it will not massively increase the amount of users - because CL users are a tiny fraction of SW engineers anyway. There are only a handful of them. One thing good about this update is the changes in UI/IDE. I really like them (and actually requested them through the support) and now need to find a way to sneak the money from the wife to do an upgrade ;)
I have nothing more recent than http://www.cliki.net/Performance%20Benchmarks
Maybe you could try [Make a Lisp](https://github.com/kanaka/mal/blob/master/process/guide.md), you will create a Lisp (not common lisp) but the [Mal Lisp](https://github.com/kanaka/mal/blob/master/process/guide.md) inspired by Clojure. It has already been implemented in 71 languages, so you will likely be able to check the source code for a language you already know.
I don't know about benchmarks, but in my limited interactive experience, LispWorks and Allegro *compilers* have been way faster than SBCL for many years, and releases in the past few years have generated comparable runtime performance.
It looks like paste.lisp.org might not use SSL, but shares an ip address (common-lisp.net) that does. So it looks like the problem is a symptom of the site owner not knowing what they're doing. Or paste.lisp.org is an alias for common-lisp.net but the site owner forgot to add the domain to the certs. 
It’s expensive, but it’s the best Lisp available if you care about any of the following: 1) CAPI: cross platform native GUIs. I do a lot of work with OpenGL, Metal on macOS, and Vulkan on Linux and Windows. I can use CAPI to create a native “window” and fill that window in with a GL-aware view to be created, modified, and destroyed at my whim interactively. Love it. I also use CAPI when building “dev” tooling that I might need lots of toggles and controls in, but don’t want to be concerned with styling. 2) Great platform support. The macOS edition makes working with cocoa a flipping breeze. I beta tested their iOS runtime, and was blown away. I have moved my day to day development from macOS to Linux, but really appreciated how well designed and implemented their objective-c interface was. And now they support simd vector types in the FLI! 3) Application delivery as an executable or shared library. They perform tree-shaking that you can configure and tune to trim the final size and capabilities of the image to your liking. I have never used anything comparable in any other Lisp before. It’s truly a professional delivery system. So why upgrade to 7.1? For me it is out of the box support for async i/o with UDP/TCP. Honestly, just take a few minutes today to read through LispWorks’ documentation. You might come away impressed.
There are several options. Perhaps the easiest is to just reference them with two colons. The peril is that they may change or disappear in the future, and you have to adapt. (This can happen with exported symbols too, but the implied contract of exported symbols is "you can and should use this".) You could also wrap the non-exported function in your own function, so you can use your function freely in many places, and if the internal function changes or disappears in the future, you only have to change it in one place. You could ask the maintainers to export the function, and wait for that to happen before using it.
It is indeed just around $9K. Franz has always taken the "If you have to ask, you can't afford it" approach to selling their product. On top of that, as lispm mentions below, their runtime is not royalty-free. So yes, by comparison, LispWorks is in the bargain bin. What irks me the most is the 2x cost increase going from 32-bit to 64-bit versions. I mean, seriously? *Still* running that old scam, eh? Oh, and notice that at the Enterprise sku, LispWorks costs the same for 32 vs 64 bit. At the Professional SKU, the cost is exactly 2x. I guess because I have to get twice as many bits or something...??? But those bits suddenly cost $0 in the Enterprise SKU.... The situation is completely idiotic, and has been since day 1 of commercial CL implementations. In many ways, commercial CL vendors, who were in a position to promote and advocate CL, are its worst enemies. 
Which is why they'll eventually go away/die. The future of CL lies in opensource. Look at Symbolics Genera for a good argument against going all-in on a proprietary stack. 
it works as http. BTW, lisp.paste.org has gone into read only mode as the service: On 16 September 2017 at 08:29, Erik Huelsmann wrote: &gt; &gt; &gt; On Thu, Sep 14, 2017 at 1:08 AM, Vladimir Sedach wrote: &gt; &gt; &gt; &gt; Read-only mode seems like the best solution. There are still many &gt; &gt; lisppaste links around on the web and in mailing list archives. &gt; &gt; &gt; &gt; Given the fact that this is the only reaction about running the paste engine, I think there's nobody interested in fighting the spambots solely to keep a lisp paste bot running. &gt; &gt; My conclusion then is that indeed we'll turn the service to be read-only for the purpose of maintaining the older pastes around. &gt; &gt; There then is one remaining thing to be done, though: clean the current body of pastes from any abusive or inappropriate content. &gt; &gt; Would anybody be interested in taking up the task to do such a thing? (btw, I'm not thinking of reading each and every one of the posts in the system; I'm more thinking of using bayes testing (like spambayes or spamassassin) to clean the system with "minimum" energy)
&gt; https://countle.com/RBz100015b Failed to parse the day 
No implementation I know of compares to SBCL when it comes to fine tuning numerical computation on the CPU. This is probably due to how flexible and hackable the SBCL compiler is by users. The flexibility it gives users who care about exactly what CPU instructions get selected and prioritized during compilation is unmatched by any public APIs in LispWorks that I know of. Caveat: I have found that the overall difference is negligible when you actually read through the LispWorks documentation and figure out how to optimize your code. The :explain directive is particularly useful here. When it comes to non-numerical code, LispWorks 7.1 absolutely blows SBCL 1.4.1 out of the water. This has been true in my experience for as long as I can remember. In particular, anything CLOS related is so much faster I actually feel comfortable making heavy use of CLOS in almost any situation because I am so confident in the efficiency of the object system in LispWorks. I love CLOS/MOP, so this is a big win for me. In conclusion: I love them both for different reasons. I wish LispWorks had source code available I could augment every single day. 
Two big advantages of SBCL: The Type Inference makes it easier to speed up code, with less work. The compile-time type checking of the SBCL compiler makes me a bit more confident when optimizing code. The big elephants in the room: * safe code - how fast is that? * multi-thread code - how fast is that? 
GUIs on mobile are very different from the ones on the desktop; I suspect that's neither their market nor their strength.
Is this drawing also yours ? All this is quite impressive.
The blog headers are usually not mine.
Thanks for the writeup! I was doing experiments about soundprocessing although in much more primitive manner and was moving in somewhat similar direction. I have a couple of questions: - libmixed is done in c due to performance reasons. Could you please elaborate on this? How much slower pure common lisp solution would be on your opinion? - All operations are reduced to a single channel. I did the same as well, since my purpose was just to do some analysis, so the lose of quality is ok for me, but how does it work with the games, where you might want to get stereo with 3d effects etc.? And thanks for all the library bindings for libmpg123 etc, it's all very useful
https://xach.livejournal.com/325276.html
I can't say how much slower it would be if I simply replicated the design of libmixed. When I tried the pure-lisp implementation, I was using a different design that would be more "lisp-friendly", but couldn't get it to perform well enough. If the lisp-friendliness constraint was relaxed, you could probably put together a system that is clunky to use, but fast enough for quite a few cases. In the end, I didn't follow up on this because interacting with systems written in other languages (like LADSPA plugins) is easiest with the C model. You might be confused about channels and buffers. Each buffer *represents* a single channel. However, segments like the basic-mixer and others can be configured to an arbitrary number of channels, which in effect just means it'll take that number of buffers for each input source, and output that number of buffers as well.
hello, &gt; it seems that many developers prefer to prepare a package containing the full library they are writing If I understand correctly, that does not seem to be the case. If we look at Caveman: https://github.com/fukamachi/caveman/ , its src/ contains `app.lisp`, `caveman.lisp`, `db.lisp` and more. Each file defines its own package: ``` (defpackage caveman2.app (:use :cl) (import-from ... (export ... ``` and caveman.lisp imports them: ``` (defpackage caveman2 (:use :cl) (:import-from :caveman2.app :&lt;app&gt; :next-route ```
&gt; Am I correct assuming this is the dominant usage, even for code written today? Yes, there is no good use of fine-grained packages in Common Lisp. It's a waste of time. I would also not generally IMPORT identifiers from various packages into my packages. I would EXPORT identifiers, though. 
Yeah, don't use that. This is practice from static programming. In interactive programming, having too many packages is a pain. If you look at Common Lisp, few people use packages that way. I'm not a big fan of that programming style either: https://github.com/fukamachi/caveman/blob/master/v2/src/app.lisp * starts with a useless IN-PACKAGE, where it could prefix the DEFPACKAGE and the next IN-PACKAGE with CL * the DEFPACKAGE and the whole file has no documentation about the purpose of that package * then DEFPACKAGE is used as a kind of module specification, which it not is. I don't now for example that the imported symbols actually are (functions, macros, variables, constants, ...?). * The DEFPACKAGE then reexports imported symbols... * it has global variables with any documentation, a big thing to avoid * it exports functions, without any documentation of their purpose... This creates a web of too many packages with lots of undocumented structure...
I think it will be helpful to simply forget or ignore how you use packages in any other system and focus on how packages are used in typical Common Lisp programs. Practical Common Lisp discusses one approach. Packagers in Lisp are about organizing the names of things, not the things themselves. They are somewhat analogous to organizing files into directory structures. Some people like many directories with a few specific files, some people don't mind lots of files in a single directory, and some people mix approaches depending on the situation. Similarly, there is no one fixed way to make use of packages in Common Lisp.
http://zeniv.linux.org.uk/~ober/clb/
Thanks. As for point 1, I also found easier to first write an `in-package :cl-user` because I can C-c C-c the following `defpackage my-package` or C-c C-k everything. Other configurations I met made it a bit more difficult to work with Slime. Do you suggest to prefix like this ? (defpackage cl:my-package in that case I can't C-c C-c it: &gt; Symbol my-package not found in the COMMON-LISP package
I think the suggestion was to `(cl:defpackage #:my-package…)`.
 (cl:defpackage what-ever-your-package-is ...) or (cl:defpackage "WHAT-EVER-YOUR-PACKAGE-IS" ...) or (cl:defpackage #:what-ever-your-package-is ...) or even (cl-user::defpackage what-ever-your-package-is ...) &gt; As for point 1, I also found easier to first write an in-package :cl-user because I can C-c C-c the following defpackage my-package or C-c C-k everything. The bigger problem is that you have TWO in-package in the same file. If your IDE is most advanced, C-c C-c will evaluate the s-epression in the region of the IN-PACKAGE it belongs to. If it is not so advanced it will only know about one package per buffer, and some expressions can be evaluated in the correct package, and some will not. 
there is this: [How to write a modern Lisp library with ASDF3 and Package Inferred System](http://davazp.net/2014/11/26/modern-library-with-asdf-and-package-inferred-system.html) which is the one package per file and one file per package method. I am not a big fan of the approach but I can see how it helps with code sprawl in a large project. I prefer a system to have one or more packages and then a package can have one or more files. That is just the way I prefer to think about it. As a system or project develops I have spun off a package into a separate system or a file can be promoted to a separate package. Of course, I like bottom-up programming especially in lisp. The other way is more top-down to me.
Just post the problem that you want help with instead of telling people to message you. Is it homework or something?
I would try to avoid using :: when writing Common Lisp. Libraries should export the symbols they want others to use, and users should not violate this convention using ::.
It's a hack in this case. For example one can use it this way: Typically Lisp has a QUIT function. But you don't know from which package it is exported. But you know that QUIT is imported into CL-USER. It probably won't be exported from CL-USER, since CL-USER is not thought to be imported. Calling (cl-user::quit) then let's you quit... ;-)
I'm really not sure what kind of hobbyist they think can pay that kind of money when there are really viable open source alternatives. If they had any option that let me install it on a couple platforms for $200 Or so, maybe. MAYBE. But I think they're misusing the word "hobbyist".
if asdf is loaded, `(uiop:quit)` works.
If ASDF is not loaded, I get another error, then.
paste.lisp.org is operated by the Common Lisp Foundation. We can be contacted at &lt;clo-admin@common-lisp.net&gt; We are not legion, we are volunteers, we will be forgotten. 
Common Lisp packages don't contain types or functions. They contain symbols. A package is an object which contains symbols, providing a map from their names (strings) to the symbols themselves. Plus, a package has various other properties and embellishments such as a list of shadowing symbols, a list of packages it uses (which are like "windows" into other packages) and such. A package is completely oblivious to what the symbols mean. The package system lets you have a `lottery:draw` and `graphical:draw` symbol, both of which have `"DRAW"` as their name. If one of those two packages is current (i.e. the value of `*package*` is that package) then the plain, unprefixed token `draw` refers to that respective symbol. These symbols are completely unrelated; except through the coincidence that their `symbol-name` strings are identical. Now suppose you have a class framework of graphical objects, and a class framework for a lottery simulation. One might have a generic function called `draw` (`graphical:draw`) and the other also, but `lottery:draw`. A user can come along and use both of these frameworks, and create their own class type, for which they specialize both methods: ;; specialize the graphical draw method for the widget class in my package (defmethod graphical:draw ((obj mypackage:widget) ...) ...) ;; likewise the lottery draw (defmethod lottery:draw ((obj mypackage:widget) ...) ...) So now `mypackage:widget` supports graphical drawing and lottery drawing. This works transparently with the slots of the class itself under multiple inheritance. If we multiply inherit from some class B1 and B2 which have slot names using symbols in different packages, then it is very straightforward. In Common Lisp there is no such thing as "class scope" and no ambiguities under multiple inheritance requiring scope resolution or anything of the sort. The package system doesn't know anything about functions, methods, variables, types or any programming or other representational paradigm. If you make a musical programming environment, with musical compositions named by symbols, those can readily be in packages. Symbols purely used as data can be in packages also and it's in fact a good idea to create a dedicated package if you're reading symbolic data at run-time. E.g. if you're parsing natural language and turning elements of it such as morphemes into symbols, that sort of thing. A top-level form is read in the context of `*package*` having a certain binding to some package and that determines what the plain, unprefixed names mean. Names not visible in that package that must be referenced in that form must use the qualifying prefixes. The Lisp printer also responds to the value of `*package*` to decide what symbols to print plainly and which require a prefix. It's almost too simple; so simple that the Common Lisp people found various ways to complicate it, quite incredibly, but that's the gist of it. 
I did a 3min video showing the result of cleaning up the prototype from the stream https://youtu.be/m0HGms89kr8 
I don't agree or disagree with his style. But your assessment is not completely reasonable. The first two points are just about the taste, please stop bitching about it. It is just two lines worth of code anyways, for three lines of complaining. It is a perfectly conforming program. Lack of documentation is bad. The purpose of using `defpackage` that way is **NOT** for defining module specification. It is just about the **control** that you want to have or you want the readers to have on the package. He claims the imported symbols should be explicit rather than implicit (through `:use`) because a future update in the library may contaminate the package by introducing a new exported symbol which is then unintentionally `:use`d. It is thus about how much confidence&amp;control you want to have on the library to make it "live longer", because it affects the software which uses your library. In fact, I sometimes get surprised when a certain symbol comes from a package that I didn't even imported, through a cascade of `:use`. Most people including me take care not to let it happen, though. Well, this is kind of contradictory to his usual lack of documentation. But it is true that it becomes increasingly scarier when lots of symbols from other packages are unnecessarily mixed up together like a mud ball. It is scarier than the lack of documentation because this is caused by the external libraries, not by the library itself, which you already have access to and can find nearby. As I said, I don't completely agree or disagree with the style. For my work I usually include arbitrary symbols. However I do see the advantage in it.
The first two points: we are going to evaluate code in an editor in the wrong package, if the editor does not keep track of multiple package regions in a buffer. I avoid USEing packages and deep package relationships with that. In fine-grained packages, like his, this gets even more of a problem.
One question from CLer that doesn't quite make sense in other languages and may confuse you is something like this: *you have `module`, `:`, `sig`, `type`, `val`, `-&gt;` and `end` symbols, but in which module are they in?*
It's a question of perspective. Look at it from above: Enterprise is what the product really costs, everything else is a rebate. If you don't need certain features, those steep rebates are a good deal, no? 
Ah yes. I've been to this discussion with /u/lispm 2 years ago. Just to be clear - I think its extremely expensive. But I understand there the pricing is coming from. At the end of the day I saved enough and just bought it. Considering at the end of the day the LW IDE is the best you can find for CL right now, so I just saved and bought a hobbyist license which I use for all my Lisp small projects (like this https://github.com/fourier/mediaimport) having IDE + GUI + Profiler + Code Coverage + delivery in the same tool and saving the time I would have spent to configuring Slime/CommonQt etc for the family. 
Why the switch from ECL to CCL?
Hi, thank you for your interest! CCL has the Ojb-c Bridge on MacOS, and there are bindings for GTK on Linux. This enables me to do cross-platform native GUI using Cocoa, and GTK respectively. This is not possible with ECL. Additionally, afaik, CCL has better performance than CCL.
Congrats! As I already said, I (probably) would have done the same if I where on a Mac. P.S. I consider ECL a "niche CL"; it's perfect for e.g. android, but other implementations are more "lispy".
Yes there is a problem with `paste.lisp.org`: *content/URL amnesia*. Where is http://paste.lisp.org/display/71196 Referenced from: https://groups.google.com/forum/#!original/comp.lang.lisp/u99XBdvRnNo/Kq83i0HnBRcJ 
Thank you! ECL was quite good in my opinion, but the Obj-c bridge is invaluable!
with firefox 57 removing xul api, would this browser be able to have extensions just as powerful? or limited to current webkit/chrome extension ecosystem?
This is implementation-dependent. If you're looking for SBCL answers, you could ask on `#sbcl` on Freenode since this is where the developers are hanging out.
&gt; It's almost too simple; so simple that the Common Lisp people found various ways to complicate it, quite incredibly, but that's the gist of it. Extensions like local nicknames do have good motivations. 
This could require that the structure classes be marked as final in some way, which is not standard. Otherwise, a new subclass could be defined dynamically that would not fit. You could also use a foreign function interface to get at C datatypes. You'd have to make sure these got freed though.
Hi thank you for your interest ! The power of extensions is limited in no way at all. You could do anything available in the native OS, you could even spawn new windows with any widget or code you like. Interaction with the web view is limited to a javascript bridge due to the asynchronous nature of it, but you can do literally anything. Its quite powerful!
If you care about the memory layout and want to specify it precisely, you could just define a C struct instead and use CFFI, or sb-alien directly, to allocate the memory and dereference the fields.
Technically possible, but not implemented. But if you have a vector pointing to structs the GC is likely put them sequentially in memory.
SBCL has sb-ext:freeze-type declaration.
I think I've just done a little wee I'm so excited to find out about this project. As soon as I get back down under, I'll download and play with this immediately.
Lol! glad to hear it!
I'm currently implementing a Lisp (but not in a Lisp) to test my virtual machine and related infrastructure
Great works, /u/jmercouris.
 &gt; The consequences of redefining a defstruct structure are undefined. - CLHS - [defstruct](http://www.lispworks.com/documentation/HyperSpec/Body/m_defstr.htm#defstruct) Given this it isn't wrong to assume a struct shouldnt be redefined as otherwise you are already in undefined territory.
I don't know if I agree completely about no good use but may be the issue is how we are defining "fine-grained" here. Also, not generally importing identifiers from other packages?. I am working on a "big" application and after I switched to a per file package system, which is very painful btw, my development has been way smoother as things (files, functions, etc) are better organized. For this approach, I make use of asdf's :class :package-inferred-system in my defsystems. It takes a lot of discipline to code this way though but for me, I have seen the benefits mostly due to better clarity and organization of files. This is not to say or suggest that other approaches are not possible, but this just seems clearer to me and works for my coding style. I guess Xach's analogy about directory structure organization is apt here.
Sure but what about the following: (defstruct base foo) (defstruct (derived (:include base)) baz) (subtypep 'base 'derived) =&gt; T T So essentially what you're saying supposes that the contained type is invariant (as opposed to co or contravariant). Then you have the following quote from the CLHS &gt; element-type indicates the type of the elements intended to be stored in the new-array. The new-array can actually store any objects of the type which results from upgrading element-type; see Section 15.1.2.1 (Array Upgrading). which allows you to figure out what type is 'stored' through the upgraded-array-element-type function. /u/stassats, am I misrepresenting some facts here or am I correct?
That is correct. Things are a bit different with integers, which are usually used for specialized arrays, since integer subtypes are smaller in range but structures subclasses are larger. Some rules will have to be bent.
Indeed, that's what I was thinking of. sb-ext:freeze-type does freeze all the subclasses, though.
Unless you really just want to try that out, and instead want to optimize a certain program, you should try profiling it first and check if AoS is really the problem. https://stackoverflow.com/questions/10082517/simplest-tool-to-measure-c-program-cache-hit-miss-and-cpu-time-in-linux [Manardb](http://cl-www.msi.co.jp/projects/manardb/index.html) might interest you, although I havent seen a real example using it. If you want to make a library instead of temporary solution, MOP should be your friend (or foe).
thank you!
**update**: android **4.2** devices should all work now (I tested successfully). They needed a workaround (pre-loading of all additional libs).
Thanks, great points!
Can you explain this a little more? If I understand the original question, OP wants to be able to specify a contiguous block of structures, and is under the impression that an implementation will give you a contiguous block of pointers to structures instead. While it seems that the spec says that redefining defstructs is undefined behavior and hence it should be safe to assume that the layout of the array in memory won't change, you suggest that the ability to define subtypes is why this is not a safe assumption that can be made. If I've got that part all correct, I don't understand why your answer means this can't be done. Thanks!
&gt; One thing good about this update is the changes in UI/IDE. I haven't noticed any changes to the UI/IDE, could you please point me to those?
The key is in what "invariant" means in this context. It means that "if an array is of type base then it can only, AND ONLY, store the type base", so no subtypes of base or anything. Then we can easily implement the feature requested above. If we can freeze the subtypes then we could also implement the feature above, but: If you have a 1000 subtypes with 1 unique slot each, then you'd have to have memory allocated for each of those slots for each element in the array. You'd also have a pretty interesting allocation scheme to figure out which slot is which. This would nullify the gains (cache locality) because we'd have to jump around in memory a lot. We'd also have a lot of internal fragmentation.
Sure: http://www.lispworks.com/documentation/lw71/RNIG/html/readme-142.htm
Check out my reply to /u/KDallas_Multipass for why subtyping still is a problem in the context of non-invariant arrays.
Not sure, but have I seen this person before? Off to a decent start anyway. I've seen much worse. Thanks. 
He does weekly streams on CEPL and related things.
&gt; If you have a 1000 subtypes with 1 unique slot each, then you'd have to have memory allocated for each of those slots for each element in the array. You'd also have a pretty interesting allocation scheme to figure out which slot is which. I don't see why this is. One could have an array in which the space allocated per entry is the maximum size of any of the subtypes. Slots in different child types can have the same offset. The bigger issue is how do you deal with Lisp's object identity semantics. Primitive immutable types can be copied with impunity (EQL will figure it out), but structures have object identity. Put a structure into an array and all the references to it have to be consistent. I suppose one could have an array of pointers AND structures, with the pointer pointing to the following structure when possible, but then why not just let the garbage collector create what amounts to a separate structure vector when it compacts?
download: https://common-lisp.net/project/cmucl/downloads/release/21c/ 
Thanks. I'm not sure this 'little bits of lisp' series will be too useful for those who are already comfortable in the language however Im hoping it helps some of the newer folks. However if you do spot errors please let me know, video is cheap and I can re-record or add new videos to patch up my mistakes :) 
&gt; &gt; &gt; I don't see why this is. One could have an array in which the space allocated per entry is the maximum size of any of the subtypes. Slots in different child types can have the same offset. Yeah I think that sounds reasonable, however it doesn't fully remove internal fragmentation but the worst case has a low probability of happening (huge structures aren't that common). Good points regarding identity.
I want to get back into lisp but I need a beard and flowing hair first.
How do you expect us to give you one that you like if you can't even express which ones you've seen, nor what you disliked about them?
Fair point. I don't expect you to go out of you way to give me one I'd like. I just wanted to know what your take on one of these algorithms would be, or point me to one you like yourself. That said: I don't expect anyone else to share my sentiments, but I think lisp code should be more hierarchical rather than linear like in other non-lisp languages. And as I said before, the code I looked at seemed to be ported from an other language. Hope that clears things up. 
The ones listed on [Rosetta Code](https://reader.tymoon.eu/article/359) seem fine if you like recursion (and thus potentially blowing your stack). I'm not sure what you mean by "hierarchical" in the context of code, but while Lisp does support first-class functions, it is not a functional language. More importantly than that still, TCO is not guaranteed by the standard, so recursive solutions are usually frowned upon compared to simple iterative schemes. Given that, it seems perfectly reasonable to me to implement a search like this: (defun depth-first (tree function) (loop while tree for element = (pop tree) do (typecase element (null) (cons (dolist (element (reverse element)) (push element tree))) (T (funcall function element)))))
Thank you. On a different note: Your "Rosetta Code" link does not, in fact, point to "Rosetta Code". 
I see, you're saying that containers can store derived types. Which makes the implementation of this problematic.
Not a requirement, really: [Guy Steele](https://www.youtube.com/watch?v=ftcIcn8AmSY) has never had prominent facial hair.
Ah fuck, copy paste history got screwed up. Sorry about that, should be fixed now.
Don't worry about it. It was an interesting read nonetheless, especially when you're trying to figure out how and when graph traversal is going to come up.
The [ones from "Paradigms of AI Programming"](http://norvig.com/paip/search.lisp) look Lispy to me. (Well, I didn't like the A* one, one of the very few misgivings I have about this all time favorite programming book of mine.) In fact, most every AI Lisp book has implementations for them, but this at the moment I am thinking about "Building Problem Solvers" and "Artificial Intelligence Strategies, Applications, and Models Through Search" (though I think the latter didn't use Lisp - I just followed along writing Lisp). You can find both online.
These are lovely, thanks.
But [McCarthy](http://www.ilmarefilm.org/archive/img/portfolio/fullsize/29_gross.jpg)...
If I understand you correctly, you say that arrays of integers might be supportable because subtyping them doesn't usually change their space requirements?
[@peterseibel](https://twitter.com/peterseibel) is about as baby-faced as a middle aged man can be, and he wrote [one of the most popular books](http://www.gigamonkeys.com/book/) on Common Lisp.
But &lt;a href="https://en.wikipedia.org/wiki/Steve_Russell_(computer_scientist)"&gt;Steve Russell&lt;/a&gt;... OK, I give up - how do you embed a URL containing parentheses in Reddit comments?
Nice try. [Tom Knight](http://cdn.worldsciencefestival.com/wp-content/uploads/2016/05/Tom-Knight_200px-1.jpg)
can't wait to share it to my college friends, I am sure videos are more appealing for some users. Your videos remind me the first time I learn emacs from jekor videos. Hope your videos cover all basic thing for one to start trying CL. Thanks for this awesome work /u/Baggers_. 
wow thankyou, jekor's videos helped me so much with emacs, if I can achieve a fraction of that I'll be chuffed
Might be? The whole reason for specialized arrays is for numbers and characters to be stored efficiently.
[removed]
You seem to be pushing these out as quickly as a factory: can't wait for the one where you explain scope &amp; extent :-)
[Steve Russell](https://en.wikipedia.org/wiki/Steve_Russell_\(computer_scientist\)) backslash the parens: `[Steve Russell](https://en.wikipedia.org/wiki/Steve_Russell_\(computer_scientist\))`
The last two days I've been stoked to get making these, however the drive to do this kind of contents comes in waves so I expect this will be rather sporadic. I'm still keeping the CEPL streams regular though.
I understand. If you'd like some feedback: I love lisp, so most of this isn't really new, but since I'm just starting out with CL itself it'd be great to know why things are named the way they are (and not just what they do). Or is is it "just because" 90% of the time?
After re-reading the thread and other replies, I now understand what you were saying.
Good idea, IIRC some of them are just however it was named in the various lisps that were drawn upon when writing the CL spec (a lot of maclisp I think) some of the names do have interesting history though, like car and cdr. Time to read http://www-formal.stanford.edu/jmc/history/lisp/lisp.html &amp; http://www.nhplace.com/kent/Papers/cl-untold-story.html again
You can [percent encode](https://en.wikipedia.org/wiki/Percent-encoding) it. [Steve Russel](https://en.wikipedia.org/wiki/Steve_Russell_%28computer_scientist%29 [Steve Russel](https://en.wikipedia.org/wiki/Steve_Russell_%28computer_scientist%29)
**Percent-encoding** Percent-encoding, also known as URL encoding, is a mechanism for encoding information in a Uniform Resource Identifier (URI) under certain circumstances. Although it is known as URL encoding it is, in fact, used more generally within the main Uniform Resource Identifier (URI) set, which includes both Uniform Resource Locator (URL) and Uniform Resource Name (URN). As such, it is also used in the preparation of data of the application/x-www-form-urlencoded media type, as is often used in the submission of HTML form data in HTTP requests. *** **Steve Russell (computer scientist)** Steve "Slug" Russell (born 1937) is an American computer scientist most famous for creating Spacewar!, one of the earliest video games. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I hacked it in like 15 minutes; it should work. https://ja.reddit.com/r/lisp/comments/7dshtw/is_it_possible_to_have_continuous_memory_layout/
Where did it go?!? Inquiring minds want to know!
Cool stuff! :) (BTW, linux + youtube-dl + emacs + evil + stumpwm [rocks](https://imgur.com/2lHVgpA))
It's an article I wrote recently. Here you go: https://reader.tymoon.eu/article/359
/me hits episode 13 on youtube I wonder if I'm catching up to the live stream? /me sees post Nope
:D
I use SBCL servers fronted by nginx and really enjoy it. Long uptimes and stable memory footprints are typical.
http://archive.is/tVkT9
I've been using SBCL for my websites and many of my services. I also developed a very flexible web framework for it called [Radiance](https://shirakumo.github.io/radiance-homepage) that you might be interested in. I don't know what you understand by "lightweight" or how that has any relevance to what your constraints seem to be, so I can't really answer anything beyond that.
Are there any for C64 or Apple II? 
As a lisp beginner I struggle to understand how a real lisp program is written. By that I mean, how to setup a project, how to split it in chunks and later how to deploy it -&gt; best practices... Most tutorials out there seem to skip this part – which I don't get why they do so – it's a really important part. Is there a way to create a single binary? Assuming I would have to copy the lisp code over to a server, how would I make sure to have all dependencies installed? Would be awesome if you could make a video about that topic! Sometimes the hard part is not the coding, but to get a correct mental picture of what is going on/should be done.
Sir, i have zero idea :) I got to this after an impromptu twitter chad about CLOS metaobjects and all of a sudden that dude tells me he wrote his thesis on an amiga.
Easy, Gerbil. No need for nginx or other parts. Full static bins with no external dependencies, making it much easier to deploy.
Cool. I've wondered if a stripped down 8-bit Scheme would be usable with under a megabyte of RAM.
https://www.youtube.com/watch?v=_iCZrSE26yg&amp;list=PLqdXlyXtzjREcfqqwd3ezqwhdFrFZH5un Adventures in Common Lisp (Paradigms of Artificial Intelligence Programming) 
That takes me back. The Amiga 500 was the first computer I ever had (in the late 80s/early 90s) and I got a lisp for it (maybe xlisp) to help me with my AI degree course. Old school AI in those days - no machine learning, just lisp, prolog (lots of prolog in the UK, and Pop-11). Good times...
Very true. I'll have to so some research on this one as so far I've only be shipping libraries through quicklisp rather than products, however even in this simple stuff there is a few things that are probably video worthy. Thanks
As I said above, I got to see this through an academic. As absurd as it sound it was below the kind of machines I would picture when thinking of AI. Base cpu for an A1200 is 14MHz. Was it sluggish or acceptable ?
I get warm and fuzzies.
The computers we worked on in the university AI lab were early Apple Macs and so I only used my Amiga at home to do the class homework exercises. It was pretty slow but acceptable to play about with. That's what got me hooked on lisp though. 
Seems to have a very slow compile time though. Am I mistaken about that?
It's been ages, but I used to do a lot with Chicken Scheme. I usually didn't even compile the code, just ran it in interpreters. Performance was fine for small, low-volume applications.
Is hunchentoot still a go-to Web server for CL? What else is popular these days? I remember hunchentoot being a little big sluggish when I first evaluated it, but that was a long time ago.
Hunchentoot is still around and is being actively developed. I've used Hunchentoot recently for a project of mine, and found it to be fast and responsive. 
There's two new servers around that you might be interested in: * [Wookie](http://wookie.lyonbros.com/) is purely async based, and doesn't need any threading, so for people that like that sort of thing it might be a valid choice. * [Woo](https://github.com/Fukamachi/woo) is a high-performance server that uses both threads and async. It used to be faster than even Go's server at one point, though I don't know if that's still the case. While I did make my framework able to support any server as backend, I still use Hunchentoot for dev and production, simply because the loads I get aren't high enough for me to bother with Woo.
[Clack](https://github.com/fukamachi/clack) is a web application environment (à la Python's WSGI or Ruby's Rack), it uses Hunchentoot by default but allows to hook Woo and others, and some frameworks are built on it: [Lucerne](https://github.com/eudoxia0/lucerne), nice semantics, nice little example, [Caveman](https://github.com/fukamachi/caveman), more active, a bit inconsistent, they both come with DB integration and a templating engine, [ningle](https://github.com/fukamachi/ningle/) is more lightweight. See more: https://github.com/CodyReichert/awesome-cl#network-and-internet
I actually used Hunchentoot's predecessor, TBNL, a lot. I generally write my own handling system on top of whatever the web server is, anyway, so it doesn't matter much to me, and my volume isn't enough to make hyper-optimizing webservers worth investigating for me.
There is several LISPs that compiles to JS which can be executed in Node.js that is well known for being performant. Some of the are * [LispyScript](http://lispyscript.com/) -- Straightforward LISP to JS * [ClojureScript](https://clojurescript.org) -- Powerful but not very lightweight * [RamdaScript](https://yosbelms.github.io/ramdascript/) -- Powered by Ramda, I'm the author ;) Many features will break in future releases.
I initially learned Scheme and Common Lisp in 1988 on a Mac Plus with 1MB of RAM and a 68000 running at 8 MHz. I used MacScheme and Coral Common Lisp (which later became Macintosh Common Lisp, and is now known as Clozure Common Lisp). It was fine. Great, in fact.
Those were pretty slow, even back then. Were you running from 400k floppy, or did you have a hard disk? Pretty cool to know lisp ran well on it though. 
Haven't seen Gerbil before, but it looks very cool. A scheme oriented around systems programming is right up my alley. Though I'd probably continue using NGINX as a load balancer and for serving static resources. I mostly just need lisp to handle HTML and POST requests. I'm new to web programming, so I'm taking this as a learning opportunity (which, since I already have a static site up, I can take my time on). 
And you have many interesting Lisp projects: - [lisp REPL exploration cheatsheet](http://bnmcgn.github.io/lisp-guide/lisp-exploration.html) - Clath, Single Sign On for Clack: https://github.com/BnMcGn/clath - debugging and testing tool for Clack: https://github.com/BnMcGn/clack-pretend (coming in next Quicklisp) - https://github.com/BnMcGn/cl-npm and more. Great stuff ! (I put some on the Awesom-cl list)
Saw that. Thanks for the encouragement!
Clojure for the JVM is pretty nice, I'm pretty sure it was my first Lisp. I don't really like Java but being able to use the large standard library it has is nice 
We have to use Java at work... I'm going to be sending this to a co-worker who accused me off heresy after seeing my "Common Lisp: A Gentle Introduction to Symbolic Computation" book. :) We'll see how it goes.
So what are those that books ?
SICP, for scheme.
Paul Graham's Common Lisp books if you don't mind the idiosyncratic style.
http://random-state.net/files/nikodemus-cl-faq.html#which-book-should-i-read-first &gt;There are plenty of other books too, but these two are the best bets for starters. Land of Lisp isn't bad, but in my limited experience it can foster some misconceptions. If you start with it, follow up with PCL. I do not recommend starting with Paul Graham's books: they're not really up to date and do not foster good style in my opinion.
www.gigamonkeys.com
I started with Stuart Saphiro book, it is dated, but a great book.
[removed]
Like I’m going through Land of Lisp and plan to then do AI Paradigms by Peter Norvig. Is this the right path ?
Dear Baggers, In your last video you mentioned to attendees it was possible to ask questions and you mentioned some support topics at the beginning. Well , the time difference prevents me from watching the direct. ... My question is then : What appropriate channel should I use to ask questions about installation and tutorials ? Your little bit of Lisp series is quite nicely done, by the way. Thank you very much.
You know what? I'm getting pretty damn tired of r/lisp getting filled with this guy's videos. Seriously though it's already here and in common_lisp, I feel like I'm spamming r/lisp half the time as it is :p
Thanks. You can reach me in the video comment's on youtube, reddit, you can reach me about per project issues here https://github.com/cbaggers or email me (address is public on github) 
Simply Scheme is a really gentle intro, it’s free online [here](https://people.eecs.berkeley.edu/~bh/ss-toc2.html). Easiest way to setup the environment for it would be using ~~PLT Scheme~~[Racket](http://racket-lang.org).
scared me until I read your nick, now you're scaring me even more o_o /jk blame it on twitter
&gt; ~~Saphiro~~ Shapiro In the sidebar: [Common Lisp: An Interactive Approach] (https://www.cse.buffalo.edu/~shapiro/Commonlisp/) (1992)
Never read Land of Lisp. But PAIP is my favorite lisp book, excellent writer and excellent coder.
[removed]
Yeah, the rest of us ought to shape up and publish our own videos too!
The Racket Documentation has been helpful for me. &lt;https://docs.racket-lang.org&gt;
This kind of self-adoring bullshit is never helpful or constructive. 
[Programming Clojure](https://pragprog.com/book/shcloj3/programming-clojure-third-edition) and [Web Development with Clojure](https://pragprog.com/book/dswdcloj2/web-development-with-clojure-second-edition) are nice, *practical* lispy books if your target environment is already Java. You can introduce lisp ideas on a familiar platform, without having to throw away all the work you've already done.
What does this mean. What is code that a computer could write vs code it could not?
It means boilerplate; copy-pasted code; unrolled loops; etc. Code that would be easier to generate using a small program than it would be to write by hand.
Well it was not you publishing this or any of the other posts, it just means some people appreciate what you do and are willing to take the time to share it (like myself).
Only because it seems to be somehow related to the topic; Did anybody here ever tried [linj](https://github.com/xach/linj)? I did read the documentation which is very good, but never tried to write anything with it.
Chicken is fairly nice for the backend. Frontend is always the annoying part. I guess parenscript wins in that case.
Land Of Lisp will make you lost. Wimpie Nortje tell why that happened. [Should beginners read Land of Lisp?](https://www.darkchestnut.com/2016/review-land-lisp-beginner/) I read PCL, Succesful Lisp and A Gentle Introduction to Symbolic Computation. I also peek to Ansi CL by Paul Graham. 
wow, this is what I need. Thanks lot Maufdez. I often explore Xach's repo, but why I don't find this. Thanks.
It's true, I also happy to share these videos to my colleagues 
Calm, at first I also suprised when talking with Baggers. But that's the way he jokes. McCarthy also has unique sense of humor.
duplicate, but still get so many upvotes. https://www.reddit.com/r/lisp/comments/7e8l9i/little_bits_of_lisp_short_and_sweet_video_series/ Thanks lot, Baggers.
it's mostly that read as an anonymous it triggered my internet arguing anxiety. Otherwise I don't mind this humor at all
I'm also especially curious about that note in the Babel project about using possibly incompatible licensed code. Secondly, how does one release a commercial binary for profit using Common Lisp, game or not, with such a small ecosystem, and a handful of not so permissive licensed software pulled in the dependency graph of any significantly large Common Lisp codebase?
Most (nearly all) FOSS licenses are entirely untested in court. I wouldn't be too alarmed about that. Even assuming everything's licensed under something as strict as the GPL, you can still distribute binaries; lots of GPL'd FOSS projects do this all the time. You just need to be able to provide the source code upon request (and do the various other things stipulated in the upstream license, but providing source code and allowing modifications is the big one). I say "just" here because I personally don't see a practical issue with releasing the source code for the game itself, or even releasing it under a FOSS license. With games, it's usually the assets that "necessitate" a non-free license (though Lisp certainly makes it tempting to blur that distinction). It's worth additionally noting that it's usually possible to use your Lisp's specific FFI implementation instead of relying on CFFI. This doesn't help the situation with libraries/packages already dependent upon CFFI, but it does help for any native wrappers you're writing yourself. The downside is that you have to write to a specific Lisp implementation.
&gt; Most (nearly all) FOSS licenses are entirely untested in court. I wouldn't be too alarmed about that. That's misleading to the point of being dishonest: the license gives you permission. Copyright law still applies. If the license were ever deemed invalid (it won't be) then you don't have permission to use the code at all. &gt; You just need to be able to provide the source code upon request That's wrong. GPL requires you to provide in the same way the binary was provided, not on request, not on sending them a floppy disk. The same way you provided the binary. 
I think you have three options: 1. Take the risk. Although GPL copyright holders are getting more assertive in enforcing their rights. 2. Hire a lawyer experienced in FOSS licenses. 3. Pay for a commercial Lisp, like Allegro, and the get the support you'll need for a commercial product. 
Well, yes. Though a good way of reducing the risk in 1. would be to gather experience of people who already did 1 or 2, if they'd be willing to share it.
&gt; Most (nearly all) FOSS licenses are entirely untested in court. I wouldn't be too alarmed about that. That's misleading to put it mildly: the license gives you permission. Copyright law still applies. If the license were ever deemed invalid (it won't be) then you don't have permission to use the code at all. &gt; You just need to be able to provide the source code upon request That's wrong. GPL requires you to provide in the same way the binary was provided, not on request, not on sending them a floppy disk. The same way you provided the binary.
Occasionally legit submissions get caught up in spam filter. This then requires a human moderator to review them and allow them post. I've removed the original submission because there are already comments here and having a duplicate submission would just dilute the discussion. In future please have a bit more patience and message the moderators before pointlessly posting duplicate submissions.
&gt; That's misleading to put it mildly: the license gives you permission. Copyright law still applies. The same can be said about all the ad-hoc EULAs and business contracts floating around. The point of my answer there is that the idea of a FOSS license being untested in court is specific to neither Lisp nor game development. Lots of FOSS-dependent companies with much higher financial stakes use a plethora of software with licenses that have yet to go through the judicial wringer. They seem to be doing just fine. &gt; That's wrong. That's right, actually. If you don't believe me, double-check Section 3 Paragraph B of the GPLv2 (or Section 6 Paragraph B of the GPLv3). Distributing binaries without source code is perfectly fine provided that said binaries are accompanied by a written offer to provide the machine-readable source code upon request. Most GPL'd software just ships the source code alongside the binaries for practical reasons (i.e. because it's a lot easier to put up an FTP server than it is to respond to a bunch of written requests and send out physical media). But - again - my point was that even the GPL allows you to make binaries so long as you provide source code as well (whether on request or alongside the binaries), and that for game development purposes there's not really much of a practical reason for a Common Lisp game engine to be closed-source (and in fact might even be a hindrance in this day and age of modding).
I apologize. It's literally the first time ever I had a Reddit post autoremoved, so I mistakenly assumed I was shadow-banned and asked /u/mfiano to repost it for me. I promise to have more patience in the future :).
I havent spent much attention to licences. thanks for lighing up this issue. i am ready to make all of my code to MIT.
You replace the dependencies, or contact the authors to get them to either change the license or give you explicit permission to use it. The latter cases being difficult if the project has multiple contributors, because you'll need to get all of them to agree. This isn't anything specific to Lisp, and applies to all software projects.
It is really good to see CMUCL is still alive and kicking. I like CMUCL very much.
[removed]
Clozure CL is now distributed under the terms of the Apache License, Version 2.0. This has been the case for at least a couple of years now. See https://ccl.clozure.com. (I'm not currently employed by Clozure Associates, but I am a Clozure CL maintainer.) 
If you have a transitive dependency on GPL (without "library" clause) you are obligated to release source code of your software. In case of LLGPL I don't think there is much to worry, the "court" argument may be applied to most licenses. This one is pretty clear. From my analysis LGPL is perfectly fine too without the LLGPL clarification which is redundant (but I'm aware that different interpretations exist) – sloppy wording taken from C world is more about technical details than a license meaning, and I strongly believe that's what is tested in (unlikely) case in court. As of Babel, since the "original" source is licensed under Apache 2 now, then this file imposes restrictions mandated by this license. But as I've mentioned, LLGPL isn't a problem here, because you use it as a library and if you don't modify babel itself, you have no obligation to release your code. All that said, please do! Having source code is better ;-)
So much wrong... I'll leave you to it. 
Why make this a git repo instead of a wiki article? Honestly wondering you reasons, if you considered it. 
I setup Chicken at first but had trouble running on it on my VPS (running Debian) for some reason. I'm too lazy to figure it out right now, but maybe I'll go back. I love Racket, too, but I'm not sure what the performance would be like in production. (Anyone have experience with it?) I'm probably way overthinking my performance needs, but I'm using a cheap server right now &amp; would prefer not to have to upgrade. For frontend, I'm fine w/ Javascript. I don't use much client-side scripting, anyway. (Everything on my current setup is server-side, but I'll probably need to use some JS since I want to add an admin page.) There's honestly too many options these days. Feel like when I started with LISP CL was pretty much the way to go (&amp; I switched to it from Visual Basic, LOL). Now there's Racket, Chicken, Guile, Pico, Gerbil, Clojure, Arc, Hy etc etc. Not to mention interesting things happening in the CL world.
As the first thing I can help for the community, I added a new `-l / --license` flag to `asdf-viz` which shows the system license in the output. Sample output below: https://github.com/guicho271828/asdf-viz#asdf-viz--visualizing-the-library-dependencies-of-asdf-systems
Don't like that here focuses on 'parentheses', while parentheses are a part of s-expressions and the usual habit to represent Lisp programs as s-expressions. The other choices are to represent Lisp programs in some other data syntax or not to use a data syntax at all (which most programing languages do).
&gt;But - again - my point was that even the GPL allows you to make binaries so long as you provide source code as well (whether on request or alongside the binaries), and that for game development purposes there's not really much of a practical reason for a Common Lisp game engine to be closed-source (and in fact might even be a hindrance in this day and age of modding). The question on my mind is: given the way Lisp systems work, if I use a GPL-ed game engine for my game (or otherwise acquire an accidental transitive dependency on GPL) and want to provide a binary (which would naturally contain in it the GPL code), what source must I provide? That of GPL-ed dependencies? Of my whole game? 
The “Try Zmacs” link is intriguing. 
Are CMUCL devs still tracking SBCL bugs? There's some commonality remaining even after all these years.
Thanks, I do really appreciate all the support I've been getting. This is just my in-built british self deprecation firing on all cylinders.
Neither paragraph does either such thing. Again: read them. Again: recall that the GPL comes from an era before it was practical to always ship the binaries and source together. Again: recall that virtually every GNU/Linux distro - including those endorsed by the FSF, the *authors* of the GPL - ships binaries separate from source code. GPLv3 does explicitly state that the binaries must be distributed in a physical medium (e.g. a device running the software, or a physical storage device like a CD or flash drive) for Paragraph B to apply. Plenty of games out there are indeed distributed as such. For digital distribution... well, if you're able to convey the binaries, there's no real reason not to also convey the source code on the same server (or a different one, even). GPLv2 does not include any such restriction. Even exclusively-Internet-distributed binaries can still be accompanied by that written offer. As for Paragraph C (in which license version? They're slightly different, and you don't specify, though they have the same intent), it does not invalidate Paragraph B at all. It only states that for noncommercial redistribution of binaries for which you already have a written offer for the source code (in compliance with Paragraph B), you may in turn pass along a copy of that same written offer to the recipient 
Naggum's approach is fine. Another is to use `ALEXANDRIA:SWITCH`. Yet another one is to write what you want to express without thinking about code, then writing an "engine" to do the interpretation/translation.
if you have dependency on GPL, you have to provide source of your game. LLGPL changes the situation drastically, you are not obliged to publish your source code. If you modify original LLGPL library, you have to provide sources of this modified library.
The LLGPL is just the LGPL with an additional exception to allow static linking. For those, you'll only need to provide the source for the LLGPL'd dependencies. For full-blown GPL'd dependencies, meanwhile, you'd have to release the full source for the game (or at least whichever parts can be considered a "derivative work"; if you're writing a multiplayer game, and the client has GPL'd dependencies while the server does not, then only the former would probably need to be under the GPL unless it can be proven that the server is a derived work of the client). This leaves the LGPL, which is tricky (and that trickiness is why the LLGPL exists). Lisp doesn't traditionally have a concept of dynamic linking, and static linking would require your whole binary's source code to be released. LGPL is still viable for Lisp implementations which *do* implement dynamic linking, or for projects where you're using an FFI mechanism to dynamically link against a LGPL'd library, but otherwise it has the same ramifications as the GPL. So yes, the LLGPL changes the situation dramatically in favor of being able to release binaries without source code (or an offer thereof). Of course - like I said before - I don't exactly sympathize with this strange need to make a game closed-source. Just provide the source code. Your players and modders will thank you for it (in the form of buying your game, knowing full well that even if your company goes belly up they'll still be able to improve it).
Working on your server-side code in the CL live-image is sometimes really a boon - and something I could not find even remotely matched elsewhere -, but using its full feature-set and Slime on top can also be overwhelming if just for a hobby project with a few hours here and then. For more lightweight tasks - mentally and resource-wise - I learned to like Bigloo Scheme and Kawa Scheme a lot. Bigloo for standalone executables and Kawa for the JVM (Bigloo also supports the JVM, but for some reason I like Kawa more here). Both are quite old Schemes - R5RS more then R7RS - but both with many extensions, where e.g. both support optional typing which I find very helpful. And even if SBCL today gives you quite good type checks, Bigloo and even more Kawa do really a good job here. The Java-integration of Kawa is sometimes a little bit idiosyncratic, because it has some history of differing syntaxes, but that just needs some ramp-up time - and you then also have the full Java world available. And even if you do not like most of that world, starting servlets in the battle-tested Jetty-server with a few lines of Scheme is not such a bad argument. With Bigloo you have a very nice C-API and also a lot of built-in functionality - and if you want to check its maturity for HTTP-server-side development, just check the Bigloo-based Hop-server. Also Bigloo is usually at the top of Scheme performance benchmarks, in case that's interesting for you. The really sad thing is that in both cases you will only find a very small community, so you have to find out most things on your own - none of the Schemes come close to Clojure in that respect. HTH and good luck with your project!
&gt; not to use a data syntax at all Why would you do that? The whole point of Lisp is that the code is data.
Originally it was not designed that way. The implementation used it as a hack.
I don't understand the problem. Are you saying you don't want to follow the conditions of the licenses? That would be the only reason you would have a problem. For software that has to be Copyleft because it derives from other Copyleft code, you can provide the source separately from the binary. You just do have to provide it.
Allowing brackets and braces to be used also, even when they have no special semantics, helps quite a bit with readability without changing the syntax much. Not sure which implementations do this but I know Racket does. (Clojure uses them but they have special semantics for indicating data types other than lists, like vectors.) Here's one I think you missed http://readable.sourceforge.net/ (Sweet)
Not only are you completely wrong and completely incapable of reasoned discourse on this topic, but now you're being a jerk as well. You're the only one "hopelessly confused" here. Stop being a jerk.
PS : This is not my repo. if you checked it. It belong to Shaun Lebron, the creator of Parinfer. Since It's get many answer here, I will make an issue there to make him noticed.