Oh dear. I'm not sure, but I'd hope for a nice equivalent to alists, since JMC's evaluator uses those from memory.
That's only about how objects and classes can be implemented (disregarding that it's a bad way). You don't need defclass for defining classes either, there's (make-instance 'standard-class), but it's tedious and unwieldy. 
As far as I can tell, Clojure `cons` takes an element and a list and adds the element to the front of the list. So Clojure `cons` will not accept two non-list elements as its arguments.
Maybe there's a tuple type that can be used for the inner conses? I've never written any Clojure, so I wouldn't know, but surely there's an equivalent for making functional maps.
Who are you referring to by "they" ?
I see, so cons is like the simplest list container data structure that adheres to functional programming essentially? I wonder if there are many lisps without gc 
Yeah, conses are pretty damn simple. I wouldn't count on any Lisps to not use a garbage collector; they're much too useful for programmers. [I don't believe you should be striving to throw out useful tools in the name of minimalism, either.](https://www.reddit.com/r/socialistprogrammers/comments/ax407x/on_masochist_programming_or_whos_doing_the/)
Everything can be implemented in closures, as it is turing complete (with lambda implementing church numbers etc), but it is just impractical. The rest is my thoughts on the taxonomy of CL macros. There are some type of macros that I believe better be implemented in combination with OO methods, but methods are not the silver bullet. Nonetheless there should be some contract between the language and the programmer. What I think might be possible is the extension of `defun`, similar to `setf`, combined with OO. Some `with-*` macros are used for resource/context management and can be implemented with methods, as in trivial-garbage's `finalize` method (for heap-allocated/indefinite extent objects) and python's `__enter__`, `__exit__` methods (for dynamic extent objects). The drawback to this approach is that it always assumes CLOS objects, and could be slow. For example, you might not be able to bind a foreign pointer and release it without boxing the pointer in an object. There should be a way to combine them nicely -- I think of an analogue of `defsetf` where you will define a function for releasing an object, e.g. `(defun (release cffi:foreign-alloc) ...)`. `with-*` macros will automatically call them when exiting the dynamic scope. The dis/advantage of pairing a constructor function and a deconstructor function this way might be that the dispatch is done by a syntactic means rather than a type. Since it is purely syntactic, it might make it difficult to compose functions. There are other types of `with-*` macros that locally provides a set of language extensions, like `with-html`. I hope some distinctions to be made between them in terms of naming conventions. Iteration macros could be combined with `next` methods as in c++'s `operator+` and python's `__next__`, but again it might have some limitations when dealing with raw objects. I could think of something like `(defun (next list) (l tmp) (values (cadr l) (cdr l))`, `(defun (next vector) (v tmp) (values (aref v tmp) (incf tmp)))`, where `tmp` is a temporary value held during iterations. Note that this is not dealing with types and is therefore purely syntactic, similar to the case for `with-*`. There are other notable groups of macros: `def-*` macros are simply a slight modifications of `setf`. Notably each `(def-X name ...)` macro globally assigns some object in a named entry `name` in some category `X`. There are two ways to implement this group of macros: Via hashtable, or via symbol-plist. I went with hashtables in [lisp-namespace](http://quickdocs.org/lisp-namespace/). Macros as an alias and for easier compiler/syntactic handling. `lambda` is a macro that simply compiles to a special form `(function (lambda ...))`. Quasiquotes in `fare-quasiquote` that are expanded from the reader macros. Macros for code walkers, that want to handle `&amp;environment` variables, e.g. those in Arnesi, macroexpand-dammit, hu.dwim.walker. Another example: `(defmacro sb-kernel::new-instance (type) `(allocate-instance (find-class ',type)))`. They are not meant to provide programmers any convenience; it is meant to make it easy for the next step in a multi-stage compiler to recognize the pattern more easily. (Same technique was used for implementing `:trivia.balland2006` optimizer.) The rests are the following: * Conditional branching and deconstructing macros --- superseded by pattern matching macros. * Utility macros. For example, `with-gensyms`, `with-unique-names`, `once-only`. Anapholic macros. Combining simple operations, such as `xor` in alexandria. Random binding. * Inlining macros for optimization --- bad way to use macros. They should use compiler-macros and inlined functions instead. * Debugging, testing and printing macros. `assert`, `check-type`, `fiveam:is`, `log4cl:log`. They need to see the input form. * Macros for top-level forms esp. readtables. * Macros for making REPL/SLIME completion available for the embedded language. When used outside the expected scope, they just signal an error. Macros are appropriate because it can signal errors in compile-time. * Modification macros defined by `define-modify-macro`, and also a group of `fluid-binding` macros e.g. `metabang-bind:fluid-bind`, `fare-utils:fluid-let*`, that sets and restores values. * Lazy evaluation, async, parallel, coroutines --- could be categorized in the DSL extension, though.
Perhaps, but it would suggest that Clojure lists don't really have the same structure as lists in other Lisps.
not all lisps work well with symbolic links, especially on Windows.
I only use `~/quicklisp/local-projects` for modified quicklisp libs and some non-quicklisp libs that I downloaded. My main workspace is `~/lisp` (or `c:/lisp` on Windows). It's configured using the `:tree` option of [ASDF configuration](https://www.common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems). Because it uses ASDF under the hood, `ql:quickload` is still able to find my systems!
Why the downvote?
Huh. TIL. Haven't had any issues so far, but I'll keep that in mind. 
what parens ? I don't see no parens
seems like only the ogg video stream is working..
I think you're putting words in their mouths a bit? Well, maybe. There's also a bit of a rule of thumb in lisp "don't use a macro when a function will do". But people can and do leap prematurely to macros in lisp, then it's easy to look at some pointless macro that could just be a function (which unfortunately describes a lot of simple "example" macros) and say "surely this could just be a closure". Another poster has already outlined a bunch of cases where macros are interesting, but outside observers often run into the "(defmacro hello (x y) (+ x y))" class of example macros and don't really "get" them. This is particularly common in people new to a language, trying to use the interesting features (which is *disastrous* in e.g. c++ projects, because c++ is such a mess). Basically, don't use macros in lisp just because they're cool. If you really want a language where everything's a macro, try the venerable m4 (well, that's a somewhat different kind of "macro", but it's still [amusingly insane](http://mbreen.com/m4.html#toc19) to use. The fact it's the basis for autotools despite the insanity is just gravy).
I much prefer a real implementation :) [http://feeley.github.io/gambit-in-the-browser/](http://feeley.github.io/gambit-in-the-browser/) Having said that, it's because I program in lisp all the time, for a living. Wasp seems like it is made for someone who uses C and knows little of Lisp beyond what they were taught in '58 :P
I was more about how fare can a FP language can go without really needing lisp macros. 
Macros are just compile-time programs, that is, language specific constructs. Comparing them to closures is like comparing apples and oranges. 
related: https://github.com/Arboreta/arboreta-wasm wasm tooling for CL
Template Haskell is such a weird thing. Bust in the end it's mostly just Lisp macros bound in Haskell's type system.
I‚Äôm the author of this library! It was fun to make. I‚Äôd appreciate any suggestions.
I wanted to say thank you for making weblocks available via your ultralisp site. Finally got it working! :) 
Love your website. That makes it so nice and convenient.
The author PMed me, and indeed they know very little Lisp.
Here's a link: https://www.orinrin.land/lispm/
Look...we talked about this yesterday, it's hardly a Lisp, and your style is a bit crap. I can relate though, I tried to make a Lisp compiler when I just got into it, but that's not a good way to learn, and I think you should study up more before trying to write all this. I've tried to get my head around [LiSP](https://en.wikipedia.org/wiki/Lisp_in_Small_Pieces), which describes a few ways to compile programs.
**Lisp in Small Pieces** Lisp in Small Pieces (Cambridge University Press, 1996 ISBN 0-521-56247-3; paperback edition (December 4, 2003) ISBN 0-521-54566-8; translated by Kathleen Callaway) is a book by Christian Queinnec on Lisp, Scheme and other related dialects, their interpretation, semantics, and compilation and contains code for 11 interpreters and 2 compilers. The English title is a kind of recursive acronym (Lisp in Small Pieces). It was originally published in French by Inter√©ditions with the title Les Langages Lisp. The revised edition, published by Paracamplus, bears the title Principes d'implantation de Scheme et Lisp, another acronym based on the cover layout which orders the title as the following list '(Lisp Implementation Scheme Principes).This book is available in English from Cambridge University Press, the French version is available at Le Monde en Tique, a Parisian bookstore. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I've worked on this project for only a month and my goal is an extremely minimal lisp and self hosting. 
I like that you are actually doing something in wasm, I would like to see ECL or SBCL compiled in WASM, but I won't do the job myself, so I cannot criticize somebody who is doing the job. Having said that, with the experience you generated doing this, probably you could try [make a lisp](https://github.com/kanaka/mal)
I'm enjoying what i'm doing, and learning quite a bit. I think i'll see where it goes.
&gt; criticize somebody who is doing the job. Having said that, with the experience you generated doing this, probably yo Thanks man, I think my most immediate dream is to get this thing self compiling. It actually helps that its quite minimal. Once I get that done, i'll have to reflect on where to take it next :)
I just checked make a lisp, and somebody already did it in web assembly using wam, I haven't checked that project in a while. I don't particularly like MAL, but is a way of learning how to make a lisp, I think it would be worth doing a Common Lisp, or a Scheme (I'm a common lisper but Scheme is great and is a lot simpler).
interesting!
Can you provide evidence of this?
`snake_case` is very unidiomatic for Lisp, and I'd rather not disclose any PMs since the author was looking for advice, and it'd be rude.
To use the name "Lisp", a language should not just be Lisp like, but actually support syntax made of nested lists made up of cons cells that may be constructed with a *cons* function, which have a *car* and *cdr* field, and where if the *cdr* field contains the symbol object *nil*, that terminates the list. Speaking of which, there should be symbols as a data structure, and symbol tokens that undergo interning. The symbol *nil* is the empty list, and false. Conses are mutable and support *rplaca* and *rplacd* functions. The function *atom* tests an object, returning *nil* if the object is a *cons* cell, and the symbol *t* otherwise. Languages not conforming to this may be very fine; just don't call them Lisp. Don't put "Lisp" in their name, please, and don't claim they are Lisp dialects in your primary documentation and landing pages. 
Thanks for feed back! I‚Äôll look into these things. It‚Äôs been an interesting thread of thought around what is a ‚Äúminimal lisp‚Äù.
If you can't provide any evidence that discredit the author's lisp abilities then I am not inclined to believe your slander against said author.
Though I think your correct but the person sharing the link and the person developing this app deserve a little nicer wording. You just capped on their post. 
weblocks website?
üñï
I was being nice with words. I won't get into details about why I've decided to be nice and not critical. Programmers look at code and language use. Or: "I think you are correct", or "I think you're correct" are both correct English. "Though I think your correct but" begs the question: My correct what? did you mistype "butt"? I mean, it's a nice one, but I usually don't get hit on by men in reddit groups. I respectfully decline sir, you are not my type. &amp;#x200B;
Additional comment: In LOL, Hoyte mentions the idea of *duality of syntax* couple of times. SETF provides a duality between readers and writers. Pattern matching also provides a duality between constructors and destructors. The first case of `with-` macros, if turned into a `defun` extension, will become another duality between constructors and deconstructors. 
The language reminds me of Clojure. Do you plan to maintain some compatibility with that language? I mean... if wou plan on investing some more serious effort into this wouldn't it be good to be able to support some of the existing libraries out there?
Unorthodox stylistic choices =/= lack of knowledge.
That was a blast from the past! Thanks
&gt;Yah, I‚Äôm still getting down with the lingo, I‚Äôm an admitted cargo cult lisper &gt;I know the principles, just not the language &gt;So I copied clojure language
Wow, that's very polite of you.
No, generally people with bad stylistic choices are unknowledgeable.
I‚Äôll post where I please. You were being unpleasant, and I responded in kind.
Do you even understand what OP did, and why I think they are being misleading?
I wrote a list processing library that conserves cons cells, but doesn't collect them. Every time a cell is disposed it goes into a pool (a list of unwanted toys if you will). New conses draw from the pool before allocating more pages. Not GC proper, but not wasteful either. 
I just tell people I can't use python because my algorithms critically depend on having a `switch` statement. 
I could definitely see a memory allocator optimized for conses. I‚Äôm right now thinking about region allocator.
That is just a slice of text. Provide a link to where they said that or a screenshot.
Again, they said it in my PMs. [Here is a screenshot.](https://imgur.com/jFSv7oC)
The concepts are really orthogonal. Macros are there to work with program's code, to create or rearrange it, was that code functional? imperative? logical? some other paradigm? -- probably doesn't matter.
I wasn't really curious about paradigms, mostly about the need at the computational level. 
Clojure is not a Lisp so this is to be expected. It doesn't run Lisp code without heavy modifications that go beyond syntax and alter the logic and semantics of the program. Thus not a Lisp.
But there still is no hope for threads, right?
&gt; I would like to see ECL or SBCL compiled in WASM +1 me too. And actually I think compiling the CLISP bytecode runtime would be good too. So you can develop in CLISP, compile to bytecode, and have the bytecode run on the WASM VM. 
&gt; I think my most immediate dream is to get this thing self compiling see `schism`, self-hosting Scheme compiler written in WASM. 
Yep, it‚Äôs cool stuff. My goal isn‚Äôt scheme, I‚Äôm brainstorming something different or at the very least useful for me.
&gt;then I am not inclined to believe your slander So disclosing a chat with the author, who tells he doesn't know too much about lisp, is slander?!
&gt;useful for me. &gt;Yep, it‚Äôs cool stuff. My goal isn‚Äôt scheme, I‚Äôm brainstorming something different or at the very least useful for me. That's ok, but my suggestion is, try to take a deep look at Scheme, Common Lisp, and maybe PicoLisp too, because to learn how a language is implemented, first you need to understand the language in depth. For example Scheme implementations will need to be designed for tail call ellimination, and efficient continuatuons. Common Lisp implementation will have special provisions for CLOS (many CL implementations are "objects all the way down") and MOP; they will also have special tweaks for FFI with C, like being able to pin objects (i.e. arrays) in memory. All two above need closures and lexical scoping, PicoLisp is a Lisp without lexical scoping (afaik) and far easier to implement. 
This I can admit as evidence. Thank you.
Sorry about that guys attitude, i think its great to see new folks getting stuck in. There's definitely a learning curve to lisp family of languages (cons cells, recursion, macros, conditions, continuations etc) but there's so much good learning material out there, and a lot to gain out of it, in my opinion. Keep doing what you're doing!
Interesting! I think almost none of the Common Lisp code I've written mutates conses. So it would also run in the non-Lisp language you get by removing rplaca, rplacd, (setf car), etc. from Common Lisp ---maybe we should call that language Common Non-Lisp, or just Common. That language still feels pretty Lispy to me... But if you also took away arrays, then it would definitely feel different, since then it would feel like it has poor support for imperative programming. And if you keep mutable cons cells but remove arrays --that would still be a Lisp!-- I guess I'd either start mutating cons cells or, more likely, still feel it didn't have good support for imperative programming
I agree it's more of a C idiom. Do you ever rely on the return value of a setf form? I think I occasionally do when it is the return value of a function, for example, storing something in a has table and also returning it. But I think I've never put an assignment in the condition of an if or cond, even though I would do that in C.
Thank you for kind words!
As much as I enjoy the name being a portmanteau of the author's nickname and another widely used Common Lisp library, I think it's terrible from the usability point of view since I immediately confused it with Alexandria.
Thanks for the feedback. From the usability point of view I was thinking to add \`(:nicknames :lerax)\` for the \`leraxandria\` main package. That way it would can be used as \`(lerax:primep 7) =&gt; t\`
Yep, it does sound better.
Boah, again there is a lot to improve. Let's have some look: (defun string-char-map (string) (let ((alist nil)) (loop for x across string if (and (last alist) (eq (caar (last alist)) x)) do (incf (cadar (last alist))) else do (setf alist (append alist (list (list x 1)))) finally (return alist)))) What's wrong with this function: * it lacks a documentation string * the name does not tell me at all what it does * characters are being compared with EQ. That does not work in general. Use EQL. * Three times walking with LAST through the result list - when lists in Lisp are singly-linked lists -&gt; **never walk through a list repeatedly in a loop** * APPEND copies the result list for each iteration to cons to the end. -&gt; **never use APPEND in a loop like that** * there is no reason to name the function string specific. The function should work for all vectors. &amp;#8203; (defun join-char-map (char-map) (apply #'append (mapcar (lambda (x) (if (= (second x) 1) (list (car x)) x)) char-map))) * never apply a list for a list operation. APPLY is for calling functions, not for list operations. APPLY is limited by the number of arguments allowed by the implementation (see the variable CALL-ARGUMENTS-LIMIT, which is just 50 in ABCL). * use LOOP or MAPCAN * given that there is nothing character-specific in the function, it is hard to see why it should have CHAR in its name. example: (mapcan (lambda (e &amp;aux (c (car e)) (n (cadr e))) (if (= 1 n) (list c) (copy-list e))) '((#\a 2) (#\b 3) (#\c 3) (#\a 1) (#\d 3))) &amp;#x200B;
&gt; (defun string-char-map (string) Wow, just 15 minutes ago I was writing a function to do exactly the same (find the frequencies of characters within a file), and my implementation was radically different, including arrays: ``` (deftype tchar () 'character) (deftype tbyte () '(unsigned-byte 8)) (defparameter *chunk-size* (expt 2 20)) ; 1MB of chunk size (defun make-buffer () (make-array *chunk-size* :element-type 'tbyte :initial-element 0 :adjustable nil )) (defstruct (status) "Status of detector." ;(ht (make-hash-table :test 'eql) :type hash-table) ;; used for histogram (bins (make-array 256 :element-type 'fixnum :adjustable nil :initial-element 0) :type simple-array)) (declaim (inline process-byte)) (defun process-byte (ch status) "Process byte for histogram" (declare (type tbyte ch) (type status status)) (when (&lt;= 0 ch 255) ;; incf the bin in one. (incf (aref (status-bins status) ch)))) (defun histogram-binary-file (path) "Histogram. Process the whole file as binary file" (declare (inline process-byte)) (let ((s (make-status)) (buffer (make-buffer))) (with-open-file (str path :element-type 'tbyte) ;; read the whole file??? no... do it in chunks... (prog (res) init ;; read buffer... (setf res (read-sequence buffer str));returns length of read sequence ;; apply process (loop for i from 0 to (1- res) do (process-byte (aref buffer i) s)) (when (&gt; res 0) (go init)) ) ;; return status s ))) ```
With a nice feedback! Thank you. Do you mind open a issue with this suggestion? I can copy paste your feedback, but indeed this is useful. Thanks!
about the string-char-map that has a little about history, in past the repo was just a collect of random things I write, string-char-map was only a function I made to solve this HackerRank problem: https://www.hackerrank.com/challenges/string-compression/problem
haha, how you solved efficiently? hash-tables?
&gt; haha, how you solved efficiently? hash-tables? Make an array of fixnums of size = 256 bins. For each character in range 0 to 255, we count the occurrence of the character. So for example (aref x 32) would give you how many times the space (character 32) appears. I'm not considering unicode or extended characters because I don't need it for this analysis. I pasted the code here, but I prefer posting it later when I have a complete library.
NICE!!!!
No more need for issue creation, I just create a reference for you comment: https://github.com/ryukinix/leraxandria/issues/6
I agree with all your comments and improvements except for the name `create-items-map` which I still find non-descriptive. I'd suggest `frequencies` or `count-occurrences` or something like that.
&gt; NICE!!!! Thanks, I'll make sure to notify you as soon as I publish it. Note: Efficiency in Lisp, in my opinion, is often basically doing the following: using arrays, avoiding consing, using fixnums, using buffered reads, enabling the optimization directives, and (if necessary) using threads. 
And you get a utility library! And you get a utility library! And you get a utility library!
If you love coding more than documenting that much, then just implement every function twice, and say that the one does whatever the other one says, and *vice versa*; and if the two disagree on any input, then the behavior is to be considered unspecified for that input. 
&gt; *it lacks a documentation string* It lacks a documentation string, external specification, and input/output test vector pairs. There is no way to know whether the function is doing anything right or wrong, since no aspect of its behavior is specified anywhere other than its source code. 
right. the name could be improved. But frequencies of count-occurrences isn't really explaining it well. It's just some encoding of a sequence by item and number of occurrences. Note that the map may have several entries for the same item: CL-USER 65 &gt; (create-items-map "aabaa") ((#\a . 2) (#\b . 1) (#\a . 2)) 
Why not just Dyslexandria. 
General comment here: It makes me happy to see a discussion like this. I find that oftentimes I learn more in the comment sections than anywhere else. Cheers.
Yes, I really like too! Thank you for lispm discussing with so much detail! I loved, today I learned a lot.
How about histogram?
Hahahah, I don't know if in this message it sounds good or bad... I hope this can be useful for someone.
Oh, I hadn't read the code carefully (or tested it). The standard name is "run-length-encoding", then.
As /u/lispm pointed out the behavior for non-consecutive repetitions make all these names inappropriate. The usual name is "run-length-encoding".
outch, this is true.
Even I forget about that, truly string-char-map is a horrible name.
Clojure is as much of a Lisp as much as a cat is a catfish, so it makes perfect sense for Clojure to be "popular" while Lisps aren't popular.
Care to back this up with an argument?
IMO, Clojure reveals too much of its gorey JVM internals to be a nice Lisp. The naming conventions are the same as Java, and some features like [polymorphic arithmetic](https://www.reddit.com/r/lisp/comments/acid7a/how_innovative_is_clojure_as_a_lisp_dialect_from/ed8ngii/) are the exception, not the norm. The syntax is whack too.
I learned a lot once again. Thank you, your critique is always so instructive.
I would say naming conventions don't define a lisp as being a lisp. I'd say source code being lists is what defines a language as being a lisp.
A decent part of Clojure isn't lists though.
Bad Lisps are more popular than good Lisps, just like Java and C++ are more popular than Smalltalk, and Scala is more popular than Haskell. Conclusion: people don‚Äôt want good things. They want the comfort that comes with their tools being as shitty as their programming. The gory JVM internals. The broken tooling. The incoherent language features. It‚Äôs a reflection of their mind and what they tolerate in it. 
I also would be interested in your library. If it is all right, would you please let us know here on /r/lisp?
Could you give an example? i'm not particularly familiar with clojure
People like half-measures and that‚Äôs what Clojure and ClojureScript provide. One foot in Lisp and the other in the standard, the popular, the major corporation backed, average Joe programming world. Although they really shouldn‚Äôt be called people and only circumstantially deserve the name programmers. 
`(let [a 2 b 3] (+ a b))` Not only are we using literal vectors for let-values, it's arranged like a property-list. Eugh. A new one I heard is that `(cons 'before list)` is not actually making a cons, it is just putting a value before the rest of a list, like a linked list in any ML.
Indeed, worse is better, and it works even better for the newbies who don't want to get better.
I'd say that's similar enough to still be quite lispy, but i do see what you mean.
McCarthy didn't write Lisp then? Here is a Lisp function from one of his [classic papers on Lisp](http://www-formal.stanford.edu/jmc/recursive/node3.html): evcon[c;a] = [eval[caar[c];a] -&gt; eval[cadar[c];a]; T -&gt; evcon[cdr[c];a]] which with one can also write as: (defun evcon (c a) (cond ((eval (caar c) a) (eval (cadar c) a)) (t (evcon (cdr c) a)))) There are literally countless languages which then would not be in the wider Lisp family of language. A few examples: This is a Lisp function in RLISP: symbolic procedure detq u; % Top level determinant function. begin integer len; len := length u; % Number of rows. for each x in u do if length x neq len then rederr "Non square matrix"; if len=1 then return caar u; matrix_clrhash(); u := detq1(u,len,0); matrix_clrhash(); return u end; This is a class definition in Dylan: define class &lt;vehicle&gt; (&lt;object&gt;) slot owner :: &lt;string&gt;, init-keyword: owner:, init-value: "Northern Motors"; end class &lt;vehicle&gt;; The same in CLOS: (defclass &lt;vehicle&gt; (&lt;object&gt;) ((owner :type string :initarg :owner :initform "Northern Motors")) Making parentheses the only and necessary definition would excluded languages which could claim to be Lisp as much or more than Clojure, including McCarthy's own first definition of Lisp.
honestly, m-expr weren't what made lisp lisp.. people kept sexps, that was the funny part of lisp, which I interpret as a sort of minimal ast/non-ast middle point (or fix point even ?)
This subreddit in a nutshell: CL GOOD, CLOJURE IZ BAD. Y CL NO MOAR POPULAR??
Well, stop with the halfassed wannabe lisp and we'll talk. Scheme and Racket are pretty damn good and aren't CL, since the people who created those did their research before throwing ideas at a language. 
the parser for m-exprs returns the same list representation. It's just a different syntax for the same program.
I'm sure there are some Social Media sites where your personal style is still considered cool.
Yeah, to me it seems like many people in the CL community are behaving like disgruntled old fellas spitting hate on everything around them because their favorite language failed to gain more traction. They choose some arbitrary subset of features and start screaming around that whoever doesn't do it the same "did not do their research" and s*** like that...
Being connected to the JVM and the Java ecosystem makes it easier to sell Clojure to the PHBs. That connection is a downside for me, though.
No I actually never read it sadly [1] I get that M-expr can be semantically equivalent to S-expr but having a language fuse both levels into one syntax has value to my eyes. It actually removes most of the syntactic layer and drive you to focus on raw structure. [1] I'm younger and French .. so I ended up reading Queinnec's re-edition of L.I.S.P and not Allen because I read somewhere that it was a modern view on the same concepts. Apparently I should have read both :)
You say Racket is "pretty damn good" and yet in it I can do `(let [[a 2] [b 3]] (+ a b))`. So is the wrapping of the `let` "assignments" the thing that makes a language go from non-Lisp POS to "pretty damn good"? To be honest, I actually like Racket a lot more than Clojure these days, so I'm not the best one to fight here with you ad nauseam over whether Clj is a lisp or not. I just find it weird that you are so full of negativity towards that language. As for what makes a Lisp: the reason why I came back to lispy languages after a brief encounter with CL in college was the virtual absence of hairy syntax and focus on functional programming that allowed me to focus on the problem I was solving a lot better. To me, syntax just doesn't scale. Yes. Clj is still a lot hairier than CL but it's still a nirvana compared to stuff like Scala. The reason I never grew fond of CL and prefer Scheme, Racket and Clojure more is primarilly its imperativenes and absolutely zero reservations about mutability. And also the grumpy elitist community. Arguing about this is kinda like agruing about the Left and the Right in politics. The original meanings vs current use.
&gt; I get that M-expr can be semantically equivalent to S-expr but having a language fuse both levels into one syntax has value to my eyes. It actually removes most of the syntactic layer and drive you to focus on raw structure. No doubt about it. &gt; Queinnec's re-edition of L.I.S.P a wonderful book...
[] and () have the same meaning in Scheme, whereas in Clojure, the first pair wrap around a vector and the second wrap around a list. I agree Common Lisp has a very imperative smell at times, but it's also got amazing native code compilers and tools that I can't find for Scheme and Clojure (and admittedly, I can't remain purely functional as much as I'd like to when hacking). You...can also not use the imperative parts of CL too. That also works, much better than imitating imperative code in a functional language.
What probiem are you trying to solve? I ask to see if I can do something about. 
Just... statistically: aren't there more Java-locked shops with programmers who dream of something better than there are CL programmers who get to choose their shops language? That could explain fixed popularity on one side, and growing popularity on the other...
And that's why.
&gt; You say Racket is "pretty damn good" and yet in it I can do `(let [[a 2] [b 3]] (+ a b)).` That is one of the most baffling design decisions in Scheme, squandering some of the most valuable syntactic real estate so users can confuse and annoy each other with different conventions around when to use `[...]`vs `(...)`. But at least you can *just say no,* unlike in Clojure. 
Is Clojure still growing? Last I heard, Clojure growth had stalled.
Maybe, but the dreamers you refer to might be just as happy (or more so) to use Common Lisp if it was an option at their shop.
It focuses on a few programming domains when deciding which features are important. Consequently it is well scoped, smaller and easier to get a handle on.
why do you consider it a half measure? 
WOW, it seems i don't need to implement anything anymore!! Look at [the inquisitor lib](https://github.com/t-sin/inquisitor/blob/master/README.markdown) , it does exactly what I want to do. /u/ryukinix take a look 
No particular project at the moment, just wishing to learn more on the topic from Lisp point of view. Thank you.
Using the JVM is part of it but not the whole story, as ABCL also targets the JVM. I think much of the credit goes to Rich Hickey and his presentations.
That seems reasonable, the sub-humans are multiplying.
just a reminder: keep the discussion civil
I found Practical Common Lisp excellent as a beginner. I'm not so much of a theory person so this book was perfect - you get started building mini projects right away. The writing is informal and relaxed, though it's quite thorough. Of course, some people prefer academic-style textbooks, but I like to get my hands dirty quickly and this book is good for that. You can [read it free online](http://www.gigamonkeys.com/book/), but I enjoy having a hard copy as well.
This is what I used. 
Pratcical Common Lisp, then Common Lisp Recipes.
Very very interesting!
Here is a bit of advice: When you come across an old hawk like lispm who is a vast nexus of knowledge and information, you don't ask him to spend *additional* time to do manual chores. Especially when said person is willing to spend his time to give you expert-level advice for free. Really, you should open your eyes and be grateful when that happens. People like lispm are literally adepts. "Where fall the footsteps of the Master, the ears of those ready for his teaching open wide"
If you like old school AI and are already an experienced dev then PAIP would be a good bet, it‚Äôs a great book. https://github.com/norvig/paip-lisp/blob/master/README.md
I used to think I preferred the academic approach. And then I read this book. 10/1
Best advice in this thread.
&gt; Very very interesting! I forked inquisitor, some problems: 1. Its CR/LF detection is too simple: It stops detecting after finding only one line. This is not useful for me, since I need to deal with files that have lines with LF and others with CR too (IT HAPPENS ON REAL LIFE...) 2. it does not work for spanish or portuguese encodings. I tried to make it work for ISO-8859-1, i can't yet.
I'm reading it right now. It's a nice read so far.
Hey Baggers\_ ! &amp;#x200B; I really like your videos and how you use emacs. I really want to display the char that are currently on cursor like you do. I read your emacs files repo but can't discover (yet) how do you achieve that. &amp;#x200B; Can you help me to understand? &amp;#x200B; Sorry for my awful english
I liked Land Of Lisp directly followed by Let Over Lambda. They *seem* far apart, but I think Land Of Lisp understates what it teaches you while Let Over Lambda overstates its own complexity.
Pratcical Common Lisp and Land of Lisp.
I see many reasons, most of which fall under Gabriel's "Worse is Better" [1] which I think Clojure provides (another) classic example towards. It is easier to digest than Common Lisp and superficially appeals to the younger generation since it has a veneer of 'freshness' and hype, thus a viral quality. Clojure seems to be getting popular because it has deliberately made popular appeal part of its design. Nevermind that a lot of the technical decisions Hickey has made and attempted to justify have now been proven to be erroneous. For a similar example, look at Python as another language that has willingly made *bad* technical choices in order to be more appealing to the masses. Then, we have the Java and JVM factor, which appeals to 9-5 brogrammers that constitute a *significant* - if not the majority - of the market. I think an illuminating answer to the original question can be found if we try to look at what kind of programmers gravitate towards Clojure. If Clojure was *technically* superior to Common Lisp, one would expect to see a lot of Common Lisp programmers moving on to it. Is this the happening? I don't think so. In fact, I dare say the opposite - folks moving to CL from Clojure - is far more prevalent. [1] https://www.dreamsongs.com/WorseIsBetter.html
Exactly what I would recommend as well
I'm going to second "Land of Lisp", because it's an immensely fun read. I really dig quirky hacker humor, so it was right up my alley.
&gt; Then, we have the Java and JVM factor, which appeals to 9-5 brogrammers that constitute a significant chunk - if not the majority - of the market. Now that's condescending. Same with the "worse is better" mantra. I mean sure, as a language, I'd rather code in CL than Java. However, if you take into account the toolings and ecosystem it's a whole different story.
For a slow and gentle start: [Common Lisp: A Gentle Introduction to Symbolic Computation](http://www.cs.cmu.edu/~./dst/LispBook/index.html) The first edition is available there as a free download.
PCL and PAIP are the top two for me, along with the super useful free online resource https://lispcookbook.github.io/cl-cookbook/. Supplement with Common Lisp Recipes, CLtL2, On Lisp and Let over Lambda. Land of Lisp is quirky but fun. Worthwhile related books: The Little Schemer, SICP, Lisp in Small Pieces (prefer the original French version if you can read French), and Anatomy of Lisp.
Biggest reason is the active ecosystem and beginner friendly resources. Common lisp (as great and respectable as it is) feels archaic and impossible to learn
&gt; never apply a function on a list for a \*list operation\*. APPLY is for calling functions, not for list operations. APPLY is limited by the number of arguments allowed by the implementation (see the variable CALL-ARGUMENTS-LIMIT, which is just 50 in ABCL). &amp;#x200B; I've checked how mappend (mapcan non destructive) was implemented by Norvig in paip and how is in Alexandria. Here in the mentioned order: (defun mappend (fn list) "Append the results of calling fn on each element of list. Like mapcon, but uses append instead of nconc." (apply #'append (mapcar fn list))) &amp;#x200B; (defun mappend (function &amp;rest lists) "Applies FUNCTION to respective element(s) of each LIST, appending all the all the result list to a single list. FUNCTION must return a list." (loop for results in (apply #'mapcar function lists) append results)) Are this two pieces of code acceptable for list manipulation in terms of salability? Am I missing something or seams apply is used on lists of arbitrary size anyway?
I am taking into account the toolings and ecosystem and I still don't want anything to do with Java. Having spent 5 years - almost seems like another life now - doing Java and getting paid for it, you wouldn't be able me to hire to do Java now unless you paid me in the 7 figures. The reason is mostly because I have realized that life is too short to have my mind rewired - against my control - by a programming language designed for damage control and to keep people in line in corporate environments. Like Nietzsche said, if you gaze long into an abyss, the abyss also gazes into you. 
The first version only accepts lists where the length is limited by CALL-ARGUMENTS-LIMIT: CL-USER 71 &gt; (mappend #'list '(1 2 3 4)) (1 2 3 4) CL-USER 72 &gt; setq *print-length* 50 50 CL-USER 73 &gt; (mappend #'list (loop repeat 5000 collect 1)) Error: Last argument to apply is too long: 5000 1 (abort) Return to top loop level 0. Type :b for backtrace or :c &lt;option number&gt; to proceed. Type :bug-form "&lt;subject&gt;" for a bug report template or :? for other options. We can thus see that the function's implementation is not adequate for processing arbitrary long lists in a portable way. The second function (the one from Alexandria) has a different interface. It support arbitrary long lists, but the number of lists is limited by CALL-ARGUMENTS-LIMIT (the first function above only supports one list). This is expected. 'function' will be called with an element from each list. But the arglist length of 'function' is limited to CALL-ARGUMENTS-LIMIT, it is okay to use APPLY MAPCAR, which is also limited by CALL-ARGUMENTS-LIMIT. Since that apply takes one extra argument, 'function', the length of 'lists' can only be CALL-ARGUMENTS-LIMIT - 1. But that's a minor problem. 
I second this choice, really enjoyed it when I was first exploring lisp.
aaah please make advertising for *the* Cookbook now ! https://lispcookbook.github.io/cl-cookbook/ and all under "Other CL resources" Ecosystem: https://github.com/CodyReichert/awesome-cl, http://quickdocs.org/, this subreddit,‚Ä¶ 
&gt; I am taking into account the tooling and ecosystem [...] Really? Because those are next to non-existent for CL in comparison to what's available for JVM-based languages. &gt; Having spent 5 years - almost seems like another life now - doing Java and getting paid for it, you wouldn't be able to hire me to do Java these days unless you offered 7 figures. Well, are you paid to code in CL? Even Clojure is not that big. I'm all for using languages that are objectively better than Java to do my job but it won't happen anytime soon. 
I like to keep [Successful Lisp - how to understand and use CL by P. Lamkins](https://successful-lisp.blogspot.com/p/httpsdrive.html) as a reference under my sleeve. There is a nice beginning, then you can pick up chapters. free download there.
SICP is in Racket but its pretty much translatable to CL. 
I find CL tooling far better - given focus on interactivity and short feedback loops and CL focus on interactivity on every front - than anything I came across in Java land, which is what these days, Jetbrains? As far as libraries go, it hasn't been an issue for me. &gt; Well, are you paid to code in CL? I get paid to solve problems, the vast majority of the time the language I use to do that is up to me. &gt; I'm all for using languages that are objectively better than Java to do my job but it won't happen anytime soon. It won't happen if you don't allow it to happen. Seek and you shall find. 
SICP uses MIT Scheme, IIRC.
Indeed, you are right. Just a info: actually I only discover that lispm &lt;=&gt; Rainer Joswig some minutes later after that request. I'll avoid this in the next occasion. Thank you again /u/lispm. All your suggestions are really valuable for me
Not to be confused with [Wasp Lisp](https://github.com/swdunlop/WaspVM/), a lisp used for building networked applications, most notably [MOSREF](https://bluishcoder.co.nz/2009/11/28/using-wasp-lisp-secure-remote-injection.html), the penetration testing tool.
In this order: [Common Lisp: A Gentle Introduction to Symbolic Computation](https://www.cs.cmu.edu/~dst/LispBook/) [On Lisp](http://www.paulgraham.com/onlisp.html) [Let Over Lambda](https://letoverlambda.com/)
I've recently tried out Common Lisp as my first language. And going into the book practical common lisp(which is a great book!) with no prior programming experience. Left me feeling stuck with alot of tools, but no idea on how to use them. If you're brand new to programming like I am then it might be wise to start from the beginning. A book that is already recommended here is [Common Lisp: A Gentle Introduction to Symbolic Computation](http://www.cs.cmu.edu/~./dst/LispBook/index.html). But there is also another book that gives you a nice start and that teaches you the computer science mindset [Concrete Abstractions](https://gustavus.edu/mcs/max/concrete-abstractions.html). This book uses scheme, and I was recommended to do it before attempting SICP, it also uses easier maths than SICP. If you on the other hand do have prior programming experience then I'd recommend you to ignore my advice and listen to the real pro's on this subreddit.
One feature I felt was missing from Common Lisp was an implicit macro for undefined functions -- such that you could "fix" the form to call a function. It would allow for some nice tricks, like using a number as an implicit ELT call. I suppose you might be able to wrap the code in an EVAL-WHEN that handles the compiler error... but that's hard to offer as a library because it needs to wrap the user code, and I'm unsure if you can change the form and recompile in any case. Maybe someone has other ideas...
Indeed: Common Lisp Recipes it's wonderful. I'm still reading carefully after Land of Lisp and some Practical Common Lisp.
I loved too, it was my first Lisp book and actually the first book that I actually read the whole thing sequentially lol
I take this journely along Land of Lisp + Practical Common Lisp as main references: https://github.com/ryukinix/lisp-insights As meta-thinking book/course, SICP it's a must-read book! 
&gt; I think much of the credit goes to Rich Hickey and his presentations. Definetly! The guy it's a really good speaker. Not saying that it does that... but I think he can even sell shit as gold :D
I'm not so sure, but there is terrible places in the whole earth...
Clojure it's in a winter for now. It's time of Common Lisp take the car to move to the right direction.
But Clojure isn't smaller... it's standard library can fit Common Lisp's standard library several times.
Oh, come on. Archaic? -- I'll grant that. But, impossible to learn? -- Comparing to how the modern languages go, CL is a very small language with a very consistent standard library. It used to be big, when everything else was smaller, but it's not being the case in the last, what... ten, maybe even twenty years.
Thanks! 
I'd say he does that. Not always, of course, but some of the claims he makes (especially when talking about anything related to types, CLOS or API-behaviour) really make me scratch my head.
&gt; It won't happen if you don't allow it to happen. Why are you content with writing Java for money? I usually work on some big projects or projects with a existing codebase, mostly ATM, aerospace. Most of the time it means Java (and some C and C++). You just don't get to change languages like that, and certainly not for CL. 
Thanks for all the links to excellent books on Lisp. I would like to add to the collection two links to a (very good) Russian translation of Practical Common Lisp: [http://lisper.ru/pcl/](http://lisper.ru/pcl/) [https://github.com/pcl-ru/pcl-ru](https://github.com/pcl-ru/pcl-ru) 
In some sort of order: 1. Common Lisp: A Gentle Introduction To Symbolic Computation 2. Land of Lisp 3. Practical Common Lisp 4. Lisp For The Web (as an interlude - I use a Raspberry Pi as a "Lisp Box" for web programming) 5. Successful Lisp 6. ANSI Common Lisp 7. On Lisp 8. Paradigms of AI Programming 9. Let Over Lambda And use StumpWM :)
Came to the CL side from Fortran, but read it, and archived MIT 6.001 . Is there lang/SICP ?
There is the lang sicp in Racket https://github.com/sicp-lang/sicp
PHBs? Small and Hobbled businesses?
It‚Äôs weird to see people copying my private messages to criticize a project I‚Äôve only been working on a month or so
This is true, I like snake case since I‚Äôm a rust dev.
It‚Äôs definitely bizarre for me to read as well.
Hey man, I just wanted to say I appreciate your feedback. I actually added a section to my new language based on your comment ‚ÄúLet‚Äôs Lisp like it‚Äôs 1959‚Äù. You are correct that my project is super new! I‚Äôd actually enjoy if you checked out some of the changes I made this week. I added recur instead of C style loops, starting to add cons. I‚Äôd love to get your opinion on what essential pieces are missing. Right now I‚Äôm working on the primitives to be able to have a type system so i can easily do some kind of memory management system.
I am taking a lot from clojure. Right now my goal is self hosting. I‚Äôm really not sure what I want to do when I reach that point.
I‚Äôm not sure, this spectre stuff has made web assembly with shared memory on web workers a questionable future. If it happens I will support it immediately in my language.
Which Lisp are you using?
 ;; recursive (defun homework (num val max) (if (&lt;= num max) (cond ((&lt;= val num) (print val) (homework num (+ 2 val) max)) (T (homework (+ 2 num) 1 max))))) (homework 1 1 10) ;; Iterative (defun homework (max) (loop for i from 1 to max by 2 do (loop for k from 1 to i by 2 do (print k)))) (homework 10) &amp;#x200B;
im using common lisp
I see that you give both ways in the example but I need it to be as a triangle like the beginner java problems to teach people how to use the inner for loops. 1 on first line 1 3 on second line and it goes on like this till we meet n
 (defun homework (max) (loop for i from 1 to max by 2 do (print (loop for k from 1 to i by 2 collect k)))) (homework 10) Output: (1) (1 3) (1 3 5) (1 3 5 7) (1 3 5 7 9) This work? 
&gt; *I was brought up with Java so Lisp is really fucking confusing for me.* That's a flimsy excuse. I had been "brought up" on BASIC, assembly languages, Pascal, Modula-2, C, C++. Lisp was very clear and intuitive from the get-go. Lisp is like Java or C in many regards: it has functions with arguments, and uses pass-by-value. Side-effects are performed with expressions. Lisp C-like (defun f (x y) int f(int x, int y) (+ x y)) { return x + y; } (incf x y) x += y (setf (aref a i) a[i] = (foo ? f(x) : g(y)) (if foo (f x) (g y))) 
dude the language is so fucking old I cant find videos on the internet, all the videos are about very simple concepts like basic syntax. There's nothing in depth
&gt;all the videos are about very simple concepts like basic syntax Well then that shows a flaw in your problem solving skills, not the languages themselves since this simple problem requires no more than the basic syntax/concepts of Common Lisp. This is not to insult you, but to prod you to improve yourself. I hope you take it in that spirit.
i know I need to improve myself thank you thats why im on reddit.
Only 1 loop: (defun triangle (max) (loop :with i = 1 :and target = 1 :and out :do (push i out) (cond ((&lt; i target) (incf i 2)) (t (print (nreverse out)) (setf i 1 target (+ target 2) out nil))) :until (&gt;= target max))) USER&gt; (triangle 10) (1) (1 3) (1 3 5) (1 3 5 7) (1 3 5 7 9) NIL
Try baggers‚Äô livecoding videos: https://www.youtube.com/user/CBaggers There are intro videos, and more in depth stuff like graphics / game engine programming. 
Because it's only LISP half of the way down, and Java all too often bubbles all the way up. If it was a full abstraction over the JVM, it would be a lot more respectable, but as it is, it's piggybacking and hedging its bets and not abstracting but rather hybridizing. Choosing both is not a choice, it's a half-choice, especially when there's very little for LISPs to actually gain from the JVM. All it does is standardize and bureaucratize, and as much as Rich Hickey likes to talk about how dynamic it is, it really isn't. Anything dynamic requires a lot of stringly-typed programming and configuration hell, which is strictly inferior to any systems that were actually designed to be. 
I say this as someone who will use and encourage others to use Clojure in anger, because at least it's better than Java, and sometimes that's the best one can get. But the anger that this is the relative best while still being absolutely bad is far stronger. And who is to blame other than the idiots holding things back? And if they're holding humanity back, their humanity is certainly questionable.
What can you do? Are you asking us to do your homework for you?
I don't recommend programming videos. What you can skim through in five minutes takes an hour. There is no Ctrl-F search, no keyword index. If you're lucky there are captions, but if they are burned into the video, they are not searchable. If Linus Torvalds had learned programming from videos, we'd still be waiting for 1.0 instead of celebrating its 25th anniversary. 
Huh? The language was standardized two years before C++ was.
I don't see how the JVM is not a big no-no compared to rock-solid native Lisp implementations like SBCL or Chez Scheme. Especially considering Oracle's shenanigans.
Recursion is more idiomatic; loops are easier to do correctly (since they're a bit more constrained, the compiler can do fancier things). I would go with recursion for something simple like this, though. You get that crisp lisp feel B-)
that's a really helpful explanation! thanks! 
I remember a few years ago I used to build SBCL on Windows with Cygwin. Nice to know MinGW works too.
Well, don't speak English in France. Speak French in France.
I am not a big fan of the JVM ecosystem or its main controller. However, being in the JVM ecosystem gives one access to a huge number of already written libraries, some of which have been used for years and many of the bugs worked out. Also, maven, has package signatures and versioning among other features that are currently missing from the ASDF + Quicklisp ecosystem. I don't know the status of this part of the Clojure world anymore, but at least years ago Clojure was also fairly solid, just a bit behind, on .NET from what I could tell; meaning you weren't completely beholden to Oracle as you could always turn to a Microsoft controlled world as well. Not many people are fans of either one, but having two such entities to choose from does allow one to hedge their bets a bit.
Sorry for the delay to get part3 going. Lots of excitement lately. 
Just do it in java then translate it to lisp. The solution is the same whatever language you door in. This isn‚Äôt a lisp question it is a ‚Äòdo you understand basic iteration and recursion‚Äô question.
It has been pointed out to me that one example in there uses a recursive macro, which "worked" for me in SLIME but is incorrect. The later version of the same example forks out that work into a compile-time-running function. I'll update the first example. I'll also clean up the source code file and put it on github or whereever as a single compilable/loadable unit.
https://lisp-journey.gitlab.io/blog/these-years-in-common-lisp-2018/ medium's "friends link": https://medium.com/@vindarel/these-years-in-common-lisp-2018-1d6b9084920d?source=friends_link&amp;sk=e117ad9b235df4bd9f0a2fdbe679d68b 
Just to mention it: working with Measures in CL: &amp;#x200B; [https://github.com/lispm/measures](https://github.com/lispm/measures)
I edited the blog post to have a temporary macro in the first example, before I properly fix it with a compile-time running function in (defmacro unit2 ...) Keep the corrections coming.
I put a runnable Lisp file of all the examples here: https://www.cons.org/cracauer/ccunits.lisp It is very hard to keep the example in medium.com up-to-date by copy and paste. This file is updated when it compiles cleanly.
Very nice series Martin. I had to go bsck to read the other 2 ealier posts. Is that a real book, coming out soon?
I have no plans, however why not? Nothing better than nailing down your evaluation order errors in a thousand printed books :-) I know somebody who did self-publishing using Amazon's printed book service. Looks pretty straightforward if you pass their editing requirements.
&gt; Well, are you paid to code in CL? I started learning CL ¬±1.5y ago and voil√†, I've been contacted to do a first contract in CL ! It happens, even without a job announce.
&gt; Being connected to the JVM and the Java ecosystem **A**rmed **B**ear **C**ommon **L**isp ABCL *ABCL* `ABCL` 
&gt; I think he can even sell shit as gold :D
&gt; I think he can even sell shit as gold I'd say he can sell "chocolate-flavored candy" as true chocolate. 
&gt; being in the JVM ecosystem gives one access to a huge number of already written libraries, Yes, but the C ecosystem is also huge, and it's easy to tap it from CL. 
&gt; It is easier to digest than Common Lisp I'm not so sure. You need to learn the details of two languages: Clojure *and* Java. Plus, Clojure introduces a lot of new slang like "transducers", "protocols". And then it introduces slang with totally different meaning than in Lisp: see "atom" for example. &gt;Nevermind that a lot of the technical decisions Hickey has made and attempted to justify have by now been proven to be erroneous. Would you please elaborate? &gt; In fact, I dare say the opposite - folks moving to CL from Clojure - is far more prevalent. I'm a CL acolyte but I didn't saw it that way. Is this really happening? 
&gt; Because those are next to non-existent for CL in comparison So, tooling and ecosystem are non-existent for CL? are you sure? Sounds like FUD to me. I have only about 2 years in CL and I have found almost all the libraries i need. The ecosystem is very small compared to stuff like NPM or Python or Java, but for practical purposes is good. Plus, we can easily use the C ecosystem. Plus, with ABCL i could use the Java ecosystem if I wanted too (ABCL makes this thing easy). As for "tooling", it seems like a claim for people used to *needing* a lot of tooling. I have had years, *years* of Java, C# and Python programming with Visual Studio, Netbeans, Eclipse, and IntelliJ/Pycharm. I am happier with Emacs and SLIME for Common Lisp. 
&gt; Is Clojure still growing? Last I heard, Clojure growth had stalled. IMHO, It is because it was attracting Java devs that looked for an alternative to Java. But currently the "alternative to Java" that is getting a ton of traction is Kotlin. So the java dev looking for the "alternative" is going to land at Kotlin. 
&gt; take the car I'd rather say "take the `first`", it sounds more welcoming for beginners.
&gt; please make advertising for &gt; the &gt; Cookbook ##Read the Cookbook, it's free! *Paid advertising*
&gt; just a reminder: &gt; Please keep the discussion civil +1 I have been guilty of flaming too much regarding this topic in the past. And I think that we should keep something in mind. We can debate about Clojure because Clojure *exists*, and it's a great thing that it exists: it gives us another tool in the toolbox. So just as we have Common Lisp, Scheme/Racket, PicoLisp, it's great that we have also another s-expression language we can also use if needed, without a steep learning curve. So Clojure made popular (or introduced) some ideas that can influence CL, Scheme, etc. This is a good thing. 
&gt; So, tooling and ecosystem are non-existent for CL? are you sure? Sounds like FUD to me. Compared to Java, yes. You could have quoted (read?) the whole sentence btw. Few libraries, even fewer good documented ones, a small userbase and no general visiblity. That's the CL ecosystem. Not exactly good selling points to promote a corporate use and a no-go in my field.
&gt;mostly ATM, aerospace American Express' card transaction verifier used to be (is?) a CL program. Piano Aero [is established in the aircraft industry](http://www.piano.aero). A CL application. &gt;You just don't get to change languages like that, Agree. 
This is insteresting. I am hopeing to Learn more about Lisp. It is really great that there are so many Lisp Books, Tutorial and videos about Lisp. It doesn't get any better than this.
I like how I my language looks. There‚Äôs no right way to write a Lisp, just people with strong opinion.
There are certainly wrong ways to write a Lisp, and snake-casing is one of them. Even in Clojure, people use snake-case.
Those people can be upset then at me.
We are, that's why you're certainly not creating a Lisp.
If your argument whether my lang is a lisp or not relies on how I spell my names,I don‚Äôt really see your opinion as valuable to me.
That's just one example of why this isn't a Lisp though. I can't read much Rust, but there doesn't seem to be any form of homoiconicity, or macros since you [shove code into a "parsed" form way too quickly](https://github.com/wasplang/wasp/blob/master/src/ast.rs) for that to ever work.
It‚Äôs true, just getting it compiled was pretty major accomplishment. I used a parser that really sped up the conversion. In the second version of this compiler I‚Äôm writing in wasp itself I‚Äôll have more phases of the compilation. Lexify into tokens, tokens into something else., etc. Would be a good opportunity to rethink these things to enable macros. I‚Äôm still not sure if I‚Äôll be able to do an complete eval system since I‚Äôm compiling to wasm bytecode and not making an interpreter .... maybe some subset could be executed. One problem with wasm is I can‚Äôt create new functions at runtime, so I may have to get clever.
There are 4 parts, or so that you'd need: - Write an interpreter for Wasp in Rust so you can evaluate macro functions in that, - Implement a symbol table in Wasp and in your compiler, - Implement quote (and maybe quasiquote), then - Create a defmacro or define-syntax form that uses your interpreter to generate code.
Sounds about right, it‚Äôs a lot to do, right now my goal is to write a standard library and reimplement the compiler in wasp so I can get out of Rust as quickly as possible.
&gt; feels archaic and impossible to learn You can actually write lots of useful programs by **only** knowing the following functions/macros/builtins: - DEFUN - LET - SETF - COND (or IF, your choice) - WITH-OPEN-FILE - FORMAT (you need only basic stuff: ~A and ~D format directives.) - TAGBODY (or PROG, your choice) - DO - EQUAL - NULL - CONS - CAR - CDR - LAMBDA And the mathematical operators: +, -, /, mod, expt And the logical operators: OR, AND, NOT That's only 22 functions to learn in total! Want to do a bit of functional programming? You can make your code even easier by just using: - MAP - REDUCE Ok, wanna use arrays? Learn: - MAKE-ARRAY - AREF or ELT That's it! Wanna use lists as stacks? Learn `POP` and `PUSH`. Wanna use lists as property-lists? Just learn `GETF`. Wanna use hash tables? Learn: - MAKE-HASH - GETHASH - REMHASH Wanna use multiple values? Learn: - VALUES - MULTIPLE-VALUE-BIND Wanna make programming easier? Learn: - LOOP - DESTRUCTURING-BIND - DEFMACRO - WITH-GENSYMS Wanna organize your code in packages? Only need: - DEFPACKAGE - USE . IN-PACKAGE So, yes, CLOS is harder. But CL isn't as big as it seems. Yeah, it has 900+ functions in the library, but many of those things are convenience things (like MAPL, MAPCAR, MAPCON) or things that are going to be part of a standard library anyway (i.e. time functions), or that would require external tools on a different programming language (i.e. DISASSEMBLE). 
That is indeed true. Depends on which ecosystem one needs access to more.
TBH, your demo looks more like Forth plus a little bit of Perl plus some extra weirdness to me. Maybe a comment or two would help.
Now I'm curious, why Perl? If you would consider being a bit more specific about which part/construct you're having problems with, I'll do my best to help.
In a very superficial sense, but seeing &amp;{ and @n has the same effect on me as seeing lots of parentheses has on others. Is that kind of line noise really necessary? I'm sort of OK with * and &amp; from C but that's how far it should go in 2019. TBF, the sometimes lengthy function names in CL and Emacs Lisp remind me of the Cobol exercises I had to do in a class a looong time ago. But at least we have autocomplete these days.
Aight, thank you. `&amp;` is taking a reference to the scope, so it's more or less in line with the meaning in `C`. And all variables live in a separate namespace prefixed with `@`, which means every time you see the symbol, you know you're dealing with a variable.. Aand symbols are likewise namespaced using `'` as prefix. Yeah, I never really got used to that in CL either. Then along came Java, C# and now Swift. Thanks, but no thanks; they read like legalese.
For me, it's the leading sigils (`$`, `&amp;`, `@`) that gives it a slightly Perly feel. (And i say this as someone comfortable with Perl5 syntax.)
(-: Like Civil war ? :-) 
How to Design Programs (HtDP) 2nd edition is also an excellent choice before tackling SICP.
Learning Perl did leave lasting impressions: it never got the credit it deserved since it wasn't theoretically impressive enough, I see a reaction to that in P6 which is trying very hard to check all boxes without loosing its soul. P5 a power tool, just like Lisp and Forth; a language by hackers for hackers; something I'm very much aiming for with Snigl. Perl might well be where I got used to sigils as well. The main reasons for using them in Snigl is simplifying the parser and making code more transparent.
/u/maufdez?
For common lisp in my opinion the best way to go is Emacs, I haven't tried portacle myself, but is what everybody recomends this days, I see you tried with no success. My suggestion based on my experience installing Common Lisp on several machines. A) Choose an implementation, SBCL, ECL or CCL are the ones I recommend, CLISP was my first it is very light but it is slow. SBCL has a binary distribution for windows, so does CCL, I am not sure about ECL because I have not played with it for a while. All these can also be installed using [roswell](https://github.com/roswell/roswell), Once you have your implementation installed run it in the terminal, roswell also allows you to do that with ease, if you decided against rowell you have to look for the executable in the installation. Once in the prompt install [quicklisp](https://www.quicklisp.org/beta/), download the quicklisp.lisp file using the provided link, make a note of here it is, then in the CL REPL type (load "path/to/quicklisp.lisp") , with the parenthesis and hit enter, notice I use / and not \\, if you decide to use \\ each \\ must be escpaed using an additional \\, in other words place two \\ where each \\ is, some instructions will appear on the REPL with some suggestions, follow the one to add quicklisp to the init file. No you can get out of the REPL, use (quit) followed by enter, again the parenthesis are necessary. Download emacs for windows from the GNU site, and just place it in a directory of your choosing, in the explorer navigate to the bin directory, right click on runemacs.exe and select new&gt;shortcut, move the shortcut to your desktop. In emacs setup [MELPA](https://melpa.org/#/getting-started), the instructions are in the web site, when asked to modify your .emacs you don't have to look around for it, using \~/.emacs in windows works too, once you added MELPA restart Emacs, when it boots you can do alt-x package-list-packages, loo for slime with c-s and install it, then go to the .emacs again and make sure it points to the right Lisp look for the line that says (setq inferior-lisp-program "/path/to/lisp.exe"), and change it if needed. After that you should be ready, you just have to open emacs and do m-x slime, and a REPL should open. To learn how to work with slime there are several resources in the internet, or you could ask more if everything works. By the way this is the minimum setting, but I do recommend setting up more things like autocompletion, parens-mode or smart-parens, helm and projectile, I can share any pieces of my .emacs you require. After that it is pretty much the same as working with emas/slime on linux.
I have the third edition sitting on my shelf. IIRC, there was a companion book on AI published at the same time.
The same guy who wrote *the* AI book?! Woah, great find!
I have that book, bought it decades ago - but I have the first edition.
There is Corman Common Lisp specially for windows 32bits with a built-in editor. It had a new release recently. That's all I can say. https://github.com/CodyReichert/awesome-cl#implementations Maybe Eclipse with the Dandelion plugin (it installs SBCL or CCL for you) ? Or Atom ? https://lispcookbook.github.io/cl-cookbook/editor-support.html (see pending PRs) Or the free version of LispWorks.
Can you talk a bit about how Snigl compares to Factor? (Which has an integrated graphical environment and a ton of libraries by now) 
Literally picked up the third addition for a couple of dollars just a bit ago, solid read. Let over Lambda is next on my list.
I got a first edition too. Bought in 1983. Still has the CMU Bookstore price tag on the back $18.95
Wow! Mind a picture?
The Ackermann function gets a Oh God Why from everyone, right?
Ha!
That is a valid question with excellent answers; if I taught those students, they would know.
How the hell would `var` work with scope rules? Anaphoric if would be much clearer.
We should have a bracket that just means "however many parens you need to close it all out."
Earlier Lisps had that. Interlisp used \] for that. Even earlier, Lisp was entered via punched cards . At the end of each deck of cards developers put a card which only had multiple closing parentheses on it. &amp;#x200B; &amp;#x200B;
I could imagine that being super error prone.
And extra closing parentheses were just ignored. MACLISP still did this.
&gt; How the hell would `var` work with scope rules That would of course be up to the language designer‚Äîhopefully one with more taste and common sense than [NAME REDACTED] ;-) &gt; Anaphoric if would be much clearer Anaphoric macros face similar questions. What should `aand` do when invoked with more than two arguments? (aand a b c) == (aand a (aand b c)) or (aand a b c) == (aand a (and b c)) They're mutually exclusive, and I wouldn't say one is unambiguously better than the other. 
True, very true. I think the suggestion is to choose the name we bind, so it may be `(aand (one a) (two b) c)` (c doesn't need a binding), like a let*.
Is emacs paren-mode close to Sedit? Was there anything in (portable) Hemlock / ZWEI ? Hemlock is ? CCLs ide
Actually I love the syntax highlight on the whiteboard...
I've had a look or three, but not written anything serious. No multiple dispatch, green threads or async IO from what I can see, and I consider those show stoppers. And it's clinging too hard to Forth for my taste. Factor seems to be aiming for the one language to rule them all, like most others I guess. Snigl isn't trying to replace anything, it's designed as a more dynamic complement to C. Hope that helps, maybe someone with more Factor experience can add more details and/or corrections.
Thanks for CL-REPL! I loved and I'm using to teach some people use CL using it. It's nice to have CL-REPL on my pocket and since I'm using http://ultralisp.org I can distribute easily my software in github to execute some systems like this: https://github.com/ryukinix/lisp-inference A Propositional Calculus Engine that I made in the past.
I still want one of those things. I/we also need to get cracking of using Lisp syntax (or lack/flexibility of it) for micro-level parallelism, e.g. for speculative execution. Especially on CPUs that support-ish that.
Programmers simply fail to understand that you can write lisp in almost any language. For example, here's JavaScript example (note the ending parens have been piled on the end in true lisp fashion). function a(x, y) { return ((y === 0) ? 0 : (x === 0) ? (2 * y) : (y === 1) ? 2 : ( a((x - 1), a(x, (y - 1))))));} Of course, JS also gives us the alternatives of writing in a less-explicit manner (also called JS-APL) var a = (x, y) =&gt; y === 0 ? 0 : x === 0 ? 2 * y : y === 1 ? 2 : a(x - 1, a(x, y - 1)); And in true infix fashion, we may double the line count and quadruple the syntax while pretending there isn't a relationship between more lines of code per file and an increasing number of bugs. function a(x, y) { if (y === 0) { return 0; } if (x === 0) { return 2 * y; } if (y === 1) { return 2; } return a(x - 1, a(x, y - 1)); } 
I dug on auctions list for many kinds of machines but CM never occured to me.
Picture is completed with Winston's Lisp book at the bottom.
It has multiple dispatch (https://docs.factorcode.org/content/vocab-multi-methods.html), green threads and async io (https://docs.factorcode.org/content/article-threads.html),(https://docs.factorcode.org/content/vocab-coroutines.html) and lazy streams (https://docs.factorcode.org/content/vocab-io.html).
https://imgur.com/a/yuaylWc?
Well then, thanks for fixing that; I have nothing more of substance to add. 
What language is this? It isn't Common Lisp, because you have an "else" there and the name of the function is put with the args.
Scheme probably judging by the `define`. 
&gt;Ive tried to use portacle but it slowed my computer down to a crawl for some reason This shouldn't happen. I use Portacle on Windows all the time and works just fine. SBCL, CCL, ABCL, CLISP, all of them work just fine on my windows (x64) machine. 
I call it 'time to refactor'.
Great, thanks for sharing!
Scheme, indeed. It is copied from the Structure and Interpretation of Computer Programs.
The 'at least you don't have to write all the ) nil) in full
Bottom bun?
lol, hamburger lisp
Since parentheses is normally shifted, thanks for the soft keys.
That't the Rainbow Road, duh
I have [proposed](https://www.reddit.com/r/lisp/comments/6h5cma/new_name_for/?st=jtd9obut&amp;sh=d26c08ec) "sfogliattla" and also "pringles". 
Bottom bum?
Parenberries?
I'm just learning the basics of Lisp currently, but what has worked best for me is installing SBCL directly and using it with [LispIDE](https://www.daansystems.com/lispide/) Works on windows 8 but not 10 for me, YMMV as it says it should work on W10. The on site installer seems a bit old, but there's a newer one on the github though. 
I love ‚Äúsfogliatella‚Äù! I‚Äôll be using that in code reviews from now on. &gt;The sfogliatelle in this file are becoming troppo giganti. Maybe it‚Äôs time to refactor?
Most likely a familiarity thing, but I actually find languages that "tidy up" some of those parentheses (Clojure) to really throw me off. Everything feels like it could just float off into space at any time.
it's the roach or the butt
Or "write yourself a nest macro already".
'"Goddammit CL-WHO" and "I missed a step, didn't I"
A lip
hey, how's the interactive debugger like in LispIDE ? thx
dat ass
I think of it as "the balance", because it balances out the expression.
It doesn't really have one of it's own, you use the SBCL one (if that's what you have installed). [Pic related](https://i.imgur.com/489J9BT.png), you just shift down into the running lisp.
https://en.m.wikipedia.org/wiki/Pointy-haired_Boss probably
**Pointy-haired Boss** The Pointy-haired Boss (often abbreviated to just PHB or "The Boss") is Dilbert's boss in the Dilbert comic strip. He is notable for his micromanagement, gross incompetence, obliviousness to his surroundings, and unhelpful buzzword usage; yet somehow retains power in the workplace. In the Dilbert TV series, in which he is voiced by comedian Larry Miller, the character is notably smarter (although still quite stupid and inept) and more openly corrupt. He is also parodied in Bee Movie as Dean Buzzwell, also voiced by Larry Miller. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Chonky parens
&gt; time to refactor Telomeres. If they get short, the former Lisper in you will soon ~~Refactor~~ Rewrite It In Rust. 
I like the "the language with all the answers."[1] phrasing, however some people may see it as being smug. [1] "the language with one answer for everything" would match better clojure spirit *imho*.
Hm last time I checked Cursive is free for not-commercial usage: &gt; Non-Commercial &gt; &gt;**Free** licence available to individuals for **non-commercial** use, including personal hacking, open-source and student work. This licence **may not** be used for commercial development. This licence is valid for 6 months, and may be renewed at that time. &amp;#x200B; I'm using both Emacs + SBCL/CCL and LispWorks IDE for Windows(expensive), and tend to use LW more. &amp;#x200B;
got it, thanks!
Changed! Thanks! Appreciate the read :-)
please note, that "one" in "one answer" was there not by an accident. Of course I have no intention to persuade making it so on your blog, just saying that what you put there carries a different meaning than what you've changed in your blog.
I thought "an answer for everything" was a slightly more truthful answer, because in so many cases there are so many cases there are so many answers. 
My usual procedure to setup Lisp on Windows is as follows: 1. Install [emacs-w64](https://github.com/zklhp/emacs-w64/releases) (or any other Emacs distribution, whatever works) 2. Install [SBCL](http://sbcl.org/platform-table.html) Windows binaries 3. Install [quicklisp](https://www.quicklisp.org/beta/) and then quicklisp-slime-helper as per instructions. Configure ~/.emacs to use SLIME and then you'll be able to launch SBCL via M-x slime. Shouldn't be too hard to make it work together. One thing that may confuse you with is that quicklisp installs into c:/Users/username and that's also where .sbclrc should be, while Emacs home directory (~) is in c:/Users/username/AppData/Roaming, so if you see tutorials asking you to edit ~/.sbclrc you need to open the right place in Emacs. Also [ASDF configuration file](https://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF) (if you're gonna make one) should be in c:/Users/username/AppData/Roaming/config/common-lisp/source-registry.conf.d *not* .config as the documentation says. You'll probably also need to install some 64-bit C library binaries like openssl if you want to run Hunchentoot etc. It will usually be apparent when you try to install some library and it can't find a DLL.
Wtb time machine 
Good Evening Sir, may we talk to you about our lord and saviour Rust?
those are a bit harder to get
There is r/lispmachine where several enthusiasts share things, maybe one of them knows where to get one. My bet is they will also read this forum, but just in case they don't you can crosspost there.
First thank you for this series! &amp;#x200B; It seems a definition of unit2 is missing.
Where are you geographically? A coworker of mine has one, but I bet he doesn't want to ship it...
&gt;Is there a word for that fat stack of parens at the end of Lisp expressions? Yes: PARWITCOANWA. (The Thing) Paredit Will Take Care Of Automatically and Nobody Worries About
Are there software emulated versions of those Lisp Machines? I am sure with today's microprocessor speeds they should be more powerful than the original hardware
I have a few MacIvory II‚Äôs and a few MicroExplorer cards, one of which needs a repair of a pin. Feel free to message me. 
It is called "Closing Square Bracket". You write it like this "]" Example; (defun (x) (..(..(..(..(..(..( ... ] It makes the reader pop to the origin of the stack.
Have you dropped an e-mail to David K. Schmidt, find his sales@ email at http://symbolics-dks.com/ ? I bought one from him a decade ago, and he unloaded a bunch of systems on eBay a few years back, but if you want actual hardware, he is probably the most reliable contact. The next best option, though it is not fully legitimate, is to find the software emulator that runs the OpenGenera software on x86-64, and play with that until your excitement dies down, and realize you don't really want one after all. Third best is to find the legitimate CADR emulator and the MIT-licensed code and hack on that. It's pretty primitive compared to the Symbolics, but it is cool in its own way, and you can understand it down to the gate level. I have a MacIvory II which I am in the process of porting from my Macintosh IIfx into a Quadra 900. I have spent a lot more time trying to get it to work than I have actual coding, if that gives you any idea of what this is like. 1. For real "production" usage, you would want a DEC Alpha machine running the OpenGenera environment, but DEC Alpha hosts are scarce. 2. For more available hardware, you would want a MacIvory. But these *require* a 68020--68040 NuBus Macintosh with multiple slots, meaning you are running SCSI-only Mac OS System 7--9 era machines that are 25+ years old and have their own issues. Symbolics keyboards (unfortunately because of keyboard fetishists) are even rarer than Symbolics machines. 3. Even the x86-64 emulator is quirky (e.g., relying on old X window methods that modern X servers don't support). You will want to run that in a virtual machine. Once you get it running, you might discover that you really don't have much use for an underpowered (&lt;=128 MB RAM, 20+ year old performance) machine that can't really survive on the modern Internet (ancient TCP/IP stack, no SSH, no HTTPS, no WiFi), coded in a unique superset of Common Lisp with a unique OS/GUI stack behind it. Unless you have a disk full of Symbolics code you are aching to run, what are you going to use it for?
Not really more powerful, but they are of course much faster. Much much faster. The real machines were ca. 5 MIPS machines and were limited by small RAM (8MW = 40MB was already much, because lots of RAM was also extremely expensive at that time) and slow disks for paging. The later and fastest machines had only SCSI II. Not really more powerful, because the emulators for the Symbolics does not emulate the (often exotic) hardware around it, like special frame buffers / graphics cards which were used for the graphics software. The Symbolics Open Genera emulator also does not run compiled Ivory code directly - code needs to be recompiled/adapted for the emulator. 
A CM-5 started at something like $1.4 Million...
50$ in your local landfill maybe ?
I looked everywhere in my local landfill and there wasn't none. 
Where are you?
Hi, I am interested too
On a related note, anyone know how to find a TI Explorer rig? We had a couple at school many moons back. More useful than a Symbolics, maybe.
looking forward to your return! 
Please send a PM. 
I have a couple MicroExplorers, manuals, and software. 
Enjoy the gig! Who are you going to see?
When we make time machines we'll have Lisp machines involved tho
I picked up a couple in the 1990s when they were retired at various institutions. A 3600 and a 3640. Apart from power consumption you really need to watch disk size. It is easy to be too squeezed in the install you get from previous use.
P-Floyd (a pink floyd cover band) who meant to be pretty good.
Pink Floyd is a valid excuse. Even a cover band.
I'm in Atlantic Canada :/
I've been using OpenGenera for quite a while, and it's what made me realize I *do* want one. I enjoy programming on vintage computers, and Lisp is my favorite language.
Fixed. Thank you.
Well, if you want the Lisp machine experience, you could put a Mac II on your desk and starve your VLM process of CPU :-) Like u/lispm pointed out, the only truly unique parts were the super-scarce graphics hardware, keyboards, and finicky hard drives. Too bad about DKS, wouldn't surprise me that he might have retired, but he still might be the best option if you can get through. Maybe Kalman Reti could tell you what DKS is up to these days.
It's not the same, I'm extremely interested in the hardware design too, not just the software.
Don't get me wrong, I am sympathetic. I don't think it is easy to learn about the hardware design unless you really get into reverse engineering. You might learn as much by working on things like disassembling the VLM worlds. I am not certain but I don't think the MacIvory microarchitecture or memory controller can be usefully observed. As opposed to the 36xx which I think had readable microcode store and are much more discrete logic. My current yak shaving project is to build a NuBus sniffer that can trace what the MacIvory does, with the aspirational goal of building an HDL model. But that's a *long* way away.
Nice, are they abroad now or will you watch them in Sweden?
Clojure only has an advantage here for people who are already well-versed in Java. For those who don't regularly code in Java, learning Clojure means learning Java and its ecosystem first, and then understanding how Clojure maps onto it. In contrast, CL can be understood from first principles without having to go understand some other system first. 
PMed, thanks
Your NuBus sniffer is indeed a nice project, are you using an FPGA for that? Also I have a side question about OpenGenera, the Lisp code thats within, is it the full source code of Genera?
I'm very interested, I sent you a message. &amp;#x200B;
Yes, the plan would be an FPGA. Unfortunately there don't seem to be many logic analyzer projects for wide parallel buses these days, and I need to figure out the level conversion, how NuBus works in detail, etc.) OpenGenera (by "open" they mean "uses someone else's hardware") has a bunch of Lisp source, but the very lowest levels (e.g. the definition of the macrocode instruction set or memory subsystem and GC) and the VLM emulator are not provided in source.
i'm too interessed in a lispm, microexplorer, PM send
I'd be happy just to have a good replica of the late model Symbolics keyboard. Not so many keys, but with all the bucky bits, you don't need many.
In lua, you get worn out coming to the end end end end end end of a definition.
This is probably very true. My background before Clojure became my favorite was years of Java and Scala, so I had a head-start there.
The source for the VLM is available, and is on github.
Interesting. I'm pretty sure that was not true when it was a live Symbolics product (mainly because those files don't each have the enormous Symbolics copyright header they stuck on every file in their source distributions.) As I recall, Brad Parker first created his x86-64 VLM by a mechanical translation of the assembled Alpha code, not from source.
Lots of security problems here: + No HTTPS *anywhere*. MITM heaven. + Let's host everything ourselves. If we get hacked, lots of people get owned. + Not at all obvious where these releases are coming from. No authoritative URLs, no clue as to where they were fetched from and what method was used. Could be anything. + Not at all obvious as to why Eve can't impersonate legitimate author and wreak havoc. The real issue here is the security disaster known as quicklisp. It boggles the mind that an entire ecosystem has been created on top of something that's fundamentally broken. 
Do you have any solutions? :)
Do you have any solutions? :)
For beginning i suggest a title rarely mentioned: A Programmer's guide to COMMON LISP, Deborah Tatar, Digital Press. Has a pratical -programmer-point-of-view- of the subject, without spending too much pages explain what an atom is or not. Next, On Lisp, Graham.
That expectations are too high... it's just a daily reddit user being reddit-user comment in the reddit way. 
Great!!! &lt;3 Ultralisp is awesome. This is a big change from the terrible centralized main dist.
https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect
If you didn't notice, the site itself is under the HTTPS. Only distribution archive isn't because of (temporary) limitations of the Quicklisp. 
Although I am using Macs for ages not everything is easy there. You are providing to little information to really get help. There a good resources on the web about setting up a Lisp environment. common-lisp.net or Cliki.net should be a good starting point. Also have a look at portacle.
Sad and true.
They are visiting Oslo so it's nice and local
Hehe thanks, my thoughts exactly
I suggest you download portacle, rather than trying to configure emacs+slime+ql etc yourself. https://portacle.github.io/
nope, he used the source. 
No, I am rather certain I heard Brad explain to me (over beers near MIT?) that he translated Alpha object code (the OpenGenera vlm binary, not the Genera code) into machine generated C, then was surprised to find that GCC could turn it into pretty good x86-64 code without a problem. The source on GitHub seems to be attributed to Gary Palter, one of the original Symbolics developers, e.g. a co-author on http://pt.withy.org/publications/VLM.html That may be what he is using today, but I don't even know if Brad is actively working on it. 
He didn't, there was a program in the source that would generate the code needed. Brad changed it to generate x86_64 assembly instead of Alpha.
0 compiler notes means that your code was compiled succesfully. What did you expect would happen after compiling a Lisp file/snippet of code?
[https://github.com/Shinmera/libcommonqt/blob/master/commonqt.h](https://github.com/Shinmera/libcommonqt/blob/master/commonqt.h)
[https://github.com/Shinmera/commonqt](https://github.com/Shinmera/commonqt)
https://www.youtube.com/watch?v=Qw9oX-kZ_9k
Hey, I caught about ten minutes of last weeks stream, or whatever the last one was. Is it going to be on youtube? No big deal if not. But do have fun at the gig!
Honestly looks super cool, but... How do we make sure the systems are not removed later? The first thing that appears on the page is that some systems were removed from the dist. I mean, for me the nice thing about a tool like QL (or a similar tool for other language) is to be able to bundle a system (that depends on other libs) and be sure that it will work on the future. 
Install Portacle and all your worries will go away. It's SLIME with Emacs, but already configured and packaged like a nice sandwich, ready to eat. And it's a /u/Shinmera product. Shinmera loves us all. &gt;while compiling the code it gets stuck on "0 compiler notes") not being able to figure out where I am going wrong. "0 compiler notes" means "I didn't find any fault with your code, you Lisp hacker." After you compile some function, you need to execute it... That's what the REPL is for.
[removed]
Have you installed CommonQt and the libcommonqt? Basically, the header file defines the alien function signature that's missing.
You need to depend on qt-libs.
Thank you, that's done the job. Strange it's not mentioned in the tutorial
No idea, I followed Shenmue's instructions. Adding a dependency on qt-libs, as /u/stassats suggested, fixed it.
Probably not. Have you tried using cl-kafka?
I don't know, but "not updated in two years" is not an \*automatic\* disqualifier in CL-land. Is it missing something specific or does it have some bug that makes it unsuitable?
Try kafka-rest interface. Then you can access everything without the need to speak kafka, just http rest. &amp;#x200B;
What's more troubling is that GNU Make hasn't [seen a new commit since September 2018](http://git.savannah.gnu.org/cgit/make.git). Think of all those vast numbers of projects built with `Makefiles`; soon they will be up the shit creek without a paddle.
&gt;What did you expect would happen after compiling a Lisp file/snippet of code? Ideally, some money would then be deposited in my bank account. 
S-expressions are part of the definition so if it doesn't use them it isn't Lisp.
Which one do you mean? I'm curious.
Python, Dylan, Ruby are lisps with alternative syntax. 
No, thanks.
Python is derived from ABC which is derived from SETL. None of them are Lisps. Ruby was "by Perl, Smalltalk, Eiffel, Ada, and Lisp". It's not a Lisp. And whilst Dylan was originally derived from Lisps it now has an Algol-like syntax which means by definition it isn't a Lisp. Just because it's dynamic and "multi-paradigm" and does memory management doesn't make it a Lisp.
Downvote all you like, doesn't make what I wrote wrong any more than it will stop the sun rising tomorrow.
S-expr are not part of Lisp definition.
A structured editor. Could work well on mobile devices, and include advanced typography.
Wisp is actually quite nice and I have used it for some "pseudocode" in presentations when the audience is parentheses-sensitive. https://srfi.schemers.org/srfi-119/srfi-119.html
Systems are removed from Quicklisp when they are not compile. Ultralisp work the same ‚Äî if me version of a system fail to load, it is removed from future version of the distribution. But the old version of the system remains in the old distributions. What ultralisp does - it packs tgz archives, generates txt files with metadata and uploads it to S3. Files aren't removed, only appended. By the way, if somebody want to sponsor the hosting and/or development, I'll highly appreciate this. 
Here is an example of such version: https://ultralisp.org/versions/20190320135500 I've turned off 3 projects because these systems conflicted with other versions. Later we need to add an automatic check if the newly added project includes systems which names conflicts with systems in the distribution: https://github.com/ultralisp/ultralisp/issues/37 Other reasons why project was disabled are: - it is unable to quickload it for some reason; - asdf:test-system fails (testing is not implemented yet).
&gt;Systems are removed from Quicklisp when they are not compile. Ultralisp work the same ‚Äî if me version of a system fail to load, it is removed from future version of the distribution. But the old version of the system remains in the old distributions. Thanks for this explanation &gt;By the way, if somebody want to sponsor the hosting and/or development, I'll highly appreciate this. If I ever get a raise, this can be a candidate. But... i'm thinking, if it could be pacakged for Azure Functions it would run for free for a lot of time. 
Downvote /u/borodust all you like, , doesn't make what /u/borodust wrote wrong any more than it will stop the sun rising tomorrow.
Oh yes they are. http://www-formal.stanford.edu/jmc/recursive/node3.html https://en.wikipedia.org/wiki/S-expression 
https://steve-yegge.blogspot.com/2006/04/lisp-is-not-acceptable-lisp.html?m=1
ugh. i find him intolerable.
I go for lisp butt. See also a respective Emacs extension [https://www.reddit.com/r/emacs/comments/b2uqdm/weekly\_tipstricketc\_thread/eiwlxt5?utm\_source=share&amp;utm\_medium=web2x](https://www.reddit.com/r/emacs/comments/b2uqdm/weekly_tipstricketc_thread/eiwlxt5?utm_source=share&amp;utm_medium=web2x) .
Actually, you are right in that regard: S-expressions and M-expressions are both mentioned there making them equal. Meaning language can be a Lisp regardless if it uses one or the other.
I played with kafka the other day. With autowrap, librdkafka bindings are trivial. I wrote toy producer/consumer tests, but since I don't use kafka, I left it alone. If you want I can put it somewhere so you can flesh it out.
John McCarthy &gt;&gt; Steve Yegge when it comes to defining what a lisp is.
I like this one. Professional, easy to remember, logical.
'Pringles' is a fun one. I also love how *global-variables* have 'earmuffs'. Cute names stick well with me.
Anything that control computation time (compile-time, run-time) like backticks, commas do? I am seriously asking. I think the backtick-comma thing can be very hard to read, not to mention figure out eval time. Something more readable would be appreciated. Just haven't seen anything lately. Apart from Python scripts writing C++ source code.
Not OP, but I possibly have an issue with Slime + SBCL on Windows. I have sbcl in my path, so I have `(setq inferior-lisp-program "sbcl")` in my config and running inferior-lisp-mode works fine. But when running Slime, it won't connect to an inferior-lisp server. All the buttons in the menubar are greyed out and running slime-connect says something like `make client process failed: Connection failed`. So I'm expecting Swank isn't working, but I don't know how to fix/start it. I can't find a function with 'swank' in it. Would you know how to fix this?
at the repl test your (inner args) is the output what you expected? untill you approach the function / program you need (2nd (inner args))
It has a Postgres database on a backend. I think most price will come from amazon S3 if the will be high rate of PUTs and GETs. I've received a $100 bill from AWS this January because of "small" mistake in the code, which made about 100000 uploads to S3. 
Since there are different definitions of ‚ÄúLISP‚Äù happening in these comments, here is what John McCarthy wrote in his 1979 paper ‚ÄúHistory of Lisp‚Äù: &gt; As a programming language, LISP is characterized by the following ideas: computing with symbolic expressions rather than numbers, representation of symbolic expressions and other information by list structure in the memory of a computer, representation of information in external media mostly by multi-level lists and sometimes by S-expressions, a small set of selector and constructor operations expressed as functions, composition of functions as a tool for forming more complex functions, the use of conditional expressions for getting branching into function definitions, the recursive use of conditional expressions as a sufficient tool for building computable functions, the use of Œª-expressions for naming functions, the representation of LISP programs as LISP data, the conditional expression interpretation of Boolean connectives, the LISP function eval that serves both as a formal definition of the language and as an interpreter, and garbage collection as a means of handling the erasure problem. http://jmc.stanford.edu/articles/lisp/lisp.pdf 
Yes, some people have claimed that those are acceptable Lisps, where by ‚ÄòLisp‚Äô they mean ‚Äòdynamic programming language‚Äô ‚Äî but none of those is homoiconic, and I claim the homoiconicity is the ultimate benefit of Lisp. It‚Äôs when your program code is data for another program whose code is data for another program that you need Lisp. I also argue that this threshold is a lot more common than people realise.
That's fine unless you care for performance.
&gt; I've received a $100 bill from AWS this January because of "small" mistake in the code Good grief... On the other hand, if every programmer had to suffer something like that, there would be no software bugs on this planet. 
Thanks for this comment! The discussion is finally getting somewhere interesting with the homoiconicity argument. Are there any homoiconic languages that are not lisps?
For what matters, I have the Lisp 1.5 book, and I have read many academic papers. This link what a way to show you that you first need to draw a boundary around what you call a lisp. John McCarthy‚Äôs work has long evolved since the sixties. Maybe it‚Äôs more interesting to have a look at what we have today? I don‚Äôt know why you are so bothered, aren‚Äôt you interested in discussing positively and politely?
That is true. 
Matching parentheses with Pringles is easy: ((((((( -&gt; rotate chip stack 90 degrees -&gt; )))))))
&gt; By the way, if somebody want to sponsor the hosting and/or development, I'll highly appreciate this. I'd give a few bucks to a liberapay/‚Ä¶ account. A corporate sponsor would be nice though.
&gt; liberapay Interesting! I've never used liberapay before. I've created a project on it: https://liberapay.com/Ultralisp.org/ and now you (and anybody else) can become a sponsor.
https://en.wikipedia.org/wiki/Homoiconicity has a list; most of ‚Äôem are Lisps or very Lisp-like. I‚Äôve heard some great things about Rebol.
I hadn't heard of autowrap -- I'll give it a try. Thanks! &amp;#x200B;
It's missing the ability to subscribe to topics. I'm digging into it to see how hard that would be to add. &amp;#x200B;
Rebol was understated, I really love the language and philosophy behind. There is an interesting project that aims to continue or enhance the work started with Rebol: https://www.red-lang.org
As a Clojure beginner, I really appreciated the comments in your code. Thanks for that.
Done. (typos: which makes *it* very easy‚Ä¶ we'll make CL *a* more‚Ä¶ CL need*s*)
My favorite alternative syntax that doesn't use Lisp S-expressions is a heap full of symbols, conses and other objects all pointing to each other. 
SETL...isp aside and work on bullshit. 
Thank you! Fixed!
I've received your donation. Will spend to pay for the server for the next few months.
It's pretty.
I am not aware that `format` has a directive for arrays as it does for lists. I would start with a quick hack like this: (defun print-2d-array (array) (loop for i from 0 below (array-dimension array 0) do (loop for j from 0 below (array-dimension array 1) do (format t "~3D " (aref array i j))) (terpri)))
Huh, this actually look quite nice. Thanks for sharing!
s/convert/print/g `(setf table2 (make-array 9 :displaced-to table))` will get you a flattened array that shares contents with `table`. If you modify `table2`, the values in `table` also change. Then you can convert table2 to a list by `(setf table3 (coerce table2 'list))`. Finally you can print it by (dolist (elem table3) (format t "~A " elem)), or more shorter one is (format t "~{~A ~}" table3) which is equivalent. `~{...~}` will iterate over a list. To remove the trailing whitespace, use (format t "~{~A~^ ~}" table3) where `~^` means "stop here if this is the last element". To combine everything into a single form (functionally) is your task
Dunno, it seems to be confusing if you have nested s-exprs which are all pretty deep for some reason. With rainbow-delimiters-mode though, it's pretty good. Maybe you can use an inverted-colours number or something like that to represent how many parens you hided?
Downvoting /u/borodust doesn't make what he wrote wrong, being wrong is what makes him wrong.
The creator of wisp hangs around in #guile on freenode. ArneBab. A very nice guy. He did a presentation about wisp in the guile devroom during FOSDEM maybe 2 years ago, which might be available online.
This will create a lot of overhead for the flattening and converting. Why not just print the array?
The lisp butt thing was merely thought as a joke but I was surprised how reliable it works. I should try the rainbow-delimiters some day and see how they can go together with the lisp butt idea. Maybe you go first? I invite you to do so.
Thank you for the pointer. I tried searching for the video of the [2016 presentation](https://archive.fosdem.org/2016/schedule/event/guilewisp/), but unfortunately it appears to be [lost](https://video.fosdem.org/2016/k3201/STATUS.TXT). But the good news is in the process I've found the [video on Wisp from the 2019 FOSDEM](https://www.youtube.com/watch?v=cI1sltJMVuM).
yes it is slow. you know, this would be good exercise for learning FORMAT. &amp;#x200B; Another example for the OP: (dotimes (i (array-total-size table)) (format t "\~a " (row-major-aref table i)))
Thanks for the help! I'll try that and see if it works. Since each 'cell' of the array will only contain a single character, i doubt i will need to change the \~3D formatting.
S-expressions are indeed part of the definition of lisp, but not the specific syntax we use for them today.
I started reading (finaly) SICP. I'm using Chez Scheme for it.
So: Chez scheme is extremely fast, but being proprietary until recently means it has a smaller ecosystem (but that is changing!). It has good documentation and is r6rs-compliant. When it comes to speed and how solid the implementation is, chez runs laps around all other scheme implementations. Chicken is a nice implementation, but the documentation can be hard to navigate. It is the nicest community online, and #chicken on Freenode is really the place that taught me scheme. I can't stress the community enough. They are amazing. Guile is my scheme of choice, mostly because it is reasonably r6rs-compliant and has a nice implementation. It is reasonably fast, and if you use guile 2.9 (beta for 3.0) it is about as fast as chicken below. It has a macro system based on syntax-case, which is knowlegde you can use in chez scheme and racket with very little modification. I rarely hear anything about MIT scheme, but that might just be my bubble. It seems like a solid implementation.
Chez has very good documentation. Why not?
It's been a while since I've done Scheme programming, but I can highly recommend [geiser](https://www.nongnu.org/geiser/) as a development environment. It supports a bunch of Schemes -- back in the day I used it with Guile, and it really was a nice experience.
guile 2.9 ? 3.0 ? I need to switch to your timeline
2.9.1 is the current head in the git repos (which will become guile 3), available as guile-next in GUIX. Watch Andy's presentation on guile 3 here https://www.youtube.com/watch?v=fWv4AlVbJZ8
Oh yeah I totally missed this. Thanks
&gt; When it comes to speed and how solid the implementation is, chez runs laps around all other scheme implementations. The sad exception being unboxed floats, where Gambit beats it.
Well no. Chez has no unboxed floats, so you are comparing boxed to unboxed floats. Of course gambit wins :D
I‚Äôm using Chez and it‚Äôs very high quality and fast. However I think the debugging experience isn‚Äôt great, and it integration with Geiser in Emacs isn‚Äôt so fantastic either. So I‚Äôd recommend Guile to begin with, which excels on both those fronts. If you need more speed you‚Äôll find it easy to work in any other implementation once you‚Äôve got the hang of it.
you could use racket, where there is a #lang sicp.
That's what I meant.
You can also use racket, starting your file with \`#lang r5rs\`. This adds DrRacket's IDE tools like variable-renaming etc, AND it gives you \`#;\` to comment out one following expression, which is awesome. Also, the ability to inter-operate w/ any other racket-lang. &amp;#x200B; BUT I just saw that in \`#lang r5rs\`, the repl doesn't print each result. So you'd have to explicitly call \`display\` on every result you wanted to see(\*), which is kinda a deal-breaker. &amp;#x200B; Myself, if I were working through that The Little Schemer, I'd use (full/regular) racket, but just have some top-level declarations \`(define first car)\` (asking on this group or /r/racket if you're not sure of how to translate something). I think very few such re-names would be necessary. &amp;#x200B; &amp;#x200B; (\*) I thought about wrapping the entire file inside a \`(map display (list ...))\`, but that won't allow \`define\` inside there.
For The Little Schemer you can literally use any implementation you want. At that point it just comes down to ease of use. &amp;#x200B; If you're on Linux I would recommend guile + geiser since the autodoc works perfectly and without any setup. If you're on Windows then Chez Scheme ain't too bad since it has an easy installation. Optionally, you could install msys2 and get guile again. &amp;#x200B; When you actually want to start developing stuff I would go with Chez/Chicken/Guile or you can try Racket. Chez is incredibly solid and fast. Chicken has an interesting implementation and a very nice community. Guile is great for using with C and comes on almost every system by default. Racket I'm not a particularly big fan of but it is an excellent project.
oh sorry. I wonder if it could be worked around using the FFI, or whether calling in and out of chez and handling the external memory would be too much overhead. 
Racket it has a pure scheme mode and is turn key. 
Chez scheme was released as open source. 
"‚Ä¶ being proprietary until recently [‚Ä¶]".
Oops 
wow, it works fine!! Some questions: What did you use for the lisp code editor? It looks great! 
It's several years old, but [this](https://wingolog.org/archives/2013/01/07/an-opinionated-guide-to-scheme-implementations) is a great guide to choosing an implementation (written by the maintainer of Guile). My advice would actually be to try out a few different implementations while you're learning. Use a different implementation to work through each chapter or rotate implementations you use to complete the exercises. Once you actually start working on a project, you're going to want to pick an implementation for that project and stick with it. My first Scheme project I made the mistake of trying to make it compatible with multiple implementations. That way madness lies. If you've experimented with different implementations while learning, you'll be better prepared to pick the best one for your project. If you really want to stick with just one, I'd recommend Racket. It's a good all-around implementation.
A little bit of "history": a few years ago I started a project "EQL" to integrate ECL with Qt (like a binding, but with some low level parts, mostly for speed). This project has come a long way, and is now called "EQL5" (because of Qt5). So, I already had EQL5, which features quite a few examples, one of them being a simple and experimental CL editor (example 9). I then tried to port the whole thing to android, which was less work than I thought. So, I used QML (from Qt5) for the UI, and an adapted version of the simple CL editor from EQL5 (I basically needed only to glue together the pieces that I already had, except for the QML part). But check out for yourself if you're interested: [example REPL](https://gitlab.com/eql/EQL5-Android/tree/master/examples/REPL)
Happens to the best of us!
Do either `(use-package :qtools)` or `(qtools:define-widget ...)`
If I wasn't doing that I'd get undefined DEFINE-WIDGET on that form rather than undefine MAIN-WINDOW from the final form.
Nope, you would get undefined `MAIN-WINDOW` first. `DEFINE-WIDGET` would get treated as a function, which means that its arguments are evaluated first in-order. The first argument is `MAIN-WINDOW` that, in this context, is indeed an unbound variable.
To be clear, evaluating: (define-widget main-window (QWidget) ()) Does not produce an error. Are you saying it would succesfully evaluate if define-widget was undefined?
Hm. Can you give me the complete stack trace for evaluating `(with-main-window (window 'main-window))`?
 Backtrace: 0: ((:METHOD %MAIN-WINDOW-SUBWIDGET-NAME-INITIALIZER (MAIN-WINDOW)) #&lt;MAIN-WINDOW QWidget 0x7FFFCC002C00&gt;) [fast-method] 1: (CALL-INITIALIZERS #&lt;MAIN-WINDOW QWidget 0x7FFFCC002C00&gt;) 2: ((:METHOD INITIALIZE-INSTANCE (WIDGET)) #&lt;MAIN-WINDOW QWidget 0x7FFFCC002C00&gt;) [fast-method] 3: ((:METHOD INITIALIZE-INSTANCE :AROUND (DYNAMIC-OBJECT)) #&lt;MAIN-WINDOW QWidget 0x7FFFCC002C00&gt;) [fast-method] 4: (SB-PCL::FAST-MAKE-INSTANCE #&lt;unavailable argument&gt; #&lt;more unavailable arguments&gt;) [more] 5: ((LABELS QTOOLS::MAIN :IN QTOOLS::MAIN-WINDOW-EXEC)) 6: (QTOOLS::MAIN-WINDOW-EXEC #&lt;FUNCTION (LAMBDA NIL) {1001F892DB}&gt; :NAME NIL :QAPPLICATION-ARGS NIL :BLOCKING T :MAIN-THREAD NIL :ON-ERROR #&lt;FUNCTION INVOKE-DEBUGGER&gt; :SHOW T :FINALIZE T :BEFORE-EXEC #&lt;F.. 7: (SB-INT:SIMPLE-EVAL-IN-LEXENV (WITH-MAIN-WINDOW (WINDOW (QUOTE MAIN-WINDOW))) #&lt;NULL-LEXENV&gt;) 8: (EVAL (WITH-MAIN-WINDOW (WINDOW (QUOTE MAIN-WINDOW)))) 
As far as I understand it, the problem lies in boxing of scalar values. Unboxed vectors can already be made either using the FFI or by using bytevectors and the bytevector-ieee-double-native-ref and bytevector-ieee-double-native-set! functions. But anything extracted will be immediately boxed, as will be all intermediate results. It would be cool if a chain of computations beginning with FFI- or bytevector-ieee-double-native-ref-extracted values and ending with the respective store operations could avoid boxing. I feel like this alone would make numerics much more useful.
What's really weird, and I've only just noticed it, is this: the error is actually "undefined variable main-widow." But everywhere in my code it's definitely "main-window". Time to restart inferior lisp I think. 
Hmm. Widow. Well that let me to finding a typo. But having fixed that I now get: ESA-MODELLER-GUI&gt; (with-main-window (window 'main-window)) =&gt; #&lt;MAIN-WINDOW QWidget DELETED&gt; 
`(make-array (list x y))`
Okay, you fixed a typo. (; As for this error, you must have encountered a case of https://github.com/Shinmera/qtools/issues/28#issuecomment-474586374 tl;dr restart your Lisp, reload your code, and when you get an error, do **not** use the topmost `ABORT` restart to recover from the error as it will effectively kill your Qt application.
To expand on this, this is happening because Lisp doesn't evaluate forms preceded by single quotes. So your code is literally using X and Y as the arguments, rather than 10 and 20 as you intended. Another way of writing the above would be: `(make-array \`(,x ,y))` But that's some syntactic sugar you might not have come across yet. If you find it confusing, better to stick with the first answer.
Oh! Thank you.
No problem! `#shirakumo` on Freenode should be able to provide you with more direct qtools support in the future.
Thank you sm! It worked on the first try!
I've heard of the back-quote system, but I didn't know it could be used for this purpose. Where could i learn more about the back-quote system? I haven't seen anything like it in other languages.
You're right - other languages don't usually have the need to have such systems in place. https://letoverlambda.com/index.cl/guest/chap4.html - there is a subchapter called Backquote here.
If quicklisp cannot do proper https now you can instead hand-roll a signing and certificate system. It is what Debian does for package distribution. You could do this as simple as signing downloadable things with a gpg key, the public part of it residing in the base quicklisp file that users download via https.
what do you mean running inferior-lisp-mode, why aren't you running m-x slime from the get go? Or am I misunderstanding what you are doing? the Slime command should start Swank in the inferior lisp by itself. You can alternatively start SBCL on a terminal then (ql:quickload :swank) followed bu (swank:create-server). Then in emacs you should be able to connect using m-x slime-connect, the default options should work ok. &amp;#x200B;
Slime gets loaded automatically when I open a .lisp file. But yeah I tried running `slime` by hand as well. I'll try the quicklisp library thing later though, that seems promising.
s7 scheme
If you just want to go through the Little Schemer (great book btw, and after you can grab The Seasoned Schemer for a follow up), then as people say, really any interpreter will do. Chez Scheme is great, Racket is good, although they have diverged a bit from Scheme proper, but not enough that it will matter for the book, Guile Scheme is really nice on Linux. If this is sort of a longer term thing that you are thinking of working with Scheme a bit more I would say that you are probably well served by using a Scheme that supports R7RS, which is basically the 7th edition of the Scheme standard. Chez Scheme supports R6RS, but that was a controversial standard and R7RS basically "rebuts" it in a way. It's not worth getting too into the weeds over, but the important thing is that R7RS introduced a mechanism for creating libraries of code, and for the first time in a while Scheme is getting some decently large libraries of reusable code distributed in a form that theoretically a large number of implementations can make use of. As great as Chez Scheme is, it doesn't support R7RS right now, and for that reason I wouldn't make it my primary interpreter. MIT Scheme supports R7RS, so does Guile, I like Gauche Scheme, you have Sagittarius Scheme, Larceny Scheme, Kawa Scheme (if you want java interop) and Chibi Scheme as well. So you have a bunch of choices that all support R7RS and each should its own strengths that might appeal to you. For myself I use Gauche Scheme and am happy with it. Hope that helps, and happy Scheming! 
I suppose a rather universal thing to do in such situations, when X as a subform of another form seems to cause a problem but Y doesn't, is to just evaluate X alone and watch what comes out. It may sound trivial but that's exactly what you should have done.
Thank you, I resolved the issue. I hadn't installed Quicklisp, because I thought SBCL came with it. So I installed that and copied the quicklisp folder and .sbclrc file from my user folder to the AppData/Roaming folder so Emacs loads it correctly. Thank you :)
If there is something like [Termux](https://play.google.com/store/apps/details?id=com.termux) on iOS, it might be possible. If not, porting Termux to iOS can be a useful week long project for someone.
I, too, would love something like Pythonista but in CL. I've never seen anything remotely like it. Someone did a bunch of groundwork to make [ECL compile in iOS](https://github.com/kriyative/ecl-iphone-builder) but it hasn't been touched in several years as far as I can see.
I don't see anything like that when I did a search just now. Unfortunately, that project is outside my skillset at the moment :(.
Bummer, so My Lisp might be the closest that I would get to?
hello a nice tutorial on macros: https://medium.com/@MartinCracauer/a-gentle-introduction-to-compile-time-computing-part-3-scientific-units-8e41d8a727ca some macros and backquote stuff: https://lispcookbook.github.io/cl-cookbook/macros.html long talk on macros: https://www.youtube.com/watch?v=ygKXeLKhiTI
Twitter spam.
Yes.
Yes.
Yes. Could you post your code? It'll be good to give it some general review, and you'll be able to learn a thing or two in the process.
Its because I can't use (load ...) to return the result of the code in the context I used it so I had to read the file normally but it just return a list. So I had the choice to turn that fonction into a macro wich fucked everything or call eval on what it was returning
I still don't understand it. Can you post your code sample?
 (defun w-render (template-path) (let (pat view) (setf pat (merge-pathnames (pathname (concatenate 'string template-path ".lisp")) *who-template-directory* )) (setf view (open pat)) (prog1 (eval (read view)) (close view))))
Is that Windows XP the screenshotted program was running in?!
5) Continue developing my own?
Hmmm. What is inside that Lisp file that you are opening? Where does the `*who-templates*` variable come from? I can't find it in the CL-WHO manual. I've rewritten your function to the following that should be a little bit more idiomatic and correct. (defun w-render (template-path) (let* ((path (merge-pathnames (concatenate 'string template-path ".lisp") *who-template-directory*))) (with-open-file (s path) (read s))))
Hm. I'm pretty sure there are things for which there are no standardized functional interfaces, like TRACE, or ADVISE in CCL. Without eval-ing a form, how would I go about doing such a thing programmatically without replicating the function of EVAL and/or without looking into what those forms do for each individual implementation?
Yes.
I have a file that contain this macro (defmacro who-tmpl (title (&amp;key lcss ljs lmeta) &amp;body body) (let ((css (gensym)) (js (gensym)) (meta (gensym)) (env (gensym))) (setf css (mapcar #'(lambda (x) (concatenate 'string "css/" x ))lcss)) (setf js (mapcar #'(lambda (x) (concatenate 'string "js/" x ))ljs)) (setf meta lmeta) (setf env *lib*) (when env (loop for x in env do(if (listp x) (cond ((eq (car x) :js) (setf js (append (cdr x) js))) ((eq (car x) :css) (setf css (append (cdr x) css))) ((eq (car x) :meta) (setf meta (append (cdr x) meta))) (t (print "One of your keywords was invalid"))) (print "One of your frontend library wasnt a list")))) `(with-html-output-to-string (output nil :prologue t :indent t) (:html :lang ,*locale* (:head (:title ,title) (:meta :charset "utf-8") ,@(when meta (mapcar #'(lambda (x) `(:meta ,@x)) meta)) ,@(when css (mapcar #'(lambda (x) `(:link :rel "css" :href ,x)) css))) (:body ,@body ,@(mapcar #'(lambda (x) `(:script :src ,x)) js)))))) I made a folder in the templates directory containing the views that works with cl-who. \*who-templates\* id the pathname to that folder that I defined in the config file. I call this macro like this in those files. (cl-ecf.macro:who-tmpl "index" (:lcss ("main.css" ):ljs ("main.js")) (:div :class "main" (:h1 "Lisp is awesome") (:form :action "/test" :method "POST" (:div :class "form-group" (:label :name "test" "text") (:input :type "text" :name "test") (:input :type "text" :name "bla") (:input :type "text" :name "tg")) (:div :class "form-group" (:input :type "submit" :name "submit"))))) and the fonctions I posted above read those files. if I don't put eval its just gonna return the list. I use the fonction here in the web.lisp file @route GET "/" (defun index () (w-render "index"))
Now *this* is a proper question body that you should have asked in the beginning. It is nowhere as trivial as the original, and I really wonder if it can be done in a better way than calling `eval`. Perhaps make a post with this in the post body.
Changing w-render into a macro kinda works as it put the list into the route body to be evaluated so you don't need eval but for some reasons it wouldn't update if I changed the index file. Even if I restart sbcl. I'll put the code in the post even if I originaly just wanted to make the "Am I gonna die ? "Joke
No, all Lispers are immortal.
if the file has only one form, then (eval (read stream)) is simply (load file)
Load returns t not the result. It just load the file into the environnement
Yes. Fun fact: both Clojure and Leiningen work just fine on Windows XP.
Numpy has an absolutely terrible API, so to answer the question, very unhappy.
[http://ix.io/1Epi](http://ix.io/1Epi)
Two comments: 1. This: (let ((var something)) (setf var something-else) ... is the same as (let ((var something-else)) ... and the latter is much cleaner. All those calls to gensym you have in the first four lines of who-templ are just thrown away. 2. You are correct that (eval (read ...)) returns the value and LOAD doesn't. However, you're not actually using the returned value AFAICT so you might as well use LOAD. If you use LOAD, you can compile the file, and everything will run much faster.
Is cl-who obligatory ? For the little I used it, I prefered Spinneret, which I found simpler to compose and which has some more features (embedded markdown, automatic numbering of &lt;h&gt; tags, warnings on malformed html,‚Ä¶) : https://github.com/ruricolist/spinneret/ Flute claims to be even simpler to compose tags and functions: https://github.com/CodyReichert/awesome-cl#html-generators-and-templates
For mention, ECl has [a REPL for Android](https://www.reddit.com/r/lisp/comments/b1wnn2/cl_repl_for_android_now_64bit_ssl_libs_included/)‚Ä¶ 
It seems cider is causing some compilation problems for you. Remove cider from project.clj and try again.
Oh shit, yeah I forgot to push it. Here it is https://youtu.be/O_iAkZNP99c
Thanks. Isn‚Äôt quite what I‚Äôm looking for though, since I don‚Äôt have an Android device. 
you could ssh onto a device using MOSH that has CL installed
Thanks for the first one . ButI need to return html to the route though.. how would that work with load ?
You could probably work around calling eval in any number of ways. The first thought that comes to mind is that you could have the file define a function that is named based off of the path, and then invoke the function. This would also allow optimizations such as checking the modification time of the file, and not reloading the file if it hasn't changed. Binding a special variable around the LOAD form would allow you to communicate to the file what function you wanted it to bind, or you could use something along the lines of `cl:*compile-file-truename*`. For various reasons, I would prefer the former. Also, there is something wrong with me in that I must point out that `cl-who` templates can be used modularly without macros. See [my most recent paste](https://gist.github.com/jasom/4d6d8aa38204f3c80db974cb20140aec) for an example of when someone asked about this.
Cool! I've seen a few Tetris implementations in Racket. A (non-exhaustive) list: ( * https://gitlab.com/dustyweb/racktris * https://github.com/ra2yama/racket-tetris * https://gitlab.com/dimitrisstr/tetris )
Seeing that the keyswitches for the new and old style boards aren't produced anymore then that'd be difficult. But depending on what you're looking for, something really similar could easily be made with available hw. Especially nowadays that programmable keyboards are both popular and affordable.
You might also want to consider using with-html-output rather than with-html-output-to-string. That outputs the HTML to a stream as a side effect when the form is called. It has two advantages: first, you don't need to worry about the return value, and second, it's more efficient since you don't need to store the entire page in memory before emitting it. 
[Petalisp](https://github.com/marcoheisig/Petalisp) exists. I wrote a [very boring neural network](https://gist.github.com/nodefunallowed/95b95469449124570f36bb05192b7ef8) using it.
That is definitely an option. The reason I was looking at something that worked entirely offline was that my data connection is not entirely reliable on the train. I realise that I wasn‚Äôt clear about that in my post. 
MOSH is designed for unreliable data connections, that's the whole idea behind it
There‚Äôs iSH but so far my efforts to get git to clone Roswell have failed, have yet to try just installing sbcl directly. Emacs works though, where 2 months ago it didn‚Äôt work. It‚Äôs currety only available if you register as a beta tester and download it with TestFlight. Apple may perhaps never allow the app in the App Store, who knows. https://github.com/tbodt/ish/
Thanks! I‚Äôll take a look into that :). 
unless you want the 1sec per sec forward chaining model
You are sort-of out of luck, at least for right now. I also like Haskell and the Raskell iOS app is very good, as is Pythonista. For Lisp, the Gambit Scheme editor and runtime for Gambit by Mark F. Is probably the best you can do.
Thanks for the link to Petalisp - didn‚Äôt know that existed.
I agree with all points you made, but here's my two cents: I know Lispers are in general terrible at documentation. If everything is guaranteed to replicate the behavior of numpy, can't we just delegate the documentation effort to the numpy community?
Me too. But apparently later in the book there is example using something called pictures language. It is fully implented in racket sicp language. If i ever reach this far in SICP i will use racket for this chapter with picture language. 
Thanks ! But I need clarification on the first one. You mean putting a defun in the file and manually putting the function name and manually writing the name in the route after loading ? Or can I use the paul graham function SYMB to generate a symbol name outside of a macro ( I know alexandria has a function like that too but I'm too lazy to check). I will definetly rethink my code a little bit to generate the html moduraly with functions though. And what do you mean by throwing a value ?
Well, that's because Numpy works by default on arrays, not matrices. In that context `a * b` being element-wise operation makes complete sense (think e.g. image manipulation!). `a.dot(b)` for 2d arrays is a straight extension of vector dot product into higher dimensions (matrix multiplication **is** calculating dot products!). If you want `a*b` to mean matrix multiplication and not element-wise multiplication, you need to work on matrices not arrays, i.e. use the `numpy.matrix` object and not `numpy.array`. Then the operations are as you expect. It is discouraged, though, because it is easy to make a mistake and thanks to the "duck typing" (every numpy matrix is also a numpy array) Python will happily perform the wrong operation when you least expect it. Numpy doesn't use `a @ b` syntax because it didn't exist before Python 3.5+. Also this operator behaves a bit differently than the numpy's .dot() function: [https://stackoverflow.com/questions/34142485/difference-between-numpy-dot-and-python-3-5-matrix-multiplication](https://stackoverflow.com/questions/34142485/difference-between-numpy-dot-and-python-3-5-matrix-multiplication)
Keep in mind that it has the radioactive AGPL license ... 
I'm kind of doing this here (though, I'm caught b/w numpy and pytorch ATM), [https://github.com/akssri/tanti](https://github.com/akssri/tanti) I have a private branch with a reasonably complete CUDA/CUBLAS interface. Some of the templating mechanism is not as clean as I'd like, but it's use is minimal (as are the "inlined" inlined-gf portions) in order for a future cleanup. It's sufficiently mature to do im2col in \~5 lines, [https://gist.github.com/akssri/9575d5ede00d26525aeee496d835e3be](https://gist.github.com/akssri/9575d5ede00d26525aeee496d835e3be) &amp;#x200B; Ping me if you're interested.
That. Especially Pandas. It's abysmal when compared to alternatives.
Many thanks for the experienced Schemers commenting on this thread. I always wanted to hear opinions on the different Scheme impls out there.
&gt;Am I gonna die ? ``` T ``` 
&gt; Numpy has an absolutely terrible API This. This can't be repeated more often. Just because it's popular, it doesn't mean it's exemplary.
and when the API changes, will you also change your software? The python community also frequently makes breaking changes to their APIs whereas the Lisp community writes stable software.
The biggest issue I can think of is something like slime would have to be aware of the (make-file-local) calls too.
What are the best alternatives ?
I finally got around to trying cl-autowrap. I seem to be doing something wrong because it's not generating the bindings in my package: `(ql:quickload :cl-autowrap)` &amp;#x200B; `(defpackage :kafka-autowrap-ffi` `(:use :common-lisp)` `(:export #:rd-kafka-t` `#:rd-kafka-version` `#:rd-kafka-metadata))` &amp;#x200B; `(in-package :kafka-autowrap-ffi)` &amp;#x200B; `(autowrap:c-include "rdkafka.h")` &amp;#x200B; `(rd-kafka-version)` &amp;#x200B; This tells me that rd-kafka-version isn't in kafka-autowrap-ffi. The spec files are created in my directory, though. Any idea what I'm doing wrong? &amp;#x200B;
R for one. Particularly Tidyverse/dplyr ‚Äî and the whole R stack. Matlab. Mathematica.
Awesome! Thanks!
I was thinking something like: ``` (let ((*path-fname* (intern template-path "MYPACKAGE"))) (let (pat view) (setf pat (merge-pathnames (pathname (concatenate 'string template-path ".lisp")) *who-template-directory* )) (load pat) (funcall *path-fname*))) ``` Then each template file would look something like: ``` (defun #.whatever-package::*path-fname* () (who-tmpl ...)) ``` Keeping track of the file modification time to prevent LOADing an unchanged template file could be then added to this.
In 2008 I made this thing called [PKG](http://www.kylheku.com/cgit/lisp-snippets/tree/pkg.lisp) which binds various package-manipulating directives to `#@` (hash at) syntax.
Please see this CDR entry about file-local variables: https://common-lisp.net/project/cdr/document/9/index.html Also please check out extension ASDF-FLV which adds this behavior for files loaded by ASDF .
(in Clojure)
[Beginnings of rdkafka bindings](https://gist.github.com/death/5417fba6aa9eea4a83d4846d5ae2b0a8) Create a `kafka` directory for the project, and place these files in it. Create a `spec` subdirectory, and place the `rdkafka.h` header file in it. After quickloading, you should be able to start writing the high-level interface. Do include the generated spec files in your repository, so that others won't need to generate them themselves.
I think you mean, to connect from iPhone to a computer with CL installed. Am I right?
you are correct
Isn't this just [shadow](http://clhs.lisp.se/Body/f_shadow.htm#shadow)?
I am a Clojure-noob, this kind of sweet little project makes learning a treat
I am curious to know, if you have used any reference or learning material to build this
with the first one. I could also have them allloaded automatically when I start the server ! so it doesnt need to load and compile shit each time a request is made 
What about lexical scoping?
Nice, this fixed! Great game.
How do you know there's no problem with Y if it hasn't been evaluated yet?
Fantastic! Thanks!
I'm not sure I understand what's happening here. Could you give me a example where this is useful?
Shadowing basically makes a certain symbol name refer to the symbol in the current package, regardless of what other packages it uses. It is also a defpackage option: CL-USER&gt; (defpackage :blahhh (:use :cl) (:shadow :append)) #&lt;PACKAGE "BLAHHH"&gt; CL-USER&gt; (in-package :blahhh) BLAHHH&gt; (defun append (x y) (list x y)) APPEND It's basically used when you don't want to use some package but don't want to import a certain symbol from it because it clashes with your own package. There's also :shadowing-import-from when you're using two packages exporting symbols with the same name, and want to import just one of them (importing both would result in an error).
Why not just make all symbols file local, except some specific ones which are not? For that, we create some throway package just for that file, and switch to that. In that package, we import or use whatever is necessary from other packages; everything else gets newly interned in that package. (defpackage anon-package-13df-4109 (:use ...) (:import ...)) (in-package anon-package-13df-4109) (defun foo ()) ;; foo is anon-package-13df-4109::foo (defun bar () ;; bar is our-api:bar, brought in via import (foo)) ;; calls the private foo
But this is something else: a way to add to the set of special variables that are bound at the start of a `load` and then restored at the end. CL has several such variables: `*readtable*` and `*package*`, but no way to make your own. 
This is generally the pattern I use for complex files. However, I frequently find myself just dumping a lot of things into the same package without exporting anything (like: my website, it's not really a library.. until I find something that really needs to be extracted out everything just goes into the same package). In that case, with this strategy if all my code is in the "universe" package, then universe would need to import each of the anon packages, and each of the anon packages need to explicitly export the symbols. It's fine, and as I said I do this frequently, but often times it's more work than I would care for. It would be nice to have a few of the symbols file-private by default. (Like a statically linked function in a C file.) My argument is that this doesn't need any change to Common Lisp, it's easily (I think) implementable using readtables, but I was wondering why it doesn't already exist (although asdf-flv seems to be \*close\*, but not exactly what I had in mind) &amp;#x200B;
Oh wow! This is fantastic! Thanks! Not exactly what I had in mind, but I can imagine so many other uses for this. (Especially overriding existing methods, like hunchentoot:easy-handler). I do think this would \*reduce\* my need for the library in my post.
This is not general enough. I'd have a way to register an initialization and cleanup hook for each of these variables. That is to say, what if I don't want to bind the variable to its existing value? Or what if I have some special clean-up that needs to take place: like removing something from a hash table, or whatever we can imagine. (defmethod asdf:perform :around ((operation asdf:load-op) (file asdf:cl-source-file)) "Establish new dynamic bindings for file-local variables." (progv *file-local-variables* (mapcar #‚Äôsymbol-value *file-local-variables*) (call-next-method))) We could have it so that `*file-local-variables*` is a list of the form `((var init cleanup) ...)` instead. Then: ;; bind specified variables to the values of their init exprs; eval cleanup exprs when done: ;; (compose comes from from cl-utilities) (progv *file-local-variables* (mapcar (compose eval cadr) *file-local-variables*) (unwind-protect (call-next-method)) (mapc (compose eval caddr) *file-local-variables*)) 
Hmm, I see. Yeah you're right, for a second I thought asdf-flv was what I was looking for but just for variables, but I see now that it's not. But yeah, I was aware of \*readtable\* and \*package\* (and was planning on abusing \*readtable\* to build the library I had in mind)
That 2nd edition of the "LISP" book used to be packaged with Golden Common Lisp (GClisp), which I believe was the first Common Lisp for the PC under DOS. It came with a version of Emacs called Gmacs that could be loaded from within the GClisp Read-Eval-Print-Loop (REPL). Interestingly, GClisp also came with the San Marco Lisp Explorer, which was an early Computer Based Training (CBT) system that allowed newcomers to interactively learn Common Lisp back in 1984-85. The CBT content was based on the 2nd edition of the "LISP" book by Winston and Horn, and Patrick Winston himself created it with others under the now defunct San Marco Associates company name. You can still get a copy of GClisp version 1.01 by Googling for "GClisp.zip" and get it running under DosBox with some minor config file editing. The San Marco Lisp Explorer can also run under DosBox when called/loaded from within the GClisp REPL, and it contained around 60 lessons teaching Common Lisp programming and AI concepts. The lessons consisted of 1,000 interactive slides, hands-on "live" exercises using the underlying GClisp system from within the CBT itself (is that conceptually recursive?), Question/Answer sessions, and AI simulations. However, GClisp version 1.01, and the included CBT, seemed to have covered only a subset of CLtL1, and didn't seem to support lexical scope among many other things. Lexical scope was eventually introduced in GClisp version 1.1 just a few years later, and that version can also be found by Googling. But, I don't know if a version 1.1 or later of the San Marco Lisp Explorer was ever created, or if a later version of that CBT ever supported teaching a proper subset of ANSI Common Lisp. That being said, when taken as a whole, the entire GClisp package seemed quite advanced for a DOS application of its time, even by today's standards of an application accessed from a Command Line Interface (CLI). In particular, the REPL offered key-chord commands to access/call and navigate parts of the system that could be nice to include as features of convenience in the native, non-SLIME, REPLs that are currently offered by today's open source Common Lisp implementations. There's a profile of Gold Hill Computers, the publishers of Golden Common Lisp, at the following Wayback Machine link that some might find interesting: [https://web.archive.org/web/20190327030949/https://ieeexplore.ieee.org/ielx5/64/4306967/04306983.pdf?tp=&amp;arnumber=4306983&amp;isnumber=4306967](https://web.archive.org/web/20190327030949/https://ieeexplore.ieee.org/ielx5/64/4306967/04306983.pdf?tp=&amp;arnumber=4306983&amp;isnumber=4306967)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/aXLijOG.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20ejhc0ne) 
Source: http://www.bitsavers.org/pdf/mit/ai/Greenberg_Notes_on_the_Programming_Language_LISP_1978.pdf Inspired by: https://twitter.com/RainerJoswig/status/1109768365621551105 
&gt; Note that i have no problems making the array with integers, i.e. &gt; (setq table (make-array '(10 20))) So apparently it *has* been evaluated?
the host website is interesting as is http://www.bitsavers.org/
spaghettisp
not sure if the name is correct but 'sweet expression' ? where the top level parens are optional defun foo (x) (if ... (call/cc ..) ...) let ((x 1)) (do ... (... x) ...) things like that. That's my sexp-less limit. Otherwise I become a full on sml-er
I started out with something like this, then continued on my own: https://github.com/luontola/tdd-tetris-tutorial
Petalisp author here. Thanks for mentioning my PhD project! Currently, Petalisp is still slightly slower than Numpy, because I want to get things 'right' before I spend a lot of time optimizing them. So there are some low-hanging fruits regarding performance, e.g., multi-threading and better inlining heuristics. Good news is, I am almost done with the design, so expect some performance improvements in the near future. Probably right after this year's [ELS](https://european-lisp-symposium.org/). Since the Topic is about Numpy, I should also mention I recently wrote a library for executing Lisp code from within Python programs - [cl4py](https://github.com/marcoheisig/cl4py) \- and a wrapper library such that Python programs can actually [use Petalisp instead of Numpy](https://github.com/marcoheisig/petalisp-for-python). (The latter is quite rudimentary, but fun to use). PS: [Feedback](https://github.com/marcoheisig/Petalisp/issues) is most welcome.
The license might change in the future. One idea is to put everything but the native code generator under MIT license. Then everyone could use Petalisp, but fast execution would still be AGPL-only. But I am again and again surprised how negative some people react to strong copyleft licenses. As if we wouldn't all benefit tremendously from free software... (but please, let's not discuss this further)
&gt;I know Lispers are in general terrible at documentation. For me, [Quickref](https://quickref.common-lisp.net/) is a real game changer with respect to Lisp documentation. I think the biggest reason for the lack of Lisp-documentation is that in the Lisp community, stating "The code is the documentation" is actually viable. Most lispers like to read code, and everyone has M-. to quickly find definitions. But now that there is a tool that uses docstrings for a good purpose - to automatically create and host user manuals - I feel much more motivated to write extensive documentation.
Off topic, but I much prefer Quickdocs due to its UI excellence. Just compare these two examples: * https://quickref.common-lisp.net/cl-ppcre.html * http://quickdocs.org/cl-ppcre/ Declt output in quickref is terrible, it has bloated margins, has too much templates, and is missing the visual que to find the information you want. Quicklisp has the right CSS, right link to the important / related materials, like dependency and who uses libraries. The search input is always on the top right. Now check the API reference page: * http://quickdocs.org/cl-ppcre/api It is beautifully done. There are no useless pile of repeated information like the package and the filename.
I inverted the colours and scaled it down to 1080p for myself. If anyone else wants it, here you go: https://imgur.com/a/uTuUCXQ Thanks for the find, OP. Was an interesting read and I love the diagram.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/sIsubFP.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
&gt; I inverted the colours and scaled it down to 1080p for myself. If anyone else wants it, here you go: https://imgur.com/a/uTuUCXQ Cool ! Thank you !
But I'm gonna give you a silver for that because it was a lot of fun and the kind of "wtf I can do that ?" Thing I so fucking love about lisp ! My whole things turns out to not work at all if I want to pass parameters though. Gonna try to find by myself
There is no problem with strong copyleft as such - if you have used GPL or LGPL (which would make more sense for a library), nobody would say anything. But AGPL pretty much guarantees that nobody involved with any sort of business will touch it (maybe preventing unpaid commercial use was your goal - but this is a very poor way of going about it, IMO). It even prevents the use of such code with otherwise GPL-ed codebase (it forces relicensing under AGPL, which may not be possible). I am not sure what lead you to select such an obscure license for your project - AGPL is meant to cover stuff that is provided as a service to someone else (e.g. some kind of web service or hosted software), using it on a general purpose library is extremely restrictive. MongoDB tried to relicense their database to AGPL - and the backlash was fierce. Of course, it is your code and you have the full right to choose any license terms you want. 
7pm UTC happens when this comment is 2 hours and 39 minutes old. You can find the live countdown here: https://countle.com/hukwAoSoW --- I'm a bot, if you want to send feedback, please comment below or send a PM.
thanks
Yeah, CL is cool because it can be so malleable. FWIW I think the "throw" example is a Bad Idea in production, but it's awesome that you can do it.
Why do I always see these posts too late? I thought "this week for sure", but here I am, having missed it again. Next week for sure.
I do post them too late too often. I'll try and get better at that
It's my fault that I keep missing them. I saw this one 4 hours late. I guess I should turn on notifications for r/lisp.
Please turn issues on in that repository. It does not seem that foreign libraries for Python 3.7 are supported.
Recording of the stream: https://youtu.be/aiJxkaxMBVE
I'm not the author, author is Masatoshi SANO. I have forked the project as well, and [activated Issues on my fork](https://github.com/defunkydrummer/burgled-batteries3), if it's of any value. 
\+1 (reminder: see also how Lem does to speak to a Python process (and others) with asnyc-process: https://github.com/cxxxr/async-process/) 
A couple of things off the top of my head: * Clojure doesn't allow user-defined reader macros. * Clojure has only one implementation, whereas CL has a number of implementations.
Here‚Äôs what I can think of: - disassemble - dribble - image saving - CLOS - Clojure is a lisp-1, CL √† lisp-n - fasls, but I guess it could be argued 
Shouldn't the conses be drawn as molecules?
Condition system, restarts etc
CL: - multiple values return - conses
Nice! Keras on Common Lisp anyone?
Clojure has fewer stuck-up a\*\*holes ? Seriously, the CL community is just so unfriendly, and passive aggressive. Pity, the language is no nice.
Is that an example of what a community should be like?
This is someone's answer from yesterday: https://www.reddit.com/r/Clojure/comments/b6137w/how_do_you_see_the_future_of_lisp_does_common/ejis5ut/ about how CLOS &gt; elegantly solves the same problems as Clojure's defmulti, defprotocol, defstruct, defrecord, and now protocols in metadata. It also adds enough typing that something like clojure.spec/schema become superfluous. about Lisp all the way down, and more. Some related questions asked this year: https://lisp-journey.gitlab.io/blog/these-years-in-common-lisp-2018/#discussion Don't be afraid to try out CL. http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/ The library situation (and editor support) might be better than you think: https://github.com/CodyReichert/awesome-cl Lastly, one key point for me: CL is a breeze to develop in, whereas Clojure eats my CPU and memory.
Given that multiple CL libraries use implementation internals I don't think it's fair to say that Clohure that doesn't allow user-defined reader macros but rather that it has no stable API for reader macros. Clojure has ClojureScript which is a different implementation.
&gt; I don't think it's fair to say that Clohure that doesn't allow user-defined reader macros but rather that it has no stable API for reader macros. Fair point. Is it likely to ever have a stable API for the equivalent of CL's user-defined reader macros? i seem to recall that Hickey is opposed to Clojure having such functionality? &gt; Clojure has ClojureScript which is a different implementation. You're right; and it seems to not be considered a second-class implementation, in that Cognitect provides support for it.
Dylan.
Original title is "I built a lisp compiler", but I did not suggest I might be that person. Even if I think a lot about writing one myself, lately ...
&gt; What does Common Lisp have that Clojure doesn't Good implementations. &gt; and vice-versa? Users.
discussion on hacker news: https://news.ycombinator.com/item?id=19508616
Don't most lisps have a compiler?
This is super good.
Thanks!
Yes. 
&gt; Clojure has ClojureScript which is a different implementation. But it [isn't the same language](https://clojurescript.org/about/differences), there are key differences like supported data types, the way equality works, etc. While the many implementations of Common Lisp implement the same language; my code for example will run identical on SBCL and CCL, and the libraries it uses will also work fine. 
[removed]
You wrote it? Good job on the article!
You are right that Hickey is opposed to exposing that functionality to the user, but that doesn't mean the user can't do it. [https://github.com/klutometis/reader-macros](https://github.com/klutometis/reader-macros)
Yes, I wrote the article.
Is it just me, or does everyone else here also dream of writing their own version of LISP? I don't know why I do, except maybe because LISP is so beautiful as a language it doesn't seem like an initial version would be that hard.
&gt; my code for example will run identical on SBCL and CCL, and the libraries it uses will also work fine. Only if written in [portable](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#portable) Common Lisp in a conforming implementation. Quite a few libraries are not-portable and some implementations like ABCL are not conforming (they are almost there though). For example if your code uses `#\No-break_space`[0] as character name then its not portable. This is not a theoretical issue, I've run into this when loading spinneret on ABCL. Yes I submitted a patch[1] and it was promptly merged, implementations try to avoid diverging but they do. Languages, even standardized ones like CL, are allowed to differ. Which is why I don't think its fair to consider Clojure and ClojureScript different language. Especially if you can write code that runs in both, normally with the `cljx` extension. With that said its fair to say that Common Lisp is more thoroughly specified. Hickey has gone on record saying 'we don't guarantee that a user error signals an error' when responding to someone reporting that (+ 1 "1") signals an error in Clojure but returns "11" in ClojureScript. [0]: https://github.com/ruricolist/spinneret/blob/c2d454847841237fce41d39fe48ab0958cb6a5b9/syntax.lisp#L9 [1]: https://github.com/armedbear/abcl/commit/8542252419450642a6526d8874db4e5770f8b4f9
Fortunately I can tell him :)
&gt; only fools and geniuses insist on implementing their &gt; own languages, and you can never tell which is which until afterwards. -- from https://www.xach.com/naggum/articles/3114703986711421%40naggum.no.html
I already know which category I would fall in, unfortunately.
&gt; Fortunately I can tell him :) Edit: the issues should be activated now. Great, thank you very much! He also accepted my PR too :)
No worries, we all pass through that [category](https://youtu.be/5gdqj0V231E?t=29)...more than once.
I know which one I would fall in, if I weren't clenching the genius rope so desperately.
lol. little scheme for little schemer
Cant remember how many guides on this matter was passed through my head..
Here's the process I'd recommend for those who want to implement a Lisp: `#1=("Use and learn the differences between all the different members of the Lisp programming language family" "Read LiSP -`[`https://en.wikipedia.org/wiki/Lisp_in_Small_Pieces`](https://en.wikipedia.org/wiki/Lisp_in_Small_Pieces)`" "Use an existing lisp to bootstrap your new implementation" . #1#)` Having said that, once your brainstack overflows, learn a way to use your dumped memory with a debugger. Then, and only then, can you set (car #1#) to include your new language, and keep on printing! :) 
Sorry for a "stupid" suggestion (but that's what I'm actually using): I use a simple and old iPhone for calls, and a new android phone (without SIM, so I can't be disturbed ;) as a mobile pocket PC.
It‚Äôs not stupid suggestion at all. Quite a few people I know use both Android and iOS concurrently. Unfortunately, I can‚Äôt get a new device at the moment, and was looking to work with what I already owned. 
CL: freedom
Very useful, thanks.
 compilers vs interpreters makes me think of speed. Lisp + speed makes me think of [Stalin](https://en.wikipedia.org/wiki/Stalin_(Scheme_implementation)). &gt; Research Statement by Siskind (compares Stalin with other Scheme compilers, and states that "STALIN *often generates code that outperforms handwritten C and Fortran cod*e." &amp;#x200B;
Heya /u/Baggers_! Will you be doing another of the Lisp-learning episodes anytime soon? Lack of time and CL knowledge prevented me in attending to your latest batch of live streams, but I did manage to watch your "Bits of Lisp" and CFFI-related episodes on youtube.
Great information and explanation. I've done similar in the past but my process for getting at the third party dependencies was a bit more brutish (quicklisp bundles and manual updates). Also I didn't account for ASDF system configuration, so I'll keep that in mind. Thanks!
_The Little Schemer_ is, like many Scheme textbooks, written to be independent of implementation. Any Scheme interpreter compliant with RnRS, n &gt;= 5, should do nicely. But if I were to recommend a Scheme to start with, I'd choose Guile. I got my start in Scheme using Guile. Its ubiquity in the GNU/Linux ecosystem means it takes relatively little to get started -- and Guile today is much better and faster than the Guile of 20 years ago! Plus it has lots of libraries and good POSIX integration, making it practical to program in -- as I like to say, "Guile goes with everything."
I've added it to Ultralisp.org, if you don't mind: https://ultralisp.org/versions/20190329134003
Wtf is vendoring? Is this some new managementspeak or did I miss something entirely? 
It's an established term of art.
Jokes on you, mines written in lisp macros. Before you ask, its lisp macros all the way down 
I wouldn‚Äôt have asked because it is impossible for it to be macros all the way down. 
I really would love to but the 5min videos take longer than the 2 hour ones to make and time has been at a premium recently. I have a list of topics I'd like to cover though. Anything you'd especially like to see?
But the question isn't "is it macros all the way down?" The question is "but what are the lisp macros built with?" &amp;#x200B; Of course, you know the answer already so I won't write it again directly below this sentence with a url to the reference I am guessing you are possibly /r/woosh ing over right after saying I won't. &amp;#x200B; \[Its lisp macros all the way down.\]([https://en.wikiquote.org/wiki/Turtles\_all\_the\_way\_down](https://en.wikiquote.org/wiki/Turtles_all_the_way_down))
Oh no. I got his reference. It just doesn‚Äôt work here. Macros eventually expand to things that are not macros. 
Unlike turtles, which are totally free to just keep expanding into more turtles. 
Yeah I get that and actually no rush, I'm just missing the "live" part of the stream watching process :) Well, when you get the time - maybe some CLOS introduction, if it's on your topic list?
Correct. 
Glad we could get this straightened out 
AOT compilation to native code, compiler macros, read macros, disassembler, conditions/restarts, image saving, CLOS, trivial interface to C libraries, better development environment (SLIME and Sly are a lot better than cider/nrepl/inf-clojure/whatever else they cook up), stable language specification. Most important: Doesn't depend on JVM or Javascript. 
Important notes on the ASD file (but not the readme): ``` This system provides support for embedding Python into Common Lisp via CFFI. It uses cffi-grovel to determine sizes and values of some assorted Python types and constants. However, if you'd rather avoid this, or grovelling is not possible for you, a best-guess effort can also be made. You can note your preference for guessing by evaluating the following form before telling ASDF to load this system: (push :burgled-batteries3.guess-not-grovel *features*) ``` Note: The `grovel-guess.lisp` file was failing to compile correctly, i've fixed that and sent a pull request. ``` If you /would/ like to use the groveller, B-B will attempt to determine the location of Python's C header files, and will prompt you to specify the appropriate directory if one cannot be found. To grovel against a specific copy of Python's header files, you may need to edit (defparameter *cpython-include-dir* ...) in #p\"grovel-include-dir.lisp\". ``` I'm going to try making it work for Python 3.7 or later. 
&gt; It does not seem that foreign libraries for Python 3.7 are supported. Did you use the groveller (which invokes gcc, etc)? Or were you using the grovel-guess process? 
So, per the Dunning-Kruger effect, there's a reasonable chance you're the genius... :) ...And actually, that jives with my experience. If somebody comes along saying "I'm a genius, I'm going to reinvent _______", there's a 90% chance it'll be an abject failure. And, on the other hand, Linux started out with "this is just a toy hobby OS, nothing professional..."
Yeah. I like this logic. That's my story and I'm sticking with it.
Neither, I took a look at https://github.com/snmsts/burgled-batteries3/blob/master/ffi-interface.lisp#L9 and only Python 3.4-3.6 seem to be there.
Has everyone from that list agreed to be there beforehand?
They haven't. There's a corresponding issue on the github.
A great opportunity for making fun of CL in the future: "So, how many people use CL?" "Well, so few, there's actually an online list..."
Not sure if this is a good idea...
It looks like all of this has been publicly available information. I'm not sure why you should need agreement for that.
Or write a Lisp knowledge management system?
Ok so I clicked on the creator's homepage: &gt;PSA: Zach Beane is a dangerous SOCIOPATH, and he is DESTROYING the Common Lisp community. &gt;Learn More (April 2018) &gt;Learn Even More (September 2018) &gt;Learn Yet Even More (February 2019) And the i saw his (he= Hexstream = Jean-Phillippe Paradis) tweets where there is claimed to be a CL mafia, where Zach Beane is a bad guy, lispm a bad guy, and creating more and more division within the CL community. And then I saw his posts on a long flame war in a GitHub issue against /u/lispm, where Hexstream incessantly wanted CLISP to be removed from a list of Lisp implementations only because the last "official" release was old. I just want to say that, as a newcomer (1.8 years in Lisp), I have found the community great, helpful, #lisp channel is great, reddit is great, and everybody has been very nice. Yes, we don't have to agree on everything but that doesn't mean we need to viciously attack other people. I don't want this "list of lispers" to become an instrument for somebody to censor or intentionally omit some people he doesn't like. 
It's one thing for me to post my contact details. It's another for a stranger to post my contact details.
This stuff is a database personally identifiable information. I'm sure it's at least a GDPR violation to post it online without explicit consent of all interested parties.
From all of his ramblings and his unhealthy obsession (to put it mildly) with Zach and other "conspiracy theories", it's kinda obvious that he is... not exactly "normal". Best to ignore him and move on.
Yeah,the reply on the GitHub issue is several hundred words long. All the warning bells go off that tell me I don't want to work with this person.
Well, I tried to defend Xach, who is really a great person and an outstanding contributor to the Lisp community. But that backfired. ;-)
I don't see any contact details on that page, only links to repositories and web pages.
The only thing I see as potentially problematic is perhaps the association of names to repositories/projects in such cases where this association isn't obvious/explicitly mentioned on the linked pages. And the applicability of GDPR depends on what GDPR actually says. I seriously doubt that, for example, writing an article saying "person XYZ is involved in project ABC" based on freely and publicly available information requires "explicit consent" from anyone. At point, journalism would break down.
Funny, I made the list and haven't written any lisp in like 3 years. I guess I'm the CLISP of common lispers ;)
It's debatable, that is correct. Nonetheless, I'd make a difference between making an article that mentions XYZ's involvement in ABC, and creating a publicly accessible opt-out database of lispers.
We might need an actual GDPR lawyer to make that decision. I doubt there is any present.
Anyone who writes... &amp;#x200B; &gt;HAH HAH HAH HAH HAH HAH. &amp;#x200B; ...in a reply to themselves could be seeking attention. May he get the right kind. On the other hand, I can see how his [table](https://www.hexstreamsoft.com/articles/common-lisp-format-reference/clhs-summary/#subsections-summary-table) organizing the [FORMAT](http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm) directives could be helpful in providing another way to lookup CLHS entries. He should consider including code examples of how to use each directive in an adjacent column. It could help clarify his meaning for Common Lisp newcomers and supplement any examples provided by CLHS.
I agree, that FORMAT reference is rather useful. /u/lispm - feel like adding it to the sidebar?
I'm not a moderator of /r/lisp . You would need to ask one of them.
It's obvious the poor guy is a loonie and should seek professional help.
Oh! TIL. Thanks.
The disagreement with Robert Strandh refers to documentation of the Meta-object Protocol. The original ALU document is copyrighted and is not modifiable much like the lispwork's hyperspec. Robert Strandh created a new version in plain html that can be forked and modified. Based on Strandh's work and permission, Hexstream created a more "modern", mobile friendly version. Hexstream wanted Strandh to remove his work from the web as to give priority to his version. Strandh disagreed and left is version up. Btw, all three versions are in the sidebar.
done
Neat, I'm on (ahungry)
Thanks.
CL has that Clojure doesn't: - CLOS - conses - reader macros - native implementations - a very fancy stack-hopping exception system - I can't see an equivalent to COMPILE (which is good enough for "JIT" compilers) - I don't think you can do generic dispatch on multiple objects and with :before/:after/:around methods? Clojure has: - a rotten Java smell - Rich Hickey - lots of blog spammers on /r/lisp
Oh wow, I've continually found it hard to look up FORMAT directives. It usually takes me a few minutes to find them in the hyperspec each time I have to look. That **is** a useful table.
if you use slime, \*c-c c-d \~\* then enter letter for format directive or enter \*?\* for all directive options.
CLiki has a [less controversial](https://www.cliki.net/person) person list which is voluntary.
The first chapter from Lisp in Small Pieces is worth its weight in gold, as is most of SICP. I would recommend a non-Lisp host language though, knowing where you are is difficult enough when writing the first. I recently started working on one (https://github.com/codr7/g-fu) in Go myself.
The issue I have with most guides is that they're too dogmatic and the language they implement isn't interesting enough to bother. Just find somewhere to start coding and let if flow from there, implement `Eval` for integers or whatever; then add identifiers and an environment, a parser, functions etc. I'm working on a guided implementation (https://github.com/codr7/g-fu) in Go, but it's still early days.
Wow, thank you! That's a tremendously useful thing I never knew.
Oh. Go is my new craze. Fun language.
I don't mind, but it is alpha-ish software though.
GDPR or not it is a common sense to remove it upon explicit request from the person in question.
Of craft, more like?
Most likely, it's the same thing you always did with other people's code before tools like quicklisp or rubygems or anything similar, but now with a crazy name.
I suspect this was not supposed to be "a person list", so it's not a substitute.
I don't think that happened. It's just the hexstream taste. I actually liked the list.
Yeah, that it's a quite hard. I don't have the information that he had to judge so profoundly Xach. Xach always it was really nice with me so it's quiet hard to understand some points based on the only self-discussion without any concrete evidences beyond guessing... That is not the way I conclude stuff. But Hexstream beyond that issues with Xach, he really likes Common Lisp and I think he have the right to think whatever he wants to think. I don't agree with him on this point, but actually, he is a nice a person. I posted the link here because I believe this contribution it's nice. Sincerely talking so much about that Xach personal issues that he have it's not too nice to the main point. The main point it's Common Lisp I think, I know, I know... The link is about community, about persons, but... About Common Lispers right? Why just not ignore it? I don't know, but I think pushing all the attention to this Xach issues it is helpful. I talk to him and he believes on that profoundly. That is a problem? I don't think that, maybe a problem for him, not for me. If Hexstream it's respectful with me, I'll be respectful with him. Actually even maybe he may in one moment a little agressive, I'll try to understand; but that never happened. Let's just focus on the Common Lispers List as a attempt to unify the community for the newbies and beyond... it's so hard to understand the great people behind CL :[, what they did, what they do, what they like... who are they (??) That list it's nice for me. 
Interesting info!
fuck! How I didn't discover that earlier??? ahaHA thanks!
&gt; SBCL and Clasp can access those slots in their structure instances inside that array via a simple pointer deference and then using the machine word. There is no conversion, and ‚Äî more importantly- there is no need to create any sort of ‚Äúforeign object‚Äù wrapper that would have to go through memory allocation and whatnot. It is very rare for languages to be able to access raw data in memory regions this way. In most cases that plan to ‚Äúwrite the low level parts in C and the higher level algorithms in &lt;foolang&gt;‚Äù breaks down because of the need to convert the C data, in most cases involving something that cause memory allocation. That‚Äôs very slow. A malloc call, or a GC equivalent alloc and dealloc is incredibly much more expensive than a pointer deference and arithmetic on a raw word. &gt; You cannot make those mixed language systems the way that ITA did with QPX (C data, Lisp algorithm) without overhead-free raw word access. Even having to go through a function call (as opposed to a simple dereference) puts you back by an order of magnitude. I from what I understand, Chez is the third Lisp system capable of doing such things.
\&gt; CLISP \&gt; "official" release A mere tangent, but I fully understand why somebody won't accept a CLISP fork as "official" when gnu.org, as of today, links "our **official** distribution sites" containing the 2010 version. 
&gt; I don't have the information that he had to judge so profoundly He has no information either. Every village had an idiot. Now they are all on the Internet.
If I would complain about every outdated link on the Internet... He can complain all day about random stuff, I will still download and install CLISP from the repository, where the developers are maintaining it.
not CL but scheme you have [http://www.lambdanative.org/](http://www.lambdanative.org/)
If that's the case for [Chez](https://cisco.github.io/ChezScheme/csug9.5/csug9_5.pdf), then by extension would that mean [Racket](https://blog.racket-lang.org/2019/01/racket-on-chez-status.html) could as well?
Depending on what is actually exposed to Racket users. Raw Chez certainly allows you to do lots of bit twiddling; [see section 4.5 of the CSUG.](https://cisco.github.io/ChezScheme/csug9.5/foreign.html#./foreign:h5)
I guess I wasn't clear in my question: I'm looking for REPL that runs on iOS, not one that can compile to it. I want to be able to practice coding CL on my iPhone while I'm commuting. 
&gt; Let's just focus on the Common Lispers List as a attempt to unify the community for the newbies and beyond... How can a list that is full of misinformation on a site built by a guy who wrongly accused half the community of plotting against him based on some mad paranoid delusions hope to "unify" the community? Why should people focus on this list and his site when there are plenty more appropriate places to build the community on? I don't want to associate myself with someone like this. Sure, let the guy have his little corner of the Internet, but please spare the rest of us from having to deal with his drivel.
&gt;I don't know, but I think pushing all the attention to this Xach issues it is not helpful. It is him who has a warning about Xach at the front of his personal web page, not us, so if somebody is wanting to let everybody know about issues with Xach, it is him. His announcement says: "PSA about Zach", PSA stands for: **Public** Service Announcement 
&gt;He can complain all day about random stuff, I will still download and install CLISP from the repository, where the developers are maintaining it. This. The complains about CLISP being still stuck at 2010 are baseless. And CLISP is an useful implementation: - it is small - it often is already present in some Linux distros - it can be easily used for scripting - it is able to compile files to portable bytecode (!) - it has fast bignum support, should you care - it comes with quite a bit of "batteries-included" extensions. - runs on platforms where other implementations aren't available. Yes it is slow compared to SBCL/CCL and some systems won't work in it (like clsql) but still an useful implementation.
Those ORLY books by Martin Cracauer are great!! "Make compile-time computing great again!!" 
I actually want to make a proper inter-language benchmark out of this. Write such an array of C struct instances to disk. Sum up one field, in several languages and implementations.
Vendoring is the accepted name for rolling third-party library dependencies into your own source repo. It comes from the Ruby community.
I read "O RLY?" as "Oh, really?" in a punny sort of way.
Link: https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f What a crock of shite either way. Fuck you Hickney, you Lisp-appropriating bitch.
Clojure's design is a crock of shit and this has been posted before. Clojure is just Java with parentheses, not a Lisp.
Can you elaborate "Clojure is just Java with parentheses, not a Lisp" part? I would like to know your views on Clojure and Lisp. &amp;#x200B;
Clojure's exception and class systems are lifted straight from Java, cons cells don't exist, and a lot of other Lisp polymorphism (like arithmetic by default in most implementations) has been flushed out and replaced with exposed JVM/Java internals. The multimethods in Clojure are also vastly inferior to the generic functions in Common Lisp, but that is also a flaw borrowed from Java.
You might be interested in this /r/lisp discussion from a couple of months ago: ["How innovative is Clojure as a Lisp dialect from Lisp expert's perspective?"](https://www.reddit.com/r/lisp/comments/acid7a/how_innovative_is_clojure_as_a_lisp_dialect_from/)
Thanks! &amp;#x200B;
They are ! Have fun: https://dev.to/rly
\&gt; cons cells don't exist they do, see clojure.lang.Cons, they just aren't so pervasive because clojure natively has lists and sequence abstraction complaining about having too much JVM in clojure has nothing to do with whether clojure is a lisp (it of course is, no matter what purists say) and is just dumb in general, being tightly integrated with JVM was one of the design goals, what the hell do you expect?
it is
Oh god, not this guy again. Thankfully I'm not on the list.
&gt;they do, see clojure.lang.Cons &amp;#x200B; And? They are not Lisp cons cells. &amp;#x200B; Clojure: user=&gt; (cons 1 2) IllegalArgumentException Don't know how to create ISeq from: java.lang.Long clojure.lang.RT.seqFrom (RT.java:505) user=&gt; ^D sbcl * (cons 1 1) (1 . 1) It's, as so often, a different data structure in Clojure, which just happens to have a name from Lisp.
cons function has different signature, clojure.lang.Cons is still a cons cell
That's not true. The function has a different signature, the cons data structure has a different type signature and Clojure lacks the Lisp syntax of dotted conses. In Lisp (1 . 2) is the literal data of a cons cell. In Clojure it would be something with three elements, since the dot is not data structure syntax, as in Lisp. &amp;#x200B;
&gt;Clojure is just Java with parentheses This is not fair at all. Clojure is *very*, very different from Java as a language. It also diverges a bit from Lisp, but of course it is infinitely closer to Lisp than to Java. 
yes, clojure lacks cons cell syntax because clojure has seq interface which is more useful.
&gt; yes, clojure lacks cons cell syntax Clojure CONS is not the same data structure as a Lisp CONS. It's not just a syntax difference. 
IMO, the section on reader macros seems like bullshit. So you don't like reader macros, fine, but don't work back from there to some nannying pseudo babble on community. Of course you can "compose" reader macros, and if your reader macro sucks, it's not going to spread to the rest the community - people just won't use it. 
That could be very informative. I wonder if ABCL could be tested similarly via [CFFI](https://github.com/cffi/cffi/blob/master/src/cffi-abcl.lisp)?
Nonsense, that is like saying "Common Lisp is C with parentheses". 
Thanks for the list, pure gold.
ok, you're right
&gt; *Clojure, like many Lisps before it, does not have a strong notion of a compilation unit.* LOL, no. &gt; (defun foo () (bar)) &gt; CL happily compiles it, and if bar is never defined, a runtime error will occur. Nope; you can also get warnings about things like this at the end of a translation unit, which can be a single file or a collection under the umbrella of the outermost `with-translation-unit`.
&gt; *It's not that the Lisp stuff is better.* I disagree; yes it is.
[DKS](http://symbolics-dks.com/) still sells them. I [bought a "MacIvory"](http://www.loper-os.org/?p=2857) from him not long ago, [for](http://btcbase.org/log-search?q=bolix) [reversing](http://www.loper-os.org/?cat=24). Be prepared to pay $4-5K for a working "Ivory"; asking price seems to grow by a $K or so each year as the number of still-working units steadily shrinks (no one's been making new ones since 1994 or so) and they slowly vanish into the dusty closets of would-be archaeologists and succumb to capacitor rot and other ravages of time. If you buy one, don't forget to [replace the ancient mechanical disk with SSD](http://www.loper-os.org/?p=2943), there is a very cheap (compared to the machine, at least) device available for this.
At one time I owned two of these keyboards ("old" and "new" style). Gave them away. I do not know if mine were typical, but the keys did not "click", the mechanical action is roughly comparable to a cheap 1990s PC keyboard. And without arrow keys.
the whole thing is bogus. compiling files was used in Lisp in the 70s or earlier. Typically these compiler created some kind of assembly program, which then was assembled during loading them. In the 70s fast loading of compiled code came up, where the assembler step was no longer needed.
Sure, what did CL lift from C? Considering MacLisp, Interlisp, Scheme and others were around without influence from C, I'd guess nothing.
&gt; being tightly integrated with JVM was one of the design goals, what the hell do you expect I'd still expect features from a Lisp we take for granted, such as conses and generic arithmetic at the least.
Why should I call it a Lisp if there are no conses, no generic arithmetic, and the classes and exception system are lifted from Java?
I used to have a new style Symbolics keyboard, but my XL1201 got tossed when it was mothballed. My desire for the keyboard's not about mech, I just want more modifiers. I find virtually all mechanical keyboards distractingly loud. I guess I'm just one of the cool kids.
If you like "soft" switches and don't need arrow keys (vi user?) it's entirely usable. Built-in wrist rest, too.
&gt; `IllegalArgumentException Don't know how to create ISeq from: java.lang.Long clojure.lang.RT.seqFrom (RT.java:505)` &gt; ` ^ ^ Dialect of Lisp!
C-p C-n C-f C-b
Aren't you a ray of sunshine.
I am when given an actual Lisp to discuss on /r/Lisp.
Is it possible for floats to be treated this way as well at least to a limited extent?
Have a look at trivial-garbage (https://common-lisp.net/project/trivial-garbage/). With it you can define additional cleanup code to execute after your instance is garbage collected.
Garbage Collectors for Lisp usually only manage memory in the Lisp heap. They don't collect garbage in the external memory areas, thus allocations one did there are of no concern of the Lisp garbage collector. 
This is an issue in many other languages (esp. Julia with its non-refcnt GC). The GC of the host language does not feel the memory pressure from externally allocated memory. Using #:tg, as I'm sure you're already doing, does not help with this. I run into this issue too when handling CUDA memory blocks from CL. One aspect, the latency of (de)alloc, is handled in popular DL libraries by creating a memory pool, but this still needs some kind of gc hook to free objects. The deterministic GC in Python means the latter is not an issue there. I haven't yet figured out how to get around this; it's likely that it can't be done in a "nice" manner, but I'm not sure. I tried #lisp but that list is not particularly helpful; need to ask someone on #sbcl how this can be tackled in a nice manner. &amp;#x200B; [Flux.ml](https://Flux.ml) from the Julia world has similar issues. I don't think they have a clean solution as yet either. Also see, ;; [https://github.com/JuliaGPU/CuArrays.jl/issues/210](https://github.com/JuliaGPU/CuArrays.jl/issues/210) ;; [https://docs-cupy.chainer.org/en/stable/reference/memory.html](https://docs-cupy.chainer.org/en/stable/reference/memory.html) ;; [https://www.google.com/search?hl=en&amp;q=julia%20cuda%20memory%20pool](https://www.google.com/search?hl=en&amp;q=julia%20cuda%20memory%20pool) &amp;#x200B; Since you're using Torch, I'm assuming this is only an issue in reverse-mode AD ? Since THC already does 'clever' memory management without blocking the CPU, may be you can solve your problem at the library level ? I'm not sure how all this is put together in ATen. ;; [https://github.com/pytorch/pytorch/pull/57/files](https://github.com/pytorch/pytorch/pull/57/files) &amp;#x200B; Also very cool project BTW! Would you mind share a bit more about your choices for the project ? Since all the kernels etc. are in ATen, does it make sense to use TH\* instead of implementing it Lisp (it's fairly small IIRC).
eh.. what specifically do you \*need\* cons dot syntax for? what can it do that clojure's seq abstraction can't and how much code written in CL critically relies on it?
Thanks but current implementation does implement this using finalize. My problem is that the garbage collector does not know the total size of allocation. For example, though real memory allocation is 1GB the collector think it's using a CLOS object whose size is just a few bytes so it does not actively collect the object. 
&gt; I just hope he reconsiders whether his views and actions were correct. Oh boy, do I have bad news for you: [link](https://twitter.com/HexstreamSoft/status/1111796378286596096). The dude is as delusional as ever, if not even more so, and I don't think that will change anytime soon, unfortunately enough. I also love how he thinks everyone who criticize or disagree with him must be a part of the CL mafia or is trying to destroy the community.
For....creating conses? They're very useful for creating assoc lists and dotted lists can have uses for destructuring, splicing in quasiquote, and you can create circular lists using them: `#1=(this is a circular list . #1#)` I'd say most code in CL *and* Scheme *and* Racket, among other Lisps, would rather have actual conses.
Uh... guys, why didn't anyone mention that it only takes 3 clicks to link from the list to a site that contains sexual explicit materials? Step to reproduce: from the (list)[https://common-lispers.hexstreamsoft.com/], click on the (link to the homepage)[https://www.hexstreamsoft.com] -&gt; click on the link to (Hexstream's personal page)[https://abc.hexstream.xyz] (I think?) -&gt; click the second link (the Hexstream Entertainment one, **WARNING: NSFW contents**) on the homepage. This is also unfortunately true of his format summary (page)[https://www.hexstreamsoft.com/articles/common-lisp-format-reference/clhs-summary/]. /u/arvid, are you aware of this? I mean, sure it is in a different domain, but it is still pretty easy to find and accidentally stumble into (like what I just did). Also, the layout of the sites make it pretty obvious that it's the same guy who made all of these... Well, PSA I guess. I'm not a prude, but IMHO this just reeks of unprofessionalism (even more so then it already is, amazingly enough), and I'd not want to be caught dead with my real name in a list on a site that contains links to hardcore pornography.
The GC itself will not look into foreign allocated memory. This your code (library) will have to manage itself. I didn't look at the details of the implementation, yet it should be possible to add the deallocation code after finalization (maybe in (initialize-instance :after) of your CLOS instances). If you could add a minimal example of how the foreign memory is allocated and deallocated we could give you better feedback. BR, Eric
I have no experience on THC though I have a plan on it :-) Yes, mostly this problem happens when AD is used. I thought there should be a way of let the garbage collector know current allocation size. I do not use ATen library. https://bitbucket.org/chunsj/libth/ is used and which is just a copy from Lua torch code. I have no experience on writing numerical code in Lisp and some test code using plain loop shows bad performance so I've decided to used libTH and libTHNN (and this is easy to me). This project is started as learning neural network from scratch but I think at some extent it's usable so I'd like to fix this annoying problem :) and to keep finding more application for learning. Thank you.
My problem is what akssri is described (sorry for my poor description), which means what I'd like to do is pressure garbage collector so that it wants to garbage collection more aggressively. In current form, the garbage collection itself does work without problem because there's no memory or resource leakage.
Wow, that's weird. I didn't saw that before. Thanks for reporting. Maybe other peoples can bother about that like you. I actually don't care too much, but I think this is something to think about it.
&gt; Uh... guys, why didn't anyone mention that it only takes 3 clicks to link from the list to a page that contains sexual explicit materials? I guess because you are the first to found it and have some concerns about it.
SICP? Sort of... Otherwise it's mostly papers at [readscheme.org](https://web.archive.org/web/20170226120049/http://library.readscheme.org/page9.html) (R.I.P.)
The issues mentioned below are also applicable here I think. [https://github.com/JuliaGPU/CuArrays.jl/issues/152](https://github.com/JuliaGPU/CuArrays.jl/issues/152) &amp;#x200B; My current duct-tape solution is to handler-bind out-of-memory errors with call (gc :full t). This is of course super-expensive. The other way would be to have a clever de-allocator within the AD routine while using a mempool to reclaim these tensors. Then again, since you don't really have an idea about the scope of the local gradients, you'd need to effectively have to create a sort of refcount gc system (you can mark/clear them as you pass gradients around). As noted earlier, I need to implement something of the sort as well; please ping me if you'd like to brain-storm on this. &amp;#x200B; Lisp is actually quite nice for numerical code; if you have a way to coerce SBCL to generate "nice" code you can achieve C-like speeds (with caveats about SIMD). SIMD optimizations are absent ATM, but hopefully that'll change soon enough. I even have macros to generate Lisp to CUDA device code (ala cl-cuda), to achieve speeds comparable to that on Pytorch/Cupy (for L1 ops). Sadly 'templating' in CL is still not easily done, and requires some unholy combination of macros and MOP in my experience.
&gt;Oh boy, do I have bad news for you: link. Good grief...
If you think that's bad, looks what I've (unintentionally) [found](https://old.reddit.com/r/lisp/comments/b79oad/common_lispers_list/ejxp224/). I swear, this guy...
&gt; but I think this is something to think about it (probably). Something to think about? Do you want us to be the laughing stock of the entire world or something? What organization or company would trust a community that hosts their documentation/directory list on a site run by a guy who proudly maintain a page full of hardcore, NSFW materials on his personal website? (Not to mention that it's so trivial to accidentally click through to this NSFW stuffs, it isn't even funny). Have you seen how much shit the GNU/FSF folks get just for their extreme views? Or how many people ridicule Stallman for his personal habit? This is like a million time worse. It's already hard enough to convince people to take the Lisp community as a whole seriously due to various issues over the years, now you want to promote a website made by a guy like this as the face of the community? Look at the side bar of this subreddit, for crying out loud, there are already millions better places than that list made by people who are far more qualified and far more sane than this guy.
My current idea (after your answer) is that NSAutoreleasePool like one; create a pool for the loop which will be destroyed after exiting loop. Though I have another kind of work before looking back this one, I think this can at least be a nice temporary solution. In fact, I've executed (gc :full t) to avoid thrashing periodically in the training loop and reduced dynamic memory size of SBCL. Thank you again.
&gt;from the list to a page that contains sexual explicit materials? I only find pony porn, which is almost comic for me. I didn't know pony porn existed, but well, rules of the internet... Where's the REAL hardcore stuff? 
\&gt; creating assoc lists you mean maps? clojure has literal syntax for that: `{'a 'b}` \&gt; uses for destructuring clojure has destructuring of base data structures built in: `(let [[a b] ["one" "two"] {c 3 d 4} {3 "three" 4 "four"}] (println a b c d))` \&gt; create circular lists you can do that in clojure too: `(cycle some-list)` \&gt; would rather have actual conses maybe, but doesn't seem like it's an essential defining element of what is lisp.
\&gt; it's an essential defining element of what is lisp. Given that linked lists of cons cells appear in McCarthy's defining paper on the first pages, generations of Lisp developers used it, etc, this seems to be a funny statement. sure things can be done differently, but then it is not Lisp.
&gt; I only find [snip] Those are bad enough in my book, especially when you are trying to get people to take you seriously. But then again maybe I'm too old...
you're wrong, mccarthy's paper doesn't mention a cons cell even once. check it for yourself: ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-008.pdf cons cells happened to be part of lisp *implementations* from early days largely because of hardware restrictions and idiosyncrasies. cons is not what defines lisp, just an implementation detail from the 60s: &gt; cons. The value of cons[x; y] must be the *location of a register that has x and y in its address and decrement parts*, respectively. There may not be such a register in the computer and, even if there were, it would be time-consuming to find it. Actually, what we do is to take the first available register from the free-storage list, put x and y in the address and decrement parts, respectively, and make the value of the function the location of the register taken. (‚Äúcons‚Äù is an abbreviation for ‚Äúconstruct.‚Äù) &gt; It is the subroutine for cons that initiates the reclamation when the freestorage list is exhausted. In the version of the system that is used at present cons is represented by a closed subroutine. In the compiled version, cons is open. (emphasis mine)
Those concepts aren't new at all, they have existed and been used for decades. "Async" has only becomed popular due to Node.js. There are two libraries to do async programming in Common Lisp. But AFAIK the async stuff so much in vogue is having a pool of worker threads and sending I/O stuff to those workers. The lparallel library (for CL) allows you to create channels and lots of nice stuff. The cl-stm library gives you Software Transactional Memory, which IMO is awesome thing. Since Scheme supports first-class continuations, I wouldn't be surprised if there are many "async" libs, and many coroutine libs too. 
You're wrong. They are mentioned in 4.2. That was an intermediate paper of an early design. The defining paper of Lisp is this: http://www-formal.stanford.edu/jmc/recursive.html **This paper appeared in Communications of the ACM in April 1960. It is the original paper on Lisp.** 
right, no true scotsman. even if "the right" paper is considered, i've already quoted the relevant part. cons cells are implementation details because 60s. lisp can be implemented without cons cells and you haven't provided any evidence that it can't. existence of clojure is evidence that it can. you disagree, i get it. i consider you a purist. there's no point arguing further.
Incidentally, is readscheme.org truly dead? Because if so that's a real shame, because it's a very useful resource.
&gt;you mean maps? clojure has literal syntax for that: {'a 'b} No, assoc lists are not "maps." &gt;you can do that in clojure too: (cycle some-list) Conses not only allow circular lists, they allow all kinds of interesting data structures to be composed. You should learn a bit of Lisp to have a clear idea of what are conses and how they can be used. 
\&gt; cons cells are implementation details because 60s. They provide singly linked lists and trees. Clojure has a completely different data structure with complete different capabilities (lazy persistent sequences). You can implement all kinds of data structures and do computation with it. It's just not Lisp when it is a different data structure, different operators, different semantics, different complexity. Since you have not even tried to give a definition of Lisp (where I said: the core operators, data structures of McCarthy's LISP make the core of Lisp), you have no argument.
you haven't provided a definition either. if you think linking to hundred pages long paper counts as providing definition, i can play that game too - same link, just replace mentions of cons with seq abstraction.
Call it Seqp then.
\&gt; No, assoc lists are not "maps." From wiki: In [computer programming](https://en.wikipedia.org/wiki/Computer_programming) and particularly in [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)), an **association list**, often referred to as an **alist**, is a [linked list](https://en.wikipedia.org/wiki/Linked_list) in which each list element (or [node](https://en.wikipedia.org/wiki/Node_(computer_science))) comprises a [key and a value](https://en.wikipedia.org/wiki/Attribute%E2%80%93value_pair). The association list is said to *associate* the value with the key. That's literally what a map is. Hash part aside, calling seq on clojure map will give you your alist. \&gt; Conses not only allow circular lists, they allow all kinds of interesting data structures to be composed ok, how is that relevant? how does that make anything that doesn't have conses \*not a lisp\*? \&gt; You should learn a bit of Lisp i can tell you the same, how constructive do you think this is?
how about you call that thing you're using a consp instead? or how about you think for a second and realize that difference is too small to fuss about it?
Archive.org still has the links, so that's something. But updates have to be sourced from somewhere else now.
I think the difference between a lazy persistent sequence and linked lists is pretty drastic. 'lazy persistent sequences' are a much higher-level data structure designed for specific purpose: to serve as a data structure for side-effect free Functional Programming. The Linked lists and linked trees of Lisp don't make any such commitment (immutable, persistent, sequence, ...). They are based on a much more primitive data structure.
What is the latest Java version that runs on XP?
why does it matter if it's higher or lower level? why do promises or commitments matter? can't lisp variant be with focus on functional programming with persistent datastructures? why does it stop being lisp?
sure, you can call a horse a dog. If that helps you. They are slightly different, do different things, look different. When does a horse stop being a dog?
\&gt; When does a horse stop being a dog? technically never, taxonomy is human invention and there are no clear borders between species. the real question is why does it bother you so much that a language is being called a lisp when it clearly adheres to all high-level design ideas of a lisp but skips on one implementation detail.
The real question is, why does it bother you that Clojure is not called Lisp? Given that it is a different programming language: a mix of Lisp, Scheme, Functional Programming languages and Java. \&gt; why does it bother you so much that a language Because it confuses people. So much that they can't see the difference between a simple linked data structure and a much more complex persistent lazy sequence. Even though it has different operators, different properties, different capabilities, different purpose, ... &amp;#x200B;
You can generally tell the difference between male and female horses by their number of teeth: males have 40 while females have 36 (but honestly, most us are going to use the much ‚Äúeasier‚Äù way).
the question was about a line between horse and a dog, not female and male individuals of the same specie (even though in some cases it's not as easy as you suggest either).
\&gt; why does it bother you that Clojure is not called Lisp clojure is called a lisp. by me and plenty other people. and it does not bother me that you do not call it a lisp. it bothers me that you have to be all up in arms because of some irrelevant petty details. save your braincells and don't stress, there are more important things in life. \&gt; all the languages have in common is { and }? did you just compare being homoiconic and s-exp based to having similar braces? that's a pretty low quality syntax evaluation. i expect more from real lispers. \&gt; Because it confuses people vague and irrelevant. homoiconicity and s-expressions don't confuse people. sequences and lists don't confuse people. if anything, cons cells confuse people much more than either of aforementioned things, which doesn't matter much because \*it's just an implementation detail and not a defining feature of lisp\*.
&gt;&gt; When does a horse stop being a dog? &gt; technically never Is there a Hickey video I can watch? 
there's a biology book you can read
Floats can be stored in unboxed vectors using either Chez's FFI or [bytevector functions](https://www.scheme.com/tspl4/objects.html#./objects:s262), but intermediate float values will currently *always* be boxed in Chez. [Here's some related reading.](https://github.com/cisco/ChezScheme/issues/248)
Write your own simple GC with a collection of weak pointers to your tensors; creating a tensor adds that tensor to the list. Whenever the number of created tensors reaches some threshold, call `(tg:gc)` and then remove all weak pointers that are no longer alive from your collection. Then, start counting the created tensors from scratch. If necessary, utilize more advanced GC techniques.
Sorry, extraordinary claims call for extraordinary evidence. Yours needs a Hickey video. 
It's O RLY, as in [TIM O RLY](https://vignette.wikia.nocookie.net/uncyclopedia/images/9/93/Tmorly.jpg/revision/latest?cb=20051221004018)
&gt; s-expressions don't confuse people see your postings here. You are confused to think that a different language with different data structures and different operators is Lisp. Simply NO / zero Lisp program from McCarthy's Lisp onwards runs in Clojure. None. All have to be completely rewritten.
where did you find an extraordinary claim?
language is not defined by an implementation detail. lisp is also not a language, it's a family. i couldn't care less about some programs from 60s not running on clojure.
\&gt; it's a family A family can talk to each other. \&gt; i couldn't care less about some programs from 60s not running on clojure. If your were a Lisp programmer, you might. &amp;#x200B;
He is not the first.
As others mentioned, the GC doesn't take into account things which are not allocated on Lisp's own heap when determining that memory is full enough to GC. So the way I see it, there are two good approaches: 1) allocate large objects on the Lisp heap and call foreign functions with pointers to them (be wary of movable objects!) 2) provide knobs to allow users finer control over tensor lifetime. For example, a macro that evaluates a body with a tensor inside its scope, and uses unwind-protect to deallocate the tensor once control flows out of the macro's scope. This is a common pattern for managing objects whose implementations exist off the Lisp heap; there are caps on the number of file descriptors and database connections a program can reasonably expect to hold at once, but the GC doesn't keep track of those either!
\&gt; A family can talk to each other. Same words, same syntax, same semantics "that's just like your opinion man" \&gt; you might care about Lisp programs from the 60s onwards i care about lisp, and i care that lisp programs existed in 60s, i don't particularly care to be able to run them without changes. to continue dragging the baggage of hardware limitations from 60 years ago brings no value.
In order to fill a small void in the Lisp world on Reddit, I have created /r/LispMemes for all the Lisp meme stuff that the Lisp world might create. And this post is a shameless promotion of that subreddit.
(+ 2 2)
10/10 i subscribed
You can't run them at all. You need to rewrite them completely. Not only the Lisp programs from the 60s, but also those from the 70s, 80s, 90s, 00s, 10s. None of that runs. Not even remotely.
&gt; I have created &gt; /r/LispMemes &gt; for all the Lisp meme stuff Excellent!! I try to collect them, only have a few that I bet everybody here know.
and it doesn't matter in the slightest.
"that's just like your opinion man"
&gt;you mean maps? Not really. Assoc lists can be added to in a "functional" manner which make them great for representing bindings. &gt;but doesn't seem like it's an essential defining element of what is lisp There's not many lists to process then.
Nobody expects that.
&gt;keymone: "that's just like your opinion man" &gt;lispm: "that's just like your opinion man" The circle is complete.
Oh, this could be a nice approach. Thank you. Even without building my own garbage collector, at least I can manage to reduce memory used in foreign tensor data. 
I'll need to learn about unwind-protect thing. Thank you. 
`(ignore-errors (find-class s))` == `(find-class s nil)` This is a useful utility for a programmer, as long as you only export symbols that name functions, dynamic variables/constants, and classes. If you export symbols for any other namespaces (if you have any other namespaces), you'll need to add that case to your utility.
Variables declared with `defvar` need not be `boundp` when you run your diagnostic. I don't remember if you can portably find out if a symbol is proclaimed special. 
Lisp in Small Pieces is an entire book on the topic. It is dense and rewards careful study.
lisp in 75 languages, including a few lisps and itself, as well as an implantation guide: https://github.com/kanaka/mal
While it doesn't use a Lisp as the implementation language, this presentation gives an overview to Make-A-Lisp (MAL) itself: &amp;#x200B; [Make Your Own Lisp Interpreter in 10 Incremental Steps](http://kanaka.github.io/lambdaconf/)
http://craftinginterpreters.com/ This is a nice source. Not lisp, but it doesn't matter too much. 
\&gt; Not really. Assoc lists can be added to in a "functional" manner (acons) which make them great for representing bindings. So can Clojure's maps. It's just named (assoc) in Clojure. 
And is there an acons too? That is, `(acons 'a 'b '((c . d)))` is `((a . b) (c . d))`
[SICP chapter 4](http://sarabander.github.io/sicp/html/index.xhtml#toc-Metalinguistic-Abstraction) covers a few interpreters.
Just an FYI...your link ([http://tilde.cat/\~t/p/intro.html](http://tilde.cat/~t/p/intro.html)) in the original post... &gt; You can find my first entry [here](http://tilde.cat/~t/p/intro.html). It might help someone :) ...no longer works. The following appears to be the new link for those who'd like to follow along with your journal. It's also [archived](https://web.archive.org/web/20190403214624/http://tilde.cat/intro.html) for future reference in case the link moves again. [http://tilde.cat/intro.html](http://tilde.cat/intro.html) Keep it up and good luck with the adventure!
It's always great to see parts of Lisp's rich history accurately summarized for newcomers. Thank you, and keep it up!
No acons, because cons cells aren't the building block. Given a map (idiomatic Clojure uses keywords, rather than symbols for map keys*): &gt; (def my-test-map {:key1 "value1" :key2 "value2"}) Adding additional key/value pairs, or replacing existing ones, is done using `assoc`: &gt; (assoc my-test-map :key1 "value3") ;; {:key1 "value3", :key2 "value2"} The original `my-test-map` is untouched. You generally can't modify a value in place, just replace it. If you need to add/replace more values in the map, just keep adding pairs to `assoc`: &gt; (assoc my-test-map :key3 "value3" :key4 "value4" :key5 "value5") ;; {:key1 "value1", :key2 "value2", :key3 "value3", :key4 "value4", :key5 "value5"} To remove values, `dissoc`: &gt; (dissoc my-test-map :key1) ;; {:key2 "value2"} For nested maps, you have `assoc-in`: &gt; (def nested-map {:single-value "my value" :map-value my-test-map}) ;; {:single-value "my value", :map-value {:key1 "value1", :key2 "value2"}} &gt; (assoc-in nested-map [:map-value :key1] "replaced-value") ;; {:single-value "my value", :map-value {:key1 "replaced-value", :key2 "value2"}} And to perform a calculation on a value and replace it, `update` or `update-in`: &gt; (def request-counts {:foos 0 :bars 0}) ;; {:foos 0 :bars 0} &gt; (update request-counts :foos (fn [x] (+ 1 x))) ;; {:foos 1, :bars 0} * Maps can use anything as keys, keywords are just preferred most of the time because keywords are also invokable as functions that perform lookups on maps. So instead of: &gt; (get my-test-map :key2) You can do: &gt; (:key2 my-test-map) 
Do all the keys have to be keywords? That seems like a big killer since assoc in CL can handle any symbol, number, or any other object with an appropriate :test (and/or :key) function.
Nope, they can be whatever you want. Pedantically, since it's running on the JVM (or JavaScript, or CLR), map keys need to be something with a stable `hashCode` and `equals` implementation, and woe be unto you if there's some way to modify the object that you used as a key. But if you stick to Clojure's values, you won't run into that. So this is fine: {:a-keyword "it's value" 12345 "an integer key" 12.0 "actually, I don't know how well a floating point key will work, ieee-754 being what it is" "a string key" 12345 {:another "map" :as "key"} "yup, still works" `a-symbol "that too" }
&gt; The multimethods in Clojure are also vastly inferior to the generic functions in Common Lisp, but that is also a flaw borrowed from Java. Clojure's multimethods aren't a Java thing at all. From [clojure.org's reference](https://www.clojure.org/reference/multimethods): &gt; This simple system is extremely powerful. One way to understand the relationship between Clojure multimethods and traditional Java-style single dispatch is that single dispatch is like a Clojure multimethod whose dispatch function calls getClass on the first argument, and whose methods are associated with those classes. Clojure multimethods are not hard-wired to class/type, they can be based on any attribute of the arguments, on multiple arguments, can do validation of arguments and route to error-handling methods etc. I've never used any of the hierarchy stuff though, it tends to confuse me. You might be thinking of [protocols](https://www.clojure.org/reference/protocols), which is another way of doing dynamic dispatch in Clojure. It's much simpler than multimethods (or CLOS) and is only single-dispatch, but is more powerful than Java's class system in that you can extend any type to implement any protocol. (If I remember correctly, protocol dispatch is also much faster than multimethod dispatch.) &gt; Lisp polymorphism (like arithmetic by default in most implementations) I'm not sure at the exact complaint with generic arithmetic, but: - Clojure supports arbitrary precision integers and decimal values. The default arithmetic functions work with native JVM values for performance's sake and will throw an exception on overflow, but alternate versions are available for arbitrary precision operations. - There's also `unchecked-add`, `unchecked-subtract`, etc if you really want to stick with fixed precision/native values and ignore overflow. - Rationals are supported too. You just have to choose what precision you want out of it. Most of the time you'll be just fine with the standard `+`, `-`, `*`, and `/`, but the other options are there when you need them.
&gt;Clojure's multimethods aren't a Java thing at all ... protocols ... [basically just all the generic function talk] Are there :before and :after methods? Method combinations? (I think you can apply arbitrary functions to arguments to dispatch with combinations.) &gt;The default arithmetic functions work with native JVM values for performance's sake and will throw an exception on overflow, but alternate versions are available for arbitrary precision operations. That's really weird and smelly. All Lisps have arbitrary precision as the default, and then through declarations the precision and ranges can be reduced to improve performance.
&gt; Are there :before and :after methods? Method combinations? (I think you can apply arbitrary functions to arguments to dispatch with combinations.) Nope. It's not CLOS, and makes no claim to be. &gt; That's really weird and smelly. All Lisps have arbitrary precision as the default, and then through declarations the precision and ranges can be reduced to improve performance. Eh, it's a tradeoff. Common Lisp asks you to declare types to ensure performance, Racket and Clojure ask you to use a different set of functions depending on what you want. Clojure defaults to safe, mostly performant math, and will throw an error if your values go beyond what that math can handle. Racket defaults to always safe, but will degrade to slower performance instead of throwing an error.
I am second to this approach. Seems to be the one that gives less headaches.
Peter Norvig's [Lisp interpreter in python](http://norvig.com/lispy.html) and [improvements](http://norvig.com/lispy2.html) are a quick, self contained exploration of the topic. If you like that, then SICP and Lisp In Small Pieces are awesome resources to dive _much_ deeper.
It does matter; writing Lisp interpreters in Lisp is vastly different to writing interpreters in many other languages due to quoted data and the convenient prefix notation, which makes writing a reader trivial.
CLOS has remained on my todo list for a long time as I don't think I know enough to explain much of it. I really only use classes as structs I can easily redefine, I use generic methods in a bunch of places but I've never used any of the qualifier/combination stuff and rarely ever have the kind of multiple-inheritence or type hierarchies that bring out any of the interesting aspects of CLOS. This pretty much leaves me as someone whos not very qualified to say anything about it.
Racket implements by default the numeric tower one knows from Scheme, which originally came from CL.
Clojure user=&gt; {:a 1 :a 2} IllegalArgumentException Duplicate key: :a clojure.lang.PersistentArrayMap.createWithCheck (PersistentArrayMap.java:71) Lisp * '((:a . 1) (:a . 2)) ((:A . 1) (:A . 2)) 
Thanks for the answer - well, if you happen to touch the subject when presenting some other stuff, it doesn't have to be a whole session dedicated to CLOS - just how you used the CLOS staff you use, when you use it :) 
Clojure: user=&gt; (assoc {:a 1} :a 2) {:a 2} Lisp \* (acons :a 2 '((a . 1))) ((:A . 2) (A . 1)) This assoc lists in Lisp are not comparable to hashmaps in Clojure.
what's your point? yes, there are differences, they are mostly in implementation details, conceptually alists \*are\* maps. you're getting desperate..
\&gt; what's your point? I thought you would get from seeing code examples. Try again.
are you able to read more than three words?
I like that refreshing lack of style.
now that you acknowledge passive aggressiveness isn't getting us anywhere... what's your point? yes, there are differences, they are mostly in implementation details, conceptually alists \*are\* maps. and how on earth does it make conses any more important/required?
\&gt; they are mostly in implementation details It's not implementation details. it's a different data-structure. Hashmaps are called hashtables in Lisp. &amp;#x200B;
Node.js is about asynchronous I/O. That just sounds similar, but it's not really the same kind of problems as the general async programming. Besides, Node.js was more of a side-effect of a more general and important thing. The real reason for the recent fashion comes from the hardware world. Persistent storage becomes more and more parallel. And while ideas about async I/O had been around way before this type of storage, there was no real motivation for implementations. Modern persistent storage keeps increasing cache, and throughput. Cache allows for multiple writers to issue I/O requests at the same time (because there is more space than is required for single request available). Higher throughput is achieved by allocating more PCIe legs to disks. So that, effectively, today, most even consumer-grade laptops come with 4 PCIe legs connecting CPU to the disk (while RAID was more of an expensive rarity before). But, the fashion really started with network adapters, where the situation is kind of similar, but it happened even earlier. The problems of async. I/O are not the same that of multithreading (even though they are related). Traditional view of computer is CPU-centric. Everything that's of any importance (in terms of running programs) happens in CPU. It tells everything else what to do. But, it seems like, and increasingly so, some computer sub-systems gain more independence, smarter controllers, own dedicated memory, special programming languages for programming just that component. So, the problems of async I/O stand on their own, just like, say, shader programming, or CUDA etc. I wouldn't be surprised if, in few years, we'd see a specialized language for programming I/O patterns for storage, just like there's eBPF, maybe?
I like drama. What is this GitHub thread everyone is talking about? Can I see? Please?
&gt; since you keep attacking me and the condescending tone from lisp purists is not an attack in your opinion? &gt; instead of actually reading the content none of my replies are out of context and none are irrelevant with regards to content they are directed at &gt; It's a different data-structure with usage/properties beyond mapping unique keys to values. i know that clojure's map is not literally an assoc list, but it can be viewed as one and it behaves as one when used with first/rest. and if you literally need alist for whatever reason - you can easily achieve the same with simply a list of pairs. so i ask again - why do you think that's a valid example of why conses are so mandatory?
I misread the OP and didn't notice that he was asking for lisp interpreter in lisp. Still, not every lisp is the same and read might not be that useful for your version of the interpreter. Not to mention that there are many ways to interpret a language, so for a person interested in the topic, the book will definitely prove useful. Parsing is just a one step. 
&gt; "and the condescending tone from lisp purists is not an attack in your opinion" 'lisp purists' - see? It's your condescending tone you should look at. &gt; none are irrelevant sure they were: 'now you're getting desperate'. This is just nonsense. I described to you that maps in Clojure don't deal with duplicate keys. You attack me that I'm 'desperate'. This is a technical forum here and attacking me as being 'desperate' is just not helping you making a positive impression and it does not help you make your argument. Telling me that I'm 'desperate' is just totally irrelevant to the subject were are discussing here. &gt; i know that clojure's map is not literally an assoc list, but it can be viewed as one It's not even a list, it's a map. In Lisp an assoc list is a LIST. That means for example that one easily can use such a list as a stack (a stack, not a map!) of bindings - where list bindings contain duplicate keys which are shadowed by the bindings pushed onto it. assoc lists in Lisp have several purposes. being used as a map of unique keys to values is just one. That's why it is called a list and not assoc map or assoc table. The typical use case of hashmaps is provided by hashtables, which are still not Clojure hashmaps, because they are not persistent. 
https://github.com/robert-strandh/CLOS-MOP-HTML/issues/4
&gt; 'lisp purists' - again, see? It's your condescending tone you should look at. why do you consider 'purism' as negative? it's just a description of attitude towards any deviation from some canonical understanding of "what is lisp". if you see that as an attack - i apologize and that was not my intention. &gt; sure they were: 'now you're getting desperate'. This is just nonsense. I described to you that maps in Clojure don't deal with duplicate keys. You attack me that I'm 'desperate'. you've described minor implementation detail as if that changes everything. i agree that i could have skipped the whole "desperate" thing, but after seeing this same thing in many discussions with lisp purists - minor details being blown out of proportions - it's gotten a bit tiring. &gt; That means for example that one easily can use such a list as a stack (a stack, not a map!) of bindings - where list bindings contain duplicate keys which are shadowed by the bindings pushed onto it. It's not that one can't do it in Clojure, but just not with hashmaps. *yes, there are differences*. if you need a stack with shadowing - use a list of pairs, you *still don't need conses*. my point of mentioning clojure map was that you can achieve the thing OP mentioned using native clojure objects and conses are not mandatory.
I'd argue that they are comparable: they both solve the same problem, associating a key with a value. They're just different implementations of the same idea, with different tradeoffs. If you really need ordering, there's `sorted-map` and `sorted-map-by`. If you need everything else: it's straightforward to build association lists on top of lists or vectors.
'ordering' and 'sorted' are again two different concepts. \&gt; If you need everything else: it's straightforward to build association lists on top of lists or vectors. Sure, then we have again different data structures. An assoc list used as a binding stack with duplicate keys, simply can't be implemented by a hashmap. You then need a different data structure. With Lisp's concept of assoc lists, this is not necessary.
&gt; An assoc list used as a binding stack with duplicate keys, simply can't be implemented by a hashmap. Oh! I missed what /u/theangeryemacsshibe was talking about when he mentioned bindings. If I'm understanding it correctly then, as you call down through a series of functions (or something similar), you push bindings onto your assoc list so that you can look up the current value of particular value and get the latest, right? You'd do exactly the same thing with a Clojure map. I don't see how duplicate keys comes into play here, unless you want to be able to inspect the history of a particular binding, in which case you'd just keep around the stack of binding maps. I guess what I'm getting at is: Clojure gives you different primitives to work with than Common Lisp or Scheme, so you solve the same problems in a slightly different way. Does that matter?
&gt; it's just a description of attitude towards any deviation from some canonical understanding of "what is lisp". what kind of 'attitude' are we talking about. Note that I find derivations from Lisp totally great. I have used a bunch myself. I just would not call them Lisp, since I always had to write new code and never could take existing Lisp code with me. 
Java 8, latest patch runs on XP.
&gt; what kind of 'attitude' are we talking about attitude of unacceptance of different ideas. there's nothing wrong with implementing lisp without conses. for me line is somewhere near homoiconicity, s-exp and macros, not lower level implementation details and not absolute portability of 60 years old code.
From Peter Norvig's comments section...and a link to [PAIP](https://github.com/norvig/paip-lisp) which is now free and open source. \----------------------------------------------------------- Frakturfreund ‚Ä¢ [7 years ago](http://norvig.com/lispy.html#comment-359244302) This code looks very nice, but i think that implementing a Lisp Interpreter in Python is some kind of cheating. Python is a high-level language, so you get very much for free. For an antipode, i suggest to have a look into Zozotez, a Lisp Interpeter in Brainfuck (which is a ridiculously low level toy language): [https://code.google.com/p/z...](https://disq.us/url?url=https%3A%2F%2Fcode.google.com%2Fp%2Fzozotez%2F%3ALVao6C7yUDEnJ-JuT65KOLe87gY&amp;cuid=7373) * &amp;#x200B; * üì∑ [Peter Norvig](https://disqus.com/by/norvig/) Mod [ Frakturfreund](http://norvig.com/lispy.html#comment-359244302) ‚Ä¢ [7 years ago](http://norvig.com/lispy.html#comment-359339548) You are right -- we are relying on many features of Python: call stack, data types, garbage collection, etc. The next step would be to show a compiler to some sort of assembly language. I think either the Java JVM or the Python byte code would be good targets. We'd also need a runtime system with GC. I show the compiler in my PAIP book. * &amp;#x200B; * üì∑Frakturfreund [ Peter Norvig](http://norvig.com/lispy.html#comment-359339548) ‚Ä¢ [7 years ago](http://norvig.com/lispy.html#comment-360115977) Thanks for the hint! I‚Äôll put the book on my christmas list :). \----------------------------------------------------------- &amp;#x200B;
&gt; in which case you'd just keep around the stack of binding maps. Right, that's a to do that and the purpose of the implementation of persistent maps, would be that this is not too costly in terms of space. Other use cases of assoc lists would be solved differently. &gt; I guess what I'm getting at is: Clojure gives you different primitives to work with than Common Lisp or Scheme, so you solve the same problems in a slightly different way. Maybe it differs even in radically different ways. &gt; Does that matter? If one has an existing code base and wants to move it through incremental language updates, then it matters. If one builds a new code base, then it does not matter too much. 
&gt; attitude of unacceptance of different ideas I accept lots of different ideas. But I just don't consider them Lisp anymore. Example: Lisp with a different syntax and types isn't Lisp anymore. It's called ML and it spawned a new language family. Even though it used linked lists, functional programming constructs and a whole bunch of stuff lifted from Lisp. &gt; 60 years old code You ignore that I said 60s onwards. &gt; absolute portability It's also not 'absolute portability'. It's no portability at all. That's the problem.
&gt; It's also not 'absolute portability'. It's no portability at all. but that's not a reasonable goal. it's reasonable when talking about different version of a single language, not when talking about different languages of the same family. you don't expect code written in ocaml to run without (often significant) modifications in f# or reason, so why do you expect code written in CL (ok, not 60 but still a 40 year old language) to run in modern lisp incarnation? what if i fork CL and rename random operators - does it stop being lisp just because words are different? one of core ideas in lisp is that symbols are arbitrary and you can assign meanings as you like. clojure is big departure from some (most?) other lisp implementations - i grant you that. some things have been design decisions from day one, but i don't see why are those design decisions (persistent datastructures, jvm hosted, etc) incompatible with idea of a lisp implementation.
&gt; but that's not a reasonable goal. No code-reuse is a reasonable idea to claim that it's still the same language? No example code from any Lisp book from the last 60 years (no, not from 60 years ago, but from ALL the years after 1960) runs in Clojure. None. Zero. &gt; you expect code written in CL (ok, not 60 but still a 40 year old language) to run in modern lisp incarnation? Because that's usual in Lisp. My first student job (at which I wasn't good) in the 80s was to help porting a large and complex natural language system from Interlisp to Zetalisp. Two VERY different Lisp dialects. The team wrote a translator which did 90% of the work. I later had a Lisp Machine, which ran three Lisp dialects side by side fully integrated in the same runtime. Xerox added Common Lisp to the Interlisp runtime. Symbolics offered an Interlisp compatibility package. I had a Scheme translator on my Lisp Machine. Many vendors offered compatibility packages to help users running their code with little changes on different Lisps. When Harlequin developed Dylan with a completely different syntax, they wrote a translator from Common Lisp to Dylan to get access to some code bases they can then work on from. There are many examples of Lisp dialect translators and compatibility libraries. None for Clojure. 
To the best of my knowledge, "OS" in this context means "Open Source", in contrast to the proprietary version of Shen, called "Shen Professional". Shen was open-sourced under a 3-clause BSD license a few years ago - though, as memory serves, at least one user on HackerNews felt that the extra "you can't relicense this under GPL" clause kept this from being a strictly 3-clause BSD license (IANAL; I don't think they were either).
&gt; None for Clojure maybe nobody cares to write one because one of clojure's goals was to have tight jvm interop and as result access to the vast ecosystem of java packages?
\&gt; I've heard that Scheme is a fairly minimal implementation &amp;#x200B; It's minimal when compared to Common Lisp, which is not easy to implement. &amp;#x200B; \&gt; I was also just looking at McCarthy's original 1960 paper and I think I could probably just follow that design. &amp;#x200B; Scheme is far from 1960 lisp. For example Scheme has lexical bindings. &amp;#x200B; \&gt; Are there other minimal Lisps I might want to consider as well? &amp;#x200B; uLisp, runs on microcontrollers. uLisp, a subset of Common Lisp, with 122 Lisp functions and special forms. For a full definition see [uLisp Language Reference](http://www.ulisp.com/show?3L). &amp;#x200B; [http://www.ulisp.com/show?1AWG](http://www.ulisp.com/show?1AWG) &amp;#x200B; PicoLisp [https://picolisp.com/wiki/?home](https://picolisp.com/wiki/?home) &amp;#x200B; If you want a really toy, toy lisp, check this one, under 200 lines of C [https://github.com/carld/micro-lisp](https://github.com/carld/micro-lisp) &amp;#x200B; &amp;#x200B; &amp;#x200B;
Can you link to the Shen OS you're thinking of? One of the commenters below is right in that "OS" can refer to the open source part of Shen (as opposed to Shen Professional, abbreviated SP). However, recently on the mailing list there have been discussions about another Shen OS, an object system, available at [https://github.com/bluejay77/SHOS1](https://github.com/bluejay77/SHOS1)
&gt; How can a list that is full of misinformation Which? Where? I don't see any of this. Can you explicit point what you classify as misinformation? &gt; Why should people focus on this list and his site when there are plenty more appropriate places to build the community on? Is there any other place? Where? &gt; I don't want to associate myself with someone like this Sure, you have the right to do that. I'm just think that most of this stuff it is very political one and not technical. I'm not supporting exactly Hexstream, i'm just really trying to understand the "real" points where the people blame him about all the weird thoughts may him have. In other words, to me that reddit thread seems not much more greater than the xach conspiracy theory. It's just a -1 multiplication. 
&gt; He has no information either. It's just insane drivel. That is true.
1. I don't see any recent development in the ryszard fork. The last commit was [9aafcb7](https://github.com/ryszard/clsql/commit/9aafcb72bd7ca1d7e908938b6a5319753b3371d9) on Jan 3, 2009. 2. Kevin Rosenberg's git repo has [development from April 2018](http://git.kpe.io/?p=clsql.git;a=shortlog;h=refs/heads/6.8.0). He's working on v6.8.0 from a separate branch and not master. 3. The Quicklisp package manager seems to [refer to](https://github.com/quicklisp/quicklisp-projects/blob/892b43ecb769799654689db5e2dd71fd8de9f671/projects/clsql/source.txt) the Keven Rosenberg repository as official. 4. From "[A Road to Common Lisp](http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/)": 'My advice is this: as you learn Common Lisp and look for libraries, try to suppress the voice in the back of your head that says ‚ÄúThis project was last updated six years ago? That‚Äôs probably abandoned and broken.‚Äù The stability of Common Lisp means that sometimes libraries can just be done, not abandoned, so don‚Äôt dismiss them out of hand.'
Thanks for your reply. &gt;1. I don't see any recent development in the ryszard fork. The last commit was 9aafcb7 on Jan 3, 2009. I have expressed myself incorrectly. This fork has been further forked by several people, and following the network graph shows fairly recent activity: [just 5 months ago](https://github.com/Ferada/clsql/commits/master) &gt;2. Kevin Rosenberg's git repo has development from April 2018. He's working on v6.8.0 from a separate branch and not master. Thanks for this, i didn't notice. &gt;The stability of Common Lisp means that sometimes libraries can just be done, not abandoned, so don‚Äôt dismiss them out of hand.' Yes, I know, but my question is not frivolous -- i already have a year of using CLSQL, however I just found out that the `clsql-postgresql` backend refuses to work under CCL on Windows, while it works just fine on SBCL. The UFFI code doesn't load the library under CCL, even with the library paths configured, etc. I've also tried loading `clsql-cfffi` but no sucess - the backend still appears to invoke UFFI (!) `clsql-postgresql-socket` works on CCL, however i'm getting different issues... pgsql complains of attempting to insert UTF8 data with invalid characters for my VARCHAR fields (my db is using iso-8859-1 as char encoding), while the exactly same code and exactly same data works fine on SBCL. Bummer, since I like CCL a bit more. I want to submit everything to the (non existing) issue tracker. 
if you want to build a lisp of your own, i recommend you worry less about building it to match a specification, and more about building a language with syntax and semantics that you want to use and implement. there's some stuff in Scheme that you may not want to implement (see http://okmij.org/ftp/continuations/against-callcc.html), and you certainly aren't going to build an ANSI Common Lisp as a hobby project. that said, if you want a standardized language to implement, i recommend you look into [mal](https://github.com/kanaka/mal), which has a [language-agnostic guide to building an implementation](https://github.com/kanaka/mal/blob/master/process/guide.md).
Call/CC is easy to implement compared to macro hygiene. Hygienic macros is really the only hard thing about r5rs. Delimited continuations are of course much better than call/cc in every way, and I hope call/cc dies. Porting the fibc bemcark (which measures continuation performance) to delimited continuations yielded a 4x speedup in guile (although guile's implementation of call/cc is slow due to c interop).
Scheme is in fact a large implementation of lisp, where as the lisp core as defined in McCarthy's original papers consists of only 5 functions (and 4 special forms.)
Scheme is a great choice. There are a bunch of Scheme's written in Lisp, too. See for example this book with example code: https://github.com/norvig/paip-lisp There are also excellent books explaining implementation of Scheme in various variants. The best is probably Lisp in Small Pieces: https://en.wikipedia.org/wiki/Lisp_in_Small_Pieces How to implement Scheme in C: http://freecomputerbooks.com/Scheme-9-from-Empty-Space.html
My take: it's so incompatible that it does not work, that it does not make sense or that it is not economically feasible. Maybe all three.
Kilo LISP ([http://t3x.org/klisp](is http://t3x.org/klisp)) is pretty much a cross between ancient LISP and Scheme. Very few keywords, simple semantics, but lexical scoping and low-level macros.
&gt; Which? Where? I don't see any of this. So you haven't even read this very thread? People who have been added to the list without their consent have come out, in this very thread, and said that their info on the list is wrong. &gt; Is there any other place? Where? Read this subreddit's sidebar on the right. Even in this very thread someone suggested an alternative "person" list (which exists long before the list made by Hexstream, and, ironically enough, is also used by Hexstream himself). &gt; I'm just think that most of this stuff it is very political one and not technical. You are right that this is not about technical, but it is not about politics either (and has never been in the first place). This is about basic social norm, about how one conducts oneself in the community and interacts with others. The reason I don't want to have anything to do with him is because how he act like a spoiled brat towards various members of the community and also how he conducts himself in public (e.g., his homepage). I couldn't careless about the guy's political or religious beliefs. &gt; Just judging, not reading, not understanding... Just like what you are doing right now? Where do you think my (and other people) opinion of the guy came from? I've read far, far too much of Hexstream's rants, both on Twitter and various Github issues (heck, I was there when Hexstream first started raving about Xach and the CL mafia on Twitter). And if you've bothered to read through all of his rants and raves (which goes back *years*, you know), you'll see that many people gave him the chance, only to ended up being called a bully or a part of the conspiracy by Hexstream when they disagreed with him on some issues or refused to do what he wants.
fair enough, i just don't agree that it automatically makes clojure not a member of lisp family :)
Now we have a discussion. Details matters. Thanks for answering.
&gt; Thanks for answering. No problems, thanks for listening. Also, if you're on the speaking terms with Hexstream: * Teach him about the manners and courtesy of working in the open source/free software communities. For an example, tell him that it's not okay to open a pull request, then nag the maintainer to reply, then being rude towards him just because he didn't response to your pull request in a timely manner. Most of the people working on open source do so in their free time, and are under no obligation to reply. That's a very rude thing to do, and that's just one example of him interacting with other contributors. Heck, seeing him acting like this alone is enough to make me never want to work with him. * Tell him to stop trying to shove his websites down our throat. Yes, they are informative, but the reason why his websites are not getting the traffic he (seemingly) wants is because: a.) the Common Lisp community is tiny (seriously, if he wants attention that badly, he should switch to making websites for Python or other more mainstream languages), and b.) despite what he thinks, many of his websites are not strictly superior to the existing one, they are often just different (case in point: his MOP website and the people list, which are just plain mundane and hardly better than the existing alternatives), so he shouldn't be surprise people aren't flocking to them. * Tell him to stop blaming the fact that people ignore him and his works because of other factors other than his actions or the quality of his works. There, if you could manage to make him understand all of that, have him apologize to Xach, and delete all his rants about Xach on his website (and that link on his homepage as well), then I'm sure other people in the community would be willing to give him a chance. But until then, please do try to understand why we don't want to deal with him, the last thing we want is to become his "target" (or fixation would be a more appropriate term?) like Xach and many other people ended up being.
&gt; So you haven't even read this very thread? People who have been added to the list without their consent have come out, in this very thread, and said that their info on the list is wrong I actually did read before comment that, but what I saw is just moral stuff and Zach Theory complaining. How this is related to a list of names, links and info about contributions? I mean, all the stuff here simply or not have correlation at all with I posted or really have a few one. Ok, may it's not totally ok building websites and putting your public name, your public repositories, your public information. That is weird. Why anyone it would use public information on their personal website? This is just crazy! I think I will after this ask for permission about citing the papers I read when I write a article. :) Sincerely this is a shame. I give up to talk here. Everyone has your opinion, ok. I understood that. But why it is necessary being so agressive what we don't agree? I do not see any reason for that. It is just noise.
I think u/a_Tick is right. The talk about OS Kernel and BSD licensing gave me the impression that there was an operating system based on Shen in the offing. And the Object System at https://github.com/bluejay77/SHOS1 also created additional confusion.
Look, it's simple. This Hexstream make a person list, trying to convince people to use it. You share the link to the list to this sub. The guy who made the list is quite controversial, some people don't know, some people don't care, some people don't like their name being on the list for the fear of being associated with the said dude and are trying to get their name de-listed. &gt; That is weird. Why anyone it would use public information on their personal website? This is just crazy! It's like I use your username and real name to register a Facebook account for you, wouldn't that be a little creepy? Anyone who've done this would be faced with a backlash, not just Hexstream. But then again, I'm an old guy who was born during an era when we teach each other to **not** share our personal information willy nilly on the Internet... But whatever, what should happen is Hexstream should just honor all request to remove a person name from the list (because it's within their right). That should be simple enough, right? Beside, judging from Github's issues, he already has people requesting to be added to the list, so why wasted time with those who don't want to be on it?
Humble Bundle offers sprites, textures and sound packs at the moment ;)
I just used CLISP on a brand new computer to compile SBCL. Sounds useful to me.
&gt;Most of the people working on open source do so in their free time This. While Hexstream, by his own admission on his homepage, is unemployed. That's why he has all the time in the world and that's why the CL community doesn't give him the response speed he (unfairly) demands. Most lispers have a job.
If you don't use the same symbol for more than one binding, why not put the export near that binding. (defun foo-frobber (arg) ...) (export 'foo-frobber) Problem solved: if you delete `foo-frobber`, you will not forget to delete the `export`. Inspired by Linux: int kernel_function(struct pt_regs *pregs) { /* ... */ } EXPORT_SYMBOL(kernel_function) 
I recommend sxql + cl-dbi (fukamachiware), I know they are actively being used in his company. ("his" --- not that he is the CEO, though)
&gt; I recommend sxql + cl-dbi I'll consider to try this as well in the future. I'll have to judge SxQL against CLSQL's "functional SQL", which I like a lot. 
Checkout NESL/\*Lisp etc.
Thanks for all the info! What do you think about working off the R7 report directly? I'm thinking I could choose a subset of the features to start with.
&gt;uLisp, a subset of Common Lisp This sounds interesting. Would you mind expanding on this? Is it really a subset of Common Lisp (CL)? The uLisp [homepage](http://www.ulisp.com/) says this... &gt;The language is generally a subset of Common Lisp, and uLisp programs should also run under Common Lisp. But, it doesn't clarify if uLisp supports a subset of any of the CL standards (CLtL1, CLtL2, or ANSI CL)? In other words, if one were to write a program in any of the CL standards supported by uLisp using just the subset of primitives provided in uLisp, could it be used unchanged in uLisp? If that were the case, then theoretically, attempting to do micro-controller development would have almost zero language impedance for a Common Lisp developer familiar with any of the CL standards beyond learning the new software/hardware environment, related domain constraints, and perhaps any learning uLisp primitive extensions (if allowed by the standards) in order to ease development within the constrained environment.
&gt; But, it doesn't clarify if uLisp supports a subset of any of the CL standards (CLtL1, CLtL2, or ANSI CL)? From the page: &gt;Requirements &gt;RAM: At least 2 Kbytes. &gt;Program memory: At least 32 Kbytes. It would be almost impossible to be able to implement the whole of CL in those conditions. &gt;if one were to write a program in any of the CL standards supported by uLisp using just the subset of primitives provided in uLisp, could it be used unchanged in uLisp? If uLisp is really a strict subset of CL, then it should be that way. But I don't know, i'm not really familiar with uLisp. 
I had missed the 2nd parameter of `find-class`, thanks for the tip! And indeed, this trick is limited to the 3 namespaces until I add more... I wonder if there is a more general way to cover all namespaces.
I didn't know about `export`, thank you so much for that! Problem solved indeed.
Nope. There's no portable way of doing that since a programmer may define an arbitary namespace on their own. You could try using https://github.com/guicho271828/lisp-namespace to somewhat automate that process though.
Thanks for the info! Nice bundle. I've talked to Lisp Game Jam organizer (mfiano), but unfortunately resources from this bundle are not free enough to use in a jam game :( 4.2c from https://www.gamedevmarket.net/terms-conditions/#pro-licence is a show stopper here.
&gt; It would be almost impossible to be able to implement the whole of CL in those conditions. It's doubtful anyone would expect that within the constrained environment of a micro-controller. However, if uLisp can achieve some parity with a pure subset of one of the Common Lisp standard, then that would be lessen the burden on the developer who already knows that standard and they can just concentrate on learning the new, constrained, micro-controller software/hardware environment and whatever primitive extensions uLisp provided in addition to the subset of the standard. &amp;#x200B;
I may take a crack [at this certifiably crazy idea](https://www.reddit.com/r/rational/comments/b9sbqi/d_friday_open_thread/ek7z3et/).
This looks like it would be right up my alley. I've used LambdaNative to build a [simple Linux desktop app](https://dev.to/goober99/learn-lambdanative-by-example-desktop-gui-277l), but I'd like to really give it a test drive by creating a cross-platform game that could run on Android. The problem is I'm leaving the country the morning after submissions are due, and I'll be gone for three weeks, so I could submit a game, but I won't have access to the internet during the voting period. I've never participated in a game jam before. Would not participating in voting be a huge breach of etiquette? No doubt trying out the games and voting is a huge part of the experience. I would still plan to try out all the games and offer feedback once I got back even though I missed out on the voting window. Or would it be better for me to sit this one out and shoot for the one next year?
CLISP should be able to save executables. LispWorks (proprietary) allows royalty free applications. SBCL can be compiled to support threads. CCL probably needs to be built from the repository. The fix for the application had been rejected by Apple, but is in the repository, AFAIK.
SBCL on macOS runs well with threads without problem. We're using it.
That's weird MacOS support is so shoddy considering it's Unix. 
CCL works on Mojave but you need to use the development branch. It contains a bug fix for Mojave that has not been back-ported to earlier versions.
&gt; SBCL on macOS runs well with threads without problem. We're using it. I don't know why the writer said that. (Prebuilt binary does not have thread support? I've not used it except first time compilation) Ditto.
As others have stated I think you need to have another look, I'm running Mojave and I've got SBCL with threads (I always build from git unsure about prebuilt binaries) and CCL works fine (from git also as there is a known issue with the App Store release and the most recent effort to resolve it was rejected by Apple IIRC). I don't use clisp or the commercial offerings so I can't comment on those. 
CCL: https://github.com/Clozure/ccl/releases SBCL has threads on macOS. What kind of issue are you facing? What stack traces do you get?
Doubly ironic considering CCL evolved out of Macintosh Common Lisp
Not only SBCL does have threads, they are enabled by default on macOS. And support of macOS is better than it has ever been, including Mojave. If you're using SBCL, disregard this post.
I too use SBCL and CCL on Mojave, daily. I also use it for the development of production products.
As ‚Äòchunsj‚Äô Said, SBCL supports threads on macOS. I used to have to build from source to get threads on macOS, but I haven‚Äôt had to do that in a long time. If the latest distribution for macOS does not have threads for some reason, just build your own system from source code.
Why that? Macintosh Common Lisp wasn't a UNIX program. It was originally a pre-Unix MacOS program from the mid/end 80s. The port for Macintosh Common Lisp to the Unix Mac OS X was based on an shaky emulation layer of the system library ('Carbon, 2003). It then mostly died after Apple moved from the PowerPC to the Intel chips. People tried to extend its life by making it portable with the PowerPC emulator ('Rosetta') from Apple for some time as RMCL. The core (not the UI) of MCL then was extracted and ported to more Unix-like operating systems - and also open sourced as CCL, Clozure Common Lisp.. It was there where it got a native Mac OS X version without using the Carbon emulation layer for the old Mac toolbox system library.
Clojure works on mac, no problem. The power of the jvm.
Let's see if CLISP can produce binaries on macOS Mojave... &amp;#x200B; $ clisp i i i i i i i ooooo o ooooooo ooooo ooooo I I I I I I I 8 8 8 8 8 o 8 8 I \ `+' / I 8 8 8 8 8 8 \ `-+-' / 8 8 8 ooooo 8oooo `-__|__-' 8 8 8 8 8 | 8 o 8 8 o 8 8 ------+------ ooooo 8oooooo ooo8ooo ooooo 8 Welcome to GNU CLISP 2.49.93+ (2018-02-18) &lt;http://clisp.org/&gt; Copyright (c) Bruno Haible, Michael Stoll 1992-1993 Copyright (c) Bruno Haible, Marcus Daniels 1994-1997 Copyright (c) Bruno Haible, Pierpaolo Bernardi, Sam Steingold 1998 Copyright (c) Bruno Haible, Sam Steingold 1999-2000 Copyright (c) Sam Steingold, Bruno Haible 2001-2018 Type :h and hit Enter for context help. [1]&gt; (ext:saveinitmem "clispapplication" :init-function (lambda () (format t "~%Hello World!~%") (ext:exit)) :quiet t :executable t) ;; Wrote the memory image into clispapplication (7,189,504 bytes) Bytes permanently allocated: 165,256 Bytes currently in use: 3,504,336 Bytes available until next GC: 873,444 3504336 ; 873444 ; 165256 ; 1 ; 78056 ; 7950 [2]&gt; (ext:exit) Bye. $ ./clispapplication Hello World! $ $ ls -l ./clispapplication -rwxr-xr-x 1 foobar wheel 7189504 6 Apr 18:36 ./clispapplication The moral: CLISP can create binary applications under macOS Mojave.
Let's see if SBCL can run threads under macOS Mojave: $ sbcl This is SBCL 1.5.0, an implementation of ANSI Common Lisp. More information about SBCL is available at &lt;http://www.sbcl.org/&gt;. SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses. See the CREDITS and COPYING files in the distribution for more information. * (sb-thread:make-thread (lambda () (loop for i below 10 do (print i)))) 0 1 2 3 4 5 6 7 8 9 SB-THREAD:THREAD FINISHED values: NIL {1003128FE3}&gt; $ sw_vers ProductName: Mac OS X ProductVersion: 10.14.4 BuildVersion: 18E226 The moral: SBCL has threads under macOS Mojave.
I read through it all and I think it‚Äôs a good start. Some comments: 1. In a few places you talk about classes having methods. Do away with this kind of language because it is misleading. 2. In a few places you could naturally use multiple dispatch. Like your last example, you have printers and formatters. You can make a multimethods here. 3. In general I think it would have been good to talk about interfaces as protocols (sets of generic functions), not as class hierarchies. 4. There‚Äôs a bit of incorrect/overuse of readers/writers/accessors. Remember that a reader/writer/accessor are generic functions, and you can install methods onto them. For your rectangle example, you could make a SQUARE class, and define the method GET-HEIGHT as just calling GET-WIDTH. No need to do extra busywork.
Generally, we should avoid applying hodge-podge development principles in Lisp that originate from Lisp-igorant environments. For instance, let's look at the "open/closed principle". That basically just disappears in Common Lisp, which integrates it at the language level. It's a principle for programmers using object systems in which extensibility is hard to achieve without offering the internals for modification (or code generation). In CL, we can write a whole new generic function, and then specialize its parameters to lowly types like strings and integers. In C++, you have to plan for that sort of extension in advance. If you write a string or integer class in the most straightforward way, it won't happen. You start with the open/closed principle. But that principle doesn't hand you the coding pattern; so, next, keeping the principle in mind as a goal, you thumb through your GoF design patterns book to see which thingamajig will achieve that principle's goal, and so it goes. C++ standard strings adhere to open/closed by arriving in the form of an ugly template called basic_string, which is parametrized on the character type and something called traits. This anticipates the user who comes with their own character type and traits. The user who wants new basic_string methods is not so well-served, unfortunately.
I.e. pretend that Uncle Bob knew Lisp, and rethink his doctrines in that light.
Don't disregard issue reports; the user is struggling with some kind of real problem with their updated Mac system
&gt;(Prebuilt binary does not have thread support? I've not used it except first time compilation The prebuilt binary is compiled without it. I haven't resorted to building my own from source (why should this be necessary?) 
I'll try this. 
You built it from source, didn't you?
If the article pointed out that the square-rectangle problem and the Liskov substitution principle actually don't go well together and that CLOS has [its solution](https://en.wikipedia.org/wiki/Circle-ellipse_problem#Change_the_programming_language), it would be great.
The problem of jumping to conclusions from incomplete information?Can't help with such problems.
I just realized that there's a build of SBCL on Homebrew. I should've checked there first. It probably has threads compiled in too.
Thank you so much! I will try to address all of the points you made. Yours are very much appreciated.
Thanks! I didn't know about that. I will try to change the examples and address this as well. 
Thanks for the review! I will to look at the use case and see if I can adapt it to suit Lisp better.
Clasp is running on current OSX versions and has threads. No binaries. You would have to package on something. 
For what it's worth, no \*earmuffs\* in your "### Good" automatically says to me that you do not know much about CL. I stopped reading there.
&gt; ;; interface (defclass bird () nil) &gt; &gt; ;; interface body (mandatory methods to be implemented) &gt; &gt; (defgeneric b-eat (bird)) &gt; (defgeneric b-sleep (bird)) Surely, if Java-style interfaces were brought to Lisp, they wouldn't simply be classes. The thing an interface is supposed to do is statically guarantee that there is an implementation of each of the methods of the interface specialized to that class, allowing unrelated classes to be passed to a method while still passing the type checker (a concern that doesn't exist in dynamically-typed languages, which is why even newer languages like Python don't have them). Even if we wanted to for some reason, multiple dispatch would make interfaces really difficult to do in a way that's consistent. Just suppose that you had a form `definterface` that you could use like this: (definterface hungry (b-eat (bird food))) Suppose that one of the things this expands to is some `defgeneric` forms for the methods. I could satisfy the interface like this: (defmethod b-eat ((bird parrot) (food cracker)) (setf (slot-value bird 'gizzard) (swallow food))) But now, whether the interface is "implemented" or not depends not only on the bird, but also the food. So there's no way to say "parrot implements hungry". The problem gets worse the more arguments the methods may accept.
Based
Your code examples don't seem too idiomatic or correct. * You have accessors named `GET-*` which aren't widely used in Lisp. I suggest to drop all of these prefixes. * You create a reader named `GET-REPORT` and right afterwards you create an accessor named `REPORT`. This creates two readers in total, `REPORT` and `GET-REPORT`. Why do so, if one is enough? * You allow instances of the class `STATUS-REPORT-MAILER` to be created with an unbound `:ADDRESS` and you do not provide any means of setting that value once it is created. * In `DEFMETHOD GENERATE-REPORT`, you use a very long `CONCATENATE 'STRING` with `WRITE-TO-STRING`. `FORMAT` would be cleaner. * The variables you create with `DEFPARAMETER` do not consistently use the earmuff convention - the one you use in your example is named `RM1` instead of `*RM1*`. However, below, you `DEFPARAMETER *CIRCLE-ONE*`. * You refer to `BIRD` as an interface, whereas a more Lispy term is a protocol class. See the related work by [Robert Strandh](http://metamodular.com/protocol.pdf) and (shameless plug here) my own [extension](https://github.com/phoe/protest/blob/master/doc/protocol.md) of that idea. * As someone mentioned below, a set of generic functions is a protocol, not an interface. In Java, you have to implement interfaces, because you cannot create new methods on generic functions due to Java's dispatch style; in Lisp, you conform to a protocol not by subclassing some interface, but by defining new methods on generic functions. Some protocols may force all of your instances to subclass some particular protocol class, but that is optional and up to the protocol itself. * `B-EAT`, `B-SLEEP`, `B-FLY`, `B-RUN` are really weird names for generic functions. Why not define a package `BIRD` and, inside it, generic functions `EAT`, `SLEEP`, `FLY`, `RUN`?
&gt;SOLID Design Principles in Common Lisp Please don't apply principles designed for very badly designed OOP systems to our blessed CLOS. What's next? "Gang-of-four Design Patterns for Common Lisp"?
&gt;Generally, we should avoid applying hodge-podge development principles in Lisp that originate from Lisp-igorant environments. This. What's next? "Gang-of-four Design Patterns for Common Lisp"?
If "asynchronous" holds, then you have the same question here: https://www.reddit.com/r/lisp/comments/b8fqke/any_good_books_on_asynchronous_programming_in_lisp/ :)
Go roswell https://github.com/roswell/roswell/ and let it compile.
Thank you! I'll correct these whenever I can.
Thanks for your point of view!
\*shrugs\* Maybe not..
https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation https://lparallel.org/
I don't think there are any books on the topic, as they are not part of the ANSI standard, however the other documentation linked in this thread is good. The same rules apply as in any other language with locks and mutexes and race conditions etc. It's the same concepts regardless of language, so I wouldn't worry about a CL specific book.
Would you prefer feedback here on Reddit or as an issue or PR in github?
If you want to do a PR, go ahead. You are very welcomed to do so. I'm trying to re-implement the examples in a more proper way based on these reviews here.
"Honorific Japanese verbs for English" "Latin-style noun declension for Chinese" 
Thanks for the all reviews. I'm going to update the book to follow a more idiomatic approach and will deal with the Interface Segregation part (whether to discard it or not..maybe write a comparison between a Java Interface Segregation example and how this problem doesn't really exist in a language like Common Lisp)
This is pretty cool! I remember I tried setting up atom-slime but failed horribly. Hope this makes it easier for devs to start hacking on Common Lisp.
The more SLIME, the better!
While not a book, this may help one get started: # [The Common Lisp Cookbook](https://lispcookbook.github.io/cl-cookbook/) ‚Äì Threads [https://lispcookbook.github.io/cl-cookbook/process.html](https://lispcookbook.github.io/cl-cookbook/process.html) &amp;#x200B; The cookbook article above appears to have been inspired/borrowed/derived from the following series of articles according to the comments section in one of the links below: # Basic Concurrency and Parallelism in Common Lisp [https://z0ltan.wordpress.com/2016/08/29/basic-concurrency-and-parallelism-in-common-lisp-part-1-setup/](https://z0ltan.wordpress.com/2016/08/29/basic-concurrency-and-parallelism-in-common-lisp-part-1-setup/) [https://z0ltan.wordpress.com/2016/09/01/basic-concurrency-and-parallelism-in-common-lisp-part-2-bootstrapping-a-threading-capable-mac-os-x-sbcl-instance-from-source/](https://z0ltan.wordpress.com/2016/09/01/basic-concurrency-and-parallelism-in-common-lisp-part-2-bootstrapping-a-threading-capable-mac-os-x-sbcl-instance-from-source/) [https://z0ltan.wordpress.com/2016/09/02/basic-concurrency-and-parallelism-in-common-lisp-part-3-concurrency-using-bordeaux-and-sbcl-threads/](https://z0ltan.wordpress.com/2016/09/02/basic-concurrency-and-parallelism-in-common-lisp-part-3-concurrency-using-bordeaux-and-sbcl-threads/) [https://z0ltan.wordpress.com/2016/09/09/basic-concurrency-and-parallelism-in-common-lisp-part-4a-parallelism-using-lparallel-fundamentals/](https://z0ltan.wordpress.com/2016/09/09/basic-concurrency-and-parallelism-in-common-lisp-part-4a-parallelism-using-lparallel-fundamentals/) [https://z0ltan.wordpress.com/2016/09/10/basic-concurrency-and-parallelism-in-common-lisp-part-4b-parallelism-using-lparallel-error-handling/](https://z0ltan.wordpress.com/2016/09/10/basic-concurrency-and-parallelism-in-common-lisp-part-4b-parallelism-using-lparallel-error-handling/) &amp;#x200B; As a bonus, the author offers a (very) short lesson on thinking about parallelism :-) [https://z0ltan.wordpress.com/2009/11/10/cats-and-parallelism/](https://z0ltan.wordpress.com/2009/11/10/cats-and-parallelism/) &amp;#x200B; &amp;#x200B;
I am SO excited about this! So many people have trouble getting into Lisp because the only available editor is Emacs. I‚Äôd love to have my colleagues give this a spin. 
Same, if this is reasonably stable I'm gonna have to start making tutorial videos using this. Aghh so stoked :D
&gt;links Really good stuff, thanks! :D
That is one of the best efforts in popularization of the Common Lisp one could hope for. The lack of good support in popular editors is something that is dragging the CL behind.
Can we hope for something like this in VScode?
There might be something to do with Eclipse too (https://lispcookbook.github.io/cl-cookbook/editor-support.html#eclipse), but Slima seems more advanced.
I'll wait to see those changes first.
Side question: do you experience any problems using StumpWM? I vaguely remember it being architecturally bound to some ancient api or something of that sort; can't easily find the discussion and would like to know your opinion as well. Good content! Couldn't find the way to get an RSS feed.
Well done ! Resources updated: https://www.cliki.net/IDE + https://lispcookbook.github.io/cl-cookbook/editor-support.html#atom + https://github.com/CodyReichert/awesome-cl#atom
Most people looking for alternatives to Java flocked to Scala. It has a familiar syntax, static typing, and OO.
Since both use Javascript for extensions, perhaps it could be ported?
I don't have plans to port it, but it should be possible. You might be interested in https://www.npmjs.com/package/swank-client, which contains the actual swank calls for Slima.
Thanks!
Thanks for the feedback. I've gotten use to how it's designed to work, so having the issues reported really helps. Also, for reconnecting, per your issue, slime:connect should work. But, I will look at either adding a reconnect alias or at least documenting it better.
The complexity of learning Emacs is why I originally tried atom-slime. So, I definately understand the sentement.
Thanks. It stills shares a lot of atom-slime's codebase, so setup is still the same. However, there are a few improvements that I'm hoping to make to the configuration/swank startup that should help. And if you have specific issues, feel free to share them so that issues with the code or documentation can be improved.
&gt; Can we hope for something like this in VScode? We already have something for VSCode, there is a Language Server for Lisp. I haven't tried it, though. 
Very nice, thank you. I do not use StumpWM, but this gave me inspiration to try it.
I just added an RSS feed just for you :-). (properly brightened my day that you asked). As far as StumpWM goes: rock solid. I used to have memory overflow problems sometimes, but someone smartly figured out that it was cause by a font library, so as long as you use a BMP font, you're good to go. It might have some weird old school dependencies, I think the X interface library might be the one, but I've never run into an issue. If there's something you want to do with X you can always call `xdotool` which is what I sometimes do. I have a ton of fun building custom stuff in it; I'll post some more about some stuff soon.
Thank you! Give it a try. I'll post more about my StumpWM config soon, and if you want, you can take a look at my [dotfiles](https://github.com/noogie13/stumpwm-configs)! 
&gt; https://www.npmjs.com/package/swank-client Oh, interesting...thanks!
Thanks.