I have not. As I did less in Arc, I started doing more in Emacs (so I was using Emacs Lisp), and more recently I've been doing stuff using [quil](http://quil.info/), a Clojure library. If I were to do more in Common Lisp, I would definitely look into Clamp. (assuming I remembered)
&gt; Valid. Of course CL'ers can just use cond everywhere and get the same benefit. That's true. I don't see people doing too much of that -- I assume it's a de facto style not to. I don't love `cond`, as discussed elsewhere, because of all the parens.
&gt; I don't think using fewer parentheses does anything to help with readability. I don't think the difference matters that much, but I don't think either style is clearly better. I think it does help, but it's not worlds of difference. I prefer Arc's trying to get rid of parentheses where it does. That's style preferences, I guess. &gt; On the other hand it looks like you would have to potentially switch between let and with with Arc. Yeah; it is interesting how that seems to bother me less than `if`/`cond`. I wonder if there could be a name improvement where the multi-variable macro was a modification of the single-variable macro: something like `let`/`lets`. That does leave out the `let*` analogue, though. Oh, and one other thing that is nice is destructuring everywhere; there's no separate `destructuring-bind`, which I find myself not wanting to use in Common Lisp because it's so long: arc&gt; (let (x y) (list 1 2) (prn x " and then " y)) 1 and then 2 1 It also works in function parameters.
If it pertains to Common Lisp, I would have disagree with the aikido part. In my opinion, if there is a martial arts system that CL more closely resembles, it would be something like Krav Maga or Combat Sambo. Common Lisp, like those martial arts, allow you to use whatever techniques necessary, in order to get the job done. Aikido, on the other hand, works in idealistic environments. It works, as long as the conditions are conducive. However, it falls apart when confronted with an opponent who is going to use all the tools available to win.
&gt; I think it does help, but it's not worlds of difference. I prefer Arc's trying to get rid of parentheses where it does. That's style preferences, I guess. I prefer even/odd alternation for simple cases. For example, with `setf`, you usually put the place and value on the same line, and there is no body anything extra at the end. Conditionals are more complicated. Once you have longer test/execute forms and more of them, it would be unreadable if everything was indented at the same level. You'd have to look at the context to determine whether something was a test-form. Of course, you could use extra newlines or custom indentation to get around that, but I personally prefer the extra parentheses because it makes things readable with the default indentation, because of the implicit progn, and because it makes editing the entire clause (e.g. deleting it, changing its position, etc.) simpler (which is not just a stylistic difference). &gt; Oh, and one other thing that is nice is destructuring everywhere FWIW there are several libraries that add destructuring to let in CL (e.g. [metabang-bind](https://common-lisp.net/project/metabang-bind/user-guide.html) and [trivia](https://github.com/guicho271828/trivia)'s `let-mtach`), making `destructuring-bind` unecessary. `let-match` specifically is far more powerful than basic destructuring, and of course you can extend pattern matching like this to be used for function parameters or whatever. 
Do you think they shouldn't have used Lisp at all or is there a dialect of Lisp that's better for web stuff?
I think it's probably not the best idea to build a startup using a language that you don't know well. CL works just fine for web applications, although I wouldn't say that's where it really shines.
Ignore whether other people find it of value. Read it. Do any exercises you find. Make up your own mind on its value. I for one, enjoyed it. 
I certainly agree with the idea that you should make up your own mind, but in this case, I'd also like to balance that with advice from those more experienced.
You don't have to necessarily use everything you read in *On Lisp*, but as a course in heavy macrology it is quite interesting (probably this same comment applies, to an even greater degree, to *Let Over Lambda*). Another book worth considering IMO is *Common Lisp Recipes*. Less mind bending, but also the only recent text dealing with "practical" matters.
I have read it and enjoyed it. It's good to take Graham's opinions with a big pinch of salt, but the knowledge he passes through that book is worthwhile in my opinion.
Is On Lisp required reading before Let Over Lambda?
I would suggest at least testing out of 'On Lisp' before moving on to 'Let Over Lambda'. If you understand why gensym() is needed in lots of macros, you can probably test out of 'On Lisp'. 
recommended. he builds pretty heavily on what On Lisp does.
Lisp has no exceptions, it has signals. A workaround I thought of: if you know the names of the packages that create name conflicts, you can create a custom handler function that will rename one of the packages to resolve the conflict, and then call `QL:QUICKLOAD` again, until it finishes without signaling an error.
It was a real mind-opener so I found it useful for the intellectual exercise but I don't think I've directly used anything from the book.
(ql:quickload "cxml-stp") (ql:quickload "cl-libxml2") \---------------------------- XPATH is a nickname for the package LIBXML2.XPATH \[Condition of type SB-KERNEL:SIMPLE-PACKAGE-ERROR\] Restarts: 0: \[TRY-RECOMPILING\] Recompile package and try loading it again 1: \[RETRY\] Retry loading FASL for #&lt;CL-SOURCE-FILE "xpath" "package"&gt;. 2: \[ACCEPT\] Continue, treating loading FASL for #&lt;CL-SOURCE-FILE "xpath" "package"&gt; as having been successful. 3: \[RETRY\] Retry ASDF operation. 4: \[CLEAR-CONFIGURATION-AND-RETRY\] Retry ASDF operation after resetting the configuration. 5: \[ABORT\] Give up on "cxml-stp" \--more--
On Lisp is a course in writing Common Lisp macros. The book goes over different macro types. Each chapter starts with some motivation (why you would want such thing), and then shows how to implement such a feature in CL. Some of the macros can get quite advanced, especially if you don't have prior macro experience. However, macros are not necessary to write programs in Lisp. They can make things simpler, more elegant or faster, but you can use other abstractions (although they might be less elegant or require more code). If you want to learn macros, read it. If you don't, well... still read it. If you don't like it you can always put it back on the shelf. I definitely think that this book is worthwhile.
6pm UTC happens when this comment is 20 hours and 49 minutes old. You can find the live countdown here: https://countle.com/-222791wiB --- I'm a bot, if you want to send feedback, please comment below or send a PM.
&gt;I was thinking of digging into On Lisp for some summer enrichment reading (for CL books, I've read ANSI Common Lisp, Practical Common Lisp, Land of Lisp, and Common Lisp (Touretzky)). It seems like the community is a bit torn over whether On Lisp would be worthwhile. Would you be willing to share you take and suggestions? Hi Mick, I think you've already read a lot! I'd suggest you, if you haven't done it already, to try to do a small project in CL instead. This will also force you to get more acquainted with the current ecosystem, which is an important part of learning CL. And, as a known lisper said: "Lisp is now. Talk to a REPL." 
I happen to enjoy On Lisp. Some people have legitimate criticism of some of Graham's style, but those are generally minor. Another excellent book is Paradigms of AI Programming. Not really about AI.
[https://github.com/norvig/paip-lisp](https://github.com/norvig/paip-lisp)
Also for some CL wizardy I'd recommend The art of metaobject protocol.
I second this. And in this case it is even permitable to judge a book by its cover.
Why is Python in there but not its close cousin GW-BASIC?
I'm not very sure. I think Peter Norvig mistook [Python for a Lisp dialect](https://news.ycombinator.com/item?id=1803627) and was destroyed by John McCarthy in the room.
1. I have successfully built and deployed multiplatform Qt4 applications using Shinmera's qtools and I enjoy that toolkit. 2. I don't know what rofi is, so I can't really help you with that one.
So I'm guessing you've never tried it with gtk? I'd just hate to bring in Qt and all its dependencies just for my little "learn cl" app
I've only used QTools as well, but a search in Quicklisp reveals no shortage of GTK libraries. Maybe start with [cl-gtk2](https://www.cliki.net/cl-gtk2) and ask questions specifically about that or some other library if you run into problems. In my experience with the CL ecosystem, sometimes the best way to identify what works for your use case is just to try a few things out first.
related to McClim, I've seen [Garnet](https://github.com/earl-ducaine/cl-garnet) to have "gtk theme" commits. 
If looks are irrelevant go McCLIM
Does it just look like crap? I looked at the examples and that top bar is super weird, but it does seem to be the cleanest and easiest to setup of them all. I'm having trouble even figuring out how to get a sample app with cl-cffi-gtk set up
I'll second McCLIM. It's received a lot of good attention recently, and doesn't take too much to get going. It even works on Windows w/ xming or another X server.
It looks like crap and it is definitely different to the typical way of writing GUIs but there are some examples and nice people who can help are working on improving it. It's probably the easiest to set up, as far as I know. LTK is definitely *the* easiest though, http://www.peter-herth.de/ltk/
cl-gtk2 is great library to write GTK+ applications. I had used it to create [my application](https://github.com/andy128k/PassStorage/tree/common-lisp) for managing passwords. Unfortunately it supports GTK+2 only. Another option is to use [GObjectIntrospection](https://github.com/andy128k/cl-gobject-introspection) to invoke g\* libraries.
I can't believe there's so little choices for gtk3...your app looks really good though. Going to look through the source, thanks for the example. Ah crap, just saw this requires asdf to setup. That's where I got super confused with cl-cffi-gtk (cl bindings for gtk3) - I don't understand what asdf is (depsite googling), and don't really understand what's going on with the setup. I'll see if maybe I can get this one going. 
ASDF is the most used Common Lisp system definition/build system. Think of it kind of like GNU Make, but for Common Lisp. To simplify finding and installing libraries, Quicklisp can be a big help. If you're having any issues with ramp up, see http://articulate-lisp.com/
&gt;I don't understand what asdf is You can think of the [ASDF](https://common-lisp.net/project/asdf/) file as a makefile (more CMake CMakeLists.txt than GNU Make Makefile) or the package.json file used by Node.js projects. Essentially, it describes your project's structure and dependencies (and even how your project should be built). You usually don't need to write an ASDF file by hand. You could use Xach's execellent [Quickproject](https://www.xach.com/lisp/quickproject/) to create your project skeleton with a ready-to-use ASDF file in it. From a SLIME's REPL: CL-USER&gt; (ql:quickload 'quickproject) &lt;snip&gt; CL-USER&gt; (quickproject:make-project "/home/user/code/cl/gui-sandbox" :depends-on '(cl-gtk2)) The above snippet quickloads the Quickproject and uses it to create a new project called "gui-sandbox" that has the cl-gtk2 library as one of its dependency at /home/user/code/cl/gui-sandbox folder. If you need to add more dependency to your project, just open the project's ASDF file and add it to the depends-on list.
&gt; I have successfully built and deployed multiplatform Qt4 applications using Shinmera's qtools and I enjoy that toolkit. Thanks for this, i'll give a look to qtools. 
&gt;Is CL really bad/complicated for GUI programs? Is there not a simple way to build a GUI ala Racket? For what it's worth, for very simple stuff (like what you mention, for example) I used the `ltk` library, which allows you to build GUIs using the TK toolikt (from Tcl/Tk) from Lisp. It's very easy to use and it has a useful documentation. This requires you to install a Tcl distribution, which is probably already installed in your computer. It's just an option, of course there are more options mentioned in this thread and which might be even better, but I just wanted to say that I found LTK fine for simple UIs. 
&gt; LTK is definitely the easiest though, http://www.peter-herth.de/ltk/ I've used it and it was extremely easy to use, at least for simple UIs. For complex UIs using the Tk toolkit, perhaps Kenny's `celtk` will make them simpler. 
To add to this reply: Often Quicklisp is used as well. Quicklisp "cooperates" with ASDF. ASDF takes care of building the project, and Quicklisp will take care of downloading all the dependencies (and use ASDF to build them). 
A native GUI project is probably \*not\* the best first project. That being said, for simple gui programs ltk is pretty doable. Qt4 (as others have mentioned) has a reasonable story as well. The GTK story is bad, partly because the GTK API is so terrible (I was trying to write my own adapter where I would wrap just the API calls I was using, and I discovered a function that returns a handle. Sometimes the handle is owned by you, sometimes the handle is not (it depends on the parameters). Properly automatically managing resources that behave like that is not fun.
Personally I'd love to see an IUP binding, potentially with Cells integration. That would be really nice. Definitely going to have a go at it once there's some free time (hahahaha ^(cries in the corner...))
Wow that sounds like a complete nightmare. I've always heard the GTK API was bad, but not that bad. You're basically saying GTK will add in too much overhead that it'll take away from me trying to learn CL I'm guessing? Based off the other answers here, seems to make a lot of sense. What do people normally use CL for then? Is it just not used to build GUI programs very often, or are CL people big on Qt? Will either use ltk or just write a program that feeds data to rofi like suggested on irc. Thanks for all the information!
Wow, this is pure gold. As it happens, the only two languages I really write in are JS and C (and I'm a huge CMake proponent), so that was the perfect explanation. I completely get it now, thank you! Like I mentioned, I got confused when trying to install cl-cffi-gtk. The instructions [here](http://www.crategus.com/books/cl-gtk/gtk-tutorial_2.html#SEC2) seem strange to me - they tell you to clone the repo, then run `(asdf:load-system :cl-cffi-gtk)`, but of course it wasn't able to find cl-cffi-gtk (and I don't even understand where load-system looks for it, or where you tell it to find the program). Then I saw cl-cffi-gtk was on quicklisp, so I installed it that way, which I thought would handle all the asdf stuff for me (and you confirmed it does). But when I ran `(cl-cffi-gtk-build-info)` at the end to make sure everything was installed correctly like they said, it said it could not find the program. So: 1. How does asdf know where to load packages/programs from? Is that something you specify in the config and always save packages in that directory or something? 2. Why didn't quicklisp install it correctly? Should it be as easy as installing the package with quicklisp and then running their command to make sure everything is set up, or did I miss/not understand a step somewhere along the way? Thanks for the help btw, really appreciate your explanations.
*Really* funny that you mention IUP. I'm actually a developer working on additional backends for IUP to make it truly cross-OS compatible. Currently working on backends for Cocoa, CocoaTouch, Android, and web (my main task, via emscripten and wasm). I've also started javascript bindings for the Iup library itself, which are unfortunately only about 30% complete. I've always really really wanted a lisp binding, and if I finish the js binding, I'm considering doing CL next! Problem is, as you can see, I'm just learning CL so even by the time I get to it, I doubt I'm the best candidate for the job. Ironic someone working on a cross-compilation GUI library is here asking for help with a basic GUI toolkit, right? I actually had little native experience before being brought into the Iup project, and now that I've just been focused on that, I still have yet to play around with building my own native gui apps. Strange, I know..
ASDF has a few pre-defined directories and some ways of extending it (frankly I don't know, read the manual hahaa). Quicklisp provides a local-projects directory in its quicklisp directory (ask about this on #lisp) that you can put asdf systems into. I'm pretty sure that there's some other mistake with the function call you tried. Can you give us the stack trace and error message? I'm almost entirely sure that you tried calling the function in the wrong package.
\&gt; I'm almost entirely sure that you tried calling the function in the wrong package. Could you explain what you mean here? That sounds like the mistake I made, considering I barely understand at all how CL and quicklisp work. Would I have needed to load the cl-cffi-gtk package before calling `(cl-cffi-gtk-build-info)`, is that what you mean? All I did was install it with quicklisp and call that function
Functions and variables reside in packages. You typically start in the cl-user package, call list-all-packages and see if you can find your package in there. Then do in-package on that package name (as a symbol), then try calling your function
Awesome. Not that I'd care about Mac OS X or web (that seems rather extreme in a way...) but Android support would be great. I can see three possible levels of support: 1) basic low-level FFI for using IUP directly, 2) handrcrafted CLOS classes matching the available IUP widgets, possibly with some MOP goodness to automate stuff, 3) like 2) but with [Cells](https://github.com/kennytilton/cells) support. I think only 2) and 3) require deeper CL knowledge. And they have to include 1) anyway as its foundation. I was thinking of simply using IUP's C API in a rather straightforward fashion, presumably using CFFI. The C API is quite nice, that's why I have IUP in my sights in the first place.
You may not care about the web, but one day if you could write one source file and have it work on every major OS AND the web...well, I hope you’d be pretty happy :) The issue with the web is that it doesn’t have native widgets like OSs do, so there needs to be a lot more styling around it than is natively required. But it is working! I even built a web browser in Iup, compiled it, and yes, opened it within another web browser :) Honestly it wasn’t even my idea, it’s how I got brought in (my “expertise” was needed with the web part, if you can call it that). But it got me into all this low-level native development, so it’s definitely been a great experience for me. Really challenging programming too, I’ve learned more than I could’ve imagined. Yes, the C API is the way to go. That’s pretty much how we’ve done everything - it’s just the best way to communicate across languages like that, especially given Iups architecture. I could probably do #1, but I still have a long way to go in learning even basic CL before I attempt. 
In taxi now, look here: https://github.com/crategus/cl-cffi-gtk/blob/master/gtk/gtk.package.lisp See the defpackage gtk form? It exports the function you were talking about: Run (gtk:cl-cffi-gtk-build-info)
It's not that I don't think that there's no value in it, just that I find it somewhat peculiar. Let's say I write a C application. How would it work using the web backend? In a local window? Or would it get launched on-demand upon a remote user accessing some URI?
The idea behind it is that every computer can run a web browser. It’s the great equalizer and ultimate fallback - even someone on a raspberry pi or similar microcomputer can run your app. It’s the final step in ultimate portability, even though it will obviously be a less ideal environment than a native OS. Coming from a web background I’ve been focusing on making it work in as native to the web as possible without changing how Iup works. We’ve already solved some really big issues in getting it to work, now I’m mainly implementing widgets. 
So it's supposed to be for client-side applications packages into a HTML page? I kind of shudder at the idea of running this with an RPi, though. In my (admittedly limited) experience the RPi really accentuates the differences in software performance. Things like the FOX Toolkit run wonderfully on it whereas you notice lags with heavier environments such as Qt or the browsers.
You doxxed me :) ! Yes, I’m the young guy who talks for 10 minutes on the web part. Were you at the lua workshop?
Nope, sadly. I watch Lua workshop presentations intently though, they're generally very interesting, even if Lua is not my priority (perhaps my favourite language after CL and Scheme, though).
I actually dislike Lua, despite my collaborator trying to force it on me. I’d take ES6 as a pure scripting language any day, and for non-web, I’d much rather use racket (though this is exactly why I want to learn CL, to use instead). Just doesn’t have a void for me that others really think it fills. I also hate having to type ”end” so much. Ir id well-designed though, most admit. Did you see our talk? What did you think?
Btw, we’ve done extensive testing on the pi and it works really well. We have some videos somewhere of apps running on it if you’re curious 
I think I saw it shortly after release and don't remember much, except for me being comforted by this confirmation of continuous improvements to IUP. I guess I'll have to watch it again. ES6 is obviously a massive improvement, even if it still feels a little bit PHP-ish where Lua is just simple and not very surprising. I like Racket in principle, but the current implementation of the fundamentals seems underwhelming. The Chez-based Racket 7 will surely be awesome though.
That would be nice to see.
If you ever get around to it, tell me what you think. The organizer and I would love any feedback from people who have used/know about Iup. So this is actually why I wanted to move to CL - Racket was very simple, but I felt like I was missing out on a lot of the fundamentals. I heard CL was great particularly for that. Is that a good reason? Am I better off plowing ahead with CL? And finally, would you do something like this (just try and build an app) or spend the time and actually go through PCL and it’s exercises?
CL is crufty, but I found the supposedly undisciplined language liberating in some respects. For example, I was trying to come up with a generic function macro for Chez that would both establish some module-level bindings (to export functionality in first-class form) and perform some idempotent side effects to register the necessary data in some global data structure for internal bookkeeping. But unless I missed something really important, in the expanded code, the bindings have to come first and all possible side effects at the end. But since a form can at most expand into a sequence of forms in a top-level begin, I concluded that I have no idea how to accomplish what I was trying to do, unless I intended to only have one definition per file, which seemed rather limiting. CL would never prevent me from doing that - at the risk of me shooting myself into the foot if I don't know what I'm doing, of course. And in many ways, I guess I'm just old-fashioned. Practical Common Lisp is nice, but there's also [this](https://www.cs.cmu.edu/~dst/LispBook/) as an intro, or [this](https://cse.buffalo.edu/~shapiro/Commonlisp/) for another one, or [this](https://github.com/norvig/paip-lisp) for some advanced techniques, but with first three chapters serving as a nice intro, too. But reading PCL from the beginning also works, I guess.
This is why we need package local nicknames.
So to answer the third part real quick: this is where my lack of knowledge of CL comes into play. For languages like lua, it’s not an issue: we run all the c parts, including lua (the compiler and vm), through emscripten (c-&gt;js/wasm compiler). The emscripten-compiled lua compiler/vm can then load your Lua scripts and execute them in the browser. For compiled languages it’s not as easy. We need a wasm generator for those languages. If we’re lucky they will make a standardized wasm ABI
Most serious CL implementations are self-hosting native compilers with the option of compiling new native code even when the application is running. Needless to say, wasm can't handle that. Chances are it never will. ECL can generate C-like ELF binaries by means of generating C code first. In the Scheme world, Gambit works similarly.
Oh wow. That’s crazy, I had no idea it worked like that. That explains the REPL and great tooling around CL. You’re right, that will definitely not work for any of our backends, and you be hard pressed to get that to work with Iup at all (Iup wants control of the event loop, for one thing). ECL seems the most practical option if it compiles straight to C - that would make it integrate seamlessly into Iup. It should simplify writing the bindings too, no?
I'm pretty sure the event loop is not that much of a problem. The fact that the really interesting applications that I have in mind require the compiler at run time however is. So the wasm web route is much less interesting to me (as opposed to, say, a web interface communicating with an embedded server running in a native application process).
The repo from crategus is unmantained, development of cl-ffi-gtk continues in Ferada's fork
There's always the bug-ridden lisp500.c or xlisp. Xlisp doesn't have a built-in debugger so the program ends with the smallest typo in tge REPL and is missing some macros/functions so it won't run many pre-existing programs, and xlisp has an alternative object system not the CL standard CLOS/MOP. However xlisp is easy to compile and doesn't require extreme configuration or system compliance to compile... (hint: use the unix Makefile).
BTW, we have minipicolisp
I haven't stumbled upon a CL variant that's "to some extent accepted". If anything, there are other Lisp dialects that are much smaller than CL, but they're separate dialects altogether.
What advantages would a smaller version of CL have, and how would using it be different than simply using a subset of the features of CL?
There are a bunch of CL variations. Generally the ANSI CL Common Lisp is a mid-sized version of Common Lisp. Note that the standard does not specify a full language, but a language which might be implemented in different ways or needs to be extended. Examples are new character and string types to support unicode. Another examples are conditions and streams - the ANSI CL standard does not say that they are CLOS-based. The ANSI CL standard also does not include the Meta-Object protocol - larger implementations often will have both: CLOS based implementations of conditions&amp;streams and an extensible CLOS. Implementations usually have an extensible version of LOOP - extensions are not in the standard. So there is a whole bunch of things one might expect in a real full Common Lisp implementations and which are not a part of the standard. Additionally there were/are smaller versions of Common Lisp - mostly a) historically, since the CLtL1 'standard' was a smaller CL, b) because some implementations only provide a subset of CL, when a full CL was too much work or not needed, c) because an explicit subset could be compiled more efficiently. Plus there are very CL influenced smaller languages, like the original Dylan or ISLisp. So examples for smaller CLs are * those who implemented CLtL1. * the original XLisp, Powerlisp and a bunch of other small Lisp implementations * L, a Lisp for robots * uLisp, a Lisp for Arduinos * CL0, a language of efficient delivery implemented by CLICC and MOCL: http://lispm.de/docs/Publications/Common%20Lisp/CLICC/CommonLisp0%20and%20CLOS0,%20The%20Language%20Definition.pdf 
&gt; Like in my mind on the scheme side of the lisp family there’s like RxRS as the small language and Racket (among others) as the big one. Rnrs is more like the standard base of scheme, which many builds on. Chibi scheme would be something like chibi that is easy to embed and uses very little resources. Racket isn't really the big brother of scheme, but really just a language that builds on scheme. We are many that prefer other schemes, since even though racket is flashy and all that, it still lacks a lot of things. Proper threading and things like a proper object system (whatever they are using now is very much java whereas guile has something a lot more CLOS)
The commercial implementations Allegro CL and LispWorks use GTK+. They used to be implemented on top of Motif. On Windows they also use the Windows APIs and on Macs LispWorks is using Cocoa. Both have a Lisp-based toolkit. Allegro CL uses 'Common Windows' and LispWorks has 'CAPI'. The 'free' Clozure Common Lisp uses Cocoa on the Mac.
If it had a small enough memory/disk footprint it would be nice to be able to use a CL for mobile dev, especially if the subset could be compiled efficiently (sbcl &amp; ecl work on android but I suspect are a bit heavy weight [just guessing I need to test this] and mocl exists but I'm not sure how it compares to regular lisp dev) 
A sight tangent but does gtk look decent on non linux OS' now? I did a little work with it when I did python and it always looked ugly or out of place on windows &amp; mac.
LispWorks runs on Android and iOS. Since it has a delivery tool, which removes partd of the language from the application, it effectively includes sub-versions of CL - without function redefinition, without function names, without eval, etc...
One other reason to read let over lambda afterwards is that it is a heavily opinionated book. Its thoroughly enjoyable as an insight into how one person believes coding should be and there are some great lisp tidbits to be learned but don't take it all as gospel or examples of how CL must be written.
You can choose for yourself a subset to use. I have been using Lisp languages since about 1980 and I use a subset of Common Lisp that I feel comfortable with and find very readable: I rarely use LOOP and use macros and CLOS very sparingly. I do the same with Haskell: use a subset, few language extensions, and a few monoxide patterns for the kinds of applications I write. Most Scheme dialects are simple enough that I use most of the language.
type `asdf:*central-registry*` to see where you can put the lisp systems to get asdf to be able to load them. you can also add other dirs to this registry using `push`, so `(push #p"/path/to/systems-directories" asdf:*central-registry*)` hope that helps!
The Lispworks runtimes for Android/iOS cost 1000$ / year each and are sold as "add-ons" to existing Lispworks licenses (cheapest: 3000$ for 64bit OSX) 
&gt; The iOS runtime doesn't even support writing GUI code in Lisp, it forces you to write it in Objective-C. One would write an application in Objective-C (or Swift). LispWorks for iOS now enables us to write some parts of the application in a relatively complete version of LispWorks. Which has the interesting side effect that it can be developed / debugged with a LispWorks IDE on for example a Mac, which can show Lisp backtraces from the iOS device and provides a Listener into the device.
[https://github.com/klimenko-serj/cl-iup](https://github.com/klimenko-serj/cl-iup) not sure what state it's in though
qtools takes care of the dependencies such as they are, and gtk integration is not great. LTK is a lightweight alternative
&gt; You're basically saying GTK will add in too much overhead that it'll take away from me trying to learn CL I'm guessing? Yes. &gt; What do people normally use CL for then? Is it just not used to build GUI programs very often, or are CL people big on Qt? Pretty much all commercial CL implementations offer a quality GUI library. Note that `#lisp` skews towards users of open source implementations, which is partly why you got the advice you did. 
Thank you very much for your time!
While my question was mostly out of curiosity, I would imagine that the following applications could be possible: * (In an educational context) discussing the differences between language design (Functional and less so). * As a scripting language. * Use in embedded systems. * Easier implementation (not an application, but furthers the previous possibilities) 
Oh no makes perfect sense. What does the open source community generally use it for then?
[TXR Lisp](http://nongnu.org/txr/) is substantially influenced by Common Lisp. It's useful in scripting and embedded systems, and I actually developed it from a certain educational angle (enlightening the user is always something I have in the back of my mind when designing and documenting). It isn't widely accepted/used, however.
ISLISP was standardized at the same time as CL, and CL actually added some features (e.g. \`define-symbol-macro\`) so ISLISP would be a subset of CL.
Hmm, why were IS and CL standardised separately? Wouldn’t it have made more sense for ISO to adopt CL?
Thanks, I had forgotten about lispworks' offerings.
So, couple bits to understand, like the difference between systems and packages. Systems are an `ASDF` level construct, so they define code dependencies; packages are a code namespacing system, so once you’ve loaded a system with asdf that code will probably have created one or more packages where it houses the names for its functions/classes/etc. Quicklisp wraps asdf, adding a few directories to the search path (like "~/quicklisp/local-projects/") and adding a way to download systems from the web as needed. The docs for `cl-cffi-gtk-build-info` says it’s in the `gtk` package (http://www.crategus.com/books/cl-cffi-gtk/pages/gtk_fun_cl-cffi-gtk-build-info.html), so you could either do `(in-package :gtk)` first before running that function or (probably, assuming they did the usual thing and exported that symbol from the `gtk` package, but I can’t check right now) refer to it with the package prefix: `(gtk:cl-cffi-gtk-build-info)`. As a side note, edi weitz has this on systems VS packages: http://mirror.informatimago.com/lisp/weitz.de/packages.html
Thank you for that link. I was looking for this article some time ago because it was referenced somewhere, but the original website was gone and I did not know about the mirror.
GOAT explanation. Every programmer approaching CL the first time should read this - I hadn’t seen this all explained anywhere this clearly. Everything makes _so much_ more sense now. I didn’t even know about systems. Thank you!!
you can read one side of the history [here under "Evolution of Lisp"](https://www.dreamsongs.com/Essays.html) by Richard Gabriel and Guy Steele 1985: &gt; The bombshell was that Steve Squires introduces Bob Mathis to talk about the need to establish an ANSI standards group for Common Lisp. The news heard was this: There was a plot afoot to start an ISO standards group for Lisp, and the only way that the US could respond was to have a Lisp standards group which sends a representative in the name of ANSI. There were persistent rumblings, the Group was told, that the Europeans did not like Common Lisp and wished to create a non-Common-Lisp standard. This effort was being lead by the French and British, and the US wanted to avoid the APL by letting the “frogs” get the convenorship. &gt; This slip of the tongue was especially damaging, because sitting in the back of the room was Jerome Chailloux, the leader of the EuLisp effort. Sitting with him are Pierre Cointe, the leading French object-oriented programming guy, and several other Europeans. &gt; Bob Mathis was sent by DARPA to save the day, by heading off the initial ISO thrust. He did this by recommending a study group that Mathis would head to determine whether Lisp was suitable for standardization. This group was to report in one year. This gave the US a year to start its standards committee and plot its strategy. &gt; Mathis was the convenor for the ISO ADA working group, so he has experience shepherding standards through the process. He was asked by Squires to help the fledgling Common Lisp Group. Stunned, the Group was not sure how to respond, except to wonder at the severity—nay, the existence—of the threat. Nevertheless, it appears the wagon train is leaving, and all that was left to do at this meeting is to schedule the first organizational meeting for what would become X3J13, with the mysterious Bob Mathis at the helm. &gt; A consummate politician, Mathis enlisted the aid of Fahlman, Steele, and Gabriel in rallying the troops. &gt; DARPA’s stated reason for fearing the European effort was that there was a law that says that if there is an ISO standard for a language, the US has to use it in defense-related work. Of course, there are many ways to circumvent this law with exceptions and such things, but possibly, thegroup was told, these mechanisms would not always work, and perhaps there may not be such a Common-Lisp-friendly set of program managers at DARPA. 
&gt; The Lispworks runtimes for Android/iOS cost 1000$ / year each and are sold as "add-ons" to existing Lispworks licenses To be honest, this isn't expensive for the enterprise world. 
&gt;I was wondering (out of curiosity) if there existed a smaller version of Common Lisp that was to some extent accepted. Depends on what do you want to "be smaller". If you want the language to be smaller, well, you don't need to use all features at once. For example you can choose not to use CLOS, not to use type declarations, etc. etc. etc. So less "language surface" to learn too. If what do you mean is that you want a Common Lisp *implementation* that is small, perhaps CLISP fits the bill. There are even smaller ones like Eclipse Common Lisp (not to be confused with ECL, Embeddable Common Lisp). If what you want is a CL implementation that produces small 'binary' (image or executable) sizes, I'd hazard a guess that the JIT-compiled implementations, like CLISP, should produce pretty small images. And then there's LispWorks which has a tree-shaker that is intended to reduce image/executable sizes as much as possible (see online documentation.) But if what you mean is a *standardized minimal subset of the CL language*, i'm afraid this doesn't really exist, and you'd be better off taking a look at Scheme or perhaps PicoLisp (which is a very different Lisp). Also note that, while in the 80s Common Lisp implementations were "big" pieces of software, nowadays they're not big at all. 
6pm UTC happens when this comment is 2 hours and 14 minutes old. You can find the live countdown here: https://countle.com/c226850z9- --- I'm a bot, if you want to send feedback, please comment below or send a PM.
No.
Interesting. Thanks for the heads up!
I don't tune in anywhere enough, but I just wanted to say please don't stop doing this series, it's amazing and inspiring.
Your twitch link is broken, the underscores are not part of the link if you click it :)
Well.. thats sucks :D. Thanks for the heads up!
For those watching in first hours after upload the episode starts at 6:29. One heads up, the gpu-array for the tangent/bitangent data was totally wrong, its amazing it 'worked'. I have since fixed up the code a little and pushed a new version to github. Thanks to chat again for being awesome and appologies I didnt read you messages as often as I should have. 
Thankyou, that's truly great to hear.
Thankyou, that's truly great to hear.
I agree! Thank you for everything.
The newest demo features McCLIM, Quicklisp, FAT32, a generational GC, and a new compiler backend.
Congratulations to the Racket contributors! Perhaps someone from the community can comment on how important it is to have Racket-on-Chez and what will be the things to look forward for in the future?:) 
I'm not a racket dev, but I believe one of the big reasons was because they thought Chez scheme was just better than C for development. Eg more maintainable and easier to use. And it makes sense that racket devs would like to develop in scheme rather than C.
Wonderful!! I have played with two previous demos, and I can’t wait to try demo 4 when I get home from my travels. I had a hardware Lisp machine, a Xerox 1108, in the 1980s and it would be awesome to get something fun and hackable on an old laptop.
I don't know but an email to lispworks will make this clear very quickly.
&gt; optimization: adding 1 to or subtracting 1 from a fixnum variable does not cons. What does it mean? I never saw an instance that fixnum is consing. Is it more like register assignment related issue?
let us know what you find out :)
Has the project moved away from SBCL? Unless I’ve got wrong end of the stick...
Adding one to most-positive-fixnum is one instance. Can you see the other case now?
It's 1500$ for 64bit and 1000$ for 32bit. The normal "hobbyist" version is 750$ and 500$ (lol).
A [blog post](http://blog.racket-lang.org/2018/01/racket-on-chez-status.html) from January says just that – Racket-on-Chez is easier to maintain.
Moved away from SBCL? What do you mean? AFAIK Mezzano never depended on SBCL for runtime, and it is only used for building.
What Xach said, but not consing isn't the main benefit (after all, how often do you add to m-p-f?), but that it never conses, so the code is more compact and slightly faster whether it actually conses or not.
This "ask random people on the internet instead of the people who know the answer" is rapidly becoming one of my Reddit pet peeves.
The prices are available at lispworks.com. SBCL is more in my price range. Especially since I can keep downloading new versions. The only real problems with SBCL seem to be that it doesn't have a tree shaker, and that it doesn't have CAPI. But I wonder if SBCL is likely to have a tree shaker in the future, and how much work it would be to make one. Or, with memory on a long term trend towards much higher density and much lower prices per byte, tree shakers could gradually become less important. If CAPI can be replaced by Qt or Gtk+, then it might be worthwhile to use one of those, regardless whether you use Lispworks, to be able to use the same GUI everywhere. One advantage of SBCL, if you get a lot of experience using it as a hobbyist, is that you can use it on jobs without getting management approval for spending money on it. 
If that's your pet Reddit peeve, you must not have been using Reddit very long.
The optimization is that (1+ most-positive-fixnum) and (1- most-negative-fixnum), which are bignums, are preallocated and reused. There's no need to cons a new one each time. If a program was counting on "fresh" bignums not being EQ, it should not have been, as the spec allows arbitrary sharing (or not sharing) of these objects. More generally, it could be possible to reused other bignums if the same EQL value came up again from various operations, but I doubt that would be worth the effort.
*One of.* And it is developing recently. Maybe I am just becoming more of a cranky old guy.
I was assuming an unsafe code with a variable declared fixnum.
sb-alien is supposed to be more type-safe, potentially at some additional cost.
I thought cffi was a portability layer on top of the ffi's of the different lisps. Doesn't it use sb-alien? How can it avoid whatever additional cost it might have?
It doesn’t use full sb-alien. It basically uses sb-alien with void* and then does its own type conversions.
You pay for an upgrade of a HobbyistDV 50% of the new license. LispWorks has quite a bit more than a treeshaker&amp;CAPI compared to SBCL. It has also a much higher price, very little source code and is proprietary software. CAPI can not replaced by Gtk+. It runs on top of Gtk+ and provides a Lisp-like cross-platform API for user interfaces. One would replace it with another Lisp toolkit which runs atleast on top of Gtk+ - that way a Lisp system provides a Lisp-like interface to a piece of C/C++ software. One usually might not want to program using a raw low-level Gtk+ API.
If this would be real, it would be quite interesting. But it sounds more like a joke. I wish it was real, though. &gt; A surprising consequence of the model is that the human mind has a 44 1/2 bit address space.
SBCL will probably have the most numerical analysis libraries available to you. There is no one right answer
 I believe that was the reason for being successful. Paul Graham advertised reddit on the cover page of his website with a laconic "Reddit is written in lisp. Kabo isn't". PG had a huge fanbase of avantgarde nerds at the time, thus frontloading reddit with the most interesting people from slashdot who loved each other. Digg, at that time on its way to the biggest website on earth, could not compete in terms of sophistication in links and debate. I can't remember who or what "kabo" was. 
You could try to convince yourself that R is a form of Lisp (it used to be, initially, and still sort of is -- under the hood) and just deal with it.
On the topic of Lisp jokes, I am reminded of the [chetef device](https://groups.google.com/forum/#!msg/comp.lang.lisp/k5kouNGPe-0/4IiBF4s7wZQJ).
6pm UTC happens when this comment is 11 hours and 36 minutes old. You can find the live countdown here: https://countle.com/f230601mTJ --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Well, you could use an expression parser. There's probably reasonable ones lying around or you could read a compiler book and learn how to do it yourself. But I'd try to just wing it with a regular expression, as in practice just a few variations are probably all you really want. I would also use Common Lisp's own psuedo-random number facility rather than random.org.
start simple with the dice notation and add more features An example progression: - v1: parse AdX notation (1d4) - v2: parse dX notation (d4) - v3: parse AdX+B notation (2d8+3) - ... - vn: parse fudge dice or % dice or multipliers, etc. just be sure to _take it one thing at a time_. You could easily use regular expressions [http://edicl.github.io/cl-ppcre/](cl-ppcre) is a solid choice. If that's too complicated, you could make something work using [split-sequence](https://www.cliki.net/SPLIT-SEQUENCE). Using a delimiter of the character "d" and "+". Both are available via [quicklisp](https://www.quicklisp.org/beta/). Using random.org is a neat idea. good luck!
Fifty !
Right?! it's crazy.
Literate programming taken to the extreme. *ALL* source code for that project is stored in a single org-mode file, and extracted from it for compilation.
This seems to have freaked out a couple of people over at hackernews, where I found it. I rather like it myself as I find it much easier to get a grasp of what's going on with literate programming, mostly because I find that I actually keep reading deeper into the document.
Thanks to lispm for posting this /r/Common_Lisp... I was planning on posting this as well. you beat me to the punch :-) Also, just for folks to know, I am the organizer of AFP and these study groups. If you have a particular suggestion for a topic that you'd like us to discuss, comment on the Youtube or free to comment here!
I wanted something like this a few years back to program a robot in clojure. I ended up using firmata which wrapped the entire Arduino API in a serial protocol. This is even better.
Awesome. BTW, the playlist is missing 34, and 31 and 32 need to be swapped thanks...been waiting for 34 to watch more!
Learning to write a parser is very useful. If you aren't going to support parenthesized expressions or multipliers, then it's pretty easy just to read one character at a time: e.g. pseudocode for parsing \[A\]dX where A is optional: (defun read-prefix (input-stream) (if (not (digit-char-p (peek-char input-stream))) 1 ;; No leading number (e.g. d4 means roll 1 die (parse-integer (read-all-digits))) (defun parse-dice-notation (input-stream) (let ((prefix (read-prefix input-stream))) (assert (char= (read-char input-stream) #\d)) (let ((suffix (read-suffix input-stream))) (values prefix suffix)))) read-all-digits is left as an exercise to the reader, and reads a string from the stream until a non-digit character is found. This example lacks error handling and probably has unmatched parens, since I just typed it. If you want to do fancy things like `3*(1d4+2)` then you'll need to learn some way of doing more complex parsing, which is good to learn eventually, but is likely not necessary for a typical die roller. FWIW, Ironclad's strong-random is going to be just as high quality as random.org for dice rolls. The builtin CL:RANDOM function is honestly good enough, so long as you reseed it on startup (by default it will produce the same numbers from startup in order to make debugging and testing easier).
ok: I'm super curious about [Cells](http://quickdocs.org/cells/), an episode on it would be nice. Also, a shorter one ;) thanks anyway, those episodes are very welcome.
&gt; You could easily use regular expressions: cl-ppcre is a solid choice. Dice notation is consistent and a perfect use of Perl regexes. Assuming that library is compatible enough, here's the regex I used in a quick dice roller Perl script I made years ago that still does the job: `/^(?:(\d*)\#)?(\d*)d(\d+)([*+-]?)(\d*)$/i` The captures, in order: number of separate rolls, number of die per roll, number of sides per die, modifier (add, subtract, multiply), and modifier value. Everything but the `d` and number of sides is optional, so you can test each and fill in missing values appropriately, e.g. "d20" lacks number of rolls and number of die per roll, so assume 1 for each. Never used anything that needed the exploding dice notation, though, so it doesn't capture that, though it could be added in easily enough. 
So, this is java or jvm based clojure-like language to c++ translator. 
Link is down for me right now. Did we crash their website? ;-)
[https://wayback.archive.org/web/20180611080125/https://www.informatik.uni-kiel.de/~wg/clicc.html](https://wayback.archive.org/web/20180611080125/https://www.informatik.uni-kiel.de/~wg/clicc.html)
http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/clicc/0.html
I can access [https://www.informatik.uni-kiel.de/\~wg/clicc.html](https://www.informatik.uni-kiel.de/~wg/clicc.html) without problems at 20180801-0830-GMT.
Thanks, that _is_ funny.
How does it compare to Carp?
Could someone explain me (noob in informatics) if this allow to run lisp written programs with C speed?
Not really. It's still Lisp, just with a different target.
Any advantages compared to ECL?
Sure. CLICC is a whole-program compiler. It takes Common Lisp (a subset) and compiles it to whole C programs. The main advantage: ** compiled CLICC applications are tiny and start at a few 10kb disk space.** As such, there are almost zero development features. It creates tiny static C programs. It's purpose is delivery of applications with low footprint.
Back when it was out of print I paid over £100 for a slightly dog eared copy from Australia. And I consider it worth every penny. A thoroughly enthralling read. Even though I don't write macros very often I found it really useful in understanding the macros I did use and how they worked, particularly the "with-*" style macros which always felt a bit magical.
Common Lisp is actually pretty great for numerical computing and interactive stuff, but the ecosystem doesn’t have as much vibrance and activity as one might like. SBCL is likely your best bet if you want traditional Lisp syntax. However I’d argue that Julia is better for interactive data exploration and its community is bigger and more geared towards that topic (its a language very focused on scientific computing, especially numeric). Julia doesn’t look like a Lisp at first glance but it’s actually very much along the lines of Dylan but with a numeric bent. All code is parsed into `Expr` objects which are structured in a way similar to S-expressions. Code as data can be operated on like any other data type at run time with regular functions or at compile time with macros. Plus, it’s screaming fast. The macros aren’t the only thing that make Julia lispy but they’re the most obvious. (By the way, there’s even a Julia package that lets you write Julia code with Lisp syntax, LispSyntax.jl and LispRepl.jl) Whether or not one wants to call it a Lisp isn’t particularly important. It at least learned the right lessons from Lisp, lessons that it seems almost no other modern languages want to learn. If you’re interested, the subreddit for Julia is a bit of a ghost-town but the Julia-Lang Discourse page is very active and the Slack channel even moreso. 
I don't like people parroting something they've seen online without understanding the ramifications. (safety 0) is not necessary for the vast majority of cases, one can get enormous speedups without compromising on safety, just by declaring types and being smart about consing and use of data structures.
&gt;I don't like people **parroting** something they've seen online without understanding the ramifications. Style-warning: Unnecessarily rude at line 1 &gt;(safety 0) is not necessary for the vast majority of cases, one can get enormous speedups without compromising on safety, just by declaring types and being smart about consing and use of data structures. Going to safety 0 should be left as a last resort when one really really needs it (and again, it's better enabled for specific functions and not globally). I'm not "parroting what i've seen online", this is usually the directives I put inside `optimize` sometimes; Now, if what you say is true, thank you very much for the tip. However, even if I have no clue on how internally SBCL is interpreting each of speed/safety directives, I could bet that setting speed to 3 should implicitly disable many checks as well. 
I found this project while looking after creating a WebAssembly program using Ferret and then giving up trying to do the same with ECL. So far porting it to Common Lisp has been going OK, but I'm surely a naive n00b. I don't think it'll be ASDF/Quicklisp-able anytime soon.
Thanks Metroholographix, i'll take a look at that section. 
Mega cool
A similar non-maintained Lisp implementation for 'real-time control applications' is ThinLisp: https://github.com/nzioki/Thinlisp-1.1 https://www.cliki.net/ThinLisp 
&gt; they didn't know what they were doing I browsed the source code for ca. 10 minutes. Looks like a-okay lisp code to me. Intent clearly visible, idiomatic lisp, nothing to be ashamed of. (Except for using * to brace constants instead of +; sometimes literals are hardcoded, perhaps a sign of being in a hurry.) I'm not a lisp expert, though. Any specifics on what's wrong with it? Don't work too hard, perhaps one pointer with a brief annotation I can google. 
AFAIK it uses JSCL internally.
Thanks mate, seems it was online but not in the playlist. Fixed now.
A bit painful, but it's possible to get at the archive index using the Wayback Machine: https://web.archive.org/web/20060715070312/http://news.gmane.org:80/gmane.lisp.lispworks.general/ (but individual articles aren't cached, so have to open them separately)
Nice guide, thanks. maybe also: https://github.com/40ants/defmain a short helper. Until the "sequential" section at least I see no difference in process and feature list with the simpler [unix-opts](https://github.com/libre-man/unix-opts/) ([cookbook](https://lispcookbook.github.io/cl-cookbook/scripting.html#parsing-command-line-arguments)).
Thanks! I came here to ask about why certain things didn't work, and now I know where to contribute patches to.
The Go documentation has this feature since ever and it is pure awesome.
What a great document! Now I have to try the library!
interesting that it starts out with instructions on how to install sbcl, but then assumes that after installing sbcl you also installed quicklisp
Not on client side yet, though, right?. Although GopherJS could presumably allow for that, too.
Just fixed it, thanks!
I'm wondering if it were possible to adapt ECL of MKCL for delivery with a whole-program compilation step. Perhaps one could get the advantage of the full language available (modulo in-process compiler of course, but maybe even that could be made to work with some assumptions?) while still achieving most of what CLICC is able to do.
"Spreadsheet-like expressiveness for CLOS, the Common Lisp Object System." Because we all would rather be "programming" in excel.
Sort of, it's called Forth :)
Lisp isn't based on lists. So, any will do, e.g. Common Lisp.
Yes, but when you’re coding Common Lisp all the s-expressions are linked lists and not array.s
Well, don't use s-expressions if they are not compatible with your goals.
You might want to look at APL, which is fundamentally array-based. It's not really like Lisp though: no macros, functions are not first-class in most dialects, etc....but it's certainly an "canonical" arrya-based language and useful to learn about if only because, like Lisp, it forces you to look at problems in ways different from other languages. (APL has many descendant languages as well, perhaps most notably J.)
You might want to look at Clojure.
The question is not “can I avoid s-exps”, but how would the language look different if it used arrays.
That question doesn't make sense. Common Lisp uses arrays, strings, hash-tables, lists and more.
I think everyone who answered until now are misunderstanding the question. The point is Lisp has *the code* represented as linked lists and the OP wants to know which perks, problems and differences would emerge in a homoiconic language (in the Lisp sense) whose code where represented as arrays. I'm not able to give an adequate answer, though. 
I guess python or fortran with it's array slicing could be thought of like a lisp for arrays.
Python isn't homoiconic like Lisp. 
If you want to represent the code itself as arrays (which still doesn't make sense based on the premise that it'd be easier to port or more efficient), here's some code that is stored in arrays: #(defun foo #(a b c) #(+ a b c)) boom, looks exactly like a "list-based" lisp. Change the syntax of ( to produce arrays and not lists, and it's back to square one.
Homoiconicity means something in Lisp because it's built on the axiom of cons, car and, cdr. These axioms come directly from logic and the lambda calculus. Homoiconicity doesn't really mean anything an array based language which is based on ram cells. I suppose macros and meta-programming might be an analog to homoiconicity. Perhaps from that perspective a proper array based language would be an Excel spreadsheet.
I think OP is asking how Lisp-like syntax could be implemented using arrays. 
/u/edulo is 100% right. I mentioned the JavaScript thing as a side note.
You're looking for http://www.rebol.com
The idea that Lisp is homoiconic because it uses lists is slightly wrong. While cons can be thought of as linked lists, they are actually a binary tree. Consider for example: (+ 1 2 3) While this is a "list", this is also a binary tree: . / \ + . / \ 1 . / \ 2 3 This is significant because non-Lisp languages have syntax that also parses into a binary tree. Consider the common expression 1 + 2 + 3. This would parse into something like: + / \ + 3 / \ 1 2 So one way to look at the difference between Lisp and non-Lisp is that non-Lisp languages need to be parsed into a parse tree, whereas Lisp code already exists as a parse tree. Other languages like Python can in fact manipulate the parse tree, allowing metaprogramming similar to Lisp, but the fact that you have to go through the language parser first makes it a huge hassle. It also means you can't trivially customize the syntax -&gt; parse tree transformation, you can only modify the parse tree afterward.
W00t? Lambda calculus has no `cons`, `car` or `cdr`. It has no concept of source code; there is no `quote` in Lambda Calculus. Pure Lambda Calculus has no terms other than functions; even numbers are built out of functions. There is no list processing whatsoever.
I think the difference would be much smaller than you'd expect. It would be handy to have array slices, so you could express algorithms that recurse down the cdrs. Code manipulation would end up doing more copying than in Lisp, because you couldn't just cons a new head onto an array (slice), you'd need to copy the rest of the array. This is fine, since the meaning of the code doesn't depend on the identity of the s-exprs, only their syntax. I'm not sure what you mean by "port". If you mean implement a Lisp, you'd want to have lists in the language, so you'd need to implement `cons`, `car` and `cdr`, anyway, and then you could use them for code. (If your language doesn't have lists built-in, it's not a Lisp in any useful sense, just a language partly inspired by Lisp - but that describes most modern languages.)
I think it would useful for you to review the basics. I'll link to lecture 2B of SICP where Abelson talks about how lists are built from the axiom of pairs. It's around the 1 hour mark. [https://youtu.be/ymsbTVLbyN4?t=3765](https://youtu.be/ymsbTVLbyN4?t=3765)
The easiest answer would be to say that machine code uses arrays for both code and data. Add a "human friendly" readability layer complete with macros aka assembly language and we're done ;-) On a more serious note there is for example Lua which heavily favors tables, a combination of arrays and hash maps, for its data. I sometimes ask myself how Lua would look like if it had a way to represent code as tables with a "natural" method to manipulate said code in semantically meaningful way. My ideas so far are too vague to explain here. I guess there's a reason why most systems use tree like structures, which of course are just lists in Lisp, as their intermediate code representation. ASTs seem easier to refactor than ASAs.
Although functions can used in Lambda Calculus to build objects which obey the cons/car/cdr axioms, that still doesn't cause Lambda Calculus to have source code which is made out of them. 
Me thinks you confused '[w00t](https://en.wikipedia.org/wiki/W00t)' for 'wut'
I don't think it matters for portability, a linked list is easy to implement in any language. Remember that the list representation is temporary. Lisps that care about being decently fast usually compile to bytecode anyways, at which point the list based code structure is lost. I think the main reason for parsing the source into a list instead of an array or struct is that it's easier for macros to work with. Macros commonly add, remove, or insert items from the source tree and doing so with an array can be awkward and could require reallocating the entire array. 
&gt; I don't think being homoiconic when dealing with arrays means the same thing as it does with lists. It does. Almost every APL stores its code as an array; k even operates on the array of characters directly. k can also manipulate its own code (like lisp!) &gt; Lisp is to list processing as Python is to array processing. Python doesn't *store its code* as an array and cannot manipulate its own code. These are a critical component [of how Lisp approaches lists](http://smuglispweeny.blogspot.com/2008/02/ooh-ooh-my-turn-why-lisp.html).
Yes! It's called "k" and it's not *obviously* a lisp since it uses M-expressions instead of S-expressions normally, but: * It's homoiconic * Functions are first-class * Code is stored as an array (of characters!) * [k can manipulate its own code](http://smuglispweeny.blogspot.com/2008/02/ooh-ooh-my-turn-why-lisp.html), which is an essential part of being "a lisp"
It's still quite a stretch to say that the "axioms" of cons, car and, cdr come directly from logic and the lambda calculus. The let's say "operations" or "structures" can of course be **implemented** in logic but then again, so can nearly everything else. That's like saying Python gets it's arithmetic primitives from logic (or lamba calculus, shudder).
&gt; Code is stored as an array (of characters!) But is it a tree structure or just an array of characters? Evalling a string is possible in most scripting languages, and since strings aren't ASTs these languages aren't really homoiconic...
Yes. Linear access versus random access.
A language is homoiconic if a program written in it can be manipulated as data using the language, saying nothing about ASTs. k does have an abstract syntax, but it doesn't use it. Without knowing k, this isn't obvious, so let's look at a function in k: */1+!x We can give each character a name: * `*` times * `/` over * `1` one (the number) * `+` plus * `!` til * `x` x (the variable) That's it. You don't need any special parser, just look one character ahead. *til* simply makes the vector 0..x (the argument), and *plus* is generalised where one argument is a scalar value (one) and the other is the vector. k4 does have a parse operator for looking at what's going on: ((/;*);(+;1;(!:;`x))) which can be written as an S-expression: ((/ *) (+ 1 (!: 'x))) k4's eval operator can evaluate this if you want. In this way, you're evaluating a tree structure- just like lisp -- but this isn't what k does, *it really does evaluate the string*, which is easier to convince yourself of if you profile the two (eval using pre-parsed tree, versus directly). This gives us the best of both worlds, and indeed I use this trick pretty frequently. I have an ad server that generates reporting with a bunch of different breakdowns (by domain, by publisher, etc). So I want to do: get_with_breakdown:{eval @[parse x;3;:;parse[y]3]}; get_with_breakdown["select impressions:count i by breakdown from raw where event=`impression"; "select x by domain from t"]; This is great, because it lets our less-confident q programmer write queries (the strings actually come from a separate files: one called "breakdowns" the other called "metrics") without having to get into the query builder itself.
In Julia AST is made up of nested arrays. So, it might fit your description. However... there are some problems with describing what arrays actually are, especially in the same terms lisp was defined. I.e. if your only way to construct pieces of programs is by combining pairs (or any finite number of elements), then you don't have arrays. They become inexpressible in your language, and that is why there are problems with defining types for arrays. The problem is essentially as follows: if your construction method allows only combining N members, then only arrays of length N can have the random access implemented in constant time (which is essentially what makes them different from lists). Once you need an array of N+1 or more elements, you must introduce indirection, similar to how it happens with lists, essentially, creating something like a B-tree.
cons, car and, cdr can be built directly from the lambda calculus. That's important because it blurs the lines of what are functions and what are data even if it's just a conceptual one. Arrays are just data. They don't have that property. If you guys don't like the term axioms I don't know what to say. That's what Gerry and Hal called it back then and, that's what I call it now.
&gt; I was wondering if a “lisp” based on arrays existed? Did you really mean arrays, or did you mean vectors? If you really meant arrays (i.e. with &gt;= 2 dimensions) then the answer is no. If you meant vectors, then the answer is "sort of". Yes, there are Lisps that represent code as vectors rather than linked lists. No, none of them have ever seen widespread use. The best way to understand why is to write your own EVAL function that operates on code represented as vectors (of arbitrary size) rather than cons cells (which are just vectors of size 2). It's not hard to do, and you will learn a LOT about why Lisp is designed the way it is, and why that design has survived for so long. Your understanding will be much deeper if you do it yourself than if someone just explains it to you. 
That's called cdr-coding. Instead of two cell cons-cells, a cdr-coded list uses single cells and the type tag tells that a next cell follows. Useful when the cdr is not destructively modified. These lists might for example be created when the operating system optimizes the memory layout before one wants to save an image - optimizing the memory (called a 'world') takes some time. Later it was checked whether there are advantages to cdr-coded lists to use this in non-Lisp-Machine implementations. There was not found enough benefit and it then wasn't used in Lisp implementations on normal hardware (x86, 68k, SPARC, and so on).
&gt; *built from purely functional axioms* Historic revisionism; Lisp had `rplaca` and `rplacd`, long before Sussman and Scheme. &gt; *Arrays are not built from any computational primitives so,* Arrays can be built from computational primtives. We can have a catenationo function that makes one array out of two, then destructuring functions that access and break apart arrays. Arrays can be nested: `#(defun foo #(arg ...) body ...)`. &gt; * it doesn't really make sense to make a homoiconic language from arrays.* The term [homoiconic](https://en.wikipedia.org/Homoiconicity) was defined using arrays (specifically, character strings). The word is a very poor fit for the code-and-data thing that happens in Lisp. That latter one is readily realizable using arrays. Arrays just have a different performance profile. When we do recursion on lists, for instance, just to traverse them, no memory need be allocated. 
http://flownet.com/ron/l.py
Um... Arrays are at least as efficient for linear access as lists, and if incrementing a pointer is cheaper than following a pointer, they are more efficient. I don't think that condition has ever been false on machines capable of running Lisp; and now that we have memory and CPU separated by several layers of cache, it's never been more true - in fact, these days it's more the case that lists are inefficient for linear access, and hopelessly so for random access.
&gt; Later it was checked whether there are advantages (in terms of space and speed) to cdr-coded lists to use this in non-Lisp-Machine implementations. There was not found enough benefit I wonder if that remains true given modern memory hierarchies - wouldn't the tendency of cdr-coding to align lists on the same cache line pay off massively?
&gt; it's more the case that lists are inefficient for linear access that really depends on how the memory is managed. A naive Lisp implementation may randomize memory over time - but that's not the state of the art since a few decades. If we have a copying generational GC, lists will be allocated in smaller memory areas and later maybe promoted to older generations. A GC then will copy the list - which is an easy opportunity to improve locality. &gt; now that we have memory and CPU separated by several layers of cache The first large Lisp systems had at least four layers of memory: registers/stacks, caches, RAM and virtual memory. The first Lisp Machines had about 1 MB of RAM and probably ten to fifty times the virtual memory (VM). When we nowadays run a GC over a 100MB memory - then it is often all in RAM. My first Lisp Machine (a Symbolics 3640) later had 4 megawords (16 MB) RAM and at least 150MB virtual memory. The base Lisp image I was using was already 3 times larger than RAM. Virtual memory was REALLY slow on really slow disks. A full GC over memory would take 20 minutes or more. You can bet that at those times implementors were doing a lot to reduce consing, improve locality, reduce VM traffic, ... If we want to invest effort into current implementations, it would be useful to show that the improvements actually matter in real Lisp programs.
&gt; that really depends on how the memory is managed But even in the best case, you can only fit half as many CONS cells into the same cache line as you can array elements. &gt; The first large Lisp systems had at least four layers of memory: registers/stacks, caches, RAM and virtual memory. My apologies; I have always been too young and too impoverished to encounter such systems.
Help me out here. Are you * challenging my assertion that arrays are always at least as efficient as lists? * agreeing, and providing additional detail? * agreeing, but suggesting some of my arguments could be more accurate? * mansplaining memory hierarchy? * putting your two penn'orth in just because you can?
Which is all fascinating, but I'm not sure how it relates to the (relatively minor) question of whether arrays are less efficient than lists in the linear case. Perhaps you could point out what I'm missing?
Yeeeeeeeess!
Lots of idiomatic Lisp code defined by recursion into the list/cons structure would have abysmal performance if you'd just swap the lists for vectors. I think you'd end up with either a reskinned APL (i.e. something quite unlike Lisp) or a tree-based functional/persistent sequence data structure instead of plain vectors. 
Wow, that is cool! I am a very long time Lisp programmer but haven’t yet spent much time with picolisp. Just put working through these examples on my todo list :-)
&gt; I agree that linearly traversing an array can be the same speed as using a list, but not faster unless the implementation is borked. **ONLY IF MEMORY ACCESSES ARE FREE**. I don't even know why this is a controversial point; to step through an array, you need to increment a pointer, and to step through a list, you need to increment a pointer *and then fetch through it*. I'm *literally pointing out the obvious* here. Only if the fetching through it took *exactly zero additional time* could linear traversal of an array *not* be *always* faster than linear traversal of a list. Please excuse my exasperation. I've just never had to seriously argue that the laws of physics were not optional before.
&gt; My point was that microbenchmarks of linear access into a single array vs. a single list is probably not very important when we look at the performance of actual running Lisp programs, which might deal with a lot tree-like data. That's a good point, but probably obiter dictum when the relative results of those microbenchmarks are (unexpectedly!) in question. &gt; One can construct cases where it matters, but if we take a real program - like a prover for some CPU features (see ACL2) or a planner/scheduler for something like train crews (see Siscog) will they run faster with clever list compaction (cdr coding) or more use of vectors? Well, nobody's ever going to know if, rather than trying, we keep accepting the answers that people advanced 25 years ago! As you've pointed out yourself, the prevailing environments in both Lisp machines and RISC machines looked somewhat different from those of modern machines, even in something as low level as what could be expected as a standard word length; surely it's time to reassess some of those trade-offs?
PicoLisp is a really strange Lisp dialect. I'm a Schemer myself but I've grown quite fond PicoLisp.I was originally drawn to its coroutines. It's got its own sexpy Prolog dialect, a sexpy DOM scheme and a complete relational database system. Sort of a minimalist kitchensink, if you will. A rare piece of software satisfying both Zawinski's law and Greenspun's tenth rule.
Sure, definitely worth investigating. Until then it is speculation.
http://www.maclisp.info/pitmanual/hunks.html
interesting, so it is explicitly created rather than implicitly.
&gt; to step through an array, you need to increment a pointer ONLY IF YOU'RE WILLING TO TAKE THE RISK OF OVERFLOWING THE END OF THE ARRAY! I don't even know why that isn't an obvious point. 
Did you forget about bounds checking every single one of those pointer increments? That's expensive when compared to the equivalent "not nil" check when traversing a list.
Please, tell me in detail how much more expensive cmp rINDEX, rBOUND is than test rCDR, rCDR when everything I know about processors tells me they're the same cost. And if you're generating code at runtime, you can even make it free by manipulating the index and the array base, so that the "index" hits 0 when you cross a bound. And of course only one bounds-check will suffice for as many indexes as you're checking in parallel. So no, I didn't forget. I am, however, sick of every tom, dick and harry mansplaining computer architecture to me.
Please, tell me in detail how much more expensive cmp rINDEX, rBOUND is than test rCDR, #ADDR-OF-NIL when everything I know about processors tells me they're the same cost? And if you're generating code at runtime, you can even make it free by manipulating the index and the array base, so that the "index" hits 0 when you cross a bound. And of course only one bounds-check will suffice for as many indexes as you're checking in parallel or in a loop - because if the last element you're referencing is in bounds, *all the others are*. Also - test rCDR, rCDR won't cut it. NIL hasn't been 0 for a *very* long time in the Common Lisp world. So no, I didn't forget. I am, however, sick of every tom, dick and harry mansplaining computer architecture to me. Badly. (A good rule of thumb: A question that starts "Did you forget about" will contain at least one more inaccurate assumption than the poster of that question believes their target to have made. It's the same rule as for typo corrections, but extrapolated.)
Please, tell me in detail how much more expensive cmp rINDEX, rBOUND is than cmp rCDR, #ADDR-OF-NIL when everything I know about processors tells me they're the same cost? And if you're generating code at runtime, you can even make it free by manipulating the index and the array base, so that the "index" hits 0 when you cross a bound. And of course only one bounds-check will suffice for as many indexes as you're checking in parallel or in a loop - because if the last element you're referencing is in bounds, *all the others are*. Also - `test rCDR, rCDR` won't cut it. NIL hasn't been 0 for a *very* long time in the Common Lisp world. So no, I didn't forget. I am, however, sick of every tom, dick and harry mansplaining computer architecture to me. *Wrongly*. (A good rule of thumb: A question that starts "Did you forget about" will almost certainly contain one more inaccurate assumption than the poster of that question believes their subject to have made. Like typo corrections.)
Pointers can be nil. Fool. Oh, damn. I really should tape Mark Twain's aphorism across the top of my computer. Bye.
There is a highly popular HPC project called "slurm".
There's a reason people don't build hardware like this: it's slow and specialized for the wrong things. It forces many operations to be mandatory which can usually be eliminated at compile-time. It's sort of a contradiction in a funny way: the very sorts of sophisticated analysis that allow this Scheme Machine design to be done also greatly reduces the necessity for such a design.
I mean, at this point, 20+ years after the rise and fall of the Lisp machines, it's 95% probable that running an OS that's Lisp from the kernel up on commodity hardware would have negligable slowdown vs C or other low-level languages at this point. I bet even fairly old (2003+) hardware would be fine.
Haskell is the new Lisp.
How about drawing massive amounts of lines in 3D – with instancing?
I was wondering if lispworks with their lisp or embaracadero with delphi were gonna be the last to hold out for insane prices for their IDEs. Looks like lispworks won.
Only in very, very, very narrow sense
In the sense that only people who have no idea about how either works would say.
I think I have a pretty good idea how they both work. Haskell is currently filling the niche that Lisp filled in the early 1980s.
The social placement of a language has nothing to do with it's technical placement. Lisp and Haskell are completely different and have very different strengths and weaknesses. By your logic Java is the new Cobol. 
Well yes, absolutely, [Java is in fact the new Cobol]( https://www.infoworld.com/article/2650254/application-development/java-is-becoming-the-new-cobol.html ). Absolutely, [Java is the new Cobol]( http://wiki.c2.com/?JavaIsTheNewCobol ). Certainly Haskell and Lisp have many profound technical differences. But both were best-effort attempts to make a practical reification of a lambda calculus (untyped in the case of Lisp, typed in the case of Haskell). They are surprisingly similar under the hood. They are the "lingua franca" of PLT. They are used by high-tech enterprises as a screen for hiring. They are used as a secret weapon for technical purposes. They are taught to similar cohorts of students. I could go on.
Your only point that is technical is &gt; But both were best-effort attempts to make a practical reification of a lambda calculus Which is wrong. Lisp has no pretensions on the lambda calculus, the language is built around s expressions and trees (that's why all the parens are there for). That you can translate (with difficulty) between the two ways of thinking doesn't make them any closer, or more similar, than register machines and the lambda calculus. After all you can translate C to Haskell too. As for the rest, again, social use and technical use have nothing in common. That java is stuck as an enterprise language is an accident of history. I'd suggest you write code in both rather than listen to people who write code in one and have minimal experience in the other.
How does this work? Is there any documentation for this that I'm missing?
(I wish I wasn't anonymous here, because I've certainly designed and implemented my share of lisps.) But just being technical, s-expressions are a particular representation of lambda-calculus terms, with a couple warts. Their typographic representation is not of particular interest, in fact MacCarthy (1960) is quite fluid about that issue, using commas to separate list elements in some places. The intent at the time was that the highly-parenthesized notation was an interrim measure, to be superceded by a more sophisticated parser in the next-generation system. MacCarthy (1960) also states "This distinction [between functions, i.e., lambda expressions, and terms, i.e., s-expressions] and a notation for describing it, from which we deviate trivially, is given by Church [3]." In other words, he views the differences between the system he describes and the lambda calculus as being a trivial matter of typographic conventions and computational expedience.
If you hadn't noticed we are still using s expressions in all lisps 60 years later. What the original intention hardly matters. Haskell and lisp are two very different ways of coding and have very little in common other than accidents of history that made them popular with a certain kind of programmer. 
Looks like the author is working on it https://functional.cafe/@m3tti/100515131525591241
Really cool logo, I must say. Looking forward for the documentation!
I've been building an educational web app with hunchentoot, cl-who and parenscript. It's been a pleasant experience, with the only irritation being the fact that it's impossible to compose cl-who macros the way I'd like. Vsevolod Dyomkin has a good writeup of the problem, and potential solutions, here: http://lisp-univ-etc.blogspot.com/2009/03/cl-who-macros.html.
Another forum page that describes TLisp: http://forums.kronosaur.com/viewtopic.php?f=8&amp;t=8113
Seems incomplete. Back to using Thinatra.
The most popular Lisp-like language that does this is Clojure. You're right that abandoning lists makes it it easy to graft to other languages (ClojureScript is a version of Clojure that is grafted to JavaScript instead of Java). The disadvantage of this is that programming in Clojure is a lot like programming in the language that it's grafted to, and you need knowledge of the host language and exactly how Clojure grafts to it to use Clojure effectively. 
There's a 2nd bit here: http://christophe.rhodes.io/notes/blog/posts/2018/beginning_an_sbcl_port/
Hi, these blog articles always look super interesting, but they're absolutely impossible to read on mobile, which is where I read Reddit from. Could you make the site slightly responsive?
Firefox on mobile provides a reader mode which makes this, and other pages, readable
Probably "lambda calculus" was just a popular reference everyone dealing with computers in the 60s tried to sneak into their paper. Really, the system described in MacCarthy's papers isn't lambda calculus, and doesn't even try to pretend to be that. The paper describes lisps to work very roughly like this: A function (in the original paper this is described as "conditional expression") is an ordered sequence of elements, where elements have heads and tails. Heads are functions and tails are functions (original paper didn't give this recursive definition, but this is how it turned out to be in reality, the paper, however, did give examples of recursively defined functions). Heads are boolean functions, if they evaluate to true, then tails have to be executed; if tail's evaluation is defined, then that's the value of the function, otherwise, next element is to be evaluated. So, surprisingly, Prolog is kind of very much like Lisp, at least, as it was originally envisioned by MacCarthy. But, Haskell isn't. Its core formalism that captures what it means to execute a program is, indeed, lambda calculus.
9:45PM UTC happens when this comment is 8 minutes old. You can find the live countdown here: https://countle.com/239149yrVK --- I'm a bot, if you want to send feedback, please comment below or send a PM.
use usocket till you find a reason to use anything else. As a C++ programmer, I find the CL wrappers around sockets to be refreshing. As usocket is a wrapper around the implementation specific socket bindings, the source code might not be too useful, but the api is simple and well documented.
I definitely second the usocket suggestion.
I would also recommend usocket. There is a simple guide on them: [https://gist.github.com/shortsightedsid/71cf34282dfae0dd2528](https://gist.github.com/shortsightedsid/71cf34282dfae0dd2528)
I second this. Most, if not all that you need with socket programming can be found with usocket.
I haven't heard of this. Anyone have much experience using it? Why would I use it over portacle?
What are the differences between Lem and Portacle?
6pm UTC happens when this comment is 19 hours and 40 minutes old. You can find the live countdown here: https://countle.com/ARVw239701 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Portacle is pure Emacs (shipping SBCL, Quicklisp, Git, etc), Lem is an editor implemented in Common Lisp, with Emacs-like keybindings, specially targetting CL development, but not only (Go mode, CSS mode,…).
- https://www.reddit.com/r/Common_Lisp/comments/7gzet5/lem_the_editor_for_common_lispers/ - https://github.com/CodyReichert/awesome-cl#lem - https://lispcookbook.github.io/cl-cookbook/editor-support.html#lem ;) 
Last issues of his newsletter: https://purelyfunctional.tv/issues/
I've been using it as my main Common Lisp editor/environment for a while. Very hackable, blazing fast startup so awesome to have a scratch budget that's common lisp.
I like the article, minus the affirmation that Clojure is the most promising incarnation of Lisp, I am not a fan of Clojure but I don't say that because of that, I say it because it skews the non Lisper readers to a dialect based purely on opinion, unless the author clarifies what he means by "promising", and shows that Clojure is in fact more deserving of that title he could have omitted that sentence or precede it with "in my opinion"
Slime is a overall better experience, also I always though geiser was buggy with Racket, I never could make it work as I wanted. For reason crashes when trying to use nanopass with it.
Lispbox is no longer maintained or recommended. Use [Portacle](https://shinmera.github.io/portacle/); it is the modern equivalent and much better than lispbox ever was.
It seems his problem is more with Emacs than with LispBox, since it still seems to run -- I assume this is Windows. The missing ingredient is probably just buffer switching with `C-x b`. Either way, Portacle also includes a [help file](https://github.com/portacle/config/blob/master/help.txt) that should (I hope) explain the basics of Emacs and help getting started using it.
\&gt; The missing ingredient is probably just buffer switching with C-x b . I did this and it says this: ";; This buffer is for notes you don't want to save, and for Lisp evaluation. ;; If you want to create a file, visit that file with C-x C-f, ;; then enter the text in that file's own buffer." I tried putting in (+ 1 3), hit return and it just goes to the next line.
Thanks, I'll try it!
if you are in a lisp file buffer, you can C-x C-e will evaluate an expression. The result will appear at the bottom below the mode line. If you want to compile an expression (like defun) in a lisp file , use C-c C-c. You also can also easily move back to the repl buffer using C-x b and typing buffer name or C-c s r gets you there immediately. The help file u/shinmera mentioned is a good start to learn the basic commands.
Thanks.
You would have to shared them and I might change my opinion :)
&gt; ... the argument that has been advanced for discarding Lisp in favor of C++ (and now for Java) is that JPL should use "industry best practice." The problem with this argument is twofold: first, we're confusing best practice with standard practice. The two are not the same. And second, we're assuming that best (or even standard) practice is an invariant with respect to the task, that the best way to write a word processor is also the best way to write a spacecacraft control system. It isn't. It sounds like lisp never really achieved a network effect. Maybe? Some of the imperative and object oriented ones did so maybe the "get rid of lisp" response was more a result of that fact rather than a result of lisp being a poor tool for the job.
Yes that is the gist of the article. Lisp is considered inadequate because of poor adoption, in a catch 22 type situation. Really unfortunate given how powerful and flexible a tool it can be. Oh well, I'm just glad there's still so many tools available to learn and use Lisp, even if it's not a highway to a job. There's more to life than complying with corporations for money.
I don't know the whole java world, but my brain classified the java ecosystem in the 'worst' box. There's near nothing that I miss about java the language, or the culture around it, the theoretical theories around it (component systems..) or the editors built on it (IntelliJ being the outlier). Industry is absolutely not guaranteed to be a value indicator. There's an old article floating around from a guy looking for a java graph processing library. He found a few, tried them, they were all crufty, heavy, and incomplete. He ended up writing his own from basic lists.. Industry considers team work to be the absolute perfection (a fuzzy correlation with social divide and conquer) but there's a perverse effect that the industry likes having an army of devs with subpar tools so they feel like they're doing expensive work. Even recently MIT caved to this trend by switching to python because it's the most used thing these days, and instead of bootstrapping solutions, they prefer to teach how to wire libs together.
too ranty ?
I've lost 15 years of life with C, C++ and Python. And continue to loose it because can't use Lisp in my daily job. Because is is not Common Lisp is not a common tool. Because there are people who are afraid they will not be able to hire specialists who will be talented enough to understand Lisp code. 
The last line rings very true for me: &gt; It is nonetheless supremely ironic that the demise of Lisp at JPL was ultimately due in no small measure to the unreliability of a C program. Lisp is a pretty decent language (it has a few warts, but what language doesn't?) but it does fall over quite hard when dealing with libraries (in my experience) and i think this is down to the inherent design philosophies of any piece of of software. i.e. OpenGL is designed by people who code in C. It is unavoidable. Even in languages like ruby and python you can see that a lot of hoop jumping has to be performed to even out the wrinkles here and there. But as those languages are also written in C it mostly works out and high level libraries take away a fair amount of the pain. But (common) lisp and its long lived REPL sessions can really tax the underlying library (or even driver) logic and put the hardware in some odd states. OpenGL was designed (I bet) with the idea of: program runs, if program f'ks up it will crash and the driver can just clean the whole damn state up in one go. In lisp, however, if something borks the developer is going to halt a thread and do some funky stuff to fix the one bit that died and then resume the thread. This never happens in C/C++ languages, right? So why bullet proof all your OpenGL code for a thing that will never happen. And so you (I) end up trying to code something and having to restart the whole lisp session because the driver got in a funny state. And OpenGL is not the worst offender in that regard. All libraries are written in this way. Anyhow. apologies for venting. /rant
Not stopping ranting about Java is good thing. 
BTW I hope that type of C code (the buggy one written by some grad student) is now written in Rust.
Would make sense if Lisp use was more widespread and this decision not typical, but...
I'll say this, Java, like anything turing complete is not that much of an issue, IF, you had proper exposition to more satisfying paradigms (forth, fp, logic, simplex/ai). You can then use it without drowning in a superstitious sea. But god forbid being fed the lie that Java is all.
I don't mind python much, it's a tiny language, unlike cpp. As always, are there organization efforts from CLers ? I know that there's the European Lisp Symposium still held every year. But what about the business side of things ?
I still think it is a misidentification of the problem. People use all sorts of software successfully without it being "widespread" or having a "community" or "support" or being high in popularity rankings. If you need widespread adoption and a huge "supportive" community to succeed in what you do, you probably are the kind of person who "needs" PHP. You can get high-quality Lisp implementations, and even for free (another weird obsession people have), and get support from commercial vendors and competent consultants and open-source contributors. What more do you need? What more does higher popularity give you? Coming at it from the other side, large organizations make all sorts of decisions that one could complain about. Lots of time, they make decisions that optimize for some other metric, and all you are really saying is that they chose the wrong metric. It could also be that insufferable jerks with bad interpersonal skills tend to not be successful in persuading other people or even identifying the people who need to be persuaded. Maybe JPL made a bad decision. Maybe it was a good one for JPL. Why is JPL's decision relevant to me? If only one guy in the organization pushes Lisp, and he can't recruit anyone else to support greater use of Lisp, then why should the organization decide to use Lisp just to make some random fanboys on the internet happy? &gt; At one point the software integration engineer was giving his presentation and listing all of the things that were going wrong. Someone (I don't know who) interrupted him and asked if he could change only one thing to make things better what would it be. His answer was: get rid of Lisp If one software integration engineer making an offhand comment at a review (assuming it wasn't a setup of some kind) can cause your entire project to be shitcanned, maybe you ought to make sure that software integration guy is *happy with you.* If his life is extraordinarily difficult and that threatens the project, maybe you shouldn't be the one making his life difficult? &gt; In an attempt to address one of the major objections to Lisp, that it was too big Oh, wait, there's another problem? &gt; [At Google...] The only thing left was to get approval from the VP of engineering. Again, the whole thing is shot down because someone whose approval you knew would be needed was not prepared to make the decision you wanted. It's even crazier: &gt; ... I got all my ducks in a row, &gt; Him: Let me guess - you want to use Smalltalk. &gt; Me: Er, no... &gt; Him: Lisp? Your VP was ready to reject you for a language that you aren't even using? If using one of the standard languages is super-important to your VP, maybe you should understand what your VP would need to hear in order to depart from that position, and do that homework. Sounds like you don't actually know how to get "all your ducks in a row." No, can't be. VPs at Google must be stupid, we have no idea why they think what they think, and they are unpersuadable, ready to shoot down my Lisp project because Smalltalk sucks. I should be able to just persuade a few colleagues with a demo and a VP should be blown away by how great my idea is. &gt; cementing my reputation as a crazy lunatic who thinks Lisp is the Answer to Everything. Huh, my reputation is as a nut, and no one listens to me. Must be everyone else's problem. Or Lisp's. &gt; at least two other major Lisp developments at JPL So it is possible? But we don't hear those people whining? Finally, in the postscript &gt; Many of the multi-language integration headaches were caused by the interprocess communication system that allowed Lisp and C to communicate. The IPC relied on a central server (written in C) which crashed regularly. Getting rid of Lisp did in fact alleviate those problems (because the unreliable IPC was no longer necessary). It is nonetheless supremely ironic that the demise of Lisp at JPL was ultimately due in no small measure to the unreliability of a C program. Oh, using Lisp meant using poorly supported IPC services....that in fact does make Lisp sound like a bad choice. I'm ready to side with the integration guy who got to throw the IPC server overboard because Lisp was the only client. Maybe you should have figured out improved IPC support would be needed before it blew your whole project out? No, better just make an excuse that the IPC server was written in C, and your loss is because C sucks. 
So now Lisp adoption is dependent on Rust adoption? This does not seem to be a step in the right direction.
I don't get it man. I mean I find hard to disagree with you on anything you wrote here, but I'm also struggling to see the point, or insight, or... ?
I guess my main point is that there is little to be gained by this kind of analysis. Lisp is what it is. There is no magic that will make it gain popularity in a useful way; go out and do good work, using Lisp where it helps. Do things to make Lisp better like /u/xach because it is good to do. Complaining that other people or companies don't get it is a waste of time and unhelpful. In the meantime, Lisp did get into Google because ITA made a great product without trying to fight some battle against non-Lisp lovers or whining all day about how bad Java is.
Hmm, I’ve had a really good experience integrating the objective-c runtime with lisp via CFFI. 
&gt;But what about the business side of things ? That's a great question. Some weeks ago, some forumer here told me a dismissive comment because I used CL on the Windows platform. I wrote on this forum that I work for a really big company where Windows is the norm, and the snarky comment was, literally, "where are the open-source Lisp contributions from your company, then?". If CL, which is historically the industry-backed Lisp, isn't purported again towards the industry (that is, as a competitive advantage), and left to the hobby or academic world, it might die, since this is overlooking one of its main strengths.
keep ranting about Java, i lost three years of my professional life with it.
&gt;BTW I hope that type of C code (the buggy one written by some grad student) is now written in Rust. Why? It isn't even standardized, there's only one serious compiler for it. For "safe" concurrent software there are already proven, well-established languages like Ada/Spark and Erlang. 
&gt;With that being said, Luminus (Clj) is pretty good. Thanks for this suggestion. I'm a hardcore Common Lisper, but i might have the need to use Clojure as well. I'm taking note. Also, if you can recommend a good database access framework that is not an ORM, but generates SQL from a functional DSL, it would be great.
There's no magic in Lisp, you're right. But there's wonder. Some of us are fascinated by the history of computing and it's multitude facets. You claim to disapprove of this kind of analysis, but produces copious amounts of it. In my opinion, dialogue is healthy, and I for one enjoyed reading the piece. How is this even whining? It's just an obscure post, no one is hyping their blog about it, and it's actually a first person account of a relevant historical event at a major institution. Quite interesting in my book... As for your last phrase, couldn't agree more. If we love a tool we should use it more, not merely talk it up.
I forgot but I think lisp is its own curse. I've read (and agree) that lisp is great when you want to find solutions to new difficult problems[1]. Meaning it will only be worth gold in that niche. For the rest of the world python / kotlin is largely good enough. Very few people have a nack for symbolic, semantic, metalevel thinking. It's probably even a brain trait to like things with stiff syntactic rules, when personally I was always running away from these. [1] unsurprisingly some quantum computing lab in the news recently uses CL. Also a biochemist made https://github.com/clasp-developers/clasp.
TBH to use C libraries from REPL via CFFI is actually a great way to explore and experiment around them, much better than to write small C programs. Yes you need to restart the image from time to time, but it is a small cost over the huge win of playing with APIs in REPL.
I also had a fantastic experience working with Obj-C APIs via both Clozure CL and especially LispWorks
Nice :) `subseq` fails if the end limit is superior to the sequence's length. I fix this with `(str:substr 0 3 '(:foo))` (function in the `str` library, which happens to work for sequences). To read lines from a file, I'd use `uiop:read-file-lines`. (and there is no error handling).
I've wrote some comments about the code in [lobsters](https://lobste.rs/s/jzmzgb/mastodon_bot_common_lisp) which I'm copying verbatim. ```lisp we want to filter an process instead of REMOVE-IF-NOT + LOOP we can use LOOP's WHEN clause instead. It is better to use the most specific construct when possible, MAPCAR instead of (MAP 'list ...). I would assume a vector if MAP was used instead of MAPCAR. You could use the structure constructor in PARSE-RSS-ITEM to make the code less 'side-effect'ful (still imperative though nothing wrong with that). PARSE-RSS-ITEM would look like (defun parse-rss-item (item) "Parse an RSS item into a lobsters-post" (let ((guid (get-first-text "guid" item)) (title (get-first-text "title" item)) (link (get-first-text "link" item))) (make-lobsters-post :guid guid :title title :url link))) Note that for the cases where we want to create a resource, modify it and then return it, the SERAPEUM library has RLET[0]. If we are going to depart from the archaic -p convention for predicates lets at least do so for a better one, which is to end the predicate's name with ? instead of is-foo. As a matter of style, please don't leave dangling parens :pray:. And use uppercase letters for the format directives. A couple of 'dependencies' where unused and can be safely removed. Note that TOOTER is already using YASON library so it would make sense to use that JSON library instead of CL-JSON? [0]: https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#lret-rest-bindings-body-body |# (defpackage "MASTODON-LOBSTERS" (:use "CL" "BABEL")) (in-package "MASTODON-LOBSTERS") (defparameter +feed-path+ "https://lobste.rs/rss") (setf drakma:*drakma-default-external-format* :utf8) (defparameter +mastodon-client+ (make-instance 'tooter:client :base "https://botsin.space" :name "lobsterbot" :key "secret" :secret "secret" :access-token "secret")) (defparameter +link-db-path+ #P"/Users/puercopop/links.txt") (defparameter +processed-links+ (with-open-file (stream +link-db-path+ :if-does-not-exist :create) (loop :for line := (read-line stream nil) :while line :collect line)) "A collection of the previously seen links.") (defun processed? (post) "Have we already processed the POST?" (find (post-guid post) +processed-links+ :key 'post-guid :test #'string=)) (defclass lobsters-post () ((guid :initarg :guid :reader post-guid) (title :initarg :title :reader post-title) (url :initarg :url :reader post-url))) (defmethod print-object ((post lobsters-post) stream) (print-unreadable-object (post stream :type t) (format stream "~A - ~A ~A" (post-guid post) (post-title post) (post-url post)))) (defun get-first-text (tag node) "Search the XML node for the given tag name and return the text of the first one" (plump:render-text (car (plump:get-elements-by-tag-name node tag)))) (defun parse-rss-item (item) "Parse an RSS item into a lobsters-post" (let ((guid (get-first-text "guid" item)) (title (get-first-text "title" item)) (link (get-first-text "link" item))) (make-instance 'lobsters-post :guid guid :title title :url link))) (defun get-rss-feed () "Gets rss feed of Lobste.rs" (let* ((xml-text (octets-to-string (drakma:http-request +feed-path+))) (plump:*tag-dispatchers* plump:*xml-tags*) (xml-tree (plump:parse xml-text)) (items (plump:get-elements-by-tag-name xml-tree "item"))) (loop :for entry :in items :collect (parse-rss-item entry)))) (defun send-toot (post) "Takes a lobsters-post and posts it on Mastodon" (tooter:make-status +mastodon-client+ (format nil "~A - ~A ~A" (post-title post) (post-guid post) (post-url post)))) (defun record-post (post) "Notes that the POST has been processed by us." (push setf +processed-links+ (cons (post-guid post) +processed-links+)) (with-open-file (out +link-db-path+ :direction :output :if-exists :append :if-does-not-exist :create) (format out "~A~%" (post-guid post)))) (defun main () (loop :with count := 0 :for rss-entry :in (get-rss-feed) :while (&gt; 10 count) :unless (processed? rss-entry) :do (send-toot rss-entry) (record-link rss-entry) (incf count))) #+entry-point (main) ```
If you press `C-h t` you'll get the built-in Emacs tutorial. Probably worth going through it at least up to the section on buffers. By the way, you're looking at the scratch buffer, and by Lisp evaluation it means *Emacs* Lisp, not Common Lisp. It's maybe confusing if you weren't using Emacs before trying CL, but when you write CL in Emacs you've got two Lisps going: 1. Emacs itself is an implementation of [Emacs] Lisp, and 2. your favorite Common Lisp implementation, which you communicate with using the SLIME REPL and via hotkeys you enter while editing Common Lisp source files. Things you evaluate in that scratch buffer are evaluated by Emacs itself and won't show up in or have access to your Common Lisp program.
Were Rust invented in 70s, then it would have been matured and standardized around 90s. For a small router-like program that was buggy and written by a grad student, Rust is a good choice.
I can see why, but it really gives a lot in the 80 first percent. Think about having list/dict comprehensions (with useful literals even), a few combinatorics algorithms in the stdlib, that gets you quite far already. It might crack semantically if you start poking at the object layer too hard. 
I am glad I have found this paper by Cornish. I am still looking for an article I read in the 80s, probably published in Scientific American (or was it Byte Magazine?) about how Lisp coders and hackers at universities were staying up all night in sheer programming bliss, completely forgetful of time, the code in their minds all day until they could get time on a Lisp Machine. If it rings a bell, please let me know the title or magazine!
I played with it in 1980's. As far as I understand MacSyma run on it. They were OK, but I managed to crash it a few times with high memory usage conditions. 
E. Fukamachi switched to Lem nearly exclusively: http://blog.8arrow.org/entry/2018/08/14/213428 (Chromium's translation is ok) &gt; I used Emacs as my main editor all the time , but I moved to lem last month. […] In the past month I used Emacs only for a few days to write Swift. It is painful that there is no syntax highlight as expected. &gt; Commit has exceeded 200 in the past month […] Furthermore, it seems that momentum has not declined as rust - mode is added immediately after release. &gt; The good point of lem is where startup is fast. &gt; Since it spews dump core including expansion, startup is fast as Vim as elementary . Since it can be started quickly, I can come back and forth with the shell, so I can cooperate with the shell if necessary. For example, to use Qlot, qlot exec lemlem's REPL refers to the project local quicklisp. Because it is written in Common Lisp , both extension and Contribute are easy. and he shares his .lem config files: https://github.com/fukamachi/.lem 
Thank you so much for this gem! 1987... The historical hindsight is staggering! For instance, I think most people would find this cute nowadays: &gt; Debugging information such as the names of the arguments of each function. Conversely, the author has many interesting intuitions that are still rather niche today: &gt; You will never fully appreciate how such fragmentation limits productivity until &gt; you have used a single-language system. Also the software stack seemed quite different: &gt; I hear people complain that they would have to learn LISP to use the Listener, &gt; the Explorer's command interpreter shell. I wonder what those Explorer and Listener are. Last but not least, "Zmacs"! Those were the days... 
I believe that's the TI Explorer. A listener is what many now call a REPL.
 else if (Py_TYPE(descr) == &amp;PyCFunction_Type &amp;&amp; PyCFunction_GET_FUNCTION(descr) == (PyCFunction)tp_new_wrapper &amp;&amp; ptr == (void**)&amp;type-&gt;tp_new) { /* The __new__ wrapper is not a wrapper descriptor, so must be special-cased differently. If we don't do this, creating an instance will always use slot_tp_new which will look up __new__ in the MRO which will call tp_new_wrapper which will look through the base classes looking for a static base and call its tp_new (usually PyType_GenericNew), after performing various sanity checks and constructing a new argument list. Cut all that nonsense short -- this speeds up instance creation tremendously. */ specific = (void *)type-&gt;tp_new; /* XXX I'm not 100% sure that there isn't a hole in this reasoning that requires additional sanity checks. I'll buy the first person to point out a bug in this reasoning a beer. */ } The above taken from the generic object initialization procedure. It kind of shows all the aspects of it: the devs. themselves aren't sure what should it do, how exactly does it happen, and, on top of it, there are tons of duct tape, which (probably) prevent it from falling apart...
I'm trying to have my breakfast. ;-P Compared to the Schemes I've extended, that seems way hairy. To be fair, when I studied Smalltalk from the blue book, the metaclass and metaobject sections bruised my brain pretty badly. It isn't so surprising to me that getting objects not-quite-right. There are way too few Kays and Paepckes, but way too many people who think they can design an object system.
These are not fundamental issues. They don’t impede work. The author just doesn’t like changes to S-expression meta-syntax. Lisp traditionally (back in the 70s-90s) had great tooling. It still has decent tooling from commercial vendors, but the open source world isn’t as nice. We do have relatively good compilers, but it’s a real hang up for beginners to learn Emacs, Paredit, and SLIME unfortunately. I’m excited to see where Lem and Mezzano go though. 
[CLISP](https://clisp.sourceforge.io/) is a Common Lisp implementation that starts up very quickly for scripting use and can even be used as a (basic) [login shell](https://clisp.sourceforge.io/clash.html)! You may want another implementation for web development work, such as [SBCL](http://www.sbcl.org), there are a wide variety available for Linux.
THE GARBAGE COLLECTOR HAS BEEN CALLED.
I think he has \*some\* Lisp knowledge. He's behind ErgoEmacs which is the only thing which makes Emacs even vaguely usable for me. The thing is, he cites Guy Steele. Steele is a Lisp (and LispM) god. [https://en.wikipedia.org/wiki/Guy\_L.\_Steele\_Jr](https://en.wikipedia.org/wiki/Guy_L._Steele_Jr). If he says something, then it's probably true. See Clarke's Third Law. Steele's point: [https://www.infoq.com/presentations/Thinking-Parallel-Programming](https://www.infoq.com/presentations/Thinking-Parallel-Programming) &amp;#x200B; &amp;#x200B;
I take your point about the tooling, but I am more getting at the core stuff about syntax, cons, etc.
Ergoemacs is not written by that guy: https://github.com/ergoemacs/ergoemacs-mode/graphs/contributors 
I never heard of the person before and decided to read it. I will be the first one to say that conses/pairs are not the end all be all, but they can be quite powerful. They make it easy to do things like remove/swap/etc. tails; make a circular object, and make a large variety of structures and be quite regular in the process. And there are some cool things underneath the hood in the actual implementation that can be done with them such as when they are freed by the garbage collector one can just cons them onto the head of a list of free conses that can be immediately used whenever a new cons is needed for an object (this is what picolisp does if I remember correctly). They are a simple structure that can represent nested trees. Not suitable for everything, hence why most lisps have other container types. But very good for some things. On the syntax stuff, all the various things that break from the very regular syntax are generally macros of a sort and ultimately translate into the standard syntax (the big exception is comments which are truly quite separate and different). Syntactic sugar is what many people call them. In the lisp family of languages, some have a lot and some have very few. Do they make it a bit more complicated for code formatting code, yes. Still would say not very much compared to say python. As far as style guides, well, one could format special forms and macros the same as everything else, but for many of them, using a slightly different indentation helps make them easier to read and understand because the different sublists in them have different meanings. Overall, though, the syntax of lisps is extremely simple compared to most languages. As an example, the C code of the reader for Guile Scheme and is pretty tiny and straightforward. Lisps are not without their flaws. Each one has some. Some are common between many lisp. And there are various double edged swords as well.
&gt; I think he has *some* Lisp knowledge. Any effective troll has a good enough knowledge of the subject to fool non-experts. He creates a controversial "take" and then defends it without conceding any points (see the comments). For example, he ignores the fact that the cons but not the list is part of the definition of s-expression: &gt; an s-expression is classically defined as &gt; 1. an atom, or &gt; 2. an expression of the form (x . y) where x and y are s-expressions. Notice he fails to define his own s-expression syntax. he also ignores the fact that `'(1 2 3)` is really shorthand for `(quote (1 2 3))` which is also shorthand for `(quote . ((1 . (2 . (3 . nil))) . nil)) ` 
Honestly, clojure/scheme/racket/common lisp are all fine for everything you mention. IIRC startup time of cljs/node is considerably faster than jvm, so even clojure isn't disqualified. I can personally vouch for SBCL: * Developing under emacs (with SLIME) is amazing. It's actually what keeps me using this stack over other languages. * If you are willing to save an image, startup time is excellent (\~10ms on my machine) * Several reasonable http implementations, though IMO clojure has an edge here (e.g. ring has more quality middleware than any CL web stack)
First of all, I'd say that designing a language that is to be used is an engineering problem, in that there isn't a perfect solution but rather tradeoffs. That means that there will be problems with any useful language, and one could make the argument that they are fundamental. &amp;#x200B; Secondly, when you are growing a language, keeping things in that would otherwise be suboptimal may be a good thing in terms of not breaking existing code and/or patterns. I think all experienced lispers have things they would like to change about the language. Actually I would go so far as to say if you don't have something bad to say about a particular language, then you just haven't used it enough. &amp;#x200B; Now on to the actual article, I find his arguments to be a bit silly. Does common lisp have too much builtin syntax? Maybe; perhaps a matter of taste, but it's hard to argue that it's a fundamental problem since you can avoid using them. Is dotted syntax confusing? Probably, but it's not something you encounter a lot, so even his cons/fons argument further down isn't convincing when applied to it. &amp;#x200B; Are CONSes the perfect data structure for representing trees? No, but they are certainly good enough for representing lisp code, which is the only place that they are unavoidable in the language. &amp;#x200B; If the author want's to list fundamental problems with lisp, I dont think this is even a good candidate list.
Which CLISP's features make it great for scripting, comparing to other CL implementations?
The usual at that time (years ago): small memory footprint, fast startup times, fast code interpreter, readline, good Unix/C integration, widely ported, various useful extensions ( https://clisp.sourceforge.io/impnotes/ext-clisp.html ) , widely used, ... CLISP hasn't have releases for some time, though there is still development activity.
Chez. Maybe guile, but I can't remember.
Guile doesn't. I should look at Chez.
Many should be able: http://www.s48.org/1.9.2/manual/manual-Z-H-4.html#node_sec_3.10 https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/World-Images.html#World-Images https://cisco.github.io/ChezScheme/csug9.5/use.html#./use:s98
4 variants of the evaluator from this blog post in Lisp, including ones that use monads like Haskell: https://github.com/jonatack/common-lisp/tree/master/talking-with-a-lisp/simple-evaluator
FYI, *An implementation of the Language Server Protocol for Common Lisp* https://github.com/cxxxr/cl-lsp
1. Most of the code is going to break if another operation is added 2. Lisps in general have better tools to deal with this, yes, not as pretty as ADT but extendable. 3. In CL, in particular, you should rather use classes and multimethods, although it is a bit like shooting a fly with a canon. 4. You don't need `main` in Lisp - you have fully functioning REPL! The only time you write it is if you save the image.
Original: (defun evaluate (e) (let ((op (car e))) (cond ((eql op 'Val) (cadr e)) (t (let ((e1 (evaluate (cadr e))) (e2 (evaluate (caddr e)))) (cond ((eql op 'Add) (+ e1 e2)) ((eql op 'Sub) (- e1 e2)) ((eql op 'Mul) (* e1 e2)) ((eql op 'Div) (if (= e2 0) nil (/ e1 e2))) (t (error "invalid operation")))))))) Shortened: (defun evaluate (e) (destructuring-bind (op &amp;optional e1 e2) e (symbol-macrolet ((v1 (evaluate e1)) (v2 (evaluate e2))) (case op (val e1) (add (+ v1 v2)) (sub (- v1 v2)) (mul (* v1 v2)) (div (let ((div v2)) (when (zerop v2) (error "division by zero")) (/ v1 div))) (t (error "invalid operation")))))) 
Good work placing Lisp history comparing it to the timeframe of more recent languages (Python, Ruby). &gt;Common Lisp doesn’t include string interpolation. You want it? No problem, you don’t have to wait for Scala 2.10 or Python 3.6, just use a library. Good example. &gt;No one’s up in arms trying to get a new revision of the Common Lisp standard to add pattern matching because you can write it as a library and get 90% or more of what you’ve get if it were built in. The language gives you enough power to extend it in a way that feels like the extension was there from the beginning. This is something I often need to explain in Reddit forums, perhaps I should just copy/paste this paragraph! &gt;Get a Lisp It should mention Portacle, really. &gt;I'm a programmer, photographer, dancer &amp; bassist Really good, worthy article!! Kudos from a programmer, photographer, and drummer. 
I read Gabriel's this year and also thought it's VERY VERY good. +1 on its recommendation. A refreshing book about methodologies, patterns, deevelopment practices and lisp itself.
Vydd and I were talking about this just now. There's no license so I don't want to look at the code to see what state it's in.
&gt; It should mention Portacle, really. I've added it.
I've always liked this example, from _Practical Common Lisp_ (2007). &gt; DOLIST is similar to Perl's foreach or Python's for. Java added a similar kind of loop construct with the "enhanced" for loop in Java 1.5, as part of JSR-201. Notice what a difference macros make. A Lisp programmer who notices a common pattern in their code can write a macro to give themselves a source-level abstraction of that pattern. A Java programmer who notices the same pattern has to convince Sun that this particular abstraction is worth adding to the language. Then Sun has to publish a JSR and convene an industry-wide "expert group" to hash everything out. That process--according to Sun--takes an average of 18 months. After that, the compiler writers all have to go upgrade their compilers to support the new feature. And even once the Java programmer's favorite compiler supports the new version of Java, they probably still can't use the new feature until they're allowed to break source compatibility with older versions of Java. So an annoyance that Common Lisp programmers can resolve for themselves within five minutes plagues Java programmers for years. 
If you specifically want a four function calculator, so that you can do (eval4 '(add 2 (mul 3 6))) =&gt; 20 the code in the article is, err, well, it is close to the Haskell, so it follows the authors plan for the article, so it is OK I guess. But one of the joys of Common Lisp is that if you can see that your project will contain a lot of interpreter code, then you can write a macro like [headcase here](http://alan.sdf-eu.org/headcase.lisp) and then go (defun eval4 (term) (headcase term (number term) ((add x y) (+ (eval4 x)(eval4 y))) ((sub x y) (- (eval4 x)(eval4 y))) ((mul x y) (* (eval4 x)(eval4 y))) ((div x 0) (error "Division by zero.")) ((div x y) (/ (eval4 x)(eval4 y))))) Notice that HEADCASE isn't a general purpose pattern matching macro. You don't have to quote the initial symbol in the list to stop it being a variable, because it was designed for prefix notation. Similarly a top level atom names a type, because that is useful for splitting the base case (a symbol could be looked up). The macro-expander uses constantp to spot that 0,1,t,nil, etc are literals. Tuning macros like this is an art. They should do more than mere template filling so that the capture the repetitions inherent in a particular application. They shouldn't be too much more than mere template filling because you don't want to fall down the rabbit hole of designing a general purpose language. [headcase.lisp](http://alan.sdf-eu.org/headcase.lisp) does support nested patterns, such as (add (mul x y) z), so it might be over-complicated.
~min 52 "Computer Sciences stand on the shoulders of their predecessors not on their toes " if I heard well
Good reading to do side by side with the curse of Lisp ;)
&gt; If you already use the Dash app for MacOS, it has the Common Lisp spec available. tip: we have the same docsets in [Zeal](https://github.com/zealdocs/zeal/), a GUI doc browser.
One can also use Velocity for Dash documentation databases for Windows.
nitpicking: &gt; For the compiling-into-binaries functionality I’d recommend using your implementation’s built-in support for this, or using UIOP’s wrapper around that, or using a separate library like Deploy. Isn't it asdf's wrapper ? `build-operation` in the `.asd` and `asdf:make`: https://lispcookbook.github.io/cl-cookbook/scripting.html#with-asdf
He was referring to \`uiop:dump-image\`.
one of the authors of [The Art of the Metaobject Protocol](https://mitpress.mit.edu/books/art-metaobject-protocol)
added to the sidebar if using *new* reddit, see http://old.reddit.com/r/lisp
I think you meant `(zerop div)`.
Cool, I'll take a look later on after work.
&gt;You should also begin to get comfortable looking up things in the Common Lisp language specification itself. It’s the ultimate manual for Common Lisp. It can be pretty dense at points, but can answer many questions you might have if you read it slowly and carefully. You can either use the index page to find what you’re looking for or just search on Google for “clhs whatever” (CLHS stands for “Common Lisp HyperSpec”, which is the hyperlinked, HTML version of the spec). Zach has online lisp search engine that includes the hyperspec: http://l1sp.org/html/ I realize you do not use emacs/slime, but slime is already connected to the online lispwork's hyperspec, C-c C-d h when the cursor is over a word (say `remove-if-not`), will bring up that entry. If it does not exists, it will prompt you to edit the word. C-c C-d ~ then enter a `format` letter while bring up the hyperspec format for that letter. You can also configure slime to reference a local copy of the spec and if you prefer not to leave emacs like me you can stay in emacs with the w3m text based browser.
Melpa has [dash-at-point](https://github.com/stanaka/dash-at-point) and [zeal-at-point](https://github.com/jinzhu/zeal-at-point) for emacs. I'll give zeal a try
It's awesome to see the project still kicking.
Still kicking? It literally pushes new versions regularly each month.
I really wish SBCL developers would put a timestamp next to each new release so that it would be easier to show people how active the project is. But for now, I guess [a search for all released threads on r/lisp](https://www.reddit.com/r/lisp/search?q=sbcl+released&amp;restrict_sr=on&amp;sort=new&amp;t=all) could be used as an ad-hoc solution.
https://en.m.wikipedia.org/wiki/Lisp_(programming_language)
Non-Mobile link: https://en.wikipedia.org/wiki/Lisp_(programming_language) *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^208827
Did you Google first?
Yes. I need basic idea of it's working. Google complicates things
Well I would recommend reading the Wikipedia page for Lisp and Common Lisp. Clisp is basically a Common Lisp implementation.
Lisp is a family of programming languages (or programming language dialects if you view them as not completely separate programming languages). Someone already linked you a wikipedia article on them. It is an old family, starting shortly after Fortran. And it is still alive today. Major langs/dialects are Common Lisp, Scheme, Clojure, and Emacs Lisp and their variations (like Racket, which is pretty different from Scheme these days) and there are several other living ones that are still used (like [PicoLisp](https://picolisp.com)) and there are periodically new ones (like [uLisp](http://www.ulisp.com)). Common Lisp and scheme have many different implementations of them (if you know Python, this is just like how there is CPython, PyPy, Jython, etc. except with Scheme and Common Lisp there are many many more). CLISP is just one implementation of Common Lisp. It's site is at https://www.gnu.org/software/clisp/.
Woohoo 🎉 
I don't want to see a presentation, let a alone be taught, by someone whose preparation consisted of going on Reddit to ask what the heck it is. Do you? Those students (or their parents, or scholarship funds) pay good money, for pete's sake.
Thanks for your answer. These are somewhat prices i won't afford today... The other Lisp dialects don't have good GUI implementations for windows? 
Best other alternative is probably Ceramic (Electron) for Common Lisp, QTools (Qt4) or EQL5 (Qt5 but must use Embedded Common Lisp)
Thanks for this. I will take a look on Racket. Wondering why most of the forums talk about Racket as an academic language. Maybe because google doesn't show any "big" companies using it nowadays. &amp;#x200B; Still curious about the loading time of Clojure though. Syntax looks appealing to me. Any hints here?
Clojure would normally be the clear winner if you are looking for pragmatic lisp for the real world, but windows desktop applications is about as far as you can get from Clojure's wheelhouse. This is not because of the startup time, where those extra few ms would not be noticeable, but just because ... windows desktop. The Clojure options would probably be &amp;#x200B; \- Clojure, using the Java UI frameworks... ughhh \- Clojure on the CLR, using Microsoft APIS - you'd be far out from the mainstream Clojure experience, probably not good for someone new to Clojure \- ClojureScript using a JS tool like electron. This is almost surely the way I'd go with Clojure, but I don't know what the gotchas are here. My guess is this is a path for suitable for an experience Clojurist &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
I have successfully used Common Lisp (SBCL/CCL) with Qtools to deploy GUI applications on Windows and Linux.
Do you have small or simple examples to share.
There are some examples bundled with Qtools - you could start there.
ECL has qt5, and for the other CLs you have commonqt which is qt4. Unless you want to use web technologies that is probably your best bet. You should also check out McClim for a really cool way of writing GUI.
there are ways to reduce load times of clojurescript apps by dumping v8 vm state, but ultimately if we're talking about gui app - a second or two isn't that long.
unfortunately i cant speak about racket as i havent used it much. i can totally recommend clojure - that's the lisp that stuck with me after years of trying different dialects. but writing GUIs comes with so many idiosyncracies that i can't tell if any other lisp would be better. html/css model in electron is at least easily understandable and probably familiar to pretty much anyone. other gui models - not so much.
There several cross-platform options for GUIs in clojure. Swing (via seesaw lib) is pretty easy and works well out of the box. Javafx presents a compelling option, since it has really nice 2d/3d integration based on a scene graph, and can integrate swing if you want. There are a couple of wrapper libs, but you'll probably be doing interop (which is easy from clojure). Another compelling option - as present in the NightCode IDE by Zach oakes - is to use javafx's webview (basically chromium) to host your ui panes, and mix-n-match components with javafx (or not). NightCode basically does everything (syntax highlighting, editing, parinfer, styling, etc.) in cljs and just renders to webview. That's a pretty slick way to go. I use swing with the substance theme (basically what earlier NightCode leverage), and everything is slick + responsive. I also have some stuff that wraps Piccolo2d for zommable user interfaces (inspiration for JavaFX actually), that works very nicely as well. Finally, if you go the webview/CLJS route.....transitioning to browser-based rendering is trivial: you already did it. So code reuse, it's all in clojure, etc. Lots of options. 
suggestions: - http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/ - what was/is CL used for ? http://lisp-lang.org/success/ - https://en.wikipedia.org/wiki/Common_Lisp
&gt;but windows desktop applications is about as far as you can get from Clojure's wheelhouse Disagree completely. I use it for cross platform apps, primary target is windows (7 - 10). Hasn't been an issue for me. NightCode is another successful example. Seesaw (Swing) makes it pretty trivial, but the better long-term solution is Javafx (optionally shoving off the load to cljs + javascript libs via webiew component).
Is the application starting speed fast?
define fast. sub-ms, no. seconds, yes. Start time does scale with the "number" of classes loaded at runtime for the jvm, so if you pull in the world it can move your startup into the eclipse realm. AOT (bytecode) compilation buys a little bit of time. There are some tricks to load lazily as well, and get the gui up fast. The cursive ide (on intellij) is another real-world example, where the author put some effort into improving load-time. If you AOT with graal as I mentioned, this goes away (although you lose the ability to eval/compile at runtime....if you don't care about that at runtime then startup time can be instantaneous in theory). For reference, on W10 on machine, loading nightcode (which has a lot of stuff aot'd via cljs) takes anywhere from 4 seconds (if the jar's been virus scanned) to 17 (if it's the first time opening it). That's consistent with my experience for a larger app.
Skip Common Lisp for now if you're just trying to learn and do Clojure. It's a joy to use and its expressiveness makes Scheme look like garbage. Just use Swing for the desktop app and CLJS for the web UI.
Perhaps this says more about my comfort level with Clojure than Clojure's innate utility, but on the spectrum from browser to server to desktop, clearly desktop is Clojure's weakest area. And window's is definitely the weakest platform for Clojure, especially for desktop apps. That doesn't mean you can't get the job done, but I personally wouldn't recommend it is a path for someone new to Clojure without hearing more people having success with that path. &amp;#x200B;
Racket is not education-oriented -- ...Well, one of its goals is to allow one to create new languages fairly easily, and one application of that is several teaching-languages (simplified schemes, where error-messages can take advantage of how certain constructs aren't allowed). And it has its origins in education. But it is a full, industrial-strength lisp. A list of packages: [https://pkgs.racket-lang.org/](https://pkgs.racket-lang.org/) &amp;#x200B; Its IDE, DrRacket, is written almost entirely in racket, so certainly GUI tools and system-call-interaction are pretty well fleshed out. (That said: no, racket is not as widely-used industrially as Clojure or Common Lisp.) &amp;#x200B;
&gt;clearly desktop is Clojure's weakest area. And window's is definitely the weakest platform for Clojure, especially for desktop apps. What criteria are you basing your statement off of? How is windows weaker/est? If you've got a selection of cross-platform options (piggy backing on JVM, alternately node, alternately [although I'm very mildly versed] clr), there seems to be relative parity among the different operating systems. I have to target windows by default, typically in a somewhat limited environment. Since the JVM (alternately browser) is allowed, there provides a platform for the stuff I mentioned earlier. My stuff runs fine in x / Linux, although haven't tested it on MacOS (although the devs providing said libraries do). I think mobile is the weakest of the platforms at the moment, that is native mobile. There are some options, like targeting react native, but that looks like a longer stretch than a simple gui/frontend with seesaw that works across multiple environments. per OP &gt;One of my main "goals" is to create native Windows desktop GUIs (and if possible webfrontend) with the language i discuss here. I think there are compelling options to accomplish the stated goal, newness (an unstated criterion) aside.
You should check the [releases page on github](https://github.com/sbcl/sbcl/releases). It even has changelogs! :)
True - mobile native apps are definitely not an ideal use case for Clojure. 
After all of your comments it's kinda hard for me to decide between Racket and Clojure for completing my task. Or if i either should learn Racket first, and then jump on the Clojure train. Racket is known to be beginner friendly and the learning curve of Clojure is kinda steap, with the JVM etc... I don't know what to do :D 
You can get started now and lateral later, if you decide to. Lisp-1 + functional programming emphasis will translate between Racket/Clojure (and some CL). If you're in Common Lisp, many of the concepts (dynamic binding, macros) translate pretty closely to Clojure as well. The biggest difference will be lisp-2, the distinction between functions/values. If you're learning and wrapping your head around getting things done, just pick one, implement something small, and revisit your decision later. The important thing is to get some mileage so you can make an informed decision - to either keep going to evaluate something else. I have traversed all three, and learned from each. There are benefits to cross training if you can afford it (if you're not trying to push a product now to put food on the table...).
there is a guy that has written a rather complex gui application for fitness tracking with racket. the gui looks nice and modern and performant. search for it in google and the racket subreddit. if you can't find it, let me know, and i'll hunt it down for you later.
here: https://www.reddit.com/r/Racket/comments/8lfw0o/running_and_biking_workout_editor_implemented_in https://alex-hhh.github.io/2018/06/a-racket-gui-widget-to-display-maps-based-on-openstreetmap-tiles.html https://www.reddit.com/r/Racket/comments/5ywuf8/my_hobby_project_in_racket_a_fitness_activity
It may be an industrial strength language, but the IDE is quite clunky on my Mac. Slow scrolling in windows, lots of GCing, clunky user interface design, slow UI when tasks are running, ... The IDE is more ambitious than it is able to deliver. 
I couldn't have said it better.
That's helpful. Can you also tell the difference between clisp and lisp?
&gt;racket Wow, this is awesome. Thank you for the insight to this project! Got my upvote :) !
Google crawls pages, indexes them based on textual content and compiles a searchable index. It doesn't complicate the content in any way whatsoever. 
So LISP in itself is not a language?
I could have sworn the project had a long dormant period in the 2000s. But I paged through the releases tags on Github, and I was wildly wrong.
Which LISP? The original created by John McCarthy in 1958, or some of the more modern and useful contemporary dialects? (: If you wanted to learn Common Lisp, then I suggest you start with https://portacle.github.io/ and http://gigamonkeys.com/book/
I like using Guile Scheme, but that's just what I like. I'm not sure what the standard is.
If I were you I’d go the painful way and do CL and either the Qt4 or Qt5 bindings people mentioned here. You said you’ve written native apps before? C# is a little different, have you used a GUI library like GTK, Qt, Cocoa, etc yet? They come with their own complications (you really have to learn how they work to build the GUI in the first place). Qt is cross platform so that takes care of that issue. CL is the most popular lisp out there so it probably has the most mature libraries for the things you want, vs Racket which I found to be a bit too new and I wasn’t crazy about the lack of options around it (mostly in regard to 3rd party package availability). CL gives you the best dev environment and the biggest package selection, and the most users should you need help. It will also have the most options on the native GUI side. 
What, nono, i am completely new to programming! I am a system administrator, but never wrote a software myself. Just starting now :)
Ah, thank you. I didn't know that there is a mirror on Github.
#(1 x) is not a constructor, it's a constant. It's analogous to having written (let ((x 2)) '(1 x)) ==&gt; (1 x), not (1 2)
Is it possible to change read-time behavior if, say, I'm inside of my own magic context? Say I have my own dispatch that creates magic lists depending on context. If I'm inside a magic-let, the list is populated based on apparent lexical bindings. If I'm not, the magic list acts as vector literals do, and is effectively symbolic/constant. Let #\{ denote magic list delimiters. (magic-let ((x 2)) #{x}) =&gt; #{2} (let ((x 2)) #{x}) =&gt; #{x} 
&gt;#(1 x) is not a constructor, it's a constant. It's analogous to having written ... Thanks, that's very concise and clear to me now. Regarding the point, I'm using CL as a language implementation platform and trying to reconcile some limits I've run into (due to my invalid mental model). This case is something I ran into unexpectedly (not vectors exactly), and I'm trying to work around it within the features CL provides (reader macros, macros, etc.) before implementing things at a lower level.
Always happy to hear from users!
No. The form must be read in its entirety before evaluation happens. That's why you can't do something like \`(progn (make-package "FOO") 'foo::bar))\`. You'd have to use some other reader macro before the form is read to set things up, e.g. \`\~(let ((...)) ...)\`
This is simplified. The expansion of the macro MAGIC-LET and the expansion of the reader macro #{ : (let ((magic t) (x 2)) (if magic (vector x) '(x))) 
It is: http://www.lispworks.com/documentation/HyperSpec/Body/02_df.htm " ``#(x1 x2 x3 ... xn)` may be interpreted to mean `(apply #'vector `(x1 x2 x3 ... xn))`. "
It is normative: http://www.lispworks.com/documentation/HyperSpec/Body/02_df.htm "Where a comma occurs in the template, the expression following the comma is to be evaluated to produce an object to be inserted at that point." "`#(x1 x2 x3 ... xn) may be interpreted to mean (apply #'vector `(x1 x2 x3 ... xn)). "
https://www.gnu.org/software/kawa/index.html 
Here, `#{exprs ...}` is just syntactic sugar for `(vector exprs ...)`. When `#{` is dispatched, it calls `read-delimited-list`, with `}` as the delimiter, then returns `(cons 'vector &lt;that-list&gt;)`.
He has spoken!!
Hi /u/joinr , so happy to see you're giving CL a try. Just some 5 cents: I've not seen too much usage of #() literals on CL, code, IMO perhaps because vectors are often used for performance reasons, and in those cases it makes more sense to previously create the vector (using make-array) and setting up the various options -- element type, adjustable or not, fill-pointer, displacement, number of cylinders, firing order, etc etc. 
So LISP in itself is not a language? The original LISP was a language, it had many descendents. From the current ones in use, Common Lisp is the closest one (in legacy and compatibility) to the original LISP, so often "Lisp" is written to mean "Common Lisp". But there are many current Lisp family languages in use: PicoLisp, Scheme, TXR Lisp and others. 
This seems very close to what I'm interested in. You can still explicitly quote the {} expr to communicate not wanting to eval. Thanks for the food for thought!
Thanks for this, i didn't know about Qtools until today. I always assumed you needed ECL (EQL) to use Qt with CL (and never understood why, because CFFI should be enough, me thinks?)
Qt is a C++ library, and binding to that is a whole lot more trouble with CFFI than if you can just compile with a C++ compiler.
All you need is some booze, a portrait of John McCarthy and a sharp knife!
I stumbled across that only a few months ago - after years of CL usage...
If you want to create web front ends ClojureScript is probably a good fit. :) I don't know about Windows native bindings though.
From what I've heard of Racket and tried myself in Clojure, you can't go wrong whichever you choose. You're in for a bunch of valuable lessons which you'll be able to apply regardless of what you do afterwards.
Javafx for wpf like ui (seesaw [swing] with substance theme is very nice tho, or use Windows plaf). Compile using graal native image (can't use classloader though, so no eval). Alternate strategy (less tested) is use clojureclr and clr nativegen facilities. As far as uwp, no idea. That's another can of worms I haven't researched.
Seems contrary to the lisp spirit, particularly common lisp where extensibility and allowing consenting adults to make decisions is prized. Again, the vector literal is a conversation starter, not the use case. Finally, if I'm using cl as a platform for language research, why would I care about others' expectations? Am I not free to bend cl to my will, as they say, grow the language to fit the problem?
I'd say the lisp spirit would be not to make a mess just because you can.
&gt;not to make a mess just because you can. No one's made a mess here. Why have reader macros, let alone macros then? Unhygienic macros even.
If you quote the whole expression, you get `'#{a b c}` -&gt; `(vector a b c)`; you have to quote the pieces within it individually that you don't want evaluated.
I ended up going with [this](https://gist.github.com/joinr/68ba0f0e9a690f69c3e23404c8815a7a) as a toy implementation. It gets the behavior I was after. I still need to modify syntax-quote to recognize things, but it works. This version does not use a dispatch, rather reads {} directly. Thanks a lot.
Thanks for the insight. In retrospect, read naturally precedes eval (can't apply without eval, can't eval without a form, can't get a form without reading it first). So either condition the reader to inject context into the form-to-be-evaluated, or let the reader emit simple forms, and embiggen what the evaluator gets fed via macros. Seems like overloading reader macros is a poor (at least inelegant, fighting the natural order, etc.) prospect in this case.
Yep, but LFE uses #(...) notation for tuples, which are very common in Erlang. Which is kinda right - they're essentially arrays.
IMO, your second choice seems to clearly indicate what is going on, whereas I'd have to discover what your use of #{...} does. Indeed, I may have my own definition of that reader macro, so now what? The value of any abstraction is hard to measure at times, but if it isn't heavily used to make understanding the meaning of the code easier, it must be asked if the cost is worth it.
&gt; Indeed, my lack of experience with this part of the language shows here in that I was not explicitly aware of how to answer my question of "what then" since it seems that there is a way to manage this. You and me both :) Not saying that messing with language semantics is not frought with peril or the utility of abstractions shouldn't be weighed. I like the flexibility of CL as a language platform (given the reusable tooling built), especially as I learn more. [These folks] (https://github.com/dylan-lang/opendylan) had the same idea years ago. 
Read the sidebar, this subreddit is for programming languages.
Where can I get a Lateral Lisp image? I'd be glad to help, but I've never heard of it.
FWIW I got a similar itch some years back. I found I was fairly easily able to tinker with the CCL internals to change the evaluation semantics for literals of my custom data types. Obviously not portable/something you could release as a library, but fun to explore the internals of an implementation, and pretty awesome to be able to change things like that interactively.
This is pretty neat! Before you add multi-threading though, you can probably gain some performance by making your backend deal with image data in terms of scanlines. Most video/image file formats are stored in a way that makes it easy to read consecutive rows of pixels at a time. Because of that, most compositing and rendering applications will read only a few scanlines at a time, process them and flush the output scanlines before moving on to the next line. This lets you allocate smaller fixed buffers for your inputs and outputs and lets you avoid dynamic allocation during your image processing. For your 3x3 convolution kernel for example, you can allocate a fixed input buffer of 3 scanlines and use a sliding window as you iterate down the image. For the ouput, you only need to buffer a single scanline at any given time. From a common lisp perspective, this means getting familiar with READ-SEQUENCE and WRITE-SEQUENCE on the file streams containing your image data. Good luck!
This is pretty neat! Before you add multi-threading though, you can probably gain some performance by making your backend deal with image data in terms of scanlines. Most video/image file formats are stored in a way that makes it easy to read consecutive rows of pixels at a time. Because of that, most compositing and rendering applications will read only a few scanlines at a time, process them and flush the output scanlines before moving on to the next line. This lets you allocate smaller fixed buffers for your inputs and outputs and lets you avoid dynamic allocation during your image processing. For your 3x3 convolution kernel for example, you can allocate a fixed input buffer of 3 scanlines and use a sliding window as you iterate down the image. For the ouput, you only need to buffer a single scanline at any given time. From a common lisp perspective, this means getting familiar with READ-SEQUENCE and WRITE-SEQUENCE on the file streams containing your image data. Good luck!
By the way, trivia supports that. (match (vector 1 2 3 4 5) (#(A B _ _ E) (list A B E))) ; -&gt; (1 2 5) Also, (match (make-a :b 1 :c 2) (#S(a :b x :c _) x)) ; =&gt; 1 
That is the most British demo I've seen in a long time. /u/baggers_ you are no longer my favourite British lisper
The brtitsh chap is Michael Rosen and his videos are well-known YTP material.
This sub is probably not the place to get help. I have never heard of sibilant before. you would probably get more help at https://old.reddit.com/r/node/
Thank you.
That is indeed not me. I don't have the stuff to keep a camera still, so I just processed the Michael Rosen Rap instead.
Right now I just use ffmpeg's image2pipe filter which reduces video decoding to reading ppm frames. I'll take your advice onboard, but a proper video decoder sounds quite difficult.
Node.js? More like Nope.js. *shows herself out*
I don't know anything about sibilant, but in your instructions there's a single double quote at the end of the last line. Is that supposed to be there?
Sorry, that was a typo on my end, not related.
I've been working with Robert Strandh on a spellchecker in portable Common Lisp, https://github.com/phoe-trash/Spell/ And the spellchecker is for a bigger project, a service for storytellers/roleplayers to do their roleplays on.
I'm extracting general purpose libraries out of `cl-bodge`, so people would be able to reuse them w/o buying into whole `cl-bodge` framework. It all started with `bodge-ui` (high level lispy wrapper over Nuklear UI library), but now i just can't stop - there would be more: host OS functionality is already spliced out into a library, graphics and physics are going to be next.
I'm polishing a [Weblocks](https://github.com/40ants/weblocks) application for [cl-torrents](https://github.com/vindarel/cl-torrents), i.e. a dynamic web page all in CL. For another idea, I'm pretty excited about the [Next browser](https://github.com/next-browser/next). ps: CL is definitely more fun than elisp or python ;)
I'll be on holidays in Tokyo this week, but knowing me, that probably wont stop me from working. After all, I wrote my first Lisp library when I was last there. Most likely I'll continue work on [Trial](https://shirakumo.org/projects/trial), and particularly the [geometry clipmaps](https://reader.tymoon.eu/article/368) component of it. In specific, I want to investigate shadow mapping and halfspace fog to improve the look of the rendered scenery.
That's certainly an interesting project! Do you have a repo for these libraries setup yet? 
Why would you say CL is more fun than elisp? I really like Python, I find it to be a real joy to work with due to its ability to just get out of your way. 
I really like the sound of the bigger project. Do you have a link for it, or any more info on what the plan/roadmap is?
In the process of pushing them to GH atm. I'll put links here just a bit later.
elisp: first of all, CL is a lisp we can do (real) real world things with \o/ elisp is for emacs, you can't build a command line app, a web app or build an executable. So CL is a Lisp with more possibilities of fun. On the top of my head, it also has an enjoyable object system and an interactive debugger that I miss in elisp. Python: I agree. Though, now that I maintain a non-trivial but not even very big app: it's a chore to deploy, SBCL does a lot more type inference (and you get notifiied when you hit C-c C-c on your function, you don't even have to re-run your test or the app), the repl and the interactive experience are addictive. And: with macros I can refactor the code however I want. Python is (a bit) boring, I can't do whatever I want with decorators or context managers. Also I learned to prefer the Quicklisp system of distributions (think apt) rather than an unstable pypi (brought me pbs on deployment, again).
https://github.com/phoe/gateway and https://github.com/phoe/raptor-launcher There's no sure plan/roadmap yet - right now, I'm working on the UI part (which is going to be in Common Lisp + Qtools) and the server (Common Lisp + PostgreSQL).
Alright, here the repo: [https://github.com/borodust/bodge-ui](https://github.com/borodust/bodge-ui) But I didn't published it into bodge distribution yet (which i'll do tomorrow morning) and example is a bit rushed, but here we go! :)
That's an interesting point about Python, and one I don't ever really concern myself with since all of my code in the language has precisely one user: me. 
Have you checked the spell module in hemlock? [https://github.com/bluelisp/hemlock/tree/master/unused/spell](https://github.com/bluelisp/hemlock/tree/master/unused/spell)
&gt;And finally, for the fun part – Common Lisp. Of course, this is not idiomatic Common Lisp by any stretch of the imagination, and the idea is to try and preserve the essence of the Haskell version whilst still being runnable Lisp. Common Lisp is, of course, a dynamically-typed language, and it doesn’t have a real equivalent of ADTs. However, the bigger discomfort, in my opinion, is that Common Lisp’s pattern matching is almost non-existent (unlike Racket). As I read this, I expected the CL version to be an explosion of convolution in comparison to the Rust version, but reading further down, it turns out to be not that bad at all, although it could be improved. 
I can't believe I forgot that...
Can you add something about finalizing classes in CLOS? That seems to surprise people because it is seldom discussed.
Nope, I was completely unaware of it. Thanks!
 CL-USER 109 &gt; (defun prompt-for-phone-number () (loop with number = "" when (= (length number) 10) do (return number) do (format t "~%~a" "Enter a valid phone number: ") (finish-output) (setf number (read-line)))) PROMPT-FOR-PHONE-NUMBER CL-USER 110 &gt; (prompt-for-phone-number) Enter a valid phone number: 12 Enter a valid phone number: Enter a valid phone number: 1234567890 "1234567890" CL-USER 111 &gt; (defun format-phone-number (number-string) (apply #'format nil "+1-~a~a~a-~a~a~a-~a~a~a~a" (coerce number-string 'list))) FORMAT-PHONE-NUMBER CL-USER 112 &gt; (format-phone-number **) "+1-123-456-7890" 
Just as a side note: internationally there's no way to format phone numbers uniformly. Phone number notation and length can vary wildly between countries. Also, if the spacing between the hyphenation of digits is uniform (it isn't in your example) then format can print it pretty easily like so: (format T "~,,'-,4:d" 123456789) ; =&gt; 1-2345-6789
ok I'll give it a shot. I then invite you to watch the cookbook to review my future PR :)
In Other Publishing Systems you could add Coleslaw for CL - https://github.com/kingcons/coleslaw - https://github.com/40ants/coleslaw-cli It doesn't seem to support writing in org directly. (nice post again)
Ah! All of that makes sense!
The site loops a little wonky on mobile, so I'd recommend some media queries for different screen sizes. I only say that specifically because I want to recommend [LASS (Lisp Augmented Style Sheets)](https://github.com/Shinmera/LASS) :P It looks really cool. Maybe once I get my basic site up (don't hurt me...it's in...*PHP*. I'm a recent 2-year graduate and every company in my area uses PHP, some Javascript mess, or ASP.NET for web stuff. I don't *want* to be a web developer, but that's the field with the most job openings here right now), I'll hopefully have honed my Lisp skills to rewrite using something like
The site loops a little wonky on mobile, so I'd recommend some media queries for different screen sizes. I only say that specifically because I want to recommend [LASS (Lisp Augmented Style Sheets)](https://github.com/Shinmera/LASS) :P It looks really cool. Maybe once I get my basic site up I'll hopefully have gotten Lisp down, and I can rewrite it in a Lispy way (in something like [Coleslaw](https://github.com/kingcons/coleslaw) as u/dzecniv mentioned) with LASS.
So, what game it is?
Indeed, the CSS is rather poor, it's not my cup of tea I'm afraid. I was thinking of using Bootstrap to produce something more robust (and pretty), but I did not know about LASS: it looks awesome!
Which OPTIMIZE controls are you using? STEP on SBCL works only if you have DEBUG set to a high enough value. Add this to .sbclrc, restart SBCL and recompile your code: (sb-ext:restrict-compiler-policy 'debug 3 3)
Forms that only contain constant expressions are constant-folded at compile-time. When you evaluate `(step (+ 2 (+ 3 4)))` you're really evaluating `(step 9)` because the arithmetic was performed at compile-time.
I went and downloaded the Interviews book and read through the first two already. They're pretty interesting! Seeing one of the interviewees mention beating the averages, I figured I definitely had to read it. Working through it now. 
And then you forget about it and wonder why the generated code looks so ugly and slow. And it won't help stepping through neither (+ 2 (+ 3 4)) (as Shinmera points out), nor REMOVE, as it's calling into SBCL internals not compiled for debugging.
No, I don't forget about it - I always globally set DEBUG and SAFETY to 3 on my development machines - that's why they are development machines. DEBUG and SAFETY are set to SBCL defaults when I deploy binaries.
&gt; Maybe once I get my basic site up I'll hopefully have gotten Lisp down Tell me more via private. And thanks for making me notice LASS, another fine product from Shinmera; looks awesome.
&gt;I really like Python, I find it to be a real joy to work with due to its ability to just get out of your way. I used to like Python a lot until I needed to do some threading and thus found out about the GIL (Global Interpreter Lock), which was a big let down for me. Later I went into Common Lisp and never looked back. &gt;I find it to be a real joy to work with due to its ability to just get out of your way. Yes, this is what you get when you have a sufficiently expressive language. And CL is massively more expressive than Python, prepare yourself to be surprised! 
I have heard about the GIL before and run into it a few times, as I tried to use multiprocessing to speed up my simulations. A very frustrating experience. As to CL being massivrly more expressive than python, that is definitely what I keep hearing about it. I'm very much looking forward to the surprise!
Thank you, this did solve my problem!
FWIW, I was using REMOVE as an example, step wasn't working for any functions.
There's a lot to like about Clojure, I really like it's support for immutable data structures. But. It's error handling and the Java stack traces are dreadful. Industry leading for dreadful. And poor library inter-op can compound that. So whilst it would be great whilst everything works, you might quickly find yourself banging your head against a wall if something doesn't and you're trying to find out why. If I were you, if you've already narrowed it down to Clojure or Racket, I'd go with Racket. It's much more beginner friendly.
No worries :) Take your time, we'll wait patiently :)
In the article Steve warns against thinking: *“This project was last updated six years ago? That’s probably abandoned and broken.”* Which is exactly what I do do. He says: *The stability of Common Lisp means that sometimes libraries can just be done, not abandoned* Which I can accept but how do I tell the difference? For example I started using a really nice prevalence library (in memory persistence backed by flat files) but it appears to have been abandoned. How can I tell if it's "just done" and so safe to use, or not? 
Can you share your error message? Even if you can't comprehend it, it's likely there's somebody here who can.
Thank you; I have added it to my original post.
You cannot do `(expr-evaluating-to-function arg)` in Common Lisp. The leftmost position of a compound expression must be the name of function or else a lambda expression. 
&gt; ... Also, try to avoid replicating codes between languages, you will often run into corners like this. Every one of them will have slight semantic differences Without replicating Mathematica code in Lisp, how can I implement a Mathematica-emulator in Lisp? I'm trying to to understand both Lisp and Mathematica well enough to do that. I used to.
well you'll need to learn how lisp work in order to know how to encode mathematica concepts into lisp (or if they're equals, share them). hopefully more seasoned programmers can help you
You have to use `funcall` or similar: (funcall (funcall (lambda (f) (lambda (x) (list f x))) 'g) 'y) This also works: (funcall ((lambda (f) (lambda (x) (list f x))) 'g) 'y) , `(lambda ...)` as a first element is treated specially while the resulting closure object isn't hence the necessary `funcall`.
&gt; ... if you want to actually make a function call.... I do not. &gt; ... you don't just construct that list. What I want to do is just construct that list, so constructing that list is what I want to do. &gt; Mathematica... the semantics are only vaguely specified.... Which is why I am using Lisp rather than Mathematica. &gt; ... and often depart from Lisp practice while keeping the same names I speak 12 languages; I can handle words having different meanings in different languages. &gt; Mathematica is probably not a good model for your semantics. My project is to develop Lisp code to interpret some Mathematica source-code. It's okay that you don't want to do that, but it's what I'm going to continue doing if that's okay with you.
p.s. Thank you for your code example. I am still working trying to understand why it does what it does.
To give more details: I thought clisp didn't allow (lambda ...) in functional place. Common Lisp normally needs a (funcall &lt;functional&gt; arguments...). Then I tried: ((lambda (x) x) (lambda (x) x)) and it worked. So all I did was to try sub expressions of your code, to see where it failed. ((lambda (f) (lambda (x) (list f x))) 'g) ;; works and returns a &lt;function...&gt; so for a reason, clisp doesn't like (&lt;function ...&gt; 'y), I tried (funcall ((lambda (f) (lambda (x) (list f x))) 'g) 'y) You know all I did.
Thank you very much. That is one combination I had not tried while trying various combinations involving 'funcall' and 'function'. 
No, the whole point of "vague semantics" is that "clear enough for all intents and purposes" is not true. If you had an actual definition for `g`, Mathematica would have applied it. So the semantics of that simple expression depend on the environment. Mathematica has (disclaimer, I haven't worked with it for more than a decade) a repeated evaluation model, which keeps going until it heuristically believes it has reached a fixed point. Mathematica is a mess. Until you understand how much of a mess it is, you won't be able to fully reproduce its behavior. Maybe take a look at Richard Fateman's old "Mockmma" code.
oh yeah that's exactly what I would envision too, you ended up hitting a convenience spot that is not generalized so it failed later on
&gt; Mathematica is a mess. Until you understand how much of a mess it is.... Your advice is misplaced. Aug 28, I emailed this to Wolfram: &gt; You dumbfucks managed to make the worst program I've ever used. Absolutely retarded, and I'll put my name on that as a phi-beta-kappa stanford graduate, and former developer for intel, microsoft, and dave smith. &gt; You got some $300 out of me for a piece of junk that's not only useless but cost me months of lost time. That's stealing, you scumbag. I followed up several minutes later with: &gt; mark my words you stupid shit, i aced symbolic systems at stanford, i see how to put a lean product on the market that outperforms your boondoggle in the ways that matter to paying customer. you essentially added yoga-positions and a retarded gui to maxima, that was stupid of you So give me credit for recognizing Mathematica's decrepitude, but if you can't make complete sense of that single line of Mathematica code I posted originally, I am sorry but that problem is with you not Stephen Wolfram. Take your autism meds and try again to understand the intent of my original post, and you will see it is clear that you have sidetracked yourself with irrelevancies.
but now I see this: (funcall (lambda (f) (lambda (x) (list f x))) 'g) it evaluates to #&lt;FUNCTION :LAMBDA (X) (LIST F X)&gt; That is an `f` in the result rather than a `g`, so now I am more confused than ever.
Good for you. As for making sense out of that line of Mathematica, I can see very well what it does in Mathematica. But *you* are the one who can't reproduce it in Lisp. And, furthermore, you will find that the symbols in Mathematica have a lot more to them than the symbols in Lisp: they can have arbitrary evaluation rules attached to them in Mathematica which will fire whenever they apply. Lisp symbols are much simpler and the evaluation rules much more straightforward. Which is why translating `Function` to `lambda` is not good enough.
&gt; you are the one who can't reproduce it in Lisp. so are you, bud
&gt; Good for you. Yes, and I emailed John McCarthy, who I never met in person, to thank him for his work on Lisp, because it is so great. Compared with my emails to Wolfram. Mathematica could have been Lisp plus symbolic integration, but instead it is so much less.
You do realize John McCarthy is dead, right?
You could use CFFI to hook Lisp to an implementation in C. The API mentioned on https://github.com/centaurean/spookyhash seems trivial to use - it's literally a single function call, `spookyhash_128(data, data_length, &amp;seed1, &amp;seed2);`.
Thanks, it sounds like a good exercise in using CFFI.
I manage some 2500 PCs with SCCM. The SCCM agent on client computers tends to break or misbehave, and needs uninstall/reinstall cycle, along with WMI fixing and some other cleanup tasks performed. Some years ago I implemented a script launch/monitoring tool with Clozure CL which I run daily. It grabs computer names from a database, filters inactive AD accounts and launches a script that does all the grunt work. Then it monitors the script output log and updates the database record with current status for each client. Once in a while I import new broken clients in the database and check out how many of them are left unrepaired. A very boring job made fun only because of Lisp.
also [helm-dash](https://github.com/areina/helm-dash).
You could call libFB via CFFI, or use your Lisp's POSIX functions to interact with the device directly. e.g. (sb-posix:read/write/open/close/ioctl).
Thank you, I'll definitely take a look at both of these. I hadn't considered looking through lisp game engine code, but it makes sense that this kind of stuff would be in there! 
This seems like it might be the simplest approach, I don't really think I've done much with SBCL's POSIX functions, but now that you say it that seems like the logical first step.
Disclaimer: I'm not into game dev, so if you wait a little bit here, you'll get even better answers.
Wait so you can write to /dev/fb0 and subsequently onto the screen?
Absolutely, you can also take raw screenshots from the framebuffer with cat /dev/fb0 &gt; file. What I'm trying to do is essentially lay a static image on /dev/fb0 with a lisp binary, and alter various portions of that display with statistical information. It's like a non-interactive HUD. 
Thanks, I now have a road map for learning lisp :)
It could have been "Lisp in Small Pieces" (https://en.wikipedia.org/wiki/Lisp_in_Small_Pieces). I strongly recommend this book anyway if you intend to write a Lisp interpreter or compiler.
"open source" is a failure, incompetents publishing sewage to pad their resumes
Try `assq` (assq :FIRST--NAME '((:ID . 4) (:FIRST--NAME . "Eve") (:LAST--NAME . "Holt") (:AVATAR . "https://s3.amazonaws.com/uifaces/faces/twitter/marcoramires/128.jpg"))) (:FIRST--NAME . "Eve") 
`assq` did not work with SBCL but `assoc` did the trick. &amp;#x200B; `* (assoc :FIRST--NAME '((:ID . 4) (:FIRST--NAME . "Eve") (:LAST--NAME . "Holt") (:AVATAR . "`[`https://s3.amazonaws.com/uifaces/faces/twitter/marcoramires/128.jpg`](https://s3.amazonaws.com/uifaces/faces/twitter/marcoramires/128.jpg)`")))` `(:FIRST--NAME . "Eve")`
There is no `assq` in Common Lisp; also re-read Ashwin Ram's [ballad](http://www.ai.sri.com/~delacaze/alu-site/alu/humor/large-programs.html) paying attention to the last line. 
How does this make Maxima “useless”?
Install sbcl then add a library that adds lexical scoping.
He wants to emulate Mathematica without listening to anyone explain how computers or software work.
Useless might be overstating it, but it's pretty seriously broken behaviour for anyone trying to write modular software.
Glad you found it; came here to suggest assoc
I hope this doc is clear: https://lispcookbook.github.io/cl-cookbook/data-structures.html Also the [access](https://lisp-journey.gitlab.io/blog/generice-consistent-access-of-data-structures-dotted-path/) might be helpful. 
Try either SBCL or Racket.
Racket is based on the Scheme dialect and SBCL is an implementation of Common Lisp. Most Common Lisp dialects automatically compile to machine code. Racket does as well, I think. 
Common Lisp has the [`disassemble`](http://clhs.lisp.se/Body/f_disass.htm) function, the SBCL implementation has a nice output.
Lisp is my favourite language of all time. However these days it has culled out a lot of growth and cultured a [not invented here](https://en.wikipedia.org/wiki/Not_invented_here) mentality. I'd suggest starting with something simple, and using as many well built libraries as you can. If you don't find what you're looking for, build it from someone else's library and publish openly. The ecosystem needs more interest and you'll get constructive (if not rather strong) feedback.
**Not invented here** Not invented here (NIH) is a stance adopted by social, corporate, or institutional cultures that avoid using or buying already existing products, research, standards, or knowledge because of their external origins and costs, such as royalties. Research illustrates a strong bias against ideas from the outside.The reasons for not wanting to use the work of others are varied, but some can include a desire to support a local economy instead of paying royalties to a foreign license-holder, fear of patent infringement, lack of understanding of the foreign work, an unwillingness to acknowledge or value the work of others, jealousy, or forming part of a wider turf war. As a social phenomenon, this philosophy can manifest as an unwillingness to adopt an idea or product because it originates from another culture, a form of tribalism.The term is normally used in a pejorative sense. The opposite predisposition is sometimes called "proudly found elsewhere" (PFE) or "invented elsewhere". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
sbcl is a common lisp implementation and racket is its own programming language and implementation which is an evolution of lisp and scheme. there are many common lisp implementations since it has a standard, so its compilation story depends on the implementation. for example, one implementation targets the jvm but others probably emit either c or native code directly. racket uses a vm/jit. https://docs.racket-lang.org/guide/performance.html but why does it matter if they compile to assembly?
I'd enjoy if users would be able to run the executables of the program without needing to install something else, while at the same time not allowing any random dude to simply run a decompiling tool and get back all the source code I wrote from the executable
Something needn't compile to assembly in order be non-decompilable. Consider the JVM and the byte code produced for it. When you compile a Java program you are not literally producing assembly, does that mean it can be decompiled? No, it doesn't.
I would suggest Common Lisp. Most implementations are just fine, I recommend either CCL or SBCL. Common Lisp is a multi-paradigm language, has many libraries, and an unchanging standard. Lots of useful Common Lisp code exists on the web, and it is very well documented.
Of the two of these, I'd recommend starting with Racket, just because of Dr. Racket. It's a nice environment for learning how lisps work, and once you know either CL or Racket, it's trivial to learn another. The enlightenment you seek can be found in all the lisps. 
PCL is a cool beast. This said, you're in for a lot of unfamiliar territory. I only know Common Lisp, but I guess that the workflow is quite similar, and it means major differences from the way you'd write code in C++: (1) We sit in REPL a lot. You use REPL to write code, to test the code incrementally, to play out with its output, to inspect the data. You basically have a frozen halfway-done program that you can interact with. If you want to add a new function you don't recompile everything, you just type that in REPL(or use SLIME for excellent Emacs-REPL connection*). (1) is also made much better with the use of restarts. Basically exceptions that you can react to without unwinding the stack, unless you decide to do so. Makes working in REPL much better, because your error is not a stack trace and halted execution now - you can inspect the data at hand or modify it (e.g. recompile a function, substitute a variable) to make program continue. (2) You don't need to do all of it in REPL. I actually type out my code in the editor and use SLIME to send it to the repl itself. This way you write down the code as you'd normally do, but get results immediately, and you can test what you just wrote. Long C++ compilation times make me don't want to recompile it as often, which leads to more bugs that are related to me forgetting something. This doesn't happen that often in CL because I see those bugs immediately. I will cut down my advertising now, but the picture should be clear - don't try to treat Lisp as you'd C++ - Lisp is not a good C++. It is a good Lisp. I'd recommend Common Lisp. You can try setting up Emacs, SLIME and SBCL. I recommend Linux. If you don't want to bother, try [Portacle](https://portacle.github.io/), which is the combo above, but portable(and available for many platforms). You can also go with Vim/SLIMV, but I'm not a vim user so can't help you with that. As for the beginner's materials, [PCL](http://www.gigamonkeys.com/book/) is a great book if you have some programming experience. It shows CL's basics and more advanced features, focusing on the practical matters. Hungry for the metaprogramming stuff? Try [On Lisp](http://www.paulgraham.com/onlisp.html) which is a nice book about CL's macros. It is not a CL learning material. It requires you to know CL, and teaches you how to deal with macros. There are many great examples though, and the book can be quite overwhelming at times. I believe it is worth reading. If you want to see metaprogramming from the different, non-macro perspective, try the [AMOP](https://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol) (The book is not available for free though; you'd need to get your hands on it somehow. I bought a copy and it's a great book). The book tells a story about implementing Common Lisp's OOP system using CL and the OOP system itself in the way that would allow for it to be extendable. The AMOP assumes some CLOS(Common Lisp Object System) knowledge. If you don't know CLOS, either google around to learn how it works (I believe PCL also shows some of the features), mess around with CL in REPL or try [Keene's book](https://www.pearson.com/us/higher-education/program/Keene-Object-Oriented-Programming-in-Common-Lisp-A-Programmer-s-Guide-to-CLOS/PGM262224.html). Again, that's a rare find (price to pay when you deal with Lisp, I guess) and was written before the standard came out so it can be a bit different, but I read it and I can tell you that it's the best introduction to CLOS that I've seen. Might be that I haven't seen many of those. Either way, congratulations on your choice. Language is great. Different, a bit odd, but I love it for that and I believe learning it made me a better programmer. Simply because it opened my eyes on what language can be.
It even adds code comments!
The decision is yours: do you want a Lisp-1 or a Lisp-2? A lisp-1 has functions and variables in the same namespace, whereas lisp-2 does not. Secondly, do you want hygienic macros or not? &amp;#x200B; I'd suggest in decreasing order: Racket, Scheme, Clojure, CL (SBCL) Racket currently compiled to its own native form but I think it's being ported to Chez scheme, if that interests you. Regardless, Racket is the pinnacle of AOT compilation with its \`#lang\` directive and macros that you yourself can create and work with.
Racket runs on a VM.
I'd suggest against bootstrap to be honest (in the context of [https://bestmotherfucking.website/](https://bestmotherfucking.website/)). You can make a beautifully simple, lightweight website with simple CSS. And to be honest your site looks great.
racket is specifically designed to be a language laboratory and a way to make new programming languages which can inter-operate. sure, common lisp has facilities to do that, but racket is specifically designed for it. i didn't mean common lisp was lacking.
with racket, on windows, yes, you can now create standalone executables. https://download.racket-lang.org/v7.0.html
If you're not going for maximum performance, I'd pick Racket. There's a book here https://htdp.org/2018-01-06/Book/ I guess it's sort of like the Haskell of LISP. If you need performance I think your only free choices are chez scheme or (for CL) SBCL.
Well, if you have time, watch https://m.youtube.com/watch?v=WQGh_NemRy4# It can of course also be done in CL (but not with defmacro), but the experience doing this in racket is vastly superior to anything I have ever used 
If you want to go the Common Lisp way, try Practical Common Lisp + Portacle. The latter gives you SBCL + Emacs + Slime + Git + Quicklisp in a preconfigured package. If you need any support, ask `#lisp` on Freenode or on the Lisp Discord server.
http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/
Your background in assembly might be tickled by the lambda papers (https://en.wikisource.org/wiki/Lambda_Papers) and Guy Steele's master thesis, which describes his Scheme compiler. Probably best to first get a little familiar with either SBCL or Racket, though. As others have mentioned, `disassemble` in SBCL is pretty cool. You might also want to give "Let over Lambda" (https://letoverlambda.com/) a try, it has some pretty cool low level-ish sections on a Forth implemented in Lisp and sorting networks, besides a general focus on Lisp macros which are, in a way, full featured compiler plugins. 
Most folks writing serious extensions to Maxima write it in Lisp anyway. Do that instead. 
Well, with Java it actually seems like you can decompile JVM without too much hassle. http://www.javadecompilers.com/
Common Lisp, and check [SBCL: The Ultimate Assembly Code Breadboard](https://www.pvk.ca/Blog/2014/03/15/sbcl-the-ultimate-assembly-code-breadboard/) for a teaser.
&gt; to simply run a decompiling tool and get back all the source code I wrote from the executable Just use enough macros and you're fine. ;)
Even innocuous code will fall prey to scoping quirks like this. E.g., evaluating a double integral inside a defined function should be easy in maxima itself, and should not require dropping down to the underlying lisp to avoid strange variable capture issues.
PicoLisp only.
How does CCL stack up against SBCL? I have used both - mostly for learning Lisp itself, so I have never done anything major. Mostly stuff in the repl and doing a mod of the database sample in PCL.
&gt; CL is old, and imho quite "archaic" Old archaic stuff is gradually getting replaced. English is getting replaced by modern slang and text message abbreviations. The works of Shakespeare are getting replaced by Youtube videos. Science is getting replaced by science fiction movies. But I'm not sure when the periodic table of the elements will be replaced. It seems very old and archaic. 
I like ASSOCDR `(cdr (assoc &lt;item&gt; &lt;alist&gt;) =&gt; (assocdr &lt;item&gt; &lt;alist&gt;` &amp;#x200B; [https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#assocdr-item-alist-rest-args-key-allow-other-keys](https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#assocdr-item-alist-rest-args-key-allow-other-keys)
Well, I'm used to unhygienic macros (and reader macros, I presume that Racket tries to make them more high-level) as well. I mean, a small library could implement the Racket's approach. The only ugliness I know of is the necessity of [binding every character](https://github.com/metawilm/cl-python/blob/0f47bf71997291266dda4095c62a5bcb9d442b57/util/readtable.lisp#L56) to your reader macro if you want to read a source through your reader completely.
Are there advantages to this approach versus just writing your parser, expanding the resulting AST to CL, and then calling eval/compile?
What exactly do you want to do? Do you mean an external parser as some sort of preprocessor?
Why don't you just try something from the options the other comments mentioned. Think about compilation later. 
Another advantage of CCL over SBCL is that CCL lacks some optimizations and doesn't throw away names of local variables. This makes debugging in CCL really nice. See the demo: https://www.reddit.com/r/Common_Lisp/comments/6kg0uo/good_guy_ccl/
Agree
&gt;I'd enjoy if users would be able to run the executables of the program without needing to install something else You can do this with Common Lisp and Scheme too. 
&gt; SBCL I would just like to say that other common lisp implementations like LispWorks or ACL or CCL can be every bit as fast as SBCL too. In other words, SBCL is not the only fast Common Lisp implementation (but it's a great one of course.) 
&gt; Clojure is quite modern and has interesting functional data structures, compiles to JVM bytecode. &gt; CL is old, and imho quite "archaic" It depends on your definitions of "modern" vs "archaic". Clojure isn't image-based. CL is. On my criteria, this would make Clojure archaic. Clojure is lisp-1, CL is lisp-2. On my criteria, this would make Clojure backwards, because if I wish to, i can call a CL lib to obtain lisp-1 behaviour, but you can't make a lisp-1 work as a lisp-2. Clojure doesn't allow me to define my own reader macros, so I can't really extend the syntax. In CL, I can. Thus Clojure will feel "older" to me. All the syntax sugar that clojure has, which is nice, like easy way to define lambdas, can also be obtained in CL by importing a library. 
&gt; How does CCL stack up against SBCL? I had a project deployed in production, same code in SBCL vs CCL was pretty similar in speed, CCL was only slightly slower. CCL, in my limited experience, produces nicer/more thorough error messages/warnings. CCL used to be a commercial lisp, now it's free! CCL also compiles faster than SBCL, though this isn't really a big advantage IMO. CCL is supposed to work more reliably on Windows. SBCL has a warning against being used for threading stuff on windows. All in all, having many choices are good. You can easily switch from CCL to SBCL back-and-forth, so don't limit yourself to only one choice.
&gt;I personally code in C, C++ and Rust, and I have a lot of background in assembly and reverse engineering, so I was thinking that a dialect supported by an AOT compiler would fit me best (Even if I don't know if it can exist due to the language design), but I wouldn't prioritize it if the other choices would be much better documented or featureful. &gt;What do you think would fit me best? If you want to generate very small/brief machine language code (like, for example, for embedded development), Scheme can be the best choice since there are many implementation suited to those purposes. If you intend to do big, complex, fast production-quality systems, to be executed on desktop/laptop/server hardware, I think the best choice would be Common Lisp. 
If you decide to go with Common Lisp (which I did), you'll see people telling you to read Practical Common Lisp. I found that book pretty tough to get through, and recommend starting out with [Common Lisp: A Gentle Introduction](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/dst/www/LispBook/book.pdf). Much more accessible; it was written in the 80's and doesn't even assume that you're familiar with *computers*. It's able to give you a really good idea of what's going on *inside* Lisp because of that. I personally thought it was a great introduction and could understand PCL way better afterwards.
In this case the definition is regarding the documentation and ease of use. I personally found Racket and Clojure to be much easier to start learning than CL. What you're writing about making CL obtain lisp-1 behaviour is interesting. Do you have any pointers?
&gt; I personally found Racket and Clojure to be much easier to start learning than CL. In which sense? I can install `Portacle`, just an easy install, and automatically i'll have a fully working Lisp IDE plus the SBCL implementation plus Quicklib to automatically install libraries. Or do you mean the learning curve is higher for CL? I would agree, then. &gt;What you're writing about making CL obtain lisp-1 behaviour is interesting. Do you have any pointers? It has been done many times, some weeks ago I saw a lib that did it, among other things, but can't remember. And i wasn't too interested. Clojure implementation in CL does it as well. Even the CL21 lib, which modifies CL for functional programming, doesn't attempt to make it lisp-1. I guess no CL user would like to go back to lisp-1... 
Somewhat tangential (perhaps) to what you're asking, but this might interest you: [A Lisp interpreter for Raspberry Pi implemented in a single ARM assembly file](https://github.com/marcpaq/arpilisp).
I just wanted to rescue the original question, disregarding the comment about Maxima, the question asked is not being answered, I do not know the answer, but some of you may know. The original question was according to me: ***Are there any lisp-based computer algebra systems with lexical scoping, which can be used as Maxima alternatives?***
I love the look of phases.png before paragraph 5.3 ... how did you generate it ? (please) ... I need some time for the rest to read :-) Thank you 
It was a problem like this one that lead me to discover Common Lisp.
It's plantuml with handwritten skin - here's the [source](https://github.com/m00natic/m00natic.github.com/blob/master/org/lisp/phases.pum).
Thank you did know plantuml provided these shaky lines :-)
First of all, "Lisp-based CAS not Maxima" is a pretty small set. https://www.cliki.net/Mathematics includes [Axiom](http://www.open-axiom.org/docs.html) but that is about it. Second, it is not clear to me that "lexical scoping" is a clear win in a CAS. The OP is fixated on a particular use of anonymous functions which seems unrelated to typical CAS applications. Most math notations use other techniques for defining or processing anonymous functions (e.g., refer to arguments by numeric position) and treat functions-taking-functions different from ordinary functions whose domains are numeric. The problems of programming in a CAS are quite different from Lisp. Third, I'm pretty sure the OP is not asking in good faith. If you look at his history, he has apparently been iterating through environments like SciPy, Mathematica, complains vigorously about any issues he encounters, then rejects any help. Let him give up on Maxima and CL and go bother some other community.
Excellent article!! &gt;DSLs become so easy to implement, it feels like cheating. Can be a new Lisp slogan as well... 
A nice one, complete enough for my taste :)
Note that for the framebuffer, what you really want to do is mmap it, which requires, as I understand it, use of cffi:mem-aref to access the memory. This is inherently unsafe, so be careful.
The same way you know if something that was updated yesterday is safe to use. Use it an see if it works.
How exactly is it unsafe? That might be a silly question, but it's not something I've done before so that ignorance is genuine. 
Yes please!
mem-aref does nothing but take a bare pointer, add an offset to it, and indirect through the result. No bounds checking or anything. Super unsafe.
Has the brokenness been circumscribed ? I have so far never suffered of any surprises ... just solving equations and formatting code for simulation but you are worrying me !!! 
Thank you for your comment .... so I can continue to carefully use Maxima for standard manipulations ... I was a little bit worried,there . I also used Scipy but had some trouble with memory limit on a small PC, that I didn't have in Maxima. 
If you never pass functions around you don't need to worry.
Well, if all you're doing is mapping the framebuffer, an invalid memory access is going to cause a segfault in your program, at worst. It won't cause a killer poke that crashes or destroys your program, and there's little risk of you leaking sensitive data to the internet while messing around. So go ahead -- mess around while you can :) There are a couple of approaches to making the memory access safer. The first is to write your own accessor (perhaps framebuffer-ref) that wraps mem-aref in a bounds check. But this will slow down your code significantly since it adds a bounds check to *every* read and write of the framebuffer. The other is to define a set of operations (for example, blits, fills, geometry primitives, etc.) you want to do on the framebuffer, and then wrap *those* in a bounds check so that, for example, any coordinates these functions receive are valid and fall within the framebuffer area. Then once you're sure the operation is safe, do it with unchecked mem-aref. Or use a combination of both approaches. I dunno.
That doesn't work: something that's actively being maintained is likely actively being discussed. The same isn't true for either "just done" or abandoned.
Looks interesting but completely unreadable on mobile. 
One could also implement an interning table for strings, which gets emptied at some safe points in time... This MAY improve runtime - depending on the application.
alists will probably be the fastest for small alists, but if you are dealing with things with more than 20 keys you are better off using a hash table. Using string= for keys is also potentially slow. Comparing strings is slower than comparing symbols.
The general mistake would be developing lisp programs by running them from the command line, instead of using an advanced environment with a REPL, like Slime. 
I'm using cl-json and all the keys returned in an alist by the json decoder are all interned (ie: :key not "key"). That's faster than string= for later assoc calls.
Just compare, using time and loop macroses. 
When I started with CL, after a few years of Python&amp;JS, or even before I dared start writing Lisp, I was concerned about having more operators, different ones for different data types. It is actually not a problem in practice, even more AFAIU it is one of the things that makes CL faster and SBCL to catch more type-related errors. Also don't be skeptical when some concepts are not here. For example, there are not really generators, we use another construct: https://stackoverflow.com/questions/32956033/is-there-a-straightforward-lisp-equivalent-of-pythons-generators Happy to speak more about Python vs Lisp if you wish. ps: I hope you didn't miss the Cookbook (https://lispcookbook.github.io/cl-cookbook/) and https://github.com/CodyReichert/awesome-cl :]
Well, the real mistake is trying to develop in something like notepad, which doesn't have proper support for indentation. Writing software interactively with a terminal in one hand and a text editor in the other is how I learned, it was fine and no worse than python, but I was using an emacs-like text editor, which could do the indentation and parenthesis matching properly.
This is absolutely true, in the base case, Python has very weird and difficult to understand scoping compared to lisp. Let and let* are the best.
There are way too many differences to list. 1. Comparisons. Python has *==* and *is*, Lisp has =, eq, eql, equal, equalp, char=, string= and so on. 2. Unlike Python, strings and characters are different types of objects. A string of one character is not equal to a character. 3. The only false value is NIL which is the same object as the empty list. Unlike Python, empty string, empty array, empty hash table and even 0 (zero) are not false. 4. If you have a variable *var* that contains a function, you can call it with `var()` in Python, but you can't call it like `(var)` in Common Lisp (you might be able to in other lisps, like Scheme). 5. CLOS classes are similar to classes in Python (including stuff like metaclasses, multiple inheritance and super/call-next-method), but defining *methods* on these classes is a very different paradigm. 6. The biggest pitfall: lists in Lisp and lists in Python have similar API, but completely different performance characteristics. Lisp uses linked lists. Random access is O(n). If you need O(1) random access use arrays. Every Lisp newbie writes very inefficient programs in Lisp because they don't realize that taking nth element of a list is a slow operation.
JSON objects are small so maybe there's no need to use hash tables. The only thing that worries me is the string= part. Think I'll try egl instead 
Well, received data is fairly small so no need for hash tables. But I agree, don't like the string comparison here.
My only point was an alternate json lib returns interned keys.
happy lisping, I hope you enjoy it as much as I/we do, it's a gigantic park with enough places to have fun for a lifetime
This is how I wanted the JSON object. Seems like the request is automatically parsed to alist with strings when using lack. Maybe I'll havr to do the parsing myself
I got into Lisp after Python; i didn't think I had any bad habits from Python, maybe because I forced myself to learn the lispy way of doing stuff. It will be a steep learning curve because they are really different - no matter all the "Python is an acceptable Lisp bullshit". 
I am yet to find a good IDE (something like PyCharm for Python); nothing I try with Lisp like LispWorks or LispIDE can even indent properly. Any recommendations?
Easiest is to use Sublime with Lispindent.
If you aren't interested in emacs, I use the slimv plugin with vim. It works well for me and I still get to use my favorite editor.
Python conflates variable definition with assignment. x = 0 function(z): x = 1 x = 2 This doesn't do what you think; the syntax`x = 1` is actually a `let` that makes a local variable; it's not assigning to the global. The syntax `x = 2` is an assignment. The two look the same but do something contextually different. There is a `global` thing to declare that `x` is the global one. In Python 3 they added a `nonlocal` because, oops, they realized that `global` accesses the global scope specifically; what if an inner function wants to assign a variable in a surrounding function? 
Anyway, profiling is the only way if you are care about performance. 
potentially as a lisp-ide-in-a-box via [Portacle](https://portacle.github.io/)
Which Lisp? If you are going to scheme you will probably end up writing non-idiomatic things using lots of set!. In CL that's not a very big deal, but in scheme compilers are generally better at reasoning about pure code so pure code often produces faster results. Scheme also has first class continuations, and using set! often leads to code not being multi-shot continuation safe (which is a rare problem).
I am spending most of the time now in python (quite unfortunately) (don't worry I always use CL for plotting) and read many shit code, mostly machine learning code, written by the others. the biggest no-no is to put everything in the `__main__` and pretend that there is no problem. Don't do that. Even if you want to write a one-time script it never is, you or someone in the world will eventually reuse them.
&gt;Any recommendations? Of course one needs to use the right tool for the job: the job is Lisp programming and the tool is `E` `M` `A` `C` `S`. Fortunately [a benevolent, humble man](/u/Shinmera) has nicely packaged Emacs with a CL implementation and other nice tools, named "Portacle", so every newcomer to CL needs not to worry about installing or configuring anything. It just works.
good one Kaz, i was only a Python2 user and was wondering exactly about that
I'd actually take no indentation before I give up the REPL, it's just making me 10x more productive, keeping the state and not going through lengthy compilation cycles (sure, that's not applicable to python). But when you combine indentation, paredit, M-., REPL, interactive restarts (and lisp itself) nothing will catch up with that.
It is not "actively updated." I just looked at other forks and merged useful changes into the mine. The situation with common lisp libraries to work with IMAP is very sad. For example, the main use case for mel-base is to move all emails from one server or folder to another. Search my criterion does not work. Working with multipart emails is absent (i found an addon, but it should required some fixes and is far from being user-friendly). There is a [postmaster](https://github.com/eudoxia0/postmaster) library by Fernando Borretti. It is built on top of mel-base, but is unfinished and unusable. Another library which is on quicklisp – [postoffice](http://quickdocs.org/postoffice/) is 10 years old Franz's cl-imap library which doesn't work with SSL/TLS servers. There is a fork of postoffice, which has SSL support – http://github.com/orivej/post-office/ but doesn't worked for me because it uses portableaserve's internals to establish ssl connection, but these internals are not available anymore. So, I've created my own fork and fixed this and some other problems. Here is the WIP branch: https://github.com/40ants/post-office/tree/ssl-and-other-fixes Don't know if Orivej Desh is still interested in maintaining this CL library. This activity on Github is in Python and Go projects since 2016. But I've made a pull-request: https://github.com/orivej/post-office/pull/1 Probably I'll create a wrapper around this fixed post-office library to simplify some tasks when working with IMAP folders.
Thank you so much for detailed info, and for so much work on Common Lisp mail libraries. I do use CL-SMTP, but that is just for sending. It works quite well in my use-cases, but a working POP3 and IMAP library would be so useful. For now I need to go through the underlying OS mail sservices, but that is a headache to maintain, especially cross-paltform.
Which project are you working at?
A ZFS-based file-store manager focussing on actively detecting bit-rot, checking duplication while ingesting files via remote clients, and media cataloguing. SMTP and POP3/IMAP are needed to do OS-level alerts and manage mail-type resources.
Sounds like a really complex software. Do you already have some users?
Spacemacs. It will change your life.
I'm still very sceptical. In my programs I try to minimize state as much as possible. Why is state in my run/build a good thing?
Proper code indentation is not the only feature of the IDE. How about debugging lisp application in Sublime?
This seems like such a neat way of achieving react-style components in a way that scales well. Question: Are you generating content client side using clojurescript or generating static content server side? (Is there a detail I missed??) I think both approaches would work although one is arguably more static.
Portacle can be compiled on an RPi. There's no official releases for it because I haven't had the time yet.
Hiccup generates content server side. I didn't want client side generation because of SEO, since this is a promo site for a restaurant. However, this style can be easily translated into react components through a library called [reagent](https://holmsand.github.io/reagent/).
It's certainly a problem if you expect the semantics of lambda calculus.
Hmmm...what exactly do you mean by work in progress? There are stable and development releases; do you mean it's yet to be fully production ready?
does anyone know of a survey of available lisps (or even ml dialects) made for running embedded systems? i am talking about something one could imagine running on the arm side of a xilinx zynq chip. i am not overly concerned with garbage collection being present or not.
It depends on an existing version of itself (or another CL implementation), because it's self-hosting. That doesn't really become a circular dependency since you'd otherwise need to depend on another existing compiler anyways. It's not more circular than depending on another language.
Thanks for replying with that great explanation. I'll explore the compiler some more!
I mean that they sometimes remove and change features.
One way to think about it is that one has a definition already and it is declared to inline the code: CL-USER 14 &gt; (declaim (inline baz)) NIL CL-USER 15 &gt; (defun baz (a) (+ a 42)) BAZ CL-USER 16 &gt; (compile 'baz) BAZ NIL NIL CL-USER 17 &gt; (baz 0) 42 CL-USER 18 &gt; (compile 'baz (lambda (a) (baz a))) BAZ NIL NIL CL-USER 19 &gt; (baz 42) 84 
Implementation tricks like this are common for languages which expose primitives as first-class functions. It's likely that some stage of the compiler will transform any call of a primitive that matches the arity of that primitive into a built-in operation, and any other mention will be left as a reference to the `defun` of the same name. The point of doing it that way is that most calls to primitives get turned directly into efficient code (without the need for inlining), while still behaving exactly as a normal CL function with argument list checking, etc. In particular, note that the call to `car` within the `defun` will become a primitive operation, so the `defun` is not actually recursive if compiled in this way. A fun exercise would be to replace the definition with `(defun car (x) (funcall #'car x))` or similar and see whether CCL breaks (although it might recognise `funcall` specially as well...).
When I `M-.` on `car`, I get two available xrefs: one is the one you mention, the other takes me further into the compiler internals. :) Fun stuff
Note: (beta-reduce '(lambda (x) (lambda (x) x)) 123) ==&gt; (lambda (123) 123) There's more to lambda calculus than straight-forward substitution. Reading about free and bound variables would be a good starting point. Shameless plug: http://t3x.org/clc/index.html The free chapters should be sufficient to implement the basics.
&gt;'(lambda (x) (lambda (x) x)) 123) Right! That's a very nice catch, thanks!
I have gone with the MPLv2 for lisp projects where I would have used LGPL for other languages. It is not really the same, but it provides an even "lesser" copyleft that works with the lisp model. Modifications should be licensed under the MPLv2, but it only takes files into account, not any linking terminology. You may link or include MPL-licensed files in any way you want as long as you give proper attribution, but as long as you make a modification to the file you have to reciprocate.
The LGPL works fine for Lisp; it doesn't need fixing. The situation where .fasl images are loaded to produce a running image (which is then possibly dumped) is the same like your C linker (`ld` or whatever) loading `.o` files to make a program image, which is then written out. The LGPL allows this; it is not tied to dynamic linking. A LGPL-ed library can be redistributed as a `.a` archive containing `.o` files, which are linked by the user with the proprietary `.o` files to produce the proprietary application. The user can modify the free parts and rebuild, so they have their GPL-granted rights. As for how you handle macros; C does actually have them, contrary to what this paper says. A C macro will expand to C code. That code then depends on the library. The sane thing is to allow the output of the macro not to inherit the copyright of the macro itself; just like the output of GCC isn't GPL-ed. I think that needs to be spelled out in the license though. However, there is an issue in that the code generated by the macro depends on the LGPL-ed library, and that code is incorporated into the proprietary application that the user cannot rebuild. This is fine, unless the macro is badly versioned. Badly versioned means that the generated code depends on the specific library version, and no longer works if the library is upgraded. However, this could be an issue with the library API itself, and so code written by hand by the proprietary application developer could run into this. Macros only make things worse because they potentially rely on some internal API, which can have versioning issues even when the public API is squeaky clean. From the licensing regard, Lisp macros differ from the C ones in that they don't survive into the running program image. That isn't any sort of problem. If a bunch of Lisp fasl's are under the LGPL, and contain macros, those macros are just sitting there under the LGPL, like all other functions. The proprietary program can call them (e.g. during dynamic compilation) like any other functions. The LGPL says only this about macros: *When a "work that uses the Library" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law. If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.)* I.e. if you just use trivial compile-time material from a library, then you're not subject to the license: like `#define` constants, type definitions and "small" macros. Oops, what is small? Lisp macros can be very big. Big Lisp macros can have small output, and vice versa. If I had to fix the LGPL for Lisp use, this is probably what I'd clarify. I'd clarify it by making an exception; so that is to say, I'd use the LGPL as is, but provide an exception to it which spells out that output of macros is fair game. This has precedent. For instance, the GNU Bison parser generator comes with a "parser skeleton" code template, which is emitted into the generated parser. While that code template is copyrighted and GPL-ed, GNU Bison's license makes an exception for it, allowing GNU Bison to generate proprietary parsers. They didn't have to make a BGPL (Bison GPL) for this. 
By the way, guys, did you seen a new print-licenses library which is in quicklisp now? Here how it works: CL-USER&gt; (ql:quickload :print-licenses) To load "print-licenses": Load 1 ASDF system: print-licenses ; Loading "print-licenses" (:PRINT-LICENSES) CL-USER&gt; (print-licenses:print-licenses :weblocks) alexandria | Public Domain / 0-clause MIT anaphora | Public Domain asdf-system-connections | MIT Style License babel | MIT bordeaux-threads | MIT cffi | MIT cffi-grovel | MIT cffi-toolchain | MIT chipz | BSD style chunga | Unspecified circular-streams | LLGPL cl+ssl | MIT cl-annot | LLGPL cl-base64 | BSD-style cl-containers | MIT Style License cl-cookie | BSD 2-Clause cl-fad | BSD-2-Clause cl-ppcre | BSD cl-reexport | LLGPL cl-strings | MIT cl-syntax | LLGPL cl-syntax-annot | LLGPL cl-utilities | Unspecified clack | LLGPL closer-mop | MIT-style license dexador | MIT f-underscore | Unspecified fare-quasiquote | MIT fare-quasiquote-extras | MIT fare-quasiquote-optima | MIT fare-quasiquote-readtable | MIT fare-utils | MIT fast-http | MIT fast-io | NewBSD flexi-streams | BSD-2-Clause global-vars | MIT http-body | BSD 2-Clause introspect-environment | WTFPL ironclad | BSD 3-Clause iterate | MIT jonathan | MIT lack | LLGPL lack-component | LLGPL lack-middleware-backtrace | LLGPL lack-request | LLGPL lack-util | LLGPL lisp-namespace | LLGPL local-time | BSD log4cl | Unspecified metabang-bind | MIT License metacopy | MIT Style License metatilities | MIT Style license metatilities-base | MIT Style license moptilities | MIT Style license named-readtables | BSD, see LICENSE nibbles | BSD-style (http://opensource.org/licenses/BSD-3-Clause) optima | LLGPL parenscript | BSD parse-declarations-1.0 | MIT parse-number | BSD 3-Clause proc-parse | BSD 2-Clause puri | GNU Lesser General Public License quri | BSD 3-Clause routes | Unspecified salza2 | BSD serapeum | MIT smart-buffer | BSD 3-Clause spinneret | MIT split-sequence | public domain static-vectors | MIT string-case | 3-clause BSD trivia | LLGPL trivia.level0 | LLGPL trivia.level1 | LLGPL trivia.level2 | LLGPL trivia.quasiquote | LLGPL trivial-backtrace | MIT Style license trivial-features | MIT trivial-file-size | MIT trivial-garbage | Public Domain trivial-gray-streams | MIT trivial-macroexpand-all | Unlicense trivial-mimes | Artistic trivial-timeout | MIT Style License trivial-types | LLGPL uiop | Unspecified usocket | MIT weblocks | LLGPL xsubseq | BSD 2-Clause ; No values CL-USER&gt; 
@crowfeather are you working at Mind.ai?
I'm interested in these posts each time you post them, but I don't apply, because there are a couple of dealbreakers in the job descriptions. I have plenty of practical Lisp experience--more than you're looking for, in all sorts of domains from application programming to systems and embedded programming. I have substantial practical experience in GOFAI (specifically, several years of working on frame languages and knowledge-based systems at Apple). But the job descriptions present these dealbreakers: 1. "Work remotely but willing to travel to Seoul every two months for two weeks, or perhaps more often/a bit longer" Can't do it, sorry. Prevented by chronic health issues. 2. "Will relocate to Seoul before the end of 2018 (we will sponsor the working visa)" Can't do it, sorry. Prevented by health and family-related issues. I'm genuinely sorry I can't meet these requirements, because the job sounds very interesting, but them's the breaks. I wish you the best of luck. 
What is interesting, a job posting is about hiring in different cities around the world. However, at the end of the reading, you understand that this is not about a distributed team and remote working. I'm also interested in this posting but don't will to relocate because I think it is better to grow children in their native country.
Just wondered why both optima and trivia are included, and visualized it with asdf-viz: There is no dependency to trivia. Bug? https://raw.githubusercontent.com/guicho271828/asdf-viz/master/weblocks.png
This is because you've build the graph for old version of the Weblocks. 
Yeah, it's interesting that it's, for example, a New York job posting, but in three months, it requires the applicant to move to Seoul.
Solid suggestions. It's my first time trying to integrate anything like this so I really appreciate the advice! For what I have in mind it makes most sense to just perform bounds checks on pre-defined operations, since nobody will be interacting with the system, it just needs to display statistics.
Make sure that your library has a defined ASDF test-op. This way, Quicklisp will be able to test your system during each monthly build. https://github.com/edicl/flexi-streams/blob/master/flexi-streams.asd#L76
On documentation, I look for the following: * What is the library about? (If you are porting something from another language, don't assume I know that other library) * Why use this library instead of existing ones? Please tell me that this adds a missing X. Don't tell me it should be faster or safer but you didn't actually check. * Usage examples On testing I look for: * Does it even have tests? * Can I look at the tests as an example of how to use it? * Are there tests that signal errors - showing the author thought about it instead of assuming perfection? 
I didn't really think about the user side of things, so thanks for bringing this up!
Been messing with this with CCL on Windows. Seems pretty stable so far.
I've written quite a few Win32 GUIs in C and wanted something similar and familiar. There's a few examples, some games etc. I had fun writing macroman. The RPC example is useful because it shows how to multiplex networking with the message pump using MsgWaitForMultipleEvents, that's really powerful because it allows you to do networking operations without blocking the main thread without having to deal with threading nightmares. There's loads of things left to implement though because Win32 is massive. Dialogs and bitmaps are a pain because the way you write them in C is use the resource compiler but I couldn't find a way to do that from Lisp. Luckily I found a hackish way of doing it at runtime which seemed to work. 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/SlightlyCyborg/sentence-similarity) - Previous text "NLP" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20e6933xt) 
&gt; grow children in their native country. I appreciate your realism.
Nice! I like the fact that there is a lot of examples included. These days i'm experimenting creating UIs using Java Swing under ABCL and have created some functions to help do this; but I need to write more sample code to make sure my mini-library is good enough. This project (FTW) does have many sample files and this is reassuring -- means that the API was comfortable enough for the creator. The only small annoyance I see, and gives me nostalgic memories of 1999-2000 when I was a student at the university, was that one still has to define your own event loop and dispatch the received messages, just as one would do on C or C++: For example here (taken from [the dialog example](https://github.com/fjames86/ftw/blob/master/examples/dialogs/dialogs.lisp). (defwndproc find-dialog-dlgproc (hwnd msg wparam lparam) (declare (ignore lparam)) (switch msg ((const +wm-initdialog+) 1) ((const +wm-command+) (switch (loword wparam) (1 ;; text box nil) (2 ;; ok (setf *show-find-dialog-text* (get-window-text (get-dialog-item hwnd 1))) (end-dialog hwnd)) (3 ;; cancel (setf *show-find-dialog-text* nil) (end-dialog hwnd))) 1) (t 0))) I would guess some extra functions or macros laid on top of FTW would help making this dispatch easy, otherwise i would guess it gets a bit cumbersome. Swing, fortunately, doesn't require this (just glue the event handling function to the appropiate control). On the other hand, it's java under ABCL, and i'm getting a major headache: java exceptions somehow "break" the swing facilities and I need to restart ABCL again... 
How's programming GUI in ABCL? Would be interested in hearing more about that.
Layman question: could this be used similar to how the tagged architecture in Symbolics machines worked?
maybe an interesting experiment is to implement a kernel lisp like Symbolics on ARM?
Relocation is not compulsory. We have updated our listing. If you do want to relocate, we will provide a package.
If there are useful things possible, then any Lisp implementation will have a benefit - no need to write a whole OS-level Lisp to verify it. For example the SPARC chip has some kind of tag scheme (more similar to what a Lisp CPU might do, but in a very limited form), which is used by some Lisp implementations. https://news.ycombinator.com/item?id=15208041 
Sure, I'm well aware doing it this way is very old fashioned and not to everyone's taste. But being old fashioned doesn't automatically make it a poor tool (we should know, we are using Lisp after all). And you're right, it should be possible to layer some CLOS over it to simplify some things. But I wanted to keep it small, adding the extra abstraction layer would only be a distraction I think. In any case, it could always be provided in a separate library.
The Symbolics architecture uses tags for two purposes: garbage collection (GC) and (parallel) type checking. I cannot come up with a method where tagged pointers can help to make GC more efficient, but they might very well be useful for type checking. Before the LISP machine era (in the age of the PDP-10), there was an approach to typing celled BIBOP (BIg Bag Of Pages) that assigned a separate segment of memory to each type of object, so the type of an object was encoded in its address. By adding an ARM memory tag to a pointer (like those in cons cells or arrays), you could make sure that the object pointed to would has specific type. Type checking would have no overhead, like on the Symbolics (and probably all LISP machine architectures), which check type tags simultaneously while executing the associated operation. So, yes, this could be interesting.
Maybe you could lessen the impact of the startup time by running two instances of ABCL inside Emacs, so that once you have initiated the restart of one instance, you can switch to the other one and continue right away?
But it's not possible to use it with portacle, is it? 
I think you can just install it on top of your portacle emacs.d.
Hit me up if you need help. Also I'll share this right now: if you're on Windows, disable the line numbering setting in your .spacemacs file, and add a hook for prog-mode that turns on display-line-numbers-mode. The default setting uses linum-mode which is slow as a dog on Windows.
I like your Daemon project, I never knew about it until now. I began toying with RiveScript, creating an interpreter for Common Lisp, this would allow to extend the brain while it is running, and was planning to use [CMUSphinx](https://cmusphinx.github.io/) for speach recognition and [Mimic](https://mycroft.ai/documentation/mimic/) for TTS, however your solution is much better. Too bad it didn't get funded.
Saved for the future!
Thanks. Are you interested in a project collab? I don't have anything particular in mind.
They're really only hiring in one city: Seoul. 
I am open to collaborate, I don't use clojure, if we wanted to use your codebase, but I have some ideas which I think are interesting. I would like to have something that could run in an SBC.
Alright, I got it working by copying the contents of the downloaded spacemacs directory into `.\all\emacsd`, then adding `(load (portacle-path "all/emacsd/init.el"))` to `.\config\emacs-init.el`. It says at the top of that file to "DO NOT MODIFY THIS FILE" so you should probably put the `load` statement in "the dedicated user.el" file once you have Spacemacs set up. BTW, `.spacemacs` will appear in `%APPDATA%` once you've got it set up, so you should do configuration in there.
Yeah, looks like it doesn't work too well. Sorry. Might be worth just installing Evil mode into the portacle distribution and having the nice movement keys without everything else spacemacs gives.
Nah, I don't have the time to learn emacs itself and CL. I could install the components themselves and just use Spacemacs but the configuration isn't easy, is it?
Yeah, Spacemacs takes over your .emacs.d so it would be difficult to integrate with Portacle-- I was mistaken earlier when I thought it would work out of the box. It's worth noting that while Spacemacs is really really nice, it's still just Emacs at the end of the day and you still have to learn it, so it's not a solution to your problem it seems. I will say that I learned Clojure while simultaneously learning Emacs and it turned out alright for me, albeit s bit of a slog for the first 3 or 4 days.
Thanks. &amp;#x200B; I guess this ends my journey through CL land then. I have too much else to do to invest time into emacs just to play around with CL - as interesting as it seems to be.
What's the point?
julia is a mess, and i am tired of hearing about it.
Not Ph. D. level material; hash up of existing ideas.
I can't speak for Simon (the author of the linked article) but think I can explain a bit of the rationale. Invariably when Julia users try and explain to others what makes Julia special, many people turn it into just a conversation about speed because that's the most tangible, easy-to-get-your-head-around selling point that Julia advertises. The common rebuttal then is "why not just use Numba or Python / Cython or ____ language?" When its brought up that Julia allows for much more flexible, easy to build abstractions than is common in other languages the conversation usually devolves into people talking past each other because the Julia users don't believe that ______ language is actually capable of delivering the sort of easy to use but powerful abstractions that Julia offers and the other side of the conversation often either believe that their language of choice *can*, in fact, deliver those abstractions or they don't see the value of those abstractions. So I think the point of this 'challenge' was intended to 1) allow us to see what other languages really can do, and 2) show others what we mean when we talk about the sort of abstractions Julia lets one build. As someone who has always had a soft spot for Lisp, I definitely would like to see a real Lisp guru show more of the Julia community that a lot of the things we think of as radically new and powerful have actually been around in the Lisp world for decades. Besides, I occasionally hear people on this sub voice their regret that they don't get to use Lisp more often. This might be a fun little project for a Lisper who wants to forget about all the Bulb code they have to write at work.
I really like [this piece of music he made](https://vimeo.com/2579694) with the precursor Impromptu Lisp.
Well, I guess there's already plenty Lisp advocacy out there, but the best advocacy is actually shipping high quality code.
https://en.wikipedia.org/wiki/Extempore_(software) 
I wonder how general such a solution would be. I can imagine a way to implement boradcasts, but without typing information guaranteeing that it produces optimal code for something like multidimensional arrays. If your language provides a iterator protocol (like Julia or racket) it is actually quite trivial to implement.
&gt; julia is a mess in which sense? It is targeted to the data scientists who are now using Python, and in all respects it's a better alternative to Python. 
&gt; Well, I guess there's already plenty Lisp advocacy out there, but the best advocacy is actually shipping high quality code. Excellent point. 
I'm not the author but maybe /u/sdanisch can shed some light?
The problem is getting the typing information at macro expansioncompile time. That is vital to be able to produce fast code. Either you require the programmer to supply the info (like specifying matrix dimensions) or the compiler has to do partial evaluation to figure it out (which is actually helps a lot of macros to produce fast code). In the first case, the code will never be as terse as the Julia code, and the second case may be hard to reason about. One thing that helps as well is a JIT compiler, since it can produce hot paths and make the first case feasible. racket's for loops uses that when the type is unknown or unspecified with little performance overhead, whereas my own port of racket's for loops to guile cannot take advantage of that and produces slow code when the programmer did not specify the sequence type. For racket this would be trivial to implement in a way that has no or very little performance overhead over hand-rolled code, but the gain over the for loops (which provides a common syntax for all kinds of iteration) would be marginal. It is, in a way, a shorthand for common use case of the loop macro. 
The CL community lives in `#lisp` on Freenode and the [Lisp Discord server](https://discord.gg/XvVKBwe). CLF has been alive, but mostly inactive as of late.
Thanks for asking ! Actually the site was updated 4 months ago… https://gitlab.common-lisp.net/clo/cl-site/ But nobody's even answering to issues (https://gitlab.common-lisp.net/clo/cl-site/issues) or merging easy PRs. I think this website is doing a mis-service to CL. Anyway, don't miss [lisp-lang.org](http://lisp-lang.org/), libraries on [awesome-cl](https://github.com/CodyReichert/awesome-cl) and [quickdocs](http://quickdocs.org/), and the [CL cookbook :)](https://lispcookbook.github.io/cl-cookbook/) The CL community lives here and in /r/common_lisp.
Thanks for hyperlinks.
Did you mean commonlisp experience or any other lisp could be count as lisp experience ?
^The linked tweet was tweeted by [@DealssZone](https://twitter.com/DealssZone) on Sep 25, 2018 10:28:27 UTC (0 Retweets | 0 Favorites) ------------------------------------------------- The Humble Book Bundle: Learn You Some Code ($463 worth of eBooks for just $15) Buy Now : [https://www.humblebundle.com/books/learn-you-some-code-books?partner=wildlings](https://www.humblebundle.com/books/learn-you-some-code-books?partner=wildlings) \#Programming \#Coding \#Java \#Python \#Linux \#Haskell \#Erlang [Attached photo](https://pbs.twimg.com/media/Dn7sT30VAAAjt6u.jpg:orig) | [imgur Mirror](https://i.imgur.com/rN9dHft.jpg) ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
common-lisp.net is overdue for an update, with auto-updating “news” section from social media. The site volunteers have just been busy/on vacations over the summer. If anyone would like to volunteer to help, please get in touch with me. As was mentioned, gitlab.common-lisp.net is quite active, but that’s not apparent from the front page of common-lisp.net. 
Actually it's even better, it looks like for 8$ you can get the Land of Lisp already :)
As a budding Lisper, Land of Lisp (picked it up in this bundle) has been amazing so far. Worth the purchase.
&gt; libraries on awesome-cl Resources like that should be opinionated if they want to be helpful to newbies. For instance, under implementations, GCL (an incomplete implementation that you should never use) is listed. It's also sorted mostly alphabetically, so ABCL is the first of the listed implementations, even though it is fairly niche and not particularly popular. If was making an opinionated, newbie-friendly list of implementations, there would be three entries: SBCL, CCL, and ECL, in that order. These are also the most likely implementations to work with every library on Quicklisp. Others, of course, might disagree on the specifics, but a debatable opinionated list is better for beginners than a neutral list of (almost) everything. Every category would need a similar rework.
Basically, ["julia is a mess and i am tired of hearing about it."](https://www.reddit.com/r/lisp/comments/9i5mmp/the_julia_challenge/e6hxbvy/)
Thanks, you're right on that category. I hope some others are ok though ;) We now take this approach, to put the most important library first in its category, but we have to state it in a contributing guideline, and to keep an eye open on the old cruft.
Perhaps there should be a way to visually mark popular things on a list so it's obvious that e.g. bordeaux-threads is on top of a list because it's so widely used, not just because it's first alphabetically. It would also make it more obvious which categories need revisiting. A system like that would put SBCL followed by CCL at the top of the implementations list. (There's probably no way to distinguish between the rest because they're very close to each other.) Unfortunately, the last published [Quicklisp stats](http://blog.quicklisp.org/2018/03/download-stats-for-february-2018.html) are from February and those are the only objective numbers that most categories could use.
Because this is spam.
Yeah, I tried to keep this macro as simple as possible. As you can see, I also don't do any shape checks etc, since they would just bloat the core implementation. The macro isn't as necessary, but I find it nice, that the language allows me to prototype such things - and then allows me to offer some syntactic sugar ;) This is especially important in a language targeting very math heavy use cases, where any syntactic noise will further obfuscate the already complicated math ;)
I've found PAIP to be a really great book (better IMO), but is based on classical AI rather than games. [It's available for free on github.](https://github.com/norvig/paip-lisp)
the mailing list for common-lisp.net site is here: https://mailman.common-lisp.net/listinfo/clo-devel
Land of Lisp is worth more than $463. Just the comic strips inside are worth at least $4500 (the price of LispWorks 64-bit Enterprise Edition, which is also a good buy.) 
Inductive definition? Non-destructive modification? Simpler structure sharing? What exactly are "real lists", anyway?
I'm just guessing here, but I think that with cons cells it was easier to implement garbage collection in Lisp Machines back then.
A [proper list](http://clhs.lisp.se/Body/26_glo_p.htm#proper_list) is linear and has nil at the cdr position of the last cell. (compare it to an [improper list](http://clhs.lisp.se/Body/26_glo_i.htm#improper_list).)
I don't see why a single-linked vector implementation cannot have a cdr operator? Just take the second node? Essentially just use cons cells internally, but don't expose cons to the user. I suppose this makes balanced binary trees slightly more cumbersome, but I think that's avoidable.
Lists as connected cons cells with obligatorily "closing" nils is conceptually interesting. It produces strictly binary-branching trees, which I find really cool (but that might just be because I'm a linguist).
So you just want a cons cell to disallow the CDR being anything other than of type list?
You have to store the length of the vector somewhere. When you take the CDR of a vector, you have to store not only the pointer to the next node, but also the new length.
And it must terminate, i.e., there must actually be a last cell.
One slight cost to the venerable definition of type LIST as (OR CONS NULL) is that it is not possible in portable CL to define the concept of a "proper list" of unknown length as a CL type specification. The obvious definition &amp;#x200B; (deftype proper-list () (or null (cons t proper-list))) &amp;#x200B; is prohibited by the ANS dictionary page for DEFTYPE because it requires recursive type expansion to terminate.
Except that NULL/NIL can be a member of the list (in a car position). How would you model that in a null-terminated vector?
See Clojure, where lists are not built out of cons cells. I think it it because building lists out of cons cells (ie. 2-element sequences) makes taking car / cdr really cheap, and that was a requirement in the past. "Proper list" is defined as a lisp-style list (ie. built out of cons cells) that properly ends in an empty list (or nil). So, proper lists by definition are not primitive. More Lisps with list defined as a generic sequence would be nice, though.
We would prefer the travel, but if you’re strongly qualified, that is more important.
Clojure, where the complex implementation of 'lists' (aka persistent sequences and similar) is hidden.
&gt; In fact, The car/cdr functions originated with the instruction set architecture for the IBM 709 (first released in 1954!) Almost! The IBM 704 (on which LISP was first implemented) did not have a CAR or CDR instruction. It did have instructions like PAX (Place Address in Index) or PDX (Place Decrement in Index), though, which allowed to implement cons cells very efficiently. A register was 36 bits wide, the "address" and "decrement" fields were 15 bits wide and available memory was up to 32K (2^15) 36-bit words. The words CAR and CDR (apocryphally) meant "Content of Address part of Register" and "Content of Decrement part of Register". And, yes, cons cells were originally used to implement pretty much everything in LISP, from atoms (symbol) to flonums, EXPRs, SUBRs (which linked to machine code), etc. The LISP 1.0 manual is full of interesting details.
&gt; And, yes, cons cells were originally used to implement pretty much everything in LISP, from atoms (symbol) to flonums, EXPRs, SUBRs (which linked to machine code), etc. Not sure if that is really correct. The first implementations (ab)used Symbols in many places. Flonums were symbols, but did they store float numbers as conses? Don't think so.
What do you want your function to do?
It seems that your function is counting the occurrences of `a` inside a list. There is a built-in function for that, [`COUNT`](http://clhs.lisp.se/Body/f_countc.htm). (count 'a '(1 2 a 3 b c a 8 4 a 0 a b f i t a)) ;=&gt; 5
 (defun checkA (lst) (if lst (+ (if (eql 'a (car lst)) 1 0) (checkA (cdr lst))) 0))
So flaming_bird gave you the "right" answer but answering your question, recursive functions will always look something like this: 1. check for end 2. move closer to end (for example, process the head of the list and increment the count if it's an 'A' 3. recursively call the function with the work left to do, in this case the rest of the list Don't use setf and setf, pass state through recursion, in your case have two parameters to checkA, lst and count. If checkA is called with just a list then default count to zero. 
TCO version: (defun checkA (lst) (labels ((checkA% (lst count) (if lst (checkA% (cdr lst) (+ count (if (eql 'a (car lst)) 1 0))) count))) (checkA% lst 0)))
I'm not so sure, for example when I learned the easiest concepts, I learned them fastest from the code alone not from the lengthy explanations.
Yeuch. You need more duct tape and a couple of nails to hold that together. 
Yes this chain of codes, where I can compare language constructs, would have helped me immensely in the beginnings.
LISP 1.0 kept flonums (both literals and results of computations) in a separate list, where the property list of each flonum was decorated with the NUMB and FLO indicators. Only positive numbers were stored under the FLO indicator and negative numbers had an additional MINUS indicator. (See LISP 1.0 Programmer's Manual, pg 92ff.) So the (positive) value of a flonum was probably stored as a single 36-bit entity, but without the NUMB, FLO and (optional) MINUS indicator, it was not a valid flonum. BTW, when you read about "association lists" in the LISP 1.0 manual, it denotes what is now known as property lists. To make confusion complete, alists were called P-lists (pair lists). This is probably the reason why official LISP history starts at LISP 1.5. ;)
How can a non-lisp programmer judge if lisp code i high quality? Maybe compare lisp code with code in other language. To decide how much effort it's worth to put in to learning lisp it should be some code that can be used as comparison to other languages.
 (defun check-a (list) (if (endp list) 0 ;; No "a"s in the empty list ;; Otherwise ;; break into pieces (let ((nibble-off-a-little-bit (car list)) (save-rest-for-later (cdr list))) (let ((little-calculation (if (equal nibble-off-a-little-bit 'a) 1 ;We've found one "a" 0 )) (by-the-magic-of-recursion (check-a save-rest-for-later))) ;; combine our little calculation ;; with the big magic calculation (+ little-calculation by-the-magic-of-recursion))))) 
 (defun check-a (list) (if (endp list) 0 ;; No "a"s in the empty list ;; Otherwise ;; break into pieces (let ((nibble-off-a-little-bit (car list)) (save-rest-for-later (cdr list))) (let ((little-calculation (if (equal nibble-off-a-little-bit 'a) 1 ;We've found one "a" 0 )) (by-the-magic-of-recursion (check-a save-rest-for-later))) ;; combine our little calculation ;; with the big magic calculation (+ little-calculation by-the-magic-of-recursion))))) 
Well, lists built with cons cells were in lisp since its inception. AFAIK this was *in part* an historical accident due to the fact that the original machine in which lisp was developed (an IBM 7090 if I remember correctly) had the ability to store and access easily two pointers plus some tag fields. Actually, the idea of having cons cells composed of two pointers (with all the implications, like dotted pairs that are not proper lists) was not fixed, at least in the early lisps: &gt; [...] when the computer has 48, 60, or 64 bits per word, there is room for *three* pointers in a single word: and some LISP systems actually use this organization in their own special way (From W. D. Maurer, The Programmer’s Introduction to LISP, page 93, 1972)
There is an older paper by McCarthy called [An Algebraic Language for The Manipulation of Symbolic Expressions (1958)](http://www.softwarepreservation.org/projects/LISP/MIT/AIM-001.pdf). This is older and not as well known as his "Lisp paper". It describes a precursor to Lisp which has a whole "zoo" of accessor functions: *3.2.2. Next we have the reference functions which extract a part of the word in the register whose number 1s the argument. These functions are cwr, cpr, csr, eir, cdr, ctr, and car. For example, car (3) is the 15 bit quantity found in the address part of register.*
&gt; where the property list of each flonum Flonums were a kind of symbols, where the symbol property list was used to store the value. 
[https://en.wikipedia.org/wiki/Information_Processing_Language](https://en.wikipedia.org/wiki/Information_Processing_Language) by Newell, Shaw, Simon 1956 also used lists as a primary data structure but was not at all like lisp. 
**Information Processing Language** Information Processing Language (IPL) is a programming language created by Allen Newell, Cliff Shaw, and Herbert A. Simon at RAND Corporation and the Carnegie Institute of Technology at about 1956. Newell had the job of language specifier-application programmer, Shaw was the system programmer, and Simon took the job of application programmer-user. The language includes features intended to help with programs that perform simple problem solving actions such as lists, dynamic memory allocation, data types, recursion, functions as arguments, generators, and cooperative multitasking. IPL invented the concept of list processing, albeit in an assembly-language style. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Honestly all of Friedman's books are incredible. 
In that case, I'll go ahead and apply for the opening. I'll attach a letter describing relevant work and the limitations that affect my ability to travel, and we can proceed from there. Thanks for your encouragement.
\_The Little Schemer\_ taught me to not fear recursion. :)
The problem is not _being new to Lisp_, it's the imperative thinking. Learn the way of the functional programming with books like SICP, The Little Schemer and/or any book on FP, and you'll be very close friends with recursion.
I thought to post this here being that at the moment, for Common Lisp 1. Only SBCL is supported at the moment 2. Using the tool only disassembles the `main` function a program. Maybe some of you here would be interesting in help with the support for Common Lisp, and *possibly* add support for Schemes. I, myself, am not knowledgeable enough yet to contribute. I certainly would like to, and maybe making use of this tool will give me the knowledge I need in order to contribute.
Im not sure i understand what your asking. If you asking 'can I use :foo as a function name?' the answers yes. The other way I could interpret your question is 'can I recursivley call a function in the argument list of the function definition?' then I have no idea, but I suspect not.
can I call (:arbitrary-keyword-thats-never-been-interned-before some-a-list).
In Clojure, keywords are functions, because (I think) they implement the IFn interface. When they are used as functions, they look themselves up in the data structure given as the first argument. 
There should be support for clisp too currently. I'm currently just using `(disassemble 'main)` to get the disassembly. Unfortunately, the output is not standardized at all, which makes sense as different implementations have different outputs. If anyone knows a way to get debug info from the output of `disassemble` to the original source (or a way to disassemble files), let me know. I'd be happy to have that even just for sbcl, as that compiles down to assembly. The limitation on CL implementations is mainly because I couldn't find equivilant flags between them all. Ideally, I need a command which will load a file, disassemble it, and output it to stdout or a file. [here is where the parsing for that is](https://gitlab.com/jgkamat/rmsbolt/blob/master/rmsbolt.el#L350-367), it should be pretty easy to add support for more implementations that have similar flag support.
&gt; A godbolt embedded in Emacs i luv u, professor sexy time
so: 1. newlisp dosen't seem to have `disassemble` at all, so we can't use that. 2. Clasp seems like the best next target, but I couldn't find it in the debian,arch, or gentoo repos, so I might have to spend a bit more time getting that installed. 3. I think I had the same issue with CCL as well. Maybe I could write a script in ccl to do the actual disassembly 4. ECL/ABCL scare me and probably won't work :P. I don't think ABCL will work much unless the `javap` tool can be used on it's output (and if so, it probably will work just fine!)
lol I didn't make this, u/jgkamat did.
This is a little tricky because Clojure is a Lisp-1 while CL is a Lisp-2. So you would either have to define a function for each keyword, which seems undesirable. To one way achieve this would be to modify the reader so that when it interns a keyword it defines the corresponding function. I can't think of an easy and portable way to do. Maybe you could use Eclector make this approach work? An "almost there" approach would be to take advantage that lambda forms in the function position are applied. So you could write a macro that takes a hash-table and sets up a macro for each key that expands into a lambda form that that retrieves the key with the same name as the macro from the argument. The gist of the idea would be something like ```lisp (defparameter +ht+ (let ((ht (make-hash-table))) (setf (gethash :foo ht) 5) ht)) (macrolet ((:foo (ht) ;; Note the extra surrounding parens `((lambda () (gethash :foo ,ht))))) (:foo +ht+)) ;; =&gt; 5 ;; here with-ht would wrap the body with the appropriate macrolet (with-ht (ht) (:foo ht) ```
In regards to ABCL, I found [some useful info on CLiki](https://cliki.net/ABCL). 
i luv him 2 then
Not directly answering, but possibly helping a "I don't like how to access data structures in CL so far": you might like the [access](https://github.com/AccelerationNet/access/) library, which is consistent and generic for all data structures, and helps for nested ones. See also [this blog post](https://lisp-journey.gitlab.io/blog/generice-consistent-access-of-data-structures-dotted-path/).
Awesome! Thank you for the link and recommendation!
Thanks! I'm actually fine with standard CL on this. I'm curious in the abstract and I'm now wondering how clojure implements this.
It'd be interesting to hook this (or pull ideas/code) into [slime-disassemble-symbol](https://github.com/slime/slime/blob/master/slime.el#L4196) this that would fit into the Lisp development workflow much better.
i tried slimv briefly. now i just do something like `rlwrap --histsize 1000000 sbcl` then ctrl-alt-j and and i can use vi cursor positioning, editing, have history, etc. what am i missing by not using slimv (or slime) and this flight-recorder? i'm ready to be convinced to change my REPL ways.
rlwrap is an external program that adds some clisp niceties. I had also seen in cl dated dribble files. echo `date` rlwrap can also do fixed file of competitions. There are IDE \ cl macs , hemlock for dynamic completion based on package, try harder for out of package.
I got partway there in clclojure. Inside a clojure eval context, with keyword literals, I scan the body for call sites. From there, I construct functions (keyword accessors) bound to the function namespace (surprisingly it works). [Here](https://github.com/joinr/clclojure/blob/master/keywordfunc.lisp) I use this automatically inside unified-let contexts for [unified lexical scope](https://github.com/joinr/clclojure/blob/master/lexical.lisp). This doesn't work outside of macros, needs a custom read eval to extract arbitrary kw calls....or even better, like clojure dies, allow a function protocol for anything to participate in.
Eclector looks slick.
Change your intern &amp; format statements, and it works just fine. &amp;#x200B; CL-USER&gt; (defvar \*ht\* (make-hash-table)) \*HT\* CL-USER&gt; (setf (gethash :foo \*ht\*) 'bar (gethash :bar \*ht\*) 'baz (gethash :qux \*ht\*) 'foo) FOO CL-USER&gt; (defun keyword-reader (stream char) (declare (ignore char)) (let ((kw (intern (format nil "\~:@(\~A\~)" (read stream t nil t)) "KEYWORD"))) (unless (symbol-function kw) (setf (symbol-function kw) (lambda (ht) (gethash kw ht)))) kw)) KEYWORD-READER CL-USER&gt; (set-macro-character #\\: #'keyword-reader) T CL-USER&gt; (:foo \*ht\*) BAR T CL-USER&gt; :foo :FOO
It works just fine if you upcase the string &amp; intern into the keyword package. ``` (defun keyword-reader (stream char) (declare (ignore char)) (let ((kw (intern (format nil "~:@(~A~)" (read stream t nil t)) "KEYWORD"))) (unless (symbol-function kw) (setf (symbol-function kw) (lambda (ht) (gethash kw ht)))) kw)) ```
If this is as an exercise, then others here have given good answers. If it's for something else, just use `position`.
No idea, but I'm working through SICP and it uses MIT Scheme 
Agreed - if you're looking to diversify, CL and Clojure are radically different beasts. I have a soft spot for Racket it's not going to teach you much Clojure hasn't already.
+1 for Common Lisp. It seems to be the most complete option, especially if your purpose is to learn. I find CL very enjoyable btw
[Practical Common Lisp](http://www.gigamonkeys.com/book/) is free and a good start. The only part that is truly out of date is the getting started with "lisp in a box" part. [Portacle](https://portacle.github.io/) is the easiest to get started with setup these days. 
Picolisp
I'll second Common Lisp, and for pointers: - http://lisp-lang.org/ and its success stories ([music](http://lisp-lang.org/success/music/) category: OpusModus) - [awesome-cl](https://github.com/CodyReichert/awesome-cl) - the [Cookbook](https://lispcookbook.github.io/cl-cookbook/) (I'm pretty active on those two) - we recently saw [Music](https://github.com/MegaLoler/Music) framework, [CL Music](https://ccrma.stanford.edu/software/clm/), [a list](https://github.com/defaultxr/cl-patterns/blob/master/doc/other-libraries.org) of audio libraries… and there may be much more. - last: if as a beginner you're surprised about how Quicklisp works, take time to [understand its benefits](https://lisp-journey.gitlab.io/blog/why-do-we-have-to-wait-one-month-before-quicklisp-updates/) upon more traditional package managers (hint: closer to apt than to npm, fortunalety). Have fun :)
Cool, I was thinking of ordering that. thanks
Since you mention music let me suggest Common Lisp, which has an important tradition in musical domains: pwgl, openmusic, opus modus, slippery chicken, and others already mentioned. Cl-collider is a CL client to Supercollider in active development - a great library for live coding and interactive experimentation. CL also benefits from a large (in lisps proportions) number of libraries, places to get help, books, etc. Scheme can me useful for Lilypond, though. 
Thanks, that's very helpful. 
I have thought about learning CL sometime. I don't have a strong enough reason yet. I know Clojure pretty well. I'm just curious about a few things that I think I will find annoying about CL. For example that `&gt;`, if I understand it correctly, is only for numbers. In Clojure, one can use `&gt;` to compare anything. Same with `=`. Similarly, `first` can be used to get the first element of any data structure. But getting an item from CL data structures differ, right? For example `car` is only for lists, right? Isn't this stuff annoying, and makes writing general functions more difficult?
Common Lisp has a lot of good books published in the last decade: Common Lisp recipes, Interpreting Lisp, Practical Common Lisp, Let over Lambda, Successful Lisp, Funktionale programmierung und metaprogrammierung (German). The classics like Ansi Common Lisp and On Lisp are still good. Generally, there is better documentation, libraries etc. for Common Lisp than for other Lisps.
See also https://ccrma.stanford.edu/software They have a mixture of music software written in Common Lisp and Scheme. IIRC Common Music was originally written in Common Lisp but most recent versions are a mixture of C++ and Scheme. 
You might want to check Chicken Scheme, here's a quick review of the dev workflow with Emacs and the REPL: https://www.youtube.com/watch?v=eXB3I3S3vJc
I would recommend Racket over anything else. &amp;#x200B; 1) It is designed to help people learn Lisp/Scheme 2) Documentation is best of any language ever 3) The brain bank of the community is a who's who in Lisp 4) The library and infrastructure is the best 5) Deployment is a press of the button and I have an executable. Haven't had any surprises yet in my builds
I dont think car works for vectors. &amp;#x200B;
Fully generic functions in Common Lisp would be usually CLOS functions. Common Lisp does not use CLOS in its more low-level functions. Especially functions like &gt; and = are seen as numeric predicates. They are not general comparison function. Traditionally it's thought that numeric-&gt; and spaceship-&gt; are two different functions. They might both compare things, but otherwise they are unrelated and thus they need to have different names or have to reside in different namespaces.
Spaceship-&gt;?
Coming from python, I had this concern before actually starting to write some code, and it turns out it doesn't buffer me at all. AFAIU it's actually a strength for SBCL to perform many welcome type checks. And indeed, writing generic functions with CLOS is nice (and a relief, coming from python). `first` doesn't work on vectors and that has annoyed me a bit though. Now much less since I use classes instead of nested data structures. [cl21](https://lispcookbook.github.io/cl-cookbook/cl21.html) fixes inconsistencies, but it isn't very active unfortunately.
The fact that there's not a set of interfaces/protocols for things like equality, ordering, etc. isn't a major pain point but I do think it's a detriment to the language. The way to impl. interfaces would be through generic functions, these do ad-hoc dispatch on the types of their arguments.
&gt; how to have Spinneret placed the generated HTML files in a /public directoy AFAIK Spinneret doesn't produce html files, it returns html on the fly. Would you create a repository, so than we can try out everything ? (Not an expert on CL web dev. I'm turning to [Weblocks](http://40ants.com/weblocks/quickstart.html), very promising and active) Not to distract from learning this stack, but for blogging/personal sites did u see https://github.com/kingcons/coleslaw ?
&gt; Other than with eval, is it possible to define a setf expander where the access function is evaluated? i.e. pass variable KW so that :FOO is defined? This should work: (setf (fdefinition `(setf ,kw)) (lambda ...))
&gt; AFAIK Spinneret doesn't produce html files/there is no need to, it returns html on the fly. Ah, so does [LASS](https://github.com/Shinmera/LASS) do that too? Because I would like to organize all the stylings like how one would with Bootstrap, Bulma, etc. i.e. like a `/mixin` folder, `_variables.scss`, things like that. &gt; (Not an expert on CL web dev. I'm turning to Weblocks, very promising and active) That looks neat, but I'll have to check that out another time. I think for the blog I might just have a `blog.my-site.[com/io/whatever]` and use Coleslaw for blogs.
Yeah, "equivalent" is the wrong word. My point was that `(elt list 0)` works like `car` on lists, but is more generic.
It's available free online here: [http://www.gigamonkeys.com/book/](http://www.gigamonkeys.com/book/)
I’m putting together a similar stack but using snooze rather than ningle, adding a few things like a macro for adding Ajax server actions via an ajax handler in the spinneret DSL. I was toying with writing a minimal component framework (but smaller than weblocks)
Gerbil scheme hands down.
I love Common Lisp, for what it's worth. It seems anything is possible with it. 
&gt; AFAIK Spinneret doesn't produce html files Indeed, but it does write to a stream, `spinneret:*html*`. Having the output saved in files is achieved by wrapping the call to `(with-html ...)` with `with-open-file`. ```lisp (with-open-file (*html* #P"/path/to/file" :direction :output) (with-html ...)) ```
6pm UTC happens when this comment is 11 hours and 8 minutes old. You can find the live countdown here: https://countle.com/4JpMuX_-3 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Good luck! I've played with CL-AUTOWRAP just a little bit before, and I've used it in https://github.com/phoe/cl-lzma - perhaps you could use this code of mine as an example of successful autowrap usage in your video.
 [package cl-cookbook]........... ; compiling clos.md no warnings thanks 
Don't know how this section looked before, but now it is great!
No discussion of finalization, which crops up in inheritance 
thanks! 
thanks, fixed the most important ones for now.
Alternatively, you can use `&amp;REST` with `&amp;KEY` to get the whole lambda list as a parameter in your function. CL-USER&gt; (defun bar (&amp;rest rest &amp;key foo bar baz) (list rest)) BAR CL-USER&gt;(bar :foo 1 :bar 3 :baz 777) ((:FOO 1 :BAR 3 :BAZ 777))
[TRIVIAL-ARGUMENTS abstracts over that function, too.](https://github.com/Shinmera/trivial-arguments/blob/master/arguments.lisp#L73)
First of all thanx for all your replies. None of the solutions works in my environment (which should be based on common lisp)… I got no package called "ARG", no functions called "function-lambda-list"; I walked over all symbols and packages I can access finding some commands (WALK-ARGLIST, for example) but I could not understand how to use them. The best I got when I found out a function called EXTRACT-LAMBDA-LIST which doesn't work when dealing with compiled functions: (EXTRACT-LAMBDA-LIST (symbol-function 'my-uncompiled-function)) -&gt; works fine; (EXTRACT-LAMBDA-LIST (symbol-function 'my-compiled-function)) -&gt; '#&lt;compiled-function&gt; is not of kind list.
 (function-lambda-expression (lambda (&amp;key x) x)) may sometimes work, but not guaranteed. 
&gt;I don't think so. I think this is entirely optional and adds no value by default. SLIME displays the initargs for a MAKE-INSTANCE. The required arguments argument is also only valid in the primitive case of a bunch of always required arguments. There are code bases / libraries which mostly don't use them. For example LispWorks' CAPI. People define them to avoid exposing implementation details to users of your library. This way if you decide to use a list of conses for example rather than your CLOS implementation, the users don't have to change their code to remove make-instance calls
Yes, forgive me mate, gave u the wrong indication: I meant I have no ARG package in my default system, and no "function-lambda-list" as well; once I load the trivial-arguments code the package is correctly defined but the "function-lambda-list" not yet, causing arg:arglist function failure...
It should mean that your "environment, which should be based on common lisp)..." is none of the supported CL implementations: #-(or :abcl :allegro :ccl :clasp :clisp :cmucl :corman :ecl :lispworks :sbcl :scl) (warn "TRIVIAL-ARGUMENTS NOTICE: Your implementation is not directly supported. Falling back to FUNCTION-LAMBDA-EXPRESSION.") ... and doesn't have the "function-lambda-list" either?
Thanks!
I can find it in youtube ? did it the session happen ? Thank you! PS : Your little bit of lisp I really informative and fun to watch !!
up for me 00:14 utc
I am gradually trying to let Racket grow on me, coming from Common Lisp. It works surprisingly well. 
I forgot about racket, probably should have been it's own category.
Well, it's a *Scheme dialect*, after all. (A mutated one, that is.) 
It sucks that Racket &amp; Clojure programmers don't hang out here as much as CLers do.
Yeah I know it's somewhat of a scheme dialect but I feel it's different enough to warrant it's own category. It seems to have slightly different aims than most schemes
It seems to be influenced by business needs, it comes with a GUI library and a decent web framework (including a webserver), but it still maintains a compact syntax. Rather nice, actually.
thank you :-) again.
Yeah, this subreddit is not representative of all lispers.
Here it is https://youtu.be/BL9MiiCcETM
I didn't think this was funny until I got to the picture for Factor, and then I totally ROFLed.
is that dr. bronner's for emacs-lisp? lol
The Ruby one is also gold. Such awkwardness!
Yes. It shows how it's built on a relatively simple and elegant foundation but is surmounted by top-heavy rails.
Tom Cruise’s Scientology lanyard has the same colors as the Clojure logo... what does this mean?..
Scientology is a Clojure macro 
It's the only Lisp/Scheme I've ever seen where there are parts of your program you can't change after it gets compiled (namely, anything loaded with `require`). 
TCL has more in common with the Bourne shell than it does with Lisp: * Variables work by string substitution, which happens before parsing the syntax of each line of code. * The `"` operator is analogous to the Bourne shell's `"` operator. * The `[]` operator is analogous to the Bourne shell's backtick operator. * The `{}` operator is analogous to the Bourne shell's `'` operator. * The use of whitespace for separation of arguments is more like the Bourne shell's use of whitespace than like Lisp's. * All the other operators work like those in Bash and Unix too. For example, `expr` is basically the Unix `/bin/expr` command. 
I never knew that was a thing, it has a surprising number of features. I highly doubt anyone has written good lisp plugins for it though.
Why not use something like Ranger and use Emacs as the default editor? That way you get proper separation between tools and you can switch editors when the time is right. I have recently switched to LEM instead of emacs for text editing and it works well.
I used Emacs as my default editor with Midnight as well. But then I decided to give a try to Midnight's editor, and actually I really liked it. It opens ups really fast, very lightweight, instantly responsive, its overall feel, interface and hotkeys are inline with the rest of midnight commander's working style. I know Ranger, but why would I give up on Midnight? I can just use Midnight and Emacs instead but my problem with Emacs is that it's much more than just editor and has a very different feel (and hotkeys) than those of Midnight Commander.
If you see Midnight Commander in the cocktail drink menu, you must be in a gay bar.
Oh! I see what you are asking now. Got it. 
If you're willing to try it the other way around, there's [Sunrise Commander](https://www.emacswiki.org/emacs/Sunrise\_Commander), which imitates MC from within Emacs.
Since the only arguments you pass to `poligon` are points, it would make sense to use `&amp;rest` arguments. (defun poligon (&amp;rest points) ...) (poligon (point 40 90) (point 67 60) (point 80 132))
This is close to what I want, but I would like to have everything being evaluated by default, instead of needing to put the comma on every expression to evaluate it. &amp;#x200B; I'm tempted leave it as a heterodox Lisp dialect since I want to use it as a JSON alternative. ;\~
I'm afraid you'll have to use the list function in this case. If you're looking for a JSON alternative, Clojure's EDN might be of interest. It's basically a more defined, extended type of S-expressions. It looks like: ```clojure (this-is-a-symbol inside-a-list ["string in vector", "comma is whitespace"] {:key1 "keywords in hash tables"}) ```
I put more thought, you are right. But I think that borrowing \[ \] isn't such bad idea either. &amp;#x200B; I'm not looking for, I'm trying to create a JSON lightweight alternative, I cannot compete with armed bear/kawa/clojure. 
You are right, but using \[ \] isn't a bad idea either... &amp;#x200B; :)
Clojure is written in edn, but edn isn't clojure. Edn is just a much better JSON like you're looking for
&gt; use '( ... ) as a list constructor It's not a constructor, it's the list itself as a literal object.
Nice. I guess that sticking to Clojure'EDN would allow my library to be more interoperable with Clojure programs. I'll put this into consideration, thanks for letting me know about this.
Well, yes. &amp;#x200B; Thanks for the patience! 
QUOTE isn't a list constructor. LIST is a list constructor.
And all the other languages that have EDN support: https://github.com/edn-format/edn/wiki/Implementations More importantly, I looked at your initial link, and your example would actually be written in edn like this: ```clojure #polygon[#point[40 90] #point[67 60] #point[111 79] #point[80 132]] ``` Now each client of your application can define how #point and #polygon get implemented in their language. For example in Java you could define that #point gets given to the Point class constructor. Pretty neat, eh? 
I prefer the original version (Star-trek themed.)
Thanks for your comment. So I can do this in Common Lisp (a reader macro) as a (list ...) shorthand. Cool! I was looking for something already existent as I confused '(...) as a list constructor. &amp;#x200B; I was wanting to avoid \[ \] since I didn't want to cross paths with Clojure. But thinking a bit more about, borrowing the \[ \] from Clojure isn't that bad. It also was very easy to implement in my grammar: &amp;#x200B; form ::= self_evaluating_form:f {: RESULT = f; :} | list_form:f {: RESULT = f; :}; self_evaluating_form ::= INT_LITERAL:i {: RESULT = new IntForm(i); :} | DOUBLE_LITERAL:d {: RESULT = new DoubleForm(d); :} | STRING_LITERAL:s {: RESULT = new StringForm(s); :} | ATOM:a {: RESULT = new AtomForm(a); :}; list_form ::= OPEN_PAR form_list:l CLOSE_PAR {: RESULT = l; :} | QUOTE_OPEN_PAR form_list:l CLOSE_PAR {: RESULT = new ListForm( new AtomForm("quote"), new ListForm( l, ListForm.NIL ), parser.environment() ); :} | OPEN_BRACKET form_list:l CLOSE_BRACKET {: RESULT = new ListForm( new AtomForm("list"), l, parser.environment() ); :} | OPEN_PAR CLOSE_PAR {: RESULT = ListForm.NIL; :}; form_list ::= form:head form_list:tail {: RESULT = new ListForm( head, tail, parser.environment() ); :} | form:head {: RESULT = new ListForm( head, ListForm.NIL, parser.environment() ); :}; &amp;#x200B; &amp;#x200B;
Among other things, the new site features: - A site generator implemented in Common Lisp. - A gitlab pipeline for automatic deployment. - A new responsive design based on Bootstrap and new content. - (and most importantly a random quote at the footer :) ) thanks and congrats to Mariano Montone and the author maintainers. 
I find the color scheme a little bit hard on the eyes. But that's not important.
Nice! Thank you for all the hard works! The new version looks very nice, IMHO.
It would be nice to mention quickdocs.org in section Libraries on page https://common-lisp.net/downloads
Really I come here after lispm tweet about the site. The new look is breeze. Then I decide to come here. (and to contact you too). But, kaboom. You are one of the team behind this. Congrats!.
I don’t think they’re meant to be compared. This one is orthogonal. 
&gt; You are one of the team behind this not quite, I followed along and made a couple simple pull requests. &gt; kaboom yeah !!
Looks great!
Great work! New site looks amazing, i think it'll serve well for common lisp community
On Hackernews: https://news.ycombinator.com/item?id=18192614
Looks very nice, nice colors, nice look.
I notice LispWorks is not mentioned anywhere on the implementations page. Is that a failure on their part to contribute, or a conscious choice? 
Check again. 
The people who tell you to use macros sparingly are talking to you as someone who doesn't *know* Lisp yet - like you're uninitiated. Beginners tend to use macros in the wrong places, so the easiest advice is just to write fewer macros until they know better. But you're right, code-as-data doesn't really matter unless you do something with it, and macros among the easiest things to do. The example of code as data outside of macros I try to give is about how easy serialization is - 'code is data' &lt;=&gt; 'data is code', but you're right that all of these things can be expressed in other languages, and many languages do pretty well without 'code is data'. The line between 'writing Lisp' and 'defining a DSL and using it' is a fine one; I think that many more experienced Lispers (more experienced than myself, at least) see this as the defining characteristic of Lisp, and start to think of their workflow in terms of 'define a DSL that solves my problem' -&gt; 'apply my DSL' rather than in terms of objects interacting with each other, like in Java/C++/C#, or in terms of functional transforms on data like in OCaml/Haskell/F#, and just like defining classes of objects or complex recursive algorithms to solve a simple problem seems silly, "defining" a "DSL" to solve a simple problem seems pretty silly.
&gt; But that's not a new language, it's two god-damned functions. You missed the fact that it includes a new syntax for time constants (`20:00` is not a valid literal in common lisp). It's a very minimal DSL, but I think it does qualify. C++ now has custom literal formats as well, but you can change the syntax both more easily and in more ways with lisp. For a crazy example of how flexible it is, [someone implemented C as a DSL for common lisp](https://github.com/vsedach/Vacietis). This isn't just a C compiler implemented in lisp, but rather it modifies the lisp reader to the point where the builtin `READ` and `LOAD` functions can be used on C code. A much simpler and real-world-useful example of a very small DSL is here: https://edicl.github.io/cl-who/#example The 3rd example includes the listing that it expands to; note that no non-standard functions are part of the expansion, but consecutive string constants are folded together into write-strings and yet you can use lisp's native control flow interspersed with generated html. This happens at compile time, and is obviously not doable with functions. When I say it's simple, I mean anybody who has been writing lisp full time for a year could make something similar in a day, and it's a relatively simple exercise to write one. &gt; And then proclaims that lisp is awesome because he just added a custom exponentiation operator. But that's not fair. He didn't add a new operator. Lisp doesn't even really have operators in the same sense as C++. He didn't define a new "operator"- he just defined a function with a name that's not allowed in C++. I wasn't impressed. Yes and no. The lack of infix operators in lisp means that you can very easily add functions that look like native operators. This isn't a big deal, so it's fine that you're not impressed. &gt; The other piece of the puzzle for me is the concept of reader macros. Everyone talks about writing DSLs in lisp, which seems like maybe they're using macros. But then, everyone (else?) says to use macros sparingly, if at all. So, are there just two camps of lispers? Are they talking about different things? Does lisp's "code is data" property even matter if you don't exploit it via macros? The more correct form of the advice is "Don't write a macro when you can write a function." Note that this is "write" not "use." Using macros is done all the time; I use the standard `LOOP` macro for iteration, but many people prefer the macro `ITERATE` which is provided by a library. While implementing an iteration library entirely with functions is not impossible (consider e.g. python's itertools), it comes with both performance and usability impacts, so writing a macro for this is fine. Some more evidence that it's not two camps of "macros are awesome" and "don't use macros" but rather exist in tension as an engineering tradeoff can be found in this quote about a specific project: &gt; The source code of the Viaweb editor was probably about 20-25% macros. Macros are harder to write than ordinary Lisp functions, and it's considered to be bad style to use them when they're not necessary. So every macro in that code is there because it has to be.
Here's an example of a macro that IMO adds a new exception-handling operator to Lisp: https://github.com/tarballs-are-good/quickutil/issues/56 Once that macro is defined, you can write this: ``` (handler-case* (some-code-that-might-throw-exceptions) (t (exn) :after-unwind (handle-the-error exn))) ``` As shown, it has the same semantics as `handler-bind` (which are the same semantics as `try` and `catch` that you're familiar with from C++). But if you replace `:after-unwind` with `:before-unwind`, then the exception handler runs *before* the stack unwinds, and so *before* any cleanup forms in `unwind-protect` handlers. Also, `:before-unwind` is what you want if you want to use [restarts](https://z0ltan.wordpress.com/2016/08/06/conditions-and-restarts-in-common-lisp/) in your error handling. The `:before-unwind` keyword is implemented with `handler-bind`, which has radically different syntax from `handler-case`, but `handler-case*` abstracts that away. The only visible difference is *when* the form after `:before-unwind` or `:after-unwind` executes. 
&gt; And then proclaims that lisp is awesome because he just added a custom exponentiation operator. But that's not fair. He didn't add a new operator. Lisp doesn't even really have operators in the same sense as C++. He didn't define a new "operator"- he just defined a function with a name that's not allowed in C++. I wasn't impressed. I'm no Lisper, or C++er, but isn't that part of the point he's making? C++ was designed in a way that means you can't write C++ code to extend the C++ language, and Lisp was designed in a way that you *can* code with Lisp to extend Lisp. When you do, your added Lisp operator looks and behaves like all the rest of the language. When you add function calls in C++ they look and behave differently, you would not confuse them as being "part of the C++ language". "*he just defined a function*" - exactly! The thing which is "nearly impossible" in C++ and Python is "just" a triviality in Lisp, barely worth mentioning, and so trivial it's even hard to pick out and explain. Therefore Lisp has a nicer design. By simply being a function like everything else, your new exponentiation "operator" can be used to reduce a list - compare to Python where you can `a ** b` for exponentiation, but if you want to use it to reduce a list you need to use `import operator; reduce(operator.pow, myList)`, because the operator is special and different. I don't think you can add custom operators in Python so if you want your own math operation it will look different again and be a function call. Once you've defined `**` in Lisp it's not "an operator separate from a function" which needs special casing and special case treatment, it's just another function call, which is just like everything else in the language. And that ties in to your first point about a DSL - if your language is `(function &lt;args&gt; &lt;params&gt;)` then a Domain Specific Language stops being about "how can I write my own programming language from scratch which is good for &lt;domain&gt;" and starts being as simple as "how do I name and implement functions helpful in &lt;domain&gt;". Instead of being "TradeScript++ written in C++" which took you a month to make a compiler and interpreter, it's "CoommonTradeScript written in Lisp" which took you a few hours, *and* it's "Lisp-tuned-for-trading" which means your "new language" has all the power of Lisp, unlike TradeScript++ which doesn't have any of the power of C++. Because the Lisp REPL is reading what you type as text, and parsing it into Lisp, and running it, all the time, you have access to that parser and interpreter, so why not use it? Make your CommonTradeScript look like Lisp and now you can simply read a file, evaluate it, and print the result, and .. voila, your own Lisp-language for trading with. Could you write a C++ program which reads a C++ file and runs it? "but it's not a different language" - exactly! You *could* define TradeScript++ with curly braces and strings quoted with angle brackets and then spend ages writing a parser and an interpreter and tooling to handle that .. and then have to learn to use it .. and then find desirable features and keep implementing them as you need them .. but why *would* you choose to do that when you have a Lisp parser and interpreter right under your fingers? Choose to make CommonTradeScript as a dialect of Lisp and then you can define a couple of functions and Read-Eval-Print the source file using the tooling you already know, and it's magically as powerful as Lisp without you having to add loads of features one at a time .. because it IS Lisp. So it's not a DSL, except it is tuned for trading because you made trading-specific operators, which .. are simply functions, so that was easy, and trading-specific functions, which was easy, and trading-specific .. nothing else because there isn't anything else, so that makes that easy. Something which is really hard in C++ is so trivial in Lisp it's almost not worth mentioning, because it's just an extension of "coding in lisp" and isn't really a separate language, if you don't need it to be. And if you *do* need it to be a totally custom language like regex, or string formatting instructions, which isn't Lisp, well parsing a custom language into an abstract syntax tree and evaluating it is pretty easy in Lisp, because once you've written a recursive descent parser (Lisp loves recursion) and turned the source into a tree (Lisp loves trees) then you can eval the nodes in the tree with Lisp functions (Lisp loves Lisp functions) .. so that was easy (easier). Your operator isn't different from functions. Which means it's easy to add custom operators. They're not special so there isn't anything special to know or do. Your DSL isn't really different from Lisp. Which means it's easy to make DSLs. They're not special and different so there isn't anything special to know or do. You are using a Lisp parser/interpreter so you naturally turn everything into Lisp, which means you can do a lot more than a C++ programmer, because things they think of as weird, impossible, special, months of work, are things you did without even noticing they were supposed to be hard. I could have this all wrong.
Maybe it's not such a good idea to use JSCL to implement the "Try Lisp Online" demo. Just about everything I tried with it failed: Welcome to JSCL 0.6.0 (built on 1 May 2018) JSCL is a Common Lisp implementation on Javascript. For more information, visit the project page at GitHub. CL-USER&gt; (loop repeat 5 collect 'x) (X X X X X) CL-USER&gt; (macroexpand-1 '(loop repeat 5 collect 'x)) (JSCL/LOOP::!LOOP REPEAT 5 COLLECT (QUOTE X)) T CL-USER&gt; (macroexpand-1 '(JSCL/LOOP::!LOOP REPEAT 5 COLLECT (QUOTE X))) (LET ((#:G40562 5)) (DECLARE (TYPE REAL #:G40562)) (JSCL/LOOP::WITH-LOOP-LIST-COLLECTION-HEAD (#:G40563 #:G40564) (BLOCK NIL (JSCL/LOOP::LOOP-BODY NIL (NIL NIL NIL NIL) ((JSCL/LOOP::LOOP-COLLECT-RPLACD (#:G40563 #:G40564) (LIST (QUOTE X)))) ((WHEN (NOT (PLUSP (SETQ #:G40562 (1- #:G40562)))) (GO JSCL/LOOP::END-LOOP)) NIL NIL NIL) ((RETURN-FROM NIL (JSCL/LOOP::LOOP-COLLECT-ANSWER #:G40563))))))) T CL-USER&gt; (restart-case ... (invoke-restart 'foo) ... (foo () :foo)) ERROR: Function 'INVOKE-RESTART' undefined CL-USER&gt; (restart-case (error 'foo) (foo () :foo)) ERROR: ERROR: `FOO' is not of type SEQUENCE CL-USER&gt; 1/2 ERROR: Variable 1/2 is unbound. CL-USER&gt; (defstruct foobar ... (x 1 :type integer) ... (y (lambda () 1) :type function)) ERROR: Bad slot description `(X 1 :TYPE INTEGER)'. CL-USER&gt; *package* #&lt;PACKAGE CL-USER&gt; CL-USER&gt; (type-of *package*) ERROR: Function 'TYPE-OF' undefined CL-USER&gt; (defpackage :my-cl (:use :common-lisp) (:shadow :car)) ERROR: ECASE expression failed for the object `:SHADOW'. ...and CLOS is explicitly mentioned on JSCL's GitHub page as not being implemented. This would be a terrible first CL experience. 
The name "Lisp Object Notation" would be inappropriate. The reason JSON has its name is because the notation can be directly evaluated by a JavaScript engine. 
There are much more extensive examples. FORMAT uses a DSL for output formatter strings. CLOS is a DSL for OOP with syntactic constructs for defining classes, methods, generic functions and more. LOOP is a DSL for imperative iteration. ITERATE is another one. SERIES is a DSL for stream-based computing. SCREAMER is a DSL for nondeterministic programming. On Lisp explorers some aspects of language extension: http://www.paulgraham.com/onlisp.html You can download the book from there.
&gt;Does lisp's "code is data" property even matter if you don't exploit it via macros? Yes it is. I have not so much of experience, but can assure you lisp is totally different, it is magic! The thing with "code is data" is you have access and control over syntax and execution. You get continuations as first class objects, and lots of other great stuff. 
Some of this comes down to the fine/blurry line between internal DSLs and old-fashioned APIs. Martin Fowler writes a bit about it [here](https://www.martinfowler.com/bliki/DslBoundary.html) that you may be interested in reading.
I had suspected that it might be the case that not using macros might just be advice for newbies. That makes sense.
&gt; Does lisp's "code is data" property even matter if you don't exploit it via macros? i'm sure you already know about the eval function. you could build a list (of "data") that you know is a form that could be evaluated and then just eval it.
&gt; I'm no Lisper, or C++er, but isn't that part of the point he's making? &gt;C++ was designed in a way that means you can't write C++ code to extend the C++ language, and Lisp was designed in a way that you *can* code with Lisp to extend Lisp. When you do, your added Lisp operator looks and behaves like all the rest of the language. When you add function calls in C++ they look and behave differently to operators, you would not confuse them as being "part of the C++ language". Your Lisp ones you can't tell that they're not a part of the language just by looking. &gt;"*he just defined a function*" - exactly! The thing which is "nearly impossible" in C++ and Python is "just" a triviality in Lisp, barely worth mentioning, and so trivial it's even hard to pick out and explain. Therefore Lisp has a nicer design. My point is that Lisp doesn't have operators in the same way that C++ has them. It's not even close to impossible to define an exponentiation function in C++. You just can't call it "**". I can easily write: `int exp(int a, int b)` in C++. Telling me that Lisp makes it easy to write custom operators sounds like something else to me. Now if you created a new "carat" operator in Lisp that does some custom behavior when you write `^(1 2 3)` **then** I'd say you wrote an operator. Calling the ** function in my example an "operator" is disingenuous, IMO. &gt;And that ties in to your first point about a DSL - if your language is (function &lt;args&gt; &lt;params&gt;) then a Domain Specific Language stops being about "how can I write my own programming language from scratch which is good for &lt;domain&gt;" and starts being as simple as "how do I name and implement functions helpful in &lt;domain&gt;". Instead of being "TradeScript++ written in C++" which took you a month to make a compiler and interpreter, it's "CoommonTradeScript written in Lisp" which took you a few hours, and it's "Lisp-tuned-for-trading" which means your "new language" has all the power of Lisp, unlike TradeScript++ which doesn't have any of the power of C++. &gt; &gt;Because the Lisp REPL is reading what you type as text, and parsing it into Lisp, and running it, all the time, you have access to that parser and interpreter, so why not use it? Make your CommonTradeScript look like Lisp and now you can simply read a file, evaluate it, and print the result, and .. voila, your own Lisp-language for trading with. &gt; &gt;Could you write a C++ program which reads a C++ file and runs it? &gt; &gt;"but it's not a different language" - exactly! You could define TradeScript++ with curly braces and strings quoted with angle brackets and then spend ages writing a parser and an interpreter and tooling to handle that .. and then have to learn to use it .. and then find desirable features and keep implementing them as you need them .. but why would you choose to do that when you have a Lisp parser and interpreter right under your fingers? Choose to make CommonTradeScript as a dialect of Lisp and then you can define a couple of functions and Read-Eval-Print the source file using the tooling you already know, and it's magically as powerful as Lisp without you having to add loads of features one at a time .. because it IS Lisp. So it's not a DSL, except it is tuned for trading because you made trading-specific operators, which .. are simply functions, so that was easy, and trading-specific functions, which was easy, and trading-specific .. nothing else because there isn't anything else, so that makes that easy. &gt; &gt;Something which is really hard in C++ is so trivial in Lisp it's almost not worth mentioning, because it's just an extension of "coding in lisp" and isn't really a separate language, if you don't need it to be. To my skeptical and cynical eyes, it sounds like you're elevating writing domain functions in Lisp and just ignoring that you can do exactly the same thing in any other language... I truly don't understand why writing a bunch of trading functions in C++ and then calling those on your data is somehow NOT a DSL. Is it truly just because C++ has operators and Lisp doesn't, so Lisp functions are automatically upgraded to something better than C++'s functions? 
Thank you. That was a good read.
Take the Hiccup framework in Clojure: [:a {:href "foo.com"} "bar"] That is equivalent to: &lt;a href = "foo.com"&gt;bar&lt;/a&gt; This is a DSL. When it comes to Lisps, DSLs reflect not so much the syntax as the meaning of the s-expressions that is "overloaded" to suit the domain. For instance, in the normal context you'd consider the given Clojure snippet as a plain old vector, right? However, in the given context, it generates HTML code with the advantage that even the syntax does match somewhat with the target domain (HTML generation).
&gt;But then, everyone (else?) says to use macros sparingly, if at all. So, are there just two camps of lispers? Simply, if something can be written as a function instead of a macro (and, without increasing complexity or difficulty), then it's preferrably to use a function. But, when you need them, macros make *all the difference in the world*, particularly in Lisp, compared to languages that have no macro facilities at all, or languages that require a lot of effort to create a macro (i.e. convert the code to AST, then manipulate the AST using a custom lib). On Lisp, creating a macro is almost, almost as easy as writing a normal Lisp function. &gt;I've read multiple times about how great it is to write DSLs in lisp. This concept has captured my fascination as a way to keep complexity in check. But creating a programming language sounds like &gt;But that's not a new language, it's two god-damned functions. That's the point. The point of having a language where the code is purely made of s-expressions, is that expressing a useful DSL doesn't really require modifying the syntax. &gt; I can write a Shares class and trade and timing-is-right functions in C++ Yes, so you would require always to instantiate a Shares object and then call the methods on the object, so the syntax is more restricted: it requires you, always, to specify the object (dot) method (parentheses) parameters. While you don't have such syntax restrictions on Lisp. By default all is s-expressions. &gt;The conclusion of this essay is that his "DSL" is basically this (...) But that's not a new language, it's two god-damned functions. Because, for his purposes, his DSL was good enough by using some lisp functions. (Nothwithstanding the `20:00`, which is syntax that doesn't exist on CL originally). In C++ you call methods like this: &lt;object instance&gt; `.` &lt;method name&gt; `(`&lt;argument&gt; `,` &lt;argument&gt; `,` &lt;argument&gt; `)` So in lisp you have the function application like this: `(` &lt;function name&gt; &lt;argument&gt; &lt;argument&gt; &lt;argument&gt; `)`. However, unlike C++, you are not constrained by this; you could as well write the function application as: `(` &lt;argument&gt; &lt;function name&gt; &lt;argument&gt; &lt;argument&gt; `)` or `(` do &lt;function name&gt; with &lt;argument&gt; and &lt;argument&gt; `)` or whatever you like, by transforming code to code, because *code is data*. This flexibilty you don't have in C++ (and many other languages) and that's what makes creating DSLs easy. 
&gt; Now if you created a new "carat" operator in Lisp that does some custom behavior when you write ^(1 2 3) By the way, it is very easy.
Fair point on the `20:00`. But your complaint about the "noise" in the C++ example is just a statement of your preference for lisp syntax- is it not? 
Good. That's the exciting stuff, to me.
[This](https://github.com/jarcane/try-racket) was once used to host an online Racket REPL. It's based on a similar system to host an online Clojure REPL ([this](https://repl.it/repls/FunctionalWanStructure) may be the one). That approach might be a good way to create a REPL for CL. I've never read the code, but it does seem to involve a VM of some kind. 
I understand what you're saying and agree with your technical point, but I disagree with the overall judgement. Instead of writing `1 + 2 * 3`, in lisp it's `(+ 1 (* 2 3))` and it all looks like math with "operators" and people think about it the same way. It's not lisp's fault that other languages either can't do something or have to introduce new specialized syntax to accomplish something. The real issue here is that it's easy in lisp to make your own thing like + or * and have it work naturally within the language. IOW, forgetting the nitty gritty mechanics and focusing on how easy it is to accomplish what you need to do, this is an easy task in lisp using only novice knowledge, and looks as natural as built-in math operations. This kind of reminds me of Norvig noticing that many design patterns in other languages don't exist in lisp. Instead of using a design pattern to accomplish X, in lisp you just do X.
&gt; He did NOT define an operator, because Lisp doesn't have operators. Fair point. &gt;Likewise, in Lisp, you don't use operators. Note that there are some notation like `#'` that *can* be considered an "operator". `#'` obtains a function, so it's used to refer to a function. For example if you have a function `foo`, and you want to pass it as an argument to some method, you can use `#'foo`. (Or, said in a more lispy-way: it gets the function-value of the symbol `foo`). You can consider that one an operator. We would say "this is a symbol macro that gives you syntax sugar". And C++ operators, in all fairness, are basically useful syntax sugar. There are others, for example `#(` to create a vector, etc. 
There's this post: https://www.reddit.com/r/lisp/comments/pg2yx/what_are_some_fun_or_useful_macros/ There's an answer which shows how to extend lisp with XML syntax which generates very efficient code.
I think of this in two ways. First, a DSL that requires a preprocessor in another language can be done with macros in lisp. Yacc or Lex (to use two venerable examples) have equivalents in lisp that are just things you load. Second, if you want to write a DSL, you will often find yourself wanting to embed more and more procedural logic in it. At some point, you'll realize you just want a general purpose programming language in there. If you had done it via macros in lisp, you have the full power of the language available. Reader macros are a different kettle of fish. I've avoid defining them in general because different sets of reader macros don't play well together.
In `1 + 2` the operator is "addition"; with the operator in the middle it's "infix notation", and writing it `+ 1 2` is "prefix notation" but the operator is still "addition". Rearranging the *notation* doesn't stop it from being an operator, it's not "disingenuous" to call `+` an operator when it's written at the front. C++ gives you `1 + 2` which is nice and convenient. And it gives you `func(1, 2)` with commas and limited names. That's two sets of syntax to learn, which don't look the same, and which restricts from adding `1 ** 2` and `** 1 2` and you cannot add `**(1, 2)`. Lisp gives you `(+ 1 2)` which is weird and inconvenient, and it gives you `(func 1 2)` with no commas and arbitrary names. Because of that choice, you can write everything that way, you can add `(** 1 2)`. It's a design choice. Which one is worse design? The one where operators look nice but you're stuck with the ones they gave you, or the one where operators look weird but they're identical to functions so adding more is trivial? &gt; Telling me that Lisp makes it easy to write custom operators sounds like something else to me. Now if you created a new "carat" operator in Lisp that does some custom behavior when you write `^(1 2 3)` *then* I'd say you wrote an operator. As I said, I'm no Lisper, but .. challenge sorta accepted. Go to https://rextester.com/l/common_lisp_online_compiler and type `(PRINT ^(8))` and click run, and it throws an error `Error(s), warning(s): *** - EVAL: variable ^ has no value`. Not valid Lisp syntax. Then type `(PRINT (EXP 8))` and see that you get answer `2980.958`. Here's the magic bit: the Lisp parser which turns that text into code and runs it, is programmable. All we have to do to make `^(8)` exist in the language is tell that parser "when you are reading Lisp source code, and you get to a `^`, give control to me, I'll deal with it, then give control back". And then turn `^(8)` in source code into `(EXP 8)` behind the scenes. Copy paste this in, and run it: (defun caret-reader (stream char) (declare (ignore char)) (list 'EXP (car (read stream t nil t)))) (set-macro-character #\^ #'caret-reader) (PRINT ^(8)) and now `^(8)` is no longer an error, it's now a working part of the language. New syntax to the Lisp language and use it in the same source file. Close enough that you said it would be a new operator? OK, honestly, this took me a couple of hours, some googling, and it's very very very limited. But, if you can see that I can do this in 4 lines, a real Lisp programmer could use the same technique to add `2 ^ 3` and you can google it and people have done that. Now ask me to add `^ 8;` as a new syntax to C++ and even with Google and a couple of hours, I don't know if I could do it. And ask me to add it to the language *at runtime* so I can use it in the same source code file just after I added it .. I can't imagine. &gt; I truly don't understand why writing a bunch of trading functions in C++ and then calling those on your data is somehow NOT a DSL. Is it truly just because C++ has operators and Lisp doesn't, so Lisp functions are automatically upgraded to something better than C++'s functions? It IS a DSL. It's just one where the only part of the language specific to your domain is the function names. You want to add `$APPL$` to TradeScript so it gets turned into "the current value of the stock APPL"? getCurrentStockPrice("APPL") &lt; 100; vs reader-macro-here (&lt; $APPL$ 100) You want to add price averaging over N days to TradeScript? getAverageStockPrice("APPL", 7) &lt; getCurrentStockPrice("APPL"); reader-macro-here (&lt; $APPL$ $APPL,7days$) In C++ you can write domain-specific C++. In Lisp you can write domain-specific Lisp. Or you can rebuild LISP to let you write whatever it is you want to write, and make a dialect of Lisp tuned for the things you want to express in your problem domain. Say you want to generate HTML `&lt;html&gt;&lt;head&gt;&lt;title&gt;blah&lt;/title&gt;&lt;/head&gt;&lt;body&gt;blah&lt;/body&gt;&lt;/html&gt;` , nested tags. How would you do it in PowerShell? Make some functions which take a scriptblock, emit angle brackets before, eval the scriptblock, emit angle brackets after, and then write: html { head { title "blah" } body { "blah" "blah" } } is that a DSL for building HTML, or is it just normal PowerShell? How would you do that in C++? What's the type of the `public string body();` function where it can take an arbitrary number of parameters which may be strings or maybe other C++ code or function calls? How would you code it? What would it look like if you did try to write it in C++? You'd probably end up with: output.Add(html()); output.Add(startHead()); output.Add(title("blah")); output.Add(endHead()); output.Add(startBody()); output.Add("blah"); output.Add("blah"); output.Add(endBody()); Which one is letting you focus your attention on the structure of the HTML, and which one is making you focus your attention on managing data structures to get around limitations of the language not being very customisable? 
You mentioned experience in webdev with Clojure. Did you ever use core.async? The =go= macro is a good example of the power of language extension (and a pretty cool look at macrology). The authors basically ported the communicating sequential processes from Go, features that are baked in at the language level, and extended Clojure (and simultaneously ClojureScript) to have embedded language-level support for co-routines/green-threads (goroutines) as a library. The result is a tiny DSL for working with CSP using channels, plus a library of functions to compose them. The "little language" consists of some new forms for defining asynchronous processes amenable to "parking" that either run on a shared thread-pool or a dedicated thread (go, thread) along with means for defining channels (chan), and primitive operations on them (&lt;!, !&gt;, &lt;!!, !!&gt;, alts, etc.). Using this little language, embedded in Clojure, you get the concurrency semantics of Go. No one had to petition the language committee to add keywords to the language, update the reference compiler, etc. They just wrote (some sophisticated) macros and (more or less) functions. Of course the same idea exists in other forms in other dialects due to the nature of macros (and the storied histories of older lisps). In "On Lisp," Paul Graham has some great examples of extending CL to include little languages for continuations, multiprocessing (including fork/wait, and other primitives for lightweight processes), nondeterministic programming, and eventually logic programming (embedded ProLog). Doug Hoyte goes ape in "Let Over Lambda," using macros to redefine the default CL defmacro to enable automatic gensym syntax (similar to Clojure's, I think Clojure was inspired by it) to enable even better metaprogramming facilities. A DSL for writing DSLs.....if you will. Pattern matching (and to a lesser extent destructuring) is another example, that's typically found (again) at the language level in non-lisps. In a lisp, you can define a DSL that can unify patterns with against inputs under arbitrary semantics. Clojure has [core.match](https://github.com/clojure/core.match) . [Odin](https://github.com/halgari/odin) is an eDSL that lets you query and transform datastructures using unification (kind of like datalog). [Specter](https://github.com/nathanmarz/specter) keeps getting attention, as a DSL for defining sophisticated reads and transforms on navigable paths within nested data structures (kind of like dynamic lenses). There are undoubtedly analogues in other dialects, these just jump to mind. &gt;The other piece of the puzzle for me is the concept of reader macros. Reader macros let you modify the reader arbitrarily; for lisps, this means altering even the fundamentally minimal syntax present. Imagine redefining what ( ... ) means at read-time, or hacking the meaning of : to not only read keywords, but say (facetiously) launch a missile every time a new keyword literal is read. You get to control that if you have reader macros (and with control comes responsibility). &gt;Everyone talks about writing DSLs in lisp, which seems like maybe they're using macros. But then, everyone (else?) says to use macros sparingly, if at all. So, are there just two camps of lispers? Are they talking about different things? There are multiple camps (Conrad Barski calls them the Lisp Guilds in "Land of Lisp," although in practice they probably blend together more than separate cleanly into guilds...). &gt;Does lisp's "code is data" property even matter if you don't exploit it via macros? As mentioned elsewhere, you can still build up expressions and eval them, primitive-like. Macros make it much easier to do this and hook into the existing infrastructure. To take it to an extreme (beyond macrology), you get into realms such as program synthesis and genetic programming, where processes synthesize programs as part of some exploration. In program synthesis (like the research Will Byrd demonstrates using miniKanren to implement a logic-programming version of eval (evalo) to search for possible implementations of arbitrary scheme programs) or building expressions according to some criteria - like [evolving efficient clojure.spec specs that can generate test data](https://github.com/gigasquid/genetic-programming-spec) .
&gt; I think you're missing the point here that in absence of infix notation, an operator is just a function in every way. I'm not missing that point, that *was* my point. Operators and functions have the same syntax, so they collapse into being "the same thing", which is overall both simpler /and/ more flexible. Hooray. &gt; But, when people then talk about operators as a separate thing even though they're just functions (that happen to have at least one parameter and a name that we associate with the concept of an operator), you start confusing people. As I said, not my language. But if they bought a HP RPN calculator and said "I can't do 1+2 this calculator doesn't have operators" they would be wrong. The confusion doesn't come from LISP, per se, it comes from only knowing about infix operators. &gt; I this case you also kinda piss them off by saying "my language is better because it doesn't have this feature" &gt; Also sidenote, there's a very good reason why you can't have custom infix operators in C++ (or many other languages for that matter), they're a pain in the neck to parse. "my language is better because it doesn't have that pain in the neck feature". "you're pissing me off". "ok, enjoy your neck pain I guess". "ow, my neck. but at least I'm not putting operators on the left, that's literally unusable. It's probably subversive like COMMUNISM or something. Ow. Ow." - bizarro world interaction. &gt; This sounds to me like you're comparing trade-offs made in the two languages, but then only looking at what C++ had to give up, and not at what lisp had to give up. What did Lisp have to give up, which is relevant in this context? I Googled for a moment and found someone has implemented [infix operators in Lisp](https://www.cs.cmu.edu/Groups/AI/lang/lisp/code/syntax/infix/infix.cl), not that I can make sense of it, but by choosing flexibility you can use that to gain back the bits you want - unlike inflexible languages where you're stuck with what you're given. Readability, maybe? Personally, I'm a bit of a fan of constraints make designs better, but ultimate freedom has its positives. &gt; The alternative to lisp in language development isn't necessarily hand-built, there are other options (from parser generators like lex/yacc, antlr or spirit, to language workbenches like EMF or MPS). I am, but they are a proliferation of options, all of which you need to step outside the C++ world and learn separately from each other, and which all presumably lead to a completely different and disconnected language from the C++ scaffolding. Unlike "writing Lisp code to customise the Lisp engine at runtime", which is all one world, so the things you learn go further and combine more together.
My take on it: it's more about defining new language keywords: from `def` or `defun` to `defroute`, `defcommand` etc that would do exactly what we want. I noticed a pattern in my application (Python): def name (self, request, **kwargs): messages = Message() try: obj = Model.… except: return JsonResponse(obj + messages) return JsonResponse(…) I want to always return error messages, there is always the try/catch,… I can not refactor this with Python features (with-statements, decorators,…), but I could use a macro. Other languages with macros have a `defroute`s, when in python frameworks there may be boilerplate. In my Lisp app, a user creates new commands with: (defun name (whatever) …) (replic.commands:add-command #'name) But now I'd like to make it shorter and hide the underlying `add-command`, so I'm about to create a `defun-command`. The Next browser does this: https://github.com/atlas-engineer/next/blob/master/next/source/command.lisp#L25
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/clojure] [Went to r\/lisp and found this gem.](https://www.reddit.com/r/Clojure/comments/9o2g16/went_to_rlisp_and_found_this_gem/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Work with Haskellers. Can confirm. 
Sometimes I miss my 33KSR... \*sigh!\* A bit... But then I think about the speed, the weight, the noise and the missing lowercase letters and I am happy about my notebook again. :-D
Can you explain? 
Only you would have used DEFINE instead of DEFUN and there would not have been &amp;OPTIONAL arguments and not even strings, and you would have typed your code on as few lines as possible without any formatting. :) E.g.: DEFINE ((HELLO (LAMBDA (NAME) (PRIN1 (QUOTE HELLO)) (COND ((NULL NAME) (PRIN1 NAME)) (T (PRIN1 (QUOTE WORLD)))))))
There should be a pile of dog shit on all pics except the CL one, then it'd be more accurate
[German keyboard layout](https://en.wikipedia.org/wiki/German_keyboard_layout)
**German keyboard layout** The German keyboard layout is a QWERTZ keyboard layout commonly used in Austria and Germany. It is based on one defined in a former edition (October 1988) of the German standard DIN 2137-2. The current edition DIN 2137-1:2012-06 standardizes it as the first (basic) one of three layouts, calling it "T1" (Tastaturbelegung 1, "keyboard layout 1"). The German layout differs from the English (US and UK) layouts in four major ways: The positions of the "Z" and "Y" keys are switched. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Brother 
Why is Khomeini there for Java? LOL... Literally burst in to laughter. What is that supposed to signal anyway? Revolutionary?
My first impression just from seeing the pic (and not knowing as much as I should about the actual guy) is a feeling of religious dogmatic authoritarianism. 
&gt; how Emacs feels to me after using a full-fledged IDE. that's a weird way of putting it since Emacs is more 'fledged' than any IDE I know.
I knew it wouldn't be long before my mention of Emacs summoned someone to assert its dominance over all other methods of programming. 
&gt; its dominance over all other methods of programming All other methods of programming? No, all other methods of manipulating text* for whatever purpose, including programming. *Where graphics are included in the 'text' category since they can be referenced as text (file paths) and displayed within Emacs. 
I'm going to screenshot this exchange because my friends aren't going to believe that an *actual* Emacs God condescendingly responded to not one, but **two** of my comments. The stories I've heard paled in comparison to seeing your pedantry firsthand. Thank you.
&gt; pedantry Wow buddy you're dumb.
Humor me. Why?
I know, I enjoyed responding to you. I aspire to attain Emacs god-dom one day. Then people like me better watch out.
Yes! I am “collecting” (i.e., buying when I found them for cheap) old LISP books and that was the style, including the missing parentheses at the top level. And apparently sometimes in the seventies someone decided that (at least in books) code formatting was useful. One very interesting thing is the kind of knowledge that the reader was assumed to have: goto, arrays, pointers? No problem! Functions, recursions, non-numerical values? That had to be explained.
This. Use PCL and [Portacle](https://portacle.github.io/) for an IDE.
The parentheses at the top level are not "missing"! The LISP 1.0 and 1.5 interpreters (APPLY) expected three arguments: a function, its arguments in a list, and an environment. Each argument of APPLY was read in separately, so you typed CONS (FOO BAR) () which was usually shortened to CONS (FOO BAR) in manuals and textbooks. Note that APPLY did not evaluate its arguments, so CONS (FOO BAR) was actually equivalent to (CONS (QUOTE FOO) (QUOTE BAR)) In the 1970's, when the primary interface became the glass TTY and programs became more complex, the decision to add some formatting was made by programmers and textbook authors simply adopted the new style. 
The [CL Cookbook](https://lispcookbook.github.io/cl-cookbook/) doesn't have an introductory crash course, but it should help for a data structures reference, a tutorial on CLOS and other practical things. also https://learnxinyminutes.com/docs/common-lisp/
Play with emacs with elisp is a good start
Just in case you like vintage AI too, Norvig PAIP is free online
it is elisp.
I can't even put to words how tired I am of this kind of question and discussion.
Indeed the question gets really tiring... The reason I posted it here is because in the comments there's some original content from someone relevant to the Lisp standardization process (who prefers to remain anonymous), so I thought it was worth posting it here.
Because it gets asked extremely frequently and mostly by people trying to figure out if it's "better" than whatever their favourite language happens to be, with no actual interest in learning it. It results in the exact same flame war every time and it is just exhausting to be plagued by such an easy troll all the time.
It's a shame if such questions are used in trolling attempts. That being the case I don't blame you.
we are using spacemacs as the editor. thank you for the manuals. 
I was programming in the late 60's -- Fortran (or was it Basic?), and a bank. I can't remember what I was typing on, or what it felt like. 50 years of programming... 
I don't speak for everyone in the community nor everyone on #lisp, but the frequency with which this occurs appears to me far less often than Nicholas makes it out to be. I would say such individuals join #lisp maybe once a week, maybe even less.
&gt; #lisp on freenode?
Another vote for PCL here!
&gt; that's a weird way of putting it since Emacs is more 'fledged' than any IDE I know. This is my experience too -- and I've used other IDEs like NetBeans, Eclipse, Visual Studio, VS Code, PyCharm, etc. 
Elisp is more similar to Common Lisp than to Scheme, but it doesn't try to conform to either standard. Elisp provides functions for manipulating text, buffers, and user interface parts for the editor. The [tutorial](https://www.gnu.org/software/emacs/manual/eintr.html) linked by u/jaoswald is a very good introduction to elisp for beginning programmers. It's a little long-ish though, so maybe [Emacs Lisp in 15 Minutes](https://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html) or [Casting SPELs in Elisp](http://www.lisperati.com/casting-spels-emacs/html/casting-spels-emacs-1.html) would be faster introductions for you. The [elisp reference](https://www.gnu.org/software/emacs/manual/elisp.html) is invaluable, but you really ought to get in the habit of using `M-x elisp-index-search` to find functions and `M-x describe-function` (usually bound to `C-h f` or `F1-f`) to display documentation. 
Here’s an example of a DSL built up in Lisp: https://gitlab.common-Lisp.net/gendl/gendl “DSL” may be a bit of a misnomer here, because Gendl is still a general purpose language (not really “domain specific”). But it is a full-blown declarative language built on top of CL (and continuing to be a superset of CL) while offering new top level constructs not present in core CL. Here’s a (rough, pre-alpha) preview of Gendl’s new object browser, a web app built up completely in Gendl as well (not released in the codebase yet): http://genworks.com/geysr-bus (yes, there’s a rendering bug with the front axle in x3dom mode). The code for the tree shown there is here: https://gitlab.common-lisp.net/gendl/gendl/tree/devo/demos/bus (Ignore the outdated README). 
Most people using Emacs do their programming in a different language, using Emacs for the text-editing portion (and interacting with the other language). Of course, it is a programming language, and reasonably powerful, but it is mostly targeted at people enhancing Emacs, not people doing discrete math. For example, spacemacs itself is mostly Elisp code turning the default GNU Emacs into a much different environment. At some level, Emacs is a framework for text editors and similar applications. But, again, for discrete math, Elisp is an odd choice. It has integers that might only be as small as 30 bits, it does not have arbitrary precision integers, it does not have numeric functions like factorial or rational number types, it does not have any kind of type system to speak of. Finally, did you try asking the professor who gave you the assignment? I find it very odd that people take a class with an instructor, then ask a group of random strangers for advice. Why don't you ask the professor how to get up to speed on Lisp? His answer is going to be many times more helpful than our guesses.
Language oriented programming. See also http://www.defmacro.org/ramblings/lisp.html
One one hand I agree, on the other - well, I've been there and only learned scheme because my professor suggested it to me. I remember being of the opinion that it is stupid, a relict of the past. "we have Haskell now". I'm not a very smart person, I know.
yes #lisp on freenode
The article should also have included a link to the MP3 of [_God Wrote in Lisp_](http://www.prometheus-music.com/audio/eternalflame.mp3).
device came in many colors and paredit options 
language oriented language lol
the teacher said elisp is very powerful. I personally havnt talked to the teacher about elisp but other people in the class have and the teacher basically says we should learn most of it on our own. 
It's languages all the way down
Hadn’t heard that in forever! Thank you!
[Here's a link to the song on Youtube.](https://www.youtube.com/watch?v=5-OjTPj7K54)
[Lisp has occult power indeed](http://zahardzhan.github.io/2011/lisp.html).
Lisp killer feature is resolution of the dialectical contradiction between the sign and the value.
Also the association "Lisp - Lambda (calculus) - (Alonzo) Church" may have had a role in it.
Putting a PPRINT around a DEFUN is not a good idea. The DEFUN form will no longer be at top-level and the file-compiler won't recognize the function as a top-level form.
Thank you! FWIW, I agree on the poor style, it's a quick draft. And the PPRINT is really a corpse from a previous draft that didn't call DEFUN. Do you think the concept can be useful, or is it a mere exercise in your opinion?
If i were to do something like this, I would probably keep using standard defuns and instead make a separate DOCUMENT function that takes all the documentation. Like this: (defun foo (x y) ... ) (document foo :description ... :in ... :out ...) 
I suggest that you should not do this. Instead use DOCUMENTATION-UTILS to set the documentation from another place of your code. This means that you can construct the docstring from any predefined template you might have. https://github.com/Shinmera/documentation-utils
Actually, Holy C is God's own programming language. Rest in peace Terry Davis.
I like that it could help one to remember to document all parameters, but I'm in the habit of writing docstrings prose-style, which I prefer. In a perfect world maybe you'd have a complete prose docstring followed by a bulleted list of argument docs, but I don't think I would consistently fully-ass both.
A popular thing for internet communities at least used to be singing a song and overlaying all of the singers' voices. Several crap singers turns into alright singing when you combine them! Anyway, I'm afraid that I'm far too embarrassed to do that myself :-).
If we all sing I'm afraid we might finally kill the CL
Your meme has been thoroughly processed by my brain in musical form. You win.
So .. could Rust kill the metal?
RIP
It looks great desu.
I do see symbolic computation being a topic of the talk, but is Lisp used anywhere in the actual implementation? Are there any papers available that are associated with the work?
Of course it was already posted here 1 day ago ...
##r/emacs --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
6pm UTC happens when this comment is 19 hours and 15 minutes old. You can find the live countdown here: https://countle.com/CeJQBU6xO --- I'm a bot, if you want to send feedback, please comment below or send a PM.
&gt;Who wants to try recording this? Umm... I play drums, guitar, bass and keyboards. But if I had the free time, i'd probably cover the "Land of Lisp" song by Conrad Barski, that's a cool song. "simple but refined / guaranteed to blow your mind / the Land of Lisp" 
How are you testing that?
inb4 fork of SBCL called "Steel Wool Common Lisp"
Originally I was using `sb-bsd-sockets:socket-send` now I use a socket-stream. Using either method, `tcpdump` would pick it up. I also could send a linefeed via `nc` afterwards and it would print both what I sent over socket-send and the linefeed from `nc` so I know it wasn't buffering on the client side.
whoa! thanks! that worked.
ease of use. with lisp, it's turtles all the way down. no syntax, no syntax errors. do more with less code. lisp comes with a deep tradition of wisdom passed down from some of the brightest minds of the 20th century. there really is nothing like it. 
For me, it's the language's "Pareto optimality". I can't pick a different one to improve something without something else I already have becoming worse.
How did you **not** see it here; it's still on the front page by "hot", under that very title. 
I love Tenacious D. Best band that has EVER existed.
To answer a part of your question: `(define x 42)` means that `X` is now a variable and its value is 42. `(define (x) 42)` means that `X` is now a function and the value returned by it is 42. It is equivalent to `(define x (lambda () 42))`.
Whatever you want to write. Lisp is a general-purpose programming language.
 I'm looking to learn lisp through experience and asking what kind of program is it best for. For example I know C is good for any type of program but I would suggest someone to use it for a program that requires low level memory manipulation. Every programming language has tasks it is best for
I can't believe these "success stories" do not include SHRDLU from 1970 ([https://www.youtube.com/watch?v=QAJz4YKUwqw](https://www.youtube.com/watch?v=QAJz4YKUwqw)) -- "even today" it is very impressive.
&gt;So I would like to ask what is the best use case for lisp? What kind of program or environment is it best suited for and/or has an advantage over other laungauges? Lisp is a general-purpose language which is specialized in being general-purpose. Lisp is the original (and still the best) *Programmable Programming Language*, thus it can be more General Purpose than others. So it has been used in almost any kind of situation you can imagine. Let's better talk what Lisp -or at least a full lisp like Common Lisp or the latest Scheme spec- is NOT suited very much for (note: doesn't mean this hasn't been done with Lisp too -- just that it isn't a good fit): - real-time systems - systems where low RAM consumption or low RAM usage is beneficial - very low level programming 
Thanks
you're welcome sir
Lisp is good for so many things though. It really is probably simpler to pick a project then see if it's going to be problematic.
and I forgot, I had good fun and success with web scraping (lquery, dexador and related). If you know some Qt, you could try Qtools.
Of course Lisp languages are general purpose. So we can refine the question as: when will a Lisp be more suitable than other kinds of general purpose languages? Lisps are very good for manipulating tree-structured information with heterogeneous, symbolic data. If your problem domain requires, or benefits from, the processing of any custom syntax and semantics, Lisp will be of more help than other languages. If someone said "write a C++ compiler", I'd reach for nothing else than Lisp. I'm not writing code to deduce and instantiate a C++ template in a non-Lisp language (let alone C++ itself); that's crazy! Lisps are also great for exploratory and prototypical coding when the domain is not fully understood and the requirements are not clear. Some code must be written to understand how to write more code, and the solution goes through prototyping stages. Once upon a time, Lisp would have been the only game in town for this kind of thing. In the recent twenty years or so, Lisp-inspired dynamic languages have arisen which have some of this kind of advantage, though not all of it. Python is undeniably better for prototyping and exploratory coding than C, for instance. Lisp, in particular common Lisp, though is unbeaten because of the superior ability to abstract, the metaprogramming and also because it offers a path form the prototype to high performance production code. If some problem domain benefits from a solution that is expressed in some unknown language that doesn't necessarily exist yet, Lisp is your best bet, because Lisp can be taught to be that language, and this can happen through the prototyping process where you start small and extend. You can concentrate on the semantics to the language and add forms to it little by little, and these can integrate into your Lisp's compile time, not only as something that is processed *by* your Lisp program's run time. Not worrying about details like lexical analysis and syntax is liberating if you're doing language design: much the same way like not worrying about releasing memory is liberating if you're working with complex data structures. Lisp is to language-oriented processing like garbage collection is to data structuring: it gets the distracting stuff out of the way, so you can get right down to working with the abstract syntax and its semantics. Whatever language you need, Lisp already has the pieces in place to express instances of that language. If you can dream up these examples and write them down, Lisp will scan them to tree structure, whose processing you can think about in a concrete way. You've already hit the ground running, without having written any code yourself to scan or parse anything. 
Thanks for the replies guys! I think now I get it. In the Compound Procedures segment, it is explained that to create one you have to do as this: `(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)` So I guess that the first `(p)` is just the name of the function and the second one is calling it.
Sin Dragan.
I don't know of one. There are some challenges in reading CL code without actually evaluating/compiling it, due to readtables and macros and such. Emacs with slime does a pretty good job but it's not as batchy or automatic as other tools.
I'm happy with emacs' automatic code indent. 
Yes: https://github.com/fukamachi/sblint Kuddos to Fukamachi.
Yes with Emacs: https://github.com/tuhdo/semantic-refactor it supports many languages, included CL.
r/DSLs
This is a reasonable choice: https://github.com/ds26gte/scmindent
To add to that you could select your entire buffer (C-x h) and press tab.
Does using SLIME count? ;)
I'm thinking of cases like this: (with-deferrals x y #/perl/{ while(&lt;&gt;) {print}; } (list x y) 
I'm not the original answerer, but I think it's because the runtime can be unpredictable in how much time things will take because garbage collection could happen at any time the runtime deems necessary.
!Remindme 8 days
I will be messaging you on [**2018-10-29 23:18:59 UTC**](http://www.wolframalpha.com/input/?i=2018-10-29 23:18:59 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/lisp/comments/9pz2v9/browsing_the_web_with_common_lisp/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/lisp/comments/9pz2v9/browsing_the_web_with_common_lisp/]%0A%0ARemindMe! 8 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
nvm i just solved if anyone is intrested, by opening the Makefile file there's a command sayng what to do: "qmake-qt4 -o Makefile [commonqt.pro](https://commonqt.pro)" i was doing that but without -o that's probably the main part, rip me
What's the point of implementing the same terrible terminal interface, but now in Lisp? One of the points of a Lisp OS is that everything is Lisp already and you don't have different applications with each having their own brand of weird ass calling convention through the process arguments.
&gt; why not a Lisp Unix userland instead Implementing a Unix userland means that Lisp will need to obey the Unix model where everything is a file (as opposed to an object), all data is text (as opposed to typed Lisp data) and the filesystem is a tree of directories and files (as opposed to, well, no filesystem whatsoever). Implementing Unix in Lisp is a wrong approach. Implementing Lisp in Lisp is a much better idea.
You could've also used the qt+libs system instead, which loads precompiled libraries.
Well this is interesting i'm kinda new to lisp libraries system so i didn't knew
Thank you, I like this analogy.
I agree with the other wise people that it is a terrible idea, knowing something of it's extent. But sometimes it may be wise to throw caution to the wind and launch a boat, not knowing if it will reach another shore. Also, if one was to find oneself foolishly paddling such a skiff upon the wide ocean, some improved profiling tools, in things other than the unconscionably fast sbcl, would really help.
I honestly expected something much less readable and I would've been impressed. Even more so this is very, very readable to me and actually is quite beautiful to look at.