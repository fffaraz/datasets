That needs further help from SBCL. https://bugs.launchpad.net/sbcl/+bug/759417
ABCL is just a jar :-) in fact, it's one of the most portable Lisps, and certainly the most portable Common Lisp. java -jar abcl.jar 
That's not the same as generating a single-file executable. Can ABCL do that?
http://xach.com/img/slad-shirt-black.jpg
Just start writing utilities/modules in CL at work.
Hey, looky, wishes granted: https://github.com/nikodemus/linedit (Pushing to official upstream once some permission issues are sorted out.) 
Thank you! I just want you to know I appreciate the brief green highlight in the middle of the commit history. ;) Looks like you did a lot of work to make the history thing work out.
What's all this talk about frameworks? What's wrong with libraries?
The blog link works, but the source code link fails.
Let me put it this way: If you want to be just like thousands of other programmers, not even knowing what's 2^8 (believe me - there are people who don't), not knowing what a stack machine is, and some other extremely elementary things - then go ahead use Lisp without Lambda Calculus --- literally thousands of programmers make a living this way and they're happy. But if you want to be a good programmer, just like you really HAVE to know what's 2^8, you SHOULD know Lambda Calculus - even if it's not exactly "Lisp", really big parts of the language are based on it (especially Scheme), and what's the most important - functional programming has it's roots in Lambda Calculus. My general advice - you're on very good track just by asking the question - since you have asked (meaning you have recognized some importance of the subject) - this means you should learn it.
That's simply not accurate. A shared library allows sharing of code between multiple processes at the virtual memory level. This does not happen for fasl's, which are loaded into the same address space.
Yes and no. In necroforest's context, the issue appeared to be sharing of disk space, not memory. In that context, fasls are used like shared libraries. They are shared on disk, and the linker/loader pulls them into the executable's memory space. Any decent OS will keep the file in cache until some LRU policy allows it to be overwritten. I do not want to get into a discussion of the mechanics of so's vs dll's, PIC vs relocatable, ...
In my experience, SBCL has always significantly outperformed CCL on my Mac. Some of that is that I've spent more time learning how to declare things to make SBCL happy. It's not as obvious how to declare things with CCL because it doesn't warn you as much when you're doing something less efficiently than it would like. I would recommend developing under SBCL and using both (declaim (ftype ...)) before a function definition to declare its arguments and return types and using (declare (type ...)) inside the function to declare arguments and local variables. SBCL will know the argument types just from the ftype declaration, but CCL will not. But, the reason that I recommend developing under SBCL is that when you tell it to optimize for speed or space, it spews tons of information about how it would like to do better for you but cannot because it cannot guarantee the type of this or that. If you eliminate a bunch of its gripes, you'll get stuff that runs faster on whatever lisp you use in the end. This page: http://nklein.com/software/cl-fft/ has some timing numbers from when I was optimizing some Fourier transform code. There are article links at the bottom of that page with various steps on the way to the final numbers. These articles also mention some of my optimization adventures: http://nklein.com/tags/optimization/
&gt; After that, I recommend: Let Over Lambda I suggest reading in this order: 1) Practical Common Lisp along with Land of Lisp (either one before the other, or both at the same time) 2) On Lisp 3) Let Over Lambda 
Cool. This is sort of what I have been thinking though. Nice to get some numbers though. 
Agree 100%. PCL and Land of Lisp are excellent introductions, and I find PCL in particular to be a decent first reference for questions I have. Let Over Lambda and On Lisp are the books that provide the "click" where you suddenly get how awesome it all is.
Does anybody know why XEmacs correctly indents loops but Emacs doesn't? It is one of reasons why I cannot finally switch to Emacs, it really bugs me.
I have a screenshot of the font + theme combo I'm currently using. http://lispgamesdev.blogspot.com/
That looks really great! Which font are you using and what is the theme (or can I get a copy)? I'm using a monospace font at the moment (I think it's Monaco), but in the times that I have accidentally switched to variable-pitch mode I haven't found anything wrong with it at all. Probably the main concern would be whether you're using tabs or spaces for indentation as a tab may be a bit more uniform across editors..
Some code will not indent properly; for example, when a LET form has multiple bindings on different lines. (let ((v1 e1) (v2 e2)) ...)
Well, I will definitely look into ContextL. Thank you for the info.
Yes, that's my objection to using a proportional font. It's probably possible to munge Emacs to make the indents line up, but I shudder to think of how hacky that would be.
&gt; The description of newLISP is a "Lisp-like scripting language". It's not a Lisp-based programming language. So... why are articles about it being posted in /r/lisp?
Hello. The font is Ubuntu Sans. I will be releasing the theme shortly---it is actually a "fork" of the current default emacs face arrangement. 
that's a deal-breaker. guess i'm back to Monospace 
Awesome thanks!
How do other lisp implementations (Clozure and Lispworks in particular) compare in standalone file size, 10MB is still ridiculous. For that matter GCC+GLIBC is ridiculous in the size of it's output.
What's the difference? That is, how does XEmacs indent them?
Not by itself, but there are other tools to turn a jar into an executable. 
[Emacs](http://imgur.com/SsjnD) [XEmacs](http://imgur.com/6PLhy)
They are smaller. 
Hah, I've had this for so long in my .emacs I'd completely forgotten about it: (setq lisp-simple-loop-indentation 2 lisp-loop-keyword-indentation 6 lisp-loop-forms-indentation 9) ...after that it should be more to your liking. 
Thank you!
You might also be interested in https://github.com/nikodemus/Slime/tree/slime-indentation which gets you Didier's stuff and a few other goodies as well. 
To be fair, indent-sexp also doesn't work properly on loops. common-lisp-loop-part-indentation should return (list &lt;indent&gt; (elt state 1)) for the last two legs. 
&gt; It's not that it's not indenting, you just don't like how it is doing it. Yup. XEmacs can handle both styles (loop on separate line and loop together with first clause), but it breaks on multi-line clauses (which I never use). While Emacs can be configured either for loop-on-separate-line case (default) or loop-together-with-first clause (with settings Nikodemus provided above).
I just added support for both styles to my slime-indentation branch of Slime. :) 
For development or use on the device? For development, Gambit Scheme can be used to build iPhone apps, and I think the Clozure guys were exploring supporting iOS as well. I've heard you can build Android apps in Clojure, but I've also heard the start-up time for the apps is atrocious. That may well have been fixed by now, though. For use on-board, there are a couple of Scheme interpreters in the app store. I imagine there must be something similar for Android.
Ecl has been made to run on both ios and Android. 
There's also "[The Moby Scheme Compiler for Smartphones](http://www.cs.brown.edu/~sk/Publications/Talks/Moby-Bootstrap/)" :-).
I got a Clojure REPL here. It starts in about 2.5 seconds (cold): https://market.android.com/details?id=com.sattvik.clojure_repl
For HP/WebOS you can certainly use CCL (Clozure), ECL should work as well, but I haven't tested it. CCL booted up fairly quickly. As far as I can tell, you're allowed to run them and to make applications with them. Should work fine with OpenGL, otherwise a hybrid app is a possibility. I don't think you're allowed to run lisp on iOS. So you'd be targeting jailbroken devices. Android allows for Clojure to be ran, but it does take a while to boot it up.
Awesome. Last time I looked into clojure on Android was at least a year ago.
You can run lisp on iOS, since they relaxed whatever that rule was about implementation languages.
Awesome! With that, I found [this](http://jlongster.com/legacy/scheme-iphone-apps.html), which is almost precisely what I wanted. 
Similarly, I've been looking for a common lisp that runs on ARM. Does anyone know of any?
Kawa runs on Android and it's fast. In fact, Google's Android AppInventor relies on it.
You can run interpreted Lisp, but I'm pretty sure you can't run compiled. The only app allowed to execute writable memory at the moment is Safari. 
Clozure runs on ARM on Linux: http://ccl.clozure.com/download.html
Yes and no. You're right insofar as Safari is the only thing that can set the execute bit on writable memory, but you're not strictly limited to interpreted Lisp if you go the Gambit Scheme route, where you can compile to C any non-eval'd code. There are at least a few apps in the app store that have gone this route.
https://github.com/dto/emacs-config/blob/master/color-theme-xiomacs.el here is the theme
Thank you very much appreciated :)
A threaded interpreter is also an option. You can get really close to compiled performance that way. 
Unfortunately can't properly submit a link to the news entry on sbcl.org, as Reddit doesn't understand that news.html#1.0.48 is different enough from news.html#1.0.35 to warrant notice... 
Wow, thanks for the link!
neat, I'll have to try that !
After watching the Land of Lisp music video YouTube helpfully suggested [this as the next video to watch](http://www.youtube.com/watch?v=dLLDWw7r3nQ).
Clisp runs on the Nokia N900/Maemo: http://www.reddit.com/r/n900/comments/av7h8/clisp_248_with_ffi_on_maemo_5/
I am *there*! Thank you, this is awesome!
Yes, I came here to say the same. There's a good hello-world type how to here: http://per.bothner.com/blog/2010/AndroidHelloScheme/
you can trick reddit into thinking it's a new link by adding a variable to the link, for instance http://article.gmane.org/gmane.lisp.steel-bank.announce/123&amp;dummy
Nice. For nicer syntax for the Objective-C calls they could incorporate PJB's [Objective-C reader macros](http://groups.google.com/group/comp.lang.lisp/msg/f7966bf3df9f716c).
Thanks, you reminded me to check a subreddit I run. It always seems like false positives queue up the day after I start forgetting to check on it.
I really like your theme: usually I go for darker backgrounds, but this appeals to me and I'm going to give it a go. WRT proportional fonts: back in the day I remember using proportional (and italicized!) fonts in comment blocks, while the code was in monospace. I think this was probably more due to the novelty of actually being able to do so than anything else. For documentation I actually prefer a proportional serif font, even on screen, but for code san-serif monospace all the way: Consolas. 
So cool! Where can I buy one?
Good work. A minor suggestion: show off Quicklisp instead of ASDF-INSTALL. 
[Buys.] Sweet.
The link gets me to Google Groups, which requires me to create an account. The App Store accessible through my MacBook Pro knows nothing relevant about either Gambit or Scheme and nothing at all about Gambit Scheme. Is there some other source of information, or do I need to go through Google Groups? Edit: I don't have any iOS device, in case that's relevant. But being able to fiddle with Scheme directly on an iPad would be a consideration.
Here ya go &gt; A version of the Gambit Scheme system for iPhone/iPod touch/iPad is now available on the Apple App Store: http://itunes.apple.com/us/app/gambit-repl/id434534076?mt=8&amp;ls=1 "Gambit REPL" is a complete version of Gambit (http://dynamo.iro.umontreal.ca/~gambit) including the interpreter, debugger and built-in library (but not the compiler). The standard REPL is provided and also a script editor. Scripts can be saved, attached to function keys, and the "main" function of the application can be redefined to customize the application to your needs. Applications can be debugged remotely by telneting to the device from a desktop machine. &gt; &gt; The application is sold for $0.99 as a demonstration that you can distribute on the App Store paid applications written in Scheme and containing an interpreter, something that wasn't clear with previous versions of the App Store developer agreement. &gt; &gt; A version of Gambit REPL for Android is not planned (by me). The Gambit Scheme system compiles fine on Android (for example see https://github.com/seoushi/gambit-android-example), but the user interface layer would have to be changed and tested, and I don't own an Android device. If someone wants to try porting Gambit REPL to Android let me know and I can help. The sources of Gambit REPL for iOS are in the examples/iOS subdirectory of the Gambit source distribution. 
Thanks. I wanted to do the same as in the Slime tutorial movie wherever it's possible in Slimv, and in the movie ASDF-INSTALL was used. But you are right, it's good to have some screens also on Quicklisp, I'll be adding that.
Thanks. That was exactly the information I needed. (Why someone downvoted you is beyond me.)
Requires iOS 4 or greater. Sad haflinger :(
I wonder what he did to his hand?
I thought that Apple's term only allowed applications to use the webkit JavaScript interpreter.
Either Apple has changed its terms or you have to get this app before it's pulled!
Like everything else he does, I'm sure it was something brilliant.
Looks pretty exciting! Gonna try it some time.
Insanity indeed.
Any interpreter is fine, the restrictions are: * No JIT (you can't mark memory pages executable; WebKit is the exception to this rule) * You're not supposed to download and execute scripts. (Again, WebKit's exempted). They don't trust folks not to introduce remote execution bugs.
as always, totally bitchin'
very interesting! especially - it has defmacro...
You should check out parenscript if you haven't already.
I know I've said this before, but quicklisp has saved me more time than any other application I can think of.
Time to rattle my [tip jar](http://www.quicklisp.org/donations.html)...
The macro system still has a major flaw in that arguments passed to it and quoted code is parsed into an AST when it shouldn't be. It works fine for simpler stuff but is very limiting. Fixing this (I'm the creator) is the biggest goal right now
Creator here, thanks! Let me know if you need any help. If I'm on irc I'll be in #pharen
By this point it might as well have its own interpreter.
A link that refers to itself. Is it art?
thanks, I deleted it, found bugs anyway
I highly recommend the font Inconsolata (http://www.levien.com/type/myfonts/inconsolata.html) for all coding tasks. It's very easy on the eyes and there is never any trouble telling the O's from the 0's.
I would usually use a text file. In this text file I would have sections for the class definitions and for the generic functions. Some also use the idea of a 'protocol', which combines related classes and generic functions. Finding the definition of a generic function or a method of a generic function is usually a task for the development environment. In LispWorks for example there is a generic function browser and the source code can be found with a click or in the text editor with the usual M-., the function ED or similar. 
Put it in a file. Also, I find it helps to think about the generic functions first, and their relationships. After that, I think about how to define classes and methods that make implementing the GFs and relationships convenient.
Thank you. I modified my question slightly; did you mean to suggest that all the code for your project goes into a single huge file? Regarding 'protocol', where can I find more information on this definition of it?
If you (defmethod foobar (…)), you can put it in a foobar.lisp file. You can put all the (defmethod foobar (…)) in your foobar.lisp file, then. Your functions doesn't depend on your classes : your classes depends on your functions. (but I may be wrong)
 (with-html-document (:stream stream) (with-document-preamble (:stream stream) (declare-title "Demo Page" :stream stream)) (with-document-body (:stream stream) (with-section-heading ("Demo Page" :stream stream) (with-paragraph (:stream stream) (format stream "Welcome to our site!"))))))) It's a bit strong !
&gt; What is the name of that file? Do both classes go into the same file as the generic function? What if Bar was a class I obtained from another project/package? Whatever makes sense. &gt; did you mean to suggest that all the code for your project goes into a single huge file? Probably not, unless it is a very small project. Typically in a project you have 'clusters' of logically related functions/macros/classes/generic functions. This relationship does not need to be formalized, but it exists. Think about order you would put it if it was a book: you'd break up your book in chapters grouped by some subject, then order material within a chapter in a way so that one could read it sequentially and understand without looking backward/forward too frequently. Just as with a book, your main goal is readability: computer will understand it anyway, but people will spend a lot of time reading and modifying it. So it should be readable and 'habitable'. For examples look at open source libraries. For example, cl-ppcre. regex-class.lisp defines various related classes, generic functions and methods. Then repetition-closures.lisp defines more methods on `repetition` class (which was defined in regex-class.lisp) together with helper functions/macros. This makes sense because there is a lot of stuff related specifically to repetitions and it would be sort of messy to put it all together with the rest. Another example: hunchentoot: acceptor.lisp compat.lisp conditions.lisp cookie.lisp easy-handlers.lisp headers.lisp lispworks.lisp log.lisp mime-types.lisp misc.lisp packages.lisp reply.lisp request.lisp session.lisp set-timeouts.lisp specials.lisp ssl.lisp taskmaster.lisp util.lisp It is easy to find something with this structure, isn't it? Here stuff is mostly grouped by classes, but one class = one file isn't a rule: taskmaster.lisp includes both generic taskmaster and implementation of a default taskmaster. &gt; What if Bar was a class I obtained from another project/package? You cannot add it to other project's file, can you? If foobar is related to foo then it makes sense to write it in foo's file. If it is a separated entity then you can write it in a separate file for foobar. 
I'm thinking cl-who and hunchentoot can still beat this. 
It looks like someone really hates special variables...
&gt; If I define classes Foo and Bar, and I write generic method foobar (accepts as params instances of Foo and Bar), where do I put foobar? Where do I put its defmethods? First of all, your understanding is back to front. CLOS isn't a "class-oriented paradigm". The reason we say "protocol" is because the design is structured around generic methods and how they interact. Classes largely exist as a means of dispatching the right behaviour and providing context. If you can track it down, [Object-Oriented Programming in Common Lisp: A Programmer's Guide to CLOS](http://www.amazon.com/Object-Oriented-Programming-Common-Lisp-Programmers/dp/0201175894) is a pretty great intro to CLOS. It depends on the size of the project, really, as to how you end up breaking up a project. Often I start with a single file and once the project gets more complicated, then I generally break it up into a file per component, with a generic protocol definition being its own component, and a concrete implementation being another. The other thing to realise is that a single file isn't necessarily a bad thing when you have such great code-browsing tools in a live environment. You'd be best to start reading the code in existing projects. Off the top of my head (pretty sure there are lots of others, but this is freshest in my mind), UCW's RERL protocol might be valuable to look at.
Can somebody highlight the differences between cl-http and hunchentoot ? Making a comparison page on cliki could be nice, but I haven't the knowledge to do it.
&lt;http://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)&gt; It is a bit like `interface` in Java but more general/flexible and informal: just a bunch of logically related generic functions + maybe classes + description of how to use it. It is quire similar to In simplest case it is just a bunch of GFs with methods defined for certain class. For example, acceptor in hunchentoot. If user implements acceptor subclass he might want to add methods to those GFs to support additional features of his subclass, but they are supposed to be compatible with existing GFs in some way ('adhere to protocol'). In more complex case it involves interaction of many classes. for example, acceptor might interact with request and reply classes and one who implements new acceptor/reply/request needs to consider whole interaction. As GFs are not attached to any particular class you do not really need to subclass anything to 'support' a protocol. Sometimes base class is defined for convenience. Sometimes it isn't and you're supposed to just implement certain methods. 
1. 2005? 2. wasn't lisp "not just for AI"?
That bit scared me away.
In LISP time 2005 was last month. Edit: And that's a good thing.
So... a common lisp wiki from 2005. But with [email instead of forms](http://lispwire.com/contribute), and [Franz owns anything you post](http://lispwire.com/legal) (though, to be fair, it looks like it might be ok to post stuff that you've released under GPL).
&gt; So... a common lisp wiki from 2005. It's not a wiki. More like a CPAN-wanna be. It never took off, obviously. It's almost as if xach posted it to embarrass Franz. Ironically, the replacement, quicklisp, was done by xach. &gt; Franz owns anything you post (though, to be fair, it looks like it might be ok to post stuff that you've released under GPL) FUD much?? The people that post stuff own it. You must abide by their license. All that legalese looks like protection for Franz if you use something that turns out to have bugs. The part you misunderstood: &gt; You represent and warrant that **you own all intellectual property rights in Your Content**. You hereby grant Franz a worldwide, irrevocable, royalty-free, nonexclusive, sub-licensable license to use, reproduce, create derivative works of, distribute, publicly perform, publicly display, transfer, transmit, distribute and publish Your Content and subsequent versions of Your Content for the purposes of (i) displaying Your Content on our sites, or (ii) distributing Your Content, either electronically or via other media, to users seeking to download or otherwise acquire it. This license shall apply to the distribution and the storage of Your Content in any form, medium, or technology now known or later developed. The bulk of that is making sure Franz can make it available once you agree.
lispwire.com was an experiment that was never publicized. Too bad that it hit reddit. We envisioned there would be a quicklisp-like front-end to it, but that never materialized. We're happy that Xach made quicklisp. We sort of forgot about it, since it isn't linked anywhere from franz.com, but now that we're getting so many kind comments here, we'll hasten its demise.
You may want to read the complete sentence. &gt; **You represent and warrant that** you own all intellectual property rights in Your Content. IANAL, but it seems like the complete statement says "Don't submit shit you don't own" not "We claim no rights on that which you submit". The remainder of the paragraph says what they're allowed to do with it and mentions nothing about them abiding by any other license you may have released the code under (which is why I put in the note that you might get away with releasing it under a license like GPL since that would prevent them from sitting on it and using it in house; again, I have no idea). I agree that they probably wouldn't do anything unsavory with it, but that wouldn't be because this agreement prevented it.
Who do you think "You" is? Franz or the person that makes their software available via the site?
It says, btw, this: &gt; You hereby grant Franz a worldwide, irrevocable, royalty-free, nonexclusive, sub-licensable license to It's a sublicense. **Clearly** Franz has to abide by the license. You are barking up the wrong tree here, trying to label Franz as "owning anything you post." That is just FUD.
SMUG is Drew Crampsie's monadic parser combinator library which inspired the talk. Here: http://common-lisp.net/~dcrampsie/smug.html
The person that makes their software available via the site (did I miss a definition somewhere?). The sentence seems to translate to (and correct me if I'm wrong and you are/know a lawyer) "Assert that you have the right to enter into this license agreement as the owner of the software you are submitting". It strikes me that the misunderstanding may be that you took "Franz owns anything you post" to mean "You transfer ownership to Franz". What I meant was, they demand &gt; a worldwide, irrevocable, royalty-free, nonexclusive, sub-licensable license to use, reproduce, create derivative works of, distribute, publicly perform, publicly display, transfer, transmit, distribute and publish Your Content and subsequent versions of Your Content for the purposes of (i) displaying Your Content on our sites, or (ii) distributing Your Content, either electronically or via other media, to users seeking to download or otherwise acquire it. You still get to own what you did, but they're under no obligation to release any derivatives of "Your Content" and all "subsequent versions" (and by extension I assume all derivative works of subsequent versions of your content). They can keep those under proprietary licenses, and they may or may not charge money for them ("royalty-free"). Maybe it's an unpopular opinion, but I prefer the share-alike licenses to things like this. EDIT: Incidentally, I noticed they have "distribute" in there twice. Or is "distribute and publish" something completely different...
The "sub-license" refers to "the license defined in this document", not "any license you like, as long as it fulfills these requirements". Again, correct me if I'm wrong.
&gt; They can keep those under proprietary licenses, and they may or may not charge money for them ("royalty-free"). This is just silly. The sub-licensable license clearly must abide by the master license. It says very clearly what the **purpose** of this sub-license is: &gt; (i) displaying Your Content on our sites, or (ii) distributing Your Content, either electronically or via other media, to users seeking to download or otherwise acquire it. That's pretty damn clear and not at all sinister ("ha ha, we re-released your software with our copyright!"). &gt; Maybe it's an unpopular opinion, but I prefer the share-alike licenses to things like this. Franz has a license based on the LGPL called the LLGPL. So, they agree with you. 
No, the sub-license refers to the license attached to the software being discussed.
So, whichever the submitter picks (as long as Franz is granted all of the rights mentioned above)? I stand corrected then, I guess.
&gt; This is just silly. The sub-licensable license clearly must abide by the master license. I'm actually not sure it works that way. It seems that this agreement asks that a submitter give Franz Inc. the rights mentioned above regardless of what license you've actually released the software under (or, at least, I can't find the bit that specifies otherwise). &gt; That's pretty damn clear and not at all sinister ("ha ha, we re-released your software with our copyright!"). The bit you quote doesn't seem to prevent the thing you mention in parentheses ("distributing Your Content, either electronically or via other media, to users seeking to download or otherwise acquire it" is a pretty broad statement). Again, I'm not saying Franz actually *would* do this, but it doesn't seem like this TOU would prevent them from it. &gt; Franz has a license based on the LGPL called the LLGPL. So, they agree with you. Cool.
One important difference to many people is that the cl-http license imposes many conditions on the behavior of applications that use cl-http, and hunchentoot does not. Here's an excerpt from the cl-http license file: By using the server or retaining a copy of the distribution, you acknowledge that you accept the terms and limitations of this license. Personal, educational, and commercial uses are allowed and may incorporate CL-HTTP into applications provided that: a. The licensee preserves all original copyrights in the CL-HTTP files; b. The licensee clearly separates their own code from the distributed sources; c. The licensee submits any extensions or improvements to CL-HTTP to the developers at bug-cl-http@ai.mit.edu; d. The licensee prominently displays the fact that your application uses CL-HTTP; e. The licensee prominently indicates that CL-HTTP was developed by and is owned by John C. Mallery; f. The licensee advises their users that they may obtain the latest release of CL-HTTP from ftp://ftp.ai.mit.edu/pub/users/jcma/cl-http/ g. The licensee advises their users that that the homepage for the server is located at http://www.ai.mit.edu/projects/iiip/doc/cl-http/home-page.html h. The licensee informs the CL-HTTP user community of any novel or significant uses in a timely manner by submitting a short description of the server to www-cl@ai.mit.edu i. The licensee may not publicly redistribute CL-HTTP, except in exactly the authoritative form the licensee received the CL-HTTP distribution from ftp://ftp.ai.mit.edu/pub/users/jcma/cl-http/ j. Any modifications by the licensee to the authoritative CL-HTTP must be distributed publicly as separate entities; k. The licensee may not use the CL-HTTP technology for the purposes of illegal or anti-social activities. Anti-social activities include, but are not limited to, attacks on computer systems and acquisition of email addresses for the purposes of transmiting spam email; l. The licensee may not operate a CL-HTTP server without sending the HTTP server header containing the true CL-HTTP server name and version, as determined by the authoritative distribution. Nor may the licensee willfully employ other methods to hide the fact that the licensee is using CL-HTTP; M. Academic licensees who publish research papers or books building on CL-HTTP acknowledge that failure to cite their use of CL-HTTP in the development or deployment of research systems constitutes plagarism. To my legally-untrained eye, it looks like a joke.
Ugh. The only thing worse than newLISP is the rhetoric surrounding it.
It's not really necessary to provide the stream all the time. Below is also legal code: (with-html-document () (with-document-preamble () (declare-title "Demo Page")) (with-document-body () (with-section-heading ("Demo Page") (with-paragraph () (format t "Welcome to our site!")))))
Because Reddit is inplemented in Python. And there are a lot of us for which this is *still* a sore spot...
It was origionally lisp. But alas, the problem of nonstandard libraries pushed them to rewrite it. 
[Even God had that problem.](http://xkcd.com/224/)
I'm guessing nobody gives a shit about that kind of thing.
Why would an up-vote be an open paren, and a down-vote a closed paren? Somewhat arbitrary.
Lisp programmers cannot stand non-balanced parentheses.
While you are asking inane questions why aren't the up and down arrows in C/C++, Java, C# etc reddits {}? Why doesn't the python reddit use spaces? Why doesn't the forth reddit use : ;. Maybe the vb reddit could use begin and end.
Because Lispers don't even see the parens, hurr hurr hurr.
pfft perl. ruby and python are more intuitive and sometimes faster. 
Really good tutorial. Keep it up, I'll be reading.
Yeah, Perl is definitely intuitive: you cannot just learn language syntax, operators and functions (as with Lisp), there is a myriad of special cases and oddities and you need pretty damn good intuition to guess what language creators meant in this particular case...
And cl-who version : (with-html-output (*standard-output*) (:html (:title "Demo Page")) (:body (:h1 "Demo Page") (:p "Welcome to our site!"))))
Is there a reason, that cl-http isn't in quicklisp? (or have I missed it?)
It is not 'free' software.
One does not need to 'hate' special variables to generally prefer lexical variables.
So you think sprinkling everything with `(:stream stream)` is OK? Even when it is not useful in 99.99% cases?
Personally, I have no problem with that.
If you have no problems with boilerplate code I don't see why you prefer Lisp to, say, Java.
If I had problems with readable, compilable, debuggable and long-winded source code, I would not use Common Lisp, but Arc, J, Ruby, ... But I haven't. Paul Graham did not like that aspect of CL. He wanted short code, etc. So he moved on to create and use Arc. As I said, I have not short code as a first priority.
It might be interesting to mention that the CL-HTTP Primer runs in CL-HTTP and uses a specialized Wiki written by David.
&gt; Compression potential is essentially abstraction potential, or the level of abstraction you can comfortably maintain in a programming language. Assembly has no compression potential aside from functional decomposition while a programming language with a programmably compiler has infinite compression potential Surely you could write an interpreter of any language you would want in Assembly, and then encode the rest of the program as data for that interpreter? All Turing Complete programming languages can do this, it is a quantitative question of difficulty rather than a qualitative one.
&gt; Correctness potential is the potential for the compiler to check that the program is correct. This requires something of a type system and all compilers, dynamic or otherwise have it. Again fully typed functional languages such as Haskell definitely have this exploited while in C++ the exploitation is up to the discretion of the programmer There's a huge range in Haskell too: You can use uninformative types (e.g: IO a) for everything, and then the compiler will not help you much, or use very informative types (e.g: `[String] -&gt; Either ParseError CommandLineOptions`) in which case the compiler will help a lot more.
There are people who've defined rigorous definitions of the expressiveness of programming languages, which necessarily go above the Turing tarpit. That's probably not what the blog author is talking about though. Also, the author mentions somewhere about doing design by contract using a type system, but this necessarily limits what your contracts can express. If you're restricting contracts to very simple pre- and post-conditions, this might work, but then you're not really using contracts fully. There are efforts to statically verify contracts, but that's not a type system.
Actually type systems are quite expressive, and can encode any arbitrary proposition. Can you give an example of a contract, so maybe I can try to give an example encoding of that contract as a dependent type? See [Dependent Types](http://en.wikipedia.org/wiki/Dependent_type) for more details.
Yes, I understand that dependent types can encode arbitrary propositions, but then your type system isn't guaranteed to be decidable or you leave some things out of the language. For most programmers using a typical programming language (i.e. not Coq or Agda), I would think contracts make more sense. A typical example that's given is a contract that checks if the input is prime (not very useful in practice, but it's difficult in a type system).
&gt; Yes, I understand that dependent types can encode arbitrary propositions, but then your type system isn't guaranteed to be decidable or you leave some things out of the language I think either case proves to be unproblematic in practice. * If it is undecidable at *compile-time*, the worst case is that you get a false-negative, and can diagnose the problem at the safety of your development environment. This is better, from a safety perspective, from undecidability or bugs at runtime (if using runtime-enforced contracts). * Empirically, restrictions on languages (e.g: Allowing structural/inductive recursions only) do not pose real barriers on expressibility, and programmers using these restricted languages say that they don't seem to pose a real problem in practice. For the alternative to a runtime prime check, you would take as an argument a proof that the given argument is prime, and encode prime-ness as a proposition type.
I prefer optionally typed - but fully capable of full typing. I am interested in this too, since types seem one of the keys to C-like performance, dealing with Lambda-calculus being the other. Tired and not really able to absorb it very well, so i **should**(damn well) re-read this tomorrow. I did write one way of doing it *partially* [type calculation](http://ojasper.nl/essays/Type calculation.html#Type calculation)(bit badly written words, quite a while ago too), the idea is that you provide functions with a function that calculates the type based on the types of the input. For functions which don't have the function for the type given, it recursively for it, You can then recursively use these until you hit a function that has type-calculator.(Actually a bit more to the algorithm regarding LAMBDA and FUNCALL) (Of course type calculators can say 'for this input figure it out yourself') If the argument types are not specified, use of a function can implies different versions of a function. To save memory, some of those may require joining. For instance (defun sqr (x) (* x x)) bear in mind that all types should be s-expressions so variables can stay in types, if it is used with x (float) and x (int), you could have two versions, if you have (eql 4), that could be joined with the (int).(Inlining would be better, but in other cases not) The balance in joining is often a memory/speed choice. There are two main caveits to type calculation 1) unless the user intervenes recursive functions will result in a infinite loop, forcing a general type 2) OR types may turn up; (if x 1 2) has type (or (eql 1) (eql 2)), but also stuff like x an integer (if (= x 0) x 3) type (or (int) (eql 3)). So basically, you need to be able to simplify these types, and eventually make the optimization choice how to implement it. I did write a bit on this and think i got a pretty good algorithm to optimize using a function that tries to join pairs, plus an advantage, because it can potentially deal with ranges like (and (&gt; 0) (&lt; 1)). The idea of [regular trees](http://ojasper.nl/readmes/Regular tree.html#Regular tree) and simplification with them might help. 3) SETQ is very poorly covered.(You can fiddle a bit finding equivalences to LET, and ORRING and simplifying) Then again, allowing that makes things a lot more complicated. The other key is dealing with LAMBDA, for this one needs to try figure out what it takes to do 'the garbage collection' at compile time. I am trying to figure that out round now, but it is going slowly because i am not spending much time on it. *Naively* you just make a structure for each lambda with pointers to variables used in the LAMBDA and not arguments of the lambda. However, the lambda may be returned and the pointers would then point to freed data,(Of course using garbage-collected pointers would work too) the variables have to be allocated at the point 'down the lambda tree' where the LAMBDA in question gets used/funcalled. And that then requires one to inspect the functions the LAMBDA enters and if they use it, or pass it yet further along. To be honest though i do not fully understand it yet, and haven't implemented this 'lambda-resolving'. I feel i should learn lambda-calculus a lot better and try express the ideas in that and implement it according to it. Annoyingly haven't been able to find a good garbage-collecting C library either. (It would be more flexible, and i would be able to save many variables from it.) I shouldn't permit myself too much time on this 'exploratory' project. Some more notes: I am thinking the best approach might be a bunch of successive transformations on the code, and try make them as 'inspectable as possible'. For instance, it'd be nice if a user can easily see and control what types the implementation is making, so he doesn't have to waste time specifying types that are inferred anyway. Another case may be that you can expand functions, allowing only macros from some packages/in a list of given symbols/exclude symbols/function saying allow/disallow for macroexpansion. (I guess one could already make this in CL, it can be a bitch though, infact, [expression-scan/hook](http://lisp-editor.berlios.de/) is somewhere in there, it just reimplements the whole macroexpansion thing. Note that the links and the code you find there is a bit crappy, and perhaps older than what i have on my harddisk. I should make a github account or something, clean that up a bit for you...
rant: I am unable to understand the reasoning behind the rush towards fully typed languages. I have spent hours attempting to understand the benefits to typing and I have come to the conclusion that it is primarily a fad, with the added attraction of waving mathematics around. I am able to create larger working programs in Python and Perl. My Lisp project is growing as well, and its reliability is quite good so far. My experience with C++ (lots) and Haskell/ML (not much) is that type systems simply slow down development. C++ does have templates, which are great - that saves typing (but Common Lisp does the same thing, without the type requirements getting in my way). Constantly having to have all the thingies aligned to satisfy the type judgement system becomes onerous. The vaunted error-trapping of types also comes into play with a unit test/functional test that exercises that line of code. That is to say, good software development practices render the benefit of types null yet, the converse does not hold true. Types have been used to good effect in SBCL for code optimization. It is telling that the advice given is to use types to *optimize*, not as mainline development practice. Reiterated: Types are the fad of the current decade in computer science. Their benefit is largely minimal, and their cost is fairly significant. Or, put another way: a fully typed programming language is bureaucratic nonsense. /endrant This *is* a nifty project that demonstrates the strength of Lisp
For me, i is because you want the *compiler* to know the types. If you add two numbers, you first have to figure out which types the two numbers are, and then determine what the result type should be and then actually calculate the number. If this is all determined in compile-time you just have to calculate the number, and it also saves extra bits that would otherwise have to specify the type. Now what i do not want to do is have to tell what the types are all the time, i want the compiler to do it. Even if it turns out the compiler cannot figure it out, i want the option not to specify it, valuing my time(possibly temporarily) over the efficiency of the program. I do not want this option to mean that i use one language for choosing to specify, and another language not choosing to specify the language. Type declarations can also be used as assertions, although a valid use, the use seems overrated, doesn't always actually prevent any bugs, and can also be reached by plain assertions, it is no reason to make a new language. (There is also of course the use of types for overloading, choosing function depending on type and such, but i am leaving this out of consideration.)
Does [this](http://3bb.cc/tutorials/cl-opengl/index.html) help?
That is just what I needed. Thanks very much!
i suppose this means that the book will never be published :(
I am quite sorry to read that you were unable to complete this project. I wish I knew enough (and had the free time) to write a book on CL.
Just to be clear, this is Nick Levines book, and his blog I linked to
You make it sound like it's optional how much you want to compiler to help. Like you could use "uninformative" types and then the compiler won't bug you as much. But the compiler helps you just as much with very general types, it just won't let you do as much. It's not like the function "a -&gt; a" could do much.
If you still want it, I have some unfinished code which does this. When I'm home I can zip it up and send it to you. EDIT: Unfinished means not in a package. Also, do you know about the [lisp game wiki](http://lispgames.org/)?
It's okay because I have managed to get it working with lispbuilder-sdl-image. That wiki looks great a too, thank you!
You really can't understand type system evangelism until you *try Haskell*. You really can *use the type system to catch mistakes*. In general, I trust Haskell's type checker more than I trust my own ability to write unit tests. That said, I have found myself considerably more productive in Lisp.
If you choose to put all your computations in IO, and pass data around in mutable variables, then the compiler will not be able to help you much. If you use return values and arguments, it will help you more.
&gt; as a newbie If you mean that you have already know Lisp and can bash out [meta-circular interpreter](http://www.cawtech.demon.co.uk/lisp/interpreter/) just for fun, and you are fluent in C, but you are a newbie in the sense that you have never written an interpreter in a low-level language, then that looks like an interesting pdf. I might brush up my C and have a look at it myself. If, by newbie, you are indicating that you don't know Lisp, learning Lisp from that pdf is taking the extra-hard route. Just get an implementation of Common Lisp and play at the REPL. If you are a mathy person you will soon find yourself coding up an algebra system and enjoying yourself no end. How does Lisp work? You can come back to that later. 
An old [PDF]. Forgot to add that...
If I remember correctly the LISP (I think full caps are justified here) described in the book is rather archaic. Dynamic scope, only integers, lists and symbols as datatypes etc. Probably not that bad or difficult if you just want to learn the basics of implementing an old fashioned toy interpreter but if you want something that is actually usable there are better papers and books available.
I think you'd get more out of the little schemer... depending on your goals, of course.
I love stuff like this. Great post
You could also checkout [Lisp in Small Pieces](http://pagesperso-systeme.lip6.fr/Christian.Queinnec/WWW/LiSP.html) by Christian Queinnec.
Just read the wikipedia articles for these games, they sound like fucking genius.
&gt;If you choose to put all your computations in IO then your life will become nightmare in haskell, and you quickly revert back to normal practice :) I hear this myth that you can code in haskell just like before in java/c, but in practice it is not true. You literally cannot do that, because the more your "All in IO" program grows the harder and harder it will be to work with it.
I have a different experience. I find that i do a lot of mistakes when i work with sbcl or clojure and they do not help me much (if at all) catching them. I find that i run my functions primarily to find what did i screw up this time, and iterate edit-run cycle several times even for simplest functions to make them work correctly. But in haskell experience is wonderfully different. Most of the time if function compiles then it runs correctly the first time. This goes against my 20+ years experience and i feel a great gratitude towards haskell. I feel that it is my true friend. 
True .Excerpt : Exercise 28.7: Program the entire LISP interpreter in LISP to run on an available LISP system. Some trickery will be needed to make your interpreter conform to the GOVOL dialect of the LISP language given in this book. 
as a newbie : I've gotten till chapter 3 of practical common lisp, and chapter 2 of sicp. I haven't written an interpreter in a low level language ever. : -)
You are declining to say whether you have written a meta-circular interpreter before. Don't go straight for C. Write three or four Lisp interpreters in Lisp first. Create your own squamous and rugose dialect (with tentacles). Then stop and think. Has that scratched the implementation itch? What about using Lisp for something? I think that [p4bl0](http://www.reddit.com/user/p4bl00)'s made the best [comment](http://www.reddit.com/r/lisp/comments/hpxpq/interpreting_lisp_gary_knott_as_a_newbie_im/c1xgrqp). Lisp in Small Pieces is a great book. 
have i written a metacircular interpreter ? - no. I may not have an implementation itch. I'm guessing that I'm looking for a/the "...you will soon find yourself coding up an algebra system and enjoying yourself no end" experience, where 'algebra system' might vary .. maybe I need to stop reading and start writing ..... 
I agree, I am just trying to explain that in Haskell there are large ranges of programs from Type-Safety-Means-Almost-Nothing, to Type-Safety-Is-Almost-A-Correctness-Proof.
&gt; Reiterated: Types are the fad of the current decade in computer science. Their benefit is largely minimal, and their cost is fairly significant. Or, put another way: a fully typed programming language is bureaucratic nonsense. …until you have to refactor code. A type system will catch all the places which still need adjusting, whereas in a dynamic language you have to do considerably more manual work to achieve the same. Types allow you to write down invariants of your code, and the type checker can enforce them. If you are writing mission critical code, proving properties about your algorithms and their implementation might be important to you. E.g., NASA spends serious effort on a verified Flash file system for the next Mars mission, which provides certain functional correctness guarantees even in the presence of faulty memory, flipped bits, etc. Perhaps this is not so important if you are only writing some web service which can be restarted and nobody cares. I have some reservations about type systems myself, but stating that their "benefit is largely minimal" is ignorant.
Fans of the genre may like http://www.ifcomp.org/ 
anyone else not finding this on quicklisp? 
Ignorant? Please. Life-critical code has been written in type-unsafe languages for years and years. In terms of invariants, those can be designed as assertion-esque guards in development time, using the *full power* of your language instead of working in a semi-baked metalanguage. 
seems ok here ? (ql:quickload "clack") To load "clack": Load 11 ASDF systems: alexandria anaphora babel cl-base64 cl-fad cl-ppcre closer-mop drakma hunchentoot puri trivial-garbage Install 16 Quicklisp releases: arnesi cl-annot cl-modlisp cl-oauth cl-test-more clack clsql f-underscore fiveam ironclad kmrcl local-time metabang-bind rucksack split-sequence uffi 
http://www.xlisp.org/zil.pdf is also interesting if you are into this stuff. Instead of the traditional textual parser it might be worth experimenting with inverse parsers. As an additional benefit it would work better on touchscreen devices.
See [cl-cont](http://www.cliki.net/cl-cont).
I like playing with [cl-muproc](http://common-lisp.net/project/cl-muproc/), which emulates Erlang's actor model.
I worked on this awhile back, check out http://github.com/ryepup/rpd-coroutines I ended up with 2 coroutine implementations, one using threads and one using cl-cont. I like the cl-cont one better.
Even if almost all these rules seems logical for me, I've never seen anybody using the inequality signs to enclose a class name. What is your opinion about that ?
&gt; What is your opinion about that ? sounds like the author used to program in Scheme.
with (make-instance '&lt;example&gt;) the output #&lt;&lt;example&gt; #x302000B34C9D&gt; looks strange (the double "&lt;")
Thank you everyone! Excellent suggestions, cl-cont and rpd-coroutines seem to be exactly what I was looking for. CL-MUPROC seems like something worth studying in its own right.
I disagree with one-package per file rule strongly. I doesn't promote loose coupling any more than "all packages in one file" does. Either you end up with huge files, in which case there is no practical difference -- from coupling perspective -- between that and having many files sharing the same package, or you end up with a dozens of packages and files. In the latter case if each file and package truly represents a logical unit with a nice interfaces, again, there is no difference to "classic" style except location of the defpackage form -- which is a trivial difference. ...and if those units aren't so logical or the interfaces aren't so clean, you've done the opposite of promoting loose coupling: you've multiplied the number of interfaces which live in separate units, all coupled together. Spaghetti coupling is not loose coupling. I argue that when this rule makes a real difference, it is liable to steer you in the wrong direction. 
"Comments are optional." is a bad guideline as well. Comments aren't for the writer. They're for the reader. The distinction of docstrings and comments is good, but there are several invaluable kinds of comments that should never be optional: * When you implement an algorithm from literature, reference the paper or whatever in a comment. * If the order of things matters, but isn't obvious -- comment on it. "Must foo before bar because..." * If there are edge-cases that might not be correctly handled, but do not matter at the moment, mark them with a FIXME and note them in a comment. (Or the docstring -- but not all functions are API functions.) * If you're being clever, explain it. * If there is something done in an "not nice, but it works" way, mark that with KLUDGE, and explain why it is so instead of something better. If the reason is "life is too short", call it a FIXME instead. * Write high-level comments that explain how things hang together. If there's an up-to-date architecture or design document, you might not need this -- but documents desynch with code much easier than comments. They should not dwell on the minutiae, but guide the reader in the right direction. 
It's actually Dylan's naming convention...
Apple Dylan used it: (define-class &lt;point&gt; (&lt;object&gt;) horizontal vertical) 
&gt; Life-critical code has been written in type-unsafe languages for years and years. I don't buy this argument. For hundreds of year, stone-age tools like flintstone, a bow and an axe were enough to survive. That we have better tools than that is called progress. You will find shockingly little software that comes attached with correctness guarantees and liability, and enough times software glitches caused significant losses, sometimes of lives. That it does not [happen more often](http://www5.in.tum.de/~huckle/bugse.html) can perhaps be attributed to lessons learned and engineering practices. But that does not mean that we should not advance our tools. For example, the [Mars Climate Orbiter](ftp://ftp.hq.nasa.gov/pub/pao/reports/1999/MCO_report.pdf)'s loss due to unit mismatch could have been prevented with a type systems which tracks unit conversions, e.g., Andrew Kennedy's work on [Units of Measure in F#](http://blogs.msdn.com/b/andrewkennedy/archive/2008/08/29/units-of-measure-in-f-part-one-introducing-units.aspx) or the [Frink](http://futureboy.us/frinkdocs/) programming language.
Absolutely useless.
Looks like a list of idiosyncrasies. (Plus some obvious stuff.)
BTW, about OO style: things like library APIs need to be well thought-out, but if you're writing application, quickly, you can forget about niceties. So I've found a method to write class definitions quickly, for example: (defclass foo (bar) ((baz :accessor baz-of :initarg :baz) (quux :accessor quux-of :initarg :quux))) 1. Slot has a simple name, not prefixed by class or anything. If it is a name, call it `name`. If it is an id, call it `id`. 2. Slot have accessors named `slotname-of`. `-of` postfix makes sure that there are no name collisions with other (especially, non-generic) functions. It is always accessor, not writer or reader unless you're absolutely sure you need writer or reader. 3. There is always initarg or initform or both. (Unless you absolutely need unbound slots.) If you are not sure whether you need initarg then add it, it will never hurt. If you're not sure whether you need initform add it too. Initarg has same symbol-name as slot but is in keyword package. 4. :documentation is needed for complex stuff. I don't use :type but I see how it can be nice. Using these simple rules I'm generally able to write class definitions as typing speed. And result isn't too bad aesthetically. I've considered making a macro for trivial slot definitions like this, but then people who are not familiar with this macro will have problems understanding it. Typing isn't a problem anyway, it takes maybe few minutes to type class definition.
So do you have any tips on how to lay code out? Files and packages and so forth, on large commercial systems with long lives and lots of programmers (I'm curious about what large system development looks like in CL at the modern CL shops -- ITA, Ravenpack, Alphacet, Netfonds, etc etc)
I thought it was dead, even though it looks great. How is that working out for you? Also, AFAIK cl-muproc implemented processes on OS threads, is that still true?
Assuming you use Emacs as your editor, you could just use [redshank](http://www.foldr.org/~michaelw/emacs/redshank/) for this. Essentially it simply asks you for the class name, base class(es) and any slots. It then generates the class definition based on the rules you posted. While I'm not a fan of code generating wizards in general, this is one case where I find that essentially including the hypothetical macro output cleaner than the macro call itself.
What did you find particularly scary about Arnesi?
right you are, I forgot about Dylan. the underlying reason is the same, though: both are Lisp-1.
Code layout in terms of files should be primarily determined by ease of understanding. "Programs must be written for people to read, and only incidentally for machines to execute." Practical considerations in terms of ease of development are the secondary guide -- not unimportant, but secondary. A piece of code will typically be read much more often than written. Code layout in terms of packages... There is a reason I mislike long.dotted.names even though they are /excellent/ in avoiding name collisions: they also make it damned inconcenient to use fully qualified symbol names. Not using qualified names means you have to spend more time maintaining package definitions, and sometimes impedes readability. Re. IMPORT-FROM and DEFPACKAGE: while it can be good to avoid pulling in everything, it is also a tad nasty because it doesn't tell you when a symbol is exported and when not -- unless you write it like so: (defpackage :foo (:use :cl) (:import-from :bar bar:quux)) 
Right. In Dylan &lt;point&gt; is a variable which has a class object as its value. In Common Lisp *point* is a symbol which names a class and the class object is retrieved using the function FIND-CLASS.
I am not very versed on it; I did some fiddling with it and promised myself to use it more seriously later. I always tell myself I need to take time to explore it more. The big question in my mind: does a dying process send a signal to a supervisor process?
2. slotname-of I find this quite annoying. Used to do that too, but it makes lines unnecessarily longer, and at the same time confuses the reader (inconsistencies like type-of, class-of). 
&gt; Used to do that too, but it makes lines unnecessarily longer How so? By three extra characters? Seriously? Some people prefix accessor with a fucking class name. E.g. user's name would be user-name. This can be really long for a longer class names, plus causes problems with class hierarchy. Now if you use shortest name possible -- slotname itself -- it makes name clashes very likely and code can be confusing. Let's say slot is called id, should I call accessor just `id`? E.g. `(id instance)`? `id` is identity function in Haskell, so it is pretty likely that some functional programming library could define it as an alias for identity. Don't forget than in English noun and verb can be the same. For example, I have slots named `access-token` and `service`. Both can be interpreted as verbs. And `service` is a name of a generic function in UCW. &gt; inconsistencies like type-of, class-of I don't see any problem here. These functions take one argument (which can be an object instance) and return something. If object would have `type` and `class` slots readers type-of and class-of would be totally appropriate. So the only problem is that you cannot define `type` and `class` slots yourself, but I can live with it.
I quite like FOO-OF style too, but I don't use it nearly always. Sometimes the fact that the accessor is an accessor instead of a computation is incidental, and another name is more appropriate. Perhaps SOMETHING-FOO instead of FOO-OF or CLASS-FOO. Or perhaps just FOO or SOMETHING. Sometimes I expect to switch to using a DEFSTRUCT once things settle down, and don't want to rewrite all the call sites then -- so I may use CLASS-SLOT style. "A foolish consistency is the hobgoblin of little minds."
Hey, it looks like STL in C++. That can only be good, right?
 &gt;&gt; Used to do that too, but it makes lines unnecessarily longer &gt; How so? By three extra characters? Seriously? Yes. The waste is more apparent when you use nested "-of" accessors. &gt; Now if you use shortest name possible -- slotname itself -- it makes name clashes very likely and code can be confusing. That's why we have packages. &gt; Let's say slot is called id, should I call accessor just id? E.g. (id instance)? Why not? Are you expecting that (name &lt;some-instance&gt;) could launch missiles? &gt; id is identity function in Haskell, so it is pretty likely that some functional programming library could define it as an alias for identity. Not necessary, CL has #'identity. But I see what you mean - do you suggest we should keep things outside of CL in mind when coming up with names in our programs? &gt; Don't forget than in English noun and verb can be the same. For example, I have slots named access-token and service. Both can be interpreted as verbs. And service is a name of a generic function in UCW. This is valid argument, sure. I just don't think it's a problem which really occurs that often. &gt; So the only problem is that you cannot define type and class slots yourself, but I can live with it. Well, each way has it's pros &amp; cons. When I am in doubt, I check the style of most prominent CL project, where the best developers hack: (length (iter (for s :in (sb-impl::apropos-list "-of")) (when (and (starts-with-subseq "SB-" (package-name (symbol-package s))) (ends-with-subseq "-OF" (symbol-name s)) (collect s))))) 20 So, just 20 functions in the whole SBCL use "-of". Sure, SBCL does not use CLOS, but I guess when structure accessors are named &lt;structure-name&gt;-&lt;structure-slot&gt;, most straightforward adaptation of this naming scheme is to drop the &lt;structure-name&gt; prefix. Bottom line: I don't really care that much, just wanted to explain my reasoning. 
&gt; But I see what you mean - do you suggest we should keep things outside of CL in mind when coming up with names in our programs? No, I think we should avoid giving short names which are too ambiguous. &gt; So, just 20 functions in the whole SBCL use "-of". Sure, SBCL does not use CLOS SBCL is not an application. Application code is different from implementation code. &gt; That's why we have packages. If you use package prefixes you waste much more characters than `-of` suffix. &gt; but I guess when structure accessors are named &lt;structure-name&gt;-&lt;structure-slot&gt;, most straightforward adaptation of this naming scheme is to drop the &lt;structure-name&gt; prefix. I don't see how it is a valid reasoning. Using slotname alone is absolutely different from using classname-slotname. 
I did some wayback machine snooping and found these: http://web.archive.org/web/20041209171947/http://www.mit.edu/people/cadet/strokes-help.html http://web.archive.org/web/20041216154358/http://www.mit.edu/people/cadet/OLCCR/paper.html http://web.archive.org/web/20041204164312/http://www.mit.edu/people/cadet/strokes-algorithm.html
1997 xerox patent case: http://www.palminfocenter.com/news/5038/palm-xerox-patent-quarrel-continues/ The relevant patent: http://www.google.com/patents?vid=5596656
about those extra links: the papers about the Strokes-mode algorithm mention single and multiple stroke gestures (such as chinese characters) and if this was in GNU Emacs in 1997, then one wonders how long the Strokes-mode work was in the works before that, the Xerox patent filing date is Oct 26, 1995 
the gesture file is just data fed to the recognition algorithm. you can copyright a set of glyphs sure, but not the PROPERTY of those glyphs all being single-stroke. we have entered sheer madness 
Arnesi just feels too big and complex for my needs, it has lots of features which I'm not interested in and &gt;cps transformer - an ad-hoc, bug ridden implementation of half of call/cc. didn't encourage me to explore it further. Although to be fair most of the CL call/cc implementations seem to fit that description.
I don't see how Apple's distribution of Strokes-mode under GPLv2 could make a passage in the GPLv3 relevant. Apple isn't distributing it under the GPLv3, so they're not subject to it. If someone updates Strokes-mode to GPLv3, Apple is under no compulsion to start using GPLv3 unless they want to distribute that person's version of Strokes-mode.
I had a really fun time with this playing with lispbuilders-sdl. Having an open window and seeing code changes immediately take effect was really exciting. Even better was when I introduced runtime errors, I'd get a slime debug window and the animation/simulation would stop, and then I'd fix it and hit retry and the whole thing just came back to life.
Did you perhaps mean to post the link too? :) http://random-state.net/log/3516533762.html 
You're not forced to copy the code of #'foo1 into #'foo, you can simply (declaim (inline foo1))
That rather defeats the point. After you've done that recompiling FOO1 doesn't change things while while FOO-LOOP is running. The point is to lift out the loop body into an out-of-line function so redefinitions take effect while the loop is running. 
Hey, actually I just read that the GPL "later version" clause explicitly says there are no additional obligations imposed on the original licensor by some downstream recipient's choice of license version, so I was wrong about that angle, However, the FSF copyright date of 1997 is not that far from the october 1995 patent filing, I wonder if the MIT research going to strokes-mode was done before that time. I don't know if the Unistrokes patent covers the code in question, but I suppose I could dig into the materials and hope a non-patent attorney can make sense of it. 
Is this is an okay pattern? (defun foo () (do-stuff) (foo)) 
Bad idea. If the compiler doesn't TCO that -- which is not required in CL -- you will blow stack. If the compiler does TCO that, it may very well also convert the tail-call to a local entry point, so that redefinitions will no be picked up. Just stick the loop in there. 
maaayyybbeee
Does there exist anywhere a slime or e-lisp function that not only re-indents but cleans-up lisp code? By clean-up, I mean removes lonely parentheses, removes extra spaces, breaks long lines, etc.
reminds me of ASP.NET serializing the world and sending it that to the client as a hidden form field. If you weren't very explicit about discarding the state of an object server side you'd burden the client with a MB of garbage they have to download and then (worse) upload again when they submitted the form.
You can turn off ViewState for controls in ASP.NET, but then you have to handle setting the control state yourself.
These are old objections and are true for page based application flow. For a single page, complex, desktop-like application back button breaking is not a big issue. Continuation based web servers are a different _kind_ of abstraction.
I don't quite concur with this assessment as a whole. Like a lot of things, continuations-based web applications have a huge potential to be misused. If done properly, URLs should be properly named -and- will be able to operate with or without a continuation in play. My own applications have only used unique URLs in places where there is a complex interaction that must be started from the beginning. And the back button in these processes because they merely reset the process to the point in time before that page was submitted. The other issue is with AJAX, and I've been able to write fully degradable applications without any thought about the lack of Javascript on some platforms purely because behind the scenes a continuation is ready to pick up the slack. 
Yeah, we figured that out pretty quick. I thought it was a funny reversal from the bad old days (ASP/PHP/Perl style that had to work in IE4) where it's a pain to preserve all the state of your app across page loads to automatic statefullness where it's a pain to NOT preserve all the state.
I have a bit of a question. A function has 'externals'(what are they really called?) For instance the function here: (let (a b c) (lambda () (uses a b c))) Has a,b,c external, whatever in a,b,c has to live at least as long as lambda, and be accessible to the lambda. Now the question: Would it be a good idea to allow users to force externals into the lambda *and* have a function that can get them. Like slots. For instance this function would make a structure with a,b,c as elements (defun make-struct (&amp;key a b c) (lambda () (force-here a b c) ;Make sure a,b,c are 'absorbed' as externals. (not-callable))) (let ((struct (make-struct :a 1 :b 2 :c 3))) (list (get-ext struct 'a) (get-ext struct 'b) (get-ext struct 'c)))) ; result (1 2 3) Edit: Tbh i am a bit vague on what continuation passing style is! (Sorry!) Anyway, point is, this is a step in removing an element of a programming languages -the structure- and alleviates the opaqueness of LAMBDA a bit.
I agree with the author
The externals you are referring to are generally called the "environment" and the lambda is called a "closure". In a lexically scoped programming language, a closure captures its environment. In a dynamically scoped programming language, such as elisp and many of the early lisps, lambdas capture not the actual variables but rather just their names; that is, the `a b c` in your example is not captured at the time the lambda is *bound* but rather when it is executed, i.e. they will refer to whatever `a b c` are in scope at the time the function is called, in a sense making them implicitly passed parameters. Lexical scope is default these days, because dynamic scope is difficult to predict and reason about, and prevents many useful programming idioms. However kitchen sink languages like Common Lisp retain support for dynamically bound variables through `SPECIAL`, `DEFVAR`, and `DEFPARAMETER`, so you can choose which one you want when. As to your specific example, I'm not sure whether or not it's possible, I haven't done any "industrial" Lisp programming (i.e. not elisp) since, well, probably 1990. 
You may be setting clg5_status correctly, but then only displaying up to the next to last character (it looks like a fixed-width display at quick glance).
Would that be under the dialog box code or the LISP code?
Sweet Jesus, that's hideous. You have my sympathies. But if you're going to dump 4000 lines here, a little hint as to where you're working would help. Code has context, and context is important. Things you should ask yourself: * What is the value of sel_clgstr? * What is the documented behavior of the AutoLisp `substr' procedure? * What is the value of evaluating (substr sel_clgstr 24 1), given the value of sel_clgstr? * What value did you want instead? * What changes to the parameters passed to `substr' would give you that value? Good luck. You've made me feel a little better about what I have to work on this morning....
I'll work on these evaluations and get back with you. Thanks for your input. 
I think you mean the externals are the variables that are 'captured'(hmm potential for confusion with variable capture as-in macro abstraction leak) from the environment? Not all variables the closure sees are used, so some may be inaccessible. &gt; dynamic scope, each identifier has a global stack of bindings. Introducing a local variable with name x pushes a binding onto the global x stack ([wp](http://en.wikipedia.org/w/index.php?title=Scope_\(computer_science\)&amp;oldid=432996623#Dynamic_scoping)) I am thinking about lexical scope, to be honest, dynamic scoping seems a bit silly, too much about the implementation and too little about the language and what the implementations of the language are capable of. That said, if you take wp definition, i don't think the DEFVAR, and DEFPARAMETER are necessarily dynamic-scope things. It is a matter of adding the special variable as arguments to all the functions that use them eventually. More specifically, if the function contains a function that uses the special variable, or it uses the special variable itself, it must add the special variable as argument. I am trying to implement a little program that makes stuff C-like; closure/lambda creation is done by making a struct including the externals/captured environment, with a function that takes the struct with externals and the lambda-arguments as argument, calling the function in effect calls it. We're not there then, of course, variables can be captured by multiple functions. That is why the externals consists of pointers. And there is question when the values must be freed. Well, they need to be freed when none of the closures that were created are alive. Which happens when the closure are all either called or discarded. Not entirely sure where i am in implementing this though.. I think i can calculate to where it drags, and i can certainly determine the externals.. Still, needs more testing, and i tend to be rather slow in development.. It can just see which variables there are in a closure, and their names, thus GET-EXT can be implemented, i think. Which is nice, because that is a good step into discarding having too many objects other than closures. Just tag a closure as 'not callable' and use it as struct. Question is if you can do other CLOS-like stuff somehow too. (I guess that involves being to estimate types well.) Edit: Also maybe reaching reasonable efficiency for lists/arrays might require them to be separate types. This little project of mine aims to make an minimalistic lisp that can be optimized well, is fast, and tries to get 'language features' as much as possible via standard libraries.
Huh, weird... I was sure to put a link.
&gt; unless you want mindless monkeys writing your software. Unfortunately, some companies do indeed want this. The idea is that they can toss out monkeys they don't like and replace them with new monkeys. Because they're all mindless, it should be no more difficult than replacing hardware.
Link is down for me. Anyone have a copy? 
Google has it cached: https://webcache.googleusercontent.com/search?q=cache:4W3oeG5_uPwJ:random-state.net/log/3516533762.html+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;lr=lang_fi|lang_en&amp;client=ubuntu&amp;source=encrypted.google.com (Domain renewal snafu, coming back up in a few hours.) 
I'm not sure if I did this correctly, but here's a shot. 1. I checked this using: !sel_cgstr, the value returned 'nil'. 2. This function retrieves a string of characters, it follows this format: Syntax : (substr "string" startPoint numberOfCharacters) 3. So given that (substr sel_clgstr 24 1), would collect the string starting at point 24 and then using one character. 4. I want to characters, so I changed the 1, to 2. I went through the code, and changed all those variable to 2, and it was still forcing it to one character. Hmm....the search continues, I think I answered your questions correctly, let me know if I missed the mark and I'll keep plugging away at this code. 
...or just use http://193.64.31.178/ ... 
If sel_clgstr were nil, then (substr sel_clgstr 24 1) should also be nil, right? So it's certainly not nil at the time that you're calling substr. When understanding the result of an expression like (substr sel_cfgstr 24 1), the value of sel_cfgstr that you want is the value *at the time of the call to substr* -- the value being passed to the substr call. Let's try a simpler example. Let foo be "ABCDEFGH". (substr foo 8 1) would eval to "H". You instead want the result "GH". How would you modify the call to substr in this case? Hint: the answer is not (substr foo 8 2), because that starts at point 8, which you know is "H", and two characters starting at that point would go past the end of "ABCDEFGH."
Ok I see what you did there. I was thinking I needed it start at the same point, but allow for 1 more character placement. As luck would have it, the author of the code emailed me this morning [with the character length fix]. I was asking if I was on the right track, this was his reply: &gt;The code you changed was for a specific layer name length so instead, it needed to be copied, the total length increased by 1 and then the change you made. Several possible lengths that included the single status character had to be done as well. Also, there were several locations dealing with the clg5_status variable that needed attention. Is there some way I can load the text[s] of both codes and look for the differences? I would like to see what changed and where, without going line by line, but hey, I poured over each line this morning trying my 'fix'. Ask me how that worked out? --Not too good. ;-] It's always weird going through someone else's code-baby...given that it was 4000 lines and my barely literate ability to read LISP. I appericate the time and effort you took to reply for this thread, it didn't get a lot of attention or comments, but I heard a few years ago that the Proggit subreddits were some of the most friendly and helpful, that is still true today. 
&gt; Is there some way I can load the text[s] of both codes and look for the differences? Assuming that you have the two versions as text files, try `diff' on Unix derivatives, or WinMerge on Windows. I don't know enough about AutoCAD to say more. &gt; it didn't get a lot of attention or comments AutoLisp - they call it Visual Lisp now, I gather? - is an abomination, painful to read for anybody who loves Lisp. And this particular lump of code that you are maintaining is straight out of TheDailyWtf, in my opinion. It is good that its original author was willing to help. If you ever decide to get more into the code monkeying and less into whatever profession has led you to this point, please don't let AutoLisp put you off of Lisp in general. It really can be a lovely language. Good luck to you.
I've actually been interested in Lisp for a while. I like how it is put together, I've never used an emac before (I'm un clear if this is a machine or platform) Yeah they deem it VisualLisp which I think combines elements of VB and Lisp,but I'm not 100% sure of that. I know there are commands that start with "vlax-" and such. Using that guys code is a give catch 22 for me. I cant update it myself, yet I don't have the time/knowledge/effort to revamp it. And his code performs many functions AutoCad should have implemented long ago. I have literally 100s and 100s of his routines. I guess my affection for this bastard child of Lisp is born out of necesssity, I'm a draftsmans and it comes with the territory. 
http://repo.or.cz/w/sbcl/pkhuong.git/commitdiff/f0dad3a76bd0f71dd61f04d72b5866bbd26fcdf3
...meaning?
Presumably that it will be able to do some vector optimizations. http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions
Are you using paredit? That makes issues like lonely parentheses much more visible.
"16 Jun 2009", and it's still not in the upstream.
[Recently in SBCL-devel](http://sourceforge.net/mailarchive/message.php?msg_id=27644807)
Well, iff Angarivol cleans up his branch, it could indeed be soon. (I haven't checked, so I don't know if it actually needs much/any cleaning.) 
Look at the original poster (but it appears that their message has been gc'd).
NIL where?
D'oh! Helpful tip: (cons 'now (cons 'hiring nil)) (format t "~&amp;~a where?" (cadr *)) Edit: Same question here.
Ah, haha, sorry, I'm still learning :-). http://www.copyleftsolutions.com/content/en/jobs
Ah, well, it's not me that's hiring (although I do work there), I just figured /r/lisp would appreciate the humour. But go for it, I'm sure the big boss appreciates applicants.
I should soon (in the next ~8 weeks) find the time to solve the last couple conceptual issues I had with the stuff, and then merge Alexander Gavrilov's fork in. Then again, it's been "coming soon" for more than 2 years.
don't they know about LIST?
What about non-Europeans interested in working in Norway?
They're still working on bootstraping their system, and don't have `LIST` implemented yet. 
I have no idea, but I can't see how that would be a problem.
Note that I posted the image because I find it funny, I'm not recruiting.
If you're looking for a reference, learn how to look things up in the [Common Lisp HyperSpec](http://www.lispworks.com/documentation/HyperSpec/Front/index.htm), and how to parse its style. For a quick reference, try the [Common Lisp Quick Reference](http://clqr.berlios.de/). [Practical Common Lisp](http://gigamonkeys.com/book/) is online in its entirety, and is very good for learning CL. [Successful Lisp](http://www.psg.com/~dlamkins/sl/contents.html) and [Common Lisp: A Gentle Introduction to Symbolic Computation](http://www.cs.cmu.edu/~dst/LispBook/) are also online in their entirety, but I haven't read either one.
Some other links beyond what Xach offers (in no particular order): * Guy Steele's [Common Lisp: The Language, 2nd Edition](http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/clm.html). Predates the finalization of the ANSI standard, so some of what it contains is obsolete. But I still find it a useful reference. * Paul Graham's [On Lisp](http://www.paulgraham.com/onlisptext.html). The PDF is missing several figures: at one point someone had scanned these and put them online, but my link to them is broken. Still, it's an interesting read. * [Pascal Costanza's Highly Opinionated Guide to Lisp](http://p-cos.net/lisp/guide.html). Not really an eBook, but worth a read. * Nick Levine's [Fundamentals of CLOS](http://www.ravenbrook.com/doc/2003/07/15/clos-fundamentals/) may be useful, though *Practical Common Lisp*s chapters on CLOS are good too. 
There is also [Common Lisp the Language, 2nd Edition](http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html). It predates the ANSI standard but many people still like it as a *reference* since it discuses some of the decisions behind the language. Also something I found useful is an info formatted version of the [Hyperspec](http://bc.tech.coop/blog/031002.html). Very nice if you are using Emacs and you don't want to have to switch to a browser.
thanks :)
thanks :)
thanks :)
mark watson's 'loving lisp - the savvy programmer's secret weapon' -short and concise and more of a handbook... 
[link](http://www.markwatson.com/opencontent/lisp_lic.htm)
that information should be included in http://cl-cookbook.sourceforge.net/
sorry - most of that stuff is already there :)
Online Books - Tutorial: [Let Over Lambda -- 50 Years of Lisp](http://letoverlambda.com/textmode.cl) - Doug Hoyt (2008) [Lisp Primer](http://mypage.iu.edu/~colallen/lp/lp.html) - Colin Allen and Maneesh Dhagat (2006) [Perlish Lisp](http://cybertiggyr.com/perlish/) - Gene Michael Stover (2004) Printable PDF/Ps [Common Lisp First Contact](http://homepage.mac.com/svc/CommonLispFirstContact/index.html) by -Sven Van Caekenberghe (2008) - link to download page for book and code Mathematical/AI/Theory: [A Lisp through the Looking Glass](http://www.cb1.com/~john/thesis/thesis.html) - Ph.D thesis by John Sturdy (1991) 
some resources are here: [franz.com/resources/educational_resources](http://www.franz.com/resources/educational_resources/) including a guide on basic lisp techniques
So *that's* where that name came from in Franz Lisp! My group at Maryland in the 80's did a bunch of work with Franz's hunks - they were the basis of our Flavors implementation.
&gt; The order of display of hunk slots is historical in nature. For better or worse, the elements of a hunk display in order except that the 0th element is last, not first. e.g., for a hunk of a length n+1, (cxr1 . cxr2 . ... . cxrn . cxr0 .) That's a tease. I'd like to know the underlying reason.
In Franz Lisp, cons nodes were stored in memory as: 0: cdr 4: car so (cdr x) could compile into *x and (car x) into *(x + 4) (in C terminology). On CISC machines like VAXes, plain indirection was faster than indirection + offset, and cdr-ing down lists was common, so they made (cdr x) the fast case. Maybe hunks were cons nodes with extra stuff in the middle.
Naming CAR/CDR reader/mutator functions with names indicating the use of the underlying data has always been one of my favorite strategies for making Lisp more readable (and maintainable!)
There are several ways to work with data structures in Lisp. Using LIST, CAR, CONS, CONSP, CDR, ACONS directly in the application code is equivalent to level 0. * level 0: use lists and conses directly * level 0.5: use list and conses and hide them behind custom procedures * level 0.55: use list and conses to implement new data structures * level 0.56: use the macro DEFSTRUCT to define list-based data structures. That's an option of DEFSTRUCT. * level 1: use Structures. Lacks runtime flexibility and reflection. * level 2: use CLOS. Possibly too much flexibility and might need some custom macros to write shorter code. Some more exotic variants: * level l: use closures. Only recommend for special purpose tasks like callback functions. * level s: use symbols and their property lists. * level h: hash tables as key/value store 
&gt; I have a couple of suggestions that might the general imperviousness of Lisp code. You the verb.
This is one of the weaknesses of Land of Lisp. The author has code that uses lists to hold different types of data, and so you have to remember the order of things when you're trying to figure out what the rest of the code does. 
I'm reading Land Of Lisp at the moment. This is interesting.
&gt; level 0: use lists and conses directly I'd say there is a difference between using alists/plists and using CAR/CDR/CONS stuff. E.g. (let ((my-data (list :foo foo :bar bar))) (getf my-data :foo)) This is pretty much same thing as hash tables, but with direct construction via 'literals' and other niceties.
Great breakdown
That's the level 0.56.
Thnks! Fied.
Not just *Land of Lisp*. I have seen it pretty frequently in non-Lisp code as well. *Land of Lisp* isn't even particularly bad, since its programs are fairly short. I think it's a symptom of building programs top-down, rather than bottom-up. If you start by thinking about how you want to solve a problem, then identifying the basic abstractions is a pretty obvious step 1.
Hey, a &gt; squamous and rugose dialect (with tentacles) is important! 
Thanks for your article :)
That's great information. Thanks.
I don't see how DEFSTRUCT is related to plists. One thing good about plists is that they are unstructured and so you can combine them, add things dynamically, do some operation on all elements etc.
N 1. There is absolutely nothing that says that you must -- or even should -- patch production images on the fly. I would guess that the vast majority of systems out there don't. Consider it an escape hatch, not the front door. Similarly, the only time most people save a development image is when they have a crapload of dependencies they don't want to reload every time they start -- so they keep an image with those preloaded. Actual Common Lisp development is very much about keeping a reliable source to app path, not the Smalltalk thing where you tinker with an image till it works. Patching live images is very much an interactive development and debugging thing -- once you're done with that you check that a clean build from source does what it's supposed to. N 2. I'm not sure what to say, since I don't really understand the question. Meta: To learn any language properly you have to read good idiomatic code written in it (to pick up good style), and write plenty of code yourself. Only way to fluency is practice. 
&gt; The whole image-based repl-thing. I can see the appeal of connecting to a &gt; system and manipulating it on the fly. SLIME was a really cool piece of &gt; software. I'm just horribly scared of the idea that production system could &gt; become hotfixed to the point where it's nothing like the source code. (I &gt; suppose this is like people being hesitant when they first learn power tools. &gt; Yes, you can hurt yourself, but you can do much more with them.) I was at a &gt; conference last year and there was this Smalltalk guy giving some demos, and &gt; at before one demo, he said "I can't run this one for very long, the image &gt; leaks memory and crashes and I'm not sure why.". That sort of thing would &gt; keep me up at night. I guess I like the certainty of compiling a binary from &gt; a checkout and knowing how to repeat that. I've never used SLIME but I used Geiser, which is almost the same thing but for Scheme (Racket and Guile implementation). I'll answer your concern in two points: * First, this ability to manipulate the system on the fly is mostly awesome for development and prototyping (prototyping is just a word for early development phase, since the "prototype" code almost always end up in the production / final code ^^). You don't have to use it once you're in production (in fact you don't have to use this feature at all, but you'll miss a lot ;-)). * Second, Geiser, and I suppose SLIME can do the same, allow you to interact with the REPL from your source file, and that's actually how you do it most of the time: you tweak your source file / fix a bug / ... and then tell Geiser "reevaluate this sexp/function/module..." as if you had typed it in the REPL, so the system is hotfixed but never goes to a point where it is "nother like the code" :-). &gt; It's funny, though, because long-running servers like MUD servers, when &gt; written in a language like C, often have a copyover feature that's a very &gt; much like a poor man's REPL. See the Greenspun's Tenth Rule :-p. &gt; I have no idea how to structure a lisp program at the module level. (Or a &gt; Haskell program, so it might be functional languages in general.) It's taken &gt; me many years to get a style for C programs that I'm happy with (in terms of &gt; program structure, &amp;c.). It's the same problem I have now that I'm learning &gt; Lua: I have all these tools and ways of structuring things, and I can't find &gt; things that feel right. I had to write and rewrite a project in C many times &gt; before I was happy with it, and I haven't found a better way of learning &gt; large-scale program structure in a new language. (Also, there were some &gt; specialist libraries, written in C, that I wanted to link against.) I also have this problem since I'm not an experimented Lisp/Scheme programmer myself, but those language are flexible enough that you can start by organizing your code as you would do in C (so OOP-like organisation) and progressively change your software architecture style to a more functional one (where it makes sense, for instance GUI programming clearly is a field where OOP seems better to me). My 2¢. 
Everything I said here was wrong, so I'm deleting it.
I wish I could downvote more than once for the claim that lists do everything.
If when you say "lisp" you mean "common lisp" than lists are most definitely not used for everything. In-fact common lisp has lists, arrays, and hash-tables. Lists have their benefits, and are useful for a great many things but they are not the only data structure in common lisp. Lists, as you mention are slow for some operations, but are very fast for others, this is why you only use them where their disadvantages do not apply. When writing common lisp and you find that you need a hash-table, use a hash-table. When you find that you need an array, use an array. Don't feel you need to stick with lists all of the time.
1. Saving Lisp 'world' into an image is merely a bonus feature of some implementations, it is not even in language spec/design. You shouldn't take it as something you absolutely need to use. And as others have said, "hot patching" of production servers is rarely used. But it is not very different from loading classes on fly in Java or C#, so it is not a thing which is unique to Lisp. If you worry about source of changes being lost modify code in source files and then 'hot-patch' it using `C-c C-c` in SLIME. `defun` straight in REPL is very rarely used. 2. It is perfectly OK to use just one package for your whole application. You probably need to organize code into multiple files to cluster similar things together. For a larger application you can introduce several packages: for example, 'front-end' and 'back-end', or 'view' and 'model'. Whatever makes sense. Perhaps some functionality can be carved out in form of library (a separate 'module') and re-used by multiple applications. &gt; I feel like I intellectually understand the bits that make lisp great, but I don't grok lisp. This just means you need more practice, knowledge of idioms etc. Check code which others are writing, it is a great way to learn something.
Patching a delivered Lisp system can also be done in a controlled way. For example LispWorks is a commercial Lisp development system. They have released a major version 6 some time ago. All bug fixes and enhancements are typically loaded into the vanilla released version. Usually they never release a new LispWorks image. All they release is a stream of small patches that are either loaded after the vanilla image is loaded or later on demand. The structuring of Lisp software is usually done with some built in functionality of Common Lisp (mainly packages and CLOS) and with a system definition facility. A system is a bunch of files that share some attributes (like a default package, ...), have some load and compile orders and which have some actions applied to them (compile, load, print, concatenate, ...). A system also may use other systems. For example your graphics editor system may use the Postscript system. A typical system has a file which describes the system (name, locations, subsystems, dependencies, default package) and its components (files, their names, types, ...). Typical components then are a file which describes the package (the namespace), a file for classes, a file for macros, several files for functionality. It may also have exampe code in some files and a test suite. Generally this is not much different from other languages, but the details may look very different, especially since most of the tools are written in Lisp itself.
One thing that has bitten me a few times: don't rename defuns. this is the path to images not looking like the source. old defuns remain in the image even though they are gone from the source. I always fancied a warning for that, but never finished coding it.
It is even worse with methods which are no longer there. fmakunbound would do one defun, but with GF you need to reevaluate all method definitions after you do this.
In LispWorks: * Mark a region containing your definitions * M-x undefine region * select the definitions to remove and press okay * rename your definitions and compile them 
Disappointed that it didn't turn out to be a 3D remake of Blackthorne, the SNES game. Still very cool though.
You could always redefine defuns that you intend to be "dead": (defun dead-function () (error "This function is dead!")) 
That would be *Blackthorne*, but yeah, I was thinking the same.
link?
"I have discovered a truly marvelous lisp tutorial, which this margin is too narrow to contain."
phantom fermat
OOPS! [here's the link](http://www.cs.gmu.edu/~sean/lisp/)
lol sorry [here's the link](http://www.cs.gmu.edu/~sean/lisp/)
The commenter is alluding to Fermat's Last Theorem: &gt;it is impossible to separate a cube into two cubes, or a fourth power into two fourth powers, or in general, any power higher than the second, into two like powers. More formally, no integer solutions exist for the equation a^n + b^n = c^n for all n &gt; 2. This conjecture was found on his copy of the Arithmetica, next to a problem asking to find general solutions to the equation k^2 = u^2 + v^2 for any given k. Fermat writes: &gt;Cubum autem in duos cubos, aut quadratoquadratum in duos quadratoquadratos, et generaliter nullam in infinitum ultra quadratum potestatem in duos eiusdem nominis fas est dividere cuius rei demonstrationem mirabilem sane detexi. Hanc marginis exiguitas non caperet. Translated from the Latin: &gt;It is impossible to separate a cube into two cubes, or a fourth power into two fourth powers, or in general, any power higher than the second, into two like powers. I have discovered a truly marvelous proof of this, which this margin is too narrow to contain. The conjecture eluded proof for hundreds of years; this lead to the statement being famous, because of the mysterious, elusive "marvelous proof". The commenter is noting that the original post has stated that he "found this tutorial to be a HUGE help", but did not link to the tutorial itself. Something that would be a "HUGE help" would be desired by all, much like the elusive proof of Fermat's Last Theorem. The commenter is therefore comparing the two using an allusion.
This commenter feels greatly honoured.
Congratulations, now you'll have generations of lispers hunting down "blue1_'s Last Lisp Tutorial".
edit your post plz
The first few comments are worth a read too (though it quickly degenerates into a squabble about the definition of equality in pure/assignment capable languages sparked by a link to [this](http://www.nhplace.com/kent/PS/EQUAL.html)).
*Dynamic!* *Static!* *Dynamic!* *Static!* Reminds me of another great debate: *Tastes great!* *Less filling!* All I know is that if you held a gun to my head and made me pick between CL and Haskell to use exclusively until my dying day, I could very well wind up shot. It would be a really difficult choice.
That could be interpreted as you saying you'd rather be shot than use either. I don't think that is what you're saying though
...which is strange. After learning new type concepts through Haskell, I explored Lisp's type features, and I discovered a different way to program in Lisp. In particular, it involves a lot more struct use and a lot less list use. I stopped being bothered with which low-level form of equality I wanted to use. This reminds me of [lispm's recent post in another thread](http://www.reddit.com/r/lisp/comments/i2qwf/some_lisp_suggestions/c20fg92), and I will be revisiting that post occasionally to track my progress. :)
Have you looked at [deftype](http://www.lispworks.com/documentation/HyperSpec/Body/m_deftp.htm)?
Put a donkey in the desert between two bails of identical hay and he'd die of thirst. No, wait...
Well, if I'm already using Python full time.... ;)
Yes, and I discovered that generics out-of-the-box do not dispatch on types; they dispatch on classes and structs. Why use struct instead of class to contain my value? I learned that although I can specify types for my class attributes, they are not honored during make-instance. They are honored during struct creation, though. So I end up with this crazy situation where, in order to handle the dispatch issue, I box my values in a fully typed struct. I made a promise to myself to learn how to alter CLOS to perform the checks during make-instance; then I could take advantage of all the relationship magic for my complex types. I have been asking myself if this is an abuse of Lisp or if that approach is an example of lispm's level 1. To achieve a proper level 2, one might need to understand MOP... or maybe that is level 3 ("roll your own CLOS to solve your problem").
&gt; I don't have time to create the complete GHC system as a DSL in Common Lisp. This is probably around 50 man years work. Programming is not building a brick wall. Here it is also an understanding issue. I am sure some people who develop Haskel(the language) can redo a most of it in a month. &gt; I find Haskell code prettier and easier to read (I find Common Lisp easy to read as well, however not as good Haskell). There is a point here for instance consider how many parenthesis making the `=` symbol saves; for `let` 4 and then 2 for every variable, `flet`4 and then 2^(3) for every function plus nestedness for those two.`defun` saves 2^(3) , `defvar` 2. ((3) is if you put function arguments in a list. Further savings are by polish notation. It is also fairly easy to implement, but the problem is that it looks ugly to us because we're not used to it and syntax highlighting doesn't highlight it. However, it is pretty perfectly transparent in how it looks as lists too, so in-principle, I don't see any reason to omit. fining `defun` and such if you do it by macro. Part of this is a missing `*expression-hook*`, or `*body-hook*`. Pretty long ago i wrote [expression hook](http://lisp-editor.berlios.de/autodoc/Package_EXPRESSION-HOOK.html#Package_EXPRESSION-HOOK), I see it does not clearly link to the [git clonable](http://developer.berlios.de/git/?group_id=10956). Basically you 'set'(use `let`! it is a special var) ` *expression-hook*` to some function that does whatever you want to, and then call `expand-hook`(the default of the var) to expand it, and return that. Then call `expand` on whatever you want. Also wrote a ['scanner'](http://lisp-editor.berlios.de/autodoc/Package_EXPRESSION-SCAN.html#Package_EXPRESSION-SCAN) gathering data with it(links to other functions, etc.), and used it to [autodocument](http://lisp-editor.berlios.de/autodoc/Package_GIL-AUTODOC.html#Package_GIL-AUTODOC), the pages there are autodocumentation. (I should've just used LML2 with a little 'shell' so in retrospect, instead of this 'GIL' thing.) (Oh btw, [*macroexpand-hook*](http://clhs.lisp.se/Body/v_mexp_h.htm#STmacroexpand-hookST) is not sufficient, and although i did start trying to expand [macroexpand-dammit](http://john.freml.in/macroexpand-dammit), i got turned off by use of `eval` encountered, and basically started from scratch. (There is a comment accidentally still mentioning it.) Sorry, i am just distracting for the point now. Very much later edit: some of this stuff may appear [on github](https://github.com/o-jasper)
&gt; There is a point here for instance consider how many parenthesis making the = symbol saves; for let 4 and then 2 for every variable, flet4 and then 2(3) for every function plus nestedness for those two.defun saves 2(3) , defvar 2. ((3) is if you put function arguments in a list. Further savings are by polish notation. Sounds like you might enjoy [Arc](http://www.paulgraham.com/arc.html).
Its pretty rare I ever find myself calling make-instance directly. Usually gets wrapped in something more API appropriate. You can then enforce types at this point. (defmethod make-foo ((alpha alpha) (beta beta)) (make-instance 'foo :alpha alpha :beta beta)) Also lets you have additional error handling, minimize the amount of information you export from a package, decouples the API from CLOS a bit, etc
Is this a commonly-held standard? It seems weird to me. I understand the utility of this kind of code: (defun red (color) ; color =&gt; (red-val green-val blue-val) (first color)) This kind of make-foo looks like arbitrary window dressing as opposed to useful function, kinda like using a macro to hide a quote. This make-foo is also inconsistent with the functions generated by defstruct; a structure foo's make-foo can take named values as opposed to accepting positional values. I know this objection is easy to overcome by just defining the make-foo method to have the feature, but that leads me to the last tentative objection... I always saw make-instance as similar to "new" in other languages and was comfortable having the generic operator. This make-foo method looks like the introduction of redundant code; it introduces a pattern (make-&lt;classname&gt; &lt;inputs in some arbitrary order&gt;). This line of thinking, though, has suggested to me that make-instance could use a higher-level wrapper to add in automatic and overrideable type-checking (call it "make-typed-instance", let it be a general operator/method, and leave the rest of the interface the same in order to be nice and flexible). On the other hand, make-instance already handles default values, and it is a generic method, which suggests that one could override the typechecks with useful errors as needed. The lack of typechecking seems like an oversight. Thank you for the insight, though. Please let me know if this is a typical standard and/or where my perception is a bit off?
Arc has that? Knew about Arc, but not that. I guess a lot of what i see there i like. 'Tricks' like `[* _ _]` for `(lambda (x) (* x x))` are nice, but we need more than tricks, i don't see much specificness about the 'axioms'.
I meant that Arc was explicitly designed to keep characters typed to a minimum, and it seems like you're counting them.
&gt; I'm just horribly scared of the idea that production system could become hotfixed to the point where it's nothing like the source code. Yeah, that's a thing to avoid doing. If you're going to hotfix code on production systems, you'll need a policy in place to make sure anything that gets on the system is also in the source. Not hotfixing at all is always an option too. &gt; I was at a conference last year and there was this Smalltalk guy giving some demos, and at before one demo, he said "I can't run this one for very long, the image leaks memory and crashes and I'm not sure why.". Was that a problem with the image itself, or did he just have a buggy program? In any case, Lisp programmers almost always work from source files, like C programmers. There's always the possibility of editing your program into an unloadable state, but any sensible person will reload the program from scratch periodically to make sure that hasn't happened. The Lisp image is not at all meant to be the place programs are stored. &gt; I have no idea how to structure a lisp program at the module level. Pretty much like C, I guess. More like C programs Java programs are, at any rate. Lisp programs are generally a bunch of functions and data types, just like C programs. You might want to dump them all in a package, which is something you can't do in C. For a really big project, you might want a few packages.
emacs
but C-s is Search!
&gt; Is this a commonly-held standard? Lord no, nothing I do is ;-) &gt; It seems weird to me. I understand the utility of this kind of code: &gt; (defun red (color) ; color =&gt; (red-val green-val blue-val) &gt; (first color)) Its the same idea, yes. &gt; This kind of make-foo looks like arbitrary window dressing as &gt; opposed to useful function, kinda like using a macro to hide a quote. Oddly enough I disagree. It may be somewhat philosophical, but to me "make-foo" implies much less than "make-instance". You're right, in the default case make-foo adds nothing to make-instance. But if I have a method like: (EDIT: Puri is a class used to represent URIs/URLs) (defmethod make-foo ((alpha puri) (beta beta)) ...) Now make-foo needs to call out over the network and retrieve a resource located remotely. Or its a clsql query and now its retrieving query results. Or whatever. To me anything passed to make-instance should simply end up as a slot value. The make-foo approach doesn't limit you to that. &gt; This make-foo is also inconsistent with the functions generated by defstruct; a structure foo's make-foo can take named values as opposed to &gt; accepting positional values. I know this objection is easy to overcome by just defining the make-foo method to have the feature, but that leads me &gt; to the last tentative objection... Don't use structs in my code, not overly worried about maintaining symmetry with them. Main problem with keyword args is you can't dispatch on their type in method definition (if memory serves me correctly). &gt; I always saw make-instance as similar to "new" in other languages and was comfortable having the generic operator. This make-foo method looks like the introduction of redundant code; it introduces a pattern (make-&lt;classname&gt; &lt;inputs in some arbitrary order&gt;). Sure, you could look at that way. But at this point, is there really much of a difference between: (make-instance 'class &lt;args&gt;) and (apply #'make-foo &lt;args&gt;) ignoring the keyword issue? The second approach may even be more generic in that it allows for data structures other than classes. No reason you can't do (apply #'make-your-struct &lt;args&gt;) or (apply #'list &lt;args&gt;) I'm not sure I see a pattern there beyond "function application returning a data structure". &gt; This line of thinking, though, has suggested to me that make-instance could use a higher-level wrapper to add in automatic and overrideable type-checking (call it "make-typed-instance", let it be a general operator/method, and leave the rest of the interface the same in order to be nice and flexible). On the other hand, make-instance already handles default values, and it is a generic method, which suggests that one could override the typechecks with useful errors as needed. Sure, you could probably look into the MOP for initializing an instance and add this in. That's the beauty of the MOP. You can easily modify CLOS to add these type of things. Check out the GF [shared-initialize](http://clhs.lisp.se/Body/f_shared.htm) for more. But, if you're going to add type checking to instance initialization then you also need to add it to slot access via slot-value, writers and accessors. Otherwise you lose all that security the moment someone accesses your object. At this point you're starting to move away from CLOS into something very different. &gt; The lack of typechecking seems like an oversight. I'm not so sure. &gt; Thank you for the insight, though. Please let me know if this is a typical standard and/or where my perception is a bit off? I think something important to remember is that in many ways CLOS is really based more on Generic Functions than classes. Many people will tell you you're better off deciding on the interaction between generic functions first and then go back and define classes later. I know Xach has several well written posts about this. I think your proposal gets away from that somewhat. I'm opposed to specifying types for slots beyond the case of _really really really_ needing to optimize code. Leave types for generic functions and methods. Essentially, care more about what your data can _do_ rather than what it _is_. EDIT: One last contrived example. This goes well beyond "type checking make-instance" into more of a discussion of classes, types and generic functions. It may not directly answer your question, but I think it may help explain why the apparent oversight of not checking slots is there. Start out with the following protocol: (defgeneric a (obj)) (defgeneric b (obj)) Now lets define an implementation (defclass foo () ((slot-a :initarg :a :reader a) (slot-b :initarg :b :reader b))) (defun make-foo (a b) (make-instance 'foo :a a :b b)) In this case, CLOS does the work of implementing it for us. We define our class, and CLOS is designed well enough that everything just works. Wicked. Good so far. Now let's implement a second implementation. (defun make-baz (a b) (cons a b)) (defmethod a ((obj cons)) (car a)) (defmethod b ((obj cons)) (cdr b)) Well, we're using generic functions and methods but we aren't even bothering with classes. But generic functions don't care how your data is defined as long as they have valid methods. Who cares if there's a relationship between the types? Now let's get a little weird... (defun protocol-dem (func a b) (let ((obj (funcall func a b))) (+ (a obj) (b obj)))) Now we can call it by (protocol-dem #'make-foo 1 2) or (protocol-dem #'make-baz 1 2) and get the exact same result. Or we can do something like: (defun weird-add (x y) (+ (a x) (b y)) and do fun things like (defparameter *x* (make-foo 4 5)) (defparameter *y* (make-baz 7 8)) (weird-add *x* *y*) and everything just works In terms of type, these two data structures couldn't be any further from each other if you tried. But if all you rely on is the generic method protocol defined with the generic functions a and b, it doesn't matter. That's the beauty of CLOS, and something that most other object systems really don't handle. You can recreate some of it with mixins or interfaces, but why bother? 
You can implement most of those tricks in Common Lisp anyway. 
I believe I see what you are saying, and I will just paraphrase it as I understand it here... This approach means you may define an arbitrary constructor for your class (or classes, even) with whatever parameters make sense for your need. You also hide the implementation detail of what kind of object you are constructing. There is the important idea that this style of programming is centered more around behavior on data than around the structure of the data. To answer my concern directly, your point is that if one is going to abstract away object construction in the first place, it would be redundant to check the types a second time during make-instance. Just checking in the protocol is sufficient. My concerns were based on a trivial example, but this approach is actually much more flexible for more complex situations. This looks good. Thank you for the details. :)
True, but still, everyone doing that on their own would make a horrible mess. But Arc obviously wants to do more than that.
via: http://spin.atomicobject.com/2011/06/22/conditions-and-exceptions/
Yup, you got it. Now, in light of all that... there's nothing wrong with the idea of a generic initialization protocol. Or having initialization be a part of an overall protocol. This is done in the MOP for example. Also a chance to show off EQL specializers... Using our example from before... If we add a GF to our protocol like so: (defgeneric a (obj)) (defgeneric b (obj)) (defgeneric new (type &amp;rest args &amp;keys &amp;allow-other-keys) If we assume the default case of a class, we can have something like: (defmethod new (type &amp;rest rest) (apply #'make-instance type args)) So the call to make-foo is now simply: (new 'foo :a &lt;arg&gt; :b &lt;arg&gt;) and make-baz can be defined as: (defmethod new ((type (eql 'baz) &amp;keys a b) (cons a b)) and similarly it can be called: (new 'baz :a &lt;arg&gt; :b &lt;arg&gt;) Its important to note that we never actually created a class or type called baz. We're just dispatching on a symbol. That's a powerful difference from adding type checking to make-instance. With essentially no overhead, we've implemented the factory (or abstract factory or builder) design pattern using singletons. That's pretty cool. **EDIT2:** But again, you can't type dispatch on keywords, so I'd end with a lot of: (defmethod new ((type (eql 'baz)) &amp;key arg1 arg2) (make-baz arg1 arg2)) so that I could still dispatch on my arg types. But depending on your application, that still might be a better solution, and you may be able to take care of that boilerplate with a macro. **EDIT: Long winded discussion on designing with generic functions after here. These are just my thoughts on the matter, put into words for the first time. Might be more for me than anyone else reading. ** But using the same technique of EQL specializers, we can just as easily implement the strategy pattern. Assuming a simple game with a generic function like: (defgeneric attack (strat attacker defender)) An Orc will always use his Ax: (defmethod attack (strat (attacker orc) defender) (print "Orc: I use my ax!")) We can implement a multitude of different strategies. Maybe a peaceful computer will apologize first: (defmethod attack :before ((strat (eql 'peaceful) attacker defender) (print attacker ":I'm so sorry!")) and a Mage has a 75% chance blocking an attack, but only against Orcs and only if the computer is set to peaceful: (defmethod attack :around ((strat (eql 'peaceful)) (attacker orc) (defender mage)) (probability-if 0.75 (print "Mage: Ha, attack defended!") ;If we defend (call-next-method))) ;If attack is successful But the mage is always killed if the computer is set to hard (defmethod attack :after ((strat (eql 'hard)) attacker (defender mage)) (print "Mage has been killed!")) Which gives us calls like (attack 'peaceful *orc* *mage*) ; Orc: I'm so sorry! ; Orc: I use my ax! (attack 'peaceful *orc* *mage*) ; Mage: Ha, attack defended! (attack 'hard *orc* *mage*) ; Orc: I use my ax! ; Mage has been killed! If later you decide that strategies also need to be able to save state, simply implement them with CLOS classes and extend the protocol with: (defmethod attack ((strat genius-strat) attacker defender) (select-optimal-weapon attacker defender)) and call it like so: (attack *strat* *orc* *mage*) ; Orc attacks with bow, it's super effective! and still have calls like (attack 'peaceful *orc* *mage*) ; Mage: Ha, attack defended! work exactly as before, with no need to refactor existing code. And as requirements change, you can keep extending that existing framework. (defmethod attack: around ((strat coward-strat) attacker defender) (if (&gt; (size attacker) (size defender)) (call-next-method) (print "Run away!"))) (attack *coward* *elf* *bear*) ; Run away! Maybe the call to size for the attacker is simply an accessor to a slot value and for the defender is calculated because he's a shape shifter. Doesn't matter, as long as the "size" protocol is properly defined. Let's assume that the original orc class didn't have a size defined, but it does have a level slot that we can use to calculate its size. We define a method then: (defmethod size ((orc orc)) (/ (level orc) 5)) And calls like this: (attack *coward* *orc* *elf*) ; Orc: I use my ax! **Still works!** Even though we didn't have any more than a vague idea that we wanted to implement strategies when the orc attack was defined. Since then we went from simple dispatching strategies to complex class based ones, added the concept of size to the game, added another type of entity (elf). You can also start adding in additional constraints using a class hierarchy if you'd like as well. In this example, we essentially implement an abstract method. Assuming a base class of: (defclass dragon () ()) You can define a method like: (defmethod attack (strat (attacker dragon) defender) (cerror "Error! attack must be defined for your dragon class!")) and then we can have a fire dragon (defclass fire-dragon (dragon) ()) (defmethod attack (strat (attacker fire-dragon) defender) (print "Fire dragon uses fire tornado, it's super effective!") And we can call it in all sorts of ways: (attack *coward* *fire-dragon* *orc*) ; "Fire dragon uses fire tornado, it's super effective!" And again, everything we've done before still works: (attack 'peaceful *fire-dragon* *elf*) ;Fire Dragon: I'm so sorry! ;Fire dragon uses fire tornado, its super effective! but if define another dragon class, an ice dragon (defclass ice-dragon (dragon) ()) and attempt to attack with that: (attack *coward* *ice-dragon* *elf*) ; And we're dropped in the debugger with our nice custom error message We find ourselves in the debugger. Now, any :around and :before methods will have been called, but to avoid that you can simply implement abstract methods using dragon for those as well, like we did with the base attack method. **EDIT** You can also use a base class to abstract out common aspects of method. So maybe every dragon needs to setup a 3D subsystem before calling attack: (defmethod attack :around (strat (attacker dragon) defender) (setup-3d) (call-next-method) (turn-off-3d)) Now to define the ice-dragon properly (defmethod attack (strat (attacker ice-dragon) defender) (print "Ice wave!")) And both the ice-attack and fire-attack are presented in stunning 3D. Since :around methods are called before :before methods, this means even a peaceful ice-dragon attack is presented in 3D. (attack 'peaceful *i-d* *orc*) ;3D on! ;I'm so sorry! ;Ice Wave! ;3D off! (attack *coward* *f-d* *elf*) ;3D on! ;Fire tornado! ;3D off! (attack *coward* *dragon* *elf*) ;should never be able to make a dragon directly, ;assumes someone called make-instance himself. ;dropped into debugger with our error. So you can certainly still rely on class hierarchies in CLOS to get your desired behavior. But even in this example, we can still rely on things defined totally independent of the dragon hierarchy, like the peaceful strategy or the coward strategy. That to me is the real power of CLOS and especially Generic Functions. With them you can develop things like class hierarchies in parallel, or add entirely new ones much later in development and still have everything Just Work. I'm sure you could implement a similar system in C++ or Java with enough work. But it would be work. It would require planning, boilerplate and a lot of things we simply didn't need to worry about. Our system grew quite naturally. Its also much more stable to change. One last example with this particular GF. At the end of the day, everything is tested and working, but a requirement comes down to add in-line strategies via lambdas. You're asked to implement something like: (attack #'(lambda (attacker defender) (if (&gt; (size attacker) (size defender)) (print "defender snuck away!") (attack *default-strat* attacker defender))) *orc* *elf*) ;Defender snuck away! (setf *default-strat* 'peaceful) (attack #'(lambda (attacker defender) (if (&gt; (size attacker) (size defender)) (print "defender snuck away!") (attack *default-strat* attacker defender))) *elf* *orc*) ;Elf: I'm so sorry! ;Elf attacks with his pointy shoes. Good luck doing that with C++ or Java. But with CLOS: (defmethod attack ((strat function) attacker defender) (funcall strat attacker defender)) One line method. No refactoring. Everything just works. Beautiful. 
In the Design and Evolution of C++, Stroustrup mentions that they considered restarts when implementing exceptions, but one of the committee members was the maintainer for a large lisp code base, and he said that over the years every use of restart was inevitably replaced by simple try/throw exceptions because whenever restart was used it inevitably was an abstraction violation. I don't remember if they go into why that was so.
Nowadays I mostly work in a file-based style; that's because it's what's easy with the tools I happen to have right now, rather than because of any strong preference or philosophical position. In the past I used a more image-based approach. Both approaches require some organization and disciplne. I assume that I need not describe the kind of discipline that makes the file-based approach work, because that's what you're already familiar with. When I had tools that made an image-based approach easier and more convenient, the way we generally worked was to establish a common baseline image that was shared among people who were working together. Each programmer then made one or more working images with a more specialized baseline, depending on what each of us was working on. We might update the saved state of that working image frequently, or, depending on the nature of the work, we might save off delta images at points where we believed things to be in a good state. Think of these staged images as having roles analogous to branches in a revision-control system. There's the image you are mainly working in, and there are fallback images you can use to return to some previous state, with some common baseline image as the last resort. Like everything, there are tradeoffs involved. Using images means you can get to exactly where you were yesterday in just a few seconds--including all the ad hoc data structures and stuff you built up for testing purposes and whatnot. As for hotpatching a production system, that's really a whole different can of worms. If you really need to do that, you need to design and plan for it. Having an image-based system can help in a couple of ways with that (for example, you can keep around a safe fallback image in case things go wrong, and use it to recover very quickly from disaster), but image-based development and hotpatching are really totally different subjects. When it comes to modularity, there's nothing language specific about that problem. You just have to develop a good modular model of your program in your head and try to organize your code to reflect it. Naming conventions can help document your mental model. In Common Lisp you can use packages to make your model manifest, and then you can treat cross-package references to unexported symbols as modularity leaks. 
The beauty of your post is that you showed off several ways to set up defmethods; prior to it, I was not aware of some of the syntax minutia. Great examples! (And, of course, you appealed to my Dark Mists MUD sensibilities with your use of RPG elements. Way to speak to the audience! :) ) I now understand one reason why eql is in the spec, and that is a pretty neat approach. Why eql and not eq? Support for global variable values? 
try this: [*Practical Common Lisp*](http://www.gigamonkeys.com/book/)
Why no love for loop? I used to hate the non-sexp extentions too, but then I started doing things like this: (Loop with hash = (make-hash-table) for i in list1 for j in list2 for k in list 3 if (or (and i j) (and j k) (and i k)) do (setf (gethash (or i j) hash) t) finally (return hash)) All this is very clean and nicely hides the complexity. 
I didn't get very far with this, on account of the experiment I'm conducting this week: I stop reading when I encounter a logical fallacy. &gt; That two accomplished and intelligent Lispers can disagree on the matter indicates that neither view is right or wrong, merely a matter of taste. It's saving me bags of time! 
Not that I have something against 'loop', but your code can be written as: &gt;(let ((hash (make-hash-table))) &gt; (map nil (lambda (i j k) &gt; (when (or (and i j) &gt; (and j k) &gt; (and i k)) &gt; (setf (gethash (or i j) hash) t))) &gt; list1 &gt; list2 &gt; list3)) 
Stop Reading!
[Iterate](http://common-lisp.net/project/iterate/) has all the advantages of loop and none of the disadvantages. I use it all the time. I've never understood why it isn't used more.
Anything with side effects reads as too complex to me. Where are Common Lisp's persistent tables? If I wanted to pitch memory around, I'd write in C. The idiom you clearly want here is a _fold_. This is just semantically _insane_. (Being a little facetious here, just for clarity).
It's an Englishism, a bit like lashings of ginger beer.
It's actually map + zip, or zipWith in haskell. zipWith3 (\i j k -&gt; any id [i &amp;&amp; j, i &amp;&amp;k, k &amp;&amp;j]) list1 list2 list3 Or, as shown by blandest, just "map" in Common Lisp.
You're right. Loop doesn't have the disadvantage of having to import potentially conflicting symbols into your package.
That was a woman from TI, who were selling the Explorer range of Lisp machines. Personally, having used Lisp Machines, I can't understand it. On the Symbolics side it was a huge feature and I, as a user, totally loved it. It was visible when some part of the system did not use it and restarts were missing. The condition system provided a lot of comfort and especially for me as hacker it was a great feature. I still like systems like LispWorks or Allegro CL, which make good use of the condition system in some places. TI was going into the Lisp business by buying the technology from LMI and the MIT. They got sponsored by DARPA - at a time when Lisp systems were a strategic mission for the military (and later when tried to commercialize those). They did a lot of development for their system, but Lisp was never really at home at TI (compared to LMI and Symbolics) and TI went out of the business with one single decision (other than Symbolics which was trying a lot of things over the year to keep at least something going). I can understand that for some technical reasons the condition system did not make it into C++, but to claim that it was not useful is just wrong. Later Apple used the idea of a condition system for their new language Dylan. See here: http://lispm.dyndns.org/documentation/prefix-dylan/book.annotated/ch13.html 
Its actually `zipWith3`, to be pedantic.
I'm always open to new ways of coding (especially in lisp since there are so many). "Land of Lisp" and "On Lisp" were huge eye-openers on how to use lisp as lisp and not C. There always seems to be a more elegant way to do thing with lisp, scheme and forth.
Hmm, odd, I thought I typed it correctly.
Check out Racket, it now has persistent tables under the `dict` umbrella which behave like Clojure tables, more or less. I really prefer to use them and write this kind of thing as a fold, where the table is the accumulator. 
I'm not sure. Certainly, breaking the back button is not a big deal for single-page, desktop-like applications. On the other hand, I'm not sure why you would want to use a continuation-based design in that case. The arguments for a rest-ish approach are pretty compelling.
Woah. Reminds me of scratch. Very cool!
Uhhuh. This (some (apply-partially 'string-match "projects") (mapcar 'buffer-name (buffer-list))) Produces a shitload of garbage whereas the loop-version runs in constant space. It may not matter for this particular case, but it does matter for a lot of stuff. 
Want [EdgeLisp](https://github.com/manuel/edgelisp).
This guy made me really happy by explicitly not claiming that dynamic typing was inherently better than static typing, but rather that each mode embodies a completely different way of thinking that carries its own set of advantages, even though he obviously personally prefers to spend most of his time in a dynamic type system. I completely agree with him on this, save that I personally prefer to spend most of my time in a static type system. :-) The sad thing is that this type of open-minded consideration of static versus dynamic typing seems to me to the exception rather than the norm (at least, among the kind of people who write their opinions on such things :-) ), with the far more common tendency being for people to trumpet their own preferred flavor as being the objectively superior one while dismissing the other as being inherently flawed. PS: Edited to polish some sentences and fix typos.
check out opticl: https://github.com/slyrus/opticl
oh, I see you already know opticl... hmm... ok, there's also ch-image :) but, seriously, do you find that opticl doesn't suit your needs?
It's not that it doesn't suit my needs. I am currently looking at many libraries, not only in Common Lisp, but also in other languages. I am learning about the different structures of many libraries and the performances they have.
There is [imago](http://common-lisp.net/project/imago/). And Nathan Froyd wrote up some [Blog Entries](http://www.method-combination.net/blog/archives/2010/09/29/optimizing-pixel-conversion.html) not long ago, which might be interesting to you.
If you want I can give you my cl-freeImage bindings. You can then use cl-cairo2 to manipulate the images. Very fast stuff. Also, I use sbcl, too.
Yes, please, I'd like to. 
URL?
I'll have to find a place to post it or email it to you.
I'll try to find a place to post it when I get home.
Github!
[Here you are...](http://goldenmeansoftware.com/download/CL-FreeImage.zip) This is just rough stuff I've written for Qix. (Universal Media Editor) I have some Pango bindings as well (for the text editing part). 
[Here you are...](http://goldenmeansoftware.com/download/CL-FreeImage.zip) This is just rough stuff I've written for Qix. (Universal Media Editor) I have some Pango bindings as well (for the text editing part). 
[Here you are...](http://goldenmeansoftware.com/download/CL-FreeImage.zip) This is just rough stuff I've written for Qix. (Universal Media Editor) I have some Pango bindings as well (for the text editing part). 
Somewhat hard to follow (for just me?) because Guy Steele SMACKS HIS LIPS BETWEEN EVERY PHRASE IN THIS ONE TOO. At one point he takes a drink of water and... oh god, I can still hear it. 
http://www.lambdassociates.org/ http://www.lambdassociates.org/Book/page000.htm 
&gt; This is a reasonably performant implementation (we haven't even tried to optimize it yet). &gt; A comparable implementation in Java/C++ will usually run a few hundred lines of code. While I liked the post, I think such a statement is misleading. A *purely functional* red-black tree constructs O(log n) new nodes in `insert` and `delete`. An *imperative* red-black tree constructs only 1 new node in `insert` and none in `delete`. That is why the latter takes a lot more lines than the former, *regardless of programming language*.
Interesting stuff. Looking at the history of languages and computer science really brings a good perspective on where we are and where we've come from.
Nice - new to Lisp, but looks like an elegant solution 
That's an interesting approach. (Haven't seen the code yet cuz pastebin's blocked from where I am right now, so forgive me if the comments below are off-target.) That seems like a fine approach to me. I'm assuming though that it doesn't support faces with normals because that syntax would probably make the Lisp reader mad: "f 1/1/1 2/1/1 3/2/2". But, beyond that, that's awesome. 
Also line continuations: \
For the face syntax "f 1/1/1 ..." and line continuations, I am going to extend the preprocessing state (the state where I merge the material file and the obj file into a new obj file) to something more sophisticated. Both problems could be solved with plain regular expressions but I want to find another approach - something nifty. I need to reread some pages from PAIP - there are some fine ideas regarding pattern matching. I want to start a discussion regarding code emitters, for instsance - I still have a not so good feeling when emitting C code with format. There must be other paradigms, more abstract ways to do this... 
What do you end up with?
The follow thread should be interesting to you. It discusses previous solutions that compile lisps to javascript. There is already some rudimentary clojure to javascript compiler. http://groups.google.com/group/clojure/browse_thread/thread/83c3c18951a764e2/73fdae1e56ffae71
Emacs is probably going to be the most recommended answer, and there is a package called Lispbox which contains a decent Emacs setup for learning Common Lisp, http://common-lisp.net/project/lispbox/
This is by far the most common answer you'll get here: [Emacs](http://www.gnu.org/software/emacs/) + [SLIME](http://common-lisp.net/project/slime/) I recommend installing SLIME via [Quicklisp](http://www.quicklisp.org/). 
I love the command line as much as the next guy, but I personally can't stand emacs. Vim vs. Emacs war aside, I just found allegrocl and I think I'm gonna stick with it. 
Check out parenscript, it does lisp-&gt;js. (Sorry, on my phone so no direct link)
Completely fair enough, good luck with your adventure into CL-land :)
Googled to help your phone out: http://common-lisp.net/project/parenscript/ http://www.cliki.net/Parenscript http://tryparenscript.com/ &gt;ParenScript is a small, Lispy language that compiles to JavaScript. So says the the project's page. But it is very small. So small, I don't consider it a language that compiles to JavaScript, but an alternate syntax for JavaScript. http://fitzgeraldnick.com/weblog/34/ 
You could look at Clozure CL. It comes with its own IDE, is free, and pretty good. Also, it contains some of my demo code, which is reason enough in itself.
See also https://github.com/manuel/edgelisp which is a Lisp interpreter/compiler written in js.
While we're at it, [scheme2js](http://www-sop.inria.fr/indes/scheme2js/)
[lispworks](http://www.lispworks.com/) has a free version with IDE. Some well-respected lispers use it. Also [Simv for Vim](http://www.vim.org/scripts/script.php?script_id=2531) And [Cusp for Eclipse](http://www.bitfauna.com/projects/cusp/) I can't vouch for any of these because I use emacs+slime 
Was gonna mention cusp as well. I'm another programmer who can't stand emacs, but loves lisp. I'm so glad that cusp exists.
How well-maintained is lispworks? Cusp sounds nice, but Eclipse seems a bit heavy for lisp. EDIT: lispworks is amazing. Its everything I was imagining when I asked for an IDE. Thank you.
(ql:quickload "mcclim") is pretty easy. 
Why put *,-, etc in the reserved words category? They are just functions and you don't always need them, so they should be shadowable. 
Although it targets Node.js, there is [fargo](https://github.com/jcoglan/fargo) as well. I've used it in some Node stuff I've worked with, and it was pretty nice. 
 (from mylib.util import a b c d) (import jQuery as $) (import backbone) (from mylib.todos import derp as herp)) [expr for ...bindings... in expr] [(capitalize name) for name in names] I know it's a direct copy from Python, but here it looks very un-Lispy, reminds me of LOOP syntax. How about (import-from mylib.util a b c d) (import jQuery $) (import backbone) (import-from mylib.todos [derp herp]) (for ...bindings... expr) (for [x y z] coords-list (+ x y z)) etc.?
The [Common Lisp HyperSpec](http://www.lispworks.com/documentation/HyperSpec/Front/) (CLHS)? If you just need to look something up, search through the master index or symbol index. If you're using emacs+SLIME there's a nice CLHS lookup feature. The command is "C-c C-d h", which looks up the symbol under the point if there is one, or prompts for a symbol to look up. I recommend downloading and using a local copy from [this page](http://www.lispworks.com/documentation/common-lisp.html). You can tell slime to use the local copy which should be faster.
and here's web lookup: http://www.xach.com/clhs also quick reference looks neat (for printing): http://clqr.berlios.de/
One release of SBCL had a bug where it couldn't compile CLX (it gave a "failed AVER" message). Make sure you're not using that version. 
In addition to the Common Lisp standard, available for browsing [online](http://l1sp.org/cl), check the manual of the implementation you're using, because it will describe important functionality not mandated or described by the standard, such as networking, threading, startup and shutdown options, and more.
this is exactly what I was looking for. 
Also [spock](http://wiki.call-cc.org/egg/spock).
Be warned, the Hyperspec can occasionally be obtuse. Eg, on reader macros: * a textual notation introduced by dispatch on one or two characters that defines special-purpose syntax for use by the Lisp reader, and that is implemented by a reader macro function. See Section 2.2 (Reader Algorithm). * the character or characters that introduce a reader macro[1]; that is, a macro character or the conceptual pairing of a dispatching macro character and the character that follows it. *(A reader macro is not a kind of macro.)* Emphasis mine.
In 2011, it's written "Lisp," not "LISP."
I'd say it's not even a matter of years, the name is "Common Lisp" not "Common LISP". "LISP" is an ancestor of "Common Lisp".
They're neat, but I haven't really found a sterling use case for them yet. CLSQL uses them to provide a pseudo-SQL-in-Lisp, which has issues sometimes with SLIME.
Thanks for the heads up on the spelling snafu. I wasn't aware.
The [Antiweb codebase](https://github.com/hoytech/antiweb) makes fairly heavy use of them to define automatically escaping strings for use with HTML generation. What issues does CLSQL have in SLIME? I haven't noticed anything other than having to evaluate `(enable-sql-reader-syntax)` at the beginning of my session.
True, and even that ancestor is now called "Lisp". Character sets now include lowet case -- we should make good use of it. 
Sometimes SLIME's REPL gets confused--or it did, a few years back when I was using CLSQL heavily. It was a minor nuisance.
I worked on [a language](http://littleb.org) which heavily relied on the reader to provide infix syntax (for symbolic math, and other stuff), hacked the square brackets to provide a syntax for relations, and even modified the dot to provide a field-access operator.
I would have liked a more in depth explanation of what was going on. 
I would still use LISP to make a distinction between the Lisp "family" of programming languages (which includes Common Lisp, the Scheme sub-family, Racket, Arc, Clojure, Qi...) and LISP, the original 7 intructions LISte Processing (only that, no macros etc.) programming languages (http://lib.store.yahoo.net/lib/paulgraham/jmc.ps).
I will agree that the command line version of emacs is a bit rough - but nowadays there are very good Graphical clients. GNU Emacs in particular has really good support for Windows, Linux and OSX using the native UI libraries. Anyways, Lispworks and Allegro are both commercial systems with out of the box IDEs so I'm sure that's everything you need right there. (send sublimepua :message "Enjoy!") Just avoid Eclipse for anything other than Java. ;)
My old copy of Winston &amp; Horn (1981) uses LISP. I checked out the last and 3rd edition (1989) uses capital L small capitals ISP.
This reminds me of nlet-tail in http://letoverlambda.com/index.cl/guest/chap5.html#sec_4
Upvoted, indeed.
I would love to see more programming tutorials written like this.
Thank you for this.
Spock and jsScheme look pretty kick-ass. Out of curiosity, anyone know any real websites that are lisp-driven on the browser end? I'd like to write websites that way, but haven't seen many examples.
None of CL-like JS-Lisps seem to implement their own stack, which precludes them from supporting TCO. (Unlike a lot of the Scheme-like entries). Found an unknown to me (or forgotten) way of achieving TCO; Cheney on the M.T.A. (http://home.pipeline.com/~hbaker1/CheneyMTA.html).
Note that both [Spock](http://api.call-cc.org/doc/spock/) and [Chicken](http://call-cc.org/) implement Cheney on the MTA!
I received some helpful feedback and have corrected a few entries and extended the table by two new implementations. Thanks!
And that should be expected since it's more of Scheme thing. 
As far as I know Parenscript is pretty popular and is used in multiple frameworks/libraries, I guess there are 'real websites' using it too, but I don't have examples... We had a beta version of a web app which used Parenscript for all browser side stuff, which was pretty extensive. But later we did a redesign and implemented a new version in pure JS. From this experience my impression is that using lisp dialect in browser makes sense if web app is big enough and requires OO design. Doing OO stuff in JS is PITA. Also, macros -- usually there's a lot of repetitive things... Otherwise there is pretty much no gain from using a lisp dialect, JS itself isn't a bad language and is very easy to learn, so there are very few reasons...
Thanks for the experience report :) I agree JS is not a bad language; for some reason I am still always looking for alternatives! Maybe it's just a syntax thing, not sure. The JS closure semantics are a bit frustrating though, compared to e.g. Scheme or Haskell.
It would be interesting to compare the performance of Chicken Scheme vs. Spock running on V8.
I recommend reading through http://www.gigamonkeys.com/book/ if you're learning Common Lisp. It sounds like it explains things in greater depth than the tutorial you're currently using. You should be able to find the answers to your particular question in the chapter on functions: http://www.gigamonkeys.com/book/functions.html.
I agree with the recommendation that you check out Practical Common Lisp, but to answer your specific question, the function adjoin takes an element (E) a set (S) and, optionally, a function used to compare E to each existing element of S to see if it's already in there. When a function has multiple optional parameters, it's common to make them "keyword parameters", which simply means you specify which parameter you are providing an argument for by putting the corresponding parameter name before it (":test", in this case). So, instead, you could put &gt; (defun set-insert (S E) &gt; (adjoin E S :test #'string=)) which would compare E to the elements of S by seeing if they have the same string value. But again, Peter Seibel [explains it so much better](http://www.gigamonkeys.com/book/functions.html#Keyword-Parameters)
ITEM and LIST are positional parameters. &amp;KEY introduces that the following are keyword parameters (named parameters). :TEST, :TEST-NOT and :KEY are names for three keyword parameters. All three need to be passed functions. Keyword parameters are optional and can be used in any order. Example: (member 3 '((a 1) (b 2) (c 3)) :test #'= :key #'second) -&gt; ((C 3)) 
&gt; can you have more then one test condition like ":test something something something and more something". Of course. You can write your own equality function and test whatever you like.
Just another perspective, in case it helps. I like to have examples. You asked what that function signature meant. The first part is pretty easy: function and two parameters. (member 3 '(1 2 3)) &amp;key is a symbol that says that the next parameters are optional named parameters, keys that may have values. As a general convention, keys in functions begin with a ":" character. So for this function, we have three optional keys. (member 3 '(1 2 3) :test #'equal) (member 3 '(1 2 3) :key #'+) (member 3 '(1 2 3) :test #'equal :key #'+) (member 3 '(1 2 3) :key #'+ :test #'equal) ; key order does not matter What the keys do is dependent on the function, but in general in Common Lisp... :test expects you to pass a function that is used to compare two elements for equality. :key expects you to pass a function that digs into an element for the real value you want to work with. In the above examples, I asked member to compare numbers using the "equal" function and to use the "+" function in order to find the real value. A note on that: (+ 2) =&gt; 2 so I was not really doing anything except wasting time. But if the element was not 2 but was, say, a list of two items, I might use a key of "car". (car '(1 10)) =&gt; 1 (member 2 '((1 10) (2 20) (3 30)) :key #'car) =&gt; finds a match! This is a good time to note that wherever you can specify a function with the #', you can specify functions you wrote and even anonymous functions. (member 3 '(1 2 3) :test (lambda (x y) (equal x y))) If you want to test more than one condition, you can write your own test function that you specify after :test. This is a silly example, though, because I can just use #'equal instead of wrapping it in a lambda. Watch out for that pattern. There are some other interesting keywords in signatures, such as &amp;optional. Parameters that follow &amp;optional do not have to be specified, but if they are, they must be specified in the exact order they are listed. For example: foo x y &amp;optional z w (foo 1 2) =&gt; x is 1, y is 2, z is not specified, and w is not specified (foo 1 2 3) =&gt; x is 1, y is 2, z is 3, and w is not specified (foo 1 2 3 4) =&gt; x is 1, y is 2, z is 3, and w is 4 
I don't really *know* Lisp. I've messed with Scheme, but that's about it. That having been said, this is really neat.
 curl http://www.reddit.com/user/scombinator/about.json | sed -re 's/^.*"comment_karma": ([0-9]+).*$/\1/' edit: this : (defun get-link-karma (about) (cdr (fifth (cdadr about)))) Is fucking horrible - see that 'fifth' there? That survives how many changes to the json format?
Indeed: (defun get-link-karma (about) (cdr (assoc :link--karma (cdr (assoc :data about))))) And modifying `get-about` to do the `(assoc :data...)` would be good too.
That's right. Tear those people down who dare not to code perfect. Tell them how superior you are.
Cool stuff! Quicklisp has really enabled development with Common Lisp.
Didn't attack the person
Thanks for pointing this out, I appreciate it. When i was writing this i was pretty sure there was a way to access this via parameter vs. positional but frankly didn't want to spend much time screwing around with it. Now I know about "assoc", many thanks :-)
Thanks for the effort!
Very cool, but 'quicklisp-quickload' should probably be 'quicklisp:quickload'
Congratulations SBCL hackers. '|:)|
What the heck is this all about?
Agreement with Guy Steele.
So all you wanted was a trace of a tail-recursive function? 
Unfortunately, this isn't a very good explanation. It turns the function calls into the jumps or it gets the hose again.
Well, the fact that the result at the bottom of the recursion is the same as the result at the top, and so we can short circuit unwinding the recusions. I always wondered why tail recursion was sought after - this ability to eliminate some calculations explained why. 
Maybe not the best explanation, but a start over where I was. 
Unfortunately it doesn't seem to emphasize an even bigger benefit: the ability to eliminate redundant call frames from the stack by transforming calls into jumps. This means while that an algorithm which is most clearly expressed recursively could easily blow your stack, tail-call elimination lets it not just be as fast as an iterative version, it *becomes* an iterative version. Can make debugging a pain though.
The function is also bad for using (= (length nums) 1) which turns O(n) algorithm into O(n^2 )
Normally when you do a function call, you save your spot in the current function (by allocating to the stack), and call the function. When you return from the called function, you pop the saved stuff off of the stack, put it back into registers, and continue execution. A 'Tail Call' is when a call to a function happens after everything else in that function has already happened. Everything has already happened, so there is no reason to save your spot. TCO is simply the compiler recognizing this, and not saving the spot. In the grand scheme of things, a function call is (pretty much) a jump to a different section of machine code. (Basically, you've got a pointer telling the computer which instruction you are on, and jmp/function calls are manipulating it to tell it that a different one is next). So additionally, what you can do is manipulate a recursive tail call to a given function into a jmp to the top of said function. The take-away here is that by not saving the spot, you save space on the stack (by not saving your spot), and can run recursive/corecursive functions in constant space.
That is the simplest part of TR. Sure, you can eliminate some jumps in the return, but that's pennies in the time of the function, and not particularily great. The thing about TH is that you can define a function like so: (defun factorial-helper (n result) (if (zerop n) result (factorial-helper (1- n) (* n result)))) (defun factorial (n) (factorial-helper n 1)) (defun naive-factorial (if (zerop n) 1 (* n (naive-factorial (1- n))))) The factorial-helper function is also tail recursive (proof left as an exercise for the reader). The important part is that (naive-factorial 100000000) will stack overflow, however (factorial 1000000000) *may not* (if the compiler does TCE, because, effectively, it can be transformed to this: factorial(n) { int result = 1; start: if (n == 0) return result; result *= n; n--; goto start; } 
Whether an explanation works for you depends on your background. [Here](http://lambda-the-ultimate.org/node/1331#comment-15125) is an explanation for those with some experience of assembler.
;; from norvig - paip (defun length=1 (l) (and (consp l) (null (rest l))))
Does this refer to a specific GS statement, or just that it is a good strategy in general?
Just to cause a little confusion; the naive-factorial does not have to stack overflow, *if* the compiler is smart enough.
You have to excuse me though, recursion seems to come natural to me. When I first started programming at the university I asked my professor why he didn't just run the same function again instead of looping. He said that was called recursion and that that was a topic for later classes. Though, he showed me some great resources which I have since lost on the matter.
Thanks for all the examples and explanations.
Thanks. Do you also know any other site that have something like homework assignments? I found doing assignments greatly reinforces what I've learn and what I haven't.
&gt; can make debugging a pain though, because debugging iteration is hard. ftfy
I don't - the guy made Java for fuck sake.
the best explanation i got was this : i saw the chapter on functions in 'programming from the ground up' - ((free online pdf)[http://download.savannah.gnu.org/releases/pgubook/ProgrammingGroundUp-1-0-booksize.pdf]) - then , I imagined all those calls NOT being nested ...
The problem is that not every tail call is conceptually part of an iterative process. Sometimes the tail call just happens to be the last thing the caller does.
im tracking the svn @ work...so I'm already testing :D
http://ticker.picolisp.com/ redirects to http://picolisp.com/21000 and http://picolisp.com/robots.txt is 'allow all', not 'disallow all'.
Did changing the version work?
Why would you need to type more than a couple of parentheses and a character if the IDE could (possibly) auto-complete them for you?
&gt; Unfortunately, this SME-music-content is not available in Germany &gt; because GEMA has not granted the respective music publishing rights. &gt; Sorry about that. Is there really SME-music-content in the video? Are there any mirrors?
Kind of remind's me of Haskell's do notation
My question would be how this compares in outcome and speed to iterated hqx. Lookup tables are fast.
For anyone who has the same question I did: &gt; **Will the talks be recorded?** &gt; Thanks to the generous support of Jeff Dlouhy and the [Northeastern University ACM Student Chapter](http://acm.ccs.neu.edu/), we will be video-taping all talks at RacketCon, and putting them on the web. Excellent. I am looking forward to seeing these, as I live in Texas and cannot go. I would have liked to attend the ~~TeachScheme~~ now [Program By Design](http://www.programbydesign.org/events) workshop at SIGCSE in Dallas but had to take care of another matter.
Well, according to the [linked paper](http://research.microsoft.com/en-us/um/people/kopf/pixelart/index.html), it looks better at least.
Dunno. Hqx preserves straight lines better. It doesn't iterate as well as I expected though.
good news!
http://www.jwz.org/doc/worse-is-better.html This article states the philosophical differences between lisp and c/java much more eloquently than the linked article. 
They don't talk about the same thing. The linked article talks about 'computer science'. The 'worse is better' article is more like a caricature about software design and was never really accurate. The author struggled with the topic for a while, writing various versions from various angles, which only made him look more confused. Even more funny is the relationship of the author of 'worse is better' with Common Lisp. He was running a company selling a Common Lisp system. But when the standard was published, the first thing he did was publish 'A Critique of Common Lisp' - a huge PR disaster. He then managed to run his company into the ground by spending the money earned from Lisp on a C++ development environment (based on Emacs) and compiler.
Actually, I think the main advantage of this algorithm is that it returns a vector graphic instead of a larger rasterized image, unlike hqx. Look at [this comparison](http://research.microsoft.com/en-us/um/people/kopf/pixelart/supplementary/comparison_hq4x.html).
cool even though I cannot think of an obvious use
It could have some FUSE-like properties to it if the code understands a filesystem (such as Ext2). Otherwise, perhaps a network mounted /var/log that does some log analysis on the fly or something? I'm not sure but it's certainly cool either way!
I don't think so. AFAIK CCL runs under iOS, but is not really robust.
No. Also, InspireData was written in LispWorks.
Hi Lispers, we just released a press release for semanticus.info: http://www.marketwire.com/press-release/derkeiler-gmbh-publishes-semanticusinfo-an-unconventional-dictionary-1539490.htm , which gives some background information about the site.
Hey I very much appreciate that you've taken the time to link these pages, thanks!
That's a good post, though I would not call a CL compiler a JIT compiler. The CL compiler can be used for some JIT purposes, but the usual understanding of JIT is that there is some kind of code, which gets automagically compiled at runtime - where the runtime system decides which code to compile, how to compile it and what to do with the compiled code (call it, cache it, meter it, ...). In most cases CL uses 'ahead of time' compilation, where all the code is already compile and under program control (not the runtime) new code gets compiled.
Thanks.
Ooh, another Scheme textbook.
 (reddit)
*slaps forehad* (I was thinking of something more involved, though.) To observe strictness (*in the most inane academic sense, for humor*) though, it should be (CONS 'REDDIT, NIL) or something like that. I'm trying to find the comment I read that had an example like that. *They were talking about a textbook where the author constructs lists and other things using the most primitive functions he can.*
&gt; (reddit) It is not incorrect that way it is just a function invocation. &gt;(CONS 'REDDIT NIL) ftfy.
But only theoreticians will say that. One might argue for `'(reddit)`
Slapping your forehead means, "I didn't think of that!" 
There always has to be a NIL, though, in that author's construct.
How about (defun ^o () (values '| (o_o)| '| \| | '| \\ /| '| ^^|)) So that CL-USER&gt; (^o) | (o_o)| | \| | | \\ /| | ^^|
There is a `nil` in `'(reddit)`; it's functionally equivalent to `(quote (reddit . ()))`, save for in languages like newLisp or Klone which have slightly different list mechanics.
Wow. That's ugly but hilarious that you actually thought of a way to do it.
Well, the theory I was consulting used commas to separate arguments, but no matter.
Lisp originally did have commas; iirc, the reason why they eventually made their way out of the language was because the original implementation treated spaces *as* commas. If you go back in time enough you can still see such code (and yes, every once and a while you run into "theory code" that still uses commas in S-Expressions).
Call it an 0.1; feel free to substitute some unicode characters to make it look half-way decent.
I had the verbose representation in mind, that's what I mean.
`cons` isn't really the 'verbose representation' though, dotted pairs are. `(this notation is really just syntactic sugar)` for `(this . (notation . (here . ())))`, just like lists in Prolog and other languages have sugar to make list notation clearer. `cons` itself is a function that creates pairs, so the application of `cons` results in the pair `(reddit . ())`, but isn't the pair `'(reddit)` in and of itself.
Okay, I suppose it depends on our frame of reference. Thanks for the info.
In terms of pictorial representations, the only ones I know of are: * A [lowercase lambda](http://en.wikipedia.org/wiki/File:Greek_lc_lamda_thin.svg) * The Lisp [lizard](http://www.normal-null.de/lisp_logo.html) * The Lisp [alien](http://www.lisperati.com/logo.html) I prefer the lizard, but EMMV. (Everyone's ...) EDIT: Add links.
Thanks for collecting these.
The number of major apps not working properly with Lion is slowly reaching a point where the responsibility should be reversed. Lion is apparently not existing apps friendly.
The current version is LispWorks 6. I have the 64bit version of LispWorks 6 and I don't see a problem.
Wow. It must be difficult to post "text" on a "website". 
Everyone will publish the new versions exclusively on the mac app store and you'll be fucked if you wanted to avoid that pile of shit.
I like the Lisp Alien the best.
http://jng.imagine27.com/files/cljs_ch.png ? That is not a convex hull.
Perhaps the OP updated the image, but the green points seem to specify a convex hull for the set. Could you explain what you think is faulty? 
UT is home to Moore &amp; his ACL2 system as well. The mother-lode. 
We used Tagging in Logo as well, the bottom two bits. It was on the 6502 and the TI 9900. I think it came from Gary Dreschers's Pascal Logo reference implementation for the TI. For example, in pointers to atoms, there were bits for dots and quite, (:X vs "X vs X). I always thought Gary got it from Tom Knight, but I could be wrong. I hadn't heard the JonL/RMS story. I do remember NIL got scrod by the uVax because NIL used RAM above the stack, and teh uVax decided it wasn't in the contract of the machine to not screw with RAM above the stack, so they used it for scratchpad for their microcoded engine. I still think they were wrong but I know folks who think otherwise. The other cool thing NIL did was use a NXM for unbound, so that when you later dereferenced it, it was a unique NXM and it could tell you the original local name of the variable that the null came from. It avoided doing unbound checks when passing parameters. It made debugging a little more painful but it was fast and preserved a weaker guarantee of the representation. I can't remember who invented this but I think tiw as Glenn S Burke.
sort of read like Lisp as a conspiracy theory
Very cool! Can you give us some implementation details? Server, database, libraries, etc.
Sure, we can give some details about the implementation: We're using LispWorks under FreeBSD as our primary development platform, because they have a solid multiprocessing implementation (very important for us) and the delivered images are blazingly fast. The site runs on a cluster of 8 FreeBSD servers, and uses two replicated MySQL Servers as backend. Here are some great libraries we can really recommend for CL web projects: -CLSQL -Hunchentoot -Parenscript -CL-WHO 
Coming back to the post. At least for Mikel Evins it turned out that he was not using 5.1 with the latest patches.
Excellent addition to Quicklisp, thanks again Xach.
It's amazing how many useful Lisp tricks from Usenet were posted by Rob Warnock.
He's given me permission to make a searchable archive of his Usenet history a la my [Erik Naggum archive](http://www.xach.com/naggum/articles/). It's been on the back burner, unfortunately; I think it would be a very useful resource.
Well written. While it wouldn't be a trivial effort, it seems like `eval` should be an explicit option, one that drags in the monumental set of dependencies. Any program compiled with a (non-optimized away) reference to `eval` would bring in the entirety of `eval` -- the full set of runtime libraries compiled against, as well as the compiler itself. Although the OP made it sound as if ClojureScript is not self hosting yet; that would put a damper on things. 
Perhaps the OP is refering to `eval`. I compute some new function, say `(lambda (x) (* x y))` where 'y' is some runtime value, and I want to compile it: (eval `(lambda (x) (* x (quote ,y)))) On many compiled Lisp, eval will return you a freshly compiled function. It's not a "true" JIT facility - I can't portably introspect the compiled result or save it, but I can probably the s-expr that produced it, and recompile it as desired.
Having a compiler available is nice for higher level tricks, but indeed, shouldn't be the default. Simple, fast code should be.
The article states that the support of Picolisp for not evaluating arguments conflicts with lexical scoping. However, it seems you could still achieve lexical scoping by allowing eval to take an environment variable *and* have the non-eval function call pass along the calling environment context. Or am I missing something?
http://cryptome.org/0005/dod-lisp-sol.htm
Hello this is David, I have been having Internet issues. I will send out an email later. -dto
I'm pretty sure you can implement `lexical-eval` and friends that carry over closure information. It's just not the default.
is he being subject to patent-trolling? (man, am I glad we don't have to put up with that crap here in Europe. Yet at least..)
Eval does take an optional env arg, and you can simulate lexical scope, of course. But there are more idiomatic ways, apparently, of moving state around in picoLisp. Haven't actually used it much myself, but I do think its an interesting example case. 
seems you have to be registered at Stanford to participate. 
Ah right, different picture. The one i saw looked like: .______. \ | \ | / | /_____|
Redditor since 2011-08-01
Very cool. I'm definitely signing up. A note: the class seems to be centered around [python](http://www.stanford.edu/class/cs221/materials.html)
I considered to apply to our local university to study AI but never got around to it. I'm pretty excited to participate in this class.
Heh, $95 for the Kindle edition of the book. Really?
At least there _is_ a kindle edition. I have the second edition, and I've been thinking of getting the third, but I've kind of been holding off as it doesn't quite sound worth it.. It might well be nice to have it on kindle. though, instead of another shelf brick. That's expensive, and maybe kind of crazy for a kindle book, though they really are kind of crazily priced in general. The kindle adds some value, maybe, but takes some away with how indexes don't work (in what I've gotten so far) and image pages are so small. 
Yeah, I have the second edition around somewhere... probably in a box. It would be super convenient to have an ebook version, but $95 is insane. The margins on eTextbooks are huge: you create the digital form once and that's really the extent of the production costs. It's extortion. But that's a different discussion. Kudos to Stanford for offering the class, *with* access to the instructors, for free. Looking at it that way, $95 (or the $115 or whatever for the dead tree version) is a bargain. 
Someone changed the Internet, we been done hacked! Yeah, that's a very liberal definition of convex.
Why would internet issues lead to the deletion of multiple online accounts?
So the implementation is not affected by http://www.lucidimagination.com/blog/2011/07/28/dont-use-java-7-for-anything/ ? Just wondering
Spooky ... :(
I got a used copy (2nd edition) on amazon for $10.
I've put back up my blog at http://blocky.io/blog and will be restoring my other sites soon.
Do you plan to take advantage of invokedynamic in Java 7, and how big effect would it have on performace do you think?
I emailed Sebastian Thrun and he's replied that the 2nd edition is sufficient. 
Hello everyone this is David O'Toole. I have taken a number of steps to protect myself from any retaliation (legal or otherwise) resulting from the appearance of parts of certain email conversations on Cryptome. http://cryptome.org/0005/dod-lisp-sol.htm I am no longer using any of my old accounts, and this is why I am using the account name "dto1139" to post this on Reddit. I can release a voice message later that should satisfy skeptics who watched my youtube channel in the past, and this will also match an as-yet-unreleased podcast interview I took part in. I have deleted my Facebook, Gmail, Blogger, Youtube, and locked down my Github for the time being. (Far from jumping into the Google Plus rabbit hole, I think this is a great time for everyone to ditch Google and Facebook and start using alternatives. In order to close my gmail account I had to ditch all my blogs at Blogger and all my videos at youtube---the more of Google you use, the harder it is to leave without destroying your online life.) Again my hope is that other Lisp programmers will be aware of the issues involved and will keep their eyes open. My blog is up at http://blocky.io/blog 
We haven't seen any problems with the infinite loop bit, but we haven't really had any reports of using ABCL with Java 7 in production. The GCL ANSI test suite has many loops, and both the compiled and interpreted version seem to run fine. 
Eventually we will use invokedynamic ("indy") in ABCL but there are no concrete plans for this at the moment. With the recent work on separating out the JVM class writer from the compiler, we believe that we are approaching a decent platform on which we can experiment with different JVM compilation strategies from Common Lisp. The first step will be the implementation of a Java 6 verifier which is mandatory for Java 7 JVMs. Any takers? 
just checking... did you write the blog post?
Yes.
Here's the message: http://soundcloud.com/dto/hello-from-david-otoole Older video with me talking: http://www.dailymotion.com/video/xkaqos_gnu-emacs-with-native-gesture-support-on-a-touchscreen-tablet-pc_videogames
First off, what the blog author doesn't seem to realize is that part of the reason languages like Ruby can compare to Lisp is that they borrowed language features heavily from it. Looking at a previous blog post by the author, he seems to have trouble with the syntax of Common Lisp. Admittedly, I'm a Scheme person (which is indeed a simpler language to work with) but the core syntax of Lisp is basically supposed to just be parentheses. If you feel something has too many arguments, change it. Lisp is whatever you want it to be because the language is so malleable. Then there was the part about more or less work, and the whole 'The idea is the hard part'. I mean, no kidding the idea is the hard part. As great as Lisp is, it's not intelligent. It just encourages you to program in an elegant way that I personally find easier to express myself in. I was working on a simple Python script today- I worked out the concept in Scheme, because it was easier for me to think that way. The languages are all Turing-complete, of course they have the same capabilities at one level or another. It's the more or less work part that defines a language, and for thinking, I find Lisp to be superior. P.S. You may ask why I wrote the script in Python instead of Scheme if I find Scheme easier. The answer to that would be Python is far more ubiquitous, and I don't want my users to need to download a language they don't have... and if anyone needs to make changes to the script, they'll likely be lost in Scheme.
What are the "non-Linux POSIX platforms" to which you refer?
Can anyone correct my thought-process? SBCL threading on Linux POSIX platforms is fine. SBCL threading on non-Linux POSIX-capable platforms (i.e. MacOS) is fine. SBCL threading on both *non-Linux* **and** *non-POSIX* platforms (i.e. MS Windows) is terrible. Did I get that right? EDIT: I really should have defined "terrible", but I don't know/remember enough to do so. IIRC, the last time I tried running Hunchentoot + WinXP + single-threaded SBCL, it caused lockups. So that could be one (barely remembered) example of "terrible"...
&gt; You may ask why I wrote the script in Python instead of Scheme if I find Scheme easier. The answer to that would be Python is far more ubiquitous, and I don't want my users to need to download a language they don't have... and if anyone needs to make changes to the script, they'll likely be lost in Scheme. This is really an important point: I've found myself in a similar situation (though replace Scheme with Common Lisp). If I'm writing a one-off for to scratch a personal itch, I'll use CL. But if there is a chance that one of my co-workers may need to use the program then I have to be a bit more considerate on language choice: whether it's ubiquity of the language / runtime or the possibility that someone will need to modify it at a later date. I've very lucky that my manager lets me use CL for as much as he does... and hopefully I'll start migrating the organization as others see the superiority for certain tasks. However, sometimes you have to swallow a bitter pill (writing in another language) for the good of an organization. 
Glad to see that cleared up :)
No. Darwin threading isn't fine at all, neither is Solaris, FreeBSD, or OpenBSD. There will be more details when the thing goes live.
I'd like to see a shirt riffing on the whole "Steel Bank" thing. Maybe a dark grey version of HSBC's logo with Steel Bank Common Lisp written out beneath it. The Save Lisp and Die shirt is pretty awesome, though.
http://xach.com/img/slad-shirt-black.jpg I got mine years ago and it's about to disintegrate. I loved it. Time to get a new one, I guess!
Is there a reason why the original quote from Conrad Barski's image was changed? It said: This product may contain trace amounts of Lisp Now it says: May contain trace amounts of Lisp The decision to make the line lengths even more different and to put single words on a line made it visually uneasy. You should have stayed with the original.
I'd love to put money towards something with obvious and transparent milestones/timelines. I know it can't always work out that way with this sort of project, but it'd be easier to commit more money with the expectation that SBCL threading becomes viable on Windows (and Mac) in some reasonable timeframe. That also made it hard to estimate what I'd donate. 100-500 seems reasonable, but I could see myself giving more if there are some really useful things coming out of this.
Isn't the predicate convention to use dashes when dashes are present in the symbol beforehand, and only a p otherwise? So, shouldn't it be sbclp? Of course, that makes the branding less apparent altogether...
And yet they didn't go for the less ambiguous, amusing repetition in `(lispp)`
... or `(got-lispp)` even.
I want a shirt with a valid Lisp evaluator written on it. Also a shirt where on the front it says "code is" and on the back "data is".
Gah, my graphic eye isn't up to snuff it seems. I'll fiddle with things when I have a moment and see if I can't make it look better. The reason I changed the text is that I find the latter funnier in most contexts it appears in the shop in -- while the "product" is bang-on for a webpage, it seems off on a T-shirt or a mug, let alone a notebook. EDIT: prettied up the layout of the text. Thanks for the heads-up!
I notice cafepress also offers steins and laptop skins. 
I don't use ABCL, but I am very grateful to the ABCL development team, keeping Common Lisp running in the JVM world. /hat tip
Think of us as your insurance policy: you hope you never need us, but you are very thankful that we *are* there when you do…
I can't seem to get CLISP installed on my (Lion-running) new Mac :( Tried MacPorts, Fink, and Homebrew.
I can't make lump sum donations in a meaningful amount however I am willing and interested in a monthly donation to fund nsiivola having some dedicated time for community decided goals. I think if we raise the issue of recurring monthly payments that may provide an interesting crowdfunding avenue.
I would absolutely buy the "code is data is" shirt.
&gt; I can't make lump sum donations in a meaningful amount Giving is giving. :) &gt; recurring monthly payments That's a good idea.
Here you go: http://www.cafepress.com/nikodemus.561518790 :)
Nikodemus, I want to contribute to SBCL without involving cotton or ceramics. What's your paypal account? Also, please put a big fat DONATE button sbcl.org. 
I feel uneasy about adding one on sbcl.org, since we then we'd really need a project account on PayPal and a way to split any monies. However, you're not the first one that tells me to have a donation button, so I've added one on my homepage: http://random-state.net/#donate There's also a crowdfunding project that will appear next week. (More on that on my blog, see the link above.) 
Since people keep telling me this, I've added a donations button on my website: http://random-state.net/#donate. The crowdfunding thing is still going to happen, though.
I don't think a block device is appropriate for networked filesystems, at least not in the general case; there are existing refined solutions to that problem. The involvement of the filesystem here is not the interesting part.
That works? I thought case used eql, and thus didn't support strings. Anyway, there's nothing wrong with that approach, while using eval would certainly be questionable. If what you want is tidy extensibility, perhaps you could keep an :test #'equal hash table mapping row names to constructors, and then use a simple defun-style macro to add to it?
 (funcall (intern (string-upcase (car token-list))) (cdr token-list)) You could then use handler-case and undefined-function to handle the "otherwise" case. Is there a problem with that approach? A simple dispatch hash table approach would work fine as well.
i would construct a matrix (defparamater *matrix* '(("rev" #'rev) ("names" #'names) ("type" #'mytype))) afterwards compare your token and call the right function via something like (apply (second (assoc token *matrix* :test 'equal)) (cdr tokellist))
Alternatively, (parse-thing (intern ...) (cdr token-list)) where PARSE-THING is a generic function with methods defined by EQL-specializer? Collecting the cases into a generic function might be nicer organizationally, right?
Out of curiosity, why would you use an assoc list rather than a hash table?
you can simply type it as a list into your code - and as long as it has few tokens I don't think you loose to much performance?
If I were you, I'd grab `cl-lex` and `cl-yacc` off of quicklisp and write a grammar for the file format. If you don't want to do that for some reason, CLOS with eql-specializers might be exotic enough for your tastes. :p So, like (defgeneric handle-line (first rest)) (defmethod handle-line ((first (eql 'rev)) (rest t)) (do-some-stuff rest)) (defmethod handle-line ((first (eql 'names)) (rest t)) (do-different-stuff rest)) ;; Note that you have to intern the string "rev" into a symbol, and you should make sure and do ;; whatever you need to do make sure that the strings follow your Lisp implementations conventions ;; for case. So you'd want to do something like ;; (handle-line (intern (string-upcase (car tokens))) (cdr tokens)) ;; for each line in the input file. This is sort of overkill, but keeps all of the dispatch cruft out of your loop over the lines of the file. A hashtable of functions is a more lightweight solution.
Yes, I was using the case example as pseudocode. I guess I was trying to think up something that was more like a compiler than an interpreter, which is what led me towards eval. But I'm somewhat out of my depth when it comes to macros, and want to get better at that.
OK, I kind of like this approach.
And I like this one too.
I'll take a look at cl-lex and cl-yacc. I've only used lex and yacc in one project, many years ago, but they worked out well for me then. Maybe it's time for a brush-up.
They're pretty easy to use (much more than the real thing!), but not *that* well documented. PM me if you have problems, since I've used them successfully in the past.
OK thanks, will do.
For extra over-engineering, use a dummy package for INTERN. \o/ God, I miss Common Lisp.
The closest analog to a compiler would be to store your files in a binary format that can be very easily and efficiently loaded into memory instead of text. Really, your current approach is just fine, and much simpler; such elaboration is rarely justified, due to how fragile it can be.
The closest analog to a compiler would be to store your files in a binary format that can be very easily and efficiently loaded into memory instead of text. Really, your current approach is just fine, and much simpler; such elaboration is rarely justified, due to how fragile it can be.
A few approaches: * Get the first word on each line and modify the corresponding hash entry (`property list` in Lisp). * Create an object that holds all that information then dump it as `my.db`. It's just like Python pickling--it stores the objects into a file. It's fairly easy to load the file back in. Read Practical Common Lisp for more details; it's free. http://gigamonkeys.com/book/practical-a-simple-database.html
A hash in other words ("property list" in Lisp speak).
They're functionally the same thing. Technically, assoc may be slower, but if you're just loading configuration settings, you won't notice the difference.
It seems that you want a way to dispatch on tokens rather than parse a text file. We will agree to call the first token "handler name", the rest of the tokens "handler arguments", and the corresponding functions "handlers". We need a mapping from handler names to handlers: (defvar *handlers* (make-hash-table :test 'equal)) In the case of an unexpected handler name, we want a default handler to be invoked: (defvar *default-handler* 'warn-unexpected-handler-name) (defun warn-unexpected-handler-name (handler-name &amp;rest handler-arguments) (declare (ignore handler-arguments)) (warn "Unexpected handler name: ~S." handler-name)) We need a pair of functions to do the actual association: (defun find-handler (name) (gethash name *handlers* *default-handler*)) (defun (setf find-handler) (new-handler name) (setf (gethash name *handlers*) new-handler)) Our dispatch function takes a list of tokens and separates them to a handler name and a list of handler arguments: (defun dispatch (tokens) (if (null tokens) (error "Empty token list passed to dispatch.") (dispatch-1 (first tokens) (rest tokens)))) Now we can dispatch comfortably. You say that the number of arguments is fixed (and, I presume, small), so we can use APPLY: (defun dispatch-1 (handler-name handler-arguments) (apply (find-handler handler-name) handler-name handler-arguments)) You also say that the arguments may not always be strings, so I assume you want to convert them from strings: (defgeneric convert (string type)) We will now define a macro to help us define handlers. The syntax will look similar to a simple DEFMETHOD syntax, e.g.: (define-handler "pins" ((n integer)) ... do stuff ...) It will expand into something like this: (progn (setf (find-handler '"pins") (lambda (#:handler-name n) (declare (ignore #:handler-name)) (setq n (convert n 'integer)) (block nil (locally ... do stuff ...)))) '"pins") Here is the macro: (defmacro define-handler (name (&amp;rest arglist) &amp;body forms) (let ((argnames (mapcar #'first arglist)) (argtypes (mapcar #'second arglist)) (name-var (gensym "HANDLER-NAME"))) `(progn (setf (find-handler ',name) (lambda (,name-var ,@argnames) (declare (ignore ,name-var)) ,@(mapcar (lambda (name type) `(setq ,name (convert ,name ',type))) argnames argtypes) (block nil (locally ,@forms)))) ',name))) We can define a conversion function like this: (defmethod convert (string (type (eql 'integer))) (let ((hash (position #\# string))) (if (null hash) (parse-integer string) (parse-integer string :start (1+ hash) :radix (parse-integer string :end hash))))) And finally our handler looks like this: (define-handler "pins" ((n integer)) (format t "You knocked down ~D pins, ~D left...~%" n (- 10 n))) To test: CL-USER&gt; (dispatch '("pins" "8")) You knocked down 8 pins, 2 left... NIL CL-USER&gt; (dispatch '("pins" "16#A")) You knocked down 10 pins, 0 left... NIL CL-USER&gt;
Wow, that's way above and beyond the call of duty. Thanks for putting so much effort and consideration into your response. I'll spend some time studying it, but it looks very much like what I had in mind. 
I thought I may have seen one already. I used to have a big collection of T-shirt links open, but I'm not sure I saved them. Here is `(eval 'mug)`: http://www.cafepress.com/+eval_mug,14330770 This is one of my favorites: [Black lettering](http://www.cafepress.com/+happy_parens_lisp_shirt,493020397) ([Light on dark version](http://www.cafepress.com/+happy_parens_lisp_shirt_white_on_black,493620106))
Here's one I came across a while ago: http://www.zazzle.com/gotp_lisp_tshirt-235202023936819755
Hmm, good question -- what's the value of lisp? 
`overflow-error` But wouldn't `gotp` check if something is present?
Not just organizationally but more securely. I get nervous about calling functions that are fed to me by some file without some kind of checking/restriction.
I've been very happy with SBCL, and I want it to become a AAA-grade Common Lisp implementation on all platforms. 
Wow, fewer than 6 hours and he's more than ⅔ of the way to his goal of $3000. C'mon, reddit lispers, put him over the top, and then some!
Already hit the first goal! How high will it go?
He should increase the goal, he might get more donations that way.
Values are separated with commas in CLisp, which means that you can't return symbols with VALUES and expect it to print the same in every lisp. I'd print that to \*terminal-io\* or something instead, and control the spacing with the format directive tilde-t. Also, your spacing is messed up. This is what I came up with: (defun o^ () (format t "~&amp;|~4t(o_0)~12t|~%|~4t|~8t|~12t|~%|~4t\\~8t/~12t|~%|~5t^ ^~12t|~%")(values)) CL-USER&gt; (o^) | (o_0) | | | | | | \ / | | ^ ^ | ; No value CL-USER&gt; 
Can't change the basic goal once the campaign is live, but secondary goals are there! $5k is read/write locks, $6k is semaphore notification objects, $8k is general refactoring of the threading API.
Is there any goal for adding threading under windows?
Not as part of this campaign, but! 1. Thanks to hard work by Anton Kovalenko and Dmitry Kalyanov a Windows fork exists that already supports threads on Windows. https://github.com/akovalenko/sbcl-win32-threads/wiki Anton at least is available for hire if you wish to support his work. 2. David Lichteblau is in the process of merging their code to mainline. He is available for consulting through his employer: I understand that he is doing the merging work on their time, so any money thrown that way helps prioritize things. 
Includes probably uncalled for dig at Perl programmers!
this looks simply awesome. I was surprised to find little influence from pd/max-msp on the site - which is one of the most usable visual languages for complex work I have seen.
I'd like to get involved with some Common Lisp project. Fixing bugs, updating documentation, etc. What projects need this kind of work SBCL?, cmucl? ? Thanks!
I'd say all of them, without having much insight myself. I doubt any free software project, whether Lisp or not, would refuse help. Just find something you might like, and then start working on it.
Just fyi, don't put `lisp.reddit.com` in as the submission link. It's confusing, and you really wanted a text post. Find a project you like and check out its code. Get it building, then look at its bug tracker. Try to find problems that look simple, and try to fix them. Ask for help on the project's IRC channel if you need it.
thatth an interethting quethton. I thay meet thome people and read thome bookth on the thubject and Google ith your friend.
Thanks for the info. Sorry about the link in the post. I don't post often and didn't know what to put for the URL. I'm currently using sbcl, so I'll check out the bug list for it first and visit the IRC channel. I used to play around with cmucl, so that is another implementation that I may look into. Have a great day, sir!
Hey, no worries about the post url. At the top of the [submit page](http://www.reddit.com/r/lisp/submit), there are two tabs: *link* and *text*. If you click *text*, you can get a text submission like [this one](http://www.reddit.com/r/lisp/comments/jbmxr/parsing_a_text_file_what_am_i_missing/). It allows you to put in text at the top rather than post a link. It's exactly for posts where you're not linking anything, but want to expand on the topic beyond the title of the submission. :) Good luck with finding a project! When you get your first commit, make sure you post about it here.
Too bad you can't change it. It would be nice if they updated the goal once the first one was reached, it would encourage people to donate more. I hope we get to 8K :-D.
[This document (pdf)](http://bitsavers.org/pdf/mit/cadr/Knight-LISP_Machine_Macro_Instruction_Set-1979.pdf) might interest you. 
Congratulations! I'm curious about a platform note, under Windows, Clozure 32 bit version now runs on 64-bit Windows. What happened? o.O
SBCL has [`sb-ext:save-lisp-and-die`](http://www.sbcl.org/manual/Saving-a-Core-Image.html). Other commercial lisp implementations have improved functionality, like a tree shaker, which will remove any functionality that your code isn't dependent on, giving you a much smaller binary. I might mention that the one of the people who responded to your original is Nikodemus Siivola who is certainly someone in the know, being a major contributor to SBCL and all.
*sb-ext:save-lisp-and-die* combined with *gzexe* is nice: http://paste.lisp.org/display/90903 9MB is not a problem today, and the increase in size after this initial big step (it includes the compiler, run-time, library, CLOS, MOP, extensions++) is in much smaller steps.
Unfortunately, I think Haskell, Clojure, and Racket won the lambda logo land grab.
Yeah but &gt; There is absolutely no binary compatibility of core images between different runtime support programs. Even runtimes built from the same sources at different times are treated as incompatible for this purpose.
Each time you dump your app using s-l-a-d, you're actually also dumping or including the run-time with it -- so this is no problem.
`gzexe` has one flaw I've run into a couple of times: it fails when the `/tmp` directory prohibits execution (`noexec`). Then you're back to moving around a giant executable. IMO, a better solution would be for SBCL to someday be able to compress and decompress its images itself. 
Won't UPX perform better? I am away from my linux machine so can't try it right now.
I have no idea. I see http://riemann.fmi.uni-sofia.bg/lzma/compressexe.man exists also; it uses LZMA as far as I can tell.
I'll repeat the substance of my answer here. It is possible -- it is not even particularly hard: unless you use inline functions an image by default contains no source code for functions, only the machine code. Now, depending on your required level of obfuscation you may want to do one or more of the following when delivering: 1. Disable the debugger. 2. Build with a debug=0 to minimize debug information present in the core. 3. Kill any inline definitions. 4. FMAKUNBOUND your macros. 5. FMAKUNBOUND some of the built-in reflective tools such as INSPECT. 
I don't know about that, but the lambda in this picture *is* the [Haskell lambda](http://xahlee.org/UnixResource_dir/gki/lambda/Haskell_logo7000.png). The [CL lambda](http://www.google.ca/search?q=common+lisp+lambda&amp;um=1&amp;ie=UTF-8&amp;tbm=isch&amp;source=og&amp;biw=1278&amp;bih=8877) is curlier. I like the idea of using the cons cell as a logo.
just out of curiosity I tried it out (on osx): sbcl 1.0.50 (run as above) upx 3.07 (run with --best) before: 41M 13 Aug 00:39 hello after: 8.1M 13 Aug 00:39 hello edit: hrmm, upx it seems does something funky to the image and the resulting application launches into the repl
Cool. Not a lot of savings, but upx is not as taxing on the CPU as gzip. Opera browser uses it for example.
&gt; I don't know about that, but the lambda in this picture is the Haskell lambda. Yes, one thing that bothered me is that the lambda ended up too similar to Haskell's... but I wanted to hear other people's opinions. &gt; Unfortunately, I think Haskell, Clojure, and Racket won the lambda logo land grab. I don't think it's a problem to have the lambda symbol binding (!) them all together...
Thanks for the link, I was wondering what they would be using. I found the code for the book and it was in multiple languages, so I'm not so sure if you really need to use python for it. Since all the assignments are graded automatically, I don't think that the code really needs to be submitted, unless they setup an automated judge, which would be pretty interesting as well.
(λ)
A curly lambda (perhaps with a flat base) above the cons cell might look nice too. I would try it if I were less incompetent with graphical tools...
I think something kind of like [this](http://images1.wikia.nocookie.net/__cb20100824092825/uncyclopedia/images/5/54/A-Perfect-Circle-Logo.jpg) would be a cool way to play on the parentheses imagery.
I think other dead heads would agree that the original PLT Scheme logo was the best.
&gt; I like the idea of using the cons cell as a logo. Reminds me of the [LISP machine](http://en.wikipedia.org/wiki/File:LISP_machine.jpg)
As others said, this would work with a script lambda on top. (That one is already in use for [Haskell](/r/haskell).) I knew I had seen this logo recently. It took me a minute to find it again: GNU Emacs T-Shirts: [1](http://www.zazzle.com/gnu_emacs_tshirt-235922233150331682) and [2](http://www.zazzle.com/gnu_emacs_and_lisp_tshirt-235928828473373715)
Wow, where could I find out more about the difference between the two and how to work with them?
I hadn't seen it. My love for the cons cell comes from the Lisp Machine logo, actually...
http://www.eecs.northwestern.edu/~robby/logos/
my understanding is PD is a piece of free software attempting to improve upon/replicate much of core ideas in max/msp and it is written by the same developer. max/msp being a popular paid utility has quite a bit more $$ behind it, and as such offers a much more polished user experience. In terms of technical differences - I am sure google will help you here and I believe they do exist. I assume there were technical nitpicks that the developer was able to incorporate into his own project that learned from/didnt get incorporated into max. PD is here: http://puredata.info/ and max/msp is here: http://cycling74.com/ I have spent my share of hours with both programs and think its all a bunch of excellent software. I dont regret at all shelling out for max/msp. There is also jitter to go along with max/msp, which allows for a matrix data type to be added to the dataflow graphs. Jitter is great for real time (or not) video processing. Ive used it to make a reverse music video (procedurally generated music from video) - which was super fun, if a little crappy ;) 
I'm an idiot.
(λ () 'reddit)
How closely related are they to that old-looking one? (begins with a C---ah, [CSound](http://www.csounds.com/). Silly me, I was looking for CAudio earlier.) Interesting, there is a page for a ["Max external to run CSound 5"](http://davixology.com/csound~.html).
I like it.
What's about fixing SBCL's defconstant so we can use defconstant portably without any third-party dependencies and custom macros? Yes, it is underspecified in ANSI spec, but that is not a reason to turn it into a portability PITA. IIRC everything except SBCL does not make a fuss about it.
Is it possible to create an ARM port of sbcl instead? Or is it too high a goal for this amount?
Agreed! It is a pain in the ass that DEFCONSTANT isn't straightforward to use.
There's already [some work](http://www.lisphacker.com/projects/sbcl-arm/port-log.txt). Nyef can set up a similar campaign to fund its further development.
From reading that tutorial, it looks like they only use regular expressions for lexing, e.g. turning the text into tokens. It seems like they use a real parser for the syntax highlighting/auto indent. So, it looks like it wouldn't be too bad to add syntax highlighting and auto indent for Common Lisp, if JavaScript is your thing (big if!). Of course, that's only the tip of the SLIME iceberg...
It wasn't possible to run 32-bit CCL on 64-bit Windows, only 64-bit CCL. Now both can be run.
As far as I could tell, the only part we can modify are the regular expressions. Why on earth would someone downvote a submission like this...
You change that variable `$rules`, which is a dictionary mapping parser states to tokens expected in different parser states, and possibly to state transitions. So, say you were doing Python. You'd have something like this.$rules = { start: [ { token: "def" regex: "def" next: "functionDefintion" } ... ] functionDefinition: [ { token: "name" regex: &lt;something that makes sense for Python&gt; next: "functionArguments" } ] ... } The idea is that when you open up a blank file, you're in a state called `start`. If you type in something that matches the regex "def", then you're starting to define a function, and the parser transitions you to the state `functionDefinition`. The reason this is different from just using regex's is that the parser can look for different regexes when it's in different states. So if you type in a literal quote character, the parser knows that you're in the middle of the string and isn't trying to match keywords while you're typing in the string. (Apologies if you already knew what a state-machine parser is). As to the downvotes, my guess is that no one in /r/lisp/ is interested in hacking on an IDE written in JavaScript.
I also like this one, I use it as my Lispforum user pic: http://en.wikipedia.org/wiki/File:Lisp-logo.jpg There's a one I don't quite understand--I think someone made it for their Lisp group: http://www.zazzle.com/phatlisp_tshirt-235628396481639591
There is a book called "Looking at Lisp" with a similar idea on the cover: http://www.amazon.com/gp/product/0201120801/
Great explanation, thanks. I thought it would be fun to try out; potentially for collaboration, and having your programs and IDE available anywhere is great if you don't own a laptop.
I might look at putting together a syntax file. It seems sort of incomplete without some way to interface with a running Lisp image, though.
Yeah, that's the unfortunate part.
Okay, so here are a few more: * Xah Lee took [the old ALU logo](http://www.lisp.org/img/lisp-big.gif) and retraced it with smooth outlines, in red, like NASA's ["worm" logo](http://www.google.com/search?q=nasa+worm+logo). I think it is good: http://xahlee.org/emacs/lisp_logo.html * He has a few more Lisp-related logos [on this page](http://xahlee.org/UnixResource_dir/lambda_logo.html). I get a lot of kicks out of MIT's shield logo. * Msr. Bourguignon produced an M.C. Escher-like lambda picture. It is available [on his site](http://darcs.informatimago.com/www.informatimago.com/develop/lisp/). It would be good for a logo, but I would use a smoother shape and fewer levels. * We could also do an imitation of the simple [Symbolics logo](http://www.symbolics-dks.com/images/Symbolicsfullcolorlogo.GIF). * Finally, I discovered a sweet cons cell design hidden away [in the German CAD forums](http://ww3.cad.de/foren/ubb/Forum29/HTML/002697.shtml#000007). They also have a few other designs, such as an inverted, glow-in-the-dark John McCarthy, two Theory of Everything relation graphs, and a cons cell messenger bag, aw yeah. Here are [the items](http://41658.spreadshirt.net/de/DE/Shop), and here are [the graphics](http://41658.spreadshirt.de/shop/designs) they used.
I'd like to see CCL's Objective-C bridge ported to SBCL, and I'd like to see CCL's FFI reader macros come standard with SBCL. I might look into it myself, since it seems doable for a relative newcomer.
Have you seen cl-objc?
That's 80% compression!
I like it, it's pretty. However, I'm personally fond of Conrad Barclay's Lisp logo family. The whole meme of "Lisp as alien technology" really grooves with me. http://www.lisperati.com/logo.html
Fuck yeah! I can't believe the CL standard ignores CLI arguments.
Did you mean "don't you dare de-obfuscate it"? 
Negative!
Less obfuscated, but longer: ;; Draw Sierpinski triangle from a to b to c, with n levels of recursion. (defun sierpinski (n a b c) (if (zerop n) (progn (line a b) (line b c) (line c a)) (let ( (ab (midpoint a b)) (bc (midpoint b c)) (ac (midpoint a c)) (n1 (1- n)) ) ( (sierpinski n1 a ac ab) (sierpinski n1 ab b bc) (sierpinski n1 bc ac c) ) ))) To run it, you need a midpoint function (in vector or complex arithmetic, it's (a + b)/2) and a line function (to draw a line segment on whatever display you're targeting). 
&gt; you need a midpoint function Isn't `avg` part of the default library?
Well then (defun sierpinski (n) (dotimes (r (1+ n)) (dotimes (c r (format t "~%~vT" (- n r))) (format t "~[ `~:; #~]" (logand c (- n r)))))) 
I tried "(avg 1.0 2.0)" in SBCL 1.0.46, and it just barfed. But average is just what's needed, as long as it can operate on points, i.e. vectors, not just numbers. 
Disregard my comment, I'm dumb. AVG is not in clhs.
I'll think about finding a better solution than what we have now. However, this is not an underspecified area in the standard -- the standard specifies EQL as the predicate to use, and IMO for a good reason: 1. DEFCONSTANT effectively allows both copying and coalesing of the constant object in file compilation. (3.2.4 Literal Objects in Compiled Files) 2. Essentially, if the object is such that it will compare EQL under DEFCONSTANT during both COMPILE-FILE and LOAD, neither copying nor coalesing is going to cause trouble for user-code. 4. If EQUAL is used instead of EQL, you can easily DEFCONSTANT strings etc, which is convenient, but also makes it a *lot* easier to make a mess: (eq +magic-string+ thing) ; implementation dependent (let ((copy (copy-seq +magic-string+))) (fill +magic-string+ #\x) (not (equal copy +magic-string+))) ; implementation dependent Obviously all things like this are likely to be programmer errors, but they can also be quite annoying to track down. Implementing what the standard requires makes such errors harder to manufacture -- though of course doing an extra spot of analysis and trying to warn about such issues would probably be even better. Anyways, I'll think about it. ...but: [Alexandria](http://common-lisp.net/project/alexandria/)'s DEFINE-CONSTANT allows you to define non-EQL-comparable constants portably -- and if your code has virtually *any* dependencies, it is very likely to load Alexandria anyways. Alexandria also comes with a ton of "semi-standard" idiomatic macros and functions you are likely to find useful. Using Alexandria is my personal recommendation: that way you remain portable, including with any *future* implementations that choose to take a strict view of the standard. Still, I admit that it is something a lot of people are bitten by, and makes some things what would otherwise work out of the box on SBCL need porting. 
Aye. Alastair is probably the better person to do an ARM port than me. Not that I would not *want* to do one, but it's out of scope for this campaign -- I'd have to do a spike first to have a better idea of what's involved. 
I haven't. The darcs repo hasn't seen any action since 2008, which worries me, but it's definitely worth a look.
I sometimes wonder if format is Turing equivalent.
By 'underspecified' I meant that standard doesn't say what should happen if values are not EQL. I see your point, but you essentially want to warn people of a _potentially_ bad situation, so shouldn't it be a warning rather than error? SBCL forgives much nastier things such as use of undefined functions and variables, so string defconstant producing ERROR looks like a preferential treatment. &gt; Anyways, I'll think about it. Thank you. &gt; Alexandria's DEFINE-CONSTANT allows you to define non-EQL-comparable constants portably Well, I think defining non-EQL constant is done mostly for aesthetic reasons and library, even as commonly used as Alexandria would defeat the purpose or be too much of a hassle. For example, if you do not `(use-package :alexandria)` you'll either have to import define-instant in each package you create or use a qualified name which is ugly and thus defeats the purpose.
Hi poslathian, There is actually a fair amount of Pd influence, and I have much more Pd experience than I do with Squeak. But there are several ways in which I have purposefully departed from the Pd design too. See http://blocky.io/design.html for some notes. 
Not quite.
 (lambda (x y) (flet ((mid (a b) (/ (+ a b) 2))) (cond ((and (numberp x) (numberp y)) (mid x y)) ((and (vectorp x) (vectorp y)) (vector (mid (aref x 0) (aref y 0)) (mid (aref x 1) (aref y 1)))))))
Nice!
Oh? You have a proof?
You should go for it. Drop us a line at cffi-devel if you need help.
Not formally, but I believe one could be constructed by noting that there is no way for the output of a format directive to be used as the input of another format directive. Thus, since the input is essentially read only, it is less than or equal in power to a http://en.wikipedia.org/wiki/Read-only_Turing_machine , which can only parse Regular languages. Thus format is not Turing complete.
My comment was a little in humor, but thank you for the educational explanation.
Horribly broken indentation. Corrected. ;; Draw Sierpinski triangle from a to b to c, with n levels of recursion. (defun sierpinski (n a b c) (if (zerop n) (progn (line a b) (line b c) (line c a)) (let ((ab (midpoint a b)) (bc (midpoint b c)) (ac (midpoint a c)) (n1 (1- n))) ((sierpinski n1 a ac ab) (sierpinski n1 ab b bc) (sierpinski n1 bc ac c)))))
I personally would rather have standard compliance than less of a PITA, DEFINE-CONSTANT works just fine.
&gt; He also eased up a bit on Lisp purity with some literals, and that is lowering the leap needed to make the transition. Maybe Clojure is softening you up for Common Lisp.
Yes. my thoughts exactly. I know Ruby was "out there" and now it seems natural. I also noticed that people are not coming back from Lisp once they cross the border. Clojure is like like "next" step in that direction. 
I'd remove the excessive bolding and tangential remarks, especially: &gt; We can learn a lot from the fifties, and learning Lisp does make you a better man, or at least a better programmer if you are a prick like me. (Or at least you feel like a better programmer if you are also suffering from Superiority complex, but are actually dumb.) They take the focus away from your thesis and put it on you.
Thanks, now I feel it's OK to post a book I've been holding on to.
Try scheme instead. Racket is an amazing, powerful, sharply designed Lisp.
I didn't post this for a while because I figured most of the readers here had seen it before. The author explains why he wrote the book [on his website](http://www.markwatson.com/opencontent/): &gt; I was motivated to write this book because I have been an enthusiastic Lisp programmer since the 1970s and I would like to motivate more programmers to learn ANSI Common Lisp. &gt; While I consider Java to be twice as "programmer efficient" as C++, I consider Common Lisp to be twice as good as Java for some applications. Common Lisp compilers are freely available, stable, and compiled Common Lisp code is very fast. &gt; Not yet programming in Lisp? Spend a few evenings with this free web book and experience what many computer scientists consider the best all-around programming language. &gt; The language Scheme is also a dialect of Lisp and is frequently used in programming classes. My free web book only covers Common Lisp, not Scheme. (And here's [an old HNews post](http://news.ycombinator.com/item?id=892229) where the author gives a comment.) 
The Lisp implementations are really nice pieces of technology. You get the Lisp equivalents of whatever dynamic features you're used to from Python/Ruby with performance that's more like the JVM than CPython or MRI, along with runtime introspection that powers an autocomplete system.
McCarthy said it best (as usual): [Lisp is an approximate local optimum](http://www-formal.stanford.edu/jmc/lisp20th/lisp20th.html). (And, as usual, he said it twenty years ago, and it's still true.) Real homoiconicity trading readability and terseness for programmability is just one of the big tradeoffs.
Thanks for posting a link to my free Common Lisp Book. BTW, a lot of people helped me with that project: check out the acknowledgements section. Really a group effort.
Yes, I noticed that in your comment on HNews. Thank you for making it freely available.
Why stop there? picolisp awaits with open arms...
&gt;Real homoiconicity trading readability and terseness for programmability is just one of the big tradeoffs. Lisp is supposed to be edited with good lisp aware editor. When you accept that, there is not tradeoff. You have reached lisp enlightement when parentheses disappear. In the meantime, properly formatted lisp with editor that can paint parentheses to look almost transparent looks like Python. 
picoLisp is neat, but also incredibly alien, both as a Lisp and compared modern, dynamicish languages like Ruby. I don't dispute that there is some powerful magic in picoLisp, only that it is more akin to a language like Factor than to most other lisps. 
It was a joke. Whenever somebody mentions simplicity of scheme as an advantage over common lisp, I mention picolisp to get a rise out of them.
Lisp, like many great languages, suffers from library rot and lack of modern tools. Rocking SBCL with emacs/slime or Clojure w/ netbeans is a lot of fun but it's hard to convince people that it's worth using for real world stuff. 
Sorry, I can be a bit literal. It is a sort of misleading joke, you have to admit. picoLisp is conceptually quite sideways from either Scheme or Common Lisp. And, in any case, Racket has much of the "batteries" that are included in Common Lisp with (arguably, of course) a nicer module system, better hygiene all around, smarter design. On the surface, it is more familiar than Common Lisp (to new programmers) and beneath the hood, the power of Lisp is there (and then some) and better marshaled and organized. When I give it an honest appraisal, there is little about Common Lisp to recommend it to new lispers.
Can you please post a screenshot of such nirvana?
I keep trying to use Racket, but every time I do I hit a WTF moment. I wish I could use MrEd, but I can't even load the thing!
http://pages.cs.wisc.edu/~psilord/blog/data/inside-lines/midi.png http://pages.cs.wisc.edu/~psilord/blog/data/inside-lines/md5.png Simple examples of color scheme that makes parentheses to almost disappear to the background. Correct indentation of Lisp code is as important as in Pyhton, because the structure of the code (from the programmers point of view) is indicated by indentation, not by parenthesis. Only the most innermost parens are relevant for the programmer. 
What exotic system can't you load Dr Racket on? I've never had a problem with it. The editor is a bit weird, but its totally possible to develop from Emacs, which I have done too. I would direct a dig at CL at this point, but quicklisp really does make it easy to set up and install libraries. 
it is funny when someone calls an alien technology... incredibly alien. I think that could be construed as a compliment.
It definitely wasn't meant as an insult, I assure you.
I like it as well. Perhaps a rainbow fill like that in the old Amiga check and apple IIe logo will tie it all together and give it a 70's/80's retro appeal.
By MrEd are you referring to the GUI library? If there's some specific problem you're having it'd be useful to know and the mailing list can probably help.
If you actually want to write software, then Common Lisp is pretty good.
I find that way to colorful. Also it makes it hard to see the parentheses.
&gt;Also it makes it hard to see the parentheses. That's the point. 
I that might be more history dependent than the merits of the particular dialects/implementations. On the other hand, that is a perfectly good reason to use one over the other.
I'm curious - why NetBeans? I've only used it with Leiningen/swank-clojure/slime/emacs, and while it's nice for REPL work, I have to admit Java's attracted some of the best one-trick-pony IDEs in the market. I wonder whether any of it crosses over to Clojure-land.
Let me repeat that - 80! Deployable! Convenient! But borked ;_;
Borked? Why is 80% is not good enough? And is that a reference? 
[parenface.el](http://www.davep.org/emacs/parenface.el) can be your friend.
&gt; lack of modern tools Such as?
I think it's brilliant, actually - sorry if I came off as sarcastic. It seems quite practical - if it would work, according to chases_mammaries. I use bork as a synonym for FUBARed - I'm not sure what the relationship to the Swedish Chef is, but there you go.
My problem is that I don't know how to use it. I've tried following the instructions on the MrEd page and it asks me to use a menu item that (as far as I can tell) doesn't exist anymore. I need a GUI editor. I would also like to map auto-complete to tab, ctrl-/ seems alien to an emacs user. I **know** Racket is a wonderful experience. I just wish there was an intro for emacs-based Common Lispers. And a GUI editor. I would also like to know if you can mix racket code with Racklog in the same program. Finally, A good explanation of why Racket is a group of languages rather than just a language would be nice. I love the idea of a slim, elegant common lisp. I just can't get past the first date.
Every time I go to develop code in MIT/Racket I get hung up on something. I try for an hour or so, then revert back to CL. I'm not angry, just frustrated and disappointed. 
I don't have Lisp image processing experience myself, but [this](http://blog.vjeux.com/2011/epita/climb-chaining-operators-component-trees.html) was posted to the Subreddit a couple of days ago. They claim to have implemented an image processing library. Perhaps you should check it out?
Parentheses are a feature in Lisp.
What problems did you have specifically with Racket? The only thing weird about Racket to me is that it is much less dynamic than CL, and not as suited to interactive development. I guess that is a matter of taste. Never tried using MIT Scheme.
&gt; I've tried following the instructions on the MrEd page and it asks me to use a menu item that (as far as I can tell) doesn't exist anymore. I need a GUI editor. Ah, the GUI builder does still exist in DrRacket. The menu item is Insert-&gt;Insert GUI. However, I don't really recommend using it because doing the GUI programmatically generally works better. &gt; I just wish there was an intro for emacs-based Common Lispers. It's not in the official release docs yet, but would [this](http://pre.racket-lang.org/docs/html/guide/other-editors.html) help you? &gt; I would also like to know if you can mix racket code with Racklog in the same program. [Yes](http://pre.racket-lang.org/docs/html/racklog/racket-w-logic.html). &gt; Finally, A good explanation of why Racket is a group of languages rather than just a language would be nice. The [Wikipedia article](http://en.wikipedia.org/wiki/Racket_\(programming_language\)) has been getting some work recently to try to explain this better. (also see [this page](http://docs.racket-lang.org/guide/dialects.html)) Is it still missing some key explanation? It'd be useful to see how best to present this idea to non-Racketeers.
most of them provide little information for the programmer. making parentheses less visible helps especially beginners who have the habit of counting them. 
I don't have time to read all this now, but I did try to add the GUI part. Under INSERT I have: Common Box, Image, Fraction, Large Letters, Lambda, XML BOX, Racket Box, Racket Splice Box, Text Box. No GUI. :(
Students then will believe Lisp is some kind of Python with dimmed parentheses. Balancing the parentheses then will only get more difficult. But that's not Lisp. The parentheses have a purpose.
Oh yeah, I understood borked as broken, but your whole comment was very, ah, lively! It seemed to echo a personality or character.
&gt; Balancing the parentheses then will only get more difficult. The editors will do that for you. Even 'vi' does that. 
most lisp programmers I know do not read their code by counting parentheses, but rather by indentation. after a while they don't really notice the parens anymore, even without the "lowlighting". lisp lends itself to structured editing, as enabled by, for example, paredit.el (http://www.emacswiki.org/emacs/ParEdit) for emacs. thus, balancing is not a problem. edit: typo
vi doesn't do that. You still have to type the parentheses and at the right places. There are two ways to support the Lisp programmer: **Provide information about matching parentheses.** You still have to see if the matching is right. The editor only provides information. (a b (c (d)) e) is different from (a b (c (d) e)) **Maintain the balance of parentheses** That's for example offered by Paredit in Emacs or by some structure editors. Still you have to set the parentheses at the right places. The editor helps editing (add, removing, moving) and maintains the balance. 
 (foo ((a b))) Are the double parentheses necessary or not? I want to see them. Second I use tools like Mouse copy, where I click on the parentheses to trigger actions. If I don't see them, where do I click?
I really got blooded in functional/dynamic programming with Perl, and I found that a good bridge into Lisp. I am sure that Ruby and Python can do the same thing.
Thanks for the link! I think the money line in there has to do with a conscious departure PD's dataflow model to a more lispy depth-first left-right execution - which makes plenty of sense. As you pointed out, max/pd have their associated headaches from allowing loops in the graph - which you have nipped in the bud. Cool stuff! 
yes, they do have purpose. But their purpose is not to be visual aid (part of the few innermost pairs anyway). i'm not advocating of getting rid of them. btw. balancing parentheses is the job of the editor. 
Ok. Now I get it, require downloads and starts the app... That's a little surprising but it makes sense now. Yes, I have MrEd Designer running! I'm going to have to give Racket another try. I could really use a GUI app with prolog built in. Thank you! You may have solved some major problems for me.
Assuming you are using Common Lisp, I think that you should load up cl-gd (available on Quicklisp) or cl-magick which will give you the ability to read and write all sorts of image files types. Then read the pixels into your own data format. With cl-gd there is a function CL-GD:GET-PIXEL that will do the trick. I am also interested in any Lisp-centric tutorial for ANNs. Keep in mind, that there are probably more language agnostic tutorials that can be easily written in Lisp.
Now you're gonna make me learn emacs? groan. vim for life!
It's funny. I think the same thing of Python/Ruby/Perl/C#/Java/C/C++ whenever I want to connect to a remotely running application and make changes/debug/monitor while it's alive as opposed to having to shut stuff down, build a framework for this myself, etc.
I have a feeling that a guy with a handle "lispm" knows something about Lisp-aware editors. Rainer must be trying to make a point more subtle than that.
Check out the Symbolics logo and the T-shirt designs I found [up there](http://www.reddit.com/r/lisp/comments/jgkol/attempt_at_a_simple_lisp_logo_sketchy/c2c9grz).
I tried Racket for a while, since it came with a GUI library, but I got frustrated and dropped it because the macro system was so un-`defmacro`-like (I'm on the fence over whether I'm being a Blub programmer on this one - Racket's macro system seems like it might be The Right Way to Do Macros if I were to just give it some time), the object system was so un-CLOS-like (I am not on the fence at all about thinking CLOS is better), and because CL seems to find its way into more production systems.
Not to mention make Python/Ruby/Perl/PHP talk to C. Common Lisp's FFI is miles ahead of similar dynamic languages.
You cannot escape your destiny.
Get Lispbuilder-SDL, it's insanely cross platform. It has SDL support out of the box, but also integrates very well with OpenGL (once you want performance) It has "Gfx" addon library for drawing basic 2d primitives, and an "Image" one for loading images. API is here: http://lispbuilder.sourceforge.net/lispbuilder-sdl.html P.S. if you use the Lispbuilder, don't use its regex &amp; networking libraries. They haven't had as much attention as CL-PPCRE (for regex) and Usocket (for networking) 
and? what happened?
From my point of view, GvR is moderately smart, but not aware of the decades-long history of Lisp that McKay knows. Some stuff like macros will never happen because GvR doesn't believe in them. Other stuff like type annotations and generic functions comes in some Pythonic flavor that might or might not realize the full benefits McKay is thinking about, mostly because the rest of the language has made different choices. Python evolved, but stubbornly insists that lambdas are useless, that a simple optimization like TCO is too scary, and gives `yield` a stupid one-level-only dynamic scope instead of full dynamic scope arbitrarily far through the stack. Oh, and can't be compiled efficiently because its "dispatch every function call through exposed dictionaries" is inherently slow.
Nothing.
Why would I do that? To each their religion: I don't want you foisting yours on me, and I won't foist mine on you. If you want to use vim for writing Lisp, go ahead: I'm pretty sure parenface's functionality could be replicated. And I think someone figured out how to get SLIME like functionality in vim as well. 
The last point is certainly a valid one - Racket's only real killer app is Dr Racket (this is admitted by the Racket developers.) And I agree with you, more or less, about CLOS vs the Java-ish Racket object system. I actually would prefer immutable objects (like Clojure maps combined with multimethods, basically). On macros, I think I ultimately am on the "Hygiene" side of the fence. You might be interested in a series of blog posts I wrote about the subject of macros, scope and hygiene (first post [here](http://dorophone.blogspot.com/2011/07/survey-of-syntactic-extension.html)). The next post in the series will be about Scheme hygienic macros. They really aren't _that_ different from defmacro style macros, once you get past the layer that makes hygiene convenient. Incidentally, I have to point out that [Swindle](http://docs.racket-lang.org/swindle/index.html?q=Swindle), a library for Racket by [Eli Barzilay](http://barzilay.org/) implements a lot of Common Lisp-like extensions, including CLOS, for Racket. Unfortunately, the Racket-class system isn't integrated into the class hierarchy. So if you are doing GUI stuff, you have to hassle with both. There is a multimethods library on Planet, which lets you simulate something near to CLOS pretty easily and, if you write the correct dispatch function, you can integrate the Racket classes manually. 
What's up with Python `yield`? What's with TCO that's so superior to Python-standardized iteration with `for`? What's the beef with generic functions that would be awkward with Python duck typing for generic action and callable classes for type specific specialization?
Well, to defend Guido a bit (not that he needs it really, he can stand for his own ;) ) - macros in Languages that don't go the data-structure-literals-as-syntax way as Lisp does (or some more strange ways like Factor or Forth do compile-time words, which in a way are macros, too) is damn hard to get right and useable. I probably would say if you want to go the full DSL-building route, just stick to some Lisp, because you will allways have more freedom that way with them. Probably it just is time for something like Clojure, just not integrated with the Java world but with the Python world. Or maybe someone should get CLPython back up on current python syntax ;) But totally with you with regards to TCO - it should at least be some kind of switch that I can willingly activate (guidos argument against it was that it messes up stack traces, but if I know what I want I should be able to still get it by saying "fuck stack traces").
References for the "TCO is too scary" incident: * [Guido](http://python-history.blogspot.com/2009/04/origins-of-pythons-functional-features.html), [again](http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html), [again](http://neopythonic.blogspot.com/2009/04/final-words-on-tail-calls.html) * [JRM's rebuttal](http://funcall.blogspot.com/2009/04/you-knew-id-say-something.html), [ii](http://funcall.blogspot.com/2009/04/you-knew-id-say-something-part-ii.html), [iii](http://funcall.blogspot.com/2009/05/you-knew-id-say-something-part-iii.html), [iv](http://funcall.blogspot.com/2009/05/you-knew-id-say-something-part-iv.html), [v](http://funcall.blogspot.com/2009/05/you-knew-id-say-something-part-v.html)
Python has macros -- but they're a fixed set, ad hoc, and baked into the compiler. Take [expr1 for x in xs if expr2] for instance, which desugars into map(lambda x: expr1, filter(lambda x: expr2, xs)) ^_^
Well, I guess that's what happens when you value simplicity over elegance in a programming language. I'm gonna go out on a limb here and wildly speculate that Guido does in fact understand the benefit of those features and how to implement them, but doesn't value them highly enough to risk complicating Python.
This [other reply](http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg00369.html) captures a poorly reasoned sentiment I see often in Lisp / Python comparisons: &gt; [It's] a myth that optional features do not add weight because you don't have to use them. If other programmers use them then you have to understand them. Libraries don't add much weight because if they are outside of your domain [...] then you are unlikely to run into code that uses them. The author implies that *optional features* get used outside of their intended domain, but *libraries* do not. This claim is left unsupported. &gt; But core language features (including central libraries like strings, regular expressions, data display) will pop up all over the place so optional features have a real cost. Agreed, but the same applies equally to Python. Pretty much any Python program involving text will `import re` right off the bat. [Case in point](http://code.activestate.com/recipes/65215-e-mail-address-validation/). The author perhaps should have noted that moving a feature into a library offers a *barrier to entry*; one must type `import re`; perhaps that impediment alone will discourage a user from using regular expressions if a core feature (probably a simpler one) will suffice (e.g. str.startswith for instance). But that claim is not made. Perhaps they just want to avoid saying something that will come off as "Python is better because we made it harder". 
Well, there are type annotations through cython and generic functions (kinda, I guess?)
Cython is a different language. It's python-like and built to be interoperable with python (or at least with cpython), but it's not Python. That's like somebody saying "C should really have built-in concurrency primitives" and you replying "well there are built-in concurrency primitives in Go".
&gt; What's with TCO that's so superior to Python-standardized iteration with for? TCO does not have much relations to `for` and iterators, though you can use TCO to easily implement iteration via recursion. Considering Python has little in the way of recursive datastructures, it's not a very interesting match.
&gt; which desugars into The *trivial* list comprehension you provided is roughly equivalent to the second expression, but comps are not trivially equivalent to these calls, let alone desugared into them.
Yeah, I know the compiler doesn't *actually* do this. However, I'm pretty sure ever list comprehension can be rewritten using a nested sequence of maps and filters (or, to offer the correct degree of laziness, it should also be using itertools' `imap` and `ifilter`). Is there a concrete case you believe demonstrates otherwise?
&gt; However, I'm pretty sure ever list comprehension can be rewritten using a nested sequence of maps and filters That's not too unlikely, but it would be an unholy mess. Using multiple iterations in comprehensions nests them, it does not sequence them.
True about the different language part, but your comparison is a bit of an overstatement. They're basically exactly the same, and built for inter-operability. So I'd view it more of a "non-standard extension". But your choice if you don't want to count them. I think it's an acceptable solution, though, so I'd let that count.
He also has an argument against making a switch that activates it (something along the lines of "if it's possible, it has to be universally implemented by all implementations etc, otherwise programmers start to write code that depends on TCE, and that code will break (with the wrong implementation or the wrong switches)")
So am I right in guessing that TCO is tail call optimization? (I swear there are so many times a couple of seconds of typing out something like TCO would save the reader minutes of following links and hunting around.)
&gt; What's up with Python yield? I could be doing it wrong, but I don't think so. This doesn't work: def subgenerator(): # do some computation yield subresult def generator_routine(blah): """Yields values that might or might not be bar""" if have_result_handy: yield result else: subgenerator() def main_routine: """return filtered results from generator""" return [for f in generator_routine(blah) process(f)] I wanted subgenerator() to be able to yield results back into the main_routine's comprehension. But that doesn't work. `yield` isn't like a throw that is caught at the level of the call stack that is waiting to collect results. It can only yield up one level. You have to work around this by explicitly collecting up subgenerator's results in generator_routine and yielding them back to main_routine. Blech. My real application was this: pass in a iterable, split the iterable's values into batches, either by a maximum count or when the values were incompatible with the current batch. I wanted a "helper routine" to be able to add a results to the batch, and if a batch was complete, send it off; I needed also to be able to flush the pending values as a batch when the iterable was ended. The "send off a batch request" could not be easily coded as a single routine, called for each case, yielding all the way up to the appropriate level. Instead, I needed to catch the values and re-yield them in an ugly, repetitive way.
I would soberly conjecture that he just didn't do his homework. After much struggle he admitted that he didn't understand TCO (which he repeatedly called just Tail Recursion) -after arguing again and again that Python's loops were the only way to go- and Python's initial scoping was just... "pragmatic", in the same way as PHP's design is. Its scoping rules still make closures scary to use e.g. within loops or list comprehensions. Edit: typo, punctuation
Perhaps you want to look at [adder](http://www.thibault.org/adder/doc/index.html). It aims to be "Lisp integrated into Python as Clojure is integrated into Java."
`For` is a special case of tail call iteration. Some things are clumsy to express in a for loop but are easy to express with tail recursion. I find tail recursion so useful that I implemented a special form which creates [recursion points in Emacs Lisp](https://github.com/VincentToups/emacs-utils/blob/master/recur.md), exactly because it was hard to write certain kinds of iteration with a loop macro. Grep around the code base to find example usage. 
Sorry, yes. This discussion has been repeated ad nauseam, so the shorthand comes naturally.
I wonder if the situation could be improved by making the brightness more dynamic. If, as you mention below, you like clicking on them, you could brighten the paren under the mouse pointer (and it's matching paren), and possibly partially brighten any parens immediately adjacent, making it easier to visually pick among the cluster. I think the motivation behind dimming the parens is when you are looking at the code like prose, trying to digest it, not when you are looking at the code like atoms, trying to re-arrange it.
Python? lisp is enough !
&gt; that would be an unholy mess I don’t find it to be the case in practice, but it really depends on your definition of "unholy mess," doesn't it? Perhaps if you had an example we where you thought this might occur? Let me propose a [nontrivial example](http://www.secnetix.de/olli/Python/list_comprehensions.hawk): noprimes = [j for i in range(2, 8) for j in range(i*2, 50, i)] the equivalent composition of maps/filters/chain: noprimes = itertools.chain.from_iterable( map(lambda i: map(lambda j: j, range(i*2, 50, i)), range(2, 8))); Map for the first variable, map+chain for each subsequent variable, and one filter for each `if`. Idiomaticly, the inner map reduces to just `range(i*2, 50, i)` in this case.
One thing TCO would permit, that goes beyond the usual iteration, is *mutual* tail recursion. Just to illustrate: def even(n): if n == 0: return True else: return odd(n - 1) def odd(n): if n == 0: return False else: return even(n - 1) This code would work for large values of n, if Python had TCO. It already does work in Scheme, OCaml, and SML. For CL, it depends on the implementation (works in SBCL). For Haskell, you may need some strictness annotation. 
seen it a while back, wasn't too interesting then, thoughg - mainly just an alternative syntax, but not many added semantics or datastructures (like atomic updates, persistent collections and all the other cool stuff clojure adds to the hava world)
I've tried to read into it, but the author also seems to almost *intentionally* redefine common terms. [For instance](http://software-lab.de/doc/faq.html#problems): &gt; This is a form of lexical scoping - though we still have dynamic binding - of symbols, similar to the static keyword in C No, no it's not. 
thank you! I have been wanting this and python on lisp just wasn't for me. This developer has just earned at least a weekend of eval from me.
Glad you liked it, i thought it might be interesting.
Yeah, I didn't mean it was the exact same, but that I had seen a logo like that.
Upvotes! Also, given that Clojure has become a recognizable and fresh name, and is making the [jump to target JavaScript](https://github.com/clojure/clojurescript), it might be interesting to migrate to use Clojure syntax, or provide a Clojure compatibility module.
That Lisp doesn't look like any Lisp I know.
Ok, it says there it's Clojure. You should've named it "Smalltalk, Clojure, Ruby".
I've contenplated about that, but my conclusion was that Clojure tradeoff with some syntax sugar is really not that much of a deal. Just like Smalltalk has couple of dialects...
Clojure is a lisp.
Lisp is not Clojure.
Everyone please write JetBrains and ask them to make an IDE for Lisp...\*sniff\* What might they call it?
Careful about mixing terminology. A hash table has a function that hashes the key in some way (e.g. running md5 on a string and using the resulting value as the key). In that case this could still be a hash table, wherein the hash function is 'identity'. Now, property lists and hashes and association lists are not technically the same things (although functionally equivalent). The structure of the example here is an association list in Lisp. That is a list of pairs/lists representing the key/values. You can access members using (assoc &lt;key&gt; &lt;alist&gt;) A property list looks like this: (list :name "John" :age 23 :married t) And access to this structure is via a get (e.g. getf) (getf &lt;plist&gt; &lt;key&gt;) For a lisp hash table, normally you construct it with 'make-hash-table'. This function allows you to specify the test function and a size hint. Access members of a hash table using (typically): (gethash &lt;key&gt; &lt;hash-table&gt;)
Syntactic compatibility only gets you so far, since the languages are built on very different standard libraries (Python and Java).
ಠ_ಠ Isn't that a bit like saying: "Gold is an element", then saying "Elements are not gold" ? Or are you comparing Clojure to some arbitrary standard, e.g. ANSI CL or Scheme?
I am not comparing anything to anything. But, the author is comparing Clojure to concrete languages, Smalltalk and Ruby. So, if it had "Clojure" in the title, I wouldn't bother reading, since I'm not interested in it.
Ah ha... OK, I see. OTOH - The article isn't about Clojure per se; it's about the power of macros and how Smalltalk and Ruby didn't measure up in these examples because they don't have macros. 
I'm sure that most folks can adapt, but I generally prefer or need to write portable code; code that I can easily adapt between different environments. It really makes my life easier if there's a useful subset of the language that ports directly, or for which I can write an adaptation layer.
It seems you are being argumentative. Right now, I like a balance between too visible (distracting) and too faint, but for everyone it is a matter of preference.
My preference as a Lisp programmer is to have the parentheses as visible as other characters - not more and not less.
 (set paren-saturation 240) Let me edit my comment above.
CMU, not MIT
Oops, my bad. Wrote it down wrong in my notes...
Like a lot of Lisp code out there, this stuff is ancient. According to the footer, the last web update was in 1995.
I found a couple of interesting things on there after a quick browse. Just because it's ancient doesn't mean it might not be useful for reference or ideas.
the front page says &gt; A subreddit for the Lisp familiy of programming languages.
Polipo, an HTTP proxy, doesn't like this web server at all. (502 Couldn't parse server headers.) I think it has to do with this: &gt; GET /lisp-decimals HTTP/1.1 &gt; User-Agent: curl/7.21.0 (x86_64-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.15 libssh2/1.2.6 &gt; Host: wukix.com &gt; Accept: */* Note: no Range header field in request. &lt; HTTP/1.1 200 OK &lt; Date: Fri, 19 Aug 2011 01:50:31 GMT &lt; Server: Apache/2.2.17 (Ubuntu) &lt; Content-Length: 14260 &lt; Last-Modified: Fri, 12 Aug 2011 04:01:17 GMT &lt; Content-Range: bytes 0-14260/* &lt; Content-Type: text/html Content-Range appears in response, but the status code is 200 rather than 206 (Partial Content). That's odd, but not illegal as far as I can tell. But the Content-Length is definitely inconsistent with the Content-Range. HTTP 1.1 byte ranges are inclusive: &gt; The last-byte-pos value gives the byte-offset of the last byte in the range; that is, the byte positions specified are inclusive. Byte offsets start at zero. [HTTP 1.1 14.35.1 Byte Ranges](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35) So a range of [0,14260] indicates a length of 14261 bytes, but that's different from the Content-Length value.
AHHH, THE WISDOM OF THE ANCIENTS IS OURS TO KNOW AT LAST
git &gt; wget
What?
Basic math and most basic concepts in AI haven't changed in a very long time and are not expected to change significantly in the foreseeable future.
If I read this correctly, this is not a fixed-point library; it uses ratios behind the scenes but allows you to visually work with decimal numbers instead of having to use ratios for accuracy. Does that sum it up?
Simple and fun, but It'll get confused with the game "half-life"
Traditional Lisps (and by that I mean Lisp-2's) tend to use fewer lambdas, preferring `labels` and macros instead. Maybe the logo should capture macros or eval in some way? 
"More cons cell!"
And what's the state of Perl 5 &amp; 6? 
Nice. That's what Nickle does, as does what sounds to be a similar library I wrote for CL. (I'm not going to disable my proxy to get access to this guy's server.) Both use a notation like 1.{3} for rationals that can't be expressed in a finite number of decimal digits.
I'd just like to point out that C++ has all of these features. *runs away*
It does, what of it? I didn't say that Clojure doesn't belong here.
A hot mess?
I just realised that Lisp programmers are like Anarchists. We don't believe in having a "benevolent" dictator for life (such as GVR) because why should any one person be so important? Instead there should **macros** so that language development can be the job of the common developer.
Seems that. Scheme r6rs was also quite the controversy. Maybe it's a problem with the number 6
Thanks for pointing this out. Really appreciate you taking the time to figure out what was going on. The bug in our web server should be fixed now.
As the creator of wu-decimal: Yes, that does sum it up.
Except it doesn't. * It doesn't have type annotations so much as it requires you to babysit it for each and every variable. * It doesn't have macros, instead it has two half-baked pseudo-replacements: * C-style textual macros, which are saner of the bunch * The template insanity, which is a crazy meta-mechanism purporting to be a superset of macros, generics and several other things, while failing to be an acceptable implementation of either. Yes, I know Boost uses it to implement lambdas and a parser generator. It only makes your binaries 10x larger and compile times 100x longer, but hey, lambdas without built-in language support! You don't even need to add it to the language standar-- oh wait. * It completely and utterly fails to have generic functions. You're advised to look at Scott Meyer's _More Effective C++_ (which is the best piece of anti-C++ advocacy ever written, btw), chapter 31, which is a fairly disheartening exercise in rolling out multiple dispatch by hand
This is pretty nice, and I really like that you took your time to explain the mathematics behind printing.
I wish people would stop repeating the QWERTY myth.
Code doesn't *necessarily* rot. Most Common Lisp code is just as good now as it was back when it was written. «The code is x years old, therefore it automatically sucks» is often a fallacy. Exceptions are if library bindings become outdated with respect to the underlying library, or if the code was written prior the last standard, and the code uses deprecated or removed functionality. Anyway, I'm happy because this is the largest Lisp repository I've found so far, and I can use this as a supplement to the hyperspec while learning :-)
Myth or not I thinks it is good example of how people are good at adjusting. Keyboard is still superior interface, and honestly it's only because it is fast enough once you wire layout to your brain.
What a horrifying notion, that there exists running code that is over 15 years old. Why, we've made so many leaps and bounds in that time. I mean garbage collection, lambda functions and dynamic languages are so new and hot now, what could this ancient code possibly teach us?
What about [PEAK](http://peak.telecommunity.com/DevCenter/PEAK_2dRules)?
Very nice, seems ideal for certain kinds of financial hacking and I'll definitely be trying it out. It's quite distracting when dealing with price data that is displayed in the REPL as all kinds of funky ratios :-) One pedantic note: IEEE-754 (2008 edition) defines both binary floating point and decimal floating point numbers these days, and there is emerging support in hardware and various languages for the new decimal floats. I had previously assumed that CL float always meant IEEE binary floating point but I've just checked the Hyperspec[1] and it doesn't even mention IEEE or base 2, so a CL implementation could presumably choose to use base 10 and could therefore represent typical money amounts exactly, no? I'm a bit confused about whether the base would have to be a constant for all floats in the system or whether it could somehow vary from number to number... [1] http://www.lispworks.com/documentation/HyperSpec/Body/t_float.htm
FTA: "The fact that emacs works at all without namespaces, with just this giant soup of symbols, is amazing and maybe even indicative of some kind of blind spot in our understanding of software development. Maybe worse is better." Obviously polite programmers in languages like Emacs Lisp and C use prefixes to avoid stepping on each other's toes and it's effectively the same as namespaces. The question I have is: could you make a reasonable namespace system (I guess CL-like) using macros?
Interesting. We were going on the same assumption as you. It does appear that the float base/radix is implementation-defined. Looking back when CL floats were being spec'd out, there was more of a diversity in CPUs than just x86 with a particular kind of binary floats (in fact I think chips might not have even had FPUs commonly), so I guess they had some motivation to leave it open to the implementation. Using the new IEEE decimal floats would indeed fix a lot of the issues with typical monetary calculations... but even that would still be fixed precision rather than arbitrary precision offered by the ratio type. For example under IEEE 754-2008, 'decimal32' only gives 7 digits of precision which already breaks down for 6-figure values with 2 decimal places for cents. So you'd at least want to crank it up to use 64-bit values, typically. Even at higher precision, some of the traditional float caveats would still apply; for instance, adding/subtracting numbers of sufficiently different magnitudes would lose information through rounding. If it makes no difference in performance, it seems simpler just to use arbitrary precision and not worry about such pitfalls. I did a quick search and found http://www.intel.com/technology/itj/2007/v11i1/s2-decimal/1-sidebar.htm which seems to indicate that Intel doesn't see a need to implement decimal floats in hardware anytime soon. That still leaves software, and out of curiosity, I do wonder what the performance of CL ratios vs. a soft decimal float might be. Whatever the performance difference, though, our view is that most applications would be still be better served by the ratio type (or some other arbitrary precision type), just for the safety it provides.
Yeah there were definitely lots of other number representations in common usage, IBM alone had several (and still do). I've just realised that ANSI Common Lisp (1984) was published before IEEE 754 (1985).
Looks like he made it to $12,000 as of right now!
It's really amazing! Let's hope he can reach the 16k goal.
Yeah! From the [campaign page](http://www.indiegogo.com/SBCL-Threading-Improvements-1): &gt;EDIT: &gt; &gt;If $16,000 is reached, the scope of the "big compiler lock" in SBCL will be curtailed, so that it will be possible to compile things in parallel. Should that goal not be reached, funds over $12k will be split between work leading towards it and general SBCL work.
a tree shaker for sbcl would also be nice
Is a tree shaker inherently non-portable?
In these remarks, I'm assuming that the major activity of a tree shaker is to unintern all symbols so that nothing not explicitly referred to survives. Standards issue: that action is inherently non-portable in that modifying the COMMON-LISP package is prohibited for conforming programs. (You could skip that, but since the main point AFAIK of a tree shaker is to drop unneeded parts of *the implementation*...) SBCL issue: As I knew it a couple years ago, stuff which the compiler is interested in (i.e. definitions) cause their symbols to be retained strongly by the "info db". (That said, the info db is one of the things protected by the Big Compiler Lock, so maybe the $16000 work would affect that incidentally. Probably not.) All that said, perhaps someone should try writing a portable tree shaker and see whether its results are worthwhile.
Congrats to all of us, SBCL gets lots of improvement. I hope more SBCL users will support Niko's work, and hopefully more people will donate more code to SBCL source tree or Lisp libraries.
or...why programmers shouldn't create logos. :b Not the linked artist's fault, of course, but...seriously. 
Oh, I dunno. I think the ABCL one is pretty stylish.
I like ABCL ones but I think SBCL ones isn't that nice. We need better logos. The Lisp Alien is good too.
see https://bugs.launchpad.net/sbcl/+bug/759417 I believe tree shakers are inherently implementation-dependent. How would one identify all the dependencies of a compiled function in a portable way? It might be possible to write portability libraries for tasks like this, but its probably best to start with an implementation-specific library and then generalize.
There is also a scheme pack available at http://mcandre.deviantart.com/gallery/#/d3am3r1
Do you really want a tree shaker, or just a reasonably small core file for distribution?
It *must* be Lisp. (disregard username)
&gt;I'd especially appreciate good materials on lambda calculus, because apart from the name I don't know anything about it. Wikipedia links to some good resources. What I found helpful: [introduction](http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf) / [another introduction](http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf) / [in-depth lecture notes](http://www.mscs.dal.ca/~selinger/papers/papers/lambdanotes.pdf) / actually, the [Wikipedia article](http://en.wikipedia.org/wiki/Lambda_calculus) itself might also be a good place to start.
&gt;Which other FP language should I pick and why? I'm not sure if Lisp is a good choice as an example of a *functional language* - you probably won't learn many other functional programming concepts from it. However, it might be worth trying both because it's worth trying out for its other concepts (minimalistic syntax, macros/code-as-data, dynamic typing, dynamic scope, ...) and because it's so different from statically typed functional languages like ML or Haskell.
PS: another kinda-functional (FP concepts and experience is relevant) language you could try out is Prolog. For some reason many comp-sci students despise it, however I found programming in Prolog really fun.
Could you post the syllabus when you get a chance? thanks.
Personally, I'd be happy with any way to build "programs" (executables, images, whatever) of non-enormous size.
As soon as I take a photo of it at faculty building and translate it to English, so not sooner than in 20 hours. Our faculty does a rather sloppy job with updating the website, some subjects' syllabi are not available on-line. I managed to find a part of recommended literature list: J.Fokker's *Functional Programming*, Hugs98 User Manual, R.Page's *Two Dozens Short Lessons with Haskell* and *The Craft of Functional Programming* EDIT: and also L.C. Paulson's *Foundations of Functional Programming*, and H. Barendregt's *Lambda Calculi With Types* and *The Impact of Lambda Calculus in Logic and Computer Science* As I said, I'll post more tomorrow.
&gt; Apart from FP languages and lambdas what else should I expect? [Purely Functional Data Structures.](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf)
F#, Erlang, Racket, Ocaml all have traction in the industry, in the right circles. Check out the proceedings of the "commercial users of functional programing" conference. And read "why functional programming matters" by John Hughes
Here is a nice [list to pick from.](http://en.wikipedia.org/wiki/List_of_programming_languages_by_category#Functional_languages) Me, I would just find the most esoteric language I could find just to mess with the professor. You might really look at Racket. It's simple, clean, cross-platform, has its own editor, etc. It's a very solid choice. As for functional programming, take your old code and turn it inside out. I would say "Like Kriss-Kross" but no one knows who that is anymore. Your old code looks like this: int value_from_following_if_statement_yes_you_need_this; If(whatever) {value_from_following... = blah;} else {value_from_following... = meh;} Your new code looks like this: int value_from_following_if_statement = if(whatever) {blah;} {meh;}; only we get sick of the different syntaxes and just say: (if (whatever) (blah) (meh)) That is lisp and it looks like a Casio reverse polish notation calculator. And you now know most of the syntax. 
Ha, I was thinking "maybe it'd work to just gzip the core file and have it decompress on load", then I look at SBCL's commit log and see this from yesterday: https://github.com/sbcl/sbcl/commit/7976926f8112b708d5927a69923cf7a3dd003c55
Prolog and logic programming aren't covered by this class. And friends who had Prolog classes generally disliked it.
I would say scheme or erlang. They're both generally functional (common lisp really isn't; e.g., CL code typically uses iteration over recursion) and significantly different from Haskell.
&gt; I would say "Like Kriss-Kross" but no one knows who that is anymore. Tell me that's not considered old yet. ;) Just for better comparison for C-heads, the code sample... int value_from_following_if_statement = if(whatever) {blah;} {meh;}; ...should be... int value_from_following_if_statement = whatever ? blah : meh; Lisp's (if &lt;cond&gt; &lt;true-expr&gt; &lt;false-expr&gt;) is the same as the infamous trinary operator, only prettier. FWIW, the trinary operator has some equivalence to Lisp's COND as well: int x = this_thing_true ? 1 : other_thing_true ? 2 : one_more_check ? 3 : /* otherwise */ 4; (setf x (cond (this_thing_true 1) (other_thing_true 2) (one_more_check 3) (t 4))) And might I propose to the C folks that this use of the trinary is much prettier than a series of if-else statements that alter a single value.
&gt; Full name of the class is actually "Equational and Functional Programming". What does "equational programming" mean and does it differ from FP? This probably refers to equational reasoning, which is simply the ability to reason about programs as if they were equations. For example, given the following: top (x : xs) = x push x xs = (x:xs) We can reason about `top (push 1 []))`: top (push 1 []) == top (1 : []) == 1
In the past I've read up on syntax-rules/syntax-case and tried some PLT examples, but I never understood the appeal. It's a lot of fuss to avoid the most easily avoidable problem. It's as if this complex apparatus was created by someone who didn't know about macroexpand-1 and SLIME. Simply look at your expansion and it's obvious where you introduced variable or forgot an unquote (which will emit a warning anyway). If that's still not enough, then place the macro in a package called IFUCKEDUP. Now, go to a different package and expand the macro. If you see "IFUCKEDUP::" then you fucked up. 
Jump! Jump!
I'd pick clojure. It has some very worthwhile and careful design vis-a-vis concurrency. (plus clojure is a lisp). Absent that, pick ml, which is the granddaddy of functional languages, and is more formally, carefully, and rigorously specified than anything else. So if you want a window on the typed lambda-calculus as such, then ml is the go-to place to examine it.
Direct link (PDF): http://www.dreamsongs.com/Files/Timrep.pdf 
$1000 in 36 hours seems pretty doable. I wonder if every Lisper that would be inclined to donate has already donated. Maybe someone should mention that SBCL is a "Python compiler." :)
Very useful, if you've misplaced your personal copy of the text, as I have. (I think the cat has knocked it behind my bookshelves....) Also still worthy for the excellent Preface and the various throwaway quotes from implementors. Otherwise, how interested are you in history?
Oh, I'm interested in the history and principles. I was wondering what, if anything, has changed about Lisp implementations since then that would matter as far as the book goes. Also, [Amazon](http://www.amazon.com/gp/offer-listing/0262070936/ref=dp_olp_used?ie=UTF8&amp;condition=used) has a few used copies at steal rates. "Library book, possible highlighting or writing", but how often would this book be checked out?!
That `setf` really is why perhaps scopes probably better than forms; he uses it because the alternative `(lambda (var) (let ((var (dep-on var))) ...)))` is more nested than `(lambda (var) (setf var (dep-on var)) ...)` but what he means is the first one. I can't say i know, but I have the feeling that using regular expressions that is not regular is potentially a bad idea?
OK, so I went and checked, and it looks like the old syllabi are gone, and the new ones are not ready yet. So sorry, I have no more info on the class.
Many of the benchmarks used for Haskell, JavaScript, the shootout, etc have their origins in this book. Plus there's great info on optimizing microcoded Lisp implementations. ;)
Educated guess, but the biggest change is probably the one not mentioned much -- the processor. Even your cell phone now uses a [superscalar](http://en.wikipedia.org/wiki/Superscalar) processor with sophisticated [branch prediction](http://en.wikipedia.org/wiki/Branch_predictor); laptops and workstations support [out-of-order execution](http://en.wikipedia.org/wiki/Out-of-order_execution) and [branch target prediction](http://en.wikipedia.org/wiki/Branch_target_predictor); both have sophisticated [caching systems](http://en.wikipedia.org/wiki/Cache_memory) to accelerate memory access. *Some of these things had not been invented yet.* It used to be branching was expensive and aliasing was almost free -- this has inverted. 
I already did a second donation. I wished I could have contributed a larger sum but I'm afraid I can't now :-/
Check your sources, all of the listed techniques have been around in computer architectures for decades. cfr. [Computer Architectures](http://www.amazon.com/Computer-Architecture-Quantitative-Approach-4th/dp/0123704901)
Most of the linked book was written in 1982 and 1983, so many things invented decades ago post-date it. Certainly the performance characteristics of the Lisp systems described are *very* different from modern processors.
You don't have to escape single-quotes in double-quoted strings.
aaronla's examples were invented mostly by IBM in the 360? 390? system, some by Cray, some by DEC. All prior to 1980. All for mainframes. Check your Hennesy/Patterson. PCs are still catching up to mainframe CPU design. 
Glad to see you're enjoying it already :). Me, personally, I hated it for a while, coming from non-functional languages like C++. It's the gold standard in musical intelligence so I stuck with it, and once I wrapped my brain around recursions and got used to those stupid parenthesis everywhere, I really love programming in it. I'd highly recommend using a repl, probably slime. You might already know from another language, but a repl is like a lisp CLI that you can just evaluate your ever-changing functions into as you go. It makes development and testing much easier and more fluid. I'd check out http://common-lisp.net/project/lispbox/, it gives you a prepackaged emacs w/ lisp and slime.
You said you didn't want to use Emacs, so I suggest you try [Slimv](http://www.vim.org/scripts/script.php?script_id=2531) which is a Swank client for Vim. It opens a lisp REPL in a Vim buffer and has most of the functionality of Slime, like debugging, profiling, indentation, completion, Hyperspec lookup, paredit, etc.
&gt; It's the gold standard in musical intelligence.... That's interesting, what do you mean?
Wow, they made it.
Thanks for that.
I started playing with the clisp cli (just typed clisp in bash), before writing the script, in fact. It's like a python cli, or like a wish terminal for tcl, yes? a language specific cli (or, I suppose my bash terminal is just the same thing for bash, really).
Oh, okay, thanks for the tip. :)
I think I get it. Kind of like the obligatory indenting in python, no?
[A friend showed me](http://www.deepsoft.com/?attachment_id=1013) a possibly better way, using let*, and making the query part a function (with defun), and the response part another function. It looks like more code, but I see how, in the long run, it makes it actually more efficient and extensible.
lolol!!!! very informative! actually this was quite a vid. upvotes!!!!!
This is the new Rick roll?
Non-bullshit link: http://dorophone.blogspot.com/2011/05/hyperturtle-monad-makes-pretty-pictures.html
I don't understand what etiquette I've violated for this link to constitute a "bullshit" link. In my experience, lots more people wanted to watch a screencast/talk than read an article, so I posted the screencast. What gives?
Click on the link up top. *Can't tell if trolling*
[Common Lisp Music](https://ccrma.stanford.edu/software/clm/) is a popular music synthesis/composition package taught at music/art universities. Common Lisp is also used for the [Common Music Notation CMN)](http://en.wikipedia.org/wiki/Common_Music_Notation). I know that for example here in Germany, the well respected Folkwang school of art [teaches ](http://icem.folkwang-hochschule.de/~finnendahl/cm_kurse/) Common Lisp and/or Scheme for [Common Music](http://icem.folkwang-hochschule.de/~finnendahl/cm_kurse/doc/cm/cm.html).
Oh duh.
Oh well, I guess we are getting that big compiler lock broken.
There are more details [on his website](http://random-state.net/log/3523852985.html).
Any use of the format language is obfuscated code.
Also, any time any one objects when I say Common Lisp is "crufty" I'm going to bring up the "terpri" function. 
I remember reading somewhere that its origin lies in the special operator LABEL that was once used to give a lambda form a name that it could use to reference itself. I can't find any references about which Lisps had the LABEL operator, though.
&gt; CAS support will be extended to at least STANDARD-INSTANCE-ACCESS, and made user-extensible. (Work in progresss.) Can anyone explain what he means by that? 
I was wondering what that meant, too. See which one of these seems most likely to you: http://en.wikipedia.org/wiki/CAS#Computing
You can also try the Lisp forum: http://lispforum.com
Forgot about Compare-and-swap, given the threading nature of many of his improvements that may make the most sense... or it could be wild speculation on my part.
My intuition was to go to the source\*, the ***LISP 1.5 Programmer's Manual*** ([downloads](http://www.google.com/search?q=lisp+1.5+programmer's+manual)). LABEL is introduced in the following way (on page 8): &gt; .... &gt; Using the lambda notation, we can write &gt; ff=λ[[x]; [atom[x]→x; T→ff [car [x]]]] &gt; The equality sign in these identities is actually not part of the LISP meta-language and is only a crutch until we develop the correct notation. The right side of the last equation cannot serve as an expression for the function **ff** because there is nothing to indicate that the occurrence of **ff** inside it stands for the function that is being defined. &gt; In order to be able to write expressions that bear their own name, we introduce the **label** notation. If ϵ is an expression, and *a* is its name, we write **label[a;ϵ]**. &gt; The function **ff** can now be written without an equal sign: &gt; label[ff; λ[[x]; [atom[x]→x; T→ff [car [x]]]]] &gt; In this expression, **x** is a bound variable, and **ff** is a bound function name. You can find a more detailed explanation on page 18: &gt; 2.3 Functions &gt; When a symbol stands for a function, the situation is similar to that in which a symbol stands for an argument. When a function is recursive, it must be given a name. This is done by means of the form LABEL, which pairs the n&amp;me with the function definition on the a-list. The name is then bound to the function definition, just as a variable is bound to its value. &gt; In actual practice, LABEL is seldom used. It is usually more convenient to attach the name to the definition in a uniform manner. This is done by putting on the property list of the name, the symbolEXPR followed by the function definition. The pseudo-function **define** used at the beginning of this section accomplishes this. When apply interprets a function represented by an atomic symbol, it searches the p-list of the atomic symbol before searching the current a-list. Thus a **define** will override a LABEL. &gt; The fact that most functions are constants defined by the programmer, and not variables that are modified by the program, is not due to any weakness of the system. On the contrary, it indicates a richness of the system which we do not know how to exploit very well. I definitely need to read this manual after I finish ["Loving Lisp"](http://www.reddit.com/r/lisp/comments/jjax5/loving_lisp_or_the_savvy_programmers_secret/). ------ \**Well, [not quite](http://www.reddit.com/r/lisp/comments/k1tnl/where_does_the_special_form_labels_come_from/c2gyr5p).*
That was my first guess, but then I saw "EXIT" and command line arguments in the context, and I didn't know about either of those CAS meanings before.
From JMC's [the original paper on LISP](http://www-formal.stanford.edu/jmc/recursive.html), of course! &gt; In order to be able to write expressions for recursive functions, we introduce another notation. label(a, E) denotes the expression E, provided that occurrences of a within E are to be interpreted as referring to the expression as a whole. Thus we can write label(sqrt, λ((a, x, ), (|x2 − a| &lt; → x, T → sqrt(a, 2 (x + x ), )))) &gt; as a name for our sqrt function. Note that it is recursive (unlike flet). It's funny that LABEL is not actually needed to write recursive functions, as one can use Y combinator, but it looks like McCarthy did not understand lambda calculus works very well. I don't think it is too puzzling, though: LABELS give functions labels so they can call each other. How is this not obvious?
c.l.l is full of spam. At least if you use its only web interface, google groups, which is what most people new to usenet will probably do. And even without the spam, nobody deserves to have to wade through bullshit discussions with gavino. The first thing you think upon seeing c.l.l is "omg this place is abandoned and riddled with spam, lisp must be dead and abandoned too, and the remaining people are all crazy". To use usenet the right way, you then have to go hunt for a client, and then go hunt for a server. Most ISPs dont offer usenet access any more. My ISP closed its last year. Also the original usenet server at Duke university, reckognized that usenet is dead and closed down their server. Usenet is not dying, usenet is already dead but doesnt know it. Recommending newbies to go there for lisp advice is bad advice, since it distorts their view of the overall health of the Lisp ecosystem, for the negative. Sending newbies to c.l.l is harmful Lisp, so please dont do it.
It's not obvious because newcomers often expect the pattern DO/DO\*, LET/LET\*, PROG/PROG\*, FLET/FLET\*. That is, they expect LABELS to be called FLET\*. Pedants will point out that LET\* is the sequential version of LET, while LABELS is the any-order version of FLET. Of course this will be missing the point, as LIST\* is not the sequential version of LIST. In the CL standard and as a CL convention, FOO\* means "just like FOO but slightly different".
&gt; Pedants will point out that LET* is the sequential version of LET, while LABELS is the any-order version of FLET. It is not just 'any order', it lets to refer to function itself within its body. I.e. it allows to write recursive functions. It is a big thing. Yeah, they could still call it FLET*, but I think LABELS sounds cool. :) Note that Scheme has both `let*` and `letrec` -- `let*` is sequential while `letrec` is like LABELS. (And there is `letrec*` too.) 
Of course this is missing the point, as LIST\* is not the recursion-allowing version of LIST.
&gt; c.l.l is full of spam. At least if you use its only web interface, google groups, which is what most people new to usenet will probably do. Back when I was reading c.l.l regularly, I used the [ggSpamFree extension](http://code.google.com/p/ggspamfree/) for Chrome. It worked pretty well.
Yes and no. The benefits of a consistent indentation are similar: if you have badly indented code, Lispers will tell you to fix the indentation before they try to help you. However, in Lisp, the indentation does not matter to the machine; the indentation of an expression is determined (to first order) by the parentheses and, sometimes, the atoms in the CAR position. Given working Lisp code, Emacs can derive the indentation. In order to get Python code to work, on the other hand, the programmer needs to have gotten the indentation right.
Right. I kind of understood that it is obligatory in python in order to work, recommended in lisp for readability, but irrelevant to function.
c.l.l. is not that terrible. I've posted there a few times, and read it every few weeks. The spam is outrageous though, and a few of the trolls need to permanently cancel their internet access.. But: I don't like the linkage with the email account too much, and there's been some freaky posting lag the last time I tried to use it.
However. Lisp-related information in discussion is already rather sparse on the web. Burrying a substantial part of it in the depths of Moria and then sending every lisp-interested newbie down there on his own, is making the community look worse than it is and scaring newbies off. Without a constant influx of newbies, communities dry up. I'm a newbie myself. If I only depended on the locked ward that is c.l.l. to read about Lisp and talk with people about Lisp, I would probably not be using it. Usenet is dying and the opportunity to talk about Lisp should not be force-bundled with usenet like an anchor to somehow "save" the usenet from the inevitable death. I assume that a number of other people in my shoes think the same. The sooner people finally give up c.l.l, the better for Lisp.
You should learn Scheme and the SICP book as background info. Learning Javascript as a functional language is educational. Then learn Haskell - by that stage you should grok what FP is and why it is important.
What reason do we have for having `flet` not behave as `labels` anway? It is readily distinguishable if functions depend on each other/are recursive anyway.. The `let` let*` distinction at least has some potential to provide information to the compiler. Btw suggestion: i use \`\` to make it write it as code in-line, took that (markdown)convention everywhere, as i don't like all-caps.
Does anybody know why c.l.l. is not on Gmane? 
I find Scheme to be very similar feeling to other FP like Haskell or ML, particularly if one uses the right syntactic extensions and libraries. Racket supports a very rich (and extensible) pattern matching library and its cons cells are immutable by default. It also has reasonable support for immutable tables. I write almost exclusively pure functional Scheme/Racket including the use of things like [monads](http://dorophone.blogspot.com/2011/05/hyperturtle-monad-makes-pretty-pictures.html) and [pattern matching](http://docs.racket-lang.org/reference/match.html). Hell, racket even has a statically typed language package built in. For a variety of reasons, I think Racket in particular is a great system to learn functional programming in - it is simpler to get started in than either Haskell or ML and you can just use the features you want to use (and use side effects if you want them). Much easier learning curve.
c.l.l has also become a proving ground for A.I. experiments, like the bot that keeps saying "classic and unsubstantiated". It was probably written by a non-native English speaker who didn't understand what "classic" meant. In the end, I suppose it is fitting that comp.lang.lisp is destined to become all A.I.
I don't think it's *readily* distinguishable whether or not functions depend on each other, but with FLET it is. Apart from the pragmatic reason of communicating intent, you may want to create local definitions. Only FLET can refer to an outer function of the same name. E.g., (defmacro with-debug-cons (&amp;body body) (with-gensyms (a b) `(flet ((cons (,a ,b) (incf *cons-count*) (cons ,a ,b))) ,@body))) You could write cl:cons instead, but then you'd be breaking the trick for others to use (you'd prevent the stacking of local definitions). This is a contrived example, of course, so I leave it as an exercise to imagine potential uses for this technique.
see [here](http://groups.google.com/group/sbcl-devel/browse_thread/thread/c77bb65890eea867)
You don't have too though, there is shit like [bind](http://www.cliki.net/bind), I think it is just better to cut functions up in smaller functions, and then hopefully there just isn't enough nesting left to have much use for binding macros. 
Damn, I like that. A really nice example of why setf is such a good idea.
Remember - keep those trailing parens on the same line. Do your best to forget the syntax idioms of your previous languages.
Okay, thanks. &gt; Yeah. In tcl {proc} { &gt; we puts parens { &gt; ok, brackets, really &gt;} on another line &gt; } I need to break this habit. 
REPL stands for Read, Eval, Print, Loop and that is exactly what it does: It reads your input, evaluates it, prints the value and then reads your next input. In fact, you can easily define this function in Lisp itself as such: (loop (print (eval (read))))
http://en.wikipedia.org/wiki/Igor_Engraver might also be interesting. I also found one of the current owners names fascinating "Cons T. Åhs".
Excuse me but any sane modern Lisp (not Emacs Lisp) has lexical scoping. Can you say that a PL has lexical scoping or does it use lexical scoping? Hm. Yeah, that's an interesting question myself.
Of course. I was referring to Common Lisp's dynamic scoping, which is not the default option, but a useful feature.
I have Richard Jones' original book from 1996 and it is fantastic: I really look forward to getting the updated version. 
I viewed all the lectures from the Stanford U CS-100 level functional programming course ([CS-61A](http://www.youtube.com/watch?v=GAHA0nJv8EA&amp;feature=relmfu)). Note: not a masters-level handling of the topic. Anyway the lecturer was completely in love with lisp and scheme and asserted repeatedly, at least once per lecture, that the things he was doing in lisp were just impossible in other languages, specifically naming Java, C#, C, C++. I don't recall him mentioning Javascript or Python by name. It made him seem really out of touch. Too bad for all the students that believed those statements. I did all the coursework in both Javascript and C# (in addition to lisp). Using C# was a little extra effort, but the generic Func types and predicates made it all pretty elegant. Doing the work in Javascript was quite easy and natural. I loved the chance to think functionally using different languages - I thought that was very instructive. So I recommend you consider Javascript, primarily because of its prevalence. It is probably the most ubiquitous language in the world, and doesn't get credit for being functional. ps: I read on the youtube comments that CS-61A is using Python for fall semester this year. 
We've come so far: &gt; Allegro Common LISP can be executed on a 1-megabyte Macintosh with a hard drive, but constant garbage collection makes it a waste of time. This language calls for 2.5 megabytes of main memory -- more if you want to create large systems. On a Macintosh II with more than 2.5 megabytes of memory, this is a development system that rivals dedicated machines at a fraction of the cost. 
And they added a source code stepper a mere ~~12~~ 22 years later. EDIT: Apparently I can't do simple math. But looks like I'm still wrong - see below.
You fellows are so retro!
1988 + 12 = 2000 Coral Software's Allegro Common LISP ≠ Franz Inc's Allegro CL. They were never related in any technical way. The name 'Allegro Common LISP' was used by Coral Software for a short time in a marketing cooperation (IIRC). Franz Inc. had a new source code stepper in 2010 (which is 22 years later than the linked review from 1988 - time flies) for Allegro CL. At that point Coral Software and its Allegro Common LISP did not even exist anymore. Coral Software years ago was bought by Apple then spun off as Digitool. The name 'Allegro Common LISP' was only used for a short period of time and later changed to 'Macintosh Common Lisp'. It was open sourced a few years ago after another version was open sourced which is now known as Clozure CL. An incarnation of MCL is here: http://code.google.com/p/mcl/ - Apple created new problems because it (MCL) runs on PowerPC and Apple removed the PowerPC emulator (Rosetta) from the new Mac OS X 10.7.
Thanks for the corrections.
It's a USENET newsgroup and not a mailing list.
From https://github.com/gihnius/cl-common-blog/blob/master/cl-common-blog.asd : :depends-on (:elephant :ele-bdb :md5 ;;:ele-postmodern :hunchentoot ;;:parenscript ;;:cl-html-parse :cl-who)
Is elephant even maintained anymore? From http://blog.quicklisp.org/ "elephant has been removed because it hasn't worked on SBCL for several months now, and patches for the problem have been ignored. As far as I [Zach] can tell, Elephant is effectively unmaintained."
Time to fork? The last time I used elephant was a few years ago, but it was quite nice then, and it would be a shame to let it rot. I'll ping xach to see what patches he was referring to, and I'll look into Elephant's license situation now. *edit*: LLGPL, not bad. 
Also Bill St. Clair's [Lisplog](https://github.com/billstclair/Lisplog).
Also Nuclblog: http://cyrusharmon.org/projects?project=nuclblog You can pull it from quicklisp. (I haven't tried it)
Someone recently merged the patches.