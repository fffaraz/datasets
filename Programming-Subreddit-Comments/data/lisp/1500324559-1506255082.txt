But it's still true, the Windows version is not stable. It can't even complete the test suite (as in, it will hang).
You are too demanding. I tell you what. CCL, which does not say "our Windows port is fragile" just crash on my multi-threaded application. With Lispworks I have artifacts in my opengl program, due to gc, that I have to workaround. And with SBCL all my stuff just WORK. So, come on, give yourself some credit.
No graphics to speak of in this one, we just start working through the paper and try to work out what will go where. Not sure how it is view watching but I had fun :D
The quote from the video is: &gt; "lots of people that got their first start programming, programming in QuakeC. But as the years have passed I've wondered to my self maybe I could have done better for the world if I had used Scheme or some small language and gotten people learning, if they are going to learn their first programming language don't learn in some ugly hybrid of a thing that was really not well thought through" The headline is catchy but the content is a little subtler. The point is less lisp but more any small, well thought through language, rather than the 'ugly hybird' that he feels his work was. This is not to detract from the video of course. Considering the human aspects of your choices is important. Also Carmack's comments are scheme, haskell, etc are generally interesting as they are usually balanced by the pragmatism of having to make stuff that runs fast. Cool stuff
Carmack made a racket system to quickly prototype VR scenes. See carmack vr lisp racket https://news.ycombinator.com/item?id=9810342
In the first sentence, it's 'programming in [QuakeC](http://www.gamers.org/dEngine/quake/spec/quake-spec34/qc-menu.htm)'. We used it at a game company I used to work for long, long ago, and I don't really remember anything especially good or bad about it, but I do remember this: &gt; Since all the functions use a single parameter marshaling area, and a single global variable to store their reture result, you should NEVER try to call a function within another function call. 
thanks, fixed. and woah to that warning :D
Thanks for this. Feels great that the word is getting out!
X-Post referenced from [/r/programming](http://np.reddit.com/r/programming) by /u/agumonkey [William Byrd on "The Most Beautiful Program Ever Written"](http://np.reddit.com/r/programming/comments/6ow20c/william_byrd_on_the_most_beautiful_program_ever/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
side note, Tim Sweeney (of Epic Unreal) went full on into functional programming, he reviews pros and cons of FP style. Even co-authored a paper on a new programming language.
Looks great but I don't have 90 minutes to watch this right now. Will bookmark. For now, can someone link to the source so I can spend a few minutes at least *browsing* The Most Beautiful Program Ever Written? (I'm sure it's better with explanation, but so much beauty should also stand on its own to some degree.)
He goes quite quickly from "here's a function that evaluates expressions" to "Let's generate an infinite number of quines!".
Nice. here is a link to a presentation on this https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf and comments on it from lambda-the-ultimate http://lambda-the-ultimate.org/node/1277 Good to look at the rough numbers from the talk (although they'll be far higher now) when reviewing ideas for managing entities in your engine, if you are interested in to possibility of making AAA games in your favorite language.
 (define eval-expr (lambda (expr env) (pmatch expr (,n (guard (number? n)) n) (,x (guard (symbol? x)) (env x)) ((lambda (,x) ,body) (lambda (arg) (eval-expr body (lambda (y) (if (eq? x y) arg (env y)))))) ((,rator ,rand) ((eval-expr rator env) (eval-expr rand env)))))) Using this definition of pmatch: https://www.cs.indiana.edu/cgi-pub/lkuper/b521/_media/pmatch.scm For anyone following along, you may need to remove the underscore from the syntax-rules literals list for the definition of ppat (syntax-rules (_ quote unquote) should become (syntax-rules (quote unquote)
is there anything like figwheel for gui apps?
6pm UTC happens when this comment is 4 hours and 40 minutes old. You can find the live countdown here: https://countle.com/gz20749wr --- I'm a bot, if you want to send feedback, please comment below or send a PM.
bad bot
I have managed to solve it in another way. Now i am a novice at all this, so this might be an ugly hack with unforeseen consequences. But there is a file called "system-index.txt" in "quicklisp\local-projects" and if you simply add the absolute path to your asd file it works, atleast for me. I have "E:/Project/CsharpCompiler/code-writer.asd" and it quickloads without a problem.
I believe there was a presentation at the last Lisp Symposium that could be related: https://www.european-lisp-symposium.org/static/2017/rideau.pdf Also: http://fare.tunes.org/files/asdf2017/asdf2017.html I wish there would be a video of it, a tutorial would be useful.
I would advise against using that. It is internal file of Quicklisp - if this mechanism is changed, your setup will cease working. local-projects directory is the supported and advertised way for adding project. You have also guarantee, that project in local-projects takes precedence over projects in system-index.txt. You may symlink your system in local-projects/ directory, it will have the same effect as putting software in that directory explicitly.
Why does this website want to "Access the list of subreddits I moderate, contribute to, and subscribe to."? I won't give you access to that data!
Sorry about that! It no longer requests that permission. It will only record your username :)
Thanks! That's being responsive! Also, it's cool that reddit lets you specify. I know some OAuth providers that don't let people using it request fewer permissions.
You can always use the Java API for Processing in Clojure or Armed Bear Common Lisp. Clojure in particular has a good ecosystem of idiomatic processing bindings and [inspired libraries](http://quil.info/)
thanks
Wow... I love every Lisp book that I've read though. Some, I would give more points to than others, but with only an 'up-vote' to give, I'm voting for lots.
[Sketch](https://github.com/vydd/sketch) may be what you're looking for. I haven't yet tried it, but I can't wait to get to it. [Cepl](https://github.com/cbaggers/cepl) is pretty awesome, too, but it is very OpenGL intensive. [Impromptu](http://impromptu.moso.com.au/) is Scheme, IIRC, but also very cool.
The 'inspectable' part is interesting as different systems have different ideas as to what that would be. To me that sounds like being able to click on visual 'thing' and read/modify it's properties in the graphical view (smalltalk style), is that what you were asking for? Could you link to any part of Processing, etc that show the feature you'd like? That would help answer the question a little better.
&gt; is that what you were asking for? that would be the ideal. &gt; Could you link to any part of Processing, etc that show the feature you'd like? I'd like all the features, but I'd settle just with drawing primitives.
Impromptu looks great, but it's only for OSX :( I'll check the other alternatives out. Thanks.
Great site ! it looks like a book review of mine disappeared though :(
Which book was it for? Was it this review: http://www.communitypicks.com/r/lisp/s/17592186046688-common-lisp-recipes-a-problem-solution-approach/t/17592186050725-getting-things-done-in-the-real-world ? Because that was great!
Yes exactly ! (edited) So either you put it back, either I was tired and saying non-sense :) (and thanks !)
*Inconvergent* is doing this: http://inconvergent.net/generative/ in Common Lisp now: https://github.com/inconvergent Snek: https://github.com/inconvergent/snek no idea for the inspectable thing.
thank you
That sounds like crud! I first programmed in C using the dialect in the game [CRobots](https://en.wikipedia.org/wiki/Crobots) (a game developed with Unix tools, notably Yacc for the C dialect, but packaged as an MS-DOS executable). C Robots C didn't have any such problem with function nesting; it used a stack-based VM. [Original author's site about this here](http://tpoindex.github.io/crobots/). 
There's a pretty cool collection of Clojure/ClojureScript libraries called [thi.ng](http://thi.ng/), which might sort of be what you're looking for. There's also a neat ClojureCLR project I've had my eye on called [Arcadia](http://arcadia-unity.github.io/), which lets you live-code Unity in Clojure. It's still in early alpha, but I see a lot of potential in it.
I simply "move" the operator to the right or left of the first argument as necessary. That is, I see: `(&lt; A B)` as `(A &lt; B)` and similarly: `(&gt; A B)` as `(A &gt; B)` however this isn't merely a lisp trick: In Q, I will write `a f b` as `f[a;b]` if I end up with fewer parenthesis. I don't know how I feel about thinking about them as music symbols; Programs are not songs to me.
As I noted earlier (possibly more than once); this cognitive trick is fine when there is no partial evaluation both (or all three, four, five) arguments are explicit. I haven't found it as helpful for situations like `(op &lt; 3)` which returns the equivalent of `(lambda (arg) (&lt; 3 arg))`. Yes; we could see that as `(op 3 &lt;)`, and so, aha, the free parameter will bind an argument on the other side of the `&lt;`, but the resemblance of `op &lt; 3` to infix messes with the brain nonetheless. 
Indeed! Q also supports projections (partial evaluation): `a f` is `f[a;]` and so on. It's for this reason that I think arc is right to have a reader macro for this.
https://github.com/LispEngineer/genera-src/blob/master/gczm/zmi.lisp
0/5 ☆☆☆☆☆ From Chapter 29: &gt;revision date: October 15, 1988 As sad as I am to say this - I consider the fact that this second edition was published a huge mistake. To me, this 2nd edition is toxic and harmful to Lisp and the Lisp community itself. With all due respect to the author and his work, this book is a good introduction to implementing a basic Lisp system in C and certainly had its value when it was published - hell, 1988 is well before I was born. This book's emergence must have been good thirty years ago, but nowadays, this book, in its current form, belongs in the grave that it was brought back to life from. This book has been resurrected from the dead just as it was created almost thirty years ago without any obvious corrections, addendums or remarks that Lisp has gone a long, long way since then. This book contains nothing about Clojure, or Scheme, or Common Lisp, or Arc, or InterLISP, or even MacLISP - not even a remark, other than a single mention of Steele's CL book in the bibliography and Moon's MacLISP manual. Quoting the "Introduction" chapter from the book: &gt; First, it is intended to be a gentle, but precise, introduction to the LISP language; Nowadays, it is not. This book is an introduction to a dead language that LISP 1.5 is, ignoring the whole work that has been done between the creation of LISP 1.5 and modern times. &gt; We shall focus on the common core of LISP, but some definitions given here are not universal, and in a few cases they are unique to the version of LISP presented herein (GOVOL). The GOVOL dialect of LISP presented here is similar to the original LISP 1.5 [...] This book is *actually* an introduction to a language called GOVOL that completely became dead - googling for it gives not even a description of the language, excluding quotes from this book itself. With multiple contemporary Lisps that are actually used nowadays, this book describes a language that is effectively extinct today with no possible niche in which it could be successfully revived. There are many books that describe modern Lisps and their ecosystems in a practical and useful way: PCL shows how CL is good for general programming, PAIP teaches good Common Lisp in AI context, SICP is a classical Scheme book and video lectures, Clojure for the Brave and True is a very good Clojure resource - and this book teaches the internals of a system and programming language that is hardly relevant and not at all useful anymore. This book has no warning that its contents are purely historical. It has no 2nd-edition-foreword stating that this book was created thirty years ago and its contents have not been anyhow edited since then. It has its original introduction whose meaning, read in the contemporary times, is simply false and misleading, and no one from Apress - especially the technical reviewer - cared enough to notice and fix this. And also, since, as of now, **this** is **the most recently published Lisp book**, I have no doubt that people who want to learn some Lisp will reach for this position. Instead of something that can show them useful, practical resources for learning contemporary Lisp, they will see something that should have stayed in an antique shop but instead was grabbed unchanged, not refreshed by any means, and just dressed in a fancy new Apress cover and published anew in 2007 with contents from 1988. This book, to me, is a proof that necromancy is best left banned.
Indeed it's a serious attack vector. Most of the erlang JSON libraries produce binaries instead of atoms for this reason! cl-json has `safe-json-intern` as a way to mitigate it, but I'm unsatisfied by how difficult it is to get "safety" in cl-json.
&gt; hell, 1988 is well before I was born Now you are just making me feel old. :P Nice review. It's a shame to see Apress released such an outdated book with misleading title such as this. I really wonder what prompted them to (maybe the sale of Lisp books has improved in recent years perhaps?). Incidentally, it's too bad we can't leave a review on Apress site to warn any potential buyer about this book's shortcoming. 
I'm surprised that a book from 1988 was using the archaic "LISP" instead of "Lisp". That spelling seems to have mostly gone away in the early 1980s. By 1981, Lisp Machine manuals were using "Lisp" and I think Common Lisp (1984) was always "Common Lisp". "LISP" seems to be used only by LISP 1.5, MACLISP/MacLISP, and INTERLISP/InterLISP. Only the third seems to have (barely) survived late enough to be contemporary with the book. No book now, or even twenty years ago, should call it "the LISP language". The book should have been aware of Lisp Machine Lisp, Common Lisp, and Scheme, but if your review is accurate, it wasn't and so it was hopelessly outdated even in 1988. And even if it wasn't out of date at the time, it predates ANSI CL (1994), modern Scheme (r4rs is 1991 and r5rs is 1998), and most of the other modern dialects entirely.
&gt; I'm surprised that a book from 1988 was using the archaic "LISP" instead of "Lisp". I'm not, given works like *Common LISPcraft* (1986).
In addition, the [code](https://github.com/apress/interpreting-lisp) is awful. Yikes! Author is not worth a damn as a C programmer, I'm afraid. The high level design is stupid: all objects are in statically allocated tables, and Lisp values are integers. Also, all errors perform a `longjmp` to a single place in the main function. No `unwind-protect`, nothing: the error handling is inspired straight out of the Bourne shell, basically. Overall, it doesn't represent a viable approach for anything resembling a production interpreter. It's like some second year undergrad homework or something. (And not by a talented undergrad; just a normal one). I would add to *flaming_bird's* review this: it is substandard quality for 1988. Lisp 1.5 was obsolete then, and the approach to interpretation is not up to the standard of that time. This **should never have been published**, period.
&gt; Now you are just making me feel old. In my case, flaming_bird is reinforcing my faith in millennials. Fantastic review from a very good angle; well played. I don't care that I'm obsolete; just don't replace me with something inferior. 
Pardon, I'm no millenial, I'm from 1992!
I hope to not disappoint you too much, but that is right at the heart of the millennial generation. According to [wikipedia](https://en.wikipedia.org/wiki/Millennials): "demographers and researchers typically use the early 1980s as starting birth years and the mid-1990s to early 2000s as ending birth years."
**Millennials** Millennials (also known as Generation Y) are the demographic cohort following Generation X. There are no precise dates for when this cohort starts or ends; demographers and researchers typically use the early 1980s as starting birth years and the mid-1990s to early 2000s as ending birth years. Millennials are sometimes referred to as "Echo Boomers" due to a major surge in birth rates in the 1980s and 1990s, and because Millennials are often the children of the Baby boomers. The 20th-century trend toward smaller families in developed countries continued, however, so the relative impact of the "baby boom echo" was generally less pronounced than the post–World War II baby boom. Millennial characteristics vary by region, depending on social and economic conditions. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Oh. TIL!
[Xelf](http://xelf.me/) seems to take a lot of influence from Smalltalk. I haven't used it much but maybe it's what you're looking for.
I have not yet tried parinfer extensively but I think Shaun (the author) is really attentive to parinfer users and deserves some attention.
So what is this evil addition to Smartparens used here, is it evil-smartparens, evil-cleverparens, something else ? Nice explations anyway, thanks.
From the description (since I don't use Spacemacs), seems to be [this one](https://github.com/syl20bnr/evil-lisp-state)
thank you !
Highly enjoyable and educative talk -- thanks!
Have you read the paper?
TLDR; 42€
You can find it on SciHub.
Click the "Download PDF" button in the link, won't you? https://link.springer.com/content/pdf/10.1007%2Fs11023-017-9432-7.pdf
this link doesn't work for me, it redirects to the same page. I only see a "buy PDF" button on the right sidebar. It becomes `https://link.springer.com/article/10.1007/s11023-017-9432-7?no-access=true`.
It's the location, if your IP belongs to an academic institution, the paper can be most probably downloaded; otherwise, you get the 'buy' button.
I'm not connecting from an academic institution.
https://i.imgtc.com/tSaMVTf.png That's what I see. 
Interesting - I can't download it from home, but I can do it from my computer at work (which belongs to an academic institution).
Found through https://news.ycombinator.com/item?id=14902948
Reed Hastings, the founder of Netflix, was an intern at Symbolics.
Oh.. episode :IX return of the lispers is going to be massive
I find it interesting that many times Python leads to LISP, in my case I never learned Python (I am doing it now because is a job necessity), because when I wanted to learn it, I started reading about it and decided I wanted to learn Common Lisp instead. I think Python is interesting, but it is still a Blub (in the Paul Graham sense, not the Esolang).
I started to use python (can't even remember when or why) long after the birth of my lisp fanatism. And thus I always approached it (as ruby or js) as yet-another-dynamic-language. As Queinnec wrote in L.I.S.P they all share the same core.
&gt; *Croma's not quite in a world-useable state, but it's getting there. I'll GPL it as soon as I think others might find it useful, anyway.* As of today, Croma appears not to be found anywhere on the search-engine-indexed Internet: not a shred of documentation, let alone implementation. It is impossible to discuss, beyond this observation.
Yeah, I saw that earlier. Man what a flashback—I forgot about lemonodor. Nice work.
I am getting all verklempt
* Yes, use Slime. It's also a good excuse to learn Emacs if you haven't already. * I like SBCL more than CLISP. You may want to install it through apt-get, then rebuild the latest version from source. * The book you have will work fine, there's no pressing need to get another one. But if you do, "Practical Common Lisp" is good. * There are many arguments which Lisp dialect is best. But the truth is, most of them are ok. Pick one and learn it well. That said, CL is best. ;-)
I'll take a stab at contacting Patrick about Croma.
Thanks for the response :) So basically, I should just continue along but will switch to the latest version of sbcl instead. After going through this book, I'll try out the one you suggested too. Thanks again :)
Ah thanks for your response :) I'll look into ccl too :) 
6pm UTC happens when this comment is 8 hours and 17 minutes old. You can find the live countdown here: https://countle.com/iSr25362L --- I'm a bot, if you want to send feedback, please comment below or send a PM.
I'd just like to point you to some material I myself (also a beginner) find necessary to know when we start writing Lisp (so as to find recent libraries and tools), and that is not always the first thing we find with a search engine: - http://lisp-lang.org/ : to get you even more hooked; success stories, some tutorials and library recommendations - https://github.com/CodyReichert/awesome-cl - libraries - https://lispcookbook.github.io/cl-cookbook/ and its much appreciated [strings](https://lispcookbook.github.io/cl-cookbook/strings.html) page - also https://shinmera.github.io/portacle/ is nice to try at least to see a nice emacs and slime configuration.
The CL standard hasn't changed since 1994 so any books you are likely to find since then will still work. You will occasional find article that were written against the CLisp implementation, there you have to be a little careful as that implementation didnt stick to the spec very well in some places. I would advise you remove clisp and use ccl or sbcl. Common Lisp is an incredibly pragmatic language. Given it's very unrestricted macro system it's a great place to explore the ideas that come from having that. Also given your background you might like the fact that you have [disassemble](http://clhs.lisp.se/Body/f_disass.htm) and some of the implementation specific feature such as for profiling (in sbcl). Also, though not part of the standard, cffi (CL's defacto standard ffi) is fantastic, so reaching out to other code is very simple.
a slow compiler producing a fast code, to be precise.
Use slime because you can do the following: *c-c c-d h* : brings up the hyperspec entry in the browser. you can also use w3m as a browser in emacs and download a local copy of hyperspec. *alt-.* : find the definition of the function (if you compile sbcl from the source, it will bring up sbcl's code). SBCL docs strings are pretty good so that will help you learn. ANSI Common Lisp is fine but it has two flaws: it ignores *loop* and barely covers CLOS. Fortunately, Practical Common Lisp does a really good job covering these. CLisp is fine to learn from but you may run into some problems with libraries. Most quicklisp libraries are written for sbcl, then tested on ccl, then maybe ecl, and then maybe another implementation.
I'm just gonna praise [Roswell](https://github.com/roswell/roswell), it's a great way of installing and switching between Common Lisp implementations (and does a lot of other stuff too). I've only tried it on Linux, on there it is pain-free to use, other OS's I don't know.
I'd just like to add to this that "Practical Common Lisp" is [available online for free](http://www.gigamonkeys.com/book/), and is indeed an excellent starting point. It combines in-depth explanations with lots of example projects which makes for a really nice learning experience (for me at least).
If you are interested in common lisp for its object system, "Object-Oriented Programming in Common Lisp" by Sonja Keene is very good. She give a thorough account of CL's object system (CLOS) which is a little different than what you are probably used to. Look up multi-methods (specialization on multiple parameters) for a sense of a relatively unusual and powerful aspect of CLOS.
Thanks :) will take a look 
Hmm, thanks :) disassemble does seem interesting Also, I did realize that the standard seems to be mature and basically unchanged for a long time, so I'm gonna stick with the current book itself. I've also switched to sbcl today and it's already been nice since it gives style warnings as well. :) it does make it a little distracting at times that the book examples are sometimes bad style (esp something like calling setf directly in the repl) but I guess I'll soon start writing good style code myself. I will have to look into cffi sometime :) 
Ah, so the compilation is slow but final run time code will be fast? I can live with that :) Thanks :) 
Ah, thanks for the handy key chords :) I'll be sure to check up of loop and CLOS in more detail from Practical Common Lisp. Thanks for pointing those out :) I've switched over to sbcl from today morning and I'm finding it quite more mature / modern than clisp, so yeah, I'm gonna stick to it, at least for a while now as I learn (and then maybe try out the others sometime later) 
Hmm, it definitely seems interesting. Will take a look into it more deeply soon :) I don't think I'll be switching implementations all that often though, at least for the first couple of days/weeks/months. Haha I'm a Linux person myself so I'm happy. Thanks for the suggestion :)
Ah, I will take a look into it soon. It definitely seems interesting and someone else on this post also said that the book I'm reading isn't too great for CLOS, so I'll have to refer to something else for that. Thanks for the suggestion :) 
[ ... in which great progress was made, Baggers_ played as the weather god, starting and stopping the rain, the chat was mostly on (or off?) a tangent as usual, and a mysterious "end-of-the-world" NaN bug crept in, in the shape of an engulfing black diamond ]
Haha mad but true. Here it is https://youtu.be/GxQH8289_Kc
Haha mad but true. Here it is https://youtu.be/GxQH8289_Kc
haha mad but all true! Here it is https://youtu.be/GxQH8289_Kc
haha mad but all true! Here it is https://youtu.be/GxQH8289_Kc
haha mad but all true!
haha mad but all true! Here it is https://youtu.be/GxQH8289_Kc
haha mad but all true! Here it is https://youtu.be/GxQH8289_Kc
mad but all true! Here it is https://youtu.be/GxQH8289_Kc
And here it is https://youtu.be/GxQH8289_Kc
haha mad but all true! Here it is https://youtu.be/GxQH8289_Kc
Haha mad but true. Here it is https://youtu.be/GxQH8289_Kc
There are multiple articles of Lisp documentation stored on SO - I saw Scheme and Clojure articles. Where should this data be moved and stored?
What CL pages do you think of interest ? (https://stackoverflow.com/documentation/common-lisp/topics) Generally I didn't find the layout clear, but there are some things to pick. Let's use the CL Cookbook ! Many topics are already present in the cookbook (unit testing, CLOS, ASDF, hash tables, cons cells, lists, …) but some could be imported: loop examples, working with databases,…
Importing them into the Cookbook is a good idea, IMO.
I think in order to have a succesful project like this, you must allow it go through a longer span of the passage of time. People need to create new projects, write docs for it etc. It felt like SO Documentation was pretty much invisible and now they are just shutting it down. However, I didn't really see the need for it anyway since most larger projects already have their own documentation and don't want to host it on a third party site. Smaller projects just have some examples on the readme. So who is SO Documentation targeted for? I think a good use case for SO Documentation could be writing tutorials and guides on how to setup stuff. How to install stuff etc.
I just archived Common Lisp articles here: http://web.archive.org/web/20170803161434/https://stackoverflow.com/documentation/common-lisp/topics Edit: I just noticed they said they will dump it themselves.
Thanks for doing this valuable work. I downloaded the apk to my Huawei mobile, tapped it in files and got a requester saying the source file does not exist. I have enabled non-play store app execution. Cheers.
sure I can help you in building your browser, please reply me with your detailed requirements so that I can check and can provide you the price and timeline accordingly
`POLL`: please upvote if it **works** on your device
`POLL`: please upvote if it **does not work** on your device
Same. Haha. What is that catchphrase they use on 4chan? NYPA.
NYPA=Not Your Personal Army for those out of the loop like myself.
With a FLOSS project it's absolutely fair to request help without being ready to pay for developers. And it's okay for you to say no.
Why nEXT? And don't we already have extensible browsers? I can think of 3.
works on phone with f-droid and cyanogenmod (xperia z1 compact)
As a heads up, NeXT is the name of a Steve Jobs' company in the 90s, so you may run into some trouble with retro computing aficionados and/or Apple's legal team (NeXT's operating system is the basis for iOS and macOS) 
and its ok to ask for compensation
Just don't contribute to free software, if that's your goal. It's much easier.
Symbolics had the trademark for 'Your next step in computing'.
plenty of open source browsers pay their developers. It isn't unreasonable to ask for compensation. open source does not necessitate unpaid developers.
I can't breathe for all the words you just stuffed in my mouth.
thank you for the heads up :) that is actually the inspiration for the name, I think to avoid issues, the name will officially be something like nEXT-Browser
We certainly do have extensible browsers, the thing is though, they are actually very limited in their extensibility. If you look at the plugin browsers for existing plugins they basically allow only the changing of things in the dom. With nEXT, the goal is to work with package maintainers and plugin makers to expose as much of the API as necessary to do really cool things. Some of these features are stuff that is not possible in other plugin environments. A great example is, that you could write a plugin that will show a thumbnail preview of every single tab, and allow you to switch to it by keyboard hotkey, it could look like this: http://imgur.com/n1TDgny Sure, many of these things "could" be done in the actual web view, many "apps" these days being entirely in browser, but many cannot, and nEXT is trying to be something better and quicker than the others. Also, it's written in Common Lisp, as are all the plugins, completely open API for all plugins, you can examine everything in your browser
I am trying to win some grant money to help support the development of the browser, if you are serious we can talk at a later time edit: I just looked at your post history, it seems like you are just fishing for jobs, I'm looking for someone who is specifically into lisp and appreciates what the project is trying to achieve, 99% of your posts are just "sure I can, let me tell you how much it would cost"
It's totally fine to ask for compensation, but I think it's important that one asks in a polite way
I didn't say you said *anything*. I am *only* stating my position. Where did I stuff words in your mouth? There is an implication that people think it is unreasonable to ask for compensation. He has at this point comment karma. Your response to me saying it's ok to ask for money even if none is offered is "Just don't contribute". I did *not* say you said it was unreasonable or that it doesn't happen or that open source developers should not be paid. I simply said what *I believe* is true and left it for you to argue it if you disagree. But we can't have any sort of discussion if you think what I'm doing (stating my position) is the same as stuffing words in your mouth.
He announced willingness to contribute. He announced a desire to see a plan so that he can help by telling you whether the plan is something he can feasibly implement in a given timeline. He allowed you to make the first offer in the negotiation for a price. There were no rude or demeaning comments made. This is in my view, very polite. So yes, it is important to ask in a polite way, and I'm glad that /u/piyushbhargavacommed did just that.
please read through the user's post history
yeah I see what you mean: the rudeness comes from the shortness of the response and the lack of genuine interest in the project itself. Thanks for pointing that out to me.
The people demand screenshots!
[Here](http://forums.roguetemple.com/index.php?topic=5261) 
Looks like a lot of fun! As always there might be some shorter code. For example this (defun translate-build-to-template (x y z build-template template-level) (loop for y1 from 0 below (length build-template) do (loop for c across (nth y1 build-template) with x1 = 0 do (cond ((char= c #\.) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-floor-stone+)) ((char= c #\#) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-wall-stone+)) ((char= c #\T) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-tree-birch+)) ((char= c #\,) (setf (aref template-level (+ x x1) (+ y y1) z) (if (&lt; (random 100) 20) +terrain-floor-dirt-bright+ +terrain-floor-dirt+))) ((char= c #\_) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-water-liquid+)) ((char= c #\`) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-floor-grass+)) ((char= c #\-) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-wall-window+)) ((char= c #\h) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-floor-chair+)) ((char= c #\t) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-floor-table+)) ((char= c #\b) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-floor-bed+)) ((char= c #\c) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-floor-cabinet+)) ((char= c #\C) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-floor-crate+)) ((char= c #\B) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-floor-bookshelf+)) ((char= c #\+) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-door-closed+)) ((char= c #\') (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-door-open+)) ((char= c #\0) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-wall-earth+)) ((char= c #\Space) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-floor-air+)) ((char= c #\u) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-slope-stone-up+)) ((char= c #\d) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-slope-stone-down+)) ((char= c #\*) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-wall-bush+)) ((char= c #\|) (setf (aref template-level (+ x x1) (+ y y1) z) +terrain-wall-lantern+)) ) (incf x1) ))) might be written as: (defun translate-build-to-template (x y z build-template template-level) (loop for y1 from 0 below (length build-template) do (loop for c across (nth y1 build-template) and x1 from 0 for b = (case c (#\. +terrain-floor-stone+) (#\# +terrain-wall-stone+) (#\T +terrain-tree-birch+) (#\, (if (&lt; (random 100) 20) +terrain-floor-dirt-bright+ +terrain-floor-dirt+)) (#\_ +terrain-water-liquid+) (#\` +terrain-floor-grass+) (#\- +terrain-wall-window+) (#\h +terrain-floor-chair+) (#\t +terrain-floor-table+) (#\b +terrain-floor-bed+) (#\c +terrain-floor-cabinet+) (#\C +terrain-floor-crate+) (#\B +terrain-floor-bookshelf+) (#\+ +terrain-door-closed+) (#\' +terrain-door-open+) (#\0 +terrain-wall-earth+) (#\Space +terrain-floor-air+) (#\u +terrain-slope-stone-up+) (#\d +terrain-slope-stone-down+) (#\* +terrain-wall-bush+) (#\| +terrain-wall-lantern+)) when b do (setf (aref template-level (+ x x1) (+ y y1) z) b)))) 
`loop` will anaphorically bind `it` to the test case of the when condition so you can even get rid of another line and use that instead of binding `b`.
Actually that does not work if I understand what you propose. IT is only available at the LOOP level, but not inside expressions. But this might work: (defun translate-build-to-template (x y z build-template template-level) (loop for y1 from 0 below (length build-template) do (loop for c across (nth y1 build-template) and x1 from 0 do (block nil (setf (aref template-level (+ x x1) (+ y y1) z) (or (case c (#\. +terrain-floor-stone+) (#\# +terrain-wall-stone+) (#\T +terrain-tree-birch+) (#\, (if (&lt; (random 100) 20) +terrain-floor-dirt-bright+ +terrain-floor-dirt+)) (#\_ +terrain-water-liquid+) (#\` +terrain-floor-grass+) (#\- +terrain-wall-window+) (#\h +terrain-floor-chair+) (#\t +terrain-floor-table+) (#\b +terrain-floor-bed+) (#\c +terrain-floor-cabinet+) (#\C +terrain-floor-crate+) (#\B +terrain-floor-bookshelf+) (#\+ +terrain-door-closed+) (#\' +terrain-door-open+) (#\0 +terrain-wall-earth+) (#\Space +terrain-floor-air+) (#\u +terrain-slope-stone-up+) (#\d +terrain-slope-stone-down+) (#\* +terrain-wall-bush+) (#\| +terrain-wall-lantern+)) (return))))))) 
&gt;IT is only available at the LOOP level, but not inside expressions. Yep, I didn't know that.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/opensourcegames] [City of the Damned (Roguelike written in Common Lisp) • r\/lisp](https://np.reddit.com/r/opensourcegames/comments/6ruqtw/city_of_the_damned_roguelike_written_in_common/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Although we have competing browsers, we have rather fewer engines, and everything is written in C++ since Netscape 4.0. Browsers are so important that I'd like to see a more diverse ecosystem with a lot more competition. It's a huge task, of course. Most people don't realize that Chrome launched in 2008 but by 2012 still only had about 20% of the market, even with the backing of one of the largest software companies in the world. A new browser probably needs a fresh paradigm to have any chance of success. High modularity could be that differentiator. 
I'm hoping that is the difference indeed! You've summed it up pretty well. Most browsers are basically the same idea rehashed, if you can use one you can use them all. The big problem though is that all of them are what I call "casual" browsers, they're a huge pain to use for any actual work Common tasks like navigation between tabs, searching all tabs, navigating and searching history, are all extremely painful with current browsers, I'm hoping to make something much better and targeted towards power users who want both a more efficient browser, and a more customizable/powerful one!
Don't dismiss usability and discoverability just because they seem "casual", though. I'm sure you already have a plan but I'd say the key to success for any software product is getting to a Minimum Viable Product then building a community.
you're 100% correct on that. I've thought about having two keymaps already, one emacs and one "simplified" that uses all the paradigms of existing browsers (as a kind of gentle way to start off) I think that it is good to have an accessible product, but part of the evangelization, especially by early adopters will be the "coolness" factor, "look, I can do everything with the keyboard! so fast!", at least that is what I am hoping for 
Oh man I've been looking for a paper like this for a while now... I find this kind of history and analysis fascinating. Thank youu!
I contacted one of the authors, Jacques Tramu last August, and he was very helpful and informative. I like the relationship to OULIPO, which I had not explored before. FYI - August is vacation time in France, so don't be discouraged if you don't get a reply until after.
Much better indeed, it may be even better to extract the huge case statement to an alist in a dynamic variable.
Could be a question of speed, though.
thanks for your compliment but I'm still waiting to know the same from your side, please let me know through your response so that we can take it forward from there.
Thank you, didn't know about f-droid! I think I will apply for getting it accepted on f-droid then. As of latest bug fixes from today (Aug. 8), the REPL seems stable now.
 CL-USER 2 &gt; (zmi:zork1) ZORK I: The Great Underground Empire Copyright (c) 1981, 1982, 1983 Infocom, Inc. All rights reserved. ZORK is a registered trademark of Infocom, Inc. Revision 88 / Serial number 840726 West of House You are standing in an open field west of a white house, with a boarded front door. There is a small mailbox here. &gt;open mailbox Opening the small mailbox reveals a leaflet. &gt;read leaflet (Taken) "WELCOME TO ZORK! ZORK is a game of adventure, danger, and low cunning. In it you will explore some of the most amazing territory ever seen by mortals. No computer should be without one!" 
Hi, is lispkit not a good bases ? https://github.com/AeroNotix/lispkit
Thanks for your suggestion! It looks better this way indeed. I need to read about 'case', it seems.
6pm UTC happens when this comment is 8 hours and 55 minutes old. You can find the live countdown here: https://countle.com/92g29527A --- I'm a bot, if you want to send feedback, please comment below or send a PM.
I'm not an expert by any means but I can give my understanding of some of these questions. &gt; Why don't libraries have version numbers? They do. Typically declared in the .asd file. It's up to the library's author to specify/update those version numbers of course. &gt; Why is adding libraries to Quicklisp a manual process that requires human review? Is there an alternative non-curated registry? Quicklisp is mostly the work of one person, and it's still considered to be in beta from what I understand. I don't think Quicklisp is "curated" in a strict sense but it does require the libraries to actually compile and not print any warnings during compilation. I don't know the answer to the second question. &gt; Why aren’t ASDF dependencies automatically fetched if missing? That's not what ASDF is for. ASDF is like `make`, Quicklisp is like your OS's package manager. Different tools for different tasks... However in the past ASDF did have functionality to download libraries that were missing (I believe it was called ASDF-Install?) but nowadays that is deprecated in favor of Quicklisp which is more complete and robust, from what I understand. &gt; Why do so few libraries use GitHub? Common Lisp has been around a long time, and many older libraries predate GitHub. &gt; Are there serious open source efforts to modernize documentation? Yes. You may be interested in the [Common Lisp UltraSpec](http://phoe.tymoon.eu/clus/doku.php) project. &gt; Are there serious open source efforts to modernize libraries? There are plenty of people working on new libraries for Common Lisp. There are also projects to update older libraries. For example, there was recently a big fundraiser to update McCLIM, a native Lisp GUI toolkit. The fundraiser was successful and there have been regular updates posted by the leader of the project about the progress being made. &gt; Would there be any benefit to extending SBCL beyond the Common Lisp standard to better support modern language features and paradigms? SBCL and most other CL implementations do include extensions. For example, threading is not described in the standard, but SBCL provides an extension to allow Lisp programs to use threads. &gt; Why aren’t there more libraries using a functional, immutable paradigm? Most seem to use many dynamic variables and large functions spanning multiple screens, with variables mutating throughout CL is a multi-paradigm programming language. It existed long before purely functional programming a la Haskell became the hip and cool thing to do. CL is not about forcing a specific paradigm on you. If you want that, no one is stopping you from using Clojure, or writing your own CL libraries in a more purely functional style. &gt; Is it worth the time and energy to develop new libraries to modernize Common Lisp – or perhaps a single extended implementation of it, like SBCL – or would that time and energy be more productively spent in a non-Common Lisp community? This largely depends on what you need from a language. CL provides many features that other languages still lack, but there are of course areas where other languages are better suited for a specific task. Sometimes the gap is larger or smaller. I think the community is more than happy to give recommendations for libraries for specific tasks, but obviously it would depend on your situation whether those libraries do enough of what you need, or if it wouldn't be worth it trying to code the rest of it yourself.
Thank you! About library versioning, I guess my main question was about dependency management -- I'm used to declaring a dependency on a specific version of a library, with the knowledge that my project won't pull in a newer version unless I explicitly say so. I know ASDF can include version dependencies, but I've not seen a single library actually do that in its depends-on clauses. I must be missing something.
I don't really have an answer for that... Hopefully someone who knows more than me will be able to chime in.
Answers inlined; removed questions I didn't know enough to have an opinion on. &gt; Why don’t libraries have version numbers? They do. In fact all ASDF systems have a version number. Just very few people use them. &gt; Why is adding libraries to Quicklisp a manual process that requires human review? Because there are few enough libraries that there hasn't been a scaling problem yet. &gt; Is there an alternative non-curated registry? Anybody can create a quicklisp "distribution" (which is a registry), though I'm not currently aware of any public ones. &gt; Why aren’t ASDF dependencies automatically fetched if missing? They are if you are using quicklisp. That being said, ASDF is solving a narrower problem of managing already installed dependencies. Quicklisp solves the problem of automatic fetching (which requires some sort of registry of packages). &gt; Why do so few libraries use GitHub? Because so many libraries are older than GitHub. &gt; Are there serious open source efforts to modernize documentation? Yes, the CLHS is not available under a permissive license, but the original specification (technically final draft specification) is. One effor I'm aware of is here: https://github.com/UltraSpec &gt; Are there serious open source efforts to modernize libraries? Too vague for me to answer. &gt; Are there efforts to encourage open source contributions? common-lisp.net exists largely for this purpose. &gt; My apologies, but I’d never even heard of GitLab prior to seeing all these libraries hosted on common-lisp.net. Why not GitHub? GitLab is at least somewhat well known. The really short answer is that GitLab is open source. Some projects that were hosted on common-lisp.net prior to github existing have moved to github. Others prefer to be hosted on common-lisp.net; for most of these projects SourceForge, not GitHub was the alternative to common-lisp.net when this decision was made. &gt; Why hasn’t the open source community standardized on a single implementation, i.e. SBCL? The same reason that the Open Source community standardized on a single Linux distribution (or even Unix kernel BSD, Illumos, Linux &amp;c.) &gt; Would there be any benefit to extending SBCL beyond the Common Lisp standard to better support modern language features and paradigms? Some of this exists already. The lisp community is very diverse, so attempts to modernize the library are hard to do. There have been many attempts; see [one recent discussion](https://youtu.be/2ZEYxxFR_Gs?list=PLA66mD-6yK8xqd5XKxzwVBIqf1d3QQXpv&amp;t=331) &gt; Why aren’t there more libraries using a functional, immutable paradigm? Most seem to use many dynamic variables and large functions spanning multiple screens, with variables mutating throughout Because the fraction of people writing pure immutable code in common lisp isn't much higher than for any other general purpose language, so the absolute number of people to work on such libraries is much smaller. &gt; Are there any efforts to bring innovative libraries from the Clojure (or elsewhere) community into Common Lisp? There are many places where people have seen a library in another language and brought some of it over to Common Lisp. The community is much smaller than other language communities, so there is limited programmer time for working on these. &gt; Is there software design innovation occurring in the Common Lisp community or is the community primarily focused on maintenance and tuning? &gt; Is it worth the time and energy to develop new libraries to modernize Common Lisp – or perhaps a single extended implementation of it, like SBCL – or would that time and energy be more productively spent in a non-Common Lisp community? See vslevod's talk I linked to earlier and find out if rutils is moving in the way you like The problem isn't that nobody wants to modernize CL, it's that the effort is spread diffusely across a small number of people. The other problem is that the language is so malleable, that you can easily do an 80% solution that solves just the problem you have right now, so there is less of an impetus to standardize on a complete solution. &gt; Why is on-boarding new developers so difficult? For instance, why isn’t Roswell linked to from every About Common Lisp page? Roswell didn't exist when many of the "About Common Lisp" pages were written. There are probably still some pages out there that mention "asdf-install" which is a failed precursor to quicklisp. Also, many of the advantages of lisp development are in the IDE and tooling. This means emacs if you want something stable. People say "I just want to program in lisp, not learn a whole new editor." This is a framing problem I think, because nobody complained about firing up TurboPascal for pascal programming. &gt; Why are there so few instructional or advocacy bloggers? I think it's because it's a smaller and older community. Also the community is very diverse for its small size. 
ASDF will not fail to pull in newer versions. The version requirement in ASDF is a minimum version, not a specific version.
&gt; Some of this exists already. The lisp community is very diverse, so attempts to modernize the library are hard to do. There have been many attempts; see [one recent discussion](https://youtu.be/2ZEYxxFR_Gs?list=PLA66mD-6yK8xqd5XKxzwVBIqf1d3QQXpv&amp;t=331) Thank you! Very informative. 
&gt; Are there serious open source efforts to modernize libraries? You might want to clarify this a bit. As a possible partial answer to your question: CL code has a tremendously long 'shelf life' when compared to "modern" languages. Because of the standard, code written tens of years ago or more will, more often than not, work just fine, assuming it was written for a lisp that conforms to the standard. External dependencies of course change, so ymmv, but the code will be no less correct because of its age.
Everything uses the latest of everything.
The long shelf life of code is a good thing in terms of stability, reliability, maintenance, etc. But the reason for my question was a focus on extensibility, modularity, extension, etc. It's possible that more recent developments in software design practices lead to code which is even more reliable and maintainable than code written, say, five years ago or more. It's also possible that older code is more battle-hardened and reliable, but I fear it's less likely to be well-understood by its users as time goes on.
So unless we're using a private repository for the external libraries we depend on, we have to be wary of breaking changes introduced by library authors, right?
Sort of. Quicklisp makes it pretty easy to use libraries of the same vintage that are known to work together. qlot also makes it pretty easy to use a variety of upstream sources and stick to a known-working set of libraries, and reproduce that set on other machines. (I haven't personally used qlot, but it seems like a sensible idea.)
&gt; Quicklisp makes it pretty easy to use libraries of the same vintage that are known to work together. This sounds actually quite powerful. &gt; qlot also makes it pretty easy to use a variety of upstream sources and stick to a known-working set of libraries, and reproduce that set on other machines. And this sounds quite sensible. Thank you!
I think it's very good that Quicklisp is curated. Without curation, you get frivolous libraries like left-pad, and you get typo-squatting malicious packages like we heard about in npm last week. You can't assume a package is reliable just because it's in Quicklisp, but at least you can have some faith in the package list itself.
Change happens slowly in the Lisp world, but at least part of that is because it's much older than other language families and many of those software design practices were already tried decades ago. Sticking with Lisp helps inoculate you against some of the more illusionary change in other languages, i.e. parading features that were already well known in the 80s. As for some of your other questions: &gt;github Github's software is notably non-free. I find this contradictory and prefer not to use it where possible. Gitlab also has a few nice features not seen on Github such as the ability to run your own instance on a server. However, the lack of libraries on Github is mostly a symptom of age, rather than any conscious choice. &gt;Standards/SBCL The community has mostly settled on SBCL, many projects (Stumwm, for example), have dropped support for less used implementations. And for good reason, SBCL is significantly faster than anything else. However, other implementations have their special use cases and can target non-x86 architectures. As the for the CL standard, basically every implementation already extends it, which is part of the reason there were portability issues in the past. The standard is another product of age and omits a number of things you'd expect from a modern language. &gt;Functional Programming Common Lisp has always been a multi-paradigm language, there are other Lisps such as Scheme if you want to go down the FP road. It's fair to say that the syntax errs towards a functional style, but the language itself is flexible enough to accommodate whatever the user thinks is best. The OO system, CLOS, is worth looking into, it's very powerful and somewhat unique, using neither message passing nor the imperative systems seen in Java/C++.
Thank you! Also, didn't know about [StumpWM](https://stumpwm.github.io/), will have to give it a try.
You used (parts of) my font without giving me credit. That blood splatter symbol, I recognized it immediately. I drew it for my roguelike (Warp Rogue) years ago. I mean Warp Rogue was GPL licensed and that license also applied to the art so I am not saying what you are doing is illegal, just that it is a dick move. 
Good set of questions :) &gt; Would there be any benefit to extending SBCL beyond the Common Lisp standard to better support modern language features and paradigms? did you see http://cl21.org/ ? It's a very important effort to me. It brings more functional and generic stuff, and fixes many CL oddities. It's very usable right now. But as always doc is scarce or missing. This is a problem I'm not sure the community is well aware of. So you could have a look at https://lispcookbook.github.io/cl-cookbook/cl21.html for cl21 details. And it's a community project hosted on github, so… ;) &gt; Why do so few libraries use GitHub? The pb to me is using common-lisp.net where registrations are not open. This is a big pb that slows drastically participation down. &gt; Are there any efforts to bring innovative libraries from the Clojure (or elsewhere) community into Common Lisp? there are. What are you thinking of ? I saw [cl-arrows](https://github.com/nightfly19/cl-arrows) for threading macros, [Fset](https://github.com/slburson/fset) for functional data structures (preceding Clojure though); what'd you like ? &gt; Is it worth the time and energy to develop new libraries to modernize Common Lisp – or perhaps a single extended implementation of it, like SBCL – or would that time and energy be more productively spent in a non-Common Lisp community? see again cl21. And maybe join the effort on [Corvus](https://github.com/eudoxia0/corvus) ? (a "low-level lisp for LLVM") &gt; Why is on-boarding new developers so difficult? I'm not sure the community is aware of this difficulty. I hope that the CL cookbook help in fixing that. Also, hope you saw - http://lisp-lang.org/ and - https://github.com/CodyReichert/awesome-cl see you for your next article :)
about github, to me the problem is to not have open registrations. common-lisp.net uses their own gitlab, why not, but the registration is not open (one must ask) and so it drastically slows down or prevents participation.
That's not my project. The lack of crediting is unfortunate.
There is just no reason to ask for help when using Lisp because it is easy. :)
SBCL and GPL have nothing to do with each other.
&gt; The community has mostly settled on SBCL I used to think this, but the more experience I get, the less I think it is true. Every active CL has a number of users that cannot or would not switch to SBCL. They'd be more likely to stop using CL.
Stack Overflow is a really good source of help for Common Lisp programming. I hope people who need help take advantage of it. There are a handful of very active and helpful people providing answers.
God there's something wrong with me. I use common lisp and vim.
One of the best hackers I know (Rob Warnock) uses straight vi for Lisp.
And now I know what I'm reading instead of Reddit today: http://xach.livejournal.com/316403.html
You guessed wrong? :) There are 4039 questions and only 198 without accepted answers, most of which are very specific or to do with things well outside the spec (lots of ffi &amp; platform specific things). The question response time pretty fast and the quality is generally excellent (especially compared to what i've experienced in the android areas of SO)
Shhh, you're breaking the status quo. :D
there are industry strength plotting package?
Any chance to get that comp.lang.lisp archive? The download links don't work for me (e.g. those at the start of https://www.xach.com/naggum/articles/notes.html). Thanks! EDIT: found [something](https://groups.google.com/forum/?hl=en#!msg/comp.lang.lisp/gO3niThNZNM/4pUS0vEjrKsJ)
I'll only go for a few of these as there are already so many good answers &gt; Q: Why hasn’t the open source community standardized on a single implementation, i.e. SBCL? In short, because people have different needs. Folks who want to embed in C applications will benefit from ECL, people who work in a java stack can benefit from ABCL people, etc &gt; Would there be any benefit to extending SBCL beyond the Common Lisp standard to better support modern language features and paradigms? As you've seen above, most implementations do extend. But it feels like the 'modern language features and paradigms' part of the question is suggesting updating the standard. One the beuties of CL (and some other members of the lisp family) is the fact you *dont* need to force the entire community to do something to get change. You can see projects like CL21 as an example, once again choice is key and the non-dictating nature of CL make it a good home for people with a wide range of priorities. You can see things like grey-streams, cffi &amp; bordeux-threads for examples of things that have become defacto standards in the community and also to projects like optima and named-readtables which provide feature to CL as libraries which in other languages would require a new version of the language. It's also wonderful that, if you make a better way of working, you can release it as a library and let people decide if you were right :) and if they dont like it you lose nothing. That and that standards compliant code from 30 years back still works just fine as we've been gaining all these nice features. There are some things that can't happen without buy in of every implementation. Here are a few examples: https://common-lisp.net/project/cdr/final.html &gt; Why is on-boarding new developers so difficult *Warning: Very much my own opinion* - CL is enjoyable to learn with a good environment - Emacs/Vim are the only places with good environments - Learning Emacs/Vim *and* CL at the same is super hard When `atom-slime` is stable I'll defintely try using that to teach people but currently (last checked 1 month ago) it's way too unstable. Please don't recommend it yet. Roswell isnt recommended by most as most people don't use it. I'm certainly in that camp too, once I had a way of getting set up that was simple I stopped looking for other ways to do it (I made a [youtube video](https://www.youtube.com/watch?v=VnWVu8VVDbI) on this process which has been fairly popular). Also teaching is hard and the longer it has been since you struggled, the harder is can be to recall what made things difficult. The 'churn' of people in the community feels low and so it seems that many of the people around have been in for a very long time. &gt; Is it worth the time and energy to develop new libraries to modernize Common Lisp – or perhaps a single extended implementation of it, like SBCL – or would that time and energy be more productively spent in a non-Common Lisp community? Again, you will need to define what you mean by 'modernize'. The reason I'm asking is that I'm writing GPU code in lisp, and that feels kind of modern..but I think the kind of modernization you are asking for might be the kind that would make me ditch CL entirely (more strictly OOP or more strictly functional..more strictly anything really). 
&gt; Why do so few libraries use GitHub? Most of them do use github. 1251 out of 1582 or **79%** quicklisp projects use github. Projects per location: ( ("github.com" 1251) ("gitlab.common-lisp.net" 56) ("common-lisp.net" 55) ("bitbucket.org" 37) ("dwim.hu" 24) ("[kmr-git]" 23) ("[ediware-http]" 17) ("tarballs.hexstreamsoft.com" 15) ("wcp.sdf-eu.org" 14) ("[xach-http]" 8) ("git.code.sf.net" 7) ("repo.or.cz" 6) ("svn.common-lisp.net" 5) ("notabug.org" 4) ("gitlab.com" 4) ("www.lichteblau.com" 3) ("www.lrde.epita.fr" 3) ("beta.quicklisp.org" 3) ("[clnet-darcs]" 3) ("download.fugue88.ws" 2) ("www.thoughtcrime.us" 2) ("abstractnonsense.com" 2) ("nklein.com" 2) ("nst.maraist.org" 2) ("www.xach.com" 2) ("vintage-digital.com" 1) ("juhaarpi.users.paivola.fi" 1) ("www.pvv.ntnu.no" 1) ("web.kepibu.org" 1) ("git.benkard.de" 1) ("www.nicklevine.org" 1) ("logand.com" 1) ("www.ljosa.com" 1) ("xn--9dbdkw.se" 1) ("quotenil.com" 1) ("git.savannah.nongnu.org" 1) ("gbbopen.org" 1) ("www.cs.utexas.edu" 1) ("www.nil.at" 1) ("www.peter-herth.de" 1) ("john.freml.in" 1) ("www.students.itu.edu.tr" 1) ("www.doc.gold.ac.uk" 1) ("git.tentpost.com" 1) ("www.foldr.org" 1) ("ftp.linux.org.uk" 1) ("darcs.unknownlamer.org" 1) ("marijnhaverbeke.nl" 1) ("stuartsierra.com" 1) ("www.common-lisp.net" 1) ("aleph0.info" 1) ("people.csail.mit.edu" 1) ("git.nklein.com" 1) ("[froydware-http]" 1) ("releases.unknownlamer.org" 1) ("wukix.com" 1) ("www.bobturf.org" 1)) 
&gt; Others may be a bit wary of a community that put the GPL on their shallow derivative of a sizeable non-GPL project Parts of SBCL are licensed under Public Domain, MIT license, and BSD license, with some parts under copyrights of Xerox, Symbolics, and Gerd Moellmann (and I believe most if not all of these are inherited from CMU CL) [1]. Not a single mention of GPL are found within its license and copyright summary file [1]. Debian project also came to the same conclusion [2]. Sources: * [1] https://sourceforge.net/p/sbcl/sbcl/ci/master/tree/COPYING * [2] http://metadata.ftp-master.debian.org/changelogs/main/s/sbcl/sbcl_1.3.14-2_copyright 
There are good reasons for open source project not to use GitHub. GitHub is a company which operates a closed-source '"walled garden" website with git hosting (which anyone can do with a host running GNU/Linux or BSD) plus various additional proprietary services. If GitHub disappears, all you have is your git repos, because they are cloned all over the place; what about all the other GitHub specific data that you and your users put effort into? Please drop the obnoxious mentality of questioning people who don't use GitHub. It's not some axiom of the universe that "thou shalt use GitHub". (Or even git, for that matter. Git is not the best version control tool in all requirements. One excellent technical reason for someone not to use Github is that they don't use Git.) 
Wrong guess. The actual mistake is that the graph is wrong. The Redmonk software was too dumb to find Common Lisp questions. As you see the graph is from 2014. I have some months ago contacted them and explained their mistake to them. They fixed it. If you see newer graphs from them, Common Lisp has a normal position in the graph and everything is fine. See for example: http://sogrady-media.redmonk.com/sogrady/files/2017/03/lang.rank_.117.wm_.png 
This deserves to be stickied.
I personally would not use cl21.org , since it has some of the worst design of any CL library I have seen. It's ugly and misguided. The code is bad and poorly designed. One takes a huge performance and functionality hit. One can look at each function and discuss its design. Something which actually was done during the CL design, which was based on knowledge of prior dialects. You can find that the designers of Common Lisp both integrated knowledge from other dialects (Maclisp, Interlisp, Standard Lisp, ZetaLisp, ...) and tried to design a language with purpose: https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node6.html#SECTION00510000000000000000 The thing was written when the author did understand only 20% of Common Lisp, which is not a good base for a language redesign. But this is a common pattern, people not knowing too much of the language and with exposure to languages like Perl, Ruby and others, first want to redesign Common Lisp. Often they do it in ways which directly violates the spirit of the language and its built-in ways to change and extend the language. The only worse thing are people who actually understand Common Lisp and use it to create personalized language constructs, where each construct got a lot of thought, but them sum of all the thoughts isn't elegant and not fit for wider use. I'm not naming people, but some can probably guess who I mean. ;-) It only supports just four implementations, though claiming to be written in portable CL... As its page says it's 'experimental'. Experiments are fine, but it's an experiment which needs a garbage collector. Throw it away and start new. Side note: this is not limited to Common Lisp. Imagine someone with exposure to Wing-Tsun and Taekwondo is trying to learn traditional Karate. Now after a year he is starting to design his own version of Karate with more effective moves, reusing tricks from Wing-Tsun and Taekwondo. But how big is the chance that this person will have understood the spirit and foundations of Karate? Alternatively one could study Karate until one has mastered it and having a Dan grade (a black belt) and then being able to redesign the moves based on actual background knowledge and first-hand experience.
wow you don't like cl21. It's possible it's slower, since it uses more generic functions, but this has to be measured and it is totally acceptable in most cases, and I accept it for the **huge boost** it gives the developer. &gt; one takes a huge functionality hit. this is the strangest of your concerns. &gt; The thing was written when the author did understand only 20% of Common Lisp. this is strange too… cl21 was written by Fukamachi, an author of so many popular and useful CL packages… (**edit**: you edited your post (CL redesign and karate) but it doesn't give solid arguments and examples either) The rest of your points about design and ugliness would benefit some pointers and explanations. 
&gt; Why is on-boarding new developers so difficult for me the difficulty was not about Emacs that I was familiar with, but the extreme lack of good, up to date and enjoyable resources. Do you imagine that many projects don't even have documentation (uiop points to its sources, series,…), don't even have syntax highlighting for lisp snippets (common-lisp.net), is old and clunky (CLHS), that lots of stuff doesn't point to modern tools (all the old books) or is outdated ? :( Hopefully we'll keep on counting on the cl-cookbook and the awesome-list, which have quite improved lately.
maybe vgplot ? https://github.com/CodyReichert/awesome-cl#plotting
For a long time I used vim, first with the CLISP REPL and then with emacs just as my REPL/debugger. I didn't switch to emacs for everything until evil-mode came out.
The speed hit is acceptable for a Ruby user, because Ruby is about 10^3 times slower than a typical Common Lisp natively-compiled implementation and thus cl21 becomes as slow as Ruby. Works fine as a scripting language though. &gt; this is the strangest of your concerns It isn't if you were actually understanding the Common Lisp primitives. Also the author does not understand how actual implementations extend the language in ways that makes sense and what consequences this has for certain language constructs. Redesigning (Common) Lisp is a popular sport and some invested a lot of time: Dylan, ISLisp, Eulisp, Arc, Clojure, CLtL3, CL21, ... The author wrote a lot of software in a very short time, but he didn't took the time to learn the language on a deeper level, which would be required for a language (re)design. That works for him and some others, but please don't assume that everyone likes the design, the implementation or even its goals. The CL21 implementation and design has never been discussed on a wider level. Promoting an experimental design as the base for general purpose libraries is possible, but don't be surprised when others point out its flaws. I'm also not a fan of the gradiose claim of a CL in the 21st century. I couldn't even be motivated to port it to other implementations, because I would not want to use it. Take for example from cl21: (defmethod coerce ((object string) output-type-spec) (case output-type-spec (integer (nth-value 0 (parse-integer object :junk-allowed t))) ((number float) (let ((read (read-from-string object))) (if (numberp read) read 0))) (symbol (intern object)) (keyword (intern object :keyword)) (T (cl:coerce object output-type-spec)))) This is at best amateur-level code. Maybe call it a bloody hack, but not "CL in the 21st century". The whole code needs a full-scale code review before I would even consider using it in production. Any library using CL21 would automatically be unfit for production. **Can you spot the various problems in above method?** Ten lines of very basic and simple-looking code...
interesting. Is the software aware that TeX has its own SE, or does it just look on SO? TeX's is a reasonably active SE.
Lisp was the reason I switched to Emacs 5 years ago after 10 years of Vimming. SLIME is great!
good points.
&gt; Please drop the obnoxious mentality of questioning people who don't use GitHub. &gt; It's not some axiom of the universe that "thou shalt use GitHub". I apologize. I was thinking mainly of the the team collaboration features, such as issue tracking, pull request reviews, notifications, etc., features which make it easier to contribute to projects. &gt; (Or even git, for that matter. Git is not the best version control tool in all requirements. One excellent technical reason for someone not to use Github is that they don't use Git.) Of course, the thrust of most of my questions come from an open source community point of view, and aren't really relevant for people or teams that develop and manage everything internally.
&gt; *Can you spot the various problems in above method?* Upon a cursory glance, I have: * `(nth-value 0 FORM)` is an obtuse way to obtain the same effect as `(values FORM)`: to return exactly one value, which is the first value of FORM. * Why the hell is the author using `case` to dispatch on an argument inside a **method**; why not make it a specialized parameter and use `eql`: (defmethod coerce ((object string) (type-spec (eql 'symbol)) (intern object)) Etc. * `read-from-string` is susceptible to read-time evaluation: &gt; (read-from-string "(progn #.(print \"haha\") nil)") "haha" (PROGN "haha" NIL) ; this should be parsing numbers in some more robust way, or at least rebind `*read-eval*` to `nil`. Oh, and also how about using `with-standard-io-syntax` so the `read` isn't influenced by read table alterations. * If non-numeric junk is coerced to `float` or `number`, then zero results. This is choice debatable in isolation. What is not debatable is that it is inconsistent with the `integer` case, which will return `nil`. * Non-numeric junk which is bad read syntax will not in fact return zero, but signal an error; e.g `(coerce ")" float)`. If `integer` conversion is applied, it will return `nil`. * The direct use of `intern` means that the operation doesn't harmonize with the current settings of the read and print case treatment. For instance, under the default configuration of Common Lisp, if we `coerce` the string `"abc"` to `symbol`, we don't get the symbol `abc`, but rather `|abc|`. This isn't wrong *per se*, but potentially surprising. It competes with a possible alternative requirement to do it differently, which at least deserves consideration. A general comment I have is that `coerce` is used so rarely, that it hardly needs these embellishments. The conversions are so semantically different that lumping them behind one generic function seems wrong. If you have a string and you want a symbol, just use `intern`! This sort of function will encourage/support scatter-brained typeless programming like what is done in Tcl, Awk and their ilk: a string that looks like a number can be fed into arithmetic operations and so on. If you have a suitable `coerce`, you can take strongly typed code that doesn't work, sprinkle in `coerce` calls and there you go. Now let me go out on a limb here, given I'm in a Lisp forum, and make an analogy to something between C and C++. C has a very loose casting operator that tries to make a conversion work, if at all possible: the casting syntax `(type) expr`. The C++ people (Stroustrup et al) realized that this is **not in fact a good idea**. They supplanted this with C++ casts, which are more specific and constrained. For instance `const_cast&lt;int *&gt;(expr)` will only change qualifiers: if `expr` is, say, `const int *`, then the `const` qualifier is stripped, but a `double *` will not convert to `int *`. C++ supports the C casting notation, and defines it as a combination of the C++ casts. For instance if `E` is of type `const void *`, then `(double *) E` is codified as something `const_cast&lt;double *&gt;(static_cast&lt;void *&gt;(E))`. A specific conversion to get rid of the `const` and then a specific one to do the `void *` to `double *`, which isn't implicit in C++. Now this cl21 generic `coerce` is like going from a C++ cast back to a looser C cast: **use one syntax, and just get the conversion**. If the code changes, the `coerce` will still possibly work without any diagnostics, even though it does something quite different from before, and possibly wrong, just like a C cast which silently adjusts its behavior to match a changing type or expression. Type conversions are often hacky, and are, arguably, usually best achieved with some language feature which performs a very specific conversion, and complains loudly if the inputs do not match that specific conversion. 
There is a lot more... the CASE dispatch is one I would also see. The EQL dispatch syntax is a bit different from your example. Anything more you can find?
I use vim/slimv. Love it. Could never get into emacs. Besides, my computer already has an operating system ;)
(I fixed the mistake already; I didn't have the right specifier for `eql` dispatch; the specifier was just `symbol` which would catch all those symbol arguments.)
&gt; *Anything more you can find?* Oh yes! There is this: the right argument of `coerce` isn't really a symbol but a type. This function is missing the fact that you can do this: [1]&gt; (deftype foo () 'float) FOO [2]&gt; (coerce 3 'foo) 3.0 The types can be hidden behind user-defined aliases, which should be resolved. Fail!
Very good! I missed this one. There is more...
I use vgplot and can also recommend it. A long term project for me is to look at moving ggplot into Common Lisp. Which is easier said than done, but an extremely interesting tasks, Who knew determining axis labels was so hard? 
Your points are all very good and valid. Okay, let me document more of this fail: * it has no specification, thus the thing can do anything and claim it is correct * if it had a specification, it still fails to document its behavior * the relationship to the specification of CL:COERCE is unclear. Does it implement an extension? Does it implement the CL:COERCE requirements? * it lies: (coerce "1/3" 'float) -&gt; 1/3 , which is not a float * it lies: (coerce "1" 'float) -&gt; 1 , which is not a float * it lies: (coerce "#c(1 1)" 'float) -&gt; #(1 2) , which is not a float * it doesn't signal type errors as required by CL (coerce "junk" 'integer) -&gt; NIL * it uses the reader. Are now the reader special variables part of the interface? * it is not consistently using the reader variables: example: (let ((*read-base* 16)) (coerce "10" 'integer)) -&gt; 10 (let ((*read-base* 16)) (coerce "10" 'number)) -&gt; 16 * the naming is poor: what is an 'output-type-spec'. Does this thing do output? Where? Why is it a 'spec'`? CL calls it a 'result-type'. * (coerce "" 'number) signals an eof error, not a type error, while (coerce "" 'integer) returns NIL. * the code base has way too few tests for COERCE 
thanks for the precisions. &gt; Dylan, ISLisp, Eulisp, Arc, Clojure, CLtL3, CL21, ... The one difference is that cl21 is not another language, it is a library we can `quickload` or not, backward compatible with our usual CL. CL has LOTS of oddities and inconsistencies (do you agree ? That should be a base for a discussion) that cl21 fixes. The way to create arrays, shorter lambdas, regexps, sane mapping functions, some modern features (string interpolation), more generics, … and most of them are put in modules, so we are not even forced to use them all. ps: &gt; don't assume that everyone likes the design, the implementation or even its goals of course not, I don't think I implied that. It looks a good fit for the OP though given his requirements.
you're welcome to open issues, I guess ;)
&gt; cl21 is not another language CL is a language. Why is 'CL in the 21st century' not a language? &gt; CL has LOTS of oddities and inconsistencies (do you agree ? That should be a base for a discussion) that cl21 fixes. CL21 adds way more oddities and inconsistencies than it fixes. See our code review of a single CL21 COERCE method as a simple example. **The code of a single COERCE method of CL21 has more problems than lines.** &gt; shorter lambdas not needed &gt; regexps existed already as a library &gt; sane mapping functions sick mapping functions 
for dead experimental code?
&gt; this is a common pattern, people not knowing too much of the language and with exposure to languages like Perl, Ruby and others, first want to redesign Common Lisp. This is me, right now, except for the scripting language emphasis. I'm coming most recently from Clojure, and initially struggled to find analogs to the useful constraints that environment provides. So now I'm implementing my own sequence abstractions, for instance, built on top of Common Lisp's list/vector abstractions but adding sets and hash-tables. I hope to later extend them to other data structures like those provided by FSet. &gt; Often they do it in ways which directly violates the spirit of the language and its built-in ways to change and extend the language. Would an example of that be looking for something simple like Clojure's atom (a thread-safe atomic reference)? It's simple enough to implement using SBCL's compare-and-set extensions, but this isn't portable. Does that mean it violates the spirit of the language, or are implementation-specific extensions like SBCL's a desirable part of the language? (I haven't yet been able to find a portable library which provides atomic references -- this tells me either the concept of atomic references in a multi-threaded environment is not useful, or Common Lisp has another way to solve the problem that I haven't learned yet.) Thank you for your response!
&gt; did you see http://cl21.org/ ? I did, and had immediate affinity for its goals, but I was hoping to see more traction. I am impressed with all of fukamachi's contributions. I also felt CL21 might be going too far with syntax and read-tables. I feel a bit more conservative when it comes to importing ideas from other languages. Changing syntax feels like it should be a last resort. It also makes libraries more difficult to compose with one another. &gt; But as always doc is scarce or missing. This is a problem I'm not sure the community is well aware of. &gt; So you could have a look at https://lispcookbook.github.io/cl-cookbook/cl21.html for cl21 details. The [Common Lisp Cookbook](https://lispcookbook.github.io/cl-cookbook/) is very useful. But impossible to find. Google's search results for "common lisp" instead points to [this cookbook](http://cl-cookbook.sourceforge.net/) on something called "sourceforge." Documentation in general is quite challenging to look at, since everyone seems to have stopped improving the design of their web pages in the early 90s. The [codex](https://github.com/CommonDoc/codex) document generation tool is a notable exception, but it's also a bit clunky: why do I have to learn a new markup language (scriba) which doesn't even have an emacs mode available in elpa? Before I manually installed the mode from the scriba repository, emacs wanted to open my .scr files as ImageMagick files. &gt; Why is on-boarding new developers so difficult? &gt; I'm not sure the community is aware of this difficulty. I hope that the CL cookbook help in fixing that. There is a huge learning curve for even the basics of how to put a system definition file together, how to build an executable, how to try out small command line scripts. And of course as a long-time emacs user, I'm completely blind to the challenges non-emacs users face. 
&gt; When atom-slime is stable I'll definitely try using that to teach people but currently (last checked 1 month ago) it's way too unstable. Please don't recommend it yet. I installed it a few weeks ago, which was a major pain, and it seemed to function at least basically. It would be great if there were a VS Code Slime extension -- that is a very nice editor, surprisingly open sourced and very well maintained by Microsoft. I guess, in general, what I mean by "modern" is: one-click install into any major editor and everything just works. (I don't mean proprietary IDEs.) I'm not sure there's anything inherently preventing open source Common Lisp implementations from working this way, if people want to make it happen, but maybe there's not enough incentive to do so. &gt; I'm writing GPU code in lisp I am looking forward to checking out your work if I ever get around to creating the game I have in mind, and thank you for all of your instructional videos and libraries!
&gt; it has no specification, thus the thing can do anything and claim it is correct Are there machine-readable specifications in Common Lisp? I ask from the point of view of something like clojure.spec or Erlang's -spec annotations which can be statically analyzed. I still haven't learned about type declarations and whether they're useful, enforced by the compiler (i.e. statically), etc.
&gt;&gt; Why aren’t ASDF dependencies automatically fetched if missing? &gt; They are if you are using quicklisp. That being said, ASDF is solving a narrower problem of managing already installed dependencies. Quicklisp solves the problem of automatic fetching (which requires some sort of registry of packages). Just a small correction or query: on my system, if I asdf:load-system a system which depends-on something I haven't loaded via Quicklisp yet, ASDF fails. I have to manually ql:quickload the missing dependency. It's a minor inconvenience but an unfamiliar one coming from other environments with integrated system definition and dependency management tools.
Here I was talking about a specification, independent whether they can be used by a machine: The ANSI CL document is a specification.
You can ql:quickload *any* ASDF system, and it will automatically download any dependencies. This is true even for ASDF systems that are not in quicklisp.
&gt; on-boarding For people who feel they are great programmers and are just switching languages: PCL was designed for this purpose. I can't speak for those guys. I was shit when I started lisp. I had used a lot of languages. I had made a lot of money off of software that I had written. After all, good code has nothing to do with good software. But I knew I was shit, programming was just way too hard. So I'm gonna talk about the people who were like me when I started out, and why they would hate and more importantly struggle to use lisp. As I've alluded, I've been on my Lisp journey for a couple of years and I've gone from knowing nothing about lisp to the point where I can actually argue why I want to use lisp instead of languages like c# or python. To me this issue is pretty simple. Lisp's lack of popularity makes it much more difficult to glue things together in order to create software. You can do it, but it pales in comparison to how easy it is to do in Python, which is the best at this in my experience. If I want to write a program in python, I can google how to do it and you bet your ass there will be a library that already does everything I want to do (and more). In addition, I'll see at least 2 stack overflow questions on "how to do x". I'm not saying you can't glue things together in lisp, you absolutely can, and I think lisp actually simplifes so many things, but there is undeniably so much more in your way if you're a newb just trying to make something. Let's get concrete! Lisp's standard library (despite being massive) does not provide you with enough to make a basic application just by gluing some high level functions together. Heck, even writing a file is a fucking mess. (defun write-file (file string)) pls. Imagine you know the filename and what you want to put in the file. That should be enough. Nope. You've gotta copy paste this mess that has something to do with something called a stream (whatever the fuck that is). Manipulating strings? Forget it! (regular expressions?! Now we have 2 problems! Lisp doesn't support regex out of the box? Make that 3 problems!) I haven't even mentioned the parenthesis. Programming lisp without rainbow parentheses is a surefire way to give up on it. If you are not a proficient programmer (ie the way I was before I learned how to apply recursion. ty little lisper), rolling your own functions to do string manipulation is a huge vacuum of your time and energy for something that you feel should already be there. Of course, once you understand how to program, it's easy to roll your own, and honestly when it comes to text, I've been thinking about it all my life, I don't need to reinvent how I think about it. I just need the computer to understand me. So if anything, I'd rather have my own functions that match my thought process instead of trying to reshape my mind to conform to regular expressions or the standard way of manipulating strings that everyone uses so you have to too. Lisp is so much about getting the computer to come to you instead of the other way around. But this is pointless when you're just trying to make something. When you're new and you're just trying to make something, it just feels like, "Why isn't this here? Doesn't everyone have to use strings? Why hasn't someone added this shit yet?" It's so frustrating that the only way someone is really going to put up with all that is if they really believe there's a payoff in the long term. Luckily, there is. Lisp rewards deep study. For example let's look at code substitution. Code substitution is great. It allows you to choose your inputs which is a very poweful thing. However, code substitution where your code is in a stupid simple data structure and you have a huge library dedicated to using that data structure, well that's not great, that's fucking beautiful. But you don't learn that in the same day. You learn about code substitution. You learn about manipulating lists. You realize that your code is a list (multiple times). And piece by piece it all comes together and you can start to see the tapestry those smug lispers wouldn't shut up about. It's fucking beautiful but it's not something you get any value out of when you're first starting out and just trying to make something. Lisp also requires blind faith and trust. You will benefit immensely from suspending belief, doing things the lisp way, and asking why do lispers do things this way. Why do we use let? There must be a good reason. Use it. Ask why. Trust that there's a smart reason for doing so. There is. And if you can't find a good reason, great! You're using lisp, do it your way instead. You're not forced to do things the lisp way. And I didn't even talk about development environments. There's just too much there, but basically it's another one of those long term rewards. I wrote my own toy IDE with LTK in ~30 lines of code that I didn't even realize could update itself in real time. So it's not even about learning EMACS SLIME. The language itself makes it easy to make really great development environments. And when you think about it, shouldn't every language? But when you're new who cares. just give me the IDE. Give me the libraries I need. Let me make my application. And suddenly all of these "features" I bragged about just stand in your way. None of that talk about beauty and reward matters to a gal who just wants to automatically download new episodes of one piece. The only thing she's thinking is why is this shit so pointlessly complicated and difficult. Even if you were to fix all of the problems I mentioned, you still can't compete with googling "how do i do x in python". ----------- Proof: https://www.google.com/search?q=how+do+i+download+one+piece+automatically+in+python https://www.google.com/search?q=how+do+i+download+one+piece+automatically+in+lisp
I see, I should be using ql:quickload, not asdf:load-system, to load my own project when I bring it to a new machine, if the dependencies have changed. Didn't think of that. I knew I must have been missing something. 
...and didn't Paul Graham hack Lisp on vim as well? Looks like you're actually in good company. :-)
Yeah this my first thought too, when I saw that dark corner over there.
you're so right… it's puzzling why the documentation is so bad. btw I just discovered rutils: https://github.com/vseloved/rutils/ a collection of utilities, between Alexandria and cl21.
Could also be like this (import 'alexandria:rcurry) (defun subtest (arg fn) (if (listp arg) (mapcar (rcurry 'subtest fn) arg) (funcall fn arg))) (subtest '(1 2 ((3 (C D 2 3)) 1 2) (F 9)) (lambda (data) (typecase data (number (1+ data)) (t data)))) EDIT: Done formatting.
hi, thank you for the link! I had actually seen it before and perused the source code, there's a couple of reasons I don't really like it 1. it relies on GTK 2. the source code is poorly documented 3. it hasn't been updated in 3 years
Lisp is all about extensibiliy. Case in Point: CLOS. One can extend the object system in terms of the same object system. (Modularity not so much imho). I'm curious, what so you think this developments in software design practices?
to teach everybody watching that repo, so that everybody learns, has a chance to fix it, and/or hopefully the next attempt will be better ?
I would say that there are more books that provide value to the CL community in spite of being old than there are books that are way outdated, due I think largely to the lack of change in the standard. I too thought that the CLHS seemed clunky, and there are parts of it that I don't understand, but for the most part when I need it I put my cursor over a symbol and get the clhs page on the symbol and I'm good to go. It took me a while to find the section where loop's semantics are explained rather than just the grammar, and I go back to that a lot. I imagine there are other such references that I haven't found yet. Regarding up-to-date resources, I found PCL to be a great start, it shows you how to get real stuff done. The only thing that might be out of date is the practical about parsing mp3's and streaming them, and thats only because I have a hard time believing that people have libraries of mp3's sitting around anymore, or maybe thats just me. I also recommend Edi Weitz' cookbook for an example of more modern excursions, esp w.r.t. the section on concurrency, where he walks through using a library that lets you specify a graph of computation steps, allowing concurrent operations to proceed when called for, and synchronizing when necessary.
Me too. At the moment one thing I got used to with CCL was not having to know the size my heap would grow to before I started the image. I didn't even know that was a problem until I started trying sbcl with code that by design would consume a bunch of memory. I remember noticing that landing in the debugger in sbcl seemed nicer and richer than it would be when I was in ccl, and I'm aware of anecdotes about how sbcl might be a slower compiler for compiling faster code, and that it provides a lot of feedback that you can use to guide performance improvements. I appreciate that there are multiple mature implementations. I worry about the messages about how the windows implementation of sbcl is considered "unstable". I know if I had found sbcl first I would probably be saying different things.
I use this. Also, cl-csv and data-tables and a few macros for an octave/matlab replacement.
Industry strength no unfortunately. Prommising yes, I use eazy-gnuplot and cl-plplot. Here is a link to a notebook I made using eazy-gnuplot implementing examples from the gnuplot cookbook. https://guicho271828.github.io/eazy-gnuplot/ I also like cl-plplot - plplot is a very extensive graphine library, unfortunately there is a bug that causes it to be crashy in regards to plot window handling that hasn't been resolved yet AFAIK. 
What's so cool about it? (subst-if nil (lambda (arg) (when (typep arg '(cons number)) (incf (car arg) 2)) nil) (copy-tree '(1 2 ((3 (C D 2 3)) 1 2) (F 9))))
All of the responses are amazing in this thread, but this one in particular is simply tremendous. My journey was a little bit different. I have always loved computing history read up on the exploits of ancient engineers as much as I can. Out of that reading I came to appreciate the following: * The beauty of the Lisp programming language. * The beauty of the APL programming language. * Just how unbeleivably smart the designers of Lisp and APL were. We are not talking normal smart here. We are talking 100 years ahead of the curve smart. Orders of magnitude smarter than smart people. Then consider that McCarthy and Iverson were not the only intellects of that caliber in the computing field in the 50s 60s and 70s. Computer science was bloody full of them! * Just how large of a canyon separates the everyday smart people in comp sci from the true geniuses like McCarthy and Iverse et al. Holy crap. Watching the smart re-invent over and over again some random subset of ideas already inventet so long ago is truly a thing to behold. It's eye watering. * Just how little we have progressed. Computer science has not really progressed much in the last 30 years. Most of the fruits of computer science that we use today were invented in the 50s 60s and 70s. All we do now is more of it and faster. Instead, to make sure the hardware folks get the well deserved spotlight, all of the innovation seems to have gone to hardware (not just better, faster, smaller and more of the same BUT new as well!). So, for every complaint about Lisp my mind just scrolls back to any of intellectual giants of the past in the field of computer science and thank my lucky stars I was born after them to be able to enjoy the fruits of the genius. Because, what would programming look like without McCarthy? Would someone else invent Lisp or APL without them? I think the world would be exactly as it is today, only a little bit poorer becasue we would probably only have a subset of the ideas discovered by these people. Everyone would be programming in some language that is essentially a cobbled together hot pile of garbage ALMOST ALWAYS containing only a subset of the ideas expressed in Lisp. A language invented 50 years ago for crying out loud. The resulting conclusion though is that, there are truly two different demographics exploring Lisp: * The pragmatist - need to deliver a real product yesterday, don't have time for bullshit, gotta pay some bills. Real world economics rules the day, real programmers deliver product. * The admirer - real world economics either don't matter or have bypassed us and we spend our time in magical fields sown for us FOR FREE by giants that are either long gone or slowly passing away. I preffer the latter than the former, perhaps one day we will manage the economics side of things to make a pragmattic Lisp experience have a lower barrier to entry. Lastly, I never look down on the pragmatist. They have delivered 99.9% of the worlds code, not us. I am just glad I don't have to suffer their toil. Lisp makes it fun. 
I would say that this is bad programming practice. First it depends on a side effect. Second an implementation is not obligated to return the tree that was modified with side effects. &gt; For **subst**, **subst-if**, and **subst-if-not**, if the functions succeed, a new copy of the tree is returned in which each occurrence of such an element is replaced by the *new* element or subexpression. If no changes are made, the original *tree* may be returned. The original *tree* is left unchanged, but the result tree may share storage with it. It is pretty clear that use of side effects in the predicate makes the result undetermined. An implementation could implement a valid subst-if where side effects have no effect on the result or the original tree. 
I'm a bit late to this, but I think one of Common Lisp's factors that pushes users towards something like Quicklisp's "working snapshots of the ecosystem" dependency management model instead of strict Semver use is that package names are global. So if you had two dependencies that used incompatible versions of, say, `cl-ppcre` you'd be out of luck; you can only get one version of it in your program. 
I generally think libraries that try to fix CL by presenting a new base package are actively harmful. Primarily this is because if a beginner starts with such a package, they will not learn the standard CL interface, and thus won't be able to easily comprehend the code of other libraries in the ecosystem. This also goes the reverse way, as it renders libraries written against these replacements incomprehensible to everyone else, not to mention potentially unsuitable for extension without also using this replacement in the process. They are thus a "everyone or no one" solution, for which the outcome should already be clear from the beginning: it's going to be no one. What I advocate instead is the usage of utility packages like alexandria, or dedicated systems like split-sequence, cl-ppcre, and so forth. These are fine to use, because their primary purpose isn't to redesign CL, but instead just to present you with helper functions and macros that already follow the generally accepted way of writing programs. They thus don't massively increase the gap between your code, and code anyone else would write. Now, if you don't care at all about putting your code out for anyone else to see, then of course you can just go ahead and do whatever you want, even if I don't think it's a great idea.
None, I think. It's very easy to invent a new Lisp on top of Common Lisp since the language makes it fairly trivial to do so, but the line between "you're writing Common Lisp with libraries FOO, BAR, BAZ" and "you're writing a Common Lisp-like language" is thin and diluted. It is going to mean if you're going to ask anybody else to work on that code together. https://www.reddit.com/r/lisp/comments/6snw5d/questions_for_2017_common_lisp_experts/dlfi78d/ has a very good case against CL21 - I'd advise to read it..
&gt; https://www.reddit.com/r/lisp/comments/6snw5d/questions_for_2017_common_lisp_experts/dlf7hqf/ has a very good case against CL21 Were you meant to link to this post? https://www.reddit.com/r/lisp/comments/6snw5d/questions_for_2017_common_lisp_experts/dlfi78d/ But yeah, it's best to avoid "sugared" libraries that tried to radically redesign the language. Not only this will ensure that other people can read and understand your programs/libraries, but it will also future-proof your programs as well. 
Yes - sorry, that's the correct one.
It works perfectly if you save the tree. The only problem is the inefficiency of COPY-TREE beforehand. Besides, it's actually interesting (and works on dotted lists) and CLHS already provides an example of a reasonable implementation of subst.
I'm not that great at CL and I don't fully understand cl-flow, but does this solve the problem mentioned here about [cl-async](https://orthecreedence.github.io/cl-async/2012/11/07/missing-coroutines-in-common-lisp.html)?
There's also cl-ana, which provides a wrapper around 2d plotting in gnuplot.
It may be less straightforward to search for CL solutions. In regards to that sample search you mentioned, I found this: https://github.com/tshatrov/ugoira
I went on that pixl site. I don't think they have anime episodes. It looks like a place for people to share anime drawings. I would have been surprised if you found something honestly. However, it's not that finding common lisp solutions is merely "less straightforward". Rather, it's actually kind of stupid that I can type "how do i [anythng] in python" and get a result, even on something so specific as "how do I [download one piece automatically] in python". That's tremendously impressive and I would never expect lisp to be able to mach this. This is an example where the raw number of people using the language directly affects how easy it is to get something done. To illustrate my point further, what if we searched a little bit smarter. We started on github and searched for kissanime, a popular site for watching anime. Take a look at the "Languages" box on the right. https://github.com/search?utf8=%E2%9C%93&amp;q=kissanime&amp;type= The number is the number of repositories in that language: 46 JavaScript 43 Python 11 Java 5 CSS 3 HTML 2 C 2 C# 2 PHP 2 Shell 1 CoffeeScript Searching for "lisp anime" yields 0 search results: https://github.com/search?utf8=%E2%9C%93&amp;q=lisp+anime&amp;type= Searching for "python anime" yields 98 search results: https://github.com/search?utf8=%E2%9C%93&amp;q=python+anime&amp;type= Python vs Lisp is not even a matter of 100 libraries to 1. It's a matter of 100 libraries to nothing at all. 
my point is not that it works or does not work. but for it to work you are dependent on how subst-if is implemented. for example, an implementation could easily and inefficiently avoid any side effects of calling predicate. (funcall predicate (if (consp arg) (copy-tree arg) arg))
That would be an incredibly stupid way to implement it. And wouldn't even be conforming.
Hmm, this link seems to predate Andrew's [blackbird](https://github.com/orthecreedence/blackbird) library. I guess, he then settled with promise approach (what `blackbird` essentially is) to asynchronous execution. `cl-flow` solves similar problem, but using a bit different approach. But, generally speaking, yes, `cl-flow` tries to solve the problem mentioned in the article.
I don't use it regularly, but rutils is the first one that I have found to be tasteful. It has a total of 5 reader macros, and the library is mostly a collection of libraries that are at least somewhat popular. In particular I have used `#{` for hash-table literals in the past independently of rutils; I think that hash-tables are under-used in CL due to the lack of a literal format [edit] rutils does have things that I find odd and unecessary though. For example, the "pair" structure; lisp has a perfectly good pair structure already named "cons' cl21 feels more like trying to write an sexpr version of ruby on top of common lisp, which isn't really my thing.
I havent heard of any language which can load two versions of a library in the same process. [Rubygem doesn't seem to](https://stackoverflow.com/questions/4333645/use-2-versions-of-gem-at-same-time); I believe python doesn't either. What is possible in ruby/python is to store multiple versions of a library in a large repository and let different processes use different versions of the library. Ruby has `bundle`, which is separated from `gem`; python has `virtualenv`; CL achieves this by `qlot`. Instead, I suspect the reason of the current state is the loose coupling between (asdf system) versions and packages. Packages do not have versions. If they coordinated tightly, then it might be possible to, say, rename-package the said package with a temporary name (which may contain Semver) and relink the package reference online. I think this would result in an overcomplication.
&gt; more strictly OOP or more strictly functional..more strictly anything really this is gold.
Syntactic sugar causes cancer of the semicolon. --Alan Perlis
If nothing needs to be fetched, `ql:quickload` is just identical to `asdf:load-system`. So, **always use ql:quickload.**
There are many open source projects hosted on bitbucket using mercurial. non-git does not mean closed-source. non-github does not mean closed-source.
Thanks ... that was quite an interesting thread!
So if I use cl-flow for my http library, I can hide the fact that it depends on cl-flow from higher dependencies? So this bypasses the issue he mentioned: &gt; So every library that depends on blocking behavior will have to be rewritten to pass any futher processing it needs to do after what used to be the blocking call into a callback.
check https://github.com/fukamachi/qlot edit: too quick there. Saw it was allready mentioned.
&gt; I havent heard of any language which can load two versions of a library in the same process. JavaScript and Rust are two examples I'm familiar with. 
I'm not sure what you are trying to solve. I'm also struggling to understand what exactly Andrew meant there. You definitely can build a facade around cl-flow to avoid exposing its features to dependent libraries. But it seems like `cl-async` will actually work for your case better, because not only it has an abstraction for asynchronous execution (promises via blackbird), it also provides async routines to networking (via bindings to `libuv`).
maybe stupid but it it would be conforming.
It wouldn't, it's supposed to work on tree elements, which includes conses, and they have to be comparable using EQ.
The thing that is jarring for me is that library dependencies (system, I guess, not package) versions are basically invisible. If I look at a repo that hasn't been updated in a year, or even a few months, I worry that its dependencies may have diverged because of breaking changes in something it depends on. I worry that I’ll be the first person to try it with this month’s Quicklisp vintage, and this makes me reluctant to depend on it. In theory, the idea of a set of Quicklisp packages that are known to work together sounds good, but in practice, this only works if every system is tested with every Quicklisp vintage. In practice, I'm sure commercial projects snapshot (fork) libraries they depend on into their own source control anyway, and carefully test new versions. But for open source development, the lack of something like npm’s package.json.lock, or more relatedly, Clojure’s leinengen project.clj, creates a lack of confidence in the reliability of systems that don't explicitly declare version dependencies. This is ironic because long-lived systems that are infrequently updated may be the most stable -- but only if they are exhaustively tested with every Quicklisp vintage. And as a newcomer, I’ve been frustrated by how invisible this quality assurance is. I always feel I'm the first to try this particular library in 2017. I guess this is what qlot hopes to achieve, but I haven't seen it used anywhere. Do any of the popular libraries that people depend on use it? Also, by the way, a complete aside: &gt; I havent heard of any language which can load two versions of a library in the same process. This is how Erlang’s hot code swapping works. The runtime actually does run exactly two versions of every module, old and new. Each “process” (like a green thread, there could be millions), decides when to update itself to the new version of its code through a well defined interface, which may have to run complex transformations on its own data structures to make them compatible with the new version. This is how they achieve legendary uptime. 
Respectfully, how are people supposed to find these projects if they don't already know about them? The programmer's best friends today are Google Search and GitHub code search, aren't they? Putting aside the economic and social reasons to be wary of market dominance, their utility and usefulness as research and learning tools are unmatched. One thing I've learned in my short exploration of Common Lisp thus far is that Google Search is not our friend. I think that means the Page Rank algorithm is working against us. I think *that* means there aren't enough people in the community generating new "content" about Common Lisp in places search engines can find, whether it's code or blog posts. There's another subthread on this thread that highlights the lack of "how to do X in Common Lisp" search results that really help non-experts get going on their learning and productivity journey.
I'm looking for a way to do non-blocking IO (usually networking IO) while hiding the implementation details (I don't want to convert all my code into CPS like Andrew mentioned). I'm just hoping I can use your library instead of a wrapper for libuv. I wish more people were congratulating you! This seems like a library that CL has needed for a while.
The documentation looks very nice, thank you for the effort for that. Another library you didn't mention is [lparallel](https://github.com/lmj/lparallel), which looks like a very good collection of concurrency tools.
I see, but unfortunately, `cl-flow` won't be able help you then. `cl-flow` is like a `blackbird` - it provides an abstraction for asynchronous execution. `cl-async`, on the other hand, is an inclusive solution for a cross-platform async task handling, including IO. Actually, I'm using [wrapper](https://github.com/borodust/bodge-async) around `libuv` myself (custom one though, not `cl-async`) for a [game engine](https://github.com/borodust/cl-bodge/) networking.
In principle, because I haven't directly explored cl21 or rutils, isn't there some benefit to libraries that presents opinionated approach to developing in Common Lisp? I'm thinking in particular to what happened in the JavaScript world after Crockford's "JavaScript, the good parts." Afterwards, numerous competing frameworks were developed to help programmers avoid the bad parts and take advantage of the good parts. There must be parts of Common Lisp that after decades of production use people have found harmful to creating maintainable systems, and teaching new programmers to avoid those parts would seem to be useful. Using global state everywhere would (for me) be one of those parts that leads to difficult-to-maintain and -extend code. A collection of libraries known to avoid those parts would also seem to be useful. This would of course fragment the community, but the good frameworks would attract adherents, and the bad ones would improve or go away, again, as in the JavaScript world.
This is the first thing I saw when I searched Google for "emacs slime vs code," wondering if anyone was working on a SLIME connection to Microsoft's excellent open source VS Code editor. This security vulnerability seems bad, no? There is an earlier thread on this but the issue is still open, and sounds more serious than the comments on this thread: https://www.reddit.com/r/Common_Lisp/comments/56zefw/slime_is_extremely_insecure_and_easily_allows/
In practice, Common Lisp is big enough that perhaps the easiest way to discourage people from using the bad parts is just not to mention them. E.g.: `prog`, `boole`, `gentemp`, logical pathnames.
Thank you! Yes, my bad. At the time, I've looked into `lparallel` too. It even has computation trees (`ptree`s)! But those are not as powerful as `cl-flow` ones ;)
Yes, they can (with respect to some conditions that aren't that restrictive). Kudos to cwebber for mentionning DNS rebinding, it's a really cool attack that's little known but very powerful if done right. For those that don't know it, it's meant to bypass the browser's Same Origin Policy that lets a website access only the resources of its own dowain by dynamically rebinding the DNS. It goes as follow: * Alice visits kitty.com (IP: 1.2.3.4) which is maintained by Mallory. * Mallory is evil and knows of slime's issues, so he set up his website to run a bunch of actions when a new visitor kicks in: * Mallory's server noticed a new visitor, its javascript 1) gets http://kitty.com/new_visitor 2) sets a short timer of a few seconds 3) gets http://kitty.com:slime_port/whatever_triggers_slime_code_execution * The first call to http://kitty.com/new_visitor tells the server to change the DNS record for kitty.com from 1.2.3.4 to 127.0.0.1 (localhost). * Once the timer goes off the second call to kitty.com actually resolves as being local so you get to exploit your slime vulnerability (which may actually not be HTTP but as long as it's TCP it's surely playable). * After some time the DNS for kitty.com is put back to 1.2.3.4 in order to get more victims in the net. All this doesn't have to be done through a website, but it's an effective method.
Quicklisp provides more assurance than you might expect. The criterion for inclusion, and maintenance, of a project in Quicklisp is that the project successfully load in SBCL alongside all the libraries in that Quicklisp distribution, and load without any errors or warnings. SBCL has extensive type inference and can catch and warn about many potential issues at compile time. And because of the pervasive use of macros in CL, successfully loading a library usually exercises a lot of code paths in its dependencies. To a surprising extent, "if it loads, it runs." Qlot isn't something a library would use. You use it to set up the dependencies for an application. My approach (with [TBRSS](https://tbrss.com)) is this. Obviously, every time I upgrade to a new Quicklisp dist, I run a test suite to make sure everything is working together. On the rare occasion there's a problem, I either pin the offending library to an older version (with Qlot) or I fork it and fix it, again using Qlot to pull from the fork until the fix makes it into the next Quicklisp dist. And of course I also use Qlot for dependencies that are not, for whatever reason, available in Quicklisp.
&gt; There must be parts of Common Lisp that after decades of production use people have found harmful to creating maintainable systems, and teaching new programmers to avoid those parts would seem to be useful. Must there be? I don't recall any other language being so influenced by its own equivalent of *JavaScript, the good parts*. I think this is just a quirk of JavaScript, along with the framework-itis it's developed. I'm not saying there's not stuff in CL that you're better off not using, or that there aren't better ways to do various things, but I would say that CL's problems and JavaScript's problems are not the same, so it's a mistake to expect the solutions to look the same.
thank you for the Erlang info. sounds neat. AFAIK Each Quicklisp library is tested every months even though there is no update in the library itself, in order to check the problems caused by the change in the libraries it depends on. Since Quicklisp also loads the system for testing (e.g. unit test), it not just loads but is also tested, I believe.
http://quickdocs.org/
The idea with pair structure is to get rid of using "." as a literal construct, which is a nasty legacy. Also, pair (just like first and rest) is more accessible to newcomers.
As for rutils, unlike cl21, it doesn't aim to "present a new base package" instead of CL: its stated goal is total backward compatibility, so nothing in CL is altered, and it can be used alongside CL (although there's, surely, an intention to provide a more accessible alternative to some of the stuff in CL).
Does the choice of port matter, or can the site just keep scanning ports indefinitely?
Python is basically one implementation and its documentation: Python 2.7.3. Its competitor is the same implementation in version 3.6.2. Other implementations just follow these mostly. Lisp is a diverse family of languages. Common Lisp is a Lisp dialect forming another family of more then 10 different implementations with a common standard from 1994 and lots of non-standard extensions to that. There is no lead implementation. This makes a huge difference in usability. 
Yes and No: SOP itself takes the port in account, but in practice that point isn't much of an issue. Actually doing the first call to execute code is possible without DNS rebinding, just by using an iframe and a form's POST for example, but if you want to retrieve data you'll never be able to send them to your server without XHR, and SOP is very restrictive on XHR, which is why you need DNS rebinding. Check out [that case](http://benmmurphy.github.io/blog/2016/07/11/rails-webconsole-dns-rebinding/) in Rails Webconsole, I found it well written.
Sorry, but why is this book so important?
For local slime sessions, I don't see an issue. When slime launches a process it connects to a random port almost immediately, and no new connections are accepted. So it's all theoretical. Now, for remote sessions using an ssh tunnel the window when it's still listening is larger, but domain sockets won't help there. EDIT: and if you want to reduce the local issue from theoretical to impossible, create ~/.slime-secret with a password in it. EDIT2: and .slime-secret can be used with remote connections as well (has to be present on both hosts)
If this is an exploitable attack vector, it would render literally several computers vulnerable. ;-) Unless you have made enough enemies to be targeted by an advanced, persistent threat, I doubt anybody would bother to write malware to exploit SLIME.
So, long story short - Sandbox your browser, especially if you have JavaScript enabled. 
Thanks for the tip, ~/.slime-secret just became a part of my dotfiles!
Thank you for your great job :).
It's non destructive and has clear spaces for the controller and modifier functions. At very little cost to run time and with decent clarity? And with the option to make it destructive if needed? It felt to me an easier to work with version of subst-if. Could argue that having both in one lambda is simpler, but I prefer the separation personally.
That is a shocking attitude to security to have in 2017.
Yeah. I mean it obviously needs sorting out ASAP, but I doubt anyone is going to use this exploit in anger anytime soon.
Your function does not mirror subst, it only performs substitions for atoms and not for conses. It always copies the tree even if there are no modifications. It crashes on dotted lists. It's ok as a solution to an exercise, but nothing to brag about on Reddit...
Looks great! Congrats on the library and also the gorgeous documentation site. More projects need to take documentation seriously. This looks like a really cool approach to parallel programming. Also, I'm excited to see what comes of the game engine. I started a toy one ([ghostie](https://github.com/orthecreedence/ghostie)) in CL a while back when I was working on a project with a friend of mine, but as with 90% of my projects, it's now slowly decaying on github =].
Unfortunately, there's no way to have async IO *and* maintain your call stack in Common Lisp. You can do [something like this](https://github.com/orthecreedence/pretend-event-loop) (basically a thread pool that mimics async) but if you go full-async, you'll either have CPS or you'll need to rely on promises. It's definitely a tradeoff. Another solution is to have an async thread that just deals with network IO and you can block your main thread waiting on responses from that thread...in other words, just move the problem to another thread and not "pollute" your main thread with an event loop. Cl-async's [threading/notifier](https://orthecreedence.github.io/cl-async/threading) support could help here.
Using promises makes sense for async networking IO. Maybe something like this in cl-flow. (run-flow (&gt;&gt; (~&gt; (-&gt; :default () (drakma:http-request "http://google.com"))) (-&gt; :d (args) (sleep 5) ;; Callback here (format *output* "~A" args))))
Author of the ugoira library mentioned above here. When I need to do something extremely specific, I just go ahead and write it. There are definitely enough "building blocks" in CL that you can combine to achieve any reasonably simple task. By the way, the functionality you're asking for is probably illegal in [your jurisdiction](https://en.wikipedia.org/wiki/Berne_Convention), so I wouldn't expect anyone to share the relevant source code.
This has nothing to do with Lisp.
Have I understood it correctly that invariants could be any sort of object, it's just that the simple-dispatcher wants them to be EQ if they're to be considered the same?
Yes, exactly. I'll describe how dispatching actually works in Advanced section of the manual. To spoiler some things, invariant is just an argument to the dispatcher, and more than this, you can pass keyword args to the dispatcher alongside an invariant. Dispatcher then decides where and how to run the atomic block. Dispatcher itself is just a function - you can find the variant of it in `simple-flow-dispatcher` [here](https://github.com/borodust/simple-flow-dispatcher/blob/11edd0115bbb7a6abe7ee4d0dbaedc0aef434e72/dispatcher.lisp#L101)
I just re-wrote s-f-d to be priority-based instead (thanks CL-HEAP for the priority queue!) wanting the following syntax: (run-flow (flow:atomically (:default 0) () (print "Hello, flowing World!" *output*))) But it seems like lists for arguments are meant to act as a &amp;key in lambda-lists.
It might look like this: (defun http-flow (url) (-&gt; :default () (drakma:http-request url))) (run-flow (&gt;&gt; (http-flow "http://google.com") (-&gt; :response-processing (response) (format *output* "~A" response)))) There's little reason to do so this way though, because it would be easier to just call #'format directly after #'drakma:http-request call. Things getting more interesting, when you need to do smth alongside the http call, like this: (run-flow (&gt;&gt; (~&gt; (http-flow "http://google.com") (-&gt; :d () ; some other work here ; parallel to http request (sleep 1) "Result")) (-&gt; :response-processing ((http-response work-result)) (format *output* "~A:~% ~A" work-result http-response)))) 
Right, so it should look like this: (run-flow (flow:atomically (:default :priority 0) () (print "Hello, flowing World!" *output*)))
Well, as a side note, pool used in `s-f-d` does actually support priorities (5 predefined), so one would need to update dispatcher to relay additional argument into `#'mt:push-to-pool` :)
Aha, I changed POP-TASK to dequeue the one with the largest priority :). How would I get the :priority option?
You can swap a couple of `s-f-d` functions [with these](https://gist.github.com/borodust/b61d97c8e9e07c46a403d5d11c35140a) to get a prioritised dispatching 
You need to add a keyword argument to a dispatcher like in this example at [this](https://gist.github.com/borodust/b61d97c8e9e07c46a403d5d11c35140a#file-dispatcher-lisp-L30) line to obtain a priority argument of the atomic block 
If you could tell me your **android version** / device (**tablet** or **phone**), you would do a great favour to all of us, thanks!
Aha, nice!
GitHub Gist mirror for readability: https://gist.github.com/phoe/d93f968f22bbcc87070cdc5831762021
Is this a joke?
What do you think is a joke?
&gt; Is there an alternative non-curated registry? Yeah they could be easily created. As Hexstream noted there are other dists, but only small ones and not alternatives to Quicklisp's one. Few years ago I created such a dist for my projects: * [cl-2dsyntax](http://cliki.net/cl-2dsyntax) * [cl-rttemplate](http://cliki.net/cl-rttemplate) Mostly I did it, because I didn't know back then how time consuming the process for a project to get into Quicklisp's dist was. I remember finding out what are the correct checksums was a bit of hassle, but overall it was quite easy. 
It's like you didn't even read my posts.
Why is this tagged by Norton as dangerous website?
phoe's answer to the question "Why hasn’t the open source community standardized on a single implementation, i.e. SBCL?" contains something that was meant to be formatted as a bulleted list. It's fairly unreadable in its current form. EDIT: seems like all lists got mangled, check out /u/flaming_bird's Gist instead.
Fixed, thank you. Teknik's MD engine does not properly parse lists if they appear right after a text paragraph, without a newline in between.
False alarm. Can you send a mail their way asking to unblock it?
Thank you for doing this! I greatly appreciate the time everyone has taken to answer, and that you've taken to organize it all.
Thanks as well! I opened a Github issue on your webpage that you might want to look at and close afterwards.q
Thank you! (Now I have to figure out why I didn't get that notification on Github.)
https://github.com/anticrisis/anticrisis.github.io/issues/1 No idea.
Actually - I notified the owner's website. Both of the identified "threads" were 404 anyway.
Chrome tells me that the certificate is invalid, but I can't seem to get more details from chrome.
Awesome. Nice work.
My own chrome works nicely here and does not complain.
Missing [2015] in title.
Just to say that for one I am very happy that such projects exist and that I'm a happy user of cl21 \o/ I'm a mere CL beginner though, who have not coded enough to love the CL horrors, but god I appreciate the shorter lambdas, the hash-table reader macro and more generics. (I didn't know about rutils until recently) 
&gt; it renders libraries written against these replacements incomprehensible to everyone else mmh would be such a problem really ? The most difficult stuff one has to learn is the shorter lambdas: `(map ^(+ 1 %) '(1 2))`, and you already can guess what it means, specially with experience from other languages. Then you have `#H` for hash-tables, string interpolation and inline regexps (`#/regexp/`) **if you use the module**, and again it's just like in sed or other languages. &gt; unsuitable for extension without also using this replacement in the process. They are thus a "everyone or no one" solution I don't get what you mean here but again, I'm skeptical with the conclusion. One can `use` cl21 in a package or not, so we can mix its use in a library. We can also directly call a cl symbol (`cl:…`) in doubt. Also it looks to me (allright, I'm far from being as experienced as you in CL) that using modern stuff like `map`, the hash-table literal and more generics is very welcome: for our sanity, for newcommers, for the language to be less a dinosaur than it is.
hi, I love the initiative of rutils, but I only learned about it a few days ago, despite my presence on reddit and googling for many months :( Maybe you could post rutils news once in a while around here ? Cheers !
edit: I had first in mind the totally undocumented osicat-posix (https://github.com/osicat/osicat/issues/20)
Wow, really nicely presented. I had no burning CL questions but I read everything and learned a lot about why things steer the way they are! Thank you, whoever put this together. 
Favorite answer to the "modernizing CL" question: &gt; "I'm writing GPU code in lisp, and that feels kind of modern" -Baggers Yes, it does! Where can I see an example of CL for GPU?
both of those could be solved without a new structure, right?
.slime-secret appears to be another attack vector, however :-/ https://github.com/slime/slime/issues/302
https://www.youtube.com/channel/UCMV8p6Lb-bd6UZtTc_QD4zA
'Kind of' is key here, I'm not doing anything that others haven't been doing for *many* years. Even in cl I'm predated by tonnes of excellent people on whos work we rely (e.g. 3b, Ryan Pavlic, etc)
6pm UTC happens when this comment is 9 hours and 48 minutes old. You can find the live countdown here: https://countle.com/34358LOwS --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Your function does also always copy the tree. Even it crashes on dotted lists, it satisfies his needs. Bragging about this is one thing, but scaring away people from posting code that can be discussed is worse. If he would not have done that, I would not learn about your modify-in-predicate hack. I will also check if https://google.github.io/styleguide/lispguide.xml says anything about that style of coding. 
They are quite different things. Think of quicklisp as package manager and repository of Lisp libraries and Useful Stuff. Roswell is for easily installing Lisps and providing utilities for working with Lisps and Lisp programs from a shell environment (among other things). Roswell uses Quicklisp 'out of the box' as it were in the sense it is installed and present when you install a Lisp via Roswell. Therefore the combination of the two would be the Lisp equivalent of Haskell's stack where Roswell is providing the mechanisms to install isolated lisps, run/test lisp programs, etc and Quicklisp is installing the packages your lisp program is using.
I see your point. Thanks. So Roswell would be more like stack and Quicklisp would be more like Cabal. If I understood correctly. cheers 
Actually Cabal's equivalent in the lisp world would be ASDF since that is what defines and implements the metadata and mechanisms that make up a lisp 'package' (system in Lisp terminology). Quicklisp itself is built on top of ASDF. My assertion that 'Roswell + Quicklisp' ~= 'stack' is due to Quicklisp handling the 'build' and dependency management via (ql:quickload) much like how stack will pull down dependencies and build them if they are not present. The problem Quicklisp solved is twofold: provide a centralized place for curated Lisp systems, and, remove the pain of working directly with ASDF.
Tangentially, for some quick scaffolding of a typical CL project you can use quickproject which is by the creator of quicklisp. https://www.xach.com/lisp/quickproject/
Stack features (https://docs.haskellstack.org/en/stable/README/) and lisp equivalents (in my opinion): - Installing GHC automatically, in an isolated location =&gt; "apt install sbcl" or Roswell, not sure for the isolated location. - Installing packages needed for your project. =&gt; Quicklisp. For an isolated location, [Qlot](https://github.com/fukamachi/qlot) - Building your project. =&gt; that's done with ASDF - Testing your project. =&gt; a command with ASDF, given you declare the test command in the .asd file (see quickproject or [cl-project](https://github.com/fukamachi/cl-project)) - Benchmarking your project. =&gt; ?
Quicklisp handles installing to isolated locations just fine; Qlot is perhaps more full-featured there and allows pinning of individual library versions (quicklisp only lets you pin to a particular set of versions)
There is another BYTE Lisp Issue: Feb 1988. Also BYTE April 1985, AI, has Lisp articles: https://archive.org/details/byte-magazine-1985-04-rescan 
When I come across magazines from the past such as this, I keep wondering why and when did we stop writing such beautifully crafted technical articles for the masses and instead turned to advertisement-like pieces on consumer electronics. Look how empowering those articles were by treating you as a creative being, and how passivizing the current articles are in encouraging perpetual consumption.
Because society as a whole colapsed to crackhead caveman level.
Every interpreter is technically a virtual machine. Every operating system is technically a virtual machine. Java at least actually called it "Java Virtual Machine".
Another classic is the [Byte Smalltalk issue](https://archive.org/details/byte-magazine-1981-08).
First of all, the term "virtual machine" is quite vague. Even C can be said to implement a virtual machine (the term used by the C language specification IIRC is "abstract machine"), since it defines certain semantics that may or may not be true of the underlying hardware. SBCL is not a "virtual machine" in the sense that java uses it: unlike Java, the programs are directly compiled ahead of time to native code. Secondly, to correct one assumption, you can make lisp programs without the entire language packaged within. One way of doing this is by using something called a "tree shaker" that removes all parts of the language that aren't used before saving the image. Another point is that SBCL doesn't use a bytecode compiler at all. (Until about 10 years ago, it didn't even have an interpreter, but one was added as a performance optimization for evaluating very small forms). When you evaluate a DEFUN in sbcl, it will compile down to native assembly. There is a runtime library for handling things like memory allocation, threading, and garbage collection. C likewise has runtime libraries for the first two, and the third is not part of the language.
Made things clear to me, thanks!
More of an image based system, like smalltalk.
Which Smalltalk got from Lisp, since Lisp uses image-based systems since the early 60s and some people like L Peter Deutsch, who had implemented image-based Lisps in the mid 60s, moved to Xerox PARC and implemented image-based Smalltalk. Even the original Lisp from McCarthy had images. https://en.wikipedia.org/wiki/L_Peter_Deutsch http://www.codersatwork.com/l-peter-deutsch.html &gt; ...Deutsch moved to Xerox PARC, where he worked on the Interlisp system and on the Smalltalk virtual machine, helping to invent the technique of just-in-time compilation. 
**L Peter Deutsch** L Peter Deutsch or Peter Deutsch (born Laurence Peter Deutsch, August 7, 1946 in Boston, Massachusetts) is the founder of Aladdin Enterprises and creator of Ghostscript, a free software PostScript and PDF interpreter. Deutsch's other work includes the definitive Smalltalk implementation that, among other innovations, inspired Java just-in-time compilation technology 15-or-so years later. He also wrote the PDP-1 Lisp 1.5 implementation, Basic PDP-1 LISP, "while still in short pants" and finished it in 1963, when he was 17 years old. He is also the author of several Request for Comments (RFCs), The Eight Fallacies of Distributed Computing, and originated the Deutsch limit adage about visual programming languages. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I would use the term 'Virtual Machine' only for a software system which emulates some kind of CPU (existing or not) with some instruction set. Since SBCL does not use any byte-code or similar, it's not a virtual machine and doesn't provide one. When SBCL was forked from CMUCL, the byte-code machine and the byte-code compiler backend were removed. Common Lisp implementations with virtual machines are for example CLISP (also has an interpreter), CMUCL (also has an interpreter and native code compiler) and ABCL (uses the Java VM).
BYTE got its start when personal computing was a small niche hobby. Its readership was hobbyists who wanted to learn all they could about their amazing new machines that hardly anyone knew much about. By the latter half of the 1980s, many more people had personal computers and a large and growing fraction of them used them for fairly ordinary everyday tasks like managing business records and personal finance and so on. That led to a growing market for periodicals that treated them less as fascinating, whizzy new technology and more as products to be compared on the basis of whether this one or that one was a better buy. Around the same time that I went to work for Apple, Gregg Williams, one of BYTE's editors, left the magazine and went to work at Apple. We shared a lot of interests--if I remember right, Gregg organized and edited the Lisp issue--and we became friends. Gregg said that BYTE was under real pressure from competing magazines like PC World and PC Magazine, which were less about fascinating technical subjects related to computing and more about who was selling the best and most attractive products. The pressure became sufficiently severe that BYTE's publisher reluctantly concluded that its best shot at surviving was to make itself over into that kind of magazine, which it gradually did. Not being interested in that kind of magazine is what drove Gregg to leave and look for other kinds of work. In short, the focus of the periodicals followed the focus of the people buying them. Eventually there were a lot of people who wanted to buy magazines about computers-as-products and not so many that wanted to buy magazines about computers-as-windows-into-science-and-technology. 
sbcl is not an interpreter: it's a compiler and runtime environment. Operating systems are typically not virtual machines, as they merely schedule, manage, and service native code execution, not interpreting or jit compiling bytecode at runtime.
That's a classic! I bough all the 1981 issues on eBay. My wife freaked out when she saw putting them on display in the living room: "But it's HISTORY, honey!" Down they went, to my nerd's cave along with my TurboPascal box. Non-nerds are a tough crowd...
I used to stand in the UQ engineering library reading all the Byte back issues in 1982. Another UK magazine Soft, turned me into the new generation of functional programming languages with an article on Hope.
More interesting qlot's feature is installation libraries from git repositories. 
Soft got me into programming, where I remain. Fantastic magazine but very short lived.
&gt; There is another BYTE Lisp Issue: Feb 1988. I wonder if anybody has this scanned somewhere (I did found an [ebay link](http://www.ebay.com/itm/BYTE-Magazine-February-1988-Vol-13-No-2-14-Multiscan-Monitors-Lisp-/332327861143) ... )
Can you say why it's considered a classic? I also saw these language based issues, do you know if any of these are good: * [Byte Magazine Volume 11 Number 08: Object-Oriented Languages](https://archive.org/details/byte-magazine-1986-08) * [Byte Magazine Volume 05 Number 08 - The Forth Language](https://archive.org/details/byte-magazine-1980-08) * [Byte Magazine Volume 08 Number 08 - The C Language](https://archive.org/details/byte-magazine-1983-08) * [Byte Magazine Volume 03 Number 08 - Pascal](https://archive.org/details/byte-magazine-1978-08) * [Byte Magazine Volume 12 Number 09: Prolog and 386 Hardware Software](https://archive.org/details/byte-magazine-1987-08) * [Byte Magazine Volume 07 Number 08 - Logo](https://archive.org/details/byte-magazine-1982-08) * [Byte Magazine Volume 10 Number 08 - Declarative Languages](https://archive.org/details/byte-magazine-1985-08) 
Two projects you could look at, depending on your definition of data science, cl-Ana https://github.com/ghollisjr/cl-ana and clml https://github.com/mmaul/clml. Both are maintained and are worth review. Also have a look at Gabor Melis stuff https://github.com/melisgl Cheers
So you think Common Lisp is the dialect to go for? I ask because I find it difficult to evaluate which lisps have the best ecosystem for this sort of thing.
Never heard of scheme for data sci. Clojure is for the WEB stuff mainly. At least CL has those options and there are at least some people (not sure about numbers) working on it. BTW, there is also CL and R bridge. https://common-lisp.net/project/rcl/ 
As a language, Common Lisp is very well-suited for data science (I'd say, it's, actually, the best of the available options due to the highest level of interactivity and sound math/algorithm fundamentals). As an ecosystem, YMMV. Depends on what you need to accomplish. Data science is a very broad field: do you want to do basic data analysis, NLP, signal processing, anomaly detection, something else? PS. And also, it's worth understanding that there are no Lisp dialects - just a number of distinct languages. You wouldn't call C, C++ and Objective C C dialects. The same applies to Lisp
Sure, I'd do. Thanks
Well, they could, but I don't find the pair solution unlispy in any way - on the contrary, it uses the most regular Lisp mechanisms. And also, looking at my code that uses rutils heavily, I should say that pair is the single most used rutils feature for me :)
Yes. I only saw two issues, but that was Brisbane in the early eighties.
Hi, I don't know about the different lisps, but if you want good CL pointers, here are some successful machine learning stuff: http://eudoxia.me/article/common-lisp-sotu-2015#machine-learning 
Do you have any idea what the future of Lisp is at Grammarly since you left :-)?
You could try [Racket.](https://racket-lang.org) It seems that some people have had success in using Racket for this sort of thing. E.g., [here is an interesting Github repo](https://github.com/n3mo/data-science) that provides data science tooling for Racket. Also [here is an interesting blog post](https://khinsen.wordpress.com/2014/05/10/exploring-racket/) about using Racket for the somewhat related field of scientific computing. [Here's a wiki page about that as well.](https://github.com/racket/racket/wiki/Scientific-Computing) Disclaimer: take my word with a grain of salt as I am not a data scientist.
Perhaps [GSLL](https://common-lisp.net/project/gsll/) would be a good place to start.
Serapeum anyone? 
They continue using it quite happily
I have allowed myself to make a [duplicate](https://www.reddit.com/r/lisp/comments/2poh9q/incudine_a_musicdsp_programming_environment_for/) as the project is still kicking after 2+ years and the documentation mentioned in the comment of the original article seems somewhat good right now; I don't know what was the original complaint though.
Sorry for the delay in replying. I think the question is quite difficult to answer because I really don’t know your requirements. Mine are, largish but not huge datasets, considerable number crunching using BLAS/lapack and a fair amount poking around at the data. I find CL quite good at this and the combination of CL and Slime is hard to beat. What The CL ecosystem lacks is good visualization tools , though there is a plethora of gnuplot interfaces, and there is no commonly accepted infrastructure for data slinging, everyone seems to roll their own. You have to be prepared to do a fair amount of bit twiddling in CL vs python say, where there is almost always a library for whatever you need. The good news is often it’s quite easy to do, because CL is a such a pleasant programming environment, the downside is that it is a distraction from the real work that you might want to do. 
Thanks for the reply! I was purposefully vague about my needs as I'm actually a physicist who's in the process of moving into data science consulting in a startup. I'm on my first contract right now where if I do any stats or ML, they'll be bonus. The main deliverable is just an ETL pipeline and some reporting tools. However, as I gain experience and move on to bigger projects with companies who have a more mature data culture, I expect to be getting into more fancy stuff. In other words: I don't really know what my requirements will be in the near future but right now they're pretty minimal. I'm currently doing most of my work in Python and from what I've seen, it is likely just the best most robust tool for the job. However, I really am interested in Lisps and so maybe its best for me to just stick with Python at work and start playing with Lisp on the side. My biggest impediment though is that I keep deciding 'Okay, I'm going to use ______ lisp' and then I encounter something about it that is lacking and so I decide to switch to another but then find something that its me off that language. I've been playing pinball switching between Clojure, Racket, Hy and Common Lisp for the last week :( Thanks for the advice! It is starting to seem that Common Lisp is the way to go... Or maybe Scheme because I've wanted to read SICM since the day I heard about it...
This is useful spam ! Take care and see you next time! 
Hey good luck with the startup. An exciting time for sure. The advantage of python here is that everyone knows it and you won’t get the common parens pushback. The downside of python is performance. You need to get across numpy. Pypy and other things like dropping down into C to wring the performance you might need for even moderate datasets. With CL it’s often a matter of just doing a (declare (optimize 3) (safety 0) (speed 3)) around your critical sections and you are good to go. Might not happen in your first gig, but something to be aware of. For etl ish stuff have a look at the CSV libraries ( I use fare-csv) and data-format-validation, which I use for both csv and fix format files. 
https://www.reddit.com/r/lisp/comments/61kegi/why_i_havent_jumped_ship_from_common_lisp_to/ (discussion from a few months ago, the article got recently updated)
Sad to see Rideau jumped ship from Common Lisp. Hopefully this wouldn't impact the development of ASDF too much. A bit surprised (and excited as well) to see him switched to Gerbil Scheme. Guess I'll have another Scheme implementation to keep an eye on. **EDIT:** Care to explain the downvote? Is it wrong to discuss, like, and use both Common Lisp and Scheme? 
Scheme, because it is the language of *Structure and Interpretation of Computer Programs* by Abelson and Sussman.
I wouldn't say I got the famous epiphany, but I got a taste of it by realizing how easy it is to write your own DSL, and think about problems in your own little language. I'd say, just pick any Lisp and don't worry about the others. My favorite so far is SBCL.
Yep, I've definitely already run into Python performance problems already even though I'm pretty strict about never looping and using the faster cnstructs like map and numpy broadcasting. By the way, I really enjoy functional programming. Do you think CL has good support for such things or is it a mostly uphill battle?
It probably will affect ASDF's development. I think there's only him and another guy (sorry for not remembering his name) that actively develop it.
[Just watch this, it should do the trick](https://www.youtube.com/watch?v=aHk42kDwesM)
I'm deaf
[removed]
I don't watch the streams but I think what you're doing is really interesting. Spam away!
sbcl is an implementation, not a lisp ;)
&gt; It probably will affect ASDF's development That is very unfortunate. Incidentally, I just took a quick look at ASDF's source, and am surprised and impressed at how clear and well structured the code base is. Hopefully this will help attract new developers/maintainers. 
Oops, my bad. I'm new to Lisp, and it's very specific way of wording :p
Time for another ASDF maintainer/developer to appear.
If you like the Emacs editor elisp is a good starting point. It’s not the most elegant or fast Lisp but you get practical results after a very short time. And the documentation is pretty good, Emacs comes with the two manuals “An Introduction to Programming in Emacs Lisp” and “Emacs Lisp”. 
yep, just gotta remember to keep in mind the division between language definition and language implementation, I know in other languages there is usually one de-facto implementation, eg. python interpreter for python specification so this difference is not important, but in lisp it can have implications 
Right; don't let the L in its name fool you or anything.
Also racket.
Unlike clojure CL is not opinionated about that. I try to work in a functional style as much as possible and generally it’s pretty easy, but from time to time you need to mutate something directly and lisp lets you do that without complaint. 
I guess you could accuse /u/artillery129 for splitting hairs, but they are right though. SBCL is an implementation of Common Lisp. The topic is *which* type of LISP dialect to learn. Like Common Lisp, Scheme, Clojure, Emacs LISP, etc. Or maybe the thread poster asks about both implementation and LISP dialects, who knows.
Common Lisp, because I love it.
ASDF's source code is definitely my favourite example of good taste in the CL world :-). It's also an interesting project with a lot of potential so I'm sure it will find new developers.
Gerbil looks amazing!
Common Lisp has a good standard library and all the goodies like macros, symbol macros, reader macros, compiler macros and so on that showcase what lisp can do that other languages cannot. It also has a simple to understand macro system rather than the hygenic system that scheme has which can obscure the power of macros for beginners. However, you won't get the enlightenment by writing programs in the same way they are written in other languages. The enlightenment comes when you start writing programs in ways you can't with other languages.
Common Lisp. Because reasons.
# 🇸🇮🇨🇵 it will really blow your socks off. it's one of those things where it's man versus monoid and machine versus god. be there. [ℝ𝔸ℂ𝕂𝔼𝕋](https://racket-lang.org/) ＡＥＳＴＨＥＴＩＣＳ - [TEXT](http://sarabander.github.io/sicp/) - [SETUP](https://github.com/zv/SICP-guile) - [MORE](http://eli.thegreenplace.net/tag/sicp) - [LISP ENLIGHTENMENT SOUNDTRACK](https://www.youtube.com/watch?v=87FDctNdUOw&amp;list=RD87FDctNdUOw#t=128) 
Python if you want to live in infamy.
Scheme
I'd say Scheme because it was designed to simplify and streamline the language (or at least the basics). And that's part of the epiphany (...I guess it is; certainly the minimal syntax is what appeals to me, about the lisp family , and scheme in particular.) Within schemes, Racket is my own preferred version. [I know, racketeers characterize Racket as a language-for-building-languages, but it's still a Scheme to me.]
Good to hear. Sometimes the way people talk about CLs support for imperative and OOP makes it sound like it *doesnt* support functional programming. 
Agreed. Writing a scheme interpreter in scheme should be pretty eye opening.
Robert Goldman I believe is his name; his initials are definitely rpg. It will be interesting to see how it affects ASDF's development because the two of them had very different ideas for its direction, and I feel like their discussions were fruitful (if at times appearing tense to the outside observer) partly because of this. I always enjoyed seeing them argue two different sides, and since I agreed with both of them it pushed me to think about what was more important to me.
Emacs Lisp 1. You get one of the best IDEs for any language. Emacs is not a text editor, it is an Emacs Lisp IDE. 2. It's really easy to try out code without having to write full programs, figure out how to run/compile/package/namespace them, etc. 3. Emacs comes with a ton of libraries, and there are a ton of libraries available via the built in package manager. You don't have to futz about learning asdf/quicklisp or some other one of the many packaging systems for other Lisps. 4. Tons of libraries not only means code for you to reuse, but also tried and tested example code to look at. Having example code to reference is very useful. 5. Emacs documentation is wonderful. You can call up the documentation for each and every function and variable. You can jump to the source code for every function. You can jump to the source code for functions called by those functions, then jump back. 6. You aren't just learning a new language that you will then "throw away". Unless you get a job working with Lisp or actively want to write code in Lisp, you will likely never touch whatever Lisp you learned again because most Lisps aren't practical in the way that, e.g. Python or Perl or shell is where it is easy to find prebuilt libraries to glue together to build tools. I would use Python to write a tool to automate some part of my workflow. I would not use Common Lisp to write such a tool, except for the sole purpose of writing Common Lisp. (Note: You have opportunities to use Scheme in the sense that it is used as an embedded scripting language, e.g. for xbindkeys. But you will rarely write any standalone Scheme scripts for lack of libraries, unless again you just want to write Scheme.) Emacs Lisp however, is immediately applicable. You can immediately start writing useful commands to make you more productive both while continuing to learn Emacs Lisp and while using Emacs to edit programs in other languages. Bonus: You will also get the Emacs epiphany. Two epiphanies for the price of one!
A Lisp is as much language as an implementation. Different implementations provide variants of Common Lisp. There is not a single Common Lisp language, but a wide variety of Common Lisps with different ways to provide the core language and different language extensions. Core language: * does it use CLOS for conditions, streams, ... ? The standard does not require CLOS for that. * are type declarations used or ignored? Common Lisp as a standard allows both. * for what are type declarations used? The Common Lisp standard does say very little about it. How optimizations in the presence of type declarations work is totally undefined. The standard does say zero about type inference. The standard does say zero about type declarations as assertions. * is the CLOS system implemented with a full MOP ? The standard does not require anything like that There are more examples. Then there are extensions to the language that are typical and form a kind of extended Common Lisp: * modern character types with unicode * extensible CLOS-based streams * multi-threading integrated with the rest of the language * TCO, which enables a slightly different functional programming style * full use of the condition system, for example in the REPL with error REPLs * Garbage Collection: yes, the standard says nothing about Garbage Collection and there are different features (like allocation regions, finalizers, weak objects, ...). * there are parts of CLtL2, which made it not into Common Lisp, but which are provided in some form, like the extended environment information for macros There is also one specific feature of Common Lisps which was only late supported by SBCL: a Lisp interpreter. It is just there and not specially used. Some other implementations will make quite a bit more use of an interpreter, which can have advantages for things like interactive debugging. Depending on the chosen Common Lisp implementation, the actual language might feel quite a bit different. The package CL-USER then will typically be composed of the symbols provided by COMMON-LISP with various extensions form implementation specific packages. The extreme example: on a Symbolics Lisp Machine one could use several different dialects of Common Lisp (and other languages), which were provided side by side: an older version, a newer version which was oriented towards ANSI CL, and Symbolics Common Lisp (a very large variant of Common Lisp). One could specify which language one is currently using, in the REPL or in files. This would then influence how package names are interpreted and the read-table. You would use the package "COMMON LISP", but it would actually be a tailored package for the chosen variant of Common Lisp. This was used when Common Lisp was under development and one had dialects like CLtL1, CLtL1, and future ANSI CL. Also it is used to restrict oneself to a more portable Common Lisp, by not using all the special features of Symbolics Common Lisp. Thus SBCL means SBCL. ;-) An extended implemention of Common Lisp, which provides a much larger language than the standard describes and has a certain implementation characteristic. 
LISP isn't worth learning, I would go with Lisp.
If you go with CL, be sure to not miss some good resources: - http://lisp-lang.org/ - https://github.com/CodyReichert/awesome-cl - https://lispcookbook.github.io/cl-cookbook/ btw you can get started very easily with Portacle, a portable and multiplatform CL environment (Emacs, SBCL, Quicklisp, Slime &amp; Git installed): https://shinmera.github.io/portacle/
Clojure. Do yourself a favor and try a lisp that is actually evolving and that you can use to find a job and use in production. It has great tooling and Emacs (CIDER) integration. You can also run your code in JS environments such as browser and mobile. But be prepared for a steep learning curve.
Jumping ship from a niche programming language suffering from a lack of libraries and a fragmented ecosystem, to an even tinier niche programming language suffering from even fewer libraries and an even more fragmented ecosystem... what could possibly go wrong here? Common Lisps major problems are imho: 1. Too few high-quality, well-documented, actively maintained libraries. Users do not want to reinvent the wheel, just for the joy of reinventing it in Lisp. Instead of having to write library X first in order to be able to write app Y, people just write app Y in Python, because library X is already there and waiting to be used. 2. Too many competing implementations, unnecessary duplication of effort. Instead of writing libraries to fight problem 1, people rewrite stuff that has already been written. Over and over and over. And over and over and over. And then once more. Of all languages, Scheme is the prime example of a collosal waste of talent and effort reimplementing the language over and over again, and abandoning the implementations as soon as they find out that they cant do anything useful with them without libraries. Lisps problems can be fixed, and since the advent of Quicklisp, it has become quite obvious that all the necessary infrastructure is now there, the awareness of the two main problems is there, it is now just a matter of effort invested in a focused way. Seeing that a high-profile contributor has stopped contributing to the solution, and instead has decided to start contributing to the problem, is just sad.
Well, to be fair to Rideau, IIUC from reading his blog, his needs are so uniquely specific and experimental (i.e., Observability property), that modifying many existing Common Lisp/Scheme implementations to support it would be non-trivial (and would likely break the language's semantic), and that the primary reason for him switching to Gerbil Scheme is because Gerbil Scheme's architecture lends itself to implementing the features he needs for his work/research. And like /u/Aidenn0 said, there is another active contributor to ASDF, who is also quite active (as far as I can see just from checking the project's mailing list), that I don't think ASDF will be completely abandoned with Rideau stepping down. And besides, if this news results in an increased awareness for the need for more participants in the tools that are essential parts of the infrastructure of the language, then all the better. I think everyone would agree that for ASDF (or other parts of Common Lisp's infrastructure) to have a bus factor of 1 (or two for that matter) for so long is not a good thing.
I found racket was pretty fun to play around with.
Not exactly what you were asking, but [this did it for me](https://www.youtube.com/watch?v=dGVqrGmwOAw).
Common Lisp also has CLOS, which is a very different way of doing object-oriented programming than most people might be familiar with. If someone's doing a lot of OO programming, I like to point them at Smalltalk and CLOS; when you understand how those two object systems work you should have a good sense of how to take advantage of the OO paradigm in your chosen language.
[My response from a few years ago.](https://news.ycombinator.com/item?id=4765806)
you could make the same argument about any implementation of a language, especially ones with different features. Does GCC vs LLVM mean different dialects of C? They have slightly different behavior than ansi suggests, are they therefore different languages?
Using SBCL will give you a very different programming experience compared to CLISP or mocl. Both the provided language and its implementation are causing this. Common Lisp implementations are much more than a language implementation. Very important for the programming experience is HOW the language is implemented and how it behaves. A batch compiler may just let a program crash on error or might only provide non-interactive error handling. In an interactive system, I would expect lots of different condition types, handlers and restarts - allow me to inspect and repair the problem. 
I gave you an up vote, you've convinced me
clojure's immutable by default approach really changed how I think about things. the language is still fun to sit down to eight years of full time work later. 
Just want to add that in addition to all of the above, Common Lisp also has SLIME, which is hands down the best IDE (even when compared to IDE of other languages). Seriously, the experience of using SLIME alone converted many people to Common Lisp and makes it really hard to switch to other Lisp/Scheme dialects (or other programing languages for that matter). I even managed to make many of my colleagues drool with envy by showing many of its features. 
A Scheme compiler in Common Lisp is also giving insights: http://norvig.com/paip/README.html
Yes, agreed. It's OO done right IMO.
Anyone made any music with this they want to share? All I've been able to muster is "Ode to the sine wave".
Man, Norvig's PAIP is really underrated. It should be a required reading for every Common Lisp programmers, along with Seibel's Practical Common Lisp and Weitz's Common Lisp Recipes.
And emacs also has paredit-mode, which makes editing s-expressions such a joy. I wish for it a lot when I'm programming in other languages.
I can't speak for other dialects/languages. I've only used common lisp. The enlightenment started almost immediately and continues to this day.
Not unlike LSD... Reply inspired by your username.
This post is quite informative. Given this, do you favor an emphasis on developing "portable" libraries, or an emphasis on extending, let's say, SBCL-specific extensions? I realize this is a question of opinion and your answer might vary based on the context. Could you share your opinion in the context of extending Common Lisp's perceived usefulness to a wider array of problems *and* professional programmers?
How much of Clojure's commercial success do you attribute to its being run on the JVM, versus its functional programming emphasis, immutability, and concurrency tools?
Both.
Huh, I wasn't even aware that a function named GENTEMP existed. I also really don't think that collaboration is that hated in the CL community :-), we do see more and more collaboration, even in spaces usually very fragmented (see the game space, where dto is going to re-implement his core using WarWeasle's Clinch).
My major gripe with CL is probably its environments/modules/packages. Loading several versions at once, reverting side-effects on packages, etc. would be very nice to have. I hope that SICL will be able to provide an easier way forward to experimenting 'underneath' CL with interesting and practical extensions to the language.
Unfortunately, warweasle has left Common Lisp in favor of C++/Unreal some months ago, and CLinch is far from usable. He recommended all users of it to migrate to Baggers' CEPL.
Deficiencies of Racket (compared to CL): * No built-in multi-methods and lots of super-specialized functions (the same functions but for lists, vectors, hashmaps etc; to be fair CL is not ideal here either). * No introspection compared to one with SLIME. * Debugger... well, essentially absent if you have to compare with CL * Module re-loading removes everything in running image (in DrRacket, perhaps, you can do a bit better in Geiser). * Efficiency: [compare the speed of SBCL and Racket](http://benchmarksgame.alioth.debian.org/u64q/racket.html) * Support for OOP: nothing compared to CLOS. Racket has message passing style OOP, which is OK (Smalltalk does it too, for example), but the syntax is so verbose. And again, lack of introspection makes it impossible to work with. * Libraries: compared even to CL libraries maintained by enthusiasts, most of Racket libraries are half-baked: unfinished, failing to build, and lacking documentation (and at least in CL you have DOCUMENTATION, DESCRIBE and APOROPOS + introspection and good debugger to figure out what the library functions are doing). This list is not to degrade Racket completely, but just to point out that the transition CL -&gt; Racket is not changing for something better as there is a lot to like about Scheme-like languages, but rather a trade off. 
Most of these issues don't really matter to me for a relatively new language that can only get better. For example, Chez as the VM soon will help with the efficiency. What matters to me are the major issues outlined in the article. I have used Common Lisp for a decade, and only watched matters get worse over time.
Racket is not that new though. Just to mention, Clojure's introspection in CIDER is much better than that of Racket. And Clojure is much younger. So, I don't think these problems will be solved in Racket as it matures. Granted, this is my speculation. Also, benchmark games used Racket 6.10, which I believe is based on Chez VM (but I might have gotten it wrong). To be fair, I can see why one would want to move from CL: CL is ugly and hairy due to lack of evolution in the standard and trying to keep too much legacy. One cannot deny this. Quicklisp distribution is fragile as rightly put in the article. ASDF has its problems (a particular one is because of CL itself: just change a read-table in one of the packages and you don't get a reproducible build anymore). Yet, in my personal experience with Racket/Chicken/Gambit-C/Clojure/Julia, you would want to come back to CL.
I have been using Racket for 8 months along with CL. I find both very enjoyable. Racket is very new compared to a language such as Common Lisp that you are contrasting. I know all of the weaknesses and strengths of both languages. I am happy I made the choice that I did. Common Lisp has lots of problems that are not being solved.
About documentation: I'd love more projects to use CommonDoc / Codex: https://commondoc.github.io/docs/overview.html and https://commondoc.github.io/codex/ it's straightforward and beautiful. Out of curiosity, does cl21 fix some language flaws to you ?
Nearly everything about cl21 just rubs me the wrong way. Also, it is going on 2 years without any further progress. Most of my issues with Common Lisp are not even due to the language - but the users and ecosystem of the language. If you read the article, all of these issues can be changed without changing code :)
&gt; all of these issues can be changed without changing code :) you're right, but you also made an ellipsis: &gt; There are numerous other issues I have with Common Lisp too, but I tried to stay out of language details so I was targetting those hidden details ;)
They are mostly minor details that I didn't want to nitpick over. Stuff that primarily defines it as a language and you grow into. I also didn't mention really anything good about the language either, but there are. I am still using it, and for good reason. I have lots of code that took years of research to write wrt graphics programming, and SBCL as mentioned above is very performant at such a use-case. The article is not so much complaining about Common Lisp's problems as it is explaining why I do not think it wise to use it exclusively any longer. The right tool for the right job I guess. With all that said, I would very much so like those few issues mentioned in the article to be worked on, particularly the whole Quicklisp model and the NIH syndrome. Also, one major thing that I left out of the article because it doesn't apply to me, is the introspection and debugging of Common Lisp is only good with SLIME (or Sly), and that only really works well on Emacs (if you haven't bought a license for ACL/LW). Atom and Vim ports are severely lacking (I used Vim to code Common Lisp for 6 years before moving to Emacs)
Serious question: How does one only code in common lisp for 9 years and still put bread on the table?
I mostly code as a hobby, but even contract work I do has given me the choice of a language.
&gt; but just to point out that the transition CL -&gt; Racket is not changing for something better as there is a lot to like about Scheme-like languages, but rather a trade off. Couldn't have said it better myself. Saying or even implying that Racket is strictly better than Common Lisp, or vice versa, is doing a disservice to both languages. Both have different priorities and design goals. Also, regarding the library ecosystem, Racket also suffered from all of the same issues that plagued Common Lisp. A quick glance at Racket package's index will show that many libraries/packages also fit the author's description of a library "developed by a single person and then stopped being maintained shortly thereafter". Even worse is that in many cases, the library ecosystem situation in Racket is even *worse* than Common Lisp because many Racket libraries, even critical one like, for example, DBI library, have *negative* bus factor, i.e multiple Racket libraries are developed and maintained by a single developer. This also affects the quality of many Racket libraries, and many of them are very immature (or even feature incomplete), especially when compared against the many battle-tested libraries that Common Lisp has (and we haven't even mention performance here). For example, I doubt Racket's web server can compare against Common Lisp's Hunchentoot. And on documentation and collaboration, while the situation isn't ideal, I feel that it is steadying improving, especially since the advent of Quickdocs and Quicklisp. But seriously, if library ecosystem is one of the major reason why the blog author moved to Racket, then I think he's in for a rude awakening.
&gt; Most of these issues don't really matter to me for a relatively new language that can only get better. Not really. For example, interactive development and introspection capabilities of Racket aren't going to improve anytime soon. In short, if your needs aligned with the PLT research group, then things should be fine, if not well... (this also explains the lack of maturity in many "practical" libraries of Racket, such as DBI, for example). 
1992, for the Apple Newton. There were a few innovations and comfort features. It's still kicking around if you want to play https://github.com/dylan-lang.
Should have [1992] in the submission title.
It was a cool language. Pity it was abandoned...
Problem with Dylan was that it was Apple pushing it. They had already shot themselves in the foot during the PowerPC transition by abandoning Pascal, the original Mac programming language, thus stranding long time developers. The old timers had no recourse but to translate their code bases into C. Those who went through that process suddenly had no appetite for Apple-proprietary languages, as you can imagine. This alone made Dylan a non-starter.
Dylan was for the Mac as well.
Quite easily, in fact. I stay as busy as I like and I have two others whom I'm able to keep busy as well.
Think apple might have it in them to do that again?
Backward compatibility has never been Apple's strong suite. You have to assume that all of their technology has a shelf life shorter than a business would like.
&gt; Also, benchmark games used Racket 6.10, which I believe is based on Chez VM (but I might have gotten it wrong). No, the Chez VM work is not anywhere near done yet. It's still using the C runtime with JIT, not Chez.
I was asking mostly about them deciding to arbitrarily fuck over developers in particular by abandoning the languages they wanted them to use.
Swift seems to be treated very well so far.
The library ecosystem critique captures my own main challenge with Common Lisp, at least as a newcomer. I am used to the idea of safety in numbers, i.e. the knowledge that if I decide to build my code on top of someone else's library, at least I won't be the only one. Others will be alongside, finding edge cases, reporting them, and helping improve the library through code contributions, documentation, tutorials, etc. The fact that so many libraries don't seem to have any recent visible activity is a major warning sign to stay away. As is the fragmented nature of the tools that are used: some use common-lisp.net, some use github, some use trac, some use launchpad. It's one thing to have relatively simple language tools like the ones Alexandria provides -- there's not a whole lot going to change there as more people use it, and not a wide surface area for new bugs and edge cases. But web servers, concurrency libraries, dependency management and packaging tools, data structure libraries, application frameworks, etc., all need active communities using, explaining, and improving them. On the other hand, for a hobbyist, it's fun to reinvent the wheel in your own special way. And coming from Clojure, SLIME and SBCL are really so much friendlier to the programmer than JVM and CIDER. Like, 100 times better. And there are bright spots, some impressive libraries whose authors have taken extraordinary time to add documentation and tests, and make those contributions available under permissive licenses. I am finally at the point where I'm starting to hit stride with CL -- figured out how to ignore the cruft and use the good parts, add the little things I miss from Clojure, etc., and I'm having fun with it.
Author here. I am having mixed thoughts right now. I received lots of private messages and emails from you. I never expected this to gather so much attention. My critiques hit home with some of you, others not so much. The fact is these are issues that do affect a good amount of you. Issues that need work. After chatting with a few Lispers privately about these matters, and reading these comments, everyone has made very good arguments. Racket is a nice language with the batteries included and lots of polish aimed at attracting new developers. However, Common Lisp really is a superior language in almost every way. As mentioned, I am having mixed thoughts. I have been using Racket sparingly to get my feet wet for the past few months, and while it is nice, there is a lot to be missed from Common Lisp, as can be seen throughout these comments. I am going to be sticking with Common Lisp, and just messing around with Racket on the side for not-so-serious projects and learning mostly. You all have enlightened me. With that said, I really am hoping that some of these issues I have brought up are important enough to the community to be actively worked on. I know we are a relatively small community compared to some other languages, and we have such a fragmented ecosystem, but maybe if these issues are important enough to solve, that we can work *together* in making that happen. I would like to thank everyone for showing me the light. I will be updating the article, and I will be staying with Common Lisp. I suppose using a language exclusively for so long has left me a bit jaded. I really do like working with this language, and I really appreciate all the comments and off-site discussions from this all.
[This discussion](https://www.reddit.com/r/lisp/comments/6w44ay/moving_away_from_common_lisp_kind_of/) made me think this might be a relevant subject for Common Lisp today. 
freelance work and contracting
&gt; I am used to the idea of safety in numbers Numbers were dependent on NPM left-pad, numbers were affected by CloudFlare's reverse proxy issue, numbers were using kernels suspectible to heartbleed, shellshock, venom, etc., numbers are using a language with widespread support only appearing for ["type system, static analysis, multi-threading, first-class IDE support, or any of a myriad of other features that are standard in any modern programming language in 2017"](https://news.ycombinator.com/item?id=15109751). The only thing that's different is the amount of people that are going to be affected whenever a critical bug is found. The eyeballs [Linus mentioned](https://en.wikipedia.org/wiki/Linus%27s_Law) are usually busy looking elsewhere.
**Linus's Law** Linus's Law is a claim about software development, named in honor of Linus Torvalds and formulated by Eric S. Raymond in his essay and book The Cathedral and the Bazaar (1999). The law states that "given enough eyeballs, all bugs are shallow"; or more formally: "Given a large enough beta-tester and co-developer base, almost every problem will be characterized quickly and the fix obvious to someone." Presenting the code to multiple developers with the purpose of reaching consensus about its acceptance is a simple form of software reviewing. Researchers and practitioners have repeatedly shown the effectiveness of various types of reviewing process in finding bugs and security issues, and also that code reviews may be more efficient than testing. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
That was not the problem. The problem was that Apple was not using it in a product and thus did not release it beyond the status of an advanced prototype. Sure Apple killed a bunch of technologies on the way (remember Taligent? ;-) ), but when it had a product for some time, people would have used it.
I just migrated to Haskell after a while. It solves all the issues you pointed, plus it has an amazing type system. The lack of macros is not a big of a problem due to lazyness, monads, free monads, and arrows. 
I don't use Lispworks but any ANSI compliant lisp has a [compile function](http://www.lispworks.com/documentation/HyperSpec/Body/f_cmp.htm).
Could you explain a situation where this is what you'd like to do? Essentially: Tell me a story where you get stuck cuz you can't compile a specific function.
got thinking about that: we don't have many people speaking about CL in conferences, do we ?
ELS gets a fair amount of Common Lisp submissions every year.
Yeah I was aware of the compile function but I am currently making simple lisp functions in online compilers but when you defun a function and want to call it later from the user side how would you do that? Also if I could get some help with the compile function that would be great as well
I was at ObjectWorld conference in mid-1992 or eary 1993, and I remember someone from Apple giving a presentation and getting a question something like "What does this mean for Dylan?" The answer was very vague. 
ELS, the European Lisp Symposium ([2017 edition](http://www.european-lisp-symposium.org/2017/index.html)) ? I know, but that's kind of cheating it's already about lisp :p Good reminder neverthless, it's still nice to see a list of talks, a list of sponsors, etc.
&gt; The problem was that Apple was not using it in a product and thus did not release it beyond the status of an advanced prototype. Yup, and why was that? Apple market tested Dylan with the developer community, and they told Apple just what I told you: Apple doesn't stand behind its technologies long enough for developers to stick our necks out as far as would be required to take on building significant apps using a language that couldn't work anywhere else. The Mac, with its smaller market share, couldn't close the business case for dedicated development with no code sharing at all with the other common windowing systems of the day. Apple is in a different place now, with a platform (iOS) with the kind of market pull that makes dedicated code bases viable. 
&gt; Yup, and why was that? Dylan was originally developed as a systems programming language for a new breed of small/mobile machines, which were under development. Apple brought the Newton Messagepad to the market with an OS written in C++ and NewtonScript. It was a management decision. Part of the reason was that they brought a very small machine with very little RAM to the market. The initial machine (the original Newton Messagepad) was slightly underpowered to run Dylan. It had 640kb RAM and 4MB ROM. It still did cost $700. The larger tablets were not brought to the market. Mac developer response had very little to do with it. The Apple Dylan stuff for the Mac was a side show, with less resources put into it. Apple originally developed a runtime with GC for ARM, a development tool on the Mac to target ARM boards (on Nubus cards and also external), an OS, applications, etc. Apple tried to pitch the language with other language developers. CMU got some funding and had a vision for an advanced IDE. But that never materialized and the project closed when the funding was cancelled. Harlequin also developed a Dylan and they got further then the others. But eventually they also got into financial trouble. Basically nobody backed the language and was able to create funding for it or was able to finance it. Both CMU and Harlequin addressed non-Apple developers. &gt; Apple market tested Dylan with the developer community But not with a product or an application behind it after the Newton was not shipped with Dylan. It was more like a research project then. A small team developed another Dylan OS version for a Newton, something for a TV, etc. But nothing which had a chance to be shipped. Earlier developers had got the message while the Newton/Tablets were under development that these might use Dylan in the product version. When Apple did release the Newton, but Dylan was not used in the shipped product, people lost interest and few resources were left working on Dylan. Even these were too expensive for Apple... A systems development language without systems, no application, little management backing, and not running on the latest hardware had no future. External developers could see that it would not fly at Apple... Before developers would invest into it, Apple had to and they cancelled it. Edit: added a section from Oliver Steele: &gt; The original Apple implementation compiled to native ARM code. The runtime was intended to be competitive with C, but by the time we approached that target, large parts of the toolbox had already been written in C, and Walter Smith had created NewtonScript as a scripting language that worked as an alternative for non-performance-critical code. At that point the Cambridge team re-targetted the implementation to build Macintosh applications, but that wasn't a sufficiently compelling (to Apple management) use, and we had lost our executive sponsor when the director of the Apple Cambridge lab was promoted to a position in Cupertino.
well, its not too hard when building business applications - your customer do not care what it is written in, providing it does the job. And the fact you have a stable, mature platform really does help. 
Just like Dylan was. I'm not saying it's going to happen. I just don't know if it won't... Haskell seems to be one of those things swift took from. Dylan did the same for lisp. I'm saying that Apple likes to try to incorporate shiny new languages into their ecosystem from time to time, but they've backed away from their established favorites and let the old ones float away into the wind. I hope they don't waste all their fans time this way, so don't take this as an attack on Apple.
Mike Levins (from the Dylan team at Apple) has added some great background in the hackernews comments: https://news.ycombinator.com/item?id=15107367
&gt; SLIME and SBCL are really so much friendlier to the programmer than JVM and CIDER. Like, 100 times better. that for a thing would be very interesting to read about. There are lots of articles on Clojure, not much on CL/Slime, even less about both. There might not be a lot of people knowing both environments. And many (IMO, at least me) constantly wonder wether Clojure's environment is easier (though I'm strongly put off by the JVM, and we hear some criticism here and there). So, any article on that would be welcome ! (don't have a blog ? Create a new github project and write posts in issues, that's well enough **edit** a gist is well enough) thanks in advance ! &gt; add the little things I miss from Clojure so, this too :)
&gt; Just like Dylan was. Dylan did not run on the latest Apple hardware, wasn't integrated into the main development tool line, API documentation wasn't rewritten&amp;publised for Dylan, the Dylan implementation wasn't open sourced, .... It wasn't actually shipped as a working&amp;supported tool to developers. The main use of Dylan was inhouse at Apple and this stuff was not shipped. 
Ok, my bad. I had an impression for some reason that Chez VM was used since 6.9
Isn't DEFUN what you want to do? `(defun square (x) (* x x))` compiles a function named `SQUARE` and `(square 10)` returns `100`. Also, [/r/learnlisp](https://www.reddit.com/r/learnlisp/) might be more suited for your question.
I liked the article, but I think he left out one factor, which is the academic, a lot of people are thought specific languages, I remember when I was in college I was thought Pascal, and a lot of the people of that era tried using Pascal or Delphi as their main language even after graduation. I really don't mind that the language I use is not mainstream, but there is a minimal mass of community that need to be maintained otherwise the language dies, and of course that should be an enthusiastic mass. I've seen good languages die just because there were not enough persons interested in them. I think that will never happen to lisp, but I don't think is primordial to try to make it the most popular language.
Co-author here. We just added 3 new features that make this suitable for game development, unlike png-read. * optionally write to a 1d array instead of maintaining compatibility with opticl, for when you want to pass the image data to somewhere that requires a 1-dimensional array fast, such as OpenGL. * optionally write to foreign memory, for when you just want to pass a pointer along to OpenGL. * flip the Y axis, for OpenGL and others that expect the image to be read bottom to top. These will be present in the upcoming Quicklisp dist, as well as full the opticl library fully supporting pngload, replacing png-read. Enjoy
I'd really like to contribute to trying ta fix these issues but I am a very new lisper and don't know how much I can really contribute. 
I like this initiative ! I'm working on improving some documentation, specially the [CL cookbook](https://lispcookbook.github.io/cl-cookbook/). Next I'd like to document error handling and web development. (come &amp; join if you're interested, no need to be an expert) I'm still trying to understand how we can help the CLUS project: https://github.com/phoe/clus-data/issues/24 Otherwise I'm writing some small web scraping scripts, it's fun and easy. (https://lispcookbook.github.io/cl-cookbook/web-scraping.html) I'm trying out Roswell, wether it's a replacement of Shelly and how we can plug a roswell script into a package (for example, into one project created with cl-project) (Roswell works well on its own with `ros init`, but with quicklisp dependencies and inside a project ? to try) ps: a threading macro: https://github.com/hipeta/arrow-macros works like a charm
I posted a threading macro to `comp.lang.lisp` in 2002, years before Clojure was released: https://groups.google.com/forum/#!msg/comp.lang.lisp/079yqEOycHU/DkuDDWABAtMJ The macro can split multiple values coming out of a pipeline element into separate pipelines, whose results are then joined again. Slightly patched six years later: https://groups.google.com/forum/#!msg/comp.lang.lisp/9TcuICAT-pc/8NZxrLmdA-kJ 
Awesome. I'm definitely in that honeymoon idealistic phase with CL so I would be interested in trying to improve the documentation and do other things to make the language more approachable to beginners.
Writing a CL version of the assembler from nand2tetris - first real project I've tried with CL. Going well so far, but I do miss native regex support..
I'm working on a simple UI toolkit for [Shirakumo](http://shirakumo.org)'s game engine [Trial](http://shirakumo.org/projects/trial). I'm kind of burnt out on that, though, so progress has been very slow and I'm considering doing something else for a bit. Maybe I'll work on a new version of my CI system next, or perhaps I'll start working on a wiki software. There's nothing that I have a burning desire to do right now though, so I haven't been as motivated as I'm used to in general.
Regex are super neat and it's too bad they're not natively supported. You know any good libraries for them?
You mean beside the well-established `cl-ppcre` by Edi Weitz that is linked from just about any Common Lisp site that gives pointers to major libraries, and the first hit for [Google "common lisp regex"](https://www.google.com/search?q=common+lisp+regex)? CL-PPCRE compiles regexes to Lisp which your Lisp compiler then translates to native code; it is "native". What it isn't is *built-in* to your Lisp implementation or the standard language. Non-built-in things are not second class "non-native" citizens in CL, though. 
I'm a complete beginner to CL so honestly I've never heard of cl-ppcre. That said, I should have googled it before asking such a dumb question. I just assumed from the comment that there wasn't a canonical choice. 
I'm working on huge refactoring of a well known but almost abandoned webframework, called Weblocks. Already ported it from the Hunchentoot webserver to the Clack. This gave me ability to run it on IPv6 only machines inside my company's infrastructure, so in parallel, I'm doing a little side project — an alternative interface to deal with large amount of outdated tickets in our issue tracker. Talking about Weblocks. It is really great. As I said, I've ported it to the clack. Rewrote a dependency system, internal signaling, etc. separated some parts into other packages. My goal is to make the code readable and easy to maintain and to provide a documentation for easy start for beginners. Work in progress is here: https://github.com/40ants/weblocks
That's great to hear. I liked some of weblocks, but absolutely nothing in it worked the way it's documentation specified things. Doing anything was: 1. Read the documentation 2. type in example code 3. read inscrutible error message 4. M-. through the code until I found where things went wrong 5. Finally write correct example code 6. Try to remember what I was trying to do in the first place
I'm working on getting much of quicklisp working on the Nix package manager via semi-automated scripts: https://github.com/jasom/ql2nix/ There are 3586 systems in QL, currently 2725 systems work, ~260 systems are known to not work and the balance depend on one or more of the non-working systems.
I'm working on nEXT, a new type of web browser based on Common Lisp / emacs paradigms https://github.com/nEXT-Browser/nEXT 
(about downvotes, i think there's a downvote bot on here that seems to downvote everything. I like your idea.)
so before you google, see: - https://github.com/CodyReichert/awesome-cl - http://lisp-lang.org/wiki/article/recommended-libraries :)
well, I have started work on an R-like data slinging infrastructure. Currently doing the ingestion and data cleaning parts. This is my hobby project I guess. Once done i will be looking into visualisation and am quite interested in Vega Lite. Hopefully I can turn that into a ggplot equivalent for lisp. More importantly, I am starting (well, re-starting) on a commercial project that got stalled last year. The server side will be lisp, the front end will start off being javascript and will likely change to native iOs/Android clients over time. I looked seriously at Clojure and Ruby for the server side last year and came away with the feeling that while both were fine languages in their way ( and being an ex APL programmer, I quite enjoyed the "line noise" Ruby one liners) there was no compelling case for me to move to either. 
I'm finally implementing a new macro I've been thinking about for a while, `dispatch-case`. I think the single most useful thing in [Serapeum](https://github.com/TBRSS/serapeum) might be the `etypecase-of` macro, a really simple macro that lets you specify the type to dispatch on and then checks, at compile time, that the branches are exhaustive. I use it everywhere. But not everything is perfect: *nested* `etypecase-of` forms are ugly and hard to read. On the other hand, exhaustiveness checking for matching permutations of different types is not, at this point, something I'm willing to live without. Thus `dispatch-case`: it *should* provide a first-class way of dispatching on permutations of types, with exhaustiveness checking, but without having to add a new layer of nesting for each object.
I've been working on a small tool to generate fake data from a json specification. Once I get the chance, I want to modify it to fully support avro schemas so that it can hopefully be useful for integration tests.
Great idea, I love it. I started working on a GBA emulator. I started with disassembling the opcodes. Not much worth showing yet, though, and it's mostly untested.
I have recently taken up work on a chat application similar to Slack. The project was dormant for about a year, but there is a lot of new features that should be coming soon. https://github.com/cicakhq/potato I'm also working on a new client for CouchDB. That one is not ready for release yet, however. 
Thanks, I'll give these a read. I haven't really gotten to the point in my lisp education where I've thought much or even looked too closely at libraries but nows as good a time as any.
You're doing god's work!
Right. I've tried it few years ago, and nothing worked. Since that time, [Olexiy Zamkoviy](https://github.com/html) fixed many issues and Weblocks become usable, but code still was a big mess. New documentation will look like that: http://40ants.com/weblocks/. This is the old one, converted, but I've already wrote a quickstart: https://github.com/40ants/weblocks/blob/reblocks/docs/source/quickstart.rst which should work for my branch.
Android has no fully interactive development stack for both CL (ECL in this case) and the UI (QML in this case). So, I'm trying to make it as interactive as possible. Connecting from Slime (PC) already works; even hot-swapping of the QML (UI definitions) files, which you can edit on the PC/Emacs, works experimentally. The show-stopper right now is that Swank sometimes freezes... (So you need to restart the app on android).
This week I worked on [pngload](https://github.com/mfiano/pngload), a replacement for png-read that is faster, more conforming, and more suitable for use with OpenGL. I also wrote a proof of concept idea I thought would be fun, called [shorty](https://github.com/mfiano/shorty), which allows storing data inside a URL. Finally a few odds and ends, fixing bugs with existing libraries, and working on my game a bit.
I'm working on a game engine called `cl-bodge`. At this moment though, I'm making `trivial-gamekit` stable enough to start writing documentation for it and share it. `trivial-gamekit` is a `cl-bodge` facade with simplest interface possible for newcomers to start with gamedev in CL quickly.
If you want to write perl-in-lisp, then `cl-ppcre` plus `cl-interpol` gets you halfway there with regex scanning and a special regex-literal syntax that does sane things with backslashes, as well as interpolated strings.
Have had a few weeks off hobby coding but am easing back in again. Have been looking at some [boids](https://en.wikipedia.org/wiki/Boids) tutorials ahead of streaming this Wednesday. About downvotes, don't worry to much about it, there are likely some folks who heavily downvote anything that's not very code focused. But I'd advise not having more than one of these 'what are you working on' posts every 2/3 months. I hope you keep having fun with CL. Also consider dropping by #lispgames as the chat there is generally more relaxed that on most other CL subcommunities I've experienced.
**Boids** Boids is an artificial life program, developed by Craig Reynolds in 1986, which simulates the flocking behaviour of birds. His paper on this topic was published in 1987 in the proceedings of the ACM SIGGRAPH conference. The name "boid" corresponds to a shortened version of "bird-oid object", which refers to a bird-like object. As with most artificial life simulations, Boids is an example of emergent behavior; that is, the complexity of Boids arises from the interaction of individual agents (the boids, in this case) adhering to a set of simple rules. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
Many ideas, no time. Should have more time when I got a permanent position!
cool, I enjoyed very much [this live coding Potato session](https://www.youtube.com/watch?v=bl8jQ2wRh6k) and I've been advertising it a bit. Because Potato is impressive and because it is a good demo of interactive development. A shorter one would be great though :p ps: I couldn't find [the demo](https://potato.dhsdevelopments.com/login) password :( 
This is really exciting, congrats and best success ! I tried your getting started guide, for notice I have encountered two problems: - restarting the app with `(progn (weblocks:restart-webapp 'tasks) (weblocks.session:reset-latest-session))` didn't seem to restart the app, thus calling again `(weblocks.server:start-weblocks)` worked. - I couldn't submit a new task (the first way), I got two warnings and the app crashed: ``` &lt;WARN&gt; [10:55:58] weblocks.hooks request-hooks.lisp (reset-html-parts) - Resetting html parts cache [2017-08-29 10:55:58 [WARNING]] Warning while processing connection: Implicitly calling MAKE-WIDGET to render #&lt;CLOSURE (LAMBDA () :IN TODO::INIT-USER-SESSION) {100E74FD0B}&gt;. [2017-08-29 10:55:58 [WARNING]] Warning while processing connection: Cannot update the widget children of #&lt;CLOSURE (LAMBDA () :IN TODO::INIT-USER-SESSION) {100E74FD0B}&gt; because it is not a widget. ``` the last piece of example with the js action works beautifuly. Very exciting.
that's exciting. What did you achieve so far ?
Yeah, I've used cl-ppcre before - but I'm trying to get to know the core language better. So far search &amp; subseq has done all I needed
I've been working on a CLOS interface for ncurses for some time now, called [croatoan](https://github.com/McParen/croatoan). Initially, I thought that the Lisp world lacked a proper terminal IRC client like irssi or epic, so I set out to write one, only to find out that the low-level ncurses C APIs are quite awful to write to directly using CFFI, so I set out to write a higher-level CLOS-based wrapper that would be (at least for me) more pleasant to work with. I clearly underestimated the amount of work necessary to understand and wrap all of ncurses and its historical cruft, and overestimated the amount of leisure time I can devote to the task, so I guess judging by my progress until now it will not reach anything resembling a stable release for another year or two, [but it's progresing](http://i.imgur.com/iywc1iG.png), and it is has been on quicklisp since december 2014.
This kind of thread needs to happen weekly or bi-weekly. &gt; I see this is getting its fair share of downvotes. Are 'What Are You Working On?' threads just not liked here or was it something else I did? 93% upvotes that I see right now. ---------------------- I have been working on assorted things over the last three-four weeks. * [CLUS](https://github.com/phoe/clus-data) - I need to focus on this. * SWANK server for Lisp Flavored Erlang * [Gateway](https://github.com/phoe/gateway) which is a game of mine * Library for reading the proprietary FOX5 image/animation format of the online game Furcadia
I think that a very fine idea is to start learning by fixing issues in already existing projects. Thanks to that you gain guidance of the maintainers who will answer your questions and a broad perspective on the projects you will contribute to. For books, Practical Common Lisp is something most people will recommend you. Here, on reddit, many valuable materials are listed on the bar at the right (books included).
I haven't started my path with Lisp yet, right now don't have much time, but when I do this is what I'll be following (In the order listed): * Land of Lisp (Fun while learning) * Practical Common Lisp (The practical side of Lisp) * ANSI Common Lisp (Required reading) * On Lisp (Required reading) * Paradigms of AI Programming: Case Studies in Common Lisp (I'm actually want to learn Lisp just to read and understand this book!) 
Any ideas or suggestions? 
It would be good to share exercises, practices and question as we fire-walk the path towards the land of lisp. 
I think bi-weekly would be fine for this sub as there's fairly little activity it seems that this post should stay near the front page for a while. When I made that edit the post was sitting around 65% but the downvotes seem to have been drowned out so I should really re-edit it. 
I'm also a newbie at common lisp, but with elisp experience. Currently I'm working through *Practical Common Lisp*, but I was stuck for a while trying to find a resource that shows that common lisp could be used for scripting, as most resources only listed functions that completely ignored stderr or mixed stderr with stdout, which is often used on the command line. After working my way through [Cliki: Getting Started](http://www.cliki.net/Getting%20Started) and the [current recommended libraries](http://www.cliki.net/current%20recommended%20libraries) I found what I was looking for. At least, that's the path I'm on. As for tools, I'm using spacemacs with sbcl to learn, which works **a lot** better than trying to use the REPL directly. 
thanks! I can make/load buffers, I'm working now on mini buffer completion a lot of the framework has been done, compilation stuff etc, you can see the project status / goals here: https://github.com/nEXT-Browser/nEXT/blob/master/documents/TIMELINE.org
Yes, I need to figure out how to run unit tests for all examples from the docs. 
Regarding projects? My suggestions will be spoiled by bias towards projects I maintain: - McCLIM is a brilliant piece of software which could use help from small things to harder tasks, - mcclim-desktop project on github has many projects written in CLIM which you might extend or learn from - ECL is Common Lisp implementation which has some tasks to do as well if you are interested in how CL may be implemented, From other projects, sharplispers group on github maintain number of packages. Browsing issues and fixing them would benefit a lot of people. If you look for actively maintained projects, you may use this blog post as heuristic, what was recently updated and is used on quicklisp: http://blog.quicklisp.org/2017/07/july-2017-quicklisp-dist-update-now.html Basically hack something what seems interesting to you, or would benefit other project which you find interesting (for instance adding unix domain sockets implementation to usocket would benefit a lot of projects).
Looking forward to it! !remindme 21hours
I started with Land of Lisp, the book suggests using CLISP which is not the best choice these days, I would suggest continue with SBCL since you already installed it. There are a couple of uses of implementation specific functions on there, particularly when generating graphs (If I remember correctly), try using ASDF3 instead to get something more portable, it is also a good exercise. For practical common lisp I think lisp in a box or something like that was suggested, disregard that and the rest of the book is excellent. If you have not installed Lisp try using [roswell](http://www.cliki.net/Roswell), or following the instructions from Baggers in [this video](https://www.youtube.com/watch?v=VnWVu8VVDbI). I think On Lisp is a must read, but I think ANSI Common lisp is not required before you jump into PAIP, I would make that a parallel read. My experience is that you learn a lot from the books, but the best thing you can do is program, invent a project, cotribute to one, but make it a priority to write code, try your hardest to not make it imperative, and pay attention to all you write, try to make Lisp do the error prone and repetitive tasks for you. Even if you just follow the code in the books, try to type it yourself, and play with it.
My brain is dumb. Is this just a better and lispy implementation of Go and JavaScript? 
This is a implementation of the LISP standardized by ISO in 2007. This implementation is written in Go and converted to JavaScript with gopherjs which is the compiler from Go to JavaScript. ISLisp specs is bigger than R5RS and smaller than CommonLisp. It's enough to write applications. For more information, please refer to the specs.
You should be able to use the signup link to create an account. Please let me if that doesn't work correctly. Also, once there is a better workflow for a new user, I'm considering setting up a more permanent server that could be used as a Slack alternative for anyone who don't want to run their own server.
By bi-weekly do you mean twice a week or once every other week?
see also https://github.com/CodyReichert/awesome-cl sometimes it has less old cruft than Cliki.
Hello, also newbie since a few months, with elisp experience so I was not looking for lisp basics. Here's some resources that got me even more hooked: - the book [Common Lisp Recipes](http://weitz.de/cl-recipes/) at least it was a high-level and recent (2015) book that presents many libraries in a broad range of subjects to getting things done in the real world. - http://lisp-lang.org/ beautiful website with success stories, recommend libraries, short tutorial. - https://github.com/CodyReichert/awesome-cl curated list of libraries. Sometimes Cliki shows too many legacy projects. - the CL cookbook: https://lispcookbook.github.io/cl-cookbook/ that I'm helping updating and extending (come join ! no need to be an expert and it's a great way to learn). Hope you'll like its strings or Data Structures pages to begin with. I'm also watching /r/learnlisp so we could ask ourselves questions or how's going progress over there (or stack overflow).
That sounds great! Developing in CL for android would be amazing (I know about mocl, but it's not free). Is this the correct repo to look at? https://gitlab.common-lisp.net/ecl/ecl-android. Looks like it hasn't been updated in last 8 months.
Once per two weeks.
Well, what can I say - I'm now anxiously waiting for the next parts!
oh, so you are phoe :) I'd like to help on CLUS, but as you saw the discussion the process is a bit awkard, not clear to me. &gt; SWANK server for Lisp Flavored Erlang wow. That'd be great.
hey, you should advertise your projects over here ;) eazy-gnuplot looks great (went on /r/learnlisp), eazy-project looks great too.
CL has in my opinion the best books! you can watch some tutorials, but i strongly suggest old school book reading. that's how i started (also with sbcl+slime). i read (and suggest in this order): * common lisp: gentle introduction to symbolic computation. * land of lisp. * practical common lisp. there is a lot of excercises and practical coding in all of this books. later you might want to move to: * common lisp recipes * on lisp * structure and interpretation of computer programs CL is HUGE! don't try to understand it all, or like all you learn about it. CL is so huge, that you can avoid most of the time parts of the language you don't like.
That's a preceding project, from which I took a few ideas (and code). This new attempt can be found here: [EQL5-Android](https://gitlab.com/eql/EQL5-Android/), [screenshots](https://gitlab.com/eql/EQL5-Android/tree/master/screenshots), [Sokoban APK](http://lights-of-holiness.eu/tmp/sokoban.apk), [REPL APK](http://lights-of-holiness.eu/tmp/repl.apk) **N.B:** You'll need android version 4.1 (API 16), because of Qt5, and the examples are designed for tablets (didn't test on a phone yet). Also, especially the REPL is still to be considered in alpha state. 
Part 2 is written and in spellcheck now. Then come code pieces.
I don't want to be rude but I don't see the point in publishing this part alone: there is no content really. Why not wait and publish everything in one go? Or is it a format specific to medium?
i mean no code whatsoever. not even a project yet. if you are *really* want to know, see my common-lisp-project-ideas repository.
We're slowly organizing CLUS work on Lisp Discord server. https://discord.gg/9KNg9Pm
Hey, check out trivial-features library, which unifies featues across implementations: https://github.com/trivial-features/trivial-features/blob/master/SPEC.md
Yes, that
I guess there really is a trivial way to do it. Maybe I should have included that as a keyword in my searches. Thanks for the quick response. This is what I was looking for.
Trying to cons up many parts to publish all at once is what held this up. This is all 12+ months old. Also, feedback on the earlier parts improves the later parts. It is not that I disagree that doing it differently would be better, but bandwidth limitations make a more of a choice between slow and no.
Idea: check the size of a C pointer via CFFI's `foreign-type-size`. 
I'm a semi-newbie currently working my way through structure and interpretation of computer programs. The book is genius!
I took a look at mcCLIM really an awesome project. I wish I could contribute to it in a near future!!. Thanks for pointing at that! 
Thanks, I think I will follow your steps. Been looking at those book you mentioned and they seem a good way to begin. 
I'm currently working on a self-maintained and self-hosted registry for ASDF prebuilt systems backed by CouchDB to use for inter-company libraries. 
Rough guess: One can look at the max fixnum size.
I started work on [a Wayland compositor](https://github.com/malcolmstill/ulubis) about a year ago. Since starting a new job I've been really struggling to find time to work on it. Hoping to get back into it soon.
userfaultfd(2) support for SBCL's generational GC. Replacing the write barrier mechanism, which currently is write protected VM pages and SIGSEGV handlers, with a faster and more flexible mechanism. https://medium.com/@MartinCracauer/generational-garbage-collection-write-barriers-write-protection-and-userfaultfd-2-8b0e796b8f7f https://www.cons.org/cracauer/cracauer-userfaultfd.html 
Also doing writing why I want Lisp in the first place - Compile Time Computing. In general, I am on a run against scattering my and others' attention, which happens way too often in today's tech world. https://medium.com/@MartinCracauer/a-gentle-introduction-to-compile-time-computing-part-1-d4d96099cea0 https://medium.com/@MartinCracauer/a-gentle-introduction-to-compile-time-computing-part-2-cb0a46f6cfe8 https://medium.com/@MartinCracauer/on-attention-focus-and-autism-in-the-tech-workplace-8246526fbbc0
Indeed. If we know that the given Lisp is ether 32 or 64, it's quite probable that the `most-positive-fixnum` will be either a few bits less than `(expt 2 32)` or well in excess of that value, in these respective cases.
I'm currently working on a game of which I haven't released the code. But it uses a graphics lib i wrote called [mariko](https://github.com/izz-j/mariko) . As i develop the game I improve and add more features to mariko at the moment you can quickly render 2d sprites and make tile (hex, squares, etc) maps based on data read from a text file. Currently needs more documentation though
Part 2 is up. Describes what specifically you can do. https://medium.com/@MartinCracauer/a-gentle-introduction-to-compile-time-computing-part-2-cb0a46f6cfe8 Part 3 will have code.
Can you not improve CL-CHARMS?
Both restructured text and asciidoc should be able to handle DEFSTRUCT without issues.
That doesn't let you check for 32/64 in the general case though, you need to query each CPU type separately. They have been discussing adding 64/32 IIRC though.
I like Charms because it also gives access to the low-level API which sooner or later you always need.
Yeah it's nice seeing all these projects and youngbloods. I've been out of touch with the CL community but still use it daily.
&gt; I know that there are really good lisp hackers around I am far from being one of them but here is a list, in some sort of order: 1. Common Lisp: A Gentle Introduction To Symbolic Computation 2. Land of Lisp 3. Practical Common Lisp 4. Lisp For The Web (as an interlude - I use a Raspberry Pi as a "Lisp Box" for web programming) 5. Successful Lisp 6. ANSI Common Lisp 7. On Lisp 8. Paradigms of AI Programming 9. Let Over Lambda And use StumpWM :)
Not without extensions - such a format should have local and remote links, multiple kinds of code snippets that also support formatting, support for HTML anchors.
Couldn't make it, hopefully next time. Thanks for the video!
Nice. I appreciate the pure prose too.
it's not a big problem (regarding discussion in the spec) - if we want to provide two different implementations and even if some implementation pushes x86 *and* x86-64 to features, you could: #+x86-64 (bla) #+(and x86 (not x86-64)) (bla2) to be always on a safe side. If you aim at other processors and you are curious about pointer size, you could use ffi for that.
Glad you enjoyed it, seeya next week :)
Is there no Common Lisp equivalent of [Scribble](https://docs.racket-lang.org/scribble/)? It's implemented in Racket and uses a custom reader to accept markup, which calls out to Racket code for formatting and such. So there are custom calls for documenting functions, macros, etc. Of course, "write a thing from scratch" is probably bad advice here...
letting you know that I asked on an issue about the 1 month Quicklisp delay: https://github.com/quicklisp/quicklisp-client/issues/148 (with help of your post).
Great, I'm glad other people think that this is a major problem. I do know why it is like it is, but a lot of people do not want it to change. I am hoping that by more people talking about it, like you are, that a demand for change is made. Thanks!
https://github.com/fare/scribble similar: https://github.com/CommonDoc/scriba
Thanks for the list. Wow StumpWM seems something to try!. It´s like xmonad to Haskellers :-) 
not a lisp developer here. I am interested in Modeling and Simulation. I sometimes work with Maxima that is implemented in lisp, based on the old MACSYMA, when Maple is not available. To improve my knowledge of common-lisp, I recently tried to interface lisp to the fortran DASKR solver (algebraic systems with discontinuity handling) using the cffi package. It works on single float version sdakr_ on continuous system but I am stuck with double precision types in the dsakr_ fortran version. Oh and big trouble with the second discontinuity handling function callback that crashes without any consideration of my admiration of both DASKR and LISP. I am probably not sharp enough to solve this ... but what a fun.
This is a good idea. I might want to use it and possibly fork/extend to accept CLUS-specific markup. Thanks for linking this to me.
You seem to have found a good workflow. I invite you to share it, even a quick post in a gist would be very welcome :)
rST: * Code snippets: http://docutils.sourceforge.net/docs/ref/rst/roles.html#code * this lets you specify both language and class for customizing appearance of code snippets * Support for HTML anchors: each section implicitly creates a link and you can explicitly create them: http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-targets * Remote links: Pretty much every lightweight markup language has this, right? AsciiDoc: * HTML Anchor: http://asciidoctor.org/docs/user-manual/#anchordef * HTML Anchor to external AsciiDoc file: http://asciidoctor.org/docs/user-manual/#inter-document-cross-references * AsciiDoc really shines for source-code listings, you can set arbitrary attributes on listing blocks, so formatting can be used in the middle of a code listing: (e.g.) http://asciidoctor.org/docs/user-manual/#applying-substitutions
What's the link to the YouTube channel?
https://youtu.be/ew3UEPFd2Wk also linked from the newer thread
&gt;[**Pushing Pixels with Lisp - Episode 14 - Flocking [119:24]**](http://youtu.be/ew3UEPFd2Wk) &gt;&gt;This week I wanted to get back to learning something new. Boids was something I had known about for ages but never implemented so that was the goal. &gt; [*^Baggers*](https://www.youtube.com/channel/UCMV8p6Lb-bd6UZtTc_QD4zA) ^in ^Science ^&amp; ^Technology &gt;*^154 ^views ^since ^Aug ^2017* [^bot ^info](/r/youtubefactsbot/wiki/index)
Great, thanks! Definitely going to check these out. 
Good bot
Thank you nicksmaddog for voting on youtubefactsbot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
And it's [done](https://github.com/TBRSS/serapeum/blob/master/reference.md#dispatch-case).
this week i've been working on a prototype of a p2p chat app. i did some digging and found the [libp2p project] (https://github.com/libp2p/libp2p).which has a javascript and go implementation. i figured my prototype would use webrtc, so i used the libp2p javascript implementation with clojurescript. i have had a great time working with [datascript](https://github.com/tonsky/datascript.git) as the source of truth for my ui and am curious to find similar projects across languages--more recently i found mozilla's [mentat](https://github.com/mozilla/mentat). 
Great thread! I too would like some recommendations. I have worked through SICP during university and later read "On Lisp", even thou it was hard, and have used "Practical Common Lisp" as an online reference book, but i am really into macros. Now i am working on a project with CCL+Slime. But i feel that i should work through a normal book about the language. Which is good? "Successful Lisp" or "ANSI Common Lisp"? Or another? I don't think that i will read two books that are that close on the subject matter, an extensive walk-through of the entire language. But i plan to reread "On Lisp" and later read "Let Over Lambda". And maybee eventually "Paradigms of AI Programming: Case Studies in Common Lisp".
You're welcome :) If you buy these books, just a word about Land of Lisp: I'd still recommend it before Practical Common Lisp, but some parts of the book are for intermediate Lisp programmers. Also, check the [errata](http://landoflisp.com/errata.html). About StumpWM: yes, it's a nice feeling to start a Lisp process as soon as you launch your WM then using that same process for coding (through `slime-connect`). There is a useful guide [here](http://www.kaashif.co.uk/2015/06/28/hacking-stumpwm-with-common-lisp/index.html).
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/olzd] [Delimited continuations with monadic functions in Common Lisp](https://np.reddit.com/r/olzd/comments/6xgyt8/delimited_continuations_with_monadic_functions_in/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I made [lispkit](https://github.com/AeroNotix/lispkit/) which had a similar idea. I used GTK though, which I highly regret. I have a branch I mess with locally every now and then to switch to Qt.
yeah, I saw your project, it was actually the inspiration for some of my ideas! if you want to work together I've started a google group as well: https://groups.google.com/forum/#!forum/next-browser
The original creator of the "Boids" technique, Craig Reynolds, has done a bunch of other research into biologically inspired computation. http://www.red3d.com/cwr/iec/
I re-read Henry Baker's papers on achieving simple, efficient garbage collection in compiled Lispy languages via CPS transformations (http://home.pipeline.com/~hbaker1/LazyAlloc.html and http://home.pipeline.com/~hbaker1/CheneyMTA.html) and was inspired to rewrite some compilers for work. However, these are internal DSLs that compile to Clojure closures rather than to a low-level language with explicit memory management, so I don't think I'm getting the full benefits -- it requires explicit trampolining, and I'm at the mercy of whatever the JVM is doing under the hood when it analyzes what data can be kept on the stack and what needs to live on the heap to be available for later continuations to use. But at least it focused my attention on ways to eliminate patterns that guaranteed unnecessary runtime allocations.
I am working on a DSL compiler to C#. Born out of my four years experience as mainly a maintenance developers on a e-commerce c# web-shop where the old version system started logging at 2008. I encountered cases where i had to change around 10 functions in over 50 files in a manner that were dependent on the class name or something else that disallowed automation change by find-and-replace or Rsharper. So i thought wouldn't it be great to have a program that can read C# files and you could feed it commands and it knew about class data, like the class-name and other stuff, and it could rewrite the file, or create a bunch of C# files following an instruction set. That is my goal. The project is in a very early stage, but i have managed to create an AST of a very basic C# class. I am hopeful that with sufficient time i will finish it. And soon, once i got the write function down, expose the github project to the common lisp subreddit for feedback :).
It really is good. Stick whit it and do the exercises! I did it in university, it is worth the time!
I use [Sly][] instead of Slime, and [Lispy][] instead of Paredit. But those, I think, are well-known; here’s some less well-known tools. - [adjust-parens][] is extremely useful and seriously underappreciated. - [mouse-copy][] is only slightly less useful but even more obscure. - [highlight-quoted][] provides valuable, bug-preventing feedback. - [easy-escape][] makes backslash storms in Lisp strings (particularly regexes) much less painful. - [expand-region][] is good for highlighting sexps. - [aggressive-indent-mode][] isn’t Lisp-specific, but indispensable for Lisp editing. Another thing that might not be obvious: you can tell Emacs to swap square and round brackets (as with the Lisp Machine keyboards of yore): (keyboard-translate ?\( ?\[) (keyboard-translate ?\[ ?\() (keyboard-translate ?\) ?\]) (keyboard-translate ?\] ?\)) [Lispy]: https://github.com/abo-abo/lispy [Sly]: https://github.com/joaotavora/sly [adjust-parens]: https://elpa.gnu.org/packages/adjust-parens.html [mouse-copy]: https://github.com/vsedach/mouse-copy [highlight-quoted]: https://github.com/Fanael/highlight-quoted [expand-region]: https://github.com/magnars/expand-region.el [easy-escape]: https://github.com/cpitclaudel/easy-escape [aggressive-indent-mode]: https://github.com/Malabarba/aggressive-indent-mode
I customize outline-mode and make parens foldable, which literally makes it look like this: (defun main (&amp;rest files)... (defun ad (f &amp;aux (name (name f)))... (defun sd (f &amp;aux (name (name f))) (let ((entry (ensure-gethash name *db* (make-array 6 :initial-element :N/A)))) (match (split-sequence #\Space (grep "type1 error:" f)) ((last (list (read t1) _) 2) (setf (aref entry 0) (threshold t1)))) (match (split-sequence #\Space (grep "type2 error:" f)) ((last (list (read t2) _) 2) (setf (aref entry 1) (threshold t2)))) entry)) 
That looks really cool! Would you mind sharing the code for doing that? Is it smart enough to fold everything beyond the function declaration automatically? edit: I tried looking for something like this and found [this link](http://emacs-fu.blogspot.com/2008/12/showing-and-hiding-blocks-of-code.html). So in my code I now have: (add-hook 'prog-mode-hook (lambda() (local-set-key (kbd "C-c &lt;right&gt;") 'hs-show-block) (local-set-key (kbd "C-c &lt;left&gt;") 'hs-hide-block) (local-set-key (kbd "C-c &lt;up&gt;") 'hs-hide-all) (local-set-key (kbd "C-c &lt;down&gt;") 'hs-show-all) (hs-minor-mode t))) and it works wonderfully! Thank you for the idea!
I've only been using Slime and Paredit. What can you do more easily because of using Sly + Lispy? Thanks for mentioning all of those packages, I'll have to try some of them soon.
My use of Lispy is pretty basic; I basically use it as Paredit with shorter keybindings. I've been switching back and forth a lot lately between Linux and Windows, and with Lispy I don't have to worry about which keybindings conflict with which operating system. (Also, on a relatively small laptop keyboard, Lispy is much more comfortable for my hands.) The big attraction of Sly, for a user's perspective, is a drastically improved REPL. It's a complete reimplementation on top of comint. It's fast, it's stable, its behavior is consistent with the rest of Emacs, you can have multiple REPLs on the same Lisp process, and you don't have to worry about crashing Emacs if a database query returns too many results.
It's really simple, but I have one function that I wrote that I use *ALL* the time. [Here](https://gist.github.com/chebert/e8e54bac7d9c21c056433cc9fc956317) is a gist of it. Basically I've taken the code for SLIME-EVAL-PRINT-LAST-EXPRESSION and modified it to print a comment on the next line(s). If it's output to standard-output, then it's prepended with "Output:" so that you can see output from the call as well as the value(s) returned. In my slime-mode hooks I've added the key-binding "C-c j". EDIT: Example (map 'string #'code-char (header-vorbis *id-header*)) ; &lt;- C-c j here ;; =&gt; "vorbis"
+1 for adjust-parens. I run in evil mode and it lets me slurp/barf in a very vim-natural way with &lt;&lt; and &gt;&gt;. If paredit is a bit to much for you, you want adjust-parens.
Thanks for posting that! That seems like a great way to make Lisp code even more interactive.
My main Lisp project currently is [cl-patterns](https://github.com/defaultxr/cl-patterns), which is a library for writing/composing musical sequences. It's heavily inspired by SuperCollider's patterns system but has a few significant changes that are supposed to make the system more flexible and not require as much work to figure out how to formulate a musical idea as code. Right now the primary backend I'm developing it for is [cl-collider](https://github.com/byulparan/cl-collider), a Lisp interface to SuperCollider's sound server, however in the future I plan to make cl-patterns work with [Incudine](http://incudine.sourceforge.net/) as well. I haven't announced the project much yet because I want to get it to "1.0" quality first, but there is already a decent amount of functionality and documentation written, and it should be stable enough for normal use.
Cool! I've been trying to write a 2D game in Lisp with cl-sdl2 but I'm just constantly having problems with it (rendering sprites with cl-sdl2's render functions seems to be very slow and uses a lot of CPU, for example). So I may end up studying your engine to see if I can learn the "correct" way to do things with cl-sdl2 rather than having to take a bunch of shots in the dark (which has ended up discouraging me from working on the game due to how frustrating it can be). Thanks for sharing!
You don't need adjust-parens if you are using lispy (see `lispy-indent-adjust-parens` and `lispy-dedent-adjust-parens`).
I'm reminded of [IBM's JSONx (XML-ified JSON)](https://www.ibm.com/support/knowledgecenter/SS9H2Y_6.0.0/com.ibm.dp.xm.doc/json_jsonxconversionexample.html) though this seems slightly more useful. 
&gt; any advantages or nice quirks the other doesn't have One major difference in CL vs. a Scheme dialect (or most lisps inspired by it, like Clojure) is how they treat function definitions. With Scheme, functions share the same namespace with variables (sometimes called a "lisp-1"), so that you can't have a function named `foo` and a variable named `foo` at the same time, whereas a lisp-2 (CL or emacs lisp) allows it. For example, CL vs. Scheme: ;; sbcl REPL * (defun foo (x) (* 2 x)) FOO * (set 'foo (lambda (x) (* 10 x))) #&lt;FUNCTION (LAMBDA (X)) {1001E70BBB}&gt; * (foo 10) 20 ;; Gambit Scheme REPL (gsi) &gt; (define (foo x) (* 2 x)) &gt; (define foo (lambda (x) (* 10 x))) &gt; (foo 10) 100 With CL, if you want to call the second `foo` definition, you have to use `(funcall foo 10)` (or use `apply`). If you aren't doing functional programming it's not something that will matter much, but Scheme's shared namespace seems more natural when using higher-order functions, in my opinion. A trivial example that hopefully illustrates what I mean: ;; Gambit Scheme REPL (gsi) &gt; (define (greeter g) (lambda (s) (println g " " s "!"))) &gt; (define hello (greeter "Hello,")) &gt; (hello "world") Hello, world! &gt; (hello "everybody") Hello, everybody! &gt; ((greeter "Hi") "all") Hi all! &gt; Ideally, I want to make AI so, any Lisp derived dialect you could recommend that suits that Something you might want to consider, not just for AI but in general, is looking into lisp dialects that piggyback onto existing languages/platforms and can utilise their ecosystems. For example, if you're interested in working with TensorFlow for machine learning, it has strong support for Python especially, so you could use [Hy](https://github.com/hylang/hy), a lisp dialect for Python. Clojure's a possibility if you need to interact with .NET (ClojureCLR), JavaScript (ClojureScript), or the Java (Clojure) ecosystems. If the Erlang VM seems like a good solution to a problem, there's two options: [Clojerl](https://github.com/jfacorro/clojerl) (Clojure on BEAM) or [Lisp Flavoured Erlang](http://lfe.io/) (more CL-inspired). There's even [a lisp dialect for Lua, called Urn](https://github.com/SquidDev/urn) that's pretty nice if you have to work with Lua for some reason, such as an application (or game) that embeds Lua. Maybe look into where modern AI work is being done, and see if there's a lisp that can interact with that language/platform well.
Please use the capitalized word 'Lisp' and not 'lisp'.
Magit! Absolutely essential for programming in any language. I don't really use any extensions for editing Lisp code specifically, vanilla Emacs is just fine for that. I do have a keyboard macro for copy-sexp though (bound to C-x c): (fset 'copy-sexp [?\C-\M- ?\M-w]) (global-set-key [24 99] 'copy-sexp)
Care to explain why it matters? Normally "Lisp", written as a proper noun, seems to be assumed to refer specifically to Common Lisp or its ancestry, which usually isn't what I intend. So, when I refer to the *language family* (including Scheme dialects) in some way, I use lowercase as in my comment, and I started doing this specifically because of the arguments that always seem to crop up when someone uses "Lisp" to refer to anything but Common Lisp. People seem to understand the distinction well enough, so what's the problem? (I'm also an unrepentant user of "Linux" when I really mean "GNU/Linux".) 
Writing 'lisp' does not make clearer what you intend to say. It just looks like you want to use the verb 'lisp'. If you explicitly want to address the wider Lisp family and want to avoid confusion, just write 'Lisp family'. Writing Scheme for R7RS Scheme (or whatever dialect one considers the current most Scheme) and 'scheme' for the collection of R4RS/R5RS/R6RS/R7RS small/R7RS large/IEEE Scheme/Racket/T/Stalin/SICP Scheme, ... variants of Scheme doesn't look useful either. It's kind of strange to lowercase a word and implying that this widens its meaning.
&gt; minor incompatible change: the CLOBBER-IT restart for defstruct redefintion has been removed after a 15 year deprecation cycle. &gt; a 15 year deprecation cycle I'm lovin' it
Is there a CL library supporting a variant of this?
I sometimes use helm-slime (https://github.com/emacs-helm/helm-slime) for an helm slime history, when M-p isn't enough (discovered not long ago that we can type text and M-p instead of M-r). Otherwise, you give great tips here, I encourage you to contribute to wikis :) either in the cookbook: https://github.com/LispCookbook/cl-cookbook (we could add a slime section in the Editors support page), and/or in http://wikemacs.org/wiki/Common_Lisp
nice example. Alexandria defines `curry` functions, but we still have to use `funcall`. What if it defined something like `defcurry` with no need to funcall (by a `setf` of `symbol-function`), like this: https://stackoverflow.com/a/46003156/1506338 ? This pattern doesn't seem to be much used in CL.
I read a nice little list here: https://www.reddit.com/r/lisp/comments/6w44ay/moving_away_from_common_lisp_kind_of/dm5atur/ Also, if you're new to CL be sure not to miss my favourite CL resources: - http://lisp-lang.org/ - https://github.com/CodyReichert/awesome-cl - https://lispcookbook.github.io/cl-cookbook/ - and http://weitz.de/cl-recipes/
I wrote a blog post where I wanted to show the difference with namespaces, and used some macros to improve the readability. Maybe not the best solution, but it was my approach for [that post](http://funlisp.blogspot.com/2017/07/licstart-following-is-entire-license.html?m=1). edit: forgot to link the post. 
Personally I don't see much win of (defcurry 'add2 #'adder 2) over (defun add2 (a) (adder 2 a)) The latter has the advantage of less quoting, an explicit arglist, not being a closure, not using &amp;rest arguments, being declared in a compile time environment, having its location recorded, having its source recorded and being simpler to inline by a compiler. 
No warning for DEFMETHOD without DEFGENERIC. I approve.
I actually enjoyed that warning because it told me that either I forgot to call DEFGENERIC for a generic function I wanted to create or - worse - I had a typo somewhere in my code.
OMG you are so right. Why was I looking for difficulty ? Thanks !
Oh there are arguments for it, I will admit (putting :documentation on the function; being able to use defgeneric to avoid undefined function warnings during compilation, for example.) All the warnings from some existing libraries are just annoying though.
Asdf should load libraries with muffle-warnings, perhaps. 
One difference that is often glossed over is that Common Lisp's forms have a well-defined evaluation order (in almost all respects, see below) and well-defined result value(s). For example, a CL function call form `(f x y z)` is required to evaluate the `x`, `y` and `z` forms in left to right order. If these contain side effects or function calls, we know how they will be ordered. There is only a minor looseness here. In the case where `f` is being resolved in the global namespace, rather than naming a lexical function) it is not specified whether the function cell of symbol `f` is accessed before the argument evaluations or after. So if the arguments produce side effects which influence the `f` binding, things are ambiguous. In Scheme, function argument evaluation order is not specified. Moreover, some imperative forms have unspecified result values (so it is basically undefined behavior to rely on their values). An example of this is the `do` loop which appears in Lisp and Scheme. In Lisp, if `do` lacks a result form, then the result value is `nil`. In Scheme, in this situation, the result value is left unspecified. (There is another difference: the Scheme `do` loop creates fresh bindings for the iteration variables prior to each iteration, whereas in Common Lisp, the requirement is that they be updated by assignment. If a lexical closure is captured in a *do* loop in Scheme, it will capture only that iteration's variables; in Lisp, the code will capture the one and only set of variables scoped over all the iterations.) 
Pick one and learn it; it's not super important which one. The macro systems are very different; I prefer CL's, but I can understand those who like Scheme's better. CL has a really good OO system, each scheme kind of implements its own. Scheme has continuations, which let you implement essentially any control structure you want. CL has a slightly richer set of control flow options built-in, but I occasionally miss `call/cc`. Individual Scheme implementations each have some features that are unique to them; this is slightly true of CL, but for scheme is very much more the case.
A lot of it comes down to personal preferences. Relevant discussion: http://fare.livejournal.com/188429.html In my opinion, CL has more "production" features, Racket has the best academic community, ECL has the best C and Qt integration, etc. I understand the arguments for pure macros and functional programming, I prefer the simple power of CL's macros and impurity, and I hope people come up with a more usable and powerful replacement for all current macro/template/monad techniques. Find what you want to write, pick a language, spend a couple weeks to months trying implement your program. Reflect on how it is going. Push forward or try another language.
My escencials are SLIME, paredit, ac-slime (autocomplete), magit. I also find useful ace-window, and ace-jump, and for org mode I set org-src-fontify-natively to t, and ad lisp to the list of or-babel-load-languages, (I used lisp in lowercase because that how it is written in babel to denote the extension). An some times I use redshank-mode but not as frequetly.
The problem is, there are basically 3 "groups" of lisp-like languages: * The original Lisp family, generally Lisp-2 with closer (sometimes direct) connection to Lisp 1.5 * Scheme implementations * Everything else lisp-like that isn't one of the previous two "Scheme" works fine for the second group already, but the problem is that "Lisp" has come to mean any lisp-like language, while *also* meaning certain languages of that group with a *specific* ancestry. While I don't necessarily have a problem with calling *anything* lisp-like "Lisp", it's prone to confusion because of its association with a specific subset of Lisp-like languages. It's also somewhat unfair to take "Lisp" away from those languages, just like it would be equally unfair to refer to dialects like Clojure as "Scheme"; despite Scheme's influence, they're completely different languages. Using "Lisp dialect" to refer to *any* of the three groups is clear enough, and is a good approach for formal writing, but it's clunky for informal writing like here, so I take the "generic" approach of "Lisp" being a name, and "lisp" being a wider category. Like how Kleenex, capitalised, refers to a specific brand, but informally, people often refer to "kleenex" to mean any sort of similar tissue. Sure, it's not perfectly accurate, but this is a chat medium, not a research paper or book to be published, and I'm talking to human beings, not compilers. Maybe I'm giving people too much credit, but I expect most will have sufficient mental capacity to infer from the context — a discussion about programming — that I'm referring to the language family rather than a speech impediment. &gt; It's kind of strange to lowercase a word and implying that this widens its meaning. Just wanted to address this separately from the rest of the comment. I'm not sure why you think that's strange at all, considering it's a common thing, especially in English. As I said above, "Kleenex" is a specific, trademarked brand, but people sometimes refer to "kleenex" for any facial tissue, which has a wider meaning than the proper noun. Likewise for "Xerox" the company vs. using "xerox" as a verb to mean photocopy, and "Google" vs. using "google" to mean "search the internet", sometimes with Google, sometimes other engines. For a more regional example, "Coke", as a proper noun, refers to "Coca-Cola", a specific soft drink, but in the southeast US, "coke" in a generic form means *any carbonated beverage*, including Dr. Pepper, Sprite, Sierra Mist, or even Pepsi. Its meaning is *greatly* widened when used generically instead of as a proper noun. If anything, it's stranger that you haven't encountered this behaviour in the real world before, because it's everywhere. 
&gt; The problem is, there are basically 3 "groups" There is no 'problem' and the 3 groups are made up by you. Other will define more dialect groups (see https://en.m.wikipedia.org/wiki/Lisp_(programming_language) or http://www.softwarepreservation.org/projects/LISP ) and lots of other ways to split up the Lisp family (US vs. international, compiled vs. interpreted vs. both, lexical vs. dynamic, s-expressions vs. no algebraic syntax, east coast vs. west coast, by involved persons, ...). See for example: http://www.dreamsongs.com/Files/Hopl2Slides.pdf &gt; behaviour in the real world 'lisp' is made up by you and is not behaviour in the real world. The lowercase 'lisp' exists already and means something else, both as a verb and noun. The smaller 'coke' has a very specific meaning as has xerox, based on actual things people do or use. The 'lisp' you claim has no meaning in the real world. Lisp or old-fashioned LISP is used to mean the 'programming language Lisp', lisp is the speech defect ('he has a lisp', 'does she lisp?'). The dictionary entry for Coke and Xerox says 'sometimes lowercase' for your cited meanings. The WikiTextBot confirms Lisp and LISP as established ways to address the Lisp family. ;-)
Non-Mobile link: https://en.wikipedia.org/wiki/Lisp_(programming_language) *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^108028
**Lisp (programming language)** Lisp (historically, LISP) is a family of computer programming languages with a long history and a distinctive, fully parenthesized prefix notation. Originally specified in 1958, Lisp is the second-oldest high-level programming language in widespread use today. Only Fortran is older, by one year. Lisp has changed since its early days, and many dialects have existed over its history. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
The most useful configuration is the keybindings I've setup for evil-mode+paredit: http://paste.lisp.org/display/335018 I've seen other evil-mode setups for lisp, but I find these keys to be really comfortable to use for all sorts of lisp-editing tasks. Also, I think people overlook paredit-convolute-sexp: it's surprisingly useful when you want to wrap an inner sexp around it's parent, although it's documentation is pretty horrible.
Any color themes (especially dark ones) people like? edit: I change it a lot but here are some that I use: * afternoon * base16-solarized-dark * naquadah * ahungry * ample-zen * deeper-blue
A change introducing a warning that is only sometimes relevant would have never been approved nowadays. Yes, too bad the intent can't be determined.
I have the w3m browser installed and use the package emacs-w3m. I have a local copy of the hyperspec and direct c-c c-d h (hyperspec lookup) there. I also created other documentation lookups for quickdocs and others: see the following [gist](https://gist.github.com/aarvid/6250845) the quickdocs one is especially useful to looking at quicklisp library documentation within emacs. edit: this [gist](https://gist.github.com/aarvid/46644bf304f01f130c990b035c8b513a) also helps with hyperspec lookup as it opens in another buffer and allows the key q to quit and go back to the code. 
https://stackoverflow.com/questions/3345397/how-is-racket-different-from-scheme there is one more for me to look up ... **edit** [Dan Grossman - 1. Introduction to Racket @2:22](https://youtu.be/vKjOTdVi99A?t=2m22s) &gt; Racket has made some non-compatible changes. The ones you are most likely to notice are related to how lists are used and in particular that, like in ML, **list elements are not mutable**. Also: * https://racket-lang.org/new-name.html * https://www.quora.com/How-are-Racket-and-Scheme-different-from-each-other Apparently it is possible to configure Racket for doing SICP: http://www.neilvandyke.org/racket/sicp/
Being elegant doesn't mean it is easier to write code in it, though.
Oh yes I know, I just wanted to start a discussion on the people's opinion on their view of the most elegant lisp dialect. :P
I really like the definition of EuLisp. It brings best of both Scheme and Common Lisp.
I've written code in Scheme, elisp, dabbled in common lisp and Clojure. By far I prefer Clojure. Superficially, to me it has better syntax with fewer parens and better structure with the use of [] and {}. I also think there are lot of elegant built-in fn's and macros, such as the threading macro (-&gt; and -&gt;&gt;). I also think it has one of the best package managers in lein. Of all the various programming langauge package managers I've used, it is by far the most solid and everything almost always just works by simply adding the library as a single line to your config file (project.clj). This in comparison to pip and gem which is a matter of crossing your fingers and hoping things work without dependency collisions. tbh, all of the lisp package managers are very nice, so maybe this isn't even a fair point to bring up.
There's an argument to be made that the technical differences don't matter. Even if two languages start in the same place, the distinct user and implementor communities ensure that they will drift apart and become more and more distinct. See e.g. "Lambda, the Ultimate Political Party" by Kent Pitman: http://www.nhplace.com/kent/PS/Lambda.html 
that was R4RS
yes! though I'm quite the rebel, I liked R6RS 
R6RS I followed close. It was turbulent. can't even imagine how R7RS is going... all with a minor and major language split...
My life has taken me away from Lisp. Sorry to say, but its true.
_My life has taken_ _Me away from Lisp. Sorry_ _To say, but its true._ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^tealeg ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
[ and ]
like piano, povray or text-adventures, one of my life-long, on-and-off hobbies :)
How about PicoLisp? Everything is a cons! That strikes me as pretty elegant. I haven't actually used it, but when did that ever stop anybody from holding forth on Lisp before?
I'd lean heavily towards Kernel, but I also see different sorts of elegence in all of what Fogus calls [Fluchtpunkt lisps](http://blog.fogus.me/2011/05/03/the-german-school-of-lisp-2/)
Funny I just found this https://franz.com/support/documentation/8.1/doc/basic-lisp-techniques.pdf Franz tech for CL including Emacs tips.
Kudos to all the team.
I don't know about Lisp dialects, but clearly I am the most elegant on this thread :-D 
Does it show the marked sexp ? Nice tweak nonetheless.
Immutable pairs are standard in R6RS; they are not an huge difference between modern Scheme and Racket: http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-18.html 
I can't stand the amount of [..] in clojure. Almost everything in clojure in a good idea, a well founded one. I have no real argument beside the fact that I love round parens most of the time.
I don't know if it was EuLisp or LeLisp .. but I read a book from Emmanuel Saint-James and I liked the choice of keywords. I think they didn't call macros as such, they were named "doubly recursive evals".
The kitchen-sink approach for R6RS was, IMHO, a mistake. The R6RS library syntax was probably the most important feature, but the rest was too much.
library syntax was so important that pretty much everyone continue with their own LOL
Think we can get a good flamewar going over whether elegance is in inverse proportion to the number of paren types or not?
Good material for sure. Now who's gonna start the combustion..
the higher-level api of croatoan is just sugar on top of the low-level ncurses api. the low-level api is always there in a separate package, its use is just not preferable because most functions have fancy names like "mvwinwchnstr" and you have to manually juggle pointers and translate back and forth to C structs. once the high-level sugar wrapper is somewhat stable, you should not really need to ever directly access the low-level api, at least that is what I'd like to avoid in my own projects.
An elegant dialect of Lisp is TXR Lisp. I made it myself, so my opinion is very biased; but it's not of course I wouldn't design something which is not elegant. The notion of elegance I'm apply here is that programs to solve various common tasks are short (measuring by number of cells in the source code tree structure) and relatively free of noise. So that is to say, elegant code; not necessarily an elegant specification of language. Hey, a [TXR Lisp answer](https://unix.stackexchange.com/questions/131117/is-it-possible-to-view-unicode-text-in-tcpdump-capture-output) was accepted on the Unix Stackexchange today. It was given in July to a question posted in 2014.
cl-charms and cl-ncurses were abandoned when I started playing with ncurses. So in a sense croatoan is my improved version of cl-charms/cl-ncurses, except that I rewrote everything from scratch to learn how cffi works.
:-]
No idea about the big R7RS, but I find R7RS Small very nice and elegant.
Racket is building an ecosystem that extends beyond traditional Scheme. So Racket implements Scheme, and Racket includes other stuff too. https://racket-lang.org/new-name.html
[:-]
&gt;The best way to use the HyperSpec is to use Google to search for No! It's "C-c C-d h" in Emacs.
See, I didn't even know about that -- thank you!
PicoLisp only. https://bitbucket.org/mihailp/tankfeeder/src
in LispWorks: c-sh-d or menu 'expression' &gt; 'manual entry'. It's usual that in an editor you can go to a symbol and then display the arglist, the documentation string, find the documentation in a manual, inspect it, find the sources, find similar symbols, find the users, ... via menu/entries or keyboard commands.
[o]
&gt; Because it has a github repository Why is that important to CL newcomers? &gt; The joke is that everybody wants to try Common Lisp until they hear you have to install emacs Sorry you don't like Emacs. I understand that people like Vim or Atom, or Nano better for their own reasons. 
&gt; Why is that important to CL newcomers? Github, I don't know, but what is attractive is a modern repo (sourceforge or an ftp are not attractive) and an open one (one must ask for an account by email on the gitlab of common-lisp.net, it took me 2 months to get an answer (bad luck, but still) and thus the repositories looks dead: no activity, no questions, no "+1").
Great write-up, keep it up ! &gt; If you don’t really care where you put your code, just put it in directories under ~/common-lisp/ in your home directory, and ASDF will find it. I believe it is in `quicklisp/local-projects/`. &gt; if you add new .asd files or systems, you need to reset ASDF. really ? I don't recall I needed this. I just tried: cloned a library in local-projects, loaded it and visited its source (M-.), it got me to the local-project source. Also, to load new systems located anywhere, like the project I'm working on, it appears I compile the asd (C-c C-k) and I can quickload it or (asdf:make-project …) on the repl. the awesome-cl is quite curated, only more updated than the blog post :) You don't want to link to the cookbook ? :( https://lispcookbook.github.io/cl-cookbook/ in which, btw, you are welcome to add stuff in a "getting started" section :) So, nice article, more will be welcome ! :) Funny, I also wrote something yesterday: (in french) https://matutine.gitlab.io/2017/09/04/les-promesses-de-common-lisp.html (promising CL and Python's limitations) 
Thank you so much for writing and sharing this. It is a very valuable reference for those of us getting into CL. 
About creating a project: you use Quickproject and I find [cl-project](https://github.com/fukamachi/cl-project) more complete since it also creates test skeletons (with Prove) (all fukamashiware).
I really like how scheme is laid out. A few well-chosen primitives that compose well and can be used easily to create more advanced or specialised functions. The only wart is call/cc (instead of delimited continuations),but now guile and scheme48 had them, so hopefully they will become common.
yeah, R7RS small might well be called R4RS ;-)
Actually `~/common-lisp/` is correct for ASDF. [See documentation](https://common-lisp.net/project/asdf/asdf/Configuring-ASDF-to-find-your-systems.html). You can also setup it to search in any other directory. `~/quicklisp/local-projects` is Quicklisp's own setting. I mostly use it for my forks of Quicklisp-sourced projects, and `~/lisp` for my own projects.
It's not hate for Emacs, but lazyness to learn a complex editor along with something already challenging. You want to do just one thing at a time ideally, keep it simple, etc. Being a Vim user I tried using Spacemacs for CL development. To my surprise, it "just worked"! So I'm quite happy with it. 
&gt;&gt; Because it has a github repository &gt; Why is that important to CL newcomers? Because most open source developers already have a github account -- I don't have a common-lisp.net account, because I couldn't figure out how to create one. (I haven't run across another website in 20+ years that requires sending an email to request an account. That one also asked me to fax something.) And, github has two sets of killer features: code search, which I use frequently to find examples of an API I'm having trouble understanding, and issues/code reviews/forks, which make contributions to a project very easy. Code search is incredibly handy, because you can search *all* repositories, or just a particular one, without cloning the darned thing. &gt; Sorry you don't like Emacs. I love emacs, use it daily, use org-mode and erc, but a lot of people born after 1990 don't.
Good job!
Thanks.
I though R6RS [blessed](http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-7.html#node_sec_4.3) square [brackets](http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-19.html#node_chap_E).
Ah, good to know. I am using r5rs at work and haven't kept up.
Ah :) I haven't been around that long and have mainly been using an "extended R5RS" aka Chicken. And as much as I love Clojure for the convenient stuff it brings in, I admire the elegant, "minimalistic" (if that's the right word) Scheme. The only thing I really miss in Chicken is a decent UI toolkit à la JavaFX...
&gt; he best way to use the HyperSpec is to use Google to search for I dont agree, I believe if on Mac try to install Kapeli's Dash and use it for search. Also SBCL is too much for beginner; I find Clozure CL is much more newbie-friendly; also there is LispWorks Personal to try CL out and play around it.
I hope it helps! Let me know if you run into any hiccups and I'll try to help if time permits, or correct my post. 
Great! Is there a way to get the HyperSpec displaying contents inside Emacs and not on the default browser? Thanks! 
In linux, you install the package w3m. then load emacs-w3m.el (I just noticed melpa has a w3m package of emacs-w3m so that should work.) this is bits of code from my .emacs: (setq common-lisp-hyperspec-root "/path/to/local/HyperSpec/") (add-to-list 'load-path "~/.emacs.d/emacs-w3m") (require 'w3m-load) (setq w3m-use-cookies t) (setq browse-url-browser-function 'w3m-browse-url) (autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t) ;; optional keyboard short-cut (global-set-key "\C-xm" 'browse-url-at-point) this [gist](https://gist.github.com/aarvid/46644bf304f01f130c990b035c8b513a) also helps with hyperspec lookup as it opens in another buffer and allows the key q to quit and go back to the code.
if you want to avoid quicklisp local-projects and use multiple directories, you can set up `~/.config/common-lisp/source-registry.conf` with the following: (:source-registry (:tree ("/path" "to" "my" "projects")) (:tree ("/path" "to" "my" "forks")) :inherit-configuration)
I'm no expert by any means. But for me: scheme's continuations, and cl's conditions/restarts/signals.
Thanks. The w3m package I found for emacs does not have w3m-load.el though... 
my setup is about 10 years old and I really have not changed it since. here is a more recent blog using emacs package w3m: [http://beatofthegeek.com/2014/02/my-setup-for-using-emacs-as-web-browser.html](http://beatofthegeek.com/2014/02/my-setup-for-using-emacs-as-web-browser.html) 
[/r/AutoCAD/](https://www.reddit.com/r/AutoCAD/) might be able to help better.
Anyone doing this, consider using Arcadia if you want to use Unity. Arcadia let's you make your game in Clojure. 
Looks great but the documentation could be better (presentation of its features and shortcomings, how it was built,…).
Is there any "recent" curated list with game libraries for the different Lisps and platforms (win/linux/...) ? Thanks. EDIT: Answering myself. It seems that in the lispgames wiki there are lists.
Game jam organizer here. Consider joining #lispgames on Freenode IRC. There are some folks such as borodust there that have nice engines and frameworks, and you can get help directly from the authors in preparation for the jam.
Wow, ECL's FFI is really nice, thank you for highlighting it. Gambit, my own preferred workhorse language, is very similar in allowing you to directly inline C code (by the look of it the basics of the FFI are pretty much the same). I think it's really one of the under-appreciated killer features of *explicitly* C-based language implementations that they let you do this. Having totally free-form access to external libraries without having to jump through hoops is both an incredible timesaver, and a boon to design since you have much more flexibility in how you expose the API.
Yes, I agreed. Actually, when I wrote that, I made a simple post on my personal blog: http://manoel.tk/lisp-chat/ (I forgot to link it on the main repository page and now is fixed) But in general I need yet to write proper docs.
and that's an informative and funny little post, thanks :) (please be different than other Lisp authors and do write doc :D )
Wow, everything is so fast!
Note that GNU Emacs is a Lisp machine *emulator* though.
How is it done? Is it just Climacs?
Oh yeah! Sexy!
The windows manager is Stumpwmp (common lisp), he is switching back and forth between clim and a few other apps, all apparently lisp apps. There is a bunch of us that use Stumpwm as the windows manager (with no toolbars or other kiddie toy addons for newbs to let them find apps on their system) + a few keystroke oriented apps that mimics Lisp machine behaviour in a very very crude way. With the work happening on mcclim, bit by bit, the Lisp machine experience is being recreated. Mcclim updates will be a huge step in that direction. ** correction The web browser is conkeror, so not a lisp application but it is keyboard driven. If we can get someone to fix up Lispkit that could be replaced. He is opening up a bunch of Algol group of applications from either the window manager of different applications like Dired as well. 
Uhhhh wooow :D
I'm working on another project called next-browser which is built 100% with Common Lisp: https://github.com/nEXT-Browser/nEXT It is cross platform compatible (anything that can run QT can run nEXT), and it has a lot of cool features in the pipeline very alphay stage right now, can just make and switch between buffers, but a lot of the groundwork has been laid and it's progressing rapidly
Here is his GitHub. Mezzano. Been working on it for a long time, he has. https://github.com/froggey/Mezzano
That looks great. Will be checking it out soon. Don't care that it is alpha stage, thank you for your contribution. I greatly appreciate it.
thank you for the support! :)
This is not Mezzano, it's a separate project based on Linux.
Are there THAT many differences in C and C++ for them to be considered different programming languages?
Would love to know more then...
https://github.com/gabriel-laddel/masamune
I didn't see emacs being used there except for debugging the debugger though.
If this helps, this demo is just unix like system running stumpwm window manager. Everything else are normal applications like: * masamune * climacs * conkeror * mcclim demo ... etc. He is switching between apps really quickly with shortcuts and splitting the stumpwm window with shortcuts as well. He is also splitting windows and sub panes in a lot of the software that he is using and it is hard to tell which one is which because the video is sped up a little bit. What he is really getting at here is that a lot of the functionality from Lisp environments of the past is being replicated. The most interesting points being (to me anyway) that lisp allows the creating of applications that can be recompiled on the fly without a restart and all of the interesting productivity and workflow changes you get as a result. However, at the heart of this is a unix system with a lisp userland on top. Ideally, we would have all of our apps built on lisp. As a side note, Mezzano is amazing and froggey is a genious. This demo is really great too.
xD yes, almost no one write proper docs. (sometimes not even a README is provided).
I'm very excited to see where this goes, and will be playing around with this with my next available free time...
Lord knows.
Related: Kent Pitman's notes on equality in CL. http://www.nhplace.com/kent/PS/EQUAL.html
The thought that *string-equal* would not distinguish case seems pretty weird. Emacs Lisp: ELISP&gt; (equalp "hello" "HELLO") *** Eval error *** Symbol’s function definition is void: equalp ELISP&gt; (equal "hello" "HELLO") nil ELISP&gt; (string= "hello" "HELLO") nil ELISP&gt; (string-equal "hello" "HELLO") nil ELISP&gt; Guile Scheme: scheme@(guile-user)&gt; (equalp "hello" "HELLO") ;;; &lt;stdin&gt;:19:0: warning: possibly unbound variable `equalp' &lt;unnamed port&gt;:19:0: In procedure #&lt;procedure 555bcea6a7c0 at &lt;current input&gt;:19:0 ()&gt;: &lt;unnamed port&gt;:19:0: In procedure module-lookup: Unbound variable: equalp Entering a new prompt. Type `,bt' for a backtrace or `,q' to continue. scheme@(guile-user) [1]&gt; ,q scheme@(guile-user)&gt; (equal "hello" "HELLO") ;;; &lt;stdin&gt;:24:0: warning: possibly unbound variable `equal' &lt;unnamed port&gt;:24:0: In procedure #&lt;procedure 555bceaacf00 at &lt;current input&gt;:24:0 ()&gt;: &lt;unnamed port&gt;:24:0: In procedure module-lookup: Unbound variable: equal Entering a new prompt. Type `,bt' for a backtrace or `,q' to continue. scheme@(guile-user) [1]&gt; ,q scheme@(guile-user)&gt; (string= "hello" "HELLO") $2 = #f scheme@(guile-user)&gt; (string-equal "hello" "HELLO") ;;; &lt;stdin&gt;:32:0: warning: possibly unbound variable `string-equal' &lt;unnamed port&gt;:32:0: In procedure #&lt;procedure 555bce6f9820 at &lt;current input&gt;:32:0 ()&gt;: &lt;unnamed port&gt;:32:0: In procedure module-lookup: Unbound variable: string-equal Entering a new prompt. Type `,bt' for a backtrace or `,q' to continue. scheme@(guile-user) [1]&gt; ,q 
In Emacs Lisp string-equal just is another name for string=. What's really *weird* is that characters are numbers in Emacs Lisp.
&gt; symbols in Common Lisp are by default NOT case sensitive Symbols are case sensitive. Their symbol-name stores the name as it is. The reader is case insensitive by default. If you enter an escaped symbol, then the case is preserved during read. Escaped symbols: ? '|bBbB| |bBbB| ? (intern "bBbB") |bBbB| The default reader is case insensitive and upcases: ? (read-from-string "bBbB") BBBB Comparing symbols: ? (equal '|bBbB| '|BbBb|) NIL ? (equal 'bBbB 'BbBb) T FIND-SYMBOL is case sensitive, the reader by default not: ? (equal 'a 'A) T ? (equal (find-symbol "a") (find-symbol "A")) NIL &gt; like two variables with the same number assigned to them EQL does not do or know anything about variables. EQL adds to EQ the equality of numbers and characters, to pointer equality. &gt; But who knows if string=, string-equal, and equal will work consistently with Unicode strings? This depends on the implementation, since the ANSI CL standard knows nothing about Unicode. That's one of the places where a standard update would be useful, but possibly also complex. 
That's what characters are to the computer anyway. The fact that your display driver decides to render some numbers as alphabetic symbols isn't important to the computer. I don't know what rms had in mind, but imagine in 1983 not making a higher level abstraction for a *character* datum was an obvious optimization. 
&gt; 1983 not making a higher level abstraction for a character datum was an obvious optimization. It was what Maclisp did, which Emacs Lisp was based on. 
In Emacs Lisp the *character* one will be `?1` or `49`, and that's what gets stored in memory. The fact that you pressed a key with a 1 label which is displayed as that symbol is of little consequence. (There is actually some abstraction in between, but I don't need to know about it.)
In Javascript one would use '1', which is a string. In Java I would use either the primitive Char (or the Character class) with some character '1', R5RS uses character objects #\1, ... Since still humans program the computer using these languages, it might matter at what abstraction level we use the machine.
&gt; Since still humans program the computer using these languages, it might matter at what abstraction level we use the machine. Yes and no. The diverse hardware systems and deeply layered software stacks make abstraction much more important because you can't assume much about how the end product will be experienced by the user. I mean, just look at how shitty the web is because "web designers" make stupid assumptions. **edit** Looks like some "web designers" read /r/lisp.
You seem to be making the error of anthropomorphizing computers. Characters are not numbers to the computer: a computer has no concept of characters or numbers. Talking about what's "important to the computer" or not is yet another instance of the error. Abstractions are for humans.
I am a human and I am guilty of assuming I was addressing another human. Looking at your response and comparing it to my original comment, I see no value in engaging you further.
Anthropomorphization is common, but sometimes it leads to specious reasoning, this case included. Thank you for sharing your value judgment, I may take it into consideration in the future.
Symbols are case-oblivious. Two distinct symbols are different objects, not `eq`, **even one string instance is used as the name of both of them**. E.g. `(list (make-symbol s) (make-symbol s))`, `s` string-valued. The read/print notation of symbols, the **symbol tokens** are treated in various ways in both directions. The default setting in the reader is actually case sensitive treatment of names, but with **case folding** of **unescaped** letters. So `fo\o`, `|FOo|` and `fo|o|` all give rise to the symbol name `"FOo"`, whereas plain `foo` produces `"FOO"`.
I cleaned this up in TXR Lisp. There are no `string-` equality functions at all. `equalp` doesn't exist. `equal` compares strings case sensitively and the same way whether it is recursing or direct. `equal` basically adds (non-cycle-detecting) recursion to `eql`. There is `=` for numbers, so that `(= 1.0 1)` is `t`. `equal` compares structs member for member. The basic, meat and potatotes OOP system is based on structs, with dumb single-dispatch and single inheritance. Custom equality for objects is achieved with a concept I dubbed *equality substitution*. A struct type can have an [`equal` method](http://www.nongnu.org/txr/txr-manpage.html#N-00790C76). This doesn't take any arguments other than the object; it does not compare two things. Rather, it calculates a representative token value (the equality substitute) for the object in question. Then that object is used by `equal`. Example: let's make a `widget` class with a `name` property, compared case insensitively: 1&gt; (defstruct widget nil name (:method equal (me) (upcase-str me.name))) #&lt;struct-type widget&gt; 2&gt; (equal (new widget name "foo") (new widget name "FOO")) t Also: 3&gt; (hash-equal (new widget name "foo")) 19263 4&gt; (hash-equal (new widget name "foO")) 19263 Thus these objects work in `equal` based hash tables. `upcase-str` doesn't react to any locale environment variables; its behavior is fixed to recognizing only the English alphabet. An object doesn't have to recalculate the equality substitute all the time; it can be cached. TXR Lisp helps supports caching tricks in the object system by featuring an inherent ["dirty flag"](http://www.nongnu.org/txr/txr-manpage.html#N-035A698D) in all struct instances. It is meta-data, not a slot. An object is marked dirty when it is newly created and whenever any slot is altered. Thus any method which calculates a dependent property can check the dirty flag to see whether the cached value is still valid. It's not ideal, since the dirty flag (currently) covers all slots unconditionally, but it works okay for rarely modified objects.
In TXR Lisp, characters are not numbers (that would almost completely stupid in a dynamic language in which objects know their type), but certain numeric and bitwise operations are allowed on characters without forcing the programmer to clutter the code with irksome two-way conversions: 1&gt; (- #\b #\a) 1 2&gt; (+ #\b #\a) ** +: invalid operands #\b #\a ** during evaluation at expr-2:1 of form (+ #\b #\a) 3&gt; (bit #\b 0) nil 4&gt; (bit #\a 0) t 5&gt; (logand #\c #xFE) #\b 
borodust folk here. I've just finised up writing `trivial-gamekit` initial [documentation](https://borodust.org/projects/trivial-gamekit/) with a little [Getting Started](https://borodust.org/projects/trivial-gamekit/getting-started/) guide. `trivial-gamekit` is quite new, a bit unstable and tolerates programming errors in not-so-much-friendly way. Feel free to report any problems you face with it to its GitHub [project](https://github.com/borodust/trivial-gamekit).
&gt; That's what characters are to the computer anyway Floating-point values are just 32 and 64 bit words; why not treat them as integers unless special floating-point operations are used? If you have dynamic typing with type tags and all, you already have a higher abstraction no matter what. What you can do is make characters and fixnums have almost the same representation so that when the type tag is stripped away, 65 and A are the same thing. That is the situation in NB (new B), the predecessor of C.
&gt; I see no value in engaging you further. To have a consistent line of argumentation, you should in fact see no value other than 0 or 1. :)
I really like Guile, but I always feel an internal struggle when having to choose it over CL (first love).
Lispers have always one too many choice.
There's no choice to be had! It's a simple `(or 'common-lisp 'scheme 'guile 'clojure ...)` that always returns its first true element. (And doesn't even evaluate the rest.)
Do you have a blog? I'd like to read more of your liking of Guile and how struggle to choose it over CL. :)
👏
&gt; EQL does not do or know anything about variables. EQL adds to EQ the equality of numbers and characters, to pointer equality. I thought I understood at least this part, but have a look at this: CL-USER&gt; (defvar a 1) A CL-USER&gt; (defvar b 1) B CL-USER&gt; (eql a b) T So far, so good, A and B are EQL because they're different variables but both have the same value. But obviously they wouldn't be EQ, right? CL-USER&gt; (eq a b) T I would assume that A and B are different pointers, and therefore be NOT EQ. But perhaps there is additional magic going on because the values are plain numbers?
A and B are not being compared; their contents are. `eq` is a **function**. The **argument expressions** `a` and `a` are reduced to their values. Those values are then passed as arguments to `eq`, which knows nothing about `a` and `b`. If we have `(let ((a 1) (b 1)) (eq a b))`, `eq` has no access to the lexical scope in which `a` and `b` have bindings. On your implementation 1 is `eq` to any other instance of 1; you have `(eq 1 1)`. 
unless that or is non deterministic you fool !
Uh, it's clear I've been over-thinking this. Of course the arguments are evaluated before being compared. Thanks.
You have not the right conceptual model of Lisp evaluation. You are thinking of some other calling scheme. It's really essential for Lisp programming to get that right. **Don't say 'a and b are EQL'. Say 'the value of a and the value of b are EQL'.** Alternatively: 'a and b have the same value'. SAME (without a predicate mentioned) in Lisp means EQL. See meaning 2 in http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#same &gt; indistinguishable by eql Also correct: 1 and 1 are EQL. Lisp evaluates the arguments. If we use (eql a b), then Lisp conceptionally does this: * looks at eql and sees that it is a not a special form and not a macro, but a function. * evaluates a to a value -&gt; 1 * evaluates b to a value -&gt; 2 * gets the function for eql -&gt; #&lt;function eql&gt; * calls the function object with the objects 1 and 2 as its arguments * eql does something * eql returns one value, a boolean Note that this is only conceptual. Lisp could also inline the definition of EQL in some code to get rid of the calling sequence and that particular overhead. EQL does not see where the objects as its arguments are coming from. It does not know about the variables A and B. Internally in some implementation the numbers 1 and 2 may be in a processor register and Lisp then calls the function EQL. In another implementation Lisp may have pushed 1 and 2 to the stack and calls EQL, which then pops them off the stack and pushes its result to a stack. Typically for example passing an array, a string, a function, a bignum, CLOS object, ... means passing a pointer to the heap. Numbers and characters have immediate ways to be stored, they can be directly stored in some data word. Thus two fixnum numbers of the same value might or might not be EQ, but they will always be EQL. Bignums OTOH usually will we always EQ, since there will only be one Bignum for each bignum number value on the heap. Lisp passes values or pointers to values, but not names or variable references. 
Thank you. Of course I understood Lisp calling conventions, though evidently not while I wrote that comment. I think one of the things that trips me up is the availability of both low-level and high-level equality functions, and their varying applicability based on the data type in question. Makes me feel I need to look up CLHS every time I do a comparison.
Have you read Henry Baker's paper on equalilty? http://home.pipeline.com/~hbaker1/ObjectIdentity.html This paper is the basis of Clojure's equality operators, but I can imagine that for a Clojurist it might be helpful for working "backward" toward an understanding of CL's idea of equality.
Thank you, quite interesting. I'm definitely more comfortable thinking in terms of immutable data structures in a call-by-value world, where it seems natural to me that two distinct structures that represent the same collection of values should be considered "equal," that I have a hard time internalizing different approaches.
Great stuff as always dude! Nice to see how cl-combinators bodge made this a fairly small project too.
Looks neat, I wish you the best. As a gamedev ignorant and CL enthousiast, I'd love some images, even better some gifs, and examples if/how we the interactivity takes place here :)
Thank you! Although `trivial-gamekit` is really just a `cl-bodge` under the covers. So it seems small only on the outside :D
That's exactly how [Getting Started](https://borodust.org/projects/trivial-gamekit/getting-started/) is written. When code snippets are put into REPL, you will see changes on the screen instantly! Except for resource importing, but that's another whole story.
Seems awesome, if I had a 64-bit system to try this on I definitely would!
I'm not sure, but I think the result of (eq 1 1) is unspecified: most lisp implementations probably intern small numbers so that there is only one `1` in a system, but I'm not sure that that behavior is required by the standard for all (any, maybe) numbers. 
(too earlyyy.........)
Good enough. Gives me motivation to keep on going and not be a lazy bum. I'm still working on my library for a proprietary graphics format for the game Furcadia, AND discussing the file formats and alternative rendering engines for Common Lisp UltraSpec.
would be very useful just for getting started with writing a visual interactive sim for scientific use. I wish this had been available when I did my bachelors.
Gerbil all the way!
This was my guess as well. And to smartly prove it, I decided to run: (loop for x = 1 then (1+ x) while (eq x x) finally (print x)) Only to find out that sbcl at least never returns nil.
Sbcl might intern every read number 
Ah yeah, that would make sense if it did it at read time. My guess was that it would do what python does which is only intern the first 100 or so. Hence why the is operator is screwy with numbers
I'm currently working on a simplified interface to SDL2. I want a library that will let me work at a really low level without being too big. It's not ready yet, but you can see the pre-alpha [here](https://github.com/chebert/ssdl). It's use case is pretty niche. One-window 2d drawing apps with an optional audio buffer and keyboard/mouse/joystick recognition. The idea is that it doesn't introduce any new types. The need for a library comes from just wanting an audio buffer. Next, I need to figure out how to bundle the shared libraries together for easy distribution. 
I think once every 2 weeks seems good. It's not like the expectation is that everyone is working on new projects. Could just give simple updates. Just my two cents.
On reflection, the numbers in your example aren't being read. 
I recently released TXR 185. In this release, I [fixed a five and a half year old bug](http://www.kylheku.com/cgit/txr/commit/?id=3270a9ec78b00feb885b65915d020e60dd712a58), and also rewrote the [hacky C implementation](http://www.kylheku.com/cgit/txr/tree/eval.c?id=7bc478a5c838c72c07097c8473c410dedecaa3d8#n3458) of the [op](http://www.nongnu.org/txr/txr-manpage.html#N-0068EA9D) macro [in Lisp](http://www.kylheku.com/cgit/txr/tree/share/txr/stdlib/op.tl). (The Lisp is a bit clunky, the reason being bootstrapping: the implementation of syntactic places and of the object system both use `op`, so we can't use their macros: no `set`, no `inc`, no `defstruct`, no `new`, no `obj.slot` access ...) In the prior release, among other things, I [ported TXR to the Aarch64 architecture](http://www.kylheku.com/cgit/txr/commit/?id=e31b1509ebb518548780aa2544459337854af48e) and then got delimited continuations working in a [follow-up commit](http://www.kylheku.com/cgit/txr/commit/?id=2399bf36c10ec9f7011008a76f96847be7255c9d). I was too busy to write about these in the prior "whatcha workin' on" thread. Currently, I've been working on several things for the next release. Among them: * Adding the inverse cumulative normal distribution function `inv-cum-norm`. I used the Odeh and Evans approximation dating back to 1974. * Added `poly` and `rpoly` functions for evaluating a polynomial from sequence of coefficients and domain value. * Added a cool visual feature to the Listener to address an annoying ambiguity. When the user hits Enter, sometimes nothing happens other than a newline being echoed (repeatedly if Enter is hit additional times). This is for one of two reasons: either the expression was accepted for evaluation and is busy calculating (possibly caught in an infinite loop) or waiting for input; or else, the expression is unbalanced and hasn't been accepted. These two cases are now distinguished as follows: if the expression has not been submitted due to being incomplete, the `!` (exclamation) character flashes twice at the cursor position. It says "I'm not running your code; you're still editing: fix it!". [Action GIF](https://imgur.com/0Cu9140).
Not really; I'm completely working on different things since the last thread. I get you though; it's not always like that. Just recently, in this year's April-May time frame, I worked for weeks and weeks on a FFI implementation for TXR Lisp. It took around 200 commits.
Don't anthropomorphize computers. They hate it when you do that.
Two problems with that: (1) SBCL may take a very long time to get out of fixnums. In a 64 bit SBCL, MOST-POSITIVE-FIXNUM is 4611686018427387903. Fixnums in SBCL are immediate; they are stored entirely in the 'pointer' with no memory allocation, and are EQ iff they are EQL. (2) And even if X becomes a BIGNUM, SBCL will not gratuitously copy it, so (EQ X X) is always true.
Yeah, on hindsight it wasn't a good idea. Specifically because I ran it on the swank server that stumpwm was running on. But it's interesting to learn even though I'll probably always just use eql/= for numbers.
Will [trivial-gamekit](https://github.com/borodust/trivial-gamekit) work for your case? Also, take a look at [cl-sdl2](https://github.com/lispgames/cl-sdl2) and [sdl2kit](https://github.com/lispgames/sdl2kit). [Here](https://borodust.org/delivering-common-lisp) you can find some tips on how to bundle shared libs with your library or app.
Well, as announced, I finally finished [Portacle](https://portacle.github.io) last week, after over a year of work on that. Next I believe I'm going to work on a rewrite of my CI system, [Autobuild](https://github.com/Shinmera/autobuild). The primary idea of the rewrite is to make things cleanly separated, and to allow machines to act as servers and clients respectively, so that builds can be coordinated from a single machine, while the others merely run them and collect results.
[removed]
I'm trying to port Python's os.path library which I really like to CL: https://github.com/fourier/pypath Almost finished with the Windows part (1 function is not working properly for now, working on it).
I just got started making a preliminary parser for my CLUS markup proposal, as a possible alternative to the ccldoc format /u/flaming_bird is investigating. I also have a Discord bot library on the back burner. 
Your library name is kinda confusing. [py.path](http://py.readthedocs.io/en/latest/path.html) and [os.path](https://docs.python.org/2/library/os.path.html) are not the same thing in Python (one could argue that py.path has more "lispy" interface, actually).
Yes, I see. It is based on os.path though as I said. It is called py path to emphasize what it is based on Python's path library; I will probably rename it later to just ppath or something similar.
I'm playing with web scraping in writing a library/app to search torrents on the Pirate Bay (and potentially other sources). I still need to explore some libraries (mocking, caching,…), learn some areas of the language, and I'm documenting my process in a tutorial.
Hi, I'd be very interested in seeing a (quick) comparison with existing libs :) I see you're defining a `getenv` function. You don't want uiop's `getenv` ? (https://lispcookbook.github.io/cl-cookbook/os.html) Also you are defining `empty?` and `concat` for strings. Maybe use and contribute on [cl-str](https://github.com/vindarel/cl-str) ? 
I'm currently working on a game engine that embeds Guile scheme. I was using Chibi scheme before, but the FFI for it was lacking, so I switched to Guile which has been superb so far. The features I've implemented are: vertex buffer creation and binding, shader compilation (with GLSL) and a bit of matrix math. If I have something worth showing in the next few weeks I'll be sure to post it here :D
I'm writing a module for stumpwm for restoring and saving Desktops. It saves and restores a stumpwm group (aka workspace) including its frame layout and window placement rules. It also offers autostart of programs associated with the group. A very poor mans hibernate if you will. The idea is that after you set up your frame layout and started / ordered your windows / programs you can save this configuration. And later you can recall the layout / group and it gets populated with the associated programs. Currently the recall mechanic works. Next step is to automate the saving part. 
I'm still working on nEXT browser, just released version 0.01 which includes fuzzy buffer switching https://github.com/nEXT-Browser/nEXT
I installed ECL (with roswell, you may add this solution into the readme), but stopped on the instructions to install EQL… too many manual steps, specially "edit eql5.pro and comment out all Qt modules you do not require".
I don't think so. What I need is to be able to write bytes directly to an audio buffer. I'm working on an emulator, so I am not working with wav or music files, and I'll need to do all of my own mixing. CL-SDL2 seems to have [punted](https://github.com/lispgames/cl-sdl2/blob/master/src/audio.lisp#L67) on this, so I wrote a very minimal wrapper around SDL, which does everything I need, and pretty much nothing else. (Also, I can't get SDL2 to load using quicklisp) Those tips on bundling are extremely helpful and exactly what I needed. Thanks so much!
I've been noodling around with making extensible environments objects. I'm pondering what I want the api to look like as implementing the cltl2 api, whilst cool, might be a bit gimmicky.
Congrats!
I am afraid that I can't control the manual dependencies, the eql author and I have worked to really simplify the installation process, the only other thing that could be simplified might be the generation of the wrapper code automagically in the meantime, on the roadmap for 0.02 is a standalone executable for OS X, not sure what I'll do about linux
If anyone is still interested, after getting feedback from here on possible solutions, I decided to check out the produced assembly. (defun dont-run () (loop for x = 1 then (1+ x) while (eq x x) finally (print x))) (disassemble 'dont-run) ; disassembly for DONT-RUN ; Size: 104 bytes. Origin: #x10041B582C ; 2C: 498B4C2460 MOV RCX, [R12+96] ; no-arg-parsing entry point ; tls: SB-VM::*BINDING-STACK-POINTER* ; 31: 48894DF8 MOV [RBP-8], RCX ; 35: B917001020 MOV ECX, 537919511 ; 3A: B902000000 MOV ECX, 2 ; 3F: EB23 JMP L1 ; 41: 660F1F840000000000 NOP ; 4A: 660F1F440000 NOP ; 50: L0: BF02000000 MOV EDI, 2 ; 55: 488BD1 MOV RDX, RCX ; 58: 41BBB0020020 MOV R11D, #x200002B0 ; GENERIC-+ ; 5E: 41FFD3 CALL R11 ; 61: 488BCA MOV RCX, RDX ; 64: L1: 4839C9 CMP RCX, RCX ; 67: 74E7 JEQ L0 ; 69: 488BD1 MOV RDX, RCX ; 6C: 488D4424F0 LEA RAX, [RSP-16] ; 71: 4883EC10 SUB RSP, 16 ; 75: B902000000 MOV ECX, 2 ; 7A: 488928 MOV [RAX], RBP ; 7D: 488BE8 MOV RBP, RAX ; 80: B838113920 MOV EAX, #x20391138 ; #&lt;FDEFN PRINT&gt; ; 85: FFD0 CALL RAX ; 87: BA17001020 MOV EDX, 537919511 ; 8C: 488BE5 MOV RSP, RBP ; 8F: F8 CLC ; 90: 5D POP RBP ; 91: C3 RET ; 92: CC10 BREAK 16 ; Invalid argument count trap In particular notice this line: ; 64: L1: 4839C9 CMP RCX, RCX the variable gets loaded into the same register and is then compared, so obviously it'll always return true and thus the loop never ends. Based on this, I decided to modify the function slightly: (defun dont-run-2 () (loop for x = 1 then (1+ x) for y = 1 then (1+ y) while (eq x y) finally (print x))) Which disassembles to this comparison instead: ; C8: L1: 4839F3 CMP RBX, RSI 
Talk to strandh on IRC.
Teaching my younger daughter Common Lisp. For a researcher, an experimental social network that uses text analysis to suggest to readers things to read and people to connect with. A new version of a data-storage application. Supporting tools for building a conlang (for the specific conlang; not general-purpose tools). The latest iteration of an experimental Lisp dialect. Various game-related experiments. 
will do. Cheers [edit] well now both he and I are wondering why you sent me to talk to him :)
TUI: an object-oriented text user interface, based on cl-charms/ncurses funge: an implementation of the esolanguge une/be/tri-funge toadstool: an emacs-like IDE for une/be/tri-funge using TUI various tools to analyze and categorize texts 
How old is your daughter and how is she taking to the language?
A little 2D game engine using SBCL, Parenscript and EaselJS :) Basically let's you use Lisp to make HTML5 browser games.
Is there a reason they use a pure shell based build approach?
Shell scripts are good at what they're made for: calling a lot of other applications and dealing with their results.
Haha, oops :D. No I just happened to know that he's done some related stuff with first-class envs with SICL (links: https://github.com/robert-strandh/SICL/blob/master/Papers/Environment-info/environment-info.tex , https://github.com/robert-strandh/SICL/blob/master/Papers/Global-environments/environments.tex ) Thank you for taking my advice, sorry for embarrassing you on IRC though :)
:p no worries. Thanks for the links, I really should read those.
And I bet we can have a portable and multiplaform Spacemacs, or Prelude ! 
I understand that EQL5 can be overwhelming for people who just want to quickly install it (author here). But it may appear more difficult than it is. Editing of `eql5.pro` is not strictly necessary, just try to build it from the defaults (you only need to make sure you have a Qt5 version which includes a pre-built QtWebKit). Feel free to contact me privately for any trouble you have (see email in repo).
Since January, sold nearly half a million online tickets with a 3-year old Lisp-based system. Then redeemed the tickets for gate and midway admissions at fairs and exhibitions across Canada with an 8-year old Lisp-based system. Managed the staff hiring, scheduling, and payroll with a 15-year old Lisp-based system. All back-room data manipulation and ad-hoc reporting done at the command line with Lisp. Around 800KLOC of Lisp in total.
She’ll be thirty years old in a couple of months. She’s picking it up rapidly.
maybe python-os.path. Well, in fact, I have an idea to port all stdlibs as well as numpy interface in python to common lisp. That way at least (the increasing number of) python users may be attracted... but I smell the reinvention of wheels. is there any similar project?
Nice!
Hi, I dont have a blog or anything where I can publish my findings. Basically the reason for me to start this library is what I'm not satisfied and confused with the existing pathname handling in CL standard; the existing libraries (cl-fad, uiop) don't provide enough functions for me or lacking some invariants which assumed in os.path library. As for library functions like getenv, empty and concat I will clear it up and replace with proper functions from uiop and probably clear all the utility library to get rid of own functions(or copy-pasted from examples from the cookbook). However I don't want to get a dependency on one more library (cl-str) if I only need 2 functions out of it and they are rather trivial one-liners. In my implementation of concat I've fixed issues with unicode on LW6.1 and LW7.0. Knowing how "abandoned" (lack of active support/development) state of CL libraries (like my patch to zlib was hanging for months), it makes it easier to just fix what I need in some support package.
I dont think it is necessary to port the whole stdlib to CL - a lot of the stuff is already there in different CL libraries. What important is to provide libraries which are well-documented, supported and convenient enough for a new user to start coding straight away to have the same productive feeling as they do working with Python. os.path for example for me personally is one of the missing bits I remember every time I need to perform any file paths-related operations in CL.
I was actually intending on publishing an article describing Trial's method, but my reviewers forgot to get back to me. Might just put it out regardless soon.
Wow, impressive! By lisp you mean common lisp or some other dialect? Can you share your experience on working on the lisp code base of this size and on actually doing production development? Any details are interesting.
I'm looking into ways of processing sound in common lisp. No previous knowledge on the topic, so I'm just investigating what can be done and how. So far I've managed to get an audio stream with cl-wav and play it with cl-portaudio. My plan is to be able to visualize this data and make sense out of it.
That would be great, I'm also happy to review it tonight if you like
hey thanks for the detailed answer. &gt; the existing libraries (cl-fad, uiop) don't provide enough functions for me or lacking some invariants which assumed in os.path library this, IMO (and only IMO) could be very well expanded a bit and added in the readme. &gt; I dont have a blog or anything where I can publish my findings and in case you want to write more (and yes do, I'm interested :) ) an easy solution is just to write in a gist and share it here. I also have a repo where I use issues to take notes and write posts (I don't care for the layout, it's for developpers).
Update to my android project: since the [Sokoban APK](http://lights-of-holiness.eu/tmp/sokoban.apk) ([screenshot](https://gitlab.com/eql/EQL5-Android/blob/master/screenshots/sokoban-repl.png)) is by far the most downloaded one, I made a new version which includes a very simple REPL (hidden by default). This simple REPL is of course capable of Quicklisp (just eval `(quicklisp)`). To prevent disappointments, the usual warnings: requires at least android 4.1, tested only on a tablet.
Baggers, thank you for doing this. I look forward to it every week!
\o/
If OpenAL API is enough for what you are doing, I can expose buffer streaming of it in `cl-bodge` and then you would be able to use it in `trivial-gamekit` along with its API for drawing. Feel free to ping me on `#lispgames` and we can figure out the rest. P.S.: `cl-bodge` (and `trivial-gamekit` consequently) uses `cl-openal` as a backend for audio
Congratulations!
Is this one of interest? https://github.com/pinterface/burgled-batteries
I do the accounting for my one-person contracting business using 610 lines of Lisp. It juggles transactions across nine accounts, keeps track of collected and receivable GST, deducts income tax and produces spiffy HTML + CSS + SVG invoices (for which 147 of those lines is template material, including the SVG logo). 164 lines are dedicated to implementing money math, using common arithmetic symbol names but in a separate package. 
looking at c/c++ implementations of webrtc datachannels and trying to go about creating an ffi for common lisp 
Thanks for suggestion! I'm not sure about OpenAL, but I think I've solved my basic needs for audio input and drawing. To be honest drawing part looks not that well since most of the libraries generate scripts to feed into gnuplot. And I guess cl-bodge can step in as a drawing surface to build a plotting library on top of. You can have a look on my current progress - https://github.com/can3p/wave-research So, as I said in the first comment, I'm more or less done with visualization part, now the time has come to do actual analysis of the audio stream to detect spikes and that's what I'm aiming for as the next step.
(Of course I'm not the author) This series promises to go through the exercises in PAIP. Posted here for larger coverage - it would be interesting to see not only the videos, but also the feedback IMO (discussions etc.).
... in which the Church of Lisp got stained glass :) (among other cool things)
Could be fun actually. Take a picture, color the cones based on the colors in the picture and do the edge detection etc as before. You would end up with something quite like stained glass. Cool idea :)
If the cones are still moving, it would be one ... heck of a saint depicted there :)
Nice
I flipped through these videos and found that it covers only basics of Common Lisp.
If you get a compile error trying to build on linux, see this bug for a quick fix: https://bugs.launchpad.net/sbcl/+bug/1714549
This week I somehow got pulled onto polishing the regex implementation in ___ Lisp (tired of plugging). I started by implementing a function called `regex-prefix-match` which takes a regex and a string. It reports true if either the regex matches the string entirely, or if the string is a prefix of a string which the regex could match. (Alternative description: the string is a prefix of at least one string in the set *denoted* by the regex). Then I somehow got pulled into optimizing the NFA simulator by reducing the number of states in the graph. I implemented two optimizations: "epsilon-threading" (elimination of useless cases of empty states that have only one e-transition to another state). The second optimization was to merge the representation of empty states and acceptance states. This allows elimination of acceptance state. Any empty state which e-transitions to an acceptance state can lose that transition and be converted to an acceptance state. So, graph time; considering the expression `a+`, the graph generated by the compiler is this (`e` is epsilon, `S` indicates the start state, `A` acceptance states): S A ( 0 ) --e-&gt; ( 1 ) --a-&gt; ( 2 ) --e-&gt; ( 3 ) ^ / `-----------e-------' The first optimization pass identifies `( 0 )` as useless. The e-transition from `( 2 )` is threaded forward to `( 1 )` and we get this; and note that `S` is correctly moved: S A ( 1 ) --a-&gt; ( 2 ) --e-&gt; ( 3 ) ^ / `--e--' Next we recognize that `( 3 )` can be folded into `( 2 )` by making `( 2 )` an acceptance state with its transitions intact: S A ( 1 ) --a-&gt; ( 2 ) ^ / `--e--' A very tiny little garbage collector (just a small bit of logic in the function which orchestrates the chain of optimizations) hunts down all the states that become unreachable and frees them. In doing this work, I discovered an 8 year old bug introduced when the whole project was just several months old. A wrong expression (post-increment rather than preincrement) in the loop which feeds characters through the NFA transitions was passing in the wrong node color. This could cause the logic to think that some states have been visited already when they have not been. The lack of optimizations of the graph was preventing this from actually reproducing. I was very surprised. I triple checked the optimizations, looking at the before and after graph; everything looked good, but `make tests` was failing left and right. I had to single step into it to see that it was refusing to visit a state that it should be visiting due to using a stale color. 
On the off-chance that some of the organizers are here, will you be recording the session?
Common Lisp. Started the oldest of those projects with CMUCL on FreeBSD. These days, 23 applications using SBCL on FreeBSD and LispWorks on OS X and Ubuntu. CL was a good choice to write these initially but the only choice to live with them for this long. Design and testing are crucial. I don't miss static typing even at this size (and have used OCaml for a code base of 100KLOC), but possibly because I've leveraged meta-programming extensively at run-time and compile-time (macros). I've even made effective use of Screamer (see Chris Kohlhepp's https://chriskohlhepp.wordpress.com/reasoning-systems/specification-driven-programming-in-common-lisp/). Using CL wherever it can be blurs the lines between development, system administration, and operation; eliminiates unnecessary technology, saving time and effort. Still, studying and practicing engineering is key; CL is just a great tool for applying it.
I'm no stranger to c, but can someone break down what is going on in the clt files??
They are cl-template source files used by the code generator. So, for instance, the .c.clt file is C source code with embedded Lisp code that is run to generate the final .c wrapper source.
Thanks! After that... What is going on with the c code proper? I don't really understand what the c macros are abstracting
It's just a Linux with some Lisp apps and stumpwm. Don't call it a Lisp Machine.
you might like : https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-871-knowledge-based-applications-systems-spring-2005/assignments/
Even more this: https://github.com/heshrobe/josh-dist
The verilator generates C++ code and header files representing your verilog module. Wrapilator extracts definitions of the verilog module inputs and outputs and from the generated headers, and inserts them into the C template file. This is how it generates setter and getter functions for the module input/outputs. It also generates a Lisp source file defining a new package for setting and getting values via CFFI. This should make sense if you are familiar with both verilog and Lisp (probably not that many people, to be honest!).
I added a fully worked example to the README so it should be more clear now.
Does anyone know what library is used for the syntax highlighting in this post? 
It's [colorize](https://github.com/kingcons/colorize) which I'm probably not doing the best job of maintaining. The blogware is [coleslaw](https://GitHub.com/kingcons/coleslaw)
Awesome...I ran across coleslaw a few weeks ago and was considering using it if I resurrected my blog. It looks solid.
Really cool to see new progress on this! When I had worked on mine, I looked to famiclom as 'how to do it right' vs my own 'how to write ugly c in lisp'.
&gt; Unfortunately, DEFCLASS does absolutely no optimization with this information, while DEFSTRUCT treats it as a guarantee and propagates it through the auto-generated slot accessors and, therefore, the rest of your code. Obviously this depends on the implementation. &gt; Both DEFCLASS and DEFSTRUCT allow you to optionally specify the types of their slots. DEFSTRUCT also allows a fixed layout of the slot vector (using the word here as a fixed single array of words, not in the sense of a Lisp data structure). The items in a structure are stored in some vector-like storage. Since the structure does not change and there is only single inheritance, Lisp lays out data as a fixed vector. Slot access then is a fixed vector reference. This can then be inlined. That means in compiled code using structures, the slot references can be inlined as fixed vector references. Since it can be inlined this way, propagating types should also be easier - depending on the compiler. Structures may also be stack allocated in some implementations. CLOS CLOS slot accessor functions are generic functions and the number and order of slots in an object can change. Thus there is always indirection. So people wrote large software using CLOS (for example I remember a talk at a Lisp conference about a CAD system which used CLOS in Allegro CL, long ago) and they had this performance hit. So what does one do to get faster CLOS slot access? a) Use SLOT-VALUE with known slot names. b) Make sure that SLOT-VALUE does not call SLOT-VALUE-USING-CLASS, since that would be a generic function. LispWorks has a Class option: 'By default, standard slot accessors are optimized such that they do not call slot-value-using-class. This optimization can be switched off using the :optimize-slot-access nil class option.' c) Provide a way to 'finalize' a class for production, where the order and number of slots for the is class is frozen. d) CCL has 'primary classes', where the slot access was/is more efficient. There are other CLOS performance issues: time to create an instance, training of various caches for improved startup behavior, ... I've collected a few papers/articles related to CLOS &amp; application performance: http://lispm.de/docs/Publications/Common%20Lisp/CLOS%20and%20Efficiency/ 
&gt; DEFSTRUCT also allows a fixed layout of the slot vector (using the word here as a fixed single array of words, not in the sense of a Lisp data structure) Is this cross-implementation? Is there more I can read about this? 
Every self-respecting implementation will store structures as a fixed vector (of immediate values or pointers to values). &gt; Is there more I can read about this? Source code of implementations. Otherwise I've posted a link to a collection of papers... above.
Flash for a MIT project? Really?
I know it's just a detail but being a web dev working with Rails, Node, and that kind of stack, I'm spoiled when it comes to websites. I just love it when the documentation website is pretty and easy to navigate. Having something like [devdocs](http://devdocs.io/) for Common Lisp would be awesome.
&gt; Also SBCL is too much for beginner; I started with SBCL. Installation is super easy and it "just works". Warnings are great too, they help me find out a lot of newbie mistakes I make. Any particular reason why you recommend Clozure CL for beginners?
FYI I've use https://github.com/orthecreedence/highlight-lisp (specifically for lisp) happily lately (it's used on the CL cookbook for example: https://lispcookbook.github.io/cl-cookbook/strings.html and has a bit more colors)
Amazing ! 
It's MIT [scratch visual programming language](https://en.wikipedia.org/wiki/Scratch_(programming_language)). It was orignally written for Squeak Smalltalk. Later versions were written in Actionscript and subsequently HTML5. Scratch is designed to teach programming skills to children, so it makes sense to use a highly accessible platform, as Flash was before HTML5 took over. Regardless of its platform, it's impressive implementing a Lisp in a visual programming language for kids.
I asked because flash is unavailable on my Android phone. I think the iPhone is the same way. Also Adobe us ending support in 2020. So I wouldn't say flash is highly accessible.
It's obviously not anymore, but it certainly was when scratch 2 was developed. You can't expect an educational toy programming environment to constantly track the latest tech trends.
Strandh's paper on generic dispatch is also interesting: http://metamodular.com/generic-dispatch.pdf
Hey Rainer, just wanted to say I greatly appreciate these corrections and especially the link to relevant publications. I'll keep all this in mind as I work on the project further. Thank you! :)
Pardon me if I'm way off base, but isn't Bitcoin is a specification that is implemented in more than one language on more than one platform?
I guess it's not written in lisp because the people who built it used another language. If anything, it should be written in Erlang, no?
It's nice! Is there any equivalent on ios?
That would definitely be interesting source to read.
PicoLisp looks cool. Has anyone had luck building it on Mac (10.11.6, Clang)?
No, gcc only
Part 4 is [up](https://www.youtube.com/watch?v=_biyVi89jeI)!
yes there's bitcoinJ (java) and NBitcoin (C#)
This is cool. I like the potential it represents.
I think given the kind of project, something like OCaml would be better than Lisp? Just guessing though I have no idea how Bitcoin works besides there's something called a blockchain which is distributed :P
ah, hence the super-judgy: main.c:730:34: error: fields must have a constant size: 'variable length array in structure' extension will never be supported struct {any sym; any val;} bnd[length(y)+2]; 
Thank you for colorize. I did not know about it. It is exactly what I was looking for, very helpful to understand complex blocks of code. Wonderful.
I appreciate that but the real thanks for Colorize go to [Brian Mastenbrook][bm] who originally wrote it. I just merged a few small patches and put it on github. :) [bm]: https://twitter.com/bmastenbrook
Bitcoin is definitely not a specification. That implies some kind of rigorous understanding of the entire system. It's more of a working code base in C++, that other systems try to adhere to as best they can. There are a lot of quirks that other systems have tried to replicate with varying degrees of success.
I reimplemented much of Bitcoin in Erlang. That was a hairy process. The biggest problem with Erlang is that much of Bitcoin validation is CPU bound, and it's local disk I/O patterns aren't very friendly either. Further much of the protocol relies on lots of mutable data for performance reasons that don't match Erlang semantics that well. I do think Erlang is a fantastic language for developing digital currency and blockchain tech though.
CPU and Disk performance is a real issue for processing the blockchain. The C++ code base is pretty darn speedy, and Ocaml is probably the language to pick if that is the primary concern? I'm not a Lisp expert by any stretch though, I know it is possible to squeeze lots of performance out of it.
Bitcoin as it is implemented relies on serialized CPU and disk bound operations. There really are some common sense protocol changes that should be made that would drastically increase performance, but as it is designed it is not particularly friendly to concurrent operation.
Gcc have uniq feature, clang will not compile
Hmm: https://decentralize.today/say-it-with-me-bitcoin-needs-a-reference-specification-76cccee61206 
bingo.
All of those things are things you will need non-lisp specific tutorials for. You will be doing a lot of FFI for most of those things, unless there is a library that exists that already does what you want. If the library does exist to do what you want, skip the next two paragraphs. Otherwise if you don't know it already, learn some basic C. You'll need to know enough C to understand function prototypes in C. Then learn CFFI which is the way of using lisp to call C functions. If you don't understand the following at all, you'll be in trouble if a lisp library doesn't already exist to do what you want: char *strncpy(char *dest, const char *src, size_t n); Once you are there, then just find tutorials for how to do X in C or C++, and you should know enough to be able to also do them from lisp at this point. In some cases someone will have already done a lot of the work already. common-qt is already setup for the Qt GUI library, and I would recommend it for rendering a GUI. This is actually a good example of how you'll learn; you can find Qt examples and tutorials, and they should translate reasonably well into lisp, using functions in common-qt. Also, #lispgames on freenode is also a good place to ask about some of this stuff, since mouse, video, sound and gui are all things that one might handle in a game. If you are on windows, you'll need to learn more about COM probably, as it's the main way of communicating with much of the OS. On linux you will be mainly opening devices as if they were files and sending commands to them by writing and using a C function named `ioctl`. For printing, I can't help you for windows, but on linux, there is actually a command you can run that takes a postscript or PDF file and prints to a printer; `uiop:run-program` is sufficient for printing. There are several libraries for lisp that can generate postscript or PDF, so if those do what you need, you can print without digging too deep.
I haven't used Julia, but it seems to be one of many examples of macros without s-expressions: - 1992 - [Dylan](http://people.eecs.berkeley.edu/~jrb/Projects/dexprs.pdf) - 2006 - [TwinLisp](http://twinlisp.nongnu.org/docs/TwinLisp%20for%20lisp%20users.html) - 2006 - [PLOT](http://users.rcn.com/david-moon/PLOT/) - 2006 - [Readable](https://sourceforge.net/p/readable/wiki/Home/) (nice [overview](https://stackoverflow.com/a/4108988/142317) of infix macros) - 2008 - [Genyris](https://github.com/birchb1024/genyris/blob/f354506df62fc7670747044a1f8cbf498831741c/examples/cps.g) - 2008 - [Ioke](https://ioke.org/), [old guide here](https://web.archive.org/web/20130213154754/http://ioke.org:80/wiki/index.php/Guide) - 2009 - [Ginger](http://sci-hub.cc/10.1145/1566445.1566481) - 2010 - [Rust](https://doc.rust-lang.org/1.7.0/book/macros.html) - 2012 - [Sweet.js](https://www.sweetjs.org/) - 2012 - [Honu](https://www.cs.utah.edu/~rafkind/papers/honu-2012.pdf) - 2014 - [Liso](http://breuleux.net/blog/liso.html) - 2014 - [Earl Grey](http://www.earl-grey.io/)
my problem with cffi is that I am familiar with c and c++, but I don't understand how and why I would need to make a c wrapper for a c++ library.
Never used Ocaml much, but I know it can run fast, probably not as fast as C/C++ but it's not so far behind anyways. You give up a bit of speed for safety. Things like automatic memory management and the type system makes it very hard to introduce bugs into the code. It's a very safe language, something great for software that deals with security/money.
Yes, absolutely. I know Jane st has used it for years in HFT, I imagine it is plenty fast. I find myself wishing for Erlang style concurrency + otp with Ocaml single threaded performance. It's possible now with alot of marshalling which I think kind of defeats the purpose and is pretty complicated.
* 1973 - CGOL (en.w**pedia.org/wiki/CGOL) 
C++ FFIs are really difficult implement to write in comparison to C FFIs. (Classes, Inheritance, name mangling, templates are a few reasons why). So implementations generally only provide C FFIs. As to how: if you want to export C++ data structures/functions so they can be read by the C FFI, wrap them with extern "C" like [this](https://isocpp.org/wiki/faq/mixing-c-and-cpp#call-cpp) and compile a new shared object file.
Because C++ has a more complicated ABI. "How" is simple, just put it all in an `extern "C"` block; the functions prototypes are limited to C rules (i.e. no member functions or overloading), but the function bodies can use all of C++. ~~There is a tool that will autogenerate FFI to C++ for you now, but I've not used it: https://github.com/rpav/cl-autowrap~~ [edit] though c2ffi supports C++ it doesn't appear that cl-autowrap does.
The language per se doesn't interest me very much, but the community around Julia is doing amazing work (well, it amazes me) to advance numerical computing in general: from macros for polynomial evaluation, to writing their own libm, to just the archival work of tracking down and compiling good, legally unencumbered special function implementations. I was working for a while on a numerical library for CL (since abandoned), and Julia was the source of most of my best ideas.
I'm working on a Lisp interpreter for the HP Prime graphing calculator, since I'm about done with the built in programming language.
Start looking for libraries at quickdocs.org
6pm UTC happens when this comment is 8 hours and 37 minutes old. You can find the live countdown here: https://countle.com/P561414IG --- I'm a bot, if you want to send feedback, please comment below or send a PM.
* 2012 - Elixir
Easy installation on popular platforms, no noisy messages which will confuse beginners, more "permissive", better error messages, faster compilation time. I've found I tend to use it more than SBCL while developing for Linux or Windows; I only test with SBCL for performance and compatibility.
Thanks for pointing to this wonderful blog!
First of all just have an aim to implement (game, gui tool, etc), then try to google for necessary libraries.
You can take a look at how Qt / CommonQt / Qtools achieves this. There's a library called `smoke` that essentially wraps Qt C++ calls in C calls that are then easily retrievable through CFFI.
Interface with libraries that do what you want. The Common Lisp library ecosystem is not terribly huge compared to other programming languages, but you can use CFFI to interface with anything that exports some functions callable via C, and use `uiop:run-program` and `uiop:launch-program` to call external programs and interface with them via stdin/stdout.
A tip: you shouldn't assume everybody is using latest hardware: I wanted to install it, but no luck: my (quite recent) android device is armv7, but the apk is only built for armv8 :-(
Nice project. We need the same for CL, and more: - html templates, - javascript, - interactive html and js development, - ajax-based apps, - shipping with Electron, - DB migrations, - connecting to a remote and running website, - hot reloading, - … we talk about it here: https://github.com/LispCookbook/cl-cookbook/issues/105
A number of people who I respect think quite highly of Julia and its community. I do some numerically intensive work in lisp and more often than not I have had to code up my own implementations of whatever routine it is that I need - there are fairly few numerical libraries around in lisp. I think Julia is actually building a community and eco system that is quite attractive from that perspective. On the other hand, given I have done the work already, there is not much there that would propel me to Julia (and I would definitely miss slime if i did . I still don't think Julia has anything to match that). 
https://jscl-project.github.io/ **edit:** (due to clarification) with the jscl.js (which is basically precompiled jscl.lisp) loaded in the browser, you can use common lisp as a script (see [this example](https://github.com/takagi/common-lisp-script)) or use pre-compiled to js ([this fork/branch](https://github.com/davazp/common-lisp-script/tree/experiment-pre-compile-lisp) is the same example with pre-compiled code loaded) There is also [parenscript](https://common-lisp.net/project/parenscript/), which is more like a pseudo-common-lisp translator to javascript. Unlike jscl which requires jscl.js, parenscript requires no overhead, it generates stand-alone files. I have used parenscript extensively for about 10 years and even have a couple libraries based on it. You can use parenscript for generate static js files but it also easy to generate programatically your own parenscript code and compile it to javascript. So one can deliver customized javascript to the browser. Parenscript is very stable and fairly complete, but development has stalled. And with parenscript you are half thinking in lisp and javascript. I have not used jscl beyond some basic explorations but I think it has promise.
https://repl.it/languages/scheme
You don't have to deal with the JVM to use ClojureScript. Lumo is CLJS, self-hosted on node, and has somewhat recently gained the ability to compile clojurescript just like JVM clojure does. It should be possible to have a 100% JVM-free ClojureScript toolchain now, if you want it, though I don't know what caveats it has with regard to the browser-connected REPL. Might be worth looking into. Though I'm honestly not sure what the issue with the normal cljs toolchain's use of the JVM is. You shouldn't be needing to interact with Java yourself, just a couple tools like `lein`, that rely on it. Just treat them like any other installed application and try to ignore that they use the JVM.
&gt; shipping with Electron Looks like what [Ceramic](http://ceramic.github.io/) by eudoxia0 is trying to achieve. &gt; hot reloading You already got this if you use Hunchentoot.
indeed I'm refering to Ceramic. &gt; You already got this if you use Hunchentoot. I didn't know that and that's awesome, thanks. I only read about Clack achieving something similar with a perl script… so this is nice to hear. I added a note into the issue.
You might like [Skewer](https://github.com/skeeto/skewer-mode), for Emacs. It can send expressions to the browser and open a REPL. Then there's [trident-mode](https://github.com/johnmastro/trident-mode.el) to use it with Parenscript (it looks quite like an experiment and hasn't seen updates recently, but it worked when I tried and the author answered questions and issues).
Fascinating article. I was particularly taken by surprise by the Warnock posting linked to from the article in which he advocates using defmethod+defstruct as a kind of more efficient CLOS-lite. But, although it seems to work in practice, it conflicts with CLHS which specifies that defmethod specialises on either a class name or eql. Thus not on a struct type. So my question is, what's up with this? Is it a conforming technique or a hack that just happens to work?
On a side note, what happened to RESTAS? Their site and the site that use the framework (lisper.ru) is down. I had to read the documentation from archive.org.
&gt; On a side note, what happened to RESTAS? It is still around, and is still being actively maintained: https://github.com/archimag/restas &gt; Their site and the site that use the framework (lisper.ru) is down. lisper.ru is up and running again for quite sometimes now. &gt; I had to read the documentation from archive.org. IIRC, one of the reason that the original RESTAS website on lisper.ru (http://restas.lisper.ru/) was not restore despite the fact that the base site was up and running was because the documentation, especially the English version, on RESTAS website was hopelessly outdated (even before the site went down, including the ones archived by archive.org), and the developers were hoping to update the documentation before restoring the RESTAS website (which apparently they still haven't come around to do either).
You're right that it's almost entirely aesthetic nonsense, but I guess I'm fantasizing about finding a fullstack Lisp that's native on the backend but has stellar compile-to-js interop. I'll check out Lumo; thanks!
I am not familiar with nEXT, does it use its own engine?
the rendering engine is based on QTWebkit
Are there any plans to port this to qtwebengine? Qtwebkit is officially deprecated, but some people are still maintaining it for now...
I'm afraid not, QTWebkit has been chosen for a variety of reasons, particularly for its tight integration with DOM functions, if/when qtwebengine receives the same level of support, we will try to offer support for using either engine
I will certainly try this (on Linux), just the "history as a tree" alone seems convincing enough!
[removed]
thanks :)
Ah, so as long as I get a suitable abstraction for the low level components of what I want to do in C - or someone's already done that and wrapped it up nicely - I'm all good. Excellent, thank you, that's exactly what I'm looking for by the sound of it! :)
oh great! I'll try this new lispy browser this weekend xD yeay! 
Unless the :TYPE option is used, DEFSTUCT defines a *class* (an instance of STRUCTURE-CLASS), which can be specialised upon.
Unfortunately, I think a trade-off is going to be necessary, because ClojureScript has the best interop around, partly *because* Clojure's made to work closely with whatever host platform it's on (CLR, JVM, or JS). I'm still hoping for some kind of native Clojure one day, doing FFI similar to how it does platform interop. Maybe someday :) 
thank you for the support :)
You should really consider just installing the JVM anyway, even if you don't write Clojure-JVM code and just Clojure-Javascript. The Google Closure compiler, which uses the JVM, is *really really good*, and having Clojurescript use it as part of compilation is just beneficial all around.
Let me say that you are amazing !! I regularly watch with great pleasure and interest your shows as they arrive on youtube. I hope to be able one day to check out your code on small Debian Linux machine for which I think I should install the last sbcl in order to avoid some trouble with your libraries. ... And I all the time show your wonderful achievements ... even buggy, they look great :-) .. to my daughter, hoping that some day it will inspire her into learning Lisp. Thank you 
That's very kind, thankyou. It's going to be fun in a year or so to look back and see what I have learned. CEPL should run fine on debian under sbcl (or ccl) if yu have GL 3.3 or newer. Luckily the Intel chips are getting much better these days so even without a dedicated graphics card it should be possible with a recent machine. I hope your daughter finds her passion, whether code or not, being able to have a slice of the world that you feel 'right' in is a lovely thing.
`DEFVAR` and `DEFPARAMETER` differ when they are re-evaluated. `DEFPARAMETER` will re-evaluate the value form and reassigns the variable with the value. `DEFVAR` only does so if the variable is unbound. No one has a good answer for what the `f` stands for. "Field" is the most plausible to me, but it still doesn't make much sense. EDIT: I find lispm's citation below to [HOPL2-Uncut](https://webcache.googleusercontent.com/search?q=cache:-bsa8SBc988J:https://www.dreamsongs.com/Files/HOPL2-Uncut.pdf+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us) persuasive, it is short for `SETFQ` where the `F` is for function and `Q` for quote. http://clhs.lisp.se/Body/m_defpar.htm Oh, and as both forms make the variable dynamically scoped, the variable in either case should conventionally be named with `*earmuffs*`.
Unrelated to Lisp, README in a language I cannot read. Downvoted and flagged, sorry.
You are trying to assign a value to a special variable that has not been declared. Please use `DEFVAR` and/or `DEFPARAMETER` first to declare that this symbol names a special variable. Once the variable has been declared in such a way, you can freely use SETF to assign to it.
I thought the f stood for "form." Which makes more sense considering that it takes entire lisp-forms as arguments. I once saw a fun post where a coder had define (setf sqrt) such that (setf (sqrt x) 2) x =&gt; 4 
The SETF thing is a bit older than Common Lisp and it seems that the F originally stood for FUNCTION: https://stackoverflow.com/a/23808420/69545
ISLisp also has JavaScript Implementation like JSCL. REPL: https://islisp.js.org Github: https://github.com/ta2gch/iris
Oh, hey, I did one of those as well... https://www.reddit.com/r/programming/comments/hjg0/why_lisp_macros_are_cool_a_perl_perspective/chlfk/
Hey, cool project! I tried to check it out, but unfortunately build step is really painful on Mac OS X (I failed on EQL). Are there any plans to optimize this part?
Do not you take the content to go to Google translation? Now everywhere to block / prohibit the nameless generation post, this is the disaster of human civilization.
The content itself might be good, but: * it is not anyhow related to the Lisp family of programming languages, * you yourself post a non-English post on an English-speaking subreddit of an English-speaking webpage, * you spam the same thing all across Reddit with no previous posting history, as seen on https://www.reddit.com/user/ShionAt (screenshot: https://i.imgur.com/mFowZXx.png). /r/worldnews is definitely not a proper subreddit for such inventions.
Haha that's a crazy coincidence :)
these situations when I want a variable in the repl, I use [Rob Warnock's](http://rpw3.org/hacks/lisp/deflex.lisp) `deflex` which defines a lexical variable. Not part of the standard but exists in many utilities (for example [repl-utilities](https://github.com/m-n/repl-utilities), [serapeum](https://github.com/TBRSS/serapeum), [misc-extensions](https://github.com/slburson/misc-extensions); all quickload-able)
Hi, yes, I plan on releasing pre-built binaries for OS X, unless you mean installing a developer version installation, in which case no, the instructions for that will likely not change significantly can you please post the error you had?
This happens because, according to the standard, `setf`/`setq` never introduce new variables. `defparmeter`/`defvar` on the other hand will introduce global variables as needed. The between them is `defparameter` will overwrite the value of an existing variable but `defvar` will not. As a side note, `defparameter` and `defvar` introduce "special" variables- variables with dynamic binding turned on. This has some useful but sometimes surprising side effects: (defparameter *x* 5) (defun a () (print *x*)) (defun b () (let ((*x* 6)) (print *x*) (a))) (a) (b) Will print 5 6 6 Basically, when you `let`-bind a special variable that change applies to any functions you call too (and any they call). This means that if you `(defparameter a 6)`, for example, now every use of the `a` variable elsewhere in your code will use dynamic binding. This the reason why global variables in lisp almost always are surrounded by `**` (sometimes called earmuffs jokingly)- they make it obvious that everywhere that variable occurs uses dynamic binding. If you want a global variable without the dynamic binding side-effect, you need to use something like `deflex` which, as arvid pointed out, is not part of the standard but is in many utility libraries provided by quicklisp. With deflex, the example turns into: (deflex x 5) (defun a () (print x)) (defun b () (let ((x 6)) (print x) (a))) (a) (b) Will print 5 5 6 Which is much more like a global variable in other languages. `setf` is interesting because it allows you to assign to more than just variables. In short, `setf` allows you to only remember the getter functions for things and have it fill in the proper setter functions for you. For example, `car` and `rplaca`- `car` gets the first value out of a cons cell, `rplaca` sets it. Because that pair of getter/setter is registered with `setf`, insted of typing `(rplaca cons-cell 5)` (which is annoying to remember) you can type `(setf (car cons-cell) 5)`. This is similar to `x.y = 5` or `x[6] = 5` in python or c, but you can register new setf places at any time. Just about all of the getter functions in the standard are already registered with `setf` too, so you can (for example) assign to an index in an array with `(setf (aref array idx) new-value)`. This feature is the reason for its name- although the exact meaning of the f seems to be lost to time, the general consensus is that it stands for "set function" or "set field" to distinguish it from just simple variable assignment. 
You don't need to worry about that: since I know the Qt internals quite well, I could maintain a WebEngine version (everything WebKit offers is possible with WebEngine, too; it's only that one needs some JS code internally when using WebEngine).
This warning saved me earlier today. My file had (defvar *bases* '(2 3 5)) After playing at the REPL for a while I wanted to make a change (setf *base* '(2 3 5 7)) I got a warning. "Oh!" thought I. Time to stop and think. Since I had declared my variable, I definitely shouldn't be getting a warning. What was it really telling me? Looking more carefully revealed that I'd left the *s* off the end of *bases*. Without the warning, I would have spent ages trying to work out where my shiny new 7 had got to. As for the difference between **defvar** and **defparameter**, the [specification](http://www.lispworks.com/documentation/HyperSpec/Body/m_defpar.htm) does explicitly state &gt; defvar, by contrast, assigns initial-value (if supplied) to the dynamic variable named name only if name is not already bound. Nevertheless, I've always felt that the description of the syntax is misleading. It says **defparameter** *name initial-value [documentation] =&gt; name* **defvar** *name [initial-value [documentation]] =&gt; name* I would have copied from the syntax for **if** which is **if** *test-form then-form [else-form] =&gt; result* \* and described the syntax of **defvar** thus **defvar** *name [else-form [documentation]] =&gt; name* My way, any-one who checks the syntax as part of debugging, gets to go "WTF?" and start worrying why it is called *else-form* as though **defvar** was some kind of control flow construct and where the hell is the *then-form*??? The answer is that **defvar** is a control flow construct. It checks whether the variable already has a value. If it has has a variable, the *then-form* is else where in the program and has already been evaluated. So the *else-form* doesn't get evaluated, just like an **if**. I've never made serious use of **defvar**. My best guess of what it is for is if you have two programs that share source files. Perhaps program A is in foo.lisp and bar.lisp. To load program A (progn (load "foo.lisp")(load "bar.lisp")) Meanwhile program B is in a single file, bar.lisp. Load program B with (load "bar.lisp") Then you hit a snag. Program A needs \*stuff\* initialised to THIS while Program B needs \*stuff\* initialised to THAT. So you write your code. At the start of foo.lisp you put (defparameter *stuff* 'this) and at the start of bar.lisp you put (defparameter *stuff* 'that) The bug you get is that program B works and Program A doesn't. When you try to load Program A, \*stuff\* gets initialised to THIS and later gets overwritten by THAT. Program A gets borked by Program B's initialisation, which it doesn't want. You fix this by changing bar.lisp to (defvar *stuff* 'that) and now, after starting a clean image, which ever program you choose, either A or B will work, because **defvar** is checking whether \*stuff\* already has a value, and leaving it in place if it does. I've only cared about the difference between **defparameter** and **defvar** when I'm mixing working at the REPL with editing and reloading source files. I try to guess ahead of time whether I want reloading the source file to reset a variable (use **defparameter**) or whether it will be annoying to lose a value that I've created interactively (use **defvar**).
The world is everywhere to prohibit / block the contents of the new registered users, you now do not read my content in the case of language alone as this is rubbish, I made the purpose of the mouth is the desire to be languid development I see that my project needs to be outdated developers, ShionKeys is designed part of it because of lisp, sad is that everyone here are using the keyboard, you said I was spam, stupid ,,,
i don't use lisp. but wouldn't people now try to match the parens to the indentation, like with other languages? (define expt (lambda (x n) (cond (I = Nnull 1) 1 (else (* x (export (x (- n 1)))) ) ) ) ) i think that makes things easier
Any lisp text editor does the indentation for you, and putting each paren on its own line doesn't provide any more information about the code so it's considered bad style to just leave a dangling paren.
&gt; but wouldn't people now try to match the parens to the indentation, like with other languages? Lisp programmers don't need to do this because most sufficiently smart editors will automatically keep the parentheses balanced (among other useful features, as mentioned in /u/charles__l's reply), thus negating the need to have dangling parentheses that are just a wasted of space. Check out the animations on the [Animated Guide to Paredit](http://danmidwood.com/content/2014/11/21/animated-paredit.html) website for examples of how this works in practice. 
If it's easier, why didn't you make it: (define expt (lambda (x n ) (cond (I = Nnull 1 ) 1 (else (* x (export (x (- n 1 ) ) ) ) ) ) ) ) And how would that really be any easier if you're blackboarding in front of a class? Any halfway decent code editor (and REPL) indicates matching parentheses by jumping the cursor briefly to the opposite parenthesis or highlighting, or both. To close a bunch of parentheses, all you do is repeatedly type ))) while keeping your eye on the one that you want to close. When that is "hit" by the highlighting or backward cursor jump, you stop. If you overshoot, you backspace, again while keeping your eye on the paren you wanted to close until you hit it. Concretely, say I have this (taken from Barski's *Land of Lisp*): (defun pairs (lst) (labels ((f (lst acc) ;; I want to close this ((f --- I keep my eyes on it. (split lst (if tail (f (cdr tail) (cons (cons head (car tail)) acc)) (reverse acc)) (reverse acc_ ;; &lt;-- cursor is here (f lst nil))) ;; I then want to enter this part: pretend it doesn't exist yet. I just look at the `((f` and start typing `)` repeatedly. The cursor first jumps to `(reverse`, then to `(split`. I don't look at that. Then it jumps to `(f`: almost there. One more and it's out to `((f`. Got it! If I overshoot by one paren, the indication goes to `(labels`; oops, backspace. Now the opening parens of `((f` is highlighted again. When I have closed the one I want, I type Enter. Then the cursor is at the right indentation level to enter the `(f lst nil)` and we close out to the `(defun` the same way. It's like keeping your eye on a target or ball hit in a sport and just taking the shot or swing, with the added assurance that you make every one.
Oh. SNAP.
 (defun pairs (lst ) (labels ((f (lst acc ) ;; I want to close this ((f --- I keep my eyes on it. (split lst (if tail (f (cdr tail ) (cons (cons head (car tail ) ) acc) ) (reverse acc) ) (reverse acc (f lst nil ) ) ) :\^)
This looks like an exciting project--thanks for sharing. I've downloaded the latest release. However, contrary to the readme it doesn't seem to be a pre-built binary as far as I can tell (rather, it contains the build files only). I'd love to give this try, but I'm unwilling to install all the dependencies before taking it for a spin. Will there be a binary option available soon? Or if I'm in error, please advise. 
I failed because qt was installed with brew, which refuses to link it to /usr/local for some reasons. Because of that I couldn't make EQL find proper paths during the configuration and make failed
Screen space has value. One closing delimiter per line is an inefficient use of that value. So Lisp programmers handle the need for closing parens by bunching them up at the end of lines. Python adopted a similar style. The languages disagree whether matching parentheses or counting leading whitespace is better.
Hey! sorry for the misinformation in the readme, you are right, there are no binaries, I was able to produce a .app bundle for OSX, but unfortunately it only works on my machine, for ver 0.03 I will try to have a .app you can just download and run!
Hi, thank you for the information, can you please tell me where the libs for QT are, if not in /usr/local? what I may do is make a port file for macports, perhaps you could also help with the accompanying brew file?
No problem--and thanks for the response! I'll keep an eye out on the project. Best of luck!
thank you!!
I told my daughter about your comment, rephrasing a little with "let us hope that she does what she likes" and she went ... \o/ !!!
&gt; Any lisp text editor... Both of them?
The downside is that it makes you strabismic in the long run.
Well... Yeah... But only two real text editors exist, right?
&gt; This formula is keg-only, which means it was not symlinked into /usr/local, because Qt 5 has CMake issues when linked. &gt; If you need to have this software first in your PATH run: echo 'export PATH="/usr/local/opt/qt/bin:$PATH"' &gt;&gt; ~/.zshrc &gt; For compilers to find this software you may need to set: LDFLAGS: -L/usr/local/opt/qt/lib CPPFLAGS: -I/usr/local/opt/qt/include &gt; For pkg-config to find this software you may need to set: PKG_CONFIG_PATH: /usr/local/opt/qt/lib/pkgconfig