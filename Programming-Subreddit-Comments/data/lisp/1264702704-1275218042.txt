Neither latitude nor longitude are linear measurements of distance. If you wanted to make the tradeoff and choose an incorrect program--even though great sphere distance calculation isn't particularly expensive--consider that 1 degree of latitude translates to a much longer distance at the equator than in Alaska. And consider that 1 degree of latitude translates into a difference distance than 1 degree of longitude does, at most (if not all) points on Earth.
&gt; Neither latitude nor longitude are linear measurements of distance. Yes, that's why I said "approximation". &gt; even though great sphere distance calculation isn't particularly expensive Clearly, here it *is* expensive. The point of the article was that this calculation was a major bottleneck.
&gt; consider that 1 degree of latitude translates to a much longer distance You certainly meant *longitude*.
Yes, thanks.
Right. But say someone wants to find the best deal on pairs of mismatched athletic socks within 50 miles. You look at the latitude and longitude of their house, figure out the factor for converting small differences in longitude to linear distances (by taking a cosine), and then you can reuse that factor for every place that sells mismatched socks to check that it's close enough. The approximation will be plenty good enough.
I'm not familiar with Clozure at all - it uses something other than emacs?
Nice that it is that fast, but how often do you have to use (the ... ...) ? It would be nice if it kept track of types nicely, and also the intervals. (And how they transform) Being able to specify with a function the dependency of the output-type based on the input type would be neat too. (That would be more advanced though) Further, why specify types? Lisp could be better, i have a project to do this, unfortunately it moves at a glacial pace.
Is python really 1/4th the speed of Java?
Well, when youre already opening a news item for CCL, you could have included more information than a simple "Tried it, way cool!!", especially some details and/or screenshots about the IDE for us non Mac users.
A Hemlock-y system iirc.
It uses a modified version of [Hemlock](http://www.cons.org/cmucl/hemlock/), which is the Emacs clone that's been packaged with CMUCL for quite a while. ISTR that the LispWorks editor is based on Hemlock as well.
Depends... if you're just just going over the bridge from new jersey, no, no it doesn't. In fact, we'd prefer it if you just stayed over there.
Yeah.... I though python was supposed to be significantly faster than Java (maybe he got his Ps and Js mixed up).
Waiting to see it show up in freemantle extra-devel, along with the GNU Emacs package (for slime that is).
For the rest of us there is a Portable Hemlock project on common-lisp.net --- http://common-lisp.net/project/phemlock/ Never used it, though...
I see the username, so I don't know if you are serious. But really. The last time I professionally worked with java was the heyday of the P3 so granted, python on an i7 is faster then my old experiences of java on a P3 900. But I'm really curious though. Is there any rule of thumb metric ... 
Precisely. You really, really want to avoid unboxing if you have a go-fast place in your code.
&gt; Nice that it is that fast, but how often do you have to use (the ... ...) ? See froydnj's comments, a lot of it is unnecessary. &gt; It would be nice if it kept track of types nicely, and also the intervals. (And how they transform) Being able to specify with a function the dependency of the output-type based on the input type would be neat too. (That would be more advanced though) Further, why specify types? Lisp could be better, i have a project to do this, unfortunately it moves at a glacial pace. Tell me more. I was recently thinking about integrating a full-fledged type-inference engine with CL, which I'm really not qualified to do due to the complete lack of background in type theory. And yes, I'm aware SBCL already has an inferencer, which is what makes it so fast, but I was also thinking about getting partially to where Haskell sits today, that is giving useful warnings about type mismatches to the programmer, while retaining the fundamentally free-style approach of CL. This kind of hints would be really, really nice for larger scale refactoring without breaking your code's invariants.
No, I was/am honestly under the impression that Python had surpassed Java in the byte code race for speed.... you know... with google's attention to it and all. Don't let the user name fool you; it's a jedi thing.
I believe this is quite wrong. The JVM has had many great minds working on it professionally for years. Check out some of the "flawed benchmarks" at the [shootout](http://shootout.alioth.debian.org/)
I think i will update [the website](http://lang-lisp.berlios.de/main.html) which is currently **woefully** out of date. I will also git-push the new (largely rewritten) version later. I will put an explanation here, and will likely copy most of it when improving the website. The scheme to 'infer' the types is actually quite simple. All the base functions have a function attached, which takes input-types of the arguments and outputs the output type. The output type of composed functions is determined via these, just denote the types put through everywhere. I prefer calling this calculation of types. So you don't really need type theory for that part. However, it can be rather tricky to make those functions outputting types, which are basically sets.(try to figure out) I did have a OR type, but i sidelined it for now, as i dont know how exactly how to make to-C output with it. I think those might be too much of a distraction and i have to focus on producing C code before having really deep type-simplification and functions. Anyway, in this scheme the only places you need to mention the type is. * In a recursive function, because calculating the type there would cause an infinite loop. * Loops setting variables. * Pointer use (?) * For the sake of optimalization.(in important places) If intervals are kept in types (defun sqr (x) (* x x)) would defaultly use the '* type-function, making a 'sqr type function can do better, by recognizing that x=x which the '* type function ignores. It could also happen that you think you can know better in 'more singular' cases, determining types inside code, instead of attached to functions. Note that types could, at this point, be described in principle in any way, it seems likely however that s-expressions are simply best. The Lisp also has macros. These are expanded *at the same point* as the types are being calculated. The reason is that this leaves the macros open to be dependent on the types. Hopefully this will allow deferring object systems to libraries. If types are not determined, the conversion to output-languages will have to produce object that determines it at run-time. After type-calculation and macroexpansion(a function i call 'resolve') only some types of expressions are allowed to linger: * (funcall ..), calling of a function * (lambda ..), making a function, and only thing that 'makes' variables a this point. The LET macro, for instance will output (funcall (lambda (..)..)) * (function ..) , referring to a function produced in a defun earlier * constants (numbers, strings etc.) * variables * regular function usage On these there are transformations, meant to change the code into equivalent forms closer to what output languages can work with. For instance, outputting to C, you cannot create variables inside argument input. LET-DEBODY finds cases of funcall-lambda, moves the code and variable(changed if conflict) to outside argument input. DELAMBDA finds lambda entries, and turns them into separate functions, referred to by (function function-name external-variables) with added external variables. Now, i know that higher-order functions can require some kind of garbage collection. Simple way of demonstrating this; say you have a function with a variable created inside and a outputted lambda form, then the point when the variable created in the function has to be cleared is dependent on what happens to the function. Further there is DE-IGNORED, which removes ignored variables, DE-EQL, which turns anything of the eql(/constant) type into just a constant. And there is T-INLINE which takes a function as argument which is the prerequisite of inlining the function. In producing functions to output to another language, you figure out what transformations are needed, possibly making a new transformation if not all exist, and then do the minimum possible in to actually output the code. Now i am daunted :/.. [This comment](http://www.reddit.com/r/programming/comments/at03u/voodoo_slide_amplifying_c/c0j91pg) has a bunch of stuff that is also interesting. Edit: [especially this](http://www.iro.umontreal.ca/~boucherd/mslug/meetings/20041020/minutes-en.html) will help a lot in figuring out how to get higher-order functions and such.
Ah, so you're concentrating on a new typed dialect. I was thinking more of plugging something into CL as such, to allow augmenting existing code with enough type hints to make useful reasoning about it possible. That'd of course need some implementation-specific plumbing, but a large part of it is already done in SBCL, which'd be a useful starting point.
None of the THEs are really necessary. The only ones that you want for performance are the ones near ASIN and SQRT, and even those should be used for specifying the type of the argument (so direct calls to the C functions/machine instructions can be used rather than going through the type-checking CL functions), rather than the result type.
Yeah, but you never know what bugs you're going to get...
Gotten some good feedback so far: http://spreadsheets.google.com/viewanalytics?formkey=dDRXZ2ZPcnRTQU5WQWhOS0JsT01WdEE6MA Thanks for answering. Edit: So I post a poll to the lisp reddit, about an open source lisp project, so more people can complete it and we have better direction for where to take the project... and it's all downvoted. What?
This is very cool...and also very scary. It's like some sort of strange reverse-Greenspunning that makes me cry *grin*
Legend has it that bots downvote all stories except the ones they've submitted. I don't know if it's true, but it's the answer that's always given when people ask the same question. Also, every post and every comment *with at least several upvotes* gets downvoted no matter what. Don't worry about it. EDIT: fix hyperbole
I pulled all articles from Erann Gat's comp.lang.lisp archive files, selected only Erik's articles, and then looked for signatures.
yeah, just thought the lisp subreddit might be a bit more immune to that because it is smaller.
If you click on an author's name, sometimes you'll get a useful profile page where you can browse articles by month and group. Half the time it doesn't work for me, though.
It can use slime + emacs of course, but it comes with portable hemlock.
This has far and away the best features list I've read (in recent memory): * 80's retro McCLIM user interface. * No documentation or online help. * Maximally frustrating color sliders, using IHS colorspace. * Intuitive modeless drawing UI, achieved by including only a pencil tool. * Saves/loads files only in its own format, based on unportable s-expressions. * Requires X11 and SBCL with threads, to keep out the riffraff. That's some refreshing honesty.
Does anyone know if the 1.0.34 release fixed the issues that complicated the Postabon ["A Simple Lisp Webapp for beginners"](http://www.reddit.com/r/lisp/?count=25&amp;after=t3_ajwlt) tutorial? The release notes say "minor incompatible change: threading support is now enabled by default on x86\[-64\] Linux", but [the bug](https://bugs.launchpad.net/sbcl/+bug/452684) is still marked as open. The tutorial doesn't indicate what version of SBCL was current at the time, though since it was posted the same day 1.0.34 was released, so I can only assume he wrote it against 1.0.33...
They ship the binary now with threading support enabled by default, yes. In the time of the said blog post you still had to rebuild to enable it yourself.
I'm looking forward to their Windows port. It would be really good to have a complete and free CL for windows. That one does not yet exist, I think, is partially what holds the language back.
Have you looked at CLISP or Clozure? Outside of threading support (admittedly, a huge thing), SBCL works well on Windows. That asked, I'm paying for a LispWorks Pro Windows license soon because I can't waste any more time fighting with various libraries/thread support.
Yup. CLisp and Clozure are available and supported on Windows. Clisp has experimental support for native threading though. One other option would be to look at ECL. You can compile it using MSYS and MINGW.
I'm using CLISP for now, but I read that its CLOS implementation wasn't complete. It was an incidental comment in a Peter Norvig article I recently read. Is it true? Honestly it doesn't affect me personally that much (I'm just a CL hobbyist - my day job is C++), but I more lament that there is no free CL implementation for Windows that's suitable for professional, production quality, work. Is threading support the only missing piece of SBCL? I was under the impression it was much more incomplete. I'll have to give it a try.
Because it makes it easy to write code that writes code.
Downvoted since there's a Scheme reddit which is much more appropriate.
Macro expansions are mostly much less transparent for a compiler, and can easily be less transparent for the user too. Further, code=data could also be seen as 'code as in only function use= data'. Also, in code, actually *not* all those parenthesis are needed..(strictly speaking, at some point readability could be damaged.) For instance if all functions have no &amp;optional/&amp;rest arguments, you could ditch all the parenthesis, changing to Polish notation. You can also recognize keywords to be keyword arguments if none of the functions take keywords as arguments. You could for instance demand keywords as values to be given with ':keyword, with the ' in there. (Edit: do i *need* to show it with code? It is easy, at least if i could get the argument lists of the functions.) None of this is new, of course, languages such as ML, Haskell use it. If one doesn't intend of macros all that often, such notation can actually be preferable. (Although some of Haskells.. i don't like '...' notation..) However, i do like the s-expression to still be available in such a case, and the lisps can *easily* implement such notation. To some extent, even, just using reader-macros! [Went a little crazy with those here](http://www.lispforum.com/viewtopic.php?f=20&amp;t=300) (cant say i can recommend using it!) All in all, my opinion is that Lisps *should* also offer some standard alternative notation, similar, or perhaps even compatible to those of ML. Combined with facilities like mathlab, mathematica, it might be able to fill that position. Edit: Don't get me wrong, i like parens, but i don't think they are necessarily *needed*. And not everyone is an experienced computer programmer, there is a reason Python is more popular. Having an notation easier on the newbies would allow them to switch to Lisp more naturally. You could even have a tool to convert back and forth between lispy notation and 'partly-Polish notation'. ML doesn't have anything silly like that afaik. Btw, making the 'alternative language' compatible with ML is silly btw, now i remember that you had to type '+.' for adding floating-points. (Annoying as hell..)
To investigate CLOS completeness, read the sources of closer-to-mop. http://common-lisp.net/project/closer/closer-mop.html As for SBCL on mswin, its missing threads, \r\n isn't translated as you might like, and select()-like behavior doesn't work for files (MS uses two descriptors per file). There may also be other, more obscure, oddities. AFAICT, Clozure has very good windows support.
See for example RLISP, used in the computer algebra software REDUCE. An example: http://www.zib.de/Symbolik/reduce/infopool/rlisp88/curve.txt 
Hmm, usually I write code that 'generates' code. This code is already data. Parentheses are an external thing. Generated code does not use any parentheses. For example I write a function to generate code that squares an argument: (defun gen-squared (arg) (list '* arg arg)) Note that we don't write: (defun gen-squared (arg) (list '|(| '* arg arg '|)| )) Parentheses are not a part of code generation. Now, if we WANT to write code, we can use PPRINT - which pretty prints the expression to a character stream (to a file, to the terminal, ...). (pprint (gen-squared 10)) Above pretty prints the code that is generated by GE-SQUARED. Only here is where we get parentheses. But it would be perfectly fine if we have a different pretty printer, which writes code in some form of infix syntax. Then we need a different reader, to read that back. That would be mostly equivalent. You can write code and read code - in a different syntax. Summary: code generation is independent from the data syntax, because it is in-memory and does not use s-expressions (s-expressions are only external syntax). Code generation in Lisp is special, because there is a primitive way to represent code as data (not as strings). There must be some other reason, 'why parens rock'. 
Having spent weeks stressing over this, my best advice is figure out what you need and let that drive your decision. Threads, if not already, will become a big deal for you. CLOS completeness probably isn't and won't be any time soon.
sorry, I forgot the URL... the title should link to: http://pvaneynd.livejournal.com/133491.html
I've heard advice to "avoid CLC" but it's usually accompanied by "use clbuild or friends".
I use CLC whenever there's a native package. When there's not, I download the source to ~/.clc/source/&lt;package&gt; and symlink the ".asd"s into ~/.clc/systems/. Then I use `(clc:clc-require &lt;package&gt;)` for everything. I've even got a simple script that goes through ~/.clc/source/ and updates all the VCS directories according to the system each one uses.
It works well so long as you consider Debian your platform.
Debian stable is my preferred platform. My personal experience was that the lisp packages were horribly old. Maybe this is not really a CLC problem, but at the end I found much easier to build my own sbcl etc.
The funny thing about the Common Lisp community is that the tip is usually rock solid. So having "stable" packages is less than useful. Use something like clbuild to pull down any libraries you need. With that said, it looks like the implementation is a lot simpler than it once was and it also seems to have clbuild integration. It may very well be a good option now.
The problem is that AFAIK clbuild doesn't do _anything_ for package maintainers, while Common Lisp Controller does.
And Fedora...
Yup, the Lisp reddit should be reserved for Lisp, not Scheme.
I can't believe so many Lispers are using MySQL. Guys, PostgreSQL is simply better--it's faster, it's more stable, it's more reliable.
That's a matter of Debian; I don't see how that can be CLC's fault unless CLC is somehow putting up obstacles to package updates. I use CLC for locally-installed packages in addition to the ones in Debian stable that aren't too old for me.
the situation reminds me a bit of the relationship between CPAN and debian. Using debian perl packages is convenient, but often they are old, or some modules are missing, so you end installing your own (or using integration hacks like dh-make-perl). 
I think it is relevant (at least) to people who are only trying Common Lisp -- it just works, and it is good for them. Other options are available, sure, but I think it makes sense to use them only once one needs something non-trivial. This way CLC provides a smoother learning curve.
Is it just me of does that look like a lot of noise and not much signal?
This is a good first effort, but there are a number of features I would like to see in something like this. I wish the graph extended back before his inauguration, but I imagine that the indirect references that are used to identify an Obama mention might need to be adjusted for that. Also, certain ways of mentioning him have slightly more or less friendly tones to them that, from the way the article describes the ObamaMeter's operation, I doubt it considers. For example: *"The President and his advisers met today to consider health care reform."* sounds much more positive than: *"Obama Administration officials conferred on health care legislation today."* ----- Note how neither actually says anything different, and neither says anything directly positive or negative. Neither offers an opinion, and both confine themselves to the facts. Nonetheless, the first statement sounds more friendly. This is done with word associations: "Consider" instead of "confer". We want people to "consider", it sounds open-minded and generous. "Confer" comes from the same root as conference, and implies that it is behind closed doors. "Reform" instead of "legislation". "Reform" implies that it is for the better... a clean up of a corrupt system; who wouldn't want reform? "Legislation" is associated with pork, and bureaucrats, and red-tape. "Advisers" instead of "officials". "Advisers" advise; advice is a friendly benevolent activity. "Officials" are seen as impersonal, even cruel. "The President" instead of "Obama administration". "The President", grants him the pomp and circumstance of the office. "Administration", grants the official quality, but without the glamor and glitter.
It's not just you, but that is a potentially interesting result in and of itself.
First, I never thought I'd see "John R. Lott" and "Common Lisp" in the same sentence. Second, from http://perceptionmetrics.com/pm/technology.aspx &gt;Profiler Plus basic language models for both English and Arabic are available along with a wide range of coding schemes developed for particular information extraction tasks, primarily for the analysis of psychological constructs and of media presentation of people and issues. Fascinating.
Sure is. And, as a bonus, I get paid to work on this stuff.
May the fleas of a thousand camels nest in your conses! You lucky dog.
&gt; Also, certain ways of mentioning him have slightly more or less friendly tones to them that, from the way the article describes the ObamaMeter's operation, I doubt it considers. IMHO, that's reading way too much into such a short passage of how it works. Considering how the president is addressed is in no way excluded by his wording; it would in fact be expected.
&gt; The funny thing about the Common Lisp community is that the tip is usually rock solid. So having "stable" packages is less than useful. Ã†h? You mean like how for example Gary King periodically rewrites all of his meta* packages to use a completely new package structure? Just because it doesn't crash most of the time doesn't mean it's "stable", especially not from the distro/deployment point of view.
I'm simply trying to point out that the ranking of a text by positive or negative connotation is a very subtle thing. The tone of an article that doesn't actually say anything positive or negative directly can nevertheless be set by the aggregate of associations from the wording it uses. I don't *KNOW* that the ObamaMeter does not do this, merely that the examples in the description do not include such subtlety.
I've started working on a Common Lisp pack for the Google AI Challenge 2010 but I probably can't put more time in it to turn in into an official starter pack. Anyway, here it is in the fourth forum post. Hopefully it's useful for someone else and perhaps it can be turned into an official pack with little work.
I recommend getting the file directly from http://clqr.berlios.de/ instead of cheatsheetheap.com.
Wow, that is nice!
Who is keeping Erik's website going?
God.
Did you guys know that Gabriel wrote several Worse is Better papers. The official Worse is Better page has them all: http://dreamsongs.com/WorseIsBetter.html
Was that sarcasm? Scheme is a Lisp.
I'd like to know that myself. I don't think it will be available indefinitely. 
Nice article but it does not mention [Rucksack](http://common-lisp.net/project/rucksack/).
The article also misses the following: - hu.dwim.serializer (formerly known as cl-serializer) a highly customizable and efficient (in terms of speed and binary representation) generic object serializer/deserializer - hu.dwim.rdbms (formerly known as cl-rdbms) a generic RDBMS/SQL interface providing efficient access to Postgresql, Oracle and Sqlite - hu.dwim.perec (formerly known as cl-perec) an efficient (in terms of tables, columns and caching) CLOS to RDBMS mapping (supporting 1-1, 1-n and m-n associations) with an optimizing query compiler and multi dimensional data support all of these are available through http://dwim.hu/ and have BSD licence 
Perhaps because it is the result of this survey / evaluation of existing solutions?
And because the article was written in 2004?
 Lord hallelujah! I've been waiting for something like this for eons.
Has anyone had any experience with Allegrocache?
The OP was about libraries written in _Common Lisp_ (j/k). It's also from 2004, when none of those libraries even existed. 
Glad to see that the wonderful Edi "etc etc" Weitz is still active in the lisp scene.
Any Berlin lispers out there willing to record it for the rest of us?
Yes please, don't let us miss Edi's talk.
Egad, who thinks 'hu.dwim.serializer' is a better name than 'cl-serializer'?!?
Time to wget --mirror?
I just did that. It missed a few files that the omniscient G had indexed. Had to do a few mirrors to get it all. Everything I found is in this tarball. http://libcl.com/tmp/erik_naggum.no.tar.bz2 Note that the tarball extracts into two directories. Let me know if I missed something. Someday, I might rewrite the URLs and extract these somewhere more permanent.
Very handy tool, thank you, xach.
Too bad they never record and/or publish the talks on Lisp meetings.
A good introduction to Lisp is this book: [Common Lisp: A Gentle Introduction to Symbolic Computation](http://www.cs.cmu.edu/~dst/LispBook/index.html) You have written a nice endless loop. Since 'int' is never changed anywhere in your code, for a number &gt; 0 the IF will always be true, and your code will never call RETURN. You can add PRINT statements (or use FORMAT, ...) to see what values your variables have.. You can also use a stepper to step through the execution. ((lambda ... ) ) makes no sense in your code. This construct is not often used. To write a sequence of forms use PROGN. You need to define variables. Setting random variables like COUNTER is wrong. Where is COUNTER defined? SUM-OF-DIGITS?
Clojure is what I had handy, so here's a Clojure solution. (defn reversed-digits ([n] (reversed-digits n 10)) ([n radix] (lazy-seq (when (pos? n) (let [left (quot n radix) digit (rem n radix)] (cons digit (reversed-digits left radix))))))) (defn add-digits ([n] (add-digits n 10)) ([n radix] (reduce + (reversed-digits n radix)))) 
Now you have solved it for him in a different language. Do you think his problem was to find somebody who would post a solution?
Hello fellow padawan. Here is an attempt at a rewrite: (defun add-digits-core(i running-total) (let ((clip (mod i 10))) (cond ((&lt; i 10) (+ clip running-total)) ((&gt; i 9) (add-digits-core (round (/ i 10)) (+ running-total clip)))))) (defun add-digits(i) (add-digits-core i 0)) The main insight is that integerp will only check if a division came out clean, which isn't of much help here. Instead you were looking for something like the round function to truncate the thing down, and also mod for cleaving off the last digit. The other point is that for this recursion example, add-digits-core is called again as the very last thing in the definition. Earlier, if there isn't much of a number left it'll just add up whats left and return it (as the final answer). This isn't part of a school program is it? Because I thought they were all phased out, with MIT representing the gold standard of transitions.
No, I just thought I'd give him an example. Thought it'd be more helpful than silence.
 CL-USER&gt; (defun add-digits (number) (loop for x = number then (round (/ x 10)) for d = (mod x 10) until (= x 0) sum d)) ADD-DIGITS CL-USER&gt; (add-digits 12) 3 CL-USER&gt; (add-digits 1234) 10 CL-USER&gt; (add-digits 1) 1 CL-USER&gt; (add-digits -5) 5 CL-USER&gt; (add-digits -532) 20 CL-USER&gt; (add-digits 532) 10 note that you will have to make some minor changes to make this work with negative numbers
Your indentation is confusing.
Since what he said implied that he has already ran the code, do you know what Lisp it is that allow code with undefined variables like that to run? ADDED: Ok, seeing `defun`, it's probably Common Lisp. So I'm guessing the code never reach the part and compiler assumed special variable there.
Note that CL does not guarantee tail-call optimization (unlike Scheme). And it is preferred to put a space between your functionname and the argumentlist. Sorry about being picky :( 
Most Common Lisp implementations will run that code when you use an interpreter. It just does not mean that it will do anything useful. Most compilers will complain. A compiler will already complain at: ((lambda (foo) ...) (lambda (foo bar) ...) (setf ...)) The compiler will note that the first function gets called with two arguments, but does expect only one. For an interpreter that does not matter - if the code has defects, but is never used, then the interpreter will not complain.
Nice one. I wanted to perform the division just once per iteration and so came up with this: (defun add-digits (num) (let ((sum 0)) (loop until (zerop num) do (multiple-value-bind (mod rem) (truncate num 10) (incf sum rem) (setf num mod)) finally (return (abs sum)))))
First, try not to use `loop` if you can. It's better to learn Lisp without using `loop`. Recursive and `map` is your friend. Use `loop` after you have learned when there's benefit for it, and even that, use only a tiny subset of it. `add-digits` is best written as recursive function. Let's say if `add-digits` takes integer `int`, there are only two case you need to handle: * If `int` is already one digit (i.e. less than 10) then that is the result of `add-digits`. * Otherwise the result is the last digit (int mod 10) plus result of `add-digits` of the remaining value (int div 10). Turn that into code and you get. (defun add-digits (int) (if (&lt; int 10) int ;; case 1 (+ (mod int 10) ;; case 2 (add-digits (floor int 10))))) One of your problem is that you don't know that Common Lisp has `floor` function which can be used in place of `div`. With that you won't need to jump around with that `counter`. Note that my code is not tail recursive, but I wouldn't care unless you have integer with that large amount of digit to blow the stack. Also I didn't check that `int` is actually integer, or that it must be positive. ADDED: Who the heck downmod this? Care to explain why?
Avoid setf if you can! If destructive approach turns out convenient, keep the side-effects locked up inside functions as much as possible! Note that variables set must **always** have been defined somewhere, and accessible in the scope by the function, a let form, a defvar or a defparameter (or anything else producing variables.) It might work otherwise, but it is *very* sloppy. I'd write it thusly: (Seems like most problems respond to recursive approaches.) (defun add-digits (n &amp;optional (base 10)) (if (= n 0) 0 (+ (mod n base) (add-digits (floor n base) base)))) Fairly confident that it would be tail-recursed, but you can write it with a DO-form i guess. Note that (floor n base) is the same as (floor (/ n base) 1) or (floor (/ n base)) Note that setf can sometimes also be applied to 'setf-functions' incase you might be confused, (defun (setf name) (set-to ...more args...) ..) supplants naming conventions other languages often have. The difference between setq and setf is just that setq cannot use setf-functions. Note that Loop doesn't really work that way. If you want to do something in loop: (loop do single-expression do single-expression) Needless to say, i find loop a little annoying sometimes. And it might be confusing to you too, perhaps in learning stage try stay away from it a little. You can use recursion / functions like MAPCAR / DO (if you find it cumbersome you can make a WHILE/UNTIL from it.) I also don't really get what you are trying to do with those lambdas.. The following: ((lambda (foo) (setf foo (/ foo 10)) int) ;This function will be run with arguments: (lambda (foo bar) (setf foo (+ foo bar)) sum-of-digits counter) ;this function (setf counter 0)) ;and the result of this, 0 But the top function only takes one argument, so that won't work. Kudos for learning lisp. It might be harder to learn, but a lightsaber is much more powerful than a mere blaster. Still, if you don't know other languages yet, if Lisp turns out too hard, try another, and come back.
I actually defined both variables to be zero a couple lines above the defun. I am indeed using Common Lisp.
Get a proper editor, one that can indent code properly for you. Don't put parens on a line by themselves. And they don't do what you think they do, this: ( (lambda (foo) (setf foo (/ foo 10)) int) (lambda (foo bar) (setf foo (+ foo bar)) sum-of-digits counter) (setf counter 0) ) Is not the same as C's `{ ... }`. And you chose the most confusing structure ever, you're calling anonymous function `(lambda (foo) (setf foo (/ foo 10)) int)` with an argument of `(lambda (foo bar) (setf foo (+ foo bar)) sum-of-digits counter)`. That's because `((lambda ...) foo bar baz)` is defined to be the same as `(funcall (lambda ...) foo bar baz)`. Unquoted list in Lisp is always function application, never a block, for that use `(progn form1 form2 ...)`. And again, use a real editor, it'd have alerted you by indenting the code differently to what you expected.
Ignore the naysayers who fear SETF and LOOP. This is Common Lisp, not Scheme. ;)
Now, with that out of the way, here's a clean, small, working version: (defun add-digits (int) ;; EDIT: as someone pointed out in another thread, using SUM instead of ;; COLLECT + REDUCE is even better (reduce #'+ (iter (for num initially int then (truncate num 10)) (while (&gt; num 0)) (collect (rem num 10))))) Some notes: 1. I don't have any qualms about using iteration instead of recursion. In fact, training yourself to rely on recursion unconditionally can bite you badly in CL when you run into data that blows up your stack. We don't have tail-call optimisation in the standard, so assuming it'll always be there is wrong. It's especially painful when you enable debugging and suddenly there's no TCO anymore, and you can't get to the original bug because the stack starts exploding in unrelated places. 2. Don't use LOOP, use [ITERATE](http://www.cliki.net/iterate). It's seventy-three times better and more lispy and has a very nice [manual](http://common-lisp.net/project/iterate/doc/index.html) 3. Although I use iteration to collect the digits, adding it up is best done with a nice REDUCE, so that's exactly what I do. CL is called multi-paradigm for a reason, we use the best tool in any given situation and mix them at will. Although Guy Steele would yell at me from his Fortress because REDUCE is not parallelisable, but you don't need to care :)
&gt; Needless to say, i find loop a little annoying sometimes. Don't loop, iterate! Although you have your own umac, which I still don't really get / see the point of, so you're probably not the best one to preach iterate to :)
floor also permits multiple-value-bind to get both the quotient and remainder from the same division. I agree with you on loop, and I have no hesitation to take advantage of the CL implementations with can do TCO.
You mean naysayers such as Steele, Gabriel, and Foderaro? Even loop's instigator, David Moon, seems to have recanted. See following around 7:30 in: http://www.ai.mit.edu/projects/dynlangs/wizards-quicktime-20mar01-fast.html 
I'm using emacs lisp-mode, I manually put the parens on their own lines. &gt;Unquoted list in Lisp is always function application Can you explain what you mean by this? I'm pretty sure emacs counts as a real editor though?
how... how... how does this work?
Can you explain what (+ (mod int 10) ... does?
Yes, very much so. But if you're manually overriding its indentation, you're shooting yourself in the foot. Learn to *use* the automatic indentation. Not only is it easier, you'll also learn to be suspect whenever it doesn't do what you expect, because 9 times out of 10, it means you've screwed something up. Although in this particular case, you also happen to have written code where it lines things up as if `( ... )` meant a block, so you just got unlucky.
 ((lambda (foo) (setf foo (/ foo 10)) int) ;This function will be run with arguments: (lambda (foo bar) (setf foo (+ foo bar)) sum-of-digits counter) ;this function (setf counter 0)) ;and the result of this, 0 What I was trying to do was have two separate lambdas: the first one like this, (lambda (foo) (setf foo (/ foo 10)) int) ; so that int is the argument Where *should* my argument go? 
Thanks. This is just for fun, I'm majoring in physics not CS.
It sums two numbers: 1. (mod int 10), ie. the remainder of the argument divided by 10 2. the result of recursively calling ourselves with the argument divided integrally by 10.
What are the various stereotypes associated with both? I am only choosing Common Lisp to learn as that is what my dad recommended; he used to do a lot of artificial intelligence work with lisp and smalltalk.
Though I don't really have any idea how your solution works, I appreciate the effort :p
Why did you use lambdas at all? Do you understand what LAMBDA does? `(lambda (foo) (setf foo (/ foo 10)) int)` returns a new anonymous value of type function, which when called with a single argument, will set its own (internal) binding of the argument `foo` to one-tenth of its initial value, then error out because SETF is called with an extra *place* (`int`), but no value to set it to. Even if it didn't error out, it'd still have no effect, because you're only setting variables bound within the lambda.
So, if I understand correctly, (mod 23 10) would equal 3? Holy crap that knowledge makes this problem a hell of a lot easier.
&gt; I actually defined both variables to be zero a couple lines above the defun Don't do that. Don't use special variables (aka. "global variables" from C) if you don't need to. And if you do, follow the convention and call them `*some-variable*`. But here not only do you not need them, using them is a serious mistake that will make code harder to read and understand and will create unnecessary coupling and non-obvious interactions.
Well, I tried this: (defvar counter 0) (defvar sum-of-digits 0) (defun add-digits (int) (loop (if (&gt; int 0) (if (integerp (/ int 10)) ((setf int (/ int 10)) (setf sum-of-digits (+ sum-of-digits counter)) (setf counter 0)) ((setf int (- int 1)) (setf counter (+ counter 1)))) (return sum-of-digits)))) But it returned error: Not the name of a function: (SETF INT (10)) error: Not the name of a function: (SETF INT (- INT 1)) So I figured I'd try turning them into anonymous functions! :) (by the way, is this indentation a bit more standard looking?)
Not stereotypes. Just that in Scheme, good style is to avoid iteration and destructive updates, and rely on recursive calls, which are guaranteed by the language to be optimised away if in tail position. But Scheme is a functional language. CL is not, and CL does *not* guarantee TCO, so insisting on recursion no matter what is not only groundless, it will bite you when your data gets larger.
I'm looking forward to debugging your portable code. Particularly when I declaim (optimize (debug 3)) and shit breaks because TCO is no longer in effect.
Oh, and in case you didn't know, pressing TAB in Emacs will get it to indent the current line to where it thinks it should be. That's what I meant by automatic indentation. It's pretty clear you didn't use it in your original snippet.
Uhhh, here's your problem. When you see an error, take time to *understand* it, don't just grab the first word and run with it. It complained because ((setf int (10)) ...) means "call the function named `(setf int (10))` with arguments ...". But that's not a valid function name. Blindly doing the first thing you can think of that has to do with "function" is asking for trouble, because you won't fix the problem; you'll mask it however until you have no idea what's going on anymore, and worse, no-one of the people you ask for help will have an idea of what you were trying to do. And yes, the indentation is correct now. Still somewhat misleading because of your trying to use parens to mean a block, but correct.
Yup, that's precisely what it means. [CLHS](http://www.lispworks.com/documentation/lw50/CLHS/Front/Contents.htm) is your best friend.
So, the if function can only handle one then and one else command? I think I understand what you mean about blocks now though, thanks.
I knew `floor` returns both quotient and remainder. My goal is to make code as clear and as straight forward from my english description as possible. That's why I didn't want to introduce `multiple-value-bind` or to take tail-recursive into consideration now. 
IF is not a function, but a special form. The difference is that functions always evaluate their arguments fully, whereas special forms don't need to (and IF indeed doesn't). But yes, each branch can have only a single form, if you need more, use `(progn form1 form2 ...)`. PROGN is a special form and equivalent to C's braces, in that it groups multiple expressions into a single compound expression. Unlike braces, however, PROGN (like everything else in Lisp) has a value, and it's the value of last form executed. That's why you don't use RETURN in Lisp most of the time (and your RETURN above was wrong and would error out, because there's no block named NIL active. To return from a named block, like a function, you'd use (return-from add-digits sum-of-digits). But as I said, it's needed only very rarely, and almost always implicit return values work fine).
Thanks a lot.
No problem. But the moral of the story is, read [PCL](http://www.gigamonkeys.com/book/) and learn the basics before you write code. Learning by doing is important, but that's not the same as groping in the dark.
I actually bought the book and have worked through the first four or five chapters already, hence knowing enough to grope around in the dark in the first place.
I see. Fair enough then, you got a crash course of the important concepts tonight. Make the best of it.
It seems like you can't find a way to put series of action in a single form. Common Lisp is not Haskell, no need to implement Monad. :-) If a control construct only accept one form, as does `if` in this case, use `progn` if you want to insert series of expressions. (if t (progn ;; do multiple thing in `t` condition. (format t "hello~%") ;; this print "hello" (format t "world~%"))) ;; this print "world" `progn` does nothing but group expressions together and returns the result of last expression. But if you are going to do something else in addition to that you can use more specific form instead. For example if you want to declare a variable to use inside scope of `if`. (if t (let ((x 10)) ;; this introduces a block, like progn, and also declare variable "x" (incf x) ;; increment x by 1 (format t "~a~%" x))) ;; then print out x Your problem seems to be that you haven't learned some basic forms/functions in CL yet, it is going to be hard to learn to program in any language when you don't know its basic constructs. I suggest taking a look at [Practical Common Lisp](http://www.gigamonkeys.com/book/).
`if` only takes one expression on each of its leg (true and false case). I see you tried to use parentheses to group multiple expression together, but it doesn't work like that. Use progn instead. (defun add-digits (int) (loop (if (&gt; int 0) (if (integerp (/ int 10)) (progn (setf int (/ int 10)) (setf sum-of-digits (+ sum-of-digits counter)) (setf counter 0)) (progn (setf int (- int 1)) (setf counter (+ counter 1)))) (return sum-of-digits)))) You can try edit Lisp code in emacs, grabbing some .emacs file on the internet from Lisp coder. Emacs usually help indenting Lisp code very well, it indent to where it should be regardless of how many TAB you press.
I've been using emacs for a very long time, thanks :) 
Yeah, I am really just beginning with lisp. I have PCL, only about five chapters into it so far. Thanks!
Nice bit of hostility in that downvote, mate. Pray tell why Lisp can't offer TCO in general! Pray tell why this language can't learn a lesson that Steele and Sussman taught us back in the mid seventies! If you consider the languages that have a strong following these days, they are BDFL languages rather than ANSI languages. That said, I have trouble with BDFL languages, because the dictators often show poor taste. (Significant white space, TCO as an evil, PERL worship) However, the take home point might be that for non-gov't contractors portability and ANSI compliance is a bit of a strawman in a world of good quality free implementations. Chill, dude!
&gt; Nice bit of hostility in that downvote, mate. Pray tell why Lisp can't offer TCO in general! Because. It's. Not. In. The. Standard. Which means it's automatically unportable AND it's not even guaranteed to be always there in implementations that provide TCO. Declaim `(debug 3)` in SBCL and watch it turn the TCO off. Which is hilarious when you try to debug some code, and then suddenly it breaks in unrelated places because it relied on TCO which has just disappeared. And by hilarious I mean I hope you enjoy having ice picks in your eyes. And no, I'm not going to chill, because it's little twats like you with "oh look how laid back I am" attitudes we have to clean up after when your shit breaks. Your nice wishes won't change the fact you're wrong when it comes to CL, and that it won't blow up in your face, it will blow up in *my* face precisely when I'm fucking trying to debug some other code I actually care about.
How very interesting. I'd like to continue this, but I was taught not to argue with boors. If you care to tone down the language, maybe we can have a reasonable discussion. 
Okay, let's try that. To rephrase: you say it's okay to rely on TCO because there's no reason "in general" that Lisp can't offer TCO, and I say it's bollocks, because it's not "in general", but the specific case of CL code with the number of undesirable properties TCO in it has, which additionally tend to seem to work, and then hurt only when you already have problems.
If I said that, I am truly sorry. I certainly don't think that lisps these days all do proper tail calls, and if I were to contract writing ANSI Common Lisp, relying on TCO would indeed be poor design. My trouble is that Uncle Sam pressured the Lisp vendors to nail something down that really didn't reflect what any of the standards participants would ideally like. A.C.L. is a great human endeavor, and like all human endeavors is flawed. I would like to see Lisp as a living language that can grow and change. I feel, perhaps as passionately as you disagree with me, that the ANSI document along with the difficulty of amending it freezes Lisp unhappily in 1994 with changes (improvement or not) considered with extreme hostility. A.C.L. is a nice departure point for a good Lisp; it is not the destination. This is not the view of an industrial software engineer but an idealist. Consider Smalltalk. I have, around here somewhere, the draft standard. I believe the standard was ratified in 1998. I think the current interest in the language would not have occurred if Smalltalk's inventors didn't have a notion of improving thing rather than simply leaving them where they stood. Whether or not Croquet, Squeak, Pharo, and Cuis consitute improvements or not isn't the point. The freedom to try improving is. I hope I've made clear that this isn't really about proper tail call implementation in Lisp as much as whether or not a language is best served by slavish adherence to what was rather than working toward what could be. I don't think there's much to be gained by slapping people around (metaphorically) when they write in "what lisp could/should be." That simply shuts off avenues of thought. Maybe if a named-let style labels expresses an iteration better than do&lt;foo&gt; or loop, maybe we should rethink the omission of proper tail calls from Common Lisp. If it helps understand me, I'll admit I've written far more Scheme than Lisp. Scheme paid bills and bought groceries. Lisp is a hobby. Whenever I hack lisp, I tend to find myself missing the control structures of Scheme assuming the existence of macros. 
2 That is a bad advice for a newcomer. 3 In what way it is best done with REDUCE? That it conses a list unnecessarily?
Not to split hairs, but Scheme is multiparadigmatic. Schools often teach a functional subset, but set! and friends are there for your err... hacking pleasure. (vis. SICP queues and memoization) Just don't count on a good grade in the case of their routine use. 
2 I seriously think not having to put up with LOOP is a very good thing, especially for a newcomer. It's atrocious and horribly at odds with everything else ever in the language. 3 In that when you have a list, summing it is best done with REDUCE. As the comment mentions, the obviously better solution is just to use the SUM clause in the first place.
Even though I liked what I read from Amsterdam's paper. I have to agree. Iterate is not standard either. Of course I'm one of those nut cases who while he'd prefer to be able to rely on TCO, would much rather read explicit (do...) or (do-&lt;foo&gt; ...) style macros. A while back, I visited lisp forum, and someone posted a loop over a hash table with (loop for foo being the hash-keys of bar...) only to use gethash later which was to my eyes gawd awful. The only reason I couldn't write a simple (do...) is that with-hash-table-iterator returns multiple values, both of which were needed. A (dohash (key val table) ...) was trivial to create, and resulted in code that, at least to my eyes, was far clearer, and had better expansion in the lisps I use.
Sure, and CL allows and doesn't mind functional code. But Scheme is still very, very strongly functional. And commonly accepted good Scheme style encourages functional programming to a much greater degree than CL. And it's very visible, with some dialects moving to make conses immutable for instance. That's not something you could ever do in CL, because that's not how we do things around here. We acknowledge the elegance of functional solutions where applicable, we might even do a little extra work to make them possible, but we ain't bending over backwards for that. And we don't have guaranteed TCO, so trying to be too functional has a cost it doesn't in Scheme.
2 That's your opinion, that's good, but forcing it upon somebody who can't judge for himself isn't good.
Note: "ACL" is not the best idea to say if you mean ANSI CL, because we have an implementation called ACL. Just like we have one called CLISP. Now, moving to your point, CL isn't perfect, and we all know that. It's the effect of a compromise to move forward while keeping old code working, and that's something extremely valuable and not to be given up lightly. That's why you're very strongly advised to keep to standard CL where possible, because we have the standard for a reason. As for the evolution, no-one ever intended ANSI CL to be the frozen, permanently untouchable Lisp forever. But ANSI is what we have right now, and we can't afford to go through the whole process again if we ever diverge in the way MacLisps did. That's why we're conservative, and work slowly and in a way designed to have some chance of reaching a consensus. We have [CDRs](http://cdr.eurolisp.org/), the CLtL3 proposal, but it's all done with the knowledge we probably won't have an ANSI working group ever again. And we don't have BDFLs either, because BDFL is precisely what CL isn't. It's a language of 50 years of keeping code running, compromise, consensus and multiple implementations. I'm not saying that wanting change and improvement is wrong, but I'm saying that happily ignoring the reality is not the right way to go about it. Come back when Python is 50 years old and you'll see what I mean.
It's my opinion that skipping LOOP and using ITERATE instead is a much better choice, especially for a novice. I don't see how I could arrive at a conclusion that not recommending it is better in this situation. And I'm not forcing it, I'm merely recommending based on personal experience. Not to mention that it's not some hack I just wrote yesterday and think is the greatest thing ever; it's a widely used library with known-solid implementation and a reasonable acceptance to replace something that's widely reviled and held by many to be the worst part of CL.
I'm unlikely to be alive when Python is fifty years old; I rather hope we'd have moved on from Python. Trouble is that legacy seems to keep us from ever casting anything aside. (ANSI CL (loop...) for instance). While I agree that keeping old stuff working is indeed valuable, this can be accomplished by maintaining implementations of the standard. But there is room for a better Lisp. I'm not sure that bible-selling the current standard is the way to move towards this better Lisp. Also I'm not sure it was such a bad time when there were a wide variety of dialects. I had hoped when I spaced out A.C.L, I'd avoid the ambiguity with Allegro. I don't like to write CL alone, because I hope CL evolves to something beyond and perhaps better than the ANSI spec. Minor nit: Lisp is half a century old, but ANSI CL is a far more recent phenomenon. Also, I'm not sure just how well the compromise and consensus was achieved with luminaries associated with the language decrying it as "significantly ugly."
Why am I receiving such negative press for pointing out that people strongly associated with Common Lisp from its inception don't care for loop? It wasn't I who wrote "kitschy pseudo-english keywords" in reference to the loop macro.
Here is a simpler implementation. (defun add-digits (number) (abs (loop for (mod rem) = (multiple-value-list (truncate number 10)) sum rem until (zerop mod) do (setf number mod))))
I really haven't been a major fan of ITERATE. Probably the main reason being that I have to import a whole bunch of symbols into my package. With that said, the ability to destructure multiple values is a major plus. I may very well use this more. (defun add-digits (number) (abs (iter (for (values mod rem) = (truncate number 10)) (sum rem) (until (zerop mod)) (setf number mod))))
If you look at Common Lisp, it is not trivial to get full TCO. If you look at the implementations of CL, they all differ in what they implement and in many places it looks more like a hack and not a careful designed language feature. The problem is the possible interaction with other language features in Common Lisp that create a dynamic scope. (defvar *foo* nil) (defun bar (baz) (let ((*foo* 3)) (foo (* *foo* 14)))) Suddenly the call to FOO is not necessarily a simple tail call, since the dynamic scope of \*foo\* is there. There are several such problems. Standard Scheme does not have special variables like that.
It is good style to attempt to write Lisp code for this and similar functions without global variables. The function the user calls should be without side effects. Even when writing an iterative (not functional) solution, it is best to keep all variables local.
In clojure, just for fun since the OP clearly wants CL help: Stack-consuming: (defn add-digits [n] (if (pos? n) (+ (rem n 10) (add-digits (int (/ n 10)))) 0)) Constant-space loop: (defn add-digits [n] (loop [n n s 0] (if (pos? n) (recur (int (/ n 10)) (+ s (rem n 10))) s))) Constant-space sequence: (defn add-digits [n] (reduce + (map #(rem % 10) (take-while pos? (iterate #(int (/ % 10)) n)))))
[Alternately.](http://www.reddit.com/r/lisp/comments/b1qy0/i_am_but_a_young_padawan_can_anyone_point_me_in/c0kjdqw)
Probably because it's not an issue a newbie needs to deal with.
x will be number in the first iteration and then the same nr without the last digit. d will be updated every iteration to be the last digit of x. We keep on looping until x equals 0 (so we processed all the digits). As long as it isn't zero we add the digit d to the total (that's what sum does). Yes, the loop macro is quite powerful, but might be a bit scary to start with.
Ah, my loop-fu is weak!
Named let is your friend =) (define (addnum num) (let loop ((n num) (a 0)) (if (= n 0) a (loop (quotient n 10) (+ a (remainder n 10)))))) Sure it is recursive, but looks so much better than the usual extra helper function that are usually taught.
This is beautiful :) Not as beautiful as the recursive versions, but wow :)
Thank you. I had forgotten that specials introduce stack-like behavior. It also occurred to me that the condition system might introduce warts that might make proper tail calls painful for a Lisp implementer. 
This recursive approach is much more Lispy: (defun add-digits (int &amp;optional (accum 0)) (if (&gt; int 0) (let ((last-digit (mod int 10))) (add-digits (/ (- int last-digit) 10) (+ accum last-digit))) accum)) This recursive procedure If you don't like the optional argument in the function definition, you can hide it using an inner function which does the real work: (defun add-digits (int) (labels ((inner (int accum) (if (&gt; int 0) (let ((last-digit (mod int 10))) (inner (/ (- int last-digit) 10) (+ accum last-digit))) accum))) (internal int 0))) EDIT: The tail call in this code *can* be optimized.
&gt; Note that CL does not guarantee tail-call optimization (unlike Scheme). Interesting - that's the first I've heard that. A Lisp implementation without TCO is pretty brain-dead, IMO - I wouldn't touch it. There are plenty of good open source and proprietary compilers that support it: Lispworks, Allegro, CMUCL, SBCL and CLisp. I'd say - use tail calls unless you absolutely have to support a non-TCO compiler.
Idiomatic Common LIsp looks like this (defun digits (number base) "Least significant first" (if (zerop number) '() (multiple-value-bind (quotient remainder) (floor number base) (cons remainder (digits quotient base))))) finished off with (defun digit-sum (number base) (reduce #'+ (digits number base))) The point of splitting the code into two functions is that it is really easy to debug DIGITS. The individual digits haven't been mashed together. Crowe-style is (defun digits (number base) (etypecase number ((eql 0) '()) ((integer 1 *) (multiple-value-bind (quotient remainder) (floor number base) (cons remainder (digits quotient base)))))) I like putting CL:ETYPECASE early in my functions because I get to use Common Lisp's fancy type system to say things about what should be in the function arguments. That is good for documentation and for catching errors early.
You're mistaking ANY, which is a symbol, with 'ANY, which is an abbreviation of (QUOTE ANY) - a cons. &gt; (type-of (elt #('any 'any 'any) 0)) CONS &gt; (type-of (elt #(any any any) 0)) SYMBOL 
Compare (let ((x 'y)) #(x x x)) =&gt; #(x x x) (let ((x 'y)) (vector x x x)) =&gt; #(Y Y Y) (let ((x 'y)) (vector 'x 'x 'x)) =&gt; #(X X X) The reader interprets #(... as syntax for a vector, that is the reader allocates space and fills it with S-expressions read from the input. When EVAL tries to evaluate a vector, it looks at the first element then says, "No, hang on a minute, that is only for lists, I don't do anything with vectors." So the result is a vector containing the forms in the input, unevaluated. Since 'a is an abbreviation for (quote a) ie (quote . (a . nil)) your vector contains conses. The news group comp.lang.lisp is still active and gives good answers to good questions. You have put a bit of work into trying to solve the problem yourself and have described that work so your question would be regarded as a good question and get a several prompt and friendly responses. 
also: &gt;Compare 153 with 150. The only thing I've changed is 'any to to-put, which has the value 'any. Not true. You've changed 'ANY to *symbol* TO-PUT, not the *variable*.
It has nothing to do with arrays. It is how quotes work. `'any` does not mean "symbol any", it means `(quote any)`. `(quote ...)` returns ..., that's how it works. `(quote (foo bar))` returns `(FOO BAR)` (a list). `(quote (quote bar))` returns `(QUOTE BAR)`. That is, if you have nested quotes, you will see quote special operators. `'('any 'any 'any)` is `(quote ((quote any) (quote any) (quote any)))`. When you evaluate it, you'll have `((quote any) (quote any) (quote any))`, a list whose first element is `(quote any)`, that is, a list itself. Hope this helps... Quote can be used to denote a symbol or a constant list, but you should be careful. Note that you can create only a constant list this way. If you want variables to be pasted into list, you should use function `list` rather than quote. E.g (type-of (elt (make-array 3 :initial-contents (list 'any 'any 'any)) 0)) will work as expected. &gt; Compare 153 with 150. The only thing I've changed is 'any to to-put, which has the value 'any. You will be surprised that array contains symbol to-put rather than symbol any. You should use list function if you want to access variables. 
Ah, I wasn't realizing what the nested quotes would do. I don't think I got the ramifications of double-nesting quotes like that. Thanks!
Ah, thanks! I didn't check what was inside the array directly (although I was printing it out prior to like 153, and not realizing I should see *ANY*, not *'ANY*).
Thanks for responding. I wasn't thinking about how #( ) would turn off evaluation inside. When printing out something inside the array, I saw *'ANY* and didn't realize I should be seeing *ANY*. I'll be sure to check out comp.lang.lisp in the future. I've never waded into newsgroups, but I guess this is as good a time as any! :)
For various reasons, Common Lisp doesn't guarantee tail call optimisation, making a recursive version fairly impractical.
Note the difference between the quoting of forms and the evaluation result of [1] and [2] below: [1]&gt; (type-of (elt (make-array 3 :initial-contents '('any 'any 'any)) 0)) CONS [2]&gt; (type-of (elt (make-array 3 :initial-contents '(any any any)) 0)) SYMBOL
Dunno; controversial statements tend to have this effect... LOOP isn't the greatest thing since sliced bread; but it actually is good for a wide range of tasks. Its current replacements aren't much better. Shivers' idea looks good; but it doesn't appear to have any CL implementations yet. http://www.ccs.neu.edu/home/shivers/citations.html#loop
Scheme was a fork of the early lisp languages. It introduced lexically-scoped variables to lisp (amazingly, this was controversial), tail-call optimization and other strong support for purely-functional programming, and focused on a small pure core. Common Lisp went the other way, standardizing on LOOP and other parts of the kitchen sink. It is a big spec, with more functionality, but more messes as well. With the latest R6RS standard, Scheme started becoming "big" like CL. This caused quite a stir, and the next standard committee is looking at defining two specs, a small core and an upward-compatible big system. For various reasons (CLOS, separate symbol-value and symbol-function, VALUES, ...) I'm in the CL camp. But there are good reasons to like Scheme. IMO, TCO isn't one of them (it should be a special form). Then again, CL's dynamic variables should probably also be accessed via a special form. Another major difference: Scheme touts "hygienic" macros, while many CL users will claim this "hygiene" is an unnecessary mess.
In most (all?) of these implementations, TCO depends on the optimization settings. IMO, TCO is a brain-dead optimization; for debugging, I generally do want those stack frames. TCO also forces functions to be designed around it, silently breaking if I tweak them improperly, and it doesn't work as well between mutually recursive functions. I'd rather have a special form that explicitly states which frames to elide, and can signal a compilation error when the enclosing body prevents this.
I have been trying to understand what exactly tail call optimization actually is for the better part of the day. Is there a better explanation than the wikipedia?
Dude, writing with LOOP is often much clearer than using MAP and recursion. Sometimes it's not. Use the right tool for the job. LOOP often is that right tool.
When a compiler supports TCO, an appropriately structured recursive function can be translated (by the compiler) into an iterative function. SICP has a comparison of the two [here](http://mitpress.mit.edu/sicp/full-text/sicp/book/node15.html). In fact, SICP is a really good introduction to a lot of computing concepts. Scheme makes a guarantee that under the right conditions this optimisation will be made, whereas the same is possible for some Common Lisp implementations, but isn't portable or necessarily available under all circumstances.
&gt; IMO, TCO is a brain-dead optimization; for debugging, I generally do want those stack frames. Of course, but not in compiled code. &gt; TCO also forces functions to be designed around it, silently breaking if I tweak them improperly, I've not heard of this. Could you give an example? 
As I said: 1. Don't start learning first with loop. 2. Use it when you you learn its pros/cons. 3. Even then, use a tiny subset of it. Loop is clearer than map and recursion when you have a clear idea of what it will come out to be. Use only a tiny subset that you and your co-worker see obviously what it does. Don't excercise every combination of its avaible keyword to write your entire function in a single `loop` expression just because you can. Keep in mind that it is a beginner we are aiming our advise to here. You suspect any experienced programmer *from any other language* will write code like that? I'd rather let him find `loop` on his own after he knows enough, not encouraging to see how wonderful `loop` is and written the whole function as a loop macro like he did there. I'm not anti-loop purist. Do you see where I said one must neve use `loop` or that one who uses it is an idiot? I only suggest that he learn the basic first. Yes, everyone can have varying degree of their level of `loop` usages, what I don't get is why would you downmod me for some non-consensus non-trolling advice like that. You can't accept another point of view? I'm not expecting any upmod, I just don't expect to get a same comment point as obvious-troll or nonsense-stupid level. You see how he code that `loop` and I got -3 for suggesting that a newbie learn it properly first? Give me a break. ADDED: Yeah, now see his final *improved* solution, and glad that you have encourage one to write C in Lisp.
Actually, these days, i mostly just use MAPCAR, recursion, and more rarely: (defmacro denest (&amp;rest args) (if (null (cdr args)) (car args) `(,@(car args) (denest ,@(cdr args))))) I changed the [berlios website](http://lisp-umac.berlios.de/main.html) a quite a while earlier. The version that i use [denest.lisp](http://lisp-umac.berlios.de/src/denest.lisp)(maybe a little different, i really need to recheck the Berlios stuff..) seems a little too ill-thought-out at the moment though. Comes with under-tested macros, and i think i shouldn't have complicated the denest macro. Maybe i will revisit it at some point. Iterate has some things to be annoyed from too, though, firstly i didn't find the source code very nice.(maybe i should look again) More importantly, things like 'collect'(jng), 'sum'(ming) aren't functions, so they don't really jive well with functional code, and i think it should. Probably already told you this though :) Perhaps i have 'reinvent the wheel', or rather 'that wheel looks a little square' syndrome..
I agree with you when you write: &gt; Don't excercise every combination of its avaible keyword to write your entire function in a single loop expression just because you can. That makes perfect sense, and applies to just about anything in Common Lisp, including all the possible arguments to, say, FIND. But I disagree that LOOP should be avoided at first: it is in many cases far, far clearer than any alternative. There's nothing wrong with LOOP--no, it's not terribly Lispy. Neither's FORMAT, but that doesn't mean that one should avoid it. Why did I downvote you? Because the advice 'don't use LOOP' is essentially wrong. It's a valuable and useful part of Common Lisp. It _is_ somewhere in between trolling and being nonsensically stupid. I'd downvote someone who posted a Ruby solution too. Yes, his final 'improved' version needs work. But that's not LOOP's fault, but more being a newbie. We all started somewhere.
&gt; Because the advice 'don't use LOOP' is essentially wrong. My advice was "try not to use `loop`" and "Use loop after you have learned", not "don't ever use `loop`", have you even read the entire comment yet? But whatever, it's not like a karma point is going to do me any good anyway.
Have you never debugged compiled code? TCO is an overly aggressive form of garbage collection; GC should be invisible. As such, it should be explicitly invoked by the programmer. As for an example of its fragility, take a tail-recursive function. Wrap its body or just the tail call in nearly any piece of code. The function is no longer tail-recursive, and the compiler (generally) won't even peep. Now imagine that wrapping was performed by a helpful macro which changed slightly since you first wrote the code.
Hmmm... I do most of my debugging on Lispworks, which recompiles functions without the optimization when you enter the code in the stepper, so I never miss the stack frames. Without this, I guess I'd agree debugging could be a pain. I don't quite follow: "GC should be invisible/it should be explicitly invoked". How is TCO-triggered GC any worse than a regular GC? &gt; Wrap its body or just the tail call in nearly any piece of code. Wrap its body or just the tail call in nearly any piece of code. The function is no longer tail-recursive, and the compiler (generally) won't even peep. The rules for TCO are pretty clear. If an author puts his tail call in a non-tail call optimizable context, that's his bad. The helper macro example is bit more compelling. A defensive programmer would avoid putting a tail call inside a custom macro for this reason. 
Version 1.1 does the busybox-style "link many names to one executable" trick.
Can anyone recommend online resources on T? I remember reading about it in a variety of Lispers' retrospective papers (Steele, Gabriel) but I've never seen any original source material. EDIT: [Wikipedia doesn't let me down](http://en.wikipedia.org/wiki/T_\(programming_language\))
Arc? 2002? has he been working on it _that_ long?!?
programming languages take a long, long time to make work and even more for them to mature and become popular
It's funny that the author of the two best Common Lisp books should dislike the language so much.
"There's only two types of languages; the ones that people complain about, and the ones nobody uses" (--- Strousstrup, probably paraphrased)
not _that_ long, and certainly not if you implement it on top of another scheme implementation.
ANSI Common Lisp is not a good book for learning Common Lisp.
He has said he spent a long time exploring the problem space, but since he hasn't published any details of that exploration (only the apparent final destination, Arc), it doesn't particularly help anyone.
With a little [correction](http://www.cs.northwestern.edu/academics/courses/325/readings/graham/graham-notes.html) to Grahams coding style, I think it's still the best introduction to Common Lisp, though Practical Common Lisp comes close. I would recommend Ansi Common Lisp just for the handy Common Lisp reference in the appendix.
I strongly disagree. The shabby treatment of anything that isn't sufficiently close to Graham's ideal Lisp (packages, CLOS, LOOP, lisp-2-ness, etc) leaves newcomers to CL with a warped impression of the language. As for references, it's much better to get intimately acquainted with the real specification as a reference. It's probably useful to read _after_ you have enough CL context to appreciate where ANSI Common Lisp is going off the rails.
cool. thanks. I figured you might have some more insight.
huh. I didn't know that. can you recommend another better intro/beginner level book for CL?
For an introduction, [Practical Common Lisp](http://www.gigamonkeys.com/book/) is pretty good. That's how I got started. Never finished though. I ended up mostly reading CLTL2, the specification and lots of code.
The thing that took so long wasn't coding it; it was figuring out what to code.
Lispworks may disable TCO in the stepper, but what do you do when a signal occurs after many stack frames have been elided? How do you debug code that now blows the stack on its inputs? A regular GC, by design, is invisible to the programmer -- except that memory seems limitless. A TCO, by design, is visible when the programmer or program looks at the stack frames. To me, that's an intrusion I want control over. TCO is useful, but silent TCO is a tad dangerous.
In most of today's programming languages, each function call creates a new "stack frame" -- a chunk of memory holding the function's local variables. So if a recursive function calls itself, you will have 10 stack frames for that function, each holding slightly different values. Tail-call optimization (TCO) is based on the observation that "purely functional" functions often don't need those intermediate recursive frames. It is sufficient to destructively reuse the recursion's first stack frame and return the result to the calling function. With a deeply recursive function, this can result in significant memory savings. Many implementations require the recursive call to be to the same function (so the frame layout is unchanged). To be eligible for TCO, a recursive call must be in a location where the call's return value can be passed directly to the current caller.
It looks like Rich Hickey was fiddling around with CL/Java bridges, developed and then made Clojure popular all in the time span between 2002 and now. But Hickey hasn't been running a VC company and promoting it by being a niche internet celebrity during that time either. It all depends on where one decides to spend one's time. One get the feeling that Arc just isn't a priority for Graham, which is fine. He says he's writing a language to be used in the future, so he can take his time and mull it over. Hickey insists that his language is pragmatic and intended to be used right now (and it's an intelligent looting of ideas from CL, Scheme and Haskell). One may not agree with all the decisions he's made, but he has good taste in general.
xach has a very important point here. Especially packages and CLOS are so important when you write software and also when you want to use existing libraries. Both need and deserve a much better treatment then what 'ANSI CL' offers. [Practical Common Lisp](http://www.gigamonkeys.com/book/) is a more enthusiastic introduction, has more useful examples and covers especially the parts of the language that are most needed to write code. The book gets you started writing code and that's a perspective I like very much. 
My critique of CL: I think Lisp-2 stands in the way of using functions as first-class values and thus using higher-order functions. It also complicates the various namespace-related functions by requiring a duplicate version of each for the function namespace. It's funny, but every time I ask why it is useful at all, I get the same example: so I can use the name "list" for a variable. Seriously, does this sound like a reasonable reason? They could call the function make-list, or even use a convention of an initial capital letter, and it'd be better for composing higher-order functions. I think another problematic issue in all the Lisps is sub-optimal use of naming. For example, as alternatives to car, cdr, cons, I'd prefer either of (first, second, pair) or (head, tail, cons). I think the prevalent use of concrete lists and iterating them everywhere is also problematic in a non-lazy language like Lisp, because it means that a lot of functions cannot be used on other kinds of containers without first copying them. Compare to Python's iterator protocol as a counter-example - which allows any kind of sequence to be used anywhere that expects a sequence. Also, after having used Haskell for a while, I really miss the curried function style (for easy partial application) in every other language that I use. I also miss return-type polymorphism, allowing me to implement and use functions like filterM.
Your critique of Common Lisp does not go very deep. There are much better ones. To address your points: * Common Lisp is not a Lisp-2. It is a Lisp-n with several namespaces for different things. Yes, functions and values have a different namespace. * You don't need duplicate versions of namespace-related functions. What functions are needed depends on the nature of the namespace. * The function namespace has a specific reason: it allows to ensure that everything in this namespace are functions. You can't bring anything else into this namespace. In contrast the value namespace supports all types as values. The function namespace ensures that in (foo 1 2) FOO is a function. There is no need to check at runtime if foo is a function. Contrast that with Scheme, where foo can be anything and (foo 2 3) will fail if foo is the number 1. In Common Lisp you can't set the function of FOO to 1 - the language prevents that. Using just one namespace for everything is a design decision and allows to simplify the language (a design goal for Scheme), but why should a language be constrained by this? Why should every language mechanism be forced to reuse the same namespace? Imagine also in Scheme, in your program, you have many functions and one is called BAZ. Now somebody writes (define (bar ... baz ...) ... much code (foo baz) ... more code ... (baz ...) ... more code ...). Now the code refers to the function baz, but it is not your baz, but the variable baz. To be able to call your function, one needs to rename the variable, or pass it in under a different name. * Using a convention for naming things, is a very weak version of a namespace. * FIRST, SECOND, ..., REST etc. exist in Common Lisp from day one. * Common Lisp has a SEQUENCE abstraction that combines lists, general vectors and strings. * Haskell is a different language and has different design decisions. The designers of Common Lisp wanted argument lists with positional, optional and keyword arguments. That design decision shaped the way how functions are defined, called and combined. Haskell does not directly provide Common Lisp's rich lambda lists. FINALLY: * the function namespace greatly enhances the readability for code using higher-order functions. It is easy to spot where functions are called or passed. If you have ever stared at complex functional Scheme code, then you might know what I mean. 
&gt; Your critique of Common Lisp does not go very deep. There are much better ones. First, thanks for your response, my knowledge of CL indeed doesn't run very deep - my critique is based on first impressions, and I'd love to have my mistakes corrected. &gt; Common Lisp is not a Lisp-2. It is a Lisp-n with several namespaces for different things. Yes, functions and values have a different namespace. It seems to me that that only complicates things further, is there a good reason for this? &gt; You don't need duplicate versions of namespace-related functions. What functions are needed depends on the nature of the namespace I distinctly remember there were a bunch of functions that were simply duplicated (e.g: let vs. flet, etc.) &gt; There is no need to check at runtime if foo is a function Thanks! Finally I see a better reason. However, there's still the runtime check for correct argument lists, correct use of their types, etc. So isn't the saving here negligible? Is it worth the extra complication? &gt; FIRST, SECOND, ..., REST etc. exist in Common Lisp from day one. They don't do quite what I was talking about. I was talking about cons pairs as an example of bad names (car, cdr, cons seem unrelated to each other, based on their names), not lists. &gt; Common Lisp has a SEQUENCE abstraction that combines lists, general vectors and strings. When you use things like "mapcar" or other such functions - won't that make the code specific to lists? &gt; Haskell is a different language and has different design decisions. The designers of Common Lisp wanted argument lists with positional, optional and keyword arguments. That design decision shaped the way how functions are defined, called and combined. Haskell does not directly provide Common Lisp's rich lambda lists. I am not sure what you mean by "rich lambda lists", can you give an example in CL that is difficult to express in Haskell?
&gt; It seems to me that that only complicates things further, is there a good reason for this? Different things may need different types of namespaces. &gt; flet vs.let Right. Anything else? But strictly it is not needed, one could define a LET that supports both namespaces. &gt; check for runtime check for correct argument lists ... (flet ((foo (a) a)) ... (foo a) ...) Why would you need a runtime check for above? FOO is the local function and there is no way to change that. The arglist can be statically checked by a Lisp compiler. What do you want to check at runtime? &gt; I was talking about cons pairs as an example of bad names But you were talking in terms of FIRST, REST, TAIL, HEAD - which has nothing to do with cons cells. These are names of list concepts. &gt; When you use things like "mapcar" or other such functions - won't that make the code specific to lists? use MAP, which works with SEQUENCEs CL-USER 218 &gt; (map 'string #'code-char '(99 65 82)) "cAR" &gt; rich lambda lists positional, optional and keyword arguments, these can be emulated in Haskell. But it is not built-in. The ANSI CL standard calls them [ordinary lambda lists](http://www.lispworks.com/documentation/HyperSpec/Body/03_da.htm). 
&gt; Right. Anything else? But strictly it is not needed, one could define a LET that supports both namespaces. Well, besides let/flet, there's a bunch of let variants (let*, etc), as well as a bunch of test-if-in-namespace functions that are also duplicated. I guess pretty much everything that operates on the namespace without caring about the actual value is duplicated. &gt; Why would you need a runtime check for above? FOO is the local function and there is no way to change that. The arglist can be statically checked by a Lisp compiler. What do you want to check at runtime? If it is locally defined, you also don't need the separate namespace, the compiler can simply verify that it is a function. We're talking about saving dynamic checks - those are only necessary for non-local symbols. In that case, the separate namespace saves you the is-function runtime check, but doesn't save you the arg list verification/etc. &gt; But you were talking in terms of FIRST, REST, TAIL, HEAD - which has nothing to do with cons cells. These are names of list concepts. I was talking about cons cells, not lists. I said it would be nice if "cons" was called "pair" with "first" and "second" being its cells. Clearly this means that list accessors would use different names. &gt; use MAP, which works with SEQUENCEs Ah, thanks. I guess I was simply wrong about the lack of a sequence protocol. Why do "mapcar" and other list-specific functions exist though? &gt; positional, optional and keyword arguments, these can be emulated in Haskell. But it is not built-in. Ok, I see. I still prefer curried form over keyword arguments, though it's nice to have a mixture of both (Agda style).
| is duplicated test-in-namespace? what would that be? There isn't really such a thing. There is the additional issue that symbols have more than a value, they can have a value, a function, a property list and more. Calling a global function uses the function cell of a symbol. Generally symbols are not used for the namespaces. In local functions, no symbols are involved. So you can test whether the various parts of a symbol are bound. Scheme does not provide such symbols. Symbols in Scheme don't have functions, property lists, packages, ... &gt; If it is locally defined, you also don't need the separate namespace, the compiler can simply verify that it is a function. It can't if one can change the binding. (let ((foo (lambda () 'foo))) (setq foo (eval (read))) ...) Any code that changes the variable can set it to something. If you disallow these changes, then the problem could go away. Same: (define (foo bar) (bar 'foo)) FOO can be passed everything. In Common Lisp you can to write: (defun foo (bar) (declare (function bar)) (funcall bar 'foo)) and the compiler can assume that the value of BAR is a function. &gt; "first" and "second" being its cells. I don't think FIRST and SECOND are good names to access cons cell parts. &gt; Why do "mapcar" and other list-specific functions exist though? Backwards compatibility, providing more primitive functionality, ... &gt; curried form over keyword arguments I don't like that for maintainable software. It favors a style for mathematicians, which creates unreadable code with all kinds of implicit assumptions that can't be read from code. Anyway, Common Lisp is like it is and it will not change anytime soon. Dealing with the namespaces for functions and values is a non-issue for most software. Learning to use FLET and LABELS is not that difficult. The theoretical advantage of Scheme by having only LET is for real code not existing, since Scheme in general lacks so much stuff in its language base or provides them in a way that users of Common Lisp don't like. The design trends in Scheme (-&gt; R6RS) are controversial even between Scheme users. 
&gt; The design trends in Scheme (-&gt; R6RS) are controversial even between Scheme users. *So* controversial that the next revision of the spec will be split into two specs. As much as CL is a PITA with certain things, you at least don't have to worry about the things Schemers do (although things like SRFI-0 &amp; SRFI-7 help a bit).
There are variants on let in Scheme as well: let* exists in both languages, and Scheme provides letrec, the lexically scoped define and the alternative "named let" syntax as well. The reason it provides all these binding constructs is that Schemers find them all useful; namespaces really have very little to do with it. On the other hand, having the single unified namespace made macros a real challenge for Scheme for many years; back when Common Lisp was being designed in the early '80s, people didn't really know how to put together the "hygienic" macro systems, and you really need hygienic macro systems if you're going to have a single namespace for values and functions. Separate function cells were one of the things that made a major problem in Scheme into a virtual non-issue in Common Lisp. Once you get the hang of the language, FLET, LABELS and FUNCALL provide no barrier to doing functional programming. 
R6RS defined Scheme as a dynamically typed static/batch language. Something like ML without a type system and more parentheses. That's kind of tragic.
Dunno; I think it's a great time to expand with other dialects &amp; ideas. I've always had to know what Scheme system I'm using before I get too heavily into it, so I was looking forward to things like [Nausicaa](http://github.com/marcomaggi/nausicaa), or even a revival of Snow! atop R6RS, but it seems like much of the enthusiasm has died down for R6RS. I've been working on my own system, inspired by Otter; When otter failed to materialize, I started writing this one. 'Tis fun. As to your specific point here, I find it funny when errors come back in Ypsilon, showing that your code has been wrapped in a BEGIN, so that it can fit into the new "library or batch" model. *le sigh*
You wrote: &gt; First, try not to use loop if you can. And, even more damningly: &gt; It's better to learn Lisp without using loop. Those are immoderate statements. Frankly, they are absurd. LOOP is a valid and important part of Lisp--just as valid and important as REMOVE-IF-NOT or MAPCAR. Again: your advice was wrong, period.
All I see there is Go source code. How about some code written in the language it implements?
Stay tuned...
This is the ultimate proggit headline. If the link was to the project on github, it would be the trifecta.
One click is too much for you? [Project on Github](http://github.com/bobappleyard/golisp)
Posting a link to your own blog on Reddit? -1 point for style. Anyway, writing a Go interpreter in Lisp would've been cooler.
My reading comprehension: bad. :(
I'd argue its the ANSI committee itself that is the cause of this. Packages and CLOS are from my (admittedly very newbie) point of view woefully under-utilized by the language itself. 
That doesn't seem likely to me. It hasn't caused problems for other people doing a good job documenting those features.
Could you point out where CLOS or packages are used in the ANSI standard? I realize they're well documented (although things like MOP being outside the standard) but in my reading of CLHS they certainly seem 'isolated' from the rest of the language. I.E everything in a single package, nothing being defined in terms of objects. Essentially it feels like you could remove CLOS or packages from the spec, and other than the sections defining those, nothing would really change. Although many rely heavily on both of these to great effect (myself included) what's it say when the language designers themselves don't use packages? Or why can't I extend find with my own method to support my own sequence types? This isn't meant to be a biting criticism of ANSI CL, more that Paul Graham's style does not appear to be unique to him, from my reading of the spec. 
Pfft. Why shouldn't he post his own blog? It's interesting, original work, and he got it in the right subreddit. If it was crap it would be downvoted. 
The standard defines two packages, COMMON-LISP and COMMON-LISP-USER. Using a single package for standard symbols is very, very different from not using packages at all. Sweeping them under the rug, as Paul Graham does, with "they confuse me, so maybe they're gross" is shameful. Every value is an object in Common Lisp, and is a member of a specific class that can be used for dispatching in DEFMETHOD. There are a lot of standard generic functions. With SBCL, you _can_ extend FIND with your own sequence types, and other implementations could follow its lead. It's done very cleanly with packages and CLOS.
Compared to any other modern language, CL's usage of packages is lacking. I agree that in terms of objects CL is rich. But I'll state again, in terms of core functionality, CL is simply not defined in terms of generic functions. And going through the index, the vast majority of standard generic functions are simply supporting the CLOS ecosystem. This is separate from the sequence based core, where the vast majority of data structure manipulation functionality is. Sorting, unions, reducing simply isn't there in the default language for user defined types. While its great that modern implementations like SBCL are supporting these things, my point was that, by using its own defining standard (and examples found within) as an example, you'd end up with a style very similar to Grahams. 
You end up with a style very similar to Graham's if you find CL distasteful and its features not worthy of careful consideration. If you use its own defining standard, and the community of enthusiastic CL users, you end up with Practical Common Lisp.
I'll defer to your knowledge of CL here. But from my readings, CLOS was not fully endorsed by all at the time Graham wrote his books. I take this from my own reading of CLHS, the fact that the ANSI committee accepted the CLOS standard later in the process, and from Guy Steele's preface to Cltl2, and other contemporary texts. But if you want to say that Graham simply had it in for CL from day one, and that his writings are not a product of their time, that the style used by contemporary lisp writers and coders has always been as such, I'll defer to you. 
&gt; if you want to say that Graham simply had it in for CL from day one That's what Graham himself says in the linked article. Contemporary Lisp writers used objects, packages, etc like crazy on Symbolics Lisp Machines, another system for which Graham has expressed contempt.
My only problem with that book was the Java style package names.
Witness self.programming and the incessant "Look at this pointless trivial web site I made!" posts that, inexplicably, aren't immediately downvoted into oblivion. Same principle. 
Would you have preferred I create a sockpuppet account?
It depends more on web site triviality than on who posted it, no? There was a bot called `gst` some time ago here, he was posting articles from all programming-related blogs, it seems, without looking at quality. Nobody really complained. Shit gets downvoted.
Yeah, those are pretty gross. A few Lispers have started using them, but IMHO that's a sign of major bad taste.
No, thanks.
Since there's no Lisp content, it's hard to call this the right subreddit.
Descriptions of Lisp implementation strategies are about as Lispy as content gets. 
For a serious effort, see Joe Marshall's MIT Scheme in C#. Toy Lisps are a nickel a dozen.
Well, yeah. It doesn't get much Lispier than putting together a toy Lisp for the hell of it.
when you type those words in caps... are you using caps lock, shift, or some completion?
It seems the latest CommonMusic release made this book obsolette. The latest CommonMusic is based on Scheme, so all the code examples won't work on CM 3.5.0 There is a source tarball for CommonMusic for Common Lisp, but I didn't succeeded building it. 
Please mention it on their mailing list. It helps showing interest and the CL version, though older, should still be usable.
The newest change in the Rucksack cvs seems to be from 8 months ago, has it been abandoned? 
I'm not sure, but it looks like it is in a stale development. The [uCliki](http://common-lisp.net/~dcrampsie/ucliki.tar.gz) â€” the Cliki successor relies on Rucksack as a data-store back end. It might get more attention when the uCliki reaches stable/production-ready state.
&gt;One may not agree with all the decisions he's made, but he has good taste in general. I've always like his writing and essays but for me Arc is a non-starter. All these cryptic unreadable names. He made the classic mistake: mistaking terse for *concise*.
&gt;I think Lisp-2 stands in the way of using functions as first-class values and thus using higher-order functions. No, being a Lisp-2 (or n as pointed out below) makes it more like other languages. In e.g. C# you don't have to worry about names of your classes or methods colliding with a variable name somewhere. Being a lisp-1 is the main reason I've never really looked at Clojure.
Reminds me to the Nu programming language http://en.wikipedia.org/wiki/Nu_(programming_language)
Fantastic, I hope that the project gains momentum. I need to reup my efforts to get good at Lisp programming...
Sadly, that means very little. "Everything is a file" is a meaningful metaphor, it gives a clear picture of what it means, what are its motivations and consequences. But "everything is a lambda" is devoid of meaning, it doesn't lead to any concrete solutions or organisation of things. It's about as useful as "justice" or "world peace" are for deriving actual social rules. There are useful models based on lambda calculus, like [the W7 kernel](http://fare.tunes.org/tmp/emergent/secureos.htm) for instance. But that's a concrete model, not just a name desperately looking for something to attach to.
It's more like "everything is an actor", in the sense of the Actor model. We tried a less worked-out version of it on the Newton. I'll try the more worked-out version of it, if I ever get around to it. So many shiny ideas; so few years in one life.
The MIT Lisp Machine OS is actually **Flavoros**: Flavors + OS. Everything interesting is a Flavors instance. You can send them messages. Everything on the screen is also a flavors instance. You can inspect it, send it a message, change it, ... The basic UI interaction with it is done via the mouse and keyboard. The mouse has its own process (today we would say a thread) and when you move it around, the process looks what is underneath the mouse and sends that object messages. If you click, the mouse process sends a message, too. There is an organizing principle behind this, but it is not originally a visual metaphor. The organizing principle is based on the 'object model' of Flavors (with multiple inheritance, dynamic changes, message sending, Mixins, ...) and the results are shaped by applying Flavors to, well, everything. Under 'Unix' everything is a file, files are organized in a hierarchy and files can be processed in pipes. In 'Flavoros' everything is a flavor instance, flavors are organized in linked relations and processing is done via sending messages. In Unix these files are either short-lived (temporary) or persistent (files in a file system on disk/tape/...). In Flavoros the flavor instances are living as long somebody needs them (they are linked from somewhere). Persistence is done via dumping an image. In the advanced version of Flavoros they are persisted in a database (Statice). Later a higher-level user interface principle was added. It is based on 'information presentation'. It is not directly a visual metaphor in the sense of 'desktop', 'rooms', but a level deeper. The main influence seems to be AIPS from BBN: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.81.7903 
That was a very fun read.
In C# you also have to worry about names of methods colliding with names of members. I'm not quite sure what you're talking about...
That makes two of us. :) C# is probably a bad example since being completely OO hides a lot of the name collisions that Lisp would have to worry about.
&gt; Unquoted list in Lisp is always function application This means that: (foo bar) means call function foo with argument bar. '(foo bar) on the other hand means a list of elements foo and bar.
I think 'closures can be objects' is best explained with code examples, [like here](http://okmij.org/ftp/Scheme/oop-in-fp.txt). (Edit: yep, i did get it via OP link) Objects, closures, and (hash/association) tables, the filesystem all have something in common, they can all find values based on names. Indeed, i have seen other people use defmethods and defuns where i found my object via a hashtable. Perhaps they should somehow be unified? I can also imagine defining a 'class-derive' function for hashtables (Just make the getter also get from the classes derived from.) Back to tables, these different types of tables all have different areas where they're efficient on different grounds. For instance for access based on names: * Structures are efficient on all counts when the type and the slot is known at compile-time; then the offset is compiled-in. * Plain tables are efficient for small amounts of names, or when space is a bigger consideration than speed. * Hashtables when lots of names are needed and speed is essensial. Just realizing i don't know how to list them all, etcetera. (In any of these, if all names, and the accessing of names are known at compile-time, they could be turned automatically to a form of structure) So in CL, in principle, get-slots, gethash, getf, "get-file" (latter doesn't actually exist.) could all just as well be named 'get'.(besides the point that name is already taken) NOTE: haven't i been reading? he said pretty much the same thing.. I can imagine you protesting on "get-file", i mean get-slots, gethash all take two arguments. Well, (in the context of talking about filesystems) you could do two things; Either files in this scheme have slots obtained with (get-file file slot), then files are objects. Or you see get-file to get a file from a filesystem; you have multiple. I always found it silly that there is only one; it forces developers/users choose which kind of organization to put in the filesystem, and which others somewhere else arbitrarily. About class derivation, and such, I do fear thinking in terms of programming experience, i think category theory might be rather important and useful in this. Unfortunately i don't know it. I know enough, however, that derivation of objects and such fit into it: (edit: pretty much indulging myself in adding this..) * Objects have slots, let all slots be differently named. * Let an arrow; arrow(object) between two vertices be derivation; it is the function that adds the slots of object to another object; arrow(object)(another-object). * Now obviously arrow(object-one)arrow(object-two) = arrow(arrow(object-one)(object-two)), {objectâˆˆAll\_objects : arrow(object)} so 'no exit' part of definition satisfied. * Since they are functions, so is associativity, and there is an identity arrow based on arrow(empty\_object). Got definition [from here(pdf)](http://www.math.uu.nl/people/jvoosten/syllabi/catsmoeder.pdf),(difficult text) [easier pdf](http://www.reddit.com/r/programming/comments/84xb2/category_theory_for_beginners_slides_pdf/?already_submitted=true).
[This](http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html) includes the same, plus a koan about Qc Na, the master programmer. **tl;dr:** closures are a poor man's objects; objects are a poor man's closures.
I have to say, I'm more be interested in a calendar, an address book, a mail client, etc. written with objects or closures or ... than a PDF about category theory. Mikel talks about how it might look and feel to implement applications in something like a Frame system (which is kind of an object system), which provides some kind of encapsulation/security in a networked environment. That you can implement an object system using closures is technically on the same level as implementing numbers and number arithmetic using closures. Theoretically useful, practically mostly useless. I would wish we would talk again about programming languages and their implementations based on the needs which arise when implementing software - not based on the needs by people wanting to write Ph.D. papers on category theory.
The OP speaks of operating systems, in a way closely related to programming languages. In such a terrain, one would want to thread in a well-thought-out fashion. A lot of stuff is potentially going to be based on it. *Of course* i continue speaking in the same fashion in replying. But you are right, we need actual applications aswel. But i think needs which arise in implementing software are better served with libraries, not new languages, and that CL (for instance) is pretty good for that. It seems likely that if we are to make a better Lisp, made for the area CL is made for(and more, hopefully) we will find a way to effectively load CL libraries(**not** via backwards compatibility, though) into it. Similarly for a lisp OS. As for specific applications, I am working on [a markup/gui(latter not yet) system](http://lisp-editor.berlios.de/) for different outputs(in markup/guis). I have already made autodocumentation in it (and scanning of code with 'expression-hooks' with it.) It is far from finished, though. The webpage is written in with it.(Also webpage bit out of date here and there [particularly this page](http://lisp-editor.berlios.de/GIL.html#GIL), i changed that..)
[obligatory](http://xkcd.com/224/)
I just saw this link in a comment on a link from the Programming Reddit. Such a classic song. Don't forget this [Lisp XKCD](http://xkcd.com/297/)
Congrats to GÃ¡bor Melis for putting CL as the highest non-C++ entry on the leaderboard. Once he entered the competition he was always somewhere at the top with his bot. I'm also curious who "positron" is. I didn't do too well myself. I had two initial approaches that were sub-optimal but which I had to get out of my system and when I got somewhat rolling with a promising approach I got ill during the last week of the competition.
Please let this song die. And let it be buried next to the Free Software song. Really, people, this is embarrassing.
That's also my strong opinion, CL is pretty good. Let's use it.
Fine, but who's this Gerald Jay Sussman guy, and why's he part of the group?
[He is a guy who learned programming from Moses](http://groups.google.com/group/scheme-reports-wg1/msg/524a239d7acd6197).
I'm not sure that a guy starting his RPG with one thread per NPC is a good example for all lisp beginners like me. But, as all lispers, I hate clojure, thus I'll not fall on this trap.
&gt; And let it be buried next to the Free Software song. But don't you want to be a... freeeeeee hacker?
This one is pretty silly. The Lisp code just calls C code with FFI. Writing a CL-only library to do the work is pretty easy, and more interesting to me.
&gt; I'm currently coauthoring with Dan the next book in the "Little Schemer" series. *squeal* ----- by the way, WG2's (although the members are TBD) introductions are at http://groups.google.com/group/scheme-reports-wg2/browse_frm/thread/4175d4e547419749# .
Spelling mock: &gt;Each resource record is encoded as yet another list of Lisp primatives chimpanzees, gorillas, etc.
*noobtroll* I cannot see myself ever using something like this. Still interesting.
Also he has been doing lisp before I was born ....
I don't find Lisp-like interfaces to built-in facilities "silly".
It's less silly than a bare exposing of the C API with C-style function names, sure. But still silly.
Why is it silly? Do you want to rewrite the whole TCP stack, because you shy away from interfacing to the OS TCP stack?
Drawing any sort of conclusions regarding Lisp vs. Java based on interfacing with the system TCP stack with FFI would also be silly.
Why? I find interfacing with the TCP stack important, not silly at all and equally important how higher-level language like Java and Lisp deal with that. How do they decode low-level data-structures, how do they support memory management, how efficient are FFI calls, how much typing is it, can it be automated (and is the result usable), how does an object-layer on top of the FFI look like, how safe are foreign calls, etc.
It is interesting to see how Lisp handles decoding low-level data structures. This DNS library pushes that interesting work off to a C library via FFI. A Lisp-only library that e.g. does RFC-compliant DNS packet parsing and synthesis would be much more interesting, and would be applicable in areas where libresolv isn't available.
A Lisp-only library would be interesting, but an interface to an existing one via FFI is fine, too. I found that 90% of machines I use have a resolver in the OS, written in C. The remaining ones are Symbolics, which have a slightly outdated resolver in Lisp - where I had to look at the source from time to time to find the source of some problems. The point of the article was not to write new Lisp infrastructure, but to learn some Lisp and to compare it with prior Java experience - via interfacing to some foreign library. I think that's fine and Lisp experts with several years experience should not look down at the first steps of somebody coming from Java... I see that the the 'pure Lisp' idea gets mindshare. That's great.
I thought it was silly in 2004 when he wrote about it on his blog, too. :)
I think he was talking about Rich Hickey (Clojure), not Paul Graham (Arc).
That's silly.
Ah, you're correct. My bad.
&gt; The last Java program I was working on was an implementation of a DNS resolver that allows a programmer access to every native DNS data time This might be a stupid question, but what is a data time?
Reminds me of [this](http://jwz.livejournal.com/424854.html). For those too lazy to click the link: &gt;Associate Member Referral: "For every three new members who name you as their inspiration for joining, your choice of FSF founder and president Richard Stallman or FSF counsel and scholar Eben Moglen will record a personalized greeting ready for use on your answering machine. Greet your callers with a prominent voice of software freedom." Unfortunately, the original link to the FSF's page for this died.
Spelling error. Data item. 
Just to qualify what I'm about to say: I'm just an ECL user and tinkerer. I've said it before - the main maintainer of ECL, Juan, is awesome. Juan puts in a lot of work on this project, so consistently: he answers mailing list posts, he answers emails, he fixes bugs, he is always friendly, and ECL has grown as others are inspired to help. I think maybe he thrives on other people using ECL and contributing. Its a thing of beauty. 
Gmane seems to be down.
Ostensibly, yes. Honestly, we hacked most of it together with Perl.
Some of you may laugh at the naivety of this but I've been wanting to learn a programming language for a while - but I didn't know which. I'm now convinced.
I'm not laughing. One of the reasons I felt compelled to learn Lisp initially was after seeing [fluxus](http://www.pawfal.org/fluxus/) (another live coding platform based on Scheme).
Everything is a flavor, except for things that aren't.
Positron is Matei Conovici.
The things that aren't Flavor-based are often pre-Flavors or just the low-level machine that enables the Flavor-based stuff.
[PDF] tag missing
[HTML transcription.](http://userweb.cs.utexas.edu/users/EWD/transcriptions/EWD12xx/EWD1284.html) 
Great paper, regardless of the missing tags on the link title. I'm curious about the Operating Systems comment; Any Canadians wish to shed some light on OS research in Canada (older the better)? I think the hubbub surrounding the inclusion of recursion is quite interesting; We think now that it could easily be solved by various optimizations (such as tail calls) and that it's quite equivalent to iteration, and yet it was an issue just some 50 years ago. Amazing.
Thanks. He has very neat hand-writing, but it was still giving me fits as far as reading quickly was concerned.
Very little real computer science research happens in Canada any more. Everyone is concerned about "getting jobs", so practical comp. sci (read: java etc) gets thought. It is really kind of sad. Enrollments are down, because students believe that even if they do finish an undergrad course, that they will be outsourced in a very short time-span...
Nice; so it's effectively the same situation as the US (for most but not all schools). It's funny considering that Canada used to have a great emphasis on computing (recall Turing &amp; the UNISYS Icon systems). Lovely. 
Agree. Ecl has gone a long way and can now be considered one of the few full featured / complete Common Lisp implementations, with some unique capabilities: * Works on any OS (Windows, Linux, MacOSX, *BSD, Solaris) * Can be embedded easily * Works on any CPU * Full feature set on every platform (eg threads are available everywhere)
If I were a teacher of Computer Science, I would assign this paper for reading. It's a marvelous summary of the history of Computer Science as it emerged mid-century from a first-hand observer. Wow.
downvoted for surprise pdf.
As a software developer living in Toronto, I could go on and on and on about knee-jerk, cowardly, no-vision software "solutions" impelemented here. I did a year long stint in NY at IBM T.J. Watson center in Yorktown Heights and Hawthorn. It was SO refreshing. I asked my boss "do you have a standard for doing 'x'" - he said "no, but if you come up with something, and it works, it will become standard." Working for a major Canadian bank (they are huge here ok), they would not let me upgrade from one SPRING java jar file to another - they needed to have a LAWYER look at it (WTF??). Then they told me no open source, and i told them, all their web apps are run with open source (struts, SPRING, Xerces, Xalan, Apache etc..), then they turned white, and went to their "happy place" - they just focused out, and went pale.. The management here are just wimps... First software approaches need to be proven elsewhere (USA only - European software is too 'socialist') for years and years, and then, they will take the least useful approach and half-assedly implement it... Fundamentally, people driving technology policies at large institutions in Canada are people who do not have a technology background. They have a marketing or accounting background. Small companies will just grab the simplest shrink-wrap Microsoft solution and deploy it - people that can maintain it are dime-a-dozen... Canada does NOT innovate - look at RIM - what's the last thing they innovated? 
To be fair, you could replace most of what you said with many companies within the US &amp; the same criticism would be accurate. I'm surprised about the "socialist" comment though, considering that Canada is certainly more European-leaning when it comes to many social policies (I know this is changing, but, as a whole, it's certainly still true). 
What part of CL did he talk about?
Interesting. Hadn't ever really thought about the significance of calling it a programming *language*, i do have the idea that (bad) programming languages can constrain the mind, but +anecdote, and with such an important concept as recursion! &gt; Industry suffers from the managerial dogma that for the sake of stability and continuity, the company should be independent of the competence of individual employees. Hence industry rejects any methodological proposal that can be viewed as making intellectual demands on its work force. This is bookmarked! This explains a lot in terms of why some so goddamn crappy things are 'industry standard'. And it is from someone that [could be considered significant](http://en.wikipedia.org/wiki/Edsger_W._Dijkstra).
what is "socialist software"?!
I've worked at only one American company (IBM) in NY, and it was an absolute pleasure. Visionaries, "go for it" attitude - I really like it. This does not exist here. Our banking system is extremely conservative, as a matter of fact, ALL business here is extremely conservative. In our banking system, the management rule #1 is - screw the other manager, #2 socialize, #3 lots of politicking and in the end, perhaps even try to do their jobs. You see, the bonus system in Canada is really screwed - the salaries are high, and the bonuses are tiny, and then they are taxed at 50%, so there is NO INCENTIVE to work hard, or to innovate - priority #4 is enlarge the number of people reporting to you... And because there is no incentive to innovate, there is no innovation in banking either - perhaps that is why we never had the banking crisis that you folks had - these ones here are too stupid to figure out these complex banking instruments that were the source of your banking bubble... - all our banks are busy ripping us off - there is only 5 banks here - Toronto Dominion, Canadian Imperial Bank of Commerce, Bank of Montreal, Royal Bank of Canada and Bank of Nova Scotia ... Because they are conservative, they do not outsource their software development to third world countries - they are very scared of that.. 
What is the url for Stella or any of the other material this book covers?
Within the conservative Canadian Banking System - Open Source..
Upvoted for non-sequitur: "We must come to the conclusion that, like Love, the mathematization of computer programming is a bad sailor." 
I've never worked for a large shop; I've a few friends who've been burned by IBM. I would note that you *were* working at the R&amp;D "HQ" of IBM; your experience might have been different had you been working in another location. I've had dinner at Bob Samuelson's house (VP of Storage), and I must admit his description of his group was quite visionary, but, again, I've heard more horrors than pleasures. I must say the incentive situation is interesting; I've always known that Canada had higher taxes on certain things, but this is pretty interesting. Seems like progress is being traded for stability whole sale. At least this means though that your job is unlikely to be outsourced. :D
As someone else mentioned, you were at Watson labs. That's a bit like wandering through the Louvre and using the experience to guess at the artistic merits of Belarus. :)
If working for a bank or insurance company, the chances of being outsourced to a 3rd world country is highly unlikely, being outsourced to a Canadian software company is quite possible. My wife works for a Canadian software services company, and one of the "big five" banks outsourced large chunks of database support and maintenance and software development to them... I am a freelance software developer, so I don't get bonuses any more, but when I was working for a bank, the biggest bonus I ever got was about 8% of my salary (and that was taxes at 50%) - so, if you make 80K a year, you get a bonus of $6400 which gets taxed, so your take home is $3200 - hardly the AIG levels ;-). In the technical field, that is the bonus level of full-timers. It is probably different for senior management. Smaller companies are even worse for bonuses, so the old motto applies here - "get all the money up front, bonuses can and will disappear".... The bonuses are always optional, and can easily disappear. Kodak used to have a great bonus scheme (I used to work for Kodak Canada at one point) - they had a multiplier, that was the same for ALL employees of Kodak world wide. They would do the following: for every $1000 you made over the last 5 years, they multiply that by the multiplier. So, if you make for sake of making this simple - $50K for the last five years, and the multiplier is 21, your bonus is: 50*5*21 = $5250 (and then that gets taxed by the government where you live) - this way, even a Kodak janitor living in a third world country gets a bonus that makes sense in his environment... 
&gt;Industry suffers from the managerial dogma that for the sake of stability and continuity, the company should be independent of the competence of individual employees. Hence industry rejects any methodological proposal that can be viewed as making intellectual demands on its work force. I've never seen the reason for the collapse of the human species put so beautifully and succinctly. We don't rely on people to think, create and contribute - we just require them to be enslaved and submissive. 
In a lot of cases that would look rather a lot like more typical command line affairs.
Neat. I've always thought the REPL would be better off having some good way of wrapping up something in parens. However, I wonder if it might be better left in the interpreter. I'm thinking maybe SLIME ought to have a binding for SHIFT-TAB that wraps whatever's on the prompt in parens, or something to that effect. 
Why the downvotes.. Validly pointed out, first to do so. Not to be overrated, but..
Small bonuses is worse then no-bonuses, (which isn't necessarily bad) because having the bonuses in the first place implies those are the reason to strive, whereas otherwise it would be goodwill. Which is a stronger motivator than one would think. I think we need to get rid of the carrot-and-stick more and more of the 'do the right thing', and internal motivation to do something well.
My understanding of this situation is that the rest of the computer world eventually settled upon C-style string syntax, possibly with local extensions. Lisp already had string support, and it looked nothing like C-style string syntax. You get a combination of history and practice, depending on the dialect you're using.
yes?
This marvellous article embodies some of Dijkstra's most well-known quotes. I'm surprised I'm seeing it for the first time. P.S. The article has nearly nothing to do with LISP, but it is still great.
it's only related... but you can extend the reader of most environments, which we did for the test suite of a lisp -&gt; javascript compiler, where constant string escaping would have been annoying. so we used two unicode character for quoting: ï½¢ and ï½£. this is read as a literal string: ï½¢`js(let ((x "x")) (setf x (+ "before" x "after")) (print x))ï½£ 
I did something much like this in Pocket Scheme, supplying outermost parens (where missing) and closing all pending right-parens. Would have been nice to have known about Warnock's prior art.
People don't realize that not everybody is in full possession of single-click Acrobat Readers, high-resolution screens, high-bandwidth connections, or even eyes in good working condition.
&gt; LISP had its serious shortcomings: what became known as "shallow binding" (and created a hacker's paradise) was an ordinary design mistake; also its promotion of the idea that a programming language should be able to formulate its own interpreter (which then could be used as the language's definition) has caused a lot of confusion because the incestuous idea of self-definition was fundamentally flawed. What self-definition issue is he referring to here?
In firefox, there is always preferences-&gt;applications-&gt;find pdf and then set behavior you want.
&gt; In firefox There's none on my mobile device. &gt; and then set behavior you want. I want an antivirus scanner which doesn't forcefully insert itself into the conversation unasked, large screen with high resolution, a high-bandwidth connection, and a set of eyes in good working condition (I have the latter, but I know people who don't). Is it really too much to ask for a [PDF] postfix on reddit links?
Interlisp-D's REPL had a variant on this. It didn't "read" input until you hit enter, and then it read from the typed stream until it ran out. If it read one form, it would EVAL it. If it read two forms, with the first one an atom and the second one a list, it essentially did (EVAL (cons first-form second-form)). So, you could type: (+ 1 2 3) or + (1 2 3) EDIT: formatting
&gt; Is it really too much to ask for a [PDF] postfix on reddit links? Never meant to imply that it is..
Why didn't they make a \*repl-hook\* :/ Tadah: (setq *repl-hook* (lambda (str) (format nil "(~s)" str))) Or slightly more complicated if it works on a stream; (setq *repl-hook* (lambda (stream) (make-concatenated-stream (make-string-input-stream "(")) stream (make-string-input-stream ")"))))) Hooks rock, add them to stuff! Hmm maybe i should look at this code, and see how to make this sort-of hook-lib instead, and then provide some defaults. Perhaps there should be a \*repl-expr-hook\* (expr stands for expression) too, going right after the reading, and accepting macros. Then (setq \*repl-expr-hook\* (macro-function 'some-macro)) would use that macro on your thing. Infact, outer-parentheses-free REPL with (setq \*repl-expr-hook\* (macro-function 'progn)) would be a outer-parentheses-required REPL again. On on aside, i'd have preffered it if the REPL evaluated if you entered shift-enter and not otherwise, but usually i use 'scraps-files' and C-M-x to evaluate bits of it. Was going to whine about not being able to stop infinite loops with it, but why the hell didn't i check [the manual](http://common-lisp.net/project/slime/doc/html/Recovery.html#Recovery).. Still it seems like Now i mentioned it, about expression hooks, i made [a lib](http://lisp-editor.berlios.de/DEFPACKAGE_EXPRESSION-HOOK.html#DEFPACKAGE_EXPRESSION-HOOK) that implements them, although it doesn't work with environment well enough.(yet) It can scan all the code i myself have written.(As the autodocs show.) The whole project and website around it is still in development and stuff, btw. I am planning to make a text with central principles(/methaphors) of the GIL project, and see if i can get a little community to build stuff around it, the [current document](http://lisp-editor.berlios.de/GIL.html#GIL) isn't good enough. Edit: [source](http://www.ojasper.nl/src/lisp/little-repl/repl.lisp), [autodoc](http://ojasper.nl/DEFPACKAGE_LITTLE-REPL.html#DEFPACKAGE_LITTLE-REPL)
Interlisp also had super-parens, which could close all previously occurring parens.
Well, I don't see anything wrong with outsourcing to the company your wife works at. For one, if they do a better job, then it might be worth the expense. This is not a jab against your wife, but I don't *think* most of these outsourcing experiments actually save as much money as they had originally hoped (especially some of the more odd ones). I remember bonuses; I've only received one, and the company fell over shortly after the bonuses went out :D I've worked mostly for not-for-profits or on my own; I've never received bonuses whilst working in either (and have had to guard against what you mention), but I've certainly been happier than those working in larger shops. The bonus system used by kodak is interesting; it certainly makes sense to bonus everyone at some equitable &amp; easily determined rate. Profit sharing is another idea I've had, but I've never had enough to share :D 
LispWorks Lisp Listener: CL-USER 94 &gt; + 1 2 3 6 CL-USER 95 &gt; list 'foo 'bar (FOO BAR) 
What happens if one enters a symbol name alone? Is the function called or the value printed?
Meta-circular evaluator I suppose.
the value. There are also commands that are written as keywords and can be used with and without parameters. :his for example prints the Listener history (the last 20). 
I've considered automatic outer parentheses when thinking about how lisp could be used conveniently as a shell. That's when you want to be able to fire off commands with minimal typing. 
In SLIME, C-RET or M-RET close any unmatched parenthesis and then evaluate the current input in Lisp. Isn't that enough?
Is the book still coming out this month?
What's the issue, though?
I've been using a similar dictionary passing mechanism to implement Haskell-like monad sugar in scheme. That said, I curry the function and pass it as an argument to the result rather than as the first argument. This lets me build macros for things like do sugar that can be used like: (define (modify f) (do (x &lt;- get) (put (f x))) The result is polymorphic in the choice of monad that provides state because do returns a function from a dictionary to a monadic value, and the get and put combinators expect that dictionary to be passed to their results and dispatch to appropriate methods. This also has the nice side effect that it can be done with hygienic macros.
I think that most companies need to show the shareholders that they are addressing the software development costs by "doing something about it". Once again, it is really a knee-jerk response. I fundamentally disagree that a company should outsource it's crown jewels. I think that the best way to do it is to outsource the crap boring stuff, that requires no real intelligence, but does need a technical person, however, keep a staff of senior people who know what they are doing, and understand how the whole system works... The company where I am currently consulting has taken the approach where they are mostly outsourcing the really crappy work (making pretty JSPs for example), while consultants and senior full timers design and architect the systems (and also do the real tricky stuff)... 
&gt; I think that most companies need to show the shareholders that they &gt; are addressing the software development costs by "doing something &gt; about it". Once again, it is really a knee-jerk response. Agreed; it's mostly "Look what we did! We saved 1 BRAZILLIAN dollars" with lots of hand waving to avoid noticing the "1 BRAZILLIAN - 1 dollars" price tag. &gt;I fundamentally disagree that a company should outsource it's crown &gt; jewels. I think that the best way to do it is to outsource the crap &gt; boring stuff, that requires no real intelligence, but does need a &gt; technical person, however, keep a staff of senior people who know &gt; what they are doing, and understand how the whole system works... That was actually my point, although I didn't word it as clearly as you do: there are *certain* things that can be outsourced effectively, although I would point out that these are things that might take advantage of automation as well. &gt;The company where I am currently consulting has taken the approach &gt; where they are mostly outsourcing the really crappy work (making &gt; pretty JSPs for example), while consultants and senior full timers &gt; design and architect the systems (and also do the real tricky stuff)... Not a bad approach; I think that there are areas of almost *every* business that rely upon domain experts, and that you loose knowledge &amp; efficiency by treating these people as cogs to be replaced. Of course, I also think that DSLs are a great way to engage these people, so I'm already on the losing side of that battle :D
According to the publishers [website](http://nostarch.com/lisp.htm), its due in March 2010, and on [Amazon](http://amzn.com/1593272006) it says March 28, 2010.
Thank you. I expected the release date to be written at the top of the amazon page, near the price. 
There is only one problem. Where will the future senior developers come from one day, unless we let them do the boring junior stuff for a few years first. :-(
Well, there is boring &amp;/| tedious, and then there is *mind-numbingly boring*, which need not be masticated upon to be a junior dev. I think every system has maintenance that could be handed off to juniors for a short time, but there is no reason why these people have to run basic tech support in order to move up. 
I didn't know about this. The obvious question... why is this implemented?
I have no idea. Probably someone wanted to save a level of parentheses when using the Listener. Similar on the Lisp Machine, where the closing parentheses sends the expression. Also there are commands. Show Directory /foo/bar/* is similar to (directory "/foo/bar/*") But the commands offer history, command completion, argument completion, prompts, arglist type checking, generated input forms and more.
Ugh, why do people still believe in bonuses? The employee bonus system is horrible. Basically they take some % of your salary and give you the opportunity to earn it back. Here's an experiment: quit the job you're doing and take a consulting job doing the same thing. Notice how much more money the same position pays? Take out vacation, sick days, everything. How much more pay is the consulting position *now*? Usually it will still be more than the average bonus in that company. If it isn't either you're working for a company that has an unusually high bonus and it's going to change or your agency is screwing you on rates.
Ok, but add in DrScheme, Ikarus, Larceny, Chicken, Gambit, SISC, Scheme48 and then we can talk. Plus, some documentation like the hyperspec, SICP, HtdP would be nice, too.
 CL-USER&gt; *features* ; in: LAMBDA NIL ; (*FEATURES*) ; ; caught WARNING: ; The function *FEATURES* is undefined, and its name is reserved by ANSI CL so ; that even if it were defined later, the code doing so would not be portable. ; compilation unit finished ; Undefined function: ; *FEATURES* ; caught 1 WARNING condition Fuuuuuuuuuuuuuu... Okay, so they do that fine, but you still can't access variables shadowed by a function.
This must have been made just so he could label it "Thnake".
The HyperSpec's license does not allow redistribution on a CD.
I am very disappointed to report that a majority of the Dr. Scheme people use Macs.
How does one develop very strong feelings about Clojure when one is a self-proclaimed (Common?) Lisp beginner? Doesn't this imply an inability to effectively and fairly value another dialect?
Speech impediment jokes never get old with Lisp. _Never!_
Why? This is a very common situation in Open Source today. The claim is always made that "they just want something that works." While I disagree (I find Macs highly unusable for my preferences), I don't much care so long as they are happy and it still supports everything else.
No Gauche? No STklos? 
Yep, these too. And Guile.
Oh ok, then how about the Common Lisp Quick Reference.
Could they not re-license it or offer it in a dual-license? It's just too damned useful not to be redistributed :(
I'm sure something like that could be negotiated, but you'd have to have a good answer to the question "Why can't users just get it from our site?" 
While he's at it, drop the python support :)
Because some people want a local copy of documentation (and maybe they don't need all 1000s of pages of it) for when the Internet goes down or they want to take a break from the Internet. [I think you can redistribute it on a CD, but you need to make a full copy of the Hyperspec and you cannot modify it nor can you charge more than the CD cost to buy (direct commercial advantage).](http://www.lispworks.com/documentation/HyperSpec/Front/Help.htm#Legal) I'm not even sure if printing a partial copy of the HyperSpec is allowed according to that license :P
&gt; Because some people want a local copy of documentation They can already do that. Again, the question is: "Why can't users just get it (a local copy) from our site?"
Why all the Scheme variants? DrScheme and Gambit should be enough.
Man, I was just browsing that site as well... even messaged this specific link to a friend of mine. Did we take the same turn on Reddit or HN earlier today? :-) That said, this is a very cool video and I've made a date with the aforementioned friend to install it on his computer and play with it while projecting it on his wall.
Reading reddit is strangely thematic sometimes, i think one event that lead to this link is ["Algorithms are Thoughts, Chainsaws are Tools"](http://www.reddit.com/r/lisp/comments/b9zxq/algorithms_are_thoughts_chainsaws_are_tools_the/) post earlier, which surely send a bunch of people searching for other livecoding.
I didn't do that so it could boot into RAM on low-spec machines. I'm planning an alternate version with MIT Scheme for people who want to do SICP, however; I might throw in Scheme48, too. There are default bookmarks in the web browser with some good documentation on both Lisp and Python.
Here is [the source](http://www.pawfal.org/flotsam/scheme-bricks/) found via the weird wiki. Btw, it seemed unlikely to me that a significant Scheme distribution would make a change that breaks('bricks') audio libs.. 
Someday, I'll write a language, and it will be LISP done *right*, and I'll call it LITHP.
I've got to say I'm a little jealous at him being able to manipulate the programs block structure so easily. It makes me wish I could toggle something in emacs, drag a block, toggle back and continue coding. Neat idea.
There is an SICP package for PLT Scheme on the PLaneT.
The name's already taken http://esolangs.org/wiki/LITHP
"This version of this package is a work-in-progress, and is not yet intended for use by arbitrary students. The goal of this version is to permit the more adventurous to help test . . ." Not quite what I want to supply at this point, but I'll direct the adventurous to it --- thanks for the suggestion.
Most people use Macs these days. Here a picture from one of the last Lisp conferences: http://lispm.dyndns.org/lisp/pics/3454016237_906383ba1e_b.jpg
Most people do not use Macs these days. That is incorrect and cannot even be disputed. Nice try, Steve.
I assume by "most" he meant "most in the Lisp Community" as in "the community that is represented by that picture".
Wow, I had no idea what I just read amounting to that length of 10-point text. If I had first seen that transcription, I fear I would not have read the whole thing. That would have been my loss.
Threads on every platform, sure, on Windows, you *have* to enable them - it won't compile without them. That sucks. I'd leave them off if I could, in the name of stability (and, I suspect, performance, although I haven't made any measurements).
You never know with the Apple crowd these days; they tend to see things in Steve-Vision.
Well, if that picture *is* representative then I've got no choice but to believe him. He's got absolutely nothing to gain either way - nor can we conclusively find out with actual statistics.
zxvxcv
FWIW, iolib includes a DNS client in pure Lisp. http://gitorious.org/iolib/iolib/trees/master/src/sockets/dns
&gt; while trying to get one that resembles your name or something personally meaningful has become an exercise in futility I didn't have much trouble; [ojasper.nl](http://ojasper.nl/), it matches my gmail account,(although i am getting the feeling that i should switch to something else) the first letter of my back name is O, and i am dutch. And it is nice and short!
Poor Symbolics... Symbolics.com is actually still there, but it's a shell company holding some Symbolics Lisp Machine stock and support contracts.
Another article: http://www.sfgate.com/cgi-bin/article.cgi?f=/c/a/2010/03/14/BUS61CEVQ6.DTL
Also related: http://ldeniau.web.cern.ch/ldeniau/cos.html http://sourceforge.net/projects/cos/
My Greenspun! It's full of stars!
CLOS - L = L(COS - 1) CLOS/L = COS 
Don't see a Linux version, but ftr, it works with wine for me. Bit scarce in information, here.. it uses opengl at least.
Thanks for point that out about Wine. Funny enough it hadn't occurred to me to try that, even though I was trying to run Spelunky under Wine just yesterday. I've added info to the web page noting that works, and mentioning OpenGL. I think there are lingering compatibility problems (probably related to video drivers with older versions of OpenGL) which I'd like to resolve.
I'm interested in whether this could help lisp projects like LibCL and Desire. Something to watch.
I can't seem to find any convenient specifics behind that link.. The point of reddit is to present stuff, not have everyone seeing this having to research it. (And i always think mailing lists have *horrible* internet interfaces.. Btw, LibCL didnt have a cliki page, [i made a basic one](http://www.cliki.net/LibCL).
You fit in too well with the Reddit crowd.
The hell does that have to do with Lisp? It's a link to the mailing list of a C++ project which doesn't even include an explanation of what it is supposed to be we should be looking for, and the sole, externally-contributed link proudly announces "Distributed C++ Development". Oh, and it seems tied to git, which is another piece of code I'm not gonna use unless at a gunpoint.
I think you're painting all the tech companies in Canada with a pretty broad brush, especially considering your point of view coming from a bank. Banking has hardly been some paragon of software development and I doubt that's any less true elsewhere in the world. And like another commenter has pointed out, a lot of what you slag Canada for is equally as applicable elsewhere in the world. The biggest difference between us and the states is, I think, scale. Anyway, there's been some gems now and then. Flickr started out over here and if you're looking just at Lisp-related companies alone, it seems there's been a healthy outgrowth of startups in Montreal stemming from Marc Feeley and his students at UdeM.
Agree with that. I wonder if it is monetary concerns that have stopped the developers from releasing source. Considering that this is a 7-day rogue like that is probably not true.
I'm still thinking about that. I wasn't going to, then I decided I should, but honestly I don't see the point. The code is a bit of a mess, I don't want to spend time supporting it, and games aren't something that benefits much from the open source model anyway.
To spell it out a bit further: CL has an issue with many libraries, but little testing and integration. ryppl is a "state of the art" project exploring how to handle this with C++. Maybe someone using CL could look and learn... Why are many lispers so xenophobic?
The point of this post was to notify people of a new project. If you aren't willing to dig a bit, that project really doesn't want you around right now. If you are, it may help for a CL person to see whether the framework could apply, and guide its development if so.
One benefit may be that if people can see how its done then in might encourage others to write games in common lisp :)
When I try to run it, it quits before opening a window, and without leaving an error file. (I'm running WinXP)
&gt; I don't want to spend time supporting it, Just make the first person who emails you with a bug the maintainer, problem solved ;)
True, perhaps it is part of getting the news early.. Did find [this website](http://www.ryppl.org/) now though.
Complete with the awful jokes and sneering about UNIX we've come to expect from MIT! OK, the sneering is totally deserved in this instance. But the jokes are still awful. 
Yes, I am probably using wide brush strokes, but, the really large software development market in Souther Ontario at least, is based around financial and insurance companies - occasionally you will get a Canadian Tire etc.. Financial companies are the only ones that have the big bucks to make large software investments. Medium and small companies will typically use off-the-shelf software with some minor modifications. The big financials are almost exclusively programming in Java/j2ee, and the mid-smaller companies are based around a Microsoft software stack. Within this environment, there is very little innovation.. Slap business software together to make $$, and let others (south of the border) do the real innovation.. Yes, some innovation probably happens as you said in Montreal, but the size of those "markets" is tiny.. Have to think of scale of the software development marketplace. 99% of all programmers in Canada will fall into the 'business programmer' market.. 
Not xenophobic, just that your submission did nothing to explain what we should be looking at and why that'd be relevant to Lisp. Hell, you didn't even link to anywhere where we could read what it was supposed to be in the first place.
Really? What's in it for me?
Any chance that someone will post a video, for those that cannot attend?
Reddit karma. You can cash it out for either Beenz or Flooz, your choice.
&gt;We are looking for people knowing Common Lisp and preferably topics like compilation, code generation, VHDL, FPGA, networking, optimization, statistics and more wow, that's really damned broad.
Only 4 chapters of 20 are available through the "early access" program. I hope he gets it finished in 2010!
...seriously, that makes the job description all the more appealing! Far more so than the laundry list of dozen of buzzwords (alongside with very precise number of years/months of experience required for each) written by recruiters who don't understand the meaning of most of them, that one finds much too often... This looks like a potentially really cool opportunity...
Code, incl. Lisp code, here: http://github.com/joshsh/twitlogic
you're just upset that you don't have 10 years of Clojure experience and 15 years of Windows 2008 deployment experience. :D 
Hmm, which Lisp? Any suggestions?
Any lisp is fine.... Common Lisp is the most used in the community I think, but Scheme, Emacs Lisp, Clojure, are all good.
I recommend Lisp 1.5 for exciting, toggle-switch-flipping action!
From Clojure you can access all the Java libraries, including JMonkeyEngine. That should be quite useful to write a game.
Sure, if you're a big sissie.
Sometimes the barrier to entry is not good tools, but good ideas.
...yeah, getting sick and tired of competing against these darn kids and their fancy time machines...
Although I heard that C++2040 is really nice though...
I generally just: import com.sun.java.ideation.ideas.GoodIdea; But I heard they removed it from the latest spec. Also, in certain JVM versions, the IdeaFactoryFactory required a BadIdeaFactory that you had to cast to a GoodIdeaFactory. However, everything else was smooth as could be! *edit*: I forgot to import com.sun.java.Speelink. 
why flip switches when you can rewire the boards and have amazing wire patterns?
If it is, as you suggest, basically trivial and worthless, then I can't imagine of what use the source code would be to you. As a sunk cost, hosting is basically free. Fortunately, I enjoyed writing it, regardless of whether anyone else actually plays it.
Great. Attacked by a teeth-gnashing, insult-slinging proto-Naggum. &gt; Do you even know what sunk cost means? Are you paid up through the indefinite future? Did you pay for exactly how much it will cost to serve the binary and no more? Yes, and I will continue to pay for web hosting whether that particular page is present or not. Bandwidth use within reasonable bounds is not metered. Putting it on the web cost me nothing but my time. &gt; So then what is the point of demonstration page? Vanity? Maybe vanity, but I expect vanity drives a fair amount of source code releases too. Naturally, I'd prefer someone play the game and find some amusement in it. A better question is why I'd choose to spend my time doing something for the 7DRL competition at all, which I don't have a rational answer to except that I just wanted to. Providing source code to a 7DRL is encouraged but not required. It would be absurd for me to finish a game and not release it at all, even if only in binary form. Shockingly, this is how most games are provided. &gt; Let me do this piece by piece since you're only capable of working with very small chunks of discussion at once. Fuck you too. &gt; It would be useful, still, for others to see how to use Lisp quickly to get something done. It might even be a worthwhile, educational exercise for someone with minimal experience to clean it up. Sure, that's why I considered releasing it. On the other hand, I don't think it would fit into the open source Lisp ecosystem in a useful way. There's already plenty of code out there to learn from and tinker with. &gt; You'd do no more than you have to right now in releasing a binary. If anything, I'd be willing to bet that a source release would involve far fewer support requests because the target audience is more informed when it comes to getting it to work. I'm actively interested in learning what goes wrong with the binary release and fixing the problems, or at least not repeating my mistakes. The ability to deliver software to an audience larger than #lisp is part of the exercise. &gt;&gt; and games aren't something that benefits much from the open source model anyway. &gt; Are you going to support that or just rationalize? Impossible and unnecessary; it's subjective. It can't be strictly true, as Nethack is an obvious counterexample. A game doesn't have a well-defined purpose like an application or utility, but instead is a creative work whose only objective constraint is that it runs without crashing. My general impression of game modding and what I've seen done with the source code to things like Doom and Quake is not favorable. I suppose someone could take my source code and create a "Super Laser Spigot" with more varied game play. That would be cool. This is not relevant. &gt; If this is somehow involved in a commercial effort, that's one thing; but I've seen no mention of it here. Indirectly. It's based on graphics, sound, and UI code from my other game (under development), which I consider a commercial effort. Portions of that code are either unused or are over-engineered for the purposes here. I'd prefer to filter out the pieces I'm not using. Some of it is functional but obviously unfinished, like my embarrassingly bad texture atlas code. It's written in neither the style nor philosophy I prefer for open-source work. It's tied to a specific implementation of lisp. It might entertain tinkerers, but I doubt it would be useful to the CL community. I don't see it forming the foundation of a new graphics/UI library (and even so, we have enough of those that no one uses already) or otherwise making itself useful. Honestly, I find not releasing source code liberating. I can focus on getting things done, and not distract myself with conforming to the least common denominator of community source code aesthetics and wasting effort on premature generality / portability while anticipating the needs of hypothetical users. Sometimes I feel like I've spent years programming in CL with little to show for it outside my own head. Getting things done is fun. (Edit: formatting)
Hmm, I wonder what the first reference will be.
Hokay, I need to know that. How did you learn about it? Do you know Portugese/Brazilian? And if not, is there some sikret otherlanguage info you used?
A little late. The selection of the collaborators has already been made [Terminada a seleÃ§Ã£o do projeto do MCT](http://permalink.gmane.org/gmane.lisp.region.brazil/1658)
Yep, it also contains a hint that there is some other project using machine translation software in Common Lisp.
I saw it mentioned, finding it then was not so difficult and Google Translate is then useful...
If you need anything translated/explained, Portuguese is my second language.
I am stealing the phrase "proto-Naggum" :)
I haven't seen any come across my radar, but keep an eye http://planet.lisp.org/meetings/ -- I'll be sure to add any conferences to it that come up.
I believe there will be many lispers at http://www.splashcon.org/
I seem to have been helped :) Not sure if it came from people here, but awesome anyway :)
1. Why don't you just install a Norwegian layout and switch to it when you want to type Norwegian layout? 2. Or use compose sequences. I type my Ã¥'s with `Compose a a`. 3. Why on earth do you do `(setq varlol "Ã¥")`? This sets a global variable for no reason. That's pollution that will come back to bite you later, don't do it. Just say `(insert "Ã¥")` directly. And since you're doing the same thing thrice, why not make it a macro? (defmacro defnorwegian (keysym char sym-name) (defun ,sym-name () ,(format "Liten %s" char) (interactive) (insert ,char))) (defnorwegian "C-c C-t" "Ã¥" na) 
1. Because I only need the norwegian layout in emacs and I use it rarely. I only need it when translating stuff, and even then it's not a lot. 2. Not sure what you mean. 3. I have no idea. I've never even seen a Elisp scripts before yesterday, so I don't really have a good explaination to why I used what command. I just started reading the Elisp intro on GNU.org and tried my way to get an easy fix to the problem.
In this case you probably want to use compose sequences. They are something specific to X Window System, but basically they're an extension of the idea of dead keys. I'm using GNOME, and with the keyboard layout applet I have mapped CapsLock to be the Compose key (CapsLock is useless anyway). This way when I press CapsLock a a (three separate keypresses, not a chord), I get Ã¥. If you're using a Unixoid as your OS, then obviously that won't work and you're probably better off with whatever hacks you do in Emacs. If so, you can take the macro I've given above and use it to define the three needed functions, which you can then bind.
I am using gNewSense on a Lemote YeeLoong with GNOME. How do you solve upper-case "Ã¥"?
Check out ``C-x 8 /``... Jeg forst ``C-x 8 / a`` r -&gt; Jeg forstÃ¥r.
[This](http://oreilly.com/catalog/9781593272005) says March 2010 (Edit: O'Reilly link is down) [This](http://www.amazon.com/Land-LISP-Learn-Program-Game/dp/1593272006) says maybe never [This](http://ebiquity.umbc.edu/blogger/2009/09/24/next-stop-land-of-lisp/) says April 2010 [This](http://nostarch.com/lisp.htm) says March 2010 Edit: The author himself has [answered](http://www.reddit.com/r/lisp/comments/bic7p/land_of_lisp_is_it_still_going_to_be_released_in/c0mwxui), so the above links no longer indicate when the book will be published. 
Probably not.
I don't know when it will be released, but knowing Conrad, the book will be awesome. 
Hi Guys- I'm Conrad, the author of the book. It's very close to being finished- Just a few more chapters need to complete their editing. I am really happy with the book, even if it's delayed. It's going to be a FAT book with lots of game examples and many illustrations. I'm sorry it's taking me so long, but it just took this long for me to write the book to the best of my abilities. I can't give you an exact release date- It might take a couple extra months or so. Sorry for the delay! "I love deadlines. I like the whooshing sound they make as they fly by." - Douglas Adams
Thank you for the update. I look forward to buying a copy when it comes out.
Hello Conrad, thanks for your update. I really cant wait to get the book eventually, so please consider posting a update every now and then to keep us excited. ;-) 
Didn't really work very well.
Excellent! Could you post on /r/lisp and let us know when the book is on sale (when you have a date, that is)?
Compose A A. But note that sadly the compose sequences *aren't* completely consistent systemwide. There are some sequences that only work in GNOME, and the a a is one of them. If you want to bring them to other apps, you need to make a file called ~/.XCompose. Here's mine: include "%L" # Include the system-wide definitions. # If you don't, nothing but the definitions below will work # My stuff &lt;Multi_key&gt; &lt;O&gt; &lt;slash&gt; : "Ã˜" U00D8 # LATIN CAPITAL LETTER O WITH STROKE &lt;Multi_key&gt; &lt;O&gt; &lt;KP_Divide&gt; : "Ã˜" U00D8 # LATIN CAPITAL LETTER O WITH STROKE &lt;Multi_key&gt; &lt;o&gt; &lt;slash&gt; : "Ã¸" U00F8 # LATIN SMALL LETTER O WITH STROKE &lt;Multi_key&gt; &lt;o&gt; &lt;KP_Divide&gt; : "Ã¸" U00F8 # LATIN SMALL LETTER O WITH STROKE &lt;Multi_key&gt; &lt;A&gt; &lt;A&gt; : "Ã…" U00C5 # LATIN CAPITAL LETTER A WITH RING ABOVE &lt;Multi_key&gt; &lt;A&gt; &lt;*&gt; : "Ã…" U00C5 # LATIN CAPITAL LETTER A WITH RING ABOVE &lt;Multi_key&gt; &lt;*&gt; &lt;A&gt; : "Ã…" U00C5 # LATIN CAPITAL LETTER A WITH RING ABOVE &lt;Multi_key&gt; &lt;a&gt; &lt;a&gt; : "Ã¥" U00E5 # LATIN SMALL LETTER A WITH RING ABOVE &lt;Multi_key&gt; &lt;a&gt; &lt;*&gt; : "Ã¥" U00E5 # LATIN SMALL LETTER A WITH RING ABOVE &lt;Multi_key&gt; &lt;*&gt; &lt;a&gt; : "Ã¥" U00E5 # LATIN SMALL LETTER A WITH RING ABOVE &lt;Multi_key&gt; &lt;h&gt; &lt;v&gt; : "Æ•" U0195 # LATIN SMALL LETTER HV &lt;Multi_key&gt; &lt;H&gt; &lt;V&gt; : "Ç¶" U01F6 # LATIN CAPITAL LETTER HWAIR &lt;Multi_key&gt; &lt;e&gt; &lt;equal&gt; : "â‚¬" EuroSign # EURO SIGN &lt;Multi_key&gt; &lt;equal&gt; &lt;e&gt; : "â‚¬" EuroSign # EURO SIGN &lt;Multi_key&gt; &lt;T&gt; &lt;M&gt; : "â„¢" U2122 # TRADE MARK SIGN &lt;Multi_key&gt; &lt;apostrophe&gt; &lt;apostrophe&gt; : "â€²" U2032 # PRIME &lt;Multi_key&gt; &lt;quotedbl&gt; &lt;quotedbl&gt; : "â€³" U2033 # DOUBLE PRIME &lt;Multi_key&gt; &lt;s&gt; &lt;q&gt; &lt;r&gt; &lt;t&gt; : "âˆš" U221A # SQUARE ROOT &lt;Multi_key&gt; &lt;i&gt; &lt;n&gt; &lt;f&gt; : "âˆž" U221E # INFINITY &lt;Multi_key&gt; &lt;i&gt; &lt;n&gt; &lt;c&gt; &lt;l&gt; : "âˆˆ" U2208 # ELEMENT OF &lt;Multi_key&gt; &lt;exclam&gt; &lt;E&gt; : "âˆƒ" U2203 # EXISTENTIAL QUALIFIER &lt;Multi_key&gt; &lt;exclam&gt; &lt;A&gt; : "âˆ€" U2200 # UNIVERSAL QUALIFIER &lt;Multi_key&gt; &lt;less&gt; &lt;equal&gt; : "â‰¤" U2264 # LESS THAN OR EQUAL &lt;Multi_key&gt; &lt;greater&gt; &lt;equal&gt; : "â‰¥" U2265 # GREATER THAN OR EQUAL If you want to add new sequences, you just need to make a new entry fitting the template and (unfortunately) restart your session or all the apps you want to see the new definitions. `&lt;Multi_key&gt;` refers to the Compose key, Latin letters are just themselves, and for other symbols use the standard `xev` app, it will tell you the name of key being pressed.
Played it, works pretty well.
That's from ANSI Common Lisp, p. 18.
Ah, nice! And the .XCompose-file will be automatically loaded every time I start GNOME? Does the only thing differ from &lt;Multi_key&gt; &lt;*&gt; &lt;A&gt; : "Ã…" U00C5 and &lt;Multi_key&gt; &lt;*&gt; &lt;a&gt; : "Ã¥" U00E5 Is that you hold in the shift key?
Sounds oddly plausible. I'm freaking. Perhaps I shouldn't. ---- Nope, it's real.
Looks like they mentioned it on the PLT mailing list in february and this is no joke... 'Ponzi Scheme' would have been cute...
I got it pre-commanded so whenever it is released, I'll get it asap :-p
&gt; It's not yet time to write blog posts or advertise the name change to &gt; the world at large. Although the change is no secret, a new name offers &gt; a rare advertising opportunity, and we'd like to make as big a splash &gt; as possible with the eventual release of Racket. (you ruined their plan :( )
Typing scheme in google gives [Scheme (programming language)](http://en.wikipedia.org/wiki/Scheme_%28programming_language%29) as first link. I hope google gives then special treatment to keyword racket. Even better would be to just hope it's April 1st. 
can this be made accessible through clbuild?
Nice job talking about it on a public mailing list, Matthew Flatt: http://list.cs.brown.edu/pipermail/plt-dev/2010-February/002233.html
Thats dumb. 
How DID YOU DO THAT AWESOME LARGE TEXT?
This feels like when they revealed that Revolution would be named Wii[.](http://www.reddit.com/r/netsec/comments/bin4p/and_the_browser_losers_are/c0myj86 "Completely misposted this the first time. Somehow I was still upvoted.")
I honestly didn't go for that, I was wanting an hrule. Four dashes directly underneath a line should do the trick. - 
Yeah, I mean chrome is fast too. Wait, what?
AWESOME ---- 
Yes and yes. Though personally I find "Compose a a" a much better combination for Ã¥ than "Compose * a".
It's perfectly sensible, the public mailing list is the official discussion venue for PLT after all. A big, official announcement on the main page of the new domain, accompanying a new release is not the same as informing about a decision on the internal mailing list.
That wasn't a really clever scheme...
Meh ... still no ported release for Windows.
Yeah that's what I was looking through the release notes for... went through the past 10 releases with no mention of Windows. Oh well... edit: Ok there are a bunch of Windows changes, I had just assumed for some reason I don't understand that any platform-specific changes would have the platform named at the start of the line.
Something wrong with the one on the download page?
What did you hope to see?
I haven't tried the Windows port in a while, maybe a year or two, but at the time there was a bug with the GC or something that made it randomly crash pretty frequently, making it pretty much unusable... maybe that's been fixed and I didn't look far back enough.
Why wait for someone else to fix it?
Heh, I'd love to fix it, but reading the notes on what the Windows port needed done it was pretty intimidating. Maybe I'll give it a shot sometime if I can manage to comprehend what the problem even is. Using SBCL is a whole lot easier than porting it.
Even just trying it and reporting build failures and things like that is helpful.
What do you mean? A fully implemented one? What problems are you encountering with 1.0.29? If you mean that there is no 1.0.37 binary, you could always download the 1.0.29 binary and then compile 1.0.37 from source. If you're talking about threads, well... I feel your pain.
Have you tried Clozure CL? In my limited experience it seems to do pretty well in Windows.
a sbcl user once, i finally completely ported our web site to clojure. We still have sbcl code doing some internal tasks, and the code is stable, so no need to touch it (or upgrade sbcl). But sooner or later everything will be ported to clojure. Lisp is dead. Long Live Lisp! 
That's a feature.
Yep. Came here to say that. Slime works pretty good on windows. Libcl compiles and loads. I wish clbuild worked on windows + CCL. It might already with cygwin. I haven't tried yet. I would like to get it working with Weblocks on windows + CCL.
No you didn't. From 1.0.37 release notes * bug fix: slam.sh now works on win32. From 1.0.34 release notes * bug fix: #p"\\\\" can now be read without error on Win32. (reported by Willem Broekema; launchpad bug lp#489698). From 1.0.29 release notes * new feature: UNC pathnames are now understood by the system on Windows. * bug fix: FILE-AUTHOR no longer signals an error on Windows. (I'm not saying that's a lot -- it's not. Just saying it's there.)
what was the reason for the switch, apart from "newer is better"?
Sbcl is "Lisp without libraries" Clojure is "Lisp with libraries" Here are some particular examples in my case: 1. We create, read and manipulate lots of pdfs. There's no pdf library fo CL. If you do not count half-baked, undocumented and untested toys. Java on the other hand has several feature complete, mature and stable libraries, both open source and commercial. We use iText. 2. We need to read/write from windows servers. With sbcl i had to use an ugly hack, where i would drop to bash, map windows share and then access that share from my sbcl code. The problem with this approach is that when windows server goes down (you know they sometimes do), the mapping is not working anymore and it is a pain to remove broken mapping. Enter java with its jcifs library, that allows me to access windows shares directly without any mapping (just like in windows.) 3. We send lots of emails. And sbcl email library chockes on some emails. Java email library on the other hand is rock solid. 4. We run hunchentoot web server, and i do not know if it is one of the libraries i use, or sbcl itself, but after about a 2-3 weeks it either hangs eating away all memory, or gives me errors about too many open sockets. I could give you more, but even one of these is enough to warrant migration. Now, thanks to clojure, i am one happy lisper. :) 
Emacs and SLIME gives you: * connects to Common Lisp systems, even on remote machine * has much more general editor tools * SLIME can be used with other Common Lisp implementations * Emacs-oriented user interface But then, the original developer of Hunchentoot, Edi Weitz, uses LispWorks to write most of his code and also offers extensions to the LispWorks environment. I find LispWorks easy to use with lots of useful GUI-based tools. If you can work with LispWorks, try it and see if you like it.
&gt; I have very little Emacs experience, and I've spent hours getting only to the point where I'm about to tackle SLIME installation. I don't even have an idea how is this possible... In Debian/Ubuntu you can install Emacs and SLIME in some two minutes, and all it takes is typing one command and editing one file. &gt; Focusing only on Lisp development, does Emacs+SLIME gain me anything LispWorks doesn't deliver? I guess the biggest feature is that it is free.
&gt; In Debian/Ubuntu you can install Emacs and SLIME in some two minutes, and all it takes is typing one command and editing one file. Would you be so kind as to share your magic incantations?
&gt;Focusing only on Lisp development, does Emacs+SLIME gain me anything LispWorks doesn't deliver? Liberty is one. But that's all I know since I've never used LispWorks. 
I used to use the Debian repository for SLIME, but it breaks too often. I just clone my own from this Git mirror (SLIME uses CVS), git clone git://git.boinkor.net/slime.git Then added these to .emacs, which comes right out of the docs (with the path to *your* clone), (add-to-list 'load-path "~/.emacs.d/slime/") (require 'slime) (slime-setup '(slime-repl)) You might want to select your lisp implementation too, (setq inferior-lisp-program "/usr/bin/sbcl") Then it's just "M-x slime". 
Thanks for your tips. Some followup questions: &gt; I used to use the Debian repository for SLIME, but it breaks too often. SLIME in the Debian repository looks fairly old. By "it breaks too often" I'm assuming you don't mean that Debian's SLIME breaks (because it hasn't changed) but rather that SLIME + (some other component) no longer works? &gt; (add-to-list 'load-path "~/.emacs.d/slime/") Is ~/.emacs.d/ the preferred place to "install" additional things for Emacs? (Assuming a single-user environment.)
Run this command: sudo aptitude install emacs slime sbcl Add this to ~/.emacs (require 'slime) (slime-setup '(slime-fancy)) (setq inferior-lisp-program "sbcl") Seems to work... By the way, I totally recommend enabling "CUA mode" in Emacs. (you can do this via menu.) It enables commonly used key combos, so Emacs behaves like your average editor and you don't need to learn how to work with it. It just works, really. 
Thanks for your response. Some feedback: * Does installing "emacs" install 22 or 23? I can't decipher the version number apt-cache shows: "23.1+1-4ubuntu2+22.2+0ubuntu6". Regardless, you can get 23 by installing "emacs23". * Everything I've read suggests that the CVS version of SLIME should be used * CUA mode's keybindings conflict with SLIME's. For example: eval region (C-c C-r). (I realize it's possible to use CUA mode without binding C-x C-c and C-v.) shift-select-mode is enabled by default on Emacs 23, so perhaps cua-mode is less necessary? And then there's pc-select-mode...
Both, actually. I run Debian unstable so I'm a little more recent. The version I'm seeing right now (but not installed) is from February 20, 2010, so it's not too old. Sometimes I would update and SLIME would report errors when I went to use it, probably due to some mismatch between versions of various other things. I've never had it happen with the CVS version. I'm also currently maintaining my own Emacs from source (simply the current stable version), which might help too. Usually .emacs.d is the typical place for user installed scripts. Emacs doesn't think of it in any special way, but it's what people tend to use. 
How is this relevant/important/interesting in the presence of clojure ? 
 * I tend to think that any particular version isn't much worse than any other version. You know, any version was the "latest and greatest" some time ago... For my work I use three year old version of SLIME and accordingly old XEmacs and SBCL. * Yep, probably you're right. I've found that CUA mode is necessary to make Emacs sane when 22 was the latest version, but I didn't recheck it for version 23. (Actually I'm mostly using XEmacs which had good defaults even 5 years ago, but it looks Emacs got very close to it :)). 
Well, Arc is a different Lisp than Clojure.
&gt; Sbcl is "Lisp without libraries" &gt; Clojure is "Lisp with libraries" This seems to imply that, since (eql Lisp Lisp), clojure is "better" because it has more libraries. But in fact they are two different lisps. For example, AFAIK sbcl is rather faster than clojure. Certainly, however, if it's libraries the main concern (like it was in your case), clojure has a big advantage.
How Clojure is relevant/important/interesting in the presence of ABCL? Real Common Lisp, that is.
Software transactional memory? Destructuring bind in fewer than 20 characters? Doesn't need to reimplement old Common Lisp APIs? Lisp-1? Lazy sequences? {} vs make-hash-table? I can go on of course.
So, Clojure is now officially proclaimed the best and only true Lisp, and other Lisp dialects can be considered obsolete? I don't mind Clojure as a Lisp dialect, but arrogance of its advocates is striking. They can't even detect sarcasm... &gt; Software transactional memory? As far as I know, it haven't been demonstrated yet that it has any practical value. Usually tales about how cool STM is start with "when processors will have 50 cores...". &gt; Destructuring bind in fewer than 20 characters? {} vs make-hash-table? With this type of reasoning, Perl is the best Lisp. I, for one, like long identifier names in plain English. But if typing becomes a problem, it is trivial to make a shorter macro or reader macro. It takes less than a minute to do this, so why is this a big deal? If you think it is a valid argument in language comparison, I guess you aren't very smart... &gt; Doesn't need to reimplement old Common Lisp APIs? What? It is already done by ABCL developers, I don't need to "reimplement old Common Lisp APIs" in my applications. And it is a feature, not a bug. It is there so you can run other programs and libaries which were made for ANSI Common Lisp. Frankly, I like it when programming language is standartized by a commitee decades ago and is not a subject to change. I hate it when you need to update your runtime frequently because library developers use latest and greatest language features. &gt; Lisp-1? It's a bug, not a feature. Many namespaces is better than one. &gt; Lazy sequences? Can be easily implemented in a library. &gt; I can go on of course. Please don't. I've got tired debunking this bullshit. Actually I can agree that Clojure is a new interesting Lisp dialect which some people might find attractive, but there is absolutely no need to push your propaganda that hard, that only creates hostility.
Firstly, you're the one that brought up Common Lisp in this thread where it is pretty much irrelevant. Clojure has marginal relevance to the thread, in that people interested in Arc or in Clojure are already rejecting Common Lisp. Most of the design objectives for Arc are also present in Clojure's design. &gt; But if typing becomes a problem, it is trivial to make a shorter macro or reader macro. It takes less than a minute to do this, so why is this a big deal? Because everyone will write their own incompatible reader macros for something that should be part of the language in the first place. It amuses me that you will advocate a language that specifies the FORMAT minilanguage but reject one that uses a shorthand for finite maps. &gt; And it is a feature, not a bug. It is there so you can run other programs and libaries which were made for ANSI Common Lisp. It's a bug, because it commits the users to things like mutable conses. &gt; It's a bug, not a feature. Many namespaces is better than one. Clojure has many namespaces; it just doesn't conflate them with position in the function application argument list.
You know the story about 2 men running away from a bear ? "I just need to run faster than you." That's the story of programming languages. Clojure just needs to run faster than such popular languages as python, ruby, perl, php, to make question of speed irrelevant. 
Arc, Clojure, Scheme, Common Lisp are all dialects of Lisp. Question "Why do we need dialect XXX at all if we already have YYY dialect?" doesn't make much sense (unless you can prove that dialect YYY is superior _in all aspects_, for all purposes), and it is quite insulting to people who use/make dialect XXX. That' my point. I've mentioned Common Lisp only to juxtapose it to Clojure so maybe Clojure advocates will understand why it is rude. That was sarcasm. I see you have problems understanding it, look it up in dictionary or something. &gt; that people interested in Arc or in Clojure are already rejecting Common Lisp. It seems that you're trying to put all Lisp dialects on some linear scale. It doesn't work this way -- there is a lot of dialects and lot of aspects. So "Arc users reject Common Lisp" makes as much sense as "newLisp users reject Clojure" and "Emacs Lisp users reject Scheme". That is, it doesn't make sense at all. &gt; Most of the design objectives for Arc are also present in Clojure's design. I don't think so. Of course, all dialects of Lisp are somewhat similar, but I can't say that Arc is particularly close to Clojure. IMHO Arc is essentially a Scheme with some fancy tricks, while Clojure has pretty different semantics. I dunno about design goals, but Arc's _lack_ of obsession with immutable data structures already makes it different from Clojure. On the other hand, last time I've checked Clojure was not very good with tail-call-optimization, and that means it's not very good for a Scheme-style language. What is common is probably those fancy tricks (syntactic sugar). Well, maybe you think they are most important (rather than semantics), it is understandable... &gt; Because everyone will write their own incompatible reader macros for something that should be part of the language in the first place. 1. People do not use reader macros much, probably because they think it is not that important. 2. If they agree that it is important, they could make some lib and use it. 3. Even if they use their own reader macros, it is not a big deal, as long as it works. So: this is non-issue. &gt; It amuses me that you will advocate a language that specifies the FORMAT minilanguage but reject one that uses a shorthand for finite maps. I don't reject it, just LOOP is good enough for me. And presence of FORMAT minilanguage doesn't mean that everybody uses it a lot. &gt; It's a bug, because it commits the users to things like mutable conses. What? Are you saying that mutable data structures are bad? Well, you know, there are different languages with different approaches. I was using pure functional programming language -- Haskell -- for some time, it is fun and everything, but for me writing imperative algorithms working with mutable data structures is more straightforward in most cases, therefore I prefer Common Lisp. But one doesn't have to use mutable data structures, there are libraries with immutable ones for Common Lisp too.
This discussion would be more productive if it was focused on the pros and cons for each language for a specific problem, e.g. Clojure is clearly superior if one is facing concurrency problems while ABCL is clearly the better solution if you already know CL and don't need the idiosyncratic Clojure features.
&gt; This discussion would be more productive if it was focused on the pros and cons for each language for a specific problem Sure, but I didn't want to start this discussion to begin with. &gt; Clojure is clearly superior if one is facing concurrency problems It is far from clear for me -- there are different kinds of concurrency problems and there are different possible solution. Yes, typical imperative, mutable data concurrency solutions are known to be complex and error-prone, but they actually work and are well-studied. I guess some problems can be very well solved with Clojure's approach, but I don't think we have a definitive answer that this indeed is the best way indeed. There is no silver bullet, you know. Immutable data structures have overhead, STM makes some assumptions which are not always true (and has some overhead too), so it is far from clear.
If your competition is Perl, then, yes. If it's C, it's another matter. Depends on the application.
Competition ? Did i just waste a bear story on you ? My competition is the task at hand, not a particular language. If millions of programmers find python, ruby, perl, php fast enough for their tasks, it means they automatically find clojure (ten times faster) more than adequate in terms of speed. Speed is not an issue. Getting work done (aka where-are-my-libraries?) is. 
&gt; With this type of reasoning, Perl is the best Lisp. Oh please no ...
&gt; Sure, but I didn't want to start this discussion to begin with. Yes you did. You brought up Common Lisp in a thread about Arc on the JVM. &gt; It is far from clear for me http://en.wikipedia.org/wiki/Argument_from_ignorance
&gt; It seems that you're trying to put all Lisp dialects on some linear scale. It doesn't work this way -- there is a lot of dialects and lot of aspects. So "Arc users reject Common Lisp" makes as much sense as "newLisp users reject Clojure" and "Emacs Lisp users reject Scheme". That is, it doesn't make sense at all. It also doesn't make any sense to bring up Common Lisp in response to someone asking why they should use Jarc over Clojure. &gt; Question "Why do we need dialect XXX at all if we already have YYY dialect?" doesn't make much sense (unless you can prove that dialect YYY is superior in all aspects, for all purposes) Let's see... the Jarc site says "There is no compiler, so it can be slow." Given that, and that Jarc's goal is "it should be as easy as possible to call Java methods," I think we have enough to justify vagif's question. &gt;On the other hand, last time I've checked Clojure was not very good with tail-call-optimization, and that means it's not very good for a Scheme-style language. On the other hand, last time I've checked Jarc has even less support for TCO. Did you not read the article before responding to vagif? Clearly you came into this thread with an agenda that had nothing to do with Jarc, but rather with Common Lisp. And yet you say the "arrogance of [Clojure] advocates is striking?"
&gt; Clojure is now officially proclaimed the best and only true Lisp, No, but it does STM, concurrency, and Java interaction (and, as mentioned, it has [some syntax](http://github.com/ayrnieu/disclojure/blob/master/syntax.lisp)) well enough for it to be interesting *especially* to ABCL people. Everything that Clojure does well (except for the boring Haskell stuff) can be done as neatly in ABCL, even done in the same way, using the same Java architecture, and just *isn't yet*.
http://en.wikipedia.org/wiki/Sarcasm &gt; Hostile, critical comments may be expressed in an ironic way such as saying "don't work too hard" to a lazy worker. The use of irony introduces an element of humour which may make the criticism seem more polite and less aggressive, but understanding the subtlety of this usage requires second-order interpretation of the speaker's intentions. This sophisticated understanding is lacking in some people with brain damage, dementia and autism, and this perception has been located by MRI in the right parahippocampal gyrus. Dude, maybe you need to check your brain or something... &gt; http://en.wikipedia.org/wiki/Argument_from_ignorance Is there a proof that STM is absolutely superior to other concurrency models? Show a proof or STFU. 
I take bear stories very seriously, and I've been thinking on this one, but still I'm not convinced (or maybe I don't understand what you're trying to say). The main appeal of clojure is *that it's lisp*. Otherwise, one would just use Java! That said, there are cases in which availability of [lisp] libraries is important, and cases in which speed is more important. In the first case clojure wins; in the latter, one is better served by something like SBCL ("There are more things in heaven and earth, Horatio, than are dreamt of in your web server scripts"). As you say, in the end it's getting work done. Perl does that too, in its domain.
Emacs is updated once in a blue moon so that's not a problem. But for sbcl and slime that's different. The problem usually is not that the old versions do not work, but that you're basically out of the community, because if you ask for help the first thing you are told is to get a current version. I am a debian user too, and I suggest not to worry about emacs, but install your own fresh sbcl and slime (after uninstalling the debian ones). You can do it in ten minutes. It's really easy. Slime is not even a "real" install: just put it somewhere and tell emacs to load it. For sbcl, just run the install script. Super easy.
Well, same procedure works on Windows too, except one have to specify a full path to sbcl's core image, like (setq inferior-lisp-program "d:/sbcl/sbcl --core d:/sbcl/sbcl.core"). 
I have no problems with SBCL from Debian unstable. It has few dependencies and can easily be used if you're using testing (my favourite) and maybe even stable.
Yup, just watch the path spaces for poorly named directories like "Program Files." Using "Progra~1" may be needed. Note however that interrupts don't work for *at least* SBCL and CLISP in Windows, so if you hang your REPL you'll probably have to kill it and restart. CL on Windows never seems to be pretty. 
I never "got" how to debug properly in Emacs+SLIME. I found that the LispWorks debugger is pretty easy to use and works very well.
Can this be preordered anywhere? Barring that, do you have an announcement mailing list you could add me to? :)
Has anybody seen any further details on this?
C-c C-c seems to work for slime+sbcl, and also there is 'signal' menu entry. Or is it just me being so lucky not to deal with a hanging REPL?
&gt; protect our intellectual property from people and enterprises who will ... generally just use it. Yes, damn those users :) 
Gosh, what a shame. If it was ported to Windows I could finally have begun my additional complaining on it lacking support for Visual Studio. Who the heck writes Windows specific software these days anyway? If anything, just write the client part of your project in C++ (Qt; for Windows, Linux and Mac support) or something, then write the server part in Lisp on Linux. But wait; Linux is too hard for me!!1 :( People solve _hard_ problems using Lisp. If something relatively simple like Linux is too hard for you then you cannot solve the really hard problems anyway. Now get off my lawn.
What else would you like to know?
Is that with the normal Windows version (i.e. not Cygwin)? Using the latest version of SBCL I can't get interrupts to work correctly. If I do it from slime, in either the REPL or the inferior lisp buffer, it just kills SBCL rather than dropping into the debugger. I get the same thing with CLISP, and the PROBLEMS doc that comes with slime also admits that CLISP has this problem. I tried interrupts without Emacs or slime, just from the command shell, and interrupts don't work there either. They just kill the process. 
How do you do the install? Is there a separate installer for the plug-in, or have you packaged the whole thing in one? 
Ah, you've meant there is no lisp debugger. Unfortunately that's true, I had no debugger neither on a clean Windows nor on Cygwin. 
From what I understand the difficulty is the weird way Windows handles interrupts. When an interrupt comes in, Windows fires off a new thread for it. It's so different from the unix way that they haven't bothered supporting it. 
I'm not affiliated with medialab, but I'm guessing they'd answer your questions if you email them. I'd also guess it's a standard-for-the-platform installer on Mac and Windows.
Of course Emacs + SLIME doesn't actually get you Common Lisp, so you can't do much with that liberty. =)
Install Lispworks and start a swank server. Now you can try them both seamlessly.
STM isn't a 'concurrency model'; it is one method by which actors or threads or tasks of some design may communicate. Clojure offers several other methods. I wrote [clj-actors](http://github.com/ayrnieu/clj-actors), which has probably rotted completely away by now, to see how satisfying Clojure's concurrency could be from an Erlang perspective.
&gt;Since generalised Freecell is NP-complete, this will enable using Freecell Solverâ„¢'s ingenious, cutting-edge algorithms to solve the previously hard, provably NP-Complete problems Is she serious? edit: oh april 1
http://en.wikipedia.org/wiki/Software_transactional_memory &gt; In computer science, software transactional memory (STM) is a concurrency control mechanism analogous to database transactions for controlling access to shared memory in concurrent computing. It functions as an alternative to lock-based synchronization. A transaction in this context is a piece of code that executes a series of reads and writes to shared memory. 
If the terms in the first sentence confuse you, sentences \#2 and \#3 are pretty clear. STM is: &gt; &gt; ... an alternative to lock-based synchronization ... an STM 'transaction': &gt; &gt; reads and writes to shared memory.
Well, I know what STM is, and I was comparing it to lock-based synchronization. Lock-based synchronization is pessimistic, STM is optimistic, neither one is universal, which is strictly superior in all situations. Also, as I understand, STM works so great in Clojure because Clojure mostly works with immutable data structures, so it only needs to deal with few mutable ones, like global variables. But immutable data structures have some overhead themselves, so again, I don't think that STM+immutable data is _always_ superior to locks+shared data. Also, I don't buy your idea that ABCL can borrow something concurrency-related from Clojure. ABCL already implements lock-based synchronization, which works fine in shared-and-mutable-everything situation. Using STM on language level will likely and up as disaster in this case. However, different concurrency control mechanisms can be used on higher levels in Common Lisp -- e.g. one can implement them for CLOS objects, as it is easy to trap slot reads and writes via MOP. Such solutions do exist, for example, if you use Elephant persistence library, it maps CLOS objects onto backend data store, and they inherit concurrency control from that store. E.g. if you use PostgreSQL as a store, you'll have MVCC (multiversion concurrency control), where different versions of one object might co-exist at same time (but you cannot commit transaction with such clash). Likewise, there are some libs which implement STM for objects in CL. But this approach works only as long as program follows some rules, and it is possible to write program which screws it badly. 
Sometimes I debug by using [trace](http://www.lispworks.com/documentation/HyperSpec/Body/m_tracec.htm#trace), inserting PRINTs. However, much more useful than those is when something errors, and you get the list of functions with arguments up to the error.. If you haven't been making huge functions/macros(which one should never do any way) you can see **exactly** where the bug occured. There can be rather much crud in this list, but the first elements are likely your functions or what you called; try not have your eyes glaze over..
Hi Conrad! Thanks for the update. Perhaps it would be nice to post regular updates somewhere (a blog or website?) WeÂ´re all looking forward to reading the book!
That message was sent to a Brazilian Lisp mailing list. It sounds *really* strange. * It seems to be announcing project grants funded by the government; * It was *ANONYMOUS* (sender did not present himself or sign the message), albeit claiming to write "on behalf of" someone and asking people to send email to "luciano.vieira.lima &lt;at&gt; terra.com.br"; * It was sent shortly before the deadline to sending applications * Universities are mentioned, but the message was *not* sent to the forum one would expect it to be sent, the Brazilian Computer Association mailing list (Sbc-l) 
First, you have to remove a period from your last link (should be [ModulesAndPackagesArcfide](http://trac.sacrideo.us/wg/wiki/ModulesAndPackagesArcfide) ). Second, I just hope that R7RS is less contentious because of the two WGs (one for the "it must be small" group and one for the "it must be more realistic" group) than R6RS was (which effectively split the Scheme community, although ERR5RS ameliorates that, as does things like [SRFI-97](http://srfi.schemers.org/srfi-97/srfi-97.html). 
yay! I think LOL was the single tipping point for my interest in Lisp at all.
&gt; Everything I've read suggests that the CVS version of SLIME should be used As far as I know thatÂ´s what you get from the Debian package: $ apt-cache policy slime slime: Installed: (none) Candidate: 1:20100220-4 Version table: 1:20100220-4 0 500 http://ftp.debian.org unstable/main Packages I read 20100220-4 as "CVS snapshot from 2010/02/20, the fourth Debian packaging"
is it called LOL?
It kind of is, actually: http://letoverlambda.com/small-cover.png
Interesting book, but something in the first paragraph immediately caught my eye: &gt; What is a functional language? The only definition that makes sense is &gt; A functional language is a programming language made up of functions. There was a recent Reddit post -- [What Does Functional Programming Mean?](http://www.reddit.com/r/haskell/comments/blb0i/what_does_functional_programming_mean/) -- to a short presentation that clearly made the point that functional programming is not about programming with functions, but instead is fundamentally about: * referential transparency * program compositionality 
Yep, a huge LOL across the cover all right.
He means "functions" in the mathematic sense. With that definition for "function", the following becomes wrong / redundant: &gt; functional programming is not about programming with functions, but instead is fundamentally about referential transparency [and] program compositionality EDIT: By "He means" read: "He presumably means".
This is a great book. It probably shouldn't be your first book on Lisp and it doesn't follow some "accepted" conventions, but it does attack an important portion of the language that most books don't cover very well.
This book is interesting, but it's a minefield too. It is very difficult to distinguish between insightful parts, very personal ideas of the author, and things that are possibly just wrong. It is a book written in isolation, which has not been peer reviewed. Too bad no one wrote a detailed and competent review of LOL.
'Too bad no one wrote a detailed and competent review of LOL' - at that point one has written a new book.
But they're java libraries! That's the worst of the three. the JVM is awesome, the language mediocre, but the libraries and the apis are awful.
I think is also shows a place where lisp could actually be better. Wouldn't types be more powerful to notate the units of a number? Then you could add then substract them, convert them etcetera, and get errors pertinent to the incorrect use of units (like adding meters and seconds), conversion automatically when needed, you could even declare a certain unit to a function argument. Like cos,sin,log etcetera should take an unitless argument. All pretty much without the user having to do things explicitly. I guess you try this in CL already, but of course, one would like some sense of security that it is optimized nicely. It is very easy to do when things are not set, and there is not COND or similar, then you can just calculate the type. If you know the trick to do this with lambdas in there.(Hmm, i should do a little writeup how that works.) If there is COND, you have to have a type (or type-1 type-2) and then see if it can simplify/make a representation in the compiled result specifying the type, which is a lot trickier.. If things are set, sometimes, of course it is simply equivalent to just another LET form.(But lispers probably won't write it that way if it is) Sometimes it is in some form of loop, and then it is hard figure out the type. I guess you could rely on a declaration of the type in that case. I am pretty much **Î»(and his close friend, funcall) over let** this way. Macros are pretty nice, but i prefer not to do any plumbing with them..
I'm not sure I follow your question, but lisp had a unit typing system in 1995. http://userweb.cs.utexas.edu/users/novak/units95.html
Some guy programmed a [procedural musical noise generator](http://www.colba.net/~eliot/shape_web.html) and is [completely in love with it](http://www.colba.net/~eliot/jj_faq.html) and [with himself.](http://www.colba.net/~eliot/jj_faq.html#who) This would be less of a problem if his site was at all informative, which it isn't. There is no source code, in lisp or otherwise, so there is nothing lisp related here. 
**Eliot Handelman** is composer of international reputation and Lisper for a long time. You can find his posts in comp.lang.lisp in late **1980**'s. If you look more carefully you'll find the source code on this site, under the "Software." In ML and Lisp, licenced under the GNU LGPL written this year, **2010**. Also, there are 15 or so of his composition for dowload, for free. Persistence for such a long time in such a strange and challenging combination of automated composition and Lisp - and giving away some of the products of his work for free - certainly deserves mention, from my point of view. 
While the author does not keep a neutral style in writing, which IMHO makes some parts a struggle to read, the other parts have been very enlightening. While I will not recommend this book to a beginner wanting to know what macros are, experienced people will surely enjoy it. If only to remind them why they developed their personal style of macro writing as it is. Thanks for this book!
Neat historical account
This looked absolutely retarded until I saw the number "1983" ... now it sounds reasonable. Good show! Emitting complex graphics was quite a challenge when programmers had such a small amount of disk space (sometimes just a stack of floppies) and ram (oftentimes under 256KB) to work with.
Ooh, it's being maintained again!
Unfortunately, drakma 1.1.0 didn't seem to work with Debian repo cl-usocket 0.3.5-2. (unknown keyword argument: nodelay) To be honest, if this is going to happen, perhaps it is better not to provide it via Debian. The svn version does work, btw svn://common-lisp.net/project/usocket/svn/usocket/trunk, rev 512
Not that it would be a bad idea to write a new book... But I suspect that the CL community is suffering from its age. No one's got enough sacred fired anymore (a trait typical of the youth, mostly). At least Hoyte tried; his book drips enthusiasm.
So I finally got around to trying this suggestion, and it almost does what I want. Here's what I really wanted, &gt; + 1 2 ; [hit C-RET] &gt; (+ 1 2) 3 Here's what normally happens, &gt; + 1 2 ; [hit C-RET] &gt; + 1 2 2 ; It didn't close any parens. It merely returns the last argument. &gt; (+ 1 2 ; [hit C-RET] &gt; (+ 1 2) 3 ; Closes parens, but it's not quite what I was looking for. SLIME's C-RET bound to the function `slime-repl-closing-return` almost does what I want. It closing up any lists, but it doesn't start them. So, what else can one do with an extensible editor but add it. (defun my-slime-repl-opening-paren () "Add an opening paren if there isn't one in the REPL already." (interactive) (save-excursion (goto-char slime-repl-input-start-mark) (unless (eq (char-after) (string-to-char "(")) (insert "(")))) (defun my-slime-repl-opening-closing-return () "Add an opening paren if there isn't one, and close any open lists, then return." (interactive) (my-slime-repl-opening-paren) (slime-repl-closing-return)) (define-key slime-repl-mode-map (kbd "&lt;C-return&gt;") 'my-slime-repl-opening-closing-return)
in theory, that's interesting because it avoids the ambiguity of the parentheses-free repl. In your system, if you type a symbol name and RET, it evaluates to the symbol value, while if you type C-RET it evaluates to a function. However, you save 2 keystrokes (the parentheses) and lose 1 for holding Ctrl to the end the line. Net gain, 1 keystroke, with the added complication that you have to think the correct way to end your line (RET for value, C-RET for function). Is it really worth the effort?
'Recently' Practical Common Lisp was pretty good and the author had enough fire. There are two (mostly) Common Lisp books in the making. One by Nick Levine for O'Reilly and then the book from Conrad Barski. Especially the later should be a lot of fun...
Perhaps another good cite would also be Steele and Gabriel: http://www.dreamsongs.com/Files/Hopl2.pdf
Yes, PCL is very good, and I am waiting for the other ones too. But they are all books for beginners, while LOL is kind of an advanced book (it is meant to be read after "On Lisp"). I would *really* like Peter Seibel to write a sequel to PCL...
What topics do you think should an advanced book cover? 
&gt;No document with DOI "10.1.1.24.8032" &gt;The supplied document identifier does not match &gt;any document in our repository. 
Works for me. Can you get it from here: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.8032 ? As Postscript: http://www.cs.indiana.edu/hyplan/tanaka/GEB/LP/LP.ps 
It works now, wasn't working an hour ago with the same error.
or better http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf
Thanks. I checked RPG's website before posting, and both links on the webpage went to the cut version. Also, RPG *just* wrote a review of AMOP which should be interesting to a lisp culture history buff. I've not finished it yet, but the description of Sussman giving a colloquium on Conniver is alone worth the price of admission. http://www.dreamsongs.com/Files/amop-review.pdf
This article has a horrible title. FTA: &gt; Lisp has long been believed not suitable for hard real-time applications. It is still true if the term "hard real-time" is used in the most rigorous meaning. However, there have been developed a variety of techniques to adopt Lisp for a certain level of real-time applications. At least, Lisp is now being used for a number of soft real time applications. ... &gt; If real-time processes do only a fixed amount of simple computation every time, the system can become hard real-time; but if Lisp is used, the user may expect more or less flexible computation, which implies at most soft real-time by de finition (1). &gt; (1) This is the reason why we do not dare to call our system hard real-time. That kind of says it all. The fact that Lisp can be used for soft real-time isn't surprising, but I think you could say the same of pretty much any language.
That is awesome. Thanks for sharing.
This bears rereading as the R7RS process gets underway. &gt; Designs and standards tend to go in cycles. After a specific new design or standard becomes established, it is incrementally â€œimprovedâ€â€”usually by the accretion of features, until it becomes unwieldy. Then it is time to step back and reassess the situation.
Works fine now. Thanks.
I'm not sure I've ever read a more pleasant or more informative book review. Thanks!
Thanks for the PS. I'm probably missing some font on my system but the PDF rendered on such a low quality it was unreadable for me.
Not being advanced myself I cannot envision all possible advanced lisp books. Anyway, I'll try... In general, I think that the basic books explain what the "pieces" of lisp are, so the advanced ones should be about what one can do with them. For example "On Lisp" does this for macros. CL is quite sophisticated (conditions, CLOS...) but it is not very clear -to the beginner at least- what one can do with these things. PCL has some chapters doing this, but the greatest part of the volume is about the basics instead. CLOS: there are stacks of book on "design patterns" around targetting the Java OO model. There is nothing comparable in the CLOS camp (Keene's book is all we have, and it just give some examples). I know that theory of Peter Norvig that most design patterns from the GOF are not necessary in Lisp-like languages, but then it just means, I suppose, that the patterns are different, in the sense that there will be other common, best-practices patterns to structure things. Best practices, in general. You are a resident of CLL, you know how ugly and "unlispy" may look the code of newcomers. How does one attain "lispness"? (I know it is a bit vague, but maybe it's something worth exploring). Optimization. There is something in PAIP, but not much. There is an old paper by Ken Anderson showing how a Genetic Programming program by John Koza can be made drastically faster. But there is no comprehensive treatment of the topic. And trying to make CL code look like C is probably not always a good/necessary thing. (BTW, On Lisp starts great but ends a bit questionably on this side. The last chapters implement very interesting things, but in a way that PG himself says it's too inefficient for real world use. One is left with doubts.) In general, no suggestion is anywhere, AFAIK, on the best ways to structure large and complex software written in CL. I found this a real problem. These are just my thought at the moment; there are probably many other areas...
These are all useful points, great! If you have more ideas, add it...
I'd settle for soft real time. Not that I've done an exhaustive survey, but I still haven't used a CL implementation with a GC that lets me do real time animation without noticeable glitches in the frame rate.
I was just submitting this just because of the page title, sorry. But I was myself expecting something different. How different? Difficult to say, but I wanted to be surprised. As an apology: here is some hardcore Lisp software: http://www.hcsw.org/
Human-like AI can't be achieved by clever programmers writing breathtaking code in advanced languages. The algorithms which produced human intelligence were quite simple -- Darwinian evolution. Humans have cognitive ceilings, and teams have also scaling ceilings, so it doesn't surprise me that language progress stopped with LISP.
&gt; Humans have cognitive ceilings, and teams have also scaling ceilings, so it doesn't surprise me that language progress stopped with LISP. That assumes that the language is above the cognitive ceiling. Might it not well be that the language one would write it in is attainable by us(as it aught to be simple), and the constructs above that are achievable completely as libraries from that language that language. (I don't think this language exists today)
What I meant is that people have a cognitive ceiling (which, of course, vastly varies between individuals, but even the smartest person has a limit, and a team of them is not improving things considerably). The core problem of human-grade (and beyond) AI is that we're not privileged observers as far as introspection is concerned, and we're prone to hybris when facing problems we poorly understand. It is much better to delegate the problem to systems which have no such bias and scale better. We know that Darwin did it once, and neuroscience is a source of plenty of constraints, so we don't even have to brute-force from scratch. LISP isn't a particularly useful tool here, of course. It's a powerful tool for smart people. Less useful for less than stellar folks, and not useful when facing problems way outside of human design reach. 
&gt; What I meant is that people have a cognitive ceiling (which, of course, vastly varies between individuals, but even the smartest person has a limit, and a team of them is not improving things considerably). You have neither claimed nor proven that this is below that which is necessary to implement, by your representation, "simple -- Darwinian evolution" algorithms. &gt; LISP isn't a particularly useful tool here, of course. Why not? What is "here"? &gt; It's a powerful tool for smart people. Less useful for less than stellar folks, and not useful when facing problems way outside of human design reach. More vague remarks with no actual claims or meaning.
There are a couple of companies using Lisp but I see nowhere near the amount of job offerings like you see for Ruby. You could be lucky but I think you'll have to create your own opportunities.
I have been trying to think of how to make this happen for about a year now. The problem with trying to make your own opportunities is that so many people have done that that the market is getting tougher. Plus, how do you extoll the benefits of Lisp to pointy haired CEOs?
One option is to make something people want and sell it.
Did you look here? http://lispjobs.wordpress.com/
I'd just like to thank you for articulating exactly what I think every time I read about clojure. It has cool features but nothing other than Java interop that is simple to achieve in common lisp. Lisp 1 huge advantage? funcall really isn't a toughie. (setq x-var #'append) (eq (symbol-value 'x-var) (symbol-function 'append)) T single namespace is nothing that special and makes macros at least twice as hard to use (keep track of both functions and variables rather than just variables). Scheme is a beautiful language it really is but I prefer Common lisp, Clojure really doesn't seem like the second coming. Read CLTL! the people that wrote the spec are incredibly intelligent. Don't dismiss CL just because it's older.
Find an employer that gives you a lot of freedom and you'll be able to use Lisp at least some of the time. Now, I don't know how to detect such employers ahead of time so you'll still have to figure that part out. Perhaps something more academically oriented? In my case, I work for a laboratory and most of the time I'm free to solve a problem in whatever way I think is best. All that's important is a timely result, and the result isn't some program but a report or some specifically formatted data. Our business is analysis, not tools. I build and maintain my own software tools to do my work, and I completely control all aspects them. This means I get to use Lisp when I desire. For most programmers, Lisp is hard and requires a lot of independent study (and unfortunately lack of solid Windows support doesn't help a lot either). Because of this I don't think there will ever be many Lisp programmers, and so there will never be many Lisp jobs. As aerique said, you have to make your own opportunities. 
I did look at that. Most of the jobs listed there want a lot of experience (Professional) which I do not yet have. Lisp has largely been a hobby and toy for me for 10 years now but I would love to work in it daily at some point.
[Got this one](http://www.streamtech.nl/site/lisp+internship) but that site has been the same for pretty long. (And i have no idea where you're at.)
you might also have a job request there - it will be then posted there
&gt; Plus, how do you extoll the benefits of Lisp to pointy haired CEOs? You don't, you sell yourself and people will let you use your own tools. If they don't, you don't work for them. Why would you want to work for a pointy-haired CEO anyway? ;) Send me a resume and an example of some lisp code you've written to "drewc at tech dot coop" . We often need extra help, and we work primarily in lisp... maybe we can come up with a way to get you some experience. 
Have you found opportunities to start using Common Lisp at work? You sound as if you're willing to take risks and/or do stuff on your own time anyway. If an employee came to me with a solution that he did on his own time that solves a problem, I'd be hard pressed to turn it down because of the implementation language. Edit: Working in an industry where technology isn't necessarily the prime focus but still highly-regarded may help as well. I know of at least a few hedge funds using CL. And you didn't mention a location or resume... a portfolio or indication of types of projects you've done would probably help.
&gt; and unfortunately lack of solid Windows support doesn't help a lot either LW and ACL work very well. I don't disagree with the sentiment with respect to Open Source implementations, though there have been some healthy improvements recently.
Depending on your .NET work, there is L#, RDNZL, IronScheme, the CLR branch of Clojure.
http://wigflip.com/ is Common Lisp. It uses my libraries from http://xach.com/lisp/ and libraries from other people, too.
pascal costanza's website is written in Lisp: http://p-cos.net/
Reddit originally ran on Lisp.
En Route Spokane, a Spokane-area bus trip planner is in Common Lisp. http://enroutespokane.com/
http://dwim.hu the content is lacking badly, but the framework is visible and it's all opensource. and there's even an install guide to replicate a local copy of the site. oh, and i think it broke again on ie, but i'm getting more and more reluctant to keep it running there... 
Netcoach, customers: http://www.orbisusa.com/index.php?id=901
http://news.ycombinator.com/
According to http://www.weitz.de/hunchentoot/ : "Hunchentoot is for example used by Postabon, City Farming, Trip Planner, clutu, TwitterBuzz, Jalat, Heike Stephan, xOs, and the NIST" I'm not sure who might be using http://common-lisp.net/project/ucw/ which is the other popular web framework for Common Lisp.
I'm using FF 3.5.8 and are getting that client side error/upgrade message constantly, what should I do?
The [CLiki](http://cliki.net) is written in CL + araneida. There is a semi-working port to ucw-core lying around somewhere as well.
Scheme or CL, did you use any libraries of note?
Cool stuff, are all the apps using CL or just the main site? When I check your lib page I'm inclined to guess that all of it is built with CL.
All the apps are built with CL. Generates about 10,000 graphics daily.
So Netcoach itself is written in CL?
Never mind, noticed the LML link and clicked it, got it.
yes
That sucks! I hope that Nick recovers from his health problems. All the best!
So I've compiled a list now of all the things posted here and some more stuff here: http://www.prodevtips.com/2010/04/13/a-list-of-web-applications-built-with-lisp/ But some prominent dialects are completely missing, like Scheme for instance, is there really nothing out there made with Scheme? Anyway, keep em coming regardless of dialect if you've got them.
you can ask in the Scheme subreddit Hackernews is written in Arc, which runs on top of Scheme.
I didnt make the website btw, I just knew that the site was written in Lisp
Poor guy...it was looking like another must-own. What a horrible ending to O'Reilly's Lisp experiment. I hope Nick gets better soon.
&gt; Poor guy...it was looking like another must-own. &gt; What a horrible ending to O'Reilly's Lisp experiment. 1/3rd of the post was about how O'Reilly is interested in continuing with the book. &gt; I hope Nick gets better soon. As do I.
Not that I think this whole line of discourse will yield any piercing insights but... &gt; Software transactional memory? [CL-STM](http://common-lisp.net/project/cl-stm/) [Implementing STM on LispWorks](http://www.reddit.com/r/lisp/comments/ay0e1/implementing_stm_on_lispworks/) &gt; Destructuring bind in fewer than 20 characters? defmacro it away. &gt; Doesn't need to reimplement old Common Lisp APIs? If you use ABCL, why do you have to reimplement "old Common Lisp APIs." What meaning is your selection of the word old meant to convey? &gt; Lisp-1 What is the benefit of this? &gt; Lazy sequences? That's a good one. There are some options but Clojure really shines provided that its definition of lazy fits your domain well (in terms of intelligent planning/access of limited/expense resources and so forth). &gt; {} vs make-hash-table? I defmacro'd this. That of course opens up the argument about having to defmacro it but I don't think that is too strong.
That is truly terrible news. Book or no, I wish Nick a speedy return to health.
http://lisper.ru
we did [perioperativebleeding.org](http://www.perioperativebleeding.org) in common lisp. This is an e-learning-website for anaesthesiologists providing cme-points. used technologies: * sbcl * hunchentoot: web-framework * cl-emb: templating html files * postmodern: to access postgres * cl-pdf: generate pdf-files 
btw. does anybody know what happened to ANSI Common Lisp Reference Book by David Margolies (Apress). I had preoder in for years. 
Cool, will add it.
http://the-deadline.appspot.com/ is a Clojure app.
Once, Apress also declared it wanted to reprint "On Lisp"...
Brian Carper made his [blog](http://briancarper.net/) in Clojure
http://ffclassic.net is built using clojure
the framework version on dwim.hu was rather buggy due to some half-baked refactoring. i've updated it and the current version should behave better.
I recently read a book by the founder of ViaWeb, called Hackers and Painters. I highly recommend the book. The author (Paul Graham) is a bigtime proponent of Lisp. In the book he makes a case for Lisp being the most "powerful" language for web development. His site, ViaWeb was built using Lisp. He talks about "macros" in lisp, which are apparently extremely useful for web development. 
Thanks for the new stuff, I added it to the list. I get the impression that separate libraries is the most popular way to go when using CL, ie. not through UCW or WebLocks. Given the problems I had getting them running (especially UCW) some 2 years ago when I wanted to try out CL I can understand that.
Yes and they were bought by Yahoo and AFIK not much of the original code is still running. Nothing wrong with it though, just that it was probably easier for Yahoo to find Perl people to expand the offering at that time.
That seems a little generous to call balanced parens "paredit mode". I also didn't understand your comment about slurpage and barfage. 
Slurpage and Barfage in Emacs moves the list elements into or out of the current list. My approach is to move the parenthesis under the cursor instead to achieve a similar effect. So in the list (x y z) you move 'z' out of the list to the right by moving ')' to the left via the &lt; key in normal mode, and you get (x y) z. Of course many paredit.el features are still missing, but I keep adding them to the script. I would appreciate if you could name those that are needed most.
Hey, if Perl can do it... http://www.perl.com/pub/a/2001/08/08/quantum.html
Really nice article! 
More Vim goodies (shameless plug): http://www.vim.org/scripts/script.php?script_id=2951
&gt; We can make our own variables just by using them, by giving them a value We most certainly cannot, not in a defined way. Moreover, even if your implementation allows it, you certainly shouldn't, it's not common lisp. &gt; (setf a 100) Are you fucking serious? and not even an earmuff in case it's now special? yikes. 
Eh imo they should rename the Python part.. I subscribed.
Maybe Python, the language, should be renamed? CMUCL's python was there before.
"Google Go" ring a bell?
Maybe Python, the animal, should be renamed too, while we're at it, to prevent further confusion with the language.
Rename LISP, too (Locator/Identifier Separation Protocol).
Jasper is being downvoted, but I don't think he's so wrong. The problem is that the language is *way* more known that the compiler, and both are in the same domain (unlike the animal). Every time I read "python" in SBCL, I experience some milliseconds of cognitive dissonance, even if I know what it means in that context. Anyway, I agree that in this case, the codename of a lisp compiler is probably a matter obscure enough not to be worth of a renaming, since it does not need instant recognition etc.
A bit aside, but calling it an 'AI language' brings nothing but confusion to anyone not privvy to lisps history. Edit: This article is much more than that..
Nitpick: you are probably reading "Python" in SBCL, not "python".
Even better is the code sample on the front page: &gt; What will QLisp Look like? &gt; Like this: (MEASURE (QBLOCK (+ (QCOND ((QFN-EQUAL #â€™F1 #â€™F2) 0) ( T 1)) (F1 0)))) I guess their editor doesn't support indentation. I can see the requests for infix support now. EDIT: &gt; We chose to use Lisp rather than Scheme primarily because of the richer set of debugging and optimization tools available, and because once one has Lisp, it is easy to write Scheme, but the converse is not true. The whole page really delivers on so many levels.
I hope [this](http://ojasper.nl/Blog.html#Type%20calculation) will clarify what i mean. and perhaps stir up some discussion about what we want in some eventual future new lisp. (Of course, it could do units.)
Also posted in [lispforum](http://www.lispforum.com/viewtopic.php?f=29&amp;t=696&amp;p=4377#p4377), and [comp.lang.lisp](http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/d325a092677f5237#).
Since you did not use the proper name Common Lisp then i take it any language of lisp family is game. Clojure has several web frameworks. I use [compojure](http://github.com/weavejester/compojure) which is based on [Ring](http://github.com/mmcgrana/ring/tree)
How about examples or something? What is it supposed to do? Why is it useful? ["Example mucking about"](http://ojasper.nl/essays-src/type-calc-muck.lisp) is not really an example -- it is a list of forms to try. I'd like to see what these forms produce without loading this thing locally.
The reason it is useful is because you want to know the types of stuff, there is a reason that C wants you to give the types everywhere; it is so that the binary compiled doesn't need to denote and check the type everywhere. The mucking about does demonstrate that it can calculate the type. It is an example that way. If i made more involved examples, i'd need a tonne more code for the types, a lot of it outside the scope of the article. I do have a lot of this stuff written at various levels of quality, though, but for a 'new lisp' i have a very high standard. What do you mean 'loading this thing locally', without being in-package :type-calc? That should work too.. Incase you missed: this isn't an actual application for direct use by users. It is more like research into how the next lisp is to be.
&gt; The reason it is useful is because you want to know the types of stuff, there is a reason that C wants you to give the types everywhere; it is so that the binary compiled doesn't need to denote and check the type everywhere. How is it different from type inference? Common Lisp implementations usually have some sort of type inference, e.g. SBCL is even pretty good at it, so you need to explain (I mean if you want your message to be understood) why is it different from what we have now. There are some experimental Lisp dialects with strong typing and type inference. E.g. [TypeL](http://www.cliki.net/TypeL). Are you trying to do something like that? &gt; What do you mean 'loading this thing locally', without being in-package :type-calc? No, I mean you should provide example of output it produces. Like examples in CLHS: (find-symbol "temp") =&gt; NIL, NIL If you show output in comments, you might get more attention from lazy people like me who do not want to run your code themselves.
&gt; How is it different from type inference? Repeating the link a little here: * You can add type calculators to your own functions aswel. * Type calculation is a transformation that produces a form that can be inspected by users. * Users should be able to see what sort of types the code will use in expansion. Edit: i mean 'see' as in reason here I call it type-calculation because it is at every point straightforward. It is not like an equation is being solved. It is also covers a large subset of places where types can be calculated. But the article also has some other points.. About TypeL.. I can't really look into it atm, not sure if one would call this strong typing. You can make a function without types and then use it in a place where types are know, and then it will make a variant of that function with types specified. I mean, each function is a bunch of (function arg-types ret-type) orred together, and at compile-time, functions are to be created from that. It might join, and treat some together, or it might make a variant for each type. Thanks for the suggestion of putting results in the examples.. I should've thought of that.. Will do that at some later point.
Looks useful. There are some omissions and slight errors. ATOM is not the same as list? An Atom is everything that is not a list and not nil. Though the real differences can be seen from programs. They tend to look quite different, even though one might find similar looking primitives in the languages. Not that important, Lisp Machines did not end in 1989. My NXP1000 is from 1992. Open Genera 2.0 is from 1998.
Some say Perl has syntax, I see noise.
Compromise on syntax they say, I see overdoses of syntactic sugar.
Also see "A Sanely Bootstrappable Common Lisp" by Christophe Rhodes for a good description of the bootstrap / build process which has some surprising intricacies (mainly keeing the host and target seperate)
(truncate (/ 7 3)) is an unnecessarily verbose way to write (truncate 7 3)
Lists SISC but not Kawa (which is a gazillion times faster). Go figure.
&gt; An Atom is everything that is not a list and not nil. Um. (atom nil) -&gt; T
An Atom is everything that is not (a list and not nil)?
Thanks. (defun my-atom (object) (not (and object (listp object)))) (defun my-atom (object) (or (null object) (not (listp object))))
*not a cons. Just sayin'. (atom '(1 . 2)) -&gt; NIL
 eq, equal, = Yeah, it's missing a couple of comparisons: eq, eql, equal, equalp, =, string-equal, string-equalp...
Wow. Zuckerberg really is Zuckerberg.
Line noise, that is. And, &gt; Doctor, I've been having the worse migraines recently &gt; Miss, you need to stop with the Perl programming.
&gt; ATOM is not the same as list? I think his point was that some Lisps have `atom` and others have `list?`, and one can be expressed using the other.
ITA Software is well known for its prominent use of Common Lisp and employing a lot of Lisp programmers.
I have no idea about those videos but Hunchentoot has pretty decent quality documentation so it shouldn't be too bad. I moved a small hobby project from an earlier version soon after the new version appeared and it really wasn't too painful (though I was already familiar with common lisp by that stage).
And the first thing they'll do is make them rewrite it all in C++ and Python?
Are there any Lisp shops other than ITA? Or if there are, any of their size? I remember there was a google talk about how they use clozure. I tried to find something I could prototype games with lisp easily but to no avail - maybe my google-fu is not strong enough.
Can't have that Lisp anymore since the team will be rotating. JAVA JAVA JAVA it is the best. Write some unit tests while you are at it.
First they steal Norvig, now this?!
Lots of ITA's core software is already C++. My recollection is that it's mostly "big dumb structs": C++ lets them easily memory map these for excellent performance. The tricky optimization stuff is in Lisp. I'm sure there are some ITA folk around here who know better, though who knows how much they can say. As for Python, wouldn't shock me at all if they're already using it on the front end, at least. EDIT: Good, albeit old, post on ITA's architecture on [pg's site](http://www.paulgraham.com/carl.html). 
http://lispgamesdev.blogspot.com/ usually has good links. http://tech.coop is a CL shop. http://www.inspiration.com/inspiredata and http://www.medialab.com/sitegrinder3/ and http://www.lissys.demon.co.uk/ are CL applications. There are fewer Lisp shops than, say, Java or .NET shops, but they're around.
jsnell's theft was worse!
There are other companies using Lisp. Still ITA is the largest one, I'd guess. There should be some that have more than a handful Lisp developers. Usually you could meet people working at these companies at Lisp conferences or workshops. See for example here: http://www.european-lisp-symposium.org/ The list of sponsors also should give you an idea.
Wait, until they steal Steele.
thanks!
well done, have a cookie
But doesn't "tricky optimization stuff is in Lisp" and "C++ used because it's easily memmapped" imply that ITA's core software is very much *not* C++ but simply using C++ for mmap? You make it sound as if the the search facility is just a simple add-on the the structs are the core software...
Maybe they are the [fifth column](http://en.wikipedia.org/wiki/Fifth_column).
In short, as I understand it, ITA's core software 'secret sauce' includes ingredients from both C++ and Lisp. It couldn't be adequately written in either language alone. My guess is that the C++ codebase is fairly large, and not just a few struct definitions, mmap calls and FFI code. From the link above: &gt; Occasionally we've had to move code from Lisp to C++, usually because of data loading issues (Lisp garbage collectors just can't deal with gigs of data, and there's no way to rapidly load gigs of data into a Lisp). Our experience has been a 10 to 1 code expansion... So LoC-wise the C++ component has got to be substantial, even if it's providing much less functionality than the Lisp (and I'm not sure about this at all: they're probably both handling big tasks, just in very different domains).
Captain Obvious! Finally we meet!
Oh you definitely get an upvote. :)
Think he's looking for apps, not frameworks.
Now thats really good news. A reasonable CL-Implementation that runs on many relevant Platforms.
So the main new user visible feature of this release is a lot of bug fixes?
Yes. See also: clisp, cmucl, sbcl, lispworks, ecl...
Unfortunately, it requires SSE2, so not exactly all platforms ... But, where it works, it works great.
Wow, I had no idea ASDF had any versioning in it. I have read critics of ASDF where one of the main complaints was no versioning support. I guess the question is, can I have the same system at two different versions in my registry? Almost certainly they cannot be loaded at the same time since it will clobber itself...
I don't really see that as being a problem, SSE2 has been around since 2001 in Intel processors and 2003 in AMD processors. 
Is slime working for everyone else? Slime/Swank stopped working for me (On Win32) after the upgrade.
I had a look at [AllegroGraph's](http://www.franz.com/agraph/allegrograph/) documentation. I'm not sure I really follow. Is this a replacement for SQL databases? If so, what's the advantage? Any idea how this compares against similar things like [CouchDB](http://couchdb.apache.org/)?
Graph databases are probably not a replacement for sql databases, but deal with a different problem that is hard in SQL which is not very good at recursion. The typical example would be a friend-of-friend (or friend-of-friend-of-friend-of-friend-of-friend) query for a "social" website. That should be simple for a graph database, but difficult for a typical SQL product. neo4j is another graph database, but not in lisp.
looks pretty cool.. 
No, not a replacement for SQL or even object databases. AllegroGraph solves the problem of storing triples (subject, object, predicate). Triples are how knowledge is stored in the semantic web. &lt;joe, isa, man&gt; Once you have enough of these, you can do inferences over your database to find out interesting things. The reason there are specialized databases for storing triples is that the retrieval of triples in a specialized task and all the existing databases do it very badly.
In fact, Oracle is orders of magnitude slower at loading and quering triples than a AllegroGraph. Oracle just wasn't designed for it.
I'd be interested to hear his reasoning on why he is doing this instead of contributing to [Movitz](http://common-lisp.net/project/movitz/), if his motivation is to get a Lisp OS (as opposed to "because I like the challenge", which I can totally respect as a valid reason).
For shits and giggles? For fun?
This is an excellent tutorial. 
Movitz is very interesting. Thanks for pointing it out.
SBCL is fairly notorious (probably due to its popularity) for having terrible threading support on Windows. CMUCL doesn't even have a Windows port. EDIT: And if you want to do web programming, there are/were [problems with Hunchentoot + CLISP](http://www.google.com/search?q=%2Bclisp+threading+hunchentoot)...
Thanks, I read the manual and did a few problems. Frankly I found the language annoying. Why should `'(1 2)` be quoted but `()` is fine without quotes? Why is the quote even necessary in the first place? Lists could be just left unevaluated until they are fed to `eval`. The parentheses are supposed to "melt away" after some time, but they didn't for me during the several hours I mucked around. In fact I couldn't see anything but the endless parens when writing something :( Maybe something like Mathematica which lets you use [{()}] would improve the visual perception. And `let`, `let*` and `letrec`? I don't know, this is supposed to be a simplified Lisp? Maybe I don't get it, that's fine. I suppose the impenetrable syntax is a trade-off in exchange for the ability to write something extraordinary and concise, but I don't know what that might be. All I see is strangeness like `(- 0 1)` and rows of ))))). The ability to manipulate lists is good but having code as lists is really a compromise, imho. You could just as easily have "sane" syntax as a thin veneer on top of the actual AST, to which you could refer directly whenever you need to manipulate code at runtime, while still enjoying readable code for the other 99% of the time. Just a C++ guy's perception after an honest try. Don't knock me, like I said I probably just don't "get it", which is fine.
&gt; Why should '(1 2) be quoted but () is fine without quotes? Because (1 2) means "Call the function named '1' with argument '2'.", while () or nil is a special symbol that evaluates to itself. &gt; Lists could be just left unevaluated until they are fed to eval. But in lisp, an unquoted list is a function call. And actually, they were fed to eval in your code -- the entire source you wrote was just fed to eval. &gt; The parentheses are supposed to "melt away" after some time, but they didn't for me during the several hours I mucked around. In fact I couldn't see anything but the endless parens when writing something :( Maybe something like Mathematica which lets you use [{()}] would improve the visual perception. Proper support in whatever editor you use really helps here -- plenty of people who write lisp use "rainbow parens", meaning they have all the different paren pairs output with a different color. Others just have the scope you are in highlighted. &gt; I suppose the impenetrable syntax is a trade-off in exchange for the ability to write something extraordinary and concise, but I don't know what that might be. All I see is strangeness like (- 0 1) and rows of ))))). After a while of use, the syntax really isn't that impenetrable -- it grows on you. &gt; You could just as easily have "sane" syntax as a thin veneer on top of the actual AST, to which you could refer directly whenever you need to manipulate code at runtime, while still enjoying readable code for the other 99% of the time. There have been various projects trying to add syntax to lisps. They tend to fail, because after you have used it for a while, the parens really do melt away, and the code does become every bit as readable as any other language. Thus, adding syntax is the kind of "improvement" that only newbies suggest, and by the time they are done with implementing, they have already started to doubt the sanity of their project. Personally, I prefer how unflinchingly regular the code looks -- even if I never used macros, I'd still prefer the syntax, because after you get used to it, it is much faster to visually parse than any other programming language I commonly use. I think the reason for this is that lisp has no precedence -- while (\* (- a b) (+ (sqrt c) d)) is more noisy than (a - b) \* (sqrt(c) + d), I can parse the lisp version strictly in-order, while I have to look at the traditional version as a whole to understand it. &gt; Just a C++ guy's perception after an honest try. Don't knock me, like I said I probably just don't "get it", which is fine. No problem. Your observations about the syntax are more or less the same I had a few years back.
&gt; Lists could be just left unevaluated until they are fed to eval. What if you want a list whose first element is eval? Or a list that starts with an undefined atom? `quote` prevents evaluation. Making "when a list begins with a number or an undefined atom, it's as if quoted" can cause unexpected effects. Say, if you write (cond ((nullp a) b) ('t 0)) would always return `b`, since the `nullp` atom is undefined (being `null?`). `()` is fine sans quote, because it doesn't have a first atom that can be evaluated. It's also valid as `'()`, and `nil`. Or the opposite: everything is unevaluated until explicitly `eval`d would add evals all over. Does `(eval (a b c))` mean "eval a, b, and c, and use their values as contents"? or does it mean "call the function a with b and c as parameters"? `'(a b c)`, `(a 'b 'c)`, `\`(,a ,b ,c)` all do different things. &gt; In fact I couldn't see anything but the endless parens when writing something :( Maybe something like Mathematica which lets you use [{()}] would improve the visual perception. A good editor can help there. A Z-machine emulator in a web page isn't a full-fledged lisp editor. &gt; And let, let* and letrec? I don't know, this is supposed to be a simplified Lisp? It's a full Lisp (schemeish) AFAICS. &gt; All I see is strangeness like (- 0 1) and rows of ))))). I'll give you the arithmetics; polish notation should remove parentesis :P. However, in function calling, what is the difference betreen `foo(bar, baz)` and `(foo bar baz)`? What about: you can define sum recursively, sure. But you can also cheat: (define sum (lambda (x) (eval (cons + x)))) There is `sum` in all the glory it needs (and even, too much; this lisp lacks apply, which'd make it `(define sum (lambda (x) (apply + x)))`) And there shines the homoiconicity: `(+ 1 2 3 4)` is just a list. A list composed of a function and parameters. It is similar enough to `(1 2 3 4)`. Which is just its tail. Compare that to m-expressions: sum(1, 2, 3, 4); // Problem 1: variable parameters. What is its tail? 1(2, 3, 4); The first element of the list is outside the list. HTH.
Hey, like I said, I totally respect those as valid reasons. I was just asking in case he really wanted to pursue reviving a Lisp Machine on top of a modern platform as his primary goal (instead of "having fun" as the primary goal). If so, it would seem Movitz is a better starting point than what he is attempting.
&gt;Maybe something like Mathematica which lets you use [{()}] would improve the visual perception. There are newer lisps that do precisely that. For example, in [clojure](http://clojure.org/): Call: `(+ 1 2)` List: `'(1 2 3)` Vector: `[1 2 3]` Map: `{"bob" 23, "sue" 21}` Set: `#{"bob", "sue"}` (and commas are whitespace)
I'm the developer of this. My original goal wasn't to build a Lisp OS, it was to build a minimal OS. I wound up choosing to base it on Lisp because I thought that the most effective way to realize the essence of an operating system. The name of the project comes from my original plan of providing OS functionality via different layers of language abstraction. One layer would just provide memory management, while another layer would sit on top of it and provide multitasking. The idea was to continue on like that, building new OS features by building continually more sophisticated languages in terms of simpler ones. Basically, the project was an experiment in operating system architecture. Movitz is a very cool project, but its goal to implement the Common Lisp spec would be at odds with my goal to see how minimal one can man an OS.
Awesome :) Are you still developing LOSAK?
Thank you very much for the explanation, it explains a lot about your design decisions and motivation, which is awesome. With such a layered approach, would there not be a lot of what is effectively message passing between all the function calls interfacing the API layers? If so, how do you anticipate addressing the message latency issue that plagued GNU Hurd until hardware advances practically solved that issue for them?
In the long term yes, but I'm a little preoccupied with real life right now to invest any time in it.
The layers are intended to be abstraction layers, not necessarily runtime layers. Eventually all of the layers would be different components of a compiler pipeline. The lowest layer is already implemented as a compiler, and for the next layer up (multitasking), I have a proof of concept compiler that needs a bit more polish before I can make another release.
&gt;. Why should '(1 2) be quoted but () is fine without quotes? I agree, () should not be allowed, and in most Schemes it is disallowed. &gt; The parentheses are supposed to "melt away" after some time, but they didn't for me during the several hours I mucked around. I imagine it takes a few weeks if you are attached to some particular syntax &gt; And let, let* and letrec? I don't know, this is supposed to be a simplified Lisp? Well if you want it simpler, you can make all of these with lambda and set!, but that wouldn't be as readable ;) I'm not sure whether you are just making a blanket statement, in which case I disagree with it, or if it is a thinly disguised request for an explanation, so I will try to elucidate. I think that they are perfectly simple as long as you realise that, although syntactically similar, they each represent a different idea of when variables are bound and what they are bound to. I will try to show these ideas by example. Example 1. (let ((odd? (lambda (x) (if (zero? x) #f (even? (- x 1))))) (even? (lambda (x) (if (zero? x) #t (odd? (- x 1)))))) (odd? 3)) If you type that into a scheme system, you will get #t (true), which is what you expect. So all is good, or is it? What is the even? in the odd? function bound to? What is the odd? bound to in the even? function? In this case, the (at first) surprising answer is that they are actually bound to previously defined functions called even? and odd? and not to the ones you think you are binding them to. A simple code transformation makes this more obvious ((lambda (odd? even?) (odd? 3)) (lambda (x) (if (zero? x) #f (even? (- x 1)))) (lambda (x) (if (zero? x) #t (odd? (- x 1))))) Here we see that in effect you were creating a function, and applying it to two arguments (both of which are functions). And it is much more obvious that the even? and odd? you bound cannot see each other. Example 2. (let* ((odd? (lambda (x) (if (zero? x) #f (even? (- x 1))))) (even? (lambda (x) (if (zero? x) #t (odd? (- x 1)))))) (odd? 3)) What's changed this time? Well we added a star to let for starters :), but what about the bindings? Well in this case, a let* can be thought of as (let ((odd? (lambda (x) (if (zero? x) #f (even? (- x 1)))))) (let ((even? (lambda (x) (if (zero? x) #t (odd? (- x 1)))))) (odd? 3))) So, where is the even? in the odd? function bound? Like before, that even? is bound in the global environment of the scheme system. So far so good. But what about the odd? in the even? function. In this case, it is bound to the odd? *that you bound in the let*. The key lesson here is that each binding in let* can see each of the bindings that preceded it. Example 3. (letrec ((odd? (lambda (x) (if (zero? x) #f (even? (- x 1))))) (even? (lambda (x) (if (zero? x) #t (odd? (- x 1)))))) (odd? 3)) So what about letrec? In this case, you are getting what you probably expected in the first example; that is, the odd? in the even? function is the one you are binding in the letrec, and the even? in the odd? function is the one you are binding in the letrec. Since I showed transformations for the last two, (let ((odd? #f) (even? #f)) (set! odd? (lambda (x) (if (zero? x) #f (even? (- x 1))))) (set! even? (lambda (x) (if (zero? x) #t (odd? (- x 1))))) (let () (odd? 3))) Now, this transformation isn't quite right as you can find out [here](http://community.schemewiki.org/?scheme-faq-macros), but it will serve for explanatory purposes. What we have here, is that two bindings called odd? and even? are created and bound to #f (chosen arbitrarily), and then we rebound them to functions. This allows the bindings for odd? and even? in those to functions to refer to the correct bindings. This is similar to having a forward declaration for a function in C, only it is enclosed in a syntactic form so you get to forget about it :) So, letrec *let*s you refer to bindings *rec*ursively At this point, you are probably thinking "I thought he said that it was simpler", and I still stick by that. The key points for each are easy to remember and give you different scoping options. It may be more flexibility than you want and that you would be happier with just one, but that is what you have been given :) As the pythonistas say "explicit is better than implicit" (although whether or not Python obeys that is a flame war for another time :) &gt; you could just as easily have "sane" syntax ... while still enjoying readable code for the other 99% of the time. I know what you mean, but as someone who came to scheme *for the syntax* as opposed to macros, continuations, or that "Eureka" moment, I find that ever so slightly insulting. :) EDIT: Formatting
SICP is more an introduction into the software development side of computer science. I would recommend it and it also shows a lot of useful techniques that can be used with Lisp, but its main purpose is not to explain Lisp programming. For a modern introduction to Lisp I would recommend [Practical Common Lisp](http://www.gigamonkeys.com/book/).
I would read SICP after two or three other lisp books (http://wiki.alu.org/Education). It has good stuff to learn, but is better digested with a bit of experience.
No. I too, thought that SICP is about teaching Scheme. But it is not, it just uses Scheme to demonstrate the topic. If you want to learn Scheme, it is probably easier to start with "The Scheme Programming Language 4th Edition" or "Simply Scheme", both available for free on the Internet.
&gt; My problem is that I learnt programming basics about 5 years ago with Pascal in a very structured way. How is that relevant to your choice? &gt; This book and lectures seem to have a quite different approach to the same subjects with a radically different language. Lisp is different. &gt; How would rate SICP in comparison with Practical Common Lisp in the subject of introducing you to Lisp, assuming PCL is a 10/10? A 5/10 would be enough for me. So you have already made up your mind that if SICP is at least an average book that you're already going to read it. Insert koan about the master and the tea cup here. Your question has no answer. They both introduce you you to Lisp, although to two implementations that have very different goals (CL vs Scheme). You should read both, but PCL will get you to the self-sufficient stage a lot faster.
I'll add that "Successful Lisp" is more of a Lisp tutorial/lightweight reference than it is an intro to computer programming... I personally love the book, but I found it to be more useful after I already grew comfortable with the language (via Seibel's PCL). But if you need to re-learn computer programming, I'm a bit out of ideas. Paul Graham's a badass. Thought I should add that. Lisp macros didn't "click" for me until I digested a good chunk of *On Lisp* (and magic mushrooms.. heh)
If you know some programming and also Pascal, then SICP is a great book. Learning Lisp with the book? 3/10 I'd say. Though you will learn some valuable Lisp programming techniques in depth. If you have some time, read both books.
I should have phrased that in other terms. My goal with SICP is to revisit basic programming concepts from a different angle. What I wanted to know if it would leave a sour taste for Lisp (academic books tend to do that). That's why I asked how would he rate it since I have no idea. If it will narrow too much my perception of Lisp then I should learn Lisp before as suggested by nuntius.
About a year ago I was in the same situation and I started with SICP as a way to learn Lisp. IMHO, it's not really the best way to learn and be productive with Common Lisp. However, I think it's a wonderful way to learn how to learn how to leverage a lot of the functional programming idioms and styles you commonly use when programming in Lisp. Higher order functions, recursion, nested functions, filter map reduce, streams, etc. Yes, you can get a these techniques from other dynamic languages but, if you're not using them regularly, SICP will drill them into your skull so you start using them regularly. Also, the presentation of the material beautiful and very well thought out. I ended up working through chapters 1-4 (and a bit of 5) in SICP before moving onto Practical Common Lisp. The reason for the change was I wanted to learn enough CL to work up to reading On Lisp. I got a lot more out of SICP than any of the other books I read at that time and, if I had the time to do it again, I would have learned more scheme beyond what is presented in that book (e.g. scheme macros). Last time I applied for a job the hiring manager read a sample of my code and immediately asked if I had been reading SICP. According to him, I got the job based on that code. TLDR: SICP is great for learning functional idoms and paradigms. You won't regret working through it.
SICP is a fantastic book and you should read it at some point. Lisp and scheme are different languages but are very similar in many respects. After reading SICP you will learn enough to actually write your own version of scheme, It will give you a fundamental understanding of how things work but it is not a practical guide. It all depends what you want to do. Do you want to understanding programming deeply or do you want to make programs that do things for you. I would read SICP because it's great, but then I'm in academia so I may be biased :) 
This may sound crazy, but [Lists and Lists](http://www.eblong.com/zarf/if.html#lists), a text adventure by Andrew Plotkin, is how I first learned Lisp, and I loved it. Itâ€™s probably best if youâ€™re completely unfamiliar with the language.
Just flipping read it already. Your concerns are pre-optimization.
Touretzsky's Gentle Introduction To Symbolic Computation is an easy read if you want to learn Common Lisp. SICP uses Scheme which is 'a Lisp' but not what is usually meant when people just say Lisp. It's not really a language tutorial, though. Mind you, everyone should read SICP at some point. You'll definitely learn to read some Lisp from it. I'd say go ahead.
Actually SICP fails to cover some essential aspects of Scheme, such as continuations [EDIT: and macros, and therefore says nothing about issues of hygiene]. It does cover interpretation and compilation of a Scheme-like language to an abstract machine, but not all of what it takes to implement a full Scheme.
The SICP lecture videos are amazing.
Actually, SICP, as an introduction to Lisp is less than a 5/10. Why? Despite it having you build a a Lisp REPL and then 'implement' it on a register machine in the last two chapters, it does not cover macro programming at all. Then again, that is not its purpose. Macro programming is one of the central features of lisp programming, and a book that doesn't cover it cannot be said to be a good introduction to lisp programming. SICP is a fantastic book, but not for its qualities as an intro to Lisp. In fact they say that they chose Lisp in the book because they can get it out of the way quickly since it has no syntax and move on to more interesting things very quickly. PCL, Successful Lisp or a Gentle Introduction to Symbolic Computing (Touretsky) are much better 'introductions', I have a personal preference for Successful Lisp. One really hasn't completed their intro to the language without having read Paul Graham's On Lisp, however. 
Good point. I forgot it didn't cover them. And you are right it doesn't cover parsing and a few other fiddly bits. But it taught me a lot about programming. I only knew C like languages before so reading SICP was an eye opener. 
Still not as awesome as [FORTH on the ATARI: Learning by using](http://www.amazon.com/gp/customer-media/product-gallery/0936200383/ref=cm_ciu_pdp_images_all)
I noticed that too while I browsed for a good Lisp book to learn from. I'm not that interested in that book :) Went with ANSI Common Lisp and Little Schemer.
&gt; Why is the quote even necessary in the first place? Lists could be just left unevaluated until they are fed to eval. That would optimize away one character for lists that contain data and make lists that contain code a lot longer. And how would you feed anything to eval if there is no way to evaluate a list starting with eval? &gt; The parentheses are supposed to "melt away" after some time, but they didn't for me during the several hours I mucked around. In fact I couldn't see anything but the endless parens when writing something :( That's a problem of the primitive environment this game provides. Like others already stated, it gets a lot better with decent editor support. &gt; And let, let* and letrec? Yes, all that would have been needed in this game is letrec, renamed to let. &gt; The ability to manipulate lists is good but having code as lists is really a compromise, imho. You could just as easily have "sane" syntax as a thin veneer on top of the actual AST, to which you could refer directly whenever you need to manipulate code at runtime, while still enjoying readable code for the other 99% of the time. It just makes macro programming a lot easier if there's no cognitive barrier between the AST and everyday syntax.
Book available at amazon.ca for $39.66
Yeah, last time I ordered a book from amazon.ca, they waited three weeks then canceled my order. In the mean time, they jacked up the price of the book to over what amazon.com was charging. My complaint went unanswered (citing a policy which was not on the .ca website); I contacted the BBB (waste of time -- Amazon's a prime sponsor) and Amazon finally offered me an amazon.com coupon that would have made the book slightly cheaper than other retailers (but more than the .ca price). Not impressed.
Lisp in small pieces?
The direct link to the PDF document: http://www.radonc.washington.edu/medinfo/prism/iccr13-dicom.pdf
Huh... I guess the additional text didn't get submitted. I recently had an MRI taken and had become curious about whether there was a visible Common Lisp option for viewing DICOM images. I remember finding [PRISM](http://www.radonc.washington.edu/medinfo/prism/) through Cliki.net surfing some years ago but I was happy to see it still active despite not personally having constant need for it. Sadly I couldn't find a date for this paper in less than 2 link levels.
The book is slated for release in October 2010, and the price will be $49.95. I'd be curious to see what you got if you bought the $443.61 copy though...
16th ICCR in 2010 &amp; 15th ICCR in 2007 This is for 13th ICCR, so 2000 or 2001.
What is the context? And why is it particularly interesting? The package system CL has now seems good, could probably use a better documentation, versioning, and an mandatory(if other packages used manually) :depends-on part would be neat. Any advantages in having nested namespaces? Seems like complexity for no good reason to me.
http://lambda-the-ultimate.org/node/3925#comment-59104 is the context in which I found this link.
Awesome; I always thought EuLisp &amp; ISLISP were under-appreciated. Now's time to go grab it :D 
What a cool idea!
&gt; Judging by the lack of enthusiasm for my drafts on comp.lang.lisp &gt; I was failing hard and became discouraged and never finished it. I've observed that comp.lang.lisp hosts a lot of competence, but very little enthusiasm for anything. In other words, it feels old. One goes to such a place to get wisdom, but for getting motivation it's probably the wrong place. (And so the question becomes: what is the *right* place then?). 
Your clients, when they say "It works better and was finished faster than I expected"?
This is true, but they are two different topics. There is an inner enthusiasm and a outer one, so to say. The outer one is the one involving third parties, that is clients, like you said. But having an esoteric platform (CL is one) is often a problem, because it is perceived as a mantenaibility risk (aka, they think they can always find a blub programmer anywhere in the middle of the night, should the need arise). I had problems with having *perl* accepted! In most cases, in the dreadful "real world", proposing CL has the same chances of having Brainfuck accepted (there aren't many ITAs around). I was depressed enough reading the ending of RG's story about JPL and Lisp. Yes, there is the old myth of lisp as a "secret weapon" as graham called it. But aren't weapons *too* secret destined to irrelevance? The other side, is the "inner" one, is the one I was referring to. I'm a recent newcomer in the CL world (about 4 years). I have the feeling that the community is now shrinking, the people are dropping out, getting old, etc. Just to give an example: some weeks ago I had the pleasure of exchanging some messages with a distinguished member of the community regarding what could go into a hypothetical new "advanced" lisp book (which I am not technically able to write, unfortunately). The thread ended with the realization that there is no one "(and motivated knowledgeable)" enough to write it anyway. This is the kind of gloom I was thinking about. 
If you think your future with Lisp will be dismal or bright, you're right.
the author perhaps? 
this is irrelevant
Could you write up a report or blog post about what that book might look like?
two months later? you're right, it is.
Groan.
I wrote some random thoughts on the matter [in this lisp reddit thread](http://www.reddit.com/r/lisp/comments/blx09/let_over_lambda_chapter_5_for_free/c0nn8do)
Sure, it's bad, but at least it's not another speech impediment joke.
Siri is demoed by Tom here: http://vimeo.com/5424527 I have no idea if Siri is using any Lisp (I doubt that), but the project CALO at SRI, which did DARPA sponsored research had some Lisp components or was based on SRI research that used Lisp (parsing, planning, ...). 'Siri' is kind of a commercial spinoff. 
Haha. That said, it's not as far as you might think - IIRC LOGO is, indeed, a Lisp. I know a guy who apparently wrote a PDP (8, I think) emulator in LOGO.
&gt; But having an esoteric platform (CL is one) is often a problem, because it is perceived as a mantenaibility risk (aka, they think they can always find a blub programmer anywhere in the middle of the night, should the need arise). I had problems with having perl accepted! It _is_ a maintainability risk. It is your job to demonstrate that you don't just want to try a new toy (as we all do) to management. If you cannot demonstrate this, why should they allow you continue with it? If you cannot show that (&gt; (+ development-time-decrease training-costs stability-increase licensing-fee-reduction) 0), then Lisp _isn't_ the right solution. That said, I find "modules", "systems" and "engines" are easier to sell than languages.
Not only is it a lisp, but the original system (Ghost) was written in (BBN?) Lisp. 
Very true. I am going to save this comment in a file!
I realize that this is a somewhat late response. &gt; How does one attain "lispness"? Read other people's code (start with the source of your favorite implementation, if it's available). Don't put space between closing parentheses. Indent like emacs would. Don't SETF parameters to your function unless you really need to. Don't bind variables with LET and then SETF them as the first thing in the body. Make your functions "look like" functions in the standard (take :START/:END keywords, take :TEST/:KEY keywords when appropriate, etc.) That'd be a decent start. &gt; Optimization. There is something in PAIP, but not much. The reason there's not much here is because, well, it's a big topic. It depends a lot on your implementation, too--what it likes to optimize and how it optimizes. For instance, in an not-compiling-to-machine-code implementation, it's (almost certainly) useless to declare types of variables. For compiled-to-machine-code implementations, it's crucial to getting good performance. And even then, depending on the sophistication of the implementation, different implementations get along better with different levels of declarations. &gt; In general, no suggestion is anywhere, AFAIK, on the best ways to structure large and complex software written in CL. I found this a real problem. Why do you find this a big problem? I'm honestly very curious, because this style of question is very common for people inquiring about Lisp. And as far as I can tell, it seems to be unique to people coming to Lisp versus other languages--nobody asks the same kind of question about Perl, nobody asks the same kind of question about Python, etc. etc. It's not like you're going to whip out 15k lines of code for your new Common Lisp app as the first thing you do. You'll likely write smaller programs before that and get a feel for what works first. And the answer is really "it depends on what you're trying to write." I think Alan Perlis once said that Pascal is for building imposing structures, Lisp is for building organisms. And like natural life, the structure for your large program is going to be different than mine. All that being said, [Joe Marshall's advice](http://groups.google.com/group/comp.lang.lisp/msg/d23a942023da202c) is not a bad place to start.
&gt; I always thought EuLisp &amp; ISLISP were under-appreciated. What about them, in particular?
That they were, um, *under-appreciated*. There's not much noise about either one, and I think that's undeserved, since they are both interesting in their own right. Also, unlike EuLisp, ISLISP is still undergoing *some* level of development; it was only three years ago that a new draft spec of ISLISP was released. Yet, few people have ever heard of it, and other than thxmoo, I've not heard of many large &amp; well-known projects written in it. T fits into this category as well, for me.
&gt;&gt; What about them, in particular? &gt; That they were, um, under-appreciated. What about them was appreciated to a lesser degree than their existence warranted? What about them warrants appreciation of the sort that would call for learning them and attempting non-trivial applications? What does they offer over the two well-accepted, standardized Lisps? I'm not trying to play word games or be a jerk. I'm interested. 
Let's look at the EuLisp Wikipedia page: &gt;Its primary characteristics is that it is a Lisp-1 (no separate function &gt;and variable namespaces), has a CLOS-style (Common Lisp Object &gt;System) generic-function type object-oriented system named TELOS &gt;(The EuLisp Object System) integrated from the ground up, has a &gt;built-in module system, and is defined in layers to promote the use of &gt;the Lisp on small, embedded hardware and educational machines. It &gt;supports continuations, though not as powerfully as Scheme. It has a &gt;simple light-weight process mechanism (threads). A frequently &gt;mentioned feature of EuLisp was that it allowed programmers to &gt;define their own error handlers. I don't know what your preferred lisp is, but these are pretty interesting from a Scheme perspective. Besides a "turtles all the way down" approach (i.e. "defined in layers to promote the use of Lisp on small, embedded machines and educational machines"). It has a decent amount of Scheme &amp; CL, enough so that it could have been a happy middle-ground, methinks, especially since it was meant to be minimal, but not as much so as the Scheme spec is. ISLISP is quite similar: it takes ideas from LeLisp, CL, Scheme &amp; EuLisp, and attempts to make a nice-fitting package (the spec is roughly 1/10 the size of the CL spec) that could be used in an industrial environment (which was part of the original purpose of ISLISP). They *both* feel like CL inspired languages, but are much simpler. I think they had interesting ideas (as did Dylan &amp; T), but were rarely used. EuLisp, for instance, Languished from ~1993 until this year. I'm pretty interested in ISLISP, as well as Scheme. So, **tl;dr**: they were both attempts *rectifying* the two major dialects of Lisp, with an industrial focus (ala CL) and without bloat/baggage (ala Scheme). As I said previously, other than thxmoo, I've not heard of much by the way of ISLISP usage, even though it's been under *somewhat* active specification development. Plus, there's at least OpenLisp (and Prime-Lisp now), which provides a relatively rich function set. Oh, and I never thought you were being a jerk. :D *edit*: are versus ownership; meh, what's the difference :D
[jrm's remarks](http://funcall.blogspot.com/2010/05/c-vs-lisp.html)
'I had to laugh'
That says it.
What was the problem he wanted to solve. The link is broken!
http://www.flownet.com/ron/papers/lisp-java/instructions.html
Iterators are so 1990's... http://www.boostcon.com/site-media/var/sphene/sphwiki/attachment/2009/05/08/iterators-must-go.pdf
[The original](http://antigreen.org/vadim/ProgLanguageComparison/lisp-cmp-with-cpp-java-etc/C++-vs-Lisp.html) from 2002.
Actually, that's a copy of the original, too, but it preserves the attribution. The original seems to be offline.
Interesting link. Unfortunately Lisp which has different functions for different containers is even worse than 1990 ...
Got as far as this: &gt; To do the same thing in Norvigâ€™s code took only one line: (format t "~a:~ { ~a}~%" num (reverse words)) This particular example showcases one of Lispâ€™s strengths: functional programming There's not an ounce of functional programming in that line of code. This is when I realized he didn't know what he was talking about. :-(
He was referring to REVERSE, which is a real, pure function (for any given argument it maps to one and only one result, and no side effects). Maybe not a whole ounce, but at least a few shreds of functional programming.
I got as far as this: &gt; But once Iâ€™d started programming in C++ on my job, Iâ€™ve never been seriously tempted to switch once I thoroughly investigated the alternatives. Before I stopped taking the article seriously.
Plus he compares C++ templates to Lisp macros ... now there might be an overlap in use cases, but good grief!
Thanks - I knew I had read that before. I'm confused - has this ebhakt guy stolen the article? And if so, why (I imagine there are more popular topics now)?
Can someone share a view about EuLisp? What was it intended to be? A replacement to Common Lisp? Is it good it died, or it had some promises?
"Using a function" /= "Functional Programming" It is utterly trivial to write the equivalent of reverse (not nreverse, *reverse*) in C++. Any moron programming language has functions.
Why downvote tanger? It's true, it sucks. The closest thing to generic iteration that Lisp has is `MAP`. And which looks better? (map nil (lambda (x) (foo x) ...) input-sequence) vs. (dolist (x input-list) (foo x) ...) And then there's not even a DOVECTOR, there's LOOP which complicates things in ways (sure it has vector iteration, but with different loop keywords), and there's no way to subclass SEQUENCE or define your own methods for sequence functions specializing on your own sequence classes. There is cl-containers, but it's really a mess.
Could they make the type a little smaller? I could almost read it at the beginning.
Not all lisps use different functions for different containers, e.g., clojure's functions, such as `map`, `reduce`, etc., all work against a sequence abstraction.
right, I actually meant CL which was used in the challenge
For that matter, for most of the CL functions that operate on sequences (including `MAP` and `REDUCE`), it will either accept any kind of `SEQUENCE`, or there will be a version that does. The matter at hand is syntactic sugar for iterating your own hunk of code over a sequence. (`MAP` with `LAMBDA` isn't the worst, but it's a little backwards-looking.)
Yeh that's kinda annoying but easily fixed. (defmacro doseq((element sequence) &amp;rest operator) `(map nil (lambda (,element) ,@operator) ,sequence)) But then this is the curse of common lisp, lots of cruft but it's so easy to work round that no one moves to a new language.
You'd want garbage collection to go with that. I know you can make do with smart pointers for the majority of cases, and gc does exist but it's not as easy as you make out.
TL;DR
On which implementations does this run?
right, I meant CL (which the article was talking about)
This is not about having functions (in the wider sense), this is about functions in the standard library being referentially transparent (i.e. functions in the narrower sense).
Currently it's running with SBCL on Linux. Theoretically it should run on any platform that supports CFFI 0.10 and bordeaux-threads (and that has GTK+ installed), but I'm pretty sure that turns out to be a short list.
&gt;Judging by the lack of enthusiasm for my drafts on comp.lang.lisp I was failing hard and became discouraged and never finished it. I found the presentation to be extraordinarily clear as I browsed it on the streetcar to work the other day, putting a lot of things that have confused me about CL package system in context. It was disappointing to find the article drop off near the end, but the effort was much appreciated by me at least.
ABCL has as good of threading support under Windows as the hosting JVMâ€¦
The video from 1989: http://www.youtube.com/watch?v=B2KXN-VUGXs
Closing parentheses on their own lines wtf?
This was a Dylan implementation written in Common Lisp (LispWorks) by Harlequin. It seems to support both Dylan syntaxes (i.e. also the Prefix Dylan).
A Dylan revival is long overdue (with no offense meant to the handful diehard Dylan hackers I know are out there carrying the torch).
I've been working on getting IDyl back up to snuff, and running atop a modern Scheme implementation. There is also [Goo](http://www.googoogaga.org/), and RScheme as well. There is fun all around to be had on reviving Dylan. I would love to have Dylan back, since then people wouldn't complain about the "terrible syntax", and we could go back to getting work done... &lt;/rant&gt;
I'm not sure I like the syntax, though. All those 'end' lines look worse than parens or C-family braces to my unaccustomed eyes. I never liked the naming convention for &lt;classes&gt;, either.
Many of the files in the implementation are in prefix Dylan. For example: [filter.dylan](http://www.opendylan.org/cgi-bin/viewvc.cgi/archive/stuff-from-fundev/old/Sources/emulator/modules/filter.dylan?revision=12645&amp;view=markup)
It's still closer to a C-style than normal Lisp, and 'end' is fashionable with Rubyists. I just want something closer to lisp, with Macros. D-Expressions give you something nice ([PDF](http://people.csail.mit.edu/jrb/Projects/dexprs.pdf)) and quite a bit saner than many of the DSL implementation techniques for Ruby &amp;al. I'll stick with my parens (particularly Scheme), but it wouldn't be bad for the ecosystem if there was a healthy Dylan system for modern programming. *edit*: added paren to PDF link, so that it's not simply floating mid-sentence :D
maybe adopting PLOT (http://users.rcn.com/david-moon/PLOT/) syntax to Dylan is worth of a try - including full procedural macros :)
This is amusing. Especially reading what a bunch of hacks BlueGene/P (and its kernel) really is.
You should see the plan9 discussion about running Plan9 atop BlueGene. I Don't think it's terribly surprising to see that this is somewhat of a mess considering that they selectively implement portions of Linux's syscall system...
Great presentation! Lots of useful insights and information. Stuart criticized using Hibernate with Clojure, but we seem to be doing fine using Hibernate's dynamic-map entity mode [1]. Lets you persist maps of maps, no classes. Nice fit for Clojure. True, we don't have extensive experience with it, and Hibernate declares this API as experimental. [1] http://docs.jboss.org/hibernate/stable/core/reference/en/html_single/#persistent-classes-dynamicmodels
&gt; Of course today the future of Lisp is Clojure. Uh... No. Unless it's meant to mean that Lisp has no future.
I see this sort of thing a lot, clojure is interesting but it isn't a patch on common lisp. Every time you discover something new in CL it opens a world of new options!
Interresting. Thanks for sharing the link :-).
&lt;rant&gt; As someone who has worked for **two** different scientific publishers, I can say that the only *good* thing to come out of SGML was [DSSSL](http://en.wikipedia.org/wiki/DSSSL), and, aside from a reprieve in certain Scheme systems that use DSSSL syntax, DSSSL is dead. SGML itself can be very odd (Hey, is this a singleton tag, or did the DTD simply define this as not requiring a closing tag?), odd syntax (I'm looking at you, Null End Tag) and historical baggage (yeah, :tag: ... :etag: from GML will work, given a concrete syntax for this in your DTD, and I've seen documents that use this). XML isn't great, and is terribly overused, but good lord is it simpler, which was the exact point: SGML is gigantic, can be difficult to parse, and requires a lot of information to be stored prior to parsing many documents. *From the Article*: &gt; SGML was in many ways smarter than necessary at the &gt; time it was a bright idea, it was evidence of too much intelligence &gt; applied to the problems it solved. Exactly; the "best practices for SGML" guides where I've worked have basically stated that SGML should look like what we would now consider XML (i.e. no omitting of end tags, no Null End Tag, no shortrefs, &amp;c &amp;c). From this, and talking to people much more knowledgeable than I wrt SGML, I think the "dumb" markup of XML is better suited to real-world use than the "smart" markup of SGML. &lt;/rant&gt;
I always thought the future of Lisps would include cool things like VLAD, R7RS, and CLtl3(000). Clojure is neat, and I use it for when I'm forced to work in java (it makes an interesting prototyping platform, and it has nice call syntax for Java), but I don't see it holding that much of a sway on the Lisp ecosystem, as a whole. It might inspire interesting dialecting of existing languages, and I may yet eat these words, but I doubt that in the future people will say "Lisp" and mean Clojure, as people do today with CL. 
Thanks for the acronyms, I'll have to look them up. The problem with Clojure is that it's limited to whatever JVM can provide, which is not very much (GC, parallelism). Arguably, we've had had peak Java, so tying the language to a platform entering a slow decline does not strike me as something particularly desirable.
Not bad article, but goes too much into emotional bits, and too little listing faults. I have gone from being rather annoyed with XML to 'ok just s-expressions i guess?' I think though that if you're looking very superficially at a language one might assume competence where if you look deeper you find bad practice/things to hate. For instance, was thinking of seeing if i can write lisp to a superset of Python. Thinking 'Python looks good, often i just use this form of macros and just flet, labels, let, defun, defvar, a basic superset might be a good idea!' But then i delve into it. For instance, [if statements](http://docs.python.org/tutorial/controlflow.html#if-statements), only toplevel, list stuff looks like it is all destructive. So it doesn't look like it will be a simple superset.. Since it can't be a superset anymore, the idea is now to make a different way to make a python-like way of using lisp. Though being able to read Python turning it into (decent)lisp(rather than binding) would be neat too.. We need to lower barriers between languages and all kinds of other stuff. ASDF is a similar example of stuff fucking up btw.(we're not immune) Making people extend it with methods on the project-side is a *horrible* idea, i don't think LOAD should've been used to read .asd files either. Asdf should have given an error whenever anything that isn't (defsystem ..) or its contents. And extensions should always be little libraries by themselves, that read arguments on the defsystem. I suggest. Well, there was a [whole long discussion](http://groups.google.com/group/comp.lang.lisp/browse_frm/thread/9451a52099ae25b6/4fc15114d6865348#4fc15114d6865348), i have written something similar to what i wrote there as an example, probably should be writing about it again... Edit: [I did](http://ojasper.nl/essays/Suggestion%20to%20improve%20ASDF.html#Suggestion%20to%20improve%20ASDF)
&gt; Thanks for the acronyms, I'll have to look them up. Oh, sorry about that. RnRS means "Revised^n Report [on] Scheme", and Common Lisp was originally defined in a book called ["Common Lisp the Language"](http://www.cliki.net/CLtL2), of which there are editions 1 &amp; 2 (although there is also ANSI CL). VLAD is a programming language, based on PreScheme from [Scheme48](http://s48.org). You can read some background on [this PDF](http://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1368&amp;context=ecetr). &gt; The problem with Clojure is that it's limited to whatever JVM can &gt; provide, which is not very much (GC, parallelism). Arguably, we've &gt; had had peak Java, so tying the language to a platform entering a &gt; slow decline does not strike me as something particularly desirable. Definitely. If the JVM was but one of **many** targets that Clojure supports, I could see it as being an interesting system for many uses, but the tie-in to the JVM is both a blessing and a curse: you get many Java libraries for free, at the expense of requiring Java libraries for many programs. I certainly *hope* that Clojure will be around for quite some time, because competition is good for a healthy ecosystem, but I'm not sure at this point if Clojure will, taking a long term view, will be more of a idea tank (ooh, STM on all data structures, I'll add that to something Termite-like &amp; make Scheme better) versus a long-term dialect.
More from the Man: http://en.wikiquote.org/wiki/Erik_Naggum Enjoy...
I can't help but notice that you used XML to form your comment...
&lt;apology/Well, it could be SGML, technically, but next time I'll note which one explicitly :D/
&gt; When the markup overhead exceeds 200%, when attributes values and element contents compete for the information, when the distance between 99% of the "tags" is /zero/, when the character set is Unicode, and when validation takes more time than processing ...granted &gt; not to mention the sorry fact that information longevity is more /threatened/ by XML than by any other data representation in the history of computing ... wait what? fact? there is a lot of emotional stuff like this that makes me not take these XML rants seriously. The one thing that I never see addressed, either, is name spaces. Has the ability to extend representations ever been more cleanly implemented in any other data interchange format? I agree XML is overkill for most things people use it for, but I've never seen a better solution for all the things that XMPP allows with its extensions. More /efficient/ means could be created, sure. But while maintaining some sort of human readability (eg. a text-based format)? (edit: changed last 'protocol' to 'format')
&lt;complaint level="moderate"&gt; It would have been nice if he had focused more on technology and less on politics. I don't mind political references in technical rants, but it sometimes felt like I was reading technical references in a political rant. &lt;/complaint&gt;
As a thought experiment, I've been working on a method to losslessly convert between XML and S-expressions. (html (xmlns . "http://www.w3.org/1999/xhtml") (lang . "en-US" ) (xml:lang . "en-US" ) (head (title "XHTML document")) (body (p "I wonder how " (em "this") " would work?"))) 
It's called [SXML](http://en.wikipedia.org/wiki/SXML)
Thanks.
CLtl3 was a nice idea but it looks [a bit dead](http://common-lisp.net/pipermail/cltl3-devel/) unfortunately.
Why not use existing [snippet collections](http://www.cliki.net/small-cl-src)? Not that there are many entries â€¦
Definitely, that's why I had the 3000 there, as a joke, since we'll probably get the next CLtl in another thousand or so years :D
I didn't know about it? 
Slime (the Emacs mode for Lisp) does this quite well.
Stop using that notepad and fire up a good editor :-p
Slime only works for evaluated symbols, so the example above using "square" does not work.
I think you mean "interned symbols". I use M-/ for other stuff.
Now you made me lose money, and Amazon win some.
Yes, interned. Thank you - I have updated the text of my original post. Do you know of a way to avoid the need for differing keyboard shortcuts which depend on the location of the symbol?
Just press M-/. It's dynamic-abbrev and completes whatever has been typed in any other Emacs buffer it can see (though it's smart enough to look for the closest context first). Together with the SLIME completion, it covers 99% of completion needs you could ever have.
It's not often that I have to complete yet-to-be-interned symbols. The reason is that I usually write code, evaluate it, write more code, evaluate that, etc.
I saw your post on the Slime mailing list. Basically, your mental model is completely wrong. You build up an image by incrementally compiling definitions. A standard workflow is: * (defun square...) `C-c C-c` * (asdf:oos 'asdf:load-op :hunchentoot) `C-c C-e` Also, if you're just wanting to load systems, then from the Slime REPL you can press comma &lt;,&gt; which allows you to enter Slime commands. `load-system` is the one you want and will autocomplete from the list of systems found through `ASDF:*CENTRAL-REGISTRY*`.
Thanks for your help.
&gt; Do you know of a way to avoid the need for differing keyboard shortcuts which depend on the location of the symbol? Write some elisp? 
Thanks for your suggestion. I'm trying to avoid learning another programming language to make it easier for me to learn Common Lisp.
&gt; I'm trying to avoid learning another programming language to make it easier for me to learn Common Lisp. That doesn't really follow. The more languages you know, the easier it is to learn another. Especially where they are both LISPs. Elisp and emacs are worth learning if you're the type that finds having two ways to complete different types of things a burden to productivity. 
&gt; &gt; I'm trying to avoid learning another programming language to make it easier for me to learn Common Lisp. &gt; That doesn't really follow. Reread. I said "*I'm trying to avoid*..." &gt; The more languages you know, the easier it is to learn another. Especially where they are both LISPs. Sure. But there are diminishing returns. I already know a LISP (Scheme) and several other programming languages. &gt; Elisp and emacs are worth learning if you're the type that finds having two ways to complete different types of things a burden to productivity. I asked a reasonable question, given the state-of-the-art in programming environments. Or perhaps the state-of-the-art over a decade ago: a user posted then deleted their comment that all one needs to do is press the COMPLETE key on one's Lisp machine. &gt; ...if you're the type that finds having two ways to complete different types of things a burden to productivity. Replace two with - say - five. Would my request then be more palatable? What if there were only 4 different ways? At what point do I stop being a member of this "type" and start being reasonable? EDIT: Expand comment.
&gt; Reread. I said "I'm trying to avoid..." Ah, my mistake. Regardless, if you're not willing to learn how to configure your programming environment, perhaps you shouldn't complain that the default configuration is not to your liking. &gt; I asked a reasonable question, given the state-of-the-art in programming environments. And there is a reasonable answer: If you are not completing lisp code but rather text, use a textual completion. If, OTOH, you are completing code, use code completion. Lisp code is made of of conses and symbols, files are bags of bits. The distinction matters to some. Since 99% of the time the symbol i want to complete has already been interned (because i tend to compile and load my functions as i write them, as i suspect most lispers do), then slime completion is enough. Every once in a while M-/ is what i actually want, usually when i'm writing a new function that introduces a local symbol that has not yet been interned. It's a habit of mine that when M-Tab fails, M-/ follows. Since this works reasonably well, and i actually like making the distinction between symbols that exist and those that don't, i find this to be an excellent solution, superior to the alternative single key approach... it has saved me a typo or two in its time. &gt;Replace two with - say - five. Would my request then be more palatable? What if there were only 4 different ways? At what point do I stop being a member of this "type" and start being reasonable? You want to expand symbols and text as if they were the same thing. They are not. If you really want everything to expand using just one key, you can use something like http://www.emacswiki.org/emacs/HippieExpand... but since you don't want to learn to configure your environment, it may not be of much help. I've heard the lispworks IDE is excellent.
&gt; And there is a reasonable answer: If you are not completing lisp code but rather text, use a textual completion. If, OTOH, you are completing code, use code completion. Makes sense. &gt; Since this works reasonably well, and i actually like making the distinction between symbols that exist and those that don't, i find this to be an excellent solution, superior to the alternative single key approach. Fair enough. Thanks for your response.
I've edited my response to reply to your edit... a difficult way to have a conversation! :)
Indeed. Sorry about that - I tend to never be satisfied with my comments on the first (or fifth) try.
I suppose we're not expecting each other to reply so fast :) Get off reddit and get back to work! :)
&gt; but since you don't want to learn to configure your environment, it may not be of much help. I'm getting tired of the snark. Learning enough of elisp to customize one's .emacs, install some addons, configure them, etc. is entirely different than *learning elisp from scratch to perform some task I have absolutely no idea how to even begin to perform*. I suspect you know this. And you may even know that I've already installed Slime, based on my demonstrated knowledge of Slime completion elsewhere in this post. It's clear we come from entirely different perspectives on how development tools should be. Perhaps you could consider this for a moment and stop being so condescending. EDIT: P.S. Your "text-completion" vs. "code-completion" advice was illuminating. I'll try to intern that.
&gt; I'm getting tired of the snark. Sensitive much? do i need to put a silly smiley near everything that may be considered an affront to your sensibilities in order to have a discussion? :P &gt; learning elisp from scratch to perform some task I have absolutely no idea how to even begin to perform. Have i suggested that? A quick look though the emacs wiki searching for 'tab completion' leads to many solutions, and i even gave you one. http://www.emacswiki.org/emacs/HippieExpand &gt; I suspect you know this. Of course i do, which is why i suggested some elisp might help, and why i mention elisp and emacs as being good tools to learn if this is a problem for you... you can fix any minor annoyance and many major ones with a little elisp and a drive to do such things. It is required that one learn a little about emacs and elisp in order to configure your environment. If you're not willing to do that, then none of my advice will be of any help to you. Since you've installed slime, you must have done some of this already. You going on about lisp machines and your claim that you are being reasonable in not wanting to learn elisp made me assume you had already rejected the idea of configuring your environment using elisp. &gt; It's clear we come from entirely different perspectives on how development tools should be. Perhaps you could consider this for a moment and stop being so condescending. It is only from your perspective that condescension has become an intent of mine. Similarly, it is your perspective that is giving you troubles when you expect very different develop environments to work in similar ways. You're likely coming to common lisp because you are looking for a better way to do things. Now that you're starting to explore, the way things are done are very different from what you are used to, and i suspect that makes you uncomfortable. My suggestion is only that you stop expecting things to conform to your perspective on how development tools should be, and rather embrace the differences, because it's in the differences that you'll find the better way to do things that you are (presumably) searching for. If you're not the type who wants to customize your environment, but rather wants something similar to other mainstream and commercial offerings out of the box, lispworks and allegro have IDEs that may conform more to your expectations. Does that need a smiley? i don't know... it probably does now ;) 
&gt; Sensitive much? do i need to put a silly smiley near everything that may be considered an affront to your sensibilities in order to have a discussion? :P Please do. I'll forward you my niece's text messages for reference. (I kid.) &gt; A quick look though the emacs wiki searching for 'tab completion' leads to many solutions, and i even gave you one. http://www.emacswiki.org/emacs/HippieExpand Fair enough. I had seen HippieExpand before (and remembered incorrectly that it wasn't what I was looking for) so I dismissed your recommendation out of hand. On further examination, that link has a "make-hippie-expand-function" example which is probably exactly what I need. &gt; Does that need a smiley? i don't know... it probably does now ;) :)
If I was a manager, I would have strongly favored an implementation using a language that people are more likely to be fluent in, like C. I wonder how CL won out.
By pure technical superiority?
In [an interview with computerworld](http://www.computerworld.com.au/article/255293/a-z_programming_languages_javascript/), Brendan Eich stated that his original goal was to have Scheme as the embedded language. He goes into the reasons why not in the linked blogpost, but just think what could have been...*sigh*
Yes
Bias and ego do not make good engineering. They are both turing complete and so it's just a matter of preferred expressiveness. Given the market of 1996, c/c++ was the php of the day; I would see continuity issues (if something unfortunate happened to the core developer) along with other things ... it's not like compiler and interpreters hadn't been in C prior to that ... most of them were, was at the time, and still are today. If I'm not mistaken, the reddit code writing team went through a painful process of having a few good lisp developers, but simply could not find enough early on. Then they switched to a more common language, python.
GCC MELT is not much related to Lisp compilers. It is a domain specific language to code GCC extensions in. GCC extensions could add some application- or domain- or project- or company- specific features to the GCC compiler (e.g. specific optimizations or specific diagnostics). For example, you can easily code in MELT an extension of the GCC compiler which tranform each call like fprintf(stdout, ...) to printf(...). You could also code an extension, related to the GTK toolkit API, which checks that functions from the GTK toolkit are correctly typed (for people familiar with GTK API: imagine checking the type of each call to g_object_set). GCC MELT is related to Lisp mostly by the syntax of the MELT domain specific language used to code your GCC extensions.
Harlequin/Fun-O's DUIM implementation is some of the most beautiful code I've ever read.
WHY WON'T IT DIE??/
Why all the downvotes? Do I need to put on some k3wl trendy shades and have a long board and say the same thing interjected with "woah" and "dude" everywhere? The only thing more trendy and emotionally driven then womens fashion is you dittoheads on computer programming.
Bias and ego do not make good engineering. For a developer who is fluent, CL is a much more efficient language to prototype in than C/C++, as has been cited time and time again. Same could be said of Python, Ruby, Scala, etc. over C/C++. See http://norvig.com/java-lisp.html for an example. The downside for a production environment is, of course, that you can't hire an army of mediocre CL programmers to maintain it. You can hire an army of mediocre C programmers to maintain something though.
As has been my experience. Whenever I have permitted someone to use a "language of their choice" and the language turns out to be one that is not commonly taught at universities and is not widely known, like objective caml for instance; things eventually turn over and I have to either expand or reassign the project for numerous reasons. I sometimes here the argument, "but it's just syntax ... shouldn't take more then a weekend to learn" - and although true, becoming highly skilled and productive in a language can take years and if you get say 100 quality programmers in a room and asked them in 1996 what languages they code in the most and are the most fluent in, I don't think CL would crop up with any statistical significance. It just seems to be managerially risky.
Bias and ego don't make for good engineering, but neither do people who insist on bandwagon arguments to justify their choice in an unsafe, low-level language. Don't call "picking a language that's easy for the masses to program in, in order to make my job of hiring easier" good engineering. That solves just one problem, namely that of finding people to work on a project, at the cost of creating new ones (like, "some newbie programmer set an array to be a static size and arranged his variables the wrong way in memory, so that someone who passed a 600 character string to his program overwrote the integer functioning as a 'boolean' value and ruined the entire application"). If you'll excuse me now, I'm going to go build a bridge with wood glue and sticks. 'cause, ya know, everyone knows what to do with wood glue and sticks. &gt;They are both turing complete and so it's just a matter of preferred expressiveness. Nah, really? A screwdriver and a chainsaw can take down a tree, it's just a matter of how long you want to stand there stabbing a fucking tree.
&gt;The only thing more trendy and emotionally driven then womens fashion is you dittoheads on computer programming. Allow me to give you some insight then - I downvoted you because it's apparent you have no idea what you're rambling about, and then sound like a whiny douche when someone has the gall to downvote you on a fucking social media site. Please take your faux wisdom and shove it up your ass, sideways.
I think it's fine. I have no problem with it. It's just that except for the world of trendy web 2.0 startups, I've found the entire industry to be fairly conservative when it comes to choosing a technology. I'm currently dealing with a firm that refuses to move away from ColdFusion and Oracle to a new technology. I dealt with a large firm two years ago that still had NetWare running. I have friends that are gainfully employed writing and maintaining Cobol code for banks. I have friends that are professional Fortran programmers. I had a contract gig last year to phase out an OpenVMS solution that ran on AlphaStations. People are talking about moving from Git to Mercurial but I still see CVS massively deployed. [There is a reason that copies of Visual Studio 6 still go for over $300 on ebay](http://cgi.ebay.com/Microsoft-Visual-Studio-6-0-Professional-Edition-NEW-/290436204594?cmd=ViewItem&amp;pt=LH_DefaultDomain_0&amp;hash=item439f58c832) and it's NOT because it's a collectors item. I sold an HP B2600 workstation running HP-UX last year for $2500. I've sold a number of AlphaStations from the mid 90's for $1200 a pop. [2GB 50 pin SCSI hard drives can still go for $70](http://cgi.ebay.com/Seagate-2GB-50-Pin-SCSI-Hard-Drive-ST32272N-/370375274278?cmd=ViewItem&amp;pt=LH_DefaultDomain_0&amp;hash=item563c162f26). Again, it's because people have a business need. So yes, this surprised me.
*Fuck* managerially.
Many companies have high turnovers so you need to make sure you push shit out the door. I look for a solid foundation wherever I can so I can meet the timetables. How is that wrong?
&gt; How is that wrong? Well, it's not incorrect if: * you're the manager * you work in some massive megacorp * you only care about the deadlines, costs, and your promotion * you expect massive turnover * you're writing well-specified software that dosen't involve any domain research * you aren't concerned about code quality or craftmanship. In that case, sure, do it in Java or even Visual Basic. Coders will be easy to hire, and the platform is well supported. There's a wide range of libraries for common tasks. It makes business sense in a way that choosing any lisp or OCaml or Haskell wouldn't. In fact, outsource the job to India. Yeah, *fuck everything about that*.
Ok, first, this is a reality I don't enjoy either. And second, I wish I could be responsible and faithfully argue against it. I'm mainly an entrepreneur these days and pay people *from my bank account* - which is certainly finite. Time and cost are real constraints. Things need to get done now. Also, holding on to good people is one of the most challenging things and the industry in replete with fantastic ideas and innovative projects that never get put into production. You can get a lot of people that commit to a project and have a *true desire* to work on it, but never end up writing any code. When I allow people to pile the expectations and aspirations high, they routinely are far less likely to come through with anything. So I try to make it look boring and simple, because then it gets done. If you can suggest a different way of running the show wherein I can make sure that quality, features, usability, testing and documentation is all reached to completion within the time and budget allocated, then please, I'm all ears. I would love there to be another way to do it where I am not the bad guy. edit: I guess the main question I would have if I was presented with the CL question is thus: "Is this person a lisp programmer first and foremost or are they really an imperative programmer who dabbled in functional programming in college and has heard that CL would be a good way of implementing the tasks at hand." If the first is the case, then please, be my guest. If the second is the case, then I smell disaster coming. Especially in terms of 1996 when all you had was barnes and noble, irc, and newsgroups to call for help.
CLtL3 always scared me slightly. Steele's book is as much a cultural artifact as a reference. I worried that much of the charm would vanish in editing. For instance, CLHS doesn't have the tagbody dining philosophers schtick and, though an excellent reference, is much the worse for it. 
As I understand it, despite the name CLTL3 was not really about updating Steele's book. More like updating the ANSI CL standard in general. See for example this [proposed charter](http://common-lisp.net/pipermail/cltl3-devel/2009-August/000017.html).
Sounds like fun. I hope to go.
saw this on comp.lang.logo. This, combined with OOPSLA should be pretty interesting indeed. If only I had money of some kind... :D
If you're employed, it can't hurt to ask your employer. A conference where you interact with good programmers and good ideas shouldn't be _too_ hard to try to sell.
I'm self employed currently, and while I'm making good money compared to the amount of time I spend, I don't have enough to fly to Reno. That's a good tip for my next long-term contract though.
Because you're using an argument from popularity. By the same argument we should be using the bible to see what it has to tell about subatomic particles, because more people know the bible than the physics involved. And because you're advocating instant gratification, being popularity from all those shits that can't learn new languages; over structural improvement, being looking at languages as what they are by themselves. &gt; Why all the downvotes? Do I need to put on some k3wl trendy shades and have a long board and say the same thing interjected with "woah" and "dude" everywhere? Are you serious? Do you see any of those here upmodded?
&gt; There is a reason that copies of Visual Studio 6 still go for over $300 on ebay and it's NOT because it's a collectors item. Let me guess, it is because M$ crapped up compatibility, and the libs are just a fucking messy shit that it is completely impossible to change into the new version.. My father is trying to do something with that stuff regardless of me telling him to use linux, showing him how to do it with it, and him apparently having little reason to use this stuff. I don't get it. Edit: I guess if you're a bank, you want to play safe. But i can't help but think maybe some of them conservative because they're *unable* to change things, tied down by stuff.
With some luck you can win the necessary money in Reno.
If you don't mind, which region do you live in? For example, would you be able to attend a conference in Japan or Europe? FYI, the best way to get free attendance is to be an invited speaker. ;)
Dunno; betting against the house in order to win money to attend a conference doesn't sound like a great long-term investment strategy. :D
Nope, none of those are closer; I would certainly go if I had the capital. Definitely, and I do have some lisp-related research that I would be interested in discussing, but it's not ready yet, and I'd like to finish it before I go (although I use it every day :|).
reports on real-world use is also appropriate
That was actually going to be my tact; the only really "novel" feature that I've added is the ability to "reason" about the keys themselves in dictionaries (which are backed by tries). Most everything else I'm doing has been done before, possibly not in one place, but certainly been done before I've looked at it. 
I'm just getting downvoted vindictively at this point, regardless of what I say. I've written my own plugins for emacs and have written CL for many years. Ok, now I'm not the enemy, ok? I've also burned through tens of thousands of my own monies with people that didn't produce any results because of the same "progress" argument you use above. For God Sakes, I had to sell off my MacIvory on ebay because of the same broken logic. As far as I'm concernd, It doesn't produce results. Ok go on, click the down arrow, I don't give a shit any more.
Its an older version.
Yes, Clozure CL works fine ... under 64 bit ... which may be the future, but not the present. But ok, under 32 bit it gets better.
Amazing how many nonsense one post can contain. You are obviously an arrogant nerd that never actually wanted to write software for any other person than yourself. Its not that Linux is good or in any way better than Windows, except that it is under a free license and has worse graphic drivers. But not any application's main part is on the server-side. And some people may want to distribute their software - even without commercial interests that makes an ACL or LW-License worthwile - to people to make them use it, even though they dont belong to some nerdy linux-religion.
I wouldnt call clisp a reasonable implementation - its good for a few small things, but more like a script-engine. cmucl - you must be kidding! lispworks is expensive. And ecl ... well, still too slow for many things, and even though it uses a C/C++-Backend, it constantly has problems on several platforms. And for sbcl, the development for Windows seems to be stuck.
We'll have to differ on the meaning of "reasonable" and "relevant", then.
I'm curious what it might cost, excluding airfare, to attend a conference in Japan (hotel, food, etc), but I suppose it depends very much on the specifics of the conference (when and where).
Everybody agrees Japan would be more expensive. Nobody is forthcoming with numbers. Airfare from Paris to Reno or Kyoto is roughly the same. Hotels and food are generally more expensive in Kyoto than Reno. As for the conference fees, nobody has provided many details (nor were they requested), but there do not appear to be any classic cheap sites (e.g. universities). Many IEEE conferences have been held in ICCKyoto. You might check whether those years are consistently more expensive; but I didn't see enough data to say anything conclusive. The location suggested for an ILC in Kyoto sounded (relatively) cheap and small (i.e. max 100 attendees). As for timing, everyone seems to agree that spring and fall in Kyoto are nice; but you do not want to be in the hot summer or cold winter. 
Great info. I prefer the [other style of formatting](http://article.gmane.org/gmane.lisp.lispworks.general/10327) though.
Me too. Next time...
*"I did quite a bit of engineering work on parallelism (in Lisp) back in 1987+ and reached the same conclusion. However, there is a lot more to successful multi-core parallelism than just minimizing shared memory - or, especially, just adding thousands of more cores and hoping, like Intel/MicroSoft, that things will somehow work out."*
I always imagined Spocks brain running Lisp
This is dated when? Linda seems soo old-fashioned; first time I read about it in years, really. Not that I mind; it seems general and powerful enough fi you can avoid the hotspots ...
An interesting response from Brian Harvey (of UCBLogo fame) to Bob Tinker; I think the arguments are similar to what I've used for "why (should we | do you) use lisp?"
&gt; Brian Harvey (of UCBLogo fame) Also of Berkeley CS61A fame (i.e. the equivalent of MIT 6.001 when it still used Scheme.)
Ah, nice catch, thanks! :D
What a great paper! Logo is greatly underappreciated in programming language circles. It inherited a substantial strain of Lisp's DNA.
My thoughts exactly. Harvey gives a decent rebuttal to arguments that you often run into with Lisp in general, and certainly makes an interesting case for Logo. The one issue I have with logo is that it's quite a bit more painful to parse than lisp is (for obvious reasons :D).
&gt; The one issue I have with logo is that it's quite a bit more painful to parse than lisp is (for obvious reasons :D). The advantage is that it leverages children's preexisting intuition for English syntax but without going overboard and taking the idea too seriously like COBOL did.
Anybody know where to find Tinker's article? I get a rather retarded image of him from this, I'd like to read the original.
This is definitely a plus, especially from a pedagogical perspective; exactly what was the point of "computer literacy" in Harvey's piece (Logo as a means of experimenting with the math that people are already familiar with). The one thing I dislike is that I find the lack of homoiconicity awkward at times. I'm playing with an extended logo dialect that has L-Expressions, similar to D-Expressions in Dylan or S-Expressions in lisp, that keeps it simple for children, but has no ceiling for adults. Fun all around really.
I don't think it was "retarded" per se, just attempting to say that Tinker comes at Logo with a BASIC perspective, which is ill suited to understanding some of Logo's finer points. It's just like when people first come to Lisp or Scheme &amp; write what they've been writing in other languages. Also, from [this](http://iae-pedia.org/Robert_Tinker) page, I don't think he *necessarily* disagreed with Logo's constructivist roots, simply that he didn't see Logo performing terribly well on machines of the day. Basically, I think he was *misinformed* rather than *retarded*.
In addition to all but hunchentoot: Nearly every package I create imports [alexandria](http://common-lisp.net/project/alexandria/). Basically things that make my code clearer that I previously ended up replicating in every new project. Eventually, I'd really like to see implementations distribute this like ASDF. I cannot recommend it enough. A few utilities and macros I regularly use from it are: CURRY, STARTS/ENDS-WITH-SUBSEQ, WHEN-LET, ONCE-ONLY, RANDOM-ELT, SHUFFLE, SYMBOLICATE, MAKE-KEYWORD, EMPTYP (I thought this was part of the spec until today), and WITH-UNIQUE-NAMES. And if you're building complex macros, then PARSE-BODY and PARSE-ORDINARY-LAMBDA-LIST are absolutely brilliant. Also, [metabang-bind](http://common-lisp.net/project/metabang-bind/) for more advanced bindings, and [postmodern](http://marijn.haverbeke.nl/postmodern/) for all my database access.
 Open Genera 2.0 Genera 8.5 Documentation Database 440.12 LMFS 442.1 Development MacIvory Support 447.0 CLIM 72.0 Genera CLIM 72.0 CLX CLIM 72.0 PostScript CLIM 72.0 CLIM Demo 72.0 CLIM Documentation 72.0 Statice Runtime 466.1 Statice 466.0 Statice Browser 466.0 Statice Server 466.2 HTTP Server 70.190 Showable Procedures 36.3 Binary Tree 34.0 W3 Presentation System 8.1 HTTP Client 51.8 HTTP Client Substrate 4.23 W4 Constraint-Guide Web Walker 45.13 Lambda Information Retrieval System 22.5 Symbolics Concordia 444.0 Metering 444.0 Hacks 440.0 Development Conversion Tools 436.0 Joshua 237.3 Joshua Metering 206.0 Jericho 237.0 Experimental Km 2.0 Genera program 9.0 
[maxima](http://maxima.sf.net)
wow you really use Open Genera and stuff? Do you use it on a lisp machine or do you use the emulation on x86-64 or alpha? Do you do real work with it? 
Open Genera is the 'Virtual Lisp Machine'. I use a version for Max OS X. Together with a real hardware Lisp Machine... I use it to try out new or old software - it is just more fun. As you can see above, I have loaded [KM](http://userweb.cs.utexas.edu/~mfkb/km/) into it.
I have not written nearly enough to have used anything very often. However, these dependencies were critical to my most recent project's success: cffi, cl-fad, local-time, cl-syslog, py-configparser and py-configvalidator. I foresee using them again.
What does that output mean, and is this from a production environment?
These are the names of the systems loaded (excluding the systems that belong to the OS itself) and their version numbers. That's a development environment.
[CLSQL](http://clsql.b9.com/) is also used (not on a Lispm).
Ah, should have been obvious that they were version numbers. I have no idea why, but I thought it might have been some sort of introspection mechanism calculating their use across the image. Need more coffee, I suppose. I will definitely have to give Open Genera another spin. I remember not having much success last time.
I still like having hard copies of my code, and to make it look pretty, I use [colorize](http://www.cliki.net/colorize).
Thanks, a year or so ago I was looking at lisppaste and trying to yank the highlighting out of it. I gave up. Wish I had known about this. 
OS X version? Sounds tantalizing...
The VLM is a product for DEC Alpha / Tru64 Unix. There are experimental VLM versions for Linux/x64 and, newer, Mac OS X (x64).
this series sounds exciting. i've been using emacs as my go-to editor for the past year and looking at clojure+slime/emacs as a development platform. good swank/slime tutorials are hard to come by, though. thanks!
I would hope that one does not reload a buffer file all the time for compiling changes. Usually it is better to compile/debug individual expressions. The Lisp system should be able to find the source - no need for line numbers and manual navigation. I'm not sure how it works in Clojure, but in Common Lisp it would be strange to think in line numbers.
Most have already been mention except for [CFFI](http://common-lisp.net/project/cffi/) which is near the top of my list.
cxml, yaclml, ucw's web server interface, rucksack, lisp-on-lines, relational-objects-for-lisp, and cl-for-the-web. 
Anyone else just really relieved that this isn't at all related to that "Brian's Brain" nonsense from a few months back?
hunchentoot and its dependencies, cl-who, parenscript, ht-ajax, cl-json, parse-number. Been meaning to figure out webblocks
Ho-ly jesus I don't think I'll be getting that GTX 295 this month.
You're ruining it. People like me have no business reading that subreddit, much less *contributing* to it. This is terrible. I shall await /r/(True)^2Reddit.
&gt; We can't bring back the engine Actually, I suppose we could. It is probably Common Lisp code running on some fairly standard hardware.
Well, initially, I created /r/TrueReddit with exactly that joke in mind, to silence the "Digg is killing Reddit" crowd, but I like how it has developed. To leave the presumptuousness behind, I tend to refer to it as /r/TR, but [it's impossible to make everybody happy](http://www.reddit.com/r/plt/comments/c8ruq/rtr_the_subreddit_that_tries_to_bring_back_the/c0qxhxl). ([you will like this picture](http://www.reddit.com/r/circlejerk/comments/c57z8/guys_weve_been_outdone_i_guess_we_should_just/c0q6s4g))