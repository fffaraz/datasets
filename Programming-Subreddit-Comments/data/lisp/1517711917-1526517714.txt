Thanks a lot, your youtube videos are interesting.
&gt; crypto-currency where everyone assumes double-precision Just in case: if everyone now uses floats to count money, then said everyone is doomed. Count money with integers only. (Rationals if you really insist—like if you're in need to dividing 2 units between 3 agents.)
You can have a decent development experience using a vanilla text editor and a repl. I did it for a while using scheme (and a readline-enabled repl). This works well for most smaller scripts, but won't give you the best lisp experience. What I like in Emacs is how simple and fast it is to just evaluate a function definition. I mostly use guile, and some macro-heavy projects might take some time to compile. Then it is much faster to just change one definition and evaluate it directly than doing the usual script workflow of re-running the whole script.
I have a weekly gamedev stream where you can watch me code in Lisp called [Treehouse](https://www.youtube.com/playlist?list=PLkDl6Irujx9MtJPRRP5KBH40SGCenztPW). As for getting started, there's [Portacle](https://portacle.github.io) which should provide you a ready-to-use package. It uses Emacs and Slime, but aside from some different shortcuts for cutting, pasting, and undoing you shouldn't have much trouble, really. Portacle includes a keybinding reference that you can refer to when you get lost, too. You can obviously just use a terminal and a text editor, but that is such a severely deprived experience that I honestly can't recommend it. If you get over the initial fear of learning a new editor and just commit a week to Emacs you should be able to get yourself settled in and productive enough to hack away to your heart's content.
You can get by with an editor that is minimally lisp-aware - parentheses matching is vital. Many people don’t know that vim has had Lisp support since the dawn of time - back when it was vi the command :se lisp turned paren-matching on and made auto-indenting slightly more Lisp-aware. You can just use two windows - one for your Lisp REPL, one for your editor, and just copy-paste edited forms between them. You can get a decent start this way without the hump of mastering emacs.
Go with Emacs and SLIME. [Here](https://pastebin.com/H7KBM7Wv) a simple but sufficient Emacs configuration file which will install and configure all needed packages to get you started. The reason why I think you should use Emacs is, because it uses Lisp itself as configuration language. Most Emacs tutorials are overwhelming, so I try my best to give you a quick start. Emacs key bindings are written differently, but once you know the notion, its easy. M stands for "meta", the `Alt` key and C stands for "control", the `Ctrl` key. `M-x` means press Alt and x together. `C-x b` means press Ctrl and x together, followed by b. Cursor movement is done with: C-f ; move forward C-b ; move backward C-p ; move up C-n ; move down Type `C-x C-c` to quit Emacs. A file can be open with `C-x C-f` and closed with `C-x k [enter]`. Sometimes help windows pop-up, navigate with `C-x o` to them and close them by pressing `q` or with `C-x 0` (zero). For getting help there are a lot of different functions, it took me some while to discover them, but they are very helpful. Move with the cursor above a function and press `C-h f` to get a detailed function description. There is a similar function to get the description of a variable `C-h v`, can you see the structure? `C-h` for help, plus an addition for what kind of help. Some very basic lisp, which is used to configure Emacs: (setf inhibit-startup-message t) ; setf, a function which sets a variable to a value ; inhibit-startup-message is the variable to be changed ; t stands for true Generally speaking Emacs has a lot of structure, once you understand it, it's not difficult to know where to look for something. Ah, and learning the most powerful text-editor in the world can never hurt ;-)
sublime text, with parinfer and sublimerepl. Or vim --lisp and tmux with sbcl repl.
You can try Racket for Scheme. For Common Lisp there is Lispworks Personal, which is free with limitations, and Clozure CL for OSX which comes with editor and repl.
Yeah I get you. I have a hard time keeping code streams in the back as well, but focusing on them fully is also a bit too boring often, so it's a difficult thing to watch.
Hello, the Common Lisp Cookbook on github is your friend :) https://lispcookbook.github.io/cl-cookbook/editor-support.html Available editors are: - Emacs, and Portacle mentioned below - Vim - Atom with [Atom-Slime](https://atom.io/packages/atom-slime) (still lacking important features like "compile this file") - Sublime (quite basic with the sublime-repl) - [Lem](https://github.com/cxxxr/lem) - a Common Lisp Common Lisp editor, ready to use ! An ncurses and an Electron interface. It's ready to use, its keybindings ressembles Emacs though (C-x C-f to open a file, alt-x slime to launch Slime, C-c C-c to compile a function etc) - [cl-repl](https://github.com/koji-kojiro/cl-repl) is a newish ipython-like CL repl. Very nice, its interactive debugger isn't complete yet though. - you'll also find links to notebooks A Slime video tutorial on the link too (and check the author's channel). I also enjoyed [this one](https://www.youtube.com/watch?v=bl8jQ2wRh6k), the guy develops a Slack-like app in CL and ClojureScript. &gt; I do want the ability to compile executables https://lispcookbook.github.io/cl-cookbook/scripting.html#building-a-self-contained-executable ps: https://github.com/CodyReichert/awesome-cl 
Video linked by /u/dzecniv: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Web Development in Emacs, Common Lisp and Clojurescript - Emacs SG](https://youtube.com/watch?v=bl8jQ2wRh6k)|Engineers.SG|2016-11-01|1:18:42|59+ (96%)|5,189 &gt; Speaker: Elias Mårtenson Emacs packages: SLIME, Paredit,... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/dzecniv ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dtrh3fm\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
&gt;I want to learn lisp, but it seems like I have to learn SLIME and emacs in order to get started. &gt;is there any reasonable alternative? Yes, there are alternatives, but if you install Portacle, you will instantaneously have SBCL, Slime, and Emacs all ready to go, and it's a really good environment once you get past the initial weird feeling of using Emacs for the first time. &gt;can I use a vanilla text editor and a command line repl? Better don't do it. You will be losing time counting parentheses etc. A good Lisp editor (like Emacs) not only allows you to easily work with lisp S-expressions; it also automatically indents code in the best possible way. Not to mention having syntax highlighting and excellent code completion. All this adds to the experience of using Lisp as a very productive programming language, not just an interesting programming language. 
Why?
You're not writing Clojure, you're writing Common Lisp. As such, you should adhere to its style and conventions. Prefixing accessors with anything is not one of those. The name space is also not "cluttered up" by accessors. They're an integral part of your code and API and should get the same treatment as anything else.
&gt;To me, prefixing accessors with a . makes sense. To me it does not make sense. What it does make sense is to keep the syntax as plain s-expressions made with very little special symbols, so macros can manipulate source code easily and powerfully. &gt;It looks like clojure Common Lisp is not Clojure; they are very different. For exmaple, CLOS, as an object system, is far more flexible. 
I was more concerned with defining an accessor named "foo" and then attempting to `(defun foo ...)`
&gt;I was more concerned with defining an accessor named "foo" and then attempting to (defun foo ...) somewhere in another file. It depends on if such "another file" is on the same package or not. Also, "accesor" is not the same as "slot value". You can have both a slot value named "foo" and an accesor named "foo". Note: On my initial comment above I added an example of how package names, function names, class names, slot names, and symbols coexist with no conflict, take a look.
Take a look at my comment, i have edited it.
&gt; and it doesn't the clutter up the namespace with generic fn's Of course it does. You need to intern a symbol for the accessor anyway, and Lisp does not care if its name is `FOO` or `.FOO`.
Great. That is a good TL;DR on packages. &gt; CODE The variable PROGRAMMING-IN-THE-LARGE is unbound. [Condition of type UNBOUND-VARIABLE] Haha. http://www.gigamonkeys.com/book/programming-in-the-large-packages-and-symbols.html
It is bad for two reasons: 1) some implementations (i.e Allegro CL) have hierarchical packages[1] and symbol name `.foo` is ambigous with package accessor 2) given we adhere to the principle that we don't know anything about objects (we know only their protocol), having a separate convention for accessors is wrong - because knowing that something is an accessor (not i.e function defined with defun or other generic function) violates this principle. Having this principle adhered to allows you to switch implementation in the future when you get rid of the slot – your software clients won't notice. [1] https://franz.com/support/tech_corner/hierpackuser.lhtml
Cargo Cult alert! In languages that have dot access, the dot isn't simply part of the name. Simulating dot access by adding it to the slot name is silly. The idea is that somehow if you just simply exhibit the ASCII period in the code, the *benefit* of a dot notation will somehow materialize. This falls under "cargo cult programming".
The problem comes down to: you either need a naming-convention for your constructors or for your slots. In CL, the style is to have constructors be called `(make-foo ...)`. This way you can have slots be called `foo`: `(defclass bar ... foo)`. An alternative is to have your slots be `.foo`, then you can have constructors like `(foo ...)`. The answer to the question lies in which function/method is most likely to change. - Is a constructor likely to be changed something other than a constructor? e.g. `(make-foo ...)` does something other than make a foo object. If it does, then the symbol `make-foo` is no longer appropriate, because it no longer constructs an object of type `foo`. - Is a slot likely to be changed into not a slot? e.g. `(.foo ...)` does something other than access a slot of a class? If it does the symbol `.foo` is no longer appropriate, because `.foo` does not access an object's slots. To me it seems likely that `(foo ...)` could easily be changed from performing a lookup on a class to performing a calculation. It seems possible, but less likely that `(make-foo ...)` would be changed to do anything but construct a foo. Aside: I actually tried doing things this way, and I feel as though doing it was worth having more concise constructor names. TLDR: accessors and constructors cannot have the same name, so one needs to adopt a naming convention. accessors are more likely to change behavior than constructors, so give them more flexible names. 
If you are really tied to another editor, try using that editor, but use SLIME as your REPL. It's better than any other REPL currently out there, so while you only get a fraction of the power of when you use it also as your editor, it's still a better alternative. If you create an ASDF system, then ASDF will manage reloading changed files for you automatically, so it's about on par with e.g. using another editor to edit your C++ files and debugging with visual studio. It's a good way to "get your feet wet" without having to lose all your muscle memory from your editor.
&gt; can I use a vanilla text editor and a command line repl? yes. that's what many of us do. plenty of us don't use SLIME or emacs. all you need is the same thing you need for any language: something to edit text with and the ability to use the console well enough to tell it to run a lisp file ("sbcl --load filename" or some shit). like i honestly started out with Vim and Terminal, and now I use an IDE that I wrote in lisp to write most of my lisp code, because it runs the code as i type. like it's a complete piece of shit that i stumbled across when i was trying to make something else, but it's still years ahead of any ide that doesn't let you code in real time. lisp is not like the other languages. you're learning it because of the sheer power you're going to get by using it. the power to make your own editor, your own anything. 
the real question is why anyone has ever put up with this floating point fucking nonsense. they're switches that can represent anything, there's no reason to represent numbers as base 10 to the user and then convert back and forth between binary behind the scenes BY DEFAULT.
no. its the effect of dumbass programmers setting a standard that's never been reversed. there's no reason to have your language use base 2. and there's no reason to trick the user into thinking he's using base 10 when he's not.
The vast majority of macros don't look at symbol names. They can do it and you could always contrive one that doesn't work with your names. Nothing to really worry about though.
1) If that's a problem, Allegro CL would be pretty unusable as a Common Lisp. I don't believe it for a second.
I know that convention and thought it was verbose! That's the reason for the `.` sugar. My first lisp was clojure. I really dislike a lot of things about it, including its use of vector syntax for binding. I personally like the syntax it uses for Java interop which is obviously object heavy. 
Try placing the dll in the directory where your project resides, that had worked in the past for me, and if you are using emacs/slime, in the REPL type ,cd and write your directory in the mini buffer. Also, in the case of sqlite3 I advise to install it, you can do it using [chocolatey](https://chocolatey.org/) to make it easier on yourself. Also as you mentioned you need the correct DLL (32 or 64) and it has to be named as expected by the application. Since you are starting I would not expect you to debug this, but if the problem persists file a bug.
I was just using the repl directly out of command prompt. Sqlite was already installed but no success. Based on your comment, I installed portacle and strangely if you have a project these will run. Thanks so much for the advice. I clearly need to learn a bit about CL project structure.
I use that style, but using a slash instead: *classname/slotname*. That makes things a bit more clear if the class or slot name have dashes in them.
Ahh this old cruft. Maybe I should get around to writing a blog post about this. The "not a valid win32 application" is due to wrong bitness, likely a 32bit implementation loading a 64 bit dll. Other gotchas mostly stem around confusion about where to put system libraries so that they can be found. On a 64 bit system, 32 bit libs go in c:\sysWOW64 (right? its where a 64 bit implementation stores 32 bit libs for 32 bit programs) while system32 is reserved for 64 bit libs. Also, dlls sometimes depend on other dlls. An error can occur if dependent dlls are not in the dll load path, even if they are all in CFFI foreign library directories. Once CFFI makes the first dllopen call, the system will take care of loading dependents and doesn't know about other cffi library directories. If you can figure out the right order, you can CFFI load them yourself, or place all libs in a system-searchable location. ~~So to sum up~~ I first try putting all the libraries I want to use in a folder in my lisp project, adding that pathname to cffi:foreign-library-directories, then quickload their lisp bindings. If I have to resolve dependent dll calls myself, I'll figure out the order and issue my own cffi:load-library calls. I do it this way so that I know exactly what dlls I need to collect to ship if I want to build a standalone executable. Usually when developing, I don't want to copy all the dlls into the directory of the currently running lisp image, but at deploy time, that would alleviate the need to modify cffi:*foreign-library-directories* If someone knows a better way of managing this I'm all ears.
Customarily, the accuser has the burden of proof! Can you provide standard-conforming code that would FOAD under Allegro CL when using such a symbol? 
&gt; My first lisp was clojure In that case the cosmetics of your idea are not a downside for you. In your place, unless you're writing for an audience, I'd probably just go and try it. I've done the same for a lot of ideas the kind folks of r/lisp would have disliked, had I been around at the time. Admittedly, a lot of these ideas I eventually came to dislike myself :-) 
I did not claim that a program won't load on ACL. To clarify: `(defclass +foo+ () ())` is also ambigous, because that convention indicates something else. Packages and accessors occupy different namespace, but when I see `.foo` what comes to my mind is a relative hierarchical package `+foo+` what comes to my mind is a constant (not a class) functions and symbols occupy different namespaces, so *compiler* won't get confused.
&gt; what comes to my mind is a relative hierarchical package I see, you think it's confusing. I didn't get that you were talking about yourself, not Allegro CL, because you said it is "ambiguous", but "confusing" is not usually understood to be the same as "ambiguous". A Schemer could be expected to think that (list list) is confusing, but that doesn't make it ambiguous. 
I'm organizing foreign libraries into loadable systems. E.g. https://github.com/borodust/chipmunk-blob/ They register and load themselves in correct order (incl. dependencies). Later I can retreive them all to pack for shipping.
 use your Editor of choice and the repl. it's programming like it's 1976, but at least nothing gets in your way. (I use vim + sbcl + rcs on Linux. That's my IDE. Works great. I'm one happy camper.) 
Have a look at [Deploy](https://shinmera.github.io/deploy/) to manage deployment with shared libraries.
&gt; https://github.com/borodust/chipmunk-blob/ So bodge-blobs-support extends asdf to allow libraries to be specified as components of an asdf system, which will automatically cffi load them when the asdf system is loaded. But I don't see anything about dependency order. Also, once you've loaded the system you have all libraries loaded this way stored in *libraries*, but what do you do to collect them and later ship them? This looks cool, thank you for the link.
Basically, it opens/loads foreign libraries upon system loading. So that means if you have another *-blob system as an asdf dependency, it will be loaded first. To collect all libraries registered this way you would call [`bodge-blobs-support:list-registered-libraries `](https://github.com/borodust/bodge-blobs-support/blob/4f7630e694344a50ba83acdbc984686fc4cc8a9d/utils.lisp#L5) which will return list of full paths to the registered libraries you can iterate over to copy them into whatever place you like.
Oh I see what you meant about dependencies. I was referring to dependencies embedded in shared objects themselves. Thank you for clearing that up!
Right, the "gotcha" is that you still have to discover the dependencies yourself. What you and Shinmera linked takes care of my first problem
I wouldn't do this, but I'm sympathetic to the feeling that an accessor called NAME isn't great. It's just a symptom of the fact that accessors in CLOS aren't scoped to the object, but to the package, making one feel that the name of the function should be meaningful within the context of the whole package. In Java or C++, the implication of a method call is that most objects do not understand the message, and if they have a method of the same name it's likely to mean something different. Prepending a dot to CL accessors is intended to convey the same understanding, that the method has limited applicability. However, consider this: you're writing the accessor's name as a literal in the code, meaning you know the class or superclass of the object in question. If the accessor applies only to one class, think about why exactly generic functions are involved. Would a struct have been more appropriate and saved you some typing? Or, if you've got a family of objects FOO, a naming convention like FOO-NAME becomes reasonable--it might have seemed silly if there was only one kind of FOO, but when an object may be a FOO and a BAR as well, it's totally logical to have a FOO-NAME and a BAR-NAME accessor floating around. Take a moment to think about generic functions in the classic OO understanding, as messages. Some OO practices have reinterpreted methods as buttons and knobs on the surface of the object. But the original idea was that objects would receive messages, and respond to them according to their methods, more like stuffing a letter in a mail slot than turning a knob. In that interpretation, a message is theoretically a first-class object and as such it ought to have a global identity. Several messages taken as a group constitute a protocol, and naturally a protocol exists outside the context of any individual object. If this kind of interpretation doesn't make sense for the object you're writing, I'd begin to suspect that OOP isn't applicable to the design and a struct should be considered. When generic functions get involved, I'd approach the design from the functionality inward, developing the core of the protocol first and writing the classes after. The FOO in FOO-NAME will refer to the protocol and not to a particular class, so you won't feel uncomfortable about including it. I would treat the :ACCESSOR slot-option (and :READER and :WRITER as well) as a shortcut to use when the protocol turns out to be best implemented with a root class.
7pm UTC happens when this comment is 19 hours and 47 minutes old. You can find the live countdown here: https://countle.com/uEkq134373 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Even though PAIP has the appeareance of a dense book it is written in an extremely clear way. It is very approchable. You dont need any stepping stones. Go for it! You wont regret it. It is a masterpiece.
PAIP uses pre-ANSI Common Lisp, so if you are willing to muddle through a few of the idiosyncrasies and discontinuities it's a great way to start learning Lisp. It also has fantastic, fully-explained applications and is a wonderful introduction to data-driven programming. One of my favorites. On Lisp on the other hand is heavy handed with macros. I *occasionally* write macros, and when I do they are immensely useful. As a beginner I very much overrated their value, and would have done better without them -- at least for a while. I would pick that up after you've had more experience. Though there are some non-macro gems early on in the book. I recommend using Seibel's book as an on-demand tutorial resource. His book becomes more interesting once you actually struggle with the material. But once you understand it, you tend to reference the hyperspec. Practical Common Lisp is like the in-between stage. It was my first book in Lisp, and it was a bit rough going.
To get into some basics of the language, I would recommend Touretzky / Gentle Introduction book. With a bit wider scope there is ANSI Common Lisp by Paul Graham. Reading one of this might help to get familiar with some basics of the language - which is different from Scheme. I would also propose to do some of the exercises, to get practical exposure to writing/reading code. PAIP can then be a next step, especially you then should have written some code, have set up your own development environment and be familiar with basics of using it.
Could you clarify your comment, please? « the worst fucking explanations in human history. » Really?
Awesome, that's really good to hear. I'l check it out then for sure, thanks!
I like these stepping stones. I'll probably end up following this path then. Thanks for the heads up :)
&gt;and wanted to know if any of you have experience with LISP plug-ins for Visual Studio I like Visual Studio a *lot* for C#, but believe me if I say that you can be as productive, or even more productive, by using Emacs+SLIME for Lisp development. Try Portacle. &gt;LISP Note that nowadays "Lisp" is the preferred way. Lisp = List Processing. 
Welcome to Lisp! I'd recommend Practical Common Lisp as a stepping stone before PAIP, just to get more familiar with the language. 
yes really. they're always writing to people who don't know what they're talking about using vocabulary that those people don't know, using ideas and concepts that the person doesn't know to explain what they're talking about. to the point where you can only understand the articles if you already understand what the person is trying to explain. programmers are the most unaware people on the planet. it took me a long time to realize that it wasn't me being dumb and uninformed.
i don't think the leap from scheme to CL is going to be significant at all. especially if you're just using norvig's book. getting comfortable with recursion is the most important thing. and you're already doing that. what you're learning in the little schemer applies to all programming.
there really isnt a polished newb friendly IDE out there. i actually saw one that was a WIP, but i forget the name of it. if you're gonna get into lisp, i highly recommend you at least figure out how to run files from the console. 
I'd do PAIP if I were you, then. The other is great to have for reference on AI techniques, but PAIP sounds more like what you want.
PAIP use Common Lisp 1. Most of the changes for Common Lisp 2 as defined in the standard were additions. 
Please, are you informed that we are in reddit/r/lisp? And that my paper is about a small lisp implementation? Any average lisper knows about the concepts I am talking about. I am waiting for friendly comments about that - helping me to go further, to improve my work - and not for unfriendly comments from an angry and arrogant man. 
For a modern GUI IDE, LispWorks can't be beat. [The Personal Edition](http://www.lispworks.com/products/lispworks.html#personal) is free, but comes with limitations. Beyond that, it's not cheap.
your paper? I see a link to a blog post about building a lisp interpreter. &gt; to the point where you can only understand the articles if you already understand what the person is trying to explain the blog is for you, it's not for the reader. that's why it's such horrific writing, and why pretty much all writing about computer software is horrific.
what does the slime repl provide you in that situation? would it really take that long to write your own hotkey that does the exact same thing?
Ctrl-alt-e worked for me. 
I don't have that much cognitive resources so just reading the a dense PAIP will not make me totally understand the book, it will only make me tired along the way. Instead, I experiment directly to the [PAIP's source code](http://www.norvig.com/paip/README.html) and try to relate to story of the code by optimizing it or making it more complex. For me, the best Lisp book that is totally worth reading to really understand Lisp, functional programming and programming in general is [SICP](https://mitpress.mit.edu/sicp/full-text/book/book.html) (SICP is written in Scheme).
1) Jump to definition 2) REPL History 3) Tab completion 4) Better interactive debugger. 5) Inspector 6) Probably more that I'm not coming up with Really this is nothing new; I knew lots of hardcore VIM users that setup visual studio to launch vim for editing files, but still use the building and debugging tools of visual studio.
Your comments are useless, it's a waste of time. Game over!
Is it possible to execute JS functions with this? What's the JSCL equivalent of `alert('Hello world')` or `console.log('Hello world')`?
take your meds
CL-USER&gt; (#j:alert "do") #&lt;JS-OBJECT undefined&gt;
what do you do in emacs? c-m-e is end-of-defun, very useful for lisp.
The repo: https://github.com/t-cool/jscl-playground
You can call all the functions and variables defined in the global scope by (#j:function-name args). For example, it loads this file in the index.html. https://github.com/t-cool/jscl-playground/blob/master/js/turtle.js And in the JS file, I defined a global variable "turtle" and add some functions to the object. Then you can access to the JS functions and variables as follows: (setf #j:turtle:penColor "green") (setf #j:turtle:x 100) (setf #j:turtle:y 10) (setf #j:turtle:penDown t) (#j:turtle:drawArrow) (setf #j:turtle:penColor "red") (#j:turtle:hexagon 55) 
I didn't know that ctrl-e in Chrome calls a Google search... Which key do you recommend for eval the codes? I'd like to change the key-binding for Windows users.
 If you have a mac, get Clozure CL (it's in the Apple app store and is free). It has its own editor (which is basically emacs) and you won't have to mess with slime or anything else.
Computable reals?
This looks great, thanks!
why do you need this? reason why I'm asking is that your question is somewhat confused. first of all the data structure is called float. Common Lisp supports single precision floats and double precision floats. cmucl also has extension for double-double-floats that I think rtoy maintains for his own secret scientific projects. the reason why you want a float as a data structure, is because you can do computations with it fast at the cost of precision. a float fits into a known size (say machine word) and cpu can do hardware level operations on it. a bigfloat kind of defeats the whole purpose, because you're no longer operating on a machine level, you now have higher level code working with an array of words. typically in a, say, business setting what you would do is implement (or in the case of Common Lisp use) a rational, which is a precise data structure, that you can at useful times round into float, or print in decimal point notation with some very obvious code. I know that maxima has bigfloats, where their existence totally makes sense: when doing modeling you don't necessarily care for speed, your computation might also not be representable as a rational, but you still want highest precision result out of it. If you are dealing with a situation like that, your best bet is to model your computation in maxima as a complete solution, and then look into Common Lisp maxima interop if you're then trying to put that computation into an bigger process. 
SBCL comes with bindings to MPFR. Try (require :sb-mpfr) and check out the package of the same name. 
haha, I'm pretty sure I actually know the algorithm you're talking about (still have to read the paper to understand it tho -_-). I suppose I'm just susceptible to taking shortcuts. 
You can set the precision for long floats in CLISP: (SETF (EXT:LONG-FLOAT-DIGITS) 3322)
If you say CLOS, it does not mean classes only. It is obvious that the OP intended the generic functions.
You may read the number of commas as the number of back quotes you want to unquote before evaluating the expression. This quickly becomes quite a mess to deal with though, so I'd recommend not going much further than this; it's often clearer to sneak in a let-binding in between back quotes to get access to the value using a single comma.
nice !
Oh nice. I have had some issues with cffi call of Fortran code. It is quite difficult for me to find a clear description of equivalent format for possible various denomination. Do you know what one should use with FORTRAN DOUBLE PRECISION ? I only manage to run the call FORTRAN REAL code. Thank you 
Personally I have hard time finding equivalent declaration in cffi calls between FORTRAN DOUBLE PRECISION and lisp. For example a FORTRAN REAL is (cffi:mem-aref *TOUT* :float 0) for example. I have not found for DOUBLE PRECISION. 
Just wanted to give some words of praise regarding this project. The aesthetic is so surprisingly pleasing, and playing with the demos really shows how much more powerful it is than would seem at first glance. Really looking forward to building something with this interface.
I think there were some very useful tidbits in there that I haven’t seen in other, similar pages. I picked up a couple new concepts reading through. Looking forward to seeing more!
Cool, thanks! If you have any questions drop by on #clim channel @ freenode.
Check out MAGICL for how to call Fortran code with double precision. 
When I write macros like this I never nest the backquote forms. Instead, I break out the inner backquote into a separate helper function, and call that function in the outer backquote form. It just seems easier to understand.
I sometimes wonder at how sometimes things can be so easy and powerful in Common Lisp. Thanks Rainer for this tip.
Nothing right now, I have other things to worry about. As for its state, it's released and seemingly stable.
Thanks for your reply. I asked because I wanted to give it a try it soon as I get some time.
I'd like to add that this distributed behavior isn't explicitly required anywhere in ANSI CL. Rather, it emerges from the reference model of backquote expansion which is described in the standard. The behavior cannot be deduced from a purely operational description of backquote given in terms of an equivalence to an `quasiquote` syntax which contains `(quote ...)` and `(unquote-splicing ...)` operators, which we explain individually. We then either have to explicitly document what it means to have `(unquote (unquote-splicing expr))` or else supply an expansion model from which the behavior merges (like the one in ANSI CL). Under the naive expansion, our `unquote` operator will receive multiple arguments. The `(unquote-splicing expr)` will insert `(a b c)` into the `unquote` producing `(unquote a b c)`. Now we have to define what it means for `unquote` to have more than one argument. The inside-out model of expansion avoids this. What happens is that the inner `unquote` is recursively expanded first. Suppose that we have ``(1 2 3 ,,@expr 4 ,@item 5) ;; expr is still (a b c); and item evaluates to d. So under a `quasiquote` operator/macro model, this is: (quasiquote (quasiquote (1 2 3 (unquote (unquote-splicing expr)) 4 (unquote item) 5)) According to the CL model, we get a round of expansion which produces a big `append` in which the unquotes are `list` items, and the spliced items are just themselves: (quasiquote (append (list 1) (list 2) (list 3) (list (unquote-splicing expr)) (list 'd) (list 5))) See where this is headed? Then we recurse to the outer backquote: (append (list (append (list 1) (list 2) (list 3) (list 'a 'b 'c) (list 'd) (list 5)))) That of course evaluates to (1 2 3 a b c d 5) It all works because `list` is an n-ary function, and it's in the context of an `append` call which splices everything.
I dont use end-of-defun, I think is because I use paredit, never tought about it before. I deactivated the windows shortcut and tried c-m-e and it didn't work for me.
I did not know either, it was surprising to me, I would have to look at a [chrome shortcut guide](https://support.google.com/chrome/answer/157179?hl=en) to see what is not used, but I think you can override the normal behavior, I've seen some extensions do it but I do not know how to do it myself.
This is great info, thanks!!
That's great to hear! What are you working on?
If only we had something like quicklisp to not require someone to manually create a redundant list? :P
That's not what quicklisp is for. 
I am really excited that this list has had 150 additions in a year. Other people might think it's nothing compared to other ecosystems, but the high quality (in terms of what they bring) of many of the Lisp libraries stands out. 
This is just sad.
There are several of them, yes - Baggers and Shinmera post their videos here or on /r/Common_Lisp, too.
Thanks for the reply. We're organizing some stuff about these days. The main reason to being stuck at telegram is the accessibility for some users. Telegram with developers is a real popular thing on Brazil. Sometimes I chat with another Brazilians at #lisp-br on freenode, as well random people on #lisp and #lispgames by lerax nickname, but this channel (lisp-br) in particular is not related specifically with the people of CommonLispBrazil. This is really a recent stuff (actually I created this whole thing yesterday with a friend) to try find more people interested about Common Lisp and Lisp in general. Unfortunately we have really a few good contents about Common Lisp at Brazil, and as you can say with my rusty English, mostly of Brazillian speakers cannot read/write English very well. So we're trying unifying forces on our own local community :) Any advice I appreciate.
Yes. There'll be one today, even: http://events.tymoon.eu/1
I try to promote mentoring in the Clojure space. your idea of livestreaming sounds very interesting. world people actually want to watch? 
I am too, but to be clear, just in case, all are not new libraries created last year, but additions of both old and new libraries that were not referenced in this list. Now *maybe* this list did catch up with the niceties of the ecosystem but I'm not sure, there are lots in Quicklisp, to discover through QL download stats and Quickdocs, and lots not in QL that authors do not advertise. I've been discovering libraries for months now. It's great, but also a shame it wasn't better organized.
Some are listed here: https://lisp-journey.gitlab.io/resources/ Shinmera's Lisp Treehous (game dev), cbaggers' (openGL, tutorials), McClim demos,…
Cool ! On reading: - "the lisps have a syntax based on parenthesis" in the introduction: I wouldn't myself emphasize on the parenthesis, but speak about higher language features (a bit like code/data, that comes after) - links: the Hyperspec and the (shitty) Cliki as the first two links is a bit arsh, IMO :S No love for http://lisp-lang.org/ ? For the [Cookbook](https://github.com/LispCookbook/cl-cookbook) and https://github.com/CodyReichert/awesome-cl ? :( - Configuring Quicklisp: no love for https://lispcookbook.github.io/cl-cookbook/getting-started.html ? :D more complete than the QL doc IMO. - your link to installing Slime gives the instructions to install from source :S there are more solutions, as listed in the "getting started" above. - no love for Portacle ? Lem maybe ? https://lispcookbook.github.io/cl-cookbook/editor-support.html - I wouldn't say the nEXT browser is totally written in Lisp, it uses bindings to webkit on Linux. - for a list of project: what about https://github.com/azzamsa/awesome-cl-software ? - you link to YASWEG, in Guile. What about https://github.com/kingcons/coleslaw ? In general, I'd like to push towards the Lisp Cookbook… Would you be interested in translating and extending it ? If you write portuguese content that would fit in, tell us, we can link to it, and I can help with translation. 
Livestreaming? I'd be afraid of people watching how I need to go back to the CLHS every 10 lines of code... ;)
&gt; Sorry, i tried googling that, what is Lerax? Nothing special. Doesn't have any special meaning. &gt; Best way of communicating internationally and unifying developers is... by writing Lisp libraries/packages! My suggestion is to create software and list them on an "Awesome Brasilian Lisp" GitHub page... let's say it's called "Os pacotes Lisp brasileiros &amp; legales" (the Lisp packages that are brazilian and awesome) and invite people to contribute. Indeed. We're working with it. There is some related project written in Common Lisp of the members, but indeed is not big deal I think. Some games and a inference engine.
Yes.
I stream most Tuesdays at 18:30 Eastern US time at http://twitch.tv/stevelosh Sometimes I stream games, sometimes coding (in Common Lisp). It depends on the week. 
If I knew what was being coded in advance, I think I'd dig watching
For anyone which wish talk through irc instead telegram we have some members at lisp-br@freenode.net
Something already done by looking at quicklisp download stats. As well as popularity in #lisp. 
Since linedit has recently been dropped from quicklisp, it seems like the only alternative is cl-readline. Best of luck finding a maintainer.
Wired called PAIP "the best Computer book ever written". Don't drop it on your foot, though. 
Some lovely folks here have mentioned by stuff but for the lazy here are the links :) I stream over [at twitch](https://www.twitch.tv/baggers___) every Wednesday 8pm CET (which is 7pm UTC right now). All recordings can be found [youtube](https://www.youtube.com/playlist?list=PL2VAYZE_4wRITJBv6saaKouj4sWSG1FcS). Currently we are making a small 2d engine with a specific code aesthetic ([episode 27](https://www.youtube.com/watch?v=J-tLs60agz4&amp;list=PL2VAYZE_4wRITJBv6saaKouj4sWSG1FcS&amp;index=32&amp;t=2098s) has the details) Hope to see you there!
Hey /u/Baggers_, any chance the previous streams were recorded?
Yup! every single one can be found [right here on youtube](https://www.youtube.com/playlist?list=PL2VAYZE_4wRITJBv6saaKouj4sWSG1FcS). Also I post the latest youtube in /r/lisp every week.
sweet! thanks :D
In case you hadn't figured it out, the weird clamping was hitting the limits on floating point. I believe it is just that there is a great deal more resolution in floating point numbers near 0.0 than there are in ones near 5776573.0. If you had done (mod start-time 2pi). 
Thanks, I had a think about it after the stream and had assumed but it's nice to have it confirmed. Also just want to say that you blog was an enormous help to me when i was starting out in lisp, I'm not sure how far I would have gone with CEPL without it. Thankyou! 
These are just libraries, can you also include the Super Awesomer Lisps (SAL) like Allegro, or Lispworks? We need to let people know there are choices, and not some default. And your list seems like the place all lisp coders go for advice. 
When a C++ exception is thrown, all your code can do is unwind the stack until you reach the matching `catch` block, at which point execution continues there. Dumb and simple. ---------------------- When a Lisp condition is signaled, the Lisp system does *not* unwind the stack automatically. Instead it searches for the last condition handler established for that condition type (last, meaning dynamic scope - just like dynamic variables, where the last binding established on the stack is the one currently used). Every condition handler is a function, and that function is executed *right where the condition was signaled*. That function may decide to unwind the stack which allows for behaviour like C++ exceptions (see `HANDLER-CASE`), or it may decide not to do it and instead just execute arbitrary code in-place, after which the execution continues after the `SIGNAL` call that signaled the condition (see `HANDLER-BIND`). ---------------------- The second part of the condition system are restarts. They also allow you to run arbitrary code, and can be called any time, though their usefulness is mostly in association with condition handlers. Restarts can be bound to various symbols, such as `CONTINUE`, `ABORT`, `RETRY` and so on, and at any point in code, you can get a list of *all* available restarts that have been established on your current stack. This means that you could get, for example, a list of four different `ABORT` restarts, each from a different depth in your code. A simple `(invoke-restart 'abort)` will invoke the last established restart, but nothing prevents your code from analyzing the restart list further and picking any of them to invoke. Restarts are first-class objects of class `RESTART` and can be invoked programmatically, or - which is much more often in my case - they can be selected a list available in the debugger every time you enter it. They are the objects bound to these `CONTINUE`, `RETRY`, `ABORT`, `ABORT` options visible in the debugger here: https://common-lisp.net/project/mcclim/static/media/it7-cap-2017-debugger.png ---------------------- Now that you've read this very short summary, go and listen to dk_jackdaniel and read the PCL chapter mentioned by him. (:
I'm aware only of gnuplot wrappers unfortunately. What do you use for GUI exactly? Ceramic, McCLIM or both?
If you use Ceramic you can use any Javascript plotting library, don't you?
McCLIM has bundled SciGraph application (in Apps/ directory), but it is broken in some regards, so that may require some work to bring it to shape.
When I was unlearned in the ways of Lisp and stuck doing Java, I came upon a problem where I desperately wanted a `throwback` keyword. So one can consider conditions are as a generalization of exceptions where they can be thrown up the stack as normal but also thrown back down the stack. 
In my perfect world I would use McCLIM for everything - do you have any tips for deploying stuff that uses McCLIM? I would love to take a look at the SciGraph stuff and see if I could fix something, but I am not an all-purpose Lisper quite yet ☹️.
It depends - if it’s something for people to play with then I use ceramic, but if it’s for my use I use McCLIM. I looked at the gnuplot wrappers like vgplot... maybe I could embed a gnuplot with HTML?
I thought about that - I figured that maybe I could somehow get plotly or one of the thousands of charts libs for js to play nice, but that would mean using JavaScript and understanding how to call js from lisp / vice versa.
If you want to build self-contained executables, this (new) resource may help: https://lispcookbook.github.io/cl-cookbook/scripting.html#building-a-self-contained-executable
It would be **awesome** if you could write a bit on your experience, your successes, examples of Lisp features you enjoy, how things were simpler than if it had been done in Python… I think the Lisp world lacks this sort of post. 
Certainly, since output of gnuplot will be png image, so it's just a matter of how you can pass it to ceramic. As it was suggested by @mmontone, js library might be a better choice, because there are plenty of them, and many support animations / interactive behaviour and all this will be missing when using gnu plot wrappers. Data can be sent via message passing. I wanted to render graphics for my pet project and my first though was to use cl-sdl library for that, since it provides an option to create a gui window and draw on it. The problem was that I wanted it to be working on Mac OS with sbcl, and that's not straightforward.
Certainly. I’m by no means a programmer (I’m in imaging physics) so Python was the implied way to go to do anything programmatically. However, Python is so slow when working with these large 3D datasets. I tried C++ and variants, but they are line noise to me. Lisp makes so much sense, it’s readable, and it treats everything as a list which is a dream when using it for computation and data manipulation. It handles mathematics so naturally, and errors are clearly thrown. If I can figure out this plotting quandary I will switch to Lisp for everything, forever.
This is really neat, I doubt I will be able to figure out how to suit it to my needs but knowing it exists will motivate me to try.
Yes, indeed. Portacle it's a awesome project! We forgot about that, but we already fixed after the dzecniv advices!
APPEND has no side effects.
Actually, `nconc` and `sort` *are* destructive. But one should still use the result value. In the case of `nconc`, this is because its first argument can be (unmodifiable) `nil`: (defun foo (l) (nconc l '(foo)) l) ⇒ FOO (foo '(bar baz)) ⇒ (BAR BAZ FOO) (foo nil) ⇒ NIL In the case of `sort`, the reason is that the cons cell referenced by the input variable can end up in the middle of the sorted list: (defvar foo '(3 1 4 1 5 9)) ⇒ FOO (sort foo '&gt;) ⇒ (9 5 4 3 1 1) foo ⇒ (3 1 1) ;; implementation-dependent 
String casting has worked so far, but I'm interested in the conversion method. Do you have any advice on that? The data will be pulled externally so i don't want to introduce having to input `backend:func` instead of `func`..
In case it's not obvious: [clhs](http://www.lispworks.com/documentation/HyperSpec/Front/index.htm). It will tell you which functions are destructive.
Yeah, it's such a mind warp! I'm digging lisp, but it's taking me sooooo long to get used to it! I dig it, though. I just don't think I have a future in Lisp development.
Hey, thanks for the links. I was messing around with Portacle but now I'm using Allegro. I've never used IDEs like this (I'm much more used to xcode and vs) so I constantly find myself hitting my head against the wall when it comes to debugging. I know they'll be much faster once I learn the key commands, but I've got to rewire my brain a bit. 
Your reserved keywords need to belong to a package that is automatically used (in the meaning of use-package) when you read your symbols. Then, they will be exactly the same symbols. Instead of `backend:func` and `frontend:func`, have a package which does not use CL but only exports your language's keywords: (defpackage :mylang (:use) (:export #:func #:global! #:macro!)) Then: (defpackage :backend (:use :mylang)) (defpackage :frontend (:use :mylang)) Your parser then needs to translate tokens from text to Lisp symbols. You could use the Lisp reader, but then: take care to bind `*read-eval*` to NIL, use a simplified readtable and maybe a temporary package for symbols introduced by the user.
Like others said, many functions in Lisp are pure; APPEND is one of them. Learn to navigate the [HyperSpec](http://www.lispworks.com/documentation/HyperSpec/Front/index.htm), it's an outstanding piece of documentation once you get used to it. For recursive solutions, you'd usually use CONS to build the list in reverse; for iterative solutions PUSH does the same thing while modifying the list in place; and then call NREVERSE on exit. The reason for this is that Lisp's lists are very good at pushing head and rearranging, and suboptimal for most other uses.
No, I would say it's a lack of experience in concepts like memory management and argument passing semantics. This basic stuff is obvious to a seasoned C programmer with no FP background. `cons` is like `malloc`. `append` uses `cons` to allocate cells or new list (possibly reusing the tail part from the original list). The newly constructed list is returned. Freeing is taken care of by garbage collection. Gotcha! OP never wrote a C program in which a linked list type was just a `struct node *` pointer to the first node and, and an empty list was represented by a null pointer. Even if the C programmer never did this kind of thing with linked lists, chances are they had done it with strings: e.g. made or used a `mstrcat` type function which glues together strings without modifying any of them and returns a newly allocated string. There is a bit of FP in every language. Given: int a = 2; a + 1; you don't ask, how come `a` is still 2? If addition is done with an add function add(a, 1); the suspicion might be much more justified, but not if *add* is an ordinary function with call-by-value arguments. *add* has to be a macro, or else a Pascal-like procedure with a `VAR` parameter, or a C++ function with an `int &amp;` reference parameter. 
You don't need to use symbol-name for string=, it takes string designators. (string= :y 'y) =&gt; T
&gt; Project web is currently offline pending the final migration of its data to our new datacenter. looks like sourceforge is migrating servers. [Maxima](http://maxima.sourceforge.net/) is also down.
That all depends on the semantics of these data structures. I don't anything about that, because you haven't told us. I was just guessing as to why you might have two different names that look the same.
For those interested, you might also want to take a look at [Urn](https://github.com/SquidDev/urn)
Would you mind commenting on [this issue](https://github.com/bakpakin/fnl/issues/2) to see what the differences are between the several "Lisp to Lua" projects?
Very interesting, considering that LuaJIT is a *very fast* implementation!! 
So, I've been trying to make my own game from scratch with cl-sdl2. I discovered recently that by default the rendering is done on the CPU, and thus it's really slow and CPU-intensive. I imagine there's some simple way to offload the rendering onto the GPU instead, but I haven't yet found any information about how to do that online. Is that sort of thing covered in any of your "Daft 2D Engine" videos? And could you point me to where, if so? I'm not using CEPL; I'm using cl-sdl2, cl-opengl, and cl-cairo2.
First, some pedantic clarification. Continuations are a very generic tool, able to express just about any kind of control flow. In the basic sense it is "what the algorithm still has to do." Conditions are something else: a classification of certain situations or states of a program or the external environment. "You are dividing an integer by zero" is a condition. "The disk is full" is a condition. "A network connection has broken," "this string is not proper UTF-8," etc. What is interesting is how control flow can be modified when more-or-less unexpected conditions arise, outside of the normal control flow. One simple idea is that you provide a different continuation for the computation to cover the exceptional case. But that is very generic and abstract. To really get into it is different ways in which languages allow programmers to define the alternative control flow, and how different the environment looks in this alternative. C++ exceptions, for instance, put the exceptional continuation at the catch, where the environment is established by the try, and the exceptional case does not have any information left about what the low-level code might have been doing before it threw. Common Lisp, however, allows you to specify computations which get executed at the point of the exception to determine which continuation gets used, or before the continuation gets executed, and also has separate ways to define and choose the handlers without introducing new continuations. http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html 
Individual characters are also string designators (of strings of length 1).
Important links that were at that page: https://sourceforge.net/projects/sbcl/ -- page for SBCL on sourceforge (repo is now viewable) https://launchpad.net/sbcl -- bug report page
Sorry, I have no experience with either of those. I just happened to hear about Urn, because it was mentioned on #lispgames freenode IRC channel.
These videos are unlikely to help you much as, whilst CEPL uses cl-opengl &amp; cl-sdl2, it is all abstracted away. If you want to do this from scratch then I expect sdl2 &amp; gl specific tutorials will be your best bet. For GL probably the best intro documents are learnopengl.com &amp; [arcsynthesis](https://bitbucket.org/alfonse/gltut/wiki/Home) (look in the downloads section)
Aw, darn. Was not expecting it to be this hard just to get good performance for 2D drawing. Thank you for the links, though, I'll look into them!
One issue is there is no 'solution' to 2d rendering that works well in all cases, just check out this article on drawing lines https://mattdesl.svbtle.com/drawing-lines-is-hard :D Saying that you can get a long way without having to get to that level of detail. Good luck
Excellent news, and i'm particularly excited by: &gt;Feature: clx-fb backend (poc of framebuffer-based backend). This opens up the door for even more portability, am I correct?
Yes. In a matter of fact someone already works on backend for Mezzano which is prtially based on clx-fb, see: https://twitter.com/dk_jackdaniel/status/959554889167900672
Normal CLX backend uses Xserver primitives to draw things (like function draw-ark etc). FB backend draws "all by itself" in a memory, so may be easier adjusted to different display servers.
To add to what Daniel said, for example this opens up the possibility for making McCLIM work in Windows (without needing an X server)
&gt;How do I compare symbols from different packages? But... but... symbols from different packages... are different symbols! 
Ok, np
Ah, is that also true of sprite-based drawing? I basically just want to be able to load images and put them on a flat surface without eating up CPU. Ideally rotate and scale them too. SDL seems to have basic sprite handling built in but it seems to be on the CPU. I was able to use something like Lua/[Love](https://love2d.org/) to make a sprite-based game really easily. I'm mostly hoping to be able to do the same but with Lisp. Cairo seems to have all the functionality I was looking for and then some, but it also eats up CPU, or at least, the way I'm getting its output on screen seems to. And sorry, don't mean to bother you but I've been trying to write a game in Lisp for YEARS and it's a bit frustrating to want something that seems so simple and yet I can barely draw images to a window without it being really slow.
It's back now.
Pretty much all sourceforge websites have been down today.
* Create a new reference backend on top of the frame buffer (providing glue code for particular platforms will be easy) * The new reference backend should follow the material design guidelines these long term goals seem promising! https://common-lisp.net/project/mcclim/involve
Reupload https://youtu.be/MuxSwaPnabw
It sounds like you want to bind `*package*`. ``` (defun yourlisp-repl () (let ((*package* (find-package :yourlisp))) (loop (format t "~%&gt; ") (print (yourlisp-eval (read)))))) ```
Yes, that is totally my bad. I meant to say "They don't change the provided variable so that it contains the result of the operation". Of course they are destructive.
What OS are you developing on?
I'll give that a go later. Thanks.
ah ok. I've been working on a library that fits your use-case, but it is currently macOS only.
Do you have a repo for it online anywhere? I'd be interested in taking a look or bookmarking it regardless.
Sure -- https://bitbucket.org/jesch/xmas It's very much in a raw state still (wasn't planning on sharing this for a bit yet, but why not). The entry point is load.lisp and there are a bunch of examples in render-buffer-test.lisp and a few simple demos (ufo.lisp, platformer.lisp, a couple others). This may help in that it is a sprite-based openGL library, but it does not use SDL at this time.
Sounds like I might be able to learn something from it even if it's not working on Linux yet. I'll definitely give it a look once I get home and have some time. Thanks!
The main difference is that Urn is trying to be its own language with its own semantics and runtime. Fennel is just trying to be a new syntax for writing what are semantically just Lua programs.
Have you tried wayback machine on archive.org ?
&gt; archive.org Thanks for the suggestion. I hadn't tried that but having just done so haven't come up with anything so far. 
I have the code to the first edition. pbi-code.cl The second edition file is called pbi-2e-code.cl 
Note that I put my first version file to github
Yeah with project Euler there’s usually a brute force method and a way that works nearly with pen and paper. The latter is much more satisfying. 
Turns out Newton's method actually gives about `n^2` accurate digits instead of like `n` as I thought, so actually just doing 10 iterations of NM with rationals for each number got me the accuracy I needed. I'll have look into this digit by digit method you describe though, that sounds cool :D
thanks for saving this, and for posting it here.
No worries at all, I'm always always happy to natter about this stuff. And nope it's not true of 'sprite based' drawing, I just find it funny how some simple sounding stuff turns out to be crazy hard. For sprites you would *just* draw a quad and texture it, if you are not used to GL that '*just*' can be a struggle though, CEPL's job was to make that feel lispy so it's not an engine like Love. You might want to check out borodust's [trivial-gamekit](https://github.com/borodust/trivial-gamekit) which is an engine for 2d games, or maybe in a couple of months the engine I am making on these streams will be in a shape where you might want to consider that.
Yeah, I figured CEPL was not the tool I was looking for for that purpose but I figured you if anyone might have a good suggestion for what I'm looking for :) I've been meaning to play around with shaders at some point and CEPL is probably the tool I'll do it with when I do. Thanks for that link, I've tried to play with Bodge a bit, maybe I'll have more luck with trivial-gamekit though.
Macros in a compiled Lisp are expanded at compile time. Thus giving them source code at runtime does not work. If you want to create source code at runtime and want to compile it, then use the function COMPILE. One does compile it once and the compiled function can be used multiple times. 
Fantastic! This is already clarifying some things I had been wondering about. Also I think LTN is local temporary name, I'm guessing from the definition of `ir2-block`: ``` ;; If an entry is :MORE, then this block contains only a single VOP. ;; This VOP has so many more arguments and/or results that they ;; cannot all be assigned distinct LTN numbers. In this case, we ;; assign all the more args one LTN number, and all the more results ;; another LTN number. We can do this, since more operands are ;; referenced simultaneously as far as conflict analysis is ;; concerned. Note that all these :MORE TNs will be global TNs. (local-tns (make-array local-tn-limit) :type local-tn-vector) ```
Thanks so much. Yesterday i was taking a look at the documentation for the internals of CMUCL and was wishing there was something similar for SBCL. 
 "Once again, let's do C-c C-d h to find out how defstruct works" 
Hint: when you pass `'(+ =input= 10)` to the macro, what you're passing is the object `(quote (+ =input= 10))`. Just write the logic in your macro to look for `(quote ...)` and strip it away; then it can be called as a function. Another idea: keep your `run-form-function` but optimize it with a compiler macro. Look into Common Lisp [compiler macros](http://clhs.lisp.se/Body/m_define.htm). A compiler macro written for `run-form-function` can recognize that it's being called with a quoted argument, and optimize that instance.
Is there a book/documentation that show how REPL works under the hood and other low-level stuffs in great detail?
Except the poster is not pasing in `'(+ =input= 10)` but rather `*form*`
In this case what you care about is unrelated to the REPL; it would be nearly the same in a file. I don't know of a tutorial, but a reference are chapters 2 and 3 of the hyperspec. They cover this fully. What is easy to miss is that the implementation of macros in common lisp are *very* simple. They are just functions that take unevaluated forms as parameters. In the case of `(some-macro *foo*)` the parameter to `some-macro` is the symbol `*foo*` not the value of `*foo*`. If you want to store code to be run in a variable, then `lambda` is what you want (just like you would use `function` in javascript). It is very rare to be dealing with dynamically generated lisp forms at runtime (unless you're implementing a REPL), and if you're not dealing with dynamically generated lisp forms, then the static form could just as well be `(lambda (x) (+ x 10))` as `(+ =input= 10)`. Obviously the lambda will be both more efficient and easier to use than the latter.
"If displaced-to non-nil, a displaced array is created. The resulting array shares its contents with the array given by displaced-to." "displaced array n. an array which has no storage of its own, but which is instead indirected to the storage of another array, called its target, at a specified offset, in such a way that any attempt to access the displaced array implicitly references the target array. " http://clhs.lisp.se/Body/26_glo_d.htm#displaced_array
Since this is gives the implementation license to return a new array, you can only rely on it being the same array, if it's [*actually adjustable*](http://clhs.lisp.se/Body/26_glo_a.htm#actually_adjustable). Of course, implementors will seek to avoid unnecessary copying of the array contents, so using that as your heuristic, you can be quite confident in some other cases that it will be the same (but you should preferably `assert` that). Note that it doesn't say "The result can be displaced", it says the argument can be displaced to the result (by a further call to `adjust-array`).
Thanks, I hadn't understood about "actually adjustable" before. I see now that when the array is created, `:adjustable t` is supplied, which makes it explicitly adjustable and therefore actually adjustable.
Yes. But I am also too bad at this stuff to do it :-).
Yes! But my problem is, I don't know anything about WebAssembly. If we want to get a group of people together to do this, however, I would be interested in helping out however I can. 
An actual lisp running in WASM is problematic for so many reasons; on most OSes, even in C you can dynamically compile code by generating a .so/.dll and dlopen() the result, but webasm doesn't support dynamically loading of code into the current module. This makes any incrementally compiling lisp a non-starter. I really think an efficient bytecode machine that could be targeted by SBCL or CCL is the only current way to get a traditional incrementally compiling lisp working in WASM
&gt; but webasm doesn't support dynamically loading of code into the current module. This makes any incrementally compiling lisp a non-starter. &gt; &gt; &gt; &gt; I really think an efficient bytecode machine that could be targeted by SBCL or CCL is the only current way to get a traditional incrementally compiling lisp working in WASM The other option is to say "bye" to dynamic compilation. So we would get a performant lisp but without dynamic compilation. Choices, choices...
what about a 1 function, 1 module scenario, or at least breaking up code into separate modules as necessary? is this a bastardization of the wasm module system?
The problem, as far as i have understood wasm, is that those two modules will not be able to share the same linear memory (i.e. what module X writes to memory is also seen by Y.). Correct me if i'm wrong. 
Multiple modules can share memory. [https://tbfleming.github.io/cib/](cib)'s runtime does this.
Thank you so much! I'll take a look. 
The way I understand it, the goal seems to be to have `(run-form-function '(+ =input= 10) i)` optimize, while allowing `(run-form-function *form* i)`. (The topic and the examples with the timed `loop` clearly show the quoted syntax rather than `*form*`).
&gt; Yes! But my problem is, I don't know anything about WebAssembly. Want a very quick introduction? Note that i am recalling from the top of my mind, so I can make mistakes: Webassembly is a bytecode (for virtual machine) specification that is intended primarily for executing said bytecode inside browsers. It is currently supported on all major browsers by default. The idea is that this bytecode is loaded by a webpage (using Javascript as bootstrap, for example), then ahead-of-time compiled to machine language and run. The virtual machine is a stack machine with very simple opcodes. Datatypes are (from the top of my mind), 32 and 64 bit, signed, unsigned, float or int. It has the standard branch instructions, standard arithmetic functions, and some math functions (for example square root). Wasm code is organized in "modules", each module can have many functions. The VM's memory space (or "heap") is a linear memory block with you define from a start (and later can grow if needed). There is also a "table" memory, separated, that can be used to list pointers to functions. So loading/storing opcodes allow you to use such "heap", and there are call opcodes that allow you to do indirect function calls (through the function table). Each module can have one heap and one function table. Functions can return only one value. There is some interoperability with Javascript, so you can call from wasm to js and viceversa, but there is a significant overhead involved. 
From the spec: [defconstant](http://clhs.lisp.se/Body/m_defcon.htm) And the bits that likely matter to you here. &gt; If a defconstant form appears as a top level form, the compiler must recognize that name names a constant variable. An implementation may choose to evaluate the value-form at compile time, load time, or both. Therefore, users must ensure that the initial-value can be evaluated at compile time (regardless of whether or not references to name appear in the file) and that it always evaluates to the same value. And remember that: &gt; The consequences are undefined if there are any bindings of the variable named by name at the time defconstant is executed or if the value is not eql to the value of initial-value. You may also want to look into alexandria's `define-constant`
Just trust the user not to shoot themselves in the face. Lisp is not a language made to restrict users. Learning that is quite liberating.
define-constant suffers from the same problem as defconstant. If foo is defined in the same file as +z+ i.e. "The function COMMON-LISP-USER::FOO is undefined." for the reasons you mentioned.
Baggers_ quotes the part of the spec that explains why this is an issue (also see my reply for the specific error). The define-symbol-macro though works!
I was wondering about that. Then maybe I just use defparameter since it makes things more uniform.
"works with `eval-when`" is a far cry from "not supported".
&gt; Lisp is not a language made to restrict users. So much truth in this; if there is such a thing as "Lisp philosophy", this should be one of its most important tenets. 
Here's another short-ish introduction: https://github.com/WebAssembly/spec/blob/master/papers/pldi2017.pdf
Having tried to load a large number of quicklisp packages, I think local package nicknames are becoming a necessity. Without them, nicknames pollute the global package namespace and collisions become unavoidable. At the moment, SBCL, ABCL, and ECL support them. CMUCL, CLISP, and CCL do not. I do not know the state of Lispworks or AllegroCL.
You can cloak a variable in a symbol macro so it isn't a 'place' that can be assigned to. (defparameter *obfuscated-variable-name-for-+x+* &lt;initial-value&gt;) (define-symbol-macro +x+ (identity *obfuscated-variable-name-for-+x+*))
&gt; "works with eval-when" is a far cry from "not supported" I'm super interested in this so any clarification would be super useful. Is what I am doing in my reply undefined behavior? In what cases is it not supported?
The bird cam is a new addition, providing you with revolutionary stream entertainment: you get to watch two budgies, being birds, live! Basically this is now an animal stream with code on the side.
Aha! Thank you for the clarification, important distinction.
Good point. It would be solving a solved problem, despite the fact that it was on the scene first more or less. If one ever lucked into a startup that sold off for enough zeroes it would be fun to hire a bunch of researchers to pickup where OpenGenera left off and build out the ecosystem and add on things like Mirai if their source code ever became available. Not having the pressure of the market to produce results has it's dangers, but it could be a fun project. 
I can get it to compile on debian but the lush2 binary starts with the following error: **** GASP: Severe error : Signal 11 has occurred **** GASP: Trying to recover **** GASP: You should save your work immediatly As well, I am pretty sure I have virtually none of the dependencies it requires except to compile the lush2 binary on my debian box. Have you managed to run the demos successfully your self? Or anyone here?
I have... about 5+ years back :D
There's any way i can convert c-string back to common Lisp?
Have a look at [CFFI](https://common-lisp.net/project/cffi/manual/cffi-manual.html#Introduction). In particular it has these functions that might be of help for your case: [#'cffi:lisp-string-to-foreign](https://common-lisp.net/project/cffi/manual/cffi-manual.html#lisp_002dstring_002dto_002dforeign), [#'cffi:foreign-string-to-lisp](https://common-lisp.net/project/cffi/manual/cffi-manual.html#foreign_002dstring_002dto_002dlisp) 
All that history and they never managed to implement non-useless error handling. :( 
Some other thoughts: Another instance of unfortunate naming, or even a design flaw: `collect-fn` is just fold (i.e., `common-lisp:reduce`). The only differences are, `collect-fn` would accept multiple sequences (series, in this case) and allows for an explicit type specifier. It's weird that this basic operator is called `collect-fn`. Implementing a sequence-like object without providing proper fold interface to it is probably a mistake. SERIES provides a substitute to such interface which turns out to be less consistent. Besides the fact that it makes the package more difficult to learn for the most interested (!) of its potential users, there is also a technical consequence regarding `collecting-fn`. This function returns a sequence of successive fold applications. However, it misses the initial element when called with one empty series as argument: `(collecting-fn t (lambda nil 'init) #'f (scan nil))` returns empty series. I admit I don't understand the rationale behind this (in particular, why should init be a function) but so far it doesn't make any sense: it's very clear that zero iterations of fold should yield initial value. So, given that init is mandatory (good!), the evaluated sequence of iterations should always have init as its initial element. (And for now I haven't implemented a proper alternative that would avoid an additional repeated wasteful check.) This signals lack of careful design, unless I'm missing some fundamental points about optimization possibilities. Also, CLtL2 chapter (appendix, to be precise) doesn't feature a single example of “2D” series, that is, series whose elements are series. I'm afraid it's like presenting a Lisp without a single mention of list of lists. On top of that, definitions of SERIES functions unfortunately don't give impression of a good Common Lisp style. Given `#+symbolics` read-time conditionals in there, it's not surprising. I'm not bashing the author(s) in any way, it's awesome that SERIES exists and is available to anyone. But this style doesn't help its popularity. By the way, there are multiple reasonable ways to evaluate fold over multiple sequences. `(fold #'f 'init '(a1 b1 c1) '(a2 b2 c2))` might be `(f (f (f x a1 a2) b1 b2) c1 c2)`, as SERIES insists, or it could be `(values (f (f (f x a1) b1) c1) (f (f (f x a2) b2) c2))`. This is not a mathematical certainity. And I found no language here https://en.wikipedia.org/wiki/Fold_(higher-order_function)#Folds_in_various_languages whose designers would feel the need to even offer fold over multiple sequences. I am spoiled by impressive arsenals for sequences manipulation. Common Lisp doesn't have those out of the box but it provides means to build it, and there are libraries of course. But corresponding means as provided by SERIES seem quite awkward to me so far. I'll keep studying and using it of course since everything else looks even more dreadful.
shame it's a poorly OCRed one, has it been proofread?
It's fake; there was no PDF in 1992. /ducks
Maybe you're referring to a previous version? It has been updated now, and the quality of the PDFs is great.
yes! I can finally replace my kindle version, and I don't have to worry about errors in code (there were quite a few).
added to the Free Books section of the sidebar ==&gt;
I think if i use CFFI i'll need to rewrite my code.But i'll give a try. Thank you !
Yeah, lisp can be quite the shock if you're used to other languages (I'm speaking from personal experience) 
I bet there is a word in German to express the intense, mixed feelings I have with respect to that beautiful logo.
.dmg files are macOs specific right ? Is there a linux version ? 
This is cool, too bad it does not work on Windows afaik, for those in windows I would suggest installing [Auto Hot Key](https://autohotkey.com/) and then using [EWOW](https://github.com/zk-phi/ewow), it does not open emacs, but it gives you a lot of its functionality almost anywhere on windows.
Nice. But it is not allowing me to drop it on the 'Services' icon. What gives? (I am using Sierrra) Run it with elevated permissions somehow? 
If this is "removed", why is it visible? 
How about "Hassliebe"? Or maybe you're experiencing kind of a "Gefühlsüberschwang"?
I made the logo in Sketch. It’s a trace of the famous Emacs pinky photo. Made me laugh when I made it.
Oh snap! Did you get? Let me know. I’ll put the work around in the README if we can figure it out...
&gt; Gefühlsüberschwang Emacs Pinky is erect and yellow. I am revulsed, but also in awe. 
Of course, my real desire is some Javascripty thing that talks emacsclient protocol directly, or maybe a Javascripty Emacs front-end to go alongside the various GUI and TTY frontends, perhaps by having Emacs actually run a web server internally. That is, just as I can do `emacsclient -nw` in a terminal and get access remotely to the GUI emacs running on my workstation, I'd be able in my browser to run some plugin or JS that would talk directly to an authenticated port on my Emacs binary, and render a frame in my browser window on equal terms with the TTY and GUI frames.
Send in a pull request, my dude!
Well, drag and drop didn't work even when I mounted the dmg using sudo. But simply double clicking worked. It got installed in Services ! Thanks!
Thank you! Might change the dmg to use the double-click method instead 🤔
This isn't CL, but still related, there are the beginnings of a Scheme to Wasm implementation at https://github.com/google/schism 
I don't know why I never thought of doing this. I'm looking forward to the Linux version. I think it will allow me to use Jupyter notebooks.
That sounds super interesting, I'll look into this during weekend sounds like a super useful project (you could use emacsclient in every text field of firefox and stuff like ipython etc could suddenly become usable.
I’ve got WIP pull request on github to add support for Linux. I need some eyeballs on it, especially since I wrote it without testing it in Linux and because bash it’s been a while since I’ve got my bash on. Thanks an adavance 🙏 
Thanks RJ for this post; i'm currently reading about the memory model used by uLisp, since it targets devices with really little RAM. 
Not working for me. I'm getting an applescript error message The action “Run AppleScript” encountered an error: “emacsclient: could not get terminal name emacsclient: error executing alternate editor ""”
So it's, like, almost everywhere, then. 
I think what you ask for is a Y combinator; for example: (((λ (f) ((λ (x) (x x)) (λ (g) (f (λ (arg) ((g g) arg)))))) (λ (fac) (λ (n) (if (= n 0) 1 (* n (fac (- n 1))))))) 5) should evaluate to `120` in your lisp if you got the scoping right, and ( ((λ (f) ((λ (x) (x x)) (λ (g) (f (λ (a1 a2) ((g g) a1 a2)))))) (λ (concat) (λ (xs ys) (if (null? xs) ys (cons (car xs) (concat (cdr xs) ys)))))) '(q w e) '(1 2 3) ) to `(q w e 1 2 3)`. And it can be embedded so ( ((λ (f) ((λ (x) (x x)) (λ (g) (f (λ (as) ((g g) as)))))) (λ (mapfac) (λ (xs) (if (null? xs) '() (cons (((λ (f) ((λ (x) (x x)) (λ (g) (f (λ (arg) ((g g) arg)))))) (λ (fac) (λ (n) (if (= n 0) 1 (* n (fac (- n 1))))))) (car xs)) (mapfac (cdr xs))))))) '(1 2 3) ) yield `(1 2 6)`, and you can do mutual recursion as well. For more details definitely check out ``Unfolding Recursive Function Definitions Using the Paradoxical Combinator'' (http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.116.5425&amp;rep=rep1&amp;type=pdf). However from the examples above it should be clear that this method it is not the chepaset one wrt number of reductions, so you'd be better with "hardcoding" `block`/`letrec`/named `let`... There is yet another soultion though, using a second environment: traditionally it was called `topenv`; the difference between `env` and `topenv` is the former contains bindings (ie results of applications of `lambda`s) while latter contains definitions (results of `defun`s). You pass `topenv` around just as you do with `env` and whenever you evaluate a symbol, you first check `env` and then `topenv`. So there are plenty of possibilities. My experience with writing LISP in C is that you'd be better with implementing a virtual machine (SECD-like) and writing a simple compiler, just as /u/[akrumbach] suggests. But that depends on what your needs and aspirations are. Anyway, good luck!
Thanks ! CPS seems kinda conter intuitive at first, I think I will try to do something like SECD. If you have any links to implement a lisp using SECD, let me know ! 
Thanks ! Yeah I tried to do something using Y combinator before, but I feared that i could fill my whole call stack. I will try do something closer to SECD, if you have any links, let me know ! 
Sure! two "timeless classics" are obviously https://www.cs.cmu.edu/~crary/819-f09/Landin64.pdf and https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf ; there was also a scheme variation by Peter Henderson (LispKit LISP or something). For my thesis I wrote something simpler, but it was meant for dynamically scoped lisp (and ideally for "free-variables-free" lisp), the DRC machine (https://github.com/drcz/drczlang) -- tbh I would not trust myself from 2011/12, though there is even a simple proof of correctness... The idea I had back then was to use defunctionalization to encode closures neatly and then use this primitive device. However I lost my interest in the project so never tried that, although I did implement d17n a few times... The topenv "trick" is neatly covered in second chapter of this paper: http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-453.pdf -- a great read anyway.
The `block` is a red-herring; it is not the basis for why `defun` allows recursion. The basis for `defun` functions being able to self-recurse is that `defun` plants the function into a global binding. So that is to say, **very** loosely speaking: (defun name (args ...) body) --&gt; (setf (symbol-function 'name) (lambda (args ...) body)) When `body` evaluates, and a call to the function occurs, by that time the function is already installed in the binding. 
Thanks ! Didn't realize that it was already working... The early return can be useful though, I will still try to implement `block`
Fremdschaemen. Meaning to feel the embaresment in place for someone else.
CelloAxeMurder, thank you for your reply. It's come to my attention that the GNU CLISP project has not been updated for some time and currently doesn't have a maintainer. Could you please recommend a CL interpreter that Quicklisp works in too?
CelloAxeMurder, your response was very helpful and appreciated!
I usually use SBCL
&gt;Bonus points if it has simple examples of its usage too. CLSQL is [well documented](http://clsql.kpe.io/manual/), and it's usage is basically: 0. Make sure you have installed the correct "database backend" for the RDBMS system you are going to use . 1. Make sure you can establish a DB connection. Then, there are three ways you can use CLSQL. a. By creating your own queries (strings with SQL statement) and executing them, with (execute-command), (query) and others. b. By using "Functional SQL" to create SQL statements based on CLSQL operators. This allows you to programatically create SQL statements in a clean way. See sections III and IV. c. By using it for object-oriented development, similar to an ORM (object-relational mapper). See sections VI and VII. 
Reposting comment here as there is a duplicate post in [/r/common-lisp](https://www.reddit.com/r/Common_Lisp/comments/82d6y3/want_to_help_an_indie_game_get_crowdfunded_and/) --- Small games are hard work for a team of people who are all good at what they do. Asking for unskilled people who can 'fake it' and learn the basics as they go is not going to inspire confidence. That is then compounded by the fact that on the site for the game you have 2 blog posts both with very loose descriptions &amp; a couple of pieces of concept art. I'm sorry to be so negative about this, I'm really looking for any clue that shows this isn't at best misguided or at worst a scam. The site says nothing concrete about the mechanics of gameplay &amp; no evidence of testing the idea in any fashion. This is basic stuff. People saying 'sounds fun' is meaningless when the description is so low resolution. Ultra realism in a GTA style game sounds super cool, but then you play it and you need to do you taxes, you get arrested real fast and spend the next 10 years of the game (in ultra real realtime) in jail. Delivering your full game will take a team, no doubt, but if you can't make a prototype to show how this could potentially be fun I don't think you should be trying to take people's money. 
Yay! An update of my favorite IDE bundle! Shinmera for president!
Doing gods work
So, after emailing Franz and a number of departments at the University of Washington, I received a reply from the UW School of Medicine which pointed me to an old [page](https://web.archive.org/web/20121223063732/http://faculty.washington.edu/ikalet/) from the Wayback Machine and the code from the 1st edition (which [lispm](https://www.reddit.com/user/lispm) already provided). One thing I could do if I find the time is update the 1st edition and put it on GitHub. 
`(quicklisp-quickstart:lisp)` ought to be `(quicklisp-quickstart:install)`. If you don't provide an ordering in the `defsystem`, one will be provided for you, and there's a risk that it isn't the ordering you want. It is better to use `:serial t`. 
Corrected, thank you!
Thank you, this is one of the clearest explanation about setting up a minimal project I have read. Please, gives us more.
Recording: https://youtu.be/CtAmBBd5Wrw?t=12m54s
Think you very much for this good tutorial.
Very clearly written, I would love to see more.
You really want to maintain your separation of concerns. The NN should be the only thing managing the weights and internals of the network itself. In order to maintain a 'smallish' and reasonably computable NN, you probably want your GA to pick a subset of inputs to feed in to the NN. I was using various transformations of noisy data in an effort to smooth out the inputs. Simple Moving Averages for instance. By keeping the NN kinda of small you can evolve a larger population with your GA to pick the best inputs that score the best 'fit' and use the top scoring NN. This is all very computationally expensive, and finding the boundary for what's the right size of the NN and the GA population is a lot of trial and error. Your first approaches are research and really aren't to find the best answer, but to ensure you have organized your various components together properly. Once you're satisfied with the software, you can try scaling out, that's when the real fun begins. With so many moving and dynamic parts, it's really hard to trust the results, especially when using real-world data, with all the noise and entropy of the world. 
Hey mike, wrote you several months about seeing your CL AWS deployment set up. May you could poiny me to a repo link, and I will figure the rest out.
Evolving an artificial neural network using genetic algorithms or other evolutionary methods is something that is already present in the literature. A quite old survey (1999) is [evolving artificial neural networks](http://www.cs.bham.ac.uk/~xin/papers/published_iproc_sep99.pdf), but I think that it could still be useful. In general, for topics like this I suggest to search in google scholar instead of the “standard” google.
Had a look at the contents, pretty excited to dive in to this! I've been tinkering with Prolog too so should have some decent crossover.
Cool! Minor note, I believe that `(ql:add-to-init-file)` is available in the system after running the Quicklisp installer so the user doesn't need to stop their Lisp in between those commands.
You're right-ish. But it happened to me that it was available immediately on one OS and happened that it wasn't on another. I can't remember the details. So while what you're saying is the expected case, I just wanted to provide the alternative I needed once too.
"Minimal QuickLisp" is hardly "minimal Common Lisp".
The aspect that Quicklisp handles is pretty minor in terms of that library. By my understanding, I could have downloaded cl-ppcre manually and put it in ~/common-lisp and things would have worked just the same.
BTW, the APK can be downloaded from here (the exact same version of the Play Store, as they are kept in sync): [CL REPL](https://www.dropbox.com/s/qcz4oci6849kjko/CL%20REPL.apk?dl=0)
It's sound and interesting and intelligent and all... but way too theoretic for the current world we're living in, where the problems are more like "how to survive the current month?". In an Ideal World (TM), this would immediately be adopted by everybody. Now answer this (rhetoric) question: are we (currently) living in an ideal world?
youtube mirror https://www.youtube.com/watch?v=OBfB2MJw3qg
This is just a hypothesis, but perhaps the user that launches your `/etc/rc.local` scripts doesn't have a ccl init file that pulls in quicklisp. The following looks like it might allow you to launch the swank server under your regular user. https://unix.stackexchange.com/questions/210939/what-user-runs-the-commands-defined-in-etc-rc-local
Running a lisp image as root... What could go wrong, eh? sudo -H -u &lt;nonprivilegeduser&gt; /usr/bin/ccl --load myscript.lisp 
I think that 1:36:43 begins a very nice breakdown of a small modification that non developers can kind of follow with and non lisp developers can find relatable and intriguing.
BZW thanks for this series.
I implemented `block` in my Lisp interpreter. My approach was to expose `longjmp` directly to Lisp, and then the `block` macro could be written in Lisp (along with `restart-case`, `handler-bind`, and `handler-case`).
Bummer I was actually trying to get around and watch this one live. Oh well there will be more. Hope your mate's talk goes well!
Urn is alright, I recently wrote an s-expression to XML converter in it, but the thing I miss most in it are keyword arguments
Thanks. Worth noting though that the original is noticeably less blurry which makes a big difference in the demonstration sections
This is really interesting. But note that I consider the "modern" adjective to be overused, and unfortunate because it needlessly implies other Lisps are not modern; as far as I am concerned, this negatively impacts how I might perceive your work (which is unfair, I agree). Also, how does it compare to http://joxa.org/ and http://lfe.io/? Will try to install and test, nice work.
'modern' usually means 'fully source code incompatible with any other Lisp dialect'.
Haha, that is a novel explanation I never heard before. Overused? might be. But implying? Can't agree with that. ;-) It didn't mean to start war by implying "all other Lisps is not modern". IMO It's just like the word "good". Usually when you says "John is a good/cool person", it will not make people think it implies anyone else except John is not good/not cool.
That may not be your intent, but the effect is the same for some people. &gt; Usually when you says "John is a good/cool person", it will not make people think it implies anyone else except John is not good/not cool. No, but you are a little bit mixing up your quantifiers. If a say "X is a functional language", I am adding the adjective to add a precision. Because *some* languages are not functional. Adding an adjective is a way to exclude other possibilities. Likewise, if you need to say that "John is a *good* person", that is surely because generally speaking, it is not true that everybody is good: you want to avoid people thinking that John might possibly be bad by adding the adjective. Now, what does "modern" mean here? that you certainly don't want to be associated with other, old-fashioned Lisp? That you are not "one of them", but a "better" one? All I am saying is that the language is kind of divisive, that's all.
Except in the world of people, "good" is a very common (and kinda trash) word since everyone likes calling everyone "good people" unless there are major exceptions. Call John a "young" person. It'll immediately alert people that not everyone around him is "young" since you just made him stand out by slapping the "young" adjective onto him while describing him. Exactly the same thing with "modern".
Thank you for the break down, guys. I will try to avoid putting adjective next time. If there anyway to modify the title of this post? If not, I might just delete the post for good.
How does this compare to [LFE?](http://lfe.io/)
I think [clojerl](https://github.com/clojerl/clojerl) is the more apt comparison. From statistics I've seen recently, I believe LFE is approximately #3 in usage in the BEAM ecosystem (behind Erlang and Elixir).
I highly recommend you watch Rich's talk about Clojure for a Lisp audience. No change in clojure was made without thought nor awareness of why it was done previously. It's fine to not like the changes (I'm not sold on them myself), but calling the changes "idiotic" is a disservice to the thought that went into them.
&gt; Additionally, the use of brackets (as a Clojure Vector) allows you more mental space, because now all parenthesis syntax is usually executable and not data. Which goes completely against the Lisp philosophy of "data is code, code is data". 
With CLIM. Here you can find the code, but it is a throw-away thing, so no work was done to clean it up or document. https://github.com/dkochmanski/charming-clim/blob/master/doc/drawing.lisp
I watched Hickey's presentation when he introduced Clojure, I was actually well into my foray as a Common Lisp programmer in the days Hickey was using Common Lisp to interface with Java. I was not impressed -- to say the least -- back then, and I'm downright convinced my initial estimation was correct now. Clojure as Lisp-improved, the way Hickey positioned it, is a failure in every way. If we look at market penetration, Clojure didn't even make a dent in the Lisp universe since pretty much nobody moved over to it [1]. Clojure carved out its own niche in the Java domain, but in Lisp-land everyone yawned and moved on. It is obvious to me that the bets Hickey made back then did not pay off, at least as far as Lisp is concerned. I'm sure Clojure worked out nicely for his consultancy, but Lisp should stand for more than finding better ways to sell Java to idiots who don't know better. In every way, the areas that Hickey outlined as "improvements" turned out to be premature optimizations -- that never caught on-- at best and mirages at worst. [1] Hans Hübner excluded but if I hesitate to call him a Lisper. Look at his code and make your own mind. 
purist position like yours is exactly what is hurting lisp's adoption. presence of convenient data literals is absolutely better than absence of convenient data literals. visually distinct bindings list is absolutely better than "thou shalt not use anything other than () ever!".
what do you mean? vector literal is code that evaluates to itself.
so you have nothing against a) b) or c) except that it's not implemented within CL? that is kind of hypocritical.
I made a specific point (compatibility with code, tools and practices that have stood the test of time), not the vague generalizations you made up in your mind. Either address my point -- how are visually distinct binding lists "absolutely better" -- with data or stop spewing sibjective conjecture as fact.
"Modern Lisp syntax, like Clojure" is the only kind of lisp i can ever imagine working with. erlang is nice too. best of luck to the author(s).
well at least you concede you're wrong about data literals calling them "idiotic syntax changes", mr. i-never-generalize. as for visually distinct bindings - they preserve lispy semantics (code is data, data is code) but are *visually distinct*. nothing subjective about that.
You keep stating the obvious yet never addressing my point. Let me make it easy: How are _visually distinct_ bindings "absolutely better" than compatibility with code, tools and practices that have been in place for decades?
I wouldn't say every way. I can use Clojure(Script) to write full stack web applications in what is essentially the same language. There have been attempts to create CL -&gt; JS languages but I haven't come across any that even hold a candle to CLJS. You might say that is a point for the community around the language rather than the language itself, but as a fairly green web developer (1.5 yrs pro exp) Clojure gives me a place to call home in a way that CL has yet to be able. I might come around to CL yet, but CLJ seems to have done a better job of accommodating me as a web dev so far.
I've spent less time looking at Clojurescript than I did with Clojure but my impression is that they're different languages -- with substantial common ground --. I don't dispute anything you say, CL is certainly not geared for clientside web development and I don't see that changing any time soon, webassembly or not. On the other hand, it's my impression that in JS-land, Clojurescript has made even less of of a dent than Clojure did in its own space. So, again, I don't see any big reverberating blasts happening after Clojure and its programming model was unveiled to the masses. 
&gt;presence of convenient data literals is absolutely better than absence of convenient data literals. CL also had syntax sugar for vector literals: `#(a,b,c)`, the point here is that in CL is an optional thing that expands later to pure parentheses; while on Clojure the [] is everywhere (i.e. function arguments).
Thanks.
There are many differences between Kapok and LFE, such as, LFE's syntax more like Erlang, while Kapok syntax is closer to Clojure; Lisp-2, Lisp-1; different macro implementations, etc.
Sorry if the description makes you feel uncomfortable, I didn't meant to start war by raising some dialect or disparaging any other. I will try to review and revise the docs everywhere in this project, avoiding using words like "modern". Regarding to the syntax of Clojure used in Kapok, it's a mix of many terms: resemblance on function declaration of Clojure and Erlang, personal favor, etc. I'm afraid it will go this way even if you dislike it. You have your freedom to refuse. Since there are many alternative languages which are compatible with the Erlang ecosystem, such as, Elixir, LFE. Maybe You could give a try on them.
By being compatible with code, tools and practices that have been in place for decades and stood the test of time *and also visually distinct*.
&gt; unleashing the full power of macros in what way are Clojure macros less powerful than CL?
Rather narrow-minded one. If you only know one language it's gonna be hard. Knowing Lisp allows you to write better code in other languages. If you religiously deny using them, it's your decision. Don't blame Lisp for that. 
100% this
Jeez, dude. Don't give away the ending!
&gt;My colleagues were using C (K&amp;R in those days) or Pascal. C++, Perl, Java, Python, etc. didn't exist. When all those modern languages are out of the picture, Lisp rocks. I've used Java and Python professionally for years and I can firmly say Lisp *rocks* compared to them. Oh yeah! No experience with perl, though. &gt;Once upon a time Lisp had a long list of features that no other language had (GC, full numeric tower, CLOS, incremental development, macros) Well, it's 2018 and almost no OOP language has the power, features and flexibility of Lisp's CLOS, except for Dylan, and Julia. It's 2018 and the kind of fully flexible interactive development where the running system can be updated at will (i.e. redefine/recompile a function or redefine a. class *while the code is running*) *and* it is also image-based, is AFAIK still only available in Lisp and Smalltalk. This gives enormous productivity. In fact, in his web page, the OP illustrates how this feature was crucial for NASA's Deep Space 1 project: &gt;In 1994 JPL started working on the Remote Agent (RA), an autonomous spacecraft control system. RA was written entirely in Common Lisp despite unrelenting political pressure to move to C++. At one point an attempt was made to port one part of the system (the planner) to C++. This attempt had to be abandoned after a year. Based on this experience I think it's safe to say that if not for Lisp the Remote Agent would have failed. &gt;(...)The Remote Agent software, running on a custom port of Harlequin Common Lisp, flew aboard Deep Space 1 (DS1), the first mission of NASA's New Millennium program. Remote Agent controlled DS1 for two days in May of 1999. During that time we were able to debug and fix a race condition that had not shown up during ground testing. (Debugging a program running on a $100M piece of hardware that is 100 million miles away is an interesting experience. Having a read-eval-print loop running on the spacecraft proved invaluable in finding and fixing the problem. The story of the Remote Agent bug is an interesting one in and of itself.) &gt;The Remote Agent was subsequently named "NASA Software of the Year". 
[I never asked for this](https://www.youtube.com/watch?v=CXpuRIZzJog)
It's irony, he is a very gifted programmer, albeit an eccentric character too. The audience he was speaking to wouldn't have needed an /s tag with that. 
So, seeing as no one would question his expertise, why do you think he is wrong about Lisp losing the advantages it used to hold, other than the fact that it rocks? However Java makes you feel when you use it, people *are* productive with it and are apparently unaware that what they are really missing is CLOS.
Agree. Rich is a very considerate person - in the sense that he considers his positions very carefully and has cogent arguments for his choices. Some may not agree with his decisions, but he supports them and justifies them reasonably. It's his language, and he gets to make the choices. I'm glad he does put the thought into them.
That’s a strategic benefit only if high reliability through dynamic code reloading becomes a more significant factor in software systems demanded by customers. At the moment, Linux hasn’t eliminated reboots on security updates yet, even though [significant effort has been expended upon kernel patching without rebooting](http://m.linuxjournal.com/content/no-reboot-kernel-patching-and-why-you-should-care). There is apparently a lot of high reliability and high serviceability mechanisms and techniques in the mainframe world that we in the distributed world haven’t picked up yet, from my casual look into it. My guess is there isn’t a large enough demand for those far rightward nines to make it a market priority at the time, and what we have is good enough for now. The best that non-Lisp&amp;Smalltalk languages can deliver at the moment [are hacks by comparison](https://news.ycombinator.com/item?id=10669131). They require either accommodations in design (Erlang hot code loading), or implementation/operation (Ruby monkey patching). Not as seamless as a SLIME-integrated environment, though I don’t know the limits to Lisp’s hot code updating. But until the market demands it, I’m not sure it is compelling enough of an advantage in general cases.
Worth reading the followup too: http://blog.rongarret.info/2009/04/some-perspective-on-destroyed-career.html 
&gt; If you look at his record he's a very gifted programmer. (Author here.) Thanks for the kind words, but I'm really not. I'm a very lazy programmer, and I've leveraged that laziness into an ability to identify or invent ways to make programming easier (for me at least) and that turns out to be a valuable skill. But it's not the same skill that a truly gifted programmer like Linus Torvalds has. 
I "blame" Lisp for making me realize what a joy programming can be, and what a fucking PITA it normally is. The choice not to put up the PITA (the "destroyed career" part) is of course my own decision, but I wouldn't have made it but for having experienced Lisp. (I also have no regrets.) 
Please, please, someday do post more details of the Remote Agent days, for example the anecdote of the bug. Sincerily, a fellow lisper. 
my feelings exactly. 
Hi! It's all relevant but I think you're (still) too modest. If we have to compare ourselves to Torvalds or Ken Thompson and the like then the bar is too high! 
&gt;Lisping has more or less made my Python 'wildly incomprehensible' too Interestingly, when I learnt Python i was surprised at how legible my code could become, for example by using named parameters. I was glad that CL supported named parameters as well (by using keywords). I think CL code can be made very legible as well, there are many features that can be used for more understandable code if you want (macros, CLOS, etc). -- and of course you can abuse them on the other direction (lol!)
Well, there's this: https://www.youtube.com/watch?v=_gZK0tW8EhQ 
&gt;I'm just some asshole, please stop glorifying me. He has spoken! Hallelujah!! ;)
&gt;He has given us.... A SHOE! Everyone, take off one shoe! `(1- shoe-count)` Done!! But i'd guess not in a thread-safe way. I hope this pleases Our Savior. 
Hey, you're decent at Super Mario Odyssey at least.
&gt; bug is publicly available I think *only you* were able to read it because you had the Multipass. Jokes aside, i see there are several PDFs around. 
But it's obviously not meant to be taken literally. By asshole he clearly means any orifice through which fecal matter might pass.
Coolest thing I've seen in years.
Yes, I should be more specific, and say I guess there isn’t enough demand in the distributed market for those rightward nines to make it into mainstream server technology (yet, I hope).
&gt;But it's obviously not meant to be taken literally. By asshole he clearly means any orifice through which fecal matter might pass. Don't interpret the scriptures of Our Savior the Chosen One literally. "I'm just an asshole", by text substitution "I'm just any orifice through which fecal matter might pass". What does this mean? This means that currently the mighty beauty of Lisp is seen as sewage, as hideous waste, by the infidels. Alternatively, the chosen weapon, Lisp must stay hidden for now, thus best hidden in such a hideous place. It is understood that when proceeding in that way, the aforementioned orifice of all pious Lispers will stay pristine and clean thanks to Holy automatical Garbage Collection. 
Right now I’m implementing a vector–field simulator, I use my program to generate code for PGFPlots to use to graph the data, it’s a little slow but it works. Perhaps it would interest you?
Laughed so hard I choked; good one.
Gave me a bit of a chuckle. It's 2018, I work part time for a company and I am forced to write Java and hate it (and the competition is even closer these days with all the functional tools). I'm probably going to graduate next year and the only reason I am going to look for a different full time job is that I want to code in another language and an interesting tech base (there's a lot of companies using clojure here). 
I wish you the best, a Clojure like lisp to use on the beam would be awesome.
Thank you for sharing! I'm a devoted Lisper, and now that you brought it up, I can begin to see this complacency creeping in to my attitude about programming. Question for you: the productivity gains (or even straight-up advantages over Lisp) that you noticed - do you think that perhaps they could have been partially or mostly caused by the massive library advantage that other languages have over Lisp? For instance, as someone who's written a non-trivial amount of Python code over the past few years, I can confirm that, while it's much less powerful and expressive than CL, it has libraries for *everything*.
In this VM model, for handling environments I've gone the route of using classical displays rather than closure conversion and such. The advantages are: * without doing a lot of heavy analysis at all, we get all local variables on the stack by default. Only when a closure is captured do we have to move the closed-over frames to the heap; this decision is delayed to run time to the point in time when a closure is created. Every newly pushed display frame is allocated on the stack. If that frame's associated code executes through to the end of the frame without making a closure, the frame stays on the stack and is disposed efficiently, just like local variables in C or Pascal. We don't have to do any analysis whatsover that "these variables are not captured by any closure, or any that escapes"; it is the default *modus operandi*. * closures are smaller: only the necessary display levels below the current scope are copied into a closure, not anything lexically inaccessible. Even levels that are in scope could be marked as non-closing (holding non-shared variables). * shared, mutable variables are naturally supported with the same representation and indirection as non-mutable or non-shared ones; neither the virtual machine code, nor the virtual machine interpreter itself are aware of whether they are accessing a shared, mutable variable or a non-shared variable. Sharing is done at the display level: two or more functions have the same environment pointer in the corresponding display entries. A mutation done by one is seen by the others. * live display vectors themselves are always on the stack and never themselves shared; i.e. every activated instance of a closure or vm toplevel execution has its own display. Running a closure means blasting the display copy from the heap into the stack, then filling the non-closure areas of it with pointers to stack allocated memory. The virtual machine is therefore free to modify the on-stack display as needed (e.g. when new frames are opened, or when captured frames move to the heap). When the closure terminates, there is no clean-up associated with the display; it just goes away with the stack frame. So for instance, the code I posted earlier does no consing beyond that done by the `push`: 1&gt; (compile-toplevel '(for ((i 0) j) ((&lt; i 10) j) ((inc i)) (push i j))) #&lt;sys:vm-desc: 8974638&gt; 2&gt; (pprof (sys:vm-execute-toplevel *1)) malloc bytes: 0 gc heap bytes: 160 total: 160 milliseconds: 0 (9 8 7 6 5 4 3 2 1 0) Heap objects like conses are 16 bytes; a list of length 10 was consed up, so 16 * 10 = 160. There is no analysis that "oh, we don't have a closure referencing `i` and `j`, so `i` and `j` can be stacked". Rather, `i` and `j` are stacked. No closure actually takes place. So `i` and `j` live out their lifetimes on the stack, never requiring relocation into the heap.
 curl -i http://www.ulisp.com/show?23QU HTTP/1.1 200 OK Date: Sat, 17 Mar 2018 09:12:28 GMT Server: CL-HTTP/70.217 (LispWorks; 2.1.7) The source for the wiki has not been published AFAIK. But ulisp is open source.
Nice, thank you.
I'm allergic to Java so I haven't used Clojure much.
`curl -I`, surely.
Any possibility you could expound on what you mean about Gerbil modules being single instantiation and this enabling higher performance? Does racket let you instantiate multiple instances, which I assume would just let them have independent global state? I don't see why that would cause a slowdown -- it just means a module is more like a C++ class than a C++ namespace.
\#important If you're eager to get good enough to dig into PAIP, this is a great head start.
So much better Gerbil news has happened since this release :P
The general idea in Common Lisp is that the programmer doesn't need to deal with the details of character encoding; You just specify the correct `:external-format` when you open the file. Ideally, the BOM should be one of those details, but often isn't. On LispWorks, [you just say :UTF-16](http://www.lispworks.com/documentation/lw71/LW/html/lw-202.htm#16299), and it handles the BOM. On many other implementations, you need to handle it, but that's not hard: UTF-16 is typically available in big-endian and little-endian varieties; open the file with the big-endian UTF-16 external format, read a character, if it's BOM byte-reversed, close and reopen in little-endian. Your instinct is probably right, and many people have coded these gyrations before, but I don't off-hand know of any.
Hello, green-ish web dev here too. I have similar considerations to you, and I chose the CL and [Weblocks](https://github.com/40ants/weblocks/blob/reblocks/docs/source/quickstart.rst) framework road. It may very well interest you, it's an old project that's seeing a fantastic update right now. To me it's a much more elegant and promising solution for web dev than CLJ+CLJS (even though, granted, CL for the web and Weblocks must show what they are capable of but see last point :) ). I only slightly tried clj and cljs, but they feel too complicated, bloated to me, specially since cljs is an intermediate between me and JS, and CLJS frameworks are intermediates between us and React (aren't they ?). In Weblocks, we think differently: everything is Lisp, and will get executed server-side with jsonp calls, and the frameworks updates the component. No worry about javascript. We can also introduce continuations-based views, instead of standard MVC. &gt; I feel I've learned much more (and continue to do so) from the Clojure-verse than I would have had I stayed the popular JS path. Absolutely. Likewise, I feel I have more to learn on the CL side: object system, conditions, reader macros, runtime repl, debugger and interpreter,… cheers
What's the end goal? Are you simply trying to start swank server after the system boots? If so, `/etc/rc.local` isn't a good place to do that. At least because it may be executed multiple times during boot, depending on your booting options. If the system is Raspbian, I think it's a systemd system, so, write a systemd unit instead, if it's an initd system, put a script in `/etc/init.d/` and so on.
Nice to see a package manager as part of distribution. From what I see, in it's current form it only supports github repositories. Is there a plan for centralised discovery platform/repo? And do you plan to support any sort of version pinning for packages?
HN is like literally the one general programming news site you're most likely to see a Lisp topic on, so I don't see the reason for surprise.
Not the author, I too was confused/interesting by this.
The easiest thing here would be to take the C library and write a binding for it. Read the file in as '(unsigned-byte 8), convert however many bytes into a c-array and pass that along to the CFFI-defined function.
Thanks for your interest in this problem. I think for my purposes an all-Lisp approach is more workable. I've written a simple encoding sniffer which I've linked in a second edit to my post. By the way, if you haven't already published the code you're working on, maybe that's something to consider; maybe others will find it useful.
I did it for fun in 30 minutes :)
Really laugh for this.
It's a little different, that analogy is not exact. You have to think of the implications on the layering of languages. Gerbil compiles to Gambit-specific Scheme code, which is then compiled to C. So if modules were multiple instantiation, then we would have to pass that extra closure pointer around in Scheme, which means there is an extra argument for all procedures. It also means that module variables are not visible, as they would have to be fished out of the closure pointer; there are no direct references, but rather ##vector-refs through an opaque object. 
I should point out that I discussed this with mflatt in person, and he agreed that multiple instantiation doesn't make much sense in an AOT compiled environment.
..link?
https://www.twitch.tv/baggers___
thanks u/sordidaugust! and thanks for spotting that Zamarok, I'll make sure I add that next time
Ah that makes more sense, I hadn't considered the layering, thanks.
You could also make [an event page](https://events.tymoon.eu/) that always links everything including the correct time.
True, I should link the one I have on twitch https://www.twitch.tv/baggers___/events
I think rust language and it's cargo package manager in particular might be an example of very good approach on my opinion. It's not only package manager, but also a build tool and much more, which streamlines development and keeps a lot of project management questions out of the way. On of the strong promises is that if dependencies are declared, they can be safely used and `cargo build` just works without any additional effort.
I was a bit dissapointed with the fps we achieved this time, so I have moved a bit of the work to the gpu and we are now at 88fps with 15000 actors on screen. These numbers are going to drop a fair bit when we do anything non trivial in the actor's update step so I'd still like to take a few more passes through this and get us to at least 20k actors. It's going in the correct direction though. Thanks to everyone who hung out in the chat, always lovely to see you all.
Love this series. Thanks for all the effort you put into it
Cargo is very interesting indeed, although I don't like needing a SAT solver in the package manager. Another approach that makes sense is go's new versioned proposal: https://github.com/golang/proposal/blob/master/design/24301-versioned-go.md
Thank-you!
You know, a blog post or 2 on optimizing Lisp-code would be pretty awesome! Just saying :-)
Lovely stuff, keep em coming
Very interesting, thanks for sharing
&gt;It's 2018 and the kind of fully flexible interactive development where the running system can be updated at will (i.e. redefine/recompile a function or redefine a. class while the code is running) and it is also image-based, is AFAIK still only available in Lisp and Smalltalk. This gives enormous productivity. Yeah because elixir and Python (used "professionally" for years btw) doesn't exist...
Thanks, its a good idea though I dont think I have any new information. I'll keep this in mind though
Looking forward to it!
Remind me 5 days to xpost to /r/scheme /r/clojure and /r/gamedev 
&gt;Yeah because elixir and Python (used "professionally" for years btw) doesn't exist... I have used Python for two applications i wrote that were delivered to banks, so it's not like I don't realize Python exist. Common Lisp is absolutely superior for hot-reloading. And if you read my post it said: &gt;and it is also image-based, Python is not image-based, thus my list only has "Smalltalk" and "Common Lisp".
Is AE-2.0 compatible with Zombo.com?
Its compatible with all applications. It doesn’t matter which browser, or which website you use it with.
Don’t be afraid. Just do it!
How does the theme work? Does one get announced or is it okay to come up with something beforehand? 
There's also `M-x bring-back-from-the-dead`, but I haven't tested it. If you wouldn't mind doing `M-x bring-bring-back-from-the-dead RET "Murray Bookchin"`, that'd be a nice test of the feature.
Well this is exactly my concern. I'm not confident whether I'll get zero, one or two newsletters if I do that.
Gnother github repo (of millions) with no actual **code** or anything. &gt; **Why Lisp?** ... Due to it's [sic] venerable age, there is an enormous corpus of code to draw from. Yeah, except none of it will run under Lua or Erlang, even if "Lisp flavored". Off topic!
fixed :)
Merci beaucoup, on peux lire plus façile maintenant
Maybe putting some asserts in your .emacs could work. If you get more or less than one newsletter, burn down your universe and try again. `(unless (= (length (remove-if #'junk-mail *newsletters-received*)) 1) (destroy '*universe*))`
Please use this tool responsibly! Don’t make the Oppenheimer in all this!
I didn't know destroying the universe would kill everyone and everything! I just wanted to stop getting spam, I swear!
So, to be abundantly clear, this is specifically for Scheme and not Common Lisp?
You could try writing a small utility program using both languages. The program should be fairly small, but still be able to perform some task that it meaningful to you. This will improve your motivation. Writing it in both languages will help you choose the one you prefer. This approach has worked well for me in the past. The last one I did fetched a few web pages and extracted some information (using simple regexes, not a parser). 
Common Lisp, even though Wikipedia may tell you otherwise, is an older language (it's official birth date is just the date of when the standard was accepted, the language itself is a codification of various other Lisps that existed for a couple decades prior to that). Scheme is a revisionist attempt to fix some problems in Lisp and to try some new things. In my view, some things they tried made Scheme a better language, but others weren't so great. So, I'd say, that if you are interested in historical aspect, Common Lisp would be better, but if you are interested in a language more open to experimentation with the language itself, then Scheme would be better. About ten years ago, when I discovered Lisp for myself, I made a big mistake not asking this question. I was deeply confused about Lisps, and in particular about Emacs Lisp and Common Lisp. Web search would often give me results for Emacs Lisp instead of Common Lisp, and it was hard to tell them apart. So, that's another thing to be mindful of.
Easy, Vyzo for Gerbil Scheme
Scheme was developed around 75 based on earlier Lisps, but with lexical binding by default and a small footprint. Common Lisp was developed starting 1981, based on Maclisp and its dialects plus influence from Scheme (lexical binding). In the 80s/90s both Common Lisp and Scheme were further defined, where Common Lisp got some new stuff like conditions, CLOS, the CLOS MOP, etc. Scheme took some stuff from Common Lisp - for example the numerics, but was at that time more concerned with staying small and incorporating some research on topics like macros. Racket then became its own branch of Scheme. Plus Racket is actually an implementation, where both Scheme and Common Lisp are defined languages with multiple implementations.
You can start with both, but Racket is actually a specific implementation, originally based on Scheme. Since there is a lot of educational and research use of Racket, it's generally good for learning. But some of that is a bit opinionated. There is a lot of stuff to learn and this can keep you busy. Common Lisp OTOH is less opionated and not so much based on research from the last 20 years. It's also a language with multiple implementations. Common Lisp implementations currently don't have a large university sponsor (like Racket), though CMU for example was hat in the past. But Common Lisp has various free implementations and people still experiment with new implementations (CLASP for example for the the LLVM). Additionally Common Lisp has two large and expensive commercial implementations which are generally in quality and practical features a bit above from what you can find in otherwise in Lisp or Scheme.
There is no theme.
 I would say go for Scheme. If you go that route you can use the venerable SICP, or books like Concrete Abstractions or Scheme And The Art Of Programming. Common Lisp also has a few good books like the book by Touretzky, Common Lisp: A Gentle Introduction to Symbolic Computation, or the book by Norvig that recently became available for free, Paradigms of Artificial Intelligence Programming. But I do think that Scheme is the better option for learning Lisp. Switching to Common Lisp should be relative straightforward afterwards.
These are not the numbers that would draw a good picture to someone asking this kind of question. I once managed to find an old Mac Lisp manual, the pages on `loop` macro. You could see it was adopted into Common Lisp without change as many other things did. I forgot the right word from the world of linguistics, but it's like Spanish and Portuguese: people who speak Portuguese will be able to understand a good deal of Spanish without ever being trained to, while Spanish speakers will not be able to understand Portuguese, unless trained to. Similarly, if one masters Common Lisp, Mac Lisp will feel like archaic / strange form of the same language. If one starts with Scheme, Mac Lisp will feel just like a confusing barrage of forms which are only superficially similar to their image of Lisp.
The LOOP macro actually comes from Interlisp, where it was the FOR macro. From there it came to Maclisp and Lisp Machine Lisp. First it was just another library in Common Lisp. Common Lisp in 1981 had no LOOP macro and the Common Lisp book from 1984 (CLtL1) did not describe the extended LOOP macro at all. When Common Lisp was standardized several iteration facilities were proposed, but the LOOP macro was later chosen as the one to include in the standard. The LOOP macro otherwise does not have a prominent place in the language standard - it's basically a standardized library. You can find similar libraries in Scheme/Racket. See https://docs.racket-lang.org/guide/for.html http://wiki.call-cc.org/eggref/4/foof-loop You can also use other iteration facilities in Common Lisp, which includes low-level go-to-based loops, mapping functions, DO, DOLIST, ... More extensive Looping support exists in Common Lisp in the form of the Iterate macro. &gt; Similarly, if one masters Common Lisp, Mac Lisp will feel like archaic / strange form of the same language. Common Lisp was designed as a joint successor to Maclisp, based mostly on slightly different successors of Maclisp: NIL, S.1, Spice Lisp, Lisp Machine Lisp. &gt; If one starts with Scheme, Mac Lisp will feel just like a confusing barrage of forms which are only superficially similar to their image of Lisp. Scheme deviated a bit from Maclisp - but the first Scheme implementation was actually written in Maclisp. There were still a lot of things of Lisp and Maclisp in Scheme: cons cells, s-expressions, linked lists, dynamic binding (fluids), lambda expressions, quote, define, cond, and, or, do, parts of the numerics, ... See: Scheme, an interpreter for extended lambda calculus https://dspace.mit.edu/handle/1721.1/5794 
If you choose Racket, you might miss interactive development, since DrRacket chose to not go this route, CL is famous for its repl and Geiser may lack some features compared to Slime/Sly (interactive debugging?). You might miss practical libraries. Judge with these CL resources: - [CL Cookbook](https://lispcookbook.github.io/cl-cookbook/) - [Awesome-CL](https://github.com/CodyReichert/awesome-cl) - lisp-lang.org
yes for scheme not common lisp
as a scheme guy, I would prefer racket. However: racket's threading situation is pretty bad
Just for the reference, I think this is the same content, although it looked different: http://www.maclisp.info/pitmanual/contro.html the manual I was talking about. Aside from that, I'm still too young to have witnessed these events firsthand. I found this manual when I was trying to reconstruct the "hacker" program (an automatic programmer), which, I believed was written in Mac Lisp. I encountered both Common Lisp and Scheme much after all the events above took place, and when I say "barrage of forms superficial similar..." I'm talking from my own experience.
Half of the Maclisp control forms are in Scheme, too. Like COND or DO. Your impression goes in the right direction, but you can actually see the Scheme was developed out of the Maclisp tradition, too. Even by the same people: Guy L Steele jr was co-developer of Scheme and later he helped to develop Common Lisp, where he for example wrote the first 'Spec': Common Lisp the Language. Note btw., that the language is called Maclisp, not Mac Lisp. It's the Lisp of project Mac - unrelated to the much later Mac from Apple. Mac here stands for 'Mathematics and Computation'.
&gt; I'm still too young to have witnessed these events firsthand In that case I'm afraid you always will be. 
I only dabbled with Racket, but I'm jumping between CL and Scheme(s) since long - today using both in friendly co-existence with different use-cases for my preferred implementations. pro CL: Emacs/slime &amp; CL image-based development is eye-opening and extremely productive in case it fits the problem at hand and once you spent the up-front effort to be able to use it. Also CL is significantly more pragmatic, features like the loop macro or the fast format options can again be huge time savers. Centralized and very detailed documentation with the [CLHS](http://clhs.lisp.se/). [SBCL](http://sbcl.org/) has very good optional type checking and it can produce really quick code, if required. pro Scheme: More elegant, quite a bit smaller and hence quicker to grasp (the first might not exactly be true for Racket). Having different implementations can even be an advantage, in case you want/need to use *one* language e.g. for Java/.Net/scripting/fast executables/... (still expect time to be spend to fight with the implementation incompatibilities). pro Racket: can very well be used without Emacs. Huge feature set with very interesting extensions, driven by a leadership both larger and more focused than CL or any other Scheme. Once the switch to Chez Scheme is complete, performance should become more competitive. And yes, once you've learned one, switching to the other will be much simpler - but you'll still spend *some* time to learn the differing libraries and ecosystem.
There are a bunch of other books to learn Common Lisp: * Practical Common Lisp * Land of Lisp * ANSI Common Lisp (Paul Graham) * Successful Lisp: How to Understand and Use Common Lisp * COMMON LISP: An Interactive Approach 
Let's start by getting straight why you'd want to learn *any* of them *at all.* As I see it, there are two reasons to get into CL or Scheme in the face of Current Year competition. The first is that you've read "The Art of the Metaobject Protocol" and want to get your hands dirty with one of the most interesting approaches to object oriented programming. If that describes you, just learn Common Lisp, CLOS, and MOP. The second major reason to get into CL/Scheme rather than a "modern! Enlightenment now! No place for `cdadr` in 2018!" language is metaprogramming. Macros. This is where it gets a bit harder to choose. If you want to learn about *macro systems* the way they have to be done if done *right,* learn Racket. They have the principled and correct solution for the twin concerns of "hygiene" and "phase separation". And yet. if you want to learn to meta-program, CL is still a very good choice. Even though CL macros only work well in a language very much like Common Lisp (the approach doesn't generalize well), it is simple, it works great *within* Common Lisp, and allows you to focus on the essential problems of meta-programming. Tough choice. Personally, I'd give the nod to CL, but it's by a hair. Be sure to read up on Scheme/Racket macros if you ever plan to design your own macro-enabled programming language ;-) 
&gt; You could try writing a small utility program using both languages. The program should be fairly small, but still be able to perform some task that it meaningful to you. This will improve your motivation. Writing it in both languages will help you choose the one you prefer. I didn't really notice the differences that turned out to be important to me until I'd written a few medium-sized projects in both.
It's my favorite lisp book. Nice reference section too (esp. the short section on FORMAT)
&gt; You can find similar libraries in Scheme/Racket. See https://docs.racket-lang.org/guide/for.html http://wiki.call-cc.org/eggref/4/foof-loop This one comes a lot closer to the LOOP found in Common Lisp. http://planet.racket-lang.org/display.ss?package=loop.plt&amp;owner=jphelps
&gt; If you want to learn about macro systems the way they have to be done if done right, learn Racket. They have the principled and correct solution for the twin concerns of "hygiene" and "phase separation". ...and as a result, writing Racket macros is a lot more work than writing CL macros.
A bit of a troll title, no? e^1000 is a big number around 231080957811190927269310943118483284648496845439628381252911541331943555697329212210172013971626240946988971751394837672615850148618263638353131386962373575159518819874308635067341309329249874178479566038914832646621137284333772314459034100053876949811722656280844471657984507140868872074738112013547919968047188518048212155498448337702206623211349884261431354161075265369049027518481664577556287008022255053265819995218943355184256. You may as well request big floats as a feature, but why post like something is broken and we could help?
I started with it. But the more I learned Common Lisp, the less I liked ANSI Common Lisp.
Strangely, it isn't too big of a number for plain old C to handle. Also, the problem only happens with e^-1000, not e^1000. 
Anything in particular? Have you written about it before?
Are you sure C is handling it and not giving you +infinity? That's a 1400+ bit number you've got there. Remember your function negates the input. The problem is with *e^1000*, which is a big number. *e^-1000* is close to zero and is not a problem.
&gt;Hey guys, I've been reading a lot of books on Lisp Have you read Queinnec's Lisp In Small Pieces? I'm going to buy that one someday. 
There's always *[iterate](https://common-lisp.net/project/iterate/)* instead if you prefer a lispier syntax.
yes &gt; This is an implementation of Common Lisp’s LOOP macro for Racket. The LOOP macro is similar to all of Racket’s for/* macros, combined with Python’s for loop, except it’s more powerful than either. 
&gt;Scheme is a revisionist attempt to fix some problems in Lisp &gt;Common Lisp, even though Wikipedia may tell you otherwise, is an older language There's a mistake here. Common Lisp is a much more recent language than Scheme. Scheme is from 1975, Common Lisp appeared 1984 and ANSI Common Lisp, 1994. "Lisp" is not exactly "Common Lisp" Scheme (1975) influenced Lisps of the time like MacLisp. Common Lisp was the amalgamation of some Lisp dialects that were used in the industry, including MacLisp. &gt;So, I'd say, that if you are interested in historical aspect, Common Lisp would be better, but if you are interested in a language more open to experimentation with the language itself, then Scheme would be better Basis for this claim? I don't think there's a big difference, if anything, CL macros are more flexible (by default scheme has the hygienic syntax-rules macros), and CL does support reader macros (Scheme doesn't really have them, SRFI-10 doesn't come.close). Also the OOP system, CLOS, is implemented using the MOP which allows experimenting with your own OOP system. AFAIK there's nothing similar and spanning the same wide scope of application in Scheme. 
Not yet, no. Lisp In Small Pieces and Let Over Lambda are two major CL books I have not read yet. The price was a turnoff at first but I need some new good books now. Planning to get a copy after I finish Sonya Keene's Object-Oriented Programming in COMMON LISP: A Programmer's Guide to CLOS.
Want another answer? If you want to learn how a Lisp language feels like, go for Racket/Scheme, since it will be simpler to learn. However if your aim is to create an application (be it web server, standalone, etc) that has the potential to grow or be used for serious purposes, it will be easier to start with Common Lisp, since it has *everything* needed for that. 
&gt;Common Lisp OTOH is less opionated and not so much based on research from the last 20 years. I'd like to interject for a moment. 
&gt;Common Lisp OTOH is less opionated and not so much based on research from the last 20 years. I think it also needs to be said that Common Lisp was based on selecting the Lisp features that at the late 70s and early 80s were already proven to be important for serious industry-grade applications. The things that were left and needed now (like threading or networking) are easily available today. 
&gt; Scheme is more clean language yes, but in practice CL is clean enough. 
Since Common Lisp was defined over a decade this is not really true. CLOS for example was not available in the late 70s and early 90s. It was specifically developed for Common Lisp. Features like threading and networking was available already in Lisp Machine Lisp end 70s/early 80s. They were left out of the standard for various reasons, for example networking was still a technology evolving and there was little consensus on the various plaforms (VAX used DECnet, Lispm used CHAOS, TCP/IP was coming, Xerox had their own network, ...). Support for TCP/IP became more important mid/end 80s. If you wanted to write a GUI application for X11 you needed networking and not-having multiple threads was a pain then. But when you were writing native GUI code then on a Windows PC or a Mac, you weren't using X11. Macintosh CL for example at that time used some form of cooperative multitasking - different from multiple threading. When TCP became available and widely used, MCL had its own TCP interface.
Paul Graham has a schemer's point of view. Or better yet an 80's lisper's POV (of which I am one). It was idiomatic but is no longer as `loop` and CLOS dominate today. ANSI Common Lisp ignores Loop and barely touches on CLOS. That said Graham writes good clear even sometimes beautiful code. PCL is nice and more attuned to today's style but it does not get across the beauty of lisp. For me, Norvig's PAIP is timeless and is the style I try to emulate. Also the reference section in the back of ANSI Common Lisp is really good and gives concise good explanations. 
One book which I found to provide a lot of Lisp insight (while not being about Lisp in general) is AMOP. 
Thanks for this reply, R. 
Most other schemes have only typical call/cc (well guile has it too: https://www.gnu.org/software/guile/manual/html_node/Continuations.html#Continuations ), while guile also has something it calls prompts - delimited composable continuations (https://www.gnu.org/software/guile/manual/html_node/Prompts.html#Prompts). Delimited means that they don't encompass as much as call/cc, but are limited by call-with-prompt invoked computation (basically "smaller" continuations), and composable basically means that you can combine them/work on them with some operators (shift, reset, etc. check the docs). About how continuations are implemented in Guile I don't know much, except what is written in docs: "However the implementation of continuations in Guile is not as efficient as one might hope, because Guile is designed to cooperate with programs written in other languages, such as C, which do not know about continuations. Basically continuations are captured by a block copy of the stack, and resumed by copying back. " Prompts are recommended as more efficient for most tasks. Also interesting is Guile approach to multi-threaded programming. It gives you POSIX-threads, futures implemented atop of them and parallel forms implemented on futures. Most of the time one (well at least I) uses parallel form, but it's nice to be able to drop "down the stack" to gain more control if you need it. (https://www.gnu.org/software/guile/manual/html_node/Scheduling.html#Scheduling)
How about land of lisp?
I find racket's for loops clearer for the vast majority of loops, and is less noisy (and a bit more lispy IMO). I have thought about porting it to CL, but I am not really friends with defmacro for those kinds of huge macros.
&gt; How to make two popular CL implementations fall over with just a little bit of simple math. How to not understand two popular CL implementations. The don't fall over. They throw an error. * (expt 2.7182818284590452353602874713527d0 1000) debugger invoked on a FLOATING-POINT-OVERFLOW: arithmetic error FLOATING-POINT-OVERFLOW signalled Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL. restarts (invokable by number or by possibly-abbreviated name): 0: [ABORT] Exit debugger, returning to top level. ("bogus stack frame") 0] 0 * (sb-int:get-floating-point-modes) (:TRAPS (:OVERFLOW :INVALID :DIVIDE-BY-ZERO) :ROUNDING-MODE :NEAREST :CURRENT-EXCEPTIONS NIL :ACCRUED-EXCEPTIONS NIL :FAST-MODE NIL) * (sb-int:set-floating-point-modes :traps '(:INVALID :DIVIDE-BY-ZERO)) * (expt 2.7182818284590452353602874713527d0 1000) #.SB-EXT:DOUBLE-FLOAT-POSITIVE-INFINITY * 
 * (expt 2.7182818284590452353602874713527d0 1000) debugger invoked on a FLOATING-POINT-OVERFLOW: arithmetic error FLOATING-POINT-OVERFLOW signalled Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL. restarts (invokable by number or by possibly-abbreviated name): 0: [ABORT] Exit debugger, returning to top level. ("bogus stack frame") 0] 0 * (sb-int:get-floating-point-modes) (:TRAPS (:OVERFLOW :INVALID :DIVIDE-BY-ZERO) :ROUNDING-MODE :NEAREST :CURRENT-EXCEPTIONS NIL :ACCRUED-EXCEPTIONS NIL :FAST-MODE NIL) * (sb-int:set-floating-point-modes :traps '(:INVALID :DIVIDE-BY-ZERO)) * (expt 2.7182818284590452353602874713527d0 1000) #.SB-EXT:DOUBLE-FLOAT-POSITIVE-INFINITY * 
What should he report?
It is concise and very clear, which are good qualities, but also very opinionated. IIRC nothing about CLOS, nor about conditions. Also it was written before the advent of common tools such as Quicklisp, ASDF etc.
What is this? 
also, iterate's find...maximizing clause is lovely.
I've read LOL, and I enjoyed the game-writing approach, and the sections around lazy programming. I didn't so much enjoy the style used, as it was very car/cdr heavy, when structures or intermediate functions would have made things much more readable. 
Out of interest, why is it bad? I've used it to create threaded applications and had no issues, and always thought that the threading situation was good... 
Thank you so much for that detailed reply! 
I have wet dreams about these..... :)
 (/ 1 X) -&gt; (/ X). 
That seems very richly nuanced; good for SBCL. 
And also CL has the `exp` function so it's not necessary to define `+e+` one's self.
It only uses one thread unless you use places, so no simple paralellism.
CCL offers similar control. (set-fpu-mode :overflow nil) And then ? (expt 2.7182818284590452353602874713527d0 1000) 1D++0 
By that reckoning, however, we don't actually need `pi` (which CL provides) because we have `(* 2 (asin 1))`. 
That looks quite interesting. However, there's not a single comment, and it is full of hacks. It's like solving a series of logic riddles, just to learn how to read this code. Maybe you could add some high-level explanations of the tricks you've pulled here.
I don't remember if I've written about it before. But I find packages, CLOS, and LOOP useful and worth learning well, and ANSI Common Lisp ranges from neglectful to hostile on these topics. I think it also presents an unbalanced view of how much time you will spend writing your own language via utilities and macros vs using the language as it already exists. CL starts off with more of a base and you don't actually have to write to your own invention nearly as much as ANSI Common Lisp suggests. Riesbeck's [Graham Crackers](https://www.cs.northwestern.edu/academics/courses/325/readings/graham/graham-notes.html) has useful specifics.
I don't remember if I've written about it before. But I find packages, CLOS, and LOOP useful and worth learning well, and ANSI Common Lisp ranges from neglectful to hostile on these topics. I think it also presents an unbalanced view of how much time you will spend writing your own language via utilities and macros vs using the language as it already exists. CL starts off with more of a base and you don't actually have to write to your own invention nearly as much as ANSI Common Lisp suggests. Riesbeck's [Graham Crackers](https://www.cs.northwestern.edu/academics/courses/325/readings/graham/graham-notes.html) has useful specifics.
That is an awesome reference, thank you.
Indeed, turns out :TRAPS is hardcoded to NIL on Raspbian's default SBCL (1.3.7.debian). Does the armv7l architecture not support floating point exceptions?
In fairness, `(defconstant pi (* 2 (asin 1)))` is probably going to be a more precise way to define it than `(defconstant pi 3.141592653`*mumble*`)`.
I've just tried to add some explanation in the project Wiki, and I'll write more details later. I have to finish my homework first, 23333
FWIW, Lispworks does just fine: CL-USER 1 &gt; (defconstant +e+ 2.7182818284590452353602874713527d0) +E+ CL-USER 2 &gt; (defun sigmoid (x) (/ 1 (+ 1 (expt +e+ (- x))))) SIGMOID CL-USER 10 &gt; (sigmoid 1000) 1.0D0 
... and it broke `tagbody`, according to "git bisect". 0:~/txr$ git bisect good 87caead8269055b4791de53be0e03afab01f1dd4 is the first bad commit commit 87caead8269055b4791de53be0e03afab01f1dd4 Author: Kaz Kylheku &lt;kaz@kylheku.com&gt; Date: Fri Nov 24 06:46:09 2017 -0800 macros: expand declined form in outer env. [ ... ] 
Nope. Racket is case-sensitive, and lowercase is the preferred case. 
SBCL and CCL handle +1000 just fine. It's -1000 that causes problems. 
Unfortunately, detecting floating-point exceptions on ARM is fairly expensive. You have to clear some bits in the fpscr status register, perform the operation, and then read the status register again to see if anything happened. I would not be surprised if implementations decide not to pay this price, at least at default optimization settings.
Our goal is use the scheme in engineering. This requires: 1. Efficient execution efficiency. 2. Efficient c language ffi so that's why chez.
Our goal is use the scheme in engineering. This requires: 1. Efficient execution efficiency. 2. Efficient c language ffi so that's why chez.
&gt; treats it as an assertion, but some other implementations just blindly trust it This may depend on the compiler setting for safety. High safety often adds specific runtime checks and low safety avoids them.
The problem is that in Common Lisp, type declarations are there mainly for performance, not safety. SBCL will do some limited static type checks if you declare function signature with "declaim ftype". To be honest i don't believe compile-time type checks would bring a lot of "safety" to Lisp. Lisp has very strict typing, CLOS (which you can use to make sure the object is operated on by the most specific method for its class), and an excellent condition system; i consider those three giving pretty good safety. 
6pm UTC happens when this comment is 4 hours and 57 minutes old. You can find the live countdown here: https://countle.com/oij1659176 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Thank u for ur advice :), I've just added the test, and I'm able to remove some unused code safely, I'll organize the code to make it more readable later. Seems that always writing tests is a good habit.
Racket has the delimited continuations, in fact they were introduced by Matthias Felleisen, who is one of the main forces behind Racket.
Oh, I didn't know that, it has been ages since I last time used it. I switched to Guile mostly due to it being GNU project. How is Racket's CFFI these days?
For using most interesting cl libs (read as Fukamachi ones) you have to be prepared for facing barely any documentation though. At the other hand that at least forces you to read some brilliant code.
&gt;For using most interesting cl libs (read as Fukamachi ones) There are many interesting, popular, useful CL libs that have nothing to do with fukamachi. Fukamachi, bless him (and thanks for contributing), does not document almost anything. While most of the CL libs I use are documented and commented. As I understand, Fukamachi-san works with Lisp at a company commercially. He's open-sourcing the things he wrote for that company (my understanding). 
That seems to work fine too: CL-USER 1 &gt; (defconstant +e+ 2.7182818284590452353602874713527d0) +E+ CL-USER 2 &gt; (defun sigmoid (x) (/ 1 (+ 1 (expt +e+ (- x))))) SIGMOID CL-USER 3 &gt; (sigmoid -1000) 0.0D0 
That was great fun to look at!! 
&gt; Yes! And I found it rewarding how even Paul Graham gave up trying to fully understand LOOP. :) At first you think it's horrible stuff, until you start using it more and more, then you are so glad the loop macro is there, for it allows doing iterative stuff in an easy, concise way. 
&gt;It's a book about implementing Scheme plus some Lisp stuff. That's why I want to read it... i want to dig into the details of implementing *a* Lisp. 
It's interesting how many libuv systems are mostly C. Including NodeJS.
SBCL will optimize based on the 'declare' or the 'ftype'. CCL will only optimize based on the 'declare'. Me, I prefer all three if it's critical or [1] and the with-expectations macro from here: https://bitbucket.org/tarballs_are_good/policy-cond
I don't know, I mostly use Common Lisp. Occasionally have used Racket. From what I could see guile has tons of stuff in their standard library from an object system (goops) to gap-buffers.
Yeah, Guile is kinda r5rs with library bigger than r6rs. But library is modularized (similar to C standard library), so you work with as big lib as you want.
Guile has MOP and CLOS based OOP. CL MOP is still better though, but sadly it isn't standarized among implementations (or did this change recently?)
I've tried to write some doc to explain the fun. [wiki](https://github.com/BlueFlo0d/CSP/wiki/Implementation-details) Will add more later. However I found implementing evcon. function kind of hard... Even though this system is theortically Turing complete now, I want to implement it using reasonable times of CPP scanning, just like other parts.. Really hope some genius to join in.
why not Gerbil? 
How about this one? http://lispcookbook.github.io/cl-cookbook/
How about Land of Lisp? https://github.com/clojurians-org/lisp-ebook/blob/master/Land.of.Lisp.pdf
I would heartily recommend Practical Common Lisp, which also is free (you can read it online at the site of the author.) Also, please download [Portacle](https://portacle.github.io/), which is a lisp IDE complete with Lisp implementation (SBCL), so you can focus on learning instead of configuring stuff. IMO, beware of some books which do everything with plain lists and don't want to use the other Lisp data structures: alists (association lists), plists (property lists), hash-tables, structs (records), and of course vectors and arrays. I'm afraid that Land of Lisp, while perhaps being *one of the most adorable programming books ever made*, makes this mistake. As for comments like &gt;Learn Racket (or Scheme, or Clojure) instead of Common Lisp because this, that and that... Consider that the main difficulty in learning any lisp dialect is to understand how to better leverage a language where: - the language itself is programmable (though macros) - and code is also data (that is, source code is also data that can be easily manipulated by the source code,. This difficulty *will* be there no matter if you use Common Lisp, Scheme/Racket, Clojure, etc. And, if anything, macros are easier to write in CL. 
Just getting into lisp finding your past streams very entertaining and informative also - I'll try to catch one live next time! Keep it up.
&gt;Lisp is great but there are a bunch of things with awkward names and questionable defaults. like for example?
&gt; Guile has MOP and CLOS based OOP. Guile also has the [sonic boom](http://streetfighter.wikia.com/wiki/Sonic_Boom) which is pretty unique. He is on a class of its own. &gt;CL MOP is still better though, but sadly it isn't standarized among implementations (or did this change recently?) You can use libs like "closer-mop" which present you an uniform (call it "standard") interface, so you can use the MOP and your code stays portable. 
I learnt from it and I liked a lot.
Yes, this is great.
"Back in the '80s, we showed you how to program [without any bugs](http://landoflisp.com/comic_20x_10.png)!" 
I loved lisp koans. Portacle + Lisp Koans + ANSI Common Lisp did it for me.
I recall enjoying this back in the day: http://ifdb.tads.org/viewgame?id=zj3ie12ewi1mrj1t
My personal path: I got into common lisp through exercism.io. It's not a tutorial site in and of itself, but the exercises gave me quick, automatically-checkable tasks in the language to guide my learning. Exercism is more suited for the purpose of learning a new language than Project Euler, because the tasks aren't supposed to be particularly difficult or illustrate a deep mathematical principle. But on the other hand, the exercises aren't really tailored to the particulars of common lisp, so you're not going to get anything that requires you to learn the more advanced features of the language. I haven't done all of the Lisp Koans, but they seem better suited for that. Practical Common Lisp and Land of Lisp each have their strengths and are worthwhile to look through, but when you have the fundamentals down, you should check out [Paul Graham's "On Lisp"](http://unintelligible.org/onlisp/onlisp.html). It's pretty advanced, but it was the book that really helped me grasp the purpose and uses of macros. When lisp proponents talk about lisp being a mind-expander, this stuff this book covers is often what they're referring to.
cadadr, rplaca ;) position/etc returning nil (which is not a number) instead of -1 or length of the sequence when the element is not found, subseq raising error then end is less than start (why not return just empty sequence?) which is not documented in the function description in clhs, order of arguments inconsistent (compare nth and elt), billion of comparison functions, etc etc. Don't present it like an ideal language - it is good but with some flaws and legacy.
Agreed on LoL, although some of the techniques were interesting. Enjoying PAIP at the moment, but also enjoyed Practical Common Lisp as a first book.
The naming situation is better in scheme, sure. But calling it an improved Lisp is a real stretch. There are many things that CL is just plain better at than Scheme or Racket.
If you use macos, give (Clozure Common Lisp (CCL))[https://itunes.apple.com/us/app/clozure-cl/id489900618?mt=12] a try. Dowanloding it from the App Store will also install a very nice editor. So, you can delay using Emacs+Slime to later. I recently rediscovered CCL, and I find it a nice development environment, and easy to learn.
&gt;&gt; Returning nil is good and convenient though. Returning a number, even though the position is not found is bizarre. No it is not good and not convenient. The function which supposed to return one type in reality could return different types. The practice of using the position next after the last is widely used, from APL to C++(STL's end() iterator), and is a basis for interval-based processing. As for bug with the code, no I don't think it is a bug in the code, to me empty sequence is more robust and correct behavior than raising an error. This is a matter of taste of course, how do you prefer to deal with these situations.
&gt; The function which supposed to return one type in reality could return different types. It does return one type though, `(or fixnum null)`. This is not unusual, even strongly typed languages have optional values. Because `nil` is the only falsey value in Lisp, it's a great representation for "no value" (unless the function actually can return `nil` normally, like `gethash`). 
Idiot.
&gt; position/etc returning nil. Beautiful thing: TXR Lisp: 1&gt; (iflet ((pos (pos 3 '(1 2 3)))) (put-line `found at @pos`) (put-line "not found")) found at 2 t 2&gt; (iflet ((pos (pos 4 '(1 2 3)))) (put-line `found at @pos`) (put-line "not found")) not found -1 can be a valid position in an indexing system: 3&gt; ["abc" -1] #\c &gt; *why not return just empty sequence [from `subseq`]* Because that might be `nil`, and you haven't had your allergy medication this morning. 
&gt; nobody intentionally calls a subseq with end &lt; start I agree with furych here. How do you feel about "nobody intentionally calls `car` with an argument of `nil`?" 6&gt; ["abc" 1..2] "b" 7&gt; ["abc" 2..1] "" 
&gt;As for bug with the code, no I don't think it is a bug in the code, to me empty sequence is more robust *end* less than the *start* is clearly a bug or faulty state of the system. So you want it to silently be ignored and return a empty sequence, so it means the same as "input arguments valid but the sequence is not found"?! Perhaps you should use Javascript where everything just returns undefined silently with no errors raised whatsoever. We all know what a bug nightmare such behavior creates, though 
Also, I find it a bit hard to swallow his style of project organization (one-package-per-file, several small defsystems, java-esque package names and directory trees) and tend to shy away from using his work because of this.
strota.de/little/lisper/little_lisper.pdf
Great. dzecniv,. So long time ago. the reddit interface is like [this](https://web.archive.org/web/20051029165515/http://www.reddit.com) (like HN). Do you get the same thing ?
I might say, if your code is portable, you can check the type validity with SBCL and if you still want to use other implementations then you can switch it. In this case, you can use SBCL just as a validator.
no, I can't install it yet.
Sorry I don't know much about dealing with large amounts of memory in Lisp. If you want something in between what you have a and C++ implementation, you could try employing memory pooling, pre-allocation, and other similar techniques to avoid garbage collection altogether. I suspect the code would be structured similarly to how the C++ version would. Seems like you might have already thought of this, and if so, I'd like to know if this doesn't work for some reason, for my own learning.
You did not mention which is this 'correct result' returned by Ruby or Racket.
This may shed some light why it was rewritten in Python: http://www.aaronsw.com/weblog/rewritingreddit
Have you already tried [ECL](https://common-lisp.net/project/ecl/main.html)?
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://common-lisp.net/project/ecl/main.html) - Previous text "ECL" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20dwiz96w) 
I wrote this in a recent comment, let me repeat it here, as I am really pleased with ccl. If you use macOS, you could give [Clozure Common Lisp - CCL](https://itunes.apple.com/us/app/clozure-cl/id489900618?mt=12) a try. Downloading it from the App Store (link above) will also install a nice editor and debugger. So, you could delay using Emacs+Slime to later. I recently rediscovered CCL, I am *exceedingly* pleased with it. I find it a nice development environment, and easy to learn. By the way, [this complete GUI application](https://itunes.apple.com/us/app/picture-window/id507262984?mt=12) was developed with ccl. [Source code is available on GitHub here.](https://github.com/Clozure/dpf)
If that's your attitude then you can go back to C++.
Could be the case he's using some fancy library or compiler extensions (and in my opinion, C compiler extensions are bad practice)
This is the angriest using in anger I've ever seen.
The problem is that it tolerates ungrateful people like you? Why should you be helped when you shit on other people's work and tell them to fuck off?
It's deliciously ironic to tell one of the most active SBCL maintainers that he doesn't improve existing implementations while, at the same time, not lifting a finger to better the situation yourself.
Yeah I just read it as them using plain old doubles, but even just a slightly bigger float would have this number in its range.
Why should I be grateful for the time-wasting horseshit you people have foisted on the world? How many decades is it going to take you to get your code up to the bare minimum of reliability?
How many decades do you need to stop being a vapid asshole?
Please don't feed the trolls. Just report them and we'll take care of it. I've already removed this thread so there's no reason to keep going.
&gt; his framing this as a Lisp vs. Python thing is rubbish. Most such comparisons are very weak, being [non-falsifiable](https://en.wikipedia.org/wiki/Falsifiability). The least weak of them happen under very carefully controlled conditions, usually simultaneously.
any example of good (and maybe large) lisp codebase ?
here is the list of project that use libuv https://github.com/libuv/libuv/wiki/Projects-that-use-libuv
Our goal is use the scheme in engineering. first, it must stable, as a commercial impl, chez is stable. seconde, we find some who face to r7rs large, something more engineering. Chez do the best for supporting r6rs, for now... third, easily c language ffi. the world of scheme has not many librairies. But C has... So if we want to use scheme in engineering, a better C ffi is very important. at last, Chez is very fast (except Bignum)
When in the repl bufferr, do C-h v slime-repl-input-history
It's subjective, but here is what comes to mind: * The code in PAIP (and the Norvig/Pitman style guide should be thoroughly internalized); * The code in AMOP (closette); * Older libraries like iterate, screamer, series, some of the code in the CMU AI Repository; * OpenGenera2 code; * Joe Marshall's repository with gigamos/kmachine/lambda code. * Likely the code of your Lisp implementation of choice (I use SBCL for a while now). * Libraries like alexandria, arnesi, cffi, cxml and friends, ironclad, iolib, cl-opengl, mgl, lparallel, fset, yaclml, vecto, filtered-functions, contextl, mcclim; * Pascal J. Bourguignon's informatimago codebase. There are many more, and the list is biased towards the "older" libraries, but I think it's an adequate answer. Unfortunately many big systems are proprietary. Somewhat recently, codebases like quux and emotiq became available.
Nice, thank you. 
Basically my dream job is to work on a team of lisp coders. If I ever get there though, this we'll be awesome!
I, too, moved to a "hybrid" way of using Quicklisp. I cloned the git repositories for the libraries I use into `~/quicklisp/third-party`. I wrote [ql-gitify](https://gist.github.com/death/2fb6218858c6212ebea052f2e3d4f0b3) to help do that. It's been a while, but I think you should first clone the `quicklisp-projects` repository into that directory.
* open music * acl2 * maxima
Thanks!
Nice. Gonna wait a bit before ranting about the lack of docs.
&gt;Another post was removed with a similar topic Yes, and let's please have this discussion without goading each other into personal attacks and other histrionics.
Yeah, I mean, it helps that this post doesn't claim two major lisp implementations are broken. I'm interested in it as well, so I'm happy this post exists
The best way to familiarize yourself with the language is using it and reading about it from multiple sources. Different people hold different viewpoints and have different experiences with the same thing
SBCL doesn't really use "only 4GB of 8GB". That will happen if you produce that much garbage. Which would be a problem for a game either way. So if your game has 8GB gigabyte of assets that are always there and not modified, then it won't need 16GB of memory. Only the "live" consed/collected set might require more memory. That's the idea behind a generational collector. But there are always ways to defeat a garbage collection scheme.
Ahh I was going off of the previous posts benchmarks (?) (that, and my knowledge of how GCs work is limited to the type that requires two banks of memory.) So you are saying that, in SBCL, if I were to allocate everything up front, and being careful to not cons _anything_ in the main game loop, then I could use (almost) the full 8/8 GB of memory without much problem?
It would depend on the actual code, but yes, that should be possible. And you should avoid consing in the game loop anyway.
CAPI doesn't work outside of LW, so if you want to create free software with it – you can't. If LW goes out of business, then you have no ability to maintain your software or port it to other platforms either. CLIM on the other hand has a specification and a free implementation. If you have time you may even write your own implementation of it or to fork one of the existing ones. As of the llok – you may devote your time to help with improving CLIM's look. On the other hand CAPI is convenient way of writing graphical applications and works very well in its domain (that is propietary applications). Many people seem to be very pleased with it.
Decades ago I wrote Lisp in the Turbo Pascal editor. I incremented at each open parenthesis, and decremented at each close parenthesis, and if I didn't get zero I knew they weren't matched ` (DEFINE EXPT 1 (λ (X N) 2 3 2 (COND ((= N 0) 1) 3 45 4 3 (ELSE 4 (* X (EXPT X (- n 1))))))) 5 6 7 6543210 `
can this job be done remotely?
http://www.paulgraham.com/carl.html It is possible to load a chunk of data into memory and access it out of reach of the GC. This can be useful when working with the graphics card requires the data be laid out a certain way.
CAPI | CLIM (Franz) | CLIM (Lispworks) | McCLIM ---------|----------|----------|---------- A1 | B1 | C1 A2 | B2 | C2
Sounds a really interesting problem the one you are tackling. Good luck. 
Going in the opposite direction, data literals and general destructuring are extremely pleasant to use in clj macros. I tend to miss that when working in cl, although I manage with a bit of additional boiler plate.
&gt; 8GB gigabyte of assets that are always there and not modified So my other question would be if I have more than 8 GB of assets, that I needed to stream in and out to reduce loading times. Each asset is a different size, and assets are of different types: songs, sound effects, models, textures. The number of each type of asset is not fixed. I could use a memory pooling scheme to avoid creating garbage? Perhaps it would be a giant vector of bytes, and a table for looking up assets, since I don't know the size or number of each different type of asset. Or maybe at that point it would be best to interface C code that streams assets in/out. This question has been sitting in the back of my mind for awhile. The other post called it to mind, and it was too bad that it was so vulgar. I don't have this problem yet -- just dabbling in game dev, and working alone. I'd love to know that I can scale up what I am doing at some point, and I'm looking for ways to work *with* the garbage collector, because it is a very practical tool.
That's very helpful to know, thank you! :)
You have to talk to the people who actually do games, like in #lispgames
Thanks! If you know of anyone, please share!
do you allow working remotely? (i'd like to stay on my city, initially)
Interesting. Do you have some product already?
&gt; Not what I would call exemplary Lisp code. What would you like to see improved?
I'm running it on OpenBSD and it works great. Same on FreeBSD.
No, we’re still in R&amp;D. We have a proof of concept demo.
I run it both on Windows and Linux. It gives an instability warning on Windows, but I haven't encountered any issues yet 
Nothing? This is just 3K lines of unmaintained code hacked in 2005 that doesn't have much technical or didactic value. The situation might have been different if instead they'd write libraries and use them for the application, or if they had anything worthy of extraction to such libraries. But it's only a "use-case" code, for library writers to consider.
If you are interested in testing CAPI, you could have a look at (this cookbook)[https://t-cool.github.io/capi-cookbook/index.html].
This is the original, in English: http://capi.plasticki.com
Thank you. People that help and share at such high level as you have been doing over so many years are such a priceless asset to all Lispers. The amount of your help and its standard, here and elsewhere, are truly outstanding. Many sincere thanks.
Good, no question. Even on my Raspberry Pis I can always fire up SBCL, with SLIME and whatnot. Nice little Lisp machine, there. Windows is a bit behind, sometimes. It is so different that it breaks easily on Unix-tested changes, and Unix people often don't have Windows around to test, or suffer from that insane Windows usage scheme that doesn't allow you to just ssh into a lightly extended Windows machine and compile SBCL.
It is unclear to me what those 4 GB are supposed to be. Lisp heap? Mapped data? Code? It sounds like you are asking for the program to waste memory. As for the other question: yes if you stop consing (allocating memory, only using preallocated memory) then you won't GC either. That is entirely realistic, QPX ran that way for a while. You have, on the other hand, not posted enough information to figure whether you will have a GC problem in the first place.
&gt;Recently, we regularly see people (usually also within the Lisp community) who have the perfect explanation as to why Lisp is not as popular as it deserves to be, namely that there is not even a single free implementation that works on all operating systems, and that has all the required libraries that languages like Python and Ruby have for web programming, etc Since today we do have many multi-platforms free implementations, i guess this article is old. But I agree with Robert Strandh's final statement: &gt;I mostly don't care how popular Lisp is. I am not using Lisp in order to score better in a popularity contest. I am using Lisp because it is the best programming language I know for the kind of programs I write. I don't think there is anything particularly or seriously wrong with Lisp. It's almost like a manifesto. Well said. 
&gt;&gt; I don't think there is anything particularly or seriously wrong with LISP. Nothing is particularly or seriously wrong if you leave the criterion of the symptom ambiguous or undefined -- 'I do not think ...' and earlier "I do not care ..." ensures that no one can attack it. Such statement is nothing but a stonewalling attitude. -- Sorry that I have developed a resentment for such statements.
&gt; I got into the habit of classifying typical code in different languages this way: &gt; writable (perl can be here) &gt; readable (most languages when used "correctly") &gt; changeable (only Lisp right now, at least if you want performance, too) I find the classification questionable, mostly due to its subjective nature. Even with changeable, any language can be extended with libraries or macros. 
&gt; It is unclear to me what those 4 GB are supposed to be. Lisp heap? Mapped data? Code? Mostly assets: models, textures, music, sound, level data, character data. Preferably in the lisp heap. &gt; It sounds like you are asking for the program to waste memory. How? Games can easily have gigabytes of assets, the more that can be stored in memory the shorter the load times. I think that is a good use of memory. &gt; You have, on the other hand, not posted enough information to figure whether you will have a GC problem in the first place. stassats answered my question about whether the SBCL GC limited the amount of memory availaible just by its nature, as some GCs do. I feel as though my question was answered, and so I also feel as though my question was adequate. I appreciate the feedback: when I have other questions I will try to provide more specific information.
One of the nice parts is that CAPI looks mostly native. Running the unchanged CAPI Cookbook example source then looks this: [CAPI Cookbook on Macos 10.13 with LispWorks 7.1](http://lispm.de/images/capi-cookbook-modern.png). As you can see the example window now has the flatter design, newer fonts and the scrollbars are on demand (the Mac has a trackpad with gestures). Windows now can be resized on all edges, so the handle on the lower right edge is gone.
Any language can be extended with *libraries*. Very few that nobody would count as a "Lisp" have meaningful *macros*.
Yes, when I work on macos, ccl is sweeter for sure. Also, sometimes we have Lisp apps on Solaris/Illumos, and there ccl seems to has less problems (at least according to our illumos guys).
Thank you, I was not expecting such an up-to-date status. It is probably time for me to get a license. I know CLIM is only available on Professional license. I wonder if CAPI is available on HobbyDV license. Somewhere you were mentioning Lispworks 7.1's update as introducing some new nice features. I have been looking for that snippet everywhere, but I could not find it. Was it Twitter, or perhaps a comment on StackExchange? Thanks again.
Thank you.
Actually, double checked and remote is OK!
CV sent!!
&gt; As for LISP, while nothing wrong, certainly isn't perfect, room for discussion? For imperative programming and OOP, with dynamic typing, it gets close to perfect... I can't think of any major fault, perhaps the lack of package name renaming, maybe. If you want to use it for pure functional programming with type inference, or think static type checks are the only way of achieving calmness, then look elsewhere (although Qi is a pure functional lang built on top of CL.) 
For what it's worth, i run SBCL under Windows with no problems yet. 
1) nice username 2) some languages are better at some things than others, which is why it's good that there are multiple programming languages. Therefore, usually I dislike `langX vs langY` style arguments, since most of the time they don't make sense anyway
Very cool, thank you.
[Main page](https://lm-3.github.io/)
1.3.10 (yes, an old one)
The usim emulator in this project is tied to X11 and has dropped support for OSX/Windows through SDL which is available in the original release: http://www.unlambda.com/cadr/ Not sure why they did that as SDL is far superior to raw X11 but it won't go down well for OSX folks.
The usim emulator in this project is tied to X11 and has dropped support for OSX/Windows through SDL which is available in the original release: http://www.unlambda.com/cadr/ Not sure why they did that as SDL is far superior to raw X11 but it won't go down well for OSX folks since XQuartz is garbage.
Simple and easy-to-understand implementation! Tail call optimization in Schemy.cs is also good. See also my Lisp implementation (Arcadia): https://github.com/kimtg/arcadia
This is fascinating. Would it be possible to configure a field-programmable gate array (FPGA) to match the CADR configuration?
^^ ;)
Cool stuff. I would trade the mess we're in for a future based on Lisp machines any day. Didn't have a speaker nearby so I ran the whole thing through the Tube's automagic subtitle-thingy, which helped put the video into context. I just wish they removed the stupid suit with a bad wig job, he ruins the atmosphere for me.
So you're saying the FPGA performance would be worse than the software emulation? My line of thinking was to use the FPGA reproduction as a prototype to then create an ASIC with the CADR interface.
&gt; So you're saying the FPGA performance would be worse than the software emulation? A stock Zen based system with DDR4 has a lot of bandwidth, and I would assume that a Lisp VM would not be CPU-bottlenecked. It's hard to beat price/peformance here. There have been some projects https://news.ycombinator.com/item?id=8340283 but they're probably not motivated by reaching high performance. You can probably do something small with FPGA and SRAM that would be fast, but it would not be cheap, and rather tiny in terms of memory space.
lovely
Thanks for the detailed reply!
6pm UTC happens when this comment is 19 hours and 54 minutes old. You can find the live countdown here: https://countle.com/5I170435CZ --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Also... Comkey 816 style phone. My dad's house is still wired with them from the 70s. Cool!
Did the Symbolics machine have sound hardware?
Nice. 
The first music from a computer I ever heard was "Ripple" by the Grateful Dead played on the Symbolics 3650 console. I was accustomed to thinking of recorded music coming from the motion of a stylus in a groove or magnetic particles being dragged past a playback head, or pits in a CD. I felt the music was disembodied, somehow. The music was being sent to the speaker from memory without analog movement. The music came on a cart tape. I wonder what format it was in. Probably raw? We were using $180,000 worth of computer and software to listen to the Grateful Dead! This was in 1988 when the memory boards were 18 inches square.
Thanks! This is an excellent version of the Common Lisp Standard Draft PDF. It really helps makes sense of the document, and it's now much easier to navigate. I had to click on the Bookmarks ribbon icon on the left side of the MS Windows version of Adobe Acrobat Reader to see sidebar contents. Another way would be to select the View&gt;Show/Hide&gt;Navigation Panes&gt;Bookmarks menu item. One could also search the PDF using the Ctrl+Shift+f key-combo, then enter search keywords to build on-the-fly indexes of search results consisting of search keywords throughout the PDF listed along with neighboring text on either side of the keywords to help give context so that one can zero in on the page of interest. If one happened to know the Common Lisp keyword to look for, one could enter something like "Syntax: digit-char" (without the quotes) when search with the Ctrl+Shift+f key-combo. That would show the exact page where the "digit-char" function was. The same could be done with any function, macro...etc., using the "Syntax: keyword" search pattern (without the quotes).
regarding ECL: why :spawn communication style doesn't work for you? you may try this patch for swank to make :fd-handler work: https://github.com/slime/slime/pull/412 (see comments).
This sounds like an autowrap bug. File an issue at https://github.com/rpav/cl-autowrap because that is an obvious type error.
Ask /u/lispm, his personal website is hosted on a ODROID-XU using LispWorks. He might have some advice for RPi.
hop on irc
I've had good luck with CCL on Arm, but I haven't used CL-SDL2 on Arm (but I have used CL-OPENGL and a number of other CFFI things). But, I'm not sure what's up in your case.
Well my bad, found the trick of changing the communication style on internet and didn't bother to check the doc if other styles where available. It seems to work, but I have errors `## is not a valid index into the object "_"` where ## is a number, that keep popping when I edit my remote file using tramp on emacs ; I think it is the auto completion. 
Yep, done !
This is very likely the same issue as (https://gitlab.com/embeddable-common-lisp/ecl/issues/406).
How do you suppose it's going to work? Wait, don't tell me "With a semicolon!" You are trying to modify lisp without really understanding it. Surprisingly, that's quite common.
The good news is that you can have Lisp almost entirely without parens. The bad news is that Dylan is practically a dead language.
This more or less what I was thinking, but u/stassats raises a good point about terminating expressions in regular sources that I hadn't thought enough about -- I was thinking newlines like ML, but then multiline expressions could become problematic. 
I was just reading about Dylan. A (somewhat) elegant artifact from a dead civilization. 
Dylan was too far ahead of its own time but I worry it's behind ours. A Baghdad Battery among programming languages.
Interlisp-D had something close to what you want, I think. You could type (define n 10) in the REPL and it would work like any Lisp. You could also type define (n 10) and it would do the same thing. That REPL was aggressively helpful - it would only present a form to the underlying reader when it was complete. The reader would kick off when you typed the final closing paren of either form - no newline required.
Would you feel better if n were quoted, as in elisp (set 'n 10)
This is evalquote. Lisp 1.5 also had evalquote in the REPL before Interlisp: CONS(A B) was the equivalent of (cons 'a 'b) in MacLisp and Common Lisp. See [The Evolution of Lisp](https://www.dreamsongs.com/Files/Hopl2.pdf). 
Weirdly, a little.
I also find any symbol such as parenthesis, quote, backtick etc visually noisy. It's not a huge issue, but I prefer whitespace over special characters. So, Dylan's or Julia's syntax is preferable to say that of scheme or elisp. But as an emacs user, I have no hard feeling, lisp is lisp.
Not sure what you mean, but http://shenlanguage.org/ ? also https://github.com/malisper/Clamp CL with Arc's terse syntax.
If it's aesthetically displeasing, use an editor that let's you color those parens in an almost-background color (i.e. treat the problem at the same - aesthetical - level) :P
don't you think it's simpler to have just one kind of application rules instead of two? 
Came here to say this. Instead I gave you an updoot. 
As a physicist I learned how to write mathematical syntax which is filled with a mix of infix, prefix and postfix operators long before I started programming so in terms of humans reading and writing the code I’d say no that’s a bit like asking "isn’t it simpler to have one eye instead of two?" Sure, but sometimes it’s useful to have two eyes and I don’t really notice it being much of a burden. In terms of macros, infix and prostfix operators *would* be a burden in a language like Julia except an expression like ``` x + y ``` Lowers to the `Expr` object which is ordered like an s-expression ie. ``` ex = :(x + 2) ``` And now if I call `ex.args` I get the following list ``` [:+, :x, 2] ``` Where the colon denotes quoting. So all expressions lower to prefix notation. 
&gt; just a little displeasing aesthetically in that something inside parens modifying something not contained within When updating a global environment, it's a side effect . Think of `(setf ...)` (or rather `(set! ...)` since you seem to be a Schemer.) When using internal `define` in Scheme, it could help you to think of the nested `(define ...)` not as separate forms/expressions of their own, but as syntactic features of the containing (implicit) `begin`. In code like (begin (define n 10) (define m 20) (+ n m)) think of the `define`s as *part of the `begin`*. The `begin` doesn't define anything outside that begin, it turns into a `letrec` (I think, not a regular Schemer here). You could observe that an isolated identifier that's not in final position within an (implicit) begin has no effect and could be re-purposed for parenthesis-free syntax: (begin n 10 m 20 (+ n m)) Ron Garret has done this for Common Lisp (https://github.com/rongarret/ergolib, the `bb` macro). People didn't flock to it... 
What is the idea of the project?
Great analogy for my interest in languages.
C interop is even better
I had a bad situation where I somehow managed to rack up like 1100 tabs or so. This was a hindrance until Firefox 57 because it made starting sessions like that much faster. However, I also lost out on one of my favorite addons (Storybook Pro). I'm trying to minimally replicate what that addon gave me in terms of being able to categorize sets of tabs. I have plans to do more with it (like HTML caching among other things) but that will come with time. Right now i'm just evalling the lisp code in org-mode, not as an extension. The webextension portion is literally just a few lines of JavaScript that gets the current tab set and saves it as json. Then I run copy(tabsData) in the webextension debugger to copy it to my clipboard, which I copy into a json file which my elisp code loads into json.el, and I do an immediate-mode insert procedure in an iterator. I'm kind of a lisp "noob" but I've been casually lisping for a few years, only just recently kind of actually trying to do something useful with it haha.
&gt;As a physicist I learned how to write mathematical syntax which is filled with a mix of infix, prefix and postfix operators long before I started programming almost the same for me (even spent 3 years studying theoretical physics and electronics at university), but then I found lisp and forth. Never looked back for infix notation. You have to know two application principles instead of one, you have to remember priorities, and, LBNL, it makes things inconsistent and less composable &gt;so in terms of humans reading and writing the code I’d say no that’s a bit like asking "isn’t it simpler to have one eye instead of two?" Sure, but sometimes it’s useful to have two eyes and I don’t really notice it being much of a burden. There are no pros of infix notation at all. And, definitely, one shouldn't mix different notations in one language. Yes, we (sadly, because for me it looks like a silly historical coincidence) have all of them mixed in Maths, but do we really have to? 
I'd be doing everyone a disservice if I didn't plug Elixir here too. Like Julia it's not a Lisp in the parenthesized, homoiconic sense, but it's got extremely elegant access to its ASTs and has almost Clojure-like facilities for metaprogramming. Additionally, it's very much a functional language as its Erlang heritage mandates.
&gt; The good news is that you can have Lisp almost entirely without parens. This is good news? Aesthetics are subjective. Parentheses allow for much better structural/contextual editing among other benefits.
I wasn't claiming it was good news for you. It seemed like what the OP was looking for.
Just started with Haskell. TH Haskell (like macros for Haskell) seems like such a massive pain compared to the ease of backquoted macros in Common Lisp. Too bad that all the lispy-haskell projects I have found are failed.
Just a note, Julia actually is homoiconic in the sense that Julia code is stored in the `Expr` data type and one can use Julia functions and macros to manipulate it just as one would with any other datatype. __ Note: this statement is obviously dependent on your definition of homoiconic. It’s a squishy term and can be defined in such a way that Julia is excluded but I think Julia captures at least all the important parts of being homoiconic. 
Eliminating the outer (file top-level) parens gives you pretty much ML (with some exceptions).
In the sense you're thinking, yes, Elixir is also homoiconic, but this was actually a huge argument early in the history of Elixir, because it's not true homoiconicity. That is to say that neither Elixir nor Julia is written as ASTs (the way real Lisp dialects are).
Ah, cool. I didn’t know this about Elixir. 
Note that Lisp is also not written as an AST. Lisp s-expressions are not an AST (abstract syntax tree) - they are a general hierarchical data structure (nested lists with objects like numbers, symbols, strings). Lisp s-expressions don't represent syntactical information besides some hierarchy information. They are actually more like a hierarchical tokenizer representation.
&gt;but the mental overhead of needing to know that there are multiple ways to apply a function is negligible. Maybe, but don't forget about priorities and composition 
Fair distinction. I guess I'd still argue that s-expressions are closer to "true" homoiconicity than a language which just exposes its ASTs.
I agree, though generally I'm not happy with the term 'homoiconicity'.
&gt; could be re-purposed for parenthesis-free syntax Just like it was re-purposed for a "structured-control-free" syntax in *tagbody*. :) 
It took me time ... but I finally have managed a (ql:quickload :magicl) :-) ... is there some documentation attached to it ? Or should I go through the code ? For example it seems there are only high level complex constructors (make-complex-matrix and nothing such as (make-double-matrix I have seen some (make-matrix function but I am stuck with the :data type 
`"# #"` is a *literal* string. Modifying literals in Common Lisp is undefined behavior. Variable bindings have nothing to do with that. `(defvar *foo* "bar")` defines a variable named `*foo*` but the *value* bound to that variable is an *immutable* string `"foo"`. Use `(copy-seq "foo")` to create mutable strings.
Oh I see, thanks!
Hi /u/PuercoPop (Pop Swine) I don't usually have time for watching full videos, would you please tell us in short and in advance: - how full-featured is this Lisp? - which is the target machine? - which language is the compiler implemented in? - is it including GC? (I ask because many such posts show what is really a very simplified Lisp with no GC at all) - is it compiling directly to machine lang, or is it using a bytecode-to-JIT strategy? Kind regards, Your friend in lisp in the year of the npm plague, defunky. 
Hi Flavio 👋, it is David Vázquez's talk about JSCL, a project we've talked about. &gt; how full-featured is this Lisp? Far from ANSI CL compatibility. But it has structs and the loop macro. &gt; which is the target machine? The target _platforms_ are node and the browser. It comes with a REPL for both environments. &gt; which language is the compiler implemented in? The subset of Common Lisp that the compiler supports. To ensure this is the case JSCL first loads the compiler in host Lisp implementation of your choice (say SBCL or CCL) and then compiles the compiler along with the run-time with that compiler. &gt; is it including GC? (I ask because many such posts show what is really a very simplified Lisp with no GC at all) No, it relies on the target platform's GC. &gt; is it compiling directly to machine lang, or is it using a bytecode-to-JIT strategy? To pre ES6 JavaScript. It compiles to an intermediate representation that is close the JS semantics. For example there is `(selfcall ...&lt;body&gt;)` which wrapped the body in an immediately invoked function. Something that used to be idiomatic in the JS community but no longer is with the advent of ES6 modules and babel. Then from this intermediate representation JS is emitted (the code that does so lives in compiler/codegen.lisp)
&gt;JSCL Thanks!! 
Shipped: [TXR 191](http://www.kylheku.com/cgit/txr/) 
Fun fact, [Symbolics.com was the first .com domain registered, back in March 1985](https://en.wikipedia.org/wiki/List_of_the_oldest_currently_registered_Internet_domain_names)
Interesting. I was thinking about my own habitual pursuit for arts/disciplines that are popularly equated with: * "ultimate" expressions of truth, * some form of enlightenment conferred by practice, or * meta-level concerns in relation to other discplines in their category My list started with: Lisp, [Systema](https://en.wikipedia.org/wiki/Systema), and [Dzogchen](https://en.wikipedia.org/wiki/Dzogchen).
[UCB Logo](http://people.eecs.berkeley.edu/~bh/logo.html)
An interesting paper. I wouldn't say I disagree with it, but I find it interesting that someone could arrive at a perspective so different from my own. If such a thing as "classical programming" is possible, surely that's Common Lisp -- old, complex, formally codified, with an idiosyncratic vocabulary and a community invested in historical continuity.
Same here, though a neophyte in both. Found Dzogchen through Meaningness. This thread reminds me of a couple points made in this article: http://www.shenlanguage.org/lambdassociates/htdocs/blog/bipolar.htm
Wow that's a list of things I have been doing for years. I have to read this paper.
I'm trying to imagine a Dzogchen version of this story: &gt; In the days when Sussman was a novice, Minsky once came to him as he sat hacking at the PDP-6. "What are you doing?" asked Minsky. "I am training a randomly wired neural net to play Tic-tac-toe," Sussman replied. "Why is the net wired randomly?" asked Minsky. "I do not want it to have any preconceptions of how to play," Sussman said. Minsky then shut his eyes. "Why do you close your eyes?" Sussman asked his teacher. "So that the room will be empty." At that moment, Sussman was enlightened. Something, something. . . unparalleled wondrous diamond vehicle of luminous mind resting in the state of primordially self-perfected wisdom?
Compiler: $ time txr day5-2.tlo 381680 real 0m0.110s user 0m0.104s sys 0m0.004s 
I think `(assert (equal (something 42) "?"))` would work better.
The third argument to the ASSERT macro is a list of places that are assigned to if you decide to continue after an assertion failure. This mechanism makes ASSERT rather heavyweight (setting up restarts and such), so SBCL internally uses something it calls AVER which does not admit continuing after a failure.
This fixed it perfectly and matches my coding style, thanks ~
google arrow macros. there is a CL version
Use cl-arrows system. With it, your code from example will be: ``` (-&lt;&gt; (narwhal y n) (hibou x &lt;&gt; z) (junction foo bar) (function control)) ```
At first glance, I would try to use Lisp macros directly, i.e., `macro` is `defmacro`, and you would just invoke them during transpilation (using `macroexpand`). Then it doesn't matter what the internal representation of the macro body is.
That seems like a great way to obfuscate code.
For me, arrow macro is specially useful, when I need to make a few subsequent getf call to take a value from a nested data structure, received from some API. 
That's why macros should be used judiciously, have sensible syntax, and preferably not change fundamental properties of the language. Unless there's no intention of sharing the code, then anything goes. 
The arrow macros may be obfuscatory in CL, but they're not exactly unheard of in the Lisp community at large. In Clojure that would be reasonably standard style. Personally I find they're very helpful for linearizing heavily nested code, something which I find greatly helps readability, and the rules for how they work are more than simple enough to learn in a few minutes.
&gt; First you compile nokolisp.asm to nokolisp.exe. Then you do (in (open 'boot.lsp)), then you start (*main-loop*), which errors and recompiles and then you (make-exe). And then you have noko.exe. &gt; There was some elegant way to do all this shit, but I cant remember what it was.
it is unreasonable to expect common lisp community to follow clojure coding standards, but there's a lot of people like you who do. there are projects coming out now that are very obviously written by clojure programmers and have jaring style, that are implicitly rejected by the community because the coding style is so alien. it is then a fair warning to let a prospective developer know that the coding style he's about to adopt is going to make it hard for experienced developers to contribute to his project, reduce adoption, and potentially be met with hostility.
the meme that x11 is bad is fashionable, but also harmful, because it fails to enumarte use cases. x11 is the only currently maintained (perhaps you can also include plan9's rio) networked windowing system. you can't just stream a gtk3 firefox over ssh with its client rendered antialiased fonts and gradients, but traditional xlib apps, particularly when written with network in mind, work great. more importantly there's no equivalent system supporting this use-case, and nobody's attempting to design a replacement (we have "web" instead). an established network protocol also means that you can write native bindings in whatever language you choose without having to use foreign function calls to C. this is important and can't be done with any other windowing system! that means that a lisp machine can use own implementation of xlib ("clx") and talk to a thin x11 client over the network to do a rich display. this is exactly what you can do with symbolics genera. you can for example connect to genera over telnet, issue a Start X Screen command, and get your symbolics desktop environment, but rendered using X instead, transparently. CADR is the only lisp machine that has full stack source code and schematics available. opengenera that's floating around is not complete enough to be able to recompile/modify the whole thing. system 7x which you can boot right now is anemic compared to genera, doesn't for example support complete common lisp, but there's system 99 sources, that eventually we'll be able to load in usim. once that is done, it would make sense to augment internal renderer with a clx equivalent, the way genera does it. this way you can get a CADR terminal remotely from an fpga. from that perspective, SDL support, explicit Windows support, etc. that is "end user" support is simply not something the project is interested in right now. people who simply want to play with CADR can simply use Brad's original, which both works and is feature complete.
um... looks to me like you defined a variable, *foo*, whose value is the string "bar" (not "foo"). 
My guess would be that the bindimgs simply haven't been updated yet to support Qt5 . Shoot the author an e-mail or write a ticket in the issue tracker kindly asking when it's going to support Qt5. Best way to get an answer.
Because nobody has made it support Qt 5.
(csv-parser:do-csv-file ((fields num-fields) file :limit 1 :skip-lines 4)) will give you row 5.
Ah, thanks, Author and/or core contributor of CommonQt, stassats.
These pipe macros are mostly coming from outside Lisp into the language. But that's not necessary bad. Keep in mind: in Lisp control structures are not so much defined by a language designer, but every user can do that. Thus also every user has an opinion about it and there are communities with their own practice, which evolved out of years of experimentation. In Lisp many users are not so much dependent on a serial programming style, since they learned to work with tree-like code.
But is it just a matter of updating some bindings or is there a bigger obstacle than that? If it's just some bindings, is it because Qt5 has no real advantages over Qt4, so it's not worth even a small amount of work to update it?
To the OP: In 2018 the easiest way to get started is to download and install [Portacle](https://portacle.github.io/), no other step required -- no configuration, no installing more tools, no need to install IDE or compiler or anything. Easier than the steps on the article -- which will only give you q Lisp REPL.
Since I did port my tool ((EQL)[https://gitlab.com/eql], ECL only) from Qt4 to Qt5, I have some experience to share: * if you only use traditional `QWidget` stuff, there is not much of a difference (Qt4 is still fine there) * if you use `QML`, there is a BIG difference, since the current `QtQuick2` (the successor of `QtQuick1`) has been almost completely rewritten, and many features that you want/need in `QML` are only available with `QtQuick2` (and a recent Qt5, like Qt5.10) The Qt community is split over `QML` usage (it can be used on the desktop, too). Personally I almost hated it (many years ago), but I have come to love it now (but mostly referring to mobile apps). P.S. Please don't spell it QT: for Qt users, this is like writing LISP instead of Lisp.
You can be the one to perform that work and I'll happily apply any patches.
Thanks for this. I'm messing about with csv-parser, and using code above with no parameter changes other than replacing "file" with the filename in quotes, it's just returning Nil. The CSV is in the directory I'm working in as is csv-parser.lisp and I've used "test3.csv", "&lt;full file path&gt;\\test3.csv", and #P"test3.csv". I know this is bonehead stuff, apologies. 
This doesn't help? https://static.loomcom.com/genera/genera-install.html#org1c2b3f9
So true. My friend come to me asking me to teach him CL. I gave him Poratacle and it's works great.
6pm UTC happens when this comment is 3 hours and 50 minutes old. You can find the live countdown here: https://countle.com/_Nca178562 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
I tried to install it on a machine running Ubuntu Mate 16.04 but I could not et Genera running. After the installation process get: $ ./genera genera (cold_load_init): using Xlib with xcb Illegal instruction (core dumped) 
I'd love to see more good docs but I feel this one falls rather short. Recommending people use an editor without any real integration and without quicklisp is not giving any kind of a representative view on the language.
I really enjoy the usual functional notation. However I agree that the pipe notation is quite nice. My only objection with the above is the Perl-like syntax: `-&lt;&gt;` is a little bit cryptic and `&lt;&gt;` is an automatic, magic variable. Except for mathematics, CL tends to favor (1) textual names and (2) explicit bindings. (defmacro with-nested-calls ((next-var) &amp;body calls) (if (cdr calls) `(let ((,next-var (with-nested-calls (,next-var) ,@(rest calls)))) ,(first calls)) (car calls))) `&lt;&gt;` as a placeholder is fine, you could also use `_` or `||` : (with-nested-calls (||) (narwhal y n ||) (hibou x || z) (junction foo bar ||) (control)) With explicit bindings, you can also nest from multiple pipes: (with-nested-calls (&lt;&gt;) (with-nested-calls (_) (list _ &lt;&gt;) (loop for i below _ collect i) (random 10)) (random 100)) Gives for example `((0 1 2) 43)`. The above is surely a huge selling point. 
Nice. Hopefully the videos are up soon as well. Lots of interesting talks this years.
This is fantastic, the PDF is a wealth of knowledge. I'm right now enjoying the details on the CLASP implementation, page 59.
I'm a bit confused... what is this?
Omg Sacha Chua is speaking! Her work in the emacs community is fantastic.
Already spoke :)
Here is a possible approach, using TXR Lisp, in which we can write a macro called `autolet` without having to implement a full blown code walker. `autolet` automatically inserts a `let` around your code which defines every free variable in that code. This is considered in context; a variable is not free if that code occurs in a broader context where the variable has a lexical binding. Basic demo: 1&gt; (autolet (set x 42) (inc x) (push x y) (list z y)) (nil (43)) Expansion: 2&gt; (sys:expand '(autolet (set x 42) (inc x) (push x y) (list z y))) (let (z y x) (sys:setq x 42) (sys:setq x (succ x)) (sys:setq y (cons x y)) (list z y)) Now suppose we make `z` a bound variable, and also introduce another variable `w` that is also bound, but inside the form. In both these cases, `autolet` correctly ignores the variable: 3&gt; (let ((z 42)) (autolet (set x 42) (inc x) (push x y) (let ((w 84)) (list w z y)))) (84 42 (43)) In the expansion we see that only `x` and `y` are identified and treated: 4&gt; (sys:expand '(let ((z 42)) (autolet (set x 42) (inc x) (push x y) (let ((w 84)) (list w z y))))) (let ((z 42)) (let (y x) (sys:setq x 42) (sys:setq x (succ x)) (sys:setq y (cons x y)) (let ((w 84)) (list w z y)))) The `autolet` macro is merely this: (defmacro autolet (:env macenv . exprs) (let ((expr ^(progn ,*exprs))) (tree-bind (expan free-vars free-funs bound-vars bound-funs) (sys:expand-with-free-refs expr macenv) ^(let ,free-vars ,expr)))) 
Sacha was not a speaker, just on the review committee. 
Late response, but there are some tests and examples included in the source code. The high level interface is pretty awful right now. Hope that we can get help designing a better one!
any idea what mode he's using to show the whitespace under cursor and in the selected region? it looks a lot better than vanilla whitespace mode
It's actually is just whitespace mode but I customized the colors to be very dark grey. I think it looks like it's only in the highlighted region a most of the time the video compression is just optimizing it away :)
Fantastic idea. Thanks. 
Fantastic idea. Thanks. 
Assuming the strstr() that blows up happens on CCL too, did you try debugging it there (break on it) and seeing what the actual string is? It might illuminate what that string is and where it's set. 
&gt; Another way to quickly bypass this issue would be to map the NULL page but that's no longer possible on osx afaik. That's an extremely bad idea.
http://griefandmourning.com/wp-content/uploads/2013/12/Perspective.jpg 
I can't help but notice stassats being a paragon of indifference / veiled hostility in that exchange. This is not an isolated incident to everyone who visits #sbcl, it's his standard modus operandi. I'm wondering how many people get turned off from contributing by having to face attitudes like his. Sometimes I wish they would keep him locked in the dungeon, coding away, like the gimp in Pulp Fiction.
This is not what this thread is for. The jam is about making cool things in a cool family of languages. If you do have issues please raise it with their team.
You should probably consider not writing hostile posts yourself if you want to preach about how other people shouldn't be hostile.
This is not what this thread is for. Please take this up elsewhere.
That is true, I'm indifferent and hostile towards Apple breaking stuff. 
This is not what this thread is for. Your attitude is well known and if you folks need to argue about it then please, do it on another thread
This is a thread to bash Apple. 
Good catch. thanks
Is this kind of like a blend of shell and Lisp similar to Eshell?
What changes did you make?
The `ct2` macro receives the symbol `*L*` itself as an argument, not the symbol's value. Your `(mapcar (lambda ...) m)` is equivalent to `(mapcar (lambda ..) '*L*)`, because the `m` variable holds the list itself.
Couldn’t he just have used ,m in the macro definition body’s mapcar?
I swapped the order of some keys. Here is the diff: $ diff .Xmodmap .Xmodmap.orig 41,42c41,42 &lt; keycode 48 = apostrophe quotedbl dead_acute dead_diaeresis apostrophe quotedbl dead_acute dead_diaeresis &lt; keycode 49 = grave asciitilde dead_grave dead_tilde grave asciitilde dead_grave dead_tilde --- &gt; keycode 48 = dead_acute dead_diaeresis apostrophe quotedbl apostrophe quotedbl dead_acute dead_diaeresis &gt; keycode 49 = dead_grave dead_tilde grave asciitilde grave asciitilde dead_grave dead_tilde I am not sure it is fully functional but the keys " ` ' do work. 
methinks it's more limited than eshell
I think the main problem you have is that the first rule of macros is to use a function if you possibly can. ct2 clearly could have been a function and indeed you've tried to use it as if it were.
Thank you /u/Baggers_. I am looking forward to what you'll come up with.
This can't work. MAPCAR returns a list and + expects zero or more numbers. A list is not a number.
I have the impression that what is expected is (defun ct0 (l) (apply #'+ (mapcar (lambda (x) (count #\. x)) l))) so that when (defparameter *L2* (list (make-array 5 :initial-element #\.)) (make-array 3 :initial-element #\.))) (ct0 *L2*) gives 8 
Don't use APPLY, use REDUCE. With APPLY the lists are limited in length.
Ah yes thank you !! 
Thank you. Good explanation. It makes sense to me after reading this thread.
Thank you. You are 100% right on both counts. The function that does what I wanted ct2 to do is pretty trivial. I didn't mean this to be actual, useful code though (hence my omission of GENSYM), it was more of an academic exercise.
A macro is invoked as the result of the expander encountering a macro form, such as `(mymacro (syntax) (more syntax))`. The expander sees that `mymacro` has a macro definition, and so it retrieves the macro expander function and calls it, **passing it the entire form** as an argument. The expander receives, literally, `(mymacro (syntax) (more syntax))`. At some point (decades ago), Lisp programmers got tired of writing one-argument macro expanders which had to completely analyze the syntax from scratch. They came up with destructuring: defining macro expanders with arguments, such that the syntax gets pulled apart and the constituent pieces of the syntax get put into local variables in the macro expander. E.g. (defmacro my-macro (left-arg right-arg) ...) This definition still produces a one-argument expander function (which we don't see). That function gets the whole form such as `(my-macro (syntax) (more syntax))` and then performs the destructuring, sticking the object `(syntax)` into the `left-arg` variable, and `(more syntax)` into the `right-arg` variable. Plus it will do checks, like there not being enough or too many arguments (destructuring mismatch). The point is, the parameter variables in macro lambda lists get, as their values, the destructured pieces of the syntax of the original form. The job of the macro is syntax transformation: taking pieces of syntax, perhaps analyzing them in some way, and calculating some new replacement syntax for the entire form (perhaps with those pieces just stuck inside it, or perhaps with substantially transformed versions of those pieces).] (You're trying to do a "substantially transformed piece" type thing: the piece of syntax `*L*` is supposed to be looked up as a global variable, and the contents of that then get massaged into something that forms the arguments of a call to the `+` function.)
Counterpoints: REDUCE is more complicated than APPLY. You have to supply an initial value, or else the function has to be callable with zero arguments and that case is supposed to produce the seeding value. APPLY is just "apply these individual arguments, plus this list of additional arguments to this function"'; it's completely transparent. REDUCE treats the function as binary, denying it the opportunity to handle all the arguments at once. For instance, if we have a nice N-ary `matrix-multiply` function and we left-reduce it as a binary function, we may not get the optimal order for decimating the matrices. 
&gt; *It might illuminate what that string is and where it's set.* Not as much as source code. I'm assuming this Apple shit is closed source, otherwise this debugging exercise would take all of five minutes. "Oh, foo-&gt;bar is null! that's set in these two places, which relate to the API calls in these ways. Oops, we aren't doing such and such before such and such and so this isn't being done ..." 
What exactly do you want to compile? Do you have a program written in a .lisp file that you want to execute? Do you mean Common Lisp, or some other lisp dialect?
If you need help with Lisp, you can also try the Brazilian Lisp community. https://lisp.com.br/ seems up to date and they can probably help you better!
What implementation are you using?
This ? https://lispcookbook.github.io/cl-cookbook/scripting.html "building self-contained executables"
Eu falo Portugues e Ingles e entendo o suficiente para te ajudar a traduzir se quiser. O que exatamente voce quer fazer?
I understand. The thing with macros is that they are tricky to get right and won't work if you don't :-) Have you got "On Lisp"? It's *the* book on CL macros and has lots of examples. Including some simple ones at the start where you could read the section, close the book, and then try to implement them yourself. "Let over Lambda" by Doug Hoyt is effectively "On Lisp Volume 2".
Indent using four spaces to preserve your formatting.
How are you measuring this? Are you measuring compile-time or run-time? What makes you think any files are being loaded at all?
Any chance of a 32 bit Windows version?
The macro generates code, it doesn't execute the code. What you're missing is this one character: `
Well I am still struggling with markdown. I was referring to ` (defmacro ct2 (m) `(+ ,@(mapcar #'(lambda (ro) (count #\. ro)) (symbol-value m)))) ` 
I use get\-internal\-real\-time at run time after using compile\-file and loading the fasl file. The only evidence I have that files are being loaded is that it takes 130 ms for the first subwidget and less than 1 ms for the 2nd. What could it possibly be doing during that 130 ms other than loading files? The approximate timing is repeatable, reliably. I know the timing is correct because it's also measuring the time it's waiting for user input when the program is running. If I use get\-internal\-run\-time instead of get\-internal\-real\-time, it omits the time it waits for user input. Why not try it yourself? Just add some timing outputs to one of your programs, such as: \(format t "\~&amp;Before define main widget: \~a\~&amp;#37;" \(get\-internal\-real\-time\)\) etc. The timing numbers it outputs when I use get\-internal\-real\-time are the number of milliseconds since the program started.
Then why does it take an additional 21 ms when I define a layout, which is after those? That implies more stuff is going on at that point. Is there any easy way to find out what stuff is happening when? Are you sure no files are being loaded?
You might be able to use statistical profilers like SBCL's sb-sprof to figure out where time is spent. Qtools and CommonQt don't load any files beyond loading the shared libraries at load-time. Qt might, but I'm pretty sure if it does any of that it only happens during the initial QApplication construction, and not during the construction of random widgets. In any case, I frankly don't understand this focus on a few milliseconds. It's a GUI app, the user will hardly notice much.
&gt; don't understand this focus on a few milliseconds It's hardly a focus. Just an interesting question, of what's happening during that time. It's enough time for millions of computer instructions to be executed.
It seems to me it should be called rash instead of lsh. Not that I'm trying to bash the name, but just that lsh can be mistaken for Ish and cause some people to forget the name and have to look it up.
also rash seems a very very nice nickname for a shell :)
https://github.com/robert-strandh/mcclim/issues would be the appropriate place to ask.
That's not exactly confined to Qt, but a general property of the CLOS implementation in SBCL (and many other implementations.) Upon first invocation of a method the compiler is invoked to optimize the dispatch, and the compiler is slow. If you use TIME you can see if anything is being compiled. commonqt performs some additional initialization for new subclasses on top of that.
 CL-USER 69 &gt; (defmacro ct2 (m) `(+ ,@(mapcar #'(lambda (ro) (count #. ro)) (symbol-value m)))) The result of evaluating this is "ct2" - the macro you just defined, not "8" (or "2"). &gt; Well I am still struggling with markdown. Prefix every line of code with four spaces -don't use tab- (in addition to any space for indenting). A new line for every line of code. 
Abstraction.
I agree. What I did struggle with -PAIP was my first Common Lisp book- was debugging the code, especially for Eliza, when I typed it in wrong. PAIP doesn't really teach how to programme in CL, how to debug effectively etc (for "good" reasons). Unfortunately I've not really found such a resource because it's not part of the standard and so is implementation specific.
CL isn't really a functional language. It's an any paradigm you want language really. If you want an (almost) functional Lisp then Clojure is it.
Sorry for the short reply I meant (ct2 *L2*) gives 8 
Aah yes, the well known country of Sweeden ;-)
They told me after 15 years of programming I could't get my P.Eng. when I applied in Alberta, requiring me to do more 'time' to get my P. Eng. so I could legally call myself an engineer.
Vladimir Sedach: &gt; *No one has yet invented a good way to write “one-liners” in Lisp. I would love to replace my Unix shell with a Lisp REPL someday.* I have, thank you very much. Hey, what's the biggest .c file here? $ txr -P '(find-max (glob "*.c") : (opip stat .size))' lib.c 
What is this black magic and where do I get my hands on it?
Faré has a neat approach: https://fare.livejournal.com/184127.html
Basically here: http://www.kylheku.com/cgit/txr/ Big alll-in-one-man-page document: https://www.nongnu.org/txr/txr-manpage.html 
This does look decently succinct. Now this with paredit support in the shell...and a swank backend to provide tab completion, docs, and other things...i could see this being more productive.
Haven't tried portacle, but usually the .desktop files are not to be run from the console. If clicking does nothing, try opening the file (it's all text), and find out the command it'd be running. 
Yeah but then I might as well setup Slime myself, which is at least something I alread know how to do :-) I've tested Portacle now on 16.04 LTS and it works fine, so the problem seems to be with 18. Ho, hum, the risks of using a beta.
- second talk, lang-os: https://github.com/7c6f434c/lang-os zero doc, zero readme…
Please report problems on GitHub in the future. This is not the right place. As for your issue, desktop files are to be used from your file manager. They are not scripts. However, the desktop file simply runs the `portacle.run` file, which is a script that can be run from the console.
What makes it similar to lisp? Supporting very basic live editing? Apparently it is written in Coffeescript
Hi Shinmera!
Send some mails to LispWorks. They administer the group, they should be able to respond the best.
I did, they said they have no archives available. That is why I was wondering if there was a public backup, or somebody could offer a mbox file with even a limited archive. I am sure it many valuable nuggets could be found there.
I think you may have too many parentheses (not (homer)) Will treat 'homer' as a function and try to call it, then use the result as an input to the function 'not'. (not homer) Looks up the value associated with the symbol 'homer', and calls the function 'not' with the value as an input. If your list S contains lambda functions, so symbol 'homer' refers to a lambda function, then in common lisp you need to use 'funcall' (not (funcall homer)) It looks like this might be some other lisp though, as it uses 'equal' rather than 'equalp'. 
Making that change still gives the same error :(
You have seven `(homer)` calls that you need to change to `homer`.
Yea I thought of doing this just now as well and can confirm that it fixed it, thank you both so much! Didn't realize the parentheses would matter so much, but I guess it makes sense as to why since the things in () for lisp usually start with an operator.
When evaluated, `FOO` is a reference to a variable, where `(FOO)` is a function call. Common Lisp has multiple namespaces, so a single symbol may mean different thing in different contexts.
as the title specifies, correctly, it's not similar to LISP. It's similar to LISP residential systems. For a modern example, see cloxp. More mentions here http://fizzygum.org/docs/fizzygum-for-lispers-and-smalltalkers/
Sounds fun we should totally look at that in a future stream. Another thing is that, although you said no static images, exploring motion vectors is something I *really* want to do http://www.klemenlozar.com/frame-blending-with-motion-vectors/ 
If you see my comment above, I was referring to the lisp image. It is not the language itself that supports live editing/function redefinition, but rather the implementation. Personally, I don't see anything besides a vague similarity between these two things. Seems more like "inspired by" rather than "like".
it's actually LISP itself that supports live editing (pretty much the whole idea is that one can make REPLs in LISP is one line) and function redefinition. The implementation of the image concept is completely independent, in fact some LISP residential systems don't use the image solution. If "inspired by" for you doesn't imply "like"-ness, then OK, for you it's "inspired by" then.
This guy has been posting this link to appropriate subreddits in order to have his project known. He never claimed that this was done in LISP, just a similarity to cloxp and LISP residential systems. Please keep an open mind, comment if you like and don't like but pleae don't troll.
Gmane is still pretty broken: [gmane](http://dir.gmane.org/gmane.lisp.lispworks.general) Still, I have found the oldest preserved article is from 2005: http://article.gmane.org/gmane.lisp.lispworks.general/4402/ The newest is from 2016: http://article.gmane.org/gmane.lisp.lispworks.general/14017/ Perhaps somebody can (gently) spider those pages and put them back in mbox format? 
I'll anwser in portuguese since this will be easier for him. Quando voce criar um programa, voce deve executar o seguinte comando (pode ser em uma funçao ou executar no REPL do proprio lisp): (sb-ext:save-lisp-and-die "nome-do-executavel" :executable t :toplevel 'main) ;; sua funcao principal. Dessa maneira ele compila o necessario do lisp para executar o programa o que acaba ficando meio grande. Existe uma maneira de importar apenas o seu programa como executavel, porem, o usuario que for utiliza-lo precisa de um core do lisp ja previamente no seu computador e eu nao lembro de cabeça como faze-lo. 
Thank you for more excellent work. Much love for Picolisp!
Another fine example.
My second live coding session with McCLIM. This time about Gadgets.
Arcadia, a Clojure for Unity, is worth investigating. 
Hi! [trivial-gamekit](https://github.com/borodust/trivial-gamekit) is designed to be trivial to use to create simple things :) Also, check out [lispgames wiki](https://github.com/lispgames/lispgames.github.io/wiki) for more or less complete information about current state of lisp gamedev. P.S.: [Lisp Game Jam 2018](https://itch.io/jam/lisp-game-jam-2018)
Clojurescript will get you up and running immediately with web layer rendering technologies. The following is a viable engine https://github.com/alexkehayias/chocolatier
I take it this won't fly on Linux?
http://xelf.me/guide.html &lt; always looked like fun to me. CLIM is also usable for game creation.
Xelf always struck me as super interesting. Kind of like a CL version of Lua's LÖVE framework.
It's a graphics environment designed to be friendly to newcomers. I think the first version was built on java, but there have been ports to python and javascript, as well as bindings for clojure.
Ah thanks
Sketch, CEPL both exist.
How is it related to Armed Bear Common Lisp?
I didn’t see any reference to ABCL
Wouldn’t it make sense to ask on that list whether someone on it kept an archive?
It isn't
[Processing](http://processing.org) is basically a simplified dialect of Java and an accompanying environment for building graphical "sketches". It's mostly popular for stuff like creative coding and digital art, but can be and has been used for simple games such as [this](https://maximilian.itch.io/swarm-saucers).
Can confirm. I couldn't get [sketch](https://github.com/vydd/sketch) running on my machine. After researching some alternatives, I stumbled upon trivial-gamekit, which just works and is super easy to use :)
Thanks, great stuff! ;)
I'm going to sound like "old man shakes fist at cloud" here, but getting started with Common Lisp just isn't that hard: 1) Install Emacs. (Learn the minimal required to use it -- you'll pick up the rest that you need as you go.) 2) Install CCL or SBCL. 3) Install Quicklisp. 4) Install Slime. 5) Start hacking. Sure, things like Portacle bundle these together, but there is real value in understanding the components of your development environment. When something goes wrong, you'll be able to fix your configuration much more quickly than if you're using a black box. 
People die everyday from terrible diseases, protests around the world claiming justice, violence subjugates the defenseless, neighbor countries on the brink of war; still, despite all the evil and sad things in the world, there is a bright flame of joy and freedom, for there is a small team that -despite all the mess- still has the will, the power to bring out a new SBCL version, at intervals so quick, you would think heaven has just been eval'd on earth. 
Am using SLIME. SLIME has a REPL. Not sure why that would be your TL;DR.
Lisp is an interactive programming language and the debugger is there to serve you whenever it is entered. If you use it for interactive programming, so fixing the errors while the error is there, then retrying the call, then you're using the debugger for exactly what it was designed for.
SLIME has support for in-file compilation with C-c C-c
Well "Slime" wasn't mentioned in his post. You can do these things directly at the REPL. Try it $ sbcl This is SBCL 1.4.1.debian... * (defun foo (n) (bar n)) ; in: DEFUN FOO ... undefined function: BAR ... FOO * (foo 5) debugger invoked on a UNDEFINED-FUNCTION ... : Type HELP for debugger help... restarts (invokable by number or by possibly-abbreviated name): 0: [CONTINUE ] Retry calling BAR. 1: [USE-VALUE ] Call specified function. 2: [RETURN-VALUE ] Return specified values. 3: [RETURN-NOTHING] Return zero values. 4: [ABORT ] Exit debugger, returning to top level. ... 0] (defun bar (n) (+ n 3)) ; No debug variables ... BAR 0] :0 8 * 
I wish you good luck with your job man, keep it up
What is SWAP1? It's not a standard Common Lisp function.
That would be the name of the function being defined. A recursive function.
let me give you an example. \(swap '\(a b c\) 1 2\) gives \(a c b\). it swaps the elements of the list you have given. i gave 1 and 2 element for swap which was b and c.
Cheers.
Thank you, knew that but some reason forgot it in the context of the debugger.
Thanks.
Geez, I did not see that. You're right!
Wish you all the best, mate ! Long live the Gang
You haven't given the requirements for this assignment. If we guess at the simplest requirements, it doesn't sound as if `swap` is applicable at all. To put `n` cars into the list of platforms, we can simply march down the list, visiting every element `el`. Whenever the `el` is an empty platform similar to `(P1 NO)`, we can flip it to `YES` using `(setf (cadr el) 'yes)` and we decrement the counter of cars `n`. If `n` hits zero, we stop. If `n` is nonzero after processing the list, it means we weren't able to park all the cars. Only some additional requirements can make it necessary to involve the `swap` function; the obvious way of putting cars into the platforms doesn't require it.
The paper version https://github.com/amirouche/neon/blob/master/doc/MOCHA2018/preview/neon-mocha-2018-preview.pdf
Wow! Great work everyone! 
Looks interesting - please let us know when it is ready to experiment with
Here is video showing what is already available https://www.youtube.com/watch?v=YMYh6f_jODg&amp;index=13&amp;list=PL_jCPpfzyfeqtG9Jm4-WkiyX3kP4GiZp5
“Heaven has just been veal’s on earth” ... love that phrase! 🙂
Lispworks and Allegro both support threads on ARM64. 
What are you looking for in terms of demo? Some AI thing or something else?
This is fascinating, thanks. I've actually become much better at getting macros right without much drama or confusion since I made this thread. It's very rewarding stuff.
I've actually moved on to Clojure. I was writing some pretty cool Common Lisp stuff at the end, but the thing about that particular Lisp is that there seems to be a lot to remember. You have to remember which functions are "non-destructive" versus "recycling," for example. Curious if there's any reason I should stick with Common Lisp instead. I enjoyed it, I just found myself needing a lot of "cheat sheets."
Thanks/sorry
Hey everyone! Thanks for all the comments and suggestions. [defunkydrummer](https://www.reddit.com/user/defunkydrummer) and others have made great suggestions. i think Practical Common Lisp is a great place to start, so I am working on it now.
Author here. No, it probably won't play well with the condition system. Somewhere out there - can't find the link now - someone has written a generators package that relies on the condition system instead of continuations. He claims that it runs faster. Maybe it works well with outside conditions too. Way down there on my list of things to do in my spare time is a lurking rewrite. It would be fun. Snakes was my first major CL project. I was trying to wrap my head around continuations. It didn't work. My head still won't quite bend that way, but the thing operates, FWIW :-) 
I cannot find the Lisp. Where is the Lisp?
For me, CL is to Clojure as C is to VB.Net. What put me right off Clojure was the god awful -I'm mean eye wateringly, punch-in-the-nads painful- stack traces Clojure dumps on you. They will quite literally contain no useful information just a load of spam about some Java library class that did something wrong. I only found out what the actual problem was because someone on /r/clojure had had a similar problem and recognised the "shape" of the stack trace. Which leads me on to the second issue. Library versioning and especially dependency versioning is terrible. It turned out "my" problem was I was using a library that *required* and *earlier* version of another library I was using. Earlier! Finally, the books. There are perhaps 2-3 really good Clojure books. Two are kind of like PCL. The third is specific to writing Web apps. But there is nothing like On Lisp or PAIP or Lisp in Small Pieces or The Art of the Metaobject Protocol or Let Over Lambda or Succesful Lisp. I really do love immutable data structures and softare transactional memory - it makes writing a lot of code so much simpler. I suppose another way of saying "CL is to Clojure as C is to VB.Net" is that "CL is computer science, Clojure is programming". That CL is standards based and it's survival doesn't depend on any one person could also be a factor. If Rich Hickey went under would Clojure survive? Personally, I think it would linger through to a slow death.
Here's a sneak peek of /r/Clojure using the [top posts](https://np.reddit.com/r/Clojure/top/?sort=top&amp;t=year) of the year! \#1: [Clojure 1.9 is now available!](http://blog.cognitect.com/blog/clojure19) | [31 comments](https://np.reddit.com/r/Clojure/comments/7ihd9t/clojure_19_is_now_available/) \#2: [How Clojure's documentation can leapfrog other languages](https://gist.github.com/oakes/8db57ac808bf6ec144d627fd83a89da3) | [50 comments](https://np.reddit.com/r/Clojure/comments/7hqlhe/how_clojures_documentation_can_leapfrog_other/) \#3: [Opening Keynote - Rich Hickey](https://www.youtube.com/watch?v=2V1FtfBDsLU) | [205 comments](https://np.reddit.com/r/Clojure/comments/75yc7c/opening_keynote_rich_hickey/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Hey, u/CommonMisspellingBot , just a quick heads-up: You’re a douchebag and a buzzkill to all. The human mind is not a computer. It ¢an R3AD thangs dat r M!SPELLED. Furthermore, predictive text and spell-check are sometimes the cause of these typos. You’re not providing a useful service. Have a nice day! The parent commenter can delete this post by leaving Reddit.
badbot I don't mind being corrected, but send me a message rather than spamming up the place.
I can't believe someone actually wrote a bot to stalk another bot. However, I doubt you were implemented in Lisp so have a bad bot for being off topic.
bad bot
Thank you, waspishly\_simple, for voting on sneakpeekbot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
What a waffly load of bollocks. Not even worth the effort to point out your argument against macros is specious@ learn once what it means, rather than having to learn every time you encounter the long hand variants.
Part of the culture of Schemers is to broadly interpret the term "Lisp." It's part of the culture of Common Lispers to wonder what is going on in the culture of Schemers. :-) I think this was a topic for one of Naggum's rants.
&gt; Part of the culture of Schemers is to broadly interpret the term "Lisp." It's part of the culture of Common Lispers to wonder what is going on in the culture of Schemers lol For me, Lisp versus Scheme is like "Engineering vs Science", and i chose to be an engineer, however I have scientists as friends and I get along pretty well with them.
Any relation to [this Lispkit](https://en.wikipedia.org/wiki/Lispkit_Lisp)?
Maybe upload to YouTube?
http://community.schemewiki.org/?scheme-faq-standards#implementations Most implementations use the name Scheme. 
or this LispKit: http://www.zogotounga.net/comp/squeak/lispkit.htm
Heya metayan, I didn’t upload it as it was basically a disaster and I was really disappointed with it. Sorry about that. I think I still have the file if need be.
How could this be used to make say iOS apps ?
Amazing that you can do that with Lisp.
That's not really a question about lisp, but programming language theory, isn't it? Anyhow, (zerop (length sequence)) works on any sequence. And don't forget to consider sequences that can be adjusted in length. How will vector-push-extend work if the empty vector is NIL?
Basically, what you are saying is that there can be no adjustable vectors (useful adjustable vectors).
Couple of two considerations to come mind immediately: 1. Having a single type requires you to decorate operations. Consider: (add-to #&lt;List size=0&gt; elt) =&gt; #&lt;List size=1&gt; (add-to #&lt;Set size=0&gt; elt) =&gt; #&lt;Set size=1&gt; (add-to #&lt;Vector size=0&gt; elt) =&gt; #&lt;Vector size=1&gt; That works nicely, but what kind of object should (add-to #&lt;Empty&gt; elt) return? Meh. So you end up with something like: (add-to-vector #&lt;Empty&gt; elt) =&gt; #&lt;Vector size=1&gt; I prefer the undecorated version. If the type matters it should be declared or enforced otherwise. 2. Your types also get more complex because all collection types end up more or less looking like: (deftype foo () `(or empty real-foo)) ...and then anywhere you have a 'foo' you have to be careful to use only operations that work both on 'real-foo' AND 'empty' on it until you've verified that you really have a 'real-foo', leading to more complex code. (Or you constrain all objects that can be empty to share the same interface, which you probably don't want, because not all operations make sense on all sets/collections.) Finally, since this is a hypothetical programming language you're speaking about, you could just as well define (equal? #&lt;Vector size=0&gt; #&lt;Set size=0&gt;) =&gt; true if you wanted. I'm not sure that's a great idea, but I suspect it is better than making all empty types actually the same. 
True, not specifically about Lisp. I first tried to post to the programming subreddit, but it was refused, saying text posts are disallowed. Only links allowed. I then looked for a type theory subreddit, but there doesn't appear to be one. Lisp was the most relevant one I could find. I'd like to draw the attention of type theorists on Reddit to my question, but I'm not sure the best way to do that here. 
Basically, what you're saying is that having to overwrite the location where the vector is stored in order to adjust it from "empty" to "non-empty" (or *vice versa*) renders that adjustable vector non-useful. 
I don't understand what you mean about the types and code being more complex if there's only one empty collection. Even if there are separate empty collections per type, real-foo still has an empty collection. What operations would work on the empty real-foo that wouldn't work on a one-for-all empty collection? It seems to me that all operations would work. E.g. if nil is the empty set, then: (car nil) is nil. (cdr nil) is nil. (assoc 'foo nil) is nil. (And should still be nil even if foo is a specialized map structure, instead of just an alist). 
Here's a concrete example. https://en.wikipedia.org/wiki/Unit_type says In Common Lisp the type named NULL is a unit type which has one value, namely the symbol NIL. This should not be confused with the NIL type, which is the bottom type. https://en.wikipedia.org/wiki/Bottom_type says In subtyping systems, the bottom type is the subtype of all types. Accordingly, if there's a single empty set (nil) common for all collection types, as I'm proposing, does this mean that the unit type would be a subtype of all collection types? And is this a standard way of handling collection types in type theory? 
**Unit type** In the area of mathematical logic and computer science known as type theory, a unit type is a type that allows only one value (and thus can hold no information). The carrier (underlying set) associated with a unit type can be any singleton set. There is an isomorphism between any two such sets, so it is customary to talk about the unit type and ignore the details of its value. One may also regard the unit type as the type of 0-tuples, i.e. *** **Bottom type** In type theory, a theory within mathematical logic, the bottom type is the type that has no values. It is also called the zero or empty type, and is sometimes denoted with falsum (⊥). A function whose return type is bottom cannot return any value. In the Curry–Howard correspondence, the bottom type corresponds to falsity. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
But I'm not proposing constraining all collections to the same API. Different types of collections must of course have different APIs. I'm only proposing that the union of all those APIs apply to the unit type and its sole value (the empty collection). 
Sure, that will work. It just has a bunch of tradeoffs that I don't like. - I don't see any real upsides from doing this -- but I do see benefits fro, an empty vector being distinct from an empty hash-table. - This required purely functional data-structures for obvious reasons. (Which is fine, but I think there are better reason to do that than this.) - Everyone implementing a new collection class needs to deal with the shared empty type. This is an collective burden I think you're underestimating. Possibly you figure out a typesystem that will ensure that all new collections/set datatypes implement their special operations also for empty... but meh. - The aforementioned need to decorate generic operations so that they can return the correct type. - I still think the typesystem will be messy for no good reason. Pervasive union types *always* come with a costs even if they're not obvious. (Performance cost if nothing else.) ...but if you're fascinated with this idea, then I suggest you go and do it. That's the best way to see the tradeoffs. 
&gt; Wouldn't you be able to cleanly get rid of nullify if empty set = empty sequence = empty string = empty list = nil = false? Then nullify would be a no-op. Yes, but I'd also be getting rid of this language being "Lisp", which would be a mortal sin, and also thereby getting rid of the important property that the language not suck. Empty sequences of all types being false means we are sliding down into PHP or Perl territory. Hey, just throw in zero for good measure (if 0 1 2) -&gt; 2, what the heck. There are implications. For instance, we cannot use a simple Boolean test to detect the absence of some string property which, if present, may be the empty string. The expression `(when context-name ...)` now has to be written `(unless (eq context-name nil) ...)` to preserve its meaning. However, what was previously written `(unless (empty context-name) ...)` can now be written more shortly as: `(when context-name ...)`. It's not a clear win. Treating empty strings as "missing" is an anti-pattern. It's an anti-pattern in a way in which empty lists being "missing" isn't. Lists are made of independent items; whereas strings are usually not just sequences or collections of independent characters. An empty string may be a valid name distinct from not having a name; it doesn't mean "absence of individual characters". An empty list is almost always indistinct from "not having items". In any such oddball situations where such a nuance is needed, you can throw in an additional representation like `T` to indicate "there is no list here at all, not even an empty one". I don't want to gain a dubious shorthand for something I consider an anti-pattern, and in the same breath, trade my ability to implicitly test for `nil` versus non-`nil` without having to compare to `nil`. 
On this topic, pure pragmatics: suppose the output is result of an operation on multiple sequences? Take the type of the left one: 1&gt; [mapcar + "abc" '(1 2 3)] "bdf" 2&gt; [mapcar + '(1 2 3) "abc"] (#\b #\d #\f) 3&gt; [mapcar + #(1 2 3) "abc"] #(#\b #\d #\f) Unless the element doesn't fit: 4&gt; [mapcar cons "abc" '(1 2 3)] ((#\a . 1) (#\b . 2) (#\c . 3)) A string can't contain conses, so fall back and output a list. 
Good points, but just one quibble: the unit type containing the empty collection is an intersection type (intersection of all the collection types), not a union type. But the union of all the collection APIs applies to it. I'm not sure if that's what you meant with your mention of costly pervasive union types. 
In that case, the empty set, map, and relation would have the same sense (absence of items) as the empty list, not the special sense of the empty string. So then, if the language happens to have native sets, maps, and relations (not just lists), then what would be the justification for arbitrarily choosing the empty list to be false, and having empty set, map, and relation be true? You can't say empty set, map, and relation (along with empty list) are all false, because then you would (as you say) lose the language's not-suck property. 
&gt; what would be the justification for arbitrarily choosing the empty list to be false, and having empty set, map, and relation be true? Well, firstly we have to back up and justify making *any* of them Boolean false at all, instead of having a dedicated false, like Scheme! Mainly, it's the pragmatics of code that rewrites code. Lists represent the program's abstract syntax tree structure. An empty vector or string is a literal atom in that syntax and not a structural plurality. We don't want a code walker to descend into a vector, looking for constituent forms to traverse. It doesn't do that because the vector fails the `consp` test (alternatively, satisfied `atom`). The whole `nil`/false/empty list design simplifies list processing code. List processing code is important for macros. List processing code deals with numerous cases (shapes of syntax, and nested syntax), which are simplified due to empty lists being Boolean false, and also by the permission to safely access an empty list's `car` and `cdr`, and positions beyond that. Other data structures don't typically deal with such cases. Strings do not nest; we don't have to walk through strings looking for different shapes. Vectors are used largely in ways whereby they provide positional access to uniformly typed items. Another effect is that if we're working with a vector, it often means we are optimizing. When we're optimizing, we are prepared to suffer some verbiage like `(empty vec)` instead of just `vec`. When we don't care about optimizing, we use lists. On the topic of Scheme, again, people developing in Scheme have to do empty testing even in list processing. That shows that doing away with the convenience is **feasible** in a Lisp-like language; it's not strictly necessary. But note that Scheme also provides a hygienic macro programming notation which avoids list processing entirely. The argument cases of a macro are matched with a kind of pattern matching, and the code template isn't a quasiquote at all: plain lexical references are used to teleport the pieces of source syntax into the target code template. A Scheme program that contains a significant quantity of macros can yet have very little list processing in it and so not be hurt all that much by the lack of convenience in list processing. The semantic model of the language is cleaner with just one object being false; in this regard we are in agreement with Scheme. We don't have an empty list that is *also* false, but that *is* the one and only false object, which is a big difference. As soon as we have additional falses, that goes away; we now have several objects that are false; false is a category with multiple instances. The uniqueness of the false object works well with lists. Non-circular lists are a linked structure which requires a terminator. It behooves us to use a unique, dedicated value for the terminator so we can just test for that special value. By golly, the Boolean domain has exactly one unique false value: that being unique, we can use it as the list terminator! It's an elegant match. Note that although Scheme doesn't make its Boolean false `#f` the empty list, **Scheme still has a unique object denoting the empty list** which serves as the terminator for every non-empty list. (Note that this is also an argument for making zero Boolean false and the list terminator. Zero is also a unique object, if integers are sanely implemented. Richard Stallman, in the 1970's, worked on a Lisp dialect in which zero played the role of `nil`.) Other kinds of objects do not naturally have this kind of unique value in their domain. There isn't a **single** empty string object which is the suffix of every string. Likewise with vectors. We could enforce that, but it would possibly cause inconveniences in the implementation of these. For instance all the string manipulation functions would have to detect that they have calculated an empty string, and substitute **the** empty string in its place before returning the result. As it stands, the way strings work is that we can can create multiple empty strings and empty vectors which are distinct. If these are to be false, oh boy, we have an unbounded number of possible false values, limited only by available memory and address space. That's a big change from "one single unique false value". Another thing: if empty string and vector are false, should this be a proper list: `(a b . "")`. If we walk this with a loop like `(while list (print (pop list)))`, it looks like a proper list! When we `pop` the two items, what is left in the `list` variable is just the string `""`. Well, that is false, and so the loop terminates. We now have complicated the notion of "proper list", since improper lists (not terminated by `nil`) quack like proper lists.
Pay seems quite low; does the job come with significant equity?
80k is really good pay in most non-US countries. In Sweden this'd be very good pay. Consider that Korea has free healthcare for example.
The job posting says Irvine, CA though
obly until the end of 2018 Work remotely but willing to travel to Seoul every two months for two weeks, or perhaps more often/a bit longer Will relocate to Seoul before the end of 2018 (we will sponsor the working visa) We will provide a relocation package
I'm kinda of fit in this position. But, i'm finishing college only next year soo... 
I assumed that it's good becaUse Korea is more of a welfare state.
Given that Javascript and run of the mill web-dev jobs pay more, the salary is preposterous if you're not already a native Korean (meaning you plan to stay/retire in Korea). I suggest the salary be increased, substantially if they want to find someone who knows what he's doing.
Too bad it's not scheme.
You might like [http://docs.racket\-lang.org/html\-parsing/index.html](http://docs.racket-lang.org/html-parsing/index.html) and [http://docs.racket\-lang.org/webscraperhelper/index.html](http://docs.racket-lang.org/webscraperhelper/index.html)
That's a pretty good salary for European standards. This translates to 67k EUR. There are not many good engineers in Germany earning above that (just to mention a country that is supposed to be doing fine).
Fucking incredible, if we're talking North. But you'd be reporting directly to Kim Jong. 
Still trying to process all that, but it already raises one question. You showed the advantage that Lisp gets by having the empty list be false, but what advantage does Scheme get by having the empty list be separate from false?
&gt; "Still Hiring for a Dream Position" &gt; 80K
&gt;That's a pretty good salary for European standards. I'm in South America, and considering the purchasing power of the EUR here vs there for basic things like food, house rental, or taxi fares, 67K EUR there would be a considerable pay cut for me, and this considering i'm underpaid here in approx. 60% (i'm already looking to move for other positions). 
&gt; *what advantage does Scheme get by having the empty list be separate from false?* Scheme avoids the situation that arises in Lisp programming when it is not clear whether some *nil* that occurs in a nested structure is supposed to be an atom (representing false, or something else like "not present" or whatever), or whether it is supposed to be an empty list. "Not clear" doesn't necessarily mean that there is an actual bug, but that it's not evident from just looking at the data: if you see a *nil* in the printed data somewhere, you may have to read the code to see whether it is traversed as a list, or treated as an atom. Chances are that your Lisp printer prints `(lambda () (foo))` as `(LAMBDA NIL (FOO))`. In Scheme, that won't happen `()` will print as `()`, because that's all it is. Thus Scheme avoids a little "optical" problem there. In Scheme we can refactor code that uses vectors to list code and vice versa, without worrying that some conditional test involving the empty case is accidentally changing polarity. 
67k EUR is nothing for a skilled software engineer that knows Lisp well and has a CS degree / 5 years experience. Even in Europe, people can go work for the companies that pay top dollar or work remote for US companies. 
It's the result of a more abstract goal, to have [disjoint types.](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-6.html#%_sec_3.2) Another instance is that unlike in Lisp, the empty list is not a symbol (of the most irritating warts of Lisp). Possibly (I wasn't there) they wanted to keep open an easier (than Lisp) path to static typing. It sort of worked, too. A subset of Scheme called PreScheme was statically typeable (full HM-style inference) and used in implementing low level code for Scheme48, 
No idea, but I invite you to blog about your experience building a Qt app :)
add-to could be polymorphic on the return type! (the vector (add-to #&lt;Empty&gt; elt))
I would expect at _least_ twice that salary, plus equity...
Update: I changed the second format-form from (class-name ....) (format t "Class-name ~a~%" ...) to (format t "Driver-name: ~a~%" (q+:drivername (db w))) That prints as expected "Driver-Name: QMYSQL". So %db seems to be bound to a QSqlDatabase .... 
You tried to get free internet points. You failed. Good job.
&gt; I don't see where you're getting the idea I don't remember my original source. "Username checks out" and all that. &gt; how can you have a numeric tower You specify that `number` behaves like a numeric tower. &gt; OOP with inheritance is not possible RnRS Scheme for much of it's life didn't even have anything resembling the lowly `defstruct`. 
I want to applaud Indeed for clearly stating the initial salary expectations. That's much better than a later surprise after you have already invested energy. Whether it is enough or not is a completely independent question. Few here have lived in Seoul. We don't know whether there is equity. If you actually want to live in Korea a paid move is very valuable. If you figure it is too low after looking into details you can always start haggling. It involves some self-selling, but then what doesn't?
I can see why you might like that, but personally I’d prefer talking in terms of an abstraction instead. Instead of trying to unify the empty collection objects of a variety of types, why not instead have an `empty` predicate that works for every type implementing your collection api? Now you still don’t have to worry about the different values used to represent an empty collection, but you haven’t lost the actual type information if you do need to go look at it later. Instead of trying to unify parts of the types themselves, unify the common parts of their APIs in an abstraction.
That's a really interesting post. I fooled around with CL for a few weeks, and I've been playing around with Clojure for the last two weeks or so. I do have this strange, lingering affection for CL that hasn't translated over to Clojure yet. There is a lot I like about Clojure in theory. It's more consistent than CL. In CL, you have some things you can apply to a collection that destroy it and make you rely on the return value only. Then there are things that let you reuse the original collection you passed in. Finally, there are things that are sort of in between- they mangle the original collection in predictable ways that you have to learn. A pure functional approach seems like it would be easier to learn. The pure functional approach also, of course, has big advantages in the concurrent environments we all use now. There are also a lot of other little things that Clojure cleans up compared to CL. Equality is more cut-and-dry, and there's no need to use "gensyms," for example That said, I think what makes me like CL more than Clojure (at this early point) is all the syntactic sugaring you have to deal with in Clojure. I get that -&gt;, -&gt;&gt;, all of the different modes of destructuring, etc. make for cleaner-looking code. I guess that's a reaction to the "write only" stereotype of CL code. It doesn't strike me as in keeping with the spirit of Lisp, though. FWIW, I really disliked the "loop" sugar in CL; I just used "do" and fought through the cryptic parts. Supposedly there were people on the CL standardization committee body who didn't like "loop" and I guess we agree. I also feel like I was able to learn a little bit of CL and dive right in and learn by doing, whereas Clojure is something where you need to read a bunch of shit and watch videos or whatever. I get so bored with that. Ultimately the reason I switched to Clojure is that I saw a guy doing Clojure in Emacs at work. It had never occurred to me that the Emacs hacking I do for fun after work could be a paid job. I was resigned to .NET drudgery, or at best C++ drudgery, being my professional life. Then I saw hope, in the form of Clojure. Now I'm wondering if there are CL jobs, too.. and CL jobs that might be open to a guy with bills and a BS from a state school.
I applied. I don't care about the salary, I just want the awesome job! I am American, but I've lived in Asia and enjoyed it.
Hi Baggars. I want to make a voxel game in lisp. What libraries do you recommend?
small pointer: check out quickproject and [this blog post](https://xach.livejournal.com/278047.html) for some insight
Have a look at Quickproject: https://www.xach.com/lisp/quickproject/
I'll add some opionated tips here. **Use SLY instead of SLIME** It is more consistent and have nice features, like access to any REPL's results by it's number. http://joaotavora.github.io/sly/#A-SLY-tour-for-SLIME-users And if you are using named-readtables, then this SLY plugin will be useful too: https://github.com/joaotavora/sly-named-readtables **Use ASDF's package inferior system** And one package per file. Here is example system definition: (defsystem app :name "app" :version "0.0.1" :class :package-inferred-system :author "Alexander Artemenko" :licence "BSD" :description "Example site." :pathname "src" :depends-on ("app/app")) After that, put your source files into the "src" subdirectory. For example, your "src/app.lisp" should start like that: (defpackage #:app/app (:nicknames #:app) (:use #:cl #:f-underscore #:anaphora) (:documentation "A web application based on Weblocks.") (:import-from #:app/utils #:setup-logging) (:export #:main)) (in-package app/app) (defun main () (setup-logging) (do-some-staff)) Pay attention, to ":use" and ":import-from" definitions. ASDF will figure out dependencies from them and you don't need to write these dependencies explicitly in your "app.asd" file. This all works if your add to your system's declaration ":class :package-inferred-system". **Use Roswell** - to setup different Lisp implementations (SBCL, CCL, etc); - to install lisp scripts from the github; - to create command-line scripts and build binaries. https://github.com/roswell/roswell **Use Qlot to not clutter your system and pin dependency versions** The most important feature is that with Qlot you can pin dependencies and commit this information into the project's reporitory as qlfile and qlfile.lock. The second important feature - Qlot allows to use dependencies not only from Quicklisp, but also from any VCS, like the Github. Here is how the qlfile might look like: ql :all :latest # mito from quicklisp 2018-04-30 is broken under the CCL: # https://github.com/fukamachi/mito/issues/30 ql mito 2018-03-28 github log4cl 40ants/log4cl github log4cl-json 40ants/log4cl-json github cl-prevalence 40ants/cl-prevalence github lack 40ants/lack :tag with-patches github defmain 40ants/defmain :tag v0.3.0 github cl-info 40ants/cl-info :tag v0.1.0 github cl-telegram-bot 40ants/cl-telegram-bot :branch clos-everywhere github cl-yandex-metrika 40ants/cl-yandex-metrika github weblocks 40ants/weblocks :tag v0.29.0 github weblocks-ui 40ants/weblocks-ui :tag v0.7.0 github weblocks-lass 40ants/weblocks-lass :tag v0.2.0 github weblocks-parenscript 40ants/weblocks-parenscript :tag v0.3.0 github weblocks-navigation-widget 40ants/weblocks-navigation-widget :tag v0.4.0 github slynk joaotavora/sly github slynk-named-readtables joaotavora/sly-named-readtables Also, Qlot will install all dependencies into the local "quicklisp" subdirectory and many projects' dependencies will not interfere with each other. https://github.com/fukamachi/qlot **Before writing your own library** Search it at http://quickdocs.org 
Looks like there are lots of styles. I would follow almost none of that advice. SLY has fewer users, so you would get more help with SLIME. I'd avoid this package inferred stuff - too much hassle for nothing. Don't pretend Common Lisp is a module language. As a beginner avoid packages. Generally all this and the rest of the advice adds much too much complexity for a beginner wanting to solve some Euler questions. 
I don't agree. Numbered results is a great help. I' use it every day, because it gives you predictable results when you try different things with data in the REPL. Maybe many modules look like "unnecessary" complexity, but if/when the projects become bigger, a single package for everything becomes a problem because there are no boundaries for code responsible for different functionality.
From tinkering to a project or library it's really just a matter of writing a small `asd` file that lets you load the system through ASDF or Quicklisp and manage dependencies that way. I typically copy-paste the same `asd` file and adapt it to the project specifics. Something like this: (asdf:defsystem project-name :author "My Name &lt;myname@mydomain.com&gt;" :maintainer "My Name &lt;myname@mydomain.com&gt;" :version "1.0.0" :description "Some short description" :serial T :components ((:file "package") (:file "other-file") (:file "documentation")) :depends-on (:whatever :dependencies :here)) Expressed in this are my own ideas for how to structure a project: a separate `package.lisp` file for the `defpackage`, and a separate `documentation.lisp` file for all the docstrings. The rest of the code goes into files as appropriate for the project.
There is no \*pointers\* in CL! :D
``` (cffi:make-pointer #x0) ```
Just open a file and start writing code without overthinking it.
&gt; Numbered results is a great help. I' use it every day, because it gives you predictable results when you try different things with data in the REPL. things I want to use I usually give names or store them somewhere... SLIME has also presentations, which keeps output and data connected. IIRC SLY dropped that feature... &gt; Maybe many modules look like "unnecessary" complexity Common Lisp packages are not really modules. Making files/packages a poor man's module defeats interactive use makes Lisp harder to use. &gt; a single package for everything becomes a problem true, but I would not use package inferred stuff, because I don't need/want a package per file. A few larger packages are usually enough, even for a large application. 
Lending a voice to /u/lispm, I too would not recommend any of that advice for a beginner. Trying to work too far around an understanding of the language and its ecosystem will only exacerbate confusion. Zach Beane's [QuickProject](https://xach.livejournal.com/278047.html) has been listed here and is a good start. I also wrote a small [post](http://notes.eatonphil.com/starting-a-minimal-common-lisp-project.html) adding my own notes to the process that a beginner may find useful while exploring.
You first start by seeing what else has already been done, so you can start from something other than zero.
Few years ago I wrote this to get my friend up to speed at CL: https://github.com/wvxvw/sudoku-solver This is, like you asked for, an example project with minimal effort put towards usual aspects of a bigger project: documentation, unit tests, system definition. Not saying it is perfect, but it's fairly small to be able to comprehend it all at once, and not contrived like many examples for the sake of example, although, it's not the best Sudoku solver :)
you're not going to get a coherent response, because the community is split between old school lispers, middle way moderates and various unix/clojure transplants who have aggressively "modern" approaches. the approaches are very different, and everyone believes theirs is the best. the old school lisper approach that in my opinion works best in common lisp environment is to just hack in repl, in cl-user package, and not really factor things out until the complexity demands it. lisp is a very interactive language, and making changes to your code early on is very cheap. don't put things in a file until you need to, but when you do don't put things in a separate package until you need to, but when you do don't split things between files, until you need to, etc. common lisp has a very ball of mud approach compared to smalltalk. for your case specifically, i would just keep the common functionality in a separate file, and load it (or hook into your common lisp's REQUIRE facility) explicitly. to be honest personally i'm not even sure i'd split project euler between separate files upfront. instead i'd just have a single euler.lisp with (in-package :cl-user) at top, where the functions closer to the top are crystalized utility functions, but closer to the bottom is almost entirely interactive work. in this case files stand for mental contexts, and need to be broken up only when the contents of the file no longer fit in your head. personally i very rarely add an asd file to personal projects. usually when i do the project is at a very high state of maturity (i do commercial lisp work and don't release projects to public, on github, etc). i think that all the bureaucratic busy work that people engage in (packages for every dozen lines of code, bunch of nested asd files in a single project, complicated hierarchies "to keep things organized") goes contrary to the spirit of lisp, obscure the shape of code, introduce unneccesary complexity, and is just a general indicator that more time is spent shuffling boxes around than solving the problem at hand.
maciej cegłowski coined a term for this genre, dabblers and blowhards, in his review of paul graham's hackers and painters. lisp, jazz and aikido are each lifetime practices, traditionally experts in the field write these kind of unifying treatises after a lifetime of study. think miyamoto musashi writing book of five rings at the age of 60. i think when thirty year olds struggle with the expression of the essence, the result comes off weak. 
My quick 0.1 cents of advice: 1. Use some IDE, quickest thing to install and use is **Portacle** which is basically SLIME+Emacs+SBCL+Paredit+Quicklisp, ready to use. 2. Don't split your work into packages at the beginning. 3. Once you get a good amount of code (say, &gt;=1000 lines), then you may want to split it onto packages. The typical way is to use one .lisp file per package, and to have a file ("package.lisp") that defines all packages (defpackage this, defpackage that...) 4. Then, write your .asd file that defines your project as a system and specifies the compilation order of your .lisp files; as well as specify the required dependencies. 5. If everything is done correctly, then you can start a new REPL and "quickload" your system with Quicklisp, and then it should compile/load without problems. (Or you can use `asdf:compile-system`). You **don't** really need roswell nor any other tool. You don't really need quicklisp either, but it's nice. 
Are you using quicklisp?
&gt; The interactive Lisp system is your main tool "Lisp is now. Talk to a REPL" --RJ 
Get on CL-LOCATIVES level 
&gt; old school lispers, middle way moderates and various unix/clojure transplants who have aggressively "modern" approaches Please, please, create a "slot" for people with modern approaches (i.e. using latest portability libs, Quicklisp, ASDF3), but that want nothing to do with Clojurisms, "CL for the 21th century" stuff, etc. Many of us can be`push`'d into that list instead. 
Yes. I'm referring to Roswell and Qlot. It's good they exist, but I don't agree on pointing a beginner to them, when they're not necessary. 
&gt; I want to applaud Indeed for clearly stating the initial salary expectations. That's much better than a later surprise after you have already invested energy. This is true. Kudos to /u/crowfeather for the sincerity. Also, I think it would be awesome to live in South Korea, to be honest. But i do have a concern over the salary. I already sort-of-have a "Lisp job", but your "Lisp job" looks much more exciting! 
But how do you suggest to replace their functionality (familiar to many developers coming to CL from other languages) with pure ASDF?
&gt; But how do you suggest to replace **their** functionality (familiar to many developers coming to CL from other languages) with pure ASDF? At line 0, character 35: `their`: Perhaps we're discussing about different things? The OP only wants to create a project. For that, the bare minimum is ASDF; over that, Quicklisp adds a convenience for auto-loading libs. But other than that, he/she doesn't really need Roswell nor Qlot, if he/she is just starting in CL and just wants to define a project. 
You right. Maintainability is nothing. Just dump your code in a few lisp files and let "yourself from the future" to figure out how do they should be used :)))
Seconded. You usually don't need to futz around with complex asdf setups for your work in progress, because most stuff in Lisp is order independent in the sense that most of the time, you can recompile the file you're working on—just a keystroke within the edit buffer—without recompiling the whole project. Changed function/method definitions, changed classes, all picked up dynamically by everything else in your running image. (Notable exceptions are macros (use sparingly) and constants (don't use)). 
I appreciate your response but I also want to advocate for the the poster you are replying to. Although I described myself as a CL "beginner", I tried to mention Java, Scheme, and Smalltalk to hint that I do have a fair amount of programming experience, closing in on 2 decades, so I am not really a "beginner" in the sense of struggling to get to grips with CL, more a beginner in terms of amount of time spent with the language. What I was trying to find out were the recommended community best practices once you want to move beyond noodling around in your repo. It's hard to share that code with anyone, and even with small files I am guessing that as I build up enough of a base of utilities I'll need to add some organization. Euler questions are small and simple but I am approaching them the way I do a sports scrimmage. Yeah it doesn't actually mean anything, but you are still playing "the same game". When I wanted to get up to speed on Smalltalk I did Euler problems as well, and by doing so I figured out Categories, extension methods, Monticello (their native DVCS), etc, etc. Yeah it was just Euler problems, but I was essentially training myself to develop code the way the community develops and the skills I learned helped me out on other, much larger, projects I did later on. Same with Java. Even my crappy little 100 line experiments are still packaged and unit tested, etc, etc, because that is how I develop on much larger projects, and practicing those skills is a good thing. I guess the feeling I am having right now is that my current development style is akin to, in Smalltalk, writing all of my code in workspaces and when that fails cramming my classes in one category and my methods into one class. It won't scale, and it's not how things are done in the real world of CL (I am guessing?). I would like to start getting that muscle memory down now, and the Euler problems are just scaffolding on which to do so. I hope that helps frame my question better, and thank you for your reply and perspective as well.
Developing software professionally already 17 years. Of cause I don't have idea. 
look, i didn't go into your thread to rug on your approach, even though i disagree with it, you could extend the same courtesy to me. i also don't think that snark is a form of debate either. BUT i do say, that you don't have any idea what you're talking about, because your argument is an attempt at a strawman, that betrays your lack of understanding: i at no point suggested "dumping your code" as you so eloquently put it. i'm saying that the complexity of the code organization must be driven by the needs of the code, and not the other way around. you're arguing that maintability can be somehow imbued onto code through magic rituals, and i insist that you can't have maintability without understanding, and you can't _shortcut_ understanding either, which is what bureaucratic busy work attempts to do. the only way to go about it is to strive to maitain a correspondce between the code organization and it's nature at all times, so that when "yourself from the future" picks up the code again, he can restore the context in the brain with the least amount of friction. upfront beaurocratic structure creates that kind of friction, while also creating the illusion that there's an organization, that's not actually there. lisp provides you with a lot of exploratory tooling that lessens the kind of friction that i'm talking about. the bureaucratic busy work is uneccesary, a transplant from the environments where the exploratory tooling is missing.
Does it make sense to set up the machinery of building a house when all you have is a bit of sand? Can you train architecture and building with it? You might want to study some applications and see how people have organized them. I would look at a tool in its context. Many of these tools have way to many features and in a typical program you need only a few percent of them. Learn to navigate around in Lisp, instead of trying to organize things for static tools or to prepare for situations you will never be in. Common Lisp does not force a class-based organization and it is fully okay to put twenty classes into a file. When I started to learn Lisp I used a listener and an editor window. Before Lisp I learned heavy module based languages like UCSD Pascal and Modula 2 - I used Modula 2 quite a bit. That's where the name of the language already forces me to think about modules and whole systems of modules. Lisp allows you to think different. For example you can think of the problem as a linguistic problem: what is the right language to solve the original problem? Then you build that language and apply it - you won't think in terms of modules/exports/imports/contracts/initializations. Another way is to think in terms of 'machines and machineries', for example you might learn about programming with 'streams' (not the I/O streams, see the chapter in SICP or SERIES in Common Lisp) and you might set up a machinery for stream-based computing - by applying this and other machines one might solve the domain problems. Another problem might need a lot of structured textual input data. Then I would think about what would be a convenient notation and how to transform it into my Lisp data. That's when you start to think about programming with a flexible and programmable programming language. Why would you learn Lisp, when you force yourself to stay in the same old programming habits. Otherwise you could have stayed with Java and enjoy the enormous eco-system and the wonderfully complex tooling.
Does it make sense to set up the machinery of building a house when all you have is a bit of sand? Can you train architecture and building with it? You might want to study some applications and see how people have organized them. I would look at a tool in its context. Many of these tools have way to many features and in a typical program you need only a few percent of them. Learn to navigate around in Lisp, instead of trying to organize things for static tools or to prepare for situations you will never be in. Common Lisp does not force a class-based organization and it is fully okay to put twenty classes into a file. When I started to learn Lisp I used a listener and an editor window. Before Lisp I learned heavy module based languages like UCSD Pascal and Modula 2 - I used Modula 2 quite a bit. That's where the name of the language already forces me to think about modules and whole systems of modules. Lisp allows you to think different. For example you can think of the problem as a linguistic problem: what is the right language to solve the original problem? Then you build that language and apply it - you won't think in terms of modules/exports/imports/contracts/initializations. Another way is to think in terms of 'machines and machineries', for example you might learn about programming with 'streams' (not the I/O streams, see the chapter in SICP or SERIES in Common Lisp) and you might set up a machinery for stream-based computing - by applying this and other machines one might solve the domain problems. Another problem might need a lot of structured textual input data. Then I would think about what would be a convenient notation and how to transform it into my Lisp data. That's when you start to think about programming with a flexible and programmable programming language. Why would you learn Lisp, when you force yourself to stay in the same old programming habits. Otherwise you could have stayed with Java and enjoy the enormous eco-system and the wonderfully complex tooling.
Very well said.
\&gt; without overthinking it. I'm still working on that part.
If you want pointers, you might want to look into C. 😎
Indeed it is. [Here](http://i0.kym-cdn.com/photos/images/newsfeed/001/363/122/464.jpg) is the original.
Thank you, this is very thoughtful. It mkes a lot of sense, and it clarifies a lot of things I have been seeing in different projects.
Thank you again for insightful comment.
My apology to /u/xach, it was not my intention in any way to lessen Quicklisp, on the contrary. I just found that post on UnixHumour. I thought some people, appreciating the "Unix Haters handbook", would find that funny, as I did, as it seems originated from a teenager-mindset, toying with Unix and Lisp at the same time. 
Unfortunately the late Dan Weinreb's blog is gone, but Feedly preserved this snapshot: &gt; Rebuttal to Stallman’s Story About The Formation of Symbolics and LMI &gt; 28 Dan Weinreb's blog / by Dan Weinreb / 1,537 days ago &gt; Richard Stallman has been telling a story about the origins of the Lisp machine companies, and the effects on the M.I.T. Artificial Intelligence Lab, for many years. He has published it in a book, and in a widely-referenced paper, which you can find at http://www.gnu.org/gnu/rms-lisp.html. &gt; His account is highly biased, and in many places just plain wrong. Here’s my own perspective on what really happened. &gt; Richard Greenblatt’s proposal for a Lisp machine company had two premises. First, there should be no outside investment. This would have been totally unrealistic: a company manufacturing computer hardware needs capital. Second, Greenblatt himself would be the CEO. The other members of the Lisp machine project were extremely dubious of Greenblatt’s ability to run a company. So Greenblatt and the others went their separate ways and set up two companies. &gt; Stallman’s characterization of this as “backstabbing”, and that Symbolics decided not “not have scruples”, is pure hogwash. There was no backstabbing whatsoever. Symbolics was extremely scrupulous. Stallman’s characterization of Symbolics as “looking for ways to destroy” LMI is pure fantasy. &gt; Stallman claims that Symbolics “hired away all the hackers” and that “the AI lab was now helpless” and “nobody had envisioned that the AI lab’s hacker group would be wiped out, but it was” and that Symbolics “wiped out MIT”. First of all, had there been only one Lisp machine company as Stallman would have preferred, exactly the same people would have left the AI lab. Secondly, Symbolics only hired four full-time and one part-time person from the AI lab (see below). &gt; Stallman goes on to say: “So Symbolics came up with a plan. They said to the lab, ‘We will continue making our changes to the system available for you to use, but you can’t put it into the MIT Lisp machine system. Instead, we’ll give you access to Symbolics’ Lisp machine system, and you can run it, but that’s all you can do.’” In other words, software that was developed at Symbolics was not given away for free to LMI. Is that so surprising? Anyway, that wasn’t Symbolics’s “plan”; it was part of the MIT licensing agreement, the very same one that LMI signed. LMI’s changes were all proprietary to LMI, too. &gt; Next, he says: “After a while, I came to the conclusion that it would be best if I didn’t even look at their code. When they made a beta announcement that gave the release notes, I would see what the features were and then implement them. By the time they had a real release, I did too.” First of all, he really was looking at the Symbolics code; we caught him doing it several times. But secondly, even if he hadn’t, it’s a whole lot easier to copy what someone else has already designed than to design it yourself. What he copied were incremental improvements: a new editor command here, a new Lisp utility there. This was a very small fraction of the software development being done at Symbolics. &gt; His characterization of this as “punishing” Symbolics is silly. What he did never made any difference to Symbolics. In real life, Symbolics was rarely competing with LMI for sales. LMI’s existence had very little to do with Symbolics’s bottom line. &gt; And while I’m setting the record straight, the original (TECO-based) Emacs was created and designed by Guy L. Steele Jr. and David Moon. After they had it working, and it had become established as the standard text editor at the AI lab, Stallman took over its maintenance. &gt; Here is the list of Symbolics founders. Note that Bruce Edwards and I had worked at the MIT AI Lab previously, but had already left to go to other jobs before Symbolics started. Henry Baker was not one of the “hackers” of which Stallman speaks. Robert Adams (original CEO, California) Russell Noftsker (CEO thereafter) Minoru Tonai (CFO, California) John Kulp (from MIT Plasma Physics Lab) Tom Knight (from MIT AI Lab) Jack Holloway (from MIT AI Lab) David Moon (half-time as MIT AI Lab) Dan Weinreb (from Lawrence Livermore Labs) Howard Cannon (from MIT AI Lab) Mike McMahon (from MIT AI Lab) Jim Kulp (from IIASA, Vienna) Bruce Edwards (from IIASA, Vienna) Bernie Greenberg (from Honeywell CISL) Clark Baker (from MIT LCS) Chris Terman (from MIT LCS) John Blankenbaker (hardware engineer, California) Bob Williams (hardware engineer, California) Bob South (hardware engineer, California) Henry Baker (from MIT) Dave Dyer (from USC ISI) http://danweinreb.org/blog/rebuttal-to-stallmans-story-about-the-formation-of-symbolics-and-lmi 
hmmmm. where did I see this blog before ?
Thank you for reminding me. That is a very important page. It is human tendency to rewrite history, and personally I feel that is fine as one's personal relief of some sort, as long as other more sober, straight versions are also found. Thanks.
If It Works, It’s Not AI: A Commercial Look at Artificial Intelligence Startups by Eve M. Phillips https://www.ifis.uni-luebeck.de/~moeller/symbolics-info/ai-business.pdf Symbolics, Inc.: A failure of heterogeneous engineering Alvin Graylin, Kari Anne Hoier, Kjolaas Jonathan Loflin, Jimmie D. Walker III https://www.ifis.uni-luebeck.de/~moeller/symbolics-info/Symbolics.pdf 
eh, Dan here seems to someone who implicitly accepts that private companies and intellectual monopolies are fundamentally a-okay by the sounds of it. Stallman's issues are probably pretty much off the philosophical radar entirely of someone like that, someone who believes copyrights and private companies holding copyrights are normal, fine, acceptable things, [when really they are not](https://en.wikipedia.org/wiki/Pirate_Party_\(Sweden\)). I just don't think Dan even understands why RMS viewed such things as backstabbing. 
You associate words like 'believe' and 'does not understand' with Dan, while you see Stallman as a philosopher who sees how things as they 'really are'. I don't think there is any reason for that.
I linked to the pirate party as shorthand - hardly going to make the entire case against scummy evil intellectual monopolists in a reddit comment. 
'Stallman is usually right' - that's why it is important to read the rebuttal by Dan - he might help you to understand that there is usually more than one side to a story.
I already read the post in its entirety (and it's largely about reasons why symbolics failed that are distinct from Stallman's issues). Empirically Stallman is right depressingly often when he predicts bad things. /r/stallmanwasright One must beware the fallacy of the middle ground. In a debate, one side can be right and the other completely wrong, the truth isn't always in the middle, and that's always a very dangerous thing to assume. Right now the overton window on intellectual monopoly is shifted significantly by entirely conscious and internationally coordinated propaganda efforts of the intellectual monopolists. Even pirate parties are arguing for "reform" of copyright or patent instead of the right thing, abolition. 
&gt; One must beware the fallacy of the middle ground. In a debate, one side can be right and the other completely wrong, the truth isn't always in the middle ... That there is a 'fallacy' does not mean that it is applicable. Sorry, I'm not interested to be dragged into a Stallman-is-right worship.
I'll try to be around for questions, but should just work (I've used it for the last jam game with no probs)
"Adrienne" sounds like RMS ;-)
As a user of SLY I would like to respond to &gt; SLY has fewer users, so you would get more help with SLIME. I would agree for an abstract 'X' has fewer users, so 'Y' has better support . But in practice Joao, SLY's maintainer, is super helpful and goes out of the way to triage issues and implement feature requests. Maybe it is because they have less users to tend to? 
you have more patience than I thought, herr lispm...
Nope, we can't stop you. Also see https://github.com/brown/swank-crew for a LPARALLEL-less solution based on SWANK.
Yes.
https://www.reddit.com/r/HomeworkHelp/
ace, thanks. Yeah I doubt the library will be the source of any problems :\)
Thanks!
Voxels can be handled a bunch of different ways. What did you have in mind? CEPL sits in roughly the place GLES would, in that it wraps GL but also provides of functions for creating a window, context etc so whilst it could be useful for a game, it would only make up a very small part of it.
No. Do your own homework.
Check out clojure's pallet for inspiration too -- I never got to use that in anger and it's now sadly dead, but it looked like exactly what I was after when I was stuck with chef.
I'd suggest: "Church's Lambda Calculus" and "Church Functional Programming" as initial searches to get you started.
You're asking for programming language semantics. You really should be asking this in /r/racket.
Also find a pretext to use your Weblocks :)
Rent in Irvine, CA is 2000 USD a month for a 2 bedroom condo.
See Touretzky's book on Lisp - https://www.cs.cmu.edu/~dst/LispBook/ It describes Common Lisp from the initial perspective of a non-programmer. It could be helpful for you.
"Anatomy of Lisp" by John R. Allen is a book that I personally enjoyed a great deal. It goes into quite a bit of architectural/implementation detail, but I think it should appeal to someone with a background in mathematics. Of course since it's from 1978 it misses lots of things that were added to Lisp \(and its implementations\) since then, but that may not be too important for your quest at this stage... have fun!
I use it for three projects already. One is public, second personal and third is available only on my company's intranet.
Yes, that makes sense. This is my first time playing with a threaded application, reading around I'm realising that special variables and their interactions with threads are more subtle than I thought... Thanks for the advice... I'll give it a try it when I get home tonight
McCarthy was not really coming at Lisp from a purely mathematical direction. Of course, his Ph.D. was in mathematics, and he had read enough to have "lambda" in mind as the marker for an anonymous function, but he had not followed that but his actual implementation was pragmatically pursuing symbolic and list programming (which was very abstract for the time, but so was FORTRAN.) http://jmc.stanford.edu/articles/lisp/lisp.pdf That he was using symbolic manipulation to do things like differentiation is not really mathematical in the sense I think you mean. Even McCarthy's paper "A Basis for a Mathematical Theory of Computation" http://www-formal.stanford.edu/jmc/basis1.ps is from 1961 and mentions ALGOL and other alternatives as well as Lisp and is somewhat removed from Lisp. I suspect you will be more interested in the mathematical formulation of programming language semantics. https://en.wikipedia.org/wiki/Semantics_(computer_science) That took more than a decade to arise from these thoughts.
**Semantics (computer science)** In programming language theory, semantics is the field concerned with the rigorous mathematical study of the meaning of programming languages. It does so by evaluating the meaning of syntactically legal strings defined by a specific programming language, showing the computation involved. In such a case that the evaluation would be of syntactically illegal strings, the result would be non-computation. Semantics describes the processes a computer follows when executing a program in that specific language. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Thank you for the reply. Just before I go to the Racket sub: Why would you say that's more useful for semantics-related discussions?
Thanks, I'll check it out! It's totally fine to be an old book, as I'm trying to learn the basics. I always like to study historically, to see how ideas flowed naturally in developing a concept.
I'm totally not against coding. I just wanted to say it's not my priority, so I'm more of a computer scientist wannabe than a software engineer. :) SICP it's a great reference, I dream of learning and understanding it some day. Moreover, as an Emacs user and lover, I'll definitely have to learn some (E)Lisp coding as well, so I hope they'll go hand in hand. But my priority is the mathematical (algebraic, logical) foundations.
Thank you. Lambda calculus comes up basically at every search, so I will get my hands on that asap. I will definitely look through Okasaki's book as well, to get an idea.
Thanks, a very good reference!
Thank you for the details! I know that McCarthy was a very good logician and I assumed he used algebraic logic as the mathematical foundation for Lisp. "Symbolic programming" comes up quite often and I have seen it connected with declarative and functional languages such as Prolog (which is also currently in my focus). That being said, as you're not the first to suggest semantics of programming languages, given my background and the present discussion, would (any of) you have any particular reference in mind?
Checking Racket sub or anything Racket related is useful because that's probably the easiest way to come in contact with a large group of world class semantics and PLT people e.g. Matthias Felleisen who's behind the reduction semantics approach. Also, learning Racket and an interest in semantics would expose you to "PLT Redex" which to [operational] semantics is what Mathematica is to mathematics. Also, save yourself time and learn lambda calculus from the yellow bible i.e. Barendregt's "The Lambda Calculus, Its Syntax and Semantics".
Thank you so much for the details! I had a look once at Racket and it seemed extremely interesting and flexible so it makes sense to think that there are many experts involved in its development. I will definitely check out their sub and more information! As for Barendregt's yellow bible (which I have and have put on the waiting list for some time), I found it extremely dry, even for an algebraist. But yes, I know it's *the* reference, so I'll swallow it somehow. :)
Semantic of Programming Languages is way out of my comfort zone. I encountered it while reading https://en.wikipedia.org/wiki/Lisp_in_Small_Pieces https://pages.lip6.fr/Christian.Queinnec/WWW/LiSP.html which is Lisp-oriented, and basically defines various dialects of Lisp more-or-less formally.
Thanks, I'll do more reading in the semantics direction, as /u/atonal174 suggests as well.
Also see Erlangen for CCL: http://mr.gy/blog/erlangen-intro.html https://github.com/eugeneia/erlangen
Thanks. What I’m getting from all of your replies is to focus on semantics. I’ll try to do just that as much as I can.
Thanks for all the effort you put into this project. Looking forward to trying out Sly later.
You're doing God's work, Shinmera &amp; the Shirakumo team.
Oh killer -- great job. This fixed the not opening issue I've been seeing on Ubuntu 18 as well.
I would never want interfere with this! A language on top of CL that covers the feature set of [HCL](https://www.terraform.io/docs/configuration/syntax.html) and ansible is something I have been daydreaming about myself. It might be quite nice if it were ASDF-aware to make provisioning your infrastructure with lisp systems especially fluid.
Ok, careful not be trapped inside elisp. Shit's like web development, seems great because of the quick satisfaction of proping something up but in the long run it might preclude you from developing other skills. Cheers!
Please explain what do you mean, talking about ASDF awareness? How do you imagine this should work?
Alonzo Church's Lambda Calculus. (see also: Combinatory Logic -- Haskell and Curry).
`- asdf: source=quicklisp pkg=alexandria state=present` (I'm guessing)
It is better to deliver a self containing artifacts during deployment. 
Awesome that you’re supporting `sly` now!
Ok, assume immutable objects, and the language has only one false value. Consider two questions: * A. Is the empty list identical to false? * B. Are all empty collections (e.g. list, set, string, map, relation) identical? (The alternative is that each collection type has its own unique empty value.) And four combinations of answers: * 1. yes, yes. (This is what I was originally advocating.) * 2. yes, no. (This is Common Lisp.) * 3. no, yes. * 4. no, no. (This is Scheme.) Assume also that one of the Scheme advantages you listed (refactorability) is a requirement. That rules out #2. And #3 seems worthless, since if there's a universal empty collection, it might as well also serve as the false value. Then add one more requirement: a type system like in Typed Racket. Does this rule out #1 (or make it overly complex), leaving #4 as the only option? TXR's nullify seems like Clojure's seq. But the implicit nullification for list functions seems problematic: 27&gt; (equal () (cdr ())) t 28&gt; (equal "" (cdr "")) nil The manual also makes nullify look unclear. It says: * The nullify method should return nil if the object is considered to denote an empty sequence. Otherwise it should either return that object itself, or else return the sequence which that object represents. How do you know what it's going to return (sequence, or original object)? 
Before you can study Lisp code under semantics, it has to be macroexpanded, which means we have to *execute* the semantics of the macros first. Only then do we have the expanded code that is then susceptible to study using semantics. Or else we need an augmented semantics which directly models all the macros that are being used. But that's a static view which doesn't handle a program-with-macro-definitions as a primary input. 
&gt; homoiconicity - where the language itself is written as a data structure that you can represent in that language. I still don't see how this is special to lisp. Lisp programs are strings, and so are Java programs, but no one says that Java is homoiconic even though Java has Strings. What test can be run which Lisp passes and Java fails which betrays Lisp's homoiconicity? Or is homoiconicity not well-defined?